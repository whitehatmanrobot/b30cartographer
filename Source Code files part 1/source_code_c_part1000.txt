****************************************

CSafeArray::CSafeArray(
    IN SAFEARRAY *pSrcCopy,
    IN int nType,
    IN int nFlags,
    IN int nGrowBy
    )
{
    m_nStatus = no_error;

    CheckType(nType);

    // Verify that this is only a 1-dimensional array.
    // ===============================================

    if (1 != COleAuto::_SafeArrayGetDim(pSrcCopy))
        m_nStatus = failed;

    // Now copy the source or 'bind' the incoming array.
    // ====================================================

    if (nFlags & bind)
        m_pArray = pSrcCopy;
    else if (COleAuto::_SafeArrayCopy(pSrcCopy, &m_pArray) != S_OK)
        m_nStatus = failed;

    // Get bound information.
    // ======================

    LONG uBound = 0;
    if (S_OK != COleAuto::_SafeArrayGetUBound(m_pArray, 1, &uBound))
        m_nStatus = failed;

    // Correct the Upper Bound into a size.
    // ====================================

    m_bound.cElements = uBound + 1;
    m_bound.lLbound = 0;
    m_nMaxElementUsed = uBound;
    m_nVarType = nType;
    m_nGrowBy = nGrowBy;
    m_nFlags = nFlags & 3;  // Mask out the acquire & copy bits.

	m_nElementSize = SafeArrayGetElemsize( m_pArray );

}


//***************************************************************************
//
//  CSafeArray::GetScalarAt
//
//  For class internal use.  This function returns the element at
//  the specified index.
//  
//  PARAMETERS:
//  nIndex
//      The index at which to retrieve the scalar.
//
//  RETURN VALUE:
//  The scalar at the specified the location.
//
//***************************************************************************
SA_ArrayScalar CSafeArray::GetScalarAt(IN int nIndex)
{
    SA_ArrayScalar retval = {0};

    // Check for out-of-range condition.
    // =================================

    if (nIndex > m_nMaxElementUsed + 1)
        return retval;

    COleAuto::_SafeArrayGetElement(m_pArray, (long *) &nIndex, &retval);
    return retval;
}


//***************************************************************************
//
//  CSafeArray assignment operator.
//
//***************************************************************************

CSafeArray& CSafeArray::operator =(IN CSafeArray &Src)
{
    Empty();

    m_nMaxElementUsed = Src.m_nMaxElementUsed;
    m_nFlags = Src.m_nFlags;
    m_nGrowBy = Src.m_nGrowBy;
    m_nStatus = Src.m_nStatus;
    m_nVarType = Src.m_nVarType;
    m_bound = Src.m_bound;
	m_nElementSize = Src.m_nElementSize;

    if (COleAuto::_SafeArrayCopy(Src.m_pArray, &m_pArray) != S_OK)
        m_nStatus = failed;

    return *this;
}

//***************************************************************************
//
//  Copy constructor.
//
//  This is implemented primarily via the assignment operator.
//
//***************************************************************************

CSafeArray::CSafeArray(CSafeArray &Src)
{
    m_nMaxElementUsed = 0;
    m_nFlags = 0;
    m_nGrowBy = 0;
    m_nStatus = no_error;
    m_nVarType = VT_NULL;
    m_pArray = 0;
    m_bound.cElements = 0;
    m_bound.lLbound = 0;

    *this = Src;
}


//***************************************************************************
//
//  CSafeArray::Add
//
//  Adds the BSTR to the array, growing the array if required.
//
//  PARAMETERS:
//  Src
//      The source BSTR to add to the array.  If NULL, then a
//      blank string is added by the underlying SAFEARRAY implementation.
//      (there is no way to prevent this).  This can point to 
//      an LPWSTR as well.
//
//  RETURN VALUE:
//  <no_error> or <failed>.
//
//***************************************************************************

int CSafeArray::AddBSTR(IN BSTR Src)
{
    // If there is no more room in the array, then expand it.
    // ======================================================

    if (m_nMaxElementUsed == (int) m_bound.cElements - 1) {

        if (m_nGrowBy == 0)
            return range_error;

        m_bound.cElements += m_nGrowBy;

        if (S_OK != COleAuto::_SafeArrayRedim(m_pArray, &m_bound))
            m_nStatus = failed;
    }

    m_nMaxElementUsed++;

    BSTR Copy = COleAuto::_SysAllocString(Src);
    CSysFreeMe auto1(Copy);

    if (COleAuto::_SafeArrayPutElement(m_pArray, (long *) &m_nMaxElementUsed, Copy) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CSafeArray::AddVariant
//
//  Adds the specified VARIANT to the array.
//
//  PARAMETERS:
//  pSrc
//      A pointer to the source VARIANT, which is copied.
//
//  RETURN VALUE:
//  range_error, failed, no_error
//
//***************************************************************************

int CSafeArray::AddVariant(IN VARIANT *pSrc)
{
    // If there is no more room in the array, then expand it.
    // ======================================================

    if (m_nMaxElementUsed == (int) m_bound.cElements - 1) {

        if (m_nGrowBy == 0)
            return range_error;
            
        m_bound.cElements += m_nGrowBy;

        if (S_OK != COleAuto::_SafeArrayRedim(m_pArray, &m_bound))
            m_nStatus = failed;
    }

    m_nMaxElementUsed++;

    if (COleAuto::_SafeArrayPutElement(m_pArray, (long *) &m_nMaxElementUsed, pSrc) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CSafeArray::AddDispatch
//
//  Adds the specified IDispatch* to the array.
//
//  PARAMETERS:
//  pSrc
//      A pointer to the source IDispatch*, which is AddRefed.
//
//  RETURN VALUE:
//  range_error, failed, no_error
//
//***************************************************************************

int CSafeArray::AddDispatch(IN IDispatch *pDisp)
{
    // If there is no more room in the array, then expand it.
    // ======================================================

    if (m_nMaxElementUsed == (int) m_bound.cElements - 1) {

        if (m_nGrowBy == 0)
            return range_error;
            
        m_bound.cElements += m_nGrowBy;

        if (S_OK != COleAuto::_SafeArrayRedim(m_pArray, &m_bound))
            m_nStatus = failed;
    }

    m_nMaxElementUsed++;

    if (COleAuto::_SafeArrayPutElement(m_pArray, (long *) &m_nMaxElementUsed, pDisp) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CSafeArray::AddUnknown
//
//  Adds the specified IUnknown* to the array.
//
//  PARAMETERS:
//  pSrc
//      A pointer to the source IUnknown*, which is AddRefed.
//
//  RETURN VALUE:
//  range_error, failed, no_error
//
//***************************************************************************

int CSafeArray::AddUnknown(IN IUnknown *pUnk)
{
    // If there is no more room in the array, then expand it.
    // ======================================================

    if (m_nMaxElementUsed == (int) m_bound.cElements - 1) {

        if (m_nGrowBy == 0)
            return range_error;
            
        m_bound.cElements += m_nGrowBy;

        if (S_OK != COleAuto::_SafeArrayRedim(m_pArray, &m_bound))
            m_nStatus = failed;
    }

    m_nMaxElementUsed++;

    if (COleAuto::_SafeArrayPutElement(m_pArray, (long *) &m_nMaxElementUsed, pUnk) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}



//***************************************************************************
//
//  CSafeArray::GetBSTRAt
//
//  If the array type is VT_BSTR, this returns the string at the specified
//  index.
//
//  PARAMETERS:
//  nIndex
//      The array index for which the string is requried.
//
//  RETURN VALUE:
//  A dynamically allocated BSTR which must be freed with SysFreeString.
//  NULL is returned on error. If NULL was originally added at this
//  location, a string with zero length will be returned, which still
//  must be freed with SysFreeString.
//
//***************************************************************************

BSTR CSafeArray::GetBSTRAt(int nIndex)
{
    BSTR StrPtr = 0;

    if (nIndex >= (int) m_bound.cElements)
        return NULL;

    if (S_OK != COleAuto::_SafeArrayGetElement(m_pArray, (long *) &nIndex, &StrPtr))
        return NULL;

    return StrPtr;
}

BSTR CSafeArray::GetBSTRAtThrow(int nIndex)
{
    BSTR StrPtr = 0;

    if (nIndex >= (int) m_bound.cElements)
        throw CX_MemoryException();

    if (S_OK != COleAuto::_SafeArrayGetElement(m_pArray, (long *) &nIndex, &StrPtr))
        throw CX_MemoryException();

    return StrPtr;
}


//***************************************************************************
//
//  CSafeArray::GetVariantAt
//
//  PARAMETERS:
//  nIndex
//      The array index from which to retrieve the VARIANT.
//  
//  RETURN VALUE:
//  Returns a new VARIANT at the specified location.  The receiver must
//  call VariantClear() on this VARIANT when it is no longer used.
//
//***************************************************************************

VARIANT CSafeArray::GetVariantAt(int nIndex)
{
    VARIANT Var;
    COleAuto::_VariantInit(&Var);

    if (nIndex >= (int) m_bound.cElements)
        return Var;

    if (S_OK != COleAuto::_SafeArrayGetElement(m_pArray, (long *) &nIndex, &Var))
        return Var;

    return Var;
}

//***************************************************************************
//
//  CSafeArray::GetDispatchAt
//
//  PARAMETERS:
//  nIndex
//      The array index from which to retrieve the IDispatch*.
//  
//  RETURN VALUE:
//  Returns the IDispatch* at the specified location.  The receiver must
//  call Release on this pointer (if not NULL) when it is no longer used.
//
//***************************************************************************

IDispatch* CSafeArray::GetDispatchAt(int nIndex)
{
    IDispatch* pDisp;
    if (nIndex >= (int) m_bound.cElements)
        return NULL;

    if (S_OK != COleAuto::_SafeArrayGetElement(m_pArray, (long *) &nIndex, &pDisp))
        return NULL;

    return pDisp;
}

//***************************************************************************
//
//  CSafeArray::GetUnknownAt
//
//  PARAMETERS:
//  nIndex
//      The array index from which to retrieve the IUnknown*.
//  
//  RETURN VALUE:
//  Returns the IUnknown* at the specified location.  The receiver must
//  call Release on this pointer (if not NULL) when it is no longer used.
//
//***************************************************************************

IUnknown* CSafeArray::GetUnknownAt(int nIndex)
{
    IUnknown* pUnk;
    if (nIndex >= (int) m_bound.cElements)
        return NULL;

    if (S_OK != COleAuto::_SafeArrayGetElement(m_pArray, (long *) &nIndex, &pUnk))
        return NULL;

    return pUnk;
}

//***************************************************************************
//
//  CSafeArray::SetAt
//
//  Replaces the BSTR value at the specified array index.   The original
//  BSTR value is automatically deallocated and replaced by the new value.
//  You can only call this to replace an existing element or to add a
//  new element to the end (one position past the last element).  If the
//  array size is 10, you can call this with 0..10, but not 11 or higher.
//
//  PARAMETERS:
//  nIndex
//      The position at which to replace the element.
//  Str
//      The new string.
//  nFlags
//      If <acquire> this function acquires ownership of the string and
//      can delete it.  Otherwise, the caller retains ownership of the
//      string.
//
//  RETURN VALUE:
//  no_error
//  range_error
//  failed
//
//***************************************************************************
int CSafeArray::SetBSTRAt(
    IN int nIndex,
    IN BSTR Str
    )
{
    // Check for out-of-range condition.
    // =================================

    if (nIndex > m_nMaxElementUsed + 1)
        return range_error;

    // Check to see if we are adding a new element.
    // ============================================

    if (nIndex == m_nMaxElementUsed + 1)
        return AddBSTR(Str);

    BSTR Copy = COleAuto::_SysAllocString(Str);
    CSysFreeMe auto1(Copy);

    // If here, we are replacing an element.
    // =====================================

    if (COleAuto::_SafeArrayPutElement(m_pArray, (long *) &nIndex, Copy) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CSafeArray::SetVariantAt
//
//  Sets the VARIANT at the specified index.
//
//  PARAMETERS:
//  nIndex
//      The index at which to set the VARIANT.  The original contents
//      at this location are automatically deallocated and replaced.
//  pVal
//      Used as the source of the new value.  This is treated as read-only.
//  
//  RETURN VALUE:
//  no_error, failed, range_error
//      
//***************************************************************************
int CSafeArray::SetVariantAt(
    IN int nIndex,
    IN VARIANT *pVal
    )
{
    // Check for out-of-range condition.
    // =================================

    if (nIndex > m_nMaxElementUsed + 1)
        return range_error;

    // Check to see if we are adding a new element.
    // ============================================

    if (nIndex == m_nMaxElementUsed + 1)
        return AddVariant(pVal);

    // If here, we are replacing an element.
    // =====================================

    if (COleAuto::_SafeArrayPutElement(m_pArray, (long *) &nIndex, pVal) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CSafeArray::SetDispatchAt
//
//  Sets the IDispatch* at the specified index.
//
//  PARAMETERS:
//  nIndex
//      The index at which to set the IDispatch*.  The original contents
//      at this location are automatically Released and replaced.
//  pVal
//      Used as the source of the new value.  This is treated as read-only.
//  
//  RETURN VALUE:
//  no_error, failed, range_error
//      
//***************************************************************************
int CSafeArray::SetDispatchAt(
    IN int nIndex,
    IN IDispatch *pDisp
    )
{
    // Check for out-of-range condition.
    // =================================

    if (nIndex > m_nMaxElementUsed + 1)
        return range_error;

    // Check to see if we are adding a new element.
    // ============================================

    if (nIndex == m_nMaxElementUsed + 1)
        return AddDispatch(pDisp);

    // If here, we are replacing an element.
    // =====================================

    if (COleAuto::_SafeArrayPutElement(m_pArray, (long *) &nIndex, pDisp) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CSafeArray::SetUnknownAt
//
//  Sets the IUnknown* at the specified index.
//
//  PARAMETERS:
//  nIndex
//      The index at which to set the IUnknown*.  The original contents
//      at this location are automatically Released and replaced.
//  pVal
//      Used as the source of the new value.  This is treated as read-only.
//  
//  RETURN VALUE:
//  no_error, failed, range_error
//      
//***************************************************************************
int CSafeArray::SetUnknownAt(
    IN int nIndex,
    IN IUnknown *pUnk
    )
{
    // Check for out-of-range condition.
    // =================================

    if (nIndex > m_nMaxElementUsed + 1)
        return range_error;

    // Check to see if we are adding a new element.
    // ============================================

    if (nIndex == m_nMaxElementUsed + 1)
        return AddUnknown(pUnk);

    // If here, we are replacing an element.
    // =====================================

    if (COleAuto::_SafeArrayPutElement(m_pArray, (long *) &nIndex, pUnk) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CSafeArray::RemoveAt
//
//  Removes the element at the specified index.  After a series of these
//  operations, the caller should call the Trim() function.
//
//  PARAMETERS:
//  nIndex
//      The target index for element removal.
//
//  RETURN VALUE:
//      no_error, range_error
//
//***************************************************************************
int CSafeArray::RemoveAt(IN int nIndex)
{
    // Check for out-of-range condition.
    // =================================

    if (nIndex > m_nMaxElementUsed + 1)
        return range_error;

    // Copy element n+1 into n.
    // ========================

    BSTR strVal;
    VARIANT v;
    SA_ArrayScalar scalar;
    IDispatch* pDisp;
    IUnknown* pUnk;

    for (long i = nIndex; i < m_nMaxElementUsed; i++) {
        long nNext = i + 1;

        if (m_nVarType == VT_BSTR) {
            COleAuto::_SafeArrayGetElement(m_pArray, &nNext, &strVal);
            COleAuto::_SafeArrayPutElement(m_pArray, &i, strVal);
            COleAuto::_SysFreeString(strVal);
        }
        else if (m_nVarType == VT_VARIANT) {
            COleAuto::_SafeArrayGetElement(m_pArray, &nNext, &v);
            COleAuto::_SafeArrayPutElement(m_pArray, &i, &v);
            COleAuto::_VariantClear(&v);
        }
        else if (m_nVarType == VT_DISPATCH) {
            COleAuto::_SafeArrayGetElement(m_pArray, &nNext, &pDisp);
            COleAuto::_SafeArrayPutElement(m_pArray, &i, pDisp);
            if(pDisp) pDisp->Release();
        }            
        else if (m_nVarType == VT_UNKNOWN) {
            COleAuto::_SafeArrayGetElement(m_pArray, &nNext, &pUnk);
            COleAuto::_SafeArrayPutElement(m_pArray, &i, pUnk);
            if(pUnk) pUnk->Release();
        }            
        else {
            COleAuto::_SafeArrayGetElement(m_pArray, &nNext, &scalar);
            COleAuto::_SafeArrayPutElement(m_pArray, &i, &scalar);
        }
    }

    m_nMaxElementUsed--;
    return no_error;
}

//***************************************************************************
//
//  CSafeArray::SetScalarAt
//
//  For class internal use.  Sets the scalar type at the specified index.
//  
//  PARAMETERS:
//  nIndex
//      The target index.
//  val
//      The new value.
//
//  RETURN VALUES:
//  range_error, failed, no_error    
//
//***************************************************************************
int CSafeArray::SetScalarAt(IN int nIndex, IN SA_ArrayScalar val)
{
    // Check for out-of-range condition.
    // =================================

    if (nIndex > m_nMaxElementUsed + 1)
        return range_error;

    // Check to see if we are adding a new element.
    // ============================================

    if (nIndex == m_nMaxElementUsed + 1)
        return AddScalar(val);

    // If here, we are replacing an element.
    // =====================================

    if (COleAuto::_SafeArrayPutElement(m_pArray, (long *) &nIndex, &val) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CSafeArray::AddScalar
//
//  For class internal use only.
//
//  Adds a new scalar to the 'end' of the array, growing it if required
//  and if possible.
//
//  PARAMETERS:
//  val
//      The new value.
//
//  RETURN VALUE:
//  no_error, range_error, failed
//
//***************************************************************************
int CSafeArray::AddScalar(IN SA_ArrayScalar val)
{
    // If there is no more room in the array, then expand it.
    // ======================================================

    if (m_nMaxElementUsed == (int) m_bound.cElements - 1) {

        if (m_nGrowBy == 0)
            return range_error;

        m_bound.cElements += m_nGrowBy;

        if (S_OK != COleAuto::_SafeArrayRedim(m_pArray, &m_bound))
            m_nStatus = failed;
    }

    m_nMaxElementUsed++;

    if (COleAuto::_SafeArrayPutElement(m_pArray, (long *) &m_nMaxElementUsed, &val) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}



//***************************************************************************
//
//  CSafeArray::Empty
//
//  Empties the SAFEARRAY.
//
//***************************************************************************
void CSafeArray::Empty()
{
    m_nMaxElementUsed = 0;
    m_nFlags = 0;
    m_nGrowBy = 0;
    m_nStatus = no_error;
    m_nVarType = VT_NULL;
    if (m_pArray)
        COleAuto::_SafeArrayDestroy(m_pArray);
    m_pArray = 0;
    m_bound.cElements = 0;
    m_bound.lLbound = 0;
	m_nElementSize = 0L;
}

//***************************************************************************
//
//  CSafeArray::GetArrayCopy
//
//  RETURN VALUE:
//  A copy of the internal SAFEARRAY or NULL on error.
//
//***************************************************************************
SAFEARRAY *CSafeArray::GetArrayCopy()
{
    SAFEARRAY *pCopy = 0;
    if (COleAuto::_SafeArrayCopy(m_pArray, &pCopy) != S_OK)
        return 0;
    return pCopy;
}

//***************************************************************************
//
//  CSafeArray destructor.
//
//  If the internal flags are set to auto_delete, then the internal
//  SAFEARRAY is destroyed during destruction.
//
//***************************************************************************
CSafeArray::~CSafeArray()
{
    if (m_nFlags == auto_delete)
        COleAuto::_SafeArrayDestroy(m_pArray);
}


//***************************************************************************
//
//  CSafeArray::Trim
//
//***************************************************************************
int CSafeArray::Trim()
{                                           
    m_bound.cElements = m_nMaxElementUsed + 1;

    // HACK for NT 3.51: may not redimention to size 0
    // ===============================================

    if(m_bound.cElements == 0)
    {
        COleAuto::_SafeArrayDestroy(m_pArray);
        m_pArray = COleAuto::_SafeArrayCreate((VARENUM) m_nVarType, 1, &m_bound);
    }
    else
    {
        COleAuto::_SafeArrayRedim(m_pArray, &m_bound);
    }

    return no_error;
}

//***************************************************************************
//
//***************************************************************************
void CSafeArray::Fatal(const char *pszMsg)
{
//    MessageBox(0, pszMsg, "CSafeArray FATAL Error",
//        MB_OK | MB_SYSTEMMODAL | MB_ICONEXCLAMATION);
}

int CSafeArray::GetActualVarType( VARTYPE* pvt )
{
	if ( FAILED( SafeArrayGetVartype( m_pArray, pvt ) ) )
		return failed;

	return no_error;
}

int CSafeArray::SetRawData( void* pvSource, int nNumElements, int nElementSize )
{
	// If the number of elements we are setting is > than the number we are allocated
	// for, or element size does not match we fail the operation
	if ( nNumElements > m_bound.cElements || nElementSize != m_nElementSize )
	{
		return failed;
	}

	LPVOID	pvDest = NULL;

	HRESULT	hr = Access( &pvDest );

	if ( SUCCEEDED( hr ) )
	{
		CopyMemory( pvDest, pvSource, nElementSize * nNumElements );
		m_nMaxElementUsed = nNumElements - 1;
		Unaccess();
	}

	return ( SUCCEEDED( hr ) ? no_error : failed );
}

int CSafeArray::GetRawData( void* pvDest, int nBuffSize )
{
	
	// If the number of elements we will copy will exceed the destination
	// buffer, don't do it!
	if ( ( ( m_nMaxElementUsed + 1 ) * m_nElementSize ) > nBuffSize )
	{
		return failed;
	}
		
	LPVOID	pvSource = NULL;

	HRESULT	hr = Access( &pvSource );

	if ( SUCCEEDED( hr ) )
	{
		CopyMemory( pvDest, pvSource, ( m_nMaxElementUsed + 1) * m_nElementSize );
		Unaccess();
	}

	return ( SUCCEEDED( hr ) ? no_error : failed );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\sleeper.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SLEEPER.H

Abstract:

    MinMax controls.

History:

--*/

#ifndef ___WBEM_SLEEPER__H_
#define ___WBEM_SLEEPER__H_

#include "sync.h"
#include "wstring.h"

//******************************************************************************
//
//  class CLimitControl
//
//  Limits the growth of a certain quantity by delaying requests to add to it.
//  This is an abstract base class for the classes that actually implement a
//  a particular enforcement strategy.
//
//  Clients of this object call Add to request to increase the controlled 
//  quantity (which will often sleep), and Remove to inform it that the quantity
//  is being reduced (which may or may not affect the sleeping clients)
//
//******************************************************************************
class POLARITY CLimitControl
{
protected:
    DWORD m_dwMembers;

public:
    CLimitControl();
    virtual ~CLimitControl(){}

    virtual HRESULT AddMember();
    virtual HRESULT RemoveMember();
    virtual HRESULT Add(DWORD dwHowMuch, DWORD dwMemberTotal, 
                            DWORD* pdwSleep = NULL) = 0;
    virtual HRESULT Remove(DWORD dwHowMuch) = 0;
};

//******************************************************************************
//
//  class CMinMaxLimitControl
//
//  This derivative of CLimitControl controls the growth of a quantity by 
//  slowing down (sleeping) progressively longer periods of time after the
//  quantity exceeds the lower threshold --- m_dwMin.  The growth of the 
//  sleep interval is linear, and is calculates to reach m_dwSleepAnMax 
//  milliseconds by the time the quantity reaches m_dwMax.  At that point, an
//  error message is logged, but the sleep interval stays at m_dwSleepAtMax.
//
//  m_nLog is the index of the log file (e.g. LOG_ESS), m_wsName is the name
//  of the controlled quantity to use in the log message
//
//******************************************************************************

class POLARITY CMinMaxLimitControl : public CLimitControl
{
protected:
    DWORD m_dwMin;
    DWORD m_dwMax;
    DWORD m_dwSleepAtMax;
    int m_nLog;
    WString m_wsName;

    DWORD m_dwCurrentTotal;
    BOOL m_bMessageLogged;
    CCritSec m_cs;

public:
    CMinMaxLimitControl(int nLog, LPCWSTR wszName);
    void SetMin(DWORD dwMin) {m_dwMin = dwMin;}
    void SetMax(DWORD dwMax) {m_dwMax = dwMax;}
    void SetSleepAtMax(DWORD dwSleepAtMax) {m_dwSleepAtMax = dwSleepAtMax;}

    virtual HRESULT Add(DWORD dwHowMuch, DWORD dwMemberTotal,
                            DWORD* pdwSleep = NULL);
    virtual HRESULT Remove(DWORD dwHowMuch);

protected:
    HRESULT ComputePenalty(DWORD dwNewTotal, DWORD dwMemberTotal, 
                            DWORD* pdwSleep, BOOL* pbLog);
};

//******************************************************************************
//
//  class CRegistryMinMaxLimitControl
//
//  This derivative of CMinMaxLimitControl gets its limiting information from 
//  the specified place in the registry
//
//  m_hHive holds the hive, m_wsKey the path to the key (e.g. "SOFTWARE\\MSFT"),
//  m_wsMinValueName, m_wsMaxValueName, and m_wsSleepAtMaxValueName hold the 
//  names of the registry values holding the values of these parameters, as
//  described in CMinMaxLimitControl
//
//******************************************************************************

class POLARITY CRegistryMinMaxLimitControl : public CMinMaxLimitControl
{
protected:
    WString m_wsKey;
    WString m_wsMinValueName;
    WString m_wsMaxValueName;
    WString m_wsSleepAtMaxValueName;
    
public:
    CRegistryMinMaxLimitControl(int nLog, LPCWSTR wszName, 
                                LPCWSTR wszKey, LPCWSTR wszMinValueName,
                                LPCWSTR wszMaxValueName, 
                                LPCWSTR wszSleepAtMaxValueName)
        : CMinMaxLimitControl(nLog, wszName), m_wsKey(wszKey),
            m_wsMinValueName(wszMinValueName), 
            m_wsMaxValueName(wszMaxValueName),
            m_wsSleepAtMaxValueName(wszSleepAtMaxValueName)
    {}

    HRESULT Reread();

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\smallarr.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SMALLARR.CPP

Abstract:

    Small Array

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include "smallarr.h"

CSmallArrayBlob* CSmallArrayBlob::CreateBlob(int nInitialSize)
{
    // Allocate enough space for the header, plus the data
    // ===================================================

    DWORD dwSize = sizeof(CSmallArrayBlob) - sizeof(void*) * ANYSIZE_ARRAY;
    dwSize += nInitialSize * sizeof(void*);
   
    CSmallArrayBlob* pBlob = (CSmallArrayBlob*)(new BYTE[dwSize]);
    if(pBlob == NULL)
        return NULL;

    // Initialize it appropriately
    // ===========================

    pBlob->Initialize(nInitialSize);
    return pBlob;
}

void CSmallArrayBlob::Initialize(int nInitialSize)
{
    // It has already been allocated to be big enough
    // ==============================================

    m_nExtent = nInitialSize;
    m_nSize = 0;
}

CSmallArrayBlob* CSmallArrayBlob::Grow()
{
    // Allocate a new array of twice our size
    // ======================================

    CSmallArrayBlob* pNew = CreateBlob(m_nExtent*2);
    if(pNew == NULL)
        return NULL;
    
    // Copy our data into it
    // =====================

    pNew->CopyData(this);

    // Delete ourselves!
    // =================

    delete this;
    return pNew;
}

void CSmallArrayBlob::CopyData(CSmallArrayBlob* pOther)
{
    m_nSize = pOther->m_nSize;
    memcpy(m_apMembers, pOther->m_apMembers, sizeof(void*) * m_nSize);
}


CSmallArrayBlob* CSmallArrayBlob::EnsureExtent(int nDesired)
{
    if(m_nExtent < nDesired)
        return Grow(); // will delete this!
    else
        return this;
}
    
CSmallArrayBlob* CSmallArrayBlob::InsertAt(int nIndex, void* pMember)
{
    // Ensure there is enough space
    // ============================

    CSmallArrayBlob* pArray = EnsureExtent(m_nSize+1);
    if(pArray == NULL)
        return NULL;

    // Move the data forward to make room
    // ==================================

    if(pArray->m_nSize > nIndex)
    {
        memmove(pArray->m_apMembers + nIndex + 1, pArray->m_apMembers + nIndex, 
            sizeof(void*) * (pArray->m_nSize - nIndex));
    }

    // Insert
    // ======

    pArray->m_apMembers[nIndex] = pMember;
    pArray->m_nSize++;

    return pArray;
}
    
void CSmallArrayBlob::SetAt(int nIndex, void* pMember, void** ppOld)
{
    // Make sure we even have that index (sparse set)
    // ==============================================

    EnsureExtent(nIndex+1);
    if(nIndex >= m_nSize)
        m_nSize = nIndex+1;

    // Save old value
    // ==============

    if(ppOld)
        *ppOld = m_apMembers[nIndex];

    // Replace
    // =======

    m_apMembers[nIndex] = pMember;
}

CSmallArrayBlob* CSmallArrayBlob::RemoveAt(int nIndex, void** ppOld)
{
    // Save old value
    // ==============

    if(ppOld)
        *ppOld = m_apMembers[nIndex];
    
    // Move the data back
    // ==================

    memcpy(m_apMembers + nIndex, m_apMembers + nIndex + 1, 
            sizeof(void*) * (m_nSize - nIndex - 1));

    m_nSize--;

    // Ensure we are not too large
    // ===========================
    
    return ShrinkIfNeeded();
}

CSmallArrayBlob* CSmallArrayBlob::ShrinkIfNeeded()
{
    if(m_nSize < m_nExtent / 4)
        return Shrink(); // will delete this!
    else
        return this;
}

CSmallArrayBlob* CSmallArrayBlob::Shrink()
{
    // Allocate a new blob of half our size
    // ====================================

    CSmallArrayBlob* pNew = CreateBlob((m_nExtent+1)/2);
    if(pNew == NULL)
    {
        // Out of memory --- we'll just have to stay large
        // ===============================================

        return this;
    }

    // Copy our data
    // =============

    pNew->CopyData(this);

    delete this; // we are no longer needed
    return pNew;
}

void CSmallArrayBlob::Trim()
{
    while(m_nSize > 0 && m_apMembers[m_nSize-1] == NULL)
        m_nSize--;
}

void CSmallArrayBlob::Sort()
{
    qsort(m_apMembers, m_nSize, sizeof(void*), CSmallArrayBlob::CompareEls);
}

int __cdecl CSmallArrayBlob::CompareEls(const void* pelem1, const void* pelem2)
{
    return *(DWORD_PTR*)pelem1 - *(DWORD_PTR*)pelem2;
}

void** CSmallArrayBlob::CloneData()
{
    void** ppReturn = new void*[m_nSize];
    
    if (ppReturn)
        memcpy(ppReturn, m_apMembers, m_nSize * sizeof(void*));

    return ppReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\servutil.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    SERVUTIL.CPP

Abstract:

    Defines various service utilities.

History:

  a-davj  04-Mar-97   Created.

--*/

#include "precomp.h"
#include "servutil.h"

//***************************************************************************
//
//  BOOL InstallService
//
//  DESCRIPTION:
//
//  Installs a service
//
//  PARAMETERS:
//
//  pServiceName        short service name
//  pDisplayName        name displayed to the user
//  pBinary             full path to the binary
//
//  RETURN VALUE:
//
//  TRUE if it worked
//
//***************************************************************************

BOOL InstallService(
                        IN LPCTSTR pServiceName,
                        IN LPCTSTR pDisplayName,
                        IN LPCTSTR pBinary)
{
    SC_HANDLE   schService = NULL;
    SC_HANDLE   schSCManager;

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = CreateService(
            schSCManager,               // SCManager database
            pServiceName,        // name of service
            pDisplayName, // name to display
            SERVICE_ALL_ACCESS,         // desired access
            SERVICE_WIN32_OWN_PROCESS,  // service type
            SERVICE_DEMAND_START,       // start type
            SERVICE_ERROR_NORMAL,       // error control type
            pBinary,                     // service's binary
            NULL,                       // no load ordering group
            NULL,                       // no tag identifier
            NULL,                       // dependencies
            NULL,                       // LocalSystem account
            NULL);                      // no password

        if ( schService )
        {
            CloseServiceHandle(schService);
        }

        CloseServiceHandle(schSCManager);
    }
    return schService != NULL;
}

//***************************************************************************
//
//  BOOL RemoveService
//
//  DESCRIPTION:
//
//  Stops and then removes the service.  
//
//  PARAMETERS:
//
//  pServiceName        Short service name
//
//  RETURN VALUE:
//
//  TRUE if it worked
//
//***************************************************************************

BOOL RemoveService(
                        IN LPCTSTR pServiceName)
{
    SC_HANDLE   schService;
    BOOL bRet = FALSE;
    SC_HANDLE   schSCManager;
    StopService(pServiceName, 15);

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = OpenService(schSCManager, pServiceName, SERVICE_ALL_ACCESS);

        if (schService)
        {
            bRet =  DeleteService(schService);
            CloseServiceHandle(schService);
        }

        CloseServiceHandle(schSCManager);
    }
    return bRet;
}

//***************************************************************************
//
//  BOOL StopService
//
//  DESCRIPTION:
//
//  Stops and then removes the service. 
//
//  PARAMETERS:
//
//  pServiceName        short service name
//  dwMaxWait           max time in seconds to wait
//
//  RETURN VALUE:
//
//  TRUE if it worked
//
//***************************************************************************

BOOL StopService(
                        IN LPCTSTR pServiceName,
                        IN DWORD dwMaxWait)
{
    BOOL bRet = FALSE;
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;
    DWORD dwCnt;
    SERVICE_STATUS          ssStatus;       // current status of the service

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = OpenService(schSCManager, pServiceName, SERVICE_ALL_ACCESS);

        if (schService)
        {
            // try to stop the service
            if ( bRet = ControlService( schService, SERVICE_CONTROL_STOP, &ssStatus ) )
            {
                for(dwCnt=0; dwCnt < dwMaxWait &&
                    QueryServiceStatus( schService, &ssStatus ); dwCnt++)
                {
                    if ( ssStatus.dwCurrentState == SERVICE_STOP_PENDING )
                        Sleep( 1000 );
                    else
                        break;
                }

            }

            CloseServiceHandle(schService);
        }

        CloseServiceHandle(schSCManager);
    }
    return bRet;
}

//***************************************************************************
//
//  BOOL StartService
//
//  DESCRIPTION:
//
//  Starts the service runnig
//
//  PARAMETERS:
//
//  pServiceName        short service name
//  dwMaxWait           max time in seconds to wait
//
//  RETURN VALUE:
//
//  TRUE if it worked
//
//***************************************************************************

BOOL StartService(
                        IN LPCTSTR pServiceName,
                        IN DWORD dwMaxWait)
{
    DWORD dwCnt;
    BOOL bRet = FALSE;
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;
    SERVICE_STATUS          ssStatus;       // current status of the service

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = OpenService(schSCManager, pServiceName, SERVICE_ALL_ACCESS);

        if (schService)
        {
            // try to stop the service
            if ( bRet = StartService( schService, 0, NULL ) )
            {
                for(dwCnt = 0; dwCnt < dwMaxWait &&
                    QueryServiceStatus( schService, &ssStatus ); dwCnt++)
                {
                    if ( ssStatus.dwCurrentState != SERVICE_RUNNING )
                        Sleep( 1000 );
                    else
                        break;
                }

            }

            CloseServiceHandle(schService);
        }

        CloseServiceHandle(schSCManager);
    }
    return bRet;
}


//***************************************************************************
//
//  BOOL SetDependency
//
//  DESCRIPTION:
//
//  Sets a service's dependency list.
//
//  PARAMETERS:
//
//  pServiceName        short service name
//  pDependency         dependency list
//
//  RETURN VALUE:
//
//  TRUE if it worked
//
//***************************************************************************

BOOL SetDependency(
                        IN LPCTSTR pServiceName,
                        IN LPCTSTR pDependency)
{
    BOOL bRet = FALSE;
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = OpenService(schSCManager, pServiceName, SERVICE_ALL_ACCESS);

        if (schService)
        {
            bRet = ChangeServiceConfig(
                schService,
                    SERVICE_NO_CHANGE,
                    SERVICE_NO_CHANGE,
                    SERVICE_NO_CHANGE,
                    NULL,
                    NULL,
                    NULL,
                    pDependency,
                    NULL,
                    NULL,
                    NULL);
            CloseServiceHandle(schService);
        }

        CloseServiceHandle(schSCManager);
    }
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\sleeper.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SLEEPER.CPP

Abstract:

    MinMax controls.

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <wbemcomn.h>
#include "sleeper.h"

CLimitControl::CLimitControl()
    : m_dwMembers(0)
{
}

HRESULT CLimitControl::AddMember()
{
    InterlockedIncrement((long*)&m_dwMembers);
    return S_OK;
}

HRESULT CLimitControl::RemoveMember()
{
    InterlockedDecrement((long*)&m_dwMembers);
    return S_OK;
}

CMinMaxLimitControl::CMinMaxLimitControl(int nLog, LPCWSTR wszName)
        : m_dwMin(10000000), m_dwMax(20000000), m_dwSleepAtMax(60000), 
        m_nLog(nLog), m_wsName(wszName), m_dwCurrentTotal(0),
        m_bMessageLogged(FALSE)
{
}

HRESULT CMinMaxLimitControl::Add(DWORD dwHowMuch, DWORD dwMemberTotal,
                                    DWORD* pdwSleep)
{
    // Add amount to the total
    // =======================

    DWORD dwNewTotal;
    {
        CInCritSec ics(&m_cs);

        m_dwCurrentTotal += dwHowMuch;
        dwNewTotal = m_dwCurrentTotal;
    }

    // Calculate the penalty
    // =====================

    DWORD dwSleep = 0;
    BOOL bLog = TRUE;

    HRESULT hres = ComputePenalty(dwNewTotal, dwMemberTotal, &dwSleep, &bLog);
    if(FAILED(hres))
        return hres;

    if(dwSleep)
    {
        DEBUGTRACE(((char) m_nLog, "Penalty for %d out of %d \n\tof %S (%d members) "
            "is %d ms\n", dwMemberTotal, dwNewTotal, (LPCWSTR)m_wsName, 
            m_dwMembers, dwSleep));
    }

    // Log a message if required
    // =========================

    if(bLog)
    {
        ERRORTRACE(((char) m_nLog, "The limit of %d was exceeded for %S. The system "
            "is under extreme stress and out-of-memory conditions can ensue\n",
            m_dwMax, (LPCWSTR)m_wsName));
    }

    // Sleep, if required
    // ==================

    if(pdwSleep == NULL)
    {
        if(dwSleep)
            Sleep(dwSleep);
    }
    else
    {
        // Just return the required amount
        // ===============================
        *pdwSleep = dwSleep;
    }

    return hres;
}

HRESULT CMinMaxLimitControl::ComputePenalty(DWORD dwNewTotal, 
                                DWORD dwMemberTotal, 
                                DWORD* pdwSleep, BOOL* pbLog)
{
    CInCritSec ics(&m_cs);

    *pdwSleep = 0;
    *pbLog = FALSE;

    if(dwNewTotal > m_dwMin)
    {
        // Threshold exceeded --- non-zero penalty
        // =======================================

        // Compute a linear value between 0 and m_dwSleepAtMax
        // ===================================================

        __int64 i64Temp = (__int64)(dwNewTotal - m_dwMin);
        i64Temp *= (__int64)m_dwSleepAtMax;
        i64Temp /= (__int64)(m_dwMax - m_dwMin);

        // i64Temp is how much we would have to sleep if all queues were
        // equal.
        // =============================================================

        if(dwMemberTotal * m_dwMembers < dwNewTotal)
        {
            for(int i = 0; i < 2; i++)
            {
                i64Temp *= (__int64)dwMemberTotal;
                i64Temp *= (__int64)m_dwMembers;
                i64Temp /= (__int64)dwNewTotal;
            }
        }
        
        *pdwSleep = (DWORD)i64Temp;

        // Check if we have exceeeded m_dwMax
        // ==================================

        if(dwNewTotal >= m_dwMax)
        {
            // Max exceeded --- log a message if not already done so
            // =====================================================

            if(!m_bMessageLogged)
            {
                *pbLog = TRUE;
                m_bMessageLogged = TRUE;
            }

            return S_FALSE; // to let the caller know that things are bad
        }
        else
        {
            return S_OK;
        }
    }
    else
    {
        // No penalty
        // ==========

        *pdwSleep = 0;
        return S_OK;
    }

    return S_OK;
}


            

HRESULT CMinMaxLimitControl::Remove(DWORD dwHowMuch)
{
    // Determine if we crossed the critical boundary back.
    // ===================================================

    BOOL bLog = FALSE;

    {
        CInCritSec ics(&m_cs);

        m_dwCurrentTotal -= dwHowMuch;
        if(m_dwCurrentTotal < (m_dwMax * 0.9) && m_bMessageLogged)
        {
            // We have crossed the boundary
            // ============================

            bLog = TRUE;
            m_bMessageLogged = FALSE;
        }
    }

    // Log the message if required
    // ===========================

    if(bLog)
    {
        ERRORTRACE(((char) m_nLog, "%S is back in its normal range: below %d\n", 
            (LPCWSTR)m_wsName, m_dwMax));
    }

    return S_OK;
}


HRESULT CRegistryMinMaxLimitControl::Reread()
{
    // Open the key
    // ============

#ifdef UNICODE
    Registry r(m_wsKey);
#else
    char *szKey = m_wsKey.GetLPSTR();
    CDeleteMe <char>delMe(szKey);
    Registry r(szKey);
#endif
    if(r.GetLastError())
    {
        ERRORTRACE(((char) m_nLog, "Unable to open registry key %S to read control "
            "information for %S.  Error code: %d.  Default values will be "
            "used\n", (const wchar_t*)m_wsKey, (LPCWSTR)m_wsName, r.GetLastError()));
        return WBEM_E_FAILED;
    }

    // Read the values
    // ===============

    DWORD dwMin, dwMax, dwSleepAtMax;

#ifdef UNICODE
    if(r.GetDWORDStr(m_wsMinValueName, &dwMin) != Registry::no_error)
    {
        r.SetDWORDStr(m_wsMinValueName, m_dwMin);
        dwMin = m_dwMin;
    }
#else
    char *pStr = m_wsMinValueName.GetLPSTR();
    if(r.GetDWORDStr(pStr, &dwMin) != Registry::no_error)
    {
        r.SetDWORDStr(pStr, m_dwMin);
        dwMin = m_dwMin;
    }
    delete [] pStr;
#endif

#ifdef UNICODE
    if(r.GetDWORDStr(m_wsMaxValueName, &dwMax) != Registry::no_error)
    {
        r.SetDWORDStr(m_wsMaxValueName, m_dwMax);
        dwMax = m_dwMax;
    }
#else
    pStr = m_wsMaxValueName.GetLPSTR();
    if(r.GetDWORDStr(pStr, &dwMax) != Registry::no_error)
    {
        r.SetDWORDStr(pStr, m_dwMax);
        dwMax = m_dwMax;
    }
    delete [] pStr;
#endif

#ifdef UNICODE
    if(r.GetDWORDStr(m_wsSleepAtMaxValueName, &dwSleepAtMax) != Registry::no_error)
    {
        r.SetDWORDStr(m_wsSleepAtMaxValueName, m_dwSleepAtMax);
        dwSleepAtMax = m_dwSleepAtMax;
    }
#else
    pStr = m_wsSleepAtMaxValueName.GetLPSTR();
    if(r.GetDWORDStr(pStr, &dwSleepAtMax) != Registry::no_error)
    {
        r.SetDWORDStr(pStr, m_dwSleepAtMax);
        dwSleepAtMax = m_dwSleepAtMax;
    }
    delete [] pStr;
#endif
    
    // Now store them in the member variables
    // ======================================

    {
        CInCritSec ics(&m_cs);

        m_dwMin = dwMin;
        m_dwMax = dwMax;
        m_dwSleepAtMax = dwSleepAtMax;
    }

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\smallarr.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SMALLARR.H

Abstract:

    Small Array

History:

--*/

#ifndef __WMI_SMALL_ARR__H_
#define __WMI_SMALL_ARR__H_

#include "corepol.h"
#include "flexarry.h"

class POLARITY CSmallArrayBlob
{
protected:
    int m_nSize;
    int m_nExtent;
    void* m_apMembers[ANYSIZE_ARRAY];

public:
    static CSmallArrayBlob* CreateBlob(int nInitialSize);

    CSmallArrayBlob* InsertAt(int nIndex, void* pMember);
    void SetAt(int nIndex, void* pMember, void** ppOld = NULL);
    CSmallArrayBlob* RemoveAt(int nIndex, void** ppOld = NULL);

    void* operator[](int nIndex) const {return m_apMembers[nIndex];}
    void* GetAt(int nIndex) const {return m_apMembers[nIndex];}
    void** GetArrayPtr() {return (void**)m_apMembers;}
    void* const* GetArrayPtr() const {return (void**)m_apMembers;}
    int Size() const {return m_nSize;}
    void Sort();
    void Trim();
    void** CloneData();
    
protected:
    void Initialize(int nInitialSize);
    CSmallArrayBlob* Grow();
    void CopyData(CSmallArrayBlob* pOther);
    CSmallArrayBlob* EnsureExtent(int nDesired);
    CSmallArrayBlob* ShrinkIfNeeded();
    CSmallArrayBlob* Shrink();

    static int __cdecl CompareEls(const void* pelem1, const void* pelem2);
};
    
class CSmallArray
{
protected:
    void* m_pData;

public:
    inline CSmallArray();
    inline ~CSmallArray();
    inline void*  GetAt(int nIndex) const;
    inline void* operator[](int nIndex) const { return GetAt(nIndex); }
    inline void SetAt(int nIndex, void *p, void** ppOld = NULL);
    inline int RemoveAt(int nIndex, void** ppOld = NULL);
    inline int InsertAt(int nIndex, void* pMember);

    int inline Add(void *pSrc) { return InsertAt(Size(), pSrc); }    
    int inline Size() const;

    inline void Trim();
    inline void Empty();
    inline void**  GetArrayPtr();
    inline void* const*  GetArrayPtr() const;
    inline void Sort();
    inline void** UnbindPtr();

protected:
    inline BOOL IsSingleton() const;
    inline BOOL IsEmpty() const;
    inline BOOL IsBlob() const;
    inline void EnsureBlob(int nMinSize);
    inline void* const & GetOnlyMember() const;
    inline void* & GetOnlyMember();
    inline void SetOnlyMember(void* p);
    inline CSmallArrayBlob* GetBlob();
    inline const CSmallArrayBlob* GetBlob() const;
    inline void SetBlob(CSmallArrayBlob* pBlob);
};

#include <smallarr.inl>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\stllock.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    STLLOCK.CPP

Abstract:

  Lock for STL

History:

--*/

#include "precomp.h"
//#include <stdio.h>
//#include <wbemcomn.h>
#include <sync.h>

/*
    This file implements the STL lockit class to avoid linking to msvcprt.dll
*/

CCritSec g_cs;

std::_Lockit::_Lockit()
{
    EnterCriticalSection(&g_cs);
}

std::_Lockit::~_Lockit()
{
    LeaveCriticalSection(&g_cs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\sortarr.inl ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SORTARR.INL

Abstract:

History:


--*/

// included into sortarr.h

template<class TKey, class TEl, class TManager, class TComparer>
CSmartSortedArray<TKey, TEl, TManager, TComparer>::
~CSmartSortedArray()
{
    Clear();
}

template<class TKey, class TEl, class TManager, class TComparer>
void CSmartSortedArray<TKey, TEl, TManager, TComparer>::
Clear()
{
    // Release all elements
    // ====================

    for(int i = 0; i < m_v.size(); i++)
        m_Manager.ReleaseElement(m_v[i]);
    m_v.clear();
}

template<class TKey, class TEl, class TManager, class TComparer>
int CSmartSortedArray<TKey, TEl, TManager, TComparer>::
Add(TEl& NewEl, TEl* pOld)
{
    // Binary search
    // =============

    int nLower = 0;
    int nUpper = m_v.size() - 1;
    while(nUpper >= nLower)
    {
        int nMiddle = (nUpper + nLower) / 2;
        int nCompare = m_Comparer.Compare(NewEl, m_v[nMiddle]);
        if(nCompare < 0)
            nUpper = nMiddle-1;
        else if(nCompare > 0)
            nLower = nMiddle+1;
        else 
        {
            // Already there!
            // ==============

            if(pOld) 
                *pOld = m_v[nMiddle];
            else
                m_Manager.ReleaseElement(m_v[nMiddle]);

            m_v[nMiddle] = NewEl;
            m_Manager.AddRefElement(NewEl);
            return nMiddle;
        }
    }

    // At this point, nUpper == nLower - 1 and our element should be between
    // =====================================================================

    m_Manager.AddRefElement(NewEl);
    m_v.insert(m_v.begin()+nLower, NewEl);
    return nLower;
}
            
template<class TKey, class TEl, class TManager, class TComparer>
bool CSmartSortedArray<TKey, TEl, TManager, TComparer>::
Remove(const TKey& K, TEl* pOld)
{
    // Binary search
    // =============

    int nLower = 0;
    int nUpper = m_v.size() - 1;
    while(nUpper >= nLower)
    {
        int nMiddle = (nUpper + nLower) / 2;
        int nCompare = m_Comparer.Compare(K, m_v[nMiddle]);
        if(nCompare < 0)
            nUpper = nMiddle-1;
        else if(nCompare > 0)
            nLower = nMiddle+1;
        else // found it
        {
            if(pOld) 
                *pOld = m_v[nMiddle];
            else
                m_Manager.ReleaseElement(m_v[nMiddle]);
            m_v.erase(m_v.begin() + nMiddle);
            return true;
        }
    }

    // never found it
    // ==============

    return false;
}

template<class TKey, class TEl, class TManager, class TComparer>
CSmartSortedArray<TKey, TEl, TManager, TComparer>::TIterator 
CSmartSortedArray<TKey, TEl, TManager, TComparer>::
Insert(TIterator it, TEl& NewEl)
{
    m_Manager.AddRefElement(NewEl);
    return m_v.insert(it, NewEl);
}

template<class TKey, class TEl, class TManager, class TComparer>
void CSmartSortedArray<TKey, TEl, TManager, TComparer>::
Append(TEl& NewEl)
{
    m_Manager.AddRefElement(NewEl);
    m_v.insert(m_v.end(), NewEl);
}
    
template<class TKey, class TEl, class TManager, class TComparer>
CSmartSortedArray<TKey, TEl, TManager, TComparer>::TIterator 
CSmartSortedArray<TKey, TEl, TManager, TComparer>::
Remove(TIterator it, RELEASE_ME TEl* pOld)
{
    if(pOld)
        *pOld = *it;
    else
        m_Manager.ReleaseElement(*it);

    return m_v.erase(it);
}

template<class TKey, class TEl, class TManager, class TComparer>
bool CSmartSortedArray<TKey, TEl, TManager, TComparer>::
Find(const TKey& K, TEl* pEl)
{
    TIterator it;
    bool bFound = Find(K, &it);
    if(bFound && pEl)
    {
        *pEl = *it;
        m_Manager.AddRefElement(*pEl);
    }
    return bFound;
}

template<class TKey, class TEl, class TManager, class TComparer>
bool CSmartSortedArray<TKey, TEl, TManager, TComparer>::
Find(const TKey& K, TIterator* pit)
{
    // Binary search
    // =============

    int nLower = 0;
    int nUpper = m_v.size() - 1;
    while(nUpper >= nLower)
    {
        int nMiddle = (nUpper + nLower) / 2;
        int nCompare = m_Comparer.Compare(K, m_v[nMiddle]);
        if(nCompare < 0)
            nUpper = nMiddle-1;
        else if(nCompare > 0)
            nLower = nMiddle+1;
        else // found it
        {
            *pit = m_v.begin() + nMiddle;
            return true;
        }
    }

    *pit = m_v.begin() + nLower;
    return false;
}

template<class TKey, class TEl, class TManager, class TComparer>
TEl* CSmartSortedArray<TKey, TEl, TManager, TComparer>::
UnbindPtr()
{
    // Allocate a new buffer
    // =====================

    TEl* aBuffer = new TEl[GetSize()];
    if(aBuffer == NULL)
        return NULL;

    // Copy the elements over --- no addreffing required
    // =================================================

    for(int i = 0; i < GetSize(); i++)
        aBuffer[i] = m_v[i];

    m_v.clear();
    return aBuffer;
}

//*****************************************************************************
//*****************************************************************************

template<class TKey, class TEl, class TManager, class TComparer>
CSmartSortedTree<TKey, TEl, TManager, TComparer>::
~CSmartSortedTree()
{
    Clear();
}

template<class TKey, class TEl, class TManager, class TComparer>
void CSmartSortedTree<TKey, TEl, TManager, TComparer>::
Clear()
{
    // Release all elements
    // ====================

    for(TIterator it = Begin(); it != End(); it++)
        m_Manager.ReleaseElement(*it);
    m_t.clear();
}

template<class TKey, class TEl, class TManager, class TComparer>
int CSmartSortedTree<TKey, TEl, TManager, TComparer>::
Add(TEl& NewEl, TEl* pOld)
{
    TIterator it = m_t.lower_bound(m_Comparer.Extract(NewEl));

    // Check if there
    // ==============

    if(it != m_t.end() && m_Comparer.Compare(NewEl, *it) == 0)
    {
        // Already there!
        // ==============

        if(pOld) 
            *pOld = *it;
        else
            m_Manager.ReleaseElement(*it);

        *it = NewEl;
        m_Manager.AddRefElement(NewEl);
    }
    else
    {
        // Not there
        // =========

        m_Manager.AddRefElement(NewEl);
        m_t.insert(it, NewEl);
    }
    return 1;
}
            
template<class TKey, class TEl, class TManager, class TComparer>
bool CSmartSortedTree<TKey, TEl, TManager, TComparer>::
Remove(const TKey& K, TEl* pOld)
{
    TIterator it = m_t.find(K);
    if(it != m_t.end())
    {
        // Found it
        // ========
        
        if(pOld) 
            *pOld = *it;
        else
            m_Manager.ReleaseElement(*it);
        m_t.erase(it);
        return true;
    }
    else
    {
        // never found it
        // ==============
    
        return false;
    }
}

template<class TKey, class TEl, class TManager, class TComparer>
CSmartSortedTree<TKey, TEl, TManager, TComparer>::TIterator 
CSmartSortedTree<TKey, TEl, TManager, TComparer>::
Insert(TIterator it, TEl& NewEl)
{
    m_Manager.AddRefElement(NewEl);

    // This iterator points to the position *after* insertion point. STL likes
    // it before
    // =======================================================================

    TIterator it1 = it;
    it1--;
    return m_t.insert(it1, NewEl);
}

template<class TKey, class TEl, class TManager, class TComparer>
void CSmartSortedTree<TKey, TEl, TManager, TComparer>::
Append(TEl& NewEl)
{
    m_Manager.AddRefElement(NewEl);
    m_t.insert(m_t.end(), NewEl);
}
    
template<class TKey, class TEl, class TManager, class TComparer>
CSmartSortedTree<TKey, TEl, TManager, TComparer>::TIterator 
CSmartSortedTree<TKey, TEl, TManager, TComparer>::
Remove(TIterator it, RELEASE_ME TEl* pOld)
{
    if(pOld)
        *pOld = *it;
    else
        m_Manager.ReleaseElement(*it);

    return m_t.erase(it);
}

template<class TKey, class TEl, class TManager, class TComparer>
bool CSmartSortedTree<TKey, TEl, TManager, TComparer>::
Find(const TKey& K, TEl* pEl)
{
    TIterator it;
    bool bFound = Find(K, &it);
    if(bFound && pEl)
    {
        *pEl = *it;
        m_Manager.AddRefElement(*pEl);
    }
    return bFound;
}

template<class TKey, class TEl, class TManager, class TComparer>
bool CSmartSortedTree<TKey, TEl, TManager, TComparer>::
Find(const TKey& K, TIterator* pit)
{
    *pit = m_t.lower_bound(K);
    if(*pit != m_t.end() && m_Comparer.Compare(K, **pit) == 0)
        return true;
    else
        return false;
}

template<class TKey, class TEl, class TManager, class TComparer>
TEl* CSmartSortedTree<TKey, TEl, TManager, TComparer>::
UnbindPtr()
{
    // Allocate a new buffer
    // =====================

    TEl* aBuffer = new TEl[GetSize()];
    if(aBuffer == NULL)
        return NULL;

    // Copy the elements over --- no addreffing required
    // =================================================

    int i = 0;
    for(TIterator it = Begin(); it != End(); it++)
        aBuffer[i++] = *it;

    m_t.clear();
    return aBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\smallarr.inl ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SMALLARR.INL

Abstract:

    Small Array Inlines.

History:

--*/

CSmallArray::CSmallArray()
{
    SetBlob(NULL);
}

CSmallArray::~CSmallArray()
{
    Empty();
}

void* CSmallArray::GetAt(int nIndex) const
{
    if(IsSingleton())
        return GetOnlyMember(); // nIndex better be 0!
    else
    {
        const CSmallArrayBlob* pBlob;

        if (pBlob = GetBlob())
            return pBlob->GetAt(nIndex);
        else
            return NULL;
    }
}

void CSmallArray::SetAt(int nIndex, void *p, void** ppOld)
{
    if(IsSingleton() && nIndex == 0)
    {
        // Changing our only element
        // =========================

        if(ppOld) *ppOld = GetOnlyMember();
        SetOnlyMember(p);
    }
    else
    {
        EnsureBlob(nIndex+1);
        CSmallArrayBlob* pBlob;

        if (pBlob = GetBlob())
            pBlob->SetAt(nIndex, p, ppOld);
    }
}

int CSmallArray::RemoveAt(int nIndex, void** ppOld)
{
    if(IsSingleton())
    {
        // Removing our only element --- nIndex better be 0
        // ================================================

        Empty(); 
    }
    else
    {
        CSmallArrayBlob* pBlob;

        if (pBlob = GetBlob())
        {
            SetBlob(pBlob->RemoveAt(nIndex, ppOld));
            pBlob = NULL; // to ward off temptation --- pBlob is no longer valid
            
            // Check if the blob has become empty
            // ==================================

            pBlob = GetBlob();
            if(pBlob && pBlob->Size() == 0)
                Empty(); 
        }
        else
            return CFlexArray::out_of_memory;
    }

    return CFlexArray::no_error;
}

int CSmallArray::InsertAt(int nIndex, void* pMember)
{
    if(IsEmpty())
    {
        // Inserting our first element --- nIndex better be 0
        // ==================================================

        SetOnlyMember(pMember);
    }
    else
    {
        EnsureBlob(nIndex+1);

        CSmallArrayBlob* pBlob;
        if (pBlob = GetBlob())
            SetBlob(pBlob->InsertAt(nIndex, pMember));
        else
            return CFlexArray::out_of_memory;
    }

    return CFlexArray::no_error;
}

int CSmallArray::Size() const
{
    if(IsEmpty())
        return 0;
    else if(IsSingleton())
        return 1;
    else 
    {
        const CSmallArrayBlob* pBlob;

        if (pBlob = GetBlob())
            return pBlob->Size();
        else
            return 0;
    }
}

void CSmallArray::Trim()
{
    if(IsSingleton())
    {
        // If the member is NULL, get rid of it
        // ====================================

        if(GetOnlyMember() == NULL)
            Empty();
    }
    else if(IsEmpty())
    {
    }
    else
    {
        CSmallArrayBlob* pBlob;

        if (pBlob = GetBlob())
        {
            pBlob->Trim();

            // If the blob is now empty, convert to "empty"
            // ============================================

            if(pBlob->Size() == 0)
                Empty();
        }
    }
}
    
void CSmallArray::Empty()
{
    if(IsBlob())
        delete [] GetBlob();

    SetBlob(NULL);
}

void CSmallArray::EnsureBlob(int nMinSize)
{
    if(IsSingleton())
    {
        // Allocate a new blob
        // ===================

        CSmallArrayBlob* pBlob = CSmallArrayBlob::CreateBlob(nMinSize);

        // Copy the data
        // =============

        if(pBlob != NULL)
            pBlob->InsertAt(0, GetOnlyMember());

        SetBlob(pBlob);
    }
}

void**  CSmallArray::GetArrayPtr()
{
    if(IsEmpty())
        return NULL;
    else if(IsSingleton())
        return &GetOnlyMember();
    else
    {
        CSmallArrayBlob* pBlob;

        if (pBlob = GetBlob())
            return pBlob->GetArrayPtr();
        else
            return NULL;
    }
}

void**  CSmallArray::UnbindPtr()
{
    void** ppReturn = NULL;
    if(IsSingleton())
    {
        ppReturn = new void*[1];
        if (ppReturn)
            *ppReturn = GetOnlyMember();
    }
    else if(IsBlob())
    {
        CSmallArrayBlob* pBlob;

        if (pBlob = GetBlob())
            ppReturn = pBlob->CloneData();
    }
    Empty();
    return ppReturn;
}

void* const*  CSmallArray::GetArrayPtr() const
{
    if(IsEmpty())
        return NULL;
    else if(IsSingleton())
        return &GetOnlyMember();
    else
    {
        const CSmallArrayBlob* pBlob;

        if (pBlob = GetBlob())
            return pBlob->GetArrayPtr();
        else
            return NULL;
    }
}

void CSmallArray::Sort()
{
    if(IsBlob())
    {
        CSmallArrayBlob* pBlob;

        if (pBlob = GetBlob())
            pBlob->Sort();
    }
}

void*& CSmallArray::GetOnlyMember()
{
    return m_pData;
}

void* const & CSmallArray::GetOnlyMember() const
{
    return m_pData;
}

void CSmallArray::SetOnlyMember(void* p)
{
    m_pData = p;
}

BOOL CSmallArray::IsEmpty() const
{
    return (m_pData == (void*)1);
}

BOOL CSmallArray::IsSingleton() const
{
    return (((DWORD_PTR)m_pData & 1) == 0);
}

BOOL CSmallArray::IsBlob() const
{
    return (m_pData != (void*)1) && ((DWORD_PTR)m_pData & 1);
}

CSmallArrayBlob* CSmallArray::GetBlob()
{
    return (CSmallArrayBlob*)((DWORD_PTR)m_pData & ~(DWORD_PTR)1);
}

const CSmallArrayBlob* CSmallArray::GetBlob() const
{
    return (CSmallArrayBlob*)((DWORD_PTR)m_pData & ~(DWORD_PTR)1);
}

void CSmallArray::SetBlob(CSmallArrayBlob* pBlob)
{
    m_pData = (CSmallArrayBlob*)((DWORD_PTR)pBlob | 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\sortarr.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SORTARR.H

Abstract:

History:


--*/

#ifndef __WMI__SMART_SORTED_ARRAY__H_
#define __WMI__SMART_SORTED_ARRAY__H_

#pragma warning( disable : 4786 )
#include <vector>
#include <arrtempl.h>
#include <wstlallc.h>

template<class TKey, class TEl, class TManager, class TComparer>
class CSmartSortedArray
{
protected:
    std::vector<TEl, wbem_allocator<TEl> > m_v;
    TManager m_Manager;
    TComparer m_Comparer;

public:
    typedef std::vector<TEl, wbem_allocator<TEl> >::iterator TIterator;
    typedef std::vector<TEl, wbem_allocator<TEl> >::const_iterator TConstIterator;

    CSmartSortedArray(){}
    virtual ~CSmartSortedArray();

    TIterator Begin() {return m_v.begin();}
    TConstIterator Begin() const {return m_v.begin();}
    TIterator End() {return m_v.end();}
    TConstIterator End() const {return m_v.end();}
    int Add(TEl& NewEl, RELEASE_ME TEl* pOld = NULL);
    bool Remove(const TKey& K, RELEASE_ME TEl* pOld = NULL);
    TIterator Remove(TIterator it, RELEASE_ME TEl* pOld = NULL);
    TIterator Insert(TIterator it, TEl& NewEl);
    void Append(TEl& NewEl);
    bool Find(const TKey& K, RELEASE_ME TEl* pEl);
    bool Find(const TKey& K, TIterator* pit);

    void Empty() {m_v.clear();}
    int GetSize() {return m_v.size();}

    TEl* UnbindPtr();
    void Clear();
};

template<class TKey, class TEl, class TComparer>
class TExtractor : public std::unary_function<TEl, TKey>
{
    TComparer m_Comparer;
public:
    const TKey& operator()(const TEl& El) const
    {
        return m_Comparer.Extract(El);
    }
};

template<class TKey, class TEl, class TManager, class TComparer>
class CSmartSortedTree
{
protected:
    TManager m_Manager;
    TComparer m_Comparer;

    class TPredicate : public std::binary_function<TKey, TKey, bool>
    {
        TComparer m_Comparer;
    public:
        bool operator()(const TKey& k1, const TKey& k2) const
        {
            return (m_Comparer.Compare(k1, k2) < 0);
        }
    };

    typedef
        std::_Tree< TKey, TEl, TExtractor<TKey, TEl, TComparer>, TPredicate, wbem_allocator<TEl> > 
        TTree;

    TTree m_t;

public:
    typedef TTree::iterator TIterator;
    typedef TTree::const_iterator TConstIterator;

    CSmartSortedTree() : m_t(TPredicate(), false) {}
    virtual ~CSmartSortedTree();

    TIterator Begin() {return m_t.begin();}
    TConstIterator Begin() const {return m_t.begin();}
    TIterator End() {return m_t.end();}
    TConstIterator End() const {return m_t.end();}
    int Add(TEl& NewEl, RELEASE_ME TEl* pOld = NULL);
    bool Remove(const TKey& K, RELEASE_ME TEl* pOld = NULL);
    TIterator Remove(TIterator it, RELEASE_ME TEl* pOld = NULL);
    TIterator Insert(TIterator it, TEl& NewEl);
    void Append(TEl& NewEl);
    bool Find(const TKey& K, RELEASE_ME TEl* pEl);
    bool Find(const TKey& K, TIterator* pit);

    void Empty() {m_t.clear();}
    int GetSize() {return (int)m_t.size();}

    TEl* UnbindPtr();
    void Clear();
};
#include "sortarr.inl"


template<class TKey, class TEl, class TComparer>
class CUniquePointerSortedArray : 
    public CSmartSortedArray<TKey, TEl*, CUniqueManager<TEl>, TComparer>
{
};

template<class TKey, class TEl, class TComparer>
class CRefedPointerSortedArray : 
    public CSmartSortedArray<TKey, TEl*, CReferenceManager<TEl>, TComparer>
{
};

template<class TKey, class TEl, class TComparer>
class CUniquePointerSortedTree : 
    public CSmartSortedTree<TKey, TEl*, CUniqueManager<TEl>, TComparer>
{
};

template<class TKey, class TEl, class TComparer>
class CRefedPointerSortedTree : 
    public CSmartSortedTree<TKey, TEl*, CReferenceManager<TEl>, TComparer>
{
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\sync.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SYNC.CPP

Abstract:

    Synchronization

History:

--*/

#include "precomp.h"

#include "sync.h"
#include <cominit.h>
#include <wbemutil.h>
#include <corex.h>


CSimpleLock::CSimpleLock()
    : m_hEvent(NULL), m_dwOwningThread(0), m_bLocked(false), m_lWaiting(0)
{
    m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
}

CSimpleLock::~CSimpleLock()
{
    CloseHandle(m_hEvent);
}

DWORD CSimpleLock::Enter(DWORD dwTimeout)
{
    m_cs.Enter();
    if(m_bLocked || m_lWaiting > 0)
    {
        //
        // Locked.  Make sure the unlocker sets the event
        //
        
        m_lWaiting++;
        m_cs.Leave();

        DWORD dwRes = WaitForSingleObject(m_hEvent, dwTimeout);
        if(dwRes != WAIT_OBJECT_0)
        {
            if(dwRes != WAIT_TIMEOUT)
            {
                ERRORTRACE((LOG_ESS, "FAILED TO ACQUIRE LOCK: %d\n", dwRes));
            }
            return dwRes;
        }

        m_cs.Enter();
        m_lWaiting--;
    }
    else
    {
        //
        // Nobody has the lock, and nobody is in the middle, so just grab it
        //

    }
    
    m_bLocked = true;
    m_cs.Leave();

    m_dwOwningThread = GetCurrentThreadId();

    return WAIT_OBJECT_0;
}

void CSimpleLock::Leave()
{
    m_dwOwningThread = 0;

    m_cs.Enter();

    //
    // Only set the event if someone is waiting
    //
    
    if(m_lWaiting > 0)
        SetEvent(m_hEvent);

    m_bLocked = false;
    m_cs.Leave();
}

CHaltable::CHaltable() : m_lJustResumed(1), m_dwHaltCount(0), m_csHalt()
{
    // This event will be signaled whenever we are not halted
    // ======================================================

    m_hReady = CreateEvent(
        NULL, 
        TRUE, // manual reset
        TRUE, // signaled: not halted
        NULL);                            
}

CHaltable::~CHaltable()
{
    CloseHandle(m_hReady);
}

HRESULT CHaltable::Halt()
{
    CInCritSec ics(&m_csHalt); // in critical section

    m_dwHaltCount++;
    ResetEvent(m_hReady);
    return S_OK;
}

HRESULT CHaltable::Resume()
{
    CInCritSec ics(&m_csHalt); // in critical section

    m_dwHaltCount--;
    if(m_dwHaltCount == 0)
    {
        SetEvent(m_hReady);
        m_lJustResumed = 1;
    }
    return S_OK;
}

HRESULT CHaltable::ResumeAll()
{
    CInCritSec ics(&m_csHalt); // in critical section
    m_dwHaltCount = 1;
    return Resume();
}


HRESULT CHaltable::WaitForResumption()
{
  while (WbemWaitForSingleObject(m_hReady, INFINITE) == WAIT_FAILED)
    Sleep(0);
    if(InterlockedDecrement(&m_lJustResumed) == 0)
    {
        // The first call after resumption
        return S_OK;
    }
    else
    {
        // weren't halted
        return S_FALSE;
    }
}

BOOL CHaltable::IsHalted()
{
    // Approximate!
    return m_dwHaltCount > 0;
}

CWbemCriticalSection::CWbemCriticalSection( void )
:   m_lLock( -1 ), m_lRecursionCount( 0 ), m_dwThreadId( 0 ), m_hEvent( NULL )
{
    m_hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

    if ( NULL == m_hEvent )
    {
        throw CX_MemoryException();
    }
}

CWbemCriticalSection::~CWbemCriticalSection( void )
{
    if ( NULL != m_hEvent )
    {
        CloseHandle( m_hEvent );
        m_hEvent = NULL;
    }
}

BOOL CWbemCriticalSection::Enter( DWORD dwTimeout /* = 0xFFFFFFFF */ )
{
    BOOL    fReturn = FALSE;

    // Only do this once
    DWORD   dwCurrentThreadId = GetCurrentThreadId();

    // Check if we are the current owning thread.  We can do this here because
    // this test will ONLY succeed in the case where we have a Nested Lock(),
    // AND because we are zeroing out the thread id when the lock count hits
    // 0.

    if( dwCurrentThreadId == m_dwThreadId )
    {
        // It's us - Bump the lock count
        // =============================

        InterlockedIncrement( &m_lRecursionCount );
        return TRUE;
    }

    // 0 means we got the lock
    if ( 0 == InterlockedIncrement( &m_lLock ) )
    {
        m_dwThreadId = dwCurrentThreadId;
        m_lRecursionCount = 1;
        fReturn = TRUE;
    }
    else
    {
        // We wait.  If we got a signalled event, then we now own the
        // critical section.  Otherwise, we should perform an InterlockedDecrement
        // to account for the Increment that got us here in the first place.
        if ( WaitForSingleObject( m_hEvent, dwTimeout ) == WAIT_OBJECT_0 )
        {
            m_dwThreadId = dwCurrentThreadId;
            m_lRecursionCount = 1;
            fReturn = TRUE;
        }
        else
        {
            InterlockedDecrement( &m_lLock );
        }
    }

    return fReturn;
}

void CWbemCriticalSection::Leave( void )
{
    // We don't check the thread id, so we can lock/unlock resources
    // across multiple threads

    BOOL    fReturn = FALSE;

    long    lRecurse = InterlockedDecrement( &m_lRecursionCount );

    // The recursion count hit zero, so it's time to unlock the object
    if ( 0 == lRecurse )
    {
        // If the lock count is >= 0, threads are waiting, so we need to
        // signal the event
        
        m_dwThreadId = 0;
        if ( InterlockedDecrement( &m_lLock ) >= 0 )
        {
            SetEvent( m_hEvent );
        }

    }   // If recursion count is at 0

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\sync.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SYNC.H

Abstract:

    Synchronization

History:

--*/

#ifndef __WBEM_CRITSEC__H_
#define __WBEM_CRITSEC__H_

#include "corepol.h"
#include <corex.h>

class POLARITY CCritSec : public CRITICAL_SECTION
{
public:
    CCritSec() 
    {
        __try
        {
            InitializeCriticalSection(this);
        }
        __except( GetExceptionCode() == STATUS_NO_MEMORY )
        {
            throw CX_MemoryException();
        }
    }

    ~CCritSec()
    {
        DeleteCriticalSection(this);
    }

    void Enter()
    {
        __try
        {
            EnterCriticalSection(this);
        }
        __except( GetExceptionCode() == STATUS_NO_MEMORY )
        {
            throw CX_MemoryException();
        }
    }

    void Leave()
    {
        LeaveCriticalSection(this);
    }
};

class POLARITY CTryCritSec
{
protected:
    CCritSec m_cs;
    CCritSec m_csControl;
    long m_lCount;

public:
    CTryCritSec() : m_lCount(0){}

    void Enter()
    {
        EnterCriticalSection(&m_csControl);
        m_lCount++;
        LeaveCriticalSection(&m_csControl);
        EnterCriticalSection(&m_cs);
    }
    void Leave()
    {
        LeaveCriticalSection(&m_cs);
        EnterCriticalSection(&m_csControl);
        m_lCount--;
        LeaveCriticalSection(&m_csControl);
    }
        
    BOOL TryEnter()
    {
        EnterCriticalSection(&m_csControl);
        if(m_lCount > 0)
        {
            LeaveCriticalSection(&m_csControl);
            return FALSE;
        }
        else
        {
            EnterCriticalSection(&m_cs);
            m_lCount++;
            LeaveCriticalSection(&m_csControl);
            return TRUE;
        }
    }
};

        
class POLARITY CInCritSec
{
protected:
    CRITICAL_SECTION* m_pcs;
public:
    CInCritSec(CRITICAL_SECTION* pcs) : m_pcs(pcs)
    {
        __try
        {
            EnterCriticalSection(m_pcs);
        }
        __except( GetExceptionCode() == STATUS_NO_MEMORY )
        {
            throw CX_MemoryException();
        }
    }

    inline ~CInCritSec()
    {
        LeaveCriticalSection(m_pcs);
    }
};

class POLARITY CInTryCritSec
{
protected:
    CTryCritSec* m_ptcs;

public:
    CInTryCritSec(CTryCritSec* ptcs) : m_ptcs(ptcs)
    {
        m_ptcs->Enter();
    }
    ~CInTryCritSec()
    {
        m_ptcs->Leave();
    }
};

// Allows user to manually leave critical section, checks if inside before leaving
class POLARITY CCheckedInCritSec
{
protected:
    CRITICAL_SECTION* m_pcs;
    BOOL                m_fInside;
public:
    CCheckedInCritSec(CRITICAL_SECTION* pcs) : m_pcs(pcs), m_fInside( FALSE )
    {
        EnterCriticalSection(m_pcs);
        m_fInside = TRUE;
    }
    ~CCheckedInCritSec()
    {
        Leave();
    }

    void Enter( void )
    {
        if ( !m_fInside )
        {
            EnterCriticalSection(m_pcs);
            m_fInside = TRUE;
        }
    }

    void Leave( void )
    {
        if ( m_fInside )
        {
            m_fInside = FALSE;
            LeaveCriticalSection(m_pcs);
        }
    }

    BOOL IsEntered( void )
    { return m_fInside; }
};

//
// This class implements a light-weight exclusive lock.  Critical sections are
// not very good for this because they:
// 1) Do not allow lock/unlock to occur on different threads
// 2) Do not admit timeouts
//
// On the flip side, this guy is intentionally non-reentrant. 
// TBD: efficiency
//

class POLARITY CSimpleLock
{
protected:
    HANDLE m_hEvent;
    DWORD m_dwOwningThread;
    long m_lWaiting;
    bool m_bLocked;
    CCritSec m_cs;

public:
    CSimpleLock();
    ~CSimpleLock();
    DWORD Enter(DWORD dwTimeout = INFINITE);
    void Leave();
};



class POLARITY CHaltable
{
public:
    CHaltable();
    virtual ~CHaltable();
    HRESULT Halt();
    HRESULT Resume();
    HRESULT ResumeAll();
    HRESULT WaitForResumption();
    BOOL IsHalted();
    bool isValid();

private:
    CCritSec m_csHalt;
    HANDLE m_hReady;
    DWORD m_dwHaltCount;
    long m_lJustResumed;
};

inline bool
CHaltable::isValid()
{ return m_hReady != NULL; };

// This class is designed to provide the behavior of a critical section,
// but without any of that pesky Kernel code.  In some circumstances, we
// need to lock resources across multiple threads (i.e. we lock on one
// thread and unlock on another).  If we do this using a critical section,
// this appears to work, but in checked builds, we end up throwing an
// exception.  Since we actually need to do this (for example using NextAsync
// in IEnumWbemClassObject) this class can be used to perform the
// operation, but without causing exceptions in checked builds.

// Please note that code that is going to do this MUST ensure that we don't
// get crossing Enter/Leave operations (in other words, it's responsible for
// synchronizing the Enter and Leave operations.)  Please note that this
// is a dangerous thing to do, so be VERY careful if you are using this
// code for that purpose.

class POLARITY CWbemCriticalSection
{
private:

    long    m_lLock;
    long    m_lRecursionCount;
    DWORD   m_dwThreadId;
    HANDLE  m_hEvent;

public:

    CWbemCriticalSection();
    ~CWbemCriticalSection();

    BOOL Enter( DWORD dwTimeout = INFINITE );
    void Leave( void );

    DWORD   GetOwningThreadId( void )
    { return m_dwThreadId; }

    long    GetLockCount( void )
    { return m_lLock; }

    long    GetRecursionCount( void )
    { return m_lRecursionCount; }

};

class POLARITY CEnterWbemCriticalSection
{
    CWbemCriticalSection*   m_pcs;
    BOOL                    m_fInside;
public:

    CEnterWbemCriticalSection( CWbemCriticalSection* pcs, DWORD dwTimeout = INFINITE )
        : m_pcs( pcs ), m_fInside( FALSE )
    {
        if ( m_pcs )
        {
            m_fInside = m_pcs->Enter( dwTimeout );
        }
    }

    ~CEnterWbemCriticalSection( void )
    {
        if ( m_fInside )
        {
            m_pcs->Leave();
        }
    }

    BOOL IsEntered( void )
    { return m_fInside; }
};

class POLARITY CScopeLock
{
private:

    long*   m_plVal;

public:

    CScopeLock( long* plVal ) : m_plVal( plVal )
    { if ( NULL != m_plVal ) InterlockedIncrement( m_plVal ); }

    ~CScopeLock()
    { if ( NULL != m_plVal ) InterlockedDecrement( m_plVal ); }

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\strutils.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    STRUTILS.H

Abstract:

	String utilities

History:

--*/

#ifndef __WBEM_STRING_UTILS__H_
#define __WBEM_STRING_UTILS__H_

#pragma optimize("gt", on)

/*
inline int wbem_towlower(wint_t c)
{
    if(c >= 0 && c <= 127)
    {
        if(c >= 'A' && c <= 'Z')
            return c + ('a' - 'A');
        else
            return c;
    }
    else return towlower(c);
}
*/

#define wbem_towlower(C) \
    (((C) >= 0 && (C) <= 127)?          \
        (((C) >= 'A' && (C) <= 'Z')?          \
            ((C) + ('a' - 'A')):          \
            (C)          \
        ):          \
        towlower(C)          \
    )          

inline wchar_t wbem_towupper(wchar_t c)
{
    if(c >= 0 && c <= 127)
    {
        if(c >= 'a' && c <= 'z')
            return c + ('A' - 'a');
        else
            return c;
    }
    else return towupper(c);
}

inline int wbem_tolower(int c)
{
    if(c >= 0 && c <= 127)
    {
        if(c >= 'A' && c <= 'Z')
            return c + ('a' - 'A');
        else
            return c;
    }
    else return tolower(c);
}

inline int wbem_toupper(int c)
{
    if(c >= 0 && c <= 127)
    {
        if(c >= 'a' && c <= 'z')
            return c + ('A' - 'a');
        else
            return c;
    }
    else return toupper(c);
}

inline int wbem_wcsicmp( const wchar_t* wsz1, const wchar_t* wsz2)
{
    while(*wsz1 || *wsz2)
    {
        int diff = wbem_towlower(*wsz1) - wbem_towlower(*wsz2);
        if(diff) return diff;
        wsz1++; wsz2++;
    }

    return 0;
}

inline int wbem_unaligned_wcsicmp( UNALIGNED const wchar_t* wsz1, UNALIGNED const wchar_t* wsz2)
{
    while(*wsz1 || *wsz2)
    {
        int diff = wbem_towlower(*wsz1) - wbem_towlower(*wsz2);
        if(diff) return diff;
        wsz1++; wsz2++;
    }

    return 0;
}

// just like wcsicmp, but first 0 of unicode chracters have been omitted
inline int wbem_ncsicmp(const char* wsz1, const char* wsz2)
{
    while(*wsz1 || *wsz2)
    {
        int diff = wbem_towlower((unsigned char)*wsz1) - 
                    wbem_towlower((unsigned char)*wsz2);
        if(diff) return diff;
        wsz1++; wsz2++;
    }

    return 0;
}

inline int wbem_wcsnicmp( const wchar_t* wsz1, const wchar_t* wsz2, size_t n )
{
    while(n-- && (*wsz1 || *wsz2))
    {
        int diff = wbem_towlower(*wsz1) - wbem_towlower(*wsz2);
        if(diff) return diff;
        wsz1++; wsz2++;
    }

    return 0;
}

inline int wbem_unaligned_wcsnicmp( UNALIGNED const wchar_t* wsz1, UNALIGNED const wchar_t* wsz2, size_t n )
{
    while(n-- && (*wsz1 || *wsz2))
    {
        int diff = wbem_towlower(*wsz1) - wbem_towlower(*wsz2);
        if(diff) return diff;
        wsz1++; wsz2++;
    }

    return 0;
}

inline int wbem_stricmp(const char* sz1, const char* sz2)
{
    while(*sz1 || *sz2)
    {
        int diff = wbem_tolower(*sz1) - wbem_tolower(*sz2);
        if(diff) return diff;
        sz1++; sz2++;
    }

    return 0;
}

inline int wbem_strnicmp(const char* sz1, const char* sz2, size_t n)
{
    while(n-- && (*sz1 || *sz2))
    {
        int diff = wbem_tolower(*sz1) - wbem_tolower(*sz2);
        if(diff) return diff;
        sz1++; sz2++;
    }

    return 0;
}

#pragma optimize("", on)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\stackcom.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    STACKCOM.CPP

Abstract:

    stack implementation.

History:


--*/

#include "precomp.h"
#include <stdio.h>


#ifdef _MT
  #undef _MT
  #include <yvals.h>
  #define _MT
#endif

#include "arena.h"

#include "sync.h"
#include "flexarry.h"
#include <time.h>
#include <stdio.h>
#include <arrtempl.h>
#include <sync.h>
#include <malloc.h>
#include <imagehlp.h>
#include <execq.h>
#include "stackcom.h"

void* CStackRecord::mstatic_apReturns[1000];

void CStackRecord::Create(int nIgnore, BOOL bStatic)
{
    m_dwNumItems = GetStackLen() - nIgnore;
    if(bStatic)
    {
        m_apReturns = (void**)mstatic_apReturns;
        m_bDelete = FALSE;
    }
    else
    {
        m_apReturns = new void*[m_dwNumItems];
        m_bDelete = TRUE;
    }

    ReadStack(nIgnore, m_apReturns);
}

CStackRecord::~CStackRecord() 
{
    if(m_bDelete)
        delete m_apReturns;
}

void CStackRecord::MakeCopy(CStackRecord& Other)
{
    m_dwNumItems = Other.GetNumItems();
    DWORD dwLen = Other.GetNumItems() * sizeof(void*);
    m_apReturns = new void*[Other.GetNumItems()];
    memcpy(m_apReturns, Other.GetItems(), dwLen);
    m_bDelete = TRUE;
}

int CStackRecord::Compare(const CStackRecord& Other) const
{
    int nDiff = GetNumItems()- Other.GetNumItems();
    if(nDiff)
        return nDiff;

    return memcmp(GetItems(), Other.GetItems(), sizeof(void*) * GetNumItems());
}

DWORD CStackRecord::GetStackLen()
{
    void* pFrame;
    __asm
    {
        mov pFrame, ebp
    }

    CStackContinuation* pPrev = CStackContinuation::Get();
    void* pEnd = NULL;
    if(pPrev)
        pEnd = pPrev->m_pThisStackEnd;

    DWORD dwLen = 0;
    while(!IsBadReadPtr(pFrame, sizeof(DWORD)))
    {
        dwLen++;
        void** ppReturn = (void**)pFrame + 1;
        void* pReturn = *ppReturn;
        if(pReturn == pEnd)
            break;
        void* pNewFrame = *(void**)pFrame;
        if(pNewFrame <= pFrame)
            break;
        pFrame = pNewFrame;
    }

    if(pPrev != NULL)
        dwLen += pPrev->m_pPrevStack->GetNumItems();

    return dwLen;
}

void CStackRecord::ReadStack(int nIgnore, void** apReturns)
{
    void* pFrame;
    __asm
    {
        mov pFrame, ebp
    }

    CStackContinuation* pPrev = CStackContinuation::Get();
    void* pEnd = NULL;
    if(pPrev)
        pEnd = pPrev->m_pThisStackEnd;

    while(!IsBadReadPtr(pFrame, sizeof(DWORD)))
    {
        void** ppReturn = (void**)pFrame + 1;
        void* pReturn = *ppReturn;
        if(pReturn == pEnd)
            break;

        if(nIgnore == 0)
            *(apReturns++) = pReturn;
        else
            nIgnore--;

        void* pNewFrame = *(void**)pFrame;
        if(pNewFrame <= pFrame)
            break;
        pFrame = pNewFrame;
    }

    if(pPrev != NULL)
    {
        memcpy(apReturns, pPrev->m_pPrevStack->m_apReturns, 
                sizeof(void*) * pPrev->m_pPrevStack->GetNumItems());
    }
}

void CStackRecord::Dump(FILE* f) const
{
    fwrite(&m_dwNumItems, sizeof(DWORD), 1, f);
    fwrite(m_apReturns, sizeof(void*), m_dwNumItems, f);
}

BOOL CStackRecord::Read(FILE* f, BOOL bStatic)
{
    if(fread(&m_dwNumItems, sizeof(DWORD), 1, f) == 0)
        return FALSE;

    if(bStatic)
    {
        m_apReturns = (void**)mstatic_apReturns;
        m_bDelete = FALSE;
    }
    else
    {
        m_apReturns = new void*[m_dwNumItems];
        m_bDelete = TRUE;
    }

    return (fread(m_apReturns, sizeof(void*), m_dwNumItems, f) != 0);
}



void CAllocRecord::Dump(FILE* f) const
{
    fwrite(&m_dwTotalAlloc, sizeof(DWORD), 1, f);
    fwrite(&m_dwNumTimes, sizeof(DWORD), 1, f);
    m_Stack.Dump(f);
    DWORD dwNumBuffers = m_apBuffers.Size();
    fwrite(&dwNumBuffers, sizeof(DWORD), 1, f);
    fwrite(m_apBuffers.GetArrayPtr(), sizeof(void*), dwNumBuffers, f);
}

void CAllocRecord::Subtract(CAllocRecord& Other)
{
    m_dwTotalAlloc -= Other.m_dwTotalAlloc;
    m_dwNumTimes -= Other.m_dwNumTimes;
    for(int i = 0; i < m_apBuffers.Size(); i++)
    {
        for(int j = 0; j < Other.m_apBuffers.Size(); j++)
            if(Other.m_apBuffers[j] == m_apBuffers[i])
                break;
        if(j < Other.m_apBuffers.Size())
        {
            m_apBuffers.RemoveAt(i);
            i--;
        }
    }
}

CTls CStackContinuation::mtls_CurrentCont;
CStackContinuation* CStackContinuation::Set(CStackContinuation* pNew)
{
    CStackContinuation* pPrev = (CStackContinuation*)(void*)mtls_CurrentCont;
    mtls_CurrentCont = pNew;
    if(pNew)
    {
        void* p;
        __asm
        {
            mov eax, [ebp]
            mov eax, [eax+4]
            mov p, eax
        }
        pNew->m_pThisStackEnd = p;
    }
    return pPrev;
}
    
CStackContinuation* CStackContinuation::Get()
{
    CStackContinuation* pPrev = (CStackContinuation*)(void*)mtls_CurrentCont;
    return pPrev;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\stackcom.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    STACKCOM.H

Abstract:

    stack implementation.

History:


--*/

#ifndef __WBEM_STACK_COM__H_
#define __WBEM_STACK_COM__H_

template<class T>
struct Ptr
{
	T* m_p;
	Ptr(T* p) : m_p(p){}
	Ptr() : m_p(NULL){}
	Ptr(const Ptr<T>& Other) :m_p(Other.m_p){}
	operator T*() {return m_p;}
	operator const T*() const {return m_p;}
	T* operator->() {return m_p;}
	const T* operator->() const {return m_p;}
	bool operator<(const Ptr<T>& Other) const {return m_p < Other.m_p;}
};

typedef DWORD CAllocationId;

struct POLARITY CStackRecord
{
    DWORD m_dwNumItems;
    void** m_apReturns;
	BOOL m_bDelete;

	static void* mstatic_apReturns[1000];

public:
	CStackRecord() : m_dwNumItems(0), m_apReturns(NULL), m_bDelete(FALSE){}
	CStackRecord(CStackRecord& Parent, DWORD dwNumItems) : 
		m_dwNumItems(dwNumItems), m_apReturns(Parent.m_apReturns), 
		m_bDelete(FALSE)
	{}
	DWORD GetNumItems() const {return m_dwNumItems;}
	void* GetItem(int nIndex) const {return m_apReturns[nIndex];}
	void** GetItems() {return m_apReturns;}
	void** const GetItems() const {return m_apReturns;}

	~CStackRecord();
	void Create(int nIgnore, BOOL bStatic);
	void MakeCopy(CStackRecord& Other);

	int Compare(const CStackRecord& Other) const;
	BOOL operator==(const CStackRecord& Other) const
		{return Compare(Other) == 0;}

	static DWORD GetStackLen();
	static void ReadStack(int nIgnore, void** apBuffer);
	void Dump(FILE* f) const;
	BOOL Read(FILE* f, BOOL bStatid);
	DWORD GetInternal() {return sizeof(void*) * m_dwNumItems;}

public:
	class CLess
	{
	public:
		bool operator()(const CStackRecord* p1, const CStackRecord* p2) const
		{
			return p1->Compare(*p2) < 0;
		}
	};
};

struct CAllocRecord
{
	CStackRecord m_Stack;
    DWORD m_dwTotalAlloc;
	DWORD m_dwNumTimes;
    CFlexArray m_apBuffers;

	CAllocRecord() : m_dwTotalAlloc(0), m_dwNumTimes(0){}
    CAllocRecord(CStackRecord& Stack) : m_dwTotalAlloc(0), m_dwNumTimes(0)
    {
		m_Stack.MakeCopy(Stack);
	}

    void AddAlloc(void* p, DWORD dwAlloc) 
        {m_dwTotalAlloc += dwAlloc; m_dwNumTimes++; m_apBuffers.Add(p);}
    void RemoveAlloc(void* p, DWORD dwAlloc) 
        {m_dwTotalAlloc -= dwAlloc; m_dwNumTimes--; RemoveBuffer(p);}
    void ReduceAlloc(DWORD dwAlloc) {m_dwTotalAlloc -= dwAlloc;}
	void Dump(FILE* f) const;
	DWORD GetInternal() {return sizeof(CAllocRecord) + m_Stack.GetInternal();}
	BOOL IsEmpty() const {return (m_dwTotalAlloc == 0);}

    void RemoveBuffer(void* p)
    {
        for(int i = 0; i < m_apBuffers.Size(); i++)
            if(m_apBuffers[i] == p) {m_apBuffers.RemoveAt(i); return;}
    }

    void Subtract(CAllocRecord& Other);
};

typedef Ptr<CAllocRecord> PAllocRecord;
typedef Ptr<CStackRecord> PStackRecord;

class POLARITY CTls
{
protected:
    DWORD m_dwIndex;
public:
    CTls() {m_dwIndex = TlsAlloc();}
    ~CTls() {TlsFree(m_dwIndex);}
    operator void*() {return (m_dwIndex)?TlsGetValue(m_dwIndex):NULL;}
    void operator=(void* p) {if(m_dwIndex)TlsSetValue(m_dwIndex, p);}
};

struct POLARITY CStackContinuation
{
    CStackRecord* m_pPrevStack;
    void* m_pThisStackEnd;

    static CTls mtls_CurrentCont;

public:
    static CStackContinuation* Set(CStackContinuation* pNew);
    static CStackContinuation* Get();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\strm.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    STRM.CPP

Abstract:

  CMemStream implementation.

  This is a generic data stream for object/interface marshaling.

History:

  a-raymcc    10-Apr-96   Created.
  a-raymcc    06-Jun-96   CArena support.
  a-raymcc    11-Sep-96   Support NULL pointers

--*/

#include "precomp.h"

#include <stdio.h>
#include <string.h>

#include <strm.h>

//***************************************************************************
//
//  CMemStream::CMemStream
//
//  Standard constructor.
//
//  PARAMETERS:
//  nFlags
//      auto_delete or no_delete.  If auto_delete, the internal buffer
//      is automatically deallocated at destruct-time.  If no_delete,
//      it is assumed that another object has acquired the m_pBuffer
//      pointer and will deallocate it with m_pArena->Free().
//  pArena
//      The arena to use for allocation/deallocation.  If NULL, the
//      CWin32DefaultArena is used.
//  nInitialSize
//      The initial size of the stream in bytes.
//  nGrowBy
//      How much to grow the internal buffer by when the caller has written
//      past the end-of-stream.
//
//***************************************************************************
// ok
CMemStream::CMemStream(
    int nFlags,
    CArena *pArena,
    int nInitialSize,
    int nGrowBy
    )
{
    _ASSERT((nInitialSize >= 16), __TEXT("CMemStream: Initial size must be >= 16"));
    
    m_lRef = 0;
    m_nStatus = no_error;

    if (pArena == 0) 
        m_pArena = _new CWin32DefaultArena;
    else 
        m_pArena = pArena;
    m_pArena->AddRef();

    m_pBuffer = (BYTE *) m_pArena->Alloc((DWORD) nInitialSize + 
        sizeof(STREAM_HEADER));
    if (!m_pBuffer)
        m_nStatus = out_of_memory;

    m_dwGrowBy = (DWORD) nGrowBy;
    m_dwSize = nInitialSize;
    m_dwCurrentPos = 0;
    m_nFlags = nFlags;
    m_nStackPtr = -1;
    m_dwEndOfStream = 0;

    // Write the validation header for this new stream.
    // ================================================

    STREAM_HEADER hdr;
    WriteBytes(&hdr, sizeof(STREAM_HEADER));    
}

//***************************************************************************
//
//  CMemStream::CMemStream
//
//  Binding constructor.
//
//***************************************************************************
// ok
CMemStream::CMemStream(
    LPVOID pBindingAddress,
    CArena *pArena,
    int nFlags,
    int nGrowBy
    )
{
    m_nStatus = no_error;
    m_pBuffer = (LPBYTE) pBindingAddress;
    m_pArena = pArena;
    m_pArena->AddRef();
    m_nFlags = nFlags;
    m_lRef = 0;

    // The stream header must be present in the block which
    // is being bound to.
    // ====================================================

    STREAM_HEADER& hdr = *(STREAM_HEADER *) m_pBuffer;

    if (!hdr.Verify()) {
        m_nStatus = failed;
        return;
    }
    
    // Initialize the remaining member variables.
    // ==========================================

    m_dwSize = hdr.dwLength;
    m_dwGrowBy = nGrowBy;
    m_dwCurrentPos = sizeof(hdr);
    m_dwEndOfStream = hdr.dwLength;
    m_nFlags = nFlags;
    m_nStackPtr = -1;
}



//***************************************************************************
//
//  CMemStream::CMemStream
//
//  Copy constructor.
//
//***************************************************************************
// ok
CMemStream::CMemStream(CMemStream &Src)
{
    m_nStatus = 0;
    m_pBuffer = 0;
    m_dwGrowBy = 0;
    m_dwSize = 0;
    m_dwCurrentPos = 0;
    m_nFlags = 0;
    m_nStackPtr = -1;
    m_dwEndOfStream = 0; 
    m_lRef = 0;

    // The assignment operator does not copy the arena
    // so as to allow transfers of stream objects between
    // arenas.  So, we have to set up the arena here.
    // ==================================================
    m_pArena = Src.m_pArena;
    m_pArena->AddRef();

    *this = Src;
}

//***************************************************************************
//
//  CMemStream::operator =
//
//  Note that the arena is not copied as part of the assignment.  This
//  is to allow transfer of objects between arenas.
//
//***************************************************************************
// ok
CMemStream& CMemStream::operator =(CMemStream &Src)
{
    m_nStatus = Src.m_nStatus;
    m_dwSize = Src.m_dwSize;

    if (m_pBuffer)
        m_pArena->Free(m_pBuffer);

    m_pBuffer = (BYTE *) m_pArena->Alloc(m_dwSize);
    if (!m_pBuffer)
        m_nStatus = out_of_memory;
    else
        memcpy(m_pBuffer, Src.m_pBuffer, m_dwSize);

    m_dwGrowBy = Src.m_dwGrowBy;

    m_dwCurrentPos = Src.m_dwCurrentPos;
    m_nFlags = Src.m_nFlags;
    m_nStackPtr = Src.m_nStackPtr;
    m_dwEndOfStream = Src.m_dwEndOfStream;

    return *this;
}


//***************************************************************************
//
//  CMemStream::Deserialize
//
//  This function deserializes a stream from a Win32 file handle.
//  This function only works for files (including memory mapped files, etc.)
/// and pipes.  It will not work for mailslots since they must be read
//  in one operation.
//
//  PARAMETERS:
//  hFile
//      The Win32 file handle.
//
//  RETURN VALUES:
//  failed, out_of_memory, no_error
//
//***************************************************************************
// ok
int CMemStream::Deserialize(HANDLE hFile)
{
    Reset();    

    // Read the header.  Note that we read this separately
    // first before the stream proper.  This is because we
    // don't know how much memory to allocate until we have
    // read the header.
    // ====================================================

    STREAM_HEADER &hdr = *(STREAM_HEADER *) m_pBuffer;
    BOOL bRes;
    DWORD dwRead;

    bRes = ReadFile(hFile, &hdr, sizeof(hdr), &dwRead, 0);
    if (!bRes || dwRead != sizeof(hdr))
    {
        DWORD t_LastError = GetLastError () ;
        return failed;
    }
    if (!hdr.Verify())
        return failed;

    DWORD t_ReadLength = hdr.dwLength;

    // Read the rest.
    // ===============
    if (Resize(hdr.dwLength))
        return out_of_memory;

    BYTE *t_ReadPosition = m_pBuffer + sizeof ( hdr ) ;
    DWORD t_Remainder = m_dwSize - dwRead ;

    while ( t_Remainder )
    {
        bRes = ReadFile(hFile, t_ReadPosition , t_Remainder, &dwRead, 0);
        if (!bRes )
            return failed;

        t_Remainder = t_Remainder - dwRead ;
        t_ReadPosition = t_ReadPosition + dwRead ;
    }

    m_dwEndOfStream = t_ReadLength;

    return no_error;
}

//***************************************************************************
//
//  CMemStream::Deserialize
//
//  This function deserializes a stream from an ANSI C file object.
//
//  PARAMETERS:
//  fStream
//      The ANSI C file object.
//
//  RETURN VALUES:
//  failed, out_of_memory, no_error
//
//***************************************************************************
// ok
int CMemStream::Deserialize(FILE *fStream)
{
    Reset();

    STREAM_HEADER &hdr = *(STREAM_HEADER *) m_pBuffer;
    
    if (1 != fread(&hdr, sizeof(STREAM_HEADER), 1, fStream))
        return failed;
    if (!hdr.Verify())
        return failed;
        
    if (Resize(hdr.dwLength) != no_error)
        return out_of_memory;

    DWORD dwRemainder = m_dwSize - sizeof(hdr);
    
    if (dwRemainder != fread(m_pBuffer + sizeof(hdr), sizeof(BYTE), 
        dwRemainder, fStream))
        return failed;

    m_dwEndOfStream = hdr.dwLength;

    return no_error;
}

//***************************************************************************
//
//  CMemStream::Deserialize
//
//  This function deserializes a stream from a memory block.
//
//  PARAMETERS:
//  pBlock
//      The memory block.
//  dwSize
//      The size of the memory block.
//
//  RETURN VALUES:
//  failed, no_error
//
//***************************************************************************

int CMemStream::Deserialize(LPBYTE pBlock, DWORD dwSize)
{
    Reset();

    STREAM_HEADER *pHdr = (STREAM_HEADER *) pBlock;

    if (!pHdr->Verify())
        return failed;

    Resize(pHdr->dwLength);

    memcpy(
        m_pBuffer,
        pBlock,
        pHdr->dwLength
        );

    m_dwEndOfStream = pHdr->dwLength;

    return no_error;
}

//***************************************************************************
//
//  CMemStream::Resize
//
//  Increases the size of the internal buffer.  Does not affect the
//  current offset or end-of-stream markers.
//
//  RETURN VALUES:
//  no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::Resize(DWORD dwNewSize)
{
    m_pBuffer = (BYTE *) m_pArena->Realloc(m_pBuffer, dwNewSize + 
        sizeof(STREAM_HEADER));

    if (!m_pBuffer) {
        m_nStatus = out_of_memory;
        return m_nStatus;
    }

    STREAM_HEADER& hdr = *(STREAM_HEADER *) m_pBuffer;
    hdr.dwSignature = SIGNATURE_STREAM ;
    hdr.dwLength = dwNewSize + sizeof ( STREAM_HEADER ) ;

    m_dwSize = dwNewSize;
    return no_error;
}

//***************************************************************************
//
//  CMemStream::Serialize
//
//  Writes the object to a Win32 file.
//
//  PARAMETERS:
//  hFile
//      The Win32 file handle to which to write the object.
//
//  RETURN VALUES:
//  failed, no_error
//
//***************************************************************************
// ok
int CMemStream::Serialize(HANDLE hFile)
{
    UpdateHdr();
    
    // Write body of stream.  This includes the header.
    // ================================================

    DWORD dwWritten = 0;
    BOOL bRes = WriteFile(hFile, m_pBuffer, m_dwEndOfStream, &dwWritten, 0);
    if (!bRes || m_dwEndOfStream != dwWritten)
        return failed;

    return no_error;
}

//***************************************************************************
//
//  CMemStream::Serialize
//
//  Serializes the entire stream to the specified FILE object, which
//  must have been opened in binary mode for writing.
//
//  PARAMETERS:
//  fStream
//      The ANSI C FILE object to which to write the object.
//
//  RETURN VALUE:
//  no_error, failed
//
//***************************************************************************
// ok

int CMemStream::Serialize(FILE *fStream)
{
    UpdateHdr();
    
    // Write body of stream.
    // =====================

    int nRes = fwrite(m_pBuffer, sizeof(BYTE), m_dwEndOfStream, fStream);
    if (nRes != (int) m_dwEndOfStream)
        return failed;

    return no_error;
}


//***************************************************************************
//
//  CMemStream::Serialize
//
//  Serializes the entire object to a memory block which is allocated
//  with HeapAlloc using the default process heap. The caller must call
//  FreeMem() when the block is no longer needed.
//
//  PARAMETERS:
//  pBlock
//      Should point to NULL on entry and will be assigned to point to the
//      new memory block containing the serialized form of the object.
//      The receiver must call FreeMem() using the default process heap
//      when this block is no longer needed.
//  pdwSize
//      Points to a DWORD which will be set to the size in bytes
//      of the returned memory block.
//
//  RETURN VALUES:
//  out_of_memory, no_error
//
//***************************************************************************

int CMemStream::Serialize(BYTE **pBlock, DWORD *pdwSize, CArena *pArena)
{
    UpdateHdr();
    if (!pArena)
        pArena = m_pArena;

    LPVOID pMem = pArena->Alloc(m_dwEndOfStream);            
    if (!pMem)
        return out_of_memory;
        
    memcpy(pMem, m_pBuffer, m_dwEndOfStream);
    *pBlock = (BYTE *) pMem;
    *pdwSize = m_dwEndOfStream;
    
    return no_error;
}


//***************************************************************************
//
//  CMemStream::Append
//
//  Appends one CMemStream object onto the end of the current one.
//  When deserialization occurs, the stream will appear as one large object;
//  the original number of appended objects is lost information.
//
//  PARAMETERS:
//  pSubStream
//      The stream which needs to be appended to 'this' object.
//
//  RETURN VALUES:
//  no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::Append(CMemStream *pSubstream)
{
    DWORD dwNumBytesToCopy =  pSubstream->m_dwEndOfStream - sizeof(STREAM_HEADER);

    if (no_error != Resize(m_dwEndOfStream + dwNumBytesToCopy))
        return out_of_memory;

    memcpy(&m_pBuffer[m_dwEndOfStream], 
        pSubstream->m_pBuffer + sizeof(STREAM_HEADER),
        dwNumBytesToCopy
        );

    m_dwEndOfStream += dwNumBytesToCopy;
    m_dwCurrentPos = m_dwEndOfStream;

    return no_error;
}

// SAFE AREA

//***************************************************************************
//
//  CMemStream::WriteBlob
//
//  Return values:
//      no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::WriteBlob(BLOB *pBlob)
{
    int nRes;
    nRes = WriteType(VT_BLOB);
    if (nRes) return nRes;

    DWORD dwSize = BlobLength(pBlob);
    if (WriteBytes(&dwSize, sizeof(DWORD)) != no_error)
        return out_of_memory;
    if (WriteBytes(BlobDataPtr(pBlob), dwSize) != no_error)
        return out_of_memory;

    return no_error;
}


//***************************************************************************
//
//  CMemStream::WriteDouble
//
//  Return values:
//      no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::WriteDouble(double dblVal)
{
    int nRes;
    nRes = WriteType(VT_R8);
    if (nRes) return nRes;
    nRes = WriteBytes(&dblVal, sizeof(double));
    return nRes;
}


//***************************************************************************
//
//  CMemStream::WriteFloat
//
//  Return values:
//      no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::WriteFloat(float fltVal)
{
    int nRes;
    nRes = WriteType(VT_R4);
    if (nRes) return nRes;
    nRes = WriteBytes(&fltVal, sizeof(float));
    return nRes;
}


//***************************************************************************
//
//  CMemStream::WriteFloat
//
//  Return values:
//      no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::WriteBool(VARIANT_BOOL bVal)
{
    int nRes;
    nRes = WriteType(VT_BOOL);
    if (nRes) return nRes;
    nRes = WriteBytes(&bVal, sizeof(VARIANT_BOOL));
    return nRes;
}


//***************************************************************************
//
//  CMemStream::WriteByte
//
//  Return values:
//      no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::WriteByte(BYTE b)
{
    int nRes;
    nRes = WriteType(VT_UI1);
    if (nRes) return nRes;
    nRes = WriteBytes(&b, sizeof(BYTE));
    return nRes;
}

//***************************************************************************
//
//  CMemStream::WriteChar
//
//  Return values:
//      no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::WriteChar(char c)
{
    int nRes;
    nRes = WriteType(VT_I1);
    if (nRes) return nRes;
    nRes = WriteBytes(&c, sizeof(char));
    return nRes;
}

//***************************************************************************
//
//  CMemStream::WriteLong
//
//  Return values:
//      no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::WriteLong(LONG l)
{
    int nRes;
    nRes = WriteType(VT_I4);
    if (nRes) return nRes;
    nRes = WriteBytes(&l, sizeof(LONG));
    return nRes;
}

//***************************************************************************
//
//  CMemStream::WriteDWORD
//
//  Return values:
//      no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::WriteDWORD(DWORD dwVal)
{
    int nRes;
    nRes = WriteType(VT_UI4);
    if (nRes) return nRes;
    nRes = WriteBytes(&dwVal, sizeof(DWORD));
    return nRes;
}


//***************************************************************************
//
//  CMemStream::WriteDWORD
//
//  Return values:
//      no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::WriteWORD(WORD wVal)
{
    int nRes;
    nRes = WriteType(VT_UI2);
    if (nRes) return nRes;
    nRes = WriteBytes(&wVal, sizeof(WORD));
    return nRes;
}

//***************************************************************************
//
//  CMemStream::WriteShort
//
//  Return values:
//      no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::WriteShort(SHORT iVal)
{
    int nRes;
    nRes = WriteType(VT_I2);
    if (nRes) return nRes;
    nRes = WriteBytes(&iVal, sizeof(SHORT));
    return nRes;
}

//***************************************************************************
//
//  CMemStream::WriteLPSTR
//
//  Return values:
//      no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::WriteLPSTR(LPSTR pStr)
{
    int nRes;
    nRes = WriteType(VT_LPSTR);
    if (nRes) return nRes;

    if (pStr)
    {
        DWORD dwLen = strlen(pStr);
        nRes = WriteBytes(&dwLen, sizeof(DWORD));
        if (nRes) return nRes;

        nRes = WriteBytes(pStr, strlen(pStr) + 1);
    }
    // Null pointers are encoded as 0xFFFFFFFF for the string length.
    // ==============================================================
    else 
    {
        DWORD dwNullEncoding = 0xFFFFFFFF;
        nRes = WriteBytes(&dwNullEncoding, sizeof(DWORD));
    }        
            
    return nRes;
}

//***************************************************************************
//
//  CMemStream::WriteLPWSTR
//
//  Return values:
//      no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::WriteLPWSTR(LPWSTR pStr)
{
    int nRes;
    nRes = WriteType(VT_LPWSTR);
    if (nRes) return nRes;
    
    // If a non-NULL pointer, the length prefixes the string data.
    // ============================================================
    if (pStr)
    {
        DWORD dwLen = wcslen(pStr);
        nRes = WriteBytes(&dwLen, sizeof(DWORD));
        if (nRes) return nRes;
        nRes = WriteBytes(pStr, (wcslen(pStr) + 1) * 2);
    }
    // Null pointers are encoded as 0xFFFFFFFF for the string length.
    // ==============================================================
    else 
    {
        DWORD dwNullEncoding = 0xFFFFFFFF;
        nRes = WriteBytes(&dwNullEncoding, sizeof(DWORD));
    }        

            
    return nRes;
}

//***************************************************************************
//
//  CMemStream::WriteBSTR
//
//  Return values:
//      no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::WriteBSTR(BSTR pStr)
{
    int nRes;
    nRes = WriteType(VT_BSTR);
    if (nRes) return nRes;
    if (pStr)
    {
        DWORD dwLen = wcslen(pStr);
        nRes = WriteBytes(&dwLen, sizeof(DWORD));
        if (nRes) return nRes;
        nRes = WriteBytes(pStr, (wcslen(pStr) + 1) * 2);
    }
    // NULL pointers are encoded as 0xFFFFFFFF for the length prefix.
    // ==============================================================
    else 
    {
        DWORD dwNullEncoding = 0xFFFFFFFF;
        nRes = WriteBytes(&dwNullEncoding, sizeof(DWORD));
    }        

    return nRes;
}

//***************************************************************************
//
//  CMemStream::WriteCLSID
//
//  Return values:
//      no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::WriteCLSID(CLSID *pClsId)
{
    int nRes;
    nRes = WriteType(VT_CLSID);
    if (nRes) return nRes;
    return WriteBytes(pClsId, sizeof(CLSID));
}

//***************************************************************************
//
//  CMemStream::WriteCLSID
//
//  Serializes the literal value of a pointer.
//
//  Return values:
//      no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::WriteUnknown(IUnknown *pObj)
{
    int nRes;
    nRes = WriteType(VT_UNKNOWN);
    if (nRes) return nRes;
    return WriteBytes(pObj, sizeof(void *));
}


//***************************************************************************
//
//  CMemStream::WriteFILETIME
//
//  Return values:
//      no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::WriteFILETIME(FILETIME *pTime)
{
    int nRes;
    nRes = WriteType(VT_FILETIME);
    if (nRes) return nRes;
    nRes = WriteBytes(pTime, sizeof(FILETIME));
    return nRes;
}

//***************************************************************************
//
//  CMemStream::WriteCVar
//
//  Writes a CVar into the stream.
//
//  PARAMETERS:
//  pObj
//      Points to the CVar object to serialize.  The CVar can contains
//      an embedded CVarVector array which itself consists of arbitrary
//      CVar objects.
//
//  RETURN VALUES:
//  critical_error (unsupported type)
//  no_error
//  invalid_parameter
//  out_of_memory  (returned by embedded calls)
//
//***************************************************************************
// ok
int CMemStream::WriteCVar(CVar *pObj)
{
    if (!pObj)
        return invalid_parameter;

    // Write the CVar type indicator for the deserialization.
    // =======================================================

    int nRes = WriteType(VT_EX_CVAR);
    int nType = pObj->GetType();

    // Write out the field.
    // ====================

    switch (nType) {
        case VT_EMPTY:
        case VT_NULL: return WriteNull();

        case VT_I1:   return WriteChar(pObj->GetChar());
        case VT_UI1:  return WriteByte(pObj->GetByte());
        case VT_I2:   return WriteShort(pObj->GetShort());
        case VT_UI2:  return WriteWORD(pObj->GetWord());
        case VT_I4:   return WriteLong(pObj->GetLong());
        case VT_UI4:  return WriteDWORD(pObj->GetDWORD());
        case VT_BOOL: return WriteBool(pObj->GetBool());
        case VT_R4:   return WriteFloat(pObj->GetFloat());
        case VT_R8:   return WriteDouble(pObj->GetDouble());

        case VT_LPSTR:  return WriteLPSTR(pObj->GetLPSTR());
        case VT_LPWSTR: return WriteLPWSTR((LPWSTR) pObj->GetLPWSTR());

        case VT_BSTR:   return WriteBSTR((LPWSTR) pObj->GetLPWSTR());
            // Intentional type mismatch on pObj->GetLPWSTR
            // so we don't have to get a new BSTR and deallocate it.
            // CVar stores BSTR as LPWSTR internally, so this is ok.

        case VT_FILETIME:
            {
                FILETIME ft = pObj->GetFileTime();
                WriteFILETIME(&ft);
                return no_error;
            }

        case VT_BLOB:    return WriteBlob((BLOB *) pObj->GetBlob());
        case VT_CLSID:   return WriteCLSID((CLSID *) pObj->GetClsId());
        case VT_EX_CVARVECTOR: return WriteCVarVector((CVarVector *) pObj->GetVarVector());
    }

    return critical_error;
}

//***************************************************************************
//
//  CMemStream::WriteCVarVector
//
//  Write the incoming CVarVector to the stream.  For efficiency,
//  the type indicator is not repeated for each element.  However, each
//  element can be another embedded VT_EX_CVAR type.
//
//  PARAMETERS:
//  pVec
//      The pointer to the CVarVector object to serialize.
//  RETURN VALUE:
//  no_error, invalid_parameter, out_of_memory, critical_error
//
//***************************************************************************
// ok
int CMemStream::WriteCVarVector(IN CVarVector *pVec)
{
    if (!pVec)
        return invalid_parameter;

    // Write the CVarVector type indicator for the deserialization.
    // ============================================================

    if (WriteType(VT_EX_CVARVECTOR) != no_error)
        return out_of_memory;

    // Write the element type.
    // =======================

    int nElementType = pVec->GetType();

    if (WriteType(nElementType) != no_error)
        return out_of_memory;

    // Write out the vector length.
    // ============================

    DWORD dwSize = (DWORD) pVec->Size();
    int nRes = WriteBytes(&dwSize, sizeof(DWORD));

    // Write out the elements.
    // =======================

    for (int i = 0; i < pVec->Size(); i++) {
        CVar& v = pVec->GetAt(i);

        switch (pVec->GetType()) {
            case VT_EX_CVARVECTOR:
                if (WriteCVarVector((CVarVector *) v.GetVarVector()) != no_error)
                    return out_of_memory;
                break;

            case VT_EX_CVAR:
                if (WriteCVar(&v) != no_error)
                    return out_of_memory;
                break;

            case VT_I1:
                {
                    char c = v.GetChar();
                    if (WriteBytes(&c, sizeof(char)) != no_error)
                        return out_of_memory;
                    break;
                }

            case VT_UI1:
                {
                    BYTE b = v.GetByte();
                    if (WriteBytes(&b, sizeof(BYTE)) != no_error)
                        return out_of_memory;
                    break;
                }

            case VT_I2:
                {
                    SHORT i = v.GetShort();
                    if (WriteBytes(&i, sizeof(SHORT)) != no_error)
                        return out_of_memory;
                    break;
                }

            case VT_UI2:
                {
                    WORD w = v.GetWord();
                    if (WriteBytes(&w, sizeof(WORD)) != no_error)
                        return out_of_memory;
                    break;
                }

            case VT_I4:
                {
                    LONG l = v.GetLong();
                    if (WriteBytes(&l, sizeof(LONG)) != no_error)
                        return out_of_memory;
                    break;
                }

            case VT_UI4:
                {
                    DWORD dw = v.GetDWORD();
                    if (WriteBytes(&dw, sizeof(DWORD)) != no_error)
                        return out_of_memory;
                    break;
                }

            case VT_BOOL:
                {
                    VARIANT_BOOL b = v.GetBool();
                    if (WriteBytes(&b, sizeof(VARIANT_BOOL)) != no_error)
                        return out_of_memory;
                    break;
                }

            case VT_R4:
                {
                    float f = v.GetFloat();
                    if (WriteBytes(&f, sizeof(float)) != no_error)
                        return out_of_memory;
                    break;
                }

            case VT_R8:
                {
                    double d = v.GetDouble();
                    if (WriteBytes(&d, sizeof(double)) != no_error)
                        return out_of_memory;
                    break;
                }


            // NOTES: String types are written with a prefixed with
            // a DWORD length indicator so that during deserialization
            // the correct buffer length can be allocated before the
            // string is read back.  The length indicator is in characters,
            // not bytes.

            case VT_LPSTR:
                {
                    LPSTR pStr = v.GetLPSTR();
                    DWORD dwLength = strlen(pStr) + 1;
                    if (WriteBytes(&dwLength, sizeof(DWORD)) != no_error)
                        return out_of_memory;
                    if (WriteBytes(pStr, dwLength) != no_error)
                        return out_of_memory;
                    break;
                }

            case VT_LPWSTR:
                {
                    LPWSTR pStr = v.GetLPWSTR();
                    DWORD dwLength = wcslen(pStr) + 1;
                    if (WriteBytes(&dwLength, sizeof(DWORD)) != no_error)
                        return out_of_memory;
                    if (WriteBytes(pStr, dwLength * 2) != no_error)
                        return out_of_memory;
                    break;
                }

            case VT_BSTR:
                {
                    // Even though the type is BSTR, we request as
                    // an LPWSTR so as to avoid the lost time of calling
                    // SysAllocString/SysFreeString, etc.
                    LPWSTR pStr = v.GetLPWSTR();
                    DWORD dwLength = wcslen(pStr) + 1;
                    if (WriteBytes(&dwLength, sizeof(DWORD)) != no_error)
                        return out_of_memory;
                    if (WriteBytes(pStr, dwLength * 2) != no_error)
                        return out_of_memory;
                    break;
                }

            case VT_FILETIME:
                {
                    FILETIME ft = v.GetFileTime();
                    if (WriteBytes(&ft, sizeof(FILETIME)) != no_error)
                        return out_of_memory;
                    break;
                }

            case VT_BLOB:
                {
                    BLOB *p = v.GetBlob();
                    DWORD dwLen = BlobLength(p);
                    if (WriteBytes(&dwLen, sizeof(DWORD)) != no_error)
                        return out_of_memory;
                    if (WriteBytes(BlobDataPtr(p), dwLen) != no_error)
                        return out_of_memory;
                    break;
                }

            case VT_CLSID:
                {
                    CLSID *p = v.GetClsId();
                    if (WriteBytes(p, sizeof(CLSID)) != no_error)
                        return out_of_memory;
                    break;
                }

            // This should never execute.
            default:
                return critical_error;
        }
    }

    return no_error;
}


//***************************************************************************
//
//  CMemStream::ReadNull
//
//  Return values:
//      end_of_stream, type_mismatch, no_error
//
//***************************************************************************
// ok
int CMemStream::ReadNull()
{
    int nRes = ReadType();
    if (nRes == VT_EMPTY)
        return end_of_stream;
    else if (nRes != VT_NULL)
        return type_mismatch;
    return no_error;
}

//***************************************************************************
//
//  CMemStream::ReadBytes
//
//  Return value:
//      no_error, end_of_stream
//
//***************************************************************************
// ok
int CMemStream::ReadBytes(LPVOID pBlock, DWORD dwLength)
{
    if (dwLength + m_dwCurrentPos > m_dwEndOfStream) {
        m_dwCurrentPos = m_dwEndOfStream;
        return end_of_stream;
    }

    memcpy(pBlock, &m_pBuffer[m_dwCurrentPos], dwLength);
    m_dwCurrentPos += dwLength;

    return no_error;
}

//***************************************************************************
//
//  CMemStream::WriteBytes
//
//  Writes the specified bytes at the current offset. The
//  end-of-stream marker is unchanged, unless the current position
//  has been advanced beyond the previous end-of-stream marker by
//  the write.  In the latter case, the end-of-stream marker is
//  set to the byte immediately after the write.
//
//  Return values:
//      no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::WriteBytes(LPVOID pBlock, DWORD dwLength)
{
    while (m_dwCurrentPos + dwLength > m_dwSize) {
        m_dwSize += m_dwGrowBy;
        if (Resize(m_dwSize) != no_error)
            return out_of_memory;
    }

    memcpy(&m_pBuffer[m_dwCurrentPos], pBlock, dwLength);
    m_dwCurrentPos += dwLength;

    // Reset the end of stream pointer if we have grown 
    if (m_dwCurrentPos > m_dwEndOfStream)
        m_dwEndOfStream = m_dwCurrentPos;
    return no_error;
}

//***************************************************************************
//
//  Macro TYPE_CHECK
//
//  Checks that the next value in the stream is a type indicator which
/// matches the current type.
//
//  Returns end_of_stream or type_mismatch on errors.
//  On error, the current stream pointer is set back to where it was
//  on entry.  It is only allowed to advance on success.
//
//***************************************************************************

#define TYPE_CHECK(vt)          \
    {                           \
    Push();                     \
    int nType = ReadType();     \
    if (nType == VT_EMPTY) {    \
        Pop(FALSE);             \
        return end_of_stream;   \
    }                           \
    if (nType != vt)          { \
        Pop(FALSE);             \
        return type_mismatch;   \
    }                           \
    Pop(TRUE);                  \
    }


//***************************************************************************
//
//  CMemStream::ReadBlob
//
//  Reads a BLOB and dynamically allocates buffer to hold it. The caller
//  must call FreeMem to free the memory block.
//
//  Parameters:
//      pBytes
//          A pointer to the user's pointer, which should point to NULL
//          on entry. This will be assigned to point to the new block.
//      pdwSize
//          Points to a DWORD which will be assigned to the size of the
//          returned block.
//
//  Return values:
//      end_of_stream,  type_mismatch, no_error
//
//***************************************************************************
// ok
int CMemStream::ReadBlob(BLOB *pBlob)
{
    TYPE_CHECK(VT_BLOB);

    DWORD dwSize = 0;
    int nRes = ReadBytes(&dwSize, sizeof(DWORD));
    if (nRes != no_error)
        return nRes;

    LPVOID pBlock = _new BYTE[dwSize];
    if (pBlock == NULL)
        return out_of_memory;

    nRes = ReadBytes(pBlock, dwSize);
    if (nRes != no_error)
        return end_of_stream;

    pBlob->cbSize = dwSize;
    pBlob->pBlobData = (BYTE *) pBlock;

    return no_error;
}


//***************************************************************************
//
//  CMemStream::ReadDouble
//
//  Return values:
//      no_error, end_of_stream
//
//***************************************************************************
// ok
int CMemStream::ReadDouble(double *pdblVal)
{
    TYPE_CHECK(VT_R8);
    return ReadBytes(pdblVal, sizeof(double));
}

//***************************************************************************
//
//  CMemStream::ReadByte
//
//  Return values:
//      no_error, end_of_stream
//
//***************************************************************************
// ok
int CMemStream::ReadByte(BYTE *pByte)
{
    TYPE_CHECK(VT_UI1);
    return ReadBytes(pByte, sizeof(BYTE));
}

//***************************************************************************
//
//  CMemStream::ReadFloat
//
//  Return values:
//      no_error, end_of_stream
//
//***************************************************************************
// ok
int CMemStream::ReadFloat(float *pfltVal)
{
    TYPE_CHECK(VT_R4);
    return ReadBytes(pfltVal, sizeof(float));
}

//***************************************************************************
//
//  CMemStream::ReadFloat
//
//  Return values:
//      no_error, end_of_stream
//
//***************************************************************************
// ok
int CMemStream::ReadBool(VARIANT_BOOL *pBool)
{
    TYPE_CHECK(VT_BOOL);
    return ReadBytes(pBool, sizeof(VARIANT_BOOL));
}

//***************************************************************************
//
//  CMemStream::ReadWORD
//
//  Return values:
//      no_error, end_of_stream
//
//***************************************************************************
// ok
int CMemStream::ReadWORD(WORD *pw)
{
    TYPE_CHECK(VT_UI2);
    return ReadBytes(pw, sizeof(WORD));
}

//***************************************************************************
//
//  CMemStream::ReadChar
//
//  Return values:
//      no_error, end_of_stream
//
//***************************************************************************
// ok
int CMemStream::ReadChar(char *pc)
{
    TYPE_CHECK(VT_I1);
    return ReadBytes(pc, sizeof(char));
}


//***************************************************************************
//
//  CMemStream::ReadLong
//
//***************************************************************************
// ok
int CMemStream::ReadLong(LONG *plVal)
{
    TYPE_CHECK(VT_I4);
    return ReadBytes(plVal, sizeof(LONG));
}

//***************************************************************************
//
//  CMemStream::ReadDWORD
//
//***************************************************************************
// ok
int CMemStream::ReadDWORD(DWORD *pdwVal)
{
    TYPE_CHECK(VT_UI4);
    return ReadBytes(pdwVal, sizeof(DWORD));
}

//***************************************************************************
//
//  CMemStream::ReadShort
//
//***************************************************************************
// ok
int CMemStream::ReadShort(SHORT *piVal)
{
    TYPE_CHECK(VT_I2);
    return ReadBytes(piVal, sizeof(SHORT));
}

//***************************************************************************
//
//  CMemStream::ReadLPSTR
//
//***************************************************************************
// ok
int CMemStream::ReadLPSTR(LPSTR *pStr)
{
    TYPE_CHECK(VT_LPSTR);
    DWORD dwLength = 0;
    int nRes = ReadBytes(&dwLength, sizeof(DWORD));
    if (nRes)
        return nRes;

    // Check for encoded NULL pointer.
    // ===============================        
    if (dwLength == 0xFFFFFFFF)
    {
        *pStr = 0;
        return no_error;
    }

    // If here, there is at least a string of some kind,
    // possibly zero length.
    // ==================================================
                    
    *pStr = _new char[dwLength + 1];
    nRes = ReadBytes(*pStr, dwLength + 1);  // Include read of NULL
    if (nRes != no_error)
        return nRes;
    return no_error;
}

//***************************************************************************
//
//  CMemStream::ReadLPWSTR
//
//***************************************************************************
// ok
int CMemStream::ReadLPWSTR(LPWSTR *pStr)
{
    TYPE_CHECK(VT_LPWSTR);

    DWORD dwLength = 0;
    int nRes = ReadBytes(&dwLength, sizeof(DWORD));
    if (nRes)
        return nRes;

    // Check for encoded NULL pointer.
    // ===============================        
    if (dwLength == 0xFFFFFFFF)
    {
        *pStr = 0;
        return no_error;
    }

    // If here, there is at least a string of some kind,
    // possibly zero length.
    // ==================================================
    
    *pStr = _new wchar_t[dwLength + 1];
    nRes = ReadBytes(*pStr, (dwLength + 1) * 2);
    if (nRes != no_error)
        return nRes;

    return no_error;
}

//***************************************************************************
//
//  CMemStream::ReadBSTR
//
//***************************************************************************
// ok
int CMemStream::ReadBSTR(BSTR *pStr)
{
    *pStr = 0;

    TYPE_CHECK(VT_BSTR);

    DWORD dwLength = 0;
    int nRes = ReadBytes(&dwLength, sizeof(DWORD));
    if (nRes)
        return nRes;

    // Check for encoded NULL pointer.
    // ===============================        
    if (dwLength == 0xFFFFFFFF)
    {
        *pStr = 0;
        return no_error;
    }

    // If here, there is at least a string of some kind,
    // possibly zero length.
    // ==================================================

    wchar_t* pTemp = _new wchar_t[dwLength + 1];
    nRes = ReadBytes(pTemp, (dwLength + 1) * 2);
    if (nRes != no_error)
        return nRes;

    *pStr = SysAllocString(pTemp);
    delete pTemp;

    return no_error;
}

//***************************************************************************
//
//  CMemStream::ReadCLSID
//
//***************************************************************************
// ok
int CMemStream::ReadCLSID(CLSID *pClsId)
{
    TYPE_CHECK(VT_CLSID);
    return ReadBytes(pClsId, sizeof(CLSID));
}


//***************************************************************************
//
//  CMemStream::ReadUnknown
//
//***************************************************************************
// ok
int CMemStream::ReadUnknown(IUnknown **pObj)
{
    TYPE_CHECK(VT_UNKNOWN);
    return ReadBytes(*pObj, sizeof(LPVOID));
}

//***************************************************************************
//
//  CMemStream::ReadFILETIME
//
//  Reads a Win32 FILETIME struct.
//
//***************************************************************************
// ok
int CMemStream::ReadFILETIME(OUT FILETIME *pTime)
{
    TYPE_CHECK(VT_FILETIME);
    return ReadBytes(pTime, sizeof(FILETIME));
}


//***************************************************************************
//
//  CMemStream::Read
//
//  Reads a CVar from the stream.
//
//  RETURN VALUES:
//  no_error
//  end_of_stream
//
//***************************************************************************
// ok
int CMemStream::ReadCVar(OUT CVar **pObj)
{
    TYPE_CHECK(VT_EX_CVAR);

    // Now read the internal type of the CVar. We read ahead, and then
    // move the current pointer back so that subsequent calls to
    // deserialize the typed value will work properly (they all need
    // the type prefixes).
    // ================================================================

    CVar *pVar = _new CVar;

    DWORD dwPos = GetCurrentPos();
    int nVarType = ReadType();
    int nErrorCode = no_error;
    SetCurrentPos(dwPos);

    switch (nVarType) {
        case VT_EMPTY:
        case VT_NULL:
            pVar->SetAsNull();
            break;

        case VT_I1:
            {
                char c = 0;
                if (ReadChar(&c) != no_error) {
                    nErrorCode = end_of_stream;
                }
                else
                    pVar->SetChar(c);
            }
            break;

        case VT_UI1:
            {
                BYTE b = 0;
                if (ReadByte(&b) != no_error) {
                    nErrorCode = end_of_stream;
                }
                else
                    pVar->SetByte(b);
            }
            break;

        case VT_I2:
            {
                SHORT i = 0;
                if (ReadShort(&i) != no_error) {
                    nErrorCode = end_of_stream;
                }
                else
                    pVar->SetShort(i);
            }
            break;

        case VT_UI2:
            {
                WORD w = 0;
                if (ReadWORD(&w) != no_error) {
                    nErrorCode = end_of_stream;
                }
                else
                    pVar->SetWord(w);
            }
            break;

        case VT_I4:
            {
                LONG l = 0;
                if (ReadLong(&l) != no_error) {
                    nErrorCode = end_of_stream;
                }
                else
                    pVar->SetLong(l);
            }
            break;

        case VT_UI4:
            {
                DWORD dw = 0;
                if (ReadDWORD(&dw) != no_error) {
                    nErrorCode = end_of_stream;
                }
                else
                    pVar->SetDWORD(dw);
            }
            break;

        case VT_BOOL:
            {
                VARIANT_BOOL b = 0;
                if (ReadBool(&b) != no_error) {
                    nErrorCode = end_of_stream;
                }
                else
                    pVar->SetBool(b);
            }
            break;

        case VT_R4:
            {
                float f = (float) 0.0;
                if (ReadFloat(&f) != no_error) {
                    nErrorCode = end_of_stream;
                }
                else
                    pVar->SetFloat(f);
            }
            break;

        case VT_R8:
            {
                double d = 0.0;
                if (ReadDouble(&d) != no_error) {
                    nErrorCode = end_of_stream;
                }
                else
                    pVar->SetDouble(d);
            }
            break;

        case VT_LPSTR:
            {
                LPSTR pStr = 0;
                if (ReadLPSTR(&pStr) != no_error) {
                    nErrorCode = end_of_stream;
                }
                else
                    pVar->SetLPSTR(pStr, TRUE);
            }
            break;

        case VT_LPWSTR:
            {
                LPWSTR pStr = 0;
                if (ReadLPWSTR(&pStr) != no_error) {
                    nErrorCode = end_of_stream;
                }
                else
                    pVar->SetLPWSTR(pStr, TRUE);
            }
            break;


        case VT_BSTR:
            {
                BSTR Str = 0;
                if (ReadBSTR(&Str) != no_error) {
                    nErrorCode = end_of_stream;
                }
                else {
                    pVar->SetBSTR(Str, FALSE);
                    SysFreeString(Str);
                }
            }
            break;

        case VT_FILETIME:
            {
                FILETIME f = {0};
                if (ReadFILETIME(&f) != no_error) {
                    nErrorCode = end_of_stream;
                }
                else
                    pVar->SetFileTime(&f);
            }
            break;

        case VT_BLOB:
            {
                BLOB b;
                BlobInit(&b);
                if (ReadBlob(&b) != no_error)
                    nErrorCode = end_of_stream;
                else
                    pVar->SetBlob(&b, TRUE);
            }
            break;

        case VT_CLSID:
            {
                CLSID ClsId = {0};
                if (ReadCLSID(&ClsId) != no_error)
                    nErrorCode = end_of_stream;
                else
                    pVar->SetClsId(&ClsId, FALSE);
            }
            break;

        case VT_EX_CVARVECTOR:
            {
                CVarVector *pVec = 0;
                if (ReadCVarVector(&pVec) != no_error)
                    nErrorCode = end_of_stream;
                else
                    pVar->SetVarVector(pVec, TRUE);
            }
            break;
    }

    if (nErrorCode != no_error)
        delete pVar;
    else
        *pObj = pVar;

    return nErrorCode;
}

//***************************************************************************
//
//  CMemStream::ReadCVarVector
//
//
//***************************************************************************
// ok
int CMemStream::ReadCVarVector(CVarVector **pObj)
{
    *pObj = 0;

    TYPE_CHECK(VT_EX_CVARVECTOR);

    // Read the element type.
    // ======================

    DWORD dwPos = GetCurrentPos();
    int nType = ReadType();
    CVarVector *pVec = _new CVarVector(nType);

    // Read the size of the vector.
    // ============================
    DWORD dwVecSize = 0;
    if (ReadBytes(&dwVecSize, sizeof(DWORD)) != no_error)
        return end_of_stream;

    // Read each element.
    // ==================

    for (DWORD dwIx = 0; dwIx < dwVecSize; dwIx++) {
        switch (nType) {
            case VT_EX_CVARVECTOR:
                {
                    CVarVector *pTmpVec = 0;
                    if (ReadCVarVector(&pTmpVec) != no_error)
                        return end_of_stream;
                    pVec->Add(CVar(pTmpVec, TRUE));
                    break;
                }

            case VT_EX_CVAR:
                {
                    CVar *pVar = 0;
                    if (ReadCVar(&pVar) != no_error)
                        return end_of_stream;
                    pVec->Add(pVar);
                    break;
                }

            case VT_I1:
                {
                    char c = 0;
                    if (ReadBytes(&c, sizeof(char)) != no_error)
                        return end_of_stream;
                    pVec->Add(CVar(c));
                    break;
                }

            case VT_UI1:
                {
                    BYTE b = 0;
                    if (ReadBytes(&b, sizeof(BYTE)) != no_error)
                        return end_of_stream;
                    pVec->Add(CVar(b));
                    break;
                }

            case VT_I2:
                {
                    SHORT i = 0;
                    if (ReadBytes(&i, sizeof(SHORT)) != no_error)
                        return end_of_stream;
                    pVec->Add(CVar(i));
                    break;
                }

            case VT_UI2:
                {
                    WORD w = 0;
                    if (ReadBytes(&w, sizeof(WORD)) != no_error)
                        return end_of_stream;
                    pVec->Add(CVar(w));
                    break;
                }

            case VT_I4:
                {
                    LONG l = 0;
                    if (ReadBytes(&l, sizeof(LONG)) != no_error)
                        return end_of_stream;
                    pVec->Add(CVar(l));
                    break;
                }

            case VT_UI4:
                {
                    DWORD dw = 0;
                    if (ReadBytes(&dw, sizeof(DWORD)) != no_error)
                        return end_of_stream;
                    pVec->Add(CVar(dw));
                    break;
                }

            case VT_BOOL:
                {
                    VARIANT_BOOL b = 0;
                    if (ReadBytes(&b, sizeof(VARIANT_BOOL)) != no_error)
                        return end_of_stream;
                    pVec->Add(CVar(b));
                    break;
                }

            case VT_R4:
                {
                    float f = (float) 0.0;
                    if (ReadBytes(&f, sizeof(float)) != no_error)
                        return end_of_stream;
                    pVec->Add(CVar(f));
                    break;
                }

            case VT_R8:
                {
                    double d = 0.0;
                    if (ReadBytes(&d, sizeof(double)) != no_error)
                        return end_of_stream;
                    pVec->Add(CVar(d));
                    break;
                }


            // NOTE: String types were written with a prefixed with
            // a DWORD length indicator so that during deserialization
            // the correct buffer length can be allocated before the
            // string is read back.  The length indicator is in characters,
            // not bytes.
            // ============================================================
            case VT_LPSTR:
                {
                    DWORD dwLen = 0;
                    if (ReadBytes(&dwLen, sizeof(DWORD)) != no_error)
                        return end_of_stream;
                    LPSTR pStr = _new char[dwLen];
                    if (ReadBytes(pStr, dwLen) != no_error)
                        return out_of_memory;
                    pVec->Add(CVar(pStr, TRUE));
                    break;
                }

            case VT_LPWSTR:
                {
                    DWORD dwLen = 0;
                    if (ReadBytes(&dwLen, sizeof(DWORD)) != no_error)
                        return end_of_stream;
                    LPWSTR pStr = _new wchar_t[dwLen];
                    if (ReadBytes(pStr, dwLen * 2) != no_error)
                        return out_of_memory;
                    pVec->Add(CVar(pStr, TRUE));
                    break;
                }

            case VT_BSTR:
                {
                    DWORD dwLen = 0;
                    if (ReadBytes(&dwLen, sizeof(DWORD)) != no_error)
                        return end_of_stream;
                    LPWSTR pStr = _new wchar_t[dwLen];
                    if (ReadBytes(pStr, dwLen * 2) != no_error)
                        return out_of_memory;
                    pVec->Add(CVar(VT_BSTR, pStr, FALSE));
                    delete pStr;
                    break;
                }

            case VT_FILETIME:
                {
                    FILETIME ft = {0};
                    if (ReadBytes(&ft, sizeof(FILETIME)) != no_error)
                        return end_of_stream;
                    pVec->Add(CVar(&ft));
                    break;
                }

            case VT_BLOB:
                {
                    BLOB b;
                    BlobInit(&b);
                    DWORD dwLen = 0;
                    if (ReadBytes(&dwLen, sizeof(DWORD)) != no_error)
                        return end_of_stream;
                    LPBYTE pBuf = _new BYTE[dwLen];
                    if (ReadBytes(pBuf, dwLen) != no_error)
                        return end_of_stream;
                    BlobAssign(&b, pBuf, dwLen, TRUE);
                    pVec->Add(CVar(&b, TRUE));
                }

            case VT_CLSID:
                {
                    CLSID clsid = {0};
                    if (ReadBytes(&clsid, sizeof(CLSID)) != no_error)
                        return end_of_stream;
                    pVec->Add(CVar(&clsid));
                    break;
                }

            // This should never execute.
            default:
                return critical_error;
        }
    }

    *pObj = pVec;
    return no_error;
}

//***************************************************************************
//
//   CMemStream::ReadError
//
//***************************************************************************
// ok
int CMemStream::ReadError(SCODE *pVal)
{
    TYPE_CHECK(VT_ERROR);
    return ReadBytes(pVal, sizeof(SCODE));
}

//***************************************************************************
//
//  CMemStream::NextType
//
//***************************************************************************
// ok
int CMemStream::NextType()
{
    Push();
    int nType = ReadType();
    Pop(FALSE);
    return nType;
}

//***************************************************************************
//
//  CMemStream::ReadType
//
//  Returns a VT_ type indicator or VT_EMPTY on end-of-stream.
//
//***************************************************************************
// ok
int CMemStream::ReadType()
{
    DWORD dwType = VT_EMPTY;

    if (ReadBytes(&dwType, sizeof(DWORD)) == end_of_stream)
        return VT_EMPTY;

    return dwType;
}


//***************************************************************************
//
//  CMemStream::Pop
//
//***************************************************************************
// ok
void CMemStream::Pop(BOOL bDiscard)
{
    if (bDiscard)
        m_nStackPtr--;
    else
        m_dwCurrentPos = m_dwStack[m_nStackPtr--];
}


//***************************************************************************
//
//  CMemStream::~CMemStream
//
//***************************************************************************
// ok
CMemStream::~CMemStream()
{
    //_ASSERT(m_lRef == 0, "CMemStream used for COM deleted without Release");
    if (m_nFlags == auto_delete)
        m_pArena->Free(m_pBuffer);
    m_pArena->Release();
}

//***************************************************************************
//
//  CMemStream::IStream implementation
//
//***************************************************************************

STDMETHODIMP CMemStream::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IStream)
    {
        *ppv = (void*)(IStream*)this;
        AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;
}

STDMETHODIMP CMemStream::Read(
     void *pv,
     ULONG cb,
     ULONG *pcbRead)
{
    if(ReadBytes(pv, cb) == no_error)
    {
        if(pcbRead) *pcbRead = cb;
        return S_OK;
    }
    else 
    {
        if(pcbRead) *pcbRead = 0;
        return S_FALSE;
    }
}
    
STDMETHODIMP CMemStream::Write(
     const void *pv,
     ULONG cb,
     ULONG *pcbWritten)
{
    if(WriteBytes((void*)pv, cb) == no_error)
    {
        if(pcbWritten) *pcbWritten = cb;
        return S_OK;
    }
    else
    {
        if(pcbWritten) *pcbWritten = 0;
        return S_FALSE;
    }
}

STDMETHODIMP CMemStream::Seek(
     LARGE_INTEGER dlibMove,
     DWORD dwOrigin,
     ULARGE_INTEGER *plibNewPosition)
{
    switch(dwOrigin)
    {
    case STREAM_SEEK_SET:
        SetCurrentPos(dlibMove.LowPart);
        break;
    case STREAM_SEEK_CUR:
        SetCurrentPos(GetCurrentPos() + (long)dlibMove.QuadPart);
        break;
    case STREAM_SEEK_END:
        SetCurrentPos(Size() + (long)dlibMove.QuadPart);
        break;
    }

    if(plibNewPosition)
    {
        plibNewPosition->QuadPart = (LONGLONG)GetCurrentPos();
    }
    return S_OK;
}

STDMETHODIMP CMemStream::SetSize(
     ULARGE_INTEGER libNewSize)
{
    return S_OK;
}

STDMETHODIMP CMemStream::CopyTo(
     IStream *pstm,
     ULARGE_INTEGER cb,
     ULARGE_INTEGER *pcbRead,
     ULARGE_INTEGER *pcbWritten)
{
    _ASSERT(0, __TEXT("CopyTo is called on CMemStream!"));
    return STG_E_INVALIDFUNCTION;
}

STDMETHODIMP CMemStream::Commit(
     DWORD grfCommitFlags)
{
    return S_OK;
}

STDMETHODIMP CMemStream::Revert()
{
    return S_OK;
}


STDMETHODIMP CMemStream::LockRegion(
     ULARGE_INTEGER libOffset,
     ULARGE_INTEGER cb,
     DWORD dwLockType)
{
    return S_OK;
}

STDMETHODIMP CMemStream::UnlockRegion(
     ULARGE_INTEGER libOffset,
     ULARGE_INTEGER cb,
     DWORD dwLockType)
{
    return STG_E_INVALIDFUNCTION;
}

STDMETHODIMP CMemStream::Stat(
     STATSTG *pstatstg,
     DWORD grfStatFlag)
{
    pstatstg->pwcsName = NULL;
    pstatstg->type = STGTY_STREAM;
    pstatstg->cbSize.QuadPart = (LONGLONG)Size();
    
    return S_OK;
}
    
    

STDMETHODIMP CMemStream::Clone(
     IStream **ppstm)
{
    *ppstm = new CMemStream(*this);
    (*ppstm)->AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\strm.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    STRM.H

Abstract:

  CMemStream implementation.

  CMemStream implementation for WBEM.

  This is a thread-safe generic data stream which can be used
  with memory objects, pipes, mailslots, or files.  This is the basic
  object for interface & call marshaling.

  a-raymcc    04-Apr-96   Created.
  a-raymcc    06-Jun-96   CArena support.
  a-raymcc    11-Sep-96   Support NULL pointers

  Supported types:
      VT_NULL

      VT_UI1, VT_I1, VT_UI2, VT_I2, VT_UI4, VT_I4, VT_I8, VT_UI8
      VT_R4, VT_R8, VT_BOOL

      VT_LPSTR, VT_LPWSTR, VT_BSTR

      VT_CLSID, VT_UNKNOWN, VT_FILETIME, VT_ERROR, VT_BLOB, VT_PTR

      VT_EMPTY = End of stream

      VT_USERDEFINED      
          VT_EX_VAR
          VT_EX_VARVECTOR

History:

--*/


#ifndef _STRM_H_
#define _STRM_H_
#include "corepol.h"

#include <arena.h>
#include <var.h>
#include <wbemutil.h>

#define SIGNATURE_STREAM            0x80F6A003

#pragma warning(disable: 4275)

class POLARITY CMemStream : public IStream
{
protected:

    // Types, constants.
    // =================
    enum { stack_size = 32 };

    struct STREAM_HEADER
    {
        DWORD dwSignature;
        DWORD dwLength;

        STREAM_HEADER() { dwSignature = SIGNATURE_STREAM; }
        BOOL Verify() { return SIGNATURE_STREAM == dwSignature; }
    };

    // Member variables.
    // =================
    int     m_nStatus;
    DWORD   m_dwSize;
    DWORD   m_dwGrowBy;
    DWORD   m_dwCurrentPos;
    DWORD   m_dwEndOfStream;
    BYTE    *m_pBuffer;
    int     m_nFlags;
    DWORD   m_dwStack[stack_size];
    int     m_nStackPtr;
    
    long    m_lRef;

    // protected functions.
    // ==================
    void Empty();
    int Resize(DWORD dwNewSize);
    void UpdateHdr() { ((STREAM_HEADER *)m_pBuffer)->dwLength = m_dwEndOfStream; }
            
public:
    enum { no_error, failed, type_mismatch, end_of_stream, 
           out_of_memory, critical_error, invalid_parameter , timeout };
        
    enum { auto_delete, no_delete };
    
    CMemStream(
        int nFlags = auto_delete, 
        CArena *pArena = 0,
        int nInitialSize = 512, 
        int nGrowBy = 512
        );

    CMemStream(
        LPVOID pBindingAddress,
        CArena *pArena,
        int nFlags = auto_delete, 
        int nGrowBy = 512
        );
        
    CMemStream(CMemStream &Src);
    CMemStream &operator =(CMemStream &Src);
   ~CMemStream();
        // Releases the arena

    void Push() { m_dwStack[++m_nStackPtr] = m_dwCurrentPos; }
    void Pop(BOOL bDiscard);
    
    BOOL FreeMemory(void *pBlock) { return free(pBlock); }
    void Unbind() { m_nFlags = no_delete; }
            
    int Append(CMemStream *pSrc);
    
    int Deserialize(HANDLE hFile);
    int Deserialize(FILE *fStream);
    int Deserialize(LPBYTE pBlock, DWORD dwSize); 
    
    int Serialize(HANDLE hFile);
    int Serialize(FILE *fStream);
    int Serialize(BYTE **pBlock, DWORD *pdwSize, CArena *pArena = 0);
         // Use HeapFree() if no arena present

    void    Trim() { UpdateHdr(); Resize(m_dwEndOfStream); }     // Reduce excess of internal block.
             
    int     Status() { return m_nStatus; }
    DWORD   GetCurrentPos() { return m_dwCurrentPos; }
    void    SetCurrentPos(DWORD dwPos) { m_dwCurrentPos = dwPos; }
    DWORD   Size() { return m_dwEndOfStream; }
    DWORD   BufferSize() { return m_dwSize; }
    LPVOID  GetPtr() { UpdateHdr(); return m_pBuffer; }    
    void    Reset() { m_dwCurrentPos = sizeof(STREAM_HEADER); }
    int     NextType();

    int WriteType(DWORD dwType) { return WriteBytes(&dwType, sizeof(DWORD)); }
                               
    // Write operations.
    // ==================
    
    int WriteBytes(LPVOID, DWORD);

    int WriteNull() { return WriteType(VT_NULL); }

    int WriteChar(IN char c);
    int WriteByte(IN BYTE b);
    int WriteShort(IN SHORT iVal);
    int WriteWORD(IN WORD wVal);
    int WriteLong(IN LONG l);
    int WriteDWORD(IN DWORD dwVal);
    int WriteFloat(IN float fltVal);
    int WriteDouble(IN double dblVal);
    int WriteBool(IN VARIANT_BOOL b);
    
    int WriteLPSTR(IN LPSTR pStr);
    int WriteLPWSTR(IN LPWSTR pStr);
    int WriteBSTR(IN BSTR pStr);

    int WriteCLSID(IN CLSID *pClsId);
    int WriteUnknown(IN IUnknown *pObj);
    int WriteFILETIME(IN FILETIME *pTime);
    int WriteError(IN SCODE sVal);        
    int WriteBlob(IN BLOB *pBlob);
    int WritePtr(IN LPVOID p);

    int WriteCVar(IN CVar *pObj);
    int WriteCVarVector(IN CVarVector *pObj);

    // Read operations.
    // ================
                    
    int ReadBytes(LPVOID, DWORD);

    int ReadNull();
    int ReadByte(OUT BYTE *pByte);
    int ReadChar(OUT char *pc);
    int ReadShort(OUT SHORT *piVal);
    int ReadWORD(OUT WORD *pwVal);
    int ReadLong(OUT LONG *plVal);
    int ReadDWORD(OUT DWORD *pdwVal);
    int ReadFloat(OUT float *pfltVal);
    int ReadDouble(OUT double *pdlbVal);    
    int ReadBool(OUT VARIANT_BOOL *pBool);
    
    int ReadLPSTR(OUT LPSTR *pStr);
    int ReadLPWSTR(OUT LPWSTR *pStr);
    int ReadBSTR(OUT BSTR *pStr);

    int ReadCLSID(OUT CLSID *pClsId);
    int ReadUnknown(IUnknown **pObj);
    int ReadFILETIME(OUT FILETIME *pTime);
    int ReadError(OUT SCODE *pVal);
    int ReadBlob(OUT BLOB *pBlob);
    int ReadPtr(OUT LPVOID *p);

    int ReadCVar(OUT CVar **pObj);    
    int ReadCVarVector(OUT CVarVector **pObj);

    int ReadType();  

    BOOL EndOfStream() { return m_dwCurrentPos == m_dwEndOfStream; }

    // IStream implementation
    STDMETHOD_(ULONG, AddRef)()
    {
        return InterlockedIncrement(&m_lRef);
    }

    STDMETHOD_(ULONG, Release)()
    {
        long lRef = InterlockedDecrement(&m_lRef);
        if(lRef == 0) delete this;
        return lRef;
    }
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);

    STDMETHOD(Read)(
         void *pv,
         ULONG cb,
         ULONG *pcbRead);

    STDMETHOD(Write)(
         const void *pv,
         ULONG cb,
         ULONG *pcbWritten);

    STDMETHOD(Seek)(
         LARGE_INTEGER dlibMove,
         DWORD dwOrigin,
         ULARGE_INTEGER *plibNewPosition);

    STDMETHOD(SetSize)(
         ULARGE_INTEGER libNewSize);

    STDMETHOD(CopyTo)(
         IStream *pstm,
         ULARGE_INTEGER cb,
         ULARGE_INTEGER *pcbRead,
         ULARGE_INTEGER *pcbWritten);

    STDMETHOD(Commit)(
         DWORD grfCommitFlags);

    STDMETHOD(Revert)( void);

    STDMETHOD(LockRegion)(
         ULARGE_INTEGER libOffset,
         ULARGE_INTEGER cb,
         DWORD dwLockType);

    STDMETHOD(UnlockRegion)(
         ULARGE_INTEGER libOffset,
         ULARGE_INTEGER cb,
         DWORD dwLockType);

    STDMETHOD(Stat)(
         STATSTG *pstatstg,
         DWORD grfStatFlag);

    STDMETHOD(Clone)(
         IStream **ppstm);
};
                            
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\tls.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    TLS.H

Abstract:

	Thread Local Storage

History:

--*/

#ifndef __WBEM_TLS__H_
#define __WBEM_TLS__H_

class CTLS
{
protected:
    DWORD m_dwIndex;
public:
    inline CTLS() {m_dwIndex = TlsAlloc();}
    inline ~CTLS() {TlsFree(m_dwIndex);}
    inline void* Get() 
        {return ((m_dwIndex==0xFFFFFFFF)?NULL:TlsGetValue(m_dwIndex));}
    inline void Set(void* p)
        {if(m_dwIndex != 0xFFFFFFFF) TlsSetValue(m_dwIndex, p);}
    inline BOOL IsValid() {return (m_dwIndex != 0xFFFFFFFF);}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\throttle.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    THROTTLE.CPP

Abstract:

        see throttle.h

History:

	24-Oct-200   ivanbrug    created.


--*/

#include "precomp.h"
#include <tchar.h>
#include <throttle.h>
#include <arrtempl.h>

#include <wbemint.h>

typedef NTSTATUS (NTAPI * fnNtQuerySystemInformation )(
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );    

fnNtQuerySystemInformation MyNtQuerySystemInformation = NULL;

HRESULT POLARITY
Throttle(DWORD dwFlags,
         DWORD IdleMSec,         // in MilliSeconds
         DWORD IoIdleBytePerSec, // in BytesPerSec
         DWORD SleepLoop,        // in MilliSeconds
         DWORD MaxWait)          // in MilliSeconds
//
//  This function will wait until one of this two/three things have happened:
//  - the system has been idle for at least IdleMSec milliseconds
//       (no user input within IdleMSec milliseconds)
//  - the Number of bytes per seconds passed through 
//      the IO system is below a threashold
//  - the MaxWait time has elapsed
//  
//  Reasonable Params are 
//  3000-5000 millisecond with THROTTLE_USER
//  300.000 - 500.000 bytes/second with THROTTLE_IO
//  200 - 500 milliseconds for SleepLoop 
//  several minutes  for MaxWait
//
//  remarks: 
//  - the function will SUCCEDED(Throttle), no matter 
//  - if the MaxWait has been reached or if the Idle conditions 
//    have been met the function will fail in any other case
//  - the function is 'precise' within the range if a System Tick 
//    (15ms on professional)
//  - in the case of an IO throttling, there will always be a Sleep(150)
//
{
    //
    // init static and globals
    //

    if (!MyNtQuerySystemInformation)
    {
        HMODULE hDll = GetModuleHandleW(L"ntdll.dll");
        if (hDll){
            MyNtQuerySystemInformation = (fnNtQuerySystemInformation)GetProcAddress(hDll,"NtQuerySystemInformation"); 
			if ( MyNtQuerySystemInformation == NULL )
			{
				return WBEM_E_FAILED;
			}
        } else {
            return WBEM_E_FAILED;
        }
    }

    static DWORD TimeInc = 0;
    if (!TimeInc)
    {
        BOOL  bIsValid;
        DWORD dwAdj;
        
        if (!GetSystemTimeAdjustment(&dwAdj,&TimeInc,&bIsValid))
        {
            return WBEM_E_FAILED;
        }
    }

    static DWORD PageSize = 0;
    if (!PageSize)
    {
        SYSTEM_INFO  SysInfo;
        GetSystemInfo(&SysInfo);
        PageSize = SysInfo.dwPageSize; 
    }
    //
    // param validation
    //
    if ((dwFlags & ~THROTTLE_ALLOWED_FLAGS) ||
        (0 == SleepLoop))
        return WBEM_E_INVALID_PARAMETER;

    DWORD nTimes = MaxWait/SleepLoop;
    // user input structures
    LASTINPUTINFO LInInfo;
    LInInfo.cbSize = sizeof(LASTINPUTINFO);
    DWORD i;
    DWORD Idle100ns = 10000*IdleMSec; // conversion from 1ms to 100ns
    // io throttling
    SYSTEM_PERFORMANCE_INFORMATION SPI[2];
    BOOL bFirstIOSampleDone = FALSE;
    DWORD dwWhich = 0;
    DWORD cbIO = 1+IoIdleBytePerSec;
    DWORD cbIOOld = 0;
    // boolean logic
    BOOL  bCnd1 = FALSE;
    BOOL  bCnd2 = FALSE;
    // registry stuff for wmisvc to force exit from this function
    HKEY hKey = NULL;
    LONG lRes;
    DWORD dwType;
    DWORD dwLen = sizeof(DWORD);
    DWORD dwVal;
    
    lRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
    	               HOME_REG_PATH,
    	               0,
    	               KEY_READ,
    	               &hKey);
    if (ERROR_SUCCESS != lRes)
    	return WBEM_E_FAILED;
    CRegCloseMe cm_(hKey);
    
    if (dwFlags & THROTTLE_IO)
    {
        NTSTATUS Status;
    	Status = MyNtQuerySystemInformation(SystemPerformanceInformation,
                                          &SPI[dwWhich],
           	                              sizeof(SYSTEM_PERFORMANCE_INFORMATION),
               	                          0);        
        if (0 != Status)
        {
            return WBEM_E_FAILED;
        }
        dwWhich = (dwWhich+1)%2;
        Sleep(150);
    }


    for (i=0;i<nTimes;i++)
    {
        //
        // check if someone is telling us to stop waiting
        //
        lRes = RegQueryValueEx(hKey,
                             DO_THROTTLE,
                             0,
                             &dwType,                             
                             (BYTE*)&dwVal,
                             &dwLen);
        if(ERROR_SUCCESS == lRes &&
          0 == dwVal)
          return THROTTLE_FORCE_EXIT;
        	
        //
        //    check the user-input idleness
        //
        if (dwFlags & THROTTLE_USER)
        {
	        if (!GetLastInputInfo(&LInInfo))
	            return WBEM_E_FAILED;
	        DWORD Now = GetTickCount();
	        if (Now < LInInfo.dwTime)
	        {
	            continue; // one of the 49.7 days events
	        }
	        DWORD LastInput100ns = (Now - LInInfo.dwTime)*TimeInc;
	        if (LastInput100ns >= Idle100ns)
	        {
                if (0 == (dwFlags & ~THROTTLE_USER)) {
                    return THROTTLE_USER_IDLE;
                } else {
                    bCnd1 = TRUE;
                };	            
	        }
        }
        //
        // avoid checking the second condition 
        // if the first is FALSE
        //
        if (((dwFlags & (THROTTLE_IO|THROTTLE_USER)) == (THROTTLE_IO|THROTTLE_USER)) &&
            !bCnd1)
        {
            goto sleep_label;
        }
        //
        //  check the io idleness
        //
        if (dwFlags & THROTTLE_IO)
        {
	        NTSTATUS Status;
    	    Status = MyNtQuerySystemInformation(SystemPerformanceInformation,
        	                                  &SPI[dwWhich],
            	                              sizeof(SYSTEM_PERFORMANCE_INFORMATION),
                	                          0);
            if (0 == Status){
            
                cbIOOld = cbIO;
                cbIO = (DWORD)((SPI[dwWhich].IoReadTransferCount.QuadPart   - SPI[(dwWhich-1)%2].IoReadTransferCount.QuadPart) +
                               (SPI[dwWhich].IoWriteTransferCount.QuadPart  - SPI[(dwWhich-1)%2].IoWriteTransferCount.QuadPart) +
                               (SPI[dwWhich].IoOtherTransferCount.QuadPart  - SPI[(dwWhich-1)%2].IoOtherTransferCount.QuadPart) +
                               ((SPI[dwWhich].PageReadCount         - SPI[(dwWhich-1)%2].PageReadCount) +
                                (SPI[dwWhich].CacheReadCount        - SPI[(dwWhich-1)%2].CacheReadCount) +
                                (SPI[dwWhich].DirtyPagesWriteCount  - SPI[(dwWhich-1)%2].DirtyPagesWriteCount) +
                                (SPI[dwWhich].MappedPagesWriteCount - SPI[(dwWhich-1)%2].MappedPagesWriteCount)) * PageSize);

                cbIO = (cbIO * 1000)/SleepLoop;  

                //DBG_PRINTFA((pBuff,"%d - ",cbIO));
                
                cbIO = (cbIOOld+cbIO)/2;
                dwWhich = (dwWhich+1)%2;
                
                //DBG_PRINTFA((pBuff,"%d < %d\n",cbIO,IoIdleBytePerSec));
                
                if (cbIO < IoIdleBytePerSec)
                {
                    if (0 == (dwFlags & ~THROTTLE_IO)) {
                         return THROTTLE_IO_IDLE;
                     } else {
                         bCnd2 = TRUE;
                     };
                }
            }
            else
            {
                return WBEM_E_FAILED;
            }
        }
        //
        //  check the combined condition
        //
        if (dwFlags & (THROTTLE_IO|THROTTLE_USER))
        {
            if (bCnd1 && bCnd2) 
            {
                return (THROTTLE_IO_IDLE|THROTTLE_USER_IDLE);
            } 
            else 
            {
                bCnd1 = FALSE;
                bCnd2 = FALSE;
            }
        }   
        
sleep_label:        
        Sleep(SleepLoop);
    }   
    
    return THROTTLE_MAX_WAIT;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\throttle.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    THROTTLE.H

Abstract:

    provide a way to do slow down an application, allowing it to execute
    only when there is no user activity (last input was XXX mseconds ago)
    and the IO level is very low (below YYY bytes per second)


History:

	24-Oct-200   ivanbrug    created.


--*/

#ifndef __THROTTLE_H__
#define __THROTTLE_H__

//
//  valid values for dwFlags
//

#define THROTTLE_USER 1
#define THROTTLE_IO   2
#define THROTTLE_ALLOWED_FLAGS (THROTTLE_USER | THROTTLE_IO)

//
//  returned values, might be a combination
//

#define THROTTLE_MAX_WAIT  1
#define THROTTLE_USER_IDLE 2
#define THROTTLE_IO_IDLE   4
#define THROTTLE_FORCE_EXIT 8


HRESULT POLARITY
Throttle(DWORD dwFlags,
         DWORD IdleMSec,         // in MilliSeconds
         DWORD IoIdleBytePerSec, // in BytesPerSecond
         DWORD SleepLoop,        // in MilliSeconds
         DWORD MaxWait);         // in MilliSeconds

//
// strings for registry settings to UnThrottle/Throttle the dredges
//

#define HOME_REG_PATH _T("Software\\Microsoft\\WBEM\\CIMOM")
#define DO_THROTTLE   _T("ThrottleDrege")

#endif /*__THROTTLE_H__*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\tpwrap.cpp ===
#include <tpwrap.h>
#include <windows.h>

class StaticTLS
{
public:
	StaticTLS() : index_(TlsAlloc()){}
	~StaticTLS() { if (index_!=TLS_OUT_OF_INDEXES) TlsFree(index_); index_ = TLS_OUT_OF_INDEXES;}
	void * getValue(void) { return TlsGetValue(index_);}
	BOOL setValue(void * ptr) { return TlsSetValue(index_, ptr);}
	bool valid() { return index_!=TLS_OUT_OF_INDEXES;};
	DWORD index_; 
} HandlerTLS;



LIST_ENTRY 
Dispatcher::handlerListHead_ = { &handlerListHead_, &handlerListHead_};

volatile 
LONG Dispatcher::registeredHandlers_ = 0;

bool 
Dispatcher::startShutDown_ = false;

CriticalSection 
Dispatcher::handlerListLock_(NOTHROW_LOCK, 4000 & 0x80000000);


EventHandler::EventHandler(void) : 
	handlerID_(NULL), once_(0), 
	dispatcher_(0), refCount_(1),
	scheduledClose_(0)

{ Flink = 0; Blink=0; };

EventHandler::~EventHandler(void)
{ }

HANDLE 
EventHandler::getHandle(void) 
{ return INVALID_HANDLE_VALUE;}


int 
EventHandler::handleTimeout(void) 
{ return -1; }

int 
EventHandler::handleEvent(void) 
{ return -1; }

void 
EventHandler::close(void) 
{ return; }

LONG 
EventHandler::AddRef(void) 
{ return InterlockedIncrement(&refCount_); }

LONG 
EventHandler::Release(void) 
{ LONG newReference = InterlockedDecrement(&refCount_);
  if (newReference==0)
	  delete this; 
  return newReference;
}

DWORD 
EventHandler::getTimeOut(void)
{ return INFINITE; }



VOID CALLBACK 
Dispatcher::HandleWaitOrTimerCallback( PVOID lpParameter, BOOLEAN TimerOrWaitFired )
{
  EventHandler * handler = reinterpret_cast<EventHandler *>(lpParameter);

  if (startShutDown_)
	return;

  if (handler->scheduledClose_)
  	return;
	
  assert(lpParameter!=0);
  assert(HandlerTLS.getValue()==0);
  HandlerTLS.setValue(lpParameter); 
  

  int result = 0;
  if (TimerOrWaitFired == TRUE)
    result = handler->handleTimeout();
  else
    result = handler->handleEvent();

  if (result == -1)
 	removeHandler(*handler);

  HandlerTLS.setValue(0);
};
 

int 
Dispatcher::registerHandler(EventHandler& eh, int flags) 
{
  assert(startShutDown_==0);
  assert(eh.handlerID_ == NULL);

  eh.type_ = EventHandler::WAIT;
  handlerListLock_.acquire();
  BOOL retVal = RegisterWaitForSingleObject(&eh.handlerID_, eh.getHandle(), HandleWaitOrTimerCallback, &eh, eh.getTimeOut(), flags);
  if (retVal)
  	openHandler(&eh);
  handlerListLock_.release();
  return retVal;
};


int 
Dispatcher::registerHandlerOnce(EventHandler& eh, int flags) 
{ 
  assert(startShutDown_==0);
  assert(eh.handlerID_ == NULL);
  
  eh.type_ = EventHandler::WAIT;
  handlerListLock_.acquire();
  eh.once_ = 1;
  BOOL retVal = RegisterWaitForSingleObject(&eh.handlerID_, eh.getHandle(), HandleWaitOrTimerCallback, &eh, eh.getTimeOut(), flags|WT_EXECUTEONLYONCE);
  if (retVal)
  	openHandler(&eh);
  handlerListLock_.release();
  return retVal;
};


void Dispatcher::insertTail(EventHandler *entry)
{
 
  LIST_ENTRY* _EX_Blink;
  LIST_ENTRY* _EX_ListhandlerListHead_;
  _EX_ListhandlerListHead_ = &handlerListHead_;
  _EX_Blink = _EX_ListhandlerListHead_->Blink;
  entry->Flink = _EX_ListhandlerListHead_;
  entry->Blink = _EX_Blink;
  _EX_Blink->Flink = entry;
  _EX_ListhandlerListHead_->Blink = entry;
};

void Dispatcher::removeEntry(EventHandler *entry)
{
  entry->Flink->Blink = entry->Blink;
  entry->Blink->Flink = entry->Flink;
  entry->Flink = 0;
  entry->Blink = 0;
};

void Dispatcher::openHandler(EventHandler* entry)
{
	entry->AddRef();
	InterlockedIncrement(&registeredHandlers_);
	insertTail(entry);
}

void Dispatcher::closeHandler(EventHandler* entry)
{
	handlerListLock_.acquire();
	removeEntry(entry);
	handlerListLock_.release();
	
	entry->handlerID_ = NULL;
	entry->close();
	entry->Release();
	InterlockedDecrement(&registeredHandlers_);
};

int 
Dispatcher::removeHandler(EventHandler& handler)
{ 
	long scheduledDelete = InterlockedCompareExchange(&handler.scheduledClose_, 1, 0);
	if (scheduledDelete==1)
	  return 0;

  	assert(handler.handlerID_);
	if (HandlerTLS.getValue()==0)
		{
		return DeleteNotification(&handler);
		}
	else
	{
		if (PostDeleteNotification(handler)==0)
			InterlockedDecrement(&registeredHandlers_);
	}
  return 0;
};

int 
Dispatcher::scheduleTimer(EventHandler& eh, DWORD first, DWORD repeat, DWORD mode )
{
   assert(startShutDown_==0);
   
   eh.type_ = EventHandler::TIMER;
   handlerListLock_.acquire();

	bool once = (repeat==0) ||( (mode & WT_EXECUTEONLYONCE) != 0);
	if (once)
		repeat = INFINITE-1;
	eh.once_ = once;

	BOOL retCode = CreateTimerQueueTimer(&eh.handlerID_, 0, TimerCallback, &eh, first, repeat, mode);
	
	if (retCode)
  		openHandler(&eh);
	handlerListLock_.release();  	
	return retCode;
};

int 
Dispatcher::cancelTimer(EventHandler& handler)
{ 
	long scheduledDelete = InterlockedCompareExchange(&handler.scheduledClose_, 1, 0);
	if (scheduledDelete==1)
	  return 0;

	if (HandlerTLS.getValue()==0)
		{
		return DeleteTimer(&handler);
		}
	else
		{
		if(PostDeleteTimer(handler)==0)
			InterlockedDecrement(&registeredHandlers_);
		}
        return 0;
};

int 
Dispatcher::changeTimer(EventHandler& handler, DWORD first, DWORD repeat)
{ 
  assert(handler.handlerID_);
  if (repeat==0)
	{
	repeat = INFINITE-1;
	handler.once_ = 1;
	}
  return ChangeTimerQueueTimer(NULL, handler.handlerID_, first, repeat);
};


DWORD WINAPI Dispatcher::DeleteTimer( LPVOID lpParameter)
{
	EventHandler * ev = reinterpret_cast<EventHandler *>(lpParameter);
	if (DeleteTimerQueueTimer(NULL, ev->handlerID_, INVALID_HANDLE_VALUE))	
		{
		closeHandler(ev);
		return 1;
		}
	else
		InterlockedDecrement(&registeredHandlers_);
	return 0;
};

DWORD WINAPI Dispatcher::DeleteNotification( LPVOID lpParameter)
{
	EventHandler * ev = reinterpret_cast<EventHandler *>(lpParameter);
	if (UnregisterWaitEx(ev->handlerID_, INVALID_HANDLE_VALUE))
		{
		closeHandler(ev);
		return 1;
		}
	else
		InterlockedDecrement(&registeredHandlers_);
	return 0;
};

BOOL Dispatcher::PostDeleteNotification(EventHandler& ev)
{
	return QueueUserWorkItem(DeleteNotification, &ev, WT_EXECUTEDEFAULT);
}

BOOL Dispatcher::PostDeleteTimer(EventHandler& ev)
{
	return QueueUserWorkItem(DeleteTimer, &ev, WT_EXECUTEDEFAULT);
};

void CALLBACK 
Dispatcher::TimerCallback(void* lpParameter, BOOLEAN TimerOrWaitFired)
{
  assert(registeredHandlers_!=0);
  assert(HandlerTLS.getValue()==0);
  assert(TimerOrWaitFired==TRUE);
  assert(lpParameter!=0);

  EventHandler * handler = reinterpret_cast<EventHandler*>(lpParameter);

  if (startShutDown_)
	return;

  if (handler->scheduledClose_)
  	return;

  if (handler->once_)
	{
	LONG fired = InterlockedCompareExchange(&handler->once_,2,1);
	if (fired != 1)
		return;
	}

  HandlerTLS.setValue(lpParameter);

  int result = handler->handleTimeout();
  if (result == -1)
	  cancelTimer(*handler);
  HandlerTLS.setValue(0);
};

int 
Dispatcher::open()
{ return handlerListLock_.valid() && HandlerTLS.valid(); };

int Dispatcher::close()
{
	startShutDown_ = 1;
	int outstandingHandlers = 0;
	handlerListLock_.acquire();
	LIST_ENTRY * p = &handlerListHead_;
	LIST_ENTRY * next  = p->Flink;
	int entries =  0;
	while((p = next) != &handlerListHead_)
		{
		next = next->Flink;
		EventHandler * ev = static_cast<EventHandler *>(p);
		long scheduledDelete = InterlockedCompareExchange(&ev->scheduledClose_, 1, 0);
		if (!scheduledDelete)
			{
			if (ev->type_==EventHandler::WAIT)
				DeleteNotification(ev);
			else
				DeleteTimer(ev);
			}
		}
	handlerListLock_.release();

	while(0!=registeredHandlers_)
		if (!SwitchToThread())
			Sleep(1);
		
	p = &handlerListHead_;
	next = p->Flink;	
	while((p = next) != &handlerListHead_)
		{
		BOOL ret;
		next = next->Flink;
		EventHandler * ev = static_cast<EventHandler *>(p);

		if (ev->type_==EventHandler::WAIT)
			ret = UnregisterWaitEx(ev->handlerID_, INVALID_HANDLE_VALUE);
		else
			ret = DeleteTimerQueueTimer(NULL, ev->handlerID_, INVALID_HANDLE_VALUE);
		if (ret)
			{
			ev->close();
			ev->Release();
			}
		}
	
	startShutDown_ = 0;
	return 0;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\thrpool.cpp ===
/*++

Copyright (C) 2001 Microsoft Corporation

Module Name:

    THRPOOL.H

Abstract:

    General purpose thread pool.

History:

    raymcc      25-Feb-99       Created

--*/


/*
    (1) Flexible thread pool size.  Starts at zero and only creates threads
        as required.
    (2) Threads wait to be reused and if not reused within the alloted time,
        they self-terminate.  Therefore, the thread pool drops to zero
        within the specified timeout if no activity occurs.
    (3) To avoid creating a lot of threads quickly, a request will attempt
        to wait a small amount of time for a thread to free up before requesting
        a new thread creation.
*/

#include "precomp.h"
#include <stdio.h>
#include <assert.h>

#include "corepol.h"
#include <thrpool.h>


#define THREAD_STACK_SIZE      0x2000   /* 8K */


//***************************************************************************
//
//  CThreadPool::CThreadPool
//
//***************************************************************************
// ok

CThreadPool::CThreadPool(
    DWORD dwMsMaxIdleBeforeDie,
    LONG lIdleThreadLimit,
    LONG  lMaxThreads
    )
{
    m_dwMsMaxIdle = dwMsMaxIdleBeforeDie;
    m_lMaxThreads = lMaxThreads;
    m_lIdleThreadLimit = lIdleThreadLimit;

    m_lTotalThreads = 0;
    m_lIdleThreads = 0;

    m_hReleaseThread = CreateEvent(0, 0, 0, 0);
    m_hBeginRendezvous = CreateEvent(0, 0, 0, 0);
    m_hParmXfer = CreateEvent(0, 0, 0, 0);
    m_hEndRendezvous = CreateEvent(0, 0, 0, 0);

    InitializeCriticalSection(&m_cs_dispatch);
    InitializeCriticalSection(&m_cs_pool);

    m_bPendingRequest = false;
    m_bShutdown = false;

    m_pXferUserParms = 0;
    m_pXferUserProc = 0;
    m_pXferReturnCode = 0;
    m_pXferElapsedTime = 0;
}

//***************************************************************************
//
//  CThreadPool::~CThreadPool
//
//***************************************************************************
// ok

CThreadPool::~CThreadPool()
{
    bool bRes = Shutdown();     // Let all threads terminate


    if (bRes)
    {
        CloseHandle(m_hReleaseThread);
        CloseHandle(m_hBeginRendezvous);
        CloseHandle(m_hParmXfer);
        CloseHandle(m_hEndRendezvous);

        DeleteCriticalSection(&m_cs_dispatch);
        DeleteCriticalSection(&m_cs_pool);
    }
    // Else we will have to leak, since all the threads didn't shut down.
}


//***************************************************************************
//
//  CThreadPool::_ThreadEntry()
//
//  Win32 entry point, which wraps and call the per-object entry point.
//  We do this because Win32 cannot easily call an entry point in a C++
//  instance unless we use various weird calling convention override
//  tricks, which I don't remember right now. :)
//
//***************************************************************************
// ok

DWORD WINAPI CThreadPool::_ThreadEntry(LPVOID pArg)
{
    CThreadPool *pThis = (CThreadPool *) pArg;
    pThis->Pool();
    return 0;       // Not used
}


//***************************************************************************
//
//  CThreadPool::Pool
//
//  The basic pool is implemented here.  All active threads remain in this
//  loop.  Any threads which get too old waiting for work are allowed to
//  retire.  New threads are created from the DispatchThread() member.
//
//  Note that the <m_lTotalThreads> and <m_lIdleThreads> are not part
//  of the algorithm; they are simply there for statistical purposes.
//
//***************************************************************************
// ok

void CThreadPool::Pool()
{
    InterlockedIncrement(&m_lTotalThreads);

    // Pool.
    // =====

    for (;;)
    {
        if (m_bShutdown)
            break;

        if (m_lIdleThreadLimit != -1 && m_lIdleThreads > m_lIdleThreadLimit)
            break;

        // Wait for either the thread to be idle or else until a new
        // request causes it to be released.
        // =========================================================

        InterlockedIncrement(&m_lIdleThreads);

        DWORD dwRes = WaitForSingleObject(m_hReleaseThread, m_dwMsMaxIdle);

        // We don't know why the thread was released.  Maybe it was tired
        // of waiting or maybe the user is shutting down our little operation.
        // ===================================================================

        if (dwRes == WAIT_TIMEOUT || m_bShutdown)
        {
            InterlockedDecrement(&m_lIdleThreads);
            break;
        }

        // If here, we now enter the pool critical section and attempt
        // to enter into a synchronized rendezvous with the dispacher.
        // ============================================================

        EnterCriticalSection(&m_cs_pool);

        if (m_bPendingRequest)
        {
            InterlockedDecrement(&m_lIdleThreads);

            SetEvent(m_hBeginRendezvous);
            WaitForSingleObject(m_hParmXfer, INFINITE);

            // Copy the parameters that the user specified in
            // DispatchThread().  We cannot be here unless
            // DispatchThread() signaled us.
            // ==============================================

            LPVOID                  pUserArg   = m_pXferUserParms;
            LPTHREAD_START_ROUTINE  pUserEntry = m_pXferUserProc;
            LPDWORD                 pElapsed   = m_pXferElapsedTime;
            LPDWORD                 pRetVal    = m_pXferReturnCode;
            HANDLE                  hCompleted = m_hXferThreadCompleted;
            m_bPendingRequest = false;

            // No longer in 'request' mode, so a new dispatch can occur.
            // Note that the user's parms are safely in local variables.
            // Allow further dispatches to occur.
            // ========================================================

            SetEvent(m_hEndRendezvous);

            LeaveCriticalSection(&m_cs_pool);

            // If user wants elapsed time, record start time.
            // ==============================================

            DWORD dwStart = 0;
            if (m_pXferElapsedTime)
                dwStart = GetCurrentTime();

            // Call user's entry point.
            // ========================

            DWORD dwResToRet = pUserEntry(pUserArg);

            // If user wants return value, forward it.
            // =======================================

            if (pRetVal)
                *pRetVal = dwResToRet;

            // If user wants elapsed time, record stop time
            // and forward elapsed time.
            // ============================================

            if (m_pXferElapsedTime)
                *m_pXferElapsedTime = GetCurrentTime() - dwStart;

            // If user wants event signaled, do it.
            // ====================================

            if (hCompleted)
                SetEvent(hCompleted);

        }

        // If here, somehow the event got signaled and nobody wanted
        // the thread.  This could occur if somebody executed Shutdown()
        // and then Restart() before Shutdown() was finished.
        // Simply return to top of loop.
        // =============================================================

        else
        {
            LeaveCriticalSection(&m_cs_pool);
            InterlockedDecrement(&m_lIdleThreads);
        }
    }

    InterlockedDecrement(&m_lTotalThreads);
//    printf("---Thread Ending--- 0x%X\n", GetCurrentThreadId());
}


//***************************************************************************
//
//  CThreadPool::Shutdown
//
//  Alas, the pool is doomed and must be drained.  Inform each thread of
//  its fate.
//
//***************************************************************************
// ok

bool CThreadPool::Shutdown(DWORD dwMaxWait)
{
    m_bShutdown = true;
    m_bPendingRequest = false;

    DWORD dwStart = GetCurrentTime();

    while (m_lTotalThreads && m_bShutdown)  // No need to protect this
    {
        SetEvent(m_hReleaseThread); // Allow thread to realize it is doomed
        if (GetCurrentTime() - dwStart > dwMaxWait)
            break;
        Sleep(10);
    }

    if (m_lTotalThreads == 0)
        return true;

    return false;
}

//***************************************************************************
//
//  CThreadPool::Restart
//
//  Allow a thread pool to get back into business again.
//
//***************************************************************************
// ok

bool CThreadPool::Restart()
{
    m_bShutdown = false;
    return true;
}

//***************************************************************************
//
//  CThreadPool::CreateNewThread
//
//  Helper to create a new thread.
//
//***************************************************************************
// ok

bool CThreadPool::CreateNewThread()
{
    DWORD dwId;

    HANDLE hThread = CreateThread(
        0,                     // Security
        THREAD_STACK_SIZE,     // 8k stack
        _ThreadEntry,          // Thread proc address
        LPVOID(this),          // Thread parm
        0,                     // Flags
        &dwId
        );

    if (hThread == NULL)
        return false;

//    printf("--Created Thread 0x%X\n", dwId);

    CloseHandle(hThread);
    return true;
}


//***************************************************************************
//
//  CThreadPool::DispatchThread
//
//  Called by the user to dispatch a thread to an entry point.
//
//  Returns:
//    NoError       -- Success
//    ExceededPool  -- No threads available within the timeout.
//    Shutdown      -- Thread pool is being shut down
//    ThreadCreationFailure -- Couldn't create a thread.
//
//***************************************************************************
// ok


int CThreadPool::DispatchThread(
    IN DWORD dwMaxPreferredWait,
    IN DWORD dwMaxWaitBeforeFail,
    IN LPTHREAD_START_ROUTINE pEntry,
    IN LPVOID pArg,
    IN DWORD *pdwReturnCode,
    IN DWORD *pdwElapsedTime,
    IN HANDLE hThreadCompleted
    )
{
    DWORD dwRes;

    // Don't allow new requests during a shutdown.
    // ===========================================

    if (m_bShutdown)
        return ShutdownInProgress;


    // Serialize all access to thread acquisition.
    // ===========================================

    EnterCriticalSection(&m_cs_dispatch);

    // If zero threads, create one.
    // ============================

    if (m_lTotalThreads == 0)
    {
        if (CreateNewThread() != true)
        {
            LeaveCriticalSection(&m_cs_dispatch);
            return ThreadCreationFailure;
        }
    }


    // Flag for the pool to look at to determine
    // if a dispatch is in progress.
    // =========================================

    m_bPendingRequest = true;

    // Release at least one thread.  If there aren't any
    // available, this is harmless.  Likewise, if this
    // releases threads which don't in fact become acquired
    // by this dispatch, again it is harmless.
    // ====================================================

    SetEvent(m_hReleaseThread);

    // We now try to rendevous with a thread within the
    // dwMaxPreferredWait time by waiting for a 'thready ready'
    // event from the thread pool.  If no thread responds,
    // because they are busy, we will timeout.
    // ========================================================

    dwRes = WaitForSingleObject(m_hBeginRendezvous, dwMaxPreferredWait);

    if (dwRes == WAIT_OBJECT_0)
    {
        // We are now in a synchronized rendevous with the thread pool.
        // Next, make the interthread parameter transfer.
        // ============================================================

        m_pXferUserParms = pArg;
        m_pXferUserProc  = pEntry;
        m_pXferElapsedTime = pdwElapsedTime;
        m_pXferReturnCode = pdwReturnCode;
        m_hXferThreadCompleted = hThreadCompleted;

        m_bPendingRequest = false;          // No longer needed

        // Now, release the thread pool thread to grab the parameters.
        // ===========================================================

        SetEvent(m_hParmXfer);

        WaitForSingleObject(m_hEndRendezvous, INFINITE);

        LeaveCriticalSection(&m_cs_dispatch);    // Allow more dispatches

        return NoError;
    }

    if (m_bShutdown)
    {
        LeaveCriticalSection(&m_cs_dispatch);
        return ShutdownInProgress;
    }

    // If here, we didn't acquire a thread.  Let's create another one.
    // If, in the meantime, the event shows up anyway (and we simply
    // didn't wait long enough!), then we ended up with another thread.
    // So what?  If one is good, two is better.
    // ================================================================

    if (m_lMaxThreads == -1 || (m_lTotalThreads < m_lMaxThreads))
    {
        if (CreateNewThread() != true)
        {
            LeaveCriticalSection(&m_cs_dispatch);
            return ThreadCreationFailure;
        }
    }

    if (m_bShutdown)
    {
        LeaveCriticalSection(&m_cs_dispatch);
        return ShutdownInProgress;
    }

    // Now, wait for that same old event, indicating we have begun
    // a synchronized rendevous with the thread pool.
    // ============================================================

    dwRes = WaitForSingleObject(m_hBeginRendezvous, dwMaxWaitBeforeFail);

    if (m_bShutdown)
    {
        LeaveCriticalSection(&m_cs_dispatch);
        return ShutdownInProgress;
    }

    if (dwRes == WAIT_OBJECT_0)
    {
        // We are now in a synchronized rendevous with the thread pool.
        // Next, make the interthread parameter transfer.
        // ============================================================

        m_pXferUserParms = pArg;
        m_pXferUserProc  = pEntry;
        m_pXferElapsedTime = pdwElapsedTime;
        m_pXferReturnCode = pdwReturnCode;
        m_hXferThreadCompleted = hThreadCompleted;

        m_bPendingRequest = false;          // No longer needed

        // Now, release the thread pool thread to grab the parameters.
        // ===========================================================

        SetEvent(m_hParmXfer);

        WaitForSingleObject(m_hEndRendezvous, INFINITE);

        LeaveCriticalSection(&m_cs_dispatch);    // Allow more dispatches

        return NoError;
    }

    // If here, we simply ran out of time.  If in the meantime
    // the event gets signaled, it will benefit any new thread coming
    // in looking for a request!
    // ==============================================================

    m_bPendingRequest = false;  // We may be too late, but it looks good anyway.

    LeaveCriticalSection(&m_cs_dispatch);

    return ExceededPool;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\tpwrap.h ===
#ifndef __TP_WRAP_
#define __TP_WRAP_

#ifdef DBG
  #undef NDEBUG
#endif
#include <assert.h>
#include <windows.h>
#include <locks.h>

class Dispatcher;

class EventHandler : public LIST_ENTRY
{
protected:
	LONG refCount_;
	LONG scheduledClose_;	// logicaly bool
  	HANDLE handlerID_;
 	LONG once_;
  	Dispatcher * dispatcher_;
  	friend class Dispatcher;
	
public:
	enum HANDLER_TYPE { TIMER, WAIT} type_;
	HANDLER_TYPE handlerType(){ return type_;}
	
	virtual LONG AddRef(void);
	virtual LONG Release(void);
       virtual void close(void);
	virtual HANDLE getHandle(void);

	virtual int handleTimeout(void);
	virtual int handleEvent(void);
	virtual DWORD getTimeOut(void);

	Dispatcher * dispatcher(void);
	void dispatcher(Dispatcher* r);

protected:
  	EventHandler(void);  
  	virtual ~EventHandler(void)=0;
};


#ifdef WINVER
#if (WINVER>=0x0500)

class Dispatcher{
	static LIST_ENTRY handlerListHead_;
	static volatile LONG registeredHandlers_;
	static bool startShutDown_;
	static CriticalSection handlerListLock_;	
public:
	static int registerHandler(EventHandler& eh, int flags = WT_EXECUTELONGFUNCTION) ;
	static int registerHandlerOnce(EventHandler& eh, int flags = WT_EXECUTELONGFUNCTION) ;
	static int removeHandler(EventHandler& handler);

	static int scheduleTimer(EventHandler& eh, DWORD first, DWORD repeat=0, DWORD mode = WT_EXECUTELONGFUNCTION);
	static int cancelTimer(EventHandler& handler);
	static int changeTimer(EventHandler& handler, DWORD first, DWORD repeat=0);
	static int close();
	static int open();

private:
	static void insertTail(EventHandler *entry);
	static void removeEntry(EventHandler *entry);
	static void closeHandler(EventHandler* entry);
	static void openHandler(EventHandler* entry);



	static DWORD WINAPI DeleteTimer( LPVOID lpParameter);
	static DWORD WINAPI DeleteNotification( LPVOID lpParameter);
	static BOOL PostDeleteNotification(EventHandler& ev);
	static BOOL PostDeleteTimer(EventHandler& ev);

	static VOID CALLBACK HandleWaitOrTimerCallback( PVOID lpParameter, BOOLEAN TimerOrWaitFired );
	static void CALLBACK TimerCallback(void* lpParameter, BOOLEAN TimerOrWaitFired);
	
};
#endif
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\thrpool.h ===
/*++

Copyright (C) 2001 Microsoft Corporation

Module Name:

    THRPOOL.H

Abstract:

	General purpose thread pool.

History:

	raymcc      25-Feb-99       Created

--*/

#ifndef _THRPOOL_H_
#define _THRPOOL_H_

class POLARITY CThreadPool
{
    // User-defined control parms.
    // ===========================
    
    DWORD  m_dwMsMaxIdle;       // Max idle milliseconds before letting thread terminate
    LONG   m_lMaxThreads;       // Max threads in pool, -1 = no limit.
    LONG   m_lIdleThreadLimit;  // No more than this number of idle threads
    
    // Thread status info.  These may become out-of-date as soon as they
    // are read, but they are statistically useful.
    // =================================================================
    
    LONG   m_lIdleThreads;     // How many threads available
    LONG   m_lTotalThreads;    // How many threads created
    
    // Other stuff.
    // ============

    HANDLE m_hReleaseThread;    // Signaled to release a blocked thread
    HANDLE m_hBeginRendezvous;  // Signaled to indicate a rendezvous
    HANDLE m_hParmXfer;         // Signaled to begin interthread transfer of parms
    HANDLE m_hEndRendezvous;    // Signaled when parameter transfer is completed

    CRITICAL_SECTION m_cs_dispatch;     // Protects dispatcher rendezvous
    CRITICAL_SECTION m_cs_pool;         // Protects thread pool rendezvous

    bool   m_bShutdown;
    bool   m_bPendingRequest;   // Used to signal that a parm transfer
                                // is taking place via the two Xfer members
                                // following this.

    // These are used for interthread parameter transfers.
    // ====================================================

    LPVOID m_pXferUserParms;                // Used to copy user-supplied thread parms

    LPTHREAD_START_ROUTINE m_pXferUserProc; // Used to copy the user-supplied
                                            // thread entry point

    LPDWORD m_pXferReturnCode;      // Receives user's return code
    LPDWORD m_pXferElapsedTime;     // Receives elapsed dispatch time
    HANDLE  m_hXferThreadCompleted; // Signaled when thread is done

    // Internal functions.
    // ===================

    bool CreateNewThread();
    static DWORD WINAPI _ThreadEntry(LPVOID pArg);
    void Pool();
        
public:
    enum { NoError, ExceededPool, ThreadCreationFailure, ShutdownInProgress, Failed, TimedOut };


    CThreadPool(
        DWORD dwMsMaxIdleBeforeDie = 5000,   // 5 sec
        LONG  lIdleThreadLimit     = 8,      // No more than this number of idle threads, -1=no limit
        LONG  lMaxThreads = -1               // No limit
        );
        
   ~CThreadPool();

    void IncrementMaxThreads() { InterlockedIncrement(&m_lMaxThreads); }       
    void DecrementMaxThreads() { InterlockedDecrement(&m_lMaxThreads); }
    LONG GetCurrentMaxThreads() { return m_lMaxThreads; }

    bool Shutdown(DWORD dwMaxWait = 5000);
        // Stops dispatching and lets thread pool return to 
        // zero.  New requests via DispatchThread() will be denied
        // with a <Shutdown> error code.
        // If this returns while there still threads due to timeout,
        // <false> is returned.

    bool Restart();
        // Allows thread pool to start again.

    // All of these can become out of date before the call even returns!
    // They are primarily for load analysis and don't have to be exact.
    // =================================================================        
                       
    LONG GetTotalThreadCount() { return m_lTotalThreads; }
    LONG GetIdleThreadCount() { return m_lIdleThreads; }

    // Dispatches a thread to the user's entry point.
    // ==============================================
            
    int DispatchThread(
	    IN DWORD dwMaxPreferredWait,    
        IN DWORD dwMaxWaitBeforeFail,   
        IN LPTHREAD_START_ROUTINE pEntry, 
        IN LPVOID pArg = 0, 
        IN DWORD *pdwReturnCode = 0,
        IN DWORD *pdwElapsedTime = 0,
        IN HANDLE hThreadCompleted = 0
        );
    /*
        dwMaxPreferredWait --
            How long to wait while attempting to reuse a thread which
            has just become idle.  Typically, no more than 250 msec.
            Once this expires, if no threads are available, one will
            be created, if the max thread limit hasn't been reached.
            If it has, then dwMaxWaitBeforeFail kicks in.
        dwMaxWaitBeforeFail --            
            The maximum wait time to acquire or create a thread. If
            a thread cannot be dispatched within this time, ExceededPool
            is returned.
        pEntry -- 
            The user's entry point.
        pdwReturnCode --
            If not NULL, receives the thread return code.
        pdwElapsedTime --
            If not NULL, receives the elapsed running time of the dispatch.                                            
        hThreadCompleted
            If not NULL, a user event handle to be signaled when thread is done

        Return value --
            One of the enum error codes            
    */
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\txttempl.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#ifndef __WBEM_TEXT_TEMPLATE__H_
#define __WBEM_TEXT_TEMPLATE__H_

#include <windows.h>
#include <wbemidl.h>
#include <wstring.h>

class CTextTemplate
{
protected:
    WString m_wsTemplate;

public:
    CTextTemplate(LPCWSTR wszTemplate = NULL);
    ~CTextTemplate();

    void SetTemplate(LPCWSTR wszTemplate);
    BSTR Apply(IWbemClassObject* pObj);

private:
	BSTR HandleEmbeddedObjectProperties(WCHAR* wszTemplate, IWbemClassObject* pObj);
	BOOL IsEmbeddedObjectProperty(WCHAR * wszProperty);
	BSTR GetPropertyFromIUnknown(WCHAR *wszProperty, IUnknown *pUnk);
    BSTR ProcessArray(const VARIANT& v, BSTR str);
    void ConcatWithoutQuotes(WString& str, BSTR& property);


    bool HasEscapeSequence(BSTR str);
    BSTR ReturnEscapedReturns(BSTR str);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\tss.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    TSS.CPP

Abstract:

  This file implements the classes used by the Timer Subsystem.

History:

  26-Nov-96   raymcc      Draft
  28-Dec-96   a-richm     Alpha PDK Release
  12-Apr-97   a-levn      Extensive changes

--*/

#include "precomp.h"

#include "tss.h"
#include <cominit.h>
#include <stdio.h>
#include <wbemutil.h>


CInstructionQueue::CInstructionQueue()
    : m_pQueue(NULL), m_csQueue(), m_bBreak(FALSE)
{
    // Create the event which will be signaled whenever a new instruction
    // is added to the head of the queue
    // ==================================================================

    m_hNewHead = CreateEvent(NULL,
        FALSE, // automatic reset
        FALSE, // non-signalled
        NULL);

}

CInstructionQueue::~CInstructionQueue()
{
    CInCritSec ics(&m_csQueue); // work inside critical section

    while(m_pQueue)
    {
        CQueueEl* pNext = m_pQueue->m_pNext;
        delete m_pQueue;
        m_pQueue = pNext;
    }
    CloseHandle(m_hNewHead);
}

void CInstructionQueue::TouchHead()
{
    SetEvent(m_hNewHead);
}

HRESULT CInstructionQueue::Enqueue(CWbemTime When,
                                   ADDREF CTimerInstruction* pInst)
{
    CInCritSec ics(&m_csQueue); // work inside critical section

    // Create the link-list element for the object
    // ===========================================

    CQueueEl* pNew = new CQueueEl(pInst, When);
    if(!pNew)
        return WBEM_E_OUT_OF_MEMORY;

    // Find the right place to insert this instruction
    // ===============================================

    CQueueEl* pCurrent = m_pQueue;
    CQueueEl* pLast = NULL;
    while(pCurrent && When >= pCurrent->m_When)
    {
        pLast = pCurrent;
        pCurrent = pCurrent->m_pNext;
    }

    // Insert it
    // =========

    if(pLast)
    {
        // Inserting in the middle
        // =======================

        pLast->m_pNext = pNew;
        pNew->m_pNext = pCurrent;
    }
    else
    {
        // Inserting at the head
        // =====================

        pNew->m_pNext = m_pQueue;
        m_pQueue = pNew;
        TouchHead();
    }

    return S_OK;
}

HRESULT CInstructionQueue::Dequeue(OUT RELEASE_ME CTimerInstruction*& pInst,
                                   OUT CWbemTime& When)
{
    CInCritSec ics(&m_csQueue); // all work in critical section

    if(m_pQueue == NULL)
        return S_FALSE;

    pInst = m_pQueue->m_pInst;
    When = m_pQueue->m_When;

    // Null out the instruction in the queue so it would not be deleted
    // ================================================================
    m_pQueue->m_pInst = NULL;

    // Delete the head from the queue
    // ==============================

    CQueueEl* pNewHead = m_pQueue->m_pNext;
    delete m_pQueue;
    m_pQueue = pNewHead;

    return S_OK;
}

HRESULT CInstructionQueue::Remove(IN CInstructionTest* pPred,
                                  OUT RELEASE_ME CTimerInstruction** ppInst)
{
    if(ppInst)
        *ppInst = NULL;

    CTimerInstruction* pToMark = NULL;
    BOOL bFound = FALSE;

    {
        CInCritSec ics(&m_csQueue); // all work in critical section
        CQueueEl* pCurrent = m_pQueue;
        CQueueEl* pLast = NULL;
        while(pCurrent)
        {
            if((*pPred)(pCurrent->m_pInst))
            {
                // Accepted. Remove
                // ================

                bFound = TRUE;
                CQueueEl* pNext;
                if(pLast)
                {
                    // removing from the middle
                    // ========================

                    pLast->m_pNext = pCurrent->m_pNext;
                    pNext = pLast->m_pNext;
                }
                else
                {
                    // Removing from the head
                    // ======================
                    m_pQueue = pCurrent->m_pNext;
                    pNext = m_pQueue;
                    TouchHead();
                }

                if(pToMark)
                {
                    // This is not entirely clean. This function was originally
                    // written to remove one instruction, but then converted to
                    // remove all matching ones.  The **ppInst and pToMark
                    // business is only applicable to the one instruction case.
                    // It would be cleaner to split this function up into two,
                    // but that's too risky at this point.
                    // ========================================================

                    pToMark->Release();
                }
                pToMark = pCurrent->m_pInst;
                pToMark->AddRef();

                delete pCurrent;
                pCurrent = pNext;
            }
            else
            {
                pLast = pCurrent;
                pCurrent = pCurrent->m_pNext;
            }
        }
    } // out of critical section

    // Preserve the instruction to be returned, if required
    // ====================================================

    if(ppInst != NULL)
    {
        // Release whatever may be in there
        // ================================

        if(*ppInst)
            (*ppInst)->Release();

        // Store the instruction being deleted there
        // =========================================

        *ppInst = pToMark;
    }
    else if(pToMark)
    {
        pToMark->MarkForRemoval();
        pToMark->Release();
    }

    if(!bFound) return S_FALSE;
    return S_OK;
}

HRESULT CInstructionQueue::Change(CTimerInstruction* pInst, CWbemTime When)
{
    CInCritSec ics(&m_csQueue); // all work in critical section

    CIdentityTest Test(pInst);
    CTimerInstruction* pObtained;
    if(Remove(&Test, &pObtained) == S_OK)
    {
        // pObtained == pInst, of course
        // =============================

        // Got it. Enqueue with new time
        // =============================

        HRESULT hres = S_OK;
        if(When.IsFinite())
            hres = Enqueue(When, pInst);
        pObtained->Release();
        return hres;
    }
    else
    {
        // This instruction is no longer there
        return S_FALSE;
    }
}

BOOL CInstructionQueue::IsEmpty()
{
    return (m_pQueue == NULL);
}

CWbemInterval CInstructionQueue::TimeToWait()
{
    // ================================================
    // Assumes that we are inside the critical section!
    // ================================================
    if(m_pQueue == NULL)
    {
        return CWbemInterval::GetInfinity();
    }
    else
    {
        return CWbemTime::GetCurrentTime().RemainsUntil(m_pQueue->m_When);
    }
}


void CInstructionQueue::BreakWait()
{
    m_bBreak = TRUE;
    SetEvent(m_hNewHead);
}


HRESULT CInstructionQueue::WaitAndPeek(
        OUT RELEASE_ME CTimerInstruction*& pInst, OUT CWbemTime& When)
{
    EnterCriticalSection(&m_csQueue);
    CWbemInterval ToWait = TimeToWait();

    // Wait that long. The wait may be interrupted and shortened by
    // insertion of new instructions
    // ============================================================

    while(!ToWait.IsZero())
    {
        LeaveCriticalSection(&m_csQueue);

        // If ToWait is infinite, wait for 30 seconds instead
        // ==================================================

        DWORD dwMilli;
        if(ToWait.IsFinite())
            dwMilli = ToWait.GetMilliseconds();
        else
            dwMilli = 30000;

        DWORD dwRes = WbemWaitForSingleObject(m_hNewHead, dwMilli);

	if(m_bBreak)
            return S_FALSE;

        if (dwRes == -1 || (dwRes == WAIT_TIMEOUT && !ToWait.IsFinite()))
        {
            if (dwRes == -1)
	      {
	      ERRORTRACE((LOG_WBEMCORE, "WaitForMultipleObjects failed. LastError = %X.\n", GetLastError()));
	      ::Sleep(0);
	      }

	    // We timed out on the 30 second wait --- time to quit for lack
            // of work
            // ============================================================

            return WBEM_S_TIMEDOUT;
        }

        EnterCriticalSection(&m_csQueue);

        ToWait = TimeToWait();
    }

    // still in critical section

    pInst = m_pQueue->m_pInst;
    When = m_pQueue->m_When;
    pInst->AddRef();
    LeaveCriticalSection(&m_csQueue);
    return S_OK;
}

long CInstructionQueue::GetNumInstructions()
{
    EnterCriticalSection(&m_csQueue);

    long lCount = 0;
    CQueueEl* pCurrent = m_pQueue;
    while(pCurrent)
    {
        lCount++;
        pCurrent = pCurrent->m_pNext;
    }
    LeaveCriticalSection(&m_csQueue);
    return lCount;
}



CTimerGenerator::CTimerGenerator()
    : CHaltable(), m_fExitNow(FALSE), m_hSchedulerThread(NULL)
{
}

void CTimerGenerator::EnsureRunning()
{
    CInCritSec ics(&m_cs);

    if(m_hSchedulerThread)
        return;

    // Create scheduler thread.
    // ========================

    NotifyStartingThread();

    DWORD dwThreadId;
    m_hSchedulerThread = CreateThread(
        NULL,                // pointer to thread security attributes
        0,                   // initial thread stack size, in bytes
        (LPTHREAD_START_ROUTINE)SchedulerThread, // pointer to thread function
        (CTimerGenerator*)this,                // argument for new thread
        0,                   // creation flags
        &dwThreadId          // pointer to returned thread identifier
        );
}

HRESULT CTimerGenerator::Shutdown()
{
    if(m_hSchedulerThread)
    {
        // Set the flag indicating that the scheduler should stop
        m_fExitNow = 1;

        // Resume the scheduler if halted.
        ResumeAll();

        // Wake up scheduler. It will stop immediately because of the flag.
        m_Queue.BreakWait();

        // Wait for scheduler thread to exit.
        WbemWaitForSingleObject(m_hSchedulerThread, INFINITE);
        CloseHandle(m_hSchedulerThread);
        m_hSchedulerThread = NULL;
        return S_OK;
    }
    else return S_FALSE;
}

CTimerGenerator::~CTimerGenerator()
{
    Shutdown();
}

HRESULT CTimerGenerator::Set(ADDREF CTimerInstruction *pInst,
                             CWbemTime NextFiring)
{
  if (isValid() == false)
    return WBEM_E_OUT_OF_MEMORY;

	CInCritSec ics(&m_cs);

    //
    // 0 for NextFiring indicates that the instruction has not been fired or
    // scheduled before, and should therefore be asked when its first firing
    // time should be
    //

    if(NextFiring.IsZero())
    {
        NextFiring = pInst->GetFirstFiringTime();
    }

    //
    // Infinite firing time indicates that this istruction can never fire
    //

    if(!NextFiring.IsFinite())
        return S_FALSE;

    //
    // Real instruction --- enqueue
    //

    HRESULT hres = m_Queue.Enqueue(NextFiring, pInst);

    //
    // Ensure time generator thread is running, as it shuts down when there are
    // no instructions on the queue
    //

    EnsureRunning();
    return hres;
}

HRESULT CTimerGenerator::Remove(CInstructionTest* pPred)
{
    CInCritSec ics(&m_cs);

    HRESULT hres = m_Queue.Remove(pPred);
    if(FAILED(hres)) return hres;
    return S_OK;
}


DWORD  CTimerGenerator::SchedulerThread(LPVOID pArg)
{
    InitializeCom();
    CTimerGenerator * pGen = (CTimerGenerator *) pArg;

	try
	{
	    while(1)
	    {
	        // Wait until we are resumed. In non-paused state, returns immediately.
	        // ====================================================================

					pGen->WaitForResumption();

	        // Wait for the next instruction on the queue to mature
	        // ====================================================

	        CTimerInstruction* pInst;
	        CWbemTime WhenToFire;
	        HRESULT hres = pGen->m_Queue.WaitAndPeek(pInst, WhenToFire);
	        if(hres == S_FALSE)
	        {
	            // End of the game: destructor called BreakDequeue
	            // ===============================================

	            break;
	        }
	        else if(hres == WBEM_S_TIMEDOUT)
	        {
	            // The thread is exiting for lack of work
	            // ======================================

	            CInCritSec ics(&pGen->m_cs);

	            // Check if there is any work
	            // ==========================

	            if(pGen->m_Queue.IsEmpty())
	            {
	                // That's it --- exit
	                // ==================

	                CloseHandle( pGen->m_hSchedulerThread );
	                pGen->m_hSchedulerThread = NULL;
	                break;
	            }
	            else
	            {
	                // Work was added before we entered CS
	                // ===================================
	                continue;
	            }
	        }

	        // Make sure we haven't been halted while sitting here
	        // ===================================================

	        if(pGen->IsHalted())
	        {
	            // try again later.
	            pInst->Release();
	            continue;
	        }

	        // Figure out how many times this instruction has "fired"
	        // ======================================================

	        long lMissedFiringCount = 0;
	        CWbemTime NextFiring = pInst->GetNextFiringTime(WhenToFire,
	            &lMissedFiringCount);

	        // Notify accordingly
	        // ==================

	        pInst->Fire(lMissedFiringCount+1, NextFiring);

	        // Requeue the instruction
	        // =======================

	        if(pGen->m_Queue.Change(pInst, NextFiring) != S_OK)
	        {
	            //Error!!!
	        }
	        pInst->Release();
	    }
	}
	catch( CX_MemoryException )
	{ 
	}
	
    pGen->NotifyStoppingThread();
    CoUninitialize();

    return 0;
}


class CFreeUnusedLibrariesInstruction : public CTimerInstruction
{
protected:
    long m_lRef;
    CWbemInterval m_Delay;

public:
    CFreeUnusedLibrariesInstruction() : m_lRef(0)
    {
        m_Delay.SetMilliseconds(660000);
    }

    virtual void AddRef() {m_lRef++;}
    virtual void Release() {if(--m_lRef == 0) delete this;}
    virtual int GetInstructionType() {return INSTTYPE_FREE_LIB;}

public:
    virtual CWbemTime GetNextFiringTime(CWbemTime LastFiringTime,
        OUT long* plFiringCount) const
    {
        *plFiringCount = 1;
        return CWbemTime::GetInfinity();
    }

    virtual CWbemTime GetFirstFiringTime() const
    {
        return CWbemTime::GetCurrentTime() + m_Delay;
    }
    virtual HRESULT Fire(long lNumTimes, CWbemTime NextFiringTime)
    {
        DEBUGTRACE((LOG_WBEMCORE, "Calling CoFreeUnusedLibraries...\n"));
        CoFreeUnusedLibraries();
        return S_OK;
    }
};


void CTimerGenerator::ScheduleFreeUnusedLibraries()
{
    // Inform our EXE that now and in 11 minutes would be a good time to call
    // CoFreeUnusedLibraries
    // ======================================================================

    HANDLE hEvent =
        OpenEvent(EVENT_MODIFY_STATE, FALSE, __TEXT("WINMGMT_PROVIDER_CANSHUTDOWN"));
    SetEvent(hEvent);
    CloseHandle(hEvent);
/*
    CoFreeUnusedLibraries();
    CFreeUnusedLibrariesInstruction* pInst =
        new CFreeUnusedLibrariesInstruction;
    Set(pInst);
*/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\tss.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    TSS.CPP

Abstract:

  This file defines the classes used by the Timer Subsystem. 

  Classes defined:

      RecurrenceInstruction       Complex recurrence information.
      TimerInstruction            Single instruction for the timer

History:

  26-Nov-96   raymcc      Draft
  28-Dec-96   a-richm     Alpha PDK Release
  12-Apr-97   a-levn      Extensive changes

--*/

#ifndef _TSS_H_
#define _TSS_H_

#include <functional>
#include <wbemidl.h>
#include <stdio.h>
#include "sync.h"
#include "CWbemTime.h"
#include "parmdefs.h"

#define INSTTYPE_WBEM 1
#define INSTTYPE_INTERNAL 2
#define INSTTYPE_AGGREGATION 3
#define INSTTYPE_UNLOAD 4
#define INSTTYPE_FREE_LIB 5

class POLARITY CTimerInstruction
{
public:
    CTimerInstruction(){}
    virtual ~CTimerInstruction()
    {
    }

    virtual void AddRef() = 0;
    virtual void Release() = 0;
    virtual int GetInstructionType() = 0;

public:
    virtual CWbemTime GetNextFiringTime(CWbemTime LastFiringTime,
        OUT long* plFiringCount) const = 0;
    virtual CWbemTime GetFirstFiringTime() const = 0;
    virtual HRESULT Fire(long lNumTimes, CWbemTime NextFiringTime) = 0;
    virtual HRESULT MarkForRemoval(){return S_OK;}
};

class POLARITY CInstructionTest 
{
public:
    virtual BOOL operator()(CTimerInstruction* pToTest) = 0;
};


class POLARITY CIdentityTest : public CInstructionTest
{
protected:
    CTimerInstruction* m_pInst;
public:
    CIdentityTest(CTimerInstruction* pInst) : m_pInst(pInst)
    {
        pInst->AddRef();
    }
    ~CIdentityTest() {m_pInst->Release();}
    BOOL operator()(CTimerInstruction* pToTest) {return pToTest == m_pInst;}
};

class POLARITY CInstructionQueue
{
public:
    CInstructionQueue();
    ~CInstructionQueue();

    HRESULT Enqueue(IN CWbemTime When, IN ADDREF CTimerInstruction* pInst);
    HRESULT Remove(IN CInstructionTest* pPred, 
        OUT RELEASE_ME CTimerInstruction** ppInst = NULL);
    HRESULT Change(CTimerInstruction* pInst, CWbemTime When);
    HRESULT WaitAndPeek(OUT RELEASE_ME CTimerInstruction*& pInst, 
        OUT CWbemTime& When);

    void BreakWait();
    BOOL IsEmpty();

    HRESULT Dequeue(OUT RELEASE_ME CTimerInstruction*& pInst, 
        OUT CWbemTime& When);

    long GetNumInstructions();
protected:
    CWbemInterval TimeToWait();
    void TouchHead();
public:

protected:
    struct CQueueEl
    {
        CWbemTime m_When;
        CTimerInstruction* m_pInst;
        CQueueEl* m_pNext;

        CQueueEl() : m_pInst(NULL), m_pNext(NULL){}
        CQueueEl(ADDREF CTimerInstruction* pInst, CWbemTime When) 
            : m_pInst(pInst), m_pNext(NULL), m_When(When)
        {
            if(pInst)pInst->AddRef();
        }
        ~CQueueEl() 
        {
            if(m_pInst) m_pInst->Release();
        }
    };

    CQueueEl* m_pQueue;

    CCritSec m_csQueue;
    HANDLE m_hNewHead;
    BOOL m_bBreak;
};


///*****************************************************************************
//
//  class CTimerGenerator                       
//
//  Primary Timer Subsystem class. Accepts timer instructions and fires them
//  at approriate times.
//
//*****************************************************************************

class POLARITY CTimerGenerator : public CHaltable
{
public:    
    CTimerGenerator();
   ~CTimerGenerator(); 

    HRESULT Set(ADDREF CTimerInstruction *pInst, 
                    CWbemTime NextFiring = CWbemTime::GetZero());
    HRESULT Remove(CInstructionTest* pPred);
    virtual HRESULT Shutdown();
    void ScheduleFreeUnusedLibraries();

protected:
    virtual void NotifyStartingThread(){}
    virtual void NotifyStoppingThread(){}
private:
    static DWORD SchedulerThread(LPVOID pArg);
    void EnsureRunning();

protected:
    CInstructionQueue m_Queue;
    HANDLE    m_hSchedulerThread;
    BOOL    m_fExitNow;                                     
    CCritSec m_cs;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\unk.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    UNK.CPP

Abstract:

    IUnknown Helpers

History:

--*/

#include "precomp.h"

#include "unk.h"


CUnk::CUnk(CLifeControl* pControl, IUnknown* pOuter)
    : m_lRef(0), m_pControl(pControl), m_pOuter(pOuter)
{
    if( m_pControl ) 
    {
        m_pControl->ObjectCreated((IUnknown*)this);
    }
}

CUnk::~CUnk()
{
    if( m_pControl ) 
    {
        m_pControl->ObjectDestroyed((IUnknown*)this);
    }
}

BOOL CUnk::Initialize()
{
    m_lRef++;
    GetUnknown()->AddRef();
    BOOL bRes = OnInitialize();
    GetUnknown()->Release();
    m_lRef--;
    return bRes;
}

// Non-delegating implementation
STDMETHODIMP CUnk::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown)
        *ppv = (IUnknown*)this;
    else
        *ppv = GetInterface(riid);

    if(*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;
}

ULONG CUnk::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG CUnk::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
    {
        m_lRef++;
        delete this;
    }
    return lRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\txttempl.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include "txttempl.h"
#include <stdio.h>
#include <assert.h>
#include "var.h"

CTextTemplate::CTextTemplate(LPCWSTR wszTemplate) : m_wsTemplate(wszTemplate)
{
}
    
CTextTemplate::~CTextTemplate()
{
}

void CTextTemplate::SetTemplate(LPCWSTR wszTemplate)
{
    m_wsTemplate = wszTemplate;
}

// replace escape sequences with proper characters
// currently enabled for:
// \t; \n; \r;
// anything else is translated literally, minus the backwhack
// returned string may or may not be same string as passed in
// if not, then arg string is deleted & a new one returned.
// -=> Thou Hast Been Forewarned!
BSTR CTextTemplate::ReturnEscapedReturns(BSTR str)
{
    BSTR newStr = str;
    
    // if we find a backwhack
    if (NULL != wcschr(str, L'\\'))
    {
        if (newStr = SysAllocString(str))
        {
            WCHAR *pSource, *pDest;
            ZeroMemory(newStr, (wcslen(str)+1) *2);

            pDest = newStr;
            pSource = str;

            do 
            {
                if (*pSource == L'\\')
                {
                    pSource++;
                    switch (*pSource)
                    {
                        case L'n' : 
                        case L'N' : 
                            *pDest = L'\n';
                            break;
                        case L't' : 
                        case L'T' : 
                            *pDest = L'\t';
                            break;
                        case L'r' : 
                        case L'R' : 
                           *pDest = L'\r';
                            break;
                        default:
                            *pDest = *pSource;
                    }
                }
                else
                    *pDest = *pSource;

                pDest++;
            }
            while (*++pSource);

            *pDest = '\0';
            SysFreeString(str);
        }
        else
            // graceful degradation: return untranslated string if we're out of memory
            // user sees ugly escape sequence but is better than failing altogether.
            newStr = str;
    }

    return newStr;
};

// v is an array (caller's supposed to check)
// str is a string representing that array
// this fcn checks for single element arrays
// and if so, magically transforms 
// "{element}" to "element"
// BSTR returned may or may not be the same as the one passed in.
BSTR CTextTemplate::ProcessArray(const VARIANT& v, BSTR str)
{
    if (SafeArrayGetDim(v.parray) == 1)
    {
        long lBound =0, uBound =0;
        SafeArrayGetLBound(v.parray, 1, &lBound);
        SafeArrayGetUBound(v.parray, 1, &uBound);

        UINT nStrLen = wcslen(str);

        assert( nStrLen >= 2 );

        // check if there's one element

        if (uBound == lBound)
        {
            // single dimensioned array, with a single element.
            // nuke the curlies by copying everything but.
            
            UINT lastChar = nStrLen - 2;            

            for (UINT i = 1; i <= lastChar; i++)
                str[i-1] = str[i];
            str[lastChar] = L'\0';
        }
        else
        {
            //
            // convert the curlies to parentheses. note that this 
            // only works for single dimensional arrays.
            //
            str[0] = '(';
            str[nStrLen-1] = ')';
        }
            
    }
    
    return str;
}

// concatentates property onto string
// does so without quotes around the property, instead of:
//     str "prop"
// you get:
//     str prop
// we do *not* check for escapes in this function: we blindly strip off the leading & trailing quote
void CTextTemplate::ConcatWithoutQuotes(WString& str, BSTR& property)
{
    // dump the quotes
    if ((property[0] == L'\"') && (property[wcslen(property) -1] == L'\"'))
    {
        // hop past the first one
        WCHAR* p = property;
        p++;
        str += p;

		// null out the last one
		p = (wchar_t*)str;
		p[wcslen(p) -1] = L'\0';
    }
    else
        str += property;

}

BSTR CTextTemplate::Apply(IWbemClassObject* pObj)
{
    WString wsText; 
    
    WCHAR* pwc = (WCHAR*)m_wsTemplate;
    while(*pwc)
    {
        if(*pwc != L'%')
        {
            wsText += *pwc;
        }
        else
        {
            pwc++;

            if(*pwc == L'%')
            {
                // Double %
                // ========

                wsText += L'%';
            }
            else
            {
                // It's a property --- find the end
                // ================================

                WCHAR *pwcEnd = wcschr(pwc, L'%');
                if(pwcEnd == NULL)  
                {
                    // No end --- fail
                    // ===============

                    wsText += L"<error>";
                    break;
                }
                else
                {
                    // Look for the optional formatting string.
                    WCHAR *pszFormat = wcschr(pwc, '(');

                    // If we found a paren before what we thought was
                    // the end, look for the end of the formatting string.
                    // Once we find it, look again for the real end.  We do
                    // this in case the % we found was actually part of the
                    // formatting string.
                    if (pszFormat && pszFormat < pwcEnd)
                    {
                        pszFormat = wcschr(pszFormat + 1, ')');
                        if (pszFormat)
                            pwcEnd = wcschr(pszFormat + 1, '%');
                    }


                    WCHAR *wszName = new WCHAR[pwcEnd - pwc + 1];
                          
                    if (!wszName)
                        return NULL;

                    wcsncpy(wszName, pwc, pwcEnd - pwc);
                    wszName[pwcEnd-pwc] = 0;

                    // Look for the optional formatting string.
                    if ((pszFormat = wcschr(wszName, '(')) != NULL)
                    {
                        WCHAR *pszEndFormat;

                        *pszFormat = 0;
                        pszFormat++;

                        pszEndFormat = wcschr(pszFormat, ')');

                        if (pszEndFormat)
                            *pszEndFormat = 0;
                        else
                            // In case of a bad format string.
                            pszFormat = NULL;
                    }

                        
                    // Get it
                    // ======

                    if(!_wcsicmp(wszName, L"__TEXT"))
                    {
                        BSTR strText = NULL;

                        pObj->GetObjectText(0, &strText);
                        if(strText != NULL)
                        {
                            wsText += strText;
                            SysFreeString( strText );
                        }
                        else 
                            wsText += L"<error>";

                    }
                    else if(IsEmbeddedObjectProperty(wszName))
                    {
                        // We have embedded object(s)
                        // ==========================

                        BSTR bstr = HandleEmbeddedObjectProperties(wszName, pObj);

                        if (bstr)
                        {
						    // we want to do this here, rather than in the HandleEmbeddedObjectProperties
						    // because that call can go recursive, thereby removing too many backwhacks!
                            bstr = ReturnEscapedReturns(bstr);
                            if (bstr)
                            {
                                ConcatWithoutQuotes(wsText, bstr);
                                SysFreeString(bstr);
                            }
                        }
                    }
                    else 
                    {
                        VARIANT v;
                        VariantInit(&v);
                        CIMTYPE ct;
                        HRESULT hres = pObj->Get(wszName, 0, &v, &ct, NULL);
    
                        // Append its value
                        // ================
                        if (WBEM_E_NOT_FOUND == hres)
			                wsText += L"<unknown>";
                        else if(FAILED(hres))
                            wsText += L"<failed>";                
                        else if (V_VT(&v) == VT_NULL)
                        {
                            wsText += L"<null>";
                        }
                        else if (V_VT(&v) == VT_UNKNOWN)
                        {
                            BSTR strText = NULL;
                            IWbemClassObject* pEmbeddedObj;
                            if (SUCCEEDED(V_UNKNOWN(&v)->QueryInterface(IID_IWbemClassObject, (void**)&pEmbeddedObj)))
                            {                                                                
                                pEmbeddedObj->GetObjectText(0, &strText);
                                pEmbeddedObj->Release();
                            }

                            if(strText != NULL)
                                wsText += strText;
                            else 
                                wsText += L"<error>";

                            SysFreeString(strText);
                        }
                        else if ( V_VT(&v) == (VT_UNKNOWN | VT_ARRAY) )
                        {
                            // We have an array of objects
                            // ==============================================
                            
                            long ix[2] = {0,0};
                            long lLower, lUpper;

                            int iDim = SafeArrayGetDim(v.parray); 
                            HRESULT hr=SafeArrayGetLBound(v.parray,1,&lLower);
                            hr = SafeArrayGetUBound(v.parray, 1, &lUpper);

                            wsText += L"{";

                            for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++)
                            {
                                IUnknown HUGEP *pUnk;
                                hr = SafeArrayGetElement( v.parray,
                                                          &(ix[0]),
                                                          &pUnk);

                                BSTR strText = NULL;
                                IWbemClassObject* pEmbeddedObj;
                                if (SUCCEEDED(pUnk->QueryInterface(
                                               IID_IWbemClassObject, 
                                               (void**)&pEmbeddedObj)))
                                {                                     
                                    pEmbeddedObj->GetObjectText(0, &strText);
                                    pEmbeddedObj->Release();
                                }

                                if(strText != NULL)
                                    wsText += strText;
                                else 
                                    wsText += L"<error>";

                                SysFreeString(strText);

                                if(ix[0] < lUpper)
                                {
                                    wsText += L", ";
                                }
                            }

                            wsText += L"}";
                        }
                        else 
                        {
                            CVar Var;
                            Var.SetVariant(&v);
                            BSTR str = Var.GetText(0, ct, pszFormat);

                            if (str == NULL)
                            {
                                wsText += L"<error>";
                            }
                            else 
                            {
                                if (V_VT(&v) & VT_ARRAY)
                                    str = ProcessArray(v, str);

                                if (str)
                                {                                
                                    str = ReturnEscapedReturns(str);

                                    if (str)
                                    {
                                        ConcatWithoutQuotes(wsText, str);
                                        SysFreeString(str);
                                    }
                                }
                            }
                        }
                        
                        VariantClear(&v);
                    }

                    delete [] wszName;

                    // Move the pointer
                    // ================

                    pwc = pwcEnd;
                }
            }
        }

        pwc++;
    }

    BSTR str = SysAllocString(wsText);
    return str;
}

                                                
BSTR CTextTemplate::HandleEmbeddedObjectProperties(WCHAR* wszTemplate, IWbemClassObject* pObj)
{
	WString wsText;

	// Get the embedded object/array
	// =============================

	WCHAR* pwc = wszTemplate;
	WCHAR* pwcEnd = wcschr(wszTemplate, L'.');

	if(!pwcEnd)
	{
		BSTR bstr = SysAllocString(L"<error>");
		return bstr;	
	}

	WCHAR* wszName = new WCHAR[pwcEnd - pwc + 1];
    if (!wszName)
        return SysAllocString(L"<failed>");

    wcsncpy(wszName, pwc, pwcEnd - pwc);
    wszName[pwcEnd-pwc] = 0;

	VARIANT v;
    VariantInit(&v);
    HRESULT hres = pObj->Get(wszName, 0, &v, NULL, NULL);
	delete [] wszName;

   if (WBEM_E_NOT_FOUND == hres)
		return SysAllocString(L"<unknown>");
    else if(FAILED(hres))
        return SysAllocString(L"<failed>");                
    else if (V_VT(&v) == VT_NULL)
		return SysAllocString(L"<null>");

	pwc = wcschr(wszTemplate, L'.');
	WCHAR wszProperty[1024];
	wcscpy(wszProperty, (pwc + 1));

	if(V_VT(&v) == VT_UNKNOWN)
	{
		// We have a single object, so process it
		// =======================================

		BSTR bstr = GetPropertyFromIUnknown(wszProperty, V_UNKNOWN(&v));

        if (bstr)
        {
		    wsText += bstr;
		    SysFreeString(bstr);
        }
	}
	else if((V_VT(&v) & VT_ARRAY) && (V_VT(&v) & VT_UNKNOWN))
	{
		// We have an array of objects, so process the elements
		// ====================================================
		
		long ix[2] = {0,0};
		long lLower, lUpper;

		int iDim = SafeArrayGetDim(v.parray); 
		HRESULT hr = SafeArrayGetLBound(v.parray, 1, &lLower);
		hr = SafeArrayGetUBound(v.parray, 1, &lUpper);

		wsText += L"{";

		for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++){

			IUnknown HUGEP *pUnk;
			hr = SafeArrayGetElement(v.parray, &(ix[0]), &pUnk);

			BSTR bstr = GetPropertyFromIUnknown(wszProperty, pUnk);

            if (bstr)
            {
			    wsText += bstr;
			    SysFreeString(bstr);
            }

			if(ix[0] < lUpper)
			{
				wsText += L", ";
			}
		}

		wsText += L"}";
	}
	else
	{
		// We have something else, which we shouldn't
		// ==========================================

		wsText += L"<error>";
	}

	VariantClear(&v);

	BSTR str = SysAllocString(wsText);
	// we don't want to do this here, it could go recursive & remove too many backwhacks!
    // str = ReturnEscapedReturns(str);

    return str;
}

BOOL CTextTemplate::IsEmbeddedObjectProperty(WCHAR * wszProperty)
{
	WCHAR* pwcStart = wcschr(wszProperty, L'[');

	if(pwcStart)
	{
		return TRUE;
	}

	pwcStart = wcschr(wszProperty, L'.');

	if(pwcStart)
	{
		return TRUE;
	}

	return FALSE;
}

BSTR CTextTemplate::GetPropertyFromIUnknown(WCHAR *wszProperty, IUnknown *pUnk)
{
	BSTR bstrRetVal = NULL;
	IWbemClassObject *pEmbedded  = NULL;

	// Get an IWbemClassObject pointer
	// ===============================

	HRESULT hres = pUnk->QueryInterface( IID_IWbemClassObject, 
                                             (void **)&pEmbedded );

	if(SUCCEEDED(hres))
	{
            // For each object get the desired property
            // ========================================

            if(IsEmbeddedObjectProperty(wszProperty))
            {
                // We have more embedded object(s)
                // ===============================
                BSTR bstr = HandleEmbeddedObjectProperties( wszProperty, 
                                                            pEmbedded );
                if (bstr)
                {
                    bstrRetVal = SysAllocString(bstr);
                    SysFreeString(bstr);
                }
            }
            else
            {
                VARIANT vProp;
                VariantInit(&vProp);
                CIMTYPE ct;
                HRESULT hRes = pEmbedded->Get( wszProperty, 0, &vProp,
                                               &ct, NULL );

                if (WBEM_E_NOT_FOUND == hRes)
                {
                    bstrRetVal = SysAllocString(L"<unknown>");
                }
                else if(FAILED(hRes))
                {
                    bstrRetVal = SysAllocString(L"<failed>");                
                }
                else if (V_VT(&vProp) == VT_NULL)
                {
                    bstrRetVal = SysAllocString(L"<null>");
                }
                else 
                {
                    BSTR str = NULL;
                    
                    if ( V_VT(&vProp) == ( VT_UNKNOWN | VT_ARRAY ) )
                    {
                        WString wsText;

                        // We have an array of objects
                        // ==============================================
                        
                        long ix[2] = {0,0};
                        long lLower, lUpper;
                        
                        int iDim = SafeArrayGetDim(vProp.parray); 
                        HRESULT hr=SafeArrayGetLBound(vProp.parray,1,&lLower);
                        hr = SafeArrayGetUBound(vProp.parray, 1, &lUpper);
                        
                        wsText += L"{";

                        for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++)
                        {
                            IUnknown *pUnkHere = NULL;
                            hr = SafeArrayGetElement( vProp.parray,
                                                      &(ix[0]),
                                                      &pUnkHere );
                            
                            BSTR strText = NULL;
                            IWbemClassObject* pEmbeddedObj = NULL;
                            if (SUCCEEDED(pUnkHere->QueryInterface(
                                               IID_IWbemClassObject, 
                                               (void**)&pEmbeddedObj)))
                            {                                     
                                pEmbeddedObj->GetObjectText(0, &strText);
                                pEmbeddedObj->Release();
                            }

                            if(strText != NULL)
                                wsText += strText;
                            else 
                                wsText += L"<error>";

                            SysFreeString(strText);

                            if(ix[0] < lUpper)
                            {
                                wsText += L", ";
                            }
                        }

                        wsText += L"}";

                        str = SysAllocString( wsText );
                    }
                    else if ( V_VT(&vProp) != VT_UNKNOWN )
                    {
                        CVar Var;
                        Var.SetVariant(&vProp);
                        str = Var.GetText( 0, ct );
                    }
                    else
                    {
                        IWbemClassObject* pEmbedded2;
                        hres = V_UNKNOWN(&vProp)->QueryInterface(
                                                  IID_IWbemClassObject,
                                                  (void**)&pEmbedded2 );
                        if ( SUCCEEDED(hres) )
                        {
                            pEmbedded2->GetObjectText( 0, &str );
                            pEmbedded2->Release();
                        }
                    }
                    
                    if( str == NULL )
                    {
                        bstrRetVal = SysAllocString(L"<error>");
                    }
                    else 
                    {
                        bstrRetVal = SysAllocString(str);
                        SysFreeString(str);
                    }

                    if ( V_VT(&vProp) & VT_ARRAY )
                    {
                        bstrRetVal = ProcessArray(vProp, bstrRetVal);
                    }
                }

                VariantClear( &vProp );
            }

            pEmbedded->Release();
            pEmbedded = NULL;
	}

	return bstrRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\unk.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    UNK.H

Abstract:

    IUnknown Helpers

History:

--*/

#ifndef __WBEM_UNKNOWN__H_
#define __WBEM_UNKNOWN__H_

#include <objbase.h>
#include "corepol.h"

#pragma warning(disable : 4355)
class POLARITY CLifeControl
{
public:
    virtual BOOL ObjectCreated(IUnknown* pv) = 0;
    virtual void ObjectDestroyed(IUnknown* pv) = 0;
    virtual void AddRef(IUnknown* pv) = 0;
    virtual void Release(IUnknown* pv) = 0;
};
   
class POLARITY CContainerControl : public CLifeControl
{
protected:
    IUnknown* m_pUnk;
public:
    CContainerControl(IUnknown* pUnk) : m_pUnk(pUnk){}

    virtual BOOL ObjectCreated(IUnknown* pv){ return TRUE;};
    virtual void ObjectDestroyed(IUnknown* pv){};
    virtual void AddRef(IUnknown* pv){m_pUnk->AddRef();}
    virtual void Release(IUnknown* pv){m_pUnk->Release();}
};

class POLARITY CUnk : public IUnknown
{
public:// THIS IS DUE TO A VC++ BUG!!! protected:
    long m_lRef;
    CLifeControl* m_pControl;
    IUnknown* m_pOuter;

    IUnknown* GetUnknown() {return m_pOuter?m_pOuter:(IUnknown*)this;}

    virtual void* GetInterface(REFIID riid) = 0;
    virtual BOOL OnInitialize(){return TRUE;}
public:
    CUnk(CLifeControl* pControl = NULL, IUnknown* pOuter = NULL);
    virtual ~CUnk();
    virtual BOOL Initialize();

    // non-delegating interface
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    IUnknown* GetInnerUnknown() {return this;}
    void SetControl(CLifeControl* pControl);
};

class POLARITY CUnkInternal : public IUnknown
{
protected:

    long m_lRef;
    CLifeControl* m_pControl;

public:

    CUnkInternal( CLifeControl* pControl ) : m_pControl(pControl), m_lRef(0) {}
    virtual ~CUnkInternal() {}

    virtual void* GetInterface(REFIID riid) = 0;
    IUnknown* GetUnknown() { return (IUnknown*)this; }

    STDMETHOD(QueryInterface)(REFIID riid, void** ppv)
    {
        HRESULT hr = InternalQueryInterface( riid, ppv );
        if ( SUCCEEDED(hr) )
            AddRef();
        return hr;
    }

    STDMETHOD_(ULONG, AddRef)()
    {
        if ( m_pControl )
            m_pControl->ObjectCreated((IUnknown*)this);
        return InternalAddRef();
    }

    STDMETHOD_(ULONG, Release)()
    {
        CLifeControl* pControl = m_pControl;
        ULONG ulRef = InternalRelease();
        if ( pControl )
            pControl->ObjectDestroyed((IUnknown*)this);
        return ulRef;
    }

    HRESULT InternalQueryInterface( REFIID riid, void** ppv )
    {
        HRESULT hr;

        if( riid == IID_IUnknown )
            *ppv = (IUnknown*)this;
        else 
            *ppv = GetInterface(riid);

        if ( *ppv != NULL )
            hr = S_OK;
        else
            hr = E_NOINTERFACE;

        return hr;
    }

    ULONG InternalAddRef()
    {
         return InterlockedIncrement(&m_lRef);   
    }

    ULONG InternalRelease()
    {
        long lRef = InterlockedDecrement(&m_lRef);
        if(lRef == 0)
            delete this;
        return lRef;        
    }
};


template <class TInterface, class TObject>
class CImpl : public TInterface
{
protected:
    TObject* m_pObject;
public:
    CImpl(TObject* pObject) : m_pObject(pObject){}
    ~CImpl(){}

    // delegating interface
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv)
    {
        return m_pObject->GetUnknown()->QueryInterface(riid, ppv);
    }
    STDMETHOD_(ULONG, AddRef)()
    {
        return m_pObject->GetUnknown()->AddRef();
    }
    STDMETHOD_(ULONG, Release)()
    {
        return m_pObject->GetUnknown()->Release();
    }
};

template <class TInterface, const IID* t_piid>
class CUnkBase : public TInterface
{
protected:
    long m_lRef;
    CLifeControl* m_pControl;

public:
    typedef CUnkBase<TInterface, t_piid> TUnkBase;

    CUnkBase(CLifeControl* pControl = NULL) 
    : m_pControl(pControl), m_lRef(0)
    {
        if ( m_pControl != NULL ) m_pControl->ObjectCreated(this);
    }

    virtual ~CUnkBase()
    {
        if ( m_pControl != NULL ) m_pControl->ObjectDestroyed(this);
    }

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return InterlockedIncrement(&m_lRef);
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        long lRef = InterlockedDecrement(&m_lRef);
        if(lRef == 0)
            delete this;
        return lRef;
    }
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv)
    {
        if(riid == IID_IUnknown || riid == *t_piid)
        {
            AddRef();
            *ppv = this;
            return S_OK;
        }
        else return E_NOINTERFACE;
    }
};

template <class TInterface, const IID* t_piid, class TInterface2,
            const IID* t_piid2>
class CUnkBase2 : public TInterface, public TInterface2
{
protected:
    long m_lRef;
    CLifeControl* m_pControl;

public:
    typedef CUnkBase2<TInterface, t_piid, TInterface2, t_piid2> TUnkBase;

    CUnkBase2(CLifeControl* pControl = NULL) : m_pControl(pControl), m_lRef(0)
    {
        if (m_pControl != NULL) 
            m_pControl->ObjectCreated((TInterface*)this);
    }

    virtual ~CUnkBase2()
    {
        if (m_pControl != NULL) 
            m_pControl->ObjectDestroyed((TInterface*)this);
    }

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return InterlockedIncrement(&m_lRef);
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        long lRef = InterlockedDecrement(&m_lRef);
        if(lRef == 0)
            delete this;
        return lRef;
    }
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv)
    {
        if(riid == IID_IUnknown || riid == *t_piid)
        {
            AddRef();
            *ppv = (TInterface*)this;
            return S_OK;
        }
        else if(riid == *t_piid2)
        {
            AddRef();
            *ppv = (TInterface2*)this;
            return S_OK;
        }
        else return E_NOINTERFACE;
    }
};


template<class TInterface1, class TInterface2>
class CChild2 : public virtual TInterface1, public virtual TInterface2
{
};

template<class TInterfaces>
class CUnkTemplate : public TInterfaces
{
protected:
    IUnknown* m_pOuter;

    class CInnerUnk : public IUnknown
    {
    private:
        CUnkTemplate<TInterfaces>* m_pObject;
        long m_lRef;
        CLifeControl* m_pControl;
    public:
        CInnerUnk(CUnkTemplate<TInterfaces>* pObject, CLifeControl* pControl)
        {
            if(m_pControl) m_pControl->ObjectCreated(this);
            m_lRef++;
            GetUnknown()->AddRef();
            m_pObject->Initialize();
            GetUnknown()->Release();
            m_lRef--;
        }
        ~CInnerUnk()
        {
            if(m_pControl) m_pControl->ObjectDestroyed(this);
        }

        // non-delegating interface
        STDMETHOD(QueryInterface)(REFIID riid, void** ppv)
        {
            if(riid == IID_IUnknown)
                *ppv = (IUnknown*)&m_Inner;
            else
                *ppv = m_pObject->GetInterface(riid);
        
            if(*ppv)
            {
                AddRef();
                return S_OK;
            }
            else return E_NOINTERFACE;
        }
        STDMETHOD_(ULONG, AddRef)()
        {
            if(m_pControl) m_pControl->AddRef((IUnknown*)this);
            return InterlockedIncrement(&m_lRef);
        }
        STDMETHOD_(ULONG, Release)()
        {
            if(m_pControl) m_pControl->Release((IUnknown*)this);
            long lRef = InterlockedDecrement(&m_lRef);
            if(lRef == 0)
            {
                m_lRef++;
                delete m_pObject;
            }
            return lRef;
        }
    } m_Inner;

    IUnknown* GetUnknown() 
        {return m_pOuter?m_pOuter:(IUnknown*)&m_Inner;}
    virtual void Initialize(){}

public:
    CUnkTemplate(CLifeControl* pControl = NULL, IUnknown* pOuter = NULL)
        : m_Inner(this, pControl), m_pOuter(pOuter){}
    virtual ~CUnkTemplate(){}

    // delegating interface
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv)
    {
        return GetUnknown()->QueryInterface(riid, ppv);
    }
    STDMETHOD_(ULONG, AddRef)()
    {
        return GetUnknown()->AddRef();
    }
    STDMETHOD_(ULONG, Release)()
    {
        return GetUnknown()->Release();
    }

    IUnknown* GetInnerUnknown() {return &m_Inner;}
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\unload.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    UNLOAD.CPP

Abstract:

  Unloading helper.

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <wbemcomn.h>
#include <unload.h>
#include <arrtempl.h>

CUnloadInstruction::CUnloadInstruction(LPCWSTR wszPath, 
                                        IWbemContext* pFirstContext)
    : CBasicUnloadInstruction(), m_strPath(SysAllocString(wszPath)),
        m_pFirstContext(pFirstContext), m_pNamespace(NULL)
{
    m_Interval.SetMilliseconds(0);
    if(m_pFirstContext)
        m_pFirstContext->AddRef();
}

void CUnloadInstruction::Clear()
{
}
    
CUnloadInstruction::~CUnloadInstruction()
{
    if(m_pNamespace)
        m_pNamespace->Release();

    SysFreeString(m_strPath);
    if(m_pFirstContext)
        m_pFirstContext->Release();
}

void CUnloadInstruction::SetToDefault()
{
    m_Interval.SetMilliseconds(3600000);
}

void CUnloadInstruction::Reread(IWbemContext* pContext)
{
    HRESULT hres;
    if(m_pNamespace == NULL)
    {
        IWbemLocator * pLocator = NULL;
        hres = CoCreateInstance(CLSID_WbemAdministrativeLocator, NULL, 
            CLSCTX_INPROC_SERVER, IID_IWbemLocator, (void**)&pLocator);
        if(hres == S_OK) 
        {
            hres = pLocator->ConnectServer(L"ROOT", NULL, NULL, NULL,
                0, NULL, NULL, &m_pNamespace);
            pLocator->Release();
        }
    
    
        if(m_pNamespace == NULL)
        {
            SetToDefault();
            return;
        }
    }

    m_Interval = staticRead(m_pNamespace, pContext, m_strPath);
}


CWbemTime CUnloadInstruction::GetFirstFiringTime() const 
{
    if(m_Interval.IsZero())
    {
        // This function is const, but Reread is not, so have to cast
        // ==========================================================

        ((CUnloadInstruction*)this)->Reread(m_pFirstContext);
    }

    return CBasicUnloadInstruction::GetFirstFiringTime();
}

//*****************************************************************************
//
//                      BASIC VERSION
// 
//*****************************************************************************
CBasicUnloadInstruction::CBasicUnloadInstruction(CWbemInterval Interval)
    : m_lRef(0), m_bTerminate(FALSE), m_Interval(Interval)
{
}

void CBasicUnloadInstruction::Terminate()
{
    CInCritSec ics(&m_cs);
    m_bTerminate = TRUE;
}



// static
CWbemInterval CBasicUnloadInstruction::staticRead(IWbemServices* pRoot, 
                IWbemContext* pContext, LPCWSTR wszPath)
{
    HRESULT hres;

    BSTR strPath = SysAllocString(wszPath);
    if(strPath == NULL)
        return CWbemInterval::GetInfinity();
    CSysFreeMe sfm1(strPath);

    IWbemClassObject* pObj = NULL;
    hres = pRoot->GetObject(strPath, 0, pContext, &pObj, NULL);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_WBEMCORE, "Unable to read cache configuration object "
            "at %S: %X\n", strPath, hres));
        return CWbemInterval::GetInfinity();
    }
    CReleaseMe rm1(pObj);

    VARIANT var;
	VariantInit(&var);
    hres = pObj->Get(L"ClearAfter", 0, &var, NULL, NULL);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_WBEMCORE, "No ClearCache property in cache "
            "configuration object at %S: %X\n", strPath, hres));
        return CWbemInterval::GetInfinity();
    }
	CClearMe cm(&var);

    if(var.vt != VT_BSTR)
    {
        return CWbemInterval::GetInfinity();
    }

    DWORD dwYears, dwMonths, dwDays, dwHours, dwMinutes, dwSeconds;
    if(swscanf(var.bstrVal, L"%4u%2u%2u%2u%2u%2u", &dwYears, &dwMonths, 
        &dwDays, &dwHours, &dwMinutes, &dwSeconds) != 6)
    {
        ERRORTRACE((LOG_WBEMCORE, "Unparsable ClearCache property in cache "
            "configuration object at %S: %X\n", strPath, hres));
        return CWbemInterval::GetInfinity();
    }
        
    if(dwYears != 0 || dwMonths != 0)
    {
        // makes no sense
        // ==============

        return CWbemInterval::GetInfinity();
    }

    dwSeconds += dwMinutes * 60 + dwHours * 3600 + dwDays * 3600 * 24;
    CWbemInterval Interval;
    Interval.SetMilliseconds(1000 * dwSeconds);
    return Interval;
}


CWbemTime CBasicUnloadInstruction::GetFirstFiringTime() const 
{
    return CWbemTime::GetCurrentTime() + m_Interval;
}

CWbemTime CBasicUnloadInstruction::GetNextFiringTime(CWbemTime LastFiringTime,
                                OUT long* plFiringCount) const
{
    if(m_bTerminate) 
        return CWbemTime::GetInfinity();

    *plFiringCount = 1;
    return LastFiringTime + m_Interval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\unload.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    UNLOAD.H

Abstract:

  Unloading helper.

History:

--*/

#ifndef _WBEM_UNLOAD__H_
#define _WBEM_UNLOAD__H_

#include <tss.h>
#include <wstring.h>
#include <wbemidl.h>

class POLARITY CBasicUnloadInstruction : public CTimerInstruction
{
protected:
    long m_lRef;
    BOOL m_bTerminate;
    CWbemInterval m_Interval;
    CCritSec m_cs;

protected:
    CBasicUnloadInstruction() : m_lRef(0), m_bTerminate(FALSE){}

public:
    CBasicUnloadInstruction(CWbemInterval Interval);
    virtual ~CBasicUnloadInstruction(){}

    void AddRef(){InterlockedIncrement(&m_lRef);}
    void Release(){if(InterlockedDecrement(&m_lRef) == 0) delete this;}

    int GetInstructionType() {return INSTTYPE_UNLOAD;}
    void SetInterval(CWbemInterval & Interval){m_Interval = Interval;};

    static CWbemInterval staticRead(IWbemServices* pRoot, 
                                      IWbemContext* pContext, LPCWSTR wszPath);

    virtual HRESULT Fire(long lNumTimes, CWbemTime NextFiringTime) = 0;

    CWbemTime GetNextFiringTime(CWbemTime LastFiringTime, 
                                    OUT long* plFiringCount) const;
        
    CWbemTime GetFirstFiringTime() const;
    void Terminate();
};

class  POLARITY CUnloadInstruction : public CBasicUnloadInstruction
{
protected:
    BSTR m_strPath;
    IWbemContext* m_pFirstContext;
    IWbemServices* m_pNamespace;


public:
    CUnloadInstruction(LPCWSTR wszPath, IWbemContext* pFirstContext);
    virtual ~CUnloadInstruction();
    const BSTR GetPath(){return m_strPath;};

    virtual void Reread(IWbemContext* pContext = NULL);
    virtual HRESULT Fire(long lNumTimes, CWbemTime NextFiringTime) = 0;

    CWbemTime GetFirstFiringTime() const;
    static void Clear();
    void SetToDefault();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\wbemcomn.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMCOMN.H

Abstract:

History:

--*/

#ifndef __WBEMCOMN__H_
#define __WBEMCOMN__H_

#define _new new

#include<corepol.h>
#include<wbemidl.h>
#include<md5wbem.h>
#include<unk.h>
#include<clsfac.h>
#include<var.h>
#include<parmdefs.h>
#include<arena.h>
#include<arrtempl.h>
#include<flexarry.h>
#include<flexq.h>
#include<perfhelp.h>
#include<reg.h>
#include<safearry.h>
#include<wstring.h>
#include<wbemutil.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\winntsec.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WINNTSEC.CPP

Abstract:

    Generic wrapper classes for NT security objects.

    Documention on class members is in WINNTSEC.CPP.  Inline members
    are commented in this file.

History:

    raymcc      08-Jul-97       Created.

--*/

#include "precomp.h"

#include <stdio.h>
#include <io.h>
#include <errno.h>
#include <winntsec.h>
#include <tchar.h>

#include <genutils.h>
#include "arena.h"
#include "reg.h"
#include "wbemutil.h"
#include "arrtempl.h"
#include <cominit.h>
extern "C"
{
#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmerr.h>
};

//***************************************************************************
//
//  CNtSid::GetSize
//
//  Returns the size of the SID in bytes.
//
//***************************************************************************
// ok

DWORD CNtSid::GetSize()
{
    if (m_pSid == 0 || !IsValidSid(m_pSid))
        return 0;

    return GetLengthSid(m_pSid);
}

//***************************************************************************
//
//  CNtSid Copy Constructor
//
//***************************************************************************
// ok

CNtSid::CNtSid(CNtSid &Src)
{
    m_pSid = 0;
    m_dwStatus = 0;
    m_pMachine = 0;
    *this = Src;
}

//***************************************************************************
//
//  CNtSid Copy Constructor
//
//***************************************************************************
// ok

CNtSid::CNtSid(SidType st)
{
    m_pSid = 0;
    m_dwStatus = InternalError;
    m_pMachine = 0;
    if(st == CURRENT_USER ||st == CURRENT_THREAD)
    {
        HANDLE hToken;
        if(st == CURRENT_USER)
        {
            if(!OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &hToken))
                return;
        }
        else
        {
            if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken))
                return;
        }

        // Get the user sid
        // ================

        TOKEN_USER tu;
        DWORD dwLen = 0;
        GetTokenInformation(hToken, TokenUser, &tu, sizeof(tu), &dwLen);

        if(dwLen == 0)
        {
            CloseHandle(hToken);
            return;
        }

        BYTE* pTemp = new BYTE[dwLen];
        if (!pTemp)
        {
            CloseHandle(hToken);
            return;
        }

        DWORD dwRealLen = dwLen;
        if(!GetTokenInformation(hToken, TokenUser, pTemp, dwRealLen, &dwLen))
        {
            CloseHandle(hToken);
            delete [] pTemp;
            return;
        }

        CloseHandle(hToken);

        // Make a copy of the SID
        // ======================

        PSID pSid = ((TOKEN_USER*)pTemp)->User.Sid;
        DWORD dwSidLen = GetLengthSid(pSid);
        m_pSid = new BYTE[dwSidLen];
        if (m_pSid)
            CopySid(dwSidLen, m_pSid, pSid);
        delete [] pTemp;
        m_dwStatus = 0;
    }
    return;
}



//***************************************************************************
//
//  CNtSid::CopyTo
//
//  An unchecked copy of the internal SID to the destination pointer.
//
//  Parameters:
//  <pDestination> points to the buffer to which to copy the SID. The
//  buffer must be large enough to hold the SID.
//
//  Return value:
//  TRUE on success, FALSE on failure.
//
//***************************************************************************
// ok

BOOL CNtSid::CopyTo(PSID pDestination)
{
    if (m_pSid == 0 || m_dwStatus != NoError)
        return FALSE;

    DWORD dwLen = GetLengthSid(m_pSid);
    memcpy(pDestination, m_pSid, dwLen);

    return TRUE;
}


//***************************************************************************
//
//  CNtSid assignment operator
//
//***************************************************************************
// ok

CNtSid & CNtSid::operator =(CNtSid &Src)
{
    if (m_pMachine != 0)
    {
        delete [] m_pMachine;
        m_pMachine = 0;
    }

    if (m_pSid != 0)
    {
        delete [] m_pSid;
        m_pSid = 0;
    }

    if (Src.m_pSid == 0)
    {
        m_pSid = 0;
        m_dwStatus = NullSid;
        return *this;
    }

    if (!IsValidSid(Src.m_pSid))
    {
        m_pSid = 0;
        m_dwStatus = InvalidSid;
        return *this;
    }


    // If here, the source has a real SID.
    // ===================================

    DWORD dwLen = GetLengthSid(Src.m_pSid);

    m_pSid = (PSID) new BYTE [dwLen];
    if (!m_pSid)
    {
        m_dwStatus = InternalError;
        return *this;
    }

    ZeroMemory(m_pSid, dwLen);

    if (!CopySid(dwLen, m_pSid, Src.m_pSid))
    {
        delete [] m_pSid;
        m_pSid = NULL;
        m_dwStatus = InternalError;
        return *this;
    }

    if (Src.m_pMachine)
    {
        m_pMachine = new wchar_t[wcslen(Src.m_pMachine) + 1];
        if (!m_pMachine)
        {
            delete [] m_pSid;
            m_pSid = NULL;
            m_dwStatus = InternalError;
            return *this;
        }

        wcscpy(m_pMachine, Src.m_pMachine);
    }

    m_dwStatus = NoError;
    return *this;
}

//***************************************************************************
//
//  CNtSid comparison operator
//
//***************************************************************************
int CNtSid::operator ==(CNtSid &Comparand)
{
    if (m_pSid == 0 && Comparand.m_pSid == 0)
        return 1;
    if (m_pSid == 0 || Comparand.m_pSid == 0)
        return 0;

    return EqualSid(m_pSid, Comparand.m_pSid);
}

//***************************************************************************
//
//  CNtSid::CNtSid
//
//  Constructor which builds a SID directly from a user or group name.
//  If the machine is available, then its name can be used to help
//  distinguish the same name in different SAM databases (domains, etc).
//
//  Parameters:
//
//  <pUser>     The desired user or group.
//
//  <pMachine>  Points to a machine name with or without backslashes,
//              or else is NULL, in which case the current machine, domain,
//              and trusted domains are searched for a match.
//
//  After construction, call GetStatus() to determine if the constructor
//  succeeded.  NoError is expected.
//
//***************************************************************************
// ok

CNtSid::CNtSid(
    LPWSTR pUser,
    LPWSTR pMachine
    )
{
    DWORD  dwRequired = 0;
    DWORD  dwDomRequired = 0;
    LPWSTR pszDomain = NULL;
    m_pSid = 0;
    m_pMachine = 0;

    if (pMachine)
    {
        m_pMachine = new wchar_t[wcslen(pMachine) + 1];
        if (!m_pMachine)
        {
            m_dwStatus = Failed;
            return;
        }
        
        wcscpy(m_pMachine, pMachine);
    }

    BOOL bRes = LookupAccountNameW(
        m_pMachine,
        pUser,
        m_pSid,
        &dwRequired,
        pszDomain,
        &dwDomRequired,
        &m_snu
        );

    DWORD dwLastErr = GetLastError();

    if (dwLastErr != ERROR_INSUFFICIENT_BUFFER)
    {
        m_pSid = 0;
        if (dwLastErr == ERROR_ACCESS_DENIED)
            m_dwStatus = AccessDenied;
        else
            m_dwStatus = InvalidSid;
        return;
    }

    m_pSid = (PSID) new BYTE [dwRequired];
    if (!m_pSid)
    {
        m_dwStatus = Failed;
        return;
    }

    ZeroMemory(m_pSid, dwRequired);
    pszDomain = new wchar_t[dwDomRequired + 1];
    if (!pszDomain)
    {
        delete [] m_pSid;
        m_pSid = 0;
        m_dwStatus = Failed;
        return;
    }

    bRes = LookupAccountNameW(
        pMachine,
        pUser,
        m_pSid,
        &dwRequired,
        pszDomain,
        &dwDomRequired,
        &m_snu
        );

    if (!bRes || !IsValidSid(m_pSid))
    {
        delete [] m_pSid;
        delete [] pszDomain;
        m_pSid = 0;
        m_dwStatus = InvalidSid;
        return;
    }

    delete [] pszDomain;   // We never really needed this
    m_dwStatus = NoError;
}

//***************************************************************************
//
//  CNtSid::CNtSid
//
//  Constructs a CNtSid object directly from an NT SID. The SID is copied,
//  so the caller retains ownership.
//
//  Parameters:
//  <pSrc>      The source SID upon which to base the object.
//
//  Call GetStatus() after construction to ensure the object was
//  constructed correctly.  NoError is expected.
//
//***************************************************************************
// ok

CNtSid::CNtSid(PSID pSrc)
{
    m_pMachine = 0;
    m_pSid = 0;
    m_dwStatus = NoError;

    if (!IsValidSid(pSrc))
    {
        m_dwStatus = InvalidSid;
        return;
    }

    DWORD dwLen = GetLengthSid(pSrc);

    m_pSid = (PSID) new BYTE [dwLen];
    // Check for mem. alloc. failure
	// NT RAID#: 158600		[marioh]
	if ( m_pSid == NULL )
	{
        m_dwStatus = Failed;
		return;
	}

	ZeroMemory(m_pSid, dwLen);

    if (!CopySid(dwLen, m_pSid, pSrc))
    {
        delete [] m_pSid;
        m_dwStatus = InternalError;
        return;
    }
}

//***************************************************************************
//
//  CNtSid::GetInfo
//
//  Returns information about the SID.
//
//  Parameters:
//  <pRetAccount>       Receives a UNICODE string containing the account
//                      name (user or group).  The caller must use operator
//                      delete to free the memory.  This can be NULL if
//                      this information is not required.
//  <pRetDomain>        Returns a UNICODE string containing the domain
//                      name in which the account resides.   The caller must
//                      use operator delete to free the memory.  This can be
//                      NULL if this information is not required.
//  <pdwUse>            Points to a DWORD to receive information about the name.
//                      Possible return values are defined under SID_NAME_USE
//                      in NT SDK documentation.  Examples are
//                      SidTypeUser, SidTypeGroup, etc.  See CNtSid::Dump()
//                      for an example.
//
//  Return values:
//  NoError, InvalidSid, Failed
//
//***************************************************************************
// ok

int CNtSid::GetInfo(
    LPWSTR *pRetAccount,       // Account, use operator delete
    LPWSTR *pRetDomain,        // Domain, use operator delete
    DWORD  *pdwUse             // See SID_NAME_USE for values
    )
{
    if (pRetAccount)
        *pRetAccount = 0;
    if (pRetDomain)
        *pRetDomain  = 0;
    if (pdwUse)
        *pdwUse   = 0;

    if (!m_pSid || !IsValidSid(m_pSid))
        return InvalidSid;

    DWORD  dwNameLen = 0;
    DWORD  dwDomainLen = 0;
    LPWSTR pUser = 0;
    LPWSTR pDomain = 0;
    SID_NAME_USE Use;


    // Do the first lookup to get the buffer sizes required.
    // =====================================================

    BOOL bRes = LookupAccountSidW(
        m_pMachine,
        m_pSid,
        pUser,
        &dwNameLen,
        pDomain,
        &dwDomainLen,
        &Use
        );

    DWORD dwLastErr = GetLastError();

    if (dwLastErr != ERROR_INSUFFICIENT_BUFFER)
    {
        return Failed;
    }

    // Allocate the required buffers and look them up again.
    // =====================================================

    pUser = new wchar_t[dwNameLen + 1];
    if (!pUser)
        return Failed;

    pDomain = new wchar_t[dwDomainLen + 1];
    if (!pDomain)
    {
        delete pUser;
        return Failed;
    }

    bRes = LookupAccountSidW(
        m_pMachine,
        m_pSid,
        pUser,
        &dwNameLen,
        pDomain,
        &dwDomainLen,
        &Use
        );

    if (!bRes)
    {
        delete [] pUser;
        delete [] pDomain;
        return Failed;
    }

    if (pRetAccount)
        *pRetAccount = pUser;
    else
        delete [] pUser;
    if (pRetDomain)
        *pRetDomain  = pDomain;
    else
        delete [] pDomain;
    if (pdwUse)
        *pdwUse = Use;

    return NoError;
}

//***************************************************************************
//
//  CNtSid::Dump
//
//  Dumps the SID to the console outuput for debugging.
//
//***************************************************************************
// ok

void CNtSid::Dump()
{
    LPWSTR pUser, pDomain;
    DWORD dwUse;

    printf("---SID DUMP---\n");

    if (m_pSid == 0)
    {
        printf("<NULL>\n");
        return;
    }

    if (!IsValidSid(m_pSid))
    {
        printf("<Invalid Sid>\n");
        return;
    }

    int nRes = GetInfo(&pUser, &pDomain, &dwUse);

    if (nRes != NoError)
        return;

    // Print out SID in SID-style notation.
    // ====================================

    // Print out human-readable info.
    // ===============================

    printf("User = %S  Domain = %S  Type = ", pUser, pDomain);

    delete [] pUser;
    delete [] pDomain;

    switch (dwUse)
    {
        case SidTypeUser:
            printf("SidTypeUser\n");
            break;

        case SidTypeGroup:
            printf("SidTypeGroup\n");
            break;

        case SidTypeDomain:
            printf("SidTypeDomain\n");
            break;

        case SidTypeAlias:
            printf("SidTypeAlias\n");
            break;

        case SidTypeWellKnownGroup:
            printf("SidTypeWellKnownGroup\n");
            break;

        case SidTypeDeletedAccount:
            printf("SidTypeDeletedAccount\n");
            break;

        case SidTypeUnknown:
            printf("SidTypeUnknown\n");
            break;

        case SidTypeInvalid:
        default:
            printf("SidTypeInvalid\n");
    }
}

//***************************************************************************
//
//  CNtSid destructor
//
//***************************************************************************

CNtSid::~CNtSid()
{
    if (m_pSid)
        delete [] m_pSid;
    if (m_pMachine)
        delete [] m_pMachine;
}

//***************************************************************************
//
//  CNtSid::GetTextSid
//
//  Converts the sid to text form.  The caller should passin a 130 character
//  buffer.
//
//***************************************************************************

BOOL CNtSid::GetTextSid(LPTSTR pszSidText, LPDWORD dwBufferLen)
{
      PSID_IDENTIFIER_AUTHORITY psia;
      DWORD dwSubAuthorities = 0;
      DWORD dwSidRev=SID_REVISION;
      DWORD dwCounter = 0;
      DWORD dwSidSize = 0;

      // test if Sid is valid

      if(m_pSid == 0 || !IsValidSid(m_pSid))
          return FALSE;

      // obtain SidIdentifierAuthority

      psia=GetSidIdentifierAuthority(m_pSid);

      // obtain sidsubauthority count

      PUCHAR p = GetSidSubAuthorityCount(m_pSid);
      dwSubAuthorities = *p;

      // compute buffer length
      // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL

      dwSidSize=(15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);

      // check provided buffer length.  If not large enough, indicate proper size.

      if (*dwBufferLen < dwSidSize)
      {
         *dwBufferLen = dwSidSize;
         return FALSE;
      }

      // prepare S-SID_REVISION-

      dwSidSize=wsprintf(pszSidText, TEXT("S-%lu-"), dwSidRev );

      // prepare SidIdentifierAuthority

      if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) )
      {
         dwSidSize+=wsprintf(pszSidText + lstrlen(pszSidText),
                             TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
                             (USHORT)psia->Value[0],
                             (USHORT)psia->Value[1],
                             (USHORT)psia->Value[2],
                             (USHORT)psia->Value[3],
                             (USHORT)psia->Value[4],
                             (USHORT)psia->Value[5]);
      }
      else
      {
         dwSidSize+=wsprintf(pszSidText + lstrlen(pszSidText),
                             TEXT("%lu"),
                             (ULONG)(psia->Value[5]      )   +
                             (ULONG)(psia->Value[4] <<  8)   +
                             (ULONG)(psia->Value[3] << 16)   +
                             (ULONG)(psia->Value[2] << 24)   );
      }

      // loop through SidSubAuthorities

      for (dwCounter=0 ; dwCounter < dwSubAuthorities ; dwCounter++)
      {
         dwSidSize+=wsprintf(pszSidText + dwSidSize, TEXT("-%lu"),
         *GetSidSubAuthority(m_pSid, dwCounter) );
      }
      return TRUE;
}


//***************************************************************************
//
//  CNtAce::CNtAce
//
//  Constructor which directly builds the ACE based on a user, access mask
//  and flags without a need to build an explicit SID.
//
//
//  Parameters:
//  <AccessMask>        A WINNT ACCESS_MASK which specifies the permissions
//                      the user should have to the object being secured.
//                      See ACCESS_MASK in NT SDK documentation.
//  <dwAceType>         One of the following:
//                          ACCESS_ALLOWED_ACE_TYPE
//                          ACCESS_DENIED_ACE_TYPE
//                          ACCESS_AUDIT_ACE_TYPE
//                      See ACE_HEADER in NT SDK documentation.
//  <dwAceFlags>        Of of the ACE propation flags.  See ACE_HEADER
//                      in NT SDK documentation for legal values.
//  <sid>               CNtSid specifying the user or group for which the ACE is being
//                      created.
//
//  After construction, call GetStatus() to verify that the ACE
//  is valid. NoError is expected.
//
//***************************************************************************
// ok

CNtAce::CNtAce(
    ACCESS_MASK AccessMask,
    DWORD dwAceType,
    DWORD dwAceFlags,
    CNtSid & Sid
    )
{
    m_pAce = 0;
    m_dwStatus = 0;

    // If the SID is invalid, the ACE will be as well.
    // ===============================================

    if (Sid.GetStatus() != CNtSid::NoError)
    {
        m_dwStatus = InvalidAce;
        return;
    }

    // Compute the size of the ACE.
    // ============================

    DWORD dwSidLength = Sid.GetSize();

    DWORD dwTotal = dwSidLength + sizeof(GENERIC_ACE) - 4;

    m_pAce = (PGENERIC_ACE) new BYTE[dwTotal];
    
    if (m_pAce)
    {
        ZeroMemory(m_pAce, dwTotal);

        // Build up the ACE info.
        // ======================

        m_pAce->Header.AceType  = BYTE(dwAceType);
        m_pAce->Header.AceFlags = BYTE(dwAceFlags);
        m_pAce->Header.AceSize = WORD(dwTotal);
        m_pAce->Mask = AccessMask;

        BOOL bRes = Sid.CopyTo(PSID(&m_pAce->SidStart));

        if (!bRes)
        {
            delete m_pAce;
            m_pAce = 0;
            m_dwStatus = InvalidAce;
            return;
        }

        m_dwStatus = NoError;
    }
    else
        m_dwStatus = InternalError;
}

//***************************************************************************
//
//  CNtAce::CNtAce
//
//  Constructor which directly builds the ACE based on a user, access mask
//  and flags without a need to build an explicit SID.
//
//
//  Parameters:
//  <AccessMask>        A WINNT ACCESS_MASK which specifies the permissions
//                      the user should have to the object being secured.
//                      See ACCESS_MASK in NT SDK documentation.
//  <dwAceType>         One of the following:
//                          ACCESS_ALLOWED_ACE_TYPE
//                          ACCESS_DENIED_ACE_TYPE
//                          ACCESS_AUDIT_ACE_TYPE
//                      See ACE_HEADER in NT SDK documentation.
//  <dwAceFlags>        Of of the ACE propation flags.  See ACE_HEADER
//                      in NT SDK documentation for legal values.
//  <pUser>             The user or group for which the ACE is being
//                      created.
//  <pMachine>          If NULL, the current machine, domain, and trusted
//                      domains are searched for a match.  If not NULL,
//                      can point to a UNICODE machine name (with or without
//                      leading backslashes) which contains the account.
//
//  After construction, call GetStatus() to verify that the ACE
//  is valid. NoError is expected.
//
//***************************************************************************
// ok

CNtAce::CNtAce(
    ACCESS_MASK AccessMask,
    DWORD dwAceType,
    DWORD dwAceFlags,
    LPWSTR pUser,
    LPWSTR pMachine
    )
{
    m_pAce = 0;
    m_dwStatus = 0;

    // Create the SID of the user.
    // ===========================

    CNtSid Sid(pUser, pMachine);

    // If the SID is invalid, the ACE will be as well.
    // ===============================================

    if (Sid.GetStatus() != CNtSid::NoError)
    {
        m_dwStatus = InvalidAce;
        return;
    }

    // Compute the size of the ACE.
    // ============================

    DWORD dwSidLength = Sid.GetSize();

    DWORD dwTotal = dwSidLength + sizeof(GENERIC_ACE) - 4;

    m_pAce = (PGENERIC_ACE) new BYTE[dwTotal];
	if ( m_pAce == NULL )
	{
        m_dwStatus = InternalError;		
		return;
	}
    ZeroMemory(m_pAce, dwTotal);

    // Build up the ACE info.
    // ======================

    m_pAce->Header.AceType  = BYTE(dwAceType);
    m_pAce->Header.AceFlags = BYTE(dwAceFlags);
    m_pAce->Header.AceSize = WORD(dwTotal);
    m_pAce->Mask = AccessMask;

    BOOL bRes = Sid.CopyTo(PSID(&m_pAce->SidStart));

    if (!bRes)
    {
        delete m_pAce;
        m_pAce = 0;
        m_dwStatus = InvalidAce;
        return;
    }

    m_dwStatus = NoError;
}

//***************************************************************************
//
//  CNtAce::GetAccessMask
//
//  Returns the ACCESS_MASK of the ACe.
//
//***************************************************************************
ACCESS_MASK CNtAce::GetAccessMask()
{
    if (m_pAce == 0)
        return 0;
    return m_pAce->Mask;
}

//***************************************************************************
//
//  CNtAce::GetSerializedSize
//
//  Returns the number of bytes needed to store this
//
//***************************************************************************

DWORD CNtAce::GetSerializedSize()
{
    if (m_pAce == 0)
        return 0;
    return m_pAce->Header.AceSize;
}

//***************************************************************************
//
//  CNtAce::DumpAccessMask
//
//  A helper function for CNtAce::Dump().  Illustrates the values
//  that the ACCESS_MASK for the ACE can take on.
//
//***************************************************************************
// ok

void CNtAce::DumpAccessMask()
{
    if (m_pAce == 0)
        return;

    ACCESS_MASK AccessMask = m_pAce->Mask;

    printf("Access Mask = 0x%X\n", AccessMask);
    printf("    User Portion = 0x%X\n", AccessMask & 0xFFFF);

    if (AccessMask & DELETE)
        printf("    DELETE\n");
    if (AccessMask & READ_CONTROL)
        printf("    READ_CONTROL\n");
    if (AccessMask & WRITE_DAC)
        printf("    WRITE_DAC\n");
    if (AccessMask & WRITE_OWNER)
        printf("    WRITE_OWNER\n");
    if (AccessMask & SYNCHRONIZE)
        printf("    SYNCHRONIZE\n");
    if (AccessMask & ACCESS_SYSTEM_SECURITY)
        printf("    ACCESS_SYSTEM_SECURITY\n");
    if (AccessMask & MAXIMUM_ALLOWED)
        printf("    MAXIMUM_ALLOWED\n");
    if (AccessMask & GENERIC_ALL)
        printf("    GENERIC_ALL\n");
    if (AccessMask & GENERIC_EXECUTE)
        printf("    GENERIC_EXECUTE\n");
    if (AccessMask & GENERIC_READ)
        printf("    GENERIC_READ\n");
    if (AccessMask & GENERIC_WRITE)
        printf("    GENERIC_WRITE\n");
}

//***************************************************************************
//
//  CNtAce::GetSid
//
//  Returns a copy of the CNtSid object which makes up the ACE.
//
//  Return value:
//      A newly allocated CNtSid which represents the user or group
//      referenced in the ACE.  The caller must use operator delete to free
//      the memory.
//
//***************************************************************************
// ok

CNtSid* CNtAce::GetSid()
{
    if (m_pAce == 0)
        return 0;

    PSID pSid = 0;

    pSid = &m_pAce->SidStart;

    if (!IsValidSid(pSid))
        return 0;

    return new CNtSid(pSid);
}

//***************************************************************************
//
//  CNtAce::GetSid
//
//  Gets the SID in an alternate manner, by assigning to an existing
//  object instead of returning a dynamically allocated one.
//
//  Parameters:
//  <Dest>              A reference to a CNtSid to receive the SID.
//
//  Return value:
//  TRUE on successful assignment, FALSE on failure.
//
//***************************************************************************

BOOL CNtAce::GetSid(CNtSid &Dest)
{
    CNtSid *pSid = GetSid();
    if (pSid == 0)
        return FALSE;

    Dest = *pSid;
    delete pSid;
    return TRUE;
}


//***************************************************************************
//
//  CNtAce::Dump
//
//  Dumps the current ACE to the console for debugging purposes.
//  Illustrates the structure of the ACE and the values the different
//  fields can take on.
//
//***************************************************************************
// ok

void CNtAce::Dump(int iAceNum)
{
    if(iAceNum != -1)
        printf("\n---ACE DUMP FOR ACE #%d---\n", iAceNum);
    else
        printf("\n---ACE DUMP---\n");

    printf("Ace Type = ");

    if (m_pAce == 0)
    {
        printf("NULL ACE\n");
        return;
    }

    switch (m_pAce->Header.AceType)
    {
        case ACCESS_ALLOWED_ACE_TYPE:
            printf("ACCESS_ALLOWED_ACE_TYPE\n");
            break;

        case ACCESS_DENIED_ACE_TYPE:
            printf("ACCESS_DENIED_ACE_TYPE\n");
            break;

        case SYSTEM_AUDIT_ACE_TYPE:
            printf("SYSTEM_AUDIT_ACE_TYPE\n");
            break;

        default:
            printf("INVALID ACE\n");
            break;
    }

    // Dump ACE flags.
    // ===============

    printf("ACE FLAGS = ");

    if (m_pAce->Header.AceFlags & INHERITED_ACE)
        printf("INHERITED_ACE ");
    if (m_pAce->Header.AceFlags & CONTAINER_INHERIT_ACE)
        printf("CONTAINER_INHERIT_ACE ");
    if (m_pAce->Header.AceFlags & INHERIT_ONLY_ACE)
        printf("INHERIT_ONLY_ACE ");
    if (m_pAce->Header.AceFlags & NO_PROPAGATE_INHERIT_ACE)
        printf("NO_PROPAGATE_INHERIT_ACE ");
    if (m_pAce->Header.AceFlags & OBJECT_INHERIT_ACE)
        printf("OBJECT_INHERIT_ACE ");
    if (m_pAce->Header.AceFlags & FAILED_ACCESS_ACE_FLAG)
        printf(" FAILED_ACCESS_ACE_FLAG");
    if (m_pAce->Header.AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG)
        printf(" SUCCESSFUL_ACCESS_ACE_FLAG");
    printf("\n");

    // Dump the SID.
    // =============

    CNtSid *pSid = GetSid();
    
    if (pSid)
    {
        pSid->Dump();
        delete pSid;
    }

    DumpAccessMask();
}

//***************************************************************************
//
//  CNtAce::CNtAce
//
//  Alternate constructor which uses a normal NT ACE as a basis for
//  object construction.
//
//  Parameters:
//  <pAceSrc>       A read-only pointer to the source ACE upon which to
//                  base object construction.
//
//  After construction, GetStatus() can be used to determine if the
//  object constructed properly.  NoError is expected.
//
//***************************************************************************
// ok

CNtAce::CNtAce(PGENERIC_ACE pAceSrc)
{
    m_dwStatus = NoError;

    if (pAceSrc == 0)
    {
        m_dwStatus = NullAce;
        m_pAce = 0;
    }

    m_pAce = (PGENERIC_ACE) new BYTE[pAceSrc->Header.AceSize];
	if ( m_pAce == NULL )
	{
		m_dwStatus = InternalError;
		return;
	}
    ZeroMemory(m_pAce, pAceSrc->Header.AceSize);
    memcpy(m_pAce, pAceSrc, pAceSrc->Header.AceSize);
}

//***************************************************************************
//
//  CNtAce copy constructor.
//
//***************************************************************************
// ok

CNtAce::CNtAce(CNtAce &Src)
{
    m_dwStatus = NoError;
    m_pAce = 0;
    *this = Src;
}

//***************************************************************************
//
//  CNtAce assignment operator.
//
//***************************************************************************
// ok

CNtAce &CNtAce::operator =(CNtAce &Src)
{
    if (m_pAce != 0)
        delete m_pAce;

    if (Src.m_pAce == 0)
    {
        m_pAce = 0;
        m_dwStatus = NullAce;
        return *this;
    }

    m_pAce = (PGENERIC_ACE) new BYTE[Src.m_pAce->Header.AceSize];
    if(m_pAce == NULL)
    {
        m_dwStatus = InternalError;
    }
    else
    {
        ZeroMemory(m_pAce, Src.m_pAce->Header.AceSize);
        memcpy(m_pAce, Src.m_pAce, Src.m_pAce->Header.AceSize);
        m_dwStatus = Src.m_dwStatus;
    }
    return *this;
}



//***************************************************************************
//
//  CNtAce destructor
//
//***************************************************************************
// ok

CNtAce::~CNtAce()
{
    if (m_pAce)
        delete m_pAce;
}

//***************************************************************************
//
//  CNtAce::GetType
//
//  Gets the Ace Type as defined under the NT SDK documentation for
//  ACE_HEADER.
//
//  Return value:
//      Returns ACCESS_ALLOWED_ACE_TYPE, ACCESS_DENIED_ACE_TYPE, or
//      SYSTEM_AUDIT_ACE_TYPE.  Returns -1 on error, such as a null ACE.
//
//      Returning -1 (or an analog) is required as an error code because
//      ACCESS_ALLOWED_ACE_TYPE is defined to be zero.
//
//***************************************************************************
// ok

int CNtAce::GetType()
{
    if (m_pAce == 0 || m_dwStatus != NoError)
        return -1;
    return m_pAce->Header.AceType;
}

//***************************************************************************
//
//  CNtAce::GetFlags
//
//  Gets the Ace Flag as defined under the NT SDK documentation for
//  ACE_HEADER.
//
//  Return value:
//      Returning -1 if error, other wise the flags.
//
//***************************************************************************

int CNtAce::GetFlags()
{
    if (m_pAce == 0 || m_dwStatus != NoError)
        return -1;
    return m_pAce->Header.AceFlags;
}

//***************************************************************************
//
//  CNtAce::GetFullUserName
//
//  Gets the domain\user name.
//
//***************************************************************************

HRESULT CNtAce::GetFullUserName(WCHAR * pBuff, DWORD dwSize)
{
    CNtSid *pSid = GetSid();
    if(pSid == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CDeleteMe<CNtSid> d0(pSid);
    DWORD dwJunk;
    LPWSTR pRetAccount = NULL, pRetDomain = NULL;
    pSid->GetInfo(&pRetAccount, &pRetDomain,&dwJunk);
    CDeleteMe<WCHAR> d1(pRetAccount);
    CDeleteMe<WCHAR> d2(pRetDomain);
    WCHAR wTemp[256];
    wTemp[0] = 0;
    if(pRetDomain && wcslen(pRetDomain) > 0)
    {
        wcscpy(wTemp, pRetDomain);
        wcscat(wTemp, L"|");
    }
    wcscat(wTemp, pRetAccount);
    wcsncpy(pBuff, wTemp, dwSize-1);
    return S_OK;
}

HRESULT CNtAce::GetFullUserName2(WCHAR ** pBuff)
{
    CNtSid *pSid = GetSid();
    if(pSid == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CDeleteMe<CNtSid> d0(pSid);
    DWORD dwJunk;
    LPWSTR pRetAccount = NULL, pRetDomain = NULL;
    if(0 != pSid->GetInfo(&pRetAccount, &pRetDomain,&dwJunk))
        return WBEM_E_FAILED;

    CDeleteMe<WCHAR> d1(pRetAccount);
    CDeleteMe<WCHAR> d2(pRetDomain);

    int iLen = 3;
    if(pRetAccount)
        iLen += wcslen(pRetAccount);
    if(pRetDomain)
        iLen += wcslen(pRetDomain);
    (*pBuff) = new WCHAR[iLen];
    if((*pBuff) == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    (*pBuff)[0] = 0;
    if(pRetDomain && wcslen(pRetDomain) > 0)
        wcscpy(*pBuff, pRetDomain);
    else
        wcscpy(*pBuff, L".");
    wcscat(*pBuff, L"|");
    wcscat(*pBuff, pRetAccount);
    return S_OK;

}
//***************************************************************************
//
//  CNtAce::Serialize
//
//  Serializes the ace.
//
//***************************************************************************

bool CNtAce::Serialize(BYTE * pData)
{
    if(m_pAce == NULL)
        return false;
    DWORD dwSize = m_pAce->Header.AceSize;
    memcpy((void *)pData, (void *)m_pAce, dwSize);
    return true;
}

//***************************************************************************
//
//  CNtAce::Deserialize
//
//  Deserializes the ace.  Normally this isnt called since the
//  CNtAce(PGENERIC_ACE pAceSrc) constructor is fine.  However, this is
//  used for the case where the db was created on win9x and we are now
//  running on nt.  In that case, the format is the same as outlined in
//  C9XAce::Serialize
//
//***************************************************************************

bool CNtAce::Deserialize(BYTE * pData)
{
    BYTE * pNext;
    pNext = pData + 2*(wcslen((LPWSTR)pData) + 1);
    DWORD * pdwData = (DWORD *)pNext;
    DWORD dwFlags, dwType, dwAccess;
    dwFlags = *pdwData;
    pdwData++;
    dwType = *pdwData;
    pdwData++;
    dwAccess = *pdwData;
    pdwData++;
    CNtAce temp(dwAccess, dwType, dwFlags, (LPWSTR)pData);
    *this = temp;
    return true;

}

//***************************************************************************
//
//  CNtAcl::CNtAcl
//
//  Constructs an empty ACL with a user-specified size.

//
//  Parameters:
//  <dwInitialSize>     Defaults to 128. Recommended values are 128 or
//                      higher in powers of two.
//
//  After construction, GetStatus() should be called to verify
//  the ACL initialized properly.  Expected value is NoError.
//
//***************************************************************************
// ok

CNtAcl::CNtAcl(DWORD dwInitialSize)
{
    m_pAcl = (PACL) new BYTE[dwInitialSize];
	if ( m_pAcl == NULL )
	{
		m_dwStatus = InternalError;
		return;
	}
    ZeroMemory(m_pAcl, dwInitialSize);
    BOOL bRes = InitializeAcl(m_pAcl, dwInitialSize, ACL_REVISION);

    if (!bRes)
    {
        delete m_pAcl;
        m_pAcl = 0;
        m_dwStatus = NullAcl;
        return;
    }

    m_dwStatus = NoError;
}


//***************************************************************************
//
//  CNtAcl copy constructor.
//
//***************************************************************************
// ok

CNtAcl::CNtAcl(CNtAcl &Src)
{
    m_pAcl = 0;
    m_dwStatus = NoError;

    *this = Src;
}

//***************************************************************************
//
//  CNtAcl assignment operator
//
//***************************************************************************
// ok

CNtAcl &CNtAcl::operator = (CNtAcl &Src)
{
    if (m_pAcl != 0)
        delete m_pAcl;

    // Default to a NULL ACL.
    // ======================

    m_pAcl = 0;
    m_dwStatus = NullAcl;

    if (Src.m_pAcl == 0)
        return *this;

    // Now copy the source ACL.
    // ========================

    DWORD dwSize = Src.m_pAcl->AclSize;

    m_pAcl = (PACL) new BYTE[dwSize];
    if(m_pAcl == NULL)
    {
        m_dwStatus = InternalError;
        return *this;
    }

    ZeroMemory(m_pAcl, dwSize);

    memcpy(m_pAcl, Src.m_pAcl, dwSize);

    // Verify it.
    // ==========

    if (!IsValidAcl(m_pAcl))
    {
        delete m_pAcl;
        m_pAcl = 0;
        m_dwStatus = InvalidAcl;
        return *this;
    }

    m_dwStatus = Src.m_dwStatus;
    return *this;
}

//***************************************************************************
//
//  CNtAcl::GetAce
//
//  Returns an ACE at the specified index.  To enumerate ACEs, the caller
//  should determine the number of ACEs using GetNumAces() and then call
//  this function with each index starting from 0 to number of ACEs - 1.
//
//  Parameters:
//  <nIndex>        The index of the desired ACE.
//
//  Return value:
//  A newly allocated CNtAce object which must be deallocated using
//  operator delete.  This is only a copy.  Modifications to the returned
//  CNtAce do not affect the ACL from which it came.
//
//  Returns NULL on error.
//
//***************************************************************************
// ok

CNtAce *CNtAcl::GetAce(int nIndex)
{
    if (m_pAcl == 0)
        return 0;

    LPVOID pAce = 0;

    BOOL bRes = ::GetAce(m_pAcl, (DWORD) nIndex, &pAce);

    if (!bRes)
        return 0;

    return new CNtAce(PGENERIC_ACE(pAce));
}

//***************************************************************************
//
//  CNtAcl::GetAce
//
//  Alternate method to get ACEs to avoid dynamic allocation & cleanup,
//  since an auto object can be used as the parameter.
//
//  Parameters:
//  <Dest>          A reference to a CNtAce to receive the ACE value.
//
//  Return value:
//  TRUE if assigned, FALSE if not.
//
//***************************************************************************

BOOL CNtAcl::GetAce(int nIndex, CNtAce &Dest)
{
    CNtAce *pNew = GetAce(nIndex);
    if (pNew == 0)
        return FALSE;

    Dest = *pNew;
    delete pNew;
    return TRUE;
}

//***************************************************************************
//
//  CNtAcl::DeleteAce
//
//  Removes the specified ACE from the ACL.
//
//  Parameters:
//  <nIndex>        The 0-based index of the ACE which should be removed.
//
//  Return value:
//  TRUE if the ACE was deleted, FALSE if not.
//
//***************************************************************************
// ok

BOOL CNtAcl::DeleteAce(int nIndex)
{
    if (m_pAcl == 0)
        return FALSE;

    BOOL bRes = ::DeleteAce(m_pAcl, DWORD(nIndex));

    return bRes;
}

//***************************************************************************
//
//  CNtAcl::GetSize()
//
//  Return value:
//  Returns the size in bytes of the ACL
//
//***************************************************************************
// ok

DWORD CNtAcl::GetSize()
{
    if (m_pAcl == 0 || !IsValidAcl(m_pAcl))
        return 0;

    return DWORD(m_pAcl->AclSize);
}


//***************************************************************************
//
//  CNtAcl::GetAclSizeInfo
//
//  Gets information about used/unused space in the ACL.  This function
//  is primarily for internal use.
//
//  Parameters:
//  <pdwBytesInUse>     Points to a DWORD to receive the number of
//                      bytes in use in the ACL.  Can be NULL.
//  <pdwBytesFree>      Points to a DWORD to receive the number of
//                      bytes free in the ACL.  Can be NULL.
//
//  Return value:
//  Returns TRUE if the information was retrieved, FALSE if not.
//
//***************************************************************************
// ok

BOOL CNtAcl::GetAclSizeInfo(
    PDWORD pdwBytesInUse,
    PDWORD pdwBytesFree
    )
{
    if (m_pAcl == 0)
        return 0;

    if (!IsValidAcl(m_pAcl))
        return 0;

    if (pdwBytesInUse)
        *pdwBytesInUse = 0;
    if (pdwBytesFree)
        *pdwBytesFree  = 0;

    ACL_SIZE_INFORMATION inf;

    BOOL bRes = GetAclInformation(
        m_pAcl,
        &inf,
        sizeof(ACL_SIZE_INFORMATION),
        AclSizeInformation
        );

    if (!bRes)
        return FALSE;

    if (pdwBytesInUse)
        *pdwBytesInUse = inf.AclBytesInUse;
    if (pdwBytesFree)
        *pdwBytesFree  = inf.AclBytesFree;

    return bRes;
}


//***************************************************************************
//
//  CNtAcl::AddAce
//
//  Adds an ACE to the ACL.
//  Ordering semantics for denial ACEs are handled automatically.
//
//  Parameters:
//  <pAce>      A read-only pointer to the CNtAce to be added.
//
//  Return value:
//  TRUE on success, FALSE on failure.
//
//***************************************************************************
// ok

BOOL CNtAcl::AddAce(CNtAce *pAce)
{
    // Verify we have an ACL and a valid ACE.
    // ======================================

    if (m_pAcl == 0 || m_dwStatus != NoError)
        return FALSE;

    if (pAce->GetStatus() != CNtAce::NoError)
        return FALSE;

    // Inherited aces go after non inherited aces

    bool bInherited = (pAce->GetFlags() & INHERITED_ACE) != 0;
    int iFirstInherited = 0;

    // inherited aces must go after non inherited.  Find out
    // the position of the first inherited ace

    int iCnt;
    for(iCnt = 0; iCnt < m_pAcl->AceCount; iCnt++)
    {
        CNtAce *pAce2 = GetAce(iCnt);
        CDeleteMe<CNtAce> dm(pAce2);
        if (pAce2)
            if((pAce2->GetFlags() & INHERITED_ACE) != 0)
                break;
    }
    iFirstInherited = iCnt;


    // Since we want to add access denial ACEs to the front of the ACL,
    // we have to determine the type of ACE.
    // ================================================================

    DWORD dwIndex;

    if (pAce->GetType() == ACCESS_DENIED_ACE_TYPE)
        dwIndex = (bInherited) ? iFirstInherited : 0;
    else
        dwIndex = (bInherited) ? MAXULONG : iFirstInherited; 

    // Verify that there is enough room in the ACL.
    // ============================================

    DWORD dwRequiredFree = pAce->GetSize();

    DWORD dwFree = 0;
    DWORD dwUsed = 0;
    GetAclSizeInfo(&dwUsed, &dwFree);

    // If we don't have enough room, resize the ACL.
    // =============================================

    if (dwFree < dwRequiredFree)
    {
        BOOL bRes = Resize(dwUsed + dwRequiredFree);

        if (!bRes)
            return FALSE;
    }

    // Now actually add the ACE.
    // =========================

    BOOL bRes = ::AddAce(
        m_pAcl,
        ACL_REVISION,
        dwIndex,                      // Either beginning or end.
        pAce->GetPtr(),         // Get ptr to ACE.
        pAce->GetSize()                       // One ACE only.
        );

    return bRes;
}


//***************************************************************************
//
//  CNtAcl::Resize()
//
//  Expands the size of the ACL to hold more info or reduces the size
//  of the ACL for maximum efficiency after ACL editing is completed.
//
//  Normally, the user should not attempt to resize the ACL to a larger
//  size, as this is automatically handled by AddAce.  However, shrinking
//  the ACL to its minimum size is recommended.
//
//  Parameters:
//  <dwNewSize>     The required new size of the ACL in bytes.  If set to
//                  the class constant MinimumSize (1), then the ACL
//                  is reduced to its minimum size.
//
//  Return value:
//  TRUE on success, FALSE on failure.
//
//***************************************************************************
// ok

BOOL CNtAcl::Resize(DWORD dwNewSize)
{
    if (m_pAcl == 0 || m_dwStatus != NoError)
        return FALSE;

    if (!IsValidAcl(m_pAcl))
        return FALSE;

    // If the ACL cannot be reduced to the requested size,
    // return FALSE.
    // ===================================================

    DWORD dwInUse, dwFree;

    if (!GetAclSizeInfo(&dwInUse, &dwFree))
        return FALSE;

    if (dwNewSize == MinimumSize)       // If user is requesting a 'minimize'
        dwNewSize = dwInUse;

    if (dwNewSize < dwInUse)
        return FALSE;

    // Allocate a new ACL.
    // ===================

    CNtAcl *pNewAcl = new CNtAcl(dwNewSize);

    if (!pNewAcl || pNewAcl->GetStatus() != NoError)
    {
        delete pNewAcl;
        return FALSE;
    }

    // Loop through ACEs and transfer them.
    // ====================================

    for (int i = 0; i < GetNumAces(); i++)
    {
        CNtAce *pAce = GetAce(i);

        if (pAce == NULL)
        {
            delete pNewAcl;
            return FALSE;
        }

        BOOL bRes = pNewAcl->AddAce(pAce);

        if (!bRes)
        {
            DWORD dwLast = GetLastError();
            delete pAce;
            delete pNewAcl;
            return FALSE;
        }

        delete pAce;
    }

    if (!IsValid())
    {
        delete pNewAcl;
        return FALSE;
    }

    // Now transfer the ACL.
    // =====================

    *this = *pNewAcl;
    delete pNewAcl;

    return TRUE;
}


//***************************************************************************
//
//  CNtAcl::CNtAcl
//
//  Alternate constructor which builds the object based on a plain
//  NT ACL.
//
//  Parameters:
//  <pAcl>  Pointer to a read-only ACL.
//
//***************************************************************************
// ok
CNtAcl::CNtAcl(PACL pAcl)
{
    m_pAcl = 0;
    m_dwStatus = NoError;

    if (pAcl == 0)
    {
        m_dwStatus = NullAcl;
        return;
    }

    if (!IsValidAcl(pAcl))
    {
        m_dwStatus = InvalidAcl;
        return;
    }

    m_pAcl = (PACL) new BYTE[pAcl->AclSize];
    if(m_pAcl == NULL)
    {
        m_dwStatus = InternalError;
        return;
    }
    ZeroMemory(m_pAcl, pAcl->AclSize);
    memcpy(m_pAcl, pAcl, pAcl->AclSize);
}

/*
    --------------------------------------------------------------------------
   |
   | Checks to see if the Acl contains an ACE with the specified SID. 
   | The characteristics of the ACE is irrelevant. Only SID comparison applies.
   |
	--------------------------------------------------------------------------
*/
BOOL CNtAcl::ContainsSid ( CNtSid& sid, BYTE& flags )
{
	BOOL bContainsSid = FALSE ;	

	int iNumAces = GetNumAces ( ) ;
	if ( iNumAces < 0 )
	{
		return FALSE ;
	}

	for ( int i = 0 ; i < iNumAces; i++ )
	{
		CNtAce* pAce = GetAce ( i ) ;
		CNtSid* pSid = pAce->GetSid ( ) ;

		CDeleteMe<CNtAce> AceDelete ( pAce ) ;
		CDeleteMe<CNtSid> SidDelete ( pSid ) ;

		if ( pAce && pSid )
		{
			if ( EqualSid ( sid.GetPtr ( ), pSid->GetPtr ( ) ) == TRUE )
			{
				flags = ( BYTE ) pAce->GetFlags ( ) ;
				bContainsSid = TRUE ;
				break ;	
			}
		}
	}
	return bContainsSid ;
}

//***************************************************************************
//
//  CNtAcl::GetNumAces
//
//  Return value:
//  Returns the number of ACEs available in the ACL.  Zero is a legal return
//  value. Returns -1 on error
//
//  Aces can be retrieved using GetAce using index values from 0...n-1 where
//  n is the value returned from this function.
//
//***************************************************************************
// ok

int CNtAcl::GetNumAces()
{
    if (m_pAcl == 0)
        return -1;

    ACL_SIZE_INFORMATION inf;

    BOOL bRes = GetAclInformation(
        m_pAcl,
        &inf,
        sizeof(ACL_SIZE_INFORMATION),
        AclSizeInformation
        );

    if (!bRes)
    {
        return -1;
    }

    return (int) inf.AceCount;
}

//***************************************************************************
//
//  CNtAcl destructor
//
//***************************************************************************
// ok

CNtAcl::~CNtAcl()
{
    if (m_pAcl)
        delete m_pAcl;
}


//***************************************************************************
//
//  CNtAcl::Dump
//
//  Dumps the ACL to the console for debugging purposes.  Illustrates
//  how to traverse the ACL and extract the ACEs.
//
//***************************************************************************
// ok

void CNtAcl::Dump()
{
    printf("---ACL DUMP---\n");

    if (m_pAcl == 0)
    {
        switch (m_dwStatus)
        {
            case NullAcl:
                printf("NullAcl\n");
                break;

            case InvalidAcl:
                printf("InvalidAcl\n");
                break;

            default:
                printf("<internal error; unknown status>\n");
        }
        return;
    }

    DWORD InUse, Free;
    GetAclSizeInfo(&InUse, &Free);
    printf("%d bytes in use, %d bytes free\n",
        InUse, Free
        );

    printf("Number of ACEs = %d\n", GetNumAces());

    for (int i = 0; i < GetNumAces(); i++)
    {
        CNtAce *pAce = GetAce(i);
        if (pAce)
        {
            pAce->Dump(i+1);
            delete pAce;
        }
    }

    printf("---END ACL DUMP---\n");

}


//***************************************************************************
//
//  CNtSecurityDescriptor::GetDacl
//
//  Returns the DACL of the security descriptor.
//
//  Return value:
//  A newly allocated CNtAcl which contains the DACL.   This object
//  is a copy of the DACL and modifications made to it do not affect
//  the security descriptor.  The caller must use operator delete
//  to deallocate the CNtAcl.
//
//  Returns NULL on error or if no DACL is available.
//
//***************************************************************************
// ok

CNtAcl *CNtSecurityDescriptor::GetDacl()
{
    BOOL bDaclPresent = FALSE;
    BOOL bDefaulted;

    PACL pDacl;
    BOOL bRes = GetSecurityDescriptorDacl(
        m_pSD,
        &bDaclPresent,
        &pDacl,
        &bDefaulted
        );

    if (!bRes)
    {
        return 0;
    }

    if (!bDaclPresent)  // No DACL present
        return 0;

    CNtAcl *pNewDacl = new CNtAcl(pDacl);

    return pNewDacl;
}

//***************************************************************************
//
//  CNtSecurityDescriptor::GetDacl
//
//  An alternate method to returns the DACL of the security descriptor.
//  This version uses an existing object instead of returning a
//  dynamically allocated object.
//
//  Parameters:
//  <DestAcl>           A object which will receive the DACL.
//
//  Return value:
//  TRUE on success, FALSE on failure
//
//***************************************************************************

BOOL CNtSecurityDescriptor::GetDacl(CNtAcl &DestAcl)
{
    CNtAcl *pNew = GetDacl();
    if (pNew == 0)
        return FALSE;

    DestAcl = *pNew;
    delete pNew;
    return TRUE;
}

//***************************************************************************
//
//  SNtAbsoluteSD
//
//  SD Helpers
//
//***************************************************************************

SNtAbsoluteSD::SNtAbsoluteSD()
{
    m_pSD = 0;
    m_pDacl = 0;
    m_pSacl = 0;
    m_pOwner = 0;
    m_pPrimaryGroup = 0;
}

SNtAbsoluteSD::~SNtAbsoluteSD()
{
    if (m_pSD)
        delete m_pSD;
    if (m_pDacl)
        delete m_pDacl;
    if (m_pSacl)
        delete m_pSacl;
    if (m_pOwner)
        delete m_pOwner;
    if (m_pPrimaryGroup)
        delete m_pPrimaryGroup;
}


//***************************************************************************
//
//  CNtSecurityDescriptor::GetAbsoluteCopy
//
//  Returns a copy of the current object's internal SD in absolute format.
//  Returns NULL on error.  The memory must be freed with LocalFree().
//
//***************************************************************************
// ok

SNtAbsoluteSD* CNtSecurityDescriptor::GetAbsoluteCopy()
{
    if (m_dwStatus != NoError || m_pSD == 0 || !IsValid())
        return 0;

    // Prepare for conversion.
    // =======================

    DWORD dwSDSize = 0, dwDaclSize = 0, dwSaclSize = 0,
        dwOwnerSize = 0, dwPrimaryGroupSize = 0;

    SNtAbsoluteSD *pNewSD = new SNtAbsoluteSD;
    if (!pNewSD)
        return NULL;

    BOOL bRes = MakeAbsoluteSD(
        m_pSD,
        pNewSD->m_pSD,
        &dwSDSize,
        pNewSD->m_pDacl,
        &dwDaclSize,
        pNewSD->m_pSacl,
        &dwSaclSize,
        pNewSD->m_pOwner,
        &dwOwnerSize,
        pNewSD->m_pPrimaryGroup,
        &dwPrimaryGroupSize
        );

    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
    {
        delete pNewSD;
        return 0;
    }

    // Allocate the required buffers and convert.
    // ==========================================

    pNewSD->m_pSD = (PSECURITY_DESCRIPTOR) new BYTE[dwSDSize];
    if(pNewSD->m_pSD == NULL)
    {
        delete pNewSD;
        return NULL;
    }
    ZeroMemory(pNewSD->m_pSD, dwSDSize);

    pNewSD->m_pDacl   = (PACL) new BYTE[dwDaclSize];
    if(pNewSD->m_pDacl == NULL)
    {
        delete pNewSD;
        return NULL;
    }
    ZeroMemory(pNewSD->m_pDacl, dwDaclSize);

    pNewSD->m_pSacl   = (PACL) new BYTE[dwSaclSize];
    if(pNewSD->m_pSacl == NULL)
    {
        delete pNewSD;
        return NULL;
    }
    ZeroMemory(pNewSD->m_pSacl, dwSaclSize);

    pNewSD->m_pOwner  = (PSID) new BYTE[dwOwnerSize];
    if(pNewSD->m_pOwner == NULL)
    {
        delete pNewSD;
        return NULL;
    }
    ZeroMemory(pNewSD->m_pOwner, dwOwnerSize);

    pNewSD->m_pPrimaryGroup  = (PSID) new BYTE[dwPrimaryGroupSize];
    if(pNewSD->m_pPrimaryGroup == NULL)
    {
        delete pNewSD;
        return NULL;
    }
    ZeroMemory(pNewSD->m_pPrimaryGroup, dwPrimaryGroupSize);

    bRes = MakeAbsoluteSD(
        m_pSD,
        pNewSD->m_pSD,
        &dwSDSize,
        pNewSD->m_pDacl,
        &dwDaclSize,
        pNewSD->m_pSacl,
        &dwSaclSize,
        pNewSD->m_pOwner,
        &dwOwnerSize,
        pNewSD->m_pPrimaryGroup,
        &dwPrimaryGroupSize
        );

    if (!bRes)
    {
        delete pNewSD;
        return 0;
    }

    return pNewSD;
}

//***************************************************************************
//
//  CNtSecurityDescriptor::SetFromAbsoluteCopy
//
//  Replaces the current SD from an absolute copy.
//
//  Parameters:
//  <pSrcSD>    A read-only pointer to the absolute SD used as a source.
//
//  Return value:
//  TRUE on success, FALSE on failure.
//
//***************************************************************************
// ok

BOOL CNtSecurityDescriptor::SetFromAbsoluteCopy(
    SNtAbsoluteSD *pSrcSD
    )
{
    if (pSrcSD ==  0 || !IsValidSecurityDescriptor(pSrcSD->m_pSD))
        return FALSE;


    // Ensure that SD is self-relative
    // ===============================

    SECURITY_DESCRIPTOR_CONTROL ctrl;
    DWORD dwRev;

    BOOL bRes = GetSecurityDescriptorControl(
        pSrcSD->m_pSD,
        &ctrl,
        &dwRev
        );

    if (!bRes)
        return FALSE;

    if (ctrl & SE_SELF_RELATIVE)  // Source is not absolute!!
        return FALSE;

    // If here, we are committed to change.
    // ====================================

    if (m_pSD)
	{
        delete m_pSD;
	}
    m_pSD = 0;
    m_dwStatus = NullSD;


    DWORD dwRequired = 0;

    bRes = MakeSelfRelativeSD(
            pSrcSD->m_pSD,
            m_pSD,
            &dwRequired
            );

    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
    {
        m_dwStatus = InvalidSD;
        return FALSE;
    }

    m_pSD = new BYTE[dwRequired];
    if (!m_pSD)
    {
        m_dwStatus = InvalidSD;
        return FALSE;
    }

    ZeroMemory(m_pSD, dwRequired);

    bRes = MakeSelfRelativeSD(
              pSrcSD->m_pSD,
              m_pSD,
              &dwRequired
              );

    if (!bRes)
    {
        m_dwStatus = InvalidSD;
        delete m_pSD;
        m_pSD = 0;
        return FALSE;
    }

    m_dwStatus = NoError;
    return TRUE;
}


//***************************************************************************
//
//  CNtSecurityDescriptor::SetDacl
//
//  Sets the DACL of the Security descriptor.
//
//  Parameters:
//  <pSrc>      A read-only pointer to the new DACL to replace the current one.
//
//  Return value:
//  TRUE on success, FALSE on failure.
//
//***************************************************************************

BOOL CNtSecurityDescriptor::SetDacl(CNtAcl *pSrc)
{
    if (m_dwStatus != NoError || m_pSD == 0)
        return FALSE;


    // Since we cannot alter a self-relative SD, we have to make
    // an absolute one, alter it, and then set the current
    // SD based on the absolute one (we keep the self-relative form
    // internally in the m_pSD variable.
    // ============================================================

    SNtAbsoluteSD *pTmp = GetAbsoluteCopy();

    if (pTmp == 0)
        return FALSE;

    BOOL bRes = ::SetSecurityDescriptorDacl(
        pTmp->m_pSD,
        TRUE,
        pSrc->GetPtr(),
        FALSE
        );

    if (!bRes)
    {
        delete pTmp;
        return FALSE;
    }

    bRes = SetFromAbsoluteCopy(pTmp);
    delete pTmp;

    return TRUE;
}


//***************************************************************************
//
//  CNtSecurityDescriptor::Dump
//
//  Dumps the contents of the security descriptor to the console
//  for debugging purposes.
//
//***************************************************************************
// ?

void CNtSecurityDescriptor::Dump()
{
    SECURITY_DESCRIPTOR_CONTROL Control;
    DWORD dwRev;
    BOOL bRes;

    printf("--- SECURITY DESCRIPTOR DUMP ---\n");

    bRes = GetSecurityDescriptorControl(m_pSD, &Control, &dwRev);

    if (!bRes)
    {
        printf("SD Dump: Failed to get control info\n");
        return;
    }

    printf("Revision : 0x%X\n", dwRev);

    printf("Control Info :\n");

    if (Control & SE_SELF_RELATIVE)
        printf("    SE_SELF_RELATIVE\n");

    if (Control & SE_OWNER_DEFAULTED)
        printf("    SE_OWNER_DEFAULTED\n");

    if (Control & SE_GROUP_DEFAULTED)
        printf("    SE_GROUP_DEFAULTED\n");

    if (Control & SE_DACL_PRESENT)
        printf("    SE_DACL_PRESENT\n");

    if (Control & SE_DACL_DEFAULTED)
        printf("    SE_DACL_DEFAULTED\n");

    if (Control & SE_SACL_PRESENT)
        printf("    SE_SACL_PRESENT\n");

    if (Control & SE_SACL_DEFAULTED)
        printf("    SE_SACL_DEFAULTED\n");

    if (Control & SE_DACL_PROTECTED)
        printf("    SE_DACL_PROTECTED\n");

    // Get owner.
    // =========

    CNtSid *pSid = GetOwner();

    if (pSid)
    {
        printf("Owner : ");
        pSid->Dump();
        delete pSid;
    }

    CNtAcl *pDacl = GetDacl();

    if (pDacl == 0)
    {
        printf("Unable to locate DACL\n");
        return;
    }

    printf("DACL retrieved\n");

    pDacl->Dump();

    delete pDacl;
}

//***************************************************************************
//
//  CNtSecurityDescriptor constructor
//
//  A default constructor creates a no-access security descriptor.
//
//***************************************************************************
//  ok

CNtSecurityDescriptor::CNtSecurityDescriptor()
{
    m_pSD = 0;
    m_dwStatus = NoError;

    PSECURITY_DESCRIPTOR pTmp = new BYTE[SECURITY_DESCRIPTOR_MIN_LENGTH];
    if (!pTmp)
    {
        delete pTmp;
        m_dwStatus = InvalidSD;
        return;
    }
    
    ZeroMemory(pTmp, SECURITY_DESCRIPTOR_MIN_LENGTH);

    if (!InitializeSecurityDescriptor(pTmp, SECURITY_DESCRIPTOR_REVISION))
    {
        delete pTmp;
        m_dwStatus = InvalidSD;
        return;
    }

    DWORD dwRequired = 0;

    BOOL bRes = MakeSelfRelativeSD(
            pTmp,
            m_pSD,
            &dwRequired
            );

    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
    {
        m_dwStatus = InvalidSD;
        delete pTmp;
        return;
    }

    m_pSD = new BYTE[dwRequired];
    if (!m_pSD)
    {
        m_dwStatus = InvalidSD;
        delete pTmp;
        return;
    }

    ZeroMemory(m_pSD, dwRequired);

    bRes = MakeSelfRelativeSD(
              pTmp,
              m_pSD,
              &dwRequired
              );

    if (!bRes)
    {
        m_dwStatus = InvalidSD;
        delete m_pSD;
        m_pSD = 0;
        delete pTmp;
        return;
    }

    delete pTmp;
    m_dwStatus = NoError;
}


//***************************************************************************
//
//  CNtSecurityDescriptor::GetSize
//
//  Returns the size in bytes of the internal SD.
//
//***************************************************************************
//  ok

DWORD CNtSecurityDescriptor::GetSize()
{
    if (m_pSD == 0 || m_dwStatus != NoError)
        return 0;

    return GetSecurityDescriptorLength(m_pSD);
}


//***************************************************************************
//
//  CNtSecurityDescriptor copy constructor
//
//***************************************************************************
// ok

CNtSecurityDescriptor::CNtSecurityDescriptor(CNtSecurityDescriptor &Src)
{
    m_pSD = 0;
    m_dwStatus = NoError;
    *this = Src;
}

//***************************************************************************
//
//  CNtSecurityDescriptor assignment operator
//
//***************************************************************************
// ok

CNtSecurityDescriptor & CNtSecurityDescriptor::operator=(
    CNtSecurityDescriptor &Src
    )
{
    if (m_pSD)
        delete m_pSD;

    m_dwStatus = Src.m_dwStatus;
    m_pSD = 0;

    if (Src.m_pSD == 0)
        return *this;

    //SIZE_T dwSize = 2*GetSecurityDescriptorLength(Src.m_pSD);
    SIZE_T dwSize = GetSecurityDescriptorLength(Src.m_pSD);
    m_pSD = (PSECURITY_DESCRIPTOR) new BYTE[dwSize];
    if(m_pSD == NULL)
    {
        m_dwStatus = Failed;
    }
    else
    {
        ZeroMemory(m_pSD, dwSize);
        CopyMemory(m_pSD, Src.m_pSD, dwSize);
    }

    return *this;
}


//***************************************************************************
//
//  CNtSecurityDescriptor destructor.
//
//***************************************************************************
// ok

CNtSecurityDescriptor::~CNtSecurityDescriptor()
{
    if (m_pSD)
        delete m_pSD;
}

//***************************************************************************
//
//  CNtSecurityDescriptor::GetSacl
//
//  Returns the SACL of the security descriptor.
//
//  Return value:
//  A newly allocated CNtAcl which contains the SACL.   This object
//  is a copy of the SACL and modifications made to it do not affect
//  the security descriptor.  The caller must use operator delete
//  to deallocate the CNtAcl.
//
//  Returns NULL on error or if no SACL is available.
//
//***************************************************************************
// ok

CNtAcl *CNtSecurityDescriptor::GetSacl()
{
    BOOL bSaclPresent = FALSE;
    BOOL bDefaulted;

    PACL pSacl;
    BOOL bRes = GetSecurityDescriptorSacl(
        m_pSD,
        &bSaclPresent,
        &pSacl,
        &bDefaulted
        );

    if (!bRes)
    {
        return 0;
    }

    if (!bSaclPresent)  // No Sacl present
        return 0;

    CNtAcl *pNewSacl = new CNtAcl(pSacl);

    return pNewSacl;
}

//***************************************************************************
//
//  CNtSecurityDescriptor::SetSacl
//
//  Sets the SACL of the Security descriptor.
//
//  Parameters:
//  <pSrc>      A read-only pointer to the new DACL to replace the current one.
//
//  Return value:
//  TRUE on success, FALSE on failure.
//
//***************************************************************************
// ok

BOOL CNtSecurityDescriptor::SetSacl(CNtAcl *pSrc)
{
    if (m_dwStatus != NoError || m_pSD == 0)
        return FALSE;

    // Since we cannot alter a self-relative SD, we have to make
    // an absolute one, alter it, and then set the current
    // SD based on the absolute one (we keep the self-relative form
    // internally in the m_pSD variable.
    // ============================================================

    SNtAbsoluteSD *pTmp = GetAbsoluteCopy();

    if (pTmp == 0)
        return FALSE;

    BOOL bRes = ::SetSecurityDescriptorSacl(
        pTmp->m_pSD,
        TRUE,
        pSrc->GetPtr(),
        FALSE
        );

    if (!bRes)
    {
        delete pTmp;
        return FALSE;
    }

    bRes = SetFromAbsoluteCopy(pTmp);
    delete pTmp;

    return TRUE;
}


//***************************************************************************
//
//  CNtSecurityDescriptor::GetGroup
//
//***************************************************************************
// ok

CNtSid *CNtSecurityDescriptor::GetGroup()
{
    if (m_pSD == 0 || m_dwStatus != NoError)
        return 0;

    PSID pSid = 0;
    BOOL bDefaulted;

    BOOL bRes = GetSecurityDescriptorGroup(m_pSD, &pSid, &bDefaulted);

    // TMP: Check to make sure the group is not NULL!!!!
	if ( pSid == NULL )
	{
//		DebugBreak();
        ERRORTRACE((LOG_WBEMCORE, "ERROR: Security descriptor has no group\n"));
	}


    if (!bRes || !IsValidSid(pSid))
        return 0;

    return new CNtSid(pSid);

}

//***************************************************************************
//
//  CNtSecurityDescriptor::SetGroup
//
//***************************************************************************
// ok

BOOL CNtSecurityDescriptor::SetGroup(CNtSid *pSid)
{
    if (m_dwStatus != NoError || m_pSD == 0)
        return FALSE;

    // TMP: Check to make sure the group is not NULL!!!!
	if ( pSid->GetPtr() == NULL )
	{
//		DebugBreak();
        ERRORTRACE((LOG_WBEMCORE, "ERROR: Security descriptor is trying to bland out the group!\n"));
	}


	
	// Since we cannot alter a self-relative SD, we have to make
    // an absolute one, alter it, and then set the current
    // SD based on the absolute one (we keep the self-relative form
    // internally in the m_pSD variable.
    // ============================================================

    SNtAbsoluteSD *pTmp = GetAbsoluteCopy();

    if (pTmp == 0)
        return FALSE;

    BOOL bRes = ::SetSecurityDescriptorGroup(
        pTmp->m_pSD,
        pSid->GetPtr(),
        FALSE
        );

    if (!bRes)
    {
        delete pTmp;
        return FALSE;
    }

    bRes = SetFromAbsoluteCopy(pTmp);
    delete pTmp;

    return TRUE;
}


//***************************************************************************
//
//  CNtSecurityDescriptor::HasOwner
//
//  Determines if a security descriptor has an owner.
//
//  Return values:
//      SDNotOwned, SDOwned, Failed
//
//***************************************************************************
// ok

int CNtSecurityDescriptor::HasOwner()
{
    if (m_pSD == 0 || m_dwStatus != NoError)
        return Failed;

    PSID pSid = 0;

    BOOL bRes = GetSecurityDescriptorOwner(m_pSD, &pSid, 0);

    if (!bRes || !IsValidSid(pSid))
        return Failed;

    if (pSid == 0)
        return SDNotOwned;

    return SDOwned;
}


//***************************************************************************
//
//  CNtSecurityDescriptor::GetOwner
//
//  Returns the SID of the owner of the Security Descriptor or NULL
//  if an error occurred or there is no owner.  Use HasOwner() to
//  determine this.
//
//***************************************************************************
// ok

CNtSid *CNtSecurityDescriptor::GetOwner()
{
    if (m_pSD == 0 || m_dwStatus != NoError)
        return 0;

    PSID pSid = 0;
    BOOL bDefaulted;

    BOOL bRes = GetSecurityDescriptorOwner(m_pSD, &pSid, &bDefaulted);

    // TMP: Check to make sure the owner is not NULL!!!!
	if ( pSid == NULL )
	{
//		DebugBreak();
        ERRORTRACE((LOG_WBEMCORE, "ERROR: Security descriptor has no owner\n"));
	}



	if (!bRes || !IsValidSid(pSid))
        return 0;

    return new CNtSid(pSid);
}

//***************************************************************************
//
//  CNtSecurityDescriptor::SetOwner
//
//  Sets the owner of a security descriptor.
//
//  Parameters:
//  <pSid>  The SID of the new owner.
//
//  Return Value:
//  TRUE if owner was changed, FALSE if not.
//
//***************************************************************************
// ok

BOOL CNtSecurityDescriptor::SetOwner(CNtSid *pSid)
{
    if (m_pSD == 0 || m_dwStatus != NoError)
        return FALSE;

    if (!pSid->IsValid())
        return FALSE;

    // TMP: Check to make sure the owner is not NULL!!!!
	if ( pSid->GetPtr() == NULL )
	{
        ERRORTRACE((LOG_WBEMCORE, "ERROR: Security descriptor is trying to zap the owner!\n"));
//		DebugBreak();
	}


    
	// We must convert to absolute format to make the change.
    // =======================================================

    SNtAbsoluteSD *pTmp = GetAbsoluteCopy();

    if (pTmp == 0)
        return FALSE;

    BOOL bRes = SetSecurityDescriptorOwner(pTmp->m_pSD, pSid->GetPtr(), FALSE);

    if (!bRes)
    {
        delete pTmp;
        return FALSE;
    }

    // If here, we have managed the change, so we have to
    // convert *this back from the temporary absolute SD.
    // ===================================================

    bRes = SetFromAbsoluteCopy(pTmp);
    delete pTmp;

    return bRes;
}



//***************************************************************************
//
//  CNtSecurityDescriptor::CNtSecurityDescriptor
//
//***************************************************************************
// ok

CNtSecurityDescriptor::CNtSecurityDescriptor(
    PSECURITY_DESCRIPTOR pSD,
    BOOL bAcquire
    )
{
    m_pSD = 0;
    m_dwStatus = NullSD;

    // Ensure that SD is not NULL.
    // ===========================

    if (pSD == 0)
    {
        if (bAcquire)
            delete pSD;
        return;
    }

    if (!IsValidSecurityDescriptor(pSD))
    {
        m_dwStatus = InvalidSD;
        if (bAcquire)
            delete pSD;
        return;
    }

    // Ensure that SD is self-relative
    // ===============================

    SECURITY_DESCRIPTOR_CONTROL ctrl;
    DWORD dwRev;

    BOOL bRes = GetSecurityDescriptorControl(
        pSD,
        &ctrl,
        &dwRev
        );

    if (!bRes)
    {
        m_dwStatus = InvalidSD;
        if (bAcquire)
            delete pSD;
        return;
    }

    if ((ctrl & SE_SELF_RELATIVE) == 0)
    {
        // If here, we have to conver the SD to self-relative form.
        // ========================================================

        DWORD dwRequired = 0;

        bRes = MakeSelfRelativeSD(
            pSD,
            m_pSD,
            &dwRequired
            );

        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            m_dwStatus = InvalidSD;
            if (bAcquire)
                delete pSD;
            return;
        }

        m_pSD = new BYTE[dwRequired];
        if (!m_pSD)
        {
            m_dwStatus = InvalidSD;
            if (bAcquire)
                delete pSD;
            return;
        }

        ZeroMemory(m_pSD, dwRequired);

        bRes = MakeSelfRelativeSD(
            pSD,
            m_pSD,
            &dwRequired
            );

        if (!bRes)
        {
            m_dwStatus = InvalidSD;
            if (bAcquire)
                delete pSD;
            return;
        }

        m_dwStatus = NoError;
        return;
    }


    // If here, the SD was already self-relative.
    // ==========================================

    if (bAcquire)
        m_pSD = pSD;
    else
    {
        DWORD dwRes = GetSecurityDescriptorLength(pSD);
        m_pSD = new BYTE[dwRes];
        if (!m_pSD)
        {
            m_dwStatus = InvalidSD;
            return;
        }

        ZeroMemory(m_pSD, dwRes);
        memcpy(m_pSD, pSD, dwRes);
    }

    m_dwStatus = NoError;
}

//***************************************************************************
//
//  CNtSecurity::DumpPrivileges
//
//  Dumps current process token privileges to the console.
//
//***************************************************************************

BOOL CNtSecurity::DumpPrivileges()
{
    HANDLE hToken = 0;
    TOKEN_INFORMATION_CLASS tki;
    BOOL bRes;
    LPVOID pTokenInfo = 0;
    DWORD  dwRequiredBytes;
    BOOL   bRetVal = FALSE;
    TOKEN_PRIVILEGES *pPriv = 0;
    TCHAR *pName = 0;
    DWORD dwIndex;
    DWORD dwLastError;

    _tprintf(__TEXT("--- Current Token Privilege Dump ---\n"));

    // Starting point: open the process token.
    // =======================================

    bRes = OpenProcessToken(
        GetCurrentProcess(),
        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
        &hToken
        );

    if (!bRes)
    {
        _tprintf(__TEXT("Unable to open process token\n"));
        goto Exit;
    }

    // Query for privileges.
    // =====================

    tki = TokenPrivileges;

    bRes = GetTokenInformation(
        hToken,
        tki,
        pTokenInfo,
        0,
        &dwRequiredBytes
        );

    dwLastError = GetLastError();

    if (dwLastError != ERROR_INSUFFICIENT_BUFFER)
    {
        printf("Unable to get buffer size for token information\n");
        goto Exit;
    }

    pTokenInfo = new BYTE[dwRequiredBytes];
    if (!pTokenInfo)
        goto Exit;
    ZeroMemory(pTokenInfo, dwRequiredBytes);

    bRes = GetTokenInformation(
        hToken,
        tki,
        pTokenInfo,
        dwRequiredBytes,
        &dwRequiredBytes
        );

    if (!bRes)
    {
        printf("Unable to query token\n");
        goto Exit;
    }

    // Loop through the privileges.
    // ============================

    pPriv = (TOKEN_PRIVILEGES *) pTokenInfo;

    for (dwIndex = 0; dwIndex < pPriv->PrivilegeCount; dwIndex++)
    {
        pName = 0;
        dwRequiredBytes = 0;

        // Find the buffer size required for the name.
        // ===========================================

        bRes = LookupPrivilegeName(
            0,                          // System name
            &pPriv->Privileges[dwIndex].Luid,
            pName,
            &dwRequiredBytes
            );

        dwLastError = GetLastError();

        if (dwLastError != ERROR_INSUFFICIENT_BUFFER)
        {
            printf("Failed to find privilege name\n");
            goto Exit;
        }

        // Allocate enough space to hold the privilege name.
        // =================================================

        pName = (TCHAR *) new BYTE[dwRequiredBytes];
        if(pName == NULL)
            goto Exit;

        ZeroMemory(pName, dwRequiredBytes);

        bRes = LookupPrivilegeName(
            0,                          // System name
            &pPriv->Privileges[dwIndex].Luid,
            pName,
            &dwRequiredBytes
            );

        printf("%s ", pName);
        delete pName;

        // Determine the privilege 'status'.
        // =================================

        if (pPriv->Privileges[dwIndex].Attributes & SE_PRIVILEGE_ENABLED)
            printf("<ENABLED> ");
        if (pPriv->Privileges[dwIndex].Attributes & SE_PRIVILEGE_ENABLED_BY_DEFAULT)
            printf("<ENABLED BY DEFAULT> ");
        if (pPriv->Privileges[dwIndex].Attributes & SE_PRIVILEGE_USED_FOR_ACCESS)
            printf("<USED FOR ACCESS> ");

        printf("\n");

        pName = 0;
    }

    printf("--- End Privilege Dump ---\n");

    bRetVal = TRUE;

Exit:
    if (pTokenInfo)
        delete pTokenInfo;
    if (hToken)
        CloseHandle(hToken);
    return bRetVal;
}

//***************************************************************************
//
//  CNtSecurity::SetPrivilege
//
//  Ensures a given privilege is enabled.
//
//  Parameters:
//
//  <pszPrivilegeName>  One of the SE_ constants defined in WINNT.H for
//                      privilege names.  Example: SE_SECURITY_NAME
//  <bEnable>           If TRUE, the privilege will be enabled. If FALSE,
//                      the privilege will be disabled.
//
//  Return value:
//  TRUE if the privilege was enabled, FALSE if not.
//
//***************************************************************************
// ok

BOOL CNtSecurity::SetPrivilege(
    TCHAR *pszPrivilegeName,     // An SE_ value.
    BOOL  bEnable               // TRUE=enable, FALSE=disable
    )
{
    HANDLE hToken = 0;
    TOKEN_PRIVILEGES tkp;
    LUID priv;
    BOOL bRes;
    BOOL bRetVal = FALSE;

    bRes = OpenProcessToken(
        GetCurrentProcess(),
        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
        &hToken
        );

    if (!bRes)
        goto Exit;

    // Locate the privilege LUID based on the requested name.
    // ======================================================

    bRes = LookupPrivilegeValue(
        0,                          // system name, 0=local
        pszPrivilegeName,
        &priv
        );

    if (!bRes)
        goto Exit;

    // We now have the LUID.  Next, we build up the privilege
    // setting based on the user-specified <bEnable>.
    // ======================================================

    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Luid  = priv;

    if (bEnable)
        tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    else
        tkp.Privileges[0].Attributes = 0;

    // Do it.
    // ======

    bRes = AdjustTokenPrivileges(
        hToken,
        FALSE,
        &tkp,
        sizeof(TOKEN_PRIVILEGES),
        0,
        0
        );

    if (!bRes)
        goto Exit;

    bRetVal = TRUE;

Exit:
    if (hToken)
        CloseHandle(hToken);
    return bRetVal;
}


//***************************************************************************
//
//  CNtSecurity::GetFileSD
//
//  Gets the complete security descriptor for file or directory on NT systems.
//
//  Parameters:
//  <pszFile>       The path to the file or directory.
//
//  <SecInfo>       The information which will be manipulated.  See
//                  SECURITY_INFORMATION in NT SDK documentation.
//
//  <pReturnedSD>   Receives a pointer to the CNtSecurityDecriptor object
//                  which represents security on the file.  The caller
//                  becomes onwer of the object, which must be deallocated
//                  with operator delete.
//
//                  The returned object which is a copy of the
//                  underlying security descriptor.  Changes to the returned
//                  object are not propagated to the file.  SetFileSD must
//                  be used to do this.
//
//                  This will be set to point to NULL on error.
//
//  Return value:
//  NoError, NotFound, AccessDenied, Failed
//
//***************************************************************************
// ok

int CNtSecurity::GetFileSD(
    IN  TCHAR *pszFile,
    IN SECURITY_INFORMATION SecInfo,
    OUT CNtSecurityDescriptor **pReturnedSD
    )
{
    // First, verify that the file/dir exists.
    // =======================================

#ifdef _UNICODE
    int nRes = _waccess(pszFile, 0);
#else
    int nRes = _access(pszFile, 0);
#endif

    if (nRes != 0)
    {
        if (errno == ENOENT)
            return NotFound;
        if (errno == EACCES)
            return AccessDenied;
        if (nRes == -1) // Other errors
            return Failed;
    }

    // If here, we think we can play with it.
    // ======================================

    PSECURITY_DESCRIPTOR pSD = 0;
    DWORD dwRequiredBytes;
    BOOL bRes;
    DWORD dwLastError;

    *pReturnedSD = 0;

    // Call once first to get the required buffer sizes.
    // =================================================

    bRes = GetFileSecurity(
        pszFile,
        SecInfo,
        pSD,
        0,
        &dwRequiredBytes
        );

    dwLastError = GetLastError();

    if (dwLastError != ERROR_INSUFFICIENT_BUFFER)
    {
        // Analyze the error

        return Failed;
    }

    // Now call again with a buffer large enough to hold the SD.
    // =========================================================

    pSD = (PSECURITY_DESCRIPTOR) new BYTE[dwRequiredBytes];
    if(pSD == NULL)
        return Failed;

    ZeroMemory(pSD, dwRequiredBytes);

    bRes = GetFileSecurity(
        pszFile,
        SecInfo,
        pSD,
        dwRequiredBytes,
        &dwRequiredBytes
        );

    if (!bRes)
    {
        delete pSD;
        return Failed;
    }

    // If here, we have a security descriptor.
    // =======================================

    CNtSecurityDescriptor *pNewSD = new CNtSecurityDescriptor(pSD, TRUE);
    if(pNewSD == NULL)
    {
        delete pSD;
        return Failed;
    }

    *pReturnedSD = pNewSD;

    return NoError;
}

//***************************************************************************
//
//  CNtSecurity::GetRegSD
//
//  Retrieves the security descriptor for a registry key.
//
//  Parameters:
//  <hRoot>         The root key (HKEY_LOCAL_MACHINE, etc.)
//  <pszSubKey>     The subkey under the root key.
//  <SecInfo>       The information which will be manipulated.  See
//                  SECURITY_INFORMATION in NT SDK documentation.
//  <pSD>           Receives the pointer to the security descriptor if
//                  no error occurs.  Caller must use operator delete.
//
//  Return value:
//  NoError, NotFound, AccessDenied, Failed
//
//***************************************************************************
int CNtSecurity::GetRegSD(
    IN HKEY hRoot,
    IN TCHAR *pszSubKey,
    IN SECURITY_INFORMATION SecInfo,
    OUT CNtSecurityDescriptor **pSD
    )
{
    HKEY hKey;
    *pSD = 0;

    ACCESS_MASK amAccess = KEY_ALL_ACCESS;
    if (SecInfo & SACL_SECURITY_INFORMATION)
        amAccess |= ACCESS_SYSTEM_SECURITY;

    LONG lRes = RegOpenKeyEx(hRoot, pszSubKey, 0, amAccess, &hKey);

    if (lRes == ERROR_ACCESS_DENIED)
        return AccessDenied;

    if (lRes != ERROR_SUCCESS)
        return Failed;

    // If here, the key is open.  Now we try to get the security descriptor.
    // =====================================================================

    PSECURITY_DESCRIPTOR pTmpSD = 0;
    DWORD dwRequired = 0;

    // Determine the buffer size required.
    // ===================================

    lRes = RegGetKeySecurity(hKey, SecInfo, pTmpSD, &dwRequired);

    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
    {
        RegCloseKey(hKey);
        return Failed;
    }

    // Allocate room for the SD and get it.
    // ====================================
    pTmpSD = new BYTE[dwRequired];
    if (!pTmpSD)
    {
        RegCloseKey(hKey);
        return Failed;
    }

    ZeroMemory(pTmpSD, dwRequired);

    lRes = RegGetKeySecurity(hKey, SecInfo, pTmpSD, &dwRequired);

    if (lRes != 0 || !IsValidSecurityDescriptor(pTmpSD))
    {
        delete pTmpSD;
        RegCloseKey(hKey);
        return Failed;
    }

    RegCloseKey(hKey);
    CNtSecurityDescriptor *pNewSD = new CNtSecurityDescriptor(pTmpSD, TRUE);
    if(pNewSD == NULL)
    {
        delete pTmpSD;
        return Failed;
    }
        
    *pSD = pNewSD;

    return NoError;
}


//***************************************************************************
//
//  CNtSecurity::SetRegSD
//
//  Sets the security descriptor for a registry key.
//
//  Parameters:
//  <hRoot>         The root key (HKEY_LOCAL_MACHINE, etc.)
//  <pszSubKey>     The subkey under the root key.
//  <SecInfo>       The information which will be manipulated.  See
//                  SECURITY_INFORMATION in NT SDK documentation.
//  <pSD>           The read-only pointer to the new security descriptor.
//
//  Return value:
//  NoError, NotFound, AccessDenied, Failed
//
//***************************************************************************
int CNtSecurity::SetRegSD(
    IN HKEY hRoot,
    IN TCHAR *pszSubKey,
    IN SECURITY_INFORMATION SecInfo,
    IN CNtSecurityDescriptor *pSD
    )
{
    HKEY hKey;

    if (!pSD->IsValid())
        return Failed;

    ACCESS_MASK amAccess = KEY_ALL_ACCESS;
    if (SecInfo & SACL_SECURITY_INFORMATION)
        amAccess |= ACCESS_SYSTEM_SECURITY;

    LONG lRes = RegOpenKeyEx(hRoot, pszSubKey, 0, amAccess, &hKey);

    if (lRes == ERROR_ACCESS_DENIED)
        return AccessDenied;

    if (lRes != ERROR_SUCCESS)
        return Failed;

    // If here, the key is open.  Now we try to get the security descriptor.
    // =====================================================================

    PSECURITY_DESCRIPTOR pTmpSD = 0;
    DWORD dwRequired = 0;

    // Determine the buffer size required.
    // ===================================

    lRes = RegSetKeySecurity(hKey, SecInfo, pSD->GetPtr());

    if (lRes != 0)
    {
        RegCloseKey(hKey);
        return Failed;
    }

    RegCloseKey(hKey);
    return NoError;
}



//***************************************************************************
//
//  CNtSecurity::SetFileSD
//
//  Sets the security descriptor for a file or directory.
//
//  Parameters:
//  <pszFile>       The file/dir for which to set security.
//  <SecInfo>       The information which will be manipulated.  See
//                  SECURITY_INFORMATION in NT SDK documentation.
//  <pSD>           Pointer to a valid CNtSecurityDescriptor
//
//***************************************************************************
//  ok
BOOL CNtSecurity::SetFileSD(
    IN TCHAR *pszFile,
    IN SECURITY_INFORMATION SecInfo,
    IN CNtSecurityDescriptor *pSD
    )
{
    // First, verify that the file/dir exists.
    // =======================================
#ifdef _UNICODE
    int nRes = _waccess(pszFile, 0);
#else
    int nRes = _access(pszFile, 0);
#endif

    if (nRes != 0)
        return FALSE;

    // Verify the SD is good.
    // ======================

    if (pSD->GetStatus() != NoError)
        return FALSE;

    BOOL bRes = ::SetFileSecurity(
        pszFile,
        SecInfo,
        pSD->GetPtr()
        );

    return bRes;
}

//***************************************************************************
//
//  CNtSecurity::GetDCName
//
//  Determines the domain controller for a given domain name.
//
//  Parameters:
//  <pszDomain>         The domain name for which to find the controller.
//  <pszDC>             Receives a pointer to the DC name.  Deallocate with
//                      operator delete.
//  <pszServer>         Optional remote helper server on which to execute
//                      the query. Defaults to NULL, which typically
//                      succeeds.
//
//  Return value:
//  NoError, NotFound, InvalidName
//
//***************************************************************************
/*
int CNtSecurity::GetDCName(
    IN  LPWSTR   pszDomain,
    OUT LPWSTR *pszDC,
    IN  LPWSTR   pszServer
    )
{
    LPBYTE pBuf;
    NET_API_STATUS Status;

    Status = NetGetDCName(pszServer, pszDomain, &pBuf);

    if (Status == NERR_DCNotFound)
        return NotFound;

    if (Status == ERROR_INVALID_NAME)
        return InvalidName;

    LPWSTR pRetStr = new wchar_t[wcslen(LPWSTR(pBuf)) + 1];
    wcscpy(pRetStr, LPWSTR(pBuf));
    NetApiBufferFree(pBuf);

    *pszDC = pRetStr;
    return NoError;
}
*/
//***************************************************************************
//
//  CNtSecurity::IsUserInGroup2
//
//  Determines if the use belongs to a particular NTLM group by checking the
//  group list in the access token.  This may be a better way than the
//  current implementation.
//
//  Parameters:
//  <hToken>            The user's access token.
//  <Sid>               Object containing the sid of the group being tested.
//
//  Return value:
//  TRUE if the user belongs to the group.
//
//***************************************************************************
/*
BOOL CNtSecurity::IsUserInGroup2(
        HANDLE hAccessToken,
        CNtSid & Sid)
{
    if(!IsNT() || hAccessToken == NULL)
        return FALSE;       // No point in further testing

    DWORD dwErr;

    // Obtain and the groups from token.  Start off by determining how much
    // memory is required.

    TOKEN_GROUPS Groups;
    DWORD dwLen = 0;
    GetTokenInformation(hAccessToken, TokenGroups, &Groups, sizeof(Groups), &dwLen);
    if(dwLen == 0)
        return FALSE;

    // Load up the group list

    int BUFFER_SIZE = dwLen;
    BYTE * byteBuffer = new BYTE[BUFFER_SIZE];
    if(byteBuffer == NULL)
        return FALSE;
    DWORD dwSizeRequired = 0;
    BOOL bResult = GetTokenInformation( hAccessToken,
                                        TokenGroups,
                                        (void *) byteBuffer,
                                        BUFFER_SIZE,
                                        &dwSizeRequired );
    if ( !bResult ) {
        delete [] byteBuffer;
        dwErr = GetLastError();
        return ( FALSE );
    }

    // Loop through the group list looking for a match

    BOOL bFound = FALSE;
    PTOKEN_GROUPS pGroups = (PTOKEN_GROUPS) byteBuffer;
    for ( unsigned i = 0; i < pGroups->GroupCount; i++ )
    {
        CNtSid test(pGroups->Groups[i].Sid);
        if(test == Sid)
        {
            bFound = TRUE;
            break;
        }
    }

    delete [] byteBuffer;
    return bFound;
}*/

//***************************************************************************
//
//  CNtSecurity::IsUserInGroup
//
//  Determines if the use belongs to a particular NTLM group.
//
//  Parameters:
//  <hToken>            The user's access token.
//  <Sid>               Object containing the sid of the group being tested.
//
//  Return value:
//  TRUE if the user belongs to the group.
//
//***************************************************************************

BOOL CNtSecurity::IsUserInGroup(
        HANDLE hAccessToken,
        CNtSid & Sid)
{
    if(!IsNT() || hAccessToken == NULL)
        return FALSE;       // No point in further testing

    // create a security descriptor with a single entry which
    // is the group in question.

    CNtAce ace(1,ACCESS_ALLOWED_ACE_TYPE,0,Sid);
    if(ace.GetStatus() != 0)
        return FALSE;

    CNtAcl acl;
    acl.AddAce(&ace);
    CNtSecurityDescriptor sd;
    sd.SetDacl(&acl);
    sd.SetGroup(&Sid);            // Access check doesnt really care what you put, so long as you
                                  // put something for the owner
    sd.SetOwner(&Sid);

    GENERIC_MAPPING map;
    map.GenericRead = 1;
    map.GenericWrite = 0;
    map.GenericExecute = 0;
    map.GenericAll = 0;
    PRIVILEGE_SET ps[10];
    DWORD dwSize = 10 * sizeof(PRIVILEGE_SET);


    DWORD dwGranted;
    BOOL bResult;

    BOOL bOK = ::AccessCheck(sd.GetPtr(), hAccessToken, 1, &map, ps, &dwSize, &dwGranted, &bResult);
    DWORD dwErr = GetLastError();
    if(bOK && bResult)
        return TRUE;
    else
        return FALSE;
}
//***************************************************************************
//
//  CNtSecurity::DoesGroupExist
//
//  Determines if a group exists.
//
//  Return value:
//  TRUE if the group exists
//
//***************************************************************************

bool CNtSecurity::DoesLocalGroupExist(
        LPWSTR pwszGroup,
        LPWSTR pwszMachine)
{
    bool bRet = false;
    HINSTANCE hAPI = LoadLibraryEx(__TEXT("netapi32"), NULL, 0);
    if(hAPI)
    {
        NET_API_STATUS (NET_API_FUNCTION *pfnGetInfo)(LPWSTR , LPWSTR ,DWORD , LPBYTE *);
        (FARPROC&)pfnGetInfo = GetProcAddress(hAPI, "NetLocalGroupGetInfo");
        long lRes;
        if(pfnGetInfo)
        {
            LOCALGROUP_INFO_1 * info;

            lRes = pfnGetInfo(pwszMachine, pwszGroup, 1, (LPBYTE *)&info);
            if(lRes == NERR_Success)
            {
                NET_API_STATUS (NET_API_FUNCTION *pfnBufferFree)(LPVOID);
                (FARPROC&)pfnBufferFree = GetProcAddress(hAPI, "NetApiBufferFree");
                if(pfnBufferFree)
                    pfnBufferFree(info);

                bRet = true;
            }
        }
        FreeLibrary(hAPI);
    }
    return bRet;
}

//***************************************************************************
//
//  CNtSecurity::AddLocalGroup
//
//  Determines if a group exists.
//
//  Return value:
//  TRUE if the group exists
//
//***************************************************************************

bool CNtSecurity::AddLocalGroup(LPWSTR pwszGroupName, LPWSTR pwszGroupDescription)
{
    bool bRet = false;
    HINSTANCE hAPI = LoadLibraryEx(__TEXT("netapi32"), NULL, 0);
    if(hAPI)
    {
        LOCALGROUP_INFO_1 info;
        info.lgrpi1_name = pwszGroupName;
        info.lgrpi1_comment = pwszGroupDescription;
        NET_API_STATUS (*pfnLocalAdd)(LPWSTR ,DWORD , LPBYTE ,LPDWORD);

        (FARPROC&)pfnLocalAdd = GetProcAddress(hAPI, "NetLocalGroupAdd");
        if(pfnLocalAdd)
            bRet = (pfnLocalAdd(NULL, 1, (LPBYTE)&info, NULL) == NERR_Success);
        FreeLibrary(hAPI);
    }
    return bRet;
}

//***************************************************************************
//
//***************************************************************************
void ChangeSecurity(CNtSecurityDescriptor *pSD)
{
    CNtAcl Acl;


    ACCESS_MASK Mask = FULL_CONTROL;


    CNtSid Sid(L"Everyone", 0);
    CNtAce Ace(
        Mask,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE,
        Sid);

    if (Ace.GetStatus() != CNtAce::NoError)
    {
        printf("Bad ACE\n");
        return;
    }

    CNtAce Ace2(Ace);
    CNtAce Ace3;
    Ace3 = Ace2;

    Acl.AddAce(&Ace3);

    CNtAcl Acl2(Acl);
    CNtAcl Acl3;
    Acl3 = Acl2;

    pSD->SetDacl(&Acl);

    CNtSecurityDescriptor SD2(*pSD);
    CNtSecurityDescriptor SD3;
    SD3.SetDacl(&Acl3);

    SD3 = SD2;

    *pSD = SD3;

    CNtSid *pOwner = pSD->GetOwner();

    if (pOwner)
        pSD->SetOwner(pOwner);
}

//***************************************************************************
//
//***************************************************************************



void SidTest(char *pUser, char *pMachine)
{
    wchar_t User[128], Mach[128];

    MultiByteToWideChar(CP_ACP, 0, pUser, -1, User, 128);
    MultiByteToWideChar(CP_ACP, 0, pMachine, -1, Mach, 128);

    printf("------SID TEST----------\n");

    LPWSTR pMach2 = 0;
    if (pMachine)
        pMach2 = Mach;

    CNtSid TseSid(User, pMach2);

    printf("TseSid status = %d\n", TseSid.GetStatus());

    TseSid.Dump();
}


void TestRegSec()
{

    CNtSecurityDescriptor *pSD = 0;

    int nRes = CNtSecurity::GetRegSD(HKEY_LOCAL_MACHINE,WBEM_REG_WBEM,
        DACL_SECURITY_INFORMATION, &pSD);

    printf("----------------BEGIN SECURITY KEY DUMP-------------\n");
    pSD->Dump();
    printf("----------------END SECURITY KEY DUMP-------------\n");

    if (pSD->IsValid())
        nRes = CNtSecurity::SetRegSD(HKEY_LOCAL_MACHINE, WBEM_REG_WBEM,
                    DACL_SECURITY_INFORMATION, pSD);
}

/*
void main(int argc, char **argv)
{
    BOOL bRes;

    printf("Test\n");

    if (argc < 2)
        return;

    bRes = CNtSecurity::SetPrivilege(SE_SECURITY_NAME, TRUE);

    CNtSecurity::DumpPrivileges();

    CNtSecurityDescriptor *pSD = 0;

    int nRes = CNtSecurity::GetFileSD(argv[1], DACL_SECURITY_INFORMATION, &pSD);

    if (nRes == CNtSecurity::NotFound)
    {
        printf("No such file/dir\n");
        return;
    }

    if (nRes != 0)
    {
        printf("Cannot get security descriptor. Last=%d\n", GetLastError());
    }

    pSD->Dump();


    delete pSD;
}
*/
//***************************************************************************
//
//  FIsRunningAsService
//
//  Purpose:
//  Determines if the current process is running as a service.
//
//  Returns:
//      FALSE if running interactively
//      TRUE if running as a service.
//
//***************************************************************************

/*BOOL FIsRunningAsService(VOID)
{
    HWINSTA hws = GetProcessWindowStation();
    if(hws == NULL)
        return TRUE;

    DWORD LengthNeeded;

    BOOL bService = FALSE;
    USEROBJECTFLAGS fl;
    if(GetUserObjectInformation(hws, UOI_FLAGS, &fl, sizeof(USEROBJECTFLAGS), &LengthNeeded))
        if(fl.dwFlags & WSF_VISIBLE)
            bService = FALSE;
        else
            bService = TRUE;
    CloseWindowStation(hws);
    return bService;
}*/


C9XAce::C9XAce(
        ACCESS_MASK Mask,
        DWORD AceType,
        DWORD dwAceFlags,
        LPWSTR pUser
        )
{
    m_wszFullName = NULL;
    if(pUser)
        m_wszFullName = Macro_CloneLPWSTR(pUser);
    m_dwAccess = Mask;
    m_iFlags = dwAceFlags;
    m_iType = AceType;
}

C9XAce::~C9XAce()
{
    if(m_wszFullName)
        delete [] m_wszFullName;
}

HRESULT C9XAce::GetFullUserName(WCHAR * pBuff, DWORD dwSize)
{
    if(pBuff && m_wszFullName)
    {
        wcsncpy(pBuff, m_wszFullName, dwSize-1);
        pBuff[dwSize-1] = 0;
        return S_OK;
    }
    return WBEM_E_FAILED;
}

HRESULT C9XAce::GetFullUserName2(WCHAR ** pBuff)
{
    if(wcslen(m_wszFullName) < 1)
        return WBEM_E_FAILED;

    int iLen = wcslen(m_wszFullName)+4;
    *pBuff = new WCHAR[iLen];
    if(*pBuff == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    // there are two possible formats, the first is "UserName", and the 
    // second is "domain\username".  

    WCHAR * pSlash;
    for(pSlash = m_wszFullName; *pSlash && *pSlash != L'\\'; pSlash++); // intentional

    if(*pSlash && pSlash > m_wszFullName)
    {
        // got a domain\user, convert to domain|user
        
        wcscpy(*pBuff, m_wszFullName);
        for(pSlash = *pBuff; *pSlash; pSlash++)
            if(*pSlash == L'\\')
            {
                *pSlash = L'|';
                break;
            }
    }
    else
    {
        // got a "user", convert to ".|user"
    
        wcscpy(*pBuff, L".|");
        wcscat(*pBuff, m_wszFullName);
    }
    return S_OK;
}

//***************************************************************************
//
//  C9XAce::GetSerializedSize
//
//  Returns the number of bytes needed to store this
//
//***************************************************************************

DWORD C9XAce::GetSerializedSize()
{
    if (m_wszFullName == 0 || wcslen(m_wszFullName) == 0)
        return 0;
    return 2 * (wcslen(m_wszFullName) + 1) + 12;
}

//***************************************************************************
//
//  C9XAce::Serialize
//
//  Serializes the ace.  The serialized version will consist of
//  <DOMAIN\USERNAME LPWSTR><FLAGS><TYPE><MASK>
//
//  Note that the fields are dwords except for the name.
//
//***************************************************************************

bool C9XAce::Serialize(BYTE * pData)
{
    wcscpy((LPWSTR)pData, m_wszFullName);
    pData += 2*(wcslen(m_wszFullName) + 1);
    DWORD * pdwData = (DWORD *)pData;
    *pdwData = m_iFlags;
    pdwData++;
    *pdwData = m_iType;
    pdwData++;
    *pdwData = m_dwAccess;
    pdwData++;
    return true;
}

//***************************************************************************
//
//  C9XAce::Deserialize
//
//  Deserializes the ace.  See the comments for Serialize for comments.
//
//***************************************************************************

bool C9XAce::Deserialize(BYTE * pData)
{
    m_wszFullName = new WCHAR[wcslen((LPWSTR)pData) + 1];
    if (!m_wszFullName)
        return false;

    wcscpy(m_wszFullName, (LPWSTR)pData);
    pData += 2*(wcslen(m_wszFullName) + 1);

    DWORD * pdwData = (DWORD *)pData;

    m_iFlags = *pdwData;
    pdwData++;
    m_iType = *pdwData;
    pdwData++;
    m_dwAccess = *pdwData;
    pdwData++;
    return true;

}

//***************************************************************************
//
//  BOOL SetObjectAccess2
//
//  DESCRIPTION:
//
//  Adds read/open and set access for the everyone group to an object.
//
//  PARAMETERS:
//
//  hObj                Object to set access on.
//
//  RETURN VALUE:
//
//  Returns TRUE if OK.
//
//***************************************************************************

BOOL SetObjectAccess2(IN HANDLE hObj)
{
    PSECURITY_DESCRIPTOR pSD = NULL;
    DWORD dwLastErr = 0;
    BOOL bRet = FALSE;

    // no point if we arnt on nt

    if(!IsNT())
    {
        return TRUE;
    }

    // figure out how much space to allocate

    DWORD dwSizeNeeded;
    bRet = GetKernelObjectSecurity(
                    hObj,           // handle of object to query
                    DACL_SECURITY_INFORMATION, // requested information
                    pSD,  // address of security descriptor
                    0,           // size of buffer for security descriptor
                    &dwSizeNeeded);  // address of required size of buffer

    if(bRet == TRUE || (ERROR_INSUFFICIENT_BUFFER != GetLastError()))
        return FALSE;

    pSD = new BYTE[dwSizeNeeded];
    if(pSD == NULL)
        return FALSE;

    // Get the data

    bRet = GetKernelObjectSecurity(
                    hObj,           // handle of object to query
                    DACL_SECURITY_INFORMATION, // requested information
                    pSD,  // address of security descriptor
                    dwSizeNeeded,           // size of buffer for security descriptor
                    &dwSizeNeeded ); // address of required size of buffer
    if(bRet == FALSE)
    {
        delete pSD;
        return FALSE;
    }
    
    // move it into object for

    CNtSecurityDescriptor sd(pSD,TRUE);    // Acquires ownership of the memory
    if(sd.GetStatus() != 0)
        return FALSE;
    CNtAcl acl;
    if(!sd.GetDacl(acl))
        return FALSE;

    // Create an everyone ace

    PSID pRawSid;
    SID_IDENTIFIER_AUTHORITY id2 = SECURITY_WORLD_SID_AUTHORITY;;

    if(AllocateAndInitializeSid( &id2, 1,
        0,0,0,0,0,0,0,0,&pRawSid))
    {
        CNtSid SidUsers(pRawSid);
        FreeSid(pRawSid);
        CNtAce * pace = new CNtAce(EVENT_MODIFY_STATE | SYNCHRONIZE, ACCESS_ALLOWED_ACE_TYPE, 0 
                                                , SidUsers);
        if(pace == NULL)
            return FALSE;
        if( pace->GetStatus() == 0)
            acl.AddAce(pace);
        delete pace;

    }

    if(acl.GetStatus() != 0)
        return FALSE;
    sd.SetDacl(&acl);
    bRet = SetKernelObjectSecurity(hObj, DACL_SECURITY_INFORMATION, sd.GetPtr());
    return TRUE;
}


//***************************************************************************
//
//  IsAdmin
//
//  returns TRUE if we are a member of the admin group or running as 
//  NETWORK_SERVICE or running as LOCAL_SERVICE
//
//***************************************************************************

BOOL IsAdmin(HANDLE hAccess)
{
    BOOL bRet = FALSE;
    PSID pRawSid;
    SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;

    if(AllocateAndInitializeSid( &id, 2,
        SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
        0,0,0,0,0,0,&pRawSid))
    {
        CNtSid Sid(pRawSid);
        bRet = CNtSecurity::IsUserInGroup(hAccess, Sid);

        // We're done with this
        FreeSid( pRawSid );
    }
    
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Lets check for NETWORK_SERVICE and LOCAL_SERVICE since 
	// they also want full admin rights
	// COMMENTED OUT DUE TO: 504554
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	//if ( !bRet )
	//{
	//	bRet = IsNetworkService ( hAccess );
	//	if ( !bRet )
	//	{
	//		bRet = IsLocalService ( hAccess );
	//	}
	//}

	return bRet;
}


//***************************************************************************
//
//  IsNetworkService
//
//  returns TRUE if we are running as NETWORK_SERVICE
//
//***************************************************************************

BOOL IsNetworkService ( HANDLE hAccess )
{
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Construct the NETWORK_SERVICE SID
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;
    PSID pSidSystem;
	BOOL bRes = FALSE;
	
    if ( AllocateAndInitializeSid(&id, 1, SECURITY_NETWORK_SERVICE_RID, 0, 0,0,0,0,0,0,&pSidSystem) )
	{
		if ( !CheckTokenMembership ( hAccess, pSidSystem, &bRes ) )
		{
			bRes = FALSE;
		}
		FreeSid ( pSidSystem );
	}

	return bRes;
}



//***************************************************************************
//
//  IsLocalService
//
//  returns TRUE if we are running as LOCAL_SERVICE
//
//***************************************************************************

BOOL IsLocalService ( HANDLE hAccess )
{
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Construct the NETWORK_SERVICE SID
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;
    PSID pSidSystem;
	BOOL bRes = FALSE;
	
    if ( AllocateAndInitializeSid(&id, 1, SECURITY_LOCAL_SERVICE_RID, 0, 0,0,0,0,0,0,&pSidSystem) )
	{
		if ( !CheckTokenMembership ( hAccess, pSidSystem, &bRes ) )
		{
			bRes = FALSE;
		}
		FreeSid ( pSidSystem );
	}

	return bRes;
}


//***************************************************************************
//
//  IsInAdminGroup
//
//  returns TRUE if we are a member of the admin group.
//
//***************************************************************************

BOOL IsInAdminGroup()
{
    HANDLE hAccessToken = INVALID_HANDLE_VALUE;
    if(S_OK != GetAccessToken(hAccessToken))
        return TRUE;       // Not having a token indicates an internal thread

    CCloseHandle cm(hAccessToken);

    DWORD dwMask = 0;

    if(IsAdmin(hAccessToken))
        return TRUE;
    else
        return FALSE;
}

//***************************************************************************
//
//  HRESULT GetAccessToken
//
//  Gets the access token and sets it the the reference argument.
//
//***************************************************************************

HRESULT GetAccessToken(HANDLE &hAccessToken)
{
    // Ensures auto release of the mutex if we crash
    CAutoSecurityMutex  autosm;

    bool bIsImpersonating = WbemIsImpersonating();

    HRESULT hRes = S_OK;
    if(bIsImpersonating == false)
        hRes = WbemCoImpersonateClient();
    if(hRes == S_OK)
    {
        BOOL bOK = OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &hAccessToken);
        if(bOK == FALSE)
        {
            hRes = WBEM_E_INVALID_CONTEXT;
        }
        else
            hRes = S_OK;
    }

    if(bIsImpersonating == false)
        WbemCoRevertToSelf();

    // The security mutex will auto release

    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\var.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    VAR.H

Abstract:

  CVar & CVarVector implemntation

History:

    16-Apr-96   a-raymcc    Created.
    12//17/98   sanjes -    Partially Reviewed for Out of Memory.
    18-Mar-99   a-dcrews    Added out-of-memory exception handling

--*/

#include "precomp.h"

#include <stdio.h>
#include <stdlib.h>

#include <var.h>
#include <wbemutil.h>
#include <genutils.h>
#include <wbemidl.h>
#include <corex.h>
#include <arrtempl.h>
#include <olewrap.h>

static wchar_t g_szNullVarString[1] = {0};
static wchar_t* g_pszNullVarString = &g_szNullVarString[0];

//***************************************************************************
//
//  CVar::Empty
//
//  Constructor helper.
//
//  This merely clears everything.  VT_EMPTY is the default.
//
//***************************************************************************

void CVar::Init()
{
    m_nStatus = no_error; 
    m_vt = VT_EMPTY;
    m_bCanDelete = TRUE;
    memset(&m_value, 0, sizeof(METAVALUE));
}


//***************************************************************************
//
//  CVar::~CVar
//
//  Destructor.
//
//***************************************************************************

CVar::~CVar()
{
    Empty();
}



//***************************************************************************
//
//  CVar::CVar
//
//  Copy constructor.  This is implemented via the assignment operator.
//  
//***************************************************************************

CVar::CVar(CVar &Src)
{
    m_vt = VT_EMPTY;
    m_nStatus = no_error; 
    memset(&m_value, 0, sizeof(METAVALUE));
    *this = Src;
}

//***************************************************************************
//
//  CVar::operator =
//
//  NOTES:
//  Observe that VT_EX_CVARVECTOR is dedicated to embedded CVarVector objects.
//  Also, only pointer types require a new allocation + copy, whereas
//  most of the simple types are directly assignable, in the <default>
//  label of the switch statement.
//
//***************************************************************************

CVar& CVar::operator =(CVar &Src)
{
    Empty();

    m_vt = Src.m_vt;
    m_nStatus = m_nStatus;
    m_bCanDelete = TRUE;

    switch (m_vt) {
        case VT_LPSTR:

            // Check for an allocation failure
            if ( NULL != Src.m_value.pStr )
            {
                m_value.pStr = new char[strlen(Src.m_value.pStr) + 1];

                if ( NULL == m_value.pStr )
                {
                    throw CX_MemoryException();
                }
                strcpy( m_value.pStr, Src.m_value.pStr );
            }
            else
            {
                m_value.pStr = NULL;
            }

            break;

        case VT_LPWSTR:
        case VT_BSTR:
            // Check for an allocation failure
            if ( NULL != Src.m_value.pWStr )
            {
                m_value.pWStr = new wchar_t[wcslen(Src.m_value.pWStr) + 1];

                if ( NULL == m_value.pWStr )
                {
                    throw CX_MemoryException();
                }
                wcscpy( m_value.pWStr, Src.m_value.pWStr );
            }
            else
            {
                m_value.pWStr = NULL;
            }

            break;

        case VT_BLOB:
            // This will natively throw an exception, but make sure the
            // original value is cleared in case an exception is thrown
            // so we don't AV destructing this object
            ZeroMemory( &m_value.Blob, sizeof( m_value.Blob ) );
            m_value.Blob = BlobCopy(&Src.m_value.Blob);
            break;

        case VT_CLSID:
            m_value.pClsId = new CLSID(*Src.m_value.pClsId);

            // Check for a failed allocation
            if ( NULL == m_value.pClsId )
            {
                throw CX_MemoryException();
            }

            break;

        case VT_DISPATCH:
            m_value.pDisp = Src.m_value.pDisp;
            if(m_value.pDisp) m_value.pDisp->AddRef();
            break;

        case VT_UNKNOWN:
            m_value.pUnk = Src.m_value.pUnk;
            if(m_value.pUnk) m_value.pUnk->AddRef();
            break;

        // CVarVector
        // ==========

        case VT_EX_CVARVECTOR:
            m_value.pVarVector = new CVarVector(*Src.m_value.pVarVector);

            // Check for a failed allocation
            if ( NULL == m_value.pVarVector )
            {
                throw CX_MemoryException();
            }

            break;

        // All remaining simple types. 
        // ===========================
        default:        
            m_value = Src.m_value;
    }

    return *this;
}

//***************************************************************************
//
//  CVar::operator ==
//
//  Equality test operator.
//
//***************************************************************************

int CVar::operator ==(CVar &Src)
{
    return CompareTo(Src, TRUE);
}

BOOL CVar::CompareTo(CVar& Src, BOOL bIgnoreCase)
{
    // If types are not the same, forget the test.
    // ===========================================

    if (m_vt != Src.m_vt)
        return 0;

    // If here, the types are the same, so test
    // the fields.
    // ========================================

    switch (m_vt) {
        case VT_LPSTR:
            if(bIgnoreCase)
            {
                if (_stricmp(m_value.pStr, Src.m_value.pStr) == 0)
                    return 1;
            }
            else
            {
                if (strcmp(m_value.pStr, Src.m_value.pStr) == 0)
                    return 1;
            }

            break;

        case VT_LPWSTR:
        case VT_BSTR:
            if(bIgnoreCase)
            {
                if (wbem_wcsicmp(m_value.pWStr, Src.m_value.pWStr) == 0)
                    return 1;
            }
            else
            {
                if (wcscmp( m_value.pWStr, Src.m_value.pWStr) == 0)
                    return 1;
            }
            break;

        case VT_BLOB:
            if (BlobLength(&m_value.Blob) != BlobLength(&Src.m_value.Blob))
                return 0;
            if (memcmp(BlobDataPtr(&m_value.Blob), BlobDataPtr(&Src.m_value.Blob),
                BlobLength(&m_value.Blob)) == 0)
                return 1;                            
            break;

        case VT_CLSID:
            if (memcmp(m_value.pClsId, Src.m_value.pClsId, sizeof(CLSID)) == 0)
                return 1;
            break;
    
        // CVarVector
        // ==========

        case VT_EX_CVARVECTOR:
            if (m_value.pVarVector == Src.m_value.pVarVector)
                return 1;
            if (m_value.pVarVector == 0 || Src.m_value.pVarVector == 0)
                return 0;
            return *m_value.pVarVector == *Src.m_value.pVarVector;

        // All remaining simple types. 
        // ===========================

        case VT_I1: 
            return m_value.cVal == Src.m_value.cVal;
        case VT_UI1:
            return m_value.bVal == Src.m_value.bVal;
        case VT_I2:
            return m_value.iVal == Src.m_value.iVal;
        case VT_UI2:
            return m_value.wVal == Src.m_value.wVal;
        case VT_I4:
            return m_value.lVal == Src.m_value.lVal;
        case VT_UI4:
            return m_value.dwVal == Src.m_value.dwVal;
        case VT_BOOL:
            return m_value.boolVal == Src.m_value.boolVal;
        case VT_R8:
            return m_value.dblVal == Src.m_value.dblVal;
        case VT_R4:
            return m_value.fltVal == Src.m_value.fltVal;
        case VT_DISPATCH:
            // Note: no proper comparison of embedded objects.
            return m_value.pDisp == Src.m_value.pDisp;
        case VT_UNKNOWN:
            // Note: no proper comparison of embedded objects.
            return m_value.pUnk == Src.m_value.pUnk;
        case VT_FILETIME:
            if (memcmp(&m_value.Time, &Src.m_value.Time, sizeof(FILETIME)) == 0)
                return 1;
        case VT_NULL:
            return 1;
    }

    return 0;    
}


//***************************************************************************
//
//  CVar::Empty
//
//  Clears the CVar to 'empty', deallocates any objects based on pointers, 
//  unless bCanDelete is set to FALSE, indicating that the stored pointer
//  is owned by somebody else.
//
//***************************************************************************

void CVar::Empty()
{
    if(m_bCanDelete)
    {
        // Only pointer types require a deallocation phase.
        // =================================================

        switch (m_vt) {
            case VT_LPSTR:       delete m_value.pStr; break;
            case VT_LPWSTR:      delete m_value.pWStr; break;
            case VT_BSTR:        delete m_value.Str; break;
            case VT_BLOB:        BlobClear(&m_value.Blob); break;
            case VT_CLSID:       delete m_value.pClsId; break;
            case VT_EX_CVARVECTOR: delete m_value.pVarVector; break;
            case VT_DISPATCH:    if(m_value.pDisp) m_value.pDisp->Release(); break;
            case VT_UNKNOWN:    if(m_value.pUnk) m_value.pUnk->Release(); break;
        }
    }

    memset(&m_value, 0, sizeof(METAVALUE)); 
    m_vt = VT_EMPTY;
    m_nStatus = no_error;
    m_bCanDelete = TRUE;
}

//***************************************************************************
//
//  CVar::IsDataNull
//
//  Determines if this CVar contains a NULL pointer.
//
//***************************************************************************
BOOL CVar::IsDataNull()
{
    if(m_vt == VT_LPWSTR && m_value.pWStr == NULL)
        return TRUE;
    if(m_vt == VT_LPSTR && m_value.pStr == NULL)
        return TRUE;
    if(m_vt == VT_BSTR && m_value.Str == NULL)
        return TRUE;
    if(m_vt == VT_DISPATCH && m_value.pDisp == NULL)
        return TRUE;
    if(m_vt == VT_UNKNOWN && m_value.pUnk == NULL)
        return TRUE;

    return FALSE;
}
//***************************************************************************
//
//  CVar::SetRaw
//
//  Creates a CVar from raw data. Sets the type and copies the right
//  number of bytes from the source to METAVALUE.
//
//***************************************************************************

void CVar::SetRaw(int vt, void* pvData, int nDataLen)
{
    m_vt = vt;
    memcpy(&m_value, pvData, nDataLen);
    m_nStatus = no_error;
    m_bCanDelete = TRUE;
}

//***************************************************************************
//
//  CVar::SetSafeArray
//
//  PARAMETERS:
//  nType  
//      This is the VT_ type indicator of the SAFEARRAY.    
//  pArray 
//      This is the pointer to the SAFEARRAY which will be used as
//      a source.  The SAFEARRAY is not acquired; it is copied.
//
//***************************************************************************

void CVar::SetSafeArray(int nType, SAFEARRAY *pArray)
{
    CVarVector *pVec = NULL;
    m_nStatus = no_error;

    try
    {
        pVec = new CVarVector(nType, pArray);

        // Check for a failed allocation
        if ( NULL == pVec )
        {
            throw CX_MemoryException();
        }

        SetVarVector(pVec, TRUE);
    }
    catch (CX_MemoryException)
    {
        // SetVarVector can throw an exception
        // m_value aquires the pVec pointer, so auto delete will not work

        if (NULL != pVec)
        {
            delete pVec;
            pVec = NULL;
        }

        throw;
    }
}


//***************************************************************************
//
//  CVar::GetNewSafeArray
//
//  RETURN VALUE:
//  A pointer to newly allocated SAFEARRAY which must be released by
//  SafeArrayDestroy.
//
//***************************************************************************

SAFEARRAY *CVar::GetNewSafeArray()
{
    CVarVector *p = (CVarVector *) GetVarVector();
    return p->GetNewSafeArray();
}


//***************************************************************************
//
//  CVar::SetValue
//  
//  Sets the value based on an incoming VARIANT.  A VARIANT containing
//  a SAFEARRAY is supported as long as it is not an array of VARIANTs.
//  Some of the other VARIANT types, such as IUnknown, Currency, etc.,
//  are not supported.  The complete list is:
//      VT_UI1, VT_I2, VT_I4, VT_BSTR, VT_BOOL
//      VT_R4, VT_R8, or SAFEARRAY of any of these.
//
//  PARAMETERS:
//  pSrc 
//      A pointer to the source VARIANT.  This is treated as read-only.
//
//  RETURN VALUES:
//  no_error
//      Returned on succcess.
//  unsupported
//      Returned if the VARIANT contains unsupported types.
//
//***************************************************************************

int CVar::SetVariant(VARIANT *pSrc, BOOL fOptimize /*=FALSE*/)
{
    if(pSrc == NULL)
    {
        SetAsNull();
        return no_error;
    }

    // If a SAFEARRAY, check it.
    // =========================

    if (pSrc->vt & VT_ARRAY) 
    {
        CVarVector *pVec = NULL;

        try
        {
            int nType = pSrc->vt & 0xFF;    // Find the type of the array

            // BEGIN MODIFIED by a-levn

            // First, check if the incoming SAFEARRAY is NULL
            // ==============================================

            SAFEARRAY *pSafeArr;
    /*
            if(pSrc->parray == NULL)
            {
                pSafeArr = NULL;
            }
            else
            {
                // Make a copy of the SAFEARRAY using CSafeArray which will NOT 
                // autodestruct
                // ============================================================

                CSafeArray array(pSrc->parray, nType, CSafeArray::no_delete, 0);
                pSafeArr = array.GetArray();
            }

    */
            pSafeArr = pSrc->parray;

			pVec = new CVarVector( nType, pSafeArr, fOptimize );

			// Check for an allocation failure.
			if ( NULL == pVec )
			{
				throw CX_MemoryException();
			}

			// END MODIFIED

			if (pVec->Status() != no_error) 
			{

				// If here, the SAFEARRAY was not compatible.
				// ==========================================

				delete pVec;
				pVec = NULL;
				m_nStatus = unsupported;
				m_vt = VT_EMPTY;
				return unsupported;
			}

			SetVarVector(pVec, TRUE);
			return no_error;
        }
        catch(CX_MemoryException)
        {
            // new and SetVarVector can throw exceptions
            // m_value aquires the pVec pointer, so an auto delete will not work

            if (NULL != pVec)
            {
                delete pVec;
                pVec = NULL;
            }

            throw;
        }
    }

    // Simple copies.
    // ==============

    switch (pSrc->vt) {
        case VT_NULL:
            SetAsNull();
            return no_error;

        case VT_UI1:
            SetByte(pSrc->bVal);
            return no_error;

        case VT_I2:
            SetShort(pSrc->iVal);
            return no_error;
        
        case VT_I4:
            SetLong(pSrc->lVal);
            return no_error;

        case VT_R4:
            SetFloat(pSrc->fltVal);
            return no_error;

        case VT_R8:        
            SetDouble(pSrc->dblVal);
            return no_error;

        case VT_BSTR:
            SetBSTR(pSrc->bstrVal);
            return no_error;

        case VT_BOOL:
            SetBool(pSrc->boolVal);
            return no_error;

        case VT_DISPATCH:
            SetDispatch(V_DISPATCH(pSrc));
            return no_error;

        case VT_UNKNOWN:
            SetUnknown(V_UNKNOWN(pSrc));
            return no_error;
    }

    m_nStatus = unsupported;
    return unsupported;
}

//***************************************************************************
//
//  CVar::GetNewVariant
//  
//  RETURN VALUE:
//  A pointer to a new VARIANT which contains the value of object.
//  If the original value was a SAFEARRAY, then the VARIANT will contain
//  the embedded SAFEARRAY.
//      
//***************************************************************************

void CVar::FillVariant(VARIANT* pNew, BOOL fOptimized/* = FALSE*/)
{
    switch (m_vt) {
        case VT_NULL:
            V_VT(pNew) = VT_NULL;
            break;

        case VT_BOOL:
            V_VT(pNew) = VT_BOOL;
            V_BOOL(pNew) = (m_value.boolVal ? VARIANT_TRUE : VARIANT_FALSE);
            break;
            
        case VT_BSTR:

            // Set type afterwards here so if the SysAlloc throws an exception, the
            // type will not have been reset to a VT_BSTR which could cause a subtle
            // memory corruption (or worse) if VariantClear is called - SJS

            V_BSTR(pNew) = COleAuto::_SysAllocString(m_value.Str);
            V_VT(pNew) = VT_BSTR;
            break;

        case VT_DISPATCH:
            V_VT(pNew) = VT_DISPATCH;
            V_DISPATCH(pNew) = m_value.pDisp;
            if(m_value.pDisp) m_value.pDisp->AddRef();
            break;

        case VT_UNKNOWN:
            V_VT(pNew) = VT_UNKNOWN;
            V_UNKNOWN(pNew) = m_value.pUnk;
            if(m_value.pUnk) m_value.pUnk->AddRef();
            break;

        case VT_UI1:
            V_VT(pNew) = VT_UI1;
            V_UI1(pNew) = m_value.bVal;
            break;

        case VT_I4:
            V_VT(pNew) = VT_I4;
            V_I4(pNew) = m_value.lVal;
            break;

        case VT_I2:
            V_VT(pNew) = VT_I2;
            V_I2(pNew) = m_value.iVal;
            break;

        case VT_R4:
            V_VT(pNew) = VT_R4;
            V_R4(pNew) = m_value.fltVal;
            break;

        case VT_R8:        
            V_VT(pNew) = VT_R8;
            V_R8(pNew) = m_value.dblVal;
            break;

        // An embedded CVarVector which must be converted
        // to a SAFEARRAY.
        // ==============================================

        case VT_EX_CVARVECTOR:
            {
                // Set type afterwards here so if GetNewSafeArray throws an exception, the
                // type will not have been reset to an Array which could cause a subtle
                // memory corruption (or worse) if VariantClear is called - SJS

				if ( fOptimized && m_value.pVarVector->IsOptimized() )
				{
					// This will get the actual SAFEARRAY pointer without
					// copying what's underneath.  Underlying code should
					// not clear the array, since it is being acquired
					V_ARRAY(pNew) = m_value.pVarVector->GetSafeArray( TRUE );
					V_VT(pNew) = m_value.pVarVector->GetType() | VT_ARRAY;
				}
				else
				{
					V_ARRAY(pNew) = m_value.pVarVector->GetNewSafeArray();
					V_VT(pNew) = m_value.pVarVector->GetType() | VT_ARRAY;
				}
            }
            break;

        default:
            COleAuto::_VariantClear(pNew);        
    }
}

VARIANT *CVar::GetNewVariant()
{
    VARIANT *pNew = new VARIANT;

    // Check for an allocation failure.
    if ( NULL == pNew )
    {
        throw CX_MemoryException();
    }

    COleAuto::_VariantInit(pNew);
    
    FillVariant(pNew);       
    return pNew;    
}
    
//***************************************************************************
//
//***************************************************************************

int CVar::DumpText(FILE *fStream)
{
    return unsupported;
}

//***************************************************************************
//
//  CVar::SetLPWSTR
//
//  Sets the value of the CVar to the indicated LPWSTR.
//
//  PARAMETERS:
//  pStr
//      A pointer to the source string.
//  bAcquire
//      If TRUE, then the ownership of pStr is trasferred and becomes
//      the internal pointer to the string. If FALSE, then the string
//      is copied.
//      
//***************************************************************************

BOOL CVar::SetLPWSTR(LPWSTR pStr, BOOL bAcquire)
{
    m_vt = VT_LPWSTR;
    if (bAcquire)
    {
        m_value.pWStr = pStr;
        return TRUE;
    }
    else            
    {
        // Check for an allocation failure
        if ( NULL != pStr )
        {
            m_value.pWStr = new wchar_t[wcslen(pStr) + 1];

            if ( NULL == m_value.pWStr )
            {
                throw CX_MemoryException();
            }
            wcscpy( m_value.pWStr, pStr );
        }
        else
        {
            m_value.pWStr = NULL;
        }

        return TRUE;
    }
}

//***************************************************************************
//
//  CVar::SetLPSTR
//
//  Sets the value of the CVar to the indicated LPSTR.
//
//  PARAMETERS:
//  pStr
//      A pointer to the source string.
//  bAcquire
//      If TRUE, then the ownership of pStr is trasferred and becomes
//      the internal pointer to the string. If FALSE, then the string
//      is copied (it must have been allocated with operator new).
//    
//***************************************************************************
    
BOOL CVar::SetLPSTR(LPSTR pStr, BOOL bAcquire)
{
    m_vt = VT_LPSTR;
    if (bAcquire)
    {
        m_value.pStr = pStr;
        return TRUE;
    }
    else        
    {
        if ( NULL != pStr)
        {
            m_value.pStr = new char[strlen(pStr) + 1];

            // On failure, throw an exception
            if ( NULL == m_value.pStr )
            {
                throw CX_MemoryException();
            }

            strcpy( m_value.pStr, pStr );
        }
        else
        {
            m_value.pStr = NULL;
        }
        
        return TRUE;

    }
}

//***************************************************************************
//
//  CVar::SetBSTR
//
//  Sets the value of the CVar to the indicated BSTR.
//
//  NOTE: This BSTR value is actually stored as an LPWSTR to avoid 
//  apartment-threading restrictions on real BSTR objects allocated 
//  with COleAuto::_SysAllocString.
//
//  PARAMETERS:
//  str
//      A pointer to the string, which is copied into an internal LPWSTR.
//  bAcquire
//      If FALSE, then the BSTR is treated as read-only and copied.
//      If TRUE, then this function becomes owner of the BSTR and
//      frees it after the copy is made.
//
//***************************************************************************

BOOL CVar::SetBSTR(BSTR str, BOOL bAcquire)
{
    m_vt = VT_BSTR;

    if (str == 0) {
        m_value.pWStr = 0;
        return TRUE;
    }
        
    // Check for an allocation failure
    if ( NULL != str )
    {
        m_value.pWStr = new wchar_t[wcslen(str) + 1];

        // If allocation fails, throw an exception
        if ( NULL == m_value.pWStr )
        {
            throw CX_MemoryException();
        }
        wcscpy( m_value.pWStr, str );
    }
    else
    {
        m_value.pWStr = NULL;
    }


    // Check that this succeeded before we free
    // the string passed into us
    if ( NULL != m_value.pWStr )
    {
        if (bAcquire)
            COleAuto::_SysFreeString(str);
    }

    // return whether or not we obtained a value
    return ( NULL != m_value.pWStr );
}

//***************************************************************************
//
//  CVar::GetBSTR
//
//  Returns the BSTR value of the current object.  
//
//  RETURN VALUE:
//  A newly allocated BSTR which must be freed with COleAuto::_SysFreeString().
//
//***************************************************************************

BSTR CVar::GetBSTR()
{
    if (m_vt != VT_BSTR)
        return NULL;
    return COleAuto::_SysAllocString(m_value.pWStr);
}
    
void CVar::SetDispatch(IDispatch* pDisp) 
{
    m_vt = VT_DISPATCH; 
    m_value.pDisp = pDisp; 

    if(pDisp) 
    {
        pDisp->AddRef();
    }
}

void CVar::SetUnknown(IUnknown* pUnk) 
{
    m_vt = VT_UNKNOWN; 
    m_value.pUnk = pUnk; 

    if(pUnk) 
    {
        pUnk->AddRef();
    }
}

//***************************************************************************
//
//  CVar::SetBlob
//
//  Sets the object to the value of the BLOB object.
//
//  PARAMETERS:
//  pBlob
//      A pointer to a valid VT_BLOB object.
//  bAcquire
//      If TRUE, then the pointer to the data will be acquired. It must
//      have been allocated with operator new in the current process, 
//      since operator delete will be used to free it.
//      
//***************************************************************************
    
void CVar::SetBlob(BLOB *pBlob, BOOL bAcquire)
{
    m_vt = VT_BLOB;
    if (pBlob == 0) 
        BlobClear(&m_value.Blob);
    else if (!bAcquire)
        m_value.Blob = BlobCopy(pBlob);        
    else
        m_value.Blob = *pBlob;        
}

//***************************************************************************
//
//  CVar::SetClsId
//
//  Sets the value of the object to a CLSID.
//  
//  PARAMETERS:
//  pClsId
//      Points the source CLSID.
//  bAcquire
//      If TRUE, the ownership of the pointer is transferred to the
//      object.  The CLSID must have been allocated with operator new.
//      If FALSE, the caller retains ownership and a copy is made.
//
//***************************************************************************
        
void CVar::SetClsId(CLSID *pClsId, BOOL bAcquire)
{
    m_vt = VT_CLSID;
    if (pClsId == 0)
        m_value.pClsId = 0;
    else
    {
        m_value.pClsId = new CLSID(*pClsId);

        // Check for an allocation failure.
        if ( NULL == m_value.pClsId )
        {
            throw CX_MemoryException();
        }

    }
}

//***************************************************************************
//
//  CVar::SetVarVector
//
//  Sets the value of the object to the specified CVarVector.  This
//  allows the CVar to contain a complete array.
//  
//  PARAMETERS:
//  pVec
//      A pointer to the CVarVector object which is the source.
//  bAcquire
//      If TRUE, then ownership of the CVarVector is transferred to
//      the object.  If FALSE, a new copy of the CVarVector is made and
//      the caller retains ownership.
//
//***************************************************************************
    
void CVar::SetVarVector(CVarVector *pVec, BOOL bAcquire)
{
    m_vt = VT_EX_CVARVECTOR;

    if (bAcquire) {
        // If here, we acquire the caller's pointer.
        // =========================================
        m_value.pVarVector = pVec;
        return;
    }

    // If here, make a copy.
    // =====================

    m_value.pVarVector = new CVarVector(*pVec);

    // Check for an allocation failure.
    if ( NULL == m_value.pVarVector )
    {
        throw CX_MemoryException();
    }


}

int CVar::GetOleType() 
{ 
    if(m_vt == VT_EX_CVARVECTOR)
    {
        if(m_value.pVarVector == NULL) return VT_ARRAY;
        else return VT_ARRAY | m_value.pVarVector->GetType();
    }
    else
    {
        return m_vt;
    }
}        


//***************************************************************************
//
//  CVar::GetText
//
//  Produces textual representation of the Var's type and data
//
//  PARAMETERS:
//  long lFlags      reseved, must be 0
//  long lType       CIM_TYPE
//  LPCWSTR szFormat optional formatting string
//  
//
//***************************************************************************

BSTR CVar::GetText(long lFlags, long lType, LPCWSTR szFormat)
{
    if(m_vt == VT_EX_CVARVECTOR)
    {
        // When we get the text for the array, make sure the CIM_FLAG_ARRAY is masked out
        BSTR strTemp = GetVarVector()->GetText(lFlags, lType & ~CIM_FLAG_ARRAY);
        CSysFreeMe auto1(strTemp);

        WCHAR* wszValue = new WCHAR[COleAuto::_SysStringLen(strTemp) + 3];

        // Check for allocation failures
        if ( NULL == wszValue )
        {
            throw CX_MemoryException();
        }

        CVectorDeleteMe<WCHAR> auto2(wszValue);

        wcscpy(wszValue, L"{");
        wcscat(wszValue, strTemp);
        wcscat(wszValue, L"}");

        BSTR strRet = COleAuto::_SysAllocString(wszValue);

        return strRet;
    }

    WCHAR* wszValue = new WCHAR[100];

    // Check for allocation failures
    if ( NULL == wszValue )
    {
        throw CX_MemoryException();
    }


    WCHAR* pwc;
    int i;

    if(m_vt == VT_NULL)
    {
        delete [] wszValue;
        return NULL;
    }

    if(lType == 0)
        lType = m_vt;

    try
    {
        switch(lType)
        {
        case CIM_SINT8:
            swprintf(wszValue, szFormat ? szFormat : L"%d", (long)(signed char)GetByte());
            break;

        case CIM_UINT8:
            swprintf(wszValue, szFormat ? szFormat : L"%d", GetByte());
            break;

        case CIM_SINT16:
            swprintf(wszValue, szFormat ? szFormat : L"%d", (long)GetShort());
            break;

        case CIM_UINT16:
            swprintf(wszValue, szFormat ? szFormat : L"%d", (long)(USHORT)GetShort());
            break;

        case CIM_SINT32:
            swprintf(wszValue, szFormat ? szFormat : L"%d", GetLong());
            break;

        case CIM_UINT32:
            swprintf(wszValue, szFormat ? szFormat : L"%lu", (ULONG)GetLong());
            break;

        case CIM_BOOLEAN:
            swprintf(wszValue, L"%s", (GetBool()?L"TRUE":L"FALSE"));
            break;

        case CIM_REAL32:
            {
                // Since the decimal point can be localized, and MOF text should
                // always be english, we will return values localized to 0x409,

                CVar    var( GetFloat() );

                // If this fails, we can't guarantee a good value,
                // so throw an exception.

                if ( !var.ChangeTypeToEx( VT_BSTR ) )
                {
                    throw CX_Exception();
                }

                wcscpy( wszValue, var.GetLPWSTR() );
            }
            break;

        case CIM_REAL64:
            {
                // Since the decimal point can be localized, and MOF text should
                // always be english, we will return values localized to 0x409,

                CVar    var( GetDouble() );

                // If this fails, we can't guarantee a good value,
                // so throw an exception.

                if ( !var.ChangeTypeToEx( VT_BSTR ) )
                {
                    throw CX_Exception();
                }

                wcscpy( wszValue, var.GetLPWSTR() );
            }
            break;

        case CIM_CHAR16:
            if(GetShort() == 0)
                wcscpy(wszValue, L"0x0");
            else
                swprintf(wszValue, L"'\\x%X'", (WCHAR)GetShort());
            break;

        case CIM_OBJECT:
            swprintf(wszValue, L"\"not supported\"");
            break;

        case CIM_REFERENCE:
        case CIM_DATETIME:
        case CIM_STRING:
        case CIM_SINT64:
        case CIM_UINT64:
        {
            // Escape all the quotes
            // =====================

            int nStrLen = wcslen(GetLPWSTR());
            delete [] wszValue;
            wszValue = NULL;

            wszValue = new WCHAR[nStrLen*2+10];

            // Check for allocation failures
            if ( NULL == wszValue )
            {
                throw CX_MemoryException();
            }

            wszValue[0] = L'"';
            pwc = wszValue+1;
            for(i = 0; i < (int)nStrLen; i++)
            {    
                WCHAR wch = GetLPWSTR()[i];
                if(wch == L'\n')
                {
                    *(pwc++) = L'\\';
                    *(pwc++) = L'n';
                }
                else if(wch == L'\t')
                {
                    *(pwc++) = L'\\';
                    *(pwc++) = L't';
                }
                else if(wch == L'"' || wch == L'\\')
                {
                    *(pwc++) = L'\\';
                    *(pwc++) = wch;
                }
                else
                {
                    *(pwc++) = wch;
                }
            }
            *(pwc++) = L'"';
            *pwc = 0;
        }
            break;
        default:
            swprintf(wszValue, L"\"not supported\"");
            break;
        }
        
        BSTR strRes = COleAuto::_SysAllocString(wszValue);

        // Still need to clean up this value
        delete [] wszValue;

        return strRes;
    }
    catch (...)
    {
        // Cleanup always if this has a value
        if ( NULL != wszValue )
        {
            delete [] wszValue;
        }

        // Rethrow the exception
        throw;
    }

}


BSTR CVar::TypeToText(int nType)
{
    const WCHAR* pwcType;

    switch(nType)
    {
    case VT_I1:
        pwcType = L"sint8";
        break;

    case VT_UI1:
        pwcType = L"uint8";
        break;

    case VT_I2:
        pwcType = L"sint16";
        break;

    case VT_UI2:
        pwcType = L"uint16";
        break;

    case VT_I4:
        pwcType = L"sint32";
        break;

    case VT_UI4:
        pwcType = L"uint32";
        break;

    case VT_I8:
        pwcType = L"sint64";
        break;

    case VT_UI8:
        pwcType = L"uint64";
        break;

    case VT_BOOL:
        pwcType = L"boolean";
        break;

    case VT_R4:
        pwcType = L"real32";
        break;

    case VT_R8:
        pwcType = L"real64";
        break;    

    case VT_BSTR:
        pwcType = L"string";
        break;

    case VT_DISPATCH:
        pwcType = L"object";
        break;

    case VT_UNKNOWN:
        pwcType = L"object";
        break;

    default:
        return NULL;
    }

    return COleAuto::_SysAllocString(pwcType);
}

BSTR CVar::GetTypeText() 
{
	if ( m_vt == VT_EX_CVARVECTOR )
	{
        return TypeToText(GetVarVector()->GetType());
	}
	else
	{
        return TypeToText(m_vt);
	}
}

BOOL CVar::ChangeTypeTo(VARTYPE vtNew)
{
    // TBD: there are more efficient ways!
    // ===================================

    // Create a VARIANT
    // ================

    VARIANT v;
    CClearMe auto1(&v);

    COleAuto::_VariantInit(&v);
    FillVariant(&v);

    // Coerce it
    // =========

    HRESULT hres = COleAuto::_WbemVariantChangeType(&v, &v, vtNew);
    if(FAILED(hres))
        return FALSE;

    // Load it back in
    // ===============

    Empty();
    SetVariant(&v, TRUE);

	// If this is an array, we will now be sitting on an optimized array
	// meaning that we will have acquired the actual safe array - so we should
	// make sure that the CVarVector cleans up the array when it is no longer
	// necessary.  We will  clear out the variant so it doesn't get deleted
	// when VariantClear is called.

	if ( m_vt == VT_EX_CVARVECTOR )
	{
		m_value.pVarVector->SetRawArrayBinding( CSafeArray::auto_delete );
		ZeroMemory( &v, sizeof(v) );
	}

    return TRUE;
}

// Performs localized changes (defaults to 0x409 for this)
BOOL CVar::ChangeTypeToEx(VARTYPE vtNew, LCID lcid /*=0x409*/)
{
    // TBD: there are more efficient ways!
    // ===================================

    // Create a VARIANT
    // ================

    VARIANT v;
    CClearMe auto1(&v);

    COleAuto::_VariantInit(&v);
    FillVariant(&v);

    // Coerce it
    // =========

    try
    {
        HRESULT hres = COleAuto::_VariantChangeTypeEx(&v, &v, lcid, 0L, vtNew);
        if(FAILED(hres))
            return FALSE;
    }
    catch(...)
    {
        return FALSE;
    }

    // Load it back in
    // ===============

    Empty();
    SetVariant(&v, TRUE);

	// If this is an array, we will now be sitting on an optimized array
	// meaning that we will have acquired the actual safe array - so we should
	// make sure that the CVarVector cleans up the array when it is no longer
	// necessary.  We will  clear out the variant so it doesn't get deleted
	// when VariantClear is called.

	if ( m_vt == VT_EX_CVARVECTOR )
	{
		m_value.pVarVector->SetRawArrayBinding( CSafeArray::auto_delete );
		ZeroMemory( &v, sizeof(v) );
	}

    return TRUE;
}

BOOL CVar::ToSingleChar()
{
    // Defer to CVarVector for arrays
    // ==============================

    if(m_vt == VT_EX_CVARVECTOR)
    {
        return GetVarVector()->ToSingleChar();
    }

    // Anything that's not a string follows normal OLE rules
    // =====================================================

    if(m_vt != VT_BSTR)
    {
        return ChangeTypeTo(VT_I2);
    }
    
    // It's a string. Make sure the length is 1
    // ========================================

    LPCWSTR wsz = GetLPWSTR();
    if(wcslen(wsz) != 1)
        return FALSE;

    // Take the first character
    // ========================
    
    WCHAR wc = wsz[0];
    Empty();

    SetShort(wc);
    return TRUE;
}

BOOL CVar::ToUI4()
{
    // Defer to CVarVector for arrays
    // ==============================

    if(m_vt == VT_EX_CVARVECTOR)
    {
        return GetVarVector()->ToUI4();
    }

    // Create a VARIANT
    // ================

    VARIANT v;
    CClearMe auto1(&v);

    COleAuto::_VariantInit(&v);
    FillVariant(&v);

    // Coerce it
    // =========

    HRESULT hres = COleAuto::_WbemVariantChangeType(&v, &v, VT_UI4);
    if(FAILED(hres))
        return FALSE;

    // Load it back in
    // ===============

    Empty();

    // Here we cheat and reset to VT_I4 so we can natively reset
    V_VT(&v) = VT_I4;
    SetVariant(&v);
    return TRUE;
}

//***************************************************************************
//
//  CVarVector::CVarVector
//
//  Default constructor.  The caller should not attempt to add any
//  elements when the internal type is VT_EMPTY.  Objects constructed
//  with this constructor should only be used as l-values in an 
//  assignment of CVarVector objects.
//
//***************************************************************************

CVarVector::CVarVector()
:	m_pSafeArray( NULL ),
	m_pRawData( NULL )
{
    m_Array.Empty();
    m_nType = VT_EMPTY;
    m_nStatus = no_error;
}

//***************************************************************************
//
//  CVarVector::CVarVector
//
//  This is the standard constructor.
//
//  PARAMETERS:
//  nVarType
//      An OLE VT_ type indicator.  Heterogeneous arrays are possible
//      if the type VT_EX_CVAR is used.  Embedded CVarVectors can
//      occur, since a CVar can in turn hold a CVarVector.
//  
//  nInitSize
//      The starting size of the internal CFlexArray. See FLEXARRY.CPP.
//  nGrowBy
//      The "grow by" factor of the internal CFlexArray. See FLEXARRAY.CPP.
//          
//***************************************************************************

CVarVector::CVarVector(
    int nVarType, 
    int nInitSize, 
    int nGrowBy
    ) :
    m_Array(nInitSize, nGrowBy),
	m_pSafeArray( NULL ),
	m_pRawData( NULL )

{
    m_nType = nVarType;
    m_nStatus = no_error;
}

//***************************************************************************
//
//  CVarVector::CVarVector
//
//  Alternate constructor to build a new CVarVector based on a 
//  SAFEARRAY object.  The only supported types for the SAFEARRAY
//  are VT_BSTR, VT_UI1, VT_I2, VT_I4, VT_R4, and VT_R8.
//
//  PARAMETERS:
//  nVarType
//      The VT_ type indicator of the incoming SAFEARRAY.
//  pSrc
//      A pointer to a SAFEARRAY, which is treated as read-only.
//
//  NOTES:
//  This will set the internal m_nStatus variable to <unsupported> if
//  an unsupported VT_ type is in the SAFEARRAY.  The caller can immediately
//  call CVarVector::Status() after construction to see if the operation
//  was successful.
//
//***************************************************************************

CVarVector::CVarVector(int nVarType, SAFEARRAY *pSrc, BOOL fOptimized /*= FALSE*/)
:	m_pSafeArray( NULL ),
	m_pRawData( NULL )
{
    SAFEARRAY* pNew = NULL;

    try
    {
        m_nType = nVarType;

		// If not a valid vector type, this is unsupported
		if ( !IsValidVectorArray( nVarType, pSrc ) )
		{
			m_nStatus = unsupported;
			return;
		}

        if(pSrc == NULL)
        {
            // NULL safearray --- empty
            // ========================

            m_nStatus = no_error;
            return;
        }

        // Bind to the incoming SAFEARRAY, but don't delete it during destruct.
        // ====================================================================
    
        if(COleAuto::_SafeArrayGetDim(pSrc) != 1)
        {
            m_nStatus = unsupported;
            return;
        }

        long lLBound, lUBound;
        COleAuto::_SafeArrayGetLBound(pSrc, 1, &lLBound);
        COleAuto::_SafeArrayGetUBound(pSrc, 1, &lUBound);

        if(lLBound != 0)
        {
            // Non-0-based safearray --- since CSafeArray doesn't support that, and
            // we can't change pSrc, create a copy
            // ====================================================================
    
            if(FAILED(COleAuto::_SafeArrayCopy(pSrc, &pNew)))
            {
                m_nStatus = failed;
                return;
            }
        
            SAFEARRAYBOUND sfb;
            sfb.cElements = (lUBound - lLBound) + 1;
            sfb.lLbound = 0;
            COleAuto::_SafeArrayRedim(pNew, &sfb);
        }
        else
        {
            pNew = pSrc;
        }
        
		if ( fOptimized )
		{
			// If we rebased the array, then we need to clean it up on delete, otherwise,
			// we don't
			if ( pNew != pSrc )
			{
				m_pSafeArray = new CSafeArray( pNew, nVarType, CSafeArray::auto_delete | CSafeArray::bind);
			}
			else
			{
				m_pSafeArray = new CSafeArray( pNew, nVarType, CSafeArray::no_delete | CSafeArray::bind);
			}

			if ( NULL == m_pSafeArray )
			{
				throw CX_MemoryException();
			}

			if ( m_pSafeArray->Status() != CSafeArray::no_error )
			{
				delete m_pSafeArray;
				m_pSafeArray = NULL;
				m_nStatus = failed;
			}

	        m_nStatus = no_error;

		}
		else
		{
			CSafeArray sa(pNew, nVarType, CSafeArray::no_delete | CSafeArray::bind);
    
			for (int i = 0; i < sa.Size(); i++) {

				CVar*   pVar = NULL;
        
				switch (m_nType) {
					case VT_BOOL:
						{
							VARIANT_BOOL boolVal = sa.GetBoolAt(i);

							pVar = new CVar(boolVal, VT_BOOL);

							// Check for allocation failure
							if ( NULL == pVar )
							{
								throw CX_MemoryException();
							}

							if ( m_Array.Add( pVar ) != CFlexArray::no_error )
							{
								delete pVar;
								throw CX_MemoryException();
							}

							break;
						}

					case VT_UI1: 
						{
							BYTE b = sa.GetByteAt(i);

							pVar = new CVar(b);

							// Check for allocation failure
							if ( NULL == pVar )
							{
								throw CX_MemoryException();
							}

							if ( m_Array.Add( pVar ) != CFlexArray::no_error )
							{
								delete pVar;
								throw CX_MemoryException();
							}
							break;
						}

					case VT_I2:  
						{
							SHORT s = sa.GetShortAt(i);

							pVar = new CVar(s);

							// Check for allocation failure
							if ( NULL == pVar )
							{
								throw CX_MemoryException();
							}

							if ( m_Array.Add( pVar ) != CFlexArray::no_error )
							{
								delete pVar;
								throw CX_MemoryException();
							}
							break;
						}

					case VT_I4:
						{
							LONG l = sa.GetLongAt(i);

							pVar = new CVar(l);

							// Check for allocation failure
							if ( NULL == pVar )
							{
								throw CX_MemoryException();
							}

							if ( m_Array.Add( pVar ) != CFlexArray::no_error )
							{
								delete pVar;
								throw CX_MemoryException();
							}
							break;
						}

					case VT_R4:
						{
							float f = sa.GetFloatAt(i);

							pVar = new CVar(f);

							// Check for allocation failure
							if ( NULL == pVar )
							{
								throw CX_MemoryException();
							}

							if ( m_Array.Add( pVar ) != CFlexArray::no_error )
							{
								delete pVar;
								throw CX_MemoryException();
							}
							break;
						}

					case VT_R8:
						{
							double d = sa.GetDoubleAt(i);

							pVar = new CVar(d);

							// Check for allocation failure
							if ( NULL == pVar )
							{
								throw CX_MemoryException();
							}

							if ( m_Array.Add( pVar ) != CFlexArray::no_error )
							{
								delete pVar;
								throw CX_MemoryException();
							}
							break;
						}

					case VT_BSTR:
						{
							BSTR bstr = sa.GetBSTRAtThrow(i);
							CSysFreeMe auto1(bstr);

							pVar = new CVar(VT_BSTR, bstr, FALSE);

							// Check for allocation failure
							if ( NULL == pVar )
							{
								throw CX_MemoryException();
							}

							if ( m_Array.Add( pVar ) != CFlexArray::no_error )
							{
								delete pVar;
								throw CX_MemoryException();
							}

							break;
						}
					case VT_DISPATCH:
						{
							IDispatch* pDisp = sa.GetDispatchAt(i);
							CReleaseMe auto2(pDisp);

							pVar = new CVar;

							// Check for allocation failure
							if ( NULL == pVar )
							{
								throw CX_MemoryException();
							}

							pVar->SetDispatch(pDisp);
							if ( m_Array.Add( pVar ) != CFlexArray::no_error )
							{
								delete pVar;
								throw CX_MemoryException();
							}
							break;
						}
					case VT_UNKNOWN:
						{
							IUnknown* pUnk = sa.GetUnknownAt(i);
							CReleaseMe auto3(pUnk);
							pVar = new CVar;

							// Check for allocation failure
							if ( NULL == pVar )
							{
								throw CX_MemoryException();
							}

							pVar->SetUnknown(pUnk);
							if ( m_Array.Add( pVar ) != CFlexArray::no_error )
							{
								delete pVar;
								throw CX_MemoryException();
							}
							break;
						}

					default:
						m_nStatus = unsupported;
						if(pNew != pSrc)
							COleAuto::_SafeArrayDestroy(pNew);
						return;
				}
			}

			if(pNew != pSrc)
				COleAuto::_SafeArrayDestroy(pNew);

	        m_nStatus = no_error;

		}	// Else not bound
    }
    catch (CX_MemoryException)
    {
        // SafeArrayCopy, GetBSTRAtThrow, new can all throw exceptions

        m_nStatus = failed;

        if(pNew != pSrc)
            COleAuto::_SafeArrayDestroy(pNew);

        throw;
    }
}

//***************************************************************************
//
//  CVarVector::GetNewSafeArray
//
//  Allocates a new SAFEARRAY equivalent to the current CVarVector.
//  
//  RETURN VALUE:
//  A new SAFEARRAY pointer which must be deallocated with 
//  SafeArrayDestroy().  Returns NULL on error or unsupported types.
//
//***************************************************************************

SAFEARRAY *CVarVector::GetNewSafeArray()
{
	SAFEARRAY *pRetValue = NULL;

	CSafeArray *pArray = new CSafeArray(m_nType, CSafeArray::no_delete);

	// Check for an allocation failure
	if ( NULL == pArray )
	{
		throw CX_MemoryException();
	}

	CDeleteMe<CSafeArray> auto1(pArray);

	int	nSize = Size();

	for (int i = 0; i < nSize; i++) {
		CVar v;
		
		FillCVarAt( i, v );
		switch (m_nType) {
			case VT_UI1:
				pArray->AddByte(v.GetByte());
				break;

			case VT_I2:
				pArray->AddShort(v.GetShort());
				break;

			case VT_I4:
				pArray->AddLong(v.GetLong());
				break;

			case VT_R4:
				pArray->AddFloat(v.GetFloat());
				break;

			case VT_R8:
				pArray->AddDouble(v.GetDouble());
				break;

			case VT_BOOL:
				pArray->AddBool(v.GetBool());
				break;
            
			case VT_BSTR:
				{
					BSTR s = v.GetBSTR();
					CSysFreeMe auto2(s);
					pArray->AddBSTR(s);
					break;
				}
			case VT_DISPATCH:
				{
					IDispatch* pDisp = v.GetDispatch();
					CReleaseMe auto3(pDisp);
					pArray->AddDispatch(pDisp);
					break;
				}
			case VT_UNKNOWN:
				{
					IUnknown* pUnk = v.GetUnknown();
					CReleaseMe auto4(pUnk);
					pArray->AddUnknown(pUnk);
					break;
				}
			default:
				// For unsupported types, return a NULL.
				// Since we constructed the SAFEARRAY object to
				// not delete the SAFEARRAY and we have encountered
				// a condition where the internal SAFEARRAY of
				// CSafeArray should not be returned, we have
				// to switch our destruct policy.
				// ================================================
				pArray->SetDestructorPolicy(CSafeArray::auto_delete);
				return 0;
		}	// SWITCH

	}// FOR enum elements

	// Final cleanup.  Get the SAFEARRAY pointer, and delete
	// the wrapper.
	// =====================================================

	pArray->Trim();

	pRetValue = pArray->GetArray();

	return pRetValue;

}

//***************************************************************************
//
//  CVarVector::GetSafeArray
//
//  Returns a direct pointer to the underlying SafeArray.  If fAcquire is
//	set, the array is returned, and cleared from underneath
//  
//  RETURN VALUE:
//  A SAFEARRAY pointer which must be deallocated with 
//  SafeArrayDestroy() if fAcquire is set to TRUE
//
//***************************************************************************

SAFEARRAY *CVarVector::GetSafeArray( BOOL fAcquire /* = FALSE */)
{
	SAFEARRAY*	psa = NULL;

	_DBG_ASSERT( NULL != m_pSafeArray );

	if ( NULL != m_pSafeArray )
	{
		if ( fAcquire )
		{
			// Unaccess data if appropriate
			if ( NULL != m_pRawData )
			{
				m_pSafeArray->Unaccess();
				m_pRawData = NULL;
			}

			psa = m_pSafeArray->GetArray();

			// Now clear the array
			m_pSafeArray->SetDestructorPolicy( CSafeArray::no_delete );
			delete m_pSafeArray;
			m_pSafeArray = NULL;

		}
		else
		{
			psa = m_pSafeArray->GetArray();
		}
	}

	return psa;
}

//***************************************************************************
//
//  CVarVector::~CVarVector
//
//  Destructor.
//
//***************************************************************************

CVarVector::~CVarVector()
{
    Empty();
}

//***************************************************************************
//
//  CVarVector::Empty
//
//***************************************************************************

void CVarVector::Empty()
{
	if ( NULL != m_pSafeArray )
	{
		delete m_pSafeArray;
	}

    for (int i = 0; i < m_Array.Size(); i++)  {
        delete (CVar *) m_Array[i];
    }
    m_Array.Empty();
    m_nType = VT_EMPTY;
    m_nStatus = no_error;
	m_pSafeArray = NULL;
	m_pRawData = NULL;
}


//***************************************************************************
//
//  CVarVector::CVarVector
//   
//  Copy constructor.  This is implemented via the assignment operator.
// 
//***************************************************************************

CVarVector::CVarVector(CVarVector &Src)
:	m_pSafeArray( NULL ),
	m_pRawData( NULL )
{
    m_nType = 0;
    m_nStatus = no_error;    
    *this = Src;
}

//***************************************************************************
//
//  CVarVector::operator =
//
//  Assignment operator.
//
//***************************************************************************

CVarVector& CVarVector::operator =(CVarVector &Src)
{
    Empty();

	if ( NULL != Src.m_pSafeArray )
	{
		m_pSafeArray = new CSafeArray( *Src.m_pSafeArray );

		if ( NULL != m_pSafeArray )
		{
			if ( m_pSafeArray->Status() != CSafeArray::no_error )
			{
				delete m_pSafeArray;
				throw CX_MemoryException();
			}
		}
		else
		{
			throw CX_MemoryException();
		}
	}
	else
	{
		for (int i = 0; i < Src.m_Array.Size(); i++) 
		{
			CVar* pVar = new CVar(*(CVar *) Src.m_Array[i]);

			// Check for an allocation failure
			if ( NULL == pVar )
			{
				throw CX_MemoryException();
			}

			if ( m_Array.Add( pVar ) != CFlexArray::no_error )
			{
				delete pVar;
				throw CX_MemoryException();
			}
		}

	}

    m_nStatus = Src.m_nStatus;
    m_nType = Src.m_nType;

    return *this;
}

//***************************************************************************
//
//  CVarVector::operator ==
//
//  Equality test operator.
//
//***************************************************************************

int CVarVector::operator ==(CVarVector &Src)
{
    return CompareTo(Src, TRUE);
}

BOOL CVarVector::CompareTo(CVarVector& Src, BOOL bIgnoreCase)
{
    if (m_nType != Src.m_nType)
        return 0;

	// Need to do things indirectly here, since we are possibly mixing
	// CVarVectors not on SAFEARRAYs and those on SAFEARRAYs
	int Src_Size = Src.Size();
    if ( Size() != Src_Size )
        return 0;

	// Allocate the variants
    for (int i = 0; i < Src_Size; i++) 
	{
		CVar	varThis;
		CVar	varThat;

		FillCVarAt( i, varThis );
		Src.FillCVarAt( i, varThat );

        if ( !varThis.CompareTo( varThat, bIgnoreCase ) )
            return 0;
    }

    return 1;
}

//***************************************************************************
//
//  CVarVector::Add
//
//  Adds a new CVar to the array.  A reference is used so that anonymous
//  objects can be constructed in the Add() call:
//
//      pVec->Add(CVar(33));
//
//  PARAMETERS:
//  Value
//      A reference to a CVar object of the correct type for the array.
//      No type checking is done. 
//
//  RETURN VALUE:
//  no_error
//  failed
//
//***************************************************************************

int CVarVector::Add(CVar &Value)
{

	if ( NULL != m_pSafeArray )
	{
		switch ( Value.GetType() )
		{
			case VT_BOOL:
				// We can store differently from what is expected in Variants, hence we
				// need to make sure to convert
				m_pSafeArray->AddBool( Value.GetBool() ? VARIANT_TRUE : VARIANT_FALSE );
				break;

			case VT_UI1:
				m_pSafeArray->AddByte( Value.GetByte() );
				break;

			case VT_I2:
				m_pSafeArray->AddShort( Value.GetShort() );
				break;

			case VT_I4:
				m_pSafeArray->AddLong( Value.GetLong() );
				break;

			case VT_R4:
				m_pSafeArray->AddFloat( Value.GetFloat() );
				break;

			case VT_R8:
				m_pSafeArray->AddDouble( Value.GetDouble() );
				break;

			case VT_BSTR:
				m_pSafeArray->AddBSTR( Value.GetBSTR() );
				break;

			case VT_UNKNOWN:
				m_pSafeArray->AddUnknown( Value.GetUnknown() );
				break;

			default:
				return failed;
		}

		return no_error;
	}
	else
	{
		CVar *p = new CVar(Value);

		// Check for allocation failures
		if ( NULL == p )
		{
			return failed;
		}

		if (m_Array.Add(p) != CFlexArray::no_error)
		{
			delete p;
			return failed;
		}

		return no_error;
	}
}

//***************************************************************************
//
//  CVarVector::Add
//
//  Adds a new CVar to the array.  This overload simply takes ownership
//  of the incoming pointer and adds it directly.
//
//  PARAMETERS:
//  pAcquiredPtr
//      A pointer to a CVar object which is acquired by the vector.
//
//  RETURN VALUE:
//  no_error
//  failed
//
//***************************************************************************

int CVarVector::Add(CVar *pAcquiredPtr)
{
	// Not a valid operation if we are sitting on a SAFEARRAY
	_DBG_ASSERT( NULL == m_pSafeArray );

	// We don't support this if we are optimized to
	// us a safe array directly
	if ( NULL != m_pSafeArray )
	{
		return failed;
	}

    if (m_Array.Add(pAcquiredPtr) != CFlexArray::no_error)
    {
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CVarVector::RemoveAt
//
//  Removes the array element at the specified index.
//
//  PARAMETERS:
//  nIndex
//      The location at which to remove the element.
//
//  RETURN VALUE:
//  no_error
//      On success.
//  failed
//      On range errors, etc.
//
//***************************************************************************

int CVarVector::RemoveAt(int nIndex)
{
	if ( NULL != m_pSafeArray )
	{
		if ( m_pSafeArray->RemoveAt( nIndex ) != CSafeArray::no_error )
		{
			return failed;
		}

	}
	else
	{
		CVar *p = (CVar *) m_Array[nIndex];
		delete p;
		if (m_Array.RemoveAt(nIndex) != CFlexArray::no_error)
			return failed;
	}

    return no_error;
}

//***************************************************************************
//
//  CVarVector::InsertAt
//
//  Inserts the new element at the specified location.
//  
//  PARAMETERS:
//  nIndex
//      The location at which to add the new element.
//  Value
//      A reference to the new value.
//
//  RETURN VALUE:
//  no_error
//      On success.
//  failed
//      An invalid nIndex value was specified.      
//
//***************************************************************************

int CVarVector::InsertAt(int nIndex, CVar &Value)
{
	// We don't support this if we are optimized to
	// us a safe array directly

	_DBG_ASSERT( NULL == m_pSafeArray );

	if ( NULL != m_pSafeArray )
	{
		return failed;
	}

    CVar *pNew = new CVar(Value);

    // Check for allocation failures
    if ( NULL == pNew )
    {
        return failed;
    }

    if (m_Array.InsertAt(nIndex, pNew) != CFlexArray::no_error)
    {
        delete pNew;
        return failed;
    }
    return no_error;
}


BSTR CVarVector::GetText(long lFlags, long lType/* = 0 */)
{
    // Construct an array of values
    // ============================

    BSTR* aTexts = NULL;
    int i;

    try
    {
        aTexts = new BSTR[Size()];

        // Check for allocation failures
        if ( NULL == aTexts )
        {
            throw CX_MemoryException();
        }

        memset(aTexts, 0, Size() * sizeof(BSTR));

        int nTotal = 0;

        for(i = 0; i < Size(); i++)
        {
			CVar	v;

			FillCVarAt( i, v );
            aTexts[i] = v.GetText(lFlags, lType);
            nTotal += COleAuto::_SysStringLen(aTexts[i]) + 2; // 2: for ", "
        }

        // Allocate a BSTR to contain them all
        // ===================================

        BSTR strRes = COleAuto::_SysAllocStringLen(NULL, nTotal);
        CSysFreeMe auto2(strRes);
        *strRes = 0;

        for(i = 0; i < Size(); i++)
        {
            if(i != 0)
            {
                wcscat(strRes, L", ");
            }

            wcscat(strRes, aTexts[i]);
            COleAuto::_SysFreeString(aTexts[i]);
        }

        delete [] aTexts;
        aTexts = NULL;
        BSTR strPerfectRes = COleAuto::_SysAllocString(strRes);
        return strPerfectRes;
    }
    catch(CX_MemoryException)
    {
        // new, GetText, COleAuto::_SysAllocStringLen and COleAuto::_SysAllocString can all throw exceptions
        if (NULL != aTexts)
        {
            for(int x = 0; x < Size(); x++)
            {
                if (NULL != aTexts[x])
                    COleAuto::_SysFreeString(aTexts[x]);
            }
            delete [] aTexts;
            aTexts = NULL;
        }

        throw;
    }
}

BOOL CVarVector::ToSingleChar()
{
	// Handle this differently if we are sitting directly on a safearray
	if ( NULL != m_pSafeArray )
	{
		int	nSize = Size();

		// One element at a time is converted and copied into the new array
		CSafeArray*	pNewArray = new CSafeArray( VT_I2, CSafeArray::auto_delete, nSize );

		for ( int i = 0; i < nSize; i++ )
		{
			CVar	v;
			FillCVarAt( i, v );

			if ( !v.ToSingleChar() )
			{
				delete pNewArray;
				return FALSE;
			}

			if ( pNewArray->AddShort( v.GetShort() ) != CSafeArray::no_error )
			{
				delete pNewArray;
				return FALSE;
			}
		}

		// Now replace the old pointer
		delete m_pSafeArray;
		m_pSafeArray = pNewArray;
	}
	else
	{
		// One element at a time, convert in place
		for(int i = 0; i < Size(); i++)
		{
			if(!GetAt(i).ToSingleChar())
				return FALSE;
		}
	}

    // Since all of the conversions succeeded, we will
    // assume the vector type is now VT_I2.

    m_nType = VT_I2;
    return TRUE;
}

BOOL CVarVector::ToUI4()
{

	// Handle this differently if we are sitting directly on a safearray
	if ( NULL != m_pSafeArray )
	{
		int	nSize = Size();

		// One element at a time is converted and copied into the new array
		CSafeArray*	pNewArray = new CSafeArray( VT_I4, CSafeArray::auto_delete, nSize );

		for ( int i = 0; i < nSize; i++ )
		{
			CVar	v;
			FillCVarAt( i, v );

			if ( !v.ToUI4() )
			{
				delete pNewArray;
				return FALSE;
			}

			if ( pNewArray->AddLong( v.GetLong() ) != CSafeArray::no_error )
			{
				delete pNewArray;
				return FALSE;
			}
		}

		// Now replace the old pointer
		delete m_pSafeArray;
		m_pSafeArray = pNewArray;
	}
	else
	{
		// One element at a time, convert in place
		for(int i = 0; i < Size(); i++)
		{
			if(!GetAt(i).ToUI4())
				return FALSE;
		}
	}

    // Since all of the conversions succeeded, we will
    // assume the vector type is now VT_I4.

    m_nType = VT_I4;
    return TRUE;
}

BOOL CVarVector::IsValidVectorType( int nVarType )
{
	if (	VT_BOOL			==	nVarType	||
			VT_UI1			==	nVarType	||
			VT_I2			==	nVarType	||
			VT_I4			==	nVarType	||
			VT_R4			==	nVarType	||
			VT_R8			==	nVarType	||
			VT_BSTR			==	nVarType	||
			VT_DISPATCH		==	nVarType	||
			VT_UNKNOWN		==	nVarType	)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL CVarVector::IsValidVectorArray( int nVarType, SAFEARRAY* pArray )
{
	BOOL	fReturn = IsValidVectorType( nVarType );

	if ( !fReturn )
	{

		// We do supprt VT_VARIANT if the array is zero length
		if ( VT_VARIANT == nVarType )
		{
			if ( NULL != pArray )
			{
				// If lUBound is 1 less than lLBound, it's a zero length array
				long	lLBound = 0,
						lUBound = 0;
				COleAuto::_SafeArrayGetLBound(pArray, 1, &lLBound);
				COleAuto::_SafeArrayGetUBound(pArray, 1, &lUBound);

				fReturn = ( lUBound == ( lLBound - 1 ) );
			}

		}	// IF VT_VARIANT
		
	}	// IF Invalid Type

	return fReturn;
}

int CVarVector::Size()
{
	if ( NULL == m_pSafeArray )
	{
		return m_Array.Size();
	}
	else
	{
		return m_pSafeArray->Size();
	}
}

HRESULT CVarVector::AccessRawArray( void** ppv )
{
	if ( NULL == m_pSafeArray )
	{
		return E_FAIL;
	}

	return m_pSafeArray->Access( ppv );
}

HRESULT CVarVector::UnaccessRawArray( void )
{
	if ( NULL == m_pSafeArray )
	{
		return E_FAIL;
	}

	if ( NULL != m_pRawData )
	{
		m_pRawData = NULL;
	}

	return m_pSafeArray->Unaccess();
}

HRESULT CVarVector::InternalRawArrayAccess( void )
{
	if ( NULL == m_pSafeArray )
	{
		return E_FAIL;
	}

	if ( NULL != m_pRawData )
	{
		return WBEM_E_INVALID_OPERATION;
	}

	return m_pSafeArray->Access( &m_pRawData );
}


CVar&   CVarVector::GetAt(int nIndex)
{
	// Not a valid operation if we are sitting on a SAFEARRAY
	_DBG_ASSERT( NULL == m_pSafeArray );

	if ( NULL == m_pSafeArray )
	{
		return *(CVar *) m_Array[nIndex];
	}
	else
	{
		throw CX_VarVectorException();
	}
}

CVar&   CVarVector::operator [](int nIndex)
{
	// Not a valid operation if we are sitting on a SAFEARRAY
	_DBG_ASSERT( NULL == m_pSafeArray );

	if ( NULL == m_pSafeArray )
	{
		return *(CVar *) m_Array[nIndex];
	}
	else
	{
		throw CX_VarVectorException();
	}
}

void   CVarVector::FillCVarAt(int nIndex, CVar& vTemp)
{

	if ( NULL == m_pSafeArray )
	{
		vTemp = *(CVar *) m_Array[nIndex];
	}
	else if ( NULL == m_pRawData )
	{
		switch( m_nType )
		{
			case VT_BOOL:
				vTemp.SetBool( m_pSafeArray->GetBoolAt( nIndex ) );
				break;

			case VT_UI1:
				vTemp.SetByte( m_pSafeArray->GetByteAt( nIndex ) );
				break;

			case VT_I2:
				vTemp.SetShort( m_pSafeArray->GetShortAt( nIndex ) );
				break;

			case VT_I4:
				vTemp.SetLong( m_pSafeArray->GetLongAt( nIndex ) );
				break;

			case VT_R4:
				vTemp.SetFloat( m_pSafeArray->GetFloatAt( nIndex ) );
				break;

			case VT_R8:
				vTemp.SetDouble( m_pSafeArray->GetDoubleAt( nIndex ) );
				break;

			case VT_BSTR:
				vTemp.SetBSTR( m_pSafeArray->GetBSTRAtThrow( nIndex ), TRUE );
				break;

			case VT_UNKNOWN:
				IUnknown* pUnk = m_pSafeArray->GetUnknownAt(nIndex);
				CReleaseMe	rm( pUnk );

				vTemp.SetUnknown( pUnk );
				break;

		}

	}
	else
	{
		// When we pull data in this state, we're using the CVar as a
		// passthrough, so it won't do any allocations or addref()
		// hence it shouldn't do any cleanup either.

		int	nDataLen = 0L;
		void*	pvElement = m_pRawData;

		switch( m_nType )
		{
			case VT_UI1:
				nDataLen = sizeof(BYTE);
				pvElement = (void*) &((BYTE*) m_pRawData)[nIndex];
				break;

			case VT_BOOL:
			case VT_I2:
				nDataLen = sizeof(short);
				pvElement = (void*) &((short*) m_pRawData)[nIndex];
				break;

			case VT_I4:
				nDataLen = sizeof(long);
				pvElement = (void*) &((long*) m_pRawData)[nIndex];
				break;

			case VT_R4:
				nDataLen = sizeof(float);
				pvElement = (void*) &((float*) m_pRawData)[nIndex];
				break;

			case VT_R8:
				nDataLen = sizeof(double);
				pvElement = (void*) &((double*) m_pRawData)[nIndex];
				break;

			case VT_BSTR:
				nDataLen = sizeof(BSTR);
				pvElement = (void*) &((BSTR*) m_pRawData)[nIndex];

				// If the BSTR is a NULL, old code converted to "", so
				// we will point to a pointer to "".
				if ( (*(BSTR*) pvElement ) == NULL )
				{
					pvElement = (void*) &g_pszNullVarString;
				}

				break;

			case VT_UNKNOWN:
				nDataLen = sizeof(IUnknown*);
				pvElement = (void*) &((IUnknown**) m_pRawData)[nIndex];
				break;

		}

		// Splat the raw value in, and Can Delete is FALSE
		// This is strictly to support optimized pass-through logic
		vTemp.SetRaw( m_nType, pvElement, nDataLen);
		vTemp.SetCanDelete( FALSE );
	}

}

// This only works if there are no elements in the safe array
BOOL CVarVector::MakeOptimized( int nVarType, int nInitSize, int nGrowBy )
{
	BOOL	fReturn = FALSE;

	if ( NULL == m_pSafeArray )
	{
		if ( m_Array.Size() == 0 )
		{
			m_pSafeArray = new CSafeArray( nVarType, CSafeArray::auto_delete, nInitSize, nGrowBy );

			if ( NULL != m_pSafeArray )
			{
				if ( m_pSafeArray->Status() == CSafeArray::no_error )
				{
					m_nType = nVarType;
					m_nStatus = no_error;
					fReturn = TRUE;
				}
				else
				{
					delete m_pSafeArray;
					m_pSafeArray = NULL;
					m_nStatus = failed;
				}
			}
			else
			{
				m_nStatus = failed;
			}
		}	// IF no elements in array

	}

	return fReturn;
}

BOOL CVarVector::DoesVectorTypeMatchArrayType( void )
{
	// If we have an underlying safe array, sometimes the actualy type of the
	// data in the safe array may be different from the type that was reported
	// to us in VARANTARG.  This info is critical in determining how we will
	// go about handling certain operations

	BOOL	fReturn = TRUE;

	if ( NULL != m_pSafeArray )
	{
		VARTYPE	vt;

		// Only return TRUE if the actual types are equal
		if ( m_pSafeArray->GetActualVarType( &vt ) == no_error )
		{
			fReturn = ( vt == m_nType );
		}
		else
		{
			fReturn = FALSE;
		}
	}

	return fReturn;
}

void CVarVector::SetRawArrayBinding( int nBinding )
{
	if ( NULL != m_pSafeArray )
	{
		m_pSafeArray->SetDestructorPolicy( nBinding );
	}
}

HRESULT CVarVector::SetRawArrayData( void* pvData, int nNumElements, int nElementSize )
{
	_DBG_ASSERT( NULL != m_pSafeArray );

	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( NULL != m_pSafeArray )
	{
		if ( m_pSafeArray->SetRawData( pvData, nNumElements, nElementSize ) != CSafeArray::no_error )
			hr = WBEM_E_FAILED;
	}
	else
	{
		hr = WBEM_E_FAILED;
	}

	return hr;
}

HRESULT CVarVector::GetRawArrayData( void* pvDest, int nBuffSize )
{
	_DBG_ASSERT( NULL != m_pSafeArray );

	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( NULL != m_pSafeArray )
	{
		if ( m_pSafeArray->GetRawData( pvDest, nBuffSize ) != CSafeArray::no_error )
			hr = WBEM_E_FAILED;
	}
	else
	{
		hr = WBEM_E_FAILED;
	}

	return hr;
}

BOOL CVarVector::SetRawArraySize( int nSize )
{
	_DBG_ASSERT( NULL != m_pSafeArray );

	BOOL	fReturn = FALSE;

	if ( NULL != m_pSafeArray )
	{
		m_pSafeArray->SetRawArrayMaxElement( nSize - 1 );
		fReturn = TRUE;
	}

	return fReturn;
}

int CVarVector::GetElementSize( void )
{
	_DBG_ASSERT( NULL != m_pSafeArray );

	int	nReturn = 0L;

	if ( NULL != m_pSafeArray )
	{
		nReturn = m_pSafeArray->ElementSize();
	}

	return nReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\wbemutil.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMUTIL.CPP

Abstract:

    General utility functions.

History:

    a-raymcc    17-Apr-96      Created.

--*/

#include "precomp.h"

#include <sys/types.h>
#include <sys/stat.h>
#include <time.h>
#include <stdio.h>
#include <wbemutil.h>
#include <corex.h>
#include "reg.h"
#include <TCHAR.H>
#include "sync.h"
#include <ARRTEMPL.H>

class AutoRevert
{
private:
	HANDLE oldToken_;
	bool self_;
public:
    AutoRevert();
    ~AutoRevert();
	void dismiss();
	bool self(){ return self_;}
};

AutoRevert::AutoRevert():oldToken_(NULL),self_(true)
{
	if (OpenThreadToken(GetCurrentThread(),TOKEN_IMPERSONATE,TRUE,&oldToken_))
	{
		RevertToSelf();
	}else
	{
		if (GetLastError() != ERROR_NO_TOKEN)
			self_ = false;
	};
}

AutoRevert::~AutoRevert()
{
	dismiss();
}

void AutoRevert::dismiss()
{
	if (oldToken_)
	{
		SetThreadToken(NULL,oldToken_);
		CloseHandle(oldToken_);
	}
}

//***************************************************************************
//
//  BOOL isunialpha(wchar_t c)
//
//  Used to test if a wide character is a unicode character or underscore.
//
//  Parameters:
//      c = The character being tested.
//  Return value:
//      TRUE if OK.
// 
//***************************************************************************

BOOL POLARITY isunialpha(wchar_t c)
{
    if(c == 0x5f || (0x41 <= c && c <= 0x5a) ||
       (0x61  <= c && c <= 0x7a) || (0x80  <= c && c <= 0xfffd))
        return TRUE;
    else
        return FALSE;
}

//***************************************************************************
//
//  BOOL isunialphanum(char_t c)
//
//  Used to test if a wide character is string suitable for identifiers.
//
//  Parameters:
//      pwc = The character being tested.
//  Return value:
//      TRUE if OK.
// 
//***************************************************************************

BOOL POLARITY isunialphanum(wchar_t c)
{
    if(isunialpha(c))
        return TRUE;
    else
        return iswdigit(c);
}

BOOL IsValidElementName( LPCWSTR wszName )
{
    if(wszName[0] == 0)
        return FALSE;

    if(wszName[0] == '_')
        return FALSE;

    const WCHAR* pwc = wszName;

    // Check the first letter
    // ======================

    // this is for compatibility with IWbemPathParser
    if (iswspace(pwc[0])) 
        return FALSE;        

    if(!isunialpha(*pwc))
        return FALSE;
    pwc++;

    // Check the rest
    // ==============

    while(*pwc)
    {
        if(!isunialphanum(*pwc))
            return FALSE;
        pwc++;
    }

    if (iswspace(*(pwc-1)))
        return FALSE;

    if(pwc[-1] == '_')
        return FALSE;

    return TRUE;
}

// Can't use overloading and/or default parameters because 
// "C" files use these guys.  No, I'm not happy about
// this!
BOOL IsValidElementName2( LPCWSTR wszName, BOOL bAllowUnderscore )
{
    if(wszName[0] == 0)
        return FALSE;

    if(!bAllowUnderscore && wszName[0] == '_')
        return FALSE;

    const WCHAR* pwc = wszName;

    // Check the first letter
    // ======================

    // this is for compatibility with IWbemPathParser
    if (iswspace(pwc[0])) 
        return FALSE;    

    if(!isunialpha(*pwc))
        return FALSE;
    pwc++;

    // Check the rest
    // ==============

    while(*pwc)
    {
        if(!isunialphanum(*pwc))
            return FALSE;
        pwc++;
    }

    if (iswspace(*(pwc-1)))
        return FALSE;

    if(!bAllowUnderscore && pwc[-1] == '_')
        return FALSE;

    return TRUE;
}

BLOB POLARITY BlobCopy(BLOB *pSrc)
{
    BLOB Blob;
    BYTE *p = new BYTE[pSrc->cbSize];

    // Check for allocation failure
    if ( NULL == p )
    {
        throw CX_MemoryException();
    }

    Blob.cbSize = pSrc->cbSize;
    Blob.pBlobData = p;
    memcpy(p, pSrc->pBlobData, Blob.cbSize);
    return Blob;
}

void POLARITY BlobAssign(BLOB *pBlob, LPVOID pBytes, DWORD dwCount, BOOL bAcquire)
{
    BYTE *pSrc = 0;
    if (bAcquire) 
        pSrc = (BYTE *) pBytes;
    else {
        pSrc = new BYTE[dwCount];

        // Check for allocation failure
        if ( NULL == pSrc )
        {
            throw CX_MemoryException();
        }

        memcpy(pSrc, pBytes, dwCount);
    }            
    pBlob->cbSize = dwCount;
    pBlob->pBlobData = pSrc;            
}

void POLARITY BlobClear(BLOB *pSrc)
{
    if (pSrc->pBlobData) 
        delete pSrc->pBlobData;

    pSrc->pBlobData = 0;
    pSrc->cbSize = 0;
}


class __Trace
{
	struct ARMutex
	{
	HANDLE h_;
	ARMutex(HANDLE h):h_(h){}
	~ARMutex(){ ReleaseMutex(h_);}
	};

public:
	enum { REG_CHECK_INTERVAL =1000 * 60 };

    DWORD m_dwLogging;
    DWORD m_dwMaxLogSize;
    DWORD m_dwTimeLastRegCheck;
    wchar_t m_szLoggingDirectory[MAX_PATH+1];
    char m_szTraceBuffer[2048];
    char m_szTraceBuffer2[4096];
	wchar_t m_szBackupFileName[MAX_PATH+1];
	wchar_t m_szLogFileName[MAX_PATH+1];
    static const wchar_t *m_szLogFileNames[];

	BOOL LoggingLevelEnabled(DWORD dwLevel);
	int Trace(char caller, const char *fmt, va_list &argptr);
    __Trace();
	~__Trace();
	HANDLE get_logfile(const wchar_t * name );
private:
	void ReadLogDirectory();
	void ReReadRegistry();
	HANDLE buffers_lock_;
};

const wchar_t * __Trace::m_szLogFileNames[] = 
                                { FILENAME_PREFIX_CORE __TEXT(".log"),
                                  FILENAME_PREFIX_EXE __TEXT(".log"),
                                  FILENAME_PREFIX_ESS __TEXT(".log"),
                                  FILENAME_PREFIX_CLI_MARSH __TEXT(".log"),
                                  FILENAME_PREFIX_SERV_MARSH __TEXT(".log"),
                                  FILENAME_PREFIX_QUERY __TEXT(".log"),
                                  FILENAME_PROFIX_MOFCOMP __TEXT(".log"),
                                  FILENAME_PROFIX_EVENTLOG __TEXT(".log"),
                                  FILENAME_PROFIX_WBEMDISP __TEXT(".log"),
                                  FILENAME_PROFIX_STDPROV __TEXT(".log"),
                                  FILENAME_PROFIX_WMIPROV __TEXT(".log"),
                                  FILENAME_PROFIX_WMIOLEDB __TEXT(".log"),
                                  FILENAME_PREFIX_WMIADAP __TEXT(".log"),
								  FILENAME_PREFIX_REPDRV __TEXT(".log")
                                  };

__Trace __g_traceInfo;

__Trace::__Trace()
    : m_dwLogging(1), 
      m_dwMaxLogSize(65536), 
      m_dwTimeLastRegCheck(GetTickCount())
{
	buffers_lock_ = CreateMutex(0,0,0);
	ReadLogDirectory();
	ReReadRegistry();
}

__Trace::~__Trace()
{
	CloseHandle(buffers_lock_);
};

void __Trace::ReReadRegistry()
{
    Registry r(WBEM_REG_WINMGMT);

	//Get the logging level
    if (r.GetDWORDStr(__TEXT("Logging"), &m_dwLogging) != Registry::no_error)
	{
        m_dwLogging = 1;
        r.SetDWORDStr(__TEXT("Logging"), m_dwLogging);
	}

	//Get the maximum log file size
    if (r.GetDWORDStr(__TEXT("Log File Max Size"), &m_dwMaxLogSize) != Registry::no_error)
    {
        m_dwMaxLogSize = 65536;
        r.SetDWORDStr(__TEXT("Log File Max Size"), m_dwMaxLogSize);
    }
}
void __Trace::ReadLogDirectory()
{
    Registry r(WBEM_REG_WINMGMT);

	//Retrieve the logging directory
    TCHAR *tmpStr = 0;
    
    if ((r.GetStr(__TEXT("Logging Directory"), &tmpStr) == Registry::failed) ||
        (lstrlen(tmpStr) > (MAX_PATH)))
    {
        delete [] tmpStr;   //Just in case someone was trying for a buffer overrun with a long path in the registry...

        if (GetSystemDirectory(m_szLoggingDirectory, MAX_PATH+1) == 0)
        {
            lstrcpy(m_szLoggingDirectory, __TEXT("c:\\"));
        }
        else
        {
            lstrcat(m_szLoggingDirectory, __TEXT("\\WBEM\\Logs\\"));
            r.SetStr(__TEXT("Logging Directory"), m_szLoggingDirectory);
       }
    }
    else
    {
        lstrcpy(m_szLoggingDirectory, tmpStr);
        //make sure there is a '\' on the end of the path...
        if (m_szLoggingDirectory[lstrlen(m_szLoggingDirectory) - 1] != '\\')
        {
            lstrcat(m_szLoggingDirectory, __TEXT("\\"));
            r.SetStr(__TEXT("Logging Directory"), m_szLoggingDirectory);
        }
        delete [] tmpStr;
    }

	//Make sure directory exists
    WbemCreateDirectory(m_szLoggingDirectory);
}



HANDLE __Trace::get_logfile(const wchar_t * file_name )
{

	AutoRevert revert; 
	if (revert.self()==false)
		return INVALID_HANDLE_VALUE;

HANDLE hTraceFile = INVALID_HANDLE_VALUE;
bool bDoneWrite = false;

//Keep trying to open the file
while (!bDoneWrite)
{
	while (hTraceFile == INVALID_HANDLE_VALUE)
	{
		if (WaitForSingleObject(buffers_lock_,-1)==WAIT_FAILED)
			return INVALID_HANDLE_VALUE;

		lstrcpy(m_szLogFileName, m_szLoggingDirectory);;
		lstrcat(m_szLogFileName, file_name);

		hTraceFile = ::CreateFileW( m_szLogFileName,
								 GENERIC_WRITE,
								 FILE_SHARE_READ | FILE_SHARE_DELETE,
								 NULL,
								 OPEN_ALWAYS,
								 FILE_ATTRIBUTE_NORMAL,
								 NULL );
		if ( hTraceFile  == INVALID_HANDLE_VALUE ) 
		{
			ReleaseMutex(buffers_lock_);
			if (GetLastError() == ERROR_SHARING_VIOLATION)
			{
				Sleep(20);
			}
			else
			{
				return INVALID_HANDLE_VALUE;
			}

		}
	}

	ARMutex arm(buffers_lock_);
	//
	//  Now move the file pointer to the end of the file
	//
	LARGE_INTEGER liSize;
	liSize.QuadPart = 0;
	if ( !::SetFilePointerEx( hTraceFile,
								  liSize,
								  NULL,
								  FILE_END ) ) 
	{
			CloseHandle( hTraceFile );
			return INVALID_HANDLE_VALUE;
	} 


	bDoneWrite = true;
	//Rename file if file length is exceeded
	LARGE_INTEGER liMaxSize;
	liMaxSize.QuadPart = m_dwMaxLogSize;
	if (GetFileSizeEx(hTraceFile, &liSize))
	{
		if (liSize.QuadPart > liMaxSize.QuadPart)
		{

			lstrcpy(m_szBackupFileName, m_szLogFileName);
			lstrcpy(m_szBackupFileName + lstrlen(m_szBackupFileName) - 3, __TEXT("lo_"));
			DeleteFile(m_szBackupFileName);
			if (MoveFile(m_szLogFileName, m_szBackupFileName) == 0)
			{
				if ( liSize.QuadPart < liMaxSize.QuadPart*2)
					return hTraceFile;
				else
				{
					CloseHandle(hTraceFile);
					return INVALID_HANDLE_VALUE;
				};
			}
				
			//Need to re-open the file!
			bDoneWrite = false;
			CloseHandle(hTraceFile);
			hTraceFile = INVALID_HANDLE_VALUE;
		}
	}
}
return hTraceFile;
};


int __Trace::Trace(char caller, const char *fmt, va_list &argptr)
{

    HANDLE hTraceFile = INVALID_HANDLE_VALUE;
	
	try
	{
		if (caller >= (sizeof(m_szLogFileNames) / sizeof(char)))
			caller = 0;

		hTraceFile  = get_logfile(m_szLogFileNames[caller]);
		if (hTraceFile == INVALID_HANDLE_VALUE)
		  return 0;
		CCloseMe ch(hTraceFile);

		if (WaitForSingleObject(buffers_lock_,-1)==WAIT_FAILED)
			return 0;
		ARMutex arm(buffers_lock_);

		// Get time.
		// =========
		char timebuf[64];
		time_t now = time(0);
		struct tm *local = localtime(&now);
		if(local)
		{
			strcpy(timebuf, asctime(local));
			timebuf[strlen(timebuf) - 1] = 0;   // O
		}
		else
		{
			strcpy(timebuf,"??");
		}
		//Put time in start of log
		sprintf(m_szTraceBuffer, "(%s.%d) : ", timebuf, GetTickCount());

		//Format the user string
		int nLen = strlen(m_szTraceBuffer);
		_vsnprintf(m_szTraceBuffer + nLen, 2047 - nLen, fmt, argptr);
		
		m_szTraceBuffer[2047] = '\0';

		//Unfortunately, lots of people only put \n in the string, so we need to convert the string...
		int nLen2 = 0;
		char *p = m_szTraceBuffer;
		char *p2 = m_szTraceBuffer2;
		for (; *p; p++,p2++,nLen2++)
		{
			if (*p == '\n')
			{
				*p2 = '\r';
				p2++;
				nLen2++;
				*p2 = '\n';
			}
			else
			{
				*p2 = *p;
			}
		}
		*p2 = '\0';

		//
		//  Write to file :
		//
		DWORD dwWritten;
		::WriteFile( hTraceFile, m_szTraceBuffer2, nLen2, &dwWritten, NULL);

		return 1;
    }
    catch(...)
    { 
		return 0;
    }
}


BOOL __Trace::LoggingLevelEnabled(DWORD dwLevel)
{
    DWORD dwCurTicks = GetTickCount();
    if (dwCurTicks - m_dwTimeLastRegCheck > REG_CHECK_INTERVAL)
    {
        ReReadRegistry();
        m_dwTimeLastRegCheck = dwCurTicks;
    }

    if ((dwLevel > m_dwLogging))
        return FALSE;
    else
        return TRUE;
}

BOOL LoggingLevelEnabled(DWORD dwLevel)
{
	return __g_traceInfo.LoggingLevelEnabled(dwLevel);
}
int ErrorTrace(char caller, const char *fmt, ...)
{
    if (__g_traceInfo.LoggingLevelEnabled(1))
    {
        va_list argptr;
        va_start(argptr, fmt);
        __g_traceInfo.Trace(caller, fmt, argptr);
        va_end(argptr);
        return 1;
    }
    else
        return 0;
}
int DebugTrace(char caller, const char *fmt, ...)
{
    if (__g_traceInfo.LoggingLevelEnabled(2))
    {
        va_list argptr;
        va_start(argptr, fmt);
        __g_traceInfo.Trace(caller, fmt, argptr);
        va_end(argptr);
        return 1;
    }
    else
        return 0;
}

int CriticalFailADAPTrace(const char *string)
// 
//  The intention of this trace function is to be used in situations where catastrophic events
//  may have occured where the state of the heap may be in question.  The function uses only 
//  stack variables.  Note that if a heap corruption has occured there is a small chance that 
//  the global object __g_traceInfo may have been damaged.
{

	return ErrorTrace(LOG_WMIADAP, "**CRITICAL FAILURE** %s", string);
}

// Helper for quick wchar to multibyte conversions.  Caller muts
// free the returned pointer
BOOL POLARITY AllocWCHARToMBS( WCHAR* pWstr, char** ppStr )
{
    if ( NULL == pWstr )
    {
        return FALSE;
    }

    // Get the length allocate space and copy the string
    long    lLen = wcstombs(NULL, pWstr, 0);
    *ppStr = new char[lLen + 1];
    if (*ppStr == 0)
        return FALSE;
    wcstombs( *ppStr, pWstr, lLen + 1 );

    return TRUE;
}

LPTSTR GetWbemWorkDir( void )
{
	LPTSTR	pWorkDir = NULL;

    Registry r1(WBEM_REG_WBEM);
    if (r1.GetStr(__TEXT("Installation Directory"), &pWorkDir))
	{
        pWorkDir = new TCHAR[MAX_PATH + 1 + lstrlen(__TEXT("\\WBEM"))];
        if (pWorkDir == 0)
            return NULL;
        GetSystemDirectory(pWorkDir, MAX_PATH + 1);
        lstrcat(pWorkDir, __TEXT("\\WBEM"));
	}

	return pWorkDir;
}

LPTSTR GetWMIADAPCmdLine( int nExtra )
{
	LPTSTR	pWorkDir = GetWbemWorkDir();
	CVectorDeleteMe<TCHAR>	vdm( pWorkDir );

	if ( NULL == pWorkDir )
	{
		return NULL;
	}

	// Buffer should be big enough for two quotes, WMIADAP.EXE and cmdline switches
	LPTSTR	pCmdLine = new TCHAR[lstrlen( pWorkDir ) +
				lstrlen(__TEXT("\\\\?\\\\WMIADAP.EXE")) + nExtra + 1];

	if ( NULL == pCmdLine )
	{
		return NULL;
	}

	wsprintf( pCmdLine, __TEXT("\\\\?\\%s\\WMIADAP.EXE"), pWorkDir );

	return pCmdLine;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\var.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    VAR.H

Abstract:

  CVar & CVarVector.


  These are thread-safe translators for VARIANT and SAFEARRAY
  and represent all types support by WBEM.

  These are mutually nestable to any level.  A CVarVector can contain 
  an array of CVar, and a CVar can contain a CVarVector.    One CVar
  can therefore contain a whole tree of CVar objects, themselves
  containing homogeneous or heterogeneous arrays of CVar objects.

  Note: CVar should not be bound to one type and then immediately
  coerced to a new type.  This object is designed for speed, not safety,
  so there is no checking to see if this has been done.  A memory leak
  is likely to occur.

  The assignment operator and copy constructors are the only method
  of changing the type on a CVar.  Do NOT construct the object as
  a BSTR, for example, and then call SetDWORD.

History:

	16-Apr-96   a-raymcc    Created.
	12//17/98	sanjes -	Partially Reviewed for Out of Memory.
	18-Mar-99	a-dcrews	Added out-of-memory exception handling

--*/

#ifndef _VAR_H_
#define _VAR_H_

#include <flexarry.h>
#include <safearry.h>


#define VT_EX_CVAR           (VT_USERDEFINED | 0x80010000)
#define VT_EX_CVARVECTOR     (VT_USERDEFINED | 0x80010002)

class CVarVector;

typedef union
{
    char     cVal;          // VT_I1
    BYTE     bVal;          // VT_UI1
    SHORT    iVal;          // VT_I2
    WORD     wVal;          // VT_UI2
    LONG     lVal;          // VT_I4
    DWORD    dwVal;         // VT_UI4
    VARIANT_BOOL boolVal;   // VT_BOOL    

    float    fltVal;        // VT_R4
    double   dblVal;        // VT_R8

    LPSTR    pStr;          // VT_LPSTR
    LPWSTR   pWStr;         // VT_LPWSTR
    BSTR     Str;           // VT_BSTR      (stored as VT_LPWSTR)
    
    FILETIME Time;          // VT_FILETIME
    BLOB   Blob;            // VT_BLOB        
    LPCLSID  pClsId;        // VT_CLSID
    IUnknown* pUnk;         // VT_UNKNOWN
    IDispatch* pDisp;       // VT_DISPATCH
    CVarVector *pVarVector; // VT_EX_CVARVECTOR
        
}   METAVALUE;


class POLARITY CVar  
{
private:
    int m_vt;
    METAVALUE m_value;
    int m_nStatus;    
    BOOL m_bCanDelete;
    
    void Init();
public:
    enum { no_error, unsupported, failed };
    
    CVar() { Init(); } 
   ~CVar();
    CVar(CVar &);
    CVar& operator =(CVar &);

    CVar(char c)            { Init(); SetChar(c); }
    CVar(BYTE b)            { Init(); SetByte(b); }
    CVar(SHORT s)           { Init(); SetShort(s); }
    CVar(WORD w)            { Init(); SetWord(w); }
    CVar(LONG l)            { Init(); SetLong(l); }
    CVar(DWORD dw)          { Init(); SetDWORD(dw); }     
    CVar(float f)           { Init(); SetFloat(f); }
    CVar(double d)          { Init(); SetDouble(d); }
    CVar(VARIANT_BOOL b,int){ Init(); SetBool(b); }

    CVar(LPSTR p, BOOL bAcquire = FALSE)  
        { Init(); SetLPSTR(p, bAcquire); }

    CVar(LPWSTR p, BOOL bAcquire = FALSE)          
        { Init(); SetLPWSTR(p, bAcquire); }
        
    CVar(int, BSTR b, BOOL bAcquire = FALSE)       
        { Init(); SetBSTR(b, bAcquire); }      
        // Dummy int required for context, since BSTR is also LPWSTR
        // from Win32 point of view, although the VT_ indicators differ.
        
    CVar(CLSID *p, BOOL bAcquire = FALSE)  
        { Init(); SetClsId(p, bAcquire); }

    CVar(BLOB *p, BOOL bAcquire = FALSE)           
        { Init(); SetBlob(p, bAcquire); }
        
    CVar(FILETIME *p)       { Init(); SetFileTime(p); }

    CVar(CVarVector *p, BOOL bAcquire = FALSE) { Init(); SetVarVector(p, bAcquire); }
    CVar(VARIANT *p)        { Init(); SetVariant(p); }    
    CVar(int nType, SAFEARRAY *p) { Init(); SetSafeArray(nType, p); }
    int Status() { return m_nStatus; }

    int  DumpText(FILE *fStream);
    int  GetType() { return m_vt; }
    int  GetOleType();
    void Empty();

    int operator ==(CVar &Other);
    BOOL CompareTo(CVar& Other, BOOL bIgnoreCase);


    void SetRaw(int vt, void* pvData, int nDataLen);
    void* GetRawData() {return (void*)&m_value;}
    BOOL CanDelete() {return m_bCanDelete;}
    void SetCanDelete(BOOL bCanDelete) {m_bCanDelete = bCanDelete;}

    // Numeric types.
    // ==============
    
    void SetAsNull() { m_vt = VT_NULL; m_value.lVal = 0; }
    BOOL IsNull() {return m_vt == VT_NULL;}
    BOOL IsDataNull();
    
    void SetChar(char c) { m_vt = VT_I1; m_value.cVal = c; }
    char GetChar() { return m_value.cVal; }
    operator char() { return m_value.cVal; }
    
    void SetByte(BYTE b) { m_vt = VT_UI1; m_value.bVal = b; }
    BYTE GetByte() { return m_value.bVal; }
    operator BYTE() { return m_value.bVal; }
    
    void  SetShort(SHORT iVal) { m_vt = VT_I2; m_value.iVal = iVal; }
    SHORT GetShort() { return m_value.iVal; }
    operator SHORT() { return m_value.iVal; }
    
    void SetWord(WORD wVal) { m_vt = VT_UI2; m_value.wVal = wVal; }
    WORD GetWord() { return m_value.wVal; }
    operator WORD() { return m_value.wVal; }
    
    void SetLong(LONG lVal) { m_value.lVal = lVal; m_vt = VT_I4; }
    LONG GetLong() { return m_value.lVal; }
    operator LONG() { return m_value.lVal; }
    
    void SetDWORD(DWORD dwVal) { m_value.dwVal = dwVal; m_vt = VT_UI4; }
    DWORD GetDWORD() { return m_value.dwVal; }
    operator DWORD() { return m_value.dwVal; }
    
    void SetBool(VARIANT_BOOL b) { m_value.boolVal = b; m_vt = VT_BOOL; }
    VARIANT_BOOL GetBool() { return m_value.boolVal; }

    void SetFloat(float f) { m_value.fltVal = f; m_vt = VT_R4; }
    float GetFloat() { return m_value.fltVal; }
    operator float() { return m_value.fltVal; }
    
    void   SetDouble(double dblVal) { m_value.dblVal = dblVal; m_vt = VT_R8; }
    double GetDouble() { return m_value.dblVal; }
    operator double() { return m_value.dblVal; }

    void SetDispatch(IDispatch* pDisp);
    IDispatch* GetDispatch() 
    {if(m_value.pDisp) m_value.pDisp->AddRef(); return m_value.pDisp;}
    
    void SetUnknown(IUnknown* pUnk);
    IUnknown* GetUnknown() 
    {if(m_value.pUnk) m_value.pUnk->AddRef(); return m_value.pUnk;}

    void SetEmbeddedObject(IUnknown* pUnk) {SetUnknown(pUnk);}
    IUnknown* GetEmbeddedObject() {return GetUnknown();}

    int SetVariant(VARIANT *pSrc, BOOL fOptimize = FALSE);

    void FillVariant(VARIANT* pDest, BOOL fOptimized = FALSE);
    VARIANT *GetNewVariant();    
    
    // String types.
    // =============
    
    BOOL  SetLPWSTR(LPWSTR pVal, BOOL bAcquire = FALSE);
    wchar_t *GetLPWSTR() { return m_value.pWStr; }
    operator LPWSTR() { return m_value.pWStr; }    
    
    BOOL  SetLPSTR(LPSTR pStr, BOOL bAcquire = FALSE);
    LPSTR GetLPSTR() { return m_value.pStr; }
    operator LPSTR() { return m_value.pStr; }
    
    BOOL SetBSTR(BSTR str, BOOL bAcquire = FALSE);
    BSTR GetBSTR();     // Makes a dynamic copy which must be freed.
    
    // Misc. types.
    // ============
    
    void SetFileTime(FILETIME *pft) { m_value.Time = *pft; m_vt = VT_FILETIME; }
    FILETIME GetFileTime() { return m_value.Time; }
    operator FILETIME() { return m_value.Time; }    
    
    void SetBlob(BLOB *pBlob, BOOL bAcquire = FALSE);
    BLOB *GetBlob() { return &m_value.Blob; }
    operator BLOB *() { return &m_value.Blob; }        
    
    void SetClsId(CLSID *pClsId, BOOL bAcquire);
    CLSID* GetClsId() { return m_value.pClsId; }    // Return value is read-only
    operator CLSID*() { return m_value.pClsId; }    // Return value is read-only    
    
    void SetVarVector(CVarVector *pVec, BOOL bAcquire);
    CVarVector *GetVarVector()  { return m_value.pVarVector; }  
    operator CVarVector *()  { return m_value.pVarVector; }  
    
    void SetSafeArray(int nType, SAFEARRAY *pArray); // Copies the source
    SAFEARRAY *GetNewSafeArray();   // New SAFEARRAY which must be released

    void SetOptimizedSafeArray(int nType, SAFEARRAY *pArray, BOOL fAcquire = FALSE);
	SAFEARRAY* GetOptimizedSafeArray( void );

    static BSTR TypeToText(int nType);
    BSTR GetTypeText();
    BSTR GetText(long lFlags, long lType = 0, LPCWSTR szFormat = NULL);

    BOOL ChangeTypeTo(VARTYPE vtNew);
    BOOL ChangeTypeToEx(VARTYPE vtNew, LCID lcid = 0x409 );
    BOOL ToSingleChar();
    BOOL ToUI4();
};


class POLARITY CVarVector
{
    int         m_nType;
    CFlexArray  m_Array;
    int         m_nStatus;
	CSafeArray*	m_pSafeArray;
	void*		m_pRawData;

public:
    enum { no_error, failed, unsupported };

    CVarVector();    
    CVarVector(int nVarType, int nInitSize = 32, int nGrowBy = 32);

    // These two only support limited SAFEARRAY types.
    // ===============================================

    CVarVector(int nVarType, SAFEARRAY *pSrc, BOOL fOptimized = FALSE);
    SAFEARRAY *GetNewSafeArray();
	SAFEARRAY* GetSafeArray( BOOL fAcquire = FALSE );

    int  GetType() { return m_nType; }        
    int  Status() { return m_nStatus; }
    void Empty();
                    
   ~CVarVector();
    CVarVector(CVarVector &Src);
    CVarVector& operator =(CVarVector &Src);
    int operator ==(CVarVector &Src);     
    BOOL CompareTo(CVarVector& Other, BOOL bIgnoreCase);
    int Size();

    int    Add(CVar &Value);  
    int    Add(CVar *pAcquiredPtr);

    CVar&   GetAt(int nIndex);
    CVar&   operator [](int nIndex);

    int    RemoveAt(int nIndex);
    int    InsertAt(int nIndex, CVar &Value);

    BSTR GetText(long lFlags, long lType = 0);
    BOOL ToSingleChar();
    BOOL ToUI4();

	BOOL IsOptimized( void )	{ return NULL != m_pSafeArray; }
	BOOL MakeOptimized( int nVarType, int nInitSize = 32, int nGrowBy = 32 );
	void SetRawArrayBinding( int nBinding );
	
	HRESULT AccessRawArray( void** ppv );
	HRESULT UnaccessRawArray( void );

	// We access raw data using internal data member.
	HRESULT InternalRawArrayAccess( void );

	static BOOL IsValidVectorType( int nVarType );
	static BOOL IsValidVectorArray( int nVarType, SAFEARRAY* pArray );

	void FillCVarAt(int nIndex, CVar& vTemp);

	BOOL DoesVectorTypeMatchArrayType( void );
	
	HRESULT SetRawArrayData( void* pvData, int nNumElements, int nElementSize );
	HRESULT GetRawArrayData( void* pvDest, int nBuffSize );

	BOOL SetRawArraySize( int nSize );
	int GetElementSize( void );
};

class CUnaccessVarVector
{
private:
	CVarVector*	m_pVV;

public:

	CUnaccessVarVector( CVarVector*	pvv = NULL ) : m_pVV( pvv )	{}
	~CUnaccessVarVector() { Unaccess(); }

	void SetVV( CVarVector* pvv )	{ m_pVV = pvv; }
	void Unaccess( void ) { if ( NULL != m_pVV ) m_pVV->UnaccessRawArray(); m_pVV = NULL; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\winntsec.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WINNTSEC.H

Abstract:

    Generic wrapper classes for NT security objects.

    Documention on class members is in WINNTSEC.CPP.  Inline members
    are commented in this file.

History:

    raymcc      08-Jul-97       Created.

--*/

#ifndef _WINNTSEC_H_
#define _WINNTSEC_H_

class POLARITY CNtSecurity;

// All ACE types are currently have the same binary layout. Rather
// than doing a lot of useless casts, we produce a general-purpose
// typedef to hold all ACEs.
// ================================================================

typedef ACCESS_ALLOWED_ACE GENERIC_ACE;
typedef GENERIC_ACE *PGENERIC_ACE;

#define FULL_CONTROL     \
        (DELETE |       \
         READ_CONTROL | \
        WRITE_DAC |         \
        WRITE_OWNER |   \
        SYNCHRONIZE | GENERIC_ALL)


//***************************************************************************
//
//  CNtSid
//
//  Models SIDs (users/groups).
//
//***************************************************************************

class POLARITY CNtSid
{
    PSID    m_pSid;
    LPWSTR  m_pMachine;
    LPWSTR  m_pDomain;
    DWORD   m_dwStatus;
    SID_NAME_USE m_snu;

public:
    enum { NoError, Failed, NullSid, InvalidSid, InternalError, AccessDenied = 0x5 };

    enum SidType {CURRENT_USER, CURRENT_THREAD};

    CNtSid(SidType st);
    CNtSid() { m_pSid = 0; m_pMachine = 0; m_dwStatus = NullSid; }
    bool IsUser(){return m_snu == SidTypeUser;};

    CNtSid(PSID pSrc);
        // Construct based on another SID.

    CNtSid(LPWSTR pUser, LPWSTR pMachine = 0);
        // Construct based on a user (machine name is optional).

   ~CNtSid();

    CNtSid(CNtSid &Src);
    CNtSid &operator =(CNtSid &Src);
    int operator ==(CNtSid &Comparand);

    DWORD GetStatus() { return m_dwStatus; }
        // Returns one of the enumerated types.

    PSID GetPtr() { return m_pSid; }
        // Returns the internal SID ptr to interface with NT APIs
    DWORD GetSize();

    BOOL CopyTo(PSID pDestination);

    BOOL IsValid() { return (m_pSid && IsValidSid(m_pSid)); }
        // Checks the validity of the internal SID.

    void Dump();
        // Dumps SID info to console for debugging.

    int GetInfo(
        LPWSTR *pRetAccount,        // Account, use operator delete
        LPWSTR *pRetDomain,         // Domain, use operator delete
        DWORD  *pdwUse              // See SID_NAME_USE for values
        );

    BOOL GetTextSid(LPTSTR pszSidText, LPDWORD dwBufferLen);

};

//***************************************************************************
//
//  CBaseAce
//
//  Base class for aces.
//
//***************************************************************************

class POLARITY CBaseAce
{

public:

    CBaseAce(){};
    virtual ~CBaseAce(){};

    virtual int GetType() = 0;
    virtual int GetFlags() = 0;         // inheritance etc.
    virtual ACCESS_MASK GetAccessMask() = 0;
    virtual HRESULT GetFullUserName(WCHAR * pBuff, DWORD dwSize) = 0;
    virtual HRESULT GetFullUserName2(WCHAR ** pBuff) = 0; // call must free
    virtual DWORD GetStatus() = 0;
    virtual void SetFlags(long lFlags) =0;
    virtual DWORD GetSerializedSize() = 0;
    virtual bool  Serialize(BYTE * pData) = 0;
    virtual bool  Deserialize(BYTE * pData) = 0;
};


//***************************************************************************
//
//  CNtAce
//
//  Models NT ACEs.
//
//***************************************************************************

class POLARITY CNtAce : public CBaseAce
{
    PGENERIC_ACE    m_pAce;
    DWORD           m_dwStatus;

public:
    enum { NoError, InvalidAce, NullAce, InternalError };

    CNtAce() { m_pAce = 0; m_dwStatus = NullAce; }

    CNtAce(PGENERIC_ACE pAceSrc);
    CNtAce(CNtAce &Src);
    CNtAce & operator =(CNtAce &Src);

   ~CNtAce();

   CNtAce(
        ACCESS_MASK Mask,
        DWORD AceType,
        DWORD dwAceFlags,
        LPWSTR pUser,
        LPWSTR pMachine = 0         // Defaults to local machine
        );

    CNtAce(
        ACCESS_MASK Mask,
        DWORD AceType,
        DWORD dwAceFlags,
        CNtSid & Sid
        );

    int GetType();
    int GetFlags();         // inheritance etc.
    void SetFlags(long lFlags){m_pAce->Header.AceFlags = (unsigned char)lFlags;};

    DWORD GetStatus() { return m_dwStatus; }
        // Returns one of the enumerated types.

    int GetSubject(
        LPWSTR *pSubject
        );

    ACCESS_MASK GetAccessMask();

    CNtSid *GetSid();
    BOOL GetSid(CNtSid &Dest);

    PGENERIC_ACE GetPtr() { return m_pAce; }
    DWORD GetSize() { return m_pAce ? m_pAce->Header.AceSize : 0; }
    HRESULT GetFullUserName(WCHAR * pBuff, DWORD dwSize);
    HRESULT GetFullUserName2(WCHAR ** pBuff); // call must free
    DWORD GetSerializedSize();
    bool Serialize(BYTE * pData);
    bool Deserialize(BYTE * pData);

    void Dump(int iAceNum = -1);
    void DumpAccessMask();
};

//***************************************************************************
//
//  C9XAce
//
//  Simulates NT ACEs for 9X boxs.
//
//***************************************************************************

class POLARITY C9XAce : public CBaseAce
{
    LPWSTR m_wszFullName;
    DWORD m_dwAccess;
    int m_iFlags;
    int m_iType;
public:

   C9XAce(){m_wszFullName = 0;};
   C9XAce(DWORD Mask,
        DWORD AceType,
        DWORD dwAceFlags,
        LPWSTR pUser);
   ~C9XAce();

    int GetType(){return m_iType;};
    int GetFlags(){return m_iFlags;};         // inheritance etc.

    ACCESS_MASK GetAccessMask(){return m_dwAccess;};
    HRESULT GetFullUserName(WCHAR * pBuff, DWORD dwSize);
    HRESULT GetFullUserName2(WCHAR ** pBuff); // call must free
    DWORD GetStatus(){ return CNtAce::NoError; };
    void SetFlags(long lFlags){m_iFlags = (unsigned char)lFlags;};
    DWORD GetSerializedSize();
    bool Serialize(BYTE * pData);
    bool Deserialize(BYTE * pData);

};


//***************************************************************************
//
//  CNtAcl
//
//  Models an NT ACL.
//
//***************************************************************************

class POLARITY CNtAcl
{
    PACL    m_pAcl;
    DWORD   m_dwStatus;

public:
    enum { NoError, InternalError, NullAcl, InvalidAcl };
    enum { MinimumSize = 1 };

    CNtAcl(DWORD dwInitialSize = 128);

    CNtAcl(CNtAcl &Src);
    CNtAcl & operator = (CNtAcl &Src);

    CNtAcl(PACL pAcl);  // Makes a copy
   ~CNtAcl();

    int  GetNumAces();

    DWORD GetStatus() { return m_dwStatus; }
        // Returns one of the enumerated types.

	BOOL ContainsSid ( CNtSid& sid, BYTE& flags ) ;

    CNtAce *GetAce(int nIndex);
    BOOL GetAce(int nIndex, CNtAce &Dest);

    BOOL DeleteAce(int nIndex);
    BOOL AddAce(CNtAce *pAce);

    BOOL IsValid() { return(m_pAcl && IsValidAcl(m_pAcl)); }
        // Checks the validity of the embedded ACL.

    BOOL Resize(DWORD dwNewSize);
        // Or use CNtAcl::MinimumSize to trim the ACL to min size.
        // Fails if an illegal size is specified.

    DWORD GetSize();

    PACL GetPtr() { return m_pAcl; }
        // Returns the internal pointer for interface with NT APIs.

    BOOL GetAclSizeInfo(
        PDWORD pdwBytesInUse,
        PDWORD pdwBytesFree
        );

    void Dump();
};

//***************************************************************************
//
//  SNtAbsoluteSD
//
//  Helper for converting between absolute and relative SDs.
//
//***************************************************************************

struct SNtAbsoluteSD
{
    PSECURITY_DESCRIPTOR m_pSD;

    PACL m_pDacl;
    PACL m_pSacl;
    PSID m_pOwner;
    PSID m_pPrimaryGroup;

    SNtAbsoluteSD();
   ~SNtAbsoluteSD();
};

//***************************************************************************
//
//  CNtSecurityDescriptor
//
//  Models an NT Security Descriptor.  Note that in order to use this for an
//  AccessCheck, the DACL, owner sid, and group sid must be set!
//
//***************************************************************************

class POLARITY CNtSecurityDescriptor
{
    PSECURITY_DESCRIPTOR m_pSD;
    int m_dwStatus;


public:
    enum { NoError, NullSD, Failed, InvalidSD, SDOwned, SDNotOwned };

    CNtSecurityDescriptor();

    CNtSecurityDescriptor(
        PSECURITY_DESCRIPTOR pSD,
        BOOL bAcquire = FALSE
        );

    CNtSecurityDescriptor(CNtSecurityDescriptor &Src);
    CNtSecurityDescriptor & operator=(CNtSecurityDescriptor &Src);

    ~CNtSecurityDescriptor();

    SNtAbsoluteSD* CNtSecurityDescriptor::GetAbsoluteCopy();
    BOOL SetFromAbsoluteCopy(SNtAbsoluteSD *pSrc);

    int HasOwner();

    BOOL IsValid() { return(m_pSD && IsValidSecurityDescriptor(m_pSD)); }
        // Checks the validity of the embedded security descriptor&

    DWORD GetStatus() { return m_dwStatus; }
        // Returns one of the enumerated types.

    CNtAcl *GetDacl();
        // Deallocate with operator delete

    BOOL GetDacl(CNtAcl &DestAcl);
        // Retrieve into an existing object

    BOOL SetDacl(CNtAcl *pSrc);

    CNtAcl *GetSacl();
        // Deallocate with operator delete

    BOOL SetSacl(CNtAcl *pSrc);

    CNtSid *GetOwner();
    BOOL SetOwner(CNtSid *pSid);

    CNtSid *GetGroup();
    BOOL SetGroup(CNtSid *pSid);

    PSECURITY_DESCRIPTOR GetPtr() { return m_pSD; }
        // Returns the internal pointer for interface with NT APIs

    DWORD GetSize();

    void Dump();
};

//***************************************************************************
//
//  CNtSecurity
//
//  General-purpose NT security helpers.
//
//***************************************************************************

class POLARITY CNtSecurity
{
public:
    enum { NoError, InternalFailure, NotFound, InvalidName, AccessDenied = 5, NoSecurity,
           Failed };

    static BOOL DumpPrivileges();

    static BOOL SetPrivilege(
        IN TCHAR *pszPrivilegeName,     // An SE_ value.
        IN BOOL  bEnable               // TRUE=enable, FALSE=disable
        );

    static BOOL GetFileSD(
        IN TCHAR *pszFile,
        IN SECURITY_INFORMATION SecInfo,
        OUT CNtSecurityDescriptor **pSD
        );

    static BOOL SetFileSD(
        IN TCHAR *pszFile,
        IN SECURITY_INFORMATION SecInfo,
        IN CNtSecurityDescriptor *pSD
        );

    static int GetRegSD(
        IN HKEY hRoot,
        IN TCHAR *pszSubKey,
        IN SECURITY_INFORMATION SecInfo,
        OUT CNtSecurityDescriptor **pSD
        );

    static int SetRegSD(
        IN HKEY hRoot,
        IN TCHAR *pszSubKey,
        IN SECURITY_INFORMATION SecInfo,
        IN CNtSecurityDescriptor *pSD
        );


/*    static int GetDCName(
        IN  LPWSTR   pszDomain,
        OUT LPWSTR *pszDC,
        IN  LPWSTR   pszServer
        );*/

    static BOOL IsUserInGroup(
        HANDLE hClientToken,
        CNtSid & Sid
        );

    static DWORD AccessCheck(
        HANDLE hAccessToken,
        ACCESS_MASK RequiredAccess,
        CNtSecurityDescriptor *pSD
        );  // TBD

    static CNtSid *GetCurrentThreadSid(); // TBD

    static bool DoesLocalGroupExist(LPWSTR pwszGroup, LPWSTR pwszMachine);
    static bool AddLocalGroup(LPWSTR pwszGroupName, LPWSTR pwszGroupDescription);
};

BOOL FIsRunningAsService(VOID);
POLARITY BOOL SetObjectAccess2(HANDLE hObj);
POLARITY BOOL IsAdmin(HANDLE hAccess);
POLARITY BOOL IsNetworkService(HANDLE hAccess);
POLARITY BOOL IsLocalService(HANDLE hAccess);
POLARITY HRESULT GetAccessToken(HANDLE &hAccessToken);
POLARITY BOOL IsInAdminGroup();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\wbemutil.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMUTIL.CPP

Abstract:

    General utility functions prototypes and macros.

History:

    a-raymcc    17-Apr-96      Created.

--*/

#ifndef _WBEMUTIL_H_
#define _WBEMUTIL_H_
#include "corepol.h"




#ifdef DBG
#define _DBG_ASSERT(X) { if (!(X)) { DebugBreak(); } }
#else
#define _DBG_ASSERT(X)
#endif



#ifndef VARIANT_TRUE
#define VARIANT_TRUE ((VARIANT_BOOL) 0xFFFF)
#define VARIANT_FALSE (0)
#endif

#ifdef __cplusplus
inline wchar_t *Macro_CloneLPWSTR(LPCWSTR src)
{
    if (!src)
        return 0;
    wchar_t *dest = new wchar_t[wcslen(src) + 1];
    if (!dest)
        return 0;
    return wcscpy(dest, src);
}
#endif

#if (defined DEBUG || defined _DEBUG)
#pragma message("_ASSERTs are being expanded.")
#define _ASSERT(exp, msg)    \
    if (!(exp)) { \
        TCHAR buf[256]; \
        int nFlag; \
        OSVERSIONINFO info; \
        info.dwOSVersionInfoSize = sizeof(info); \
        GetVersionEx(&info); \
        if(info.dwPlatformId != VER_PLATFORM_WIN32_NT) nFlag = 0; \
        else if(info.dwMajorVersion < 4) nFlag = MB_SERVICE_NOTIFICATION_NT3X; \
        else nFlag = MB_SERVICE_NOTIFICATION; \
        wsprintf(buf, __TEXT("%s [%s:%d]"), msg, __FILE__, __LINE__); \
        MessageBox(0, buf, __TEXT("WBEM Critical Error"), \
            MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL | nFlag); \
    }
#else
#define _ASSERT(exp, msg)
#endif

#ifdef DBG
#define _DBG_MSG_ASSERT(X, msg) { if (!(X)) { OutputDebugStringW( msg ); DebugBreak(); } }
#define _DBG_ASSERT(X) { if (!(X)) { DebugBreak(); } }
#else
#define _DBG_MSG_ASSERT(X, msg)
#define _DBG_ASSERT(X)
#endif


//LOGGING module.
//This is an index into an array in wbemutil.cpp which uses
//the filenames specified next
#define LOG_WBEMCORE    0
#define LOG_WINMGMT     1
#define LOG_ESS         2
#define LOG_WBEMPROX    3
#define LOG_WBEMSTUB    4
#define LOG_QUERY       5
#define LOG_MOFCOMP     6
#define LOG_EVENTLOG    7
#define LOG_WBEMDISP    8
#define LOG_STDPROV     9
#define LOG_WIMPROV     10
#define LOG_WMIOLEDB    11
#define LOG_WMIADAP     12
#define LOG_REPDRV		13

//These are the log file names (possibly other things
//as well!) which is used in conjunction with the above
//ids.
#define FILENAME_PREFIX_CORE __TEXT("wbemcore")
#define FILENAME_PREFIX_EXE __TEXT("WinMgmt")
#define FILENAME_PREFIX_EXE_W L"WinMgmt"
#define FILENAME_PREFIX_CLI_MARSH __TEXT("wbemprox")
#define FILENAME_PREFIX_SERV_MARSH __TEXT("wbemstub")
#define FILENAME_PREFIX_ESS __TEXT("wbemess")
#define FILENAME_PREFIX_QUERY __TEXT("query")
#define FILENAME_PROFIX_MOFCOMP __TEXT("mofcomp")
#define FILENAME_PROFIX_EVENTLOG __TEXT("eventlog")
#define FILENAME_PROFIX_WBEMDISP __TEXT("wbemdisp")
#define FILENAME_PROFIX_STDPROV __TEXT("stdprov")
#define FILENAME_PROFIX_WMIPROV __TEXT("wmiprov")
#define FILENAME_PROFIX_WMIOLEDB __TEXT("wmioledb")
#define FILENAME_PREFIX_WMIADAP __TEXT("wmiadap")
#define FILENAME_PREFIX_REPDRV __TEXT("replog")

// True if unicode identifier, _, a-z, A-Z or 0x100-0xffef
BOOL POLARITY isunialpha(wchar_t c);
BOOL POLARITY isunialphanum(wchar_t c);
BOOL POLARITY IsValidElementName(LPCWSTR wszName);
// Can't use overloading and/or default parameters because
// "C" files use these guys.  No, I'm not happy about
// this!
BOOL POLARITY IsValidElementName2(LPCWSTR wszName, BOOL bAllowUnderscore);
BOOL POLARITY LoggingLevelEnabled(DWORD nLevel);
int POLARITY ErrorTrace(char cCaller, const char *fmt, ...);
#define TRACE(x) DebugTrace x
#define ERRORTRACE(x) ErrorTrace x

#define DEBUGTRACE(x)   DebugTrace x

int POLARITY DebugTrace(char cCaller, const char *fmt, ...);

int POLARITY CriticalFailADAPTrace(const char *string);

// BLOB manipulation.
// ==================

BLOB  POLARITY BlobCopy(BLOB *pSrc);
void  POLARITY BlobClear(BLOB *pSrc);
void  POLARITY BlobAssign(BLOB *pSrc, LPVOID pBytes, DWORD dwCount, BOOL bAcquire);

#define BlobInit(p) \
    ((p)->cbSize = 0, (p)->pBlobData = 0)

#define BlobLength(p)  ((p)->cbSize)
#define BlobDataPtr(p) ((p)->pBlobData)

// Object ref count helpers.
// =========================
void ObjectCreated(DWORD,IUnknown * pThis);
void ObjectDestroyed(DWORD,IUnknown * pThis);

#define MAX_OBJECT_TYPES            16

#define OBJECT_TYPE_LOCATOR         0
#define OBJECT_TYPE_CLSOBJ          1
#define OBJECT_TYPE_PROVIDER        2
#define OBJECT_TYPE_QUALIFIER       3
#define OBJECT_TYPE_NOTIFY          4
#define OBJECT_TYPE_OBJENUM         5
#define OBJECT_TYPE_FACTORY         6
#define OBJECT_TYPE_WBEMLOGIN       7
#define OBJECT_TYPE_WBEMLOGINHELP   8
#define OBJECT_TYPE_CORE_BUSY       9
#define OBJECT_TYPE_STATUS         10
#define OBJECT_TYPE_BACKUP_RESTORE 11
#define OBJECT_TYPE_PATH_PARSER    12
#define OBJECT_TYPE_WMIARRAY	   13
#define OBJECT_TYPE_OBJ_FACTORY    14
#define OBJECT_TYPE_FREEFORM_OBJ   15

//Creates directories recursively
BOOL POLARITY WbemCreateDirectory(const TCHAR *szDirectory);

#define VT_EMBEDDED_OBJECT VT_UNKNOWN
#define V_EMBEDDED_OBJECT(VAR) V_UNKNOWN(VAR)
#define I_EMBEDDED_OBJECT IUnknown

#define IDISPATCH_METHODS_STUB \
    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo) \
    {return E_NOTIMPL;}                         \
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)\
    {return E_NOTIMPL;}                                                 \
    STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR** rgszNames, UINT cNames,\
      LCID lcid, DISPID* rgdispid)                                          \
    {return E_NOTIMPL;}                                                      \
    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,\
      DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo,     \
      UINT* puArgErr)                                                          \
{return E_NOTIMPL;} \

// Quick WCHAR to MBS conversion helper
BOOL POLARITY AllocWCHARToMBS( WCHAR* pWstr, char** ppStr );

// Helpers needed in a couple of places.
LPTSTR POLARITY GetWbemWorkDir( void );
LPTSTR POLARITY GetWMIADAPCmdLine( int nExtra );

// In Debug this does something, in release, it's
// a noop.  C files don't need it.

#if defined(__cplusplus)
    inline void WbemDebugBreak( void )
    {
        DebugBreak();
    }
#endif

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\wqllex.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WQLLEX.CPP

Abstract:

    WQL DFA Table

History:

    raymcc    14-Sep-97       Created.
    raymcc    06-Oct-97       Single quote support

--*/

#include "precomp.h"
#include <stdio.h>

#include <genlex.h>
#include <wqllex.h>             

#define ST_STRING       26
#define ST_IDENT        31
#define ST_GE           37
#define ST_LE           39
#define ST_NE           42
#define ST_NUMERIC      44
#define ST_REAL         47
#define ST_STRING2      49
#define ST_STRING_ESC   54
#define ST_STRING2_ESC  55   
#define ST_SSTRING      56
#define ST_DOT          61

// DFA State Table for QL Level 1 lexical symbols.
// ================================================

LexEl WQL_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  0x80,  0xfffd,     ST_IDENT,   0,               GLEX_ACCEPT,

/* 4 */  L'(',   GLEX_EMPTY, 0,          WQL_TOK_OPEN_PAREN,  GLEX_ACCEPT,
/* 5 */  L')',   GLEX_EMPTY, 0,  WQL_TOK_CLOSE_PAREN, GLEX_ACCEPT,
/* 6 */  L'.',   GLEX_EMPTY, ST_DOT,  0,         GLEX_ACCEPT,
/* 7 */  L'*',   GLEX_EMPTY, 0,  WQL_TOK_ASTERISK,    GLEX_ACCEPT,
/* 8 */  L'=',   GLEX_EMPTY, 0,  WQL_TOK_EQ,          GLEX_ACCEPT,
/* 9 */  L'[',   GLEX_EMPTY, 0,  WQL_TOK_OPEN_BRACKET,  GLEX_ACCEPT,
/* 10 */  L']',   GLEX_EMPTY, 0,  WQL_TOK_CLOSE_BRACKET, GLEX_ACCEPT,

/* 11 */  L'>',   GLEX_EMPTY, ST_GE,      0,               GLEX_ACCEPT,
/* 12 */  L'<',   GLEX_EMPTY, ST_LE,      0,               GLEX_ACCEPT,
/* 13 */ L'0',   L'9',       ST_NUMERIC, 0,               GLEX_ACCEPT,
/* 14 */ L'"',   GLEX_EMPTY, ST_STRING,  0,               GLEX_CONSUME,
/* 15 */ L'\'',  GLEX_EMPTY, ST_STRING2, 0,               GLEX_CONSUME,
/* 16 */ L'!',   GLEX_EMPTY, ST_NE,      0,               GLEX_ACCEPT,
/* 17 */ L'-',   GLEX_EMPTY, ST_NUMERIC, 0,               GLEX_ACCEPT,
/* 18 */ L'\'',  GLEX_EMPTY, ST_SSTRING, 0,               GLEX_CONSUME,

    // Whitespace, newlines, etc.
/* 19 */ L' ',   GLEX_EMPTY, 0,          0,               GLEX_CONSUME,
/* 20 */ L'\t',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 21 */ L'\n',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME|GLEX_LINEFEED,
/* 22 */ L'\r',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 23 */ 0,      GLEX_EMPTY, 0,  WQL_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 24 */ L',',   GLEX_EMPTY, 0,  WQL_TOK_COMMA, GLEX_ACCEPT,

    // Unknown characters

/* 25 */ GLEX_ANY, GLEX_EMPTY, 0,        WQL_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_STRING
/* 26 */   L'\n', GLEX_EMPTY, 0,  WQL_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 27 */   L'\r', GLEX_EMPTY, 0,  WQL_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 28 */   L'"',  GLEX_EMPTY, 0,  WQL_TOK_QSTRING,  GLEX_CONSUME,
/* 29 */   L'\\',  GLEX_EMPTY, ST_STRING_ESC,  0,     GLEX_CONSUME,
/* 30 */   GLEX_ANY, GLEX_EMPTY, ST_STRING, 0,        GLEX_ACCEPT,
                                                      
// ST_IDENT

/* 31 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 32 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 33 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 34 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 35 */  0x80,  0xfffd,     ST_IDENT,   0,          GLEX_ACCEPT,
/* 36 */  GLEX_ANY, GLEX_EMPTY,  0,       WQL_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_GE
/* 37 */  L'=',   GLEX_EMPTY,  0,  WQL_TOK_GE,  GLEX_ACCEPT,
/* 38 */  GLEX_ANY, GLEX_EMPTY,  0,       WQL_TOK_GT,   GLEX_PUSHBACK|GLEX_RETURN,

// ST_LE
/* 39 */  L'=',   GLEX_EMPTY,      0,  WQL_TOK_LE,  GLEX_ACCEPT,
/* 40 */  L'>',   GLEX_EMPTY,      0,  WQL_TOK_NE,  GLEX_ACCEPT,
/* 41 */  GLEX_ANY, GLEX_EMPTY,    0,  WQL_TOK_LT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_NE
/* 42 */  L'=',   GLEX_EMPTY,      0,  WQL_TOK_NE,     GLEX_ACCEPT,
/* 43 */  GLEX_ANY,  GLEX_EMPTY,   0,  WQL_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,

// ST_NUMERIC
/* 44 */  L'0',   L'9',         ST_NUMERIC, 0,          GLEX_ACCEPT,
/* 45 */  L'.',   GLEX_EMPTY,   ST_REAL,    0,          GLEX_ACCEPT,
/* 46 */  GLEX_ANY, GLEX_EMPTY, 0,          WQL_TOK_INT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_REAL
/* 47 */  L'0',   L'9',   ST_REAL, 0,          GLEX_ACCEPT,
/* 48 */  GLEX_ANY,       GLEX_EMPTY,   0,     WQL_TOK_REAL, GLEX_PUSHBACK|GLEX_RETURN,

// ST_STRING2
/* 49 */   L'\n',  GLEX_EMPTY, 0,  WQL_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 50 */   L'\r',  GLEX_EMPTY, 0,  WQL_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 51 */   L'\'',  GLEX_EMPTY, 0,  WQL_TOK_QSTRING,   GLEX_CONSUME,
/* 52 */   L'\\',  GLEX_EMPTY, ST_STRING2_ESC,  0,      GLEX_CONSUME,
/* 53 */   GLEX_ANY, GLEX_EMPTY, ST_STRING2, 0,        GLEX_ACCEPT,

// ST_STRING_ESC
/* 54 */   GLEX_ANY, GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,

// ST_STRING2_ESC
/* 55 */   GLEX_ANY, GLEX_EMPTY, ST_STRING2, 0, GLEX_ACCEPT,

// ST_SSTRING (Single quoted strings)
/* 56 */   L'\n', GLEX_EMPTY, 0,  WQL_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 57 */   L'\r', GLEX_EMPTY, 0,  WQL_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 58 */   L'\'',  GLEX_EMPTY, 0,  WQL_TOK_QSTRING,  GLEX_CONSUME,
/* 59 */   L'\\',  GLEX_EMPTY, ST_STRING_ESC,  0,     GLEX_CONSUME,
/* 60 */   GLEX_ANY, GLEX_EMPTY, ST_STRING, 0,        GLEX_ACCEPT,

// ST_DOT
/* 61 */  L'0',   L'9',   ST_REAL, 0,          GLEX_ACCEPT,
/* 62 */  GLEX_ANY,       GLEX_EMPTY,   0,     WQL_TOK_DOT, GLEX_PUSHBACK|GLEX_RETURN,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\wqllex.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WQLLEX.H

Abstract:

	WQL DFA Table & Tokenizer

History:

	raymcc    14-Sep-97       Created.

--*/

#ifndef _WQLLEX_H_

#include <genlex.h>
#define WQL_TOK_EOF           0
#define WQL_TOK_ERROR         1


#define WQL_TOK_SELECT                      256
#define WQL_TOK_ALL                         257
#define WQL_TOK_DISTINCT                    258
#define WQL_TOK_OPTIONS_DUMMY               259
#define WQL_TOK_ASTERISK                    260
#define WQL_TOK_COUNT                       261
#define WQL_TOK_COMMA                       262
#define WQL_TOK_OPEN_PAREN                  263
#define WQL_TOK_CLOSE_PAREN                 264
#define WQL_TOK_IDENT                       265
#define WQL_TOK_DOT                         266
#define WQL_TOK_FROM                        267
#define WQL_TOK_AS                          268
#define WQL_TOK_INNER                       269
#define WQL_TOK_FULL                        270
#define WQL_TOK_LEFT                        271
#define WQL_TOK_RIGHT                       272
#define WQL_TOK_OUTER                       273
#define WQL_TOK_JOIN                        274
#define WQL_TOK_ON                          275
#define WQL_TOK_WHERE                       276
#define WQL_TOK_GROUP                       277
#define WQL_TOK_BY                          278
#define WQL_TOK_HAVING                      279
#define WQL_TOK_ORDER                       280
#define WQL_TOK_OR                          281
#define WQL_TOK_AND                         282
#define WQL_TOK_NOT                         283
#define WQL_TOK_LE                          284
#define WQL_TOK_LT                          285
#define WQL_TOK_GE                          286
#define WQL_TOK_GT                          287
#define WQL_TOK_EQ                          288
#define WQL_TOK_NE                          289
#define WQL_TOK_LIKE                        290
#define WQL_TOK_IS                          291
#define WQL_TOK_BEFORE                      292
#define WQL_TOK_AFTER                       293
#define WQL_TOK_BETWEEN                     294
#define WQL_TOK_QSTRING                     295
#define WQL_TOK_INT                         296
#define WQL_TOK_REAL                        297
#define WQL_TOK_CHAR                        298
#define WQL_TOK_NULL                        299
#define WQL_TOK_OPEN_BRACKET                300
#define WQL_TOK_CLOSE_BRACKET               301
#define WQL_TOK_ISA                         302
#define WQL_TOK_A                           303
#define WQL_TOK_DAY                         304
#define WQL_TOK_MONTH                       305
#define WQL_TOK_YEAR                        306
#define WQL_TOK_HOUR                        307
#define WQL_TOK_MINUTE                      308
#define WQL_TOK_SECOND                      309
#define WQL_TOK_MILLISECOND                 310

#define WQL_TOK_UPPER                       311
#define WQL_TOK_LOWER                       312
#define WQL_TOK_DATEPART                    313
#define WQL_TOK_QUALIFIER                   314
#define WQL_TOK_ISNULL                      315
#define WQL_TOK_IN                          316

#define WQL_TOK_NOT_LIKE                    317
#define WQL_TOK_NOT_BEFORE                  318
#define WQL_TOK_NOT_AFTER                   319
#define WQL_TOK_NOT_BETWEEN                 320
#define WQL_TOK_NOT_NULL                    321
#define WQL_TOK_NOT_IN                      322
#define WQL_TOK_NOT_A                       323

#define WQL_TOK_TYPED_EXPR                  324


#define WQL_TOK_IN_SUBSELECT                325
#define WQL_TOK_NOT_IN_SUBSELECT            326
#define WQL_TOK_IN_CONST_LIST               327
#define WQL_TOK_NOT_IN_CONST_LIST           328

#define WQL_TOK_ASC                         329
#define WQL_TOK_DESC                        330
#define WQL_TOK_AGGREGATE                   331
#define WQL_TOK_FIRSTROW                    332

#define WQL_TOK_PROMPT                      333
#define WQL_TOK_UNION                       334
extern LexEl WQL_LexTable[];


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemtest\bstring.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    BSTRING.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include "bstring.h"

CBString::CBString(int nSize)
{
    m_pString = SysAllocStringLen(NULL, nSize);
}

CBString::CBString(WCHAR* pwszString)
{
    m_pString = SysAllocString(pwszString);
}

CBString::~CBString()
{
    if(m_pString) {
        SysFreeString(m_pString);
        m_pString = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\wstlallc.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    WSTLALLC.H

Abstract:

	WMI STL Allocator so we can throw exceptions

History:

    sanjes  16-Aug-99   Created

--*/

#ifndef __WSTLALLC_H__
#define __WSTLALLC_H__

#include <memory>
#include "corex.h"

template<class _Ty>
	class wbem_allocator {
public:
	typedef _SIZT size_type;
	typedef _PDFT difference_type;
	typedef _Ty _FARQ *pointer;
	typedef const _Ty _FARQ *const_pointer;
	typedef _Ty _FARQ& reference;
	typedef const _Ty _FARQ& const_reference;
	typedef _Ty value_type;
	pointer address(reference _X) const
		{return (&_X); }
	const_pointer address(const_reference _X) const
		{return (&_X); }
	pointer allocate(size_type _N, const void *)
		{
		_Ty _FARQ * pRet = ((_Ty _FARQ *)operator new(
		(_SIZT)_N * sizeof (_Ty)));

		if ( NULL == pRet )
		{
			throw CX_MemoryException();
		}

		return pRet; }
	char _FARQ *_Charalloc(size_type _N)
		{
		char _FARQ * pRet = ((char _FARQ *)operator new(
		(_SIZT)_N * sizeof (_Ty)));

		if ( NULL == pRet )
		{
			throw CX_MemoryException();
		}

		return pRet; }
	void deallocate(void _FARQ *_P, size_type)
		{operator delete(_P); }
	void construct(pointer _P, const _Ty& _V)
		{std::_Construct(_P, _V); }
	void destroy(pointer _P)
		{std::_Destroy(_P); }
	_SIZT max_size() const
		{_SIZT _N = (_SIZT)(-1) / sizeof (_Ty);
		return (0 < _N ? _N : 1); }
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\wqlscan.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WQLSCAN.CPP

Abstract:

    WQL Prefix Scanner

    This module implements a specially cased shift-reduce parser to
    parse out selected columns, JOINed tables and aliases, while ignoring
    the rest of the query.

History:

    raymcc    17-Oct-97       SMS extensions.

--*/


#include "precomp.h"
#include <stdio.h>

#include <flexarry.h>
#include <wqllex.h>
#include <wqlnode.h>
#include <wqlscan.h>


inline wchar_t *Macro_CloneLPWSTR(LPCWSTR src)
{
    if (!src)
        return 0;
    wchar_t *dest = new wchar_t[wcslen(src) + 1];
    if (!dest)
        return 0;
    return wcscpy(dest, src);
}

#define trace(x) printf x


class CTokenArray : public CFlexArray
{
public:
    ~CTokenArray() { Empty(); }
    void Empty()
    {
        for (int i = 0; i < Size(); i++) delete PWSLexToken(GetAt(i));
        CFlexArray::Empty();
    }
};

//***************************************************************************
//
//  CWQLScanner::CWQLScanner
//
//  Constructor
//
//  Parameters:
//  <pSrc>          A source from which to lex from.
//
//***************************************************************************

CWQLScanner::CWQLScanner(CGenLexSource *pSrc)
{
    m_pLexer = new CGenLexer(WQL_LexTable, pSrc);
    m_nLine = 0;
    m_pTokenText = 0;
    m_nCurrentToken = 0;
    m_bCount = FALSE;
}

//***************************************************************************
//
//  CWQLScanner::~CWQLScanner
//
//***************************************************************************


CWQLScanner::~CWQLScanner()
{
    delete m_pLexer;

    ClearTokens();
    ClearTableRefs();
    ClearPropRefs();
}

//***************************************************************************
//
//***************************************************************************

BOOL CWQLScanner::GetReferencedAliases(CWStringArray &aAliases)
{
    for (int i = 0; i < m_aTableRefs.Size(); i++)
    {
        WSTableRef *pTRef = (WSTableRef *) m_aTableRefs[i];
        aAliases.Add(pTRef->m_pszAlias);
    }
    return TRUE;
}
//***************************************************************************
//
//***************************************************************************

BOOL CWQLScanner::GetReferencedTables(CWStringArray &aClasses)
{
    for (int i = 0; i < m_aTableRefs.Size(); i++)
    {
        WSTableRef *pTRef = (WSTableRef *) m_aTableRefs[i];
        aClasses.Add(pTRef->m_pszTable);
    }
    return TRUE;
}

//***************************************************************************
//
//***************************************************************************
void CWQLScanner::ClearTokens()
{
    for (int i = 0; i < m_aTokens.Size(); i++)
        delete (WSLexToken *) m_aTokens[i];
}

//***************************************************************************
//
//***************************************************************************
void CWQLScanner::ClearPropRefs()
{
    for (int i = 0; i < m_aPropRefs.Size(); i++)
        delete (SWQLColRef *) m_aPropRefs[i];
}

//***************************************************************************
//
//***************************************************************************

void CWQLScanner::ClearTableRefs()
{
    for (int i = 0; i < m_aTableRefs.Size(); i++)
        delete (WSTableRef *) m_aTableRefs[i];
    m_aTableRefs.Empty();
}

//***************************************************************************
//
//  Next()
//
//  Advances to the next token and recognizes keywords, etc.
//
//***************************************************************************

struct WqlKeyword
{
    LPWSTR m_pKeyword;
    int    m_nTokenCode;
};

static WqlKeyword KeyWords[] =      // Keep this alphabetized for binary search
{
    L"ALL",      WQL_TOK_ALL,
    L"AND",      WQL_TOK_AND,
    L"AS",       WQL_TOK_AS,
    L"BETWEEN",  WQL_TOK_BETWEEN,
    L"BY",       WQL_TOK_BY,
    L"COUNT",    WQL_TOK_COUNT,
    L"DATEPART", WQL_TOK_DATEPART,
    L"DISTINCT", WQL_TOK_DISTINCT,
    L"FIRSTROW", WQL_TOK_FIRSTROW,
    L"FROM",     WQL_TOK_FROM,
    L"FULL",     WQL_TOK_FULL,
    L"GROUP",    WQL_TOK_GROUP,
    L"HAVING",   WQL_TOK_HAVING,
    L"IN",       WQL_TOK_IN,
    L"INNER",    WQL_TOK_INNER,
    L"IS",       WQL_TOK_IS,
    L"ISA",      WQL_TOK_ISA,
    L"ISNULL",   WQL_TOK_ISNULL,
    L"JOIN",     WQL_TOK_JOIN,
    L"LEFT",     WQL_TOK_LEFT,
    L"LIKE",     WQL_TOK_LIKE,
    L"LOWER",    WQL_TOK_LOWER,
    L"NOT",      WQL_TOK_NOT,
    L"NULL",     WQL_TOK_NULL,
    L"ON",       WQL_TOK_ON,
    L"OR",       WQL_TOK_OR,
    L"ORDER",    WQL_TOK_ORDER,
    L"OUTER",    WQL_TOK_OUTER,
    L"QUALIFIER", WQL_TOK_QUALIFIER,
    L"RIGHT",    WQL_TOK_RIGHT,
    L"SELECT",   WQL_TOK_SELECT,
    L"UNION",    WQL_TOK_UNION,
    L"UPPER",    WQL_TOK_UPPER,
    L"WHERE",    WQL_TOK_WHERE

};

const int NumKeywords = sizeof(KeyWords)/sizeof(WqlKeyword);

BOOL CWQLScanner::Next()
{
    if (!m_pLexer)
        return FALSE;

    m_nCurrentToken = m_pLexer->NextToken();
    if (m_nCurrentToken == WQL_TOK_ERROR)
        return FALSE;

    m_nLine = m_pLexer->GetLineNum();
    m_pTokenText = m_pLexer->GetTokenText();
    if (m_nCurrentToken == WQL_TOK_EOF)
        m_pTokenText = L"<end of file>";

    // Keyword check. Do a binary search
    // on the keyword table.
    // =================================

    if (m_nCurrentToken == WQL_TOK_IDENT)
    {
        int l = 0, u = NumKeywords - 1;

        while (l <= u)
        {
            int m = (l + u) / 2;
            if (_wcsicmp(m_pTokenText, KeyWords[m].m_pKeyword) < 0)
                u = m - 1;
            else if (_wcsicmp(m_pTokenText, KeyWords[m].m_pKeyword) > 0)
                l = m + 1;
            else        // Match
            {
                m_nCurrentToken = KeyWords[m].m_nTokenCode;
                break;
            }
        }
    }

    return TRUE;
}

//***************************************************************************
//
//  CWQLScanner::ExtractNext
//
//***************************************************************************

PWSLexToken CWQLScanner::ExtractNext(BOOL bRemove)
{
    if (m_aTokens.Size() == 0)
        return NULL;

    PWSLexToken pTok = PWSLexToken(m_aTokens[0]);
    if (bRemove)
        m_aTokens.RemoveAt(0);
    return pTok;
}

//***************************************************************************
//
//  CWQLScanner::Pushback
//
//***************************************************************************

int CWQLScanner::Pushback(PWSLexToken pPushbackTok)
{
    return m_aTokens.InsertAt(0, pPushbackTok);
}

//***************************************************************************
//
//  Shift-reduce parser entry.
//
//***************************************************************************

int CWQLScanner::Parse()
{
    int nRes = SYNTAX_ERROR;
    if (m_pLexer == NULL)
        return FAILED;

    m_pLexer->Reset();

    if (!Next())
        return LEXICAL_ERROR;


    // Completely tokenize the entire query and build a parse-stack.
    // =============================================================

    if (m_nCurrentToken == WQL_TOK_SELECT)
    {
        while (1)
        {
            WSLexToken *pTok = new WSLexToken;
            if (!pTok)
                return FAILED;

            pTok->m_nToken = m_nCurrentToken;
            pTok->m_pszTokenText = Macro_CloneLPWSTR(m_pTokenText);
            if (!pTok->m_pszTokenText)
                return FAILED;

            if (m_aTokens.Add(pTok))
            {
                delete pTok;
                return FAILED;
            }

            if (m_nCurrentToken == WQL_TOK_EOF)
                break;

            if (!Next())
                return LEXICAL_ERROR;
        }
    }
    else
        return SYNTAX_ERROR;

    // Reduce by extracting the select type keywords if possible.
    // ==========================================================

    nRes = ExtractSelectType();
    if (nRes)
        return nRes;

    // Eliminate all tokens from WHERE onwards.
    // ========================================

    StripWhereClause();

    // Reduce by extracting the select list.
    // =====================================

    if (!m_bCount)
    {
        nRes = SelectList();
        if (nRes != 0)
            return nRes;
    }
    else
    {
        // Strip everything until the FROM keyword is encountered.
        // =======================================================

        WSLexToken *pTok = ExtractNext(FALSE);
        if (pTok->m_nToken != WQL_TOK_OPEN_PAREN)
        {
            nRes = SelectList();
            if (nRes )
                return nRes;
        }
        else
        {
            pTok = ExtractNext();
            while (pTok)
            {
                if (pTok->m_nToken == WQL_TOK_FROM)
                {
                    if (Pushback(pTok))
                    {
                        delete pTok;
                        return FAILED;
                    }
                    break;
                }
                // Bug #46728: the count(*) clause
                // can be the only element of the select clause.

                else if (!wcscmp(pTok->m_pszTokenText, L","))
                {
                    delete pTok;
                    return SYNTAX_ERROR;
                }

                delete pTok;
                pTok = ExtractNext();
            }
            if (pTok == 0)
                return SYNTAX_ERROR;
        }
    }

    // Extract tables/aliases from JOIN clauses.
    // =========================================

    if (ReduceSql89Joins() != TRUE)
    {
        ClearTableRefs();
        if (ReduceSql92Joins() != TRUE)
            return SYNTAX_ERROR;
    }


    // Post process select clause to determine if
    // columns are tables or aliases.
    // ==========================================
    for (int i = 0; i < m_aPropRefs.Size(); i++)
    {
        SWQLColRef *pCRef = (SWQLColRef *) m_aPropRefs[i];
        if (pCRef->m_pTableRef != 0)
        {
            LPWSTR pTbl = AliasToTable(pCRef->m_pTableRef);
            if (pTbl == 0)
                continue;

            if (_wcsicmp(pTbl, pCRef->m_pTableRef) == 0)
                pCRef->m_dwFlags |= WQL_FLAG_TABLE;
            else
                pCRef->m_dwFlags |= WQL_FLAG_ALIAS;
        }
    }


    if (m_aTableRefs.Size() == 0)
        return SYNTAX_ERROR;


    return SUCCESS;
}

//***************************************************************************
//
//  CWQLScanner::StripWhereClause
//
//  If present, removes the WHERE or ORDER BY clause.  Because
//  of SQL Syntax, stripping the first of {ORDER BY, WHERE} will automatically
//  get rid of the other.
//
//***************************************************************************
BOOL CWQLScanner::StripWhereClause()
{
    for (int i = 0; i < m_aTokens.Size(); i++)
    {
        WSLexToken *pCurrent = (WSLexToken *) m_aTokens[i];

        // If a WHERE token is found, we have something to strip.
        // ======================================================

        if (pCurrent->m_nToken == WQL_TOK_WHERE ||
            pCurrent->m_nToken == WQL_TOK_ORDER)
        {
            int nNumTokensToRemove = m_aTokens.Size() - i - 1;
            for (int i2 = 0; i2 < nNumTokensToRemove; i2++)
            {
                delete PWSLexToken(m_aTokens[i]);
                m_aTokens.RemoveAt(i);
            }
            return TRUE;
        }
    }

    return FALSE;
}


//***************************************************************************
//
//  CWQLScanner::ExtractSelectType
//
//  Examines the prefix to reduce the query by eliminating the SELECT
//  and select-type keywords, such as ALL, DISTINCT, FIRSTROW, COUNT
//
//  If COUNT is used, move past the open-close parentheses.
//
//***************************************************************************

int CWQLScanner::ExtractSelectType()
{
    // Verify that SELECT is the first token.
    // ======================================

    WSLexToken *pFront = ExtractNext();

    if (pFront == 0 || pFront->m_nToken == WQL_TOK_EOF)
    {
        delete pFront;
        return SYNTAX_ERROR;
    }

    if (pFront->m_nToken != WQL_TOK_SELECT)
    {
        delete pFront;
        return SYNTAX_ERROR;
    }

    delete pFront;

    // Check for possible select-type and extract it.
    // ==============================================

    pFront = ExtractNext();
    if (pFront == 0)
        return SYNTAX_ERROR;

    if (pFront->m_nToken == WQL_TOK_COUNT)
    {
        delete pFront;
        m_bCount = TRUE;
    }
    else if (pFront->m_nToken == WQL_TOK_ALL ||
        pFront->m_nToken == WQL_TOK_DISTINCT ||
        pFront->m_nToken == WQL_TOK_FIRSTROW
       )
        delete pFront;
    else
    {
        if (Pushback(pFront))
        {
            delete pFront;
            return FAILED;
        }
    }

    return SUCCESS;
}

//***************************************************************************
//
//  CWQLScanner::SelectList
//
//  Extracts all tokens up to the FROM keyword and builds a list
//  of selected properties/columns.  FROM is left on the parse-stack on exit.
//
//***************************************************************************

int CWQLScanner::SelectList()
{
    // If the first token is FROM, then we have a SELECT FROM <rest>
    // which is the same as SELECT * FROM <rest>.  We simply
    // alter the parse-stack and let the following loop handle it.
    // =============================================================

    WSLexToken *pTok = ExtractNext();

    if (!pTok)
        return SYNTAX_ERROR;

    if (pTok->m_nToken == WQL_TOK_FROM)
    {
        WSLexToken *pAsterisk = new WSLexToken;
        if (pAsterisk == NULL)
            return FAILED;

        pAsterisk->m_nToken = WQL_TOK_ASTERISK;
        pAsterisk->m_pszTokenText = Macro_CloneLPWSTR(L"*");
        if (!pAsterisk->m_pszTokenText)
            return FAILED;
        if (Pushback(pTok))
        {
            delete pTok;
            delete pAsterisk;
            return FAILED;
        }
        if (Pushback(pAsterisk))
        {
            delete pAsterisk;
            return FAILED;
        }
    }
    else
    {
        if (Pushback(pTok))
        {
            delete pTok;
            return FAILED;
        }
    }

    // Otherwise, some kind of column selection is present.
    // ====================================================

    BOOL bTerminate = FALSE;

    while (!bTerminate)
    {
        pTok = ExtractNext();
        if (pTok == 0)
            return SYNTAX_ERROR;

        // We must begin at a legal token.
        // ===============================

        if (pTok->m_nToken != WQL_TOK_EOF)
        {
            CTokenArray Tokens;
            if (Tokens.Add(pTok))
            {
                delete pTok;
                return FAILED;
            }

            while (1)
            {
                pTok = ExtractNext();
                if (pTok == 0 || pTok->m_nToken == WQL_TOK_EOF)
                {
                    delete pTok;
                    return SYNTAX_ERROR;
                }
                if (pTok->m_nToken == WQL_TOK_FROM)
                {
                    if (Pushback(pTok))
                    {
                        delete pTok;
                        return FAILED;
                    }

                    bTerminate = TRUE;
                    break;
                }
                else if (pTok->m_nToken == WQL_TOK_COMMA)
                {
                    delete pTok;
                    break;
                }
                else
                {
                    if (Tokens.Add(pTok))
                    {
                        delete pTok;
                        return FAILED;
                    }
                }
            }

            SWQLColRef *pColRef = new SWQLColRef;
            if (pColRef == 0)
                return FAILED;

            BOOL bRes = BuildSWQLColRef(Tokens, *pColRef);
            if (bRes)
            {
                if (m_aPropRefs.Add(pColRef))
                {
                    delete pColRef;
                    return FAILED;
                }
            }
            else
            {
                delete pColRef;
                return SYNTAX_ERROR;
            }
        }

        // Else an illegal token, such as WQL_TOK_EOF.
        // ===========================================
        else
        {
            delete pTok;
            return SYNTAX_ERROR;

        }
    }

    return SUCCESS;
}



//***************************************************************************
//
//  CWQLScanner::ReduceSql89Joins
//
//  Attempts to reduce the FROM clause, assuming it is based on SQL-89
//  join syntax or else a simple unary select.
//
//  The supported forms are:
//
//      FROM x
//      FROM x, y
//      FROM x as x1, y as y1
//      FROM x x1, y y1
//
//  If incompatible tokens are encountered, the entire function
//  returns FALSE and the results are ignored, and the parse-stack
//  is unaffected, in essence, allowing backtracking to try the SQL-92
//  syntax branch instead.
//
//***************************************************************************
BOOL CWQLScanner::ReduceSql89Joins()
{
    int i = 0;

    // Parse the FROM keyword.
    // =======================

    WSLexToken *pCurr = (WSLexToken *) m_aTokens[i++];
    if (pCurr->m_nToken != WQL_TOK_FROM)
        return FALSE;

    pCurr = (WSLexToken *) m_aTokens[i++];

    while (1)
    {
        if (pCurr->m_nToken != WQL_TOK_IDENT)
            return FALSE;

        // If here, we are looking at the beginnings of a table ref.
        // =========================================================

        WSTableRef *pTRef = new WSTableRef;
        if (pTRef == 0)
            return FAILED;

        pTRef->m_pszTable = Macro_CloneLPWSTR(pCurr->m_pszTokenText);
        if (!pTRef->m_pszTable)
            return FAILED;
        pTRef->m_pszAlias = Macro_CloneLPWSTR(pCurr->m_pszTokenText);
        if (!pTRef->m_pszAlias)
            return FAILED;
        if (m_aTableRefs.Add(pTRef))
        {
            delete pTRef;
            return FAILED;
        }

        // Attempt to recognize an alias.
        // ==============================

        pCurr = (WSLexToken *) m_aTokens[i++];
        if (pCurr == WQL_TOK_EOF || pCurr->m_nToken == WQL_TOK_UNION)
            break;

        if (pCurr->m_nToken == WQL_TOK_AS)
            pCurr = (WSLexToken *) m_aTokens[i++];

        if (pCurr->m_nToken == WQL_TOK_COMMA)
        {
            pCurr = (WSLexToken *) m_aTokens[i++];
            continue;
        }

        if (pCurr->m_nToken == WQL_TOK_EOF || pCurr->m_nToken == WQL_TOK_UNION)
            break;

        if (pCurr->m_nToken != WQL_TOK_IDENT)
            return FALSE;

        delete [] pTRef->m_pszAlias;
        pTRef->m_pszAlias = Macro_CloneLPWSTR(pCurr->m_pszTokenText);
        if (!pTRef->m_pszAlias)
            return FALSE;

        // We have completely parsed a table reference.
        // Now we move on to the next one.
        // ============================================

        pCurr = (WSLexToken *) m_aTokens[i++];

        if (pCurr->m_nToken == WQL_TOK_EOF || pCurr->m_nToken == WQL_TOK_UNION)
            break;

        if (pCurr->m_nToken != WQL_TOK_COMMA)
            return FALSE;

        pCurr = (WSLexToken *) m_aTokens[i++];
    }

    if (m_aTableRefs.Size())
        return TRUE;

    return FALSE;
}

//***************************************************************************
//
//  CWQLScanner::ReduceSql92Joins
//
//  This scans SQL-92 JOIN syntax looking for table aliases.   See the
//  algorithm at the end of this file.
//
//***************************************************************************

BOOL CWQLScanner::ReduceSql92Joins()
{
    WSLexToken *pCurrent = 0, *pRover = 0, *pRight = 0, *pLeft;
    int nNumTokens = m_aTokens.Size();
    DWORD dwNumJoins = 0;
    int iCurrBase = 0;

    for (int i = 0; i < nNumTokens; i++)
    {
        pCurrent = (WSLexToken *) m_aTokens[i];

        // If a JOIN token is found, we have a candidate.
        // ==============================================

        if (pCurrent->m_nToken == WQL_TOK_JOIN)
        {
            dwNumJoins++;

            // Analyze right-context.
            // ======================

            if (i + 1 < nNumTokens)
                pRover = PWSLexToken(m_aTokens[i + 1]);
            else
                pRover = NULL;

            if (pRover && pRover->m_nToken == WQL_TOK_IDENT)
            {
                // Check for aliased table by checking for
                // AS or two juxtaposed idents.
                // =======================================

                if (i + 2 < nNumTokens)
                    pRight = PWSLexToken(m_aTokens[i + 2]);
                else
                    pRight = NULL;


                if (pRight && pRight->m_nToken == WQL_TOK_AS)
                {
                    if (i + 3 < nNumTokens)
                        pRight = PWSLexToken(m_aTokens[i + 3]);
                    else
                        pRight = NULL;
                }

                if (pRight && pRight->m_nToken == WQL_TOK_IDENT)
                {
                    WSTableRef *pTRef = new WSTableRef;
                    if (pTRef == 0)
                        return FAILED;
                    pTRef->m_pszAlias = Macro_CloneLPWSTR(pRight->m_pszTokenText);
                    if (!pTRef->m_pszAlias)
                        return FAILED;
                    pTRef->m_pszTable = Macro_CloneLPWSTR(pRover->m_pszTokenText);
                    if (!pTRef->m_pszTable)
                        return FAILED;
                    if (m_aTableRefs.Add(pTRef))
                    {
                        delete pTRef;
                        return FAILED;
                    }
                }
                else    // An alias wasn't used, just a simple table ref.
                {
                    WSTableRef *pTRef = new WSTableRef;
                    if (pTRef == 0)
                        return FAILED;

                    pTRef->m_pszAlias = Macro_CloneLPWSTR(pRover->m_pszTokenText);
                    if (!pTRef->m_pszAlias)
                        return FAILED;                        
                    pTRef->m_pszTable = Macro_CloneLPWSTR(pRover->m_pszTokenText);
                    if (!pTRef->m_pszTable)
                        return FAILED;
                    if (m_aTableRefs.Add(pTRef))
                    {
                        delete pTRef;
                        return FAILED;
                    }
                }
                // discontinue analysis of right-context.
            }


            // Analyze left-context.
            // =====================

            int nLeft = i - 1;

            if (nLeft >= 0)
                pRover = PWSLexToken(m_aTokens[nLeft--]);
            else
                continue;   // No point in continuing

            // Verify the ANSI join syntax.

            if (nLeft)
            {
                int iTemp = nLeft;
                WSLexToken *pTemp = pRover;
                bool bInner = false;
                bool bDir = false;
                bool bOuter = false;
                bool bFail = false;
                bool bIdent = false;
                while (iTemp >= iCurrBase)
                {
                    if (pTemp->m_nToken == WQL_TOK_INNER)
                    {
                        if (bOuter || bIdent || bInner)
                            bFail = TRUE;
                        bInner = true;
                    }
                    else if (pTemp->m_nToken == WQL_TOK_OUTER)
                    {
                        if (bInner || bIdent || bOuter)
                            bFail = TRUE;
                        bOuter = true;
                    }
                    else if (pTemp->m_nToken == WQL_TOK_FULL  ||
                        pTemp->m_nToken == WQL_TOK_LEFT  ||
                        pTemp->m_nToken == WQL_TOK_RIGHT
                        )
                    {
                        if (bDir || bIdent)
                            bFail = TRUE;
                        bDir = true;
                    }
                    else
                        bIdent = TRUE;

                    // We are trying to enforce correct ANSI-92 joins
                    // even though we don't support them ourselves:
                    // OK:  LEFT OUTER JOIN
                    //      OUTER LEFT JOIN
                    //      LEFT JOIN
                    //      INNER JOIN
                    // NOT: LEFT LEFT JOIN
                    //      LEFT INNER JOIN
                    //      LEFT RIGHT JOIN
                    //      OUTER INNER JOIN
                    //      OUTER LEFT OUTER JOIN
                    //      OUTER GARBAGE LEFT JOIN
                    //      (no right side)

                    if ((bDir && bInner) || bFail)
                        return FALSE;

                    pTemp = PWSLexToken(m_aTokens[iTemp--]);
                }

            }

            // Skip past potential JOIN modifiers : INNER, OUTER,
            // FULL, LEFT, RIGHT
            // ==================================================

            if (pRover->m_nToken == WQL_TOK_INNER ||
                pRover->m_nToken == WQL_TOK_OUTER ||
                pRover->m_nToken == WQL_TOK_FULL  ||
                pRover->m_nToken == WQL_TOK_LEFT  ||
                pRover->m_nToken == WQL_TOK_RIGHT
                )
            {
                if (nLeft >= 0)
                    pRover = PWSLexToken(m_aTokens[nLeft--]);
                else
                    pRover = 0;
            }

            if (pRover->m_nToken == WQL_TOK_INNER ||
                pRover->m_nToken == WQL_TOK_OUTER ||
                pRover->m_nToken == WQL_TOK_FULL  ||
                pRover->m_nToken == WQL_TOK_LEFT  ||
                pRover->m_nToken == WQL_TOK_RIGHT
                )
            {
                if (nLeft >= 0)
                    pRover = PWSLexToken(m_aTokens[nLeft--]);
                else
                    pRover = 0;
            }

            // Now we look to see if the roving pointer is pointing
            // to an ident.
            // ====================================================

            if (pRover && pRover->m_nToken != WQL_TOK_IDENT)
            {
                // No chance that we are looking at an aliased
                // table in a JOIN clause.
                // ===========================================
                continue;
            }

            iCurrBase = i;

            // If here, we are now possibliy looking at the second half
            // of an alias, the 'alias' name proper.  We mark this
            // by leaving pRover alone and continue to move into the
            // left context with a different pointer.
            // ========================================================

            if (nLeft >= 0)
                pLeft = PWSLexToken(m_aTokens[nLeft--]);
            else
                pLeft = 0;

            if (pLeft && pLeft->m_nToken == WQL_TOK_AS)
            {
                if (nLeft >= 0)
                    pLeft = PWSLexToken(m_aTokens[nLeft--]);
                else
                    pLeft = 0;
            }

            // The critical test.  Are we at an ident?
            // =======================================

            if (pLeft && pLeft->m_nToken == WQL_TOK_IDENT)
            {
                WSTableRef *pTRef = new WSTableRef;
                if (pTRef == 0)
                    return FAILED;

                pTRef->m_pszAlias = Macro_CloneLPWSTR(pRover->m_pszTokenText);
                if (!pTRef->m_pszAlias)
                    return FAILED;
                pTRef->m_pszTable = Macro_CloneLPWSTR(pLeft->m_pszTokenText);
                if (!pTRef->m_pszTable)
                    return FAILED;
                if (m_aTableRefs.Add(pTRef))
                {
                    delete pTRef;
                    return FAILED;
                }
            }
            else if (pLeft && pLeft->m_nToken == WQL_TOK_FROM)
            {
                WSTableRef *pTRef = new WSTableRef;
                if (pTRef == 0)
                    return FAILED;

                pTRef->m_pszAlias = Macro_CloneLPWSTR(pRover->m_pszTokenText);
                if (!pTRef->m_pszAlias)
                    return FAILED;
                pTRef->m_pszTable = Macro_CloneLPWSTR(pRover->m_pszTokenText);
                if (!pTRef->m_pszTable)
                    return FAILED;
                if (m_aTableRefs.Add(pTRef))
                {
                    delete pTRef;
                    return FAILED;
                }

                if (nLeft >= 0)
                {
                    pLeft = PWSLexToken(m_aTokens[nLeft--]);
                    if (pLeft && pLeft->m_nToken == WQL_TOK_FROM)
                        return FALSE;
                }
            }
        }

        // Find next JOIN occurrence
    }

    // Make sure there are two sides to every join reference.

    if (dwNumJoins+1 != (DWORD)m_aTableRefs.Size())
        return FALSE;

    return TRUE;
}


//***************************************************************************
//
//***************************************************************************
void CWQLScanner::Dump()
{
    WSLexToken *pCurrent = 0;

    printf("---Token Stream----\n");

    for (int i = 0; i < m_aTokens.Size(); i++)
    {
        pCurrent = (WSLexToken *) m_aTokens[i];

        printf("Token %d <%S>\n", pCurrent->m_nToken, pCurrent->m_pszTokenText);
    }

    printf("---Table Refs---\n");

    for (i = 0; i < m_aTableRefs.Size(); i++)
    {
        WSTableRef *pTRef = (WSTableRef *) m_aTableRefs[i];
        printf("Table = %S  Alias = %S\n", pTRef->m_pszTable, pTRef->m_pszAlias);
    }


    if (!m_bCount)
    {
        printf("---Select List---\n");

        for (i = 0; i < m_aPropRefs.Size(); i++)
        {
            SWQLColRef *pCRef = (SWQLColRef *) m_aPropRefs[i];
            pCRef->DebugDump();
        }
    }
    else
        printf(" -> COUNT query\n");

    printf("\n\n---<end of dump>---\n\n");
}


/*---------------------------------------------------------------------------

   Algorithm for detecting aliased tables in SQL-92 join syntax.

   The JOIN keyword must appear.

   It may appear in several contexts which are not
   relevant to the aliasing problem, such as the following:

     select distinct t1a.name, t2a.id, t3.value from
       (t1 as t1a join t2 as t2a on t1a.name = t2a.name)
       join
       (t1 as t1b join t3 on t1b.id = t3.id and (t3.id = t1b.id or t1b.id = t3.id))
       on
       t1a.id = t3.id
     where a = b and c = d

   where the middle join is against anonymous result sets.

   When analyzing the JOIN, we can easily parse the right-context.  Either
   an identifier follows (possibly further followed by AS),and an optional
   identifier if the JOIN is aliased.  Otherwise, we hit ON immediately, or
   a parenthesis.

   The problem is the left-context of the JOIN token.

   For an alias to occur, an identifier must appear immediately to
   the left of the JOIN.

     id JOIN id2 as id3 ON ...
     ^

   If here, there is a chance we are looking at the left hand side of a
   SQL92 join, a table reference.  However, we might be looking at the end of
   an ON clause which ends in an identifier:

     idx = id JOIN id2 as id3 ON...
         ^
   To disambiguate, we have to do further analysis of left context.

   Consider the follow left-context possibilities:

        (1) t1 AS id JOIN id2 as id3 ON
               ^
        (2) t1 id JOIN id2 as id3 ON
            ^
        (3) <keyword (except AS)> id JOIN id2 as id3 ON
             ^
        (4) on x <rel op> id JOIN id2 as id3 ON
                  ^

   Once we have identified <id>, we have to consider the above cases.

   (1) Case 1 is easy.  An AS clearly tells us we have an alias
       and we know how to get at the table and alias names.

   (2) Case 2 is easy.  Two juxtaposed identifiers to the left always
       indicates an alias.

   In all other cases, like (3) and (4), etc., the table is not
   aliased anyway.  Therefore, we only have to determine whether we
   are looking at an unaliased table name or the trailing end of
   another construct like an ON clause.  This is easy.  Only the
   FROM keyword can precede <id> if <id> is a simple table name.

---------------------------------------------------------------------------
*/


//***************************************************************************
//
//  CWQLScanner::BuildSWQLColRef
//
//***************************************************************************

BOOL CWQLScanner::BuildSWQLColRef(
    IN  CFlexArray     &aTokens,
    IN OUT SWQLColRef  &ColRef      // Empty on entry
    )
{
    if (aTokens.Size() == 0)
        return FALSE;
    int nCurrent = 0;
    WSLexToken *pTok = PWSLexToken(aTokens[nCurrent++]);

    // Initial state: single asterisk or else prop name.
    // =================================================

    if (pTok->m_nToken == WQL_TOK_ASTERISK && aTokens.Size() == 1)
    {
        ColRef.m_pColName = Macro_CloneLPWSTR(L"*");
        if (!ColRef.m_pColName)
            return FALSE;
        ColRef.m_dwFlags = WQL_FLAG_ASTERISK;
        ColRef.m_pQName = new SWQLQualifiedName;
        if (ColRef.m_pQName == 0)
            return FALSE;
        SWQLQualifiedNameField *pField = new SWQLQualifiedNameField;
        if (pField == 0)
            return FALSE;

        pField->m_pName = Macro_CloneLPWSTR(L"*");
        if (!pField->m_pName)
            return FALSE;
        if (ColRef.m_pQName->Add(pField))
        {
            delete pField;
            return FALSE;
        }

        return TRUE;
    }

    // If not an identifier, we have an error.
    // =======================================

    else if (pTok->m_nToken == WQL_TOK_EOF)
        return FALSE;

    // If here, we have an identifier.
    // ===============================

    ColRef.m_pQName = new SWQLQualifiedName;
    if (ColRef.m_pQName == NULL)
        return FALSE;
    SWQLQualifiedNameField *pField = new SWQLQualifiedNameField;
    if (pField == 0)
        return FALSE;

    pField->m_pName = Macro_CloneLPWSTR(pTok->m_pszTokenText);
    if (!pField->m_pName)
         return FALSE;
    if (ColRef.m_pQName->Add(pField))
    {
        delete pField;
        return FALSE;
    }

    // Subsequent states.
    // ==================

    while (1)
    {
        if (nCurrent == aTokens.Size())
            break;

        pTok = PWSLexToken(aTokens[nCurrent++]);

        if (pTok->m_nToken == WQL_TOK_DOT)
        {
            pField = new SWQLQualifiedNameField;
            if (pField == 0)
                return FALSE;

            if (ColRef.m_pQName->Add(pField))
            {
                delete pField;
                return FALSE;
            }

            if (nCurrent == aTokens.Size())
                return FALSE;
            pTok = PWSLexToken(aTokens[nCurrent++]);
            if (pTok->m_nToken != WQL_TOK_IDENT &&
                pTok->m_nToken != WQL_TOK_ASTERISK
                )
                return FALSE;

            pField->m_pName = Macro_CloneLPWSTR(pTok->m_pszTokenText);
            if (!pField->m_pName)
                return FALSE;
        }
        else if (pTok->m_nToken == WQL_TOK_OPEN_BRACKET)
        {
            return FALSE; // Not supported at present!
        }
        else // illegal token
            return FALSE;
    }

    // Post-process.  If the name is not complex, then we
    // can fill out fields of ColRef.
    // ==================================================
    if (ColRef.m_pQName->GetNumNames() == 2)
    {
        ColRef.m_pTableRef = Macro_CloneLPWSTR(ColRef.m_pQName->GetName(0));
        if (!ColRef.m_pTableRef)
            return FALSE;
        ColRef.m_pColName  = Macro_CloneLPWSTR(ColRef.m_pQName->GetName(1));
        if (!ColRef.m_pColName)
            return FALSE;
        if (_wcsicmp(ColRef.m_pColName, L"NULL") == 0)
            ColRef.m_dwFlags |= WQL_FLAG_NULL;
    }
    else if (ColRef.m_pQName->GetNumNames() == 1)
    {
        LPWSTR pName = ColRef.m_pQName->GetName(0);
        ColRef.m_pColName  = Macro_CloneLPWSTR(pName);
        if (!ColRef.m_pColName)
            return FALSE;
        if (0 == _wcsicmp(ColRef.m_pColName, L"NULL"))
            ColRef.m_dwFlags |= WQL_FLAG_NULL;
    }
    else
    {
        ColRef.m_pTableRef = Macro_CloneLPWSTR(ColRef.m_pQName->GetName(0));
        if (!ColRef.m_pTableRef)
            return FALSE;
        
        ColRef.m_dwFlags = WQL_FLAG_COMPLEX_NAME;
    }

    return TRUE;
}




const LPWSTR CWQLScanner::AliasToTable(LPWSTR pszAlias)
{
    if (pszAlias == 0)
        return 0;

    for (int i = 0; i < m_aTableRefs.Size(); i++)
    {
        WSTableRef *pTRef = (WSTableRef *) m_aTableRefs[i];
        if (_wcsicmp(pszAlias, pTRef->m_pszAlias) == 0)
            return pTRef->m_pszTable;

        if (_wcsicmp(pszAlias, pTRef->m_pszTable) == 0)
            return pTRef->m_pszTable;
    }

    return 0;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\wqlscan.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    WQLSCAN.H

Abstract:

    WQL Prefix Scanner

History:

	raymcc  26-Mar-98

--*/

#ifndef _WQLSCAN_H_
#define _WQLSCAN_H_


struct WSLexToken
{
    int      m_nToken;
    wchar_t *m_pszTokenText;

    WSLexToken() { m_pszTokenText = 0; }
    ~WSLexToken() { delete [] m_pszTokenText; }
};

typedef WSLexToken *PWSLexToken;

struct WSTableRef
{
    wchar_t *m_pszTable;    
    wchar_t *m_pszAlias;    // Can be NULL if no alias specified

    WSTableRef() { m_pszTable = m_pszAlias = 0; }
   ~WSTableRef() { delete [] m_pszTable; delete [] m_pszAlias; }
};

typedef WSTableRef * PWSTableRef;

class POLARITY CWQLScanner
{
    // Data.
    // =====

    CGenLexer    *m_pLexer;
    int           m_nLine;
    wchar_t      *m_pTokenText;
    int           m_nCurrentToken;
    BOOL          m_bCount;

    CFlexArray m_aTokens;       // Array of ptrs to WSLexToken structs.
    CFlexArray m_aPropRefs;     // Array of ptrs to SWQLColRef structs.
    CFlexArray m_aTableRefs;    // Ptrs to WSTableRef structs.
    
    // Local functions.
    // ==================

    BOOL Next();
    PWSLexToken ExtractNext(BOOL bRemoveToken = TRUE);
    int Pushback(PWSLexToken);

    BOOL StripWhereClause();
    BOOL SelectList();
    BOOL ReduceSql92Joins();
    BOOL ReduceSql89Joins();
    BOOL ExtractSelectType();

    void ClearTableRefs();
    void ClearPropRefs();
    void ClearTokens();

    BOOL BuildSWQLColRef(
        CFlexArray &aTokens,
        SWQLColRef  &ColRef      // Empty on entry
        );

public:
    enum { 
        SUCCESS,
        SYNTAX_ERROR,
        LEXICAL_ERROR,
        FAILED,
        BUFFER_TOO_SMALL,
        INVALID_PARAMETER,
        INTERNAL_ERROR
    };

    const LPWSTR AliasToTable(LPWSTR pszAlias);

    BOOL GetReferencedAliases(CWStringArray &aClasses);
    BOOL GetReferencedTables(CWStringArray &aClasses);
    BOOL CountQuery() {return m_bCount;}

    CWQLScanner(CGenLexSource *pSrc);
   ~CWQLScanner(); 
    int Parse();
    
    void Dump();

    const CFlexArray *GetSelectedColumns() { return &m_aPropRefs; }
        // Returns pointer to array of SWQLColRef*

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\wqltest.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WQLTEST.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <stdio.h>

#include <genlex.h>

#include <flexarry.h>

#include <wqllex.h>
#include <wqlnode.h>
#include <wqlscan.h>




void xmain(int argc, char **argv)
{
    if (argc < 2)
    {
        printf("No SQL query specified\n");
        return;
    }

    char buf[8192];

    FILE *f = fopen(argv[1], "rt");
    int nCnt = fread(buf, 1, 8192, f);
    fclose(f);

    buf[nCnt] = 0;

    wchar_t buf2[8192];
    MultiByteToWideChar(CP_ACP, 0, buf, -1, buf2, 8192); 

    CTextLexSource src(buf2);

    CWQLScanner parser(&src);

    int nRes = parser.Parse();

    if (nRes)
    {
        printf("ERROR: %d\n", nRes);
    }
    else
    {
        printf("No errors.\n");
        parser.Dump();
    }
}

void main(int argc, char **argv)
{
    for (;;)
    {
        Sleep(500);
        xmain(argc, argv);
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemtest\bstring.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    BSTRING.H

Abstract:

History:

--*/

#ifndef _BSTRING_H_
#define _BSTRING_H_

class CBString
{
private:
    BSTR    m_pString;


public:
    CBString()
    {
        m_pString = NULL;
    }

    CBString(int nSize);

    CBString(WCHAR* pwszString);

    ~CBString();

    BSTR GetString()
    {
        return m_pString;
    }

    const CBString& operator=(LPWSTR pwszString)
    {
        if(m_pString) {
            SysFreeString(m_pString);
        }
        m_pString = SysAllocString(pwszString);

        return *this;
    }
};

#endif // _BSTRING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemtest\localloc.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include <arena.h>

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\wstring.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WSTRING.H

Abstract:

    Utility string class

History:

    a-raymcc    30-May-96       Created.
    a-dcrews    16-Mar-99       Added out-of-memory exception handling

--*/

#ifndef _WSTRING_H_
#define _WSTRING_H_

#include "corepol.h"
#include <strutils.h>

class POLARITY WString
{
private:
    wchar_t *m_pString;

    void DeleteString(wchar_t *pStr);

public:
    enum { leading = 0x1, trailing = 0x2 };

    WString(wchar_t *pSrc, BOOL bAcquire = FALSE);
    WString(DWORD dwResourceID, HMODULE hMod);      // creates from resource string
    WString(const wchar_t *pSrc);
    WString(const char *pSrc);
//    inline WString() { m_pString = g_szNullString; }
    WString();
    inline WString(const WString &Src) {  m_pString = 0; *this = Src; }
    WString& operator =(const WString &);
    WString& operator =(LPCWSTR);
   inline ~WString() { DeleteString(m_pString); }
    inline int Length() const { return wcslen(m_pString); }

    WString& operator +=(const WString &Other);
    WString& operator +=(const wchar_t *);
    WString& operator +=(wchar_t);
    
    inline operator const wchar_t *() const { return m_pString; } 
    inline operator wchar_t *() { return m_pString; } 
    wchar_t operator[](int nIndex) const;
    LPSTR GetLPSTR() const;

    inline BOOL Equal(const wchar_t *pTarget) const
        { return wcscmp(m_pString, pTarget) == 0; }
    inline BOOL EqualNoCase(const wchar_t *pTarget) const
        { return wbem_wcsicmp(m_pString, pTarget) == 0; }

    inline BOOL operator< (LPCWSTR wszTarget) const
        { return wcscmp(m_pString, wszTarget) < 0; }
    inline BOOL operator> (LPCWSTR wszTarget) const
        { return wcscmp(m_pString, wszTarget) > 0; }
    inline BOOL operator<= (LPCWSTR wszTarget) const
        { return wcscmp(m_pString, wszTarget) <= 0; }
    inline BOOL operator>= (LPCWSTR wszTarget) const
        { return wcscmp(m_pString, wszTarget) >= 0; }
        

    LPWSTR UnbindPtr();
    inline void BindPtr(LPWSTR ptr) { DeleteString(m_pString); m_pString = ptr; }
    void Empty();
    WString& StripWs(int nType);
        // Strip whitespace, use with a combination
        // of leading | trailing
        
    WString& TruncAtRToken(wchar_t Token);
        // Truncates the string at the token starting from the
        // right end. The token itself is also wiped out.

    WString& TruncAtLToken(wchar_t Token);
          
    WString& StripToToken(wchar_t Token, BOOL bIncludeToken);
        // Strips leading chars until the token is encountered.
        // If bIncludeTok==TRUE, strips the token too.

    wchar_t *GetLToken(wchar_t wcToken) const;
        // Gets the first occurrence of wcToken in the string or NULL
        
    WString operator()(int, int) const;
        // Returns a new WString based on the slice
        
    BOOL ExtractToken(const wchar_t * pDelimiters, WString &Extract);
        // Extracts the leading chars up to the token delimiter,
        // Removing the token from *this, and assigning the extracted
        // part to <Extract>.

    BOOL ExtractToken(wchar_t Delimiter, WString &Extract);
        // Extracts the leading chars up to the token delimiter,
        // Removing the token from *this, and assigning the extracted
        // part to <Extract>.
        
    BOOL WildcardTest(const wchar_t *pTestStr) const;
        // Tests *this against the wildcard string.  If a match,
        // returns TRUE, else FALSE.        
        
    void Unquote();        
        // Removes leading/trailing quotes, if any. 
        // Leaves escaped quotes intact.

    WString EscapeQuotes() const;
};

class WSiless
{
public:
    inline bool operator()(const WString& ws1, const WString& ws2) const
        {return wbem_wcsicmp(ws1, ws2) < 0;}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\comnlib\tmpltest.cpp ===
#include "precomp.h"
#include <stdio.h>
#include <wbemcli.h>
#include "txttempl.h"
#include "comutl.h"

extern "C" int __cdecl wmain( int argc, wchar_t* argv[] )
{
    if ( argc < 3 )
    {
        printf("Usage:: tmpltest <objref> <tmplstr>\n");
        return 1;
    }
 
    LPWSTR wszPath = argv[1];
    LPWSTR wszTmpl = argv[2];

    HRESULT hr;
    CoInitialize( NULL );

    {

    CWbemPtr<IWbemLocator> pLocator;
    CWbemPtr<IWbemServices> pSvc;

    hr = CoCreateInstance( CLSID_WbemLocator, 
                           NULL, 
                           CLSCTX_SERVER, 
                           IID_IWbemLocator, 
                           (void**)&pLocator );

    if ( FAILED(hr) )
    {
        printf("ERROR CoCIing WbemLocator : hr = 0x%x\n",hr);
        return 1;
    }

    hr = pLocator->ConnectServer( L"root", 
                                  NULL,
                                  NULL, 
                                  NULL,
                                  0, 
                                  NULL, 
                                  NULL, 
                                  &pSvc );
    
    if ( FAILED(hr) )
    {
        wprintf( L"ERROR Connecting to WMI : hr = 0x%x\n", hr );
        return 1;
    }

    CWbemPtr<IWbemClassObject> pObj;
    hr = pSvc->GetObject( wszPath, 0, NULL, &pObj, NULL );

    if ( FAILED(hr) )
    {
        printf("ERROR Fetching Obj : hr = 0x%x\n", hr );
        return 1;
    }

    CTextTemplate TextTmpl( wszTmpl );

    BSTR bstrNewQuery = TextTmpl.Apply( pObj );

    if ( bstrNewQuery == NULL )
    {
        printf("Failed getting applying template str to obj\n" );
        return 1;
    }

    wprintf( L"Template string is %s\n", bstrNewQuery );
    SysFreeString( bstrNewQuery );

    }



    CoUninitialize(); 
                   
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemcomn\wstring.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WSTRING.CPP

Abstract:

    Utility string class

History:

    a-raymcc    30-May-96       Created.
    a-dcrews    16-Mar-99       Added out-of-memory exception handling

--*/

#include "precomp.h"

#include <stdio.h>
#include <wstring.h>
#include <corex.h>

static wchar_t g_szNullString[1] = {0};

/*inline*/ void WString::DeleteString(wchar_t *pStr)
{
    if (pStr != g_szNullString)
        delete [] pStr;
}

WString::WString()
{ 
    m_pString = g_szNullString; 
}
WString::WString(wchar_t *pSrc, BOOL bAcquire)
{
    if (bAcquire) {
        m_pString = pSrc;
        if (m_pString == 0)
            m_pString = g_szNullString;
        return;            
    }

    if (pSrc == 0) {
        m_pString = g_szNullString;
        return;
    }

    m_pString = new wchar_t[wcslen(pSrc) + 1];

    // Watch for allocation failures
    if ( NULL == m_pString )
    {
        throw CX_MemoryException();
    }

    wcscpy(m_pString, pSrc);
}

WString::WString(DWORD dwResourceID, HMODULE hMod)
{
    int iSize = 100;
    BOOL bNotDone = TRUE;
    TCHAR* pTemp = NULL;

    // load the string from the string table.  Since we dont know what size, try increasing the
    // buffer till it works, or until the clearly obsurd case is hit

    while (iSize < 10240)
    {
        pTemp = new TCHAR [iSize];

        // Watch for allocation failures
        if ( NULL == pTemp )
        {
            throw CX_MemoryException();
        }

        int iRead = LoadString(hMod, dwResourceID, pTemp, iSize);
        if(iRead == 0)
        {
            // Bad string

            m_pString = g_szNullString;
            delete [] pTemp;
            return;
        }
        if(iRead +1 < iSize)
            break;      // all is well;
        iSize += 100;    // Try again
        delete [] pTemp;
        pTemp = NULL;
    }

#ifdef UNICODE
//For unicode, this is the string we need!
    m_pString = pTemp;
#else
//Only have to convert if we are not using unicode, otherwise it is already in wide mode!
    if(pTemp)
    {   
        // got a narrow string, allocate a large string buffer and convert

        long len = mbstowcs(NULL, pTemp, lstrlen(pTemp)+1) + 1;
        m_pString = new wchar_t[len];

        // Watch for allocation failures
        if ( NULL == m_pString )
        {
            delete [] pTemp;
            throw CX_MemoryException();
        }

        mbstowcs(m_pString, pTemp, lstrlen(pTemp)+1);
        delete [] pTemp;
    }
    else
        m_pString = g_szNullString;
#endif

}


WString::WString(const wchar_t *pSrc)
{
    if (pSrc == 0) {
        m_pString = g_szNullString;
        return;
    }

    m_pString = new wchar_t[wcslen(pSrc) + 1];

    // Watch for allocation failures
    if ( NULL == m_pString )
    {
        throw CX_MemoryException();
    }

    wcscpy(m_pString, pSrc);
}

WString::WString(const char *pSrc)
{
    m_pString = new wchar_t[strlen(pSrc) + 1];

    // Watch for allocation failures
    if ( NULL == m_pString )
    {
        throw CX_MemoryException();
    }

    mbstowcs(m_pString, pSrc, strlen(pSrc) + 1);
//    swprintf(m_pString, L"%S", pSrc);
}

LPSTR WString::GetLPSTR() const
{
    long len = 2*(wcslen(m_pString) + 1);
    char *pTmp = new char[len];

    // Watch for allocation failures
    if ( NULL == pTmp )
    {
        throw CX_MemoryException();
    }

    wcstombs(pTmp, m_pString, len);
//    sprintf(pTmp, "%S", m_pString);
    return pTmp;
}

WString& WString::operator =(const WString &Src)
{
    DeleteString(m_pString);
    m_pString = new wchar_t[wcslen(Src.m_pString) + 1];

    // Watch for allocation failures
    if ( NULL == m_pString )
    {
        throw CX_MemoryException();
    }

    wcscpy(m_pString, Src.m_pString);
    return *this;    
}

WString& WString::operator =(LPCWSTR pSrc)
{
    DeleteString(m_pString);
    m_pString = new wchar_t[wcslen(pSrc) + 1];

    // Watch for allocation failures
    if ( NULL == m_pString )
    {
        throw CX_MemoryException();
    }

    wcscpy(m_pString, pSrc);
    return *this;    
}

WString& WString::operator +=(const wchar_t *pOther)
{
    wchar_t *pTmp = new wchar_t[wcslen(m_pString) + 
            wcslen(pOther) + 1];

    // Watch for allocation failures
    if ( NULL == pTmp )
    {
        throw CX_MemoryException();
    }

    wcscpy(pTmp, m_pString);
    wcscat(pTmp, pOther);
    DeleteString(m_pString);
    m_pString = pTmp;
    return *this;            
}

WString& WString::operator +=(wchar_t NewChar)
{
    wchar_t Copy[2];
    Copy[0] = NewChar;
    Copy[1] = 0;
    wchar_t *pTmp = new wchar_t[wcslen(m_pString) + 2];

    // Watch for allocation failures
    if ( NULL == pTmp )
    {
        throw CX_MemoryException();
    }

    wcscpy(pTmp, m_pString);
    wcscat(pTmp, Copy);
    DeleteString(m_pString);
    m_pString = pTmp;
    return *this;            
}


WString& WString::operator +=(const WString &Other)
{
    wchar_t *pTmp = new wchar_t[wcslen(m_pString) + 
            wcslen(Other.m_pString) + 1];

    // Watch for allocation failures
    if ( NULL == pTmp )
    {
        throw CX_MemoryException();
    }

    wcscpy(pTmp, m_pString);
    wcscat(pTmp, Other.m_pString);
    DeleteString(m_pString);
    m_pString = pTmp;
    return *this;            
}


wchar_t WString::operator[](int nIndex) const
{
    if (nIndex >= (int) wcslen(m_pString))
        return 0;
    return m_pString[nIndex];        
}


WString& WString::TruncAtRToken(wchar_t Token)
{
    for (int i = (int) wcslen(m_pString); i >= 0; i--) {
        wchar_t wc = m_pString[i];
        m_pString[i] = 0;
        if (wc == Token)
            break;
    }
    
    return *this;        
}


WString& WString::TruncAtLToken(wchar_t Token)
{
    int nStrlen = wcslen(m_pString);
    for (int i = 0; i < nStrlen ; i++) 
    {
        if (Token == m_pString[i])
        {
            m_pString[i] = 0;
            break;
        }        
    }
    
    return *this;        
}


WString& WString::StripToToken(wchar_t Token, BOOL bIncludeToken)
{
    int nStrlen = wcslen(m_pString);
    wchar_t *pTmp = new wchar_t[nStrlen + 1];

    // Watch for allocation failures
    if ( NULL == pTmp )
    {
        throw CX_MemoryException();
    }

    *pTmp = 0;

    BOOL bFound = FALSE;
        
    for (int i = 0; i < nStrlen; i++) {
        if (m_pString[i] == Token) {
            bFound = TRUE;
            break;    
        }            
    }    

    if (!bFound)
    {
        delete [] pTmp;
        return *this;
    }
        
    if (bIncludeToken) i++;
    wcscpy(pTmp, &m_pString[i]);
    DeleteString(m_pString);
    m_pString = pTmp;
    return *this;
}

LPWSTR WString::UnbindPtr()
{
    if (m_pString == g_szNullString)
    {
        m_pString = new wchar_t[1];

        // Watch for allocation failures
        if ( NULL == m_pString )
        {
            throw CX_MemoryException();
        }

        *m_pString = 0;
    }
    wchar_t *pTmp = m_pString;
    m_pString = g_szNullString;
    return pTmp;
}

WString& WString::StripWs(int nType)
{
    if (nType & leading)
    {
        wchar_t *pTmp = new wchar_t[wcslen(m_pString) + 1];

        // Watch for allocation failures
        if ( NULL == pTmp )
        {
            throw CX_MemoryException();
        }

        int i = 0;
        while (iswspace(m_pString[i]) && m_pString[i]) i++;
        wcscpy(pTmp, &m_pString[i]);
        DeleteString(m_pString);
        m_pString = pTmp;
    }
               
    if (nType & trailing)
    {
        wchar_t *pCursor = m_pString + wcslen(m_pString) - 1;
        while (pCursor >= m_pString && iswspace(*pCursor)) 
            *pCursor-- = 0;
    }
    return *this;
}

wchar_t *WString::GetLToken(wchar_t Tok) const
{
    wchar_t *pCursor = m_pString;
    while (*pCursor && *pCursor != Tok) pCursor++;
    if (*pCursor == Tok)
        return pCursor;
    return 0;                
}

WString WString::operator()(int nLeft, int nRight) const
{
    wchar_t *pTmp = new wchar_t[wcslen(m_pString) + 1];

    // Watch for allocation failures
    if ( NULL == pTmp )
    {
        throw CX_MemoryException();
    }

    wchar_t *pCursor = pTmp;
        
    for (int i = nLeft; i < (int) wcslen(m_pString) && i <= nRight; i++)
        *pCursor++ = m_pString[i];
    *pCursor = 0;

    return WString(pTmp, TRUE);        
}

BOOL WString::ExtractToken(const wchar_t * pDelimiters, WString &Extract)
{
    if(pDelimiters == NULL)
    {
        Extract.Empty();
        return FALSE;
    }

    // Find which character in the list works.  Use the first if none are
    // present

    int nLen = wcslen(m_pString);
    int nDimLen = wcslen(pDelimiters);

    for (int i = 0; i < nLen; i++)
        for(int j = 0; j < nDimLen; j++)
            if (m_pString[i] == pDelimiters[j])
                return ExtractToken(pDelimiters[j], Extract);

    // If none were found, just use the first.

    return ExtractToken(*pDelimiters, Extract);

}
 
BOOL WString::ExtractToken(wchar_t Delimiter, WString &Extract)
{
    int i, i2;
    BOOL bTokFound = FALSE;
    Extract.Empty();
    int nLen = wcslen(m_pString);
    wchar_t *pTmp = new wchar_t[nLen + 1];
    
    // Watch for allocation failures
    if ( NULL == pTmp )
    {
        throw CX_MemoryException();
    }

    for (i = 0; i < nLen; i++)
        if (m_pString[i] == Delimiter) {
            bTokFound = TRUE;
            break;    
        }            
        else
            pTmp[i] = m_pString[i];            

    pTmp[i] = 0;
    Extract.BindPtr(pTmp);                      
                                              
    // Now make *this refer to any leftover stuff.
    // ===========================================
    pTmp = new wchar_t[nLen - wcslen(pTmp) + 1];

    // Watch for allocation failures
    if ( NULL == pTmp )
    {
        throw CX_MemoryException();
    }

    *pTmp = 0;

    for (i2 = 0, i++; i <= nLen; i++)
        pTmp[i2++] = m_pString[i];

    DeleteString(m_pString);
    m_pString = pTmp;
    
    // Return TRUE if the token was encountered, FALSE if not.
    // =======================================================
    return bTokFound;
}

void WString::Empty()
{
    DeleteString(m_pString);
    m_pString = g_szNullString;
}

static int _WildcardAux(const wchar_t *pszWildstr, const wchar_t *pszTargetstr, 
    int iGreedy)
{
    enum { start, wild, strip } eState;
    wchar_t cInput, cInputw, cLaToken;
    
    if (!wcslen(pszTargetstr) || !wcslen(pszWildstr))
        return 0;
                
    for (eState = start;;)
        switch (eState)
        {
            case start:
                cInputw = *pszWildstr++;        // wildcard input 
                cInput = *pszTargetstr;         // target input 

                if (!cInputw)                   // at end of wildcard string? 
                    goto EndScan;

                // Check for wildcard chars first 
                   
                if (cInputw == L'?') {          // Simply strips both inputs 
                    if (!cInput)                // If end of input, error 
                        return 0;
                    pszTargetstr++;
                    continue;
                }
                if (cInputw == L'*')  {
                    eState = wild;                
                    break;
                }

                // If here, an exact match is required.                 

                if (cInput != cInputw)
                    return 0;
                    
                // Else remain in same state, since match succeeded 
                pszTargetstr++;
                break;

            case wild:
                cLaToken = *pszWildstr++;   // Establish the lookahead token 
                eState = strip;
                break;

            case strip:
                cInput = *pszTargetstr;

                if (cInput == cLaToken) {
                    if (!cInput)            // Match on a NULL 
                        goto EndScan;
                    ++pszTargetstr;  

                    // If there is another occurrence of the lookahead 
                    // token in the string, and we are in greedy mode,
                    // stay in this state 

                    if (!iGreedy)
                        eState = start;

                    if (!wcschr(pszTargetstr, cLaToken))
                        eState = start;

                    break;
                }
                    
                if (cLaToken && !cInput)    // End of input with a non-null la token 
                    return 0;

                ++pszTargetstr;             // Still stripping input 
                break;
        }


    //  Here if the wildcard input is exhausted.  If the
    //  target string is also empty, we have a match,
    //  otherwise not. 

EndScan:
    if (wcslen(pszTargetstr))
        return 0; 

    return 1;   
}

// Run the test both with greedy and non-greedy matching, allowing the
// greatest possible chance of a match. 

BOOL WString::WildcardTest(const wchar_t *pszWildstr) const
{
    return (_WildcardAux(pszWildstr, m_pString, 0) | 
            _WildcardAux(pszWildstr, m_pString, 1));
}


void WString::Unquote()
{
    if (!m_pString)
        return;
    int nLen = wcslen(m_pString);
    if (nLen == 0)
        return;

    // Remove trailing quote.
    // ======================
    
    if (m_pString[nLen - 1] == L'"')
        m_pString[nLen - 1] = 0;

    // Remove leading quote.
    // =====================
    
    if (m_pString[0] == L'"')
    {
        for (int i = 0; i < nLen; i++)
            m_pString[i] = m_pString[i + 1];
    }
}

WString WString::EscapeQuotes() const
{
    WString ws;

    int nLen = Length();
    for(int i = 0; i < nLen; i++)
    {
        if(m_pString[i] == '"' || m_pString[i] == '\\')
        {
            ws += L'\\';
        }

        ws += m_pString[i];
    }

    return ws;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemtest\precomp.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemtest\notsink.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    NOTSINK.H

Abstract:

History:

--*/

#include <wbemidl.h>
//#include <arena.h>
//#include <flexarry.h>
#include "wbemtest.h"

#pragma warning(disable:4355)

class CNotSink : public IWbemObjectSink
{
    long m_lRefCount;
    CQueryResultDlg* m_pViewer;
    CRITICAL_SECTION m_cs;
    
public:
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam, 
                         IWbemClassObject* pObjPAram);

    // Private to implementation.
    // ==========================

    CNotSink(CQueryResultDlg* pViewer);
    ~CNotSink();
    void ResetViewer() { m_pViewer = NULL;}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemtest\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemtest\method.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    METHOD.H

Abstract:

History:

--*/

#ifndef __method__H_
#define __method__H_


#include <wbemdlg.h>
#include <wbemidl.h>
#include <resrc1.h>
#include "wbemqual.h"
#include "WT_WString.h"

class CMethodDlg : public CWbemDialog
{
    IWbemClassObject* m_pInParams;
    IWbemClassObject* m_pOutParams;

    BOOL m_bHasOutParam;
    IWbemClassObject * m_pClass;
    HWND m_hMethodList;
    BOOL m_bAtLeastOne;
    WString m_wsName;

    WCHAR m_Path[2048];
    WCHAR m_Class[2048];

    LONG  m_lGenFlags;  // generic WBEM_FLAG_ .. flags
    LONG  m_lSync;      // enum {sync = 0, async, semisync}
    LONG  m_lTimeout;   // used in semisync only

public:
    CMethodDlg(HWND hParent, LONG lGenFlags, LONG lSync, LONG lTimeout);
    ~CMethodDlg();
	void RunDetached(CRefCountable* pOwner);

protected:
    BOOL OnInitDialog();
    BOOL OnExecute();
    BOOL GetPath();
    BOOL OnCommand(WORD wNotifyCode, WORD nId);
    BOOL OnSelChange(int nID);
    void ResetButtons();
    BOOL UpdateObjs();
};

class CMethodEditor : public CWbemDialog
{
    CTestMethod *m_pTarget;
    BOOL m_bEditOnly;
    BOOL m_bInstance;

    // Control handles.
    // ================

    HWND m_hPropName;
    HWND m_hPropType;
    HWND m_hValue;
    HWND m_hQualifierList;


public:
    CMethodEditor(HWND hParent, CTestMethod *pMethod, BOOL bEditOnly,
                        BOOL bInstance);
    INT_PTR Edit();

    BOOL OnInitDialog();
    BOOL Verify();
    BOOL OnCommand(WORD wCode, WORD wID);
    BOOL OnDoubleClick(int nID);
    BOOL OnSelChange(int nID);

    void Refresh();
    void OnAddQualifier();
    void OnDelQualifier();
    void OnEditQualifier();
    void OnNotNull();
    void ViewEmbedding(BOOL bInput);
    int RemoveSysQuals();
    void SetSystemCheck(int nID);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemtest\notsink.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    NOTSINK.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include "notsink.h"
#include <stdio.h>
#include "wbemntfy.h"

extern CStatusMonitor gStatus; 

// Notification Query Sink

SCODE CNotSink::QueryInterface(
    REFIID riid,
    LPVOID * ppvObj
    )
{
    if (riid == IID_IUnknown)
    {
        *ppvObj = this;
    }
    else if (riid == IID_IWbemObjectSink)
        *ppvObj = this;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}


ULONG CNotSink::AddRef()
{
    InterlockedIncrement(&m_lRefCount);
    return (ULONG) m_lRefCount;
}

ULONG CNotSink::Release()
{
    InterlockedDecrement(&m_lRefCount);

    if (0 != m_lRefCount)
    {
        return 1;
    }

    delete this;
    return 0;
}


SCODE CNotSink::Indicate(
    long lObjectCount,
    IWbemClassObject ** pObjArray
    )
{
    if(lObjectCount == 0) return WBEM_NO_ERROR;
    if(m_pViewer == NULL) return WBEM_NO_ERROR;

    // Use critical section to prevent re-entrancy
    // from additional Indicate's into this code.
    EnterCriticalSection(&m_cs);
    for (int i = 0; i < lObjectCount; i++)
    {
        IWbemClassObject *pObj = pObjArray[i];
        m_pViewer->PostObject(pObj);
    }
    m_pViewer->PostCount(lObjectCount);
    LeaveCriticalSection(&m_cs);

    return WBEM_NO_ERROR;
}

STDMETHODIMP CNotSink::SetStatus(long lFlags, long lParam, BSTR strParam, 
                         IWbemClassObject* pObjParam)
{ 
    if(lFlags & WBEM_STATUS_PROGRESS)
    {
        gStatus.Add(lFlags, lParam, strParam);
        return WBEM_NO_ERROR;
    }

    EnterCriticalSection(&m_cs);
    if(m_pViewer)
        m_pViewer->PostComplete(lParam, strParam, pObjParam);
    LeaveCriticalSection(&m_cs);
    return WBEM_S_NO_ERROR;
}

CNotSink::CNotSink(CQueryResultDlg* pViewer)
{
    m_lRefCount = 1;
    m_pViewer = pViewer;
    InitializeCriticalSection(&m_cs);
}

CNotSink::~CNotSink()
{
    DeleteCriticalSection(&m_cs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemtest\method.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    METHOD.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <stdio.h>
//#include <wbemutil.h>
//#include "wstring.h"
#include "method.h"
#include "wbemtest.h"
#include "bstring.h"
#include "wbemqual.h"
#include "textconv.h"
#include "genlex.h"
#include "objpath.h"
#include <cominit.h>            // for SetInterfaceSecurityEx()


extern DWORD            gdwAuthLevel;
extern DWORD            gdwImpLevel;
extern BSTR             gpPrincipal;
extern COAUTHIDENTITY*  gpAuthIdentity;


INT_PTR GetObjectPath(HWND hDlg, LPWSTR pStr, int nMax);

#include "objedit.h"

CMethodDlg::CMethodDlg(HWND hParent, LONG lGenFlags, LONG lSync, LONG lTimeout)
    : CWbemDialog(IDD_METHOD, hParent), m_pOutParams(NULL), m_pInParams(NULL), 
            m_lGenFlags(lGenFlags), m_lSync(lSync), m_lTimeout(lTimeout)
{
    m_Path[0] = 0;
    m_Class[0] = 0;
    m_pClass = NULL;
    m_bAtLeastOne = FALSE;
    m_bHasOutParam = FALSE;
}

CMethodDlg::~CMethodDlg()
{
    if(m_pInParams) m_pInParams->Release();
    if(m_pClass)
        m_pClass->Release();
    if(m_pOutParams)
        m_pOutParams->Release();
}

BOOL CMethodDlg::OnInitDialog()
{
    m_hMethodList = GetDlgItem(IDC_METHLIST);
    BOOL bRet = GetPath();
    if(!bRet)
        EndDialog(IDCANCEL);
    ResetButtons();
    return bRet;
}


void CMethodDlg::RunDetached(CRefCountable* pOwner)
{
    SetOwner(pOwner);
    SetDeleteOnClose();
    Create(FALSE);
}

BOOL CMethodDlg::GetPath()
{
    WCHAR wTemp[2048];
    wcscpy(wTemp, m_Path);
    INT_PTR dwRet = GetObjectPath(m_hDlg, wTemp, 2048);
    if(dwRet == IDOK)
    {
        if(wcslen(wTemp) < 1)
        {
            MessageBox(m_hDlg, IDS_CANT_GET_CLASS, IDS_ERROR, MB_OK | MB_ICONSTOP);
            return FALSE;
        }
        wcscpy(m_Path, wTemp);
        CObjectPathParser par;
        ParsedObjectPath *pOutput;
        int nRes = par.Parse(m_Path, &pOutput);
        if(nRes || pOutput == NULL || pOutput->m_pClass == NULL)
        {
            MessageBox(IDS_CANT_GET_CLASS, IDS_WARNING, MB_OK | MB_ICONSTOP);
            return FALSE;
        }
        wcscpy(m_Class, pOutput->m_pClass);
        if(m_pClass)
        {
            m_pClass->Release();
            m_pClass = NULL;
        }
        CBString bsPath = m_Class;
        SCODE sc = g_pNamespace->GetObject(bsPath.GetString(), m_lGenFlags, g_Context, 
                                        &m_pClass, NULL);

        if(sc != S_OK)
        {
            FormatError(sc, m_hDlg, NULL);
            return FALSE;
        }
        // populate the combo box with methods.

        SendMessage(m_hMethodList, CB_RESETCONTENT, 0, 0);
        SendMessage(m_hMethodList, CB_SETCURSEL, -1, 0);

        m_bAtLeastOne = FALSE;
        if(sc == S_OK && m_pClass)
        {
            BSTR Name = NULL;
            m_pClass->BeginMethodEnumeration(0);
            while (m_pClass->NextMethod(0, &Name, NULL, NULL) == WBEM_S_NO_ERROR)
            {
                char buf[TEMP_BUF];
                wcstombs(buf, Name, TEMP_BUF);
                buf[TEMP_BUF-1] = '\0';
                SendMessage(m_hMethodList, CB_ADDSTRING, 0, LPARAM(buf));
                m_bAtLeastOne = TRUE;
            }
            if(m_bAtLeastOne)
            {
                SendMessage(m_hMethodList, CB_SETCURSEL, 0, 0);
                OnSelChange(0);
            }
            else
            {
                MessageBox(m_hDlg, IDS_CLASS_HAS_NO_METHODS, IDS_ERROR, MB_OK | MB_ICONSTOP);
                ResetButtons();
                return FALSE;
            }


            m_pClass->EndMethodEnumeration();
        }

        return TRUE;
    }
    else
        return FALSE;

}

BOOL CMethodDlg::OnCommand(WORD wNotifyCode, WORD nId)
{
    switch(nId)
    {
    case IDC_EDITPATH:
        GetPath();
        break;
    case IDC_CLEAR:
        UpdateObjs();
        break;

    case IDC_EXECUTE:
        OnExecute();
        break;

    case IDC_EDITOUT:
        if(m_pOutParams != NULL)
        {
            IWbemClassObject* pNew;
            m_pOutParams->Clone(&pNew);

            CObjectEditor ed(m_hDlg, m_lGenFlags, CObjectEditor::readonly, m_lSync, 
                    pNew, m_lTimeout);
            ed.Run();
            pNew->Release();
        }
        break;

    case IDC_EDITIN:
        if(m_pInParams != NULL)
        {
            IWbemClassObject* pNew;
            m_pInParams->Clone(&pNew);

            CObjectEditor ed(m_hDlg, m_lGenFlags, CObjectEditor::readwrite, m_lSync,
                    pNew, m_lTimeout);
            if(ed.Run() == IDOK)
            {
                m_pInParams->Release();
                m_pInParams = pNew;
            }
        }
        else
        {
            m_pInParams = _CreateInstance(m_hDlg, m_lGenFlags, m_lSync, m_lTimeout);
        }
        break;
    }
    ResetButtons();
    return TRUE;
}


void CMethodDlg::ResetButtons()
{
    EnableWindow(GetDlgItem(IDC_CLEAR), (m_pInParams != NULL));
    EnableWindow(GetDlgItem(IDC_EXECUTE), (wcslen(m_Path)));
    EnableWindow(GetDlgItem(IDC_EDITIN), (m_pInParams != NULL));
    EnableWindow(GetDlgItem(IDC_EDITOUT), (m_pOutParams != NULL));
    char cTemp[2048];
    wcstombs(cTemp, m_Path, 2048);
    SetWindowText(GetDlgItem(IDC_OBJPATH), cTemp);
}

BOOL CMethodDlg::OnExecute()
{
    // Get all the parameters
    // ======================

    if(wcslen(m_Path) == 0)
    {
        MessageBox(IDS_MUST_SPECIFY_PATH, IDS_ERROR, MB_OK | MB_ICONHAND);
        return FALSE;
    }
    if(wcslen(m_wsName) == 0)
    {
        MessageBox(IDS_MUST_SPECIFY_NAME, IDS_ERROR, MB_OK | MB_ICONHAND);
        return FALSE;
    }

    // Execute the method
    // ==================

    CBString bsPath(m_Path);
    CBString bsMethod(m_wsName);

    if(m_pOutParams)
        m_pOutParams->Release();
    m_pOutParams = NULL;

    HRESULT res;
    IWbemClassObject* pErrorObj = NULL;

    // Asynchronous
    if (m_lSync & ASYNC)
    {
        CHourGlass hg;
        CTestNotify* pNtfy = new CTestNotify(1);

        res = g_pNamespace->ExecMethodAsync(bsPath.GetString(), bsMethod.GetString(),
                                WBEM_FLAG_SEND_STATUS, 
                                g_Context, m_pInParams, CUnsecWrap(pNtfy));

        if(SUCCEEDED(res))
        {
            pNtfy->WaitForSignal(INFINITE);

            res = pNtfy->GetStatusCode(&pErrorObj);
            if(SUCCEEDED(res))
            {
                CFlexArray* pArray = pNtfy->GetObjectArray();

                if(m_bHasOutParam && pArray && pArray->Size() > 0)
                {
                    m_pOutParams = (IWbemClassObject*)pArray->GetAt(0);
                    if (m_pOutParams)
                        m_pOutParams->AddRef();
                }
            }
        }
        pNtfy->Release();
    }

    // Semisynchronous
    else if (m_lSync & SEMISYNC)
    {
        IWbemCallResult* pCallRes = NULL;
        CHourGlass hg;
        res = g_pNamespace->ExecMethod(bsPath.GetString(), bsMethod.GetString(),
                                WBEM_FLAG_RETURN_IMMEDIATELY, 
                                g_Context, m_pInParams, (m_bHasOutParam) ? &m_pOutParams : NULL, 
                                &pCallRes);

        if (SUCCEEDED(res))
        {
            LONG lStatus;
            SetInterfaceSecurityEx(pCallRes, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
            while ((res = pCallRes->GetCallStatus(m_lTimeout, &lStatus)) == WBEM_S_TIMEDOUT)
            {
                // wait
            }
            if (res == WBEM_S_NO_ERROR)
            {
                res = (HRESULT)lStatus;     // lStatus is the final result of the above IWbemServices::ExecMethod call
                if (m_bHasOutParam && res == WBEM_S_NO_ERROR)
                {
                    res = pCallRes->GetResultObject(0, &m_pOutParams);  // don't use timeout since object should be available
                }
            }

            pCallRes->Release();
        }
    }

    // Synchronous
    else
    {
        CHourGlass hg;
        res = g_pNamespace->ExecMethod(bsPath.GetString(), bsMethod.GetString(),
                                0, 
                                g_Context, m_pInParams, (m_bHasOutParam) ? &m_pOutParams : NULL, 
                                NULL);
    }

    if (FAILED(res))
        FormatError(res, m_hDlg, pErrorObj);
    else
        MessageBox(m_hDlg, IDS_STRING_METHOD_OK, IDS_WBEMTEST, MB_OK);

    return TRUE;
}

BOOL CMethodDlg::UpdateObjs()
{
    SCODE sc;
    if(m_pClass == NULL)
        return FALSE;

    if(m_pInParams)
    {
        m_pInParams->Release();
        m_pInParams = NULL;
    }
    if(m_pOutParams)
    {
        m_pOutParams->Release();
        m_pOutParams = NULL;
    }

    sc = m_pClass->GetMethod((LPWSTR)m_wsName, 0, &m_pInParams, &m_pOutParams); 

    m_bHasOutParam = (m_pOutParams != NULL);
    if(m_pOutParams)
    {
        m_pOutParams->Release();
        m_pOutParams = NULL;
    }

    return sc == S_OK;
}
BOOL CMethodDlg::OnSelChange(int nID)
{

    if(m_pClass == NULL)
        return FALSE;

    LRESULT nIndex = SendMessage(m_hMethodList, CB_GETCURSEL, 0, 0);
    if (nIndex == LB_ERR)
        return FALSE;

    char buf[TEMP_BUF];
    *buf = 0;
    SendMessage(m_hMethodList, CB_GETLBTEXT, nIndex, LPARAM(buf));
    if (*buf == 0)
        return FALSE;

    m_wsName = buf;

    // Get the property value from the object
    // ======================================

    UpdateObjs();
    ResetButtons();
    return TRUE;
}
void CMethodEditor::OnAddQualifier()
{
    CTestQualifier att;

    att.m_lType =  
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | 
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS;

    CTestQualifierEditor ed(m_hDlg, &att, FALSE);
    INT_PTR nRes = ed.Edit();
    if ((nRes == IDCANCEL) || (nRes == 0))
        return;


    // If here, the Qualifier is being added.
    // ======================================

    IWbemQualifierSet* pQualifierSet = m_pTarget->m_pQualifiers;

    VARIANT *p = att.m_pValue->GetNewVariant();

    HRESULT hres = pQualifierSet->Put(att.m_pName, p, att.m_lType);
    if(FAILED(hres))
    {
        FormatError(hres, m_hDlg);
    }

    VariantClear(p);
    Refresh();
}

void CMethodEditor::SetSystemCheck(int nID)
{
    SetCheck(IDC_NOT_NULL, BST_UNCHECKED);
    SetCheck(IDC_NORMAL, BST_UNCHECKED);
    SetCheck(nID, BST_CHECKED);
}

int CMethodEditor::RemoveSysQuals()
{
    IWbemQualifierSet* pSet = m_pTarget->m_pQualifiers;
    HRESULT hres;

    hres = pSet->Delete(L"not_null");
    if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
    {
        SetSystemCheck(IDC_NOT_NULL);
        return IDC_NOT_NULL;
    }

    return 0;
}


void CMethodEditor::OnNotNull()
{
    IWbemQualifierSet* pQualifierSet = m_pTarget->m_pQualifiers;
    int nRes = RemoveSysQuals();
    if(nRes != 0)
    {
        MessageBox(IDS_CANNOT_CHANGE_SYSTEM_QUALS, IDS_ERROR, MB_OK);
        return;
    }
    VARIANT v;
    V_VT(&v) = VT_BOOL;
    V_BOOL(&v) = VARIANT_TRUE;
    HRESULT hres = pQualifierSet->Put(L"not_null", 
                &v,
                WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | 
                WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS);

    if(FAILED(hres))
    {
        MessageBox(IDS_MAY_NOT_SPECIFY_NOT_NULL, IDS_ERROR,
            MB_OK | MB_ICONSTOP);
        
        SetSystemCheck(IDC_NORMAL);
    }
}


void CMethodEditor::OnEditQualifier()
{
    // See if anything is selected.
    // ============================
    LRESULT nSel = SendMessage(m_hQualifierList, LB_GETCURSEL, 0, 0);

    if (nSel == LB_ERR)
        return;

    char buf[TEMP_BUF];
    *buf = 0;
    SendMessage(m_hQualifierList, LB_GETTEXT, nSel, LPARAM(buf));
    if (*buf == 0)
        return;

    // At this point, the text of the selected Qualifier is in <buf>.
    // ==============================================================

    char name[TEMP_BUF];
    *name = 0;
    if (sscanf(buf, "%[^\t\0]", name) == EOF)
		return;
	if (*name == 0)
        return;

    WString WName = name;

    // Find the Qualifier in question.
    // ===============================

    VARIANT v;
    VariantInit(&v);
    LONG lType = 0;
    IWbemQualifierSet* pQualifierSet = m_pTarget->m_pQualifiers;

    CBString bsWName(WName);

    SCODE res = pQualifierSet->Get(bsWName.GetString(), 0, &v, &lType);
    if (res != 0)
    {
        MessageBox(IDS_QUALIFIER_NOT_FOUND, IDS_CRITICAL_ERROR, MB_OK);
        return;
    }

    // If here, convert temporarily to a CTestQualifier object for the duration of
    // the edit.
    // ====================================================================

    CVar *pNewVal = new CVar;
    pNewVal->SetVariant(&v);
    VariantClear(&v);

    CTestQualifier att;
    att.m_pValue = pNewVal;
    att.m_pName = new wchar_t[wcslen(WName) + 1];
    wcscpy(att.m_pName, WName);
    att.m_lType = lType;

    CTestQualifierEditor ed(m_hDlg, &att, TRUE);
    INT_PTR nRes = ed.Edit();
    if ((nRes == IDCANCEL) || (nRes == 0))
    {
        return;
    }

    // If here, the Qualifier is being added.
    // ======================================

    VARIANT *p = att.m_pValue->GetNewVariant();

    CBString bsName(att.m_pName);

    res = pQualifierSet->Put(bsName.GetString(), p, att.m_lType);
    if(FAILED(res))
    {
        FormatError(res, m_hDlg);
    }
    VariantClear(p);
    Refresh();
}

//ok
void CMethodEditor::OnDelQualifier()
{
    // See if anything is selected.
    // ============================
    LRESULT nSel = SendMessage(m_hQualifierList, LB_GETCURSEL, 0, 0);

    if (nSel == LB_ERR)
        return;

    char buf[TEMP_BUF];
    *buf = 0;
    SendMessage(m_hQualifierList, LB_GETTEXT, nSel, LPARAM(buf));
    if (*buf == 0)
        return;

    // At this point, the text of the selected Qualifier is in <buf>.
    // ==============================================================

    char name[TEMP_BUF];
    *name = 0;
    if (sscanf(buf, "%[^\t\0]", name) == EOF)
		return;
    if (*name == 0)
        return;

    WString WName = name;

    // Remove the Qualifier.
    // =====================

    IWbemQualifierSet *pQualifierSet = m_pTarget->m_pQualifiers;

    CBString bsName(WName);

    HRESULT hres = pQualifierSet->Delete(bsName.GetString());
    if(FAILED(hres) || hres != 0)
    {
        FormatError(hres, m_hDlg);
    }
    Refresh();
}

void CMethodEditor::Refresh()
{
    // Zap the current contents.
    // =========================
    SendMessage(m_hQualifierList, LB_RESETCONTENT, 0, 0);
    SetCheck(IDC_NOT_NULL, BST_UNCHECKED);
    SetCheck(IDC_NORMAL, BST_CHECKED);

    EnableWindow(GetDlgItem(IDC_INPUT_ARGS), GetCheck(IDC_CHECKINPUT) == BST_CHECKED);
    EnableWindow(GetDlgItem(IDC_OUTPUT_ARGS), GetCheck(IDC_CHECKOUTPUT) == BST_CHECKED);

    // Fill in the Qualifier list.
    // ===========================

    IWbemQualifierSet *pQualifiers = m_pTarget->m_pQualifiers;

    if(pQualifiers == NULL)
    {
        EnableWindow(m_hQualifierList, FALSE);
        EnableWindow(GetDlgItem(IDC_NOT_NULL), FALSE);
        EnableWindow(GetDlgItem(IDC_NORMAL), FALSE);
        EnableWindow(GetDlgItem(IDC_ADD_ATTRIB), FALSE);
        EnableWindow(GetDlgItem(IDC_EDIT_ATTRIB), FALSE);
        EnableWindow(GetDlgItem(IDC_DELETE_ATTRIB), FALSE);
        EnableWindow(GetDlgItem(IDC_STATIC_QUAL), FALSE);
    }

    if (pQualifiers)
    {
        pQualifiers->BeginEnumeration(0);

        BSTR strName = NULL;
        long lFlavor;
        VARIANT vVal;
        VariantInit(&vVal);

        while(pQualifiers->Next(0, &strName, &vVal, &lFlavor) == S_OK)
        {
            if(!_wcsicmp(strName, L"not_null"))
            {
                if(GetCheck(IDC_KEY) == BST_UNCHECKED && 
                        GetCheck(IDC_INDEXED) == BST_UNCHECKED)
                {
                    SetSystemCheck(IDC_NOT_NULL);
                }
                SysFreeString(strName);
                strName = NULL;
                continue;
            }
                
            CTestQualifier A;
            A.m_pName = new wchar_t[wcslen(strName)+1];
            wcscpy(A.m_pName, strName);
            A.m_pValue = new CVar(&vVal);
            A.m_lType = lFlavor;

            // Build list box string.
            // ======================

            SendMessage(m_hQualifierList, LB_ADDSTRING, 0,LPARAM(CTestQualifierToString(&A)));
            VariantClear(&vVal);
            SysFreeString(strName);
            strName = NULL;
        }

        pQualifiers->EndEnumeration();
        VariantClear(&vVal);
    }
}

BOOL CMethodEditor::OnDoubleClick(int nID)
{
    if(nID == IDC_ATTRIB_LIST)
    {
        OnEditQualifier();
        return TRUE;
    }
    return FALSE;
}

BOOL CMethodEditor::OnSelChange(int nID)
{
    if(nID == IDC_TYPE_LIST)
    {
        char* pszType = GetCBCurSelString(IDC_TYPE_LIST);
        BOOL bArray = (GetCheck(IDC_ARRAY) == BST_CHECKED);
        m_pTarget->m_lType = StringToType(pszType);
        if(bArray)
            m_pTarget->m_lType |= VT_ARRAY;

        if((m_pTarget->m_lType & ~VT_ARRAY) == VT_EMBEDDED_OBJECT)
        {
            ShowWindow(GetDlgItem(IDC_EMBEDDING), SW_SHOW);
        }
        else
        {
            ShowWindow(GetDlgItem(IDC_EMBEDDING), SW_HIDE);
        }
        delete [] pszType;
    }
    return TRUE;
}

BOOL CMethodEditor::OnCommand(WORD wCode, WORD wID)
{
    switch(wID)
    {
        case IDC_EDIT_ATTRIB: OnEditQualifier(); return TRUE;

        case IDC_ADD_ATTRIB: OnAddQualifier(); return TRUE;
        case IDC_DELETE_ATTRIB: OnDelQualifier(); return TRUE;
        case IDC_NOT_NULL:
            if(wCode == BN_CLICKED)
                OnNotNull();
            return TRUE;
        case IDC_NORMAL:
            if(wCode == BN_CLICKED)
                RemoveSysQuals();
            return TRUE;
        case IDC_INPUT_ARGS:
            ViewEmbedding(TRUE);
            return TRUE;
        case IDC_OUTPUT_ARGS:
            ViewEmbedding(FALSE);
            return TRUE;
        case IDC_CHECKINPUT:
            m_pTarget->m_bEnableInputArgs = (GetCheck(IDC_CHECKINPUT) == BST_CHECKED);
            Refresh();
            return TRUE;

        case IDC_CHECKOUTPUT:
            m_pTarget->m_bEnableOutputArgs = (GetCheck(IDC_CHECKOUTPUT) == BST_CHECKED);
            Refresh();
            return TRUE;

    }

    return TRUE;
}


BOOL CMethodEditor::OnInitDialog()
{
    ShowWindow(GetDlgItem(IDC_EMBEDDING), SW_HIDE);
    CenterOnParent();

    m_hPropName = GetDlgItem(IDC_PROPNAME);
    m_hQualifierList = GetDlgItem(IDC_ATTRIB_LIST);

    SetCheck(IDC_CHECKINPUT, (m_pTarget->m_bEnableInputArgs) ? BST_CHECKED : BST_UNCHECKED);
    SetCheck(IDC_CHECKOUTPUT, (m_pTarget->m_bEnableOutputArgs) ? BST_CHECKED : BST_UNCHECKED);

    LONG Tabs[] = { 80, 120, 170 };
    int TabCount = 3;

    SendMessage(m_hQualifierList, LB_SETTABSTOPS,
        (WPARAM) TabCount, (LPARAM) Tabs);


    // Now initialize the controls with the contents of the
    // current object, if any.
    // ====================================================

    if (m_pTarget->m_pName)
    {
        SetWindowText(m_hPropName, LPWSTRToLPSTR(m_pTarget->m_pName));
    }

    if(m_pTarget->m_pClass)
    {
        SetDlgItemText(IDC_ORIGIN, LPWSTRToLPSTR(m_pTarget->m_pClass));
    }


    // Refresh the Qualifiers.
    // =======================

    Refresh();

    // If editing, don't allow type/name change.
    // =========================================

    if (m_bEditOnly)
    {
        EnableWindow(m_hPropName, FALSE);
    }

    if(m_bInstance)
    {
        EnableWindow(GetDlgItem(IDC_NOT_NULL), FALSE);
        EnableWindow(GetDlgItem(IDC_NORMAL), FALSE);
    }

    return TRUE;
}

void CMethodEditor::ViewEmbedding(BOOL bInput)
{

        IWbemClassObject* pCurrentEmbed;
        if(bInput)
            pCurrentEmbed = m_pTarget->m_pInArgs;
        else
            pCurrentEmbed = m_pTarget->m_pOutArgs;

        IWbemClassObject* pEmbed;
        pCurrentEmbed->Clone(&pEmbed);
//        pCurrentEmbed->Release();

        CObjectEditor ed(m_hDlg, 0, CObjectEditor::readwrite | CObjectEditor::nomethods,
                         SYNC, pEmbed);
        if(ed.Edit() == IDOK)
        {
            if(bInput)
                m_pTarget->m_pInArgs = pEmbed;
            else
                m_pTarget->m_pOutArgs = pEmbed;
        }
        else
            pEmbed->Release();
}
                

BOOL CMethodEditor::Verify()
{
    char buf[TEMP_BUF];

    // Verify that name is present.
    // ============================

    if (GetWindowText(m_hPropName, buf, TEMP_BUF) == 0)
    {
        MessageBox(IDS_NO_METHOD_NAME, IDS_ERROR, MB_OK);
        return FALSE;
    }
    StripTrailingWs(buf);

    WString Name = buf;

    if (m_pTarget->m_pName)
        delete m_pTarget->m_pName;

    m_pTarget->m_pName = new wchar_t[wcslen(Name) + 1];
    wcscpy(m_pTarget->m_pName, Name);

    return TRUE;
}

CMethodEditor::CMethodEditor(
    HWND hParent,
    CTestMethod *pMethod,
    BOOL bEditOnly,
    BOOL bInstance
    ) : CWbemDialog(IDD_METHOD_EDITOR, hParent)
{
    m_pTarget = pMethod;
    m_bEditOnly = bEditOnly;
    m_bInstance = bInstance;
}

INT_PTR CMethodEditor::Edit()
{
    return Run();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemtest\resource.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    RESOURCE.H

Abstract:

History:

--*/

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Wbemtest.x.rc
//
#define IDD_DIALOGBAR                   103
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemtest\objedit.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    OBJEDIT.CPP

Abstract:

    WBEMTEST object editor classes.

History:

    a-raymcc    12-Jun-96       Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include "wbemqual.h"

#include "resource.h"
#include "resrc1.h"
#include "objedit.h"
#include "wbemtest.h"
//#include <wbemutil.h>
#include "textconv.h"
#include <cominit.h>
#include "bstring.h"
#include "WT_wstring.h"
#include "method.h"

// following were changed due to very large SNMP properties

#define LARGE_BUF   2096

#define IDC_CLASS           IDC_SUPERCLASS
#define IDC_REFERENCES      IDC_DERIVED
#define IDC_ASSOCIATIONS    IDC_INSTANCES

extern DWORD            gdwAuthLevel;
extern DWORD            gdwImpLevel;
extern BSTR             gpPrincipal;
extern COAUTHIDENTITY*  gpAuthIdentity;

char *ValidQualifierTypes[] =
{
    "CIM_SINT32",
    "CIM_STRING",
    "CIM_BOOLEAN",
    "CIM_REAL64"
};

void CopyQualifierSet(IWbemQualifierSet* pDest, IWbemQualifierSet* pSrc, HWND hDlg)
{
    pSrc->BeginEnumeration(0);

    BSTR strName = NULL;
    VARIANT vVal;
    VariantInit(&vVal);
    long lFlavor;
    while(pSrc->Next(0, &strName, &vVal, &lFlavor) == S_OK)
    {
        if(!_wcsicmp(strName, L"cimtype") && 
           !_wcsicmp(V_BSTR(&vVal), L"sint32")) continue;
        SCODE hres = pDest->Put(strName, &vVal, lFlavor);
        if(FAILED(hres))
        {
            FormatError(hres, hDlg);
        }
    }
}

const int nNumValidQualifierTypes = sizeof(ValidQualifierTypes) / sizeof(char *);

LPSTR TypeToString(CVar *p)
{
    return TypeToString(p->GetOleType());
}

LPSTR LPWSTRToLPSTR(LPWSTR pWStr)
{
    static char buf[TEMP_BUF];
    wcstombs(buf, pWStr, TEMP_BUF);
    buf[TEMP_BUF-1] = '\0';
    return buf;
}


LPSTR CTestQualifierToString(CTestQualifier *pQualifier)
{
    static char buf[TEMP_BUF];

    if (pQualifier->m_pName)
    {
        wcstombs(buf, pQualifier->m_pName, TEMP_BUF);
        buf[TEMP_BUF-1] = '\0';
    }

    if (pQualifier->m_pValue)
    {
        strcat(buf, "\t");
        strcat(buf, TypeToString(pQualifier->m_pValue));

        strcat(buf, "\t");
        strcat(buf, ValueToString(pQualifier->m_pValue));
    }

    return buf;
}




BOOL CTestQualifierEditor::Verify()
{
    // Get the Qualifier name.
    // =======================
    char NameBuf[TEMP_BUF];
    char buf[TEMP_BUF];
    if (GetWindowText(m_hQualifierName, NameBuf, TEMP_BUF) == 0)
    {
        MessageBox(IDS_INVALID_QUALIFIER_NAME, IDS_ERROR, MB_OK);
        return FALSE;
    }
    StripTrailingWs(NameBuf);

    delete m_pTarget->m_pName;
    WString Tmp(NameBuf);
    m_pTarget->m_pName = new wchar_t[wcslen(Tmp) + 1];
    wcscpy(m_pTarget->m_pName, Tmp);

    // Get the Qualifier flavor.
    // =========================

    m_pTarget->m_lType = 0;

    if (SendMessage(m_hRadioPropClass, BM_GETCHECK, 0, 0) == BST_CHECKED)
        m_pTarget->m_lType |= WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS;
    if (SendMessage(m_hRadioPropInst, BM_GETCHECK, 0, 0) == BST_CHECKED)
        m_pTarget->m_lType |= WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE;
    if (SendMessage(m_hRadioOverride, BM_GETCHECK, 0, 0) == BST_UNCHECKED)
        m_pTarget->m_lType |= WBEM_FLAVOR_NOT_OVERRIDABLE;
    if (SendMessage(m_hRadioAmended, BM_GETCHECK, 0, 0) == BST_CHECKED)
        m_pTarget->m_lType |= WBEM_FLAVOR_AMENDED;

    // NOTE: do not retrieve origin!

    // Get the type string.
    // ====================

    LRESULT nIndex = SendMessage(m_hQualifierType, CB_GETCURSEL, 0, 0);

    if (SendMessage(m_hQualifierType, CB_GETLBTEXT, nIndex, LPARAM(buf)) == CB_ERR)
    {
        MessageBox(IDS_INVALID_QUALIFIER_TYPE, IDS_ERROR, MB_OK);
        return FALSE;
    }

    // Convert type string to a type.
    // ==============================
    int nType = StringToType(buf);
    if (nType == 0)
    {
        MessageBox(IDS_INVALID_QUALIFIER_TYPE, IDS_ERROR, MB_OK);
        return FALSE;
    }

    if(GetCheck(IDC_ARRAY) == BST_CHECKED)
        nType |= VT_ARRAY;

    // Get the value.
    // ==============
    if (m_pTarget->m_pValue)
    {
        m_pTarget->m_pValue->Empty();
        m_pTarget->m_pValue->SetAsNull();
    }

    CVar *pTemp = 0;

    if (GetWindowText(m_hQualifierVal, buf, TEMP_BUF))
    {
        StripTrailingWs(buf);
        pTemp = StringToValue(buf, nType);
    }
    else  // Value is NULL
    {
        pTemp = new CVar;
    }

    if (pTemp)
    {
        if (m_pTarget->m_pValue)
        {
            *m_pTarget->m_pValue = *pTemp;
            delete pTemp;
        }
        else
            m_pTarget->m_pValue = pTemp;
    }
    else
    {
        MessageBox(IDS_INVALID_VALUE, IDS_ERROR, MB_OK);
        return FALSE;
    }

    return TRUE;
}

BOOL CTestQualifierEditor::OnInitDialog()
{
    CenterOnParent();

    m_hQualifierName = GetDlgItem(IDC_ATTRIB_NAME);
    m_hQualifierVal = GetDlgItem(IDC_ATTRIB_VALUE);
    m_hQualifierType = GetDlgItem(IDC_ATTRIB_TYPE);

    m_hRadioPropInst = GetDlgItem(IDC_PROP_INST);
    m_hRadioPropClass = GetDlgItem(IDC_PROP_CLASS);
    m_hRadioOverride = GetDlgItem(IDC_OVERRIDE);
    m_hRadioPropagated = GetDlgItem(IDC_PROPAGATED);
    m_hRadioAmended = GetDlgItem(IDC_AMENDED);

    SendMessage(m_hRadioPropInst, BM_SETCHECK, 
        (m_pTarget->m_lType & WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE)?BST_CHECKED:BST_UNCHECKED,
        0);
    SendMessage(m_hRadioPropClass, BM_SETCHECK, 
        (m_pTarget->m_lType & WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS)?BST_CHECKED:BST_UNCHECKED,
        0);
    SendMessage(m_hRadioOverride, BM_SETCHECK,
        (m_pTarget->m_lType & WBEM_FLAVOR_NOT_OVERRIDABLE)?BST_UNCHECKED:BST_CHECKED,
        0);
    SendMessage(m_hRadioPropagated, BM_SETCHECK, 
        (m_pTarget->m_lType & WBEM_FLAVOR_ORIGIN_PROPAGATED)?BST_CHECKED:BST_UNCHECKED,
        0);
    SendMessage(m_hRadioAmended, BM_SETCHECK, 
        (m_pTarget->m_lType & WBEM_FLAVOR_AMENDED)?BST_CHECKED:BST_UNCHECKED,
        0);

    EnableWindow(m_hRadioPropagated, FALSE);

    // Default property name.
    // ======================

    if (m_pTarget->m_pName)
        SetWindowText(m_hQualifierName, LPWSTRToLPSTR(m_pTarget->m_pName));

    // Populate the combo box with the valid Qualifier types
    // ======================================================

    for (int i = 0; i < nNumValidQualifierTypes; i++)
        SendMessage(m_hQualifierType, CB_ADDSTRING, 0, LPARAM(ValidQualifierTypes[i]));

    // If a type is assigned, select it.
    // =================================

    if (m_pTarget->m_pValue) 
    {
        long lType = m_pTarget->m_pValue->GetOleType();
        LPSTR pTypeStr = TypeToString(lType & ~VT_ARRAY);
        SendMessage(m_hQualifierType, CB_SELECTSTRING, WPARAM(-1), 
            LPARAM(pTypeStr));

        // Set the array bit
        // =================

        SetCheck(IDC_ARRAY, 
            ((lType & VT_ARRAY) ? BST_CHECKED : BST_UNCHECKED));
    }
    // Else select VT_BSTR by default.
    // ===============================
    else
    {
        SendMessage(m_hQualifierType, CB_SELECTSTRING, WPARAM(-1), LPARAM("CIM_STRING"));
    }

    // If a value is assigned, initialize it.
    // ======================================

    if (m_pTarget->m_pValue)
    {
        LPSTR pVal = ValueToString(m_pTarget->m_pValue);
        SetWindowText(m_hQualifierVal, pVal);
    }

    // If editing, don't allow the user to change
    // the Qualifier name or type.
    // ==========================================
    if (m_bEditing)
    {
        EnableWindow(m_hQualifierName, FALSE);
    }

    return TRUE;
}

CTestQualifierEditor::CTestQualifierEditor(
    HWND hParent,
    CTestQualifier *pTarget,
    BOOL bEditing
    ) : CWbemDialog(IDD_ATTRIB_EDITOR, hParent)
{
    m_pTarget = pTarget;
    m_bEditing = bEditing;
}

INT_PTR CTestQualifierEditor::Edit()
{
    return Run();
}



CEmbeddedObjectListEditor::CEmbeddedObjectListEditor(HWND hParent, LONG lGenFlags, LONG lQryFlags,
                                                     LPCWSTR wszPropName, CVarVector* pVarVector)
    : CQueryResultDlg(hParent, lGenFlags, lQryFlags), m_wsPropName((LPWSTR)wszPropName)
{
    m_pVarVector = pVarVector;
    for(int i = 0; i < pVarVector->Size(); i++)
    {
		CVar	vTemp;

		pVarVector->FillCVarAt( i, vTemp );

        IWbemClassObject* pObj = (IWbemClassObject*) vTemp.GetEmbeddedObject();
        m_InternalArray.Add(pObj);

        // Verify the object pointer

        if ( NULL != pObj )
        {
            pObj->Release();
        }
    }
}

CEmbeddedObjectListEditor::~CEmbeddedObjectListEditor()
{
    // Prevent object release --- we don't own them.
    // =============================================
}

BOOL CEmbeddedObjectListEditor::OnInitDialog()
{
    char szBuffer[1000];
    char szFormat[104];
    if(LoadString(GetModuleHandle(NULL), IDS_EMBEDDED_ARRAY, szFormat, 104))
    {
        sprintf(szBuffer, szFormat, (LPWSTR)m_wsPropName);
        SetTitle(szBuffer);
    }
    else
        SetTitle("Embedded array");

    BOOL bRet = CQueryResultDlg::OnInitDialog();
    SetComplete(WBEM_S_NO_ERROR, NULL, NULL);
    return bRet;
}

BOOL CEmbeddedObjectListEditor::Verify()
{
	// First AddRef all elements - this is so we don't release objects
	// out from underneath ourselves.
    for(int i = 0; i < m_InternalArray.Size(); i++)
    {
        IWbemClassObject* pObj = (IWbemClassObject*)m_InternalArray[i];

		if ( NULL != pObj )
		{
			pObj->AddRef();
		}
    }

	// Now axe the elements in the Vector
    while(m_pVarVector->Size()) m_pVarVector->RemoveAt(0);

	// First AddRef all elements - this is so we don't release objects
	// out from underneath ourselves.
    for(int i = 0; i < m_InternalArray.Size(); i++)
    {
        IWbemClassObject* pObj = (IWbemClassObject*)m_InternalArray[i];
        CVar v;
        v.SetEmbeddedObject((I_EMBEDDED_OBJECT*)pObj);
        m_pVarVector->Add( v );
    }


    return TRUE;
}

IWbemClassObject* CEmbeddedObjectListEditor::AddNewElement()
{
    return _CreateInstance(m_hDlg, m_lGenFlags, m_lSync, m_lTimeout);
}


BOOL CEmbeddedObjectListEditor::DeleteListElement(int nSel)
{
    return TRUE;
}



//***************************************************************************
//
//  class CTestPropertyEditor
//
//***************************************************************************

class CTestPropertyEditor : public CWbemDialog
{
    CTestProperty *m_pTarget;
    BOOL m_bEditOnly;
    BOOL m_bInstance;
    LONG m_lGenFlags;   // generic WBEM_FLAG_ .. flags
    LONG m_lSync;       // sync, async, semisync
    LONG m_lTimeout;    // used for semisync

    // Control handles.
    // ================

    HWND m_hPropName;
    HWND m_hPropType;
    HWND m_hValue;
    HWND m_hQualifierList;


public:
    CTestPropertyEditor(HWND hParent, LONG lGenFlags, BOOL bEditOnly, LONG lSync, 
                        CTestProperty *pProp, BOOL bInstance, LONG lTimeout);
    INT_PTR Edit();

    BOOL OnInitDialog();
    BOOL Verify();
    BOOL OnCommand(WORD wCode, WORD wID);
    BOOL OnDoubleClick(int nID);
    BOOL OnSelChange(int nID);

    void Refresh();
    void OnAddQualifier();
    void OnDelQualifier();
    void OnEditQualifier();
    void OnKey();
    void OnIndexed();
    void OnNotNull();
    void ViewEmbedding();
    void OnValueNull();
    void OnValueNotNull();
    void OnArray();

    int RemoveSysQuals();
    void SetSystemCheck(int nID);
};


void CTestPropertyEditor::OnAddQualifier()
{
    CTestQualifier att;

    att.m_lType =  
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | 
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS;

    CTestQualifierEditor ed(m_hDlg, &att, FALSE);
    INT_PTR nRes = ed.Edit();
    if ((nRes == IDCANCEL) || (nRes == 0))
        return;


    // If here, the Qualifier is being added.
    // ======================================

    IWbemQualifierSet* pQualifierSet = m_pTarget->m_pQualifiers;

    VARIANT *p = att.m_pValue->GetNewVariant();

    HRESULT hres = pQualifierSet->Put(att.m_pName, p, att.m_lType);
    if(FAILED(hres))
    {
        FormatError(hres, m_hDlg);
    }

    VariantClear(p);
    Refresh();
}

void CTestPropertyEditor::SetSystemCheck(int nID)
{
    SetCheck(IDC_KEY, BST_UNCHECKED);
    SetCheck(IDC_INDEXED, BST_UNCHECKED);
    SetCheck(IDC_NOT_NULL, BST_UNCHECKED);
    SetCheck(IDC_NORMAL, BST_UNCHECKED);
    SetCheck(nID, BST_CHECKED);
}

int CTestPropertyEditor::RemoveSysQuals()
{
    IWbemQualifierSet* pSet = m_pTarget->m_pQualifiers;
    HRESULT hres;
    hres = pSet->Delete(L"key");
    if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
    {
        SetSystemCheck(IDC_KEY);
        return IDC_KEY;
    }

    hres = pSet->Delete(L"indexed");
    if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
    {
        SetSystemCheck(IDC_INDEXED);
        return IDC_INDEXED;
    }

    hres = pSet->Delete(L"not_null");
    if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
    {
        SetSystemCheck(IDC_NOT_NULL);
        return IDC_NOT_NULL;
    }

    return 0;
}

void CTestPropertyEditor::OnIndexed()
{
    IWbemQualifierSet* pQualifierSet = m_pTarget->m_pQualifiers;
    int nRes = RemoveSysQuals();
    if(nRes != 0)
    {
        MessageBox(IDS_CANNOT_CHANGE_SYSTEM_QUALS, IDS_ERROR, MB_OK);
        return;
    }

    VARIANT v;
    V_VT(&v) = VT_BOOL;
    V_BOOL(&v) = VARIANT_TRUE;
    HRESULT hres = pQualifierSet->Put(L"indexed", 
                &v,
                WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | 
                WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS);

    if(FAILED(hres))
    {
        MessageBox(IDS_MAY_NOT_SPECIFY_INDEXED, IDS_ERROR,
            MB_OK | MB_ICONSTOP);
        
        SetSystemCheck(IDC_NORMAL);
    }
}

void CTestPropertyEditor::OnKey()
{
    IWbemQualifierSet* pQualifierSet = m_pTarget->m_pQualifiers;
    int nRes = RemoveSysQuals();
    if(nRes != 0)
    {
        MessageBox(IDS_CANNOT_CHANGE_SYSTEM_QUALS, IDS_ERROR, MB_OK);
        return;
    }

    VARIANT v;
    V_VT(&v) = VT_BOOL;
    V_BOOL(&v) = VARIANT_TRUE;
    HRESULT hres = pQualifierSet->Put(L"key", 
                &v,
                WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | 
                WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS);

    if(FAILED(hres) && hres == WBEM_E_CANNOT_BE_KEY)
    {
        MessageBox(IDS_MAY_NOT_SPECIFY_KEY, IDS_ERROR,
            MB_OK | MB_ICONSTOP);
        
        SetSystemCheck(IDC_NORMAL);
    }
}

void CTestPropertyEditor::OnNotNull()
{
    IWbemQualifierSet* pQualifierSet = m_pTarget->m_pQualifiers;
    int nRes = RemoveSysQuals();
    if(nRes != 0)
    {
        MessageBox(IDS_CANNOT_CHANGE_SYSTEM_QUALS, IDS_ERROR, MB_OK);
        return;
    }
    VARIANT v;
    V_VT(&v) = VT_BOOL;
    V_BOOL(&v) = VARIANT_TRUE;
    HRESULT hres = pQualifierSet->Put(L"not_null", 
                &v,
                WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | 
                WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS);

    if(FAILED(hres))
    {
        MessageBox(IDS_MAY_NOT_SPECIFY_NOT_NULL, IDS_ERROR,
            MB_OK | MB_ICONSTOP);
        
        SetSystemCheck(IDC_NORMAL);
    }
}


void CTestPropertyEditor::OnEditQualifier()
{
    // See if anything is selected.
    // ============================
    LRESULT nSel = SendMessage(m_hQualifierList, LB_GETCURSEL, 0, 0);

    if (nSel == LB_ERR)
        return;

    char buf[TEMP_BUF];
    *buf = 0;
    SendMessage(m_hQualifierList, LB_GETTEXT, nSel, LPARAM(buf));
    if (*buf == 0)
        return;

    // At this point, the text of the selected Qualifier is in <buf>.
    // ==============================================================

    char name[TEMP_BUF];
    *name = 0;
    if (sscanf(buf, "%[^\t\0]", name) == EOF)
		return;
    if (*name == 0)
        return;

    WString WName = name;

    // Find the Qualifier in question.
    // ===============================

    VARIANT v;
    VariantInit(&v);
    LONG lType = 0;
    IWbemQualifierSet* pQualifierSet = m_pTarget->m_pQualifiers;

    CBString bsWName(WName);

    SCODE res = pQualifierSet->Get(bsWName.GetString(), 0, &v, &lType);
    if (res != 0)
    {
        MessageBox(IDS_QUALIFIER_NOT_FOUND, IDS_CRITICAL_ERROR, MB_OK);
        return;
    }

    // If here, convert temporarily to a CTestQualifier object for the duration of
    // the edit.
    // ====================================================================

    CVar *pNewVal = new CVar;
    pNewVal->SetVariant(&v);
    VariantClear(&v);

    CTestQualifier att;
    att.m_pValue = pNewVal;
    att.m_pName = new wchar_t[wcslen(WName) + 1];
    wcscpy(att.m_pName, WName);
    att.m_lType = lType;

    CTestQualifierEditor ed(m_hDlg, &att, TRUE);
    INT_PTR nRes = ed.Edit();
    if ((nRes == IDCANCEL) || (nRes == 0))
    {
        return;
    }

    // If here, the Qualifier is being added.
    // ======================================

    VARIANT *p = att.m_pValue->GetNewVariant();

    CBString bsName(att.m_pName);

    res = pQualifierSet->Put(bsName.GetString(), p, att.m_lType);
    if(FAILED(res))
    {
        FormatError(res, m_hDlg);
    }
    VariantClear(p);
    Refresh();
}

//ok
void CTestPropertyEditor::OnDelQualifier()
{
    // See if anything is selected.
    // ============================
    LRESULT nSel = SendMessage(m_hQualifierList, LB_GETCURSEL, 0, 0);

    if (nSel == LB_ERR)
        return;

    char buf[TEMP_BUF];
    *buf = 0;
    SendMessage(m_hQualifierList, LB_GETTEXT, nSel, LPARAM(buf));
    if (*buf == 0)
        return;

    // At this point, the text of the selected Qualifier is in <buf>.
    // ==============================================================

    char name[TEMP_BUF];
    *name = 0;
    if (sscanf(buf, "%[^\t\0]", name) == EOF)
		return;
    if (*name == 0)
        return;

    WString WName = name;

    // Remove the Qualifier.
    // =====================

    IWbemQualifierSet *pQualifierSet = m_pTarget->m_pQualifiers;

    CBString bsName(WName);

    HRESULT hres = pQualifierSet->Delete(bsName.GetString());
    if(FAILED(hres) || hres != 0)
    {
        FormatError(hres, m_hDlg);
    }
    Refresh();
}

void CTestPropertyEditor::Refresh()
{
    // Zap the current contents.
    // =========================
    SendMessage(m_hQualifierList, LB_RESETCONTENT, 0, 0);
    SetCheck(IDC_KEY, BST_UNCHECKED);
    SetCheck(IDC_INDEXED, BST_UNCHECKED);
    SetCheck(IDC_NOT_NULL, BST_UNCHECKED);
    SetCheck(IDC_NORMAL, BST_CHECKED);

    // Fill in the Qualifier list.
    // ===========================

    IWbemQualifierSet *pQualifiers = m_pTarget->m_pQualifiers;

    if(pQualifiers == NULL)
    {
        EnableWindow(m_hQualifierList, FALSE);
        EnableWindow(GetDlgItem(IDC_KEY), FALSE);
        EnableWindow(GetDlgItem(IDC_INDEXED), FALSE);
        EnableWindow(GetDlgItem(IDC_NOT_NULL), FALSE);
        EnableWindow(GetDlgItem(IDC_NORMAL), FALSE);
        EnableWindow(GetDlgItem(IDC_ADD_ATTRIB), FALSE);
        EnableWindow(GetDlgItem(IDC_EDIT_ATTRIB), FALSE);
        EnableWindow(GetDlgItem(IDC_DELETE_ATTRIB), FALSE);
        EnableWindow(GetDlgItem(IDC_STATIC_QUAL), FALSE);
    }

    if (pQualifiers)
    {
        pQualifiers->BeginEnumeration(0);

        BSTR strName = NULL;
        long lFlavor;
        VARIANT vVal;
        VariantInit(&vVal);

        while(pQualifiers->Next(0, &strName, &vVal, &lFlavor) == S_OK)
        {
            if(!_wcsicmp(strName, L"key"))
            {
                SetSystemCheck(IDC_KEY);
                SysFreeString(strName);
                strName = NULL;
                continue;
            }
            else if(!_wcsicmp(strName, L"indexed"))
            {
                if(GetCheck(IDC_KEY) == BST_UNCHECKED)
                {
                    SetSystemCheck(IDC_INDEXED);
                }
                SysFreeString(strName);
                strName = NULL;
                continue;
            }
            else if(!_wcsicmp(strName, L"not_null"))
            {
                if(GetCheck(IDC_KEY) == BST_UNCHECKED && 
                        GetCheck(IDC_INDEXED) == BST_UNCHECKED)
                {
                    SetSystemCheck(IDC_NOT_NULL);
                }
                SysFreeString(strName);
                strName = NULL;
                continue;
            }
                
            CTestQualifier A;
            A.m_pName = new wchar_t[wcslen(strName) + 1];
            wcscpy(A.m_pName, strName);
            A.m_pValue = new CVar(&vVal);
            A.m_lType = lFlavor;

            // Build list box string.
            // ======================

            SendMessage(m_hQualifierList, LB_ADDSTRING, 0,LPARAM(CTestQualifierToString(&A)));
            VariantClear(&vVal);
            SysFreeString(strName);
            strName = NULL;
        }

        pQualifiers->EndEnumeration();
        VariantClear(&vVal);
    }
}

BOOL CTestPropertyEditor::OnDoubleClick(int nID)
{
    if(nID == IDC_ATTRIB_LIST)
    {
        OnEditQualifier();
        return TRUE;
    }
    return FALSE;
}

BOOL CTestPropertyEditor::OnSelChange(int nID)
{
    if(nID == IDC_TYPE_LIST)
    {
        char* pszType = GetCBCurSelString(IDC_TYPE_LIST);
        BOOL bArray = (GetCheck(IDC_ARRAY) == BST_CHECKED);
        m_pTarget->m_lType = StringToType(pszType);
        if(bArray)
            m_pTarget->m_lType |= VT_ARRAY;

        if((m_pTarget->m_lType & ~VT_ARRAY) == VT_EMBEDDED_OBJECT)
        {
            ShowWindow(GetDlgItem(IDC_EMBEDDING), SW_SHOW);
        }
        else
        {
            ShowWindow(GetDlgItem(IDC_EMBEDDING), SW_HIDE);
        }
        delete [] pszType;
    }
    return TRUE;
}

BOOL CTestPropertyEditor::OnCommand(WORD wCode, WORD wID)
{
    switch(wID)
    {
        case IDC_EDIT_ATTRIB: OnEditQualifier(); return TRUE;

        case IDC_ADD_ATTRIB: OnAddQualifier(); return TRUE;
        case IDC_DELETE_ATTRIB: OnDelQualifier(); return TRUE;
        case IDC_KEY:
            if(wCode == BN_CLICKED)
                OnKey();
            return TRUE;
        case IDC_INDEXED:
            if(wCode == BN_CLICKED)
                OnIndexed();
            return TRUE;
        case IDC_NOT_NULL:
            if(wCode == BN_CLICKED)
                OnNotNull();
            return TRUE;
        case IDC_NORMAL:
            if(wCode == BN_CLICKED)
                RemoveSysQuals();
            return TRUE;
        case IDC_VALUE_NULL:
            OnValueNull();
            return TRUE;
        case IDC_VALUE_NOT_NULL:
            OnValueNotNull();
            return TRUE;
        case IDC_EMBEDDING:
            ViewEmbedding();
            return TRUE;
        case IDC_ARRAY:
            OnArray();
            return TRUE;
    }

    return TRUE;
}

void CTestPropertyEditor::OnArray()
{
    if(GetCheck(IDC_ARRAY) == BST_CHECKED)
        m_pTarget->m_lType |= VT_ARRAY;
    else
        m_pTarget->m_lType &= ~VT_ARRAY;
}

void CTestPropertyEditor::OnValueNull()
{      
    if((m_pTarget->m_lType & ~VT_ARRAY) == VT_EMBEDDED_OBJECT)
    {
        if(MessageBox(IDS_SAVE_EMBEDDING, IDS_WARNING, 
            MB_ICONQUESTION | MB_YESNO) == IDYES)
        {
            SetCheck(IDC_VALUE_NULL, BST_UNCHECKED);
            SetCheck(IDC_VALUE_NOT_NULL, BST_CHECKED);
            return;
        }
        else
        {
            delete m_pTarget->m_pValue;
            m_pTarget->m_pValue = NULL;
            SetDlgItemText(IDC_VALUE, "");
        }
    }
        
    EnableWindow(m_hValue, FALSE);
    EnableWindow(GetDlgItem(IDC_EMBEDDING), FALSE);
}

void CTestPropertyEditor::OnValueNotNull()
{      
    if((m_pTarget->m_lType & ~VT_ARRAY) != VT_EMBEDDED_OBJECT)
    {
        EnableWindow(m_hValue, TRUE);
    }
    EnableWindow(GetDlgItem(IDC_EMBEDDING), TRUE);
}

BOOL CTestPropertyEditor::OnInitDialog()
{
    ShowWindow(GetDlgItem(IDC_EMBEDDING), SW_HIDE);
    CenterOnParent();

    m_hPropName = GetDlgItem(IDC_PROPNAME);
    m_hPropType = GetDlgItem(IDC_TYPE_LIST);
    m_hValue = GetDlgItem(IDC_VALUE);
    m_hQualifierList = GetDlgItem(IDC_ATTRIB_LIST);

    LONG Tabs[] = { 80, 140, 170 };
    int TabCount = 3;

    SendMessage(m_hQualifierList, LB_SETTABSTOPS,
        (WPARAM) TabCount, (LPARAM) Tabs);

    // Populate the combo box with the valid prop types
    // ================================================

    for (int i = 0; i < g_nNumValidPropTypes; i++)
        SendMessage(m_hPropType, CB_ADDSTRING, 0, LPARAM(g_aValidPropTypes[i]));

    SendMessage(m_hPropType, CB_SELECTSTRING, WPARAM(-1), LPARAM("CIM_STRING"));

    // Now initialize the controls with the contents of the
    // current object, if any.
    // ====================================================

    if (m_pTarget->m_pName)
    {
        SetWindowText(m_hPropName, LPWSTRToLPSTR(m_pTarget->m_pName));
    }

    if(m_pTarget->m_pClass)
    {
        SetDlgItemText(IDC_ORIGIN, LPWSTRToLPSTR(m_pTarget->m_pClass));
    }

    // If the value is available, set the text and select.
    // ===================================================

    if (m_pTarget->m_pValue)
    {
        LPSTR pTypeStr = TypeToString(m_pTarget->m_lType & ~VT_ARRAY);
        SendMessage(m_hPropType, CB_SELECTSTRING, WPARAM(-1), LPARAM(pTypeStr));
        if(m_pTarget->m_lType & VT_ARRAY)
            SetCheck(IDC_ARRAY, BST_CHECKED);
        else
            SetCheck(IDC_ARRAY, BST_UNCHECKED);

        if((m_pTarget->m_lType & ~VT_ARRAY) == VT_EMBEDDED_OBJECT)
        {
            ShowWindow(GetDlgItem(IDC_EMBEDDING), SW_SHOW);
        }

        if(m_pTarget->m_pValue->IsNull())
        {
            SetCheck(IDC_VALUE_NULL, BST_CHECKED);
            EnableWindow(m_hValue, FALSE);
            EnableWindow(GetDlgItem(IDC_EMBEDDING), FALSE);
        }
        else
        {
            SetCheck(IDC_VALUE_NOT_NULL, BST_CHECKED);
            LPSTR pValStr = ValueToNewString(m_pTarget->m_pValue, 
                                            m_pTarget->m_lType);
            SetWindowText(m_hValue, pValStr);
            delete [] pValStr;
            EnableWindow(m_hValue, strstr(pTypeStr, "VT_EMBEDDED_OBJECT") 
                                    == NULL);
        }
    }
    else
    {
        SetCheck(IDC_VALUE_NULL, BST_CHECKED);
        SendMessage(m_hPropType, CB_SELECTSTRING, WPARAM(-1), LPARAM("VT_BSTR"));
        EnableWindow(m_hValue, FALSE);
        EnableWindow(GetDlgItem(IDC_EMBEDDING), FALSE);
    }

    // Refresh the Qualifiers.
    // =======================

    Refresh();

    // If editing, don't allow type/name change.
    // =========================================

    if (m_bEditOnly)
    {
        EnableWindow(m_hPropName, FALSE);
        EnableWindow(m_hPropType, FALSE);
    }

    if(m_bInstance)
    {
        EnableWindow(GetDlgItem(IDC_KEY), FALSE);
        EnableWindow(GetDlgItem(IDC_INDEXED), FALSE);
        EnableWindow(GetDlgItem(IDC_NOT_NULL), FALSE);
        EnableWindow(GetDlgItem(IDC_NORMAL), FALSE);
    }

    return TRUE;
}

void CTestPropertyEditor::ViewEmbedding()
{
    if(m_pTarget->m_lType == VT_EMBEDDED_OBJECT)
    {
        if(m_pTarget->m_pValue != NULL &&
            m_pTarget->m_pValue->GetType() != VT_EMBEDDED_OBJECT)
        {
            delete m_pTarget->m_pValue;
            m_pTarget->m_pValue = NULL;
        }

        if(m_pTarget->m_pValue == NULL)
        {
            m_pTarget->m_pValue = new CVar;
            m_pTarget->m_pValue->SetEmbeddedObject(NULL);
        }

        IWbemClassObject* pCurrentEmbed = 
            (IWbemClassObject*)m_pTarget->m_pValue->GetEmbeddedObject();

        IWbemClassObject* pEmbed;
        if(pCurrentEmbed == NULL)
        {
            pEmbed = PreCreateInstance(m_hDlg, m_lGenFlags, m_lSync, m_lTimeout);
            if(pEmbed == NULL) return;
        }
        else
        {
            pCurrentEmbed->Clone(&pEmbed);
            pCurrentEmbed->Release();
        }

        CObjectEditor ed(m_hDlg, m_lGenFlags, CObjectEditor::readwrite, m_lSync, 
                         pEmbed, m_lTimeout);
        if(ed.Edit() == IDOK)
        {
            m_pTarget->m_pValue->SetEmbeddedObject(pEmbed);
            SetDlgItemText(IDC_VALUE, "<embedded object>");
        }

        pEmbed->Release();
    }
    else if(m_pTarget->m_lType == (VT_EMBEDDED_OBJECT | VT_ARRAY))
    {
        if(m_pTarget->m_pValue != NULL &&
            m_pTarget->m_pValue->GetType() != VT_EX_CVARVECTOR)
        {
            delete m_pTarget->m_pValue;
            m_pTarget->m_pValue = NULL;
        }

        if(m_pTarget->m_pValue == NULL)
        {
            m_pTarget->m_pValue = new CVar;
            CVarVector* pvv = new CVarVector(VT_EMBEDDED_OBJECT);
            m_pTarget->m_pValue->SetVarVector(pvv, TRUE);
        }

        CVarVector* pCurrentEmbed = m_pTarget->m_pValue->GetVarVector();
        
        CEmbeddedObjectListEditor ed(m_hDlg, m_lGenFlags, 0, m_pTarget->m_pName,
                                     pCurrentEmbed);
        // Pass on invocation method (sync, async..) related settings for use
        // by any further operations (editing/deleting/etc. of an instance).
        ed.SetCallMethod(m_lSync);
        ed.SetTimeout(m_lTimeout);

        ed.Run();
        SetDlgItemText(IDC_VALUE, "<array of embedded objects>");
    }
    else
    {
        ShowWindow(GetDlgItem(IDC_EMBEDDING), SW_HIDE);
    }
}
                

BOOL CTestPropertyEditor::Verify()
{
    // Buffer is used for property name, value string (which can be long if an array), and type string).
    // Find the largest of the three for buffer length (TEMP_BUF size is used for type).
    int   buflen = max(max(GetWindowTextLength(m_hPropName), GetWindowTextLength(m_hValue)) + 1, TEMP_BUF);
    char* buf = new char[buflen];

    // Verify that name is present.
    // ============================

    if (GetWindowText(m_hPropName, buf, buflen) == 0)
    {
        MessageBox(IDS_NO_PROPERTY_NAME, IDS_ERROR, MB_OK);
        delete [] buf;
        return FALSE;
    }
    StripTrailingWs(buf);

    WString Name = buf;

    if (m_pTarget->m_pName)
        delete m_pTarget->m_pName;

    m_pTarget->m_pName = new wchar_t[wcslen(Name) + 1];
    wcscpy(m_pTarget->m_pName, Name);

    // Get the type.
    // =============

    LRESULT nIndex = SendMessage(m_hPropType, CB_GETCURSEL, 0, 0);

    if (SendMessage(m_hPropType, CB_GETLBTEXT, nIndex, LPARAM(buf)) == CB_ERR)
    {
        MessageBox(IDS_INVALID_PROPERTY_TYPE, IDS_ERROR, MB_OK);
        delete [] buf;
        return FALSE;
    }

    // Convert type string to a type.
    // ==============================

    int nType = StringToType(buf);
    if(GetCheck(IDC_ARRAY) == BST_CHECKED)
        nType |= VT_ARRAY;
    if (nType == 0)
    {
        MessageBox(IDS_INVALID_PROPERTY_TYPE, IDS_ERROR, MB_OK);
        delete [] buf;
        return FALSE;
    }

    m_pTarget->m_lType = nType;

    // Verify that Value is present.
    // =============================

    CVar *p;
    if(GetCheck(IDC_VALUE_NULL) == BST_CHECKED)
    {
        p = new CVar;
        p->SetAsNull();
    }
    else
    {
        *buf = 0;
        GetWindowText(m_hValue, buf, buflen);
        StripTrailingWs(buf);

        // Convert value string to the correct value.
        // ==========================================

        if((nType & ~VT_ARRAY) != VT_EMBEDDED_OBJECT)
        {
            p = StringToValue(buf, nType);
        }
        else
        {
            // otherwise already there
            p = m_pTarget->m_pValue;
        }
    }

    if (!p)
    {
        MessageBox(IDS_INVALID_PROPERTY_VALUE, IDS_ERROR, MB_OK);
        delete [] buf;
        return FALSE;
    }

    if(m_pTarget->m_pValue != p)
    {
        if (m_pTarget->m_pValue)
            delete m_pTarget->m_pValue;

        m_pTarget->m_pValue = p;
    }

    delete [] buf;
    return TRUE;
}

CTestPropertyEditor::CTestPropertyEditor(HWND hParent, LONG lGenFlags, BOOL bEditOnly, LONG lSync,
                                         CTestProperty* pProp, BOOL bInstance, LONG lTimeout) 
    : CWbemDialog(IDD_PROPERTY_EDITOR, hParent)
{
    m_pTarget = pProp;
    m_lGenFlags = lGenFlags;
    m_bEditOnly = bEditOnly;
    m_lSync = lSync;
    m_bInstance = bInstance;
    m_lTimeout = lTimeout;
}

INT_PTR CTestPropertyEditor::Edit()
{
    return Run();
}

void CObjectEditor::OnAddQualifier()
{
    CTestQualifier att;

    att.m_lType = WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | 
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS;

    CTestQualifierEditor ed(m_hDlg, &att, FALSE);
    INT_PTR nRes = ed.Edit();
    if ((nRes == IDCANCEL) || (nRes == 0))
        return;

    // If here, the Qualifier is being added.
    // ======================================

    IWbemQualifierSet* pQualifierSet = 0;
    m_pObj->GetQualifierSet(&pQualifierSet);

    VARIANT *p = att.m_pValue->GetNewVariant();

    CBString bsName(att.m_pName);

    /*
    DWORD dwFlavor = 
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | 
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS;
    */

    HRESULT hres = pQualifierSet->Put(bsName.GetString(), p, att.m_lType);
    if(FAILED(hres))
    {
        FormatError(hres, m_hDlg);
    }
    VariantClear(p);
    pQualifierSet->Release();
    Refresh();
}

void CObjectEditor::OnEditQualifier()
{
    // See if anything is selected.
    // ============================
    LRESULT nSel = SendMessage(m_hQualifierList, LB_GETCURSEL, 0, 0);

    if (nSel == LB_ERR)
        return;

    char buf[TEMP_BUF];
    *buf = 0;
    SendMessage(m_hQualifierList, LB_GETTEXT, nSel, LPARAM(buf));
    if (*buf == 0)
        return;

    // At this point, the text of the selected Qualifier is in <buf>.
    // ==============================================================

    char name[TEMP_BUF];
    *name = 0;
    if (sscanf(buf, "%[^\t\0]", name) == EOF)
		return;
    if (*name == 0)
        return;

    WString WName = name;

    // Find the Qualifier in question.
    // ===============================

    IWbemQualifierSet* pQualifierSet = 0;
    VARIANT v;
    VariantInit(&v);
    LONG lType = 0;
    m_pObj->GetQualifierSet(&pQualifierSet);
    SCODE res = pQualifierSet->Get(WName, 0, &v, &lType);
    if (res != 0)
    {
        MessageBox(IDS_QUALIFIER_NOT_FOUND, IDS_CRITICAL_ERROR, MB_OK);
        pQualifierSet->Release();
        return;
    }

    // If here, convert temporarily to a CTestQualifier object for the duration of
    // the edit.
    // ====================================================================

    CVar *pNewVal = new CVar;
    pNewVal->SetVariant(&v);
    VariantClear(&v);

    CTestQualifier att;
    att.m_pValue = pNewVal;
    att.m_pName = new wchar_t[wcslen(WName) + 1];
    wcscpy(att.m_pName, WName);
    att.m_lType = lType;

    CTestQualifierEditor ed(m_hDlg, &att, TRUE);
    INT_PTR nRes = ed.Edit();
    if ((nRes == IDCANCEL) || (nRes == 0))
    {
        pQualifierSet->Release();
        return;
    }

    // If here, the Qualifier is being added.
    // ======================================

    m_pObj->GetQualifierSet(&pQualifierSet);

    VARIANT *p = att.m_pValue->GetNewVariant();

    CBString bsName(att.m_pName);

    res = pQualifierSet->Put(bsName.GetString(), p, att.m_lType);
    if(FAILED(res))
    {
        FormatError(res, m_hDlg);
    }
    VariantClear(p);
    pQualifierSet->Release();
    Refresh();
}

//
//
// Called when deleting an Qualifier on the object itself.
//

void CObjectEditor::OnDelQualifier()
{
    // See if anything is selected.
    // ============================
    LRESULT nSel = SendMessage(m_hQualifierList, LB_GETCURSEL, 0, 0);

    if (nSel == LB_ERR)
        return;

    char buf[TEMP_BUF];
    *buf = 0;
    SendMessage(m_hQualifierList, LB_GETTEXT, nSel, LPARAM(buf));
    if (*buf == 0)
        return;

    // At this point, the text of the selected Qualifier is in <buf>.
    // ==============================================================

    char name[TEMP_BUF];
    *name = 0;
    if (sscanf(buf, "%[^\t\0]", name) == EOF)
		return;
    if (*name == 0)
        return;

    WString WName = name;

    // Remove the Qualifier.
    // =====================

    IWbemQualifierSet *pQualifierSet;
    m_pObj->GetQualifierSet(&pQualifierSet);
    HRESULT hres = pQualifierSet->Delete(WName);
    if(FAILED(hres) || hres != 0)
    {
        FormatError(hres, m_hDlg);
    }
    pQualifierSet->Release();
    Refresh();
}

void CObjectEditor::OnAddProp()
{
    HRESULT hres;

    // Add a dummy property for now
    // ============================

    VARIANT v;
    VariantInit(&v);
    V_VT(&v) = VT_I4;
    V_I4(&v) = 1;

    CBString bsTemp(L"DUMMY_PROPERTY__D");

    if(FAILED(m_pObj->Put(bsTemp.GetString(), 0, &v, 0)))
    {
        MessageBox(NULL, IDS_CANNOT_ADD_PROPERTIES, IDS_ERROR, MB_OK|MB_ICONSTOP);
        return;
    }

    IWbemQualifierSet* pQualifierSet;
    m_pObj->GetPropertyQualifierSet(bsTemp.GetString(), &pQualifierSet);

    // Create CTestProperty with the dummy attr set for now
    // ================================================
    CTestProperty prop(pQualifierSet);

    VariantClear(&v);
    hres = m_pObj->Get(L"__CLASS", 0, &v, NULL, NULL);
    
    if (hres != S_OK || V_VT(&v) != VT_BSTR )
    {
        prop.m_pClass = new wchar_t[wcslen(L"Unknown") + 1];
        wcscpy(prop.m_pClass, L"Unknown");
    }
    else
    {
        prop.m_pClass = new wchar_t[wcslen(V_BSTR(&v)) + 1];
        wcscpy(prop.m_pClass, V_BSTR(&v));
        VariantClear(&v);
    }

    CTestPropertyEditor ed(m_hDlg, m_lGenFlags, FALSE, m_lSync, &prop, FALSE, 
                           m_lTimeout);
    INT_PTR nRes = ed.Edit();
    if ((nRes == IDCANCEL) || (nRes == 0))
    {
        pQualifierSet->Release();
        m_pObj->Delete(bsTemp.GetString());
        return;
    }

    // Set the property
    // ================

    VARIANT* pVariant = prop.m_pValue->GetNewVariant();

    bsTemp = prop.m_pName;

    VARTYPE vtType;
    if(m_bClass)
    {
        vtType = (VARTYPE)prop.m_lType;
    }
    else 
    {
        vtType = 0;
    }

    hres = m_pObj->Put(bsTemp.GetString(), 0, pVariant, vtType);
    VariantClear(pVariant);
    if(FAILED(hres))
    {
        FormatError(hres, m_hDlg);
        return;
    }

    // Copy the Qualifiers
    // ===================

    IWbemQualifierSet* pRealQualifierSet;

    bsTemp = prop.m_pName;
    m_pObj->GetPropertyQualifierSet(bsTemp.GetString(), &pRealQualifierSet);
    CopyQualifierSet(pRealQualifierSet, pQualifierSet, m_hDlg);

    pQualifierSet->EndEnumeration();
    pQualifierSet->Release();
    pRealQualifierSet->Release();

    bsTemp = L"DUMMY_PROPERTY__D";
    m_pObj->Delete(bsTemp.GetString());

    Refresh();
}

void CObjectEditor::OnEditProp()
{
    // Find out which property is selected.
    // ====================================

    LRESULT nIndex = SendMessage(m_hPropList, LB_GETCURSEL, 0, 0);
    if (nIndex == LB_ERR)
        return;

    char buf[TEMP_BUF];
    *buf = 0;
    SendMessage(m_hPropList, LB_GETTEXT, nIndex, LPARAM(buf));
    if (*buf == 0)
        return;

    // Scan out the property name.
    // ===========================

    char name[TEMP_BUF];
    *name = 0;
    if (sscanf(buf, "%[^\t\0]", name) == EOF)
		return;
    if (*name == 0)
        return;

    WString wsName = name;

    // Get the property value from the object
    // ======================================

    VARIANT vVal;
    CIMTYPE ctType;
    m_pObj->Get((LPWSTR)wsName, 0, &vVal, &ctType, NULL);

    // Create a CTestProperty from it
    // ==========================

    IWbemQualifierSet* pQualifierSet = 0;
    SCODE sc = m_pObj->GetPropertyQualifierSet((LPWSTR)wsName, &pQualifierSet);

    CTestProperty Copy(pQualifierSet);
    if (pQualifierSet)
        pQualifierSet->Release();

    Copy.m_pName = new wchar_t[wcslen(wsName) + 1];
    wcscpy(Copy.m_pName, wsName);
    Copy.m_pValue = new CVar(&vVal);
    Copy.m_lType = ctType;

    // Note that GetPropertyOrigin can fail for objects returned by Projection
    // Queries, so we need to be careful with strClass.

    BSTR strClass = NULL;
    m_pObj->GetPropertyOrigin((LPWSTR)wsName, &strClass);

    if ( NULL != strClass )
    {
        Copy.m_pClass = new wchar_t[wcslen(strClass)+1];
        wcscpy(Copy.m_pClass, strClass);
        SysFreeString(strClass);
    }

    // Edit it.
    // =========
    CTestPropertyEditor ed(m_hDlg, m_lGenFlags, TRUE, m_lSync, &Copy, !m_bClass, 
                           m_lTimeout);
    INT_PTR nRes = ed.Edit();
    if ((nRes == IDCANCEL) || (nRes == 0))
        return;

    // If here, we must replace the info for the property.
    // ===================================================

    VARIANT* pVariant = Copy.m_pValue->GetNewVariant();
    if(m_bClass && V_VT(pVariant) == VT_NULL)
        ctType = (VARTYPE)Copy.m_lType;
    else
        ctType = 0;

    sc = m_pObj->Put(Copy.m_pName, 0, pVariant, ctType);
    VariantClear(pVariant);
    if(FAILED(sc))
    {
        FormatError(sc, m_hDlg);
    }

    Refresh();
}

void CObjectEditor::OnDelProp()
{
    // Find out which property is selected.
    // ====================================

    LRESULT nIndex = SendMessage(m_hPropList, LB_GETCURSEL, 0, 0);
    if (nIndex == LB_ERR)
        return;

    char buf[TEMP_BUF];
    *buf = 0;
    SendMessage(m_hPropList, LB_GETTEXT, nIndex, LPARAM(buf));
    if (*buf == 0)
        return;

    // Scan out the property name.
    // ===========================

    char name[TEMP_BUF];
    *name = 0;
    if (sscanf(buf, "%[^\t\0]", name) == EOF)
		return;
    if (*name == 0)
        return;

    WString WName = name;
    if(FAILED(m_pObj->Delete(LPWSTR(WName))))
    {
        MessageBox(NULL, IDS_CANNOT_EDIT_PROPERTY, IDS_ERROR,
            MB_OK|MB_ICONSTOP);
        return;
    }

    Refresh();
}

class CMofViewer : public CWbemDialog
{
    BSTR m_strText;
public:
    CMofViewer(HWND hParent, BSTR strText) 
        : CWbemDialog(IDD_MOF, hParent), m_strText(strText)
    {}

    BOOL OnInitDialog();
};

BOOL CMofViewer::OnInitDialog()
{
    int iSize = wcslen(m_strText)*2+1;
    char* szText = new char[iSize];
    wcstombs(szText, m_strText, iSize);
    char* szText1 = new char[strlen(szText)*2+1];
    char* pc = szText;
    char* pc1 = szText1;
    while(*pc)
    {
        if(*pc == '\n')
        {
            *(pc1++) = '\r';
        }
        *(pc1++) = *(pc++);
    }
    *pc1 = 0;
    SetDlgItemText(IDC_MOF, szText1);
    delete [] szText;
    return TRUE;
}

void CObjectEditor::OnShowMof()
{
    BSTR strText;
    HRESULT hres = m_pObj->GetObjectText(0, &strText);
    if(FAILED(hres))
    {
        MessageBox(IDS_MOF_FAILED, IDS_ERROR, MB_OK);
    }
    else
    {
        CMofViewer mv(m_hDlg, strText);
        mv.Run();
    }
}


void CObjectEditor::OnRefreshObject()
{
#if 0
    BSTR strText;
	HRESULT res;
    // Asynchronous
    if (m_lSync & ASYNC)
    {
        MessageBox(IDS_ASYNC_NOT_SUPPORTED, IDS_ERROR, MB_OK);
        return;
    }
    else if (m_lSync & SEMISYNC)
    {
        IWbemCallResultEx* pCallRes = NULL;
        CHourGlass hg;
        res = g_pServicesEx->RefreshObject(&m_pObj,
                                m_lGenFlags  | WBEM_FLAG_RETURN_IMMEDIATELY,
                                g_Context, &pCallRes);

        if (SUCCEEDED(res))
        {
            LONG lStatus;
            SetInterfaceSecurityEx(pCallRes, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
            while ((res = pCallRes->GetCallStatus(m_lTimeout, &lStatus)) == WBEM_S_TIMEDOUT)
            {
                // wait
            }
            if (res == WBEM_S_NO_ERROR)
            {
                res = (HRESULT)lStatus;     // lStatus is the final result of the above IWbemServices::PutClass call
            }

            pCallRes->Release();
        }
    }

    // Synchronous
    else
    {
        CHourGlass hg;
        res = g_pServicesEx->RefreshObject(&m_pObj,
                                m_lGenFlags ,
                                g_Context, NULL);
    }




    HRESULT hres = g_pServicesEx->RefreshObject(&m_pObj, 0, NULL, NULL );
    if(FAILED(hres))
    {
        FormatError(hres, m_hDlg, NULL);
    }
	else
		Refresh();
#endif	

    HRESULT res;

    if (m_pObj)
    {
        VARIANT Var;
        VariantInit(&Var);
        
	    res = m_pObj->Get(L"__RELPATH",0,&Var,NULL,NULL);

	    if (SUCCEEDED(res))	    
	    {
	        if (VT_BSTR == V_VT(&Var))
	        {
	            IWbemClassObject * pObj = NULL;
			    res = g_pNamespace->GetObject(V_BSTR(&Var),
			                                  m_lGenFlags ,
			                                  g_Context,
			                                  &pObj,
			                                  NULL);
			    if (SUCCEEDED(res))
			    {
			        m_pObj->Release();
			        m_pObj = pObj;
			    }
			    else
			    {
			        FormatError(res, m_hDlg, NULL);
			    }
		    }
		    else
		    {
    		    FormatError(WBEM_E_INVALID_OBJECT, m_hDlg, NULL);
		    }
        }
        else
        {
            FormatError(res, m_hDlg, NULL);
        }
        
	    VariantClear(&Var);
	    
    }

}
BOOL CObjectEditor::OnInitDialog()
{
    CenterOnParent();

    m_hPropList = GetDlgItem(IDC_PROP_LIST);
    m_hQualifierList = GetDlgItem(IDC_ATTRIB_LIST);
    m_hMethodList = GetDlgItem(IDC_METHOD_LIST);

    // Set tabs in the property list box.
    // ==================================
    LONG Tabs[] = { 80, 140, 170 };
    int TabCount = 3;

    SendMessage(m_hPropList, LB_SETTABSTOPS,
        (WPARAM) TabCount, (LPARAM) Tabs);

    SendMessage(m_hPropList, LB_SETHORIZONTALEXTENT, 1000, 0);

    SendMessage(m_hQualifierList, LB_SETTABSTOPS,
        (WPARAM) TabCount, (LPARAM) Tabs);

    SendMessage(m_hQualifierList, LB_SETHORIZONTALEXTENT, 1000, 0);

    SendMessage(m_hMethodList, LB_SETTABSTOPS,
        (WPARAM) TabCount, (LPARAM) Tabs);

    SendMessage(m_hMethodList, LB_SETHORIZONTALEXTENT, 1000, 0);

    if (m_dwEditMode == readonly)
    {
        EnableWindow(GetDlgItem(IDOK), FALSE);
    }

    if (m_bClass)
    {
        SetCheck(IDC_UPDATE_NORMAL, TRUE);
        SetCheck(IDC_UPDATE_COMPATIBLE, TRUE);
    }
    else
    {
        SetCheck(IDC_UPDATE_NORMAL, TRUE);
        EnableWindow(GetDlgItem(IDC_UPDATE_COMPATIBLE), FALSE);
        EnableWindow(GetDlgItem(IDC_UPDATE_SAFE), FALSE);
        EnableWindow(GetDlgItem(IDC_UPDATE_FORCE), FALSE);
    }

    Refresh();
    return TRUE;
}

BOOL CObjectEditor::OnDoubleClick(int nID)
{
    if(nID == IDC_ATTRIB_LIST)
    {
        OnEditQualifier();
        return TRUE;
    }
    else if(nID == IDC_PROP_LIST)
    {
        OnEditProp();
        return TRUE;
    }
    else if(nID == IDC_METHOD_LIST)
    {
        OnEditMethod();
        return TRUE;
    }
    else return FALSE;
}

BOOL CObjectEditor::OnCommand(WORD wCode, WORD wID)
{
    switch(wID)
    {
        case IDC_EDIT_ATTRIB: OnEditQualifier(); return TRUE;

        case IDC_ADD_ATTRIB: OnAddQualifier(); return TRUE;

        case IDC_DELETE_ATTRIB: OnDelQualifier(); return TRUE;
        case IDC_SHOW_MOF: OnShowMof(); return TRUE;
		case IDC_ADD_PROP: OnAddProp(); return TRUE;
        case IDC_EDIT_PROP: OnEditProp(); return TRUE;
        case IDC_DELETE_PROP: OnDelProp(); return TRUE;
        case IDC_ADD_METHOD: OnAddMethod(); return TRUE;
        case IDC_EDIT_METHOD: OnEditMethod(); return TRUE;
        case IDC_DELETE_METHOD: OnDelMethod(); return TRUE;
        case IDC_REFRESH_OBJECT: OnRefreshObject(); return TRUE;

        case IDC_SUPERCLASS: 
            if(m_bClass) OnSuperclass(); 
            else OnClass();
            return TRUE;
        case IDC_DERIVED:
            if(m_bClass) OnDerived();
            else OnRefs();
            return TRUE;
        case IDC_INSTANCES:
            if(m_bClass) OnInstances();
            else OnAssocs();
            return TRUE;
        case IDC_HIDE_SYSTEM:
            OnHideSystem();
            return TRUE;
        case IDC_HIDE_DERIVED:
            OnHideDerived();
            return TRUE;
    }

    return FALSE;
}

void CObjectEditor::OnSuperclass()
{
    // Get the superclass
    // ==================

    VARIANT v;
    VariantInit(&v);
    if(FAILED(m_pObj->Get(L"__SUPERCLASS", 0, &v, NULL, NULL)) ||
        V_VT(&v) != VT_BSTR)
    {
        MessageBox(IDS_NO_SUPERCLASS, IDS_ERROR, MB_OK);
        return;
    }

    ShowClass(m_hDlg, m_lGenFlags, V_BSTR(&v), m_lSync, m_pOwner, m_lTimeout);
}

void CObjectEditor::OnClass()
{
    // Get the class
    // =============

    VARIANT v;
    VariantInit(&v);
    if(FAILED(m_pObj->Get(L"__CLASS", 0, &v, NULL, NULL)))
    {
        MessageBox(IDS_CRITICAL_ERROR, IDS_ERROR, MB_OK);
        return;
    }

    ShowClass(m_hDlg, m_lGenFlags, V_BSTR(&v), m_lSync, m_pOwner, m_lTimeout);
}

void CObjectEditor::OnDerived()
{
    // Get the children
    // ================

    VARIANT v;
    VariantInit(&v);
    if(FAILED(m_pObj->Get(L"__CLASS", 0, &v, NULL, NULL)) ||
        SysStringLen(V_BSTR(&v)) == 0)
    {
        MessageBox(IDS_INCOMPLETE_CLASS, IDS_ERROR, MB_OK);
        return;
    }

    ShowClasses(m_hDlg, m_lGenFlags, WBEM_FLAG_SHALLOW, V_BSTR(&v), m_lSync, m_pOwner,
                m_lTimeout, m_nBatch);
}

void CObjectEditor::OnInstances()
{
    // Get the instances
    // ================

    VARIANT v;
    VariantInit(&v);
    if(FAILED(m_pObj->Get(L"__CLASS", 0, &v, NULL, NULL)) ||
        SysStringLen(V_BSTR(&v)) == 0)
    {
        MessageBox(IDS_INCOMPLETE_CLASS, IDS_ERROR, MB_OK);
        return;
    }

    ShowInstances(m_hDlg, m_lGenFlags, WBEM_FLAG_SHALLOW, V_BSTR(&v), m_lSync, m_pOwner, 
                  m_lTimeout, m_nBatch);
}

void CObjectEditor::OnRefs()
{
    CQueryResultDlg* pResDlg = new CQueryResultDlg(m_hDlg, m_lGenFlags, WBEM_FLAG_DEEP);
    // Pass on invocation method (sync, async..) and related settings for this
    // query and by any further operations (editing/deleting/etc. of an instance).
    pResDlg->SetCallMethod(m_lSync);
    pResDlg->SetTimeout(m_lTimeout);
    pResDlg->SetBatchCount(m_nBatch);

    VARIANT v;
    VariantInit(&v);
    if(FAILED(m_pObj->Get(L"__RELPATH", 0, &v, NULL, NULL)) ||
        V_VT(&v) != VT_BSTR)
    {
        MessageBox(IDS_UNREFERENCABLE_OBJECT, IDS_ERROR, MB_OK);
        delete pResDlg;
        return;
    }

    WCHAR* wszQuery = new WCHAR[wcslen(V_BSTR(&v))+100];
    swprintf(wszQuery, L"references of {%s}", V_BSTR(&v));  // Actual query, dont internationalize
    char szTitle[1000];
    char szFormat[104];
    char* pTitle = NULL;
    if(LoadString(GetModuleHandle(NULL), IDS_REFERENCES_OF, szFormat, 104))
    {
        sprintf(szTitle, szFormat, V_BSTR(&v));
        pTitle = szTitle;
    }

    if(_ExecQuery(m_hDlg, m_lGenFlags, WBEM_FLAG_DEEP, wszQuery, L"WQL", m_lSync, 
                  pResDlg, pTitle, m_lTimeout, m_nBatch))
    {
        pResDlg->RunDetached(m_pOwner);
    }
    else
    {
        delete pResDlg;
    }
    delete [] wszQuery;
}

void CObjectEditor::OnAssocs()
{
    CQueryResultDlg* pResDlg = new CQueryResultDlg(m_hDlg, m_lGenFlags, WBEM_FLAG_DEEP);
    // Pass on invocation method (sync, async..) and related settings for this
    // query and by any further operations (editing/deleting/etc. of an instance).
    pResDlg->SetCallMethod(m_lSync);
    pResDlg->SetTimeout(m_lTimeout);
    pResDlg->SetBatchCount(m_nBatch);

    VARIANT v;
    VariantInit(&v);
    if(FAILED(m_pObj->Get(L"__RELPATH", 0, &v, NULL, NULL)) ||
        V_VT(&v) != VT_BSTR)
    {
        MessageBox(IDS_UNREFERENCABLE_OBJECT, IDS_ERROR, MB_OK);
        delete pResDlg;
        return;
    }

    WCHAR* wszQuery = new WCHAR[wcslen(V_BSTR(&v))+100];
    swprintf(wszQuery, L"associators of {%s}", V_BSTR(&v));  // Actual query, dont internationalize
    char szTitle[1000];
    char szFormat[104];
    char* pTitle = NULL;
    if(LoadString(GetModuleHandle(NULL), IDS_ASSOCIATORS_OF, szFormat, 104))
    {
        sprintf(szTitle, szFormat, V_BSTR(&v));
        pTitle = szTitle;
    }

    if(_ExecQuery(m_hDlg, m_lGenFlags, WBEM_FLAG_DEEP, wszQuery, L"WQL", m_lSync, 
                  pResDlg, pTitle, m_lTimeout, m_nBatch))
    {
        pResDlg->RunDetached(m_pOwner);
    }
    else
    {
        delete pResDlg;
    }
    delete [] wszQuery;
}
        

BOOL CObjectEditor::mstatic_bHideSystemDefault = FALSE;

void CObjectEditor::OnHideSystem()
{
    m_bHideSystem = (GetCheck(IDC_HIDE_SYSTEM) == BST_CHECKED);
    mstatic_bHideSystemDefault = m_bHideSystem;
    Refresh();
}

void CObjectEditor::OnHideDerived()
{
    m_bHideDerived = (GetCheck(IDC_HIDE_DERIVED) == BST_CHECKED);
    Refresh();
}

void CObjectEditor::Refresh()
{
    // Zap the current contents.
    // =========================
    SendMessage(m_hPropList, LB_RESETCONTENT, 0, 0);
    SendMessage(m_hQualifierList, LB_RESETCONTENT, 0, 0);
    SendMessage(m_hMethodList, LB_RESETCONTENT, 0, 0);

    // Set the title to relpath
    // ========================

    char buf[TEMP_BUF];
    char szFormat[1024];

    VARIANT v;
    VariantInit(&v);
    HRESULT hres = m_pObj->Get(L"__RELPATH", 0, &v, NULL, NULL);
    if(FAILED(hres) || V_VT(&v) == VT_NULL)
    {
        hres = m_pObj->Get(L"__CLASS", 0, &v, NULL, NULL);
        if(FAILED(hres) || V_VT(&v) == VT_NULL)
        {
            hres = m_pObj->Get(L"__SUPERCLASS", 0, &v, NULL, NULL);
            if(FAILED(hres) || V_VT(&v) != VT_BSTR)
            {
                LoadString(GetModuleHandle(NULL), IDS_NEW_TOP_LEVEL_CLASS, buf, TEMP_BUF);
            }
            else
            {
                LoadString(GetModuleHandle(NULL), IDS_NEW_CHILD_OF, szFormat, 1024);
                _snprintf(buf, sizeof(buf)/sizeof(buf[0]), szFormat, V_BSTR(&v));
            }

        }
        else
        {
            LoadString(GetModuleHandle(NULL), IDS_INSTANCE_OF, szFormat, 1024);
            _snprintf(buf, sizeof(buf)/sizeof(buf[0]), szFormat, V_BSTR(&v));
        }
    }
    else
    {
        LoadString(GetModuleHandle(NULL), IDS_OBJECT_EDITOR_FOR, szFormat, 1024);
        _snprintf(buf, sizeof(buf)/sizeof(buf[0]), szFormat, V_BSTR(&v));
    }
		buf[sizeof(buf)-1] = '\0';

    VariantClear(&v);

    SetWindowText(m_hDlg, buf);    

    // Fill in the property list.
    // ==========================

    LONG lConFlags = 0;                 // condition flags (i.e., WBEM_CONDITION_FLAG_TYPE)
    if(m_bHideDerived)
        lConFlags = WBEM_FLAG_LOCAL_ONLY;
    else if(m_bHideSystem)
        lConFlags = WBEM_FLAG_NONSYSTEM_ONLY;

    m_pObj->BeginEnumeration(lConFlags);
    BSTR Name = NULL;

    CIMTYPE ctType;
    while (m_pObj->Next(0, &Name, &v, &ctType, NULL) == WBEM_S_NO_ERROR)
    {
        char buf2[TEMP_BUF];
        CVar value(&v);
        LPSTR TypeString = TypeToString(ctType);
        LPSTR ValueString = ValueToNewString(&value, ctType);
        if(strlen(ValueString) > 100)
        {
            ValueString[100] = 0;
        }
        sprintf(buf2, "%S\t%s\t%s", Name, TypeString, ValueString);
        delete [] ValueString;
        SendMessage(m_hPropList, LB_ADDSTRING, 0, LPARAM(buf2));
        VariantClear(&v);
    }
    m_pObj->EndEnumeration();

    // Fill in the Qualifier list.
    // ===========================

    IWbemQualifierSet *pQualifiers = NULL;
    hres = m_pObj->GetQualifierSet(&pQualifiers);
	if(SUCCEEDED(hres))
	{
		pQualifiers->BeginEnumeration(0);

		BSTR strName = NULL;
		VARIANT vVal;
		VariantInit(&vVal);

		long lFlavor;
		while(pQualifiers->Next(0, &strName, &vVal, &lFlavor) == S_OK)
		{
			CTestQualifier A;
			A.m_pName = new wchar_t[wcslen(strName)+1];
			wcscpy(A.m_pName, strName);
			A.m_pValue = new CVar(&vVal);
			A.m_lType = lFlavor;

			// Build list box string.
			// ======================

			SendMessage(m_hQualifierList, LB_ADDSTRING, 0,
							LPARAM(CTestQualifierToString(&A)));
		}
		pQualifiers->EndEnumeration();
		pQualifiers->Release();
	}
	else
		EnableWindow(m_hQualifierList, FALSE);
    // Fill in the methods

    m_pObj->BeginMethodEnumeration(0);
    while (m_pObj->NextMethod(0, &Name, NULL, NULL) == WBEM_S_NO_ERROR)
    {
        char buf3[TEMP_BUF];
        wcstombs(buf3, Name, TEMP_BUF);
        buf3[TEMP_BUF-1] = '\0';
        SendMessage(m_hMethodList, LB_ADDSTRING, 0, LPARAM(buf3));
        VariantClear(&v);
    }
    m_pObj->EndMethodEnumeration();


    // Configure the buttons
    // =====================

    ConfigureButtons();
}

void CObjectEditor::ConfigureButtons()
{
    VARIANT v;
    VariantInit(&v);

    if(m_bClass)
    {
        // Configure for class
        // ===================

        if(FAILED(m_pObj->Get(L"__SUPERCLASS", 0, &v, NULL, NULL)) ||
            V_VT(&v) != VT_BSTR)
        {
            EnableWindow(GetDlgItem(IDC_SUPERCLASS), FALSE);
        }
        else
        {
            VariantClear(&v);
            EnableWindow(GetDlgItem(IDC_SUPERCLASS), TRUE);
        }
    }
    else
    {
        // Configure for instance
        // ======================

        SetDlgItemText(IDC_CLASS, IDS_CLASS);
        SetDlgItemText(IDC_REFERENCES, IDS_REFERENCES);
        SetDlgItemText(IDC_ASSOCIATIONS, IDS_ASSOCIATORS);

        EnableWindow(GetDlgItem(IDC_KEY), FALSE);
        EnableWindow(GetDlgItem(IDC_INDEXED), FALSE);
    }

    if(m_bNoMethods || !m_bClass)
    {
        EnableWindow(GetDlgItem(IDC_ADD_METHOD), FALSE);
        EnableWindow(GetDlgItem(IDC_EDIT_METHOD), FALSE);
        EnableWindow(GetDlgItem(IDC_DELETE_METHOD), FALSE);
    }

    SetCheck(IDC_HIDE_SYSTEM, m_bHideSystem?BST_CHECKED:BST_UNCHECKED);
    SetCheck(IDC_HIDE_DERIVED, m_bHideDerived?BST_CHECKED:BST_UNCHECKED);
    EnableWindow(GetDlgItem(IDC_HIDE_SYSTEM), !m_bHideDerived);

    if(m_dwEditMode == foreign)
    {
        EnableWindow(GetDlgItem(IDC_CLASS), FALSE);
        EnableWindow(GetDlgItem(IDC_REFERENCES), FALSE);
        EnableWindow(GetDlgItem(IDC_ASSOCIATIONS), FALSE);
        EnableWindow(GetDlgItem(IDOK), FALSE);
    }
}

CObjectEditor::CObjectEditor(HWND hParent, LONG lGenFlags, DWORD dwEditMode, LONG lSync,
                             IWbemClassObject *pObj, LONG lTimeout, ULONG nBatch)
 : CWbemDialog(IDD_OBJECT_EDITOR, hParent)
{
    m_pObj = pObj;
    pObj->AddRef();
    m_dwEditMode = dwEditMode;
    m_bHideSystem = mstatic_bHideSystemDefault;
    m_bHideDerived = FALSE;
    m_bNoMethods = dwEditMode & nomethods;

    m_lGenFlags = lGenFlags;    // generic flags (i.e., WBEM_GENERIC_FLAG_TYPE)
    m_lSync = lSync;            // sync, async, semisync
    m_lTimeout = lTimeout;      // used in semisync only
    m_nBatch = nBatch;          // used in semisync and sync enumerations

    VARIANT v;
    VariantInit(&v);
    m_pObj->Get(L"__GENUS", 0, &v, NULL, NULL);
    m_bClass = (V_I4(&v) == WBEM_GENUS_CLASS);

    m_bResultingObj = NULL;
}

CObjectEditor::~CObjectEditor()
{
    m_pObj->Release();
}

INT_PTR CObjectEditor::Edit()
{
   return Run();
}

BOOL CObjectEditor::OnOK()
{
    if(m_bResultingObj)
    {
        //We need to extract the flag values...
        LONG lChgFlags = 0;             // change flags  (i.e., WBEM_CHANGE_FLAG_TYPE)
        if (GetCheck(IDC_UPDATE_NORMAL))
            lChgFlags |= WBEM_FLAG_CREATE_OR_UPDATE;
        if (GetCheck(IDC_UPDATE_CREATE))
            lChgFlags |= WBEM_FLAG_CREATE_ONLY;
        if (GetCheck(IDC_UPDATE_UPDATE))
            lChgFlags |= WBEM_FLAG_UPDATE_ONLY;
        if (GetCheck(IDC_UPDATE_COMPATIBLE))
            lChgFlags |= WBEM_FLAG_UPDATE_COMPATIBLE;
        if (GetCheck(IDC_UPDATE_SAFE))
            lChgFlags |= WBEM_FLAG_UPDATE_SAFE_MODE;
        if (GetCheck(IDC_UPDATE_FORCE))
            lChgFlags |= WBEM_FLAG_UPDATE_FORCE_MODE;

        if (!ResultingObject(m_pObj, lChgFlags))
            return TRUE;
    }
    return CBasicWbemDialog::OnOK();
}

void CObjectEditor::RunDetached(CRefCountable* pOwner)
{
    m_bResultingObj = TRUE;
    SetOwner(pOwner);
    SetDeleteOnClose();
    Create(FALSE);
}

BOOL CObjectEditor::ResultingObject(IWbemClassObject* pObj, LONG lChgFlags)
{
    BOOL bRes;

    if(m_bClass)
        bRes = _PutClass(m_hDlg, m_lGenFlags, lChgFlags, m_lSync, pObj, m_lTimeout);
    else
        bRes = _PutInstance(m_hDlg, m_lGenFlags, lChgFlags, m_lSync, pObj, m_lTimeout);

    return bRes;
}

void CObjectEditor::OnAddMethod()
{

    // Add a dummy property for now
    // ============================

    SCODE hres;
    VARIANT v;
    v.vt = VT_BSTR;
    IWbemClassObject * pIn = NULL;
    IWbemClassObject * pOut = NULL;
    SCODE sc;
    CBString bsParm(L"__PARAMETERS");

    sc = g_pNamespace->GetObject(bsParm.GetString(), m_lGenFlags, g_Context, &pIn, NULL);
    sc = g_pNamespace->GetObject(bsParm.GetString(), m_lGenFlags, g_Context, &pOut, NULL);

    CBString bsTemp(L"__CLASS");

    v.bstrVal = SysAllocString(L"InArgs");
    sc = pIn->Put(bsTemp.GetString(), 0, &v, 0);
    SysFreeString(v.bstrVal);

    v.bstrVal = SysAllocString(L"OutArgs");
    sc = pOut->Put(bsTemp.GetString(), 0, &v, 0);
    SysFreeString(v.bstrVal);

    bsTemp = L"DUMMY_METHOD__D";

    if(FAILED(m_pObj->PutMethod(bsTemp.GetString(), 0, NULL, NULL)))
    {
        MessageBox(NULL, IDS_CANNOT_EDIT_METHOD, IDS_ERROR, MB_OK|MB_ICONSTOP);
        return;
    }

    IWbemQualifierSet* pQualifierSet;
    m_pObj->GetMethodQualifierSet(bsTemp.GetString(), &pQualifierSet);

    // Create CTestMethod with the dummy attr set for now
    // =================================================

    CTestMethod method(pQualifierSet, pIn, pOut, FALSE, FALSE);

    m_pObj->Get(L"__CLASS", 0, &v, NULL, NULL);
    method.m_pClass = new wchar_t[wcslen(V_BSTR(&v)) + 1];
    wcscpy(method.m_pClass, V_BSTR(&v));
    VariantClear(&v);

    CMethodEditor ed(m_hDlg, &method, FALSE, FALSE);
    INT_PTR nRes = ed.Edit();
    if ((nRes == IDCANCEL) || (nRes == 0))
    {
        pQualifierSet->Release();
        goto DeleteDummy;
    }

    // Set the method
    // ================

     

    bsTemp = method.m_pName;


    hres = m_pObj->PutMethod(bsTemp.GetString(), 0, 
        (method.m_bEnableInputArgs) ? method.m_pInArgs: NULL, 
        (method.m_bEnableOutputArgs) ? method.m_pOutArgs : NULL);
    if(FAILED(hres))
    {
        FormatError(hres, m_hDlg, NULL);
        goto DeleteDummy;
    }
                
    // Copy the Qualifiers
    // ===================

    IWbemQualifierSet* pRealQualifierSet;

    m_pObj->GetMethodQualifierSet(bsTemp.GetString(), &pRealQualifierSet);

    CopyQualifierSet(pRealQualifierSet, pQualifierSet, m_hDlg);

    pQualifierSet->EndEnumeration();
    pQualifierSet->Release();
    pRealQualifierSet->Release();

    

DeleteDummy:
    bsTemp = L"DUMMY_METHOD__D";
    m_pObj->DeleteMethod(bsTemp.GetString());
    Refresh();
    return;

}

void CObjectEditor::OnEditMethod()
{

    SCODE sc;
    IWbemClassObject * pIn = NULL;
    IWbemClassObject * pOut = NULL;

    // Find out which property is selected.
    // ====================================

    LRESULT nIndex = SendMessage(m_hMethodList, LB_GETCURSEL, 0, 0);
    if (nIndex == LB_ERR)
        return;

    char buf[TEMP_BUF];
    *buf = 0;
    SendMessage(m_hMethodList, LB_GETTEXT, nIndex, LPARAM(buf));
    if (*buf == 0)
        return;

    WString wsName = buf;
    CBString bsTemp(L"__CLASS");

    // Get the property value from the object
    // ======================================

    m_pObj->GetMethod((LPWSTR)wsName, 0, &pIn, &pOut); 

    // Create a CTestMethod from it
    // ==========================

    IWbemQualifierSet* pQualifierSet = 0;
    sc = m_pObj->GetMethodQualifierSet((LPWSTR)wsName, &pQualifierSet); 

    IWbemClassObject * pTempIn = pIn;
    IWbemClassObject * pTempOut = pOut;
    VARIANT v;
    v.vt = VT_BSTR;

    // If the current methods lacks an input or output object, then just create a
    // temporary one in case the user decides to start using the input or output object.

    if(pTempIn == NULL)
    {
        CBString bsParm(L"__PARAMETERS");
        sc = g_pNamespace->GetObject(bsParm.GetString(), m_lGenFlags, g_Context, 
                                     &pTempIn, NULL);
        v.bstrVal = SysAllocString(L"InArgs");
        sc = pTempIn->Put(bsTemp.GetString(), 0, &v, 0);
        SysFreeString(v.bstrVal);
    }
    if(pTempOut == NULL)
    {
        CBString bsParm(L"__PARAMETERS");
        sc = g_pNamespace->GetObject(bsParm.GetString(), m_lGenFlags, g_Context, 
                                     &pTempOut, NULL);
        v.bstrVal = SysAllocString(L"OutArgs");
        sc = pTempOut->Put(bsTemp.GetString(), 0, &v, 0);
        SysFreeString(v.bstrVal);
    }

    CTestMethod Copy(pQualifierSet, pTempIn, pTempOut, pIn != NULL, pOut != NULL);
    if (pQualifierSet)
        pQualifierSet->Release();

    Copy.m_pName = new wchar_t[wcslen(wsName) + 1];
    wcscpy(Copy.m_pName, wsName);
    BSTR strClass;
    m_pObj->GetMethodOrigin((LPWSTR)wsName, &strClass); 
    Copy.m_pClass = new wchar_t[wcslen(strClass) + 1];
    wcscpy(Copy.m_pClass, strClass);
    SysFreeString(strClass);

    // Edit it.
    // =========
    CMethodEditor ed(m_hDlg, &Copy, TRUE, !m_bClass);
    INT_PTR nRes = ed.Edit();
    if ((nRes == IDCANCEL) || (nRes == 0))
        return;

    // If here, we must replace the info for the property.
    // ===================================================

    sc = m_pObj->PutMethod(Copy.m_pName, 0, 
        (Copy.m_bEnableInputArgs) ? Copy.m_pInArgs : NULL, 
        (Copy.m_bEnableOutputArgs) ? Copy.m_pOutArgs : NULL); 
    if(FAILED(sc))
    {
        FormatError(sc, m_hDlg);
    }

    Refresh();
}

void CObjectEditor::OnDelMethod()
{
    // Find out which property is selected.
    // ====================================

    LRESULT nIndex = SendMessage(m_hMethodList, LB_GETCURSEL, 0, 0);
    if (nIndex == LB_ERR)
        return;

    char buf[TEMP_BUF];
    *buf = 0;
    SendMessage(m_hMethodList, LB_GETTEXT, nIndex, LPARAM(buf));
    if (*buf == 0)
        return;

    WString WName = buf;
    if(FAILED(m_pObj->DeleteMethod(LPWSTR(WName)))) 
    {
        MessageBox(NULL, IDS_CANNOT_EDIT_METHOD, IDS_ERROR,
            MB_OK|MB_ICONSTOP);
        return;
    }

    Refresh();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemtest\objedit.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    OBJEDIT.H

Abstract:

	WBEMTEST object editor classes.

History:

	a-raymcc    12-Jun-96       Created.

--*/

#ifndef _OBJEDIT_H_
#define _OBJEDIT_H_

#include "wbemqual.h"
#include "wbemdlg.h"
#include "resrc1.h"
#include "wbemtest.h"

#define TEMP_BUF    2096

class CObjectEditor : public CWbemDialog
{
    IWbemClassObject* m_pObj;

    DWORD m_dwEditMode;                     // readwrite, readonly, foreign, nomethods
    HWND  m_hPropList;
    HWND  m_hQualifierList;
    HWND  m_hMethodList;
    BOOL  m_bClass;

    BOOL  m_bHideSystem;
    BOOL  m_bHideDerived;
    BOOL  m_bNoMethods;
    BOOL  m_bResultingObj;

    LONG  m_lGenFlags;  // generic call flags (i.e., WBEM_FLAG_ .. used in IWbemServices methods)
    LONG  m_lSync;      // sync, async, semisync
    LONG  m_lTimeout;   // used in semisync only
    ULONG m_nBatch;     // used in semisync and sync enumerations

    static BOOL mstatic_bHideSystemDefault;

public:
    enum {readwrite = 0, readonly, foreign, nomethods};     // used for edit mode: controls commands (buttons) enabled

    CObjectEditor(HWND hParent, LONG lGenFlags, DWORD dwEditMode, LONG lSync, 
                  IWbemClassObject *pObj, LONG lTimeout = WBEM_INFINITE, 
                  ULONG nBatch = 1);
    ~CObjectEditor();
    INT_PTR  Edit();
    void RunDetached(CRefCountable* pOwner);

protected:
    BOOL OnInitDialog();
    BOOL OnCommand(WORD wCode, WORD wID);
    BOOL OnDoubleClick(int nID);
    BOOL OnOK();
    
    void ConfigureButtons();

    // Buttons
    void OnAddQualifier();
    void OnEditQualifier();
    void OnDelQualifier();

    void OnAddProp();
    void OnEditProp();
    void OnDelProp();

    void OnAddMethod();
    void OnEditMethod();
    void OnDelMethod();

    void OnSuperclass();
    void OnDerived();
    void OnInstances();

    void OnClass();
    void OnRefs();
    void OnAssocs();

    void OnShowMof();
	void OnHideSystem();
    void OnHideDerived();
    void Refresh();
	void OnRefreshObject();
    BOOL ResultingObject(IWbemClassObject* pObj, LONG lChgFlags);
};

//***************************************************************************
//
//  class CTestQualifierEditor
//
//***************************************************************************

class CTestQualifierEditor : public CWbemDialog
{
    HWND m_hQualifierName;
    HWND m_hQualifierVal;
    HWND m_hQualifierType;
    HWND m_hRadioPropInst;
    HWND m_hRadioPropClass;
    HWND m_hRadioOverride;
    HWND m_hRadioPropagated;
    HWND m_hRadioAmended;

    CTestQualifier *m_pTarget;
    BOOL m_bEditing;

public:
    CTestQualifierEditor(HWND hParent, CTestQualifier *pTarget,
                         BOOL bEditing = TRUE);
    INT_PTR Edit();
    BOOL OnInitDialog();
    BOOL Verify();
};
LPSTR CTestQualifierToString(CTestQualifier *pQualifier);
LPSTR LPWSTRToLPSTR(LPWSTR pWStr);

//***************************************************************************
//
//  class CEmbeddedObjectEditor
//
//***************************************************************************

class CEmbeddedObjectListEditor : public CQueryResultDlg
{
protected:
    CVarVector* m_pVarVector;
    WString m_wsPropName;
public:
    CEmbeddedObjectListEditor(HWND hParent, LONG lGenFlags, LONG lQryFlags,
                              LPCWSTR wszPropName, CVarVector* pVarVector);
    ~CEmbeddedObjectListEditor();

    BOOL CanAdd()		{ return TRUE;}
    IWbemClassObject* AddNewElement();
    BOOL DeleteListElement(int nSel);
    BOOL Verify();
    BOOL OnInitDialog();
};

extern char *ValidQualifierTypes[];

extern const int nNumValidQualifierTypes;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemtest\textconv.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    TEXTCONV.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <float.h>
#include <textconv.h>
#include <WT_wstring.h>
#include <bstring.h>
#include <wbemidl.h>

#include "WT_converter.h"

char *g_aValidPropTypes[] =
{
    "CIM_UINT8",
    "CIM_SINT8",
    "CIM_SINT16",
    "CIM_UINT16",
    "CIM_SINT32",
    "CIM_UINT32",
    "CIM_SINT64",
    "CIM_UINT64",
    "CIM_STRING",
    "CIM_BOOLEAN",
    "CIM_REAL32",
    "CIM_REAL64",
    "CIM_DATETIME",
    "CIM_REFERENCE",
    "CIM_OBJECT",
    "CIM_CHAR16",
    "CIM_EMPTY",
};

const int g_nNumValidPropTypes = sizeof(g_aValidPropTypes) / sizeof(char *);

LPWSTR CreateUnicode(LPSTR sz)
{
    int len = strlen(sz);
		WCHAR* wsz = new WCHAR[len+1];
		if (wsz == 0)
				return 0;

		mbstowcs(wsz, sz, len+1);
	  wsz[len] = L'\0';
    return wsz;
}

LPSTR TypeToString(int nType)
{
    static char *pCIM_EMPTY  = "CIM_EMPTY";
    static char *pCIM_UINT8  = "CIM_UINT8";
    static char *pCIM_SINT8  = "CIM_SINT8";
    static char *pCIM_SINT16   = "CIM_SINT16";
    static char *pCIM_UINT16   = "CIM_UINT16";
    static char *pCIM_SINT32   = "CIM_SINT32";
    static char *pCIM_UINT32   = "CIM_UINT32";
    static char *pCIM_SINT64   = "CIM_SINT64";
    static char *pCIM_UINT64   = "CIM_UINT64";
    static char *pCIM_REAL32   = "CIM_REAL32";
    static char *pCIM_REAL64   = "CIM_REAL64";
    static char *pCIM_BOOLEAN = "CIM_BOOLEAN";
    static char *pCIM_STRING = "CIM_STRING";
    static char *pCIM_DATETIME = "CIM_DATETIME";
    static char *pCIM_REFERENCE = "CIM_REFERENCE";
    static char *pCIM_OBJECT = "CIM_OBJECT";
    static char *pCIM_CHAR16 = "CIM_CHAR16";

    static char *pCIM_UINT8_ARRAY  = "CIM_UINT8 | CIM_FLAG_ARRAY";
    static char *pCIM_SINT8_ARRAY  = "CIM_SINT8 | CIM_FLAG_ARRAY";
    static char *pCIM_SINT16_ARRAY   = "CIM_SINT16 | CIM_FLAG_ARRAY";
    static char *pCIM_UINT16_ARRAY   = "CIM_UINT16 | CIM_FLAG_ARRAY";
    static char *pCIM_SINT32_ARRAY   = "CIM_SINT32 | CIM_FLAG_ARRAY";
    static char *pCIM_UINT32_ARRAY   = "CIM_UINT32 | CIM_FLAG_ARRAY";
    static char *pCIM_SINT64_ARRAY   = "CIM_SINT64 | CIM_FLAG_ARRAY";
    static char *pCIM_UINT64_ARRAY   = "CIM_UINT64 | CIM_FLAG_ARRAY";
    static char *pCIM_REAL32_ARRAY   = "CIM_REAL32 | CIM_FLAG_ARRAY";
    static char *pCIM_REAL64_ARRAY   = "CIM_REAL64 | CIM_FLAG_ARRAY";
    static char *pCIM_BOOLEAN_ARRAY = "CIM_BOOLEA | CIM_FLAG_ARRAY";
    static char *pCIM_STRING_ARRAY = "CIM_STRING | CIM_FLAG_ARRAY";
    static char *pCIM_DATETIME_ARRAY = "CIM_DATETIME | CIM_FLAG_ARRAY";
    static char *pCIM_REFERENCE_ARRAY = "CIM_REFERENCE | CIM_FLAG_ARRAY";
    static char *pCIM_OBJECT_ARRAY = "CIM_OBJECT | CIM_FLAG_ARRAY";
    static char *pCIM_CHAR16_ARRAY = "CIM_CHAR16 | CIM_FLAG_ARRAY";
    
    char *pRetVal = "<unknown>";

    switch (nType)
    {
        case CIM_UINT8: pRetVal = pCIM_UINT8; break;
        case CIM_SINT16: pRetVal = pCIM_SINT16; break;
        case CIM_SINT32: pRetVal = pCIM_SINT32; break;
        case CIM_SINT8: pRetVal = pCIM_SINT8; break;
        case CIM_UINT16: pRetVal = pCIM_UINT16; break;
        case CIM_UINT32: pRetVal = pCIM_UINT32; break;
        case CIM_UINT64: pRetVal = pCIM_UINT64; break;
        case CIM_SINT64: pRetVal = pCIM_SINT64; break;
        case CIM_REAL32: pRetVal = pCIM_REAL32; break;
        case CIM_REAL64: pRetVal = pCIM_REAL64; break;
        case CIM_BOOLEAN: pRetVal = pCIM_BOOLEAN; break;
        case CIM_STRING: pRetVal = pCIM_STRING; break;
        case CIM_DATETIME: pRetVal = pCIM_DATETIME; break;
        case CIM_REFERENCE: pRetVal = pCIM_REFERENCE; break;
        case CIM_OBJECT: pRetVal = pCIM_OBJECT; break;
        case CIM_CHAR16: pRetVal = pCIM_CHAR16; break;

        case CIM_UINT8|CIM_FLAG_ARRAY: pRetVal = pCIM_UINT8_ARRAY; break;
        case CIM_SINT16|CIM_FLAG_ARRAY: pRetVal = pCIM_SINT16_ARRAY; break;
        case CIM_SINT32|CIM_FLAG_ARRAY: pRetVal = pCIM_SINT32_ARRAY; break;
        case CIM_SINT8|CIM_FLAG_ARRAY: pRetVal = pCIM_SINT8_ARRAY; break;
        case CIM_UINT16|CIM_FLAG_ARRAY: pRetVal = pCIM_UINT16_ARRAY; break;
        case CIM_UINT32|CIM_FLAG_ARRAY: pRetVal = pCIM_UINT32_ARRAY; break;
        case CIM_UINT64|CIM_FLAG_ARRAY: pRetVal = pCIM_UINT64_ARRAY; break;
        case CIM_SINT64|CIM_FLAG_ARRAY: pRetVal = pCIM_SINT64_ARRAY; break;
        case CIM_REAL32|CIM_FLAG_ARRAY: pRetVal = pCIM_REAL32_ARRAY; break;
        case CIM_REAL64|CIM_FLAG_ARRAY: pRetVal = pCIM_REAL64_ARRAY; break;
        case CIM_BOOLEAN|CIM_FLAG_ARRAY: pRetVal = pCIM_BOOLEAN_ARRAY; break;
        case CIM_STRING|CIM_FLAG_ARRAY: pRetVal = pCIM_STRING_ARRAY; break;
        case CIM_DATETIME|CIM_FLAG_ARRAY: pRetVal = pCIM_DATETIME_ARRAY; break;
        case CIM_REFERENCE|CIM_FLAG_ARRAY: pRetVal = pCIM_REFERENCE_ARRAY;break;
        case CIM_OBJECT|CIM_FLAG_ARRAY: pRetVal = pCIM_OBJECT_ARRAY; break;
        case CIM_CHAR16|CIM_FLAG_ARRAY: pRetVal = pCIM_CHAR16_ARRAY; break;
    }

    return pRetVal;
}

// Returns 0 on error

int StringToType(LPSTR pString)
{
    if(pString == NULL)
        return 0;
    if (_stricmp(pString, "CIM_STRING") == 0)
        return CIM_STRING;
    if (_stricmp(pString, "CIM_UINT8") == 0)
        return CIM_UINT8;
    if (_stricmp(pString, "CIM_SINT16") == 0)
        return CIM_SINT16;
    if (_stricmp(pString, "CIM_SINT32") == 0)
        return CIM_SINT32;
    if (_stricmp(pString, "CIM_SINT8") == 0)
        return CIM_SINT8;
    if (_stricmp(pString, "CIM_UINT16") == 0)
        return CIM_UINT16;
    if (_stricmp(pString, "CIM_UINT32") == 0)
        return CIM_UINT32;
    if (_stricmp(pString, "CIM_UINT64") == 0)
        return CIM_UINT64;
    if (_stricmp(pString, "CIM_SINT64") == 0)
        return CIM_SINT64;
    if (_stricmp(pString, "CIM_BOOLEAN") == 0)
        return CIM_BOOLEAN;
    if (_stricmp(pString, "CIM_DATETIME") == 0)
        return CIM_DATETIME;
    if (_stricmp(pString, "CIM_REFERENCE") == 0)
        return CIM_REFERENCE;
    if (_stricmp(pString, "CIM_REAL32") == 0)
        return CIM_REAL32;
    if (_stricmp(pString, "CIM_REAL64") == 0)
        return CIM_REAL64;
    if (_stricmp(pString, "CIM_EMPTY") == 0)
        return CIM_EMPTY;
    if (_stricmp(pString, "CIM_OBJECT") == 0)
        return CIM_OBJECT;
    if (_stricmp(pString, "CIM_CHAR16") == 0)
        return CIM_CHAR16;
    return 0;
}

// The functions does a preliminary check on arrays looking for leading commas, 
// multiple commas, and trailing commas

bool PrelimCheck(LPSTR pStr)
{
    int iNumCommaSinceLastNum = 3;
    for(; *pStr; pStr++)
    {
        // If not a space or comma, assume we are in a number
        
        if(!isspace(*pStr) && *pStr != ',')
            iNumCommaSinceLastNum = 0;
        if(*pStr == ',')
        {
            if(iNumCommaSinceLastNum > 0)
                return false;
            iNumCommaSinceLastNum++;
        }
    }
    if(iNumCommaSinceLastNum > 0)
        return false;
    else
        return true;
}

CVarVector* GetVT_I8Array(LPSTR pStr)
{
    if(!PrelimCheck(pStr))
        return NULL;
    CVarVector *pVec = new CVarVector(VT_BSTR);

    char buf[TEMP_BUF];
    int n = 0;
    buf[0] = 0;

    char* pc = pStr;

    while(*pc)
    {
        if(*pc == ',')
        {
            buf[n] = 0;
            if(n == 0)
            {
                delete pVec;
                return NULL;
            }
            WString s = buf;
            pVec->Add(CVar(VT_BSTR, s));
            n = 0;
            buf[0] = 0;
        }
        else if(!isspace(*pc) && *pc != '"')
        {
            buf[n++] = *pc;
        }

        pc++;
    }

    if(n != 0)
    {
        buf[n] = 0;
        WString s = buf;
        pVec->Add(CVar(VT_BSTR, s));
        n = 0;
    }

    return pVec;
}



CVarVector* GetVT_BSTRArray(LPSTR pStr)
{
    CVarVector *pVec = new CVarVector(VT_BSTR);

    char buf[TEMP_BUF];
    int n = 0;
    BOOL bInString = FALSE;
    while (*pStr)
    {
        if (*pStr == '\"')
        {
            if (bInString)
            {
                WString s = buf;
                pVec->Add(CVar(VT_BSTR, s));
                n = 0;
                bInString = FALSE;
                pStr++;
            }
            else {
                bInString = TRUE;
                pStr++;
                n=0;
                buf[0] = 0;
            }
            continue;
        }

        // Allow for \" escape sequence to include quotes in strings.
        // ==========================================================
        if (*pStr == '\\' && (*(pStr+1) == '\"' || (*(pStr+1) == '\\'))) {
            buf[n] = *(pStr+1);
            buf[++n] = 0;
            pStr += 2;
            continue;
        }

        if (!bInString)
        {
            if (isspace(*pStr) || *pStr == ',') {
                pStr++;
                continue;
            }
            // Error in array element separators
            delete pVec;
            return 0;
        }
        else
        {
            buf[n] = *pStr++;
            buf[++n] = 0;
        }
    }

	if(pVec->Size() < 1)
	{
		delete pVec;
		return 0;
	}
    return pVec;
}

CVarVector* GetVT_BOOLArray(LPSTR pStr)
{
    if(!PrelimCheck(pStr))
        return NULL;
    CVarVector *pVec = new CVarVector(VT_BOOL);
    char buf[TEMP_BUF];
    int n = 0;
    BOOL bPending = FALSE;

    while (*pStr)
    {
        if (isspace(*pStr))
            pStr++;

        else if (*pStr == ',')
        {
            if (_stricmp(buf, "TRUE") == 0 ||
                _stricmp(buf, "1") == 0 ||
                _stricmp(buf, "-1") == 0)
                pVec->Add(CVar((VARIANT_BOOL) -1, VT_BOOL));

            else if (_stricmp(buf, "FALSE") == 0 || _stricmp(buf, "0") == 0)
                pVec->Add(CVar((VARIANT_BOOL) 0, VT_BOOL));
            else
            {
                delete pVec;
                return NULL;
            }

            pStr++;
            bPending = FALSE;
            n = 0;
            buf[n] = 0;
        }
        else
        {
            buf[n] = *pStr++;
            buf[++n] = 0;
            bPending = TRUE;
        }
    }

    if (bPending)
    {
        if (_stricmp(buf, "TRUE") == 0 ||
            _stricmp(buf, "1") == 0 ||
            _stricmp(buf, "-1") == 0)
            pVec->Add(CVar((VARIANT_BOOL) -1, VT_BOOL));

        else if (_stricmp(buf, "FALSE") == 0 || _stricmp(buf, "0") == 0)
            pVec->Add(CVar((VARIANT_BOOL) 0, VT_BOOL));
        else
        {
            delete pVec;
            return NULL;
        }
    }

    return pVec;
}

CVarVector* GetVT_I4Array(LPSTR pStr)
{
    if(!PrelimCheck(pStr))
        return NULL;
    CVarVector *pVec = new CVarVector(VT_I4);
    char buf[TEMP_BUF];
    int n = 0;
    BOOL bInNum = FALSE;

    while (*pStr)
    {
        if (isdigit(*pStr) || *pStr == '-')
        {
            bInNum = TRUE;
            buf[n] = *pStr++;
            buf[++n] = 0;
            continue;
        }
        else  // Non digit
        {
            if (bInNum)
            {
                pVec->Add(CVar((LONG) atol(buf)));
                n = 0;
                bInNum = FALSE;
                pStr++;
            }
            else // A separator or trash
            {
                if (*pStr == ',' || isspace(*pStr))
                    pStr++;
                else
                {
                    delete pVec;
                    return 0;
                }
            }
        }
    }

    if (bInNum)
        pVec->Add(CVar((LONG) atol(buf)));

    return pVec;
}

CVarVector* GetVT_I2Array(LPSTR pStr)
{
    if(!PrelimCheck(pStr))
        return NULL;
    CVarVector *pVec = new CVarVector(VT_I2);
    char buf[TEMP_BUF];
    int n = 0;
    BOOL bInNum = FALSE;

    while (*pStr)
    {
        if (isdigit(*pStr) || *pStr == '-')
        {
            bInNum = TRUE;
            buf[n] = *pStr++;
            buf[++n] = 0;
            continue;
        }
        else  // Non digit
        {
            if (bInNum)
            {
                pVec->Add(CVar((SHORT) atol(buf)));
                n = 0;
                bInNum = FALSE;
                pStr++;
            }
            else // A separator or trash
            {
                if (*pStr == ',' || isspace(*pStr))
                    pStr++;
                else
                {
                    delete pVec;
                    return 0;
                }
            }
        }
    }

    if (bInNum)
        pVec->Add(CVar((SHORT) atol(buf)));

    return pVec;
}



CVarVector* GetVT_UI1Array(LPSTR pStr)
{
    if(!PrelimCheck(pStr))
        return NULL;
    CVarVector *pVec = new CVarVector(VT_UI1);
    char buf[TEMP_BUF];
    int n = 0;
    BOOL	bPending = FALSE,
			fFailedConvert = FALSE;

    while ( !fFailedConvert && *pStr )
    {
        if (isspace(*pStr))
            pStr++;

        else if (*pStr == ',')
        {
            BYTE b = 0;
            int nRes = sscanf(buf, "'%c'", &b);
            if (nRes == 0)
            {
                int n2 = 0;
                nRes = sscanf(buf, "0x%X", &n2);
                if (nRes == 0)
                {
                    nRes = sscanf(buf, "%d", &n2);

					// check that n is in the byte range

					if ( n2 >= 0 && n2 <= 0xFF )
					{
						b = (BYTE)n2;
					}
					else
					{
						fFailedConvert = TRUE;
					}
                }
                else b = (BYTE)n2;
            }

			if ( !fFailedConvert )
			{
				pVec->Add(CVar(b));

				pStr++;
				bPending = FALSE;
				n = 0;
				buf[n] = 0;
			}
        }
        else
        {
            buf[n] = *pStr++;
            buf[++n] = 0;
            bPending = TRUE;
        }
    }

    if ( !fFailedConvert && bPending )
    {
        BYTE b = 0;
        int nRes = sscanf(buf, "'%c'", &b);
        if (nRes == 0)
        {
            int n2 = 0;
            nRes = sscanf(buf, "0x%X", &n2);
            if (nRes == 0)
            {
                nRes = sscanf(buf, "%d", &n2);

				// check that n is in the byte range

				if ( n2 >= 0 && n2 <= 0xFF )
				{
					b = (BYTE)n2;
				}
				else
				{
					fFailedConvert = TRUE;
				}
            }
            else b = (BYTE)n2;
        }

		// Don't set the value if the conversion failed
		if ( !fFailedConvert )
		{
			pVec->Add(CVar(b));
		}
    }

	// Check that we didn't fail conversion
	if ( fFailedConvert )
	{
		delete pVec;
		pVec = NULL;
	}

    return pVec;
}

CVarVector* GetVT_R4Array(LPSTR pStr)
{
    int iNumConv;
    if(!PrelimCheck(pStr))
        return NULL;
    CVarVector *pVec = new CVarVector(VT_R4);
    char buf[TEMP_BUF];
    int n = 0;
    BOOL bInNum = FALSE;

    while (*pStr)
    {
        if (*pStr != ',' && !isspace(*pStr))
        {
            bInNum = TRUE;
            buf[n] = *pStr++;
            buf[++n] = 0;
            continue;
        }
        else  // Non digit
        {
            if (bInNum)
            {
                double d = 0.0;
                iNumConv = sscanf(buf, "%lG", &d);
				if (!_finite(d) || iNumConv == 0)
				{
					delete pVec;
					return NULL;
				}
                pVec->Add(CVar((float) d));
                n = 0;
                bInNum = FALSE;
                pStr++;
            }
            else // A separator or trash
            {
                if (*pStr == ',' || isspace(*pStr))
                    pStr++;
                else
                {
                    delete pVec;
                    return 0;
                }
            }
        }
    }

    if (bInNum)
    {
        double d = 0.0;
        iNumConv = sscanf(buf, "%lG", &d);
		if (!_finite(d) || iNumConv == 0)
		{
			delete pVec;
			return NULL;
		}
        pVec->Add(CVar(float(d)));
    }

    return pVec;
}

CVarVector* GetVT_R8Array(LPSTR pStr)
{
    int iNumConv;
    if(!PrelimCheck(pStr))
        return NULL;
    CVarVector *pVec = new CVarVector(VT_R8);
    char buf[TEMP_BUF];
    int n = 0;
    BOOL bInNum = FALSE;

    while (*pStr)
    {
        if (*pStr != ',' && !isspace(*pStr))
        {
            bInNum = TRUE;
            buf[n] = *pStr++;
            buf[++n] = 0;
            continue;
        }
        else  // Non digit
        {
            if (bInNum)
            {
                double d = 0.0;
                iNumConv = sscanf(buf, "%lG", &d);
				if (!_finite(d) || iNumConv == 0)
				{
					delete pVec;
					return NULL;
				}

                pVec->Add(CVar(d));
                n = 0;
                bInNum = FALSE;
                pStr++;
            }
            else // A separator or trash
            {
                if (*pStr == ',' || isspace(*pStr))
                    pStr++;
                else
                {
                    delete pVec;
                    return 0;
                }
            }
        }
    }

    if (bInNum)
    {
        double d = 0.0;
        iNumConv = sscanf(buf, "%lG", &d);
 		if (!_finite(d) || iNumConv ==0)
		{
			delete pVec;
			return NULL;
		}
		pVec->Add(CVar(d));
    }

    return pVec;
}


// Allocates a new copy which must be deleted.

CVar* StringToValue(LPSTR pString, int nValType)
{
    char g;

    CVar *pRet = 0;
    if (pString == 0)
        return 0;

    switch (nValType)
    {
        case CIM_EMPTY:
            pRet = new CVar;
            pRet->SetAsNull();
            break;
        case CIM_CHAR16:
            {
                long l;
                if(sscanf(pString, "%d %c", &l, &g) != 1 && g != '(')
                    return NULL;

                pRet = new CVar;
                pRet->SetLong(l);
            }
            break;
        case CIM_UINT8:
        case CIM_SINT8:
        case CIM_SINT16:
        case CIM_UINT16:
        case CIM_SINT32:
        case CIM_UINT32:
			{
				pRet = new CVar;
				UINT uRetVal = CConverter::Convert(pString, nValType, pRet);
				if (ERR_NOERROR != uRetVal)
					return NULL;
			}
			break;
        case CIM_REAL32:
            {
                double d;
                if(sscanf(pString, "%lG %c", &d, &g) != 1)
                    return NULL;

				if (!_finite(d))
					return NULL;
				if ((d > 3.4E+38) || (d < 3.4E-38))
					return NULL;

                pRet = new CVar;
                pRet->SetFloat(float(d));
            }
            break;

        case CIM_REAL64:
            {
                double d;
                if(sscanf(pString, "%lG %c", &d, &g) != 1)
                    return NULL;
				if (!_finite(d))
					return NULL;
                pRet = new CVar;
                pRet->SetDouble(d);
            }
            break;

        case CIM_BOOLEAN:
            {
                pRet = new CVar;
                pRet->SetBool(0);   // False by default
                if (_stricmp(pString, "TRUE") == 0)
                    pRet->SetBool(-1);
                else if (_stricmp(pString, "FALSE") == 0)
                    pRet->SetBool(0);
                else if (atoi(pString) == 1)
                    pRet->SetBool(-1);
                else if (atoi(pString) == 0)
                    pRet->SetBool(0);
                else
                    return NULL;
            }
            break;

        case CIM_SINT64:
        case CIM_UINT64:
        case CIM_STRING:
        case CIM_DATETIME:
        case CIM_REFERENCE:
            {
                pRet = new CVar;
								wchar_t * wbuf = CreateUnicode(pString);
								if (wbuf != 0)
								{
									CBString bsTemp(wbuf);
									pRet->SetBSTR(bsTemp.GetString());
									delete wbuf;
								}
            }
            break;

        // Array types.
        // ============

        case CIM_SINT64|CIM_FLAG_ARRAY:
        case CIM_UINT64|CIM_FLAG_ARRAY:
            {
                CVarVector *pVec = GetVT_I8Array(pString);
                if (!pVec)
                    return 0;
                pRet = new CVar;
                pRet->SetVarVector(pVec, TRUE);
            }
            break;

        case CIM_STRING|CIM_FLAG_ARRAY:
        case CIM_DATETIME|CIM_FLAG_ARRAY:
        case CIM_REFERENCE|CIM_FLAG_ARRAY:
            {
                CVarVector *pVec = GetVT_BSTRArray(pString);
                if (!pVec)
                    return 0;
                pRet = new CVar;
                pRet->SetVarVector(pVec, TRUE);
            }
            break;

        case CIM_BOOLEAN|CIM_FLAG_ARRAY:
            {
                CVarVector *pVec = GetVT_BOOLArray(pString);
                if (!pVec)
                    return 0;
                pRet = new CVar;
                pRet->SetVarVector(pVec, TRUE);
            }
            break;

        case CIM_UINT8|CIM_FLAG_ARRAY:
        case CIM_SINT8|CIM_FLAG_ARRAY:
        case CIM_UINT16|CIM_FLAG_ARRAY:
        case CIM_SINT16|CIM_FLAG_ARRAY:
        case CIM_UINT32|CIM_FLAG_ARRAY:
		case CIM_SINT32|CIM_FLAG_ARRAY:
			{
				CVarVector *pVec = new CVarVector;
				UINT uRes = CConverter::Convert(pString, (nValType & ~CIM_FLAG_ARRAY), pVec);
				if (ERR_NOERROR != uRes)
					return NULL;
				pRet = new CVar;
				pRet->SetVarVector(pVec, TRUE);
			}break;

        case CIM_CHAR16|CIM_FLAG_ARRAY:
            {
                CVarVector *pVec = GetVT_I2Array(pString);
                if (!pVec)
                    return 0;
                pRet = new CVar;
                pRet->SetVarVector(pVec, TRUE);
            }
            break;

        case CIM_REAL32|CIM_FLAG_ARRAY:
            {
                CVarVector *pVec = GetVT_R4Array(pString);
                if (!pVec)
                    return 0;
                pRet = new CVar;
                pRet->SetVarVector(pVec, TRUE);
            }
            break;

        case CIM_REAL64|CIM_FLAG_ARRAY:
            {
                CVarVector *pVec = GetVT_R8Array(pString);
                if (!pVec)
                    return 0;
                pRet = new CVar;
                pRet->SetVarVector(pVec, TRUE);
            }
            break;
    }

    return pRet;
}


LPSTR ValueToString(CVar *pValue, int vt)
{
    static char buf[LARGE_BUF];

    char* sz = ValueToNewString(pValue, vt);
    strcpy(buf, sz);
    return buf;
}

LPSTR ValueToNewString(CVar *pValue, int vt)
{
    WString wsOut;
    char buf[LARGE_BUF];

    int nType = 0;

    if(pValue->GetType() == VT_NULL)
    {
        nType = CIM_EMPTY;
    }
    else if(vt != 0)
    {
        nType = vt;
    }
    else if (pValue->GetType() == VT_EX_CVARVECTOR)
    {
        nType = pValue->GetVarVector()->GetType();
        nType |= CIM_FLAG_ARRAY;
    }
    else
    {
        nType = pValue->GetType();
    }

    buf[0] = 0;
    switch (nType)
    {
        case CIM_EMPTY:
            sprintf(buf, "<null>");
            break;
        case CIM_OBJECT:
            if(pValue->GetEmbeddedObject() != NULL)
                sprintf(buf, "<embedded object>");
            else
                buf[0] = 0;
            break;
        case CIM_BOOLEAN:
            {
                VARIANT_BOOL b = pValue->GetBool();
                if (!b)
                    sprintf(buf, "FALSE");
                else
                    sprintf(buf, "TRUE");
            }
            break;

        case CIM_UINT8:
            {
                BYTE b = pValue->GetByte();
                sprintf(buf, "%d", (long)b);
            }
            break;

        case CIM_SINT8:
            {
                signed char b = (signed char)pValue->GetByte();
                sprintf(buf, "%d", (long)b);
            }
            break;

        case CIM_SINT16:
        case CIM_CHAR16:
            {
                SHORT i = pValue->GetShort();
                sprintf(buf, "%d (0x%04hx)", i, i);
            }
            break;

        case CIM_UINT16:
            {
                USHORT i = (USHORT)pValue->GetShort();
                sprintf(buf, "%d (0x%X)", (long)i, (long)i);
            }
            break;

        case CIM_SINT32:
            {
                LONG l = pValue->GetLong();
                sprintf(buf, "%d (0x%X)", l, l);
            }
            break;

        case CIM_UINT32:
            {
                ULONG l = (ULONG)pValue->GetLong();
                sprintf(buf, "%lu (0x%X)", l, l);
            }
            break;

        case CIM_REAL32:
            {
                float f = pValue->GetFloat();
                sprintf(buf, "%G", f);

            }
            break;

        case CIM_REAL64:
            {
                double d = pValue->GetDouble();
                sprintf(buf, "%G", d);
            }
            break;

        case CIM_SINT64:
        case CIM_UINT64:
        case CIM_STRING:
        case CIM_DATETIME:
        case CIM_REFERENCE:
            {
                LPWSTR pWStr = pValue->GetLPWSTR();
                wsOut += pWStr;
                *buf = 0;
            }
            break;

        case CIM_SINT64|CIM_FLAG_ARRAY:
        case CIM_UINT64|CIM_FLAG_ARRAY:
        case CIM_STRING|CIM_FLAG_ARRAY:
        case CIM_DATETIME|CIM_FLAG_ARRAY:
        case CIM_REFERENCE|CIM_FLAG_ARRAY:
            {
                CVarVector *pVec = pValue->GetVarVector();
                BOOL bFirst = TRUE;
                for (int i = 0; i < pVec->Size(); i++)
                {
                    if (!bFirst)
                        wsOut += L",";

                    CVar v;
					pVec->FillCVarAt( i, v );

                    LPWSTR pTmp = v.GetLPWSTR();
                    wsOut += L"\"";

                    LPWSTR pTmp2 = new WCHAR[ lstrlenW(pTmp)+1000 ];
                    int nIdx = 0;

                    // Add '\' before any "'s or '\'s
                    // ==============================
                    while(*pTmp) {
                        if(*pTmp == '\"' || *pTmp == '\\') {
                            pTmp2[nIdx++] = '\\';
                        }
                        pTmp2[nIdx++] = *pTmp++;
                    }
                    pTmp2[nIdx] = 0;

                    wsOut += pTmp2;
                    wsOut += L"\"";
                    bFirst = FALSE;
                    delete[] pTmp2;
                }

                *buf = 0;
            }
            break;

        case CIM_UINT8|CIM_FLAG_ARRAY:
            {
                CVarVector *pVec = pValue->GetVarVector();
                BOOL bFirst = TRUE;
                for (int i = 0; i < pVec->Size(); i++)
                {
                    if (!bFirst)
                        wsOut += L",";

                    CVar v;
					pVec->FillCVarAt( i, v );

                    BYTE b = v.GetByte();
                    wchar_t buf2[128];

                    swprintf(buf2, L"%d", (long)b);
                    wsOut += buf2;
                    bFirst = FALSE;
                }

                *buf = 0;
            }
            break;

        case CIM_SINT8|CIM_FLAG_ARRAY:
            {
                CVarVector *pVec = pValue->GetVarVector();
                BOOL bFirst = TRUE;
                for (int i = 0; i < pVec->Size(); i++)
                {
                    if (!bFirst)
                        wsOut += L",";

                    CVar v;
					pVec->FillCVarAt( i, v );

                    signed char b = (signed char)v.GetByte();
                    wchar_t buf2[128];

                    swprintf(buf2, L"%d", (long)b);
                    wsOut += buf2;
                    bFirst = FALSE;
                }

                *buf = 0;
            }
            break;

        case CIM_BOOLEAN|CIM_FLAG_ARRAY:
            {
                CVarVector *pVec = pValue->GetVarVector();
                BOOL bFirst = TRUE;
                for (int i = 0; i < pVec->Size(); i++)
                {
                    if (!bFirst)
                        wsOut += L",";

                    CVar v;
					pVec->FillCVarAt( i, v );

                    VARIANT_BOOL b = v.GetBool();
                    if (b)
                        wsOut += L"TRUE";
                    else
                        wsOut += L"FALSE";
                    bFirst = FALSE;
                }

                *buf = 0;
            }
            break;

        case CIM_SINT16|CIM_FLAG_ARRAY:
        case CIM_CHAR16|CIM_FLAG_ARRAY:
            {
                CVarVector *pVec = pValue->GetVarVector();
                BOOL bFirst = TRUE;
                for (int i = 0; i < pVec->Size(); i++)
                {
                    if (!bFirst)
                        wsOut += L",";

                    CVar v;
					pVec->FillCVarAt( i, v );

                    SHORT Tmp = v.GetShort();
                    wchar_t buf2[128];
                    swprintf(buf2, L"%ld", (long)Tmp);
                    wsOut += buf2;
                    bFirst = FALSE;
                }

                *buf = 0;
            }
            break;

        case CIM_UINT16|CIM_FLAG_ARRAY:
            {
                CVarVector *pVec = pValue->GetVarVector();
                BOOL bFirst = TRUE;
                for (int i = 0; i < pVec->Size(); i++)
                {
                    if (!bFirst)
                        wsOut += L",";

                    CVar v;
					pVec->FillCVarAt( i, v );

                    USHORT Tmp = (USHORT)v.GetShort();
                    wchar_t buf2[128];
                    swprintf(buf2, L"%ld", (long)Tmp);
                    wsOut += buf2;
                    bFirst = FALSE;
                }

                *buf = 0;
            }
            break;

        case CIM_SINT32|CIM_FLAG_ARRAY:
            {
                CVarVector *pVec = pValue->GetVarVector();
                BOOL bFirst = TRUE;
                for (int i = 0; i < pVec->Size(); i++)
                {
                    if (!bFirst)
                        wsOut += L",";

                    CVar v;
					pVec->FillCVarAt( i, v );

                    LONG Tmp = v.GetLong();
                    wchar_t buf2[128];
                    swprintf(buf2, L"%d", Tmp);
                    wsOut += buf2;
                    bFirst = FALSE;
                }

                *buf = 0;
            }
            break;

        case CIM_UINT32|CIM_FLAG_ARRAY:
            {
                CVarVector *pVec = pValue->GetVarVector();
                BOOL bFirst = TRUE;
                for (int i = 0; i < pVec->Size(); i++)
                {
                    if (!bFirst)
                        wsOut += L",";

                    CVar v;
					pVec->FillCVarAt( i, v );

                    ULONG Tmp = (ULONG)v.GetLong();
                    wchar_t buf2[128];
                    swprintf(buf2, L"%lu", Tmp);
                    wsOut += buf2;
                    bFirst = FALSE;
                }

                *buf = 0;
            }
            break;

        case CIM_REAL32|CIM_FLAG_ARRAY:
            {
                CVarVector *pVec = pValue->GetVarVector();
                BOOL bFirst = TRUE;
                for (int i = 0; i < pVec->Size(); i++)
                {
                    if (!bFirst)
                        wsOut += L",";

                    CVar v;
					pVec->FillCVarAt( i, v );

                    double d = v.GetFloat();
                    wchar_t buf2[128];
                    swprintf(buf2, L"%G", d);
                    wsOut += buf2;
                    bFirst = FALSE;
                }

                *buf = 0;
            }
            break;

        case CIM_REAL64|CIM_FLAG_ARRAY:
            {
                CVarVector *pVec = pValue->GetVarVector();
                BOOL bFirst = TRUE;
                for (int i = 0; i < pVec->Size(); i++)
                {
                    if (!bFirst)
                        wsOut += L",";

                    CVar v;
					pVec->FillCVarAt( i, v );

                    double d = v.GetDouble();
                    wchar_t buf2[128];
                    swprintf(buf2, L"%G", d);
                    wsOut += buf2;
                    bFirst = FALSE;
                }

                *buf = 0;
            }
            break;
        case CIM_OBJECT|CIM_FLAG_ARRAY:
            if(pValue->GetVarVector() != NULL)
                sprintf(buf, "<array of embedded objects>");
            else
                buf[0] = 0;
            break;

        default:
            sprintf(buf, "<error>");
    }

    wsOut += WString(buf);
    return wsOut.GetLPSTR();
}


void StripTrailingWs(LPSTR pVal)
{
    if (!pVal || strlen(pVal) == 0)
        return;
    for (int i = strlen(pVal) - 1; i >= 0; i--)
        if (isspace(pVal[i])) pVal[i] = 0;
        else break;
}

void StripTrailingWs(LPWSTR pVal)
{
    if (!pVal || wcslen(pVal) == 0)
        return;
    for (int i = wcslen(pVal) - 1; i >= 0; i--)
        if (iswspace(pVal[i])) pVal[i] = 0;
        else break;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemtest\resrc1.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wbemtest.rc
//
#define IDS_NOT_REGISTERED              1
#define IDS_EMPTY                       2
#define IDS_ERROR                       3
#define IDC_ADDENUM                     3
#define IDS_MUST_SPECIFY_PATH           4
#define IDS_MUST_SPECIFY_NAME           5
#define IDS_STRANGE_RESULT_CODE         6
#define IDS_INVALID_QUALIFIER_NAME      7
#define IDS_INVALID_QUALIFIER_TYPE      8
#define IDS_INVALID_VALUE               9
#define IDS_CANNOT_CHANGE_SYSTEM_QUALS  10
#define IDS_MAY_NOT_SPECIFY_INDEXED     11
#define IDS_MAY_NOT_SPECIFY_KEY         12
#define IDS_MAY_NOT_SPECIFY_NOT_NULL    13
#define IDS_CRITICAL_ERROR              14
#define IDS_SAVE_EMBEDDING              15
#define IDS_WARNING                     16
#define IDS_NO_PROPERTY_NAME            17
#define IDS_INVALID_PROPERTY_TYPE       18
#define IDS_INVALID_PROPERTY_VALUE      19
#define IDS_QUALIFIER_NOT_FOUND         20
#define IDS_CANNOT_ADD_PROPERTIES       21
#define IDS_CANNOT_EDIT_PROPERTY        22
#define IDS_MOF_FAILED                  23
#define IDS_NO_SUPERCLASS               24
#define IDS_INCOMPLETE_CLASS            25
#define IDS_UNREFERENCABLE_OBJECT       26
#define IDS_WRONG_OBJECT                27
#define IDS_OLE_INIT_FAILED             28
#define IDS_FAILED_IWBEMLOCATOR         29
#define IDS_ABNORMAL_TERMINATION        30
#define IDS_INVALID_NAMESPACE           31
#define IDS_MUST_CLOSE_WINDOWS          32
#define IDS_NO_PATH                     33
#define IDS_NO_INITIAL_CONNECTION       34
#define IDS_MUST_SPECIFY_QUERY          35
#define IDS_MUST_SPECIFY_QUERY_LANGUAGE 36
#define IDS_DELETING_CLASS              37
#define IDS_CLASS                       38
#define IDS_REFERENCES                  39
#define IDS_ASSOCIATORS                 40
#define IDS_NEW_TOP_LEVEL_CLASS         41
#define IDS_NEW_CHILD_OF                42
#define IDS_NEW_INSTANCE_FOR            43
#define IDS_OBJECT_EDITOR_FOR           44
#define IDS_TOP_LEVEL_CLASSES           45
#define IDS_CHILD_CLASSES_OF            46
#define IDS_RECURSIVE_PARENS            47
#define IDS_CLASS_INFO                  48
#define IDS_INSTANCES_OF                49
#define IDS_INSTANCE_OF                 50
#define IDS_NO_CONNECTION               51
#define IDS_REFERENCES_OF               52
#define IDS_ASSOCIATORS_OF              53
#define IDS_ASSOC_COM_EVENT             54
#define IDS_EMBEDDED_ARRAY              55
#define IDD_CONNECT                     101
#define IDD_MAIN                        101
#define IDD_OBJECT_EDITOR               102
#define IDD_PROPERTY_EDITOR             103
#define IDD_ATTRIB_EDITOR               104
#define IDD_QUALIFIER_EDITOR            104
#define IDD_SUPERCLASS                  105
#define IDD_CLASS_NAME                  106
#define IDD_OBJECT_PATH                 107
#define IDM_MAIN_MENU                   109
#define IDD_QUERY_RESULT                110
#define IDD_QUERY                       111
#define IDD_PARENTCLASS                 112
#define IDD_PARENTINFO                  112
#define IDD_EVENT_REGISTRATION          113
#define IDD_EVENT_MONITOR               114
#define IDD_ERROR                       115
#define IDD_ACTUALCONNECT               116
#define IDD_WBEM_CONNECT                116
#define IDD_SECURITY_MAIN               117
#define IDD_USER_SECURITY               118
#define IDD_METHOD                      119
#define IDD_MOF                         120
#define IDD_CONTEXT_EDITOR              121
#define IDD_CONTEXT_PROPERTY            122
#define IDD_METHOD_EDITOR               123
#define IDS_NO_METHOD_NAME              124
#define IDD_STATUS_MONITOR              124
#define IDS_CANNOT_EDIT_METHOD          125
#define IDD_REFRESHER_OBJECT_PATH       125
#define IDS_CANT_GET_CLASS              126
#define IDD_QUERY_RESULT_SORTED         126
#define IDS_CLASS_HAS_NO_METHODS        127
#define IDD_RENAMEDIALOG                127
#define IDS_STRING_METHOD_OK            128
#define IDD_CREATEINSTANCE              128
#define IDS_WBEMTEST                    129
#define IDS_DONE                        130
#define IDS_IN_PROGRESS                 131
#define ERROR_FORMAT_EX                 132
#define ERROR_FORMAT_LONG               133
#define IDS_UNSECAPP_ERROR              134
#define IDS_FAIL_ENABLE_ALL_PRIV        135
#define IDS_NUM_OBJECTS_FORMAT          136
#define IDS_NUM_BATCH_FORMAT            137
#define IDS_ASYNC_NOT_SUPPORTED         138
#define IDD_WBEM_BIND                   139
#define IDS_FAILED_IWBEMBINDER          139
#define IDS_MULTIPLE_SEMISYNC_NOTIFICATION_QUERY_DLG_MSG 140
#define IDS_PARTIALRESULTS				141
#define IDC_NAMESPACE                   1001
#define IDC_CONNECT                     1002
#define IDC_CREATE_CLASS                1003
#define IDC_GET_CLASS                   1004
#define IDC_GET_CLASSES                 1005
#define IDC_EDIT_CLASS                  1006
#define IDC_DELETE_CLASS                1007
#define IDC_CREATE_INSTANCE             1008
#define IDC_GET_INSTANCE                1009
#define IDC_GET_INSTANCES               1010
#define IDC_EDIT_INSTANCE               1011
#define IDC_DELETE_INSTANCE             1012
#define IDC_QUERY                       1013
#define IDC_STATUS                      1014
#define IDC_ATTRIB_LIST                 1015
#define IDC_EVENTS                      1015
#define IDC_NUM_BATCH                   1015
#define IDC_ADD_ATTRIB                  1016
#define IDC_EDIT_ATTRIB                 1017
#define IDC_DELETE_ATTRIB               1018
#define IDC_PROP_LIST                   1019
#define IDC_ADD_PROP                    1020
#define IDC_EDIT_PROP                   1021
#define IDC_DELETE_PROP                 1022
#define IDC_SHOW_MOF                    1023
#define IDC_SHOW_XML                    1024
#define IDC_PROPNAME                    1025
#define IDC_TYPE_LIST                   1026
#define IDC_VALUE                       1027
#define IDC_ATTRIB_NAME                 1032
#define IDC_ATTRIB_TYPE                 1033
#define IDC_ATTRIB_VALUE                1034
#define IDC_SUPERCLASS                  1035
#define IDC_CLASS_NAME                  1036
#define IDC_DERIVED                     1036
#define IDC_OBJECT_PATH                 1037
#define IDR_CLASS_ATTRIB                1038
#define IDC_METHOD_NAME                 1038
#define IDR_TEMP_ATTRIB                 1039
#define IDR_NAMESPACE_ATTRIB            1040
#define IDR_PRIVATE_ATTRIB              1041
#define IDR_DYNAMIC_KEY                 1050
#define IDR_OBJECT_PATH                 1051
#define IDC_OBJECT_LIST                 1053
#define IDC_QUERY_STRING                1054
#define IDC_QUERY_TYPE                  1055
#define IDC_GET_CLASS_ASYNC             1056
#define IDC_GET_OBJECT_ASYNC            1057
#define IDC_GET_OBJECTS_ASYNC           1058
#define IDC_ASYNC_QUERY                 1059
#define IDC_REFRESH_INSTANCE            1060
#define IDC_REFRESH_INSTANCE_ASYNC      1061
#define IDC_GET_CLASSES_ASYNC           1062
#define IDC_IMMEDIATE_SUBCLASSES        1063
#define IDC_GET_INSTANCE_ASYNC          1063
#define IDC_RECURSIVE_SUBCLASSES        1064
#define IDC_GET_INSTANCES_ASYNC         1064
#define IDC_QUERY_ASYNC                 1065
#define IDC_OPEN_NS                     1067
#define IDC_NUM_OBJECTS                 1068
#define IDC_EXEC_METHOD                 1068
#define IDC_PROP_INST                   1069
#define IDC_PROP_CLASS                  1070
#define IDC_OVERRIDE                    1071
#define IDC_PROPAGATED                  1072
#define IDC_KEY                         1073
#define IDC_AMENDED                     1073
#define IDC_INDEXED                     1074
#define IDC_NOT_NULL                    1075
#define IDC_SPIN                        1078
#define IDC_USE_AMENDED                 1079
#define IDC_ASYNC                       1080
#define IDC_SYNC                        1081
#define IDC_SEMISYNC                    1082
#define IDC_DIRECT_READ                 1083
#define IDC_TYPE                        1084
#define IDC_CLEAR                       1086
#define IDC_DELETE                      1088
#define IDC_ADD                         1089
#define IDC_COPY_SEL                    1090
#define IDC_INSTANCES                   1091
#define IDC_HIDE_SYSTEM                 1092
#define IDC_HIDE_DERIVED                1093
#define IDC_HIDE_DERIVED2               1094
#define IDC_NORMAL                      1096
#define IDC_MESSAGE                     1097
#define IDC_SHOWOBJECT                  1098
#define IDC_ORIGIN                      1099
#define IDC_VALUE_NULL                  1100
#define IDC_VALUE_NOT_NULL              1101
#define IDC_EMBEDDING                   1102
#define IDC_USER                        1104
#define IDC_PASSWORD                    1105
#define IDC_TRANSPORT                   1106
#define IDC_LOCALE                      1107
#define IDC_SECURITY                    1108
#define IDC_AUTHORITY                   1108
#define IDC_ENABLE_NETWORK_ACCESS       1109
#define IDC_LIST1                       1113
#define IDC_METHOD_LIST                 1113
#define IDC_REPORTS                     1113
#define IDC_EDIT                        1116
#define IDC_EDITIN                      1116
#define IDC_EDITOUT                     1117
#define IDC_WBEM_SIGNATURES             1118
#define IDC_WBEM_ENCRYPTION             1119
#define IDC_WBEM_AUTHENTICATION         1121
#define IDC_NTLM_AUTHENTICATION         1122
#define IDC_ACCOUNT_ENABLED             1124
#define IDC_FULL_NAME                   1125
#define IDC_CONFIRM_PASSWORD            1127
#define IDC_READ_ONLY                   1128
#define IDC                             1129
#define IDC_NTLM_DOMAIN                 1130
#define IDC_ENABLE_ANONYMOUS_RW         1131
#define IDC_NULL                        1132
#define IDC_BLANK                       1133
#define IDC_LOCAL_ADMINS                1144
#define IDC_WBEM_USERS                  1145
#define IDC_WBEM_ADMINS                 1146
#define IDC_ADD_GROUP                   1148
#define IDC_ADD_USER                    1149
#define IDC_NTLM_DOMAIN_ADMINS          1150
#define IDC_MOF                         1158
#define IDC_EVT_COUNT                   1159
#define IDC_USE_CONTEXT                 1161
#define IDC_CONTEXT                     1162
#define IDC_VALUE_LIST                  1163
#define IDC_USE_NEXTASYNC               1163
#define IDC_REQUEST                     1165
#define IDC_ARRAY                       1166
#define IDC_REFRESH                     1167
#define IDC_PROTOTYPE                   1169
#define IDC_ADD_METHOD                  1170
#define IDC_EDIT_METHOD                 1171
#define IDC_INPUT_ARGS                  1171
#define IDC_DELETE_METHOD               1172
#define IDC_OUTPUT_ARGS                 1172
#define IDC_EXECUTE_METHOD              1173
#define IDC_CHECKINPUT                  1173
#define IDC_CHECKOUTPUT                 1174
#define IDC_EDITPATH                    1174
#define IDC_METHLIST                    1175
#define IDC_OBJPATH                     1176
#define IDC_OUTRES                      1177
#define IDC_EXECUTE                     1178
#define IDC_AS_EMPTY                    1180
#define IDC_IMP_IDENTIFY                1182
#define IDC_IMP_IMPERSONATE             1183
#define IDC_IMP_DELEGATE                1184
#define IDC_AUTH_NONE                   1185
#define IDC_AUTH_CONNECTION             1186
#define IDC_AUTH_CALL                   1187
#define IDC_AUTH_PACKET                 1188
#define IDC_AUTH_PACKET_INTEGRITY       1189
#define IDC_AUTH_PACKET_PRIVACY         1190
#define IDC_UPDATE_COMPATIBLE           1194
#define IDC_UPDATE_SAFE                 1195
#define IDC_UPDATE_FORCE                1196
#define IDC_UPDATE_CREATE               1199
#define IDC_UPDATE_UPDATE               1200
#define IDC_UPDATE_NORMAL               1202
#define IDC_ENABLE_PRIVILEGES           1204
#define IDC_REFR_OBJECT_PATH            1205
#define IDC_CALL_METHOD                 1209
#define IDC_TIMEOUT                     1211
#define IDC_STATIC_TIMEOUT              1213
#define IDC_STATIC_BATCH                1214
#define IDC_ENUM_OPTIONS                1215
#define IDC_BATCH                       1216
#define IDC_OPTIONS                     1217
#define IDC_OPEN                        1218
#define IDC_ADDOBJECT                   1219
#define IDC_DELETEOBJECT                1220
#define IDC_RENAMEOBJECT                1222
#define IDC_GETOBJECTSECURITY           1223
#define IDC_EDITOLD                     1224
#define IDC_SETOBJECTSECURITY           1224
#define IDC_EDITNEW                     1225
#define IDC_REFRESH_OBJECT              1226
#define IDC_BIND                        1227
#define IDC_USE_CLASSOBJ                1228
#define IDC_USE_SERVICES                1229
#define IDC_CONNECTUSING                1230
#define IDC_INTERFACERETURNED           1231
#define IDC_AUTHORITYLABEL              1232
#define IDC_PATHLABEL                   1233
#define IDC_COMPLETION                  1234
#define IDC_COMPLETIONLABEL             1235
#define IDC_QUERYTEST                   1236
#define IDC_QTAUTOTEST                  1237
#define IDC_QTMANUALTEST                1238
#define IDD_QUERYTEST                   1239
#define IDC_WBEMHELP                    1240
#define IDC_VIEW_REG                    2000
#define IDC_OPEN_VIEWER                 2000
#define IDC_REGISTER                    2001
#define IDC_NOTIFICATION_QUERY          2001
#define IDC_PROVIDE                     2003
#define IDC_STATIC                      -1
#define IDC_MENU_EXIT                   65535
#define IDC_STATIC_QUAL                 65535

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1237
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemtest\textconv.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    TEXTCONV.H

Abstract:

History:

--*/

#include <windows.h>
#include <stdio.h>
//#include <dbgalloc.h>
//#include <arena.h>
#include <var.h>
//#include <wbemutil.h>

#define TEMP_BUF    2096
#define LARGE_BUF   2096

LPWSTR CreateUnicode(LPSTR sz);
LPSTR TypeToString(int nType);
int StringToType(LPSTR pString);
CVar* StringToValue(LPSTR pString, int nValType);
LPSTR ValueToString(CVar *pValue, int nValType = 0);
LPSTR ValueToNewString(CVar *pValue, int nValType = 0);
void StripTrailingWs(LPSTR pVal);
void StripTrailingWs(LPWSTR pVal);

extern char *g_aValidPropTypes[];
extern const int g_nNumValidPropTypes;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemtest\wbemdlg.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMDLG.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <wbemdlg.h>
#include <stdio.h>

CBasicWbemDialog::CBasicWbemDialog(HWND hParent)
{
    m_lRefCount = 0;
    m_hParent = hParent;
    m_hDlg = NULL;
    m_bDeleteOnClose = FALSE;
    m_pOwner = NULL;
}


CBasicWbemDialog::~CBasicWbemDialog()
{
    if(m_pOwner)
        m_pOwner->Release();
}

INT_PTR CALLBACK CBasicWbemDialog::staticDlgProc(
        HWND hDlg,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam
        )
{
    CBasicWbemDialog* pThis;
    if(uMsg == WM_INITDIALOG)
    {
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        pThis = (CBasicWbemDialog*)lParam;
        pThis->m_hDlg = hDlg;
        ShowWindow(hDlg, SW_HIDE);
	}
    else
    {
        pThis = (CBasicWbemDialog*)GetWindowLongPtr(hDlg, DWLP_USER);
    }

    if(pThis)
    {
        return pThis->DlgProc(hDlg, uMsg, wParam, lParam);
    }
    else return FALSE;
}


BOOL CBasicWbemDialog::DlgProc(
        HWND hDlg,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam
        )
{
    switch(uMsg)
    {
    case WM_INITDIALOG:
	{
		CenterOnParent();
        return OnInitDialog();
	}
    case WM_COMMAND:
        if(LOWORD(wParam) == IDOK)
            return OnOK();
        else if(LOWORD(wParam) == IDCANCEL)
            return OnCancel();
        else if(HIWORD(wParam) == LBN_DBLCLK)
            return OnDoubleClick(LOWORD(wParam));
        else if(HIWORD(wParam) == LBN_SELCHANGE || HIWORD(wParam)==CBN_SELCHANGE)
            return OnSelChange(LOWORD(wParam));
        else
            return OnCommand(HIWORD(wParam), LOWORD(wParam));
    case WM_ACTIVATE:
        if(!m_bModal)
        {
            if(LOWORD(wParam) != WA_INACTIVE)
            {
                ms_hCurrentModeless = m_hDlg;
            }
            else
            {
                ms_hCurrentModeless = NULL;
            }
        }
        return TRUE;
    case WM_CLOSE:
        EndDialog(IDCANCEL);
        DestroyWindow(hDlg);
        return TRUE;
    case WM_NCDESTROY:
        if(m_bDeleteOnClose)
        {
            delete this;
        }
        return TRUE;

    case WM_APP:        // safe private message range (doesn't overlap with dialog controls)
        return OnUser(wParam, lParam);
    }
    return FALSE;
}


BOOL CBasicWbemDialog::OnOK()
{
    if(Verify())
    {
        EndDialog(IDOK);
        return TRUE;
    }
    else return FALSE;
}


BOOL CBasicWbemDialog::OnCancel()
{
    EndDialog(IDCANCEL);
    return TRUE;
}


BOOL CBasicWbemDialog::EndDialog(int nResult)
{
    if(m_bModal)
    {
//        PostMessage(m_hDlg, WM_DESTROY, 0, (LPARAM)nResult);
//        return TRUE;
        return ::EndDialog(m_hDlg, nResult);
    }
    else
    {
        DestroyWindow(m_hDlg);
        return TRUE;
    }
}


WORD CBasicWbemDialog::GetCheck(int nID)
{
    return (WORD)SendMessage(GetDlgItem(nID), BM_GETCHECK, 0, 0);
}


void CBasicWbemDialog::SetCheck(int nID, WORD wCheck)
{
    SendMessage(GetDlgItem(nID), BM_SETCHECK, wCheck, 0);
}

UINT CBasicWbemDialog::GetDlgItemTextX(
    int nDlgItem,
    LPWSTR pStr,
    int nMaxCount
    )
///////////////////////////////////////////////////////////////////
//
//	Starts a loop which creates a buffer of an initial conservative 
//	size and attempts to retrieve the dialog text using the buffer.  
//	If the buffer overflows, iterate the loop, deleting the current 
//	buffer, and recreating it incrementally larger.  Continue until
//	full text is retrieved.  If pStr is NULL, then the inner buffer
//	is not copied.
//
//	PARAMETERS: The dialog item ID, a buffer pointer to receive 
//				the string, the size of the buffer
//	
//	RETURNS:	The size of the total amount of text in the dialog
//				item, or 0 on failure/empty buffer.  It is up 
//				to the caller to compare the buffer size to the 
//				return value to determine of all text was recieved
//
///////////////////////////////////////////////////////////////////
{
	size_t	uLen = 0;		// Size of the internal buffer
	char	*pTmpStr = 0;	// The internal buffer
	UINT	uRes;			// The return value

	do {
		// Delete the previous buffer
		if (pTmpStr)
			delete [] pTmpStr;

		// Increase the size of the buffer
		uLen += 2048;

		pTmpStr = new char[(uLen+1)*2];
		if (0 == pTmpStr)
			return 0;
		
		// Get the text
		uRes = GetDlgItemTextA(m_hDlg, nDlgItem, pTmpStr, uLen);

		// Verify the text
		if (uRes == 0 || _mbstrlen(pTmpStr) == 0)
			return 0;

	// If the buffer is smaller than the text, 
	//	then continue to expand the buffer
	} while(uRes >= (uLen - 1));

	if (NULL != pStr)
		mbstowcs(pStr, pTmpStr, nMaxCount);

	delete [] pTmpStr;

	// Return the size of the text in the dlg box - regardless of 
	//	whether it was copied or not.
	return uRes;
}

BOOL CBasicWbemDialog::SetDlgItemTextX(int ID, WCHAR * pwc)
{
	int iLen = 2*(wcslen(pwc))+1;
	char * pTemp = new char[iLen];
	if(pTemp == NULL)
		return FALSE;
	wcstombs(pTemp, pwc, iLen);
	SetDlgItemText(ID, pTemp);
	delete [] pTemp;
    return TRUE;
}

void CBasicWbemDialog::AddStringToCombo(int nID, LPSTR szString, DWORD dwItemData)
{
	HWND hControl=GetDlgItem(nID);
	if (hControl!=NULL)
	{
		int pos=(int)SendMessage(GetDlgItem(nID), CB_ADDSTRING, 0, LPARAM(szString));
		if (dwItemData!=CB_ERR && pos!=CB_ERR)
		{
			SendMessage (hControl, CB_SETITEMDATA, pos, dwItemData);
		}
	}
}


void CBasicWbemDialog::SetComboSelection (int nID, DWORD dwItemData)
{
	HWND hControl=GetDlgItem(nID);
	int count=(int)SendMessage (hControl, CB_GETCOUNT, 0, 0L);
	for (int pos=0; pos<count; pos++)
	{
		DWORD dwTestData=(DWORD)SendMessage (hControl, CB_GETITEMDATA, pos, 0L);
		if (dwTestData==dwItemData)
		{
			SendMessage (hControl, CB_SETCURSEL, pos, 0L);
		}
	}
}


void CBasicWbemDialog::AddStringToList(int nID, LPSTR szString)
{
    SendMessage(GetDlgItem(nID), LB_ADDSTRING, 0, LPARAM(szString));
}


void CBasicWbemDialog::CenterOnParent()
{
    RECT rParent;

    if(m_hParent == NULL)
    {     
        GetWindowRect(GetDesktopWindow(), &rParent);
    }
    else
    {
        GetWindowRect(m_hParent, &rParent);
    }
        
    RECT rUs;
    GetWindowRect(m_hDlg, &rUs);

    int nHeight = rUs.bottom - rUs.top;
    int nWidth = rUs.right - rUs.left;
    int nX = ((rParent.right - rParent.left) - nWidth) / 2;
/// if(nX < 0) nX = 0;
    int nY = ((rParent.bottom - rParent.top) - nHeight) / 2;
/// if(nY < 0) nY = 0;

	if ( NULL != m_hParent )
	{
		RECT rDesktop;

		HWND hProgMan = FindWindowEx( NULL, NULL, "Progman", "Program Manager" );
		HWND hShell = FindWindowEx( hProgMan, NULL, "SHELLDLL_DefView", NULL );

		if ( ( NULL != hProgMan ) && ( NULL != hShell ) )
		{
			if ( GetClientRect( hShell, &rDesktop ) )
			{
				if ( ( nHeight < ( rDesktop.bottom ) ) && 
					 ( ( rParent.top + nY + nHeight ) > rDesktop.bottom ) )
				{
					nY = ( rDesktop.bottom - nHeight ) - rParent.top;
				}

				if ( ( nWidth < ( rDesktop.right ) ) && 
					 ( ( rParent.left + nX + nWidth ) > rDesktop.right ) )
				{
					nX = ( rDesktop.right - nWidth ) - rParent.left;
				}
			}
		}
	}

    MoveWindow(m_hDlg, rParent.left + nX, rParent.top + nY, 
        nWidth, nHeight, TRUE);
}

void CBasicWbemDialog::SetOwner(CRefCountable* pOwner)
{
    if(m_pOwner)
        m_pOwner->Release();
    m_pOwner = pOwner;
    if(m_pOwner)
        m_pOwner->AddRef();
}

LRESULT CBasicWbemDialog::GetLBCurSel(int nID)
{
    return SendMessage(GetDlgItem(nID), LB_GETCURSEL, 0, 0);
}

LPSTR CBasicWbemDialog::GetLBCurSelString(int nID)
{
    LRESULT nIndex = SendMessage(GetDlgItem(nID), LB_GETCURSEL, 0, 0);
    if(nIndex == LB_ERR)
        return NULL;
    LRESULT nLength = SendMessage(GetDlgItem(nID), LB_GETTEXTLEN, 
                                (WPARAM)nIndex, 0);
    char* sz = new char[nLength+3];
    SendMessage(GetDlgItem(nID), LB_GETTEXT, (WPARAM)nIndex, (LPARAM)sz);
    return sz;
}

LRESULT CBasicWbemDialog::GetCBCurSel(int nID)
{
    return SendMessage(GetDlgItem(nID), CB_GETCURSEL, 0, 0);
}

LPSTR CBasicWbemDialog::GetCBCurSelString(int nID)
{
    LRESULT nIndex = SendMessage(GetDlgItem(nID), CB_GETCURSEL, 0, 0);
    if(nIndex == CB_ERR)
        return NULL;
    LRESULT nLength = SendMessage(GetDlgItem(nID), CB_GETLBTEXTLEN, 
                                (WPARAM)nIndex, 0);
    char* sz = new char[nLength+3];
    SendMessage(GetDlgItem(nID), CB_GETLBTEXT, (WPARAM)nIndex, (LPARAM)sz);
    return sz;
}

HWND CBasicWbemDialog::ms_hCurrentModeless = NULL;

BOOL CBasicWbemDialog::IsDialogMessage(MSG* pMsg)
{
    if(ms_hCurrentModeless != NULL && IsWindow(ms_hCurrentModeless))
        return ::IsDialogMessage(ms_hCurrentModeless, pMsg);
    else
        return FALSE;
}

LRESULT CBasicWbemDialog::MessageLoop()
{
    MSG msg;
    while (GetMessage(&msg, (HWND) NULL, 0, 0)) 
    { 
        if(msg.message == WM_DESTROY && msg.hwnd == m_hDlg)
        {
            DispatchMessage(&msg); 
            return msg.lParam;
        }
        if(CBasicWbemDialog::IsDialogMessage(&msg))
            continue;
        TranslateMessage(&msg); 
        DispatchMessage(&msg); 
    } 

    return FALSE;
}

BOOL CBasicWbemDialog::PostUserMessage(HWND hWnd, WPARAM wParam, LPARAM lParam)
{
    // Since user messages don't seem to be queued (even when
    // posted) mouse & keyboard input messages aren't getting
    // processed.  So we will process them here first.
    MSG msg;
    while (PeekMessage(&msg, (HWND)NULL, 0, 0, PM_REMOVE)) 
    { 
        if (CBasicWbemDialog::IsDialogMessage(&msg))
            continue;
        TranslateMessage(&msg); 
        DispatchMessage(&msg); 
    } 
    BOOL result;
    while (result = PostMessage(hWnd, WM_APP, wParam, lParam) == 0 && IsWindow(hWnd))
    { SwitchToThread();};
    return result;
}

int CBasicWbemDialog::MessageBox(UINT uTextId, UINT uCaptionId, UINT uType)
{
    return MessageBox(m_hDlg, uTextId, uCaptionId, uType);
}

int CBasicWbemDialog::MessageBox(HWND hDlg, UINT uTextId, UINT uCaptionId, UINT uType)
{
    char szText[2048];
    if(LoadString(GetModuleHandle(NULL), uTextId, szText, 2048) <= 0)
    {
        strcpy(szText, "Unable to load resource string");
    }

    char szCaption[2048];
    if(LoadString(GetModuleHandle(NULL), uCaptionId, szCaption, 2048) <= 0)
    {
        strcpy(szCaption, "Unable to load resource string");
    }

    return ::MessageBox(hDlg, szText, szCaption, uType);
}

BOOL CBasicWbemDialog::SetDlgItemText(int nID, UINT uTextId)
{
    char szText[2048];
    if(LoadString(GetModuleHandle(NULL), uTextId, szText, 2048) <= 0)
    {
        strcpy(szText, "Unable to load resource string");
    }

    return SetDlgItemText(nID, szText);
}

BOOL CALLBACK EnableWindowsProc(HWND hWnd, LPARAM lParam)
{
    DWORD dwPid;
    DWORD dwTid = GetWindowThreadProcessId(hWnd, &dwPid);
    if(dwPid == GetCurrentProcessId())
    {
        EnableWindow(hWnd, (BOOL)lParam);
    }
    return TRUE;
}
    
void CBasicWbemDialog::EnableAllWindows(BOOL bEnable)
{
    EnumWindows((WNDENUMPROC)EnableWindowsProc, (LPARAM)bEnable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemtest\wbemdlg.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMDLG.H

Abstract:

History:

--*/

#ifndef __WBEMTEST_DIALOG__H_
#define __WBEMTEST_DIALOG__H_

#include <windows.h>

class CRefCountable
{
protected:
    long m_lRefCount;
public:
    virtual long AddRef() {return ++m_lRefCount;}
    virtual long Release() {return --m_lRefCount;}
};

class CBasicWbemDialog : public CRefCountable
{
protected:
    HWND m_hDlg;
    HWND m_hParent;
    BOOL m_bDeleteOnClose;
    BOOL m_bModal;

    CRefCountable* m_pOwner;

    static HWND ms_hCurrentModeless;
public:
    CBasicWbemDialog(HWND hParent = NULL);
    virtual ~CBasicWbemDialog();

    void SetDeleteOnClose() { m_bDeleteOnClose = TRUE;}
    void SetOwner(CRefCountable* pOwner);

public:
    HWND GetHWND() {return m_hDlg;}

    BOOL EndDialog(int nResult);
    HWND GetDlgItem(int nID) {return ::GetDlgItem(m_hDlg, nID);}

    WORD GetCheck(int nID);
    void SetCheck(int nID, WORD wCheck);

    UINT GetDlgItemTextX(int nDlgItem, LPWSTR pStr, int nMaxCount);
    BOOL SetDlgItemText(int nID, LPSTR szStr)
        {return ::SetDlgItemText(m_hDlg, nID, szStr);}
    BOOL SetDlgItemText(int nID, UINT uTextId);
    BOOL SetDlgItemTextX(int nDlgItem, LPWSTR pStr);

	void AddStringToCombo(int nID, LPSTR szString, DWORD dwItemData=CB_ERR);
	void SetComboSelection (int nID, DWORD dwItemData);
    void AddStringToList(int nID, LPSTR szString);

    LRESULT GetLBCurSel(int nID);
    LPSTR GetLBCurSelString(int nID);
    LRESULT GetCBCurSel(int nID);
    LPSTR GetCBCurSelString(int nID);
    
    void CenterOnParent();

    BOOL PostUserMessage(HWND hWnd, WPARAM wParam, LPARAM lParam);
    int MessageBox(UINT uTextId, UINT uCaptionId, UINT uType);
    static int MessageBox(HWND hDlg, UINT uTextId, UINT uCaptionId, UINT uType);

    static BOOL IsDialogMessage(MSG* pmsg);
    static void EnableAllWindows(BOOL bEnable);

protected:
    virtual BOOL DlgProc(
        HWND hDlg,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam
        );

    virtual BOOL OnInitDialog() {return TRUE;}
    virtual BOOL OnCommand(WORD wNotifyCode, WORD wID) {return TRUE;}
    virtual BOOL OnUser(WPARAM wParam, LPARAM lParam) 
        {return TRUE;}
    virtual BOOL OnOK();
    virtual BOOL OnCancel();
    virtual BOOL OnDoubleClick(int nID) {return TRUE;}
    virtual BOOL OnSelChange(int nID) {return TRUE;}
    virtual BOOL Verify() {return TRUE;}

protected:
    static INT_PTR CALLBACK staticDlgProc(
        HWND hDlg,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam
        );

    LRESULT MessageLoop();
};

class CWbemDialog : public CBasicWbemDialog
{
public:
	int m_ID;
    CWbemDialog(int tID, HWND hParent = NULL) : CBasicWbemDialog(hParent), m_ID(tID) {}
    virtual ~CWbemDialog(){}

    BOOL Create(BOOL bChild = TRUE);
    INT_PTR Run(HWND hParent = NULL, bool bPopup = false);
};

inline BOOL CWbemDialog::Create(BOOL bChild)
{
    m_bModal = FALSE;
    m_hDlg = CreateDialogParam(GetModuleHandle(NULL), 
        MAKEINTRESOURCE(m_ID), 
        (bChild?m_hParent:NULL), &staticDlgProc,
        (LPARAM)(CBasicWbemDialog*)this);

    ShowWindow(m_hDlg, SW_NORMAL);
    return (m_hDlg != NULL);
}

inline INT_PTR CWbemDialog::Run(HWND hParent, bool bPopup)
{
    if(hParent != NULL)
        m_hParent = hParent;

    //Create(TRUE);
    m_bModal = TRUE;
    HWND hCurrentFocus = GetFocus();

    if(!bPopup)
        EnableAllWindows(FALSE);

    INT_PTR ptr = DialogBoxParam(GetModuleHandle(NULL), 
        MAKEINTRESOURCE(m_ID), m_hParent, &staticDlgProc,
        (LPARAM)(CBasicWbemDialog*)this);

    if(!bPopup)
        EnableAllWindows(TRUE);
    SetFocus(hCurrentFocus);
    return ptr;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemtest\wbemntfy.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMNTFY.H

Abstract:

History:

--*/

#ifndef _WBEMNOTFY_H_
#define _WBEMNOTFY_H_

#include <wbemidl.h>
//#include <arena.h>
#include <WT_flexarry.h>

DWORD WINAPI WbemWaitForSingleObject(
    HANDLE hHandle, // handle of object to wait for
    DWORD dwMilliseconds    // time-out interval in milliseconds
   );

class CStatusMonitor
{
private:
    BOOL m_bOpen;
    HWND m_hDlg;
    HWND m_hList;
    BOOL m_bVisible;

public:
    CStatusMonitor();
    ~CStatusMonitor();
    void Hide();
    void Add(long lFlags, HRESULT hRes, BSTR bstr);
    static BOOL CALLBACK DlgProc(
        HWND hDlg,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam
        );
};



class CTestNotify : public IWbemObjectSinkEx
{
    CFlexArray m_aObjects;
    LONG m_lRefCount;
    CRITICAL_SECTION m_cs;
    HANDLE m_hEvent;
    HRESULT m_hres;
    IWbemClassObject* m_pErrorObj;
	IID m_pInterfaceID;
	IUnknown *m_pInterface;

public:
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
    STDMETHOD(SetStatus)(long lFlags, HRESULT hResult, BSTR strParam, 
                         IWbemClassObject* pObjPAram);

	STDMETHOD(Set)(long lFlags, REFIID riid, void *pComObject);

    // Private to implementation.
    // ==========================

    CTestNotify(LONG lStartingRefCount = 1);
   ~CTestNotify();

    UINT WaitForSignal(DWORD dwMSec) { return ::WbemWaitForSingleObject(m_hEvent, dwMSec); }
    CFlexArray* GetObjectArray() { return &m_aObjects; }
	IUnknown *GetInterface() { return m_pInterface; }
    HRESULT GetStatusCode(IWbemClassObject** ppErrorObj = NULL)
    {
        if(ppErrorObj) 
        {
            *ppErrorObj = m_pErrorObj;
            if(m_pErrorObj) m_pErrorObj->AddRef();
        }
        return m_hres;
    }

    void Lock() { EnterCriticalSection(&m_cs); }
    void Unlock() { LeaveCriticalSection(&m_cs); }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemtest\wbemntfy.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMNTFY.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <wbemint.h>
#include <wbemdlg.h>
#include <resource.h>
#include <resrc1.h>
#include <wbemntfy.h>

CStatusMonitor gStatus; 

SCODE CTestNotify::QueryInterface(
    REFIID riid,
    LPVOID * ppvObj
    )
{
    if (riid == IID_IUnknown)
    {
        *ppvObj = (IUnknown *)this;
    }
    else if (riid == IID_IWbemObjectSink)
	{
        *ppvObj = (IWbemObjectSink *)this;
	}
    else if (riid == IID_IWbemObjectSinkEx)
	{
		*ppvObj = (IWbemObjectSinkEx *)this;
	}
	else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}


ULONG CTestNotify::AddRef()
{
    return (ULONG)InterlockedIncrement(&m_lRefCount);
}

ULONG CTestNotify::Release()
{
    Lock();
    if(m_lRefCount <= 0) {
        char szDebug[1000];
        wsprintf(szDebug, "CTestNotify::Release(), ref count is %d", m_lRefCount);
        MessageBox(NULL, szDebug, "DEBUG", MB_OK);
        delete this;
        return 0;
    }

    if (InterlockedDecrement(&m_lRefCount))
    {
        Unlock();
        return 1;
    }

    Unlock();
    delete this;
    return 0;
}


SCODE CTestNotify::Indicate(
    long lObjectCount,
    IWbemClassObject ** pObjArray
    )
{
    if(lObjectCount == 0) return WBEM_NO_ERROR;

    Lock();

    for (int i = 0; i < lObjectCount; i++)
    {
        IWbemClassObject *pObj = pObjArray[i];
        pObj->AddRef();
        m_aObjects.Add(pObj);
    }

    Unlock();
    return WBEM_NO_ERROR;
}


HRESULT CTestNotify::Set(
    long lFlags,
    REFIID riid,
    void *pComObject)
{
	Lock();

	m_pInterfaceID=riid;
    if(pComObject)
    {
	    m_pInterface=(IUnknown *)pComObject;
        m_pInterface->AddRef();
    }
	Unlock();
	return WBEM_NO_ERROR;
}


STDMETHODIMP CTestNotify::SetStatus(long lFlags, HRESULT hResult, BSTR strParam, 
                         IWbemClassObject* pObjParam)
{
    m_hres = hResult;
    if(lFlags & WBEM_STATUS_PROGRESS)
    {
        gStatus.Add(lFlags, hResult, strParam);
        return WBEM_NO_ERROR;
    }
    m_pErrorObj = pObjParam;
    if(pObjParam)
        pObjParam->AddRef();

    SetEvent(m_hEvent);
    return WBEM_NO_ERROR;
}

CTestNotify::CTestNotify(LONG lStartingRefCount)
{
    InitializeCriticalSection(&m_cs);
    m_lRefCount = lStartingRefCount;
    m_hEvent = CreateEvent(0, FALSE, FALSE, 0);
    m_pErrorObj = NULL;
    m_pInterface = NULL;
}

CTestNotify::~CTestNotify()
{
    DeleteCriticalSection(&m_cs);
    CloseHandle(m_hEvent);

    for (int i = 0; i < m_aObjects.Size(); i++)
         ((IWbemClassObject *) m_aObjects[i])->Release();
    if(m_pErrorObj) m_pErrorObj->Release();
}

CStatusMonitor::CStatusMonitor()
{
    m_bVisible = FALSE;
        m_hDlg = CreateDialog(GetModuleHandle(NULL),
            MAKEINTRESOURCE(IDD_STATUS_MONITOR), NULL,
            (DLGPROC)CStatusMonitor::DlgProc);
        ShowWindow(m_hDlg, SW_HIDE);

        m_hList = GetDlgItem(m_hDlg, IDC_REPORTS);
}

CStatusMonitor::~CStatusMonitor()
{
    if(m_bOpen)
        EndDialog(m_hDlg, 0);
}

char buff[2048];

void CStatusMonitor::Add(long lFlags, HRESULT lParam, BSTR strParam)
{
    if(m_bVisible == FALSE)
    {
        ShowWindow(m_hDlg, SW_SHOW);
        SendMessage(m_hList, LB_RESETCONTENT, 0, 0);
    }

    m_bVisible = TRUE;
    if(strParam)
        wsprintf(buff,"Go progress, value is 0x%0x, and string is %S", lParam, strParam);
    else
        wsprintf(buff,"Go progress, value is 0x%0x, and no string", lParam);
 
    SendMessage(m_hList, LB_ADDSTRING, 0, (LPARAM)(LPSTR)buff);
}
void CStatusMonitor::Hide()
{
    ShowWindow(m_hDlg, SW_HIDE);
    m_bVisible = FALSE;
}

BOOL CALLBACK CStatusMonitor::DlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HWND hList;
    switch (uMsg)
    {
        case WM_INITDIALOG:
            hList = GetDlgItem(hDlg, IDC_REPORTS);
            SendMessage(hList, LB_RESETCONTENT, 0, 0);
            return TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case 2: // was IDANI_CLOSE:
                    gStatus.Hide();
                    return TRUE;
            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemtest\wbemqual.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMQUAL.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <stdio.h>
//#include <wbemutil.h>

#include "wbemqual.h"

//***************************************************************************
//
//  CTestQualifier::CTestQualifier
//
//  Constructor for CTestQualifier.
//
//***************************************************************************

CTestQualifier::CTestQualifier()
{
    m_pName = 0;
    m_pValue = 0;
    m_lType = 0;
}

//***************************************************************************
//
//  CTestQualifier::~CTestQualifier
//
//  Destructor for CTestQualifier.
//
//***************************************************************************

CTestQualifier::~CTestQualifier()
{
    delete m_pName;
    delete m_pValue;
}

//***************************************************************************
//
//  CTestQualifier::CTestQualifier
//
//  Copy constructor for CTestQualifier.
//
//***************************************************************************

CTestQualifier::CTestQualifier(CTestQualifier &Src)
{
    m_pName = 0;
    m_pValue = 0;
    m_lType = 0;
    *this = Src;
}

//***************************************************************************
//
//  CTestQualifier::operator =
//
//  Copy constructor for CTestQualifier.
//
//***************************************************************************

CTestQualifier& CTestQualifier::operator =(CTestQualifier &Src)
{
    delete m_pName;
    delete m_pValue;
    m_pName = new wchar_t[wcslen(Src.m_pName) + 1];
    wcscpy(m_pName, Src.m_pName);
    m_pValue = new CVar(*Src.m_pValue);
    m_lType = Src.m_lType;
    return *this;
}

//***************************************************************************
//
//  CTestProperty::CTestProperty
//
//  Constructor.
//
//***************************************************************************

CTestProperty::CTestProperty(IWbemQualifierSet* pQualifiers)
{
    m_pName = 0;
    m_pValue = 0;
    m_lType = 0;
    m_pClass = 0;

    m_pQualifiers = pQualifiers;
    if (m_pQualifiers)
        m_pQualifiers->AddRef();
}

//***************************************************************************
//
//  CTestProperty::~CTestProperty
//
//  Destructor.
//
//***************************************************************************

CTestProperty::~CTestProperty()
{
    delete m_pName;
    delete m_pValue;
    delete m_pClass;

    if (m_pQualifiers)
        m_pQualifiers->Release();
}

//***************************************************************************
//
//  CTestMethod::CTestMethod
//
//  Constructor.
//
//***************************************************************************

CTestMethod::CTestMethod(IWbemQualifierSet* pQualifiers, IWbemClassObject * pInArgs, 
                         IWbemClassObject * pOutArgs, BOOL bEnableInputArgs, BOOL bEnableOutputArgs)
                 :CTestProperty(pQualifiers)
{
    m_pInArgs = pInArgs;
    if (m_pInArgs)
        m_pInArgs->AddRef();
    m_pOutArgs = pOutArgs;
    if (m_pOutArgs)
        m_pOutArgs->AddRef();
    m_bEnableInputArgs = bEnableInputArgs;
    m_bEnableOutputArgs = bEnableOutputArgs;

}

//***************************************************************************
//
//  CTestMethod::~CTestMethod
//
//  Destructor.
//
//***************************************************************************

CTestMethod::~CTestMethod()
{
    if (m_pInArgs)
        m_pInArgs->Release();
    if (m_pOutArgs)
        m_pOutArgs->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemtest\wbemqual.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMQUAL.H

Abstract:

History:

--*/

#ifndef __WbemQualifier__H_
#define __WbemQualifier__H_

//#include <dbgalloc.h>
//#include <arena.h>
#include <var.h>
#include <wbemidl.h>

class CTestQualifier
{
public:
    wchar_t  *m_pName;
    LONG        m_lType;
    CVar        *m_pValue;

    CTestQualifier();
   ~CTestQualifier();
    CTestQualifier(CTestQualifier &Src);
    CTestQualifier& operator =(CTestQualifier &Src);
};

class CTestProperty
{
public:

    LPWSTR m_pName;

    CVar*  m_pValue;
    long m_lType;
    IWbemQualifierSet *m_pQualifiers;
    LPWSTR m_pClass;

    CTestProperty(IWbemQualifierSet* pQualifiers);
    ~CTestProperty();
};
typedef CTestProperty* PCTestProperty;

class CTestMethod : public CTestProperty
{
public:
    IWbemClassObject * m_pInArgs;
    IWbemClassObject * m_pOutArgs;
    BOOL m_bEnableInputArgs;
    BOOL m_bEnableOutputArgs;
    CTestMethod(IWbemQualifierSet* pQualifiers, IWbemClassObject * pInArgs, IWbemClassObject * pOutArgs
        , BOOL bEnableInputArgs, BOOL bEnableOuputArgs);
    ~CTestMethod();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemtest\wt_arrtempl.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    ARRTEMPL.H

Abstract:

    This file defines a simple template for an array of arbitrary pointers.
    Actual growing array functionality is provided by CFlexArray.

    Classes defined:

        template CPointerArray

History:

    11/27/96    a-levn      Compiles.

--*/

#ifndef __ARRAY_TEMPLATE__H_
#define __ARRAY_TEMPLATE__H_

#pragma warning(disable:4786)

#include <map>
#include <WT_strutils.h>


using namespace std;
class wcsless : public binary_function<LPWSTR, LPWSTR, bool>
{
public:
    bool operator()(const LPWSTR& wcs1, const LPWSTR& wcs2) const
        {return wcscmp(wcs1, wcs2) < 0;}
};

class wcsiless : public binary_function<LPWSTR, LPWSTR, bool>
{
public:
    bool operator()(const LPWSTR& wcs1, const LPWSTR& wcs2) const
        {return wbem_wcsicmp(wcs1, wcs2) < 0;}
};

class CReleaseMe
{
protected:
    IUnknown* m_pUnk;

public:
    CReleaseMe(IUnknown* pUnk) : m_pUnk(pUnk){}
    ~CReleaseMe() {if(m_pUnk) m_pUnk->Release();}
};

template<class T>
class CTemplateReleaseMe
{
protected:
    T* m_p;

public:
    CTemplateReleaseMe(T* p) : m_p(p){}
    ~CTemplateReleaseMe() {if(m_p) m_p->Release();}
};

template<class T>
class CDeleteMe
{
protected:
    T* m_p;

public:
    CDeleteMe(T* p) : m_p(p){}
    ~CDeleteMe() {delete m_p;}
};

class CCloseMe
{
protected:
    HANDLE m_h;
public:
    CCloseMe(HANDLE hToClose){m_h = hToClose;};
    ~CCloseMe(){if(m_h && m_h != INVALID_HANDLE_VALUE)CloseHandle(m_h);};
};

class CfcloseMe
{
protected:
    FILE * m_h;
public:
    CfcloseMe(FILE * ToClose){m_h = ToClose;};
    ~CfcloseMe(){if(m_h != NULL)fclose(m_h);};
};

typedef CCloseMe CCloseHandle;

class CRegCloseMe
{
protected:
    HKEY m_h;
public:
    CRegCloseMe(HKEY hToClose){m_h = hToClose;};
    ~CRegCloseMe(){if(m_h)RegCloseKey(m_h);};
};

template<class T>
class CVectorDeleteMe
{
protected:
    T* m_p;
    T** m_pp;

public:
    CVectorDeleteMe(T* p) : m_p(p), m_pp(NULL){}
    CVectorDeleteMe(T** pp) : m_p(NULL), m_pp(pp){}
    ~CVectorDeleteMe() {if(m_p) delete [] m_p; else if(m_pp) delete [] *m_pp;}
};

class CClearMe
{
protected:
    VARIANT* m_pv;

public:
    CClearMe(VARIANT* pv) : m_pv(pv){}
    ~CClearMe() {VariantClear(m_pv);}
};

class CSysFreeMe
{
protected:
    BSTR m_str;

public:
    CSysFreeMe(BSTR str) : m_str(str){}
    ~CSysFreeMe() {SysFreeString(m_str);}
};

class CUnaccessMe
{
protected:
    SAFEARRAY* m_psa;
public:
    CUnaccessMe(SAFEARRAY* psa) : m_psa(psa){}
    ~CUnaccessMe() {SafeArrayUnaccessData(m_psa);}
};

class CMemFreeMe
{
protected:
    void*	m_pMem;
public:
    CMemFreeMe( void* pMem ) : m_pMem(pMem){}
    ~CMemFreeMe() { if ( NULL != m_pMem ) CoTaskMemFree(m_pMem);}
};

#include <WT_flexarry.h>
//#include <flexq.h>
//#include <smallarr.h>

//*****************************************************************************
//
//  class CPointerArray
//
//  Array of pointers to TMember, where TMember is any class. See CFlexArray
//  in coredll\flexarry.h/cpp for documentation.
//
//*****************************************************************************

template <class TMember>
class CNullManager
{
public:
    void AddRefElement(TMember*){}
    void ReleaseElement(TMember*){}
};

template <class TMember, class TManager = CNullManager<TMember>,
                class TArray = CFlexArray>
class CPointerArray
{
protected:
    TArray m_Array;
    TManager m_Manager;
public:
    CPointerArray(const TManager& Manager = TManager())
        : m_Manager(Manager){}
    ~CPointerArray();

     int GetSize() const
        {return m_Array.Size();}
     void SetSize(int nNewSize)
        {m_Array.SetSize(nNewSize);}
     const TMember* GetAt(int nIndex) const
        {return (TMember*)m_Array.GetAt(nIndex);}
     TMember* GetAt(int nIndex)
        {return (TMember*)m_Array.GetAt(nIndex);}
     const TMember* operator[](int nIndex) const
        {return (TMember*)m_Array.GetAt(nIndex);}
     TMember* operator[](int nIndex)
        {return (TMember*)m_Array.GetAt(nIndex);}
     void SetAt(int nIndex, TMember* pElement, TMember** ppOld = NULL);
     bool RemoveAt(int nIndex, TMember** ppOld = NULL);
     bool InsertAt(int nIndex, TMember* pElement);
     int Add(TMember* pElement);
     TMember** GetArrayPtr();
     TMember** UnbindPtr();
     void RemoveAll();
     void Swap(int nIndex1, int nIndex2);
     void Trim() {m_Array.Trim();}

protected:
     void AddRefElement(TMember* p){m_Manager.AddRefElement(p);}
     void ReleaseElement(TMember* p){m_Manager.ReleaseElement(p);}
};
/*
template<class TMember>
class CPointerSmallArray :
        public CPointerArray<TMember, CNullManager<TMember>, CSmallArray>
{
};
*/
//*****************************************************************************
//
//  class CPointerQueue
//
//  Queue of pointers to TMember, where TMember is any class. See CFlexQueue
//  in coredll\flexq.h/cpp for documentation.
//
//*****************************************************************************
/*
template <class TMember, class TManager = CNullManager<TMember> >
class CPointerQueue
{
protected:
    CFlexQueue m_Queue;
    TManager m_Manager;
public:
    CPointerQueue(int nInitialSize = 1, const TManager& Manager = TManager())
        : m_Manager(Manager), m_Queue(nInitialSize){}
    Clear();
    ~CPointerQueue()
        {Clear();}

    inline int GetQueueSize() const
        {return m_Queue.GetQueueSize();}

    bool Enqueue(TMember* pNew)
    {
        AddRefElement(pNew);
        return m_Queue.Enqueue(pNew);
    }
    TMember* Dequeue()
    {
        TMember* p = (TMember*)m_Queue.Dequeue();
        return p;
    }
    bool Requeue(TMember* pNew)
    {
        AddRefElement(pNew);
        return m_Queue.Requeue(pNew);
    }
    TMember* Unqueue()
    {
        TMember* p = (TMember*)m_Queue.Unqueue();
        AddRefElement(p);
        return p;
    }
protected:
     void AddRefElement(TMember* p){m_Manager.AddRefElement(p);}
     void ReleaseElement(TMember* p){m_Manager.ReleaseElement(p);}
};
*/

//*****************************************************************************
//
//  UNIQUE POINTER ARRAY
//
//*****************************************************************************

template <class TMember>
class CUniqueManager
{
public:
    void AddRefElement(TMember*){}
    void ReleaseElement(TMember* pMember) {delete pMember;}
};

template<class TMember>
class CUniquePointerArray :
        public CPointerArray<TMember, CUniqueManager<TMember> >
{
};
/*
template<class TMember>
class CUniquePointerSmallArray :
        public CPointerArray<TMember, CUniqueManager<TMember>, CSmallArray>
{
};
*/
/*
template<class TMember>
class CUniquePointerQueue :
        public CPointerQueue<TMember, CUniqueManager<TMember> >
{
public:
    CUniquePointerQueue<TMember>(int nInitialSize = 1)
        : CPointerQueue<TMember, CUniqueManager<TMember> >(nInitialSize)
    {}
};
*/

//*****************************************************************************
//
//  REFED POINTER ARRAY
//
//*****************************************************************************
template <class TMember>
class CReferenceManager
{
public:
    void AddRefElement(TMember* pMember) {if(pMember)pMember->AddRef();}
    void ReleaseElement(TMember* pMember) {if(pMember)pMember->Release();}
};

template<class TMember>
class CRefedPointerArray :
        public CPointerArray<TMember, CReferenceManager<TMember> >
{
};

		/*
template<class TMember>
class CRefedPointerSmallArray :
        public CPointerArray<TMember, CReferenceManager<TMember>, CSmallArray>
{
};
*/
/*
template<class TMember>
class CRefedPointerQueue :
        public CPointerQueue<TMember, CReferenceManager<TMember> >
{
    CRefedPointerQueue(int nInitialSize = 1)
        : CPointerQueue<TMember, CReferenceManager<TMember> >(nInitialSize)
    {}
};
*/
//*****************************************************************************
//
//  ARRAY OF UNIQUE ARRAYS
//
//*****************************************************************************

template <class TMember>
class CUniqueArrayManager
{
    void AddRefElement(TMember**){}
    void ReleaseElement(TMember** pMember) {delete [] pMember;}
};
template<class TMember>
class CUniqueArrayArray : public CPointerArray<TMember*,
                                               CUniqueArrayManager<TMember> >
{
};

//*****************************************************************************
//
//  IMPLEMENTATION
//
//*****************************************************************************

template <class TMember, class TManager, class TArray>
CPointerArray<TMember, TManager, TArray>::~CPointerArray()
{
    RemoveAll();
}

template <class TMember, class TManager, class TArray>
void CPointerArray<TMember, TManager, TArray>::RemoveAll()
{
    for(int i = 0; i < m_Array.Size(); i++)
    {
        ReleaseElement(GetAt(i));
    }
    m_Array.Empty();
}

template <class TMember, class TManager, class TArray>
void CPointerArray<TMember, TManager, TArray>::SetAt(int nIndex,
                                            TMember* pElement, TMember** ppOld)
{
    if(ppOld == NULL)
        ReleaseElement(GetAt(nIndex));
    else
        *ppOld = GetAt(nIndex);

    AddRefElement(pElement);

    m_Array.SetAt(nIndex, (void*)pElement);
}

template <class TMember, class TManager, class TArray>
bool CPointerArray<TMember, TManager, TArray>::RemoveAt(int nIndex,
                                                        TMember** ppOld)
{
    if(ppOld == NULL)
        ReleaseElement(GetAt(nIndex));
    else
        *ppOld = GetAt(nIndex);

    if(m_Array.RemoveAt(nIndex) != CFlexArray::no_error)
        return false;
    return true;
}

template <class TMember, class TManager, class TArray>
bool CPointerArray<TMember, TManager, TArray>::InsertAt(int nIndex,
                                                        TMember* pElement)
{
    AddRefElement(pElement);
    if(m_Array.InsertAt(nIndex, (void*)pElement) != CFlexArray::no_error)
    {
        ReleaseElement(pElement);
        return false;
    }
    return true;
}

template <class TMember, class TManager, class TArray>
int CPointerArray<TMember, TManager, TArray>::Add(TMember* pElement)
{
    AddRefElement(pElement);
    if(m_Array.Add((void*)pElement) != CFlexArray::no_error)
    {
        ReleaseElement(pElement);
        return -1;
    }
    return m_Array.Size()-1;
}

template <class TMember, class TManager, class TArray>
TMember** CPointerArray<TMember, TManager, TArray>::GetArrayPtr()
{
    return (TMember**)m_Array.GetArrayPtr();
}

template <class TMember, class TManager, class TArray>
TMember** CPointerArray<TMember, TManager, TArray>::UnbindPtr()
{
    return (TMember**)m_Array.UnbindPtr();
}

template <class TMember, class TManager, class TArray>
void CPointerArray<TMember, TManager>::Swap(int nIndex1, int nIndex2)
{
    void* pTemp = m_Array[nIndex1];
    m_Array.SetAt(nIndex1, m_Array[nIndex2]);
    m_Array.SetAt(nIndex2, pTemp);
}
/*
template <class TMember, class TManager>
CPointerQueue<TMember, TManager>::Clear()
{
    TMember* p;
    while(p = (TMember*)m_Queue.Dequeue())
    {
        ReleaseElement(p);
    }
}
*/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemtest\wt_converter.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    CONVERTER.CPP

Abstract:

    <sequence>   ::= <number> | <number><separator><sequence>
    <separator>  ::= [<whitespace>],[<whitespace>] | <whitespace>
    <number>     ::= <whitespace>[-]0x<hexfield>[<comment>] | <whitespace>[-]<digitfield>[<comment>]
    <decfield>   ::= <decdigit> | <decdigit><decfield>
    <decdigit>   ::= 0..9
    <hexfield>   ::= <hexdigit> | <hexdigit><hexfield>
    <hexdigit>   ::= 1..9 | A | B | C | D | E | F
    <comment>    ::= [<whitespace>](<string>)[<whitespace>]
    <whitespace> ::= SP | TAB | CR | LF

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <stdlib.h>
#include <wtypes.h>

#include "wbemcli.h"
#include "var.h"
#include "WT_Converter.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CConverter::CConverter(const char* szString, CIMType ct)
{
    int nSize = strlen(szString);
    m_szString = new char[nSize + 1];   // Made to fit

    strcpy(m_szString, szString);
    m_ct = ct;                          // CIM_TYPE
}

CConverter::~CConverter()
{
    delete m_szString;
}

/******************************************************************
//
//      Helper Functions
//
*******************************************************************/

UINT CConverter::SetBoundary(BOOL bNeg, ULONG *uMaxSize)
//////////////////////////////////////////////////////////////////////
//
//  Establishs the outer boundary of a give CIM type.  Returns the 
//  maximum absolute value, including an offset if the value is 
//  negative. (Compensating for the additional size of 2's complement 
//  negative values)
//
//////////////////////////////////////////////////////////////////////
{
    *uMaxSize = 0;

    switch (m_ct)   
    {
    case CIM_UINT8:
        *uMaxSize = 0x000000FF; break;
    case CIM_SINT8:
        *uMaxSize = (bNeg ? 0x00000080 : 0x0000007F); break;
    case CIM_UINT16:
        *uMaxSize = 0x0000FFFF; break;
    case CIM_SINT16:
        *uMaxSize = (bNeg ? 0x00008000 : 0x00007FFF); break;
    case CIM_UINT32:
        *uMaxSize = 0xFFFFFFFF; break;
    case CIM_SINT32:
        *uMaxSize = (bNeg ? 0x80000000 : 0x7FFFFFFF); break;
    case NULL:
        return ERR_NULL_CIMTYPE;
    default:
        return ERR_UNKNOWN;
    }

    return ERR_NOERROR;
}

BOOL CConverter::IsValidDec(char ch)
//////////////////////////////////////////////////////////////////////
//
//  PARAMETERS : a character to be validated as decimal
//  RETURNS: TRUE only if the character is a valid decimal character
//
//////////////////////////////////////////////////////////////////////
{
    return (('0' <= ch) && ('9' >= ch));
}

BOOL CConverter::IsValidHex(char ch)
//////////////////////////////////////////////////////////////////////
//
//  PARAMETERS : a character to be validated as hexadecimal
//  RETURNS: TRUE only if the character is a valid hexadecimal character
//
//////////////////////////////////////////////////////////////////////
{
    return ((('0' <= ch) && ('9' >= ch)) || (('a' <= ch) && ('f' <= ch)));
}

/******************************************************************
//
//      Parser Functions
//
*******************************************************************/

char CConverter::PeekToken(char *ch)
//////////////////////////////////////////////////////////////////////
//
//  PARAMETERS: the token pointer (by val)
//  RETURNS: the character following the current token pointer.  Does
//  not increment the token pointer.
//
//////////////////////////////////////////////////////////////////////
{
    // ch is passed by value; change is local to method
    ch++;

    // Ensure lower case
    if (('A' <= *ch) && ('Z' >= *ch))
        *ch += ('a' - 'A');
    
    return *ch;
}

BOOL CConverter::GetToken(char **ch)
//////////////////////////////////////////////////////////////////////
//
//  If the token pointer is not at the end of the string, it will be
//  incremented and the current token will be converted into lower 
//  case and passed back.  If the pointer is at the end of the string, 
//  NULL will be passed and the pointer unaffected.  
//
//  PARAMETERS: the token pointer (by ref) 
//
//  RETURNS: TRUE if the token pointer is mid-string, and FALSE if it 
//  is at the end of the string.
//
//////////////////////////////////////////////////////////////////////
{
    // Increment pointer by 1 byte
    if ('\0' != **ch)
        *ch += 1;

    // Ensure lower case
    if (('A' <= **ch) && ('Z' >= **ch))
        **ch += ('a' - 'A');

    // End of the line?
    return ('\0' != **ch);
}

void CConverter::ReplaceToken(char **ch)
//////////////////////////////////////////////////////////////////////
//
//  If not at the front of the string, the token pointer will be 
//  decremented one place towards the head of the string.
//
//  PARAMETERS: the token pointer (by ref) 
//
//  RETURNS: void
//
//////////////////////////////////////////////////////////////////////
{
    if (*ch != m_szString)
        *ch -= 1;
    return;
}

BOOL CConverter::Done(char *ch)
//////////////////////////////////////////////////////////////////////
//
//  Checks for additional non-whitespace tokens following current 
//  token.  Does not validate token.
//
//  PARAMETERS: the token pointer (by ref) 
//
//  RETURNS: TRUE if no further non-whitespace tokens follow the 
//  current token pointer
//
//////////////////////////////////////////////////////////////////////
{
    if ('\0' == *ch)
        return TRUE;

    while (isspace(*ch))
        ch++;

    return ('\0' == *ch);
}

/******************************************************************
//
//      Token Functions
//
*******************************************************************/

UINT CConverter::Token_Sequence(CVar *pVar)
//////////////////////////////////////////////////////////////////////
//
//  Root of parsing for single (non-array) values.  Sets up token
//  pointer (ch), and parses one number.  If tokens remain in the 
//  input string following the parsing of the first number, then
//  the input string is invalid.  
//
//  If the parsing fails, the value of pVar is not changed
//
//  PARAMETERS: a variant for the result (by ref)
//
//  RETURNS: the result state of the parsing
//
//////////////////////////////////////////////////////////////////////
{
    CVar aVar;              // A temporary result variant
    char *ch = m_szString;  // The token pointer
    UINT uRes;              // A generic result sink

    // Parse out the number
    uRes = Token_Number(&ch, &aVar);
    if (ERR_NOERROR != uRes)
        return uRes;

    // Check for remaining tokens
    if (!Done(ch))
        return ERR_INVALID_INPUT_STRING;

    // Parsing ok, copy temp variant into final destiation
    *pVar = aVar;

    return ERR_NOERROR;
}

UINT CConverter::Token_Sequence(CVarVector *pVarVec)
//////////////////////////////////////////////////////////////////////
//
//  Root of parsing for multiple (array) values.  Sets up token
//  pointer (ch), and parses the input string.  It starts with a 
//  single number, and then enters the loop, verifying a seperator
//  between each subsequent number.  Each number is added to the 
//  variant array as it is parsed.
//
//  If the parsing fails, the value if pVarVec is not changed
//
//  PARAMETERS: a variant vector for the result (by ref)
//
//  RETURNS: the result state of the parsing
//
//////////////////////////////////////////////////////////////////////
{
    CVar aVar;                  // A temporary result variant
    char *ch = m_szString;      // The token pointer
    UINT uRes;                  // A generic result sink
    UINT uVTType;

    switch (m_ct)
    {
    case CIM_UINT8:
        uVTType = VT_UI1;break;
    case CIM_SINT8:
    case CIM_SINT16:
        uVTType = VT_I2;break;
    case CIM_UINT16:
    case CIM_UINT32:
    case CIM_SINT32:
        uVTType = VT_I4;break;
    }

    CVarVector aVarVec(uVTType);// A temporary result variant vector

    // Parse out the first number
    uRes = Token_Number(&ch, &aVar);
    if (ERR_NOERROR != uRes)
        return uRes;

    // Add to array, and clear temporary variant
    aVarVec.Add(aVar);

    // If more tokens exist, continue
    while (!Done(ch))
    {
        // Verify separator
        uRes = Token_Separator(&ch);
        if (ERR_NOERROR != uRes)
            return uRes;

        // Parse out next number
        uRes = Token_Number(&ch, &aVar);
        if (ERR_NOERROR != uRes)
            return uRes;

        // Add to array, and clear temporary variant
        aVarVec.Add(aVar);
    }

    // Parsing ok, copy temp variant vector into final destiation
    *pVarVec = aVarVec;

    return ERR_NOERROR;
}

UINT CConverter::Token_WhiteSpace(char **ch)
//////////////////////////////////////////////////////////////////////
//
//  Move token pointer to the next non-white space token
//
//  PARAMETERS: the token pointer (by ref) 
//
//  RETURNS: the result state of the parsing
//
//////////////////////////////////////////////////////////////////////
{
    while (isspace(**ch))
        GetToken(ch);

    return ERR_NOERROR;
}

UINT CConverter::Token_Separator(char **ch)
//////////////////////////////////////////////////////////////////////
//
//  A valid separator is either white space or a comma optionally 
//  preceeded by white space.  Parese out white space.  Stop when
//  a non-whitespace character is encountered.  If a comma, then 
//  there must be a following non-whitespace token.
//
//  PARAMETERS: the token pointer (by ref) 
//
//  RETURNS: the result state of the parsing
//
//////////////////////////////////////////////////////////////////////
{
    BOOL bComma = FALSE;
    
    while ((isspace(**ch) || (',' == **ch)) && !bComma)
    {
        if (',' == **ch)
            bComma = TRUE;

        // If a comma exists, the string must not be done
        if (!GetToken(ch) && bComma)
            return ERR_INVALID_TOKEN;
    }

    return ERR_NOERROR;
}

UINT CConverter::Token_Number(char **ch, CVar *pVar)
//////////////////////////////////////////////////////////////////////
//
//  Determines the sign and base values of the number, and then 
//  calls either Token_HexField or Token_DecField to continue
//  parsing the digit fields.  The numerical value returned from
//  the parsing is unsigned.  If the value is signed and negative
//  the value is negated.  Comments are then parsed out.
//
//  If the parsing fails, the value of pVar does not change
//
//  PARAMETERS: the token pointer (by ref) and a Variant representing 
//  the number (by ref)
//
//  RETURNS: the result state of the parsing
//
//////////////////////////////////////////////////////////////////////
{
    ULONG   aVal;               // Temp value returned from Token_XXXField
    USHORT  uBase = BASE_DEC;   // Base of number
    BOOL    bNegative = FALSE;  // Sign of number
    UINT    uRes;               // Generic result sink

    // Parse out white space
    uRes = Token_WhiteSpace(ch);
    if (ERR_NOERROR != uRes)
        return uRes;

    // Determines the sign (assumed positive) and validates against type
    if (**ch == '-')
    {
        if ((CIM_UINT8 == m_ct) || (CIM_UINT16 == m_ct) || (CIM_UINT32 == m_ct))
            return ERR_INVALID_SIGNED_VALUE;
        //else
        bNegative = TRUE;
        GetToken(ch);   // Get the next token to handle
    }

    // Determine Base (we have initialized as decimal)
    if (**ch == '0')
    {
        if (PeekToken(*ch) == 'x')      // Hexadecimal!
        {                       
            uBase = BASE_HEX;   // Modify base 
            GetToken(ch);       // Get Rid of the 'x' token
            GetToken(ch);       // Get the next token to handle
        }
    }

    // Parse digit field and put result in aVal
    if (BASE_HEX == uBase)
        uRes = Token_HexField(ch, bNegative, &aVal);
    else if (BASE_DEC == uBase)
        uRes = Token_DecField(ch, bNegative, &aVal);
    else
        return ERR_UNKNOWN_BASE;

    if (ERR_NOERROR != uRes)
        return uRes;

    // NOTE: signed operation on unsigned value 
    //      -this may cause a problem on some platforms
    if (bNegative)
        aVal *= (-1);

    // Set variant
    pVar->SetLong(aVal);

    // Parse out comments
    uRes = Token_Comment(ch);
    if (ERR_NOERROR != uRes)
        return uRes;
    
    return ERR_NOERROR;
}

UINT CConverter::Token_DecField(char **ch, BOOL bNeg, ULONG *pVal)
//////////////////////////////////////////////////////////////////////
//
//  Token_DecField first determines the maximum possible value of 
//  the number based on the CIM type for the purpose of bonuds checking.
//  The digit field is parsed, withe each token being added to the 
//  previous tally value after it has increased in magnitude.
//
//  Prior to the tally increasing, the proposed tally is validated 
//  using an algorithm that assumes that the current value is in 
//  range, and verifies that the proposed value will be in range 
//  by working back from the maximum value.  This algorithm works,
//  given that the initial value is 0, which is guarenteed to be
//  within range.  The difference between the current tally, and the
//  proposed tally is subtracted from the maximum value, and if the 
//  result is larger than the current tally, then the propsed value
//  is valid.
//
//  This algorithm assumes that we are using unsigend values.  Signed 
//  negative values are constructed as positive values, and then
//  converted.  In this case, the maximum value is one larger than the 
//  positive maximum value, according to the rules of 2's complement.
//
//  If the parsing fails, the value of pVal does not change
//
//  PARAMETERS: the token pointer (by ref), the sign flag (by val) 
//  and a the unsigned value of the number (by ref)
//
//  RETURNS: the result state of the parsing
//
//////////////////////////////////////////////////////////////////////
{
    ULONG uMaxSize;     // Boundary value
    ULONG aVal = 0;     // Tally value
    ULONG uDigitVal;    // Return digit from Token_DecDigit
    UINT uRes;          // Generic result sink

    // Sets the maximum value of the tally
    uRes = SetBoundary(bNeg, &uMaxSize);
    if (ERR_NOERROR != uRes)
        return uRes;

    // Pareses the first digit
    uRes = Token_DecDigit(ch, &uDigitVal);
    if (ERR_NOERROR != uRes)
        return uRes;

    // Adds to tally
    aVal = uDigitVal;

    // If more decimal tokens...
    while (IsValidDec(**ch))
    {
        // Parse the token
        uRes = Token_DecDigit(ch, &uDigitVal);
        if (ERR_NOERROR != uRes)
            return uRes;

        // Test the bounds of the proposed tally
        if (((uMaxSize - uDigitVal) / BASE_DEC ) < aVal) 
            return ERR_OUT_OF_RANGE;

        // Increase the magnitude and add the token digit value
        aVal = (aVal * BASE_DEC) + uDigitVal;
    }

    // Parsing ok, copy the temp to the destination
    *pVal = aVal;

    return ERR_NOERROR;
}

UINT CConverter::Token_HexField(char **ch, BOOL bNeg, ULONG *pVal)
//////////////////////////////////////////////////////////////////////
//
//  See Token_DecField
//
//////////////////////////////////////////////////////////////////////
{
    ULONG uMaxSize;     // Boundary value
    ULONG aVal = 0;     // Tally value
    ULONG uDigitVal;    // Return digit from Token_DecDigit
    UINT uRes;          // Generic result

    // Sets the maximum value of the tally
    uRes = SetBoundary(bNeg, &uMaxSize);
    if (ERR_NOERROR != uRes)
        return uRes;

    // Pareses the first digit
    uRes = Token_HexDigit(ch, &uDigitVal);
    if (ERR_NOERROR != uRes)
        return uRes;

    // Adds to tally
    aVal = uDigitVal;

    // If more decimal tokens...
    while (IsValidHex(**ch))
    {
        // Parse the token
        uRes = Token_HexDigit(ch, &uDigitVal);
        if (ERR_NOERROR != uRes)
            return uRes;

        // Test the bounds of next tally
        if (((uMaxSize - uDigitVal) / BASE_HEX ) < aVal) 
            return ERR_OUT_OF_RANGE;

        // Increase the magnitude and add the token digit value
        aVal = (aVal * BASE_HEX) + uDigitVal;
    }

    // Parsing ok, copy the temp to the destination
    *pVal = aVal;
    return ERR_NOERROR;
}

UINT CConverter::Token_DecDigit(char **ch, ULONG *pVal)
//////////////////////////////////////////////////////////////////////
//
//  Validates the token, and converts to numerical equivalent
//
//  If the parsing fails, the value of pVal does not change
//
//  PARAMETERS: the token pointer (by ref) and a the value 
//  of the digit (by ref)
//
//  RETURNS: the result state of the parsing
//
//////////////////////////////////////////////////////////////////////
{
    ULONG uVal = 0;     // Temp value

    // Validate digit & convert
    if (('0' <= **ch) && ('9' >= **ch)) 
        uVal = **ch - '0';
    else if ('\0' == **ch)
        return ERR_NULL_TOKEN;
    else
        return ERR_INVALID_TOKEN;

    // Parsing ok, copy value to destination
    *pVal = uVal;

    // Move token pointer
    GetToken(ch);

    return ERR_NOERROR;
}

UINT CConverter::Token_HexDigit(char **ch, ULONG *pVal)
//////////////////////////////////////////////////////////////////////
//
//  Validates the token, and converts to numerical equivalent
//
//  If the parsing fails, the value of pVal does not change
//
//  PARAMETERS: the token pointer (by ref) and a the value 
//  of the digit (by ref)
//
//  RETURNS: the result state of the parsing
//
//////////////////////////////////////////////////////////////////////
{
    ULONG uVal = 0;     // Temp value

    // Validate digit & convert
    if (('a' <= **ch) && ('f' >= **ch))
        uVal = 0xA + (**ch - 'a');
    else if (('0' <= **ch) && ('9' >= **ch)) 
        uVal = **ch - '0';
    else if ('\0' == **ch)
        return ERR_NULL_TOKEN;
    else
        return ERR_INVALID_TOKEN;

    // Parsing ok, copy value to destination
    *pVal = uVal;

    // Move token pointer
    GetToken(ch);

    return ERR_NOERROR;
}

UINT CConverter::Token_Comment(char** ch)
//////////////////////////////////////////////////////////////////////
//
//  Parses out white space and contents between braces, if they exist.
//  If an opening brace is encountered, all of the contents, including 
//  the braces, are ignored.  If an opening brace is encountered, a 
//  closing brace must follow.
//
//  NOTE: Nested comments are not allowed
//
//  PARAMETERS: the token pointer (by ref) 
//  
//  RETURNS: the result state of the parsing
//
//////////////////////////////////////////////////////////////////////
{
    // Parse out white space
    UINT uRes = Token_WhiteSpace(ch);
    if (ERR_NOERROR != uRes)
        return uRes;

    // If the token following the white space is an opening brace,
    // parse out the contents, and verify the existance of the 
    // closing brace
    if ('(' == **ch)
    {
        while ((')' != **ch)) 
        {
            if (!GetToken(ch))
                return ERR_UNMATCHED_BRACE;
        }
        GetToken(ch);   // Purge closing brace
    }

    return ERR_NOERROR;
}

/******************************************************************
//
//      Static Functions
//
*******************************************************************/

UINT CConverter::Convert(const char* szString, CIMType ct, CVar *pVar)
/////////////////////////////////////////////////////////////////////
//
//  Convert is a static method that creates an instance of the 
//  Converter object and converts the string to a variant.  If an
//  error occurs, the value of pVar is not affected.
//
//  PARAMETERS: the input string (by val), the CIM type (by val) and
//  the outout variant (by ref)
//
//  RETURNS: the result state of the parsing
//
/////////////////////////////////////////////////////////////////////
{
    // Checks the CIM type is initialized
    if (NULL == ct)
        return ERR_NULL_CIMTYPE;

    CConverter converter(szString, ct); // The converter object
    CVar aVar;                          // Temp variant

    // Parse out the first number
    UINT uRes = converter.Token_Sequence(&aVar);
    // Check return code
    if (ERR_NOERROR != uRes)
        return uRes;

    // Parsing ok, copy temp to destination
    *pVar = aVar;
    
    return ERR_NOERROR;
}

UINT CConverter::Convert(const char* szString, CIMType ct, CVarVector *pVarVec)
/////////////////////////////////////////////////////////////////////
//
//  Convert is a static method that creates an instance of the 
//  Converter object and converts the string to an array of values.
//  If an error occurs, the value of pVarVec is not affected.
//
//  PARAMETERS: the input string (by val), the CIM type (by val) and
//  the outout variant vecter (by ref)
//
//  Returns the result state of the parsing
//
/////////////////////////////////////////////////////////////////////
{
    // Checks the CIM type is initialized
    if (NULL == ct)
        return ERR_NULL_CIMTYPE;

    CConverter converter(szString, ct); // The converter object
    CVarVector aVarVec;                 // Temp variant vector

    // Parse out the first number
    UINT uRes = converter.Token_Sequence(&aVarVec);
    // Check return code
    if (ERR_NOERROR != uRes)
        return uRes;

    // Parsing ok, copy temp to destination
    *pVarVec = aVarVec;
    
    return ERR_NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemtest\wt_converter.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    Converter.h

Abstract:

    interface for the CConverter class.

History:

	9/15/98 Created 
	9/22/98	Removed Convert(ULONG); Added Convert(CVar) & Convert(CVarVector)

--*/
#ifndef __CONVERTER_H
#define __CONVERTER_H

#define ERR_NOERROR					0x00000000
#define ERR_UNKNOWN					0x00000001
#define ERR_INVALID_SIGNED_VALUE	0x00000002
#define ERR_INVALID_TOKEN			0x00000003
#define ERR_OUT_OF_RANGE			0x00000004
#define ERR_NULL_CIMTYPE			0x00000005
#define ERR_INVALID_INPUT_STRING	0x00000006
#define ERR_NULL_TOKEN				0x00000007
#define ERR_UNKNOWN_BASE			0x00000008
#define ERR_UNMATCHED_BRACE			0x00000009

#define BASE_DEC	10
#define BASE_HEX	16

typedef long CIMType;

class CConverter  
{
	CIMType	m_ct;			// CIM type
	char*	m_szString;		// Input string
//	char*	m_szCurrent;	// Current token pointer

	CConverter(const char* szString, CIMType ct);
	virtual ~CConverter();

	UINT SetBoundary(BOOL bNeg, ULONG *uMaxSize);
	BOOL Done(char *ch);
	BOOL Separator();
	BOOL IsValidDec(char ch);
	BOOL IsValidHex(char ch);

	char PeekToken(char *ch);
	BOOL GetToken(char **ch);
	void ReplaceToken(char **ch);

	UINT Token_Sequence(CVarVector *pVarVec);
	UINT Token_Sequence(CVar *pVar);
	UINT Token_Number(char **ch, CVar *pVar);
	UINT Token_Digit(char **ch, ULONG *ulRes);
	UINT Token_Separator(char **ch);
	UINT Token_DecField(char **ch, BOOL bNeg, ULONG *pVal);
	UINT Token_HexField(char **ch, BOOL bNeg, ULONG *pVal);
	UINT Token_DecDigit(char **ch, ULONG *pVal);
	UINT Token_HexDigit(char **ch, ULONG *pVal);
	UINT Token_Comment(char **ch);
	UINT Token_WhiteSpace(char **ch);
public:
	static UINT Convert(const char* szString, CIMType ct, ULONG *ulRes);
	static UINT Convert(const char* szString, CIMType ct, CVar *pVar);
	static UINT Convert(const char* szString, CIMType ct, CVarVector *pVarVec);
};

#endif //__CONVERTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemtest\wbemtest.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMTEST.CPP

Abstract:

    Test for WBEM

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <time.h>
#include <locale.h>
#include <mbstring.h>
#include <wbemidl.h>

#include <cominit.h>

#include "objedit.h"
#include "wbemntfy.h"
#include "resource.h"
#include "resrc1.h"

#include "bstring.h"

#include "wbemtest.h"

#include "initguid.h"
//#include <wbemcomn.h>
#include "notsink.h"
#include "method.h"
#include "textconv.h"
#include <string.h>
#include <tchar.h>
#include <Htmlhelp.h>
//#include <wbemerror.h>
//#include <genutils.h>

DWORD gdwAuthLevel = RPC_C_AUTHN_LEVEL_PKT;
DWORD gdwImpLevel = RPC_C_IMP_LEVEL_IMPERSONATE;

WCHAR gNameSpace[2048] = L"";
WCHAR gPassword[1024];
WCHAR * gpPassword = NULL;
WCHAR gUser[1024] = L"";
WCHAR * gpUser = NULL;
WCHAR gAuthority[1024] = L"";
WCHAR * gpAuthority = NULL;

// These will be established at ConnectServer time and should remain valid for
// the life of the namespace and all its proxies, refreshers, etc.
BSTR            gpPrincipal = NULL;
COAUTHIDENTITY* gpAuthIdentity = NULL;

WCHAR gTransport[1024] = L"";
WCHAR gLocale[1024] = L"";
long gLoginType = 0;
BOOL gbSecured = FALSE;
//BOOL gbAdvanced = FALSE;

class CCreateInstanceDlg : public CWbemDialog
{
protected:
    LPWSTR m_wszClass;
    long m_lMaxLen;
    LONG* m_plQryFlags;
public:
    CCreateInstanceDlg(HWND hParent, LPWSTR wszClass, long lMaxLen, LONG* plQryFlags)
        : m_wszClass(wszClass), m_lMaxLen(lMaxLen), m_plQryFlags(plQryFlags),
            CWbemDialog(IDD_CREATEINSTANCE, hParent)
    {}

protected:
    BOOL OnInitDialog();
    BOOL Verify();
};

//#pragma warning(4270:disable)

int __cdecl CmpFunc( const void *arg1, const void *arg2 )
{
    if ((arg1 == NULL) || (*(int*)arg1 == 0))
    {
        return 1;
    }

    if ((arg2 == NULL) || (*(int*)arg2 == 0))
    {
        return -1;
    }

    VARIANT t_v1;
    VariantInit(&t_v1);
    VARIANT t_v2;
    VariantInit(&t_v2);
    int retVal = 0;

    if (SUCCEEDED( (*(IWbemClassObject **)arg1)->Get(L"__RELPATH", 0, &t_v1, NULL, NULL) ))
    {
        if (SUCCEEDED( (*(IWbemClassObject **)arg2)->Get(L"__RELPATH", 0, &t_v2, NULL, NULL) ))
        {
            if ( (VT_BSTR == t_v1.vt) && (VT_BSTR == t_v2.vt) )
            {
                char buffA[5120];
                char buffB[5120];
                wcstombs( buffA, t_v1.bstrVal, 5120 );
                wcstombs( buffB, t_v2.bstrVal, 5120 );
                int t_i = CompareStringA(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, buffA, -1, buffB, -1 );

                switch (t_i)
                {
                    case CSTR_LESS_THAN:
                    {
                        retVal = -1;
                        break;
                    }
                    case CSTR_EQUAL:
                    {
                        retVal = 0;
                        break;
                    }
                    case CSTR_GREATER_THAN:
                    default:
                    {
                        retVal = 1;
                        break;
                    }
                }
            }

            VariantClear(&t_v2);
        }

        VariantClear(&t_v1);
    }

    return retVal;
}

UINT WINAPI GetDlgItemTextX(
    HWND hDlg,
    int nDlgItem,
    LPWSTR pStr,
    int nMaxCount
    )
{
    char Tmp[5120];
    *Tmp = 0;
    *pStr = 0;
    UINT uRes = GetDlgItemTextA(hDlg, nDlgItem, Tmp, 5120);
    if (uRes == 0 || strlen(Tmp) == 0)
        return uRes;
    if (mbstowcs(pStr, Tmp, nMaxCount) == (unsigned) nMaxCount)
        *(pStr + nMaxCount - 1) = 0;
    return uRes;
}

BOOL GetServerNamespace(IWbemClassObject *pObj, WCHAR *szResult, int nMaxSize);
INT_PTR GetSuperclassInfo(HWND hDlg, LPWSTR pClass, LONG lMaxBuf, LONG *plQryFlags);
INT_PTR GetClassInfo(HWND hDlg, LPWSTR pClass, LONG lMaxBuf, LONG *plQryFlags);


/////////////////////////////////////////////////////////////////////////////


IWbemLocator *g_pLocator = 0;
IWbemConnection *g_pConnection = 0;
IWbemServices *g_pNamespace = 0;
IWbemServicesEx *g_pServicesEx=NULL;
BSTR g_strNamespace = NULL;
CAppOwner g_Owner;
CContext g_Context;

void Fatal(UINT uMsg)
{
    CBasicWbemDialog::MessageBox(0, uMsg, IDS_CRITICAL_ERROR, MB_OK | MB_SYSTEMMODAL);
}

/////////////////////////////////////////////////////////////////////////////


BOOL RegisterEventSink();
BOOL UnregisterEventSink();

/////////////////////////////////////////////////////////////////////////////


IUnsecuredApartment* CUnsecWrap::mstatic_pApartment = NULL;
IUnsecuredApartment* CUnsecWrapEx::mstatic_pApartment = NULL;


class CMainDlg : public CWbemDialog
{
protected:
    void Connect(BOOL bBind);
    void ConnectButtons(BOOL b);
    void OpenHelp(void);
    void GetClasses();
    void EditClass();
    void CreateClass();
    void DeleteClass();

    void GetInstances();
    void EditInstance();
    void CreateInstance();
    void DeleteInstance();

    void ExecQuery();

    void ExecNotificationQuery();

    void ExecMethod();
    void OpenNs();
    void CreateRefresher();
    void EditContext();
    void Open();
    void AddObject();
    void DeleteObject();
    void RenameObject();
    void GetObjectSecurity();
    void SetObjectSecurity();
	void DoServicesExGenObject(int iOpt);

    LONG  Timeout();
    ULONG BatchCount();

    LONG  m_lGenFlags;      // generic flags (i.e., WBEM_FLAG_ .. used in IWbemServices methods)
    LONG  m_lSync;          // sync, async, semisync

public:
    BOOL  m_fNotificationQueryResultDlg;

    CMainDlg() : CWbemDialog(IDD_MAIN, (HWND)NULL)
    {
        m_lGenFlags = 0;
        m_lSync = SEMISYNC;
        m_fNotificationQueryResultDlg = FALSE;
    }
    ~CMainDlg();

    BOOL OnInitDialog();
    BOOL OnCommand(WORD wNotifyCode, WORD wID);
    BOOL OnOK();
};

BOOL CMainDlg::OnOK()
{
    if(m_lRefCount > 0)
    {
        MessageBox(IDS_MUST_CLOSE_WINDOWS, IDS_ERROR, MB_OK | MB_ICONSTOP);
        return FALSE;
    }

    return CBasicWbemDialog::OnOK();
}

long CAppOwner::Release()
{
    if(CRefCountable::Release() == 0)
    {
        //CoUninitialize();
    }
    return m_lRefCount;
}


int WINAPI WinMain(
    HINSTANCE hInst,
    HINSTANCE hPrevInst,
    PSTR szCmdLine,
    int iCmdShow
    )
{
    mbstowcs(gNameSpace, "", 1000);
    g_strNamespace = SysAllocString(gNameSpace);

    setlocale(LC_ALL, "");

    // OLE initialization.
    // ===================

    HRESULT hr = InitializeCom();

    if (hr != S_OK)
    {
        Fatal(IDS_OLE_INIT_FAILED);
        return -1;
    }

    gbSecured = (strstr(szCmdLine, "/sec") != NULL);
    //gbAdvanced = (strstr(szCmdLine, "/test") != NULL);

    if (strstr(szCmdLine, "/setp") != NULL)
    {
        if (FAILED(EnableAllPrivileges(TOKEN_PROCESS)))
        {
            Fatal(IDS_FAIL_ENABLE_ALL_PRIV);
            return -1;
        }
    }



    hr = InitializeSecurity(NULL, -1, NULL, NULL,
                                RPC_C_AUTHN_LEVEL_NONE,
                                RPC_C_IMP_LEVEL_IMPERSONATE,
                                NULL, EOAC_NONE, 0);

///	// Get a session object.
///	// =======================
///
///	dwRes = CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
///			IID_IWbemLocator, (LPVOID *) &g_pLocator);
///
///
///	if (dwRes != S_OK)
///	{
///		Fatal(IDS_FAILED_IWBEMLOCATOR);
///		OleUninitialize();
///		Fatal(IDS_ABNORMAL_TERMINATION);
///		return -1;
///	}
///
///	dwRes = CoCreateInstance(CLSID_WbemConnection, 0, CLSCTX_INPROC_SERVER,
///			IID_IWbemConnection, (LPVOID *) &g_pConnection);
///
///
///	if (dwRes != S_OK)
///	{
///		Fatal(IDS_FAILED_IWBEMBINDER);
///		OleUninitialize();
///		Fatal(IDS_ABNORMAL_TERMINATION);
///		return -1;
///	}



    CMainDlg* pDlg = new CMainDlg;
    pDlg->SetDeleteOnClose();
    pDlg->SetOwner(&g_Owner);
    pDlg->Create();

    MSG msg;
    while (GetMessage(&msg, (HWND) NULL, 0, 0))
    {
        if(CBasicWbemDialog::IsDialogMessage(&msg))
            continue;
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    if (g_pNamespace) g_pNamespace->Release();
    if (g_pServicesEx) g_pServicesEx->Release();
    if (g_pLocator) g_pLocator->Release();
    if (g_pConnection) g_pConnection->Release();

    g_Context.Clear();
    CoUninitialize();

    // Terminating normally.
    // =====================

    return 0;
}

//***************************************************************************
//
//***************************************************************************

class CErrorDlg : public CWbemDialog
{
protected:
    HRESULT m_hres;
    IWbemClassObject* m_pErrorObj;

public:
    CErrorDlg(HWND hParent, HRESULT hres, IWbemClassObject* pErrorObj = NULL)
        : CWbemDialog(IDD_ERROR,hParent), m_hres(hres), m_pErrorObj(pErrorObj)
    {
        if(pErrorObj) pErrorObj->AddRef();
    }
    ~CErrorDlg()
    {
        if(m_pErrorObj) m_pErrorObj->Release();
    }

    BOOL OnInitDialog();
    BOOL OnCommand(WORD wNotifyCode, WORD wID);
};

BOOL CErrorDlg::OnInitDialog()
{
    CenterOnParent();

    WCHAR szError[TEMP_BUF];
    szError[0] = 0;
    WCHAR szFacility[TEMP_BUF];
    szFacility[0] = 0;
    char szMsg[TEMP_BUF];
    char szFormat[100];
    IWbemStatusCodeText * pStatus = NULL;

    SCODE sc = CoCreateInstance(CLSID_WbemStatusCodeText, 0, CLSCTX_INPROC_SERVER,
                                        IID_IWbemStatusCodeText, (LPVOID *) &pStatus);

    if(sc == S_OK)
    {
        BSTR bstr = 0;
        sc = pStatus->GetErrorCodeText(m_hres, 0, 0, &bstr);
        if(sc == S_OK)
        {
            wcsncpy(szError, bstr, TEMP_BUF-1);
            SysFreeString(bstr);
            bstr = 0;
        }
        sc = pStatus->GetFacilityCodeText(m_hres, 0, 0, &bstr);
        if(sc == S_OK)
        {
            wcsncpy(szFacility, bstr, TEMP_BUF-1);
            SysFreeString(bstr);
            bstr = 0;
        }
        pStatus->Release();
    }
    if(wcslen(szFacility) == 0 || wcslen(szError) == 0)
    {
        LoadString(GetModuleHandle(NULL), ERROR_FORMAT_EX, szFormat, 99);
        sprintf(szMsg, szFormat, m_hres);
    }
    else
    {
        LoadString(GetModuleHandle(NULL), ERROR_FORMAT_LONG, szFormat, 99);
        sprintf(szMsg, szFormat, m_hres, szFacility, szError);
    }
    SetDlgItemText(IDC_MESSAGE, szMsg);


    EnableWindow(GetDlgItem(IDC_SHOWOBJECT), (m_pErrorObj != NULL));
    return TRUE;
}

BOOL CErrorDlg::OnCommand(WORD wNotifyCode, WORD wID)
{
    // Show object is the only command out there

    if(wID == IDC_SHOWOBJECT)
    {
        CObjectEditor Ed(m_hDlg, 0, CObjectEditor::readonly, SYNC, m_pErrorObj);
        Ed.Edit();
    }
    return TRUE;
}

void FormatError(HRESULT res, HWND hParent, IWbemClassObject* pErrorObj)
{
    BOOL bOwn = FALSE;
    if(pErrorObj == NULL)
    {
        IErrorInfo* pEI;
        if(GetErrorInfo(0, &pEI) == S_OK)
        {
            pEI->QueryInterface(IID_IWbemClassObject, (void**)&pErrorObj);
            pEI->Release();
            if(pErrorObj)
                bOwn = TRUE;
        }
    }

    CErrorDlg Dlg(hParent, res, pErrorObj);
    Dlg.Run(NULL, true); // no disablement
    if(bOwn)
        pErrorObj->Release();
}


static wchar_t *g_pTargetClassBuf;
static int g_nMaxTargetClassBuf;

void SetDlgItemTextWC(HWND hDlg, int ID, WCHAR * pwc)
{
    int iLen = 2*(wcslen(pwc))+1;
    char * pTemp = new char[iLen];
    if(pTemp == NULL)
        return;
    wcstombs(pTemp, pwc, iLen);
    SetDlgItemText(hDlg, ID, pTemp);
    delete pTemp;
}

void GetDlgItemTextWC(HWND hDlg, int ID, WCHAR * pwc,int iwcSize)
{
    char * pTemp = new char[iwcSize * 2];
    if(pTemp == NULL)
        return;
    if(GetDlgItemText(hDlg, ID, pTemp, iwcSize *2))
    {
        mbstowcs(pwc, pTemp, iwcSize);
    }
    else *pwc = 0;

    delete pTemp;
}


class CConnectDlg : public CWbemDialog
{
protected:
	BOOL m_bBind;
    LONG  m_lGenFlags;  // generic WBEM_FLAG_ .. flags
    LONG  m_lTimeout;   // used in semisync only

public:
    CConnectDlg(HWND hParent, BOOL bBind, LONG lGenFlags, LONG lTimeout) : CWbemDialog((bBind) ? IDD_WBEM_BIND : IDD_WBEM_CONNECT, hParent),
		 m_lGenFlags(lGenFlags), m_lTimeout(lTimeout)
    { m_bBind = bBind;}

protected:
	enum {CONNECT_IWBEMLOCATOR, CONNECT_IWBEMCONNECTION};
	enum {INTERFACE_IWBEMSERVICES, INTERFACE_IWBEMSERVICESEX, INTERFACE_IWBEMCLASSOBJECT};

    BOOL OnInitDialog();
    BOOL Verify();
    virtual BOOL OnSelChange(int nID);
};

BOOL CConnectDlg::OnInitDialog()
{
	if (gNameSpace[0]==L'\0')
		SetDlgItemTextX(IDC_NAMESPACE, L"root\\default");
	else
		SetDlgItemTextX(IDC_NAMESPACE, gNameSpace);
    SetDlgItemTextX(IDC_USER, gUser);
    SetDlgItemTextX(IDC_PASSWORD, gPassword);
    SetDlgItemTextX(IDC_LOCALE, gLocale);
    SetDlgItemTextX(IDC_AUTHORITY, gAuthority);
    BOOL bRet = CheckRadioButton(m_hDlg, IDC_NULL, IDC_BLANK, IDC_NULL);

    if (gdwImpLevel == RPC_C_IMP_LEVEL_IDENTIFY)
    {
        CheckRadioButton(m_hDlg, IDC_IMP_IDENTIFY, IDC_IMP_DELEGATE, IDC_IMP_IDENTIFY);
    }
    else if (gdwImpLevel == RPC_C_IMP_LEVEL_IMPERSONATE)
    {
        CheckRadioButton(m_hDlg, IDC_IMP_IDENTIFY, IDC_IMP_DELEGATE, IDC_IMP_IMPERSONATE);
    }
    else if (gdwImpLevel == RPC_C_IMP_LEVEL_DELEGATE)
    {
        CheckRadioButton(m_hDlg, IDC_IMP_IDENTIFY, IDC_IMP_DELEGATE, IDC_IMP_DELEGATE);
    }
    if (gdwAuthLevel == RPC_C_AUTHN_LEVEL_NONE)
    {
        CheckRadioButton(m_hDlg, IDC_AUTH_NONE, IDC_AUTH_PACKET_PRIVACY, IDC_AUTH_NONE);
    }
    else if (gdwAuthLevel == RPC_C_AUTHN_LEVEL_CONNECT)
    {
        CheckRadioButton(m_hDlg, IDC_AUTH_NONE, IDC_AUTH_PACKET_PRIVACY, IDC_AUTH_CONNECTION);
    }
    else if (gdwAuthLevel == RPC_C_AUTHN_LEVEL_CALL)
    {
        CheckRadioButton(m_hDlg, IDC_AUTH_NONE, IDC_AUTH_PACKET_PRIVACY, IDC_AUTH_CALL);
    }
    else if (gdwAuthLevel == RPC_C_AUTHN_LEVEL_PKT)
    {
        CheckRadioButton(m_hDlg, IDC_AUTH_NONE, IDC_AUTH_PACKET_PRIVACY, IDC_AUTH_PACKET);
    }
    else if (gdwAuthLevel == RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)
    {
        CheckRadioButton(m_hDlg, IDC_AUTH_NONE, IDC_AUTH_PACKET_PRIVACY, IDC_AUTH_PACKET_INTEGRITY);
    }
    else if (gdwAuthLevel == RPC_C_AUTHN_LEVEL_PKT_PRIVACY)
    {
        CheckRadioButton(m_hDlg, IDC_AUTH_NONE, IDC_AUTH_PACKET_PRIVACY, IDC_AUTH_PACKET_PRIVACY);
    }

   	AddStringToCombo (IDC_CONNECTUSING, "IWbemLocator (Namespaces)", CONNECT_IWBEMLOCATOR);

#if 0
	RAID 167868 
	Support for EX temporary removed, default IWbemLocator
	AddStringToCombo (IDC_CONNECTUSING, "IWbemConnection (Namespaces, Scopes, Objects)", CONNECT_IWBEMCONNECTION);
#endif
	SetComboSelection (IDC_CONNECTUSING, g_pConnection ? CONNECT_IWBEMCONNECTION : CONNECT_IWBEMLOCATOR );
	SendMessage (m_hDlg, WM_COMMAND, MAKEWPARAM(IDC_CONNECTUSING, CBN_SELCHANGE), (LPARAM)GetDlgItem (IDC_CONNECTUSING));

	AddStringToCombo (IDC_COMPLETION, "Synchronous", SYNC);
	AddStringToCombo (IDC_COMPLETION, "Semisynchronous", SEMISYNC);
	AddStringToCombo (IDC_COMPLETION, "Asynchronous", ASYNC);
	SetComboSelection (IDC_COMPLETION, SYNC);

	return TRUE;
}


BOOL CConnectDlg::OnSelChange(int nID)
{
	int sel=(int)SendDlgItemMessage (m_hDlg, IDC_CONNECTUSING, CB_GETCURSEL, 0, 0L);
	int connectusing=(int)SendDlgItemMessage (m_hDlg, IDC_CONNECTUSING, CB_GETITEMDATA, sel, 0L);
	sel=(int)SendDlgItemMessage (m_hDlg, IDC_INTERFACERETURNED, CB_GETCURSEL, 0, 0L);
	int interfacereturned=(int)SendDlgItemMessage (m_hDlg, IDC_INTERFACERETURNED, CB_GETITEMDATA, sel, 0L);

	switch (nID)
	{
		case IDC_CONNECTUSING:
		{
			bool authority=(connectusing==CONNECT_IWBEMLOCATOR);
			EnableWindow (GetDlgItem (IDC_AUTHORITY), authority);
			EnableWindow (GetDlgItem (IDC_AUTHORITYLABEL), authority);

			bool asynchronous=(connectusing==CONNECT_IWBEMCONNECTION);
			EnableWindow (GetDlgItem (IDC_COMPLETION), asynchronous);
			EnableWindow (GetDlgItem (IDC_COMPLETIONLABEL), asynchronous);
			if (!asynchronous)
				SetComboSelection (IDC_COMPLETION, SYNC);

			SendDlgItemMessage (m_hDlg, IDC_INTERFACERETURNED, CB_RESETCONTENT, 0, 0L);
			AddStringToCombo (IDC_INTERFACERETURNED, "IWbemServices", INTERFACE_IWBEMSERVICES);
			
#if 0		
			RAID 167868 
			Support for EX temporary removed 
			AddStringToCombo (IDC_INTERFACERETURNED, "IWbemServicesEx", INTERFACE_IWBEMSERVICESEX);
#endif
			if (connectusing==CONNECT_IWBEMCONNECTION)
				AddStringToCombo (IDC_INTERFACERETURNED, "IWbemClassObject", INTERFACE_IWBEMCLASSOBJECT);
			
			SetComboSelection (IDC_INTERFACERETURNED, ( g_pServicesEx ? INTERFACE_IWBEMSERVICESEX : INTERFACE_IWBEMSERVICES ));

			SendMessage (m_hDlg, WM_COMMAND, MAKEWPARAM(IDC_INTERFACERETURNED, CBN_SELCHANGE), (LPARAM)GetDlgItem (IDC_INTERFACERETURNED));

			break;
		}

		case IDC_INTERFACERETURNED:
		{
			if (connectusing==CONNECT_IWBEMLOCATOR)
				SetDlgItemText (IDC_PATHLABEL, "Namespace");
			else
			{
				if (interfacereturned==INTERFACE_IWBEMCLASSOBJECT)
					SetDlgItemText (IDC_PATHLABEL, "Object Path");
				else
					SetDlgItemText (IDC_PATHLABEL, "Namespace/Scope");
			}

			break;
		}
	}

    return TRUE;
}

BOOL CConnectDlg::Verify()
{
    WCHAR NameSpace[512], User[64], Password[64], Locale[128];
    WCHAR Authority[64];
    User[0] = Password[0] = Locale[0] = Authority[0] = NameSpace[0] = 0;
	bool bBoundToObject = false;

    GetDlgItemTextX(IDC_NAMESPACE, NameSpace, 512);
    GetDlgItemTextX(IDC_USER, User, 64);
    GetDlgItemTextX(IDC_PASSWORD, Password, 64);
    GetDlgItemTextX(IDC_AUTHORITY, Authority, 64);
    GetDlgItemTextX(IDC_LOCALE, Locale, 128);

    bool bTreatEmptyAsBlank = (BST_CHECKED == IsDlgButtonChecked(m_hDlg, IDC_BLANK));

    gdwAuthLevel = RPC_C_AUTHN_LEVEL_NONE;
    gdwImpLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
    if (BST_CHECKED == IsDlgButtonChecked(m_hDlg, IDC_IMP_IDENTIFY))
    {
        gdwImpLevel = RPC_C_IMP_LEVEL_IDENTIFY ;
    }
    else if (BST_CHECKED == IsDlgButtonChecked(m_hDlg, IDC_IMP_IMPERSONATE))
    {
        gdwImpLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;
    }
    else if (BST_CHECKED == IsDlgButtonChecked(m_hDlg, IDC_IMP_DELEGATE))
    {
        gdwImpLevel = RPC_C_IMP_LEVEL_DELEGATE ;
    }
    if (BST_CHECKED == IsDlgButtonChecked(m_hDlg, IDC_AUTH_NONE))
    {
        gdwAuthLevel = RPC_C_AUTHN_LEVEL_NONE;
    }
    else if (BST_CHECKED == IsDlgButtonChecked(m_hDlg, IDC_AUTH_CONNECTION))
    {
        gdwAuthLevel = RPC_C_AUTHN_LEVEL_CONNECT;
    }
    else if (BST_CHECKED == IsDlgButtonChecked(m_hDlg, IDC_AUTH_CALL))
    {
        gdwAuthLevel = RPC_C_AUTHN_LEVEL_CALL ;
    }
    else if (BST_CHECKED == IsDlgButtonChecked(m_hDlg, IDC_AUTH_PACKET))
    {
        gdwAuthLevel = RPC_C_AUTHN_LEVEL_PKT ;
    }
    else if (BST_CHECKED == IsDlgButtonChecked(m_hDlg, IDC_AUTH_PACKET_INTEGRITY))
    {
        gdwAuthLevel = RPC_C_AUTHN_LEVEL_PKT_INTEGRITY ;
    }
    else if (BST_CHECKED == IsDlgButtonChecked(m_hDlg, IDC_AUTH_PACKET_PRIVACY))
    {
        gdwAuthLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY ;
    }

    if(wcslen(NameSpace) < 1)
    {
        MessageBox(m_hDlg, IDS_INVALID_NAMESPACE, IDS_ERROR, MB_OK | MB_ICONSTOP);
        return FALSE;
    }
    CBString bsNamespace(NameSpace);
    CBString bsLocale(Locale);

    HCURSOR hWait, hSave = NULL;

    CBString bsUser;
    CBString bsAuthority;
    CBString bsPassword;

    if(wcslen(User) > 0)
        bsUser = User;

    if(wcslen(Password) > 0)
        bsPassword = Password;
    else if (bTreatEmptyAsBlank)
        bsPassword = L"";

    if(wcslen(Authority) > 0)
        bsAuthority = Authority;

    // Cleanup a preexisting principal and AuthIdentity as necessary
    if ( NULL != gpPrincipal )
    {
        SysFreeString( gpPrincipal );
        gpPrincipal = NULL;
    }

    if ( NULL != gpAuthIdentity )
    {
        WbemFreeAuthIdentity( gpAuthIdentity );
        gpAuthIdentity = NULL;
    }

    hWait = LoadCursor(NULL, IDC_WAIT);
    SCODE sRes=S_OK;
    if(hWait)
        hSave = SetCursor(hWait);


	// Determine which connection method and interface is requested.
	int cursel=(int)SendDlgItemMessage (m_hDlg, IDC_CONNECTUSING, CB_GETCURSEL, 0, 0);
	int ConnectUsing=(int)SendDlgItemMessage (m_hDlg, IDC_CONNECTUSING, CB_GETITEMDATA, cursel, 0);
	cursel=(int)SendDlgItemMessage (m_hDlg, IDC_INTERFACERETURNED, CB_GETCURSEL, 0, 0);
	int InterfaceReturned=(int)SendDlgItemMessage (m_hDlg, IDC_INTERFACERETURNED, CB_GETITEMDATA, cursel, 0);
	int sel=(int)SendDlgItemMessage (m_hDlg, IDC_COMPLETION, CB_GETCURSEL, 0, 0);
	LONG lSync=(LONG)SendDlgItemMessage (m_hDlg, IDC_COMPLETION, CB_GETITEMDATA, sel, 0);
    IID riid;
	switch (InterfaceReturned)
	{
		case INTERFACE_IWBEMSERVICES:
            riid = IID_IWbemServices;
			break;
		case INTERFACE_IWBEMSERVICESEX:
            riid = IID_IWbemServicesEx;
			break;
		case INTERFACE_IWBEMCLASSOBJECT:
            riid = IID_IWbemClassObject;
    }

	// Obtain a connection object of the requested type.
	if (g_pLocator) g_pLocator->Release();
	if (g_pConnection) g_pConnection->Release();
	g_pLocator=NULL;
	g_pConnection=NULL;
	switch (ConnectUsing)
	{
		case CONNECT_IWBEMLOCATOR:
		{
			sRes=CoCreateInstance (CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (void **)&g_pLocator);
			break;
		}

		case CONNECT_IWBEMCONNECTION:
		{
			sRes=CoCreateInstance (CLSID_WbemConnection, 0, CLSCTX_INPROC_SERVER, IID_IWbemConnection, (void **)&g_pConnection);
			break;
		}
    }


	// Connect and obtain requested interfaces.
	if (g_pNamespace) g_pNamespace->Release();
	if (g_pServicesEx) g_pServicesEx->Release();
	g_pNamespace=NULL;
	g_pServicesEx=NULL;
	IWbemClassObject *pObject=NULL;
	if (g_pLocator)
	{
		sRes=g_pLocator->ConnectServer (bsNamespace.GetString(), 
			bsUser.GetString(), bsPassword.GetString(),
			bsLocale.GetString(), 0, bsAuthority.GetString(), g_Context, &g_pNamespace);

		if (SUCCEEDED(sRes))
		{
			switch (InterfaceReturned)
			{
				case INTERFACE_IWBEMSERVICESEX:
				{
					sRes=g_pNamespace->QueryInterface (IID_IWbemServicesEx, (void **)&g_pServicesEx);
					break;
				}

				case INTERFACE_IWBEMCLASSOBJECT:
				{
					// This should always fail.  It's here so that wbemtest can display the actual
					// return code as generated by QI in such a case.
					sRes=g_pNamespace->QueryInterface (IID_IWbemClassObject, (void **)&pObject);
					break;
				}
			}
		}
	}
	else if (g_pConnection)
	{
		IUnknown *pUnknown=NULL;

		if (lSync & ASYNC)
		{
			CTestNotify* pSink=new CTestNotify();

			sRes=g_pConnection->OpenAsync(bsNamespace.GetString(),
				bsUser.GetString(), bsPassword.GetString(),
				bsLocale.GetString(), 0, g_Context, 
				riid, pSink);

			if (SUCCEEDED(sRes))
			{
				pSink->WaitForSignal(INFINITE);
				sRes = pSink->GetStatusCode();
				if(SUCCEEDED(sRes))
				{
					pUnknown=pSink->GetInterface();
					pSink->Release();
				}
			}
		}
		else if (lSync & SEMISYNC)
		{
	        IWbemCallResultEx *pResult=NULL;

			sRes=g_pConnection->Open (bsNamespace.GetString(),
				bsUser.GetString(), bsPassword.GetString(),
				bsLocale.GetString(), 0, g_Context, 
				riid, NULL, &pResult);

			if (SUCCEEDED(sRes))
			{
				SetInterfaceSecurityEx (pResult, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);

				LONG lStatus;
				while ((sRes=pResult->GetCallStatus (WBEM_INFINITE, &lStatus))==WBEM_S_TIMEDOUT)
				{
                    Sleep(200);         // give the other threads a chance
				}

				if (SUCCEEDED(sRes))
				{
					sRes=(HRESULT)lStatus;
					if (sRes==WBEM_S_NO_ERROR)
					{
						sRes=pResult->GetResult (0, 0, IID_IWbemServices, (void**)&pUnknown);
					}
				}

				pResult->Release();
			}
		}
		else
		{
			sRes=g_pConnection->Open (bsNamespace.GetString(),
				bsUser.GetString(), bsPassword.GetString(),
				bsLocale.GetString(), 0, g_Context, 
				riid, (void **)&pUnknown, NULL);
		}

		if (SUCCEEDED(sRes))
		{
			switch (InterfaceReturned)
			{
				case INTERFACE_IWBEMSERVICES:
				{
					sRes=pUnknown->QueryInterface (IID_IWbemServices, (void **)&g_pNamespace);
					break;
				}

				case INTERFACE_IWBEMSERVICESEX:
				{
					// A-DAVCOO: We temporarily need both interfaces when an IWbemServicesEx is requested.
					sRes=pUnknown->QueryInterface (IID_IWbemServices, (void **)&g_pNamespace);
					if (SUCCEEDED(sRes))
						sRes=pUnknown->QueryInterface (IID_IWbemServicesEx, (void **)&g_pServicesEx);

					break;
				}

				case INTERFACE_IWBEMCLASSOBJECT:
				{
					sRes=pUnknown->QueryInterface (IID_IWbemClassObject, (void **)&pObject);
					break;
				}
			}

			pUnknown->Release();
			pUnknown=NULL;
		}
	}


	// If an IWbemClassObject was obtained, display the object editor.
	if (pObject)
	{
		bBoundToObject=true;
		CObjectEditor ed(m_hDlg, m_lGenFlags, CObjectEditor::foreign, lSync, pObject, m_lTimeout);
		ed.Edit();

		pObject->Release();
		pObject=NULL;
	}


    if(hSave)
        SetCursor(hSave);
    if(SUCCEEDED(sRes))
    {
        if(!bBoundToObject)
			wcscpy(gNameSpace, NameSpace);
        wcscpy(gLocale, Locale);
        wcscpy(gAuthority, Authority);
        wcscpy(gUser, User);
        if(wcslen(gUser) > 0)
            gpUser = gUser;
        else
            gpUser = NULL;
        wcscpy(gPassword, Password);
        if(wcslen(gPassword) > 0)
            gpPassword = gPassword;
        else if (bTreatEmptyAsBlank)
            gpPassword = L"";
        else
            gpPassword = NULL;

        if(wcslen(gAuthority) > 0)
            gpAuthority = gAuthority;
        else
            gpAuthority = NULL;

		if (g_pNamespace)
		{
			SetInterfaceSecurityEx(g_pNamespace, gpAuthority, gpUser, gpPassword,
				gdwAuthLevel, gdwImpLevel, EOAC_NONE, &gpAuthIdentity, &gpPrincipal );
		}

		if (g_pServicesEx)
		{
			SetInterfaceSecurityEx(g_pNamespace, gpAuthority, gpUser, gpPassword,
				gdwAuthLevel, gdwImpLevel, EOAC_NONE, &gpAuthIdentity, &gpPrincipal );
		}
    }

	if (FAILED(sRes))
	{
        FormatError(sRes, m_hDlg);
        SetDlgItemText(IDC_PASSWORD, "");
        return FALSE;
    }

	if(bBoundToObject)
		return FALSE;
	else
	{
		SysFreeString(g_strNamespace);
		g_strNamespace = SysAllocString(bsNamespace.GetString());
	    return TRUE;
	}
}

//***************************************************************************
//
//***************************************************************************
void CMainDlg::Connect(BOOL bBind)
{
    if(m_lRefCount > 0)
    {
        MessageBox(IDS_MUST_CLOSE_WINDOWS, IDS_ERROR, MB_OK | MB_ICONSTOP);
        return;
    }

    CConnectDlg ConnectDlg(m_hDlg, bBind, m_lGenFlags, Timeout());
    INT_PTR nRes = ConnectDlg.Run();
    ConnectButtons(g_pNamespace!=NULL);

    if(nRes != IDOK)
    {
        if(g_pNamespace == NULL)
            SetDlgItemText(IDC_NAMESPACE, "");
        return;
    }
    // If here, we succeeded.
    // ======================
    SetDlgItemTextWC(m_hDlg, IDC_NAMESPACE, gNameSpace);
    ConnectButtons(TRUE);
}


//***************************************************************************
//
//***************************************************************************
void CMainDlg::OpenHelp(void)
{

  TCHAR helpFile[]=TEXT("\\HELP\\WBEMTEST.CHM");
  const int maxPath = MAX_PATH+sizeof(helpFile)/sizeof(TCHAR);

  TCHAR sysLoc[maxPath];  
  const int pathLen = GetWindowsDirectory (sysLoc,MAX_PATH);

  if (pathLen == 0 || pathLen >=MAX_PATH)
      return;
  _tcscat(sysLoc,helpFile);

 HtmlHelp(m_hDlg,sysLoc,HH_DISPLAY_TOPIC,0);
}


//***************************************************************************
//
//***************************************************************************



LRESULT CALLBACK GetClassNameDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            return TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                    *g_pTargetClassBuf = 0;
                    GetDlgItemTextX(hDlg, IDC_CLASS_NAME, g_pTargetClassBuf,
                        g_nMaxTargetClassBuf);
                    EndDialog(hDlg, IDOK);
                    return TRUE;

                case IDCANCEL:
                    EndDialog(hDlg, IDCANCEL);
                    return TRUE;
            }
    }
    return FALSE;
}

//***************************************************************************
//
//***************************************************************************

INT_PTR GetClassName(HWND hDlg, wchar_t *pszClassName, int nLimit)
{
    g_pTargetClassBuf = pszClassName;
    g_nMaxTargetClassBuf = nLimit;

    INT_PTR nRes = DialogBox(GetModuleHandle(0),
        MAKEINTRESOURCE(IDD_CLASS_NAME), hDlg,
            (DLGPROC) GetClassNameDlgProc
            );

    return nRes;
}

BOOL _GetObject(HWND hDlg, LONG lGenFlags, wchar_t *pszPath, LONG lSync, IWbemClassObject*& pClass,
                LONG lTimeout, bool bSuppressErrors = false)
{
    CBString bsPath(pszPath);
    pClass = NULL;

    HRESULT res;
    IWbemClassObject* pErrorObj = NULL;

    // Asynchronous
    if (lSync & ASYNC)
    {
        CHourGlass hg;
        CTestNotify* pNtfy = new CTestNotify(1);

        res = g_pNamespace->GetObjectAsync(bsPath.GetString(),
                                lGenFlags | WBEM_FLAG_SEND_STATUS,
                                g_Context, CUnsecWrap(pNtfy));

        if(SUCCEEDED(res))
        {
            pNtfy->WaitForSignal(INFINITE);

            res = pNtfy->GetStatusCode(&pErrorObj);
            if(SUCCEEDED(res))
            {
                CFlexArray* pArray = pNtfy->GetObjectArray();

                if(pArray && pArray->Size() > 0)
                {
                    pClass = (IWbemClassObject*)pArray->GetAt(0);
                    if (pClass)
                        pClass->AddRef();
                }
            }
        }
        pNtfy->Release();
    }

    // Semisynchronous
    else if (lSync & SEMISYNC)
    {
        IWbemCallResult* pCallRes = NULL;
        CHourGlass hg;
        res = g_pNamespace->GetObject(bsPath.GetString(),
                                lGenFlags | WBEM_FLAG_RETURN_IMMEDIATELY,
                                g_Context, &pClass, &pCallRes);

        if (SUCCEEDED(res))
        {
            LONG lStatus;
            SetInterfaceSecurityEx(pCallRes, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
            while ((res = pCallRes->GetCallStatus(lTimeout, &lStatus)) == WBEM_S_TIMEDOUT)
            {
                // wait
            }
            if (res == WBEM_S_NO_ERROR)
            {
                res = (HRESULT)lStatus;     // lStatus is the final result of the above IWbemServices::GetObject call
				if ( SUCCEEDED (res) )
                {
                    res = pCallRes->GetResultObject(0, &pClass); // don't use timeout since object should be available
                }
				else
				{
			        if(!bSuppressErrors)
						FormatError(res, hDlg, pErrorObj);
					return FALSE;
				}
            }

            pCallRes->Release();
        }
    }

    // Synchronous
    else
    {
        CHourGlass hg;
        res = g_pNamespace->GetObject(bsPath.GetString(),
                                lGenFlags,
                                g_Context, &pClass, NULL);
    }

    if (FAILED(res))
    {
        if(!bSuppressErrors)
			FormatError(res, hDlg, pErrorObj);
        return FALSE;
    }

    return TRUE;
}

BOOL _PutClass(HWND hDlg, LONG lGenFlags, LONG lChgFlags, LONG lSync,
               IWbemClassObject* pClass, LONG lTimeout)
{
    HRESULT res;
    IWbemClassObject* pErrorObj = NULL;

    // Asynchronous
    if(lSync & ASYNC)
    {
        CHourGlass hg;
        CTestNotify* pNtfy = new CTestNotify(1);

        res = g_pNamespace->PutClassAsync(pClass,
                                lGenFlags | lChgFlags | WBEM_FLAG_SEND_STATUS,
                                g_Context, CUnsecWrap(pNtfy));

        if(SUCCEEDED(res))
        {
            pNtfy->WaitForSignal(INFINITE);

            res = pNtfy->GetStatusCode(&pErrorObj);
        }
        pNtfy->Release();
    }

    // Semisynchronous
    else if (lSync & SEMISYNC)
    {
        IWbemCallResult* pCallRes = NULL;
        CHourGlass hg;
        res = g_pNamespace->PutClass(pClass,
                                lGenFlags | lChgFlags | WBEM_FLAG_RETURN_IMMEDIATELY,
                                g_Context, &pCallRes);

        if (SUCCEEDED(res))
        {
            LONG lStatus;
            SetInterfaceSecurityEx(pCallRes, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
            while ((res = pCallRes->GetCallStatus(lTimeout, &lStatus)) == WBEM_S_TIMEDOUT)
            {
                // wait
            }
            if (res == WBEM_S_NO_ERROR)
            {
                res = (HRESULT)lStatus;     // lStatus is the final result of the above IWbemServices::PutClass call
            }

            pCallRes->Release();
        }
    }

    // Synchronous
    else
    {
        CHourGlass hg;
        res = g_pNamespace->PutClass(pClass,
                                lGenFlags | lChgFlags,
                                g_Context, NULL);
    }

    if (FAILED(res))
    {
        FormatError(res, hDlg, pErrorObj);
        return FALSE;
    }

    return TRUE;
}

void ShowClass(HWND hDlg, LONG lGenFlags, LPWSTR wszClass, LONG lSync,
               CRefCountable* pOwner, LONG lTimeout)
{
    IWbemClassObject* pClass;
    if(!_GetObject(hDlg, lGenFlags, wszClass, lSync, pClass, lTimeout))
        return;

    DWORD dwEditMode;
    if(wcschr(wszClass, L'\\') || wcschr(wszClass, L':'))
        dwEditMode = CObjectEditor::foreign;
    else
        dwEditMode = CObjectEditor::readwrite;

    CObjectEditor* ped = new CObjectEditor(hDlg, lGenFlags, dwEditMode, lSync, pClass,
                                           lTimeout);
    ped->RunDetached(pOwner);
    pClass->Release();
}

void CMainDlg::EditClass()
{
    wchar_t Class[2048];
    *Class = 0;

    INT_PTR nRes = GetClassName(m_hDlg, Class, 2048);
    if (nRes == IDCANCEL || wcslen(Class) == 0)
        return;

    // Create the requested class; the timeout is only used if semisync
    IWbemClassObject* pClass;
    if (!_GetObject(m_hDlg, m_lGenFlags, Class, m_lSync, pClass, Timeout()))
        return;

    DWORD dwEditMode = CObjectEditor::readwrite;

    // Create an object that is guarenteed to be in the local server\namespace
    IWbemClassObject *pLocalObj = 0;

    if (_GetObject(m_hDlg, m_lGenFlags, L"__SystemClass", m_lSync, pLocalObj, Timeout(), true))
	{

		// Extract the server\namespace path for the objects
		WCHAR szSNS1[2048], szSNS2[2048];
		GetServerNamespace(pClass, szSNS1, 2048);
		GetServerNamespace(pLocalObj, szSNS2, 2048);

		// Set the edit permissions based on whether the requested
		//  object is in the same namespace
		if (_wcsicmp(szSNS1, szSNS2))
			dwEditMode = CObjectEditor::foreign;
	}

    if (pLocalObj)
        pLocalObj->Release();

    CObjectEditor* ped = new CObjectEditor(m_hDlg, m_lGenFlags, dwEditMode, m_lSync,
                                           pClass, Timeout(), BatchCount());
    ped->RunDetached(this);
    pClass->Release();
}

//***************************************************************************
//
//***************************************************************************

static wchar_t *g_pSupClassBuf = 0;
static int g_nMaxSupClassBuf = 0;

LRESULT CALLBACK SuperclassDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            return TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                    *g_pSupClassBuf = 0;
                    GetDlgItemTextX(hDlg, IDC_SUPERCLASS, g_pSupClassBuf,
                        g_nMaxSupClassBuf);
                    EndDialog(hDlg, IDOK);
                    return TRUE;

                case IDCANCEL:
                    EndDialog(hDlg, IDCANCEL);
                    return TRUE;
            }
    }
    return FALSE;
}

//***************************************************************************
//
//***************************************************************************

INT_PTR GetSuperclass(HWND hDlg, wchar_t *pszClassName, int nLimit)
{
    g_pSupClassBuf = pszClassName;
    g_nMaxSupClassBuf = nLimit;

    INT_PTR nRes = DialogBox(GetModuleHandle(0),
        MAKEINTRESOURCE(IDD_SUPERCLASS), hDlg,
            (DLGPROC) SuperclassDlgProc
            );

    return nRes;
}

//***************************************************************************
//
//***************************************************************************
BOOL PreCreateClass(HWND hDlg, LONG lGenFlags, WCHAR* Superclass, LONG lSync,
                    IWbemClassObject*& pNewClass, LONG lTimeout)
{
    // Get the parent class, if any
    // ============================

    IWbemClassObject* pParentClass = 0;
    if (!_GetObject(hDlg, lGenFlags, Superclass, lSync, pParentClass, lTimeout))
    {
        return FALSE;
    }

    // Create an empty child class
    // ===========================

    HRESULT hres = WBEM_S_NO_ERROR;
    if (wcslen(Superclass) > 0)
    {
        hres = pParentClass->SpawnDerivedClass(0, &pNewClass);
        if (hres != WBEM_S_NO_ERROR)
        {
            FormatError(hres, hDlg);
            pParentClass->Release();
            return FALSE;
        }
    }
    else
    {
        pNewClass = pParentClass;
        pNewClass->AddRef();
    }

    pParentClass->Release();
    if (FAILED(hres))
    {
        FormatError(hres, hDlg);
        return FALSE;
    }

    VARIANT v;
    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(L"");
    pNewClass->Put(L"__CLASS", 0, &v, 0);
    VariantClear(&v);

    return TRUE;
}

BOOL _CreateClass(HWND hDlg, LONG lGenFlags, WCHAR* Superclass, LONG lSync,
                    IWbemClassObject** ppClass, LONG lTimeout)
{
    IWbemClassObject* pNewClass;

    if (!PreCreateClass(hDlg, lGenFlags, Superclass, lSync, pNewClass, lTimeout))
        return FALSE;

    // Start editing
    // =============

    CObjectEditor ed(hDlg, lGenFlags, CObjectEditor::readwrite, lSync, pNewClass,
                     lTimeout);
    if (ed.Edit() == IDCANCEL)
    {
        pNewClass->Release();
        return FALSE;
    }

    // Finally, commit the class definition if the user
    // did not hit 'cancel'.
    // =================================================

    BOOL bRes = _PutClass(hDlg, lGenFlags, WBEM_FLAG_CREATE_ONLY, lSync, pNewClass, lTimeout);

    if (bRes && ppClass)
        *ppClass = pNewClass;
    else
        pNewClass->Release();

    return bRes;
}

void CMainDlg::CreateClass()
{
    wchar_t Superclass[2048];
    *Superclass = 0;

    // Allow user to specify a superclass.
    // ====================================

    INT_PTR nRes = GetSuperclass(m_hDlg, Superclass, 2048);
    if ((nRes == IDCANCEL) || (nRes == 0))
        return;

    IWbemClassObject* pClass = NULL;
    PreCreateClass(m_hDlg, m_lGenFlags, Superclass, m_lSync, pClass, Timeout());

    if(pClass == NULL)
        return;

    CObjectEditor* ped = new CObjectEditor(m_hDlg, m_lGenFlags, CObjectEditor::readwrite,
                                           m_lSync, pClass, Timeout(), BatchCount());
    ped->RunDetached(this);
    pClass->Release();
}

void CMainDlg::DeleteClass()
{
    wchar_t ClassName[2048];
    *ClassName = 0;

    INT_PTR nRes = GetClassName(m_hDlg, ClassName, 2048);

    if (nRes == IDCANCEL || wcslen(ClassName) == 0)
        return;

    nRes = MessageBox(IDS_DELETING_CLASS, IDS_WARNING, MB_YESNO | MB_ICONWARNING);
    if(nRes != IDYES)
        return;

    CBString bsClassName(ClassName);

    HRESULT res;
    IWbemClassObject* pErrorObj = NULL;

    // Asynchronous
    if(m_lSync & ASYNC)
    {
        CHourGlass hg;
        CTestNotify* pNtfy = new CTestNotify(1);

        res = g_pNamespace->DeleteClassAsync(bsClassName.GetString(),
                                             m_lGenFlags | WBEM_FLAG_SEND_STATUS,
                                             g_Context, CUnsecWrap(pNtfy));

        if (SUCCEEDED(res))
        {
            pNtfy->WaitForSignal(INFINITE);

            res = pNtfy->GetStatusCode(&pErrorObj);
        }
        pNtfy->Release();
    }

    // Semisynchronous
    else if (m_lSync & SEMISYNC)
    {
        IWbemCallResult* pCallRes = NULL;
        CHourGlass hg;
        res = g_pNamespace->DeleteClass(bsClassName.GetString(),
                                        m_lGenFlags | WBEM_FLAG_RETURN_IMMEDIATELY,
                                        g_Context, &pCallRes);
        if (SUCCEEDED(res))
        {
            LONG lStatus;
            LONG lTimeout = Timeout();
            SetInterfaceSecurityEx(pCallRes, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
            while ((res = pCallRes->GetCallStatus(lTimeout, &lStatus)) == WBEM_S_TIMEDOUT)
            {
                // wait
            }
            if (res == WBEM_S_NO_ERROR)
            {
                res = (HRESULT)lStatus;     // lStatus is the final result of the above IWbemServices::DeleteClass call
            }

            pCallRes->Release();
        }
    }

    // Synchronous
    else
    {
        CHourGlass hg;
        res = g_pNamespace->DeleteClass(bsClassName.GetString(),
                                        m_lGenFlags,
                                        g_Context, NULL);
    }

    if (FAILED(res))
    {
        FormatError(res, m_hDlg, pErrorObj);
        return;
    }
}

BOOL _PutInstance(HWND hDlg, LONG lGenFlags, LONG lChgFlags, LONG lSync,
                  IWbemClassObject* pInstance, LONG lTimeout)
{
    HRESULT res;
    IWbemClassObject* pErrorObj = NULL;

    // Asynchronous
    if(lSync & ASYNC)
    {
        CHourGlass hg;
        CTestNotify* pNtfy = new CTestNotify(1);

        res = g_pNamespace->PutInstanceAsync(pInstance,
                                lGenFlags | lChgFlags | WBEM_FLAG_SEND_STATUS,
                                g_Context, CUnsecWrap(pNtfy));

        if (SUCCEEDED(res))
        {
            pNtfy->WaitForSignal(INFINITE);

            res = pNtfy->GetStatusCode(&pErrorObj);
        }
        pNtfy->Release();
    }

    // Semisynchronous
    else if (lSync & SEMISYNC)
    {
        IWbemCallResult* pCallRes = NULL;
        CHourGlass hg;
        res = g_pNamespace->PutInstance(pInstance,
                                lGenFlags | lChgFlags |  WBEM_FLAG_RETURN_IMMEDIATELY,
                                g_Context, &pCallRes);

        if (SUCCEEDED(res))
        {
            LONG lStatus;
            SetInterfaceSecurityEx(pCallRes, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
            while ((res = pCallRes->GetCallStatus(lTimeout, &lStatus)) == WBEM_S_TIMEDOUT)
            {
                // wait
            }
            if (res == WBEM_S_NO_ERROR)
            {
                res = (HRESULT)lStatus;     // lStatus is the final result of the above IWbemServices::PutInstance call
            }

            pCallRes->Release();
        }
    }

    // Synchronous
    else
    {
        CHourGlass hg;
        res = g_pNamespace->PutInstance(pInstance,
                                lGenFlags | lChgFlags,
                                g_Context, NULL);
    }

    if (FAILED(res))
    {
        FormatError(res, hDlg, pErrorObj);
        return FALSE;
    }

    return TRUE;
}


IWbemClassObject* PreCreateInstance(HWND hDlg, LONG lGenFlags, LONG lSync, LONG lTimeout)
{
    // Get the class.
    // ==============
    wchar_t ClassName[2048];
    *ClassName = 0;

	long lFlags = 0;
    CCreateInstanceDlg InfoDlg(hDlg, ClassName, 2048, &lFlags);
    INT_PTR nRes = InfoDlg.Run();

    if (nRes == IDCANCEL || wcslen(ClassName) == 0)
        return NULL;

	IWbemClassObject* pInst = 0;
	if(lFlags == 1)
	{
		IWbemClassObject* pClass = 0;
		if (!_GetObject(hDlg, lGenFlags, ClassName, lSync, pClass, lTimeout))
			return NULL;

		// Get a clean instance of the class.
		// ==================================

		HRESULT hres = pClass->SpawnInstance(0, &pInst);
		if (FAILED(hres))
		{
			FormatError(hres, hDlg);
			return NULL;
		}
	}
	else
	{
		if (!_GetObject(hDlg, WBEM_FLAG_SPAWN_INSTANCE, ClassName, lSync, pInst, lTimeout))
			return NULL;
	}

    return pInst;
}

IWbemClassObject* _CreateInstance(HWND hDlg, LONG lGenFlags, LONG lSync, LONG lTimeout)
{
    IWbemClassObject* pInst = PreCreateInstance(hDlg, lGenFlags, lSync, lTimeout);
    if(pInst == NULL)
        return NULL;

    // If here, we have an instance we can edit.
    // =========================================

    CObjectEditor ed(hDlg, lGenFlags, CObjectEditor::readwrite, lSync, pInst, lTimeout);
    if (ed.Edit() == IDCANCEL)
    {
        pInst->Release();
        return NULL;
    }

    return pInst;
}


void CMainDlg::CreateInstance()
{
    IWbemClassObject* pInst = PreCreateInstance(m_hDlg, m_lGenFlags, m_lSync, Timeout());
    if(pInst == NULL)
        return;

    CObjectEditor* ped = new CObjectEditor(m_hDlg, m_lGenFlags, CObjectEditor::readwrite,
                                           m_lSync, pInst, Timeout(), BatchCount());
    ped->RunDetached(this);
    pInst->Release();
}

/////////////////////////////////////////////////////////////////////////////
//
//  Refresher Object Path Dialog
//
/////////////////////////////////////////////////////////////////////////////
static wchar_t *g_pszRefrObjectPath = 0;
static int g_nMaxRefrObjectPath = 0;

LRESULT CALLBACK RefrObjectPathDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            return TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                    *g_pszRefrObjectPath = 0;
                    GetDlgItemTextX(hDlg, IDC_REFR_OBJECT_PATH, g_pszRefrObjectPath,
                        g_nMaxRefrObjectPath);
                    EndDialog(hDlg, IDOK);
                    return TRUE;

                case IDC_ADDENUM:
                    *g_pszRefrObjectPath = 0;
                    GetDlgItemTextX(hDlg, IDC_REFR_OBJECT_PATH, g_pszRefrObjectPath,
                        g_nMaxRefrObjectPath);
                    EndDialog(hDlg, IDC_ADDENUM);
                    return TRUE;

                case IDCANCEL:
                    EndDialog(hDlg, IDCANCEL);
                    return TRUE;
            }
    }
    return FALSE;
}

INT_PTR GetRefrObjectPath(HWND hDlg, LPWSTR pStr, int nMax)
{
    g_pszRefrObjectPath = pStr;
    g_nMaxRefrObjectPath = nMax;

    INT_PTR nRes = DialogBox(GetModuleHandle(0),
        MAKEINTRESOURCE(IDD_REFRESHER_OBJECT_PATH), hDlg,
            (DLGPROC) RefrObjectPathDlgProc
            );
    return nRes;
}

/////////////////////////////////////////////////////////////////////////////
//
//  Object Path Dialog
//
/////////////////////////////////////////////////////////////////////////////
static wchar_t *g_pszObjectPath = 0;
static int g_nMaxObjectPath = 0;

LRESULT CALLBACK ObjectPathDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            return TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                    *g_pszObjectPath = 0;
                    GetDlgItemTextX(hDlg, IDC_OBJECT_PATH, g_pszObjectPath,
                        g_nMaxObjectPath);
                    EndDialog(hDlg, IDOK);
                    return TRUE;

                case IDCANCEL:
                    EndDialog(hDlg, IDCANCEL);
                    return TRUE;
            }
    }
    return FALSE;
}

INT_PTR GetObjectPath(HWND hDlg, LPWSTR pStr, int nMax)
{
    g_pszObjectPath = pStr;
    g_nMaxObjectPath = nMax;

    INT_PTR nRes = DialogBox(GetModuleHandle(0),
        MAKEINTRESOURCE(IDD_OBJECT_PATH), hDlg,
            (DLGPROC) ObjectPathDlgProc
            );
    return nRes;
}

BOOL GetServerNamespace(IWbemClassObject *pObj, WCHAR *szResult, int nMaxSize)
///////////////////////////////////////////////////////////////////
//
//  Calls Get on the object's path property, removes the colon
//  and object name which results in a string representing the
//  server\namespace.
//
//  Parameters: a pointer to a Class Object, a pointer to the output
//              string, and the maximum size of the output string
//
//  Returns :   True if success.
//
///////////////////////////////////////////////////////////////////
{
    VARIANT vObjNS;
    VariantInit(&vObjNS);

    // Get the full object path
    HRESULT hRes = pObj->Get(L"__PATH", 0, &vObjNS, NULL, NULL);
    if (FAILED(hRes))
        return FALSE;

    // Identify the colon location
    int len = wcscspn(V_BSTR(&vObjNS), L":");

    // Check boundary of the result string
    if (len + 1 > nMaxSize)
        return FALSE;

    // Copy the server\namespace
    wcsncpy(szResult, V_BSTR(&vObjNS), len);
    szResult[len] = L'\0';

    VariantClear(&vObjNS);

    return TRUE;
}

void CMainDlg::EditInstance()
{
    wchar_t ObjPath[2560];

    // Get the path for the object to be created
    INT_PTR iRet = GetObjectPath(m_hDlg, ObjPath, 2560);
    if(iRet == IDCANCEL)
        return;

    if (wcslen(ObjPath) == 0)
    {
        MessageBox(IDS_NO_PATH, IDS_ERROR, MB_OK);
        return;
    }

    // Create the requested object; the timeout is only used if semisync
    IWbemClassObject *pInst = 0;
    if (!_GetObject(m_hDlg, m_lGenFlags, ObjPath, m_lSync, pInst, Timeout()))
        return;

    DWORD dwEditMode = CObjectEditor::readwrite;

    // Create an object that is guarenteed to be in the server\namespace
	// This is used so that we can gray out the "save" buttons in the case
	// where an a GetObject is passed another namespace and we dont have the
	// IWbemServices pointer to it.

    IWbemClassObject *pLocalObj = 0;
    if (_GetObject(m_hDlg, m_lGenFlags, L"__SystemClass", m_lSync, pLocalObj,
                    Timeout(), true))
	{
		// Extract the server\namespace path for the objects
		WCHAR szSNS1[2048], szSNS2[2048];
		GetServerNamespace(pInst, szSNS1, 2048);
		GetServerNamespace(pLocalObj, szSNS2, 2048);

		// Set the edit permissions based on whether the requested
		//  object is in the same namespace
		if(_wcsicmp(szSNS1, szSNS2))
			dwEditMode = CObjectEditor::foreign;

		if (pLocalObj)
			pLocalObj->Release();
	}

    CObjectEditor* ped = new CObjectEditor(m_hDlg, m_lGenFlags, dwEditMode, m_lSync,
                                           pInst, Timeout(), BatchCount());
    ped->RunDetached(this);
    pInst->Release();
}


void CMainDlg::DeleteInstance()
{
    wchar_t ObjPath[2560];
    *ObjPath = 0;

    INT_PTR iRet = GetObjectPath(m_hDlg, ObjPath, 2560);
    if (iRet == IDCANCEL)
        return;

    if (wcslen(ObjPath) == 0)
        return;

    CBString bsObjPath(ObjPath);
    HRESULT res;
    IWbemClassObject* pErrorObj = NULL;

    // Asynchronous
    if (m_lSync & ASYNC)
    {
        CHourGlass hg;
        CTestNotify* pNtfy = new CTestNotify(1);

        res = g_pNamespace->DeleteInstanceAsync(bsObjPath.GetString(),
                                                m_lGenFlags | WBEM_FLAG_SEND_STATUS,
                                                g_Context, CUnsecWrap(pNtfy));

        if (SUCCEEDED(res))
        {
            pNtfy->WaitForSignal(INFINITE);

            res = pNtfy->GetStatusCode(&pErrorObj);
        }
        pNtfy->Release();
    }

    // Semisynchronous
    else if (m_lSync & SEMISYNC)
    {
        IWbemCallResult* pCallRes = NULL;
        CHourGlass hg;
        res = g_pNamespace->DeleteInstance(bsObjPath.GetString(),
                                           m_lGenFlags | WBEM_FLAG_RETURN_IMMEDIATELY,
                                           g_Context, &pCallRes);
        if (SUCCEEDED(res))
        {
            LONG lStatus;
            LONG lTimeout = Timeout();
            SetInterfaceSecurityEx(pCallRes, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
            while ((res = pCallRes->GetCallStatus(lTimeout, &lStatus)) == WBEM_S_TIMEDOUT)
            {
                // wait
            }
            if (res == WBEM_S_NO_ERROR)
            {
                res = (HRESULT)lStatus;     // lStatus is the final result of the above IWbemServices::DeleteIntance call
            }

            pCallRes->Release();
        }
    }

    // Synchronous
    else
    {
        CHourGlass hg;
        res = g_pNamespace->DeleteInstance(bsObjPath.GetString(), m_lGenFlags,
                                           g_Context, NULL);
    }

    if (FAILED(res))
    {
        FormatError(res, m_hDlg, pErrorObj);
    }
}



//***************************************************************************
//
//***************************************************************************
class CNotificationQueryResultDlg : public CQueryResultDlg
{
public:
    CNotificationQueryResultDlg(HWND hParent, LONG lGenFlags, LONG lQryFlags, LONG lSync )
	    : CQueryResultDlg(hParent, lGenFlags, lQryFlags, FALSE)
	{
        if ( SEMISYNC == lSync )
        {
		    CMainDlg * pMainDlg = (CMainDlg*)GetWindowLongPtr(hParent, DWLP_USER);
		    pMainDlg->m_fNotificationQueryResultDlg = TRUE;
        }
	};

	~CNotificationQueryResultDlg( )
	{
        if ( SEMISYNC == m_lSync )
        {
		    CMainDlg * pMainDlg = (CMainDlg*)GetWindowLongPtr(m_hParent, DWLP_USER);
			if ( NULL != pMainDlg )
			{
			    pMainDlg->m_fNotificationQueryResultDlg = FALSE;
			}
			else
			{
				// this means that the main dlg has been yanked away, so reset owner, because owner is GONE
				m_pOwner = NULL;
			}
        }
	}
};



//***************************************************************************
//
//***************************************************************************
class CInstanceListDlg : public CQueryResultDlg
{
protected:
    BSTR m_strClass;

    BOOL CanAdd()		{ return !m_bReadOnly && m_lQryFlags & WBEM_FLAG_SHALLOW; }
    IWbemClassObject* AddNewElement();

public:
    CInstanceListDlg(HWND hParent, LONG lGenFlags, LONG lQryFlags, LPWSTR wszClass,
                     LONG lSync, BOOL bReadOnly, LONG lTimeout, ULONG nBatch)
        : CQueryResultDlg(hParent, lGenFlags, lQryFlags), m_strClass(SysAllocString(wszClass))
    {
        SetReadOnly(bReadOnly);
        // Pass on invocation method (sync, async..) related settings for use in this
        // enumeration and by any further operations (editing/deleting/etc. of an instance).
        SetCallMethod(lSync);
        SetTimeout(lTimeout);
        SetBatchCount(nBatch);
    }
    ~CInstanceListDlg()
    {
        SysFreeString(m_strClass);
    }
    BOOL Initialize();
};

BOOL CInstanceListDlg::Initialize()
{
    char szTitle[1024];
    char szFormat[1024];
    LoadString(GetModuleHandle(NULL), IDS_INSTANCES_OF, szFormat, 1024);
    sprintf(szTitle, szFormat, m_strClass);

    if(m_lQryFlags & WBEM_FLAG_DEEP)
    {
        LoadString(GetModuleHandle(NULL), IDS_RECURSIVE_PARENS, szFormat, 1024);
        strcat(szTitle, szFormat);
    }

    SetTitle(szTitle);

    // Asynchronous
    if(m_lSync & ASYNC)
    {
        CNotSink* pHandler = new CNotSink(this);        // contructor starts ref count at 1
        SetNotify(pHandler);

        HRESULT hres;
        {
            CHourGlass hg;
            hres = g_pNamespace->CreateInstanceEnumAsync(m_strClass,
                         m_lGenFlags | m_lQryFlags | WBEM_FLAG_SEND_STATUS,
                         g_Context, GetWrapper());
        }
        pHandler->Release();

        if (FAILED(hres))
        {
            FormatError(hres, m_hParent);
            return FALSE;
        }
    }

    // Semisynchronous
    else if (m_lSync & SEMISYNC)
    {
        IEnumWbemClassObject* pEnum = NULL;
        HRESULT hres;
        {
            CHourGlass hg;
            hres = g_pNamespace->CreateInstanceEnum(m_strClass,
                        m_lGenFlags | m_lQryFlags | WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                        g_Context, &pEnum);
        }

        if (FAILED(hres))
        {
            FormatError(hres, m_hParent);
            return FALSE;
        }

        // Create sink for use in NextAsync calls.
        if (m_lSync & USE_NEXTASYNC)
        {
            CNotSink* pHandler = new CNotSink(this);        // contructor starts ref count at 1
            SetNotify(pHandler);
            pHandler->Release();
        }

        SetInterfaceSecurityEx(pEnum, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
        SetEnum(pEnum);
        pEnum->Release();
    }

    // Synchronous
    else
    {
        IEnumWbemClassObject* pEnum = NULL;
        HRESULT hres;
        {
            CHourGlass hg;
            hres = g_pNamespace->CreateInstanceEnum(m_strClass,
                        m_lGenFlags | m_lQryFlags | WBEM_FLAG_FORWARD_ONLY,
                        g_Context, &pEnum);
        }

        if (FAILED(hres))
        {
            FormatError(hres, m_hParent);
            return FALSE;
        }

        SetInterfaceSecurityEx(pEnum, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
        SetEnum(pEnum,hres);
        pEnum->Release();
    }

    return TRUE;
}

IWbemClassObject* CInstanceListDlg::AddNewElement()
{
    IWbemClassObject* pClass = 0;
    if(!_GetObject(m_hDlg, m_lGenFlags, m_strClass, m_lSync, pClass, m_lTimeout))
        return NULL;

    // Get a clean instance of the class.
    // ==================================

    IWbemClassObject* pInst = 0;
    HRESULT hres = pClass->SpawnInstance(0, &pInst);
    pClass->Release();
    if (FAILED(hres))
    {
        FormatError(hres, m_hDlg);
        return NULL;
    }

    CObjectEditor ed(m_hDlg, m_lGenFlags, CObjectEditor::readwrite, m_lSync, pInst,
                     m_lTimeout, m_nBatch);
    if (ed.Edit() == IDCANCEL)
    {
        pInst->Release();
        return NULL;
    }

    if(_PutInstance(m_hDlg, m_lGenFlags, WBEM_FLAG_CREATE_ONLY, m_lSync, pInst, m_lTimeout))
        return pInst;
    else
    {
        pInst->Release();
        return NULL;
    }
}


void ShowInstances(HWND hDlg, LONG lGenFlags, LONG lQryFlags, LPWSTR wszClass, LONG lSync,
                   CRefCountable* pOwner, LONG lTimeout, ULONG nBatch)
{
    CInstanceListDlg* pDlg = new CInstanceListDlg(hDlg, lGenFlags, lQryFlags, wszClass, lSync,
                                                  FALSE, lTimeout, nBatch);
    pDlg->RunDetached(pOwner);
}

void CMainDlg::GetInstances()
{
    wchar_t ClassName[2560];
    *ClassName = 0;
    LONG lQryFlags = 0;
    INT_PTR nRes = GetClassInfo(m_hDlg, ClassName, 2560, &lQryFlags);
    if ((nRes == IDCANCEL) || (nRes == 0))
        return;

    CInstanceListDlg* pDlg = new CInstanceListDlg(m_hDlg, m_lGenFlags, lQryFlags, ClassName, m_lSync,
                                                  FALSE, Timeout(), BatchCount());
    pDlg->RunDetached(this);
}

//********************************************************************
class CClassListDlg : public CQueryResultDlg
{
protected:
    BSTR m_strParentClass;

    BOOL CanAdd()		{ return !m_bReadOnly; /* && m_lQryFlags & WBEM_FLAG_SHALLOW; */ }
    IWbemClassObject* AddNewElement();

public:
    CClassListDlg(HWND hParent, LONG lGenFlags, LONG lQryFlags, LPWSTR wszParentClass, LONG lSync,
                  BOOL bReadOnly, LONG lTimeout, ULONG nBatch)
        : CQueryResultDlg(hParent, lGenFlags, lQryFlags, TRUE, IDD_QUERY_RESULT_SORTED),
                m_strParentClass(SysAllocString(wszParentClass))
    {
        SetReadOnly(bReadOnly);
        // Pass on invocation method (sync, async..) related settings for use in this
        // enumeration and by any further operations (editing/deleting/etc. of an instance).
        SetCallMethod(lSync);
        SetTimeout(lTimeout);
        SetBatchCount(nBatch);
    }
    ~CClassListDlg()
    {
        SysFreeString(m_strParentClass);
    }
    BOOL Initialize();
};

BOOL CClassListDlg::Initialize()
{
    const TitleSize = 1000;
    char szTitle[TitleSize];
    char szFormat[1024];
    if (m_strParentClass == NULL || wcslen(m_strParentClass) == 0)
    {
        LoadString(GetModuleHandle(NULL), IDS_TOP_LEVEL_CLASSES, szTitle, TitleSize);
    }
    else
    {
        LoadString(GetModuleHandle(NULL), IDS_CHILD_CLASSES_OF, szFormat, 1024);
        sprintf(szTitle, szFormat, m_strParentClass);
    }
    szTitle[TitleSize-1] = '\0';

    if (m_lQryFlags & WBEM_FLAG_DEEP)
    {
        LoadString(GetModuleHandle(NULL), IDS_RECURSIVE_PARENS, szFormat, 1024);
        strncat(szTitle, szFormat, sizeof(szTitle) - strlen(szTitle) - 1);
    }

    SetTitle(szTitle);

    // Asynchronous
    if (m_lSync & ASYNC)
    {
        CHourGlass hg;
        CNotSink* pHandler = new CNotSink(this);
        SetNotify(pHandler);

        HRESULT hres = g_pNamespace->CreateClassEnumAsync(m_strParentClass,
                              m_lGenFlags | m_lQryFlags | WBEM_FLAG_SEND_STATUS,
                              g_Context, GetWrapper());

        if (FAILED(hres))
        {
            FormatError(hres, m_hParent);
            return FALSE;
        }
        pHandler->Release();
    }

    // Semisynchronous
    else if (m_lSync & SEMISYNC)
    {
        IEnumWbemClassObject* pEnum = NULL;
        HRESULT hres;
        {
            CHourGlass hg;
            hres = g_pNamespace->CreateClassEnum(m_strParentClass,
                         m_lGenFlags | m_lQryFlags  | WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                         g_Context, &pEnum);
        }

        if (FAILED(hres))
        {
            FormatError(hres, m_hParent);
            return FALSE;
        }

        // Create sink for use in NextAsync calls.
        if (m_lSync & USE_NEXTASYNC)
        {
            CNotSink* pHandler = new CNotSink(this);        // contructor starts ref count at 1
            SetNotify(pHandler);
            pHandler->Release();
        }

        SetInterfaceSecurityEx(pEnum, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
        SetEnum(pEnum);
        pEnum->Release();
    }

    // Synchronous
    else
    {
        IEnumWbemClassObject* pEnum = NULL;
        HRESULT hres;
        {
            CHourGlass hg;
            hres = g_pNamespace->CreateClassEnum(m_strParentClass,
                         m_lGenFlags | m_lQryFlags  | WBEM_FLAG_FORWARD_ONLY,
                         g_Context, &pEnum);
        }

        if (FAILED(hres))
        {
            FormatError(hres, m_hParent);
            return FALSE;
        }

        SetInterfaceSecurityEx(pEnum, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
        SetEnum(pEnum,hres);
        pEnum->Release();
    }

    return TRUE;
}

IWbemClassObject* CClassListDlg::AddNewElement()
{
    IWbemClassObject* pClass;
    if(_CreateClass(m_hDlg, m_lGenFlags, m_strParentClass, m_lSync, &pClass, m_lTimeout))
        return pClass;
    else
        return NULL;
}


void ShowClasses(HWND hDlg, LONG lGenFlags, LONG lQryFlags, LPWSTR wszParentClass, LONG lSync,
                 CRefCountable* pOwner, LONG lTimeout, ULONG nBatch)
{
    CClassListDlg* pDlg = new CClassListDlg(hDlg, lGenFlags, lQryFlags, wszParentClass,
                                            lSync, FALSE, lTimeout, nBatch);
    pDlg->RunDetached(pOwner);
}


void CMainDlg::GetClasses()
{
    wchar_t Superclass[2048];
    *Superclass = 0;
    LONG lQryFlags = 0;
    INT_PTR nRes = GetSuperclassInfo(m_hDlg, Superclass, 2048, &lQryFlags);
    if ((nRes == IDCANCEL) || (nRes == 0))
        return;

    CClassListDlg* pDlg = new CClassListDlg(m_hDlg, m_lGenFlags, lQryFlags, Superclass, m_lSync,
                                            FALSE, Timeout(), BatchCount());
    pDlg->RunDetached(this);
}

//***************************************************************************
//
//***************************************************************************
void CMainDlg::OpenNs()
{
    wchar_t ObjPath[2560];
    INT_PTR iRet = GetObjectPath(m_hDlg, ObjPath, 2560);
    if(iRet == IDCANCEL)
        return;

    if (wcslen(ObjPath) == 0)
    {
        MessageBox(IDS_NO_PATH, IDS_ERROR, MB_OK);
        return;
    }

    if (g_pNamespace == 0)
    {
        MessageBox(IDS_NO_INITIAL_CONNECTION, IDS_ERROR, MB_OK);
        return;
    }

    IWbemServices* pNewNs = NULL;
    CBString bsObjPath(ObjPath);

    HRESULT res;
    IWbemClassObject* pErrorObj = NULL;

    // Asynchronous
    if (m_lSync & ASYNC)
    {
        MessageBox(IDS_ASYNC_NOT_SUPPORTED, IDS_ERROR, MB_OK);
        return;
    }

    // Semisynchronous
    else if (m_lSync & SEMISYNC)
    {
        IWbemCallResult* pCallRes = NULL;
        CHourGlass hg;
        res = g_pNamespace->OpenNamespace(bsObjPath.GetString(),
                                m_lGenFlags | WBEM_FLAG_RETURN_IMMEDIATELY,
                                g_Context, NULL, &pCallRes);

        if (SUCCEEDED(res))
        {
            LONG lStatus;
            SetInterfaceSecurityEx(pCallRes, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
            while ((res = pCallRes->GetCallStatus(Timeout(), &lStatus)) == WBEM_S_TIMEDOUT)
            {
                // wait
            }
            if (res == WBEM_S_NO_ERROR)
            {
                res = (HRESULT)lStatus;     // lStatus is the final result of the above IWbemServices::OpenNamespace call
                if (res == WBEM_S_NO_ERROR)
                {
                    res = pCallRes->GetResultServices(0, &pNewNs);    // don't use timeout since object should be available
                }
            }

            pCallRes->Release();
        }
    }

    // Synchronous
    else
    {
        CHourGlass hg;
        res = g_pNamespace->OpenNamespace(bsObjPath.GetString(),
                                m_lGenFlags,
                                g_Context, &pNewNs, NULL);
    }

    if (FAILED(res))
    {
        FormatError(res, m_hDlg, pErrorObj);
        return;
    }

    g_pNamespace->Release();
    pNewNs->QueryInterface(IID_IWbemServices, (void **)&g_pNamespace);
    pNewNs->Release();
    SetInterfaceSecurityEx(g_pNamespace, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);

    wcscat(gNameSpace, L"\\");
    wcscat(gNameSpace, bsObjPath.GetString());
    SetDlgItemTextWC(m_hDlg, IDC_NAMESPACE, gNameSpace);

    SysFreeString(g_strNamespace);
    g_strNamespace = SysAllocString(gNameSpace);
}

void CMainDlg::CreateRefresher()
{
    CRefresherDlg* pDlg = new CRefresherDlg(m_hDlg, m_lGenFlags);
    pDlg->RunDetached(NULL);
}

void CMainDlg::EditContext()
{
    g_Context.Edit(m_hDlg);
}

//***************************************************************************
//
//***************************************************************************

void CenterOnScreen(HWND hDlg)
{
    HWND hScreen = GetDesktopWindow();

    RECT rScreen;
    GetClientRect(hScreen, &rScreen);

    RECT rDlg;
    GetWindowRect(hDlg, &rDlg);

    int nX = (rScreen.right - (rDlg.right - rDlg.left))/2;
    int nY = (rScreen.bottom - (rDlg.bottom - rDlg.top))/2;

    MoveWindow(hDlg, nX, nY, rDlg.right - rDlg.left,
        rDlg.bottom - rDlg.top, TRUE);
}


void CMainDlg::ConnectButtons(BOOL b)
{
    EnableWindow(GetDlgItem(IDC_CREATE_CLASS), b);
    EnableWindow(GetDlgItem(IDC_GET_CLASS), b);
    EnableWindow(GetDlgItem(IDC_GET_CLASSES), b);
    EnableWindow(GetDlgItem(IDC_EDIT_CLASS), b);
    EnableWindow(GetDlgItem(IDC_DELETE_CLASS), b);

    EnableWindow(GetDlgItem(IDC_CREATE_INSTANCE), b);
    EnableWindow(GetDlgItem(IDC_GET_INSTANCE), b);
    EnableWindow(GetDlgItem(IDC_GET_INSTANCES), b);
    EnableWindow(GetDlgItem(IDC_EDIT_INSTANCE), b);
    EnableWindow(GetDlgItem(IDC_DELETE_INSTANCE), b);

    EnableWindow(GetDlgItem(IDC_QUERY), b);

///	EnableWindow(GetDlgItem(IDC_ASYNC), TRUE);
///	EnableWindow(GetDlgItem(IDC_SYNC), TRUE);
///	EnableWindow(GetDlgItem(IDC_SEMISYNC), TRUE);
	EnableWindow(GetDlgItem(IDC_ASYNC), b);
	EnableWindow(GetDlgItem(IDC_SYNC), b);
	EnableWindow(GetDlgItem(IDC_SEMISYNC), b);
	EnableWindow(GetDlgItem(IDC_BATCH), b);
	EnableWindow(GetDlgItem(IDC_TIMEOUT), b);
	EnableWindow(GetDlgItem(IDC_BATCH), b && !(m_lSync & ASYNC));
	EnableWindow(GetDlgItem(IDC_TIMEOUT), b && m_lSync & SEMISYNC && !(m_lSync & USE_NEXTASYNC));
	EnableWindow(GetDlgItem(IDC_USE_NEXTASYNC), b && m_lSync & SEMISYNC);

    EnableWindow(GetDlgItem(IDC_USE_AMENDED), b);
    EnableWindow(GetDlgItem(IDC_DIRECT_READ), b);

    EnableWindow(GetDlgItem(IDC_REGISTER), b);
    EnableWindow(GetDlgItem(IDC_VIEW_REG), b);
    EnableWindow(GetDlgItem(IDC_EVENTS), b);
    EnableWindow(GetDlgItem(IDC_EXEC_METHOD), b);
    EnableWindow(GetDlgItem(IDC_OPEN_NS), b);

    EnableWindow(GetDlgItem(IDC_REFRESH), b);
    
	// IWbemServicesEx
#if 0
	RAID 167868
	bool ex=(b && g_pServicesEx!=NULL);
	EnableWindow(GetDlgItem(IDC_OPEN), ex);
	EnableWindow(GetDlgItem(IDC_ADDOBJECT), ex);
	EnableWindow(GetDlgItem(IDC_DELETEOBJECT), ex);
	EnableWindow(GetDlgItem(IDC_RENAMEOBJECT), ex);
	EnableWindow(GetDlgItem(IDC_GETOBJECTSECURITY), ex);
	EnableWindow(GetDlgItem(IDC_SETOBJECTSECURITY), ex);
#endif
}

//////////////////


//////////////////
CQueryResultDlg::CQueryResultDlg(HWND hParent, LONG lGenFlags, LONG lQryFlags, BOOL fCanDelete, int tID)
    : CWbemDialog(tID, hParent), m_pHandler(NULL), m_bReadOnly(FALSE), m_fDeletesAllowed(fCanDelete),
            m_pEnum(NULL), m_pWrapper(NULL), m_bComplete(FALSE),
            m_lGenFlags(lGenFlags), m_lQryFlags(lQryFlags),
            m_lTimeout(0), m_nBatch(1),
            m_partial_result(false)
{
    m_szTitle = 0;
    m_nReturnedMax = 0;

    if (tID == IDD_QUERY_RESULT_SORTED)
    {
        m_bSort = TRUE;
    }
    else
    {
        m_bSort = FALSE;
    }
}

void CQueryResultDlg::SetEnum(IEnumWbemClassObject* pEnum, HRESULT hres)
{
    set_partial (hres==WBEM_S_PARTIAL_RESULTS);
    m_pEnum = pEnum;
    if(m_pEnum)
        m_pEnum->AddRef();
    if(m_hDlg)
    {
        PostUserMessage(m_hDlg, 0, 0);      // starts processing of enumeration
    }
}

// This function is called once (via PostMessage) and will loop until the
// synchronous enumeration is complete.  It repeatedly requests batches of
// objects (without a timeout) and adds them to the list.
void CQueryResultDlg::ProcessEnum()
{
    ULONG uIdx;
    IWbemClassObject** aObjects = new IWbemClassObject*[m_nBatch];

    for (uIdx = 0; uIdx < m_nBatch; uIdx++)
    {
        aObjects[uIdx] = NULL;
    }

    ULONG uRet = 0;
    HRESULT hres;

    // Do not use the timeout since the synchronous enumeration was
    // started without WBEM_FLAG_RETURN_IMMEDIATELY.
    while (SUCCEEDED(hres = m_pEnum->Next(WBEM_NO_WAIT, m_nBatch, aObjects, &uRet)))
    {
        for (uIdx = 0; uIdx < uRet; uIdx++)
        {
            if (aObjects[uIdx])
            {
                IWbemClassObject* pObj = aObjects[uIdx];
                AddObject(pObj);
                pObj->Release();
                aObjects[uIdx] = NULL;
            }
        }
        if (uRet)
            SetNumBatchItems(uRet);

        if (hres == WBEM_S_FALSE)
        {
            InvalidateRect(GetDlgItem(IDC_OBJECT_LIST), NULL, FALSE);
            UpdateWindow(GetDlgItem(IDC_OBJECT_LIST));
            break;
        }
    }

    SetComplete(hres, NULL, NULL);
    m_pEnum->Release();
    m_pEnum = NULL;

    delete [] aObjects;
}

// This function is called repeatedly (via PostMessage) until the
// semisync enumeration is complete.  This function adds the objects
// to the list and requests another batch of objects with a timeout.
void CQueryResultDlg::ProcessEnumSemisync()
{
    ULONG uIdx;
    IWbemClassObject** aObjects = new IWbemClassObject*[m_nBatch];

    for (uIdx = 0; uIdx < m_nBatch; uIdx++)
    {
        aObjects[uIdx] = NULL;
    }

    ULONG uRet = 0;
    HRESULT hres = m_pEnum->Next(m_lTimeout, m_nBatch, aObjects, &uRet);
    if (SUCCEEDED(hres))
    {
        for (uIdx = 0; uIdx < uRet; uIdx++)
        {
            if (aObjects[uIdx])
            {
                IWbemClassObject* pObj = aObjects[uIdx];
                AddObject(pObj);
                pObj->Release();
                aObjects[uIdx] = NULL;
            }
        }

        if (uRet)
        {
            SetNumBatchItems(uRet);
            InvalidateRect(GetDlgItem(IDC_OBJECT_LIST), NULL, FALSE);
            UpdateWindow(GetDlgItem(IDC_OBJECT_LIST));
        }
    }

    if (hres == WBEM_S_NO_ERROR || hres == WBEM_S_TIMEDOUT)
    {
        PostUserMessage(m_hDlg, 0, 0);      // continues processing of enumeration
    }
    else
    {
        // Stop if an error or if WBEM_S_FALSE is returned.
        // WBEM_S_FALSE indicates that the enumeration is complete.
        SetComplete(hres, NULL, NULL);
        m_pEnum->Release();
        m_pEnum = NULL;
    }

    delete [] aObjects;
}

// This function is called repeatedly (via PostMessage) until the semisync
// enumeration using NextAsync is complete.  This function simply requests
// another (or the first) batch of objects using the same sink.
void CQueryResultDlg::SemisyncNextAsync()
{
    if (m_pEnum)
    {
        HRESULT hres = m_pEnum->NextAsync(m_nBatch, m_pHandler);

        // If WBEM_S_FALSE or error then we are done with the enumerator.
        // For NextAsync, SetStatus is called after every Indicate so that
        // we must call SetComplete here.
        if (hres != WBEM_S_NO_ERROR)
        {
            SetComplete(hres, NULL, NULL);
            m_pEnum->Release();
            m_pEnum = NULL;
        }
    }
}

void CQueryResultDlg::SetNotify(CNotSink* pNotify)
{
    m_pHandler = pNotify;
    if (m_pHandler)
        m_pHandler->AddRef();

    CUnsecWrap Wrap(m_pHandler);
    m_pWrapper = (IWbemObjectSink*)Wrap;
    if(m_pWrapper)
        m_pWrapper->AddRef();
}

CQueryResultDlg::~CQueryResultDlg()
{
    if (m_szTitle)
        delete [] m_szTitle;

    if(m_pHandler)
    {
        m_pHandler->ResetViewer();

        if(!m_bComplete)
        {
            CHourGlass hg;
            g_pNamespace->CancelAsyncCall(m_pWrapper);
        }
        m_pHandler->Release();
    }

    if(m_pWrapper)
        m_pWrapper->Release();
    if(m_pEnum)
        m_pEnum->Release();

    for(int i = 0; i < m_InternalArray.Size(); i++)
    {
        // Check the pointer
        if ( NULL != m_InternalArray[i] )
        {
            ((IWbemClassObject*)m_InternalArray[i])->Release();
        }
    }
}

void CQueryResultDlg::SetTitle(char* szTitle)
{
    m_szTitle = new char[strlen(szTitle)+2];
    strcpy(m_szTitle, szTitle);
    unsigned char* pc = (unsigned char*)m_szTitle;
    while(*pc)
    {
        if(*pc < 32) *pc = 32;
        pc = _mbsinc(pc);
    }

    if(m_hDlg)
    {
        SetDlgItemText(IDC_REQUEST, m_szTitle);
    }
}

void CQueryResultDlg::PostObject(IWbemClassObject* pObject)
{
    if(m_hDlg)
    {
        pObject->AddRef();
        PostUserMessage(m_hDlg, 1, LPARAM(pObject));
    }
    else
    {
        AddObject(pObject);
    }
}

void CQueryResultDlg::AddObject(IWbemClassObject* pObject)
{
    HWND hList = GetDlgItem(IDC_OBJECT_LIST);

    if(pObject == NULL)
        return;
    pObject->AddRef();
    m_InternalArray.Add(pObject);

    WString wsText;
    MakeListEntry(pObject, wsText);
    long len = wsText.Length()*2+20;
    char* szTemp = new char[len];
    wcstombs(szTemp, LPWSTR(wsText), len);
    SendMessage(hList, LB_ADDSTRING, 0, LPARAM(szTemp));
    delete [] szTemp;
    SetNumItems(SendMessage(hList, LB_GETCOUNT, 0, 0));
}

void CQueryResultDlg::MakeListEntry(IWbemClassObject* pObj, WString& ListEntry)
{
    ListEntry = L"";
	HRESULT hres;
    if ( NULL != pObj )
    {
        VARIANT v;
        VariantInit(&v);
        pObj->Get(L"__GENUS", 0, &v, NULL, NULL);

        if (V_I4(&v) == 1)
        {
            // Class def.
            VariantClear(&v);

            hres = pObj->Get(L"__CLASS", 0, &v, NULL, NULL);
			if(SUCCEEDED(hres))
				ListEntry += V_BSTR(&v);
			else
				ListEntry += L"Unknown class";
            VariantClear(&v);

            ListEntry += L"\t(";

            hres = pObj->Get(L"__SUPERCLASS", 0, &v, NULL, NULL);
            if (SUCCEEDED(hres) && V_VT(&v) == VT_BSTR)
                ListEntry += V_BSTR(&v);
            VariantClear(&v);

            ListEntry += L')';
        }
        else
        {
            // Instance
            VariantClear(&v);

            hres = pObj->Get(L"__RELPATH", 0, &v, NULL, NULL);
            if(FAILED(hres) || V_VT(&v) == VT_NULL)
            {
                hres = pObj->Get(L"__CLASS", 0, &v, NULL, NULL);
                if(SUCCEEDED(hres))
					ListEntry += V_BSTR(&v);
                ListEntry += L"=<no key>";
            }
            else
            {
                ListEntry += V_BSTR(&v);
            }
            VariantClear(&v);
        }

    }   // IF NULL != pObj
    else
    {
        ListEntry = L"NULL Object";
    }

}

void CQueryResultDlg::PostCount(long nCount)
{
    if(m_hDlg)
    {
        PostUserMessage(m_hDlg, 3, LPARAM(nCount));
    }
}

void CQueryResultDlg::RefreshItem(int nItem)
{
    IWbemClassObject* pObj = (IWbemClassObject*)m_InternalArray.GetAt(nItem);
    WString wsListEntry;
    MakeListEntry(pObj, wsListEntry);

    // Convert to ANSI (Win95 requires this)
    char* szTemp = new char[wsListEntry.Length()*2+10];
    wcstombs(szTemp, LPWSTR(wsListEntry), wsListEntry.Length()+1);
    szTemp[wsListEntry.Length()] = '\0';
    SendMessage(GetDlgItem(IDC_OBJECT_LIST), LB_DELETESTRING, nItem, 0);
    SendMessage(GetDlgItem(IDC_OBJECT_LIST), LB_INSERTSTRING, nItem,
        LPARAM(szTemp));
    delete [] szTemp;
}

void CQueryResultDlg::RunDetached(CRefCountable* pOwner)
{
    SetDeleteOnClose();
    SetOwner(pOwner);
    Create(FALSE);
    if(!Initialize())
    {
        PostMessage(m_hDlg, WM_CLOSE, 0, 0);
    }
}

void CQueryResultDlg::PostComplete(long lParam, BSTR strParam,
                                    IWbemClassObject* pObjParam)
{
    if(m_hDlg)
    {
        if (m_lSync & SEMISYNC)
        {
            // For semisync using NextAsync, SetStatus indicates the batch is
            // complete so we continue with the sink and another NextAsync call.
            PostUserMessage(m_hDlg, 0, 0);
        }
        else
        {
            // For async, the final SetStatus has been called so we are done
            // with the sink.
            CStatus* pStatus = new CStatus(lParam, strParam, pObjParam);
            PostUserMessage(m_hDlg, 2, (LPARAM)pStatus);
        }
    }
    else
    {
        SetComplete(lParam, strParam, pObjParam);
    }
}

void CQueryResultDlg::SetComplete(HRESULT hres, BSTR strParam,
                                  IWbemClassObject* pErrorObj)
{
    if(m_bComplete)
        return;
    set_partial(hres==WBEM_S_PARTIAL_RESULTS);
    m_bComplete = TRUE;

    if(FAILED(hres))
    {
        FormatError(hres, m_hDlg, pErrorObj);
        PostMessage(m_hDlg, WM_CLOSE, 0, 0);
        return;
    }

    if(m_pHandler)
    {
        m_pHandler->Release();
        m_pHandler = NULL;
    }
    if(m_hDlg)
    {
        char szBuffer[1024]="";
        LoadString(GetModuleHandle(NULL), m_partial_result==true?IDS_PARTIALRESULTS:IDS_DONE, szBuffer, 1024);
        SetDlgItemText(IDC_STATUS, szBuffer);
        EnableWindow(GetDlgItem(IDC_DELETE), CanDelete());
        EnableWindow(GetDlgItem(IDC_ADD), CanAdd());
        if (m_bSort)
        {
            qsort((void*)m_InternalArray.GetArrayPtr(), m_InternalArray.Size(), sizeof(void*), CmpFunc);
        }
    }
}

BOOL CQueryResultDlg::OnInitDialog()
{
    CenterOnParent();
    static LONG Tabs[] = { 80, 120, 170 };
    int TabCount = 3;

    SendMessage(GetDlgItem(IDC_OBJECT_LIST), LB_SETTABSTOPS,
        (WPARAM) TabCount, (LPARAM) Tabs);
    SendMessage(GetDlgItem(IDC_OBJECT_LIST), LB_SETHORIZONTALEXTENT,
        10000, 0);

    IWbemClassObject *pObj;
    HWND hList = GetDlgItem(IDC_OBJECT_LIST);
    WString wsListEntry;

    SetDlgItemText(IDC_REQUEST, m_szTitle);
    if(m_bComplete)
    {
        char szBuffer[1024];
        LoadString(GetModuleHandle(NULL), IDS_DONE, szBuffer, 1024);
        SetDlgItemText(IDC_STATUS, szBuffer);
    }
    else
    {
        char szBuffer[1024];
        LoadString(GetModuleHandle(NULL), IDS_IN_PROGRESS, szBuffer, 1024);
        SetDlgItemText(IDC_STATUS, szBuffer);
    }

    EnableWindow(GetDlgItem(IDC_ADD), CanAdd());
    EnableWindow(GetDlgItem(IDC_DELETE), CanDelete());
    for(int i = 0; i < m_InternalArray.Size(); i++)
    {
        pObj = (IWbemClassObject*)m_InternalArray.GetAt(i);
        MakeListEntry(pObj, wsListEntry);

        // Convert to ANSI (Win95 requires this)
        char* szTemp = new char[wsListEntry.Length()*2+10];
        wcstombs(szTemp, LPWSTR(wsListEntry), wsListEntry.Length()+1);
        SendMessage(hList, LB_ADDSTRING, 0, LPARAM(szTemp));
        delete [] szTemp;
    }

    if(m_pEnum)
    {
        PostUserMessage(m_hDlg, 0, 0);
    }

    SetNumItems(m_InternalArray.Size());

    if(m_bReadOnly)
    {
        EnableWindow(GetDlgItem(IDC_DELETE), FALSE);
        EnableWindow(GetDlgItem(IDC_ADD), FALSE);
    }

    return TRUE;
}

// Total number of items
void CQueryResultDlg::SetNumItems(LRESULT nNum)
{
    char szBuffer[512];
    char szFormat[500];
    LoadString(GetModuleHandle(NULL), IDS_NUM_OBJECTS_FORMAT, szFormat, 500);
    sprintf(szBuffer, szFormat, nNum);
    SetWindowText(GetDlgItem(IDC_NUM_OBJECTS), szBuffer);
}

// Number returned in most recent sink Indicate or enum Next.
void CQueryResultDlg::SetNumBatchItems(ULONG nNum)
{
    // Show only maximum returned batch size.
    if (nNum > m_nReturnedMax)
    {
        char szBuffer[512];
        char szFormat[500];
        LoadString(GetModuleHandle(NULL), IDS_NUM_BATCH_FORMAT, szFormat, 500);
        sprintf(szBuffer, szFormat, nNum);
        SetWindowText(GetDlgItem(IDC_NUM_BATCH), szBuffer);
        m_nReturnedMax = nNum;
    }
}

BOOL CQueryResultDlg::ViewListElement(LRESULT nSel)
{
    IWbemClassObject *pObj = 0;

    pObj = (IWbemClassObject*)m_InternalArray.GetAt((DWORD)nSel);

    if ( NULL != pObj )
    {
        CObjectEditor* ped = new CObjectEditor(m_hDlg, m_lGenFlags,
                m_bReadOnly ? CObjectEditor::readonly : CObjectEditor::readwrite,
                m_lSync, pObj, m_lTimeout, m_nBatch);
        ped->RunDetached(m_pOwner);
    }

    return TRUE;
}

BOOL CQueryResultDlg::OnDoubleClick(int nID)
{
    if(nID != IDC_OBJECT_LIST) return FALSE;
    HWND hList = GetDlgItem(IDC_OBJECT_LIST);

    LRESULT nSel = SendMessage(hList, LB_GETCURSEL, 0, 0);

    if (nSel == LB_ERR)
        return TRUE;

    ViewListElement(nSel);
    SendMessage(hList, LB_SETCURSEL, nSel, 0);
    return TRUE;
}

BOOL CQueryResultDlg::OnUser(WPARAM wParam, LPARAM lParam)
{
    if(wParam == 0)
    {
        if (m_lSync & SEMISYNC)
        {
            if (m_lSync & USE_NEXTASYNC)
                SemisyncNextAsync();
            else
                ProcessEnumSemisync();
        }
        else    // synchronous
        {
            ProcessEnum();
        }
        return TRUE;
    }
    else if(wParam == 1)
    {
        IWbemClassObject* pObj = (IWbemClassObject*)lParam;
        AddObject(pObj);
        pObj->Release();
        return TRUE;
    }
    else if(wParam == 2)
    {
        CStatus* pStatus = (CStatus*)lParam;
        SetComplete(pStatus->m_hres, pStatus->m_str, pStatus->m_pObj);
        delete pStatus;
        return TRUE;
    }
    else if(wParam == 3)
    {
        SetNumBatchItems(ULONG(lParam));
        return TRUE;
    }
    else return FALSE;
}

BOOL CQueryResultDlg::OnCommand(WORD wCode, WORD nID)
{
    if(wCode == 0xFFFF && nID == 0xFFFF)
    {
        if (m_lSync & SEMISYNC)
        {
            if (m_lSync & USE_NEXTASYNC)
                SemisyncNextAsync();
            else
                ProcessEnumSemisync();
        }
        else    // synchronous
        {
            ProcessEnum();
        }
        return TRUE;
    }
    else if(nID == IDC_DELETE)
    {
        OnDelete();
        return TRUE;
    }
    else if(nID == IDC_ADD)
    {
        OnAdd();
        return TRUE;
    }
    else if(nID == IDC_COPY_SEL)
    {
        OnCopy();
        return TRUE;
    }

    return FALSE;
}

void CQueryResultDlg::OnDelete()
{
    HWND hList = GetDlgItem(IDC_OBJECT_LIST);
    LRESULT nSel = SendMessage(hList, LB_GETCURSEL, 0, 0);
    if (nSel == LB_ERR)
        return;

    if(DeleteListElement(nSel))
    {
        SendMessage(hList, LB_DELETESTRING, nSel, 0);

        SetNumItems(SendMessage(hList, LB_GETCOUNT, 0, 0));

        IWbemClassObject* pObj = (IWbemClassObject*)m_InternalArray.GetAt((DWORD)nSel);
        m_InternalArray.RemoveAt((DWORD)nSel);

        // Verify the pointer
        if ( NULL != pObj )
        {
            pObj->Release();
        }
    }
}


BOOL CQueryResultDlg::DeleteListElement(LRESULT nSel)
{
    HWND hList = GetDlgItem(IDC_OBJECT_LIST);

    IWbemClassObject *pObj = 0;

    pObj = (IWbemClassObject*)m_InternalArray.GetAt((DWORD)nSel);

    VARIANT vPath;
    VariantInit(&vPath);
    pObj->Get(L"__RELPATH", 0, &vPath, NULL, NULL);

    VARIANT vGenus;
    VariantInit(&vGenus);
    pObj->Get(L"__GENUS", 0, &vGenus, NULL, NULL);

    HRESULT hres;
    if(V_I4(&vGenus) == WBEM_GENUS_CLASS)
    {
        CHourGlass hg;
        hres = g_pNamespace->DeleteClass(V_BSTR(&vPath), m_lGenFlags, g_Context, NULL);
    }
    else
    {
        CHourGlass hg;
        hres = g_pNamespace->DeleteInstance(V_BSTR(&vPath), m_lGenFlags, g_Context, NULL);
    }

    if(FAILED(hres))
    {
        FormatError(hres, m_hDlg);
        return FALSE;
    }

    return TRUE;
}

void CQueryResultDlg::OnAdd()
{
    HWND hList = GetDlgItem(IDC_OBJECT_LIST);
    IWbemClassObject* pNewObj;

    pNewObj = AddNewElement();
    if(pNewObj)
    {
        // Search for the object with the same PATH
        // ========================================

        VARIANT vNewPath;
        HRESULT hres = pNewObj->Get(L"__RELPATH", 0, &vNewPath, NULL, NULL);
        if(SUCCEEDED(hres) && V_VT(&vNewPath) == VT_BSTR)
        {
            for(int i = 0; i < m_InternalArray.Size(); i++)
            {
                IWbemClassObject* pThis = (IWbemClassObject*)m_InternalArray[i];

                // Check for a NULL pointer
                if ( NULL != pThis )
                {
                    VARIANT vThisPath;
                    hres = pThis->Get(L"__RELPATH", 0, &vThisPath, NULL, NULL);
                    if(SUCCEEDED(hres) && V_VT(&vThisPath) == VT_BSTR &&
                        !_wcsicmp(V_BSTR(&vThisPath), V_BSTR(&vNewPath)))
                    {
                        // Found a duplicate
                        // =================

                        pThis->Release();
                        m_InternalArray.SetAt(i, pNewObj);
                        RefreshItem(i);
                        return;
                    }

                }
            }
        }

        AddObject(pNewObj);
        pNewObj->Release();

        if (m_bSort)
        {
            qsort((void*)m_InternalArray.GetArrayPtr(), m_InternalArray.Size(), sizeof(void*), CmpFunc);
        }
    }
}

// TODO: WM_COPY doesn't work for listbox so we need to code
// OpenClipboard & SetClipboardData.  Also need way to copy all
// items to clipboard.  Buttons changed to invisible for now.
void CQueryResultDlg::OnCopy()
{
    HWND hList = GetDlgItem(IDC_OBJECT_LIST);
    SendMessage(hList, WM_COPY, 0, 0);
}

IWbemClassObject* CQueryResultDlg::AddNewElement()
{
    return NULL;
}


////////////////////////////

char *CQueryDlg::m_szLastQueryType = NULL;
char *CQueryDlg::m_szLastQuery = NULL;

BOOL CQueryDlg::OnInitDialog()
{
    AddStringToCombo(IDC_QUERY_TYPE, "WQL");

    // Initialize Query Type

    if(NULL == m_szLastQueryType)
    {
        m_szLastQueryType = new char[8];
        strcpy(m_szLastQueryType, "WQL");
    }

    // Initialize Query String

    if (NULL == m_szLastQuery)
    {
        m_szLastQuery = new char[1];
        *m_szLastQuery = 0;
    }

    LRESULT uRes = SendMessage(GetDlgItem(IDC_QUERY_TYPE), CB_SELECTSTRING,
                    WPARAM(-1), LPARAM(m_szLastQueryType));

    SetDlgItemText(IDC_QUERY_STRING, m_szLastQuery);
    SendMessage(GetDlgItem(IDC_QUERY_STRING), EM_SETSEL, 0, -1);
    EnableWindow(GetDlgItem(IDC_PROTOTYPE), NULL != m_plQryFlags);

    return TRUE;
}

BOOL CQueryDlg::Verify()
{
    UINT uRes = 0;
    UINT uStringSize = 0;

    // Query String Processing

    if (*m_pwszQueryString)
        delete [] *m_pwszQueryString;

    // Determine the required size of the buffer
    uRes = GetDlgItemTextX(IDC_QUERY_STRING, *m_pwszQueryString, uStringSize);
    if(0 == uRes)
    {
        MessageBox(IDS_MUST_SPECIFY_QUERY, IDS_ERROR,
            MB_OK | MB_ICONHAND);
        return FALSE;
    }

    // Create the buffer
    uStringSize = uRes + 10;
    *m_pwszQueryString = new wchar_t[uStringSize];

    // Fetch the text
    uRes = GetDlgItemTextX(IDC_QUERY_STRING, *m_pwszQueryString, uStringSize);
    if(wcslen(*m_pwszQueryString) == 0)
    {
        MessageBox(IDS_MUST_SPECIFY_QUERY, IDS_ERROR,
            MB_OK | MB_ICONHAND);
        return FALSE;
    }

    // Set up last query member
    if (m_szLastQuery)
        delete [] m_szLastQuery;
    m_szLastQuery = new char[uStringSize];
    wcstombs(m_szLastQuery, *m_pwszQueryString, uStringSize);
    m_szLastQuery[uStringSize - 1] = '\0';

    // Query Type Processing

    if (*m_pwszQueryType)
        delete [] *m_pwszQueryType;
    uStringSize = 0;

    // Determine the required size of the buffer
    uRes = GetDlgItemTextX(IDC_QUERY_TYPE, *m_pwszQueryType, uStringSize);
    if(0 == uRes)
    {
        MessageBox(IDS_MUST_SPECIFY_QUERY_LANGUAGE, IDS_ERROR,
            MB_OK | MB_ICONHAND);
        return FALSE;
    }

    // Create the buffer
    uStringSize = uRes + 10;
    *m_pwszQueryType = new wchar_t[uStringSize];

    // Fetch the text
    uRes = GetDlgItemTextX(IDC_QUERY_TYPE, *m_pwszQueryType, uStringSize);
    if(wcslen(*m_pwszQueryType) == 0)
    {
        MessageBox(IDS_MUST_SPECIFY_QUERY_LANGUAGE, IDS_ERROR,
            MB_OK | MB_ICONHAND);
        return FALSE;
    }

    // Set up last query type
    if (m_szLastQueryType)
        delete [] m_szLastQueryType;
    m_szLastQueryType = new char[uStringSize];
    wcstombs(m_szLastQueryType, *m_pwszQueryType, uStringSize);
    m_szLastQueryType[uStringSize - 1] = '\0';

    if(m_plQryFlags)
    {
        if(GetCheck(IDC_PROTOTYPE) == BST_CHECKED)
            *m_plQryFlags |= WBEM_FLAG_PROTOTYPE;
        else
            *m_plQryFlags &= ~WBEM_FLAG_PROTOTYPE;
    }

    return TRUE;
}

// ****************************************************************************

BOOL _ExecQuery(HWND hDlg, LONG lGenFlags, LONG lQryFlags, LPWSTR wszQuery, LPWSTR wszLanguage,
                LONG lSync, CQueryResultDlg* pRes, char* pWindowTitle, LONG lTimeout, ULONG nBatch)
{
    CBString bsQueryType(wszLanguage);
    CBString bsQueryStr(wszQuery);

    if(pWindowTitle)
        pRes->SetTitle(pWindowTitle);

    HRESULT hres;

    // Asynchronous
    if(lSync & ASYNC)
    {
        CNotSink* pHandler = new CNotSink(pRes);        // constructor starts ref count at 1
        pRes->SetNotify(pHandler);

        {
            CHourGlass hg;
            hres = g_pNamespace->ExecQueryAsync(bsQueryType.GetString(), bsQueryStr.GetString(),
                        lGenFlags | lQryFlags | WBEM_FLAG_SEND_STATUS,
                        g_Context, pRes->GetWrapper());
        }
        pHandler->Release();

        if (FAILED(hres))
        {
            FormatError(hres, hDlg);
            return FALSE;
        }
    }

    // Semisynchronous
    else if (lSync & SEMISYNC)
    {
        IEnumWbemClassObject* pEnum = NULL;

        {
            CHourGlass hg;
            hres = g_pNamespace->ExecQuery(bsQueryType.GetString(), bsQueryStr.GetString(),
                       lGenFlags | lQryFlags | WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                       g_Context, &pEnum);
        }

        if (FAILED(hres))
        {
            FormatError(hres, hDlg);
            return FALSE;
        }

        // Create sink for use in NextAsync calls.
        if (lSync & USE_NEXTASYNC)
        {
            CNotSink* pHandler = new CNotSink(pRes);        // contructor starts ref count at 1
            pRes->SetNotify(pHandler);
            pHandler->Release();
        }

        SetInterfaceSecurityEx(pEnum, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
        pRes->SetEnum(pEnum);
        pEnum->Release();
    }

    // Synchronous
    else
    {
        IEnumWbemClassObject* pEnum = NULL;
        {
            CHourGlass hg;
            hres = g_pNamespace->ExecQuery(bsQueryType.GetString(), bsQueryStr.GetString(),
                       lGenFlags | lQryFlags  | WBEM_FLAG_FORWARD_ONLY,
                       g_Context, &pEnum);
        }
        if (FAILED(hres))
        {
            FormatError(hres, hDlg);
            return FALSE;
        }

        SetInterfaceSecurityEx(pEnum, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
        pRes->SetEnum(pEnum,hres);
        pEnum->Release();
    }

    return TRUE;
}

void CMainDlg::ExecQuery()
{
    wchar_t *pQueryStr = 0;
    wchar_t *pQueryType = 0;
    LONG lQryFlags = 0;

    CQueryDlg QD(m_hDlg, &lQryFlags, &pQueryStr, &pQueryType);
    INT_PTR nRes = QD.Run();

    if ((nRes == IDCANCEL) || (nRes == 0) || (!pQueryStr) || (!pQueryType))
        return;

    // If here, we are ready to execute the query.
    // ===========================================

    CQueryResultDlg* pResDlg = new CQueryResultDlg(m_hDlg, m_lGenFlags, lQryFlags);
    // Pass on invocation method (sync, async..) and related settings for this
    // query and by any further operations (editing/deleting/etc. of an instance).
    pResDlg->SetCallMethod(m_lSync);
    pResDlg->SetTimeout(Timeout());
    pResDlg->SetBatchCount(BatchCount());

    wchar_t szDest[512];
	szDest[511] = L'\0';
    char szTitle[1000];
    sprintf(szTitle, "%S: %S", pQueryType, wcsncpy(szDest, pQueryStr, 511));

    if (_ExecQuery(m_hDlg, m_lGenFlags, lQryFlags, pQueryStr, pQueryType, m_lSync,
                  pResDlg, szTitle, Timeout(), BatchCount()))
    {
        pResDlg->RunDetached(this);
    }
    else
    {
        delete pResDlg;
    }

    delete [] pQueryStr;
    delete [] pQueryType;
}

// ****************************************************************************

BOOL _ExecNotificationQuery(HWND hDlg, LONG lGenFlags, LONG lQryFlags, LPWSTR wszQuery,
                            LPWSTR wszLanguage, LONG lSync, CQueryResultDlg* pRes,
                            char* pWindowTitle, LONG lTimeout, ULONG nBatch)
{
    CBString bsQueryType(wszLanguage);
    CBString bsQueryStr(wszQuery);

    if(pWindowTitle)
        pRes->SetTitle(pWindowTitle);

    HRESULT hres;

    // Asynchronous
    if(lSync & ASYNC)
    {
        CNotSink* pHandler = new CNotSink(pRes);        // constructor starts ref count at 1
        pRes->SetNotify(pHandler);

        {
            CHourGlass hg;
            hres = g_pNamespace->ExecNotificationQueryAsync(bsQueryType.GetString(),
                        bsQueryStr.GetString(),
                        lGenFlags | lQryFlags,
                        g_Context, pRes->GetWrapper());
        }
        pHandler->Release();

        if (FAILED(hres))
        {
            FormatError(hres, hDlg);
            return FALSE;
        }
    }

    // Semisynchronous
    else if (lSync & SEMISYNC)
    {
        IEnumWbemClassObject* pEnum = NULL;

		{
            CHourGlass hg;
            hres = g_pNamespace->ExecNotificationQuery(bsQueryType.GetString(), bsQueryStr.GetString(),
                       lGenFlags | lQryFlags | WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                       g_Context, &pEnum);
        }

        if (FAILED(hres))
        {
            FormatError(hres, hDlg);
            return FALSE;
        }

        // Create sink for use in NextAsync calls.
        if (lSync & USE_NEXTASYNC)
        {
            CNotSink* pHandler = new CNotSink(pRes);        // contructor starts ref count at 1
            pRes->SetNotify(pHandler);
            pHandler->Release();
        }

        SetInterfaceSecurityEx(pEnum, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
        pRes->SetEnum(pEnum);
        pEnum->Release();
    }

    // Synchronous
    else
    {
        // Note, this call should fail with WBEM_E_INVALID_PARAMETER because synchronous invocation
        // isn't supported for ExecNotificationQuery due to the continuous nature of events.
        IEnumWbemClassObject* pEnum = NULL;
        {
            CHourGlass hg;
            hres = g_pNamespace->ExecNotificationQuery(bsQueryType.GetString(), bsQueryStr.GetString(),
                       lGenFlags | lQryFlags  | WBEM_FLAG_FORWARD_ONLY,
                       g_Context, &pEnum);
        }
        if (FAILED(hres))
        {
            FormatError(hres, hDlg);
            return FALSE;
        }

        SetInterfaceSecurityEx(pEnum, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
        pRes->SetEnum(pEnum,hres);
        pEnum->Release();
    }

    return TRUE;
}

void CMainDlg::ExecNotificationQuery()
{
    // Does not allow multiple semisync notification query dlg
    // ========================================================

	if ( m_fNotificationQueryResultDlg && SEMISYNC == m_lSync )
    {
        MessageBox(IDS_MULTIPLE_SEMISYNC_NOTIFICATION_QUERY_DLG_MSG, IDS_ERROR, MB_OK | MB_ICONHAND);
        return;
    }
    
    wchar_t *pQueryStr = 0;
    wchar_t *pQueryType = 0;
    LONG lQryFlags = 0;

    CQueryDlg QD(m_hDlg, &lQryFlags, &pQueryStr, &pQueryType);
    INT_PTR nRes = QD.Run();

    if ((nRes == IDCANCEL) || (nRes == 0) || (!pQueryStr) || (!pQueryType))
        return;

    // If here, we are ready to execute the query.
    // ===========================================

    CNotificationQueryResultDlg* pResDlg = new CNotificationQueryResultDlg(m_hDlg, m_lGenFlags, lQryFlags, m_lSync );
    // Pass on invocation method (sync, async..) and related settings for this
    // query and by any further operations (editing/deleting/etc. of an instance).

    pResDlg->SetCallMethod(m_lSync);
    pResDlg->SetTimeout(Timeout());
    pResDlg->SetBatchCount(BatchCount());

    wchar_t szDest[512];
	szDest[511] = L'\0';
    char szTitle[1000];
    sprintf(szTitle, "%S: %S", pQueryType, wcsncpy(szDest, pQueryStr, 511));

    if(lQryFlags & WBEM_FLAG_PROTOTYPE)
        lQryFlags = (lQryFlags & ~WBEM_FLAG_PROTOTYPE) | WBEM_FLAG_MONITOR;

    if (_ExecNotificationQuery(m_hDlg, m_lGenFlags, lQryFlags, pQueryStr, pQueryType,
                               m_lSync, pResDlg, szTitle, Timeout(), BatchCount()))
    {
        pResDlg->RunDetached(this);
    }
    else
    {
        delete pResDlg;
    }

    delete [] pQueryStr;
    delete [] pQueryType;
}

// ****************************************************************************

void CMainDlg::ExecMethod()
{
    CMethodDlg * pDlg = new CMethodDlg(m_hDlg, m_lGenFlags, m_lSync, Timeout());
    pDlg->RunDetached(this);
}



////////////////////////////////////////////////////////////////////////
//

class CSuperclassInfoDlg : public CWbemDialog
{
protected:
    LPWSTR m_wszSuperclass;
    long m_lMaxLen;
    LONG* m_plQryFlags;
    BOOL m_bIsInstance;
public:
    CSuperclassInfoDlg(HWND hParent, LPWSTR wszClass, long lMaxLen, LONG* plQryFlags)
        : m_wszSuperclass(wszClass), m_lMaxLen(lMaxLen), m_plQryFlags(plQryFlags),
            m_bIsInstance(FALSE), CWbemDialog(IDD_PARENTINFO, hParent)
    {}
    void SetIsInstance() {m_bIsInstance = TRUE;}

protected:
    BOOL OnInitDialog();
    BOOL Verify();
};

class CRenameDlg : public CWbemDialog
{
protected:
    LPWSTR m_wszOld;
    long m_lMaxOldLen;
    LPWSTR m_wszNew;
    long m_lMaxNewLen;
public:
    CRenameDlg(HWND hParent, LPWSTR wszOld, long lMaxOldLen, LPWSTR wszNew, long lMaxNewLen)
        : m_wszOld(wszOld), m_lMaxOldLen(lMaxOldLen), m_wszNew(wszNew), m_lMaxNewLen(lMaxNewLen),
            CWbemDialog(IDD_RENAMEDIALOG, hParent)
    {}

protected:
    BOOL OnInitDialog(){return TRUE;};
    BOOL Verify();
};
BOOL CRenameDlg::Verify()
{
    *m_wszOld = 0;
    GetDlgItemTextX(IDC_EDITOLD, m_wszOld, m_lMaxOldLen);
    *m_wszNew = 0;
    GetDlgItemTextX(IDC_EDITNEW, m_wszNew, m_lMaxNewLen);
    return TRUE;
}

BOOL CSuperclassInfoDlg::OnInitDialog()
{
    char szFormat[1024];
    SetCheck(IDC_IMMEDIATE_SUBCLASSES, BST_CHECKED);
    if(m_bIsInstance)
    {
        LoadString(GetModuleHandle(NULL), IDS_CLASS_INFO, szFormat, 1024);
        SetWindowText(m_hDlg, szFormat);
    }

    return TRUE;
}

BOOL CSuperclassInfoDlg::Verify()
{
    if (GetCheck(IDC_IMMEDIATE_SUBCLASSES) == BST_CHECKED)
        *m_plQryFlags = WBEM_FLAG_SHALLOW;
    else
        *m_plQryFlags = WBEM_FLAG_DEEP;

    *m_wszSuperclass = 0;
    GetDlgItemTextX(IDC_SUPERCLASS, m_wszSuperclass, m_lMaxLen);
    return TRUE;
}

BOOL CCreateInstanceDlg::OnInitDialog()
{
    char szFormat[1024];
    SetCheck(IDC_USE_CLASSOBJ, BST_CHECKED);
    return TRUE;
}

BOOL CCreateInstanceDlg::Verify()
{
    if (GetCheck(IDC_USE_CLASSOBJ) == BST_CHECKED)
        *m_plQryFlags = 1;
    else
        *m_plQryFlags = 0;

    *m_wszClass = 0;
    GetDlgItemTextX(IDC_SUPERCLASS, m_wszClass, m_lMaxLen);
    return TRUE;
}

INT_PTR GetSuperclassInfo(HWND hDlg, LPWSTR pClass, LONG lMaxBuf, LONG* plQryFlags)
{
    CSuperclassInfoDlg InfoDlg(hDlg, pClass, lMaxBuf, plQryFlags);
    return InfoDlg.Run();
}

INT_PTR GetClassInfo(HWND hDlg, LPWSTR pClass, LONG lMaxBuf, LONG* plQryFlags)
{
    CSuperclassInfoDlg InfoDlg(hDlg, pClass, lMaxBuf, plQryFlags);
    InfoDlg.SetIsInstance();
    return InfoDlg.Run();
}

class CContextValueDlg : public CWbemDialog
{
protected:
    BSTR* m_pstrName;
    VARIANT* m_pvValue;
    BOOL m_bNew;

public:
    CContextValueDlg(HWND hParent, BSTR* pstrName, VARIANT* pvValue, BOOL bNew)
        : CWbemDialog(IDD_CONTEXT_PROPERTY, hParent), m_pstrName(pstrName),
        m_pvValue(pvValue), m_bNew(bNew)
    {}

    BOOL OnInitDialog();
    BOOL Verify();

    void Refresh();
};

BOOL CContextValueDlg::OnInitDialog()
{
    // Populate the combo box with the valid prop types
    // ================================================

    AddStringToCombo(IDC_TYPE_LIST, "CIM_STRING");
    AddStringToCombo(IDC_TYPE_LIST, "CIM_UINT8");
    AddStringToCombo(IDC_TYPE_LIST, "CIM_SINT16");
    AddStringToCombo(IDC_TYPE_LIST, "CIM_SINT32");
    AddStringToCombo(IDC_TYPE_LIST, "CIM_REAL32");
    AddStringToCombo(IDC_TYPE_LIST, "CIM_REAL64");
    AddStringToCombo(IDC_TYPE_LIST, "CIM_BOOLEAN");
    AddStringToCombo(IDC_TYPE_LIST, "CIM_OBJECT");

    if(!m_bNew)
        EnableWindow(GetDlgItem(IDC_PROPNAME), FALSE);

    if(*m_pstrName)
    {
        SetDlgItemTextX(IDC_PROPNAME, *m_pstrName);
    }

    if(V_VT(m_pvValue) != VT_EMPTY)
    {
        LPSTR pTypeStr = TypeToString(V_VT(m_pvValue) & ~VT_ARRAY);
        SendMessage(GetDlgItem(IDC_TYPE_LIST), CB_SELECTSTRING, WPARAM(-1),
            LPARAM(pTypeStr));
        if(V_VT(m_pvValue) & VT_ARRAY)
            SetCheck(IDC_ARRAY, BST_CHECKED);

        CVar v;
        v.SetVariant(m_pvValue);
        LPSTR szValue = ValueToString(&v);
        SetDlgItemText(IDC_VALUE, szValue);
    }
    else
    {
        SendMessage(GetDlgItem(IDC_TYPE_LIST), CB_SELECTSTRING, WPARAM(-1),
            LPARAM("VT_NULL"));
    }

    return TRUE;
}

BOOL CContextValueDlg::Verify()
{
    WCHAR wszName[1024];
    GetDlgItemTextX(IDC_PROPNAME, wszName, 1024);
    if(*wszName == 0)
    {
        MessageBox(IDS_NO_PROPERTY_NAME, IDS_ERROR, MB_OK);
        return FALSE;
    }

    StripTrailingWs(wszName);

    LPSTR szType = GetCBCurSelString(IDC_TYPE_LIST);
    int nType = StringToType(szType);
    if(nType == VT_NULL)
    {
        MessageBox(IDS_INVALID_PROPERTY_TYPE, IDS_ERROR, MB_OK);
        return FALSE;
    }

    if(GetCheck(IDC_ARRAY) == BST_CHECKED)
    {
        nType |= VT_ARRAY;
    }

    CHAR szValue[1024];
    UINT uRes = GetDlgItemTextA(m_hDlg, IDC_VALUE, szValue, 1024);
    CVar* pVal = StringToValue(szValue, nType);
    if(pVal == NULL)
    {
        MessageBox(IDS_INVALID_PROPERTY_VALUE, IDS_ERROR, MB_OK);
        return FALSE;
    }

    // All checked out. Store and succeed
    // ==================================

    SysFreeString(*m_pstrName);
    *m_pstrName = SysAllocString(wszName);
    VariantClear(m_pvValue);
    pVal->FillVariant(m_pvValue);

    return TRUE;
}

class CContextDlg : public CWbemDialog
{
    CContext* m_pContext;
    CContext m_Context;
public:
    CContextDlg(HWND hParent, CContext* pContext)
        : CWbemDialog(IDD_CONTEXT_EDITOR, hParent), m_pContext(pContext)
    {}
protected:
    BOOL OnInitDialog();
    BOOL Verify();
    BOOL OnCommand(WORD wCode, WORD wID);
    BOOL OnDoubleClick(int nId);

    void EnableControls(BOOL bEnable);
    void Refresh();
    void OnUse();
    void OnAdd();
    void OnDelete();
    void OnEdit();

    BSTR GetCurSelEntryName();
    LPSTR MakeListEntry(LPCWSTR wszName, VARIANT& vValue);
};

CContext::CContext() : m_bNull(TRUE), m_pContext(NULL)
{
}

BOOL CContext::SetNullness(BOOL bNull)
{
    m_bNull = bNull;
    if(!m_bNull && m_pContext == NULL)
    {
        HRESULT hres = CoCreateInstance(CLSID_WbemContext, NULL,
            CLSCTX_INPROC_SERVER, IID_IWbemContext, (void**)&m_pContext);
        return SUCCEEDED(hres);
    }
    else return TRUE;
}

CContext::~CContext()
{
    if(m_pContext)
        m_pContext->Release();
}

void CContext::Clear()
{
    if(m_pContext)
        m_pContext->Release();
    m_pContext = NULL;
    m_bNull = TRUE;
}


INT_PTR CContext::Edit(HWND hParent)
{
    CContextDlg Dlg(hParent, this);
    return Dlg.Run();
}

CContext::operator IWbemContext*()
{
    if(m_bNull)
        return NULL;
    else
        return m_pContext;
}

void CContext::operator=(const CContext& Other)
{
    m_bNull = Other.m_bNull;
    if(m_pContext)
        m_pContext->Release();
    if(Other.m_pContext)
        Other.m_pContext->Clone(&m_pContext);
    else
        m_pContext = NULL;
}

void CContextDlg::OnUse()
{
    BOOL bEnable = (GetCheck(IDC_USE_CONTEXT) == BST_CHECKED);
    EnableControls(bEnable);
    m_Context.SetNullness(!bEnable);
}

BOOL CContextDlg::OnCommand(WORD wCode, WORD wID)
{
    if(wID == IDC_USE_CONTEXT)
        OnUse();
    else if(wID == IDC_ADD_PROP)
        OnAdd();
    else if(wID == IDC_EDIT_PROP)
        OnEdit();
    else if(wID == IDC_DELETE_PROP)
        OnDelete();
    return TRUE;
}

BOOL CContextDlg::OnDoubleClick(int nID)
{
    if(nID == IDC_VALUE_LIST)
        OnEdit();
    return TRUE;
}

void CContextDlg::OnAdd()
{
    BSTR strName = NULL;
    VARIANT vValue;
    VariantInit(&vValue);

    CContextValueDlg Dlg(m_hDlg, &strName, &vValue, TRUE);
    INT_PTR nRes = Dlg.Run();
    if(nRes == IDOK)
    {
        m_Context.SetNullness(FALSE);
        m_Context->SetValue(strName, 0, &vValue);
        Refresh();
    }
    SysFreeString(strName);
    VariantClear(&vValue);
}

void CContextDlg::OnEdit()
{
    BSTR strName = GetCurSelEntryName();
    if(strName == NULL)
        return;
    VARIANT vValue;
    VariantInit(&vValue);

    m_Context->GetValue(strName, 0, &vValue);

    CContextValueDlg Dlg(m_hDlg, &strName, &vValue, FALSE);
    INT_PTR nRes = Dlg.Run();
    if(nRes == IDOK)
    {
        m_Context->SetValue(strName, 0, &vValue);
        Refresh();
    }
    SysFreeString(strName);
    VariantClear(&vValue);
}

void CContextDlg::OnDelete()
{
    BSTR strName = GetCurSelEntryName();
    if(strName == NULL)
        return;
    m_Context->DeleteValue(strName, 0);
    SysAllocString(strName);
    Refresh();
}

LPSTR CContextDlg::MakeListEntry(LPCWSTR wszName, VARIANT& vValue)
{
    CVar value(&vValue);
    LPSTR TypeString = TypeToString(V_VT(&vValue));
    LPSTR ValueString = ValueToString(&value);

    char* sz = new char[strlen(TypeString) + strlen(ValueString) +
        wcslen(wszName)*4 + 100];

    sprintf(sz, "%S\t%s\t%s", wszName, TypeString, ValueString);
    return sz;
}

BSTR CContextDlg::GetCurSelEntryName()
{
    LPSTR szEntry = GetLBCurSelString(IDC_VALUE_LIST);
    if(szEntry == NULL)
        return NULL;
    char* pc = strchr(szEntry, '\t');
    if(pc) *pc = 0;
    LPWSTR wszName = CreateUnicode(szEntry);
    delete [] szEntry;
    BSTR strName = SysAllocString(wszName);
    delete [] wszName;
    return strName;
}

void CContextDlg::Refresh()
{
    SendMessage(GetDlgItem(IDC_VALUE_LIST), LB_RESETCONTENT, 0, 0);

    IWbemContext* pContext = m_Context.GetStoredContext();
    if(pContext)
    {
        pContext->BeginEnumeration(0);
        BSTR strName;
        VARIANT vValue;
        VariantInit(&vValue);
        while(pContext->Next(0, &strName, &vValue) == S_OK)
        {
            char* szEntry = MakeListEntry(strName, vValue);
            AddStringToList(IDC_VALUE_LIST, szEntry);
            delete [] szEntry;
            VariantClear(&vValue);
        }
        pContext->EndEnumeration();
    }

    if(m_Context.IsNull())
    {
        SetCheck(IDC_USE_CONTEXT, BST_UNCHECKED);
        EnableControls(FALSE);
    }
    else
    {
        SetCheck(IDC_USE_CONTEXT, BST_CHECKED);
    }
}

BOOL CContextDlg::OnInitDialog()
{
    m_Context = *m_pContext;

    // Set tabs in the list box
    // ========================
    LONG Tabs[] = { 80, 120, 170 };
    int TabCount = 3;

    SendMessage(GetDlgItem(IDC_VALUE_LIST), LB_SETTABSTOPS,
        (WPARAM) TabCount, (LPARAM) Tabs);

    SendMessage(GetDlgItem(IDC_VALUE_LIST), LB_SETHORIZONTALEXTENT, 1000, 0);

    Refresh();

    return TRUE;
}

void CContextDlg::EnableControls(BOOL bEnable)
{
    EnableWindow(GetDlgItem(IDC_VALUE_LIST), bEnable);
    EnableWindow(GetDlgItem(IDC_ADD_PROP), bEnable);
    EnableWindow(GetDlgItem(IDC_EDIT_PROP), bEnable);
    EnableWindow(GetDlgItem(IDC_DELETE_PROP), bEnable);
}

CContextDlg::Verify()
{
    *m_pContext = m_Context;
    return TRUE;
}



CMainDlg::~CMainDlg()
{
    PostQuitMessage(0);
}

BOOL CMainDlg::OnInitDialog()
{
    CenterOnScreen(m_hDlg);
//    if(!gbAdvanced)
//  {
//      ShowWindow(GetDlgItem(IDC_ENABLE_PRIVILEGES), SW_HIDE);
//  }

    ConnectButtons(FALSE);
    SetDlgItemTextWC(m_hDlg, IDC_NAMESPACE, gNameSpace);

    CheckRadioButton(m_hDlg, IDC_ASYNC, IDC_SEMISYNC,
            (m_lSync & ASYNC) ? IDC_ASYNC : ((m_lSync & SEMISYNC) ? IDC_SEMISYNC : IDC_SYNC));
    SetDlgItemText(IDC_TIMEOUT, "5000");
    SetDlgItemText(IDC_BATCH, "10");

    SetFocus(GetDlgItem(IDC_CONNECT));
    return FALSE;
}

BOOL CMainDlg::OnCommand(WORD wNotifyCode, WORD wID)
{

    switch (wID)
    {
        case IDC_MENU_EXIT:
        case IDC_CONNECT:
            Connect(FALSE);
            return TRUE;
	case IDC_WBEMHELP:
  	  OpenHelp();
	  return TRUE;

        case IDC_BIND:
            Connect(TRUE);
            return TRUE;

        case IDC_CREATE_CLASS:
            CreateClass();
            return TRUE;
        case IDC_GET_CLASSES:
            GetClasses();
            return TRUE;

        case IDC_EDIT_CLASS:
            EditClass();
            return TRUE;

        case IDC_DELETE_CLASS:
            DeleteClass();
            return TRUE;

        case IDC_CREATE_INSTANCE:
            CreateInstance();
            return TRUE;
        case IDC_GET_INSTANCES:
            GetInstances();
            return TRUE;

        case IDC_EDIT_INSTANCE:
            EditInstance();
            return TRUE;

        case IDC_EXEC_METHOD:
            ExecMethod();
            return TRUE;

        case IDC_DELETE_INSTANCE:
            DeleteInstance();
            return TRUE;

        case IDC_QUERY:
            ExecQuery();
            return TRUE;

        case IDC_NOTIFICATION_QUERY:
            ExecNotificationQuery();
            return TRUE;

        case IDC_OPEN_NS:
            OpenNs();
            return TRUE;

        case IDC_REFRESH:
            CreateRefresher();
            return TRUE;
        case IDC_CONTEXT:
            EditContext();
            return TRUE;
        case IDC_ENABLE_PRIVILEGES:
            {
                // From common\genutils.cpp
                HRESULT hRes = EnableAllPrivileges(TOKEN_PROCESS);
                BOOL bRes = SUCCEEDED(hRes);
                if (bRes)
                    EnableWindow(GetDlgItem(IDC_ENABLE_PRIVILEGES), FALSE);
                return bRes;
            }
        case IDC_USE_AMENDED:
            if (GetCheck(IDC_USE_AMENDED) == BST_CHECKED)
                m_lGenFlags |= WBEM_FLAG_USE_AMENDED_QUALIFIERS;
            else
                m_lGenFlags &= ~WBEM_FLAG_USE_AMENDED_QUALIFIERS;
            return TRUE;
        case IDC_DIRECT_READ:
            if (GetCheck(IDC_DIRECT_READ) == BST_CHECKED)
                m_lGenFlags |= WBEM_FLAG_DIRECT_READ;
            else
                m_lGenFlags &= ~WBEM_FLAG_DIRECT_READ;
            return TRUE;
        case IDC_USE_NEXTASYNC:
            if (GetCheck(IDC_USE_NEXTASYNC) == BST_CHECKED)
                m_lSync |= USE_NEXTASYNC;
            else
                m_lSync &= ~USE_NEXTASYNC;
            EnableWindow(GetDlgItem(IDC_TIMEOUT), !(m_lSync & USE_NEXTASYNC));
            return TRUE;

        case IDC_ASYNC:
        case IDC_SYNC:
        case IDC_SEMISYNC:
            // Can ignore USE_NEXTASYNC checkbox because we are changing to or from
            // semisync which means this checkbox either was clear or is now cleared.
            if (GetCheck(IDC_ASYNC) == BST_CHECKED)
            {
                m_lSync = ASYNC;
                SetCheck(IDC_USE_NEXTASYNC, BST_UNCHECKED);
            }
            else if (GetCheck(IDC_SYNC) == BST_CHECKED)
            {
                m_lSync = SYNC;
                SetCheck(IDC_USE_NEXTASYNC, BST_UNCHECKED);
            }
            else if (GetCheck(IDC_SEMISYNC) == BST_CHECKED)
            {
                m_lSync = SEMISYNC;
            }
            EnableWindow(GetDlgItem(IDC_BATCH), !(m_lSync & ASYNC));
            EnableWindow(GetDlgItem(IDC_TIMEOUT), (m_lSync & SEMISYNC));
            EnableWindow(GetDlgItem(IDC_USE_NEXTASYNC), (m_lSync & SEMISYNC));
            return TRUE;
		case IDC_OPEN:
            Open();
            return TRUE;

		case IDC_ADDOBJECT:
            AddObject();
            return TRUE;

		case IDC_DELETEOBJECT:
            DeleteObject();
            return TRUE;

		case IDC_RENAMEOBJECT:
            RenameObject();
            return TRUE;

		case IDC_GETOBJECTSECURITY:
            GetObjectSecurity();
            return TRUE;

		case IDC_SETOBJECTSECURITY:
            SetObjectSecurity();
            return TRUE;
    }
    return TRUE;
}

LONG CMainDlg::Timeout()
{
    wchar_t wszTimeout[32];
    *wszTimeout = 0;
    LONG lTimeout = 0;

    ::GetDlgItemTextX(m_hDlg, IDC_TIMEOUT, wszTimeout, 32);
    if (*wszTimeout != 0)
        lTimeout = _wtol(wszTimeout);
    if (lTimeout < 0)
        lTimeout = WBEM_INFINITE;

    return lTimeout;
}

ULONG CMainDlg::BatchCount()
{
    wchar_t wszBatch[32];
    *wszBatch = 0;
    ULONG nBatch = 1;

    ::GetDlgItemTextX(m_hDlg, IDC_BATCH, wszBatch, 32);
    if (*wszBatch != 0)
        nBatch = _wtol(wszBatch);
    if (nBatch == 0)
        nBatch = 1;

    return nBatch;
}

CRefresherDlg::CRefresherDlg(HWND hParent, LONG lGenFlags)
    : CQueryResultDlg(hParent, lGenFlags, WBEM_FLAG_DEEP)
{
    CoCreateInstance(CLSID_WbemRefresher, NULL,
        CLSCTX_INPROC_SERVER, IID_IWbemRefresher, (void**)&m_pRefresher);
    m_pRefresher->QueryInterface(IID_IWbemConfigureRefresher,
        (void**)&m_pCreator);
}

CRefresherDlg::~CRefresherDlg()
{
    // Release all allocated enumerators
    while ( m_apEnums.Size() != 0 )
    {
        IEnumWbemClassObject*   pEnum = (IEnumWbemClassObject*) m_apEnums.GetAt( 0 );
        if ( NULL != pEnum )
        {
            pEnum->Release();
        }
        m_apEnums.RemoveAt( 0 );
    }

    m_pRefresher->Release();
    m_pCreator->Release();
}

BOOL CRefresherDlg::OnInitDialog()
{
    SetTitle("REFRESHER");
    ShowWindow(GetDlgItem(IDC_STATUS), SW_HIDE);
    ShowWindow(GetDlgItem(IDC_NUM_BATCH), SW_HIDE);
    if(!CQueryResultDlg::OnInitDialog())
        return FALSE;
    ShowWindow(GetDlgItem(IDC_REFRESH), SW_SHOWNORMAL);
    return TRUE;
}

BOOL CRefresherDlg::OnCommand(WORD wCode, WORD wID)
{
    if(wID == IDC_REFRESH)
    {
        OnRefresh();
        return TRUE;
    }
    else return CQueryResultDlg::OnCommand(wCode, wID);
}

void CRefresherDlg::OnRefresh()
{
    HRESULT hres = m_pRefresher->Refresh(0);
    if(FAILED(hres))
    {
        FormatError(hres, NULL);
    }
}

BOOL CRefresherDlg::DeleteListElement(LRESULT nSel)
{
    HRESULT hres = m_pCreator->Remove(PtrToLong(m_aIds[(DWORD)nSel]), 0);
    if(FAILED(hres))
    {
        FormatError(hres, NULL);
        return FALSE;
    }

    m_aIds.RemoveAt((DWORD)nSel);

    // If this is an enumerator, we should release it before we remove it
    IEnumWbemClassObject*   pEnum = (IEnumWbemClassObject*) m_apEnums.GetAt( (DWORD)nSel );

    if ( NULL != pEnum )
    {
        pEnum->Release();
    }
    m_apEnums.RemoveAt((DWORD)nSel);

    return TRUE;
}


IWbemClassObject* CRefresherDlg::AddNewElement()
{
    if(g_pNamespace == NULL)
    {
        MessageBox(IDS_NO_CONNECTION, IDS_ERROR, MB_OK);
        return NULL;
    }
    wchar_t ObjPath[2560];

    INT_PTR iRet = GetRefrObjectPath(m_hDlg, ObjPath, 2560);
    if(iRet == IDCANCEL)
        return NULL;

    if (wcslen(ObjPath) == 0)
    {
        MessageBox(IDS_NO_PATH, IDS_ERROR, MB_OK);
        return NULL;
    }

    IWbemClassObject* pObj = NULL;
    IWbemHiPerfEnum*    pEnum = NULL;
    long lId;
    HRESULT hres = WBEM_S_NO_ERROR;



    // iRet for whether we want to add an object or an enum

    if ( IDOK == iRet )
    {
        hres = m_pCreator->AddObjectByPath(g_pNamespace, ObjPath,
            m_lGenFlags, g_Context, &pObj, &lId);
        if(FAILED(hres))
        {
            FormatError(hres, NULL);
            return NULL;
        }
#ifdef _WIN64
        m_aIds.Add(IntToPtr(lId));   // ok since we are really using safearray for dword 
#else
        m_aIds.Add((void*)lId);
#endif
        // Fakes out the Enumerator List
        m_apEnums.Add( NULL );
        return pObj;
    }

    // Add an enumerator to the dialog
    hres = m_pCreator->AddEnum(g_pNamespace, ObjPath,
        m_lGenFlags, g_Context, &pEnum, &lId);
    if(FAILED(hres))
    {
        FormatError(hres, NULL);
        return NULL;
    }

#ifdef _WIN64
        m_aIds.Add(IntToPtr(lId));      // ok since we are really using safearray for dword 
#else
        m_aIds.Add((void*)lId);
#endif
    m_apEnums.Add( (void*) pEnum );

    // Fakes out the object list
    m_InternalArray.Add( NULL );

    HWND hList = GetDlgItem(IDC_OBJECT_LIST);

    // Allocate a large enough buffer
    char*   szTemp = new char[(wcslen( ObjPath ) * 2) + 64];
    sprintf( szTemp, "%S Enumerator, Id: %d", ObjPath, lId );
    SendMessage(hList, LB_ADDSTRING, 0, LPARAM(szTemp));
    delete [] szTemp;

    SetNumItems(SendMessage(hList, LB_GETCOUNT, 0, 0));

    return NULL;

}

BOOL CRefresherDlg::OnDoubleClick(int nID)
{
    if(nID != IDC_OBJECT_LIST) return FALSE;
    HWND hList = GetDlgItem(IDC_OBJECT_LIST);

    LRESULT nSel = SendMessage(hList, LB_GETCURSEL, 0, 0);

    if (nSel == LB_ERR)
        return TRUE;

    IWbemHiPerfEnum*    pEnum = (IWbemHiPerfEnum*) m_apEnums.GetAt( (DWORD)nSel );

    if ( NULL != pEnum )
    {
        char*   szTemp = new char[SendMessage( hList, LB_GETTEXTLEN, nSel, 0 )+10];
        SendMessage( hList, LB_GETTEXT, nSel, (LPARAM) szTemp );

        // Run the dialog modal
        CRefresherEnumDlg* pDlg = new CRefresherEnumDlg(m_hDlg, m_lGenFlags, pEnum, szTemp);
        pDlg->Run( NULL );

		delete pDlg;
        delete [] szTemp;
        SendMessage(hList, LB_SETCURSEL, nSel, 0);
        return TRUE;
    }
    else
    {
        return CQueryResultDlg::OnDoubleClick( nID );
    }
    return TRUE;
}

CRefresherEnumDlg::CRefresherEnumDlg(HWND hParent, LONG lGenFlags, IWbemHiPerfEnum* pEnum,
                                     char* pszName)
    : CQueryResultDlg(hParent, lGenFlags, WBEM_FLAG_DEEP), m_pEnum(pEnum), m_pszName(pszName)
{

    if ( NULL != m_pEnum )
    {
        m_pEnum->AddRef();
    }
}

CRefresherEnumDlg::~CRefresherEnumDlg()
{
    if ( NULL != m_pEnum )
    {
        m_pEnum->Release();
    }
}

BOOL CRefresherEnumDlg::OnInitDialog()
{
    // Set the dialog title
    char*   szTemp = new char[strlen(m_pszName)+64];
    sprintf( szTemp, "REFRESHER: %s", m_pszName );
    SetTitle(szTemp);
    delete [] szTemp;

    ShowWindow(GetDlgItem(IDC_STATUS), SW_HIDE);
    ShowWindow(GetDlgItem(IDC_NUM_BATCH), SW_HIDE);
    if(!CQueryResultDlg::OnInitDialog())
        return FALSE;

    // Iterate the enumerator and add all its objects into the list
    HRESULT hr = WBEM_S_NO_ERROR;
    IWbemClassObject*   pObj = NULL;
    ULONG               nNumObjects = 0,
                        nNumReturned = 0;

    // Find out how many objects to retrieve then get them
    // and stick them in the dialog

    // Don't pass flags on  this call
    m_pEnum->GetObjects( 0L, 0, NULL, &nNumObjects );

    if ( nNumObjects > 0 )
    {
        IWbemObjectAccess** apObjAccess = new IWbemObjectAccess*[nNumObjects];

        if ( NULL != apObjAccess )
        {
            // Don't pass flags on  this call
            hr = m_pEnum->GetObjects( 0L, nNumObjects, apObjAccess, &nNumReturned );

            if ( SUCCEEDED( hr ) )
            {
                IWbemClassObject*   pClassObj = NULL;

                for ( ULONG n = 0; SUCCEEDED( hr ) && n < nNumReturned; n++ )
                {
                    hr = apObjAccess[n]->QueryInterface( IID_IWbemClassObject, (void**) &pClassObj );

                    if ( SUCCEEDED( hr ) )
                    {
                        AddObject( pClassObj );
                        apObjAccess[n]->Release();
                        pClassObj->Release();
                    }
                }
            }
            delete [] apObjAccess;
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }

    if ( FAILED( hr ) )
    {
        FormatError(hr, NULL);
    }

    return TRUE;
}

CHourGlass::CHourGlass()
{
    m_hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
}

CHourGlass::~CHourGlass()
{
    SetCursor(m_hCursor);
}

HRESULT EnableAllPrivileges(DWORD dwTokenType)
{
    // Open thread token
    // =================

    HANDLE hToken = NULL;
    BOOL bRes;

    switch (dwTokenType)
    {
    case TOKEN_THREAD:
        bRes = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, TRUE, &hToken);
        break;
    case TOKEN_PROCESS:
        bRes = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, &hToken);
        break;
    }
    if(!bRes)
        return WBEM_E_ACCESS_DENIED;

    // Get the privileges
    // ==================

    DWORD dwLen;
    TOKEN_USER tu;
    memset(&tu,0,sizeof(TOKEN_USER));
    bRes = GetTokenInformation(hToken, TokenPrivileges, &tu, sizeof(TOKEN_USER), &dwLen);

    BYTE* pBuffer = new BYTE[dwLen];
    if(pBuffer == NULL)
    {
        CloseHandle(hToken);
        return WBEM_E_OUT_OF_MEMORY;
    }

    bRes = GetTokenInformation(hToken, TokenPrivileges, pBuffer, dwLen,
                                &dwLen);
    if(!bRes)
    {
        CloseHandle(hToken);
        delete [] pBuffer;
        return WBEM_E_ACCESS_DENIED;
    }

    // Iterate through all the privileges and enable them all
    // ======================================================

    TOKEN_PRIVILEGES* pPrivs = (TOKEN_PRIVILEGES*)pBuffer;
    for(DWORD i = 0; i < pPrivs->PrivilegeCount; i++)
    {
        pPrivs->Privileges[i].Attributes |= SE_PRIVILEGE_ENABLED;
    }

    // Store the information back into the token
    // =========================================

    bRes = AdjustTokenPrivileges(hToken, FALSE, pPrivs, 0, NULL, NULL);
    delete [] pBuffer;
    CloseHandle(hToken);

    if(!bRes)
        return WBEM_E_ACCESS_DENIED;
    else
        return WBEM_S_NO_ERROR;
}
void CMainDlg::Open()
{

    wchar_t ObjPath[2560];
    int iRet = (int) GetObjectPath(m_hDlg, ObjPath, 2560);
    if(iRet == IDCANCEL)
        return;

    if (wcslen(ObjPath) == 0)
    {
        MessageBox(IDS_NO_PATH, IDS_ERROR, MB_OK);
        return;
    }

    if (g_pNamespace == 0)
    {
        MessageBox(IDS_NO_INITIAL_CONNECTION, IDS_ERROR, MB_OK);
        return;
    }

    IWbemServicesEx* pNewNs = NULL;
    CBString bsObjPath(ObjPath);

    HRESULT res;
    IWbemClassObject* pErrorObj = NULL;

    // Asynchronous
    if (m_lSync & ASYNC)
    {

		IUnknown *pUnknown=NULL;

		CTestNotify* pSink=new CTestNotify(1);

		res=g_pServicesEx->OpenAsync(bsObjPath.GetString(), 0,
                                m_lGenFlags,
                                g_Context, CUnsecWrapEx(pSink));

		if (SUCCEEDED(res))
		{
			pSink->WaitForSignal(INFINITE);
			res = pSink->GetStatusCode();
			if(SUCCEEDED(res))
			{
				pUnknown=pSink->GetInterface();
                if(pUnknown)
                {
                    res = pUnknown->QueryInterface(IID_IWbemServicesEx, (void**)&pNewNs);
                    pUnknown->Release();
                }
                else
                    res = WBEM_E_FAILED;
			}
		}
		pSink->Release();
    }

    // Semisynchronous
    else if (m_lSync & SEMISYNC)
    {
        IWbemCallResultEx* pCallRes = NULL;
        CHourGlass hg;
        res = g_pServicesEx->Open(bsObjPath.GetString(), 0,
                                m_lGenFlags | WBEM_FLAG_RETURN_IMMEDIATELY,
                                g_Context, NULL, &pCallRes);

        if (SUCCEEDED(res))
        {
            LONG lStatus;
            SetInterfaceSecurityEx(pCallRes, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
            while ((res = pCallRes->GetCallStatus(Timeout(), &lStatus)) == WBEM_S_TIMEDOUT)
            {
                // wait
            }
            if (res == WBEM_S_NO_ERROR)
            {
                res = (HRESULT)lStatus;     // lStatus is the final result of the above IWbemServices::OpenNamespace call
                if (res == WBEM_S_NO_ERROR)
                {
                    res = pCallRes->GetResult(0, 0, IID_IWbemServicesEx, (LPVOID *) &pNewNs);    // don't use timeout since object should be available
                }
            }

            pCallRes->Release();
        }
		
    }

    // Synchronous
    else
    {
        CHourGlass hg;
        res = g_pServicesEx->Open(bsObjPath.GetString(), 0,
                                m_lGenFlags,
                                g_Context, &pNewNs, NULL);
    }

    if (FAILED(res))
    {
        FormatError(res, m_hDlg, pErrorObj);
        return;
    }

    g_pNamespace->Release();
	g_pNamespace = pNewNs;
    SetInterfaceSecurityEx(g_pNamespace, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);

    wcscat(gNameSpace, L":");
    wcscat(gNameSpace, bsObjPath.GetString());
    SetDlgItemTextWC(m_hDlg, IDC_NAMESPACE, gNameSpace);

    SysFreeString(g_strNamespace);
    g_strNamespace = SysAllocString(gNameSpace);
}

void CMainDlg::DoServicesExGenObject(int iOpt)
{
    wchar_t ObjPath[2560];
    *ObjPath = 0;

    int iRet = (int) GetObjectPath(m_hDlg, ObjPath, 2560);
    if (iRet == IDCANCEL)
        return;

    if (wcslen(ObjPath) == 0)
        return;

    CBString bsObjPath(ObjPath);
    HRESULT res = 0;
    IWbemClassObject* pErrorObj = NULL;

    // Asynchronous
    if (m_lSync & ASYNC)
    {
        MessageBox(IDS_ASYNC_NOT_SUPPORTED, IDS_ERROR, MB_OK);
        return;
    }

    // Semisynchronous
    else if (m_lSync & SEMISYNC)
    {
        IWbemCallResultEx* pCallRes = NULL;
        CHourGlass hg;
		switch (iOpt)
		{
			case IDC_ADDOBJECT:
				// Link
                res = E_NOTIMPL;
				break;

			case IDC_DELETEOBJECT:
				// Unlink
                res = E_NOTIMPL;
				break;


		}
        if (SUCCEEDED(res))
        {
            LONG lStatus;
            LONG lTimeout = Timeout();
            SetInterfaceSecurityEx(pCallRes, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
            while ((res = pCallRes->GetCallStatus(lTimeout, &lStatus)) == WBEM_S_TIMEDOUT)
            {
                // wait
            }
            if (res == WBEM_S_NO_ERROR)
            {
                res = (HRESULT)lStatus;     // lStatus is the final result of the above IWbemServices::DeleteIntance call
            }
            pCallRes->Release();
        }
    }

    // Synchronous
    else
    {
        CHourGlass hg;

		switch (iOpt)
		{
			case IDC_ADDOBJECT:
                // Link
                res = E_NOTIMPL;
                break;

			case IDC_DELETEOBJECT:
                // Unlink
                res = E_NOTIMPL;
                break;


		}
    }

    if (FAILED(res))
    {
        FormatError(res, m_hDlg, pErrorObj);
    }
}

void CMainDlg::AddObject()
{
	DoServicesExGenObject(IDC_ADDOBJECT);
}

void CMainDlg::DeleteObject()
{
    wchar_t ObjPath[2560];
    *ObjPath = 0;

    INT_PTR iRet = GetObjectPath(m_hDlg, ObjPath, 2560);
    if (iRet == IDCANCEL)
        return;

    if (wcslen(ObjPath) == 0)
        return;

    CBString bsObjPath(ObjPath);
    HRESULT res;
    IWbemClassObject* pErrorObj = NULL;

    // Asynchronous
    if (m_lSync & ASYNC)
    {
        CHourGlass hg;
        CTestNotify* pNtfy = new CTestNotify(1);

        res = g_pServicesEx->DeleteObjectAsync(bsObjPath.GetString(),
                                                m_lGenFlags | WBEM_FLAG_SEND_STATUS,
                                                g_Context, CUnsecWrap(pNtfy));

        if (SUCCEEDED(res))
        {
            pNtfy->WaitForSignal(INFINITE);

            res = pNtfy->GetStatusCode(&pErrorObj);
        }
        pNtfy->Release();
    }

    // Semisynchronous
    else if (m_lSync & SEMISYNC)
    {
        IWbemCallResult* pCallRes = NULL;
        CHourGlass hg;
        res = g_pServicesEx->DeleteObject(bsObjPath.GetString(),
                                           m_lGenFlags | WBEM_FLAG_RETURN_IMMEDIATELY,
                                           g_Context, &pCallRes);
        if (SUCCEEDED(res))
        {
            LONG lStatus;
            LONG lTimeout = Timeout();
            SetInterfaceSecurityEx(pCallRes, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
            while ((res = pCallRes->GetCallStatus(lTimeout, &lStatus)) == WBEM_S_TIMEDOUT)
            {
                // wait
            }
            if (res == WBEM_S_NO_ERROR)
            {
                res = (HRESULT)lStatus;     // lStatus is the final result of the above IWbemServices::DeleteIntance call
            }

            pCallRes->Release();
        }
    }

    // Synchronous
    else
    {
        CHourGlass hg;
        res = g_pServicesEx->DeleteObject(bsObjPath.GetString(), m_lGenFlags,
                                           g_Context, NULL);
    }

    if (FAILED(res))
    {
        FormatError(res, m_hDlg, pErrorObj);
    }
}


void CMainDlg::GetObjectSecurity()
{
	::MessageBox(NULL, "Show me the code", "help!", MB_OK);
}

void CMainDlg::SetObjectSecurity()
{
	::MessageBox(NULL, "Show me the code", "help!", MB_OK);
}

void CMainDlg::RenameObject()
{
	WCHAR wsOld[512], wsNew[512];
    CRenameDlg InfoDlg(m_hDlg, wsOld, 512, wsNew, 512);
    if(IDOK != InfoDlg.Run())
		return;

    CBString bsOld(wsOld);
    CBString bsNew(wsNew);
    HRESULT res;
    IWbemClassObject* pErrorObj = NULL;

    // Asynchronous
    if (m_lSync & ASYNC)
    {
        MessageBox(IDS_ASYNC_NOT_SUPPORTED, IDS_ERROR, MB_OK);
        return;
    }

    // Semisynchronous
    else if (m_lSync & SEMISYNC)
    {
        IWbemCallResultEx* pCallRes = NULL;
        CHourGlass hg;
		res = g_pServicesEx->RenameObject(bsOld.GetString(), bsNew.GetString(),
                                           m_lGenFlags | WBEM_FLAG_RETURN_IMMEDIATELY,
                                           g_Context, &pCallRes);
        if (SUCCEEDED(res))
        {
            LONG lStatus;
            LONG lTimeout = Timeout();
            SetInterfaceSecurityEx(pCallRes, gpAuthIdentity, gpPrincipal, gdwAuthLevel, gdwImpLevel);
            while ((res = pCallRes->GetCallStatus(lTimeout, &lStatus)) == WBEM_S_TIMEDOUT)
            {
                // wait
            }
            if (res == WBEM_S_NO_ERROR)
            {
                res = (HRESULT)lStatus;     // lStatus is the final result of the above IWbemServices::DeleteIntance call
            }
            pCallRes->Release();
        }
    }

    // Synchronous
    else
    {
        CHourGlass hg;

    	res = g_pServicesEx->RenameObject(bsOld.GetString(), bsNew.GetString(),
                                           m_lGenFlags,
                                           g_Context, NULL);
 }

    if (FAILED(res))
    {
        FormatError(res, m_hDlg, pErrorObj);
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemtest\wbemtest.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMTEST.H

Abstract:

History:

--*/

#ifndef __WBEMTEST__H_
#define __WBEMTEST__H_

#include <windows.h>
#include <wbemidl.h>
#include <wbemint.h>

//#include <dbgalloc.h>
//#include <arena.h>
#include <WT_wstring.h>

#include <wbemdlg.h>
#include <wbemntfy.h>
#include <resrc1.h>

#define I_EMBEDDED_OBJECT IUnknown
#define VT_EMBEDDED_OBJECT VT_UNKNOWN
#define TOKEN_THREAD	0
#define TOKEN_PROCESS	1
HRESULT EnableAllPrivileges(DWORD dwTokenType = TOKEN_THREAD);
int Trace(const char *fmt, ...);
extern IWbemLocator *g_pLocator;
extern IWbemServices *g_pNamespace;
extern IWbemServicesEx *g_pServicesEx;
extern BSTR g_strNamespace;
extern BOOL gbSecured;

enum 
{ 
    SYNC            = 0,
    ASYNC           = 0x1, 
    SEMISYNC        = 0x2,
    USE_NEXTASYNC   = 0x1000        // applies to semisync enumeration only
};

void FormatError(SCODE res, HWND hParent, IWbemClassObject* pErrorObj = NULL);

class CQueryResultDlg;

void ShowClass(HWND hDlg, LONG lGenFlags, LPWSTR wszClass, 
               LONG lSync, CRefCountable* pOwner, LONG lTimeout);
void ShowClasses(HWND hDlg, LONG lGenFlags, LONG lQryFlags, LPWSTR wszParentClass, 
                 LONG lSync, CRefCountable* pOwner, LONG lTimeout, ULONG nBatch);
void ShowInstances(HWND hDlg, LONG lGenFlags, LONG lQryFlags, LPWSTR wszClass, 
                   LONG lSync, CRefCountable* pOwner, LONG lTimeout, ULONG nBatch);
BOOL _ExecQuery(HWND hDlg, LONG lGenFlags, LONG lQryFlags, LPWSTR wszQuery, LPWSTR wszLanguage, 
                LONG lSync, CQueryResultDlg* pRes, char* pWindowTitle, LONG lTimeout, ULONG nBatch);
BOOL _PutInstance(HWND hDlg, LONG lGenFlags, LONG lChgFlags, LONG lSync, 
                  IWbemClassObject* pInstance, LONG lTimeout);
BOOL _PutClass(HWND hDlg, LONG lGenFlags, LONG lChgFlags, LONG lSync, 
               IWbemClassObject* pClass, LONG lTimeout);

IWbemClassObject* _CreateInstance(HWND hDlg, LONG lGenFlags, LONG lSync, LONG lTimeout);
IWbemClassObject* PreCreateInstance(HWND hDlg, LONG lGenFlags, LONG lSync, LONG lTimeout);


class CNotSink;

//***************************************************************************

class CQueryResultDlg : public CWbemDialog
{
protected:
    CFlexArray m_InternalArray;
    CNotSink* m_pHandler;
    IWbemObjectSink* m_pWrapper;
    IEnumWbemClassObject* m_pEnum;          // for synchronous and semisynchronous enumeration

	bool m_partial_result;
    BOOL m_bRelease;
    BOOL m_bReadOnly;
	BOOL m_fDeletesAllowed;
    BOOL m_bComplete;
	BOOL m_bSort;

    LONG  m_lGenFlags;  // generic WBEM_FLAG_ .. flags
    LONG  m_lQryFlags;  // query WBEM_FLAG_ .. flags
    LONG  m_lSync;      // sync, async, semisync
    LONG  m_lTimeout;   // used in semisync only
    ULONG m_nBatch;     // used in semisync and sync enumerations
    ULONG m_nReturnedMax;   // maximum size of batch returned

    char *m_szTitle;

    struct CStatus
    {
        HRESULT m_hres;
        BSTR m_str;
        IWbemClassObject* m_pObj;
        
        CStatus(long l, BSTR str, IWbemClassObject* pObj)
            : m_hres(l), m_pObj(pObj)
        {
            m_str = (str ? SysAllocString(str) : NULL);
            if(m_pObj) m_pObj->AddRef();
        }
        ~CStatus()
        {
            SysFreeString(m_str);
            if(m_pObj) m_pObj->Release();
        }
    };
        
        
public:
								
    CQueryResultDlg(HWND hParent, LONG lGenFlags, LONG lQryFlags, BOOL fDeletesAllowed = TRUE, int tID = IDD_QUERY_RESULT);
    virtual ~CQueryResultDlg();

    void SetNotify(CNotSink* pNotify);
    void SetEnum(IEnumWbemClassObject* pEnum, HRESULT = 0);

    void SetReadOnly(BOOL bReadOnly = TRUE) { m_bReadOnly = bReadOnly; }
    void SetCallMethod(LONG lSync) { m_lSync = lSync; }
    void SetTimeout(LONG lTimeout) { m_lTimeout = lTimeout; }
    void SetBatchCount(ULONG nBatch) { m_nBatch = nBatch; }

    void SetTitle(char* szTitle);
    void SetComplete(HRESULT hres, BSTR strParam, IWbemClassObject* pErrorObj);
    void AddObject(IWbemClassObject* pObj);
    void RunDetached(CRefCountable* pOwner);
    void PostObject(IWbemClassObject* pObj);
    void PostCount(long nCount);
    void PostComplete(long lParam, BSTR strParam, IWbemClassObject* pObjParam);
    void set_partial(bool value){ if (m_partial_result==false) m_partial_result = value;}

    IWbemObjectSink* GetWrapper() {return m_pWrapper;}
protected:
    virtual BOOL OnInitDialog();
    virtual BOOL OnCommand(WORD wCode, WORD wID);
    virtual BOOL OnUser(WPARAM wParam, LPARAM lParam);
    virtual void OnDelete();
    virtual void OnAdd();
    virtual void OnCopy();
    virtual BOOL OnDoubleClick(int nID);

    virtual BOOL DeleteListElement(LRESULT nSel);
    virtual BOOL ViewListElement(LRESULT nSel);
    virtual IWbemClassObject* AddNewElement();
    virtual BOOL CanAdd()		{ return FALSE;}
    virtual BOOL CanDelete()	{ return m_fDeletesAllowed;}

    virtual BOOL Initialize() {return TRUE;}

    void MakeListEntry(IWbemClassObject* pObj, WString& ListEntry);
    void SetNumItems(LRESULT nNum);
    void SetNumBatchItems(ULONG nNum);
    void RefreshItem(int nItem);
    void ProcessEnum();
    void ProcessEnumSemisync();
    void SemisyncNextAsync();
};

//***************************************************************************

class CAppOwner : public CRefCountable
{
public:
    virtual long Release();
};

//***************************************************************************

class CQueryDlg : public CWbemDialog
{
protected:
    wchar_t **m_pwszQueryType;
    wchar_t **m_pwszQueryString;
    static char *m_szLastQueryType;
    static char *m_szLastQuery;
    LONG* m_plQryFlags;

public:
    CQueryDlg(HWND hParent, LONG* plQryFlags, LPWSTR *pwszQueryString, LPWSTR *pwszQueryType)
        :  CWbemDialog(IDD_QUERY, hParent), m_plQryFlags(plQryFlags), 
            m_pwszQueryType(pwszQueryType), m_pwszQueryString(pwszQueryString)
    {}

protected:
    BOOL OnInitDialog();
    BOOL Verify();
};

class CContext
{
protected:
    BOOL m_bNull;
    IWbemContext* m_pContext;

public:
    CContext();
    ~CContext();

    BOOL IsNull() {return m_bNull;}
    IWbemContext* GetStoredContext() {return m_pContext;}

    INT_PTR Edit(HWND hParent);
    operator IWbemContext*();
    IWbemContext* operator->() {return (IWbemContext*)*this;}
    void operator=(const CContext& Other);

    BOOL SetNullness(BOOL bNull);
    void Clear();
};

extern CContext g_Context;

//***************************************************************************

class CRefresherDlg : public CQueryResultDlg
{
protected:
    IWbemRefresher* m_pRefresher;
    IWbemConfigureRefresher* m_pCreator;
    CFlexArray m_aIds;
	CFlexArray m_apEnums;

public:
    CRefresherDlg(HWND hParent, LONG lGenFlags);
    ~CRefresherDlg();

    virtual BOOL OnInitDialog();
    virtual BOOL OnCommand(WORD wCode, WORD wID);
    virtual void OnRefresh();
    virtual IWbemClassObject* AddNewElement();
    virtual BOOL DeleteListElement(LRESULT nSel);

	virtual BOOL OnDoubleClick( int nID );
    virtual BOOL CanAdd()    { return TRUE;}
};

//***************************************************************************

class CRefresherEnumDlg : public CQueryResultDlg
{
protected:
    IWbemHiPerfEnum*		m_pEnum;
	char*					m_pszName;

public:
    CRefresherEnumDlg(HWND hParent, LONG lGenFlags, IWbemHiPerfEnum* pEnum, char* pszName);
    ~CRefresherEnumDlg();

    virtual BOOL OnInitDialog();
    virtual BOOL CanAdd()		{ return FALSE;}
};

//***************************************************************************

class CHourGlass
{
protected:
    HCURSOR m_hCursor;
public:
    CHourGlass();
    ~CHourGlass();
};

//***************************************************************************

void Fatal(UINT uMsg);

class CUnsecWrap
{
protected:
    IWbemObjectSink* m_pSink;
    IWbemObjectSink* m_pWrapper;
    
    static IUnsecuredApartment* mstatic_pApartment;

protected:
    static void Init()
    {
        if(mstatic_pApartment == NULL && gbSecured)
        {
            HRESULT hres = CoCreateInstance(CLSID_UnsecuredApartment, NULL, 
                            CLSCTX_ALL,
                            IID_IUnsecuredApartment, 
                            (void**)&mstatic_pApartment);
            if(FAILED(hres))
            {
                Fatal(IDS_OLE_INIT_FAILED);
            }
        }
    }
public:
    CUnsecWrap(IWbemObjectSink* pSink) : m_pSink(pSink), m_pWrapper(NULL)
    {
        m_pSink->AddRef();
        Init();
    }
    ~CUnsecWrap()
    {
        m_pSink->Release();
        if(m_pWrapper)
            m_pWrapper->Release();
    }

    operator IWbemObjectSink*()
    {
        if(!gbSecured)
            return m_pSink;
        if(m_pWrapper)
            return m_pWrapper;
        
        IUnknown* pUnk = NULL;
        SCODE sc = mstatic_pApartment->CreateObjectStub(m_pSink, &pUnk);
        if(sc != S_OK || pUnk == NULL)
        {

            Fatal(IDS_UNSECAPP_ERROR);
            FormatError(sc, NULL);
            return NULL;
        }
        pUnk->QueryInterface(IID_IWbemObjectSink, (void**)&m_pWrapper);
        pUnk->Release();
        return m_pWrapper;
    }
};


class CUnsecWrapEx
{
protected:
    IWbemObjectSinkEx* m_pSink;
    IWbemObjectSinkEx* m_pWrapper;
    
    static IUnsecuredApartment* mstatic_pApartment;

protected:
    static void Init()
    {
        if(mstatic_pApartment == NULL && gbSecured)
        {
            HRESULT hres = CoCreateInstance(CLSID_UnsecuredApartment, NULL, 
                            CLSCTX_ALL,
                            IID_IUnsecuredApartment, 
                            (void**)&mstatic_pApartment);
            if(FAILED(hres))
            {
                Fatal(IDS_OLE_INIT_FAILED);
            }
        }
    }
public:
    CUnsecWrapEx(IWbemObjectSinkEx* pSink) : m_pSink(pSink), m_pWrapper(NULL)
    {
        m_pSink->AddRef();
        Init();
    }
    ~CUnsecWrapEx()
    {
        m_pSink->Release();
        if(m_pWrapper)
            m_pWrapper->Release();
    }

    operator IWbemObjectSinkEx*()
    {
        if(!gbSecured)
            return m_pSink;
        if(m_pWrapper)
            return m_pWrapper;
        
        IUnknown* pUnk = NULL;
        SCODE sc = mstatic_pApartment->CreateObjectStub(m_pSink, &pUnk);
        if(sc != S_OK || pUnk == NULL)
        {

            Fatal(IDS_UNSECAPP_ERROR);
            FormatError(sc, NULL);
            return NULL;
        }
        pUnk->QueryInterface(IID_IWbemObjectSinkEx, (void**)&m_pWrapper);
        pUnk->Release();
        return m_pWrapper;
    }
};
      
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemtest\wt_flexarry.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FLEXARRAY.CPP

Abstract:

  CFlexArray and CWStringArray implementation.

  These objects can operate from any allocator, and be constructed
  on arbitrary memory blocks.

History:

  11-Apr-96   a-raymcc    Created.
  24-Apr-96   a-raymcc    Updated for CArena support.

--*/

#include "precomp.h"
#include <stdio.h>
#include <WT_flexarry.h>
#include "WT_strutils.h"
class CX_MemoryException
{
};

//***************************************************************************
//
//  CFlexArray::CFlexArray
//
//  Constructs the array.
//
//  Parameters:
//  <nSize>         The starting preallocated size of the array.
//  <nGrowBy>       The amount to grow by when the array fills up.
//
//  Size() returns the number of elements in use, not the 'true' size.
//
//***************************************************************************
// ok

CFlexArray::CFlexArray(
    int nSize, 
    int nGrowByPercent
    )
{
    m_nExtent = nSize;
    m_nSize = 0;
    m_nGrowByPercent = nGrowByPercent;
    if(nSize > 0)
    {
        m_pArray = 
            (void**)HeapAlloc(GetProcessHeap(), 0, sizeof(void *) * nSize);

        // Check for allocation failures
        if ( NULL == m_pArray )
        {
            throw CX_MemoryException();
        }
    }
    else
        m_pArray = NULL;
}
    
//***************************************************************************
//
//  CFlexArray::~CFlexArray
//
//***************************************************************************
// ok
CFlexArray::~CFlexArray()
{
    HeapFree(GetProcessHeap(), 0, m_pArray);
}


//***************************************************************************
//
//  Copy constructor.
//  
//  Copies the pointers, not their contents.
//
//***************************************************************************
// ok

CFlexArray::CFlexArray(CFlexArray &Src)
{
    m_pArray = 0;
    m_nSize = 0;
    m_nExtent = 0;
    m_nGrowByPercent = 0;

    *this = Src;
}

//***************************************************************************
//
//  operator =
//
//  Assignment operator.
//
//  Arenas are not copied.  This allows transfer of arrays between arenas.
//  Arrays are copied by pointer only.
//
//***************************************************************************
// ok

CFlexArray& CFlexArray::operator=(CFlexArray &Src)
{
    m_nSize   = Src.m_nSize;
    m_nExtent = Src.m_nExtent;
    m_nGrowByPercent = Src.m_nGrowByPercent;

    HeapFree(GetProcessHeap(), 0, m_pArray);
    if(m_nExtent > 0)
    {
        m_pArray = 
           (void**)HeapAlloc(GetProcessHeap(), 0, sizeof(void *) * m_nExtent);

        // Check for allocation failures
        if ( NULL == m_pArray )
        {
            throw CX_MemoryException();
        }

    }
    else
        m_pArray = NULL;
    memcpy(m_pArray, Src.m_pArray, sizeof(void *) * m_nSize);
        
    return *this;    
}

//***************************************************************************
//
//  CFlexArray::RemoveAt
//
//  Removes the element at the specified location.  Does not
//  actually delete the pointer. Shrinks the array over the top of
//  the 'doomed' element.
//
//  Parameters:
//  <nIndex>    The location of the element.
//    
//  Return value:
//  range_error     The index is not legal.
//  no_error        Success.
//  
//***************************************************************************
// ok

int CFlexArray::RemoveAt(int nIndex)
{
    if (nIndex >= m_nSize)
        return range_error;

    // Account for the index being 0 based and size being 1 based
    MoveMemory( &m_pArray[nIndex], &m_pArray[nIndex+1], ( ( m_nSize - nIndex ) - 1 ) * sizeof(void *) );
    
    m_nSize--;
    m_pArray[m_nSize] = 0;

    return no_error;
}

int CFlexArray::EnsureExtent(int nExtent)
{
    if(m_nExtent < nExtent)
    {
        m_nExtent = nExtent;
        if(m_pArray)
        {
            register void** pTmp = (void **) HeapReAlloc(GetProcessHeap(), 0, m_pArray, sizeof(void *) * m_nExtent);
            if (pTmp == 0)
                return out_of_memory;
            m_pArray =  pTmp;
        }
        else
            m_pArray = (void **) HeapAlloc(GetProcessHeap(), 0, sizeof(void *) * m_nExtent);    
        if (!m_pArray)
            return out_of_memory;                
    }

    return no_error;
}
        
    
//***************************************************************************
//
//  CFlexArray::InsertAt
//
//  Inserts a new element at the specified location.  The pointer is copied.
//
//  Parameters:
//  <nIndex>        The 0-origin location at which to insert the new element.
//  <pSrc>          The pointer to copy. (contents are not copied).
//
//  Return value:
//  array_full
//  out_of_memory
//  no_error
//
//***************************************************************************
// ok

int CFlexArray::InsertAt(int nIndex, void *pSrc)
{
    // TEMP: fix for sparse functionality in stdprov
    // =============================================

    while(nIndex > m_nSize)
        Add(NULL);

    // If the array is full, we need to expand it.
    // ===========================================
    
    if (m_nSize == m_nExtent) {
        if (m_nGrowByPercent == 0)
            return array_full;
        register nTmpExtent = m_nExtent;
        m_nExtent += 1;
        m_nExtent *= (100 + m_nGrowByPercent);
        m_nExtent /= 100;

        if(m_pArray)
        {
            register void** pTmp = (void **) HeapReAlloc(GetProcessHeap(), 0, m_pArray, sizeof(void *) * m_nExtent);
            if (pTmp == 0)
            {
                m_nExtent = nTmpExtent; //Change it back, otherwise the extent could constantly grow even though  it keeps failing...
                return out_of_memory;
            }
            m_pArray =  pTmp;
        }
        else
            m_pArray = (void **) HeapAlloc(GetProcessHeap(), 0, sizeof(void *) * m_nExtent);    
        if (!m_pArray)
            return out_of_memory;                
    }

    // Special case of appending.  This is so frequent
    // compared to true insertion that we want to optimize.
    // ====================================================
    
    if (nIndex == m_nSize) {
        m_pArray[m_nSize++] = pSrc;
        return no_error;
    }
    
    // If here, we are inserting at some random location.
    // We start at the end of the array and copy all the elements 
    // one position farther to the end to make a 'hole' for
    // the new element.
    // ==========================================================

    // Account for nIndex being 0 based and m_nSize being 1 based
    MoveMemory( &m_pArray[nIndex+1], &m_pArray[nIndex], ( m_nSize - nIndex ) * sizeof(void *) );

    m_pArray[nIndex] = pSrc;
    m_nSize++;
            
    return no_error;    
}

void CFlexArray::Sort()
{
    if(m_pArray)
        qsort((void*)m_pArray, m_nSize, sizeof(void*), CFlexArray::CompareEls);
}

int __cdecl CFlexArray::CompareEls(const void* pelem1, const void* pelem2)
{
    return *(int*)pelem1 - *(int*)pelem2;
}
//***************************************************************************
//
//  CFlexArray::DebugDump
//
//***************************************************************************
void CFlexArray::DebugDump()
{
    printf("----CFlexArray Debug Dump----\n");
    printf("m_pArray = 0x%P\n", m_pArray);
    printf("m_nSize = %d\n", m_nSize);
    printf("m_nExtent = %d\n", m_nExtent);
    printf("m_nGrowByPercent = %d\n", m_nGrowByPercent);

    for (int i = 0; i < m_nExtent; i++)
    {
        if (i < m_nSize)
            printf("![%P] = %X\n", i, m_pArray[i]);
        else
            printf("?[%P] = %X\n", i, m_pArray[i]);                    
    }        
}

//***************************************************************************
//
//  CFlexArray::Compress
//
//  Removes NULL elements by moving all non-NULL pointers to the beginning
//  of the array.  The array "Size" changes, but the extent is untouched.
//
//***************************************************************************
// ok

void CFlexArray::Compress()
{
    int nLeftCursor = 0, nRightCursor = 0;
    
    while (nLeftCursor < m_nSize - 1) {
        if (m_pArray[nLeftCursor]) {
            nLeftCursor++;
            continue;
        }
        else {
            nRightCursor = nLeftCursor + 1;
            while (m_pArray[nRightCursor] == 0 && nRightCursor < m_nSize)
                nRightCursor++;
            if (nRightCursor == m_nSize)
                break;  // Short circuit, no more nonzero elements.
            m_pArray[nLeftCursor] = m_pArray[nRightCursor];
            m_pArray[nRightCursor] = 0;                                            
        }                    
    }
    
    Trim();
}    

void CFlexArray::Trim()
{
    while (m_nSize >  0 && m_pArray[m_nSize - 1] == NULL) m_nSize--;
}

//***************************************************************************
//
//  CFlexArray::Empty
//
//  Clears the array of all pointers (does not deallocate them) and sets
//  its apparent size to zero.
//
//***************************************************************************
// ok
void CFlexArray::Empty()
{
    HeapFree(GetProcessHeap(), 0, m_pArray);
    m_pArray = NULL;
    m_nSize = 0;
    m_nExtent = 0;
}

//***************************************************************************
//
//  CFlexArray::UnbindPtr
//
//  Empties the array and returns the pointer to the data it contained
//
//***************************************************************************

void** CFlexArray::UnbindPtr()
{
    void** pp = m_pArray;
    m_pArray = NULL;
    Empty();
    return pp;
}

//***************************************************************************
//
//  CFlexArray::CopyData
//
//  Copies the data but not the settings of another flexarray
//
//***************************************************************************

int CFlexArray::CopyDataFrom(const CFlexArray& aOther)
{
    // Check if there is enough room
    // =============================

    if(aOther.m_nSize > m_nExtent)
    {
        // Extend the array to the requisite size
        // ======================================

        m_nExtent = aOther.m_nSize;
        if(m_pArray)
        {
            register void** pTmp = (void **) HeapReAlloc(GetProcessHeap(), 0, m_pArray, sizeof(void *) * m_nExtent);
            if (pTmp == 0)
                return out_of_memory;
            m_pArray =  pTmp;
        }
        else
            m_pArray = (void **) HeapAlloc(GetProcessHeap(), 0, sizeof(void *) * m_nExtent);    
        if (!m_pArray)
            return out_of_memory;                
    }

    // Copy the data
    // =============

    m_nSize = aOther.m_nSize;
    memcpy(m_pArray, aOther.m_pArray, sizeof(void*) * m_nSize);
    return no_error;
}

//***************************************************************************
//
//  CWStringArray::CWStringArray
//
//  Constructs a wide-string array.
//
//  Parameters:
//  <nSize>         The starting preallocated size of the array.
//  <nGrowBy>       The amount to grow by when the array fills up.
//
//  Size() returns the number of elements in use, not the 'true' size.
//
//***************************************************************************

CWStringArray::CWStringArray(
        int nSize, 
        int nGrowBy
        )
        : 
        m_Array(nSize, nGrowBy)
{
}        

//***************************************************************************
//
//  Copy constructor.
//
//***************************************************************************

CWStringArray::CWStringArray(CWStringArray &Src)
{
    
    *this = Src;    
}

//***************************************************************************
//
//  Destructor.  Cleans up all the strings.
//
//***************************************************************************

CWStringArray::~CWStringArray()
{
    Empty();
}

//***************************************************************************
//
//  CWStringArray::DeleteStr
//
//  Frees the string at the specified index and sets the element to NULL.  
//  Does not compress array.
// 
//  Does not currently do a range check.
//
//  Parameters:
//  <nIndex>    The 0-origin index of the string to remove.
//
//  Return values:
//  no_error
//  
//***************************************************************************

int CWStringArray::DeleteStr(int nIndex)
{
    HeapFree(GetProcessHeap(), 0, m_Array[nIndex]);
    m_Array[nIndex] = 0;
    return no_error;
}   

//***************************************************************************
//
//  CWStringArray::FindStr
//
//  Finds the specified string and returns its location.
//
//  Parameters:
//  <pTarget>       The string to find.
//  <nFlags>        <no_case> or <with_case>
//  
//  Return value:
//  The 0-origin location of the string, or -1 if not found.
//
//***************************************************************************

int CWStringArray::FindStr(const wchar_t *pTarget, int nFlags)
{
    if (nFlags == no_case) {
        for (int i = 0; i < m_Array.Size(); i++)
            if (wbem_wcsicmp((wchar_t *) m_Array[i], pTarget) == 0)
                return i;
    }
    else {
        for (int i = 0; i < m_Array.Size(); i++)
            if (wcscmp((wchar_t *) m_Array[i], pTarget) == 0)
                return i;
    }
    return not_found;
}

//***************************************************************************
//
//  operator =
//  
//***************************************************************************

//  Heap handle & allocation functions are not copied. This allows
//  transfer of arrays between heaps.
         
CWStringArray& CWStringArray::operator =(CWStringArray &Src)
{
    Empty();
    
    for (int i = 0; i < Src.Size(); i++) 
    {
        wchar_t *pSrc = (wchar_t *) Src.m_Array[i];
        wchar_t *pCopy = (wchar_t *) HeapAlloc(GetProcessHeap, 0, (wcslen(pSrc) + 1) * 2);

        // Check for allocation failures
        if ( NULL == pCopy )
        {
            throw CX_MemoryException();
        }

        wcscpy(pCopy, pSrc);

        if ( m_Array.Add(pCopy) != CFlexArray::no_error )
        {
            throw CX_MemoryException();
        }
    }

    return *this;
}

//***************************************************************************
//
//  CWStringArray::Add
//
//  Appends a new string to the end of the array.
//
//  Parameters:
//  <pSrc>      The string to copy.
//
//  Return value:
//  The return values of CFlexArray::Add.
//  
//***************************************************************************
    
int CWStringArray::Add(const wchar_t *pSrc)
{
    wchar_t *pNewStr = (wchar_t *) HeapAlloc(GetProcessHeap(), 0, (wcslen(pSrc) + 1) * 2);

    // Check for allocation failures
    if ( NULL == pNewStr )
    {
        return out_of_memory;
    }

    wcscpy(pNewStr, pSrc);
    return m_Array.Add(pNewStr);
}
//***************************************************************************
//
//  CWStringArray::InsertAt
//
//  Inserts a copy of a string in the array.
//
//  Parameters:
//  <nIndex>    The 0-origin location at which to insert the string.
//  <pSrc>      The string to copy.
//
//  Return values:
//  The return values of CFlexArray::InsertAt
//
//***************************************************************************

int CWStringArray::InsertAt(int nIndex, const wchar_t *pSrc)
{
    wchar_t *pNewStr = (wchar_t *) HeapAlloc(GetProcessHeap(), 0, (wcslen(pSrc) + 1) * 2);

    // Check for allocation failures
    if ( NULL == pNewStr )
    {
        return out_of_memory;
    }

    wcscpy(pNewStr, pSrc);
    return m_Array.InsertAt(nIndex, pNewStr);
}


//***************************************************************************
//
//  CWStringArray::RemoveAt
//
//  Removes and deallocates the string at the specified location.
//  Shrinks the array.
//
//  Parameters:
//  <nIndex>    The 0-origin index of the 'doomed' string.
//  
//  Return value:
//  Same as CFlexArray::RemoveAt.
//
//***************************************************************************

int CWStringArray::RemoveAt(int nIndex)
{
    wchar_t *pDoomedString = (wchar_t *) m_Array[nIndex];
    HeapFree(GetProcessHeap, 0, pDoomedString);
    return m_Array.RemoveAt(nIndex);
}

//***************************************************************************
//
//  CWStringArray::SetAt
//
//  Replaces the string at the targeted location with the new one.
//  The old string at the location is cleaned up.
//
//  No range checking or out-of-memory checks at present.
//
//  Parameters:
//  <nIndex>        The 0-origin location at which to replace the string.
//  <pSrc>          The string to copy.  
//
//  Return value:
//  no_error
//   
//***************************************************************************

int CWStringArray::SetAt(int nIndex, const wchar_t *pSrc)
{
    wchar_t *pNewStr = (wchar_t *) HeapAlloc(GetProcessHeap(), 0, (wcslen(pSrc) + 1) * 2);
    // Check for allocation failures
    if ( NULL == pNewStr )
    {
        return out_of_memory;
    }

    wchar_t *pDoomedString = (wchar_t *) m_Array[nIndex];
    if (pDoomedString)
        delete [] pDoomedString;

    wcscpy(pNewStr, pSrc);
    m_Array[nIndex] = pNewStr;

    return no_error;
}

//***************************************************************************
//
//  CWStringArray::ReplaceAt
//
//  Directly replaces the pointer at the specified location with the
//  one in the parameter.   No copy or cleanup.
//
//  Parameters:
//  <nIndex>     The 0-origin location at which to replace.
//  <pSrc>       The new pointer to copy over the old one.
//
//  Return value:
//  no_error        (No checking done at present).
//  
//***************************************************************************

int CWStringArray::ReplaceAt(int nIndex, wchar_t *pSrc)
{
    m_Array[nIndex] = pSrc;
    return no_error;
}



//***************************************************************************
//
//  CWStringArray::Empty
//
//  Empties the array, deallocates all strings, and sets the apparent
//  array size to zero.
//
//***************************************************************************

void CWStringArray::Empty()
{
    for (int i = 0; i < m_Array.Size(); i++)
        HeapFree(GetProcessHeap(), 0, m_Array[i]);
    m_Array.Empty();        
}

//***************************************************************************
//
//  CWStringArray::Sort
//
//  Sorts the array according to UNICODE order.  
//  (Shell sort).
//
//***************************************************************************
void CWStringArray::Sort()
{
    for (int nInterval = 1; nInterval < m_Array.Size() / 9; nInterval = nInterval * 3 + 1);    

    while (nInterval) 
    {
        for (int iCursor = nInterval; iCursor < m_Array.Size(); iCursor++) 
        {
            int iBackscan = iCursor;
            while (iBackscan - nInterval >= 0 &&
               wbem_wcsicmp((const wchar_t *) m_Array[iBackscan],
                    (const wchar_t *) m_Array[iBackscan-nInterval]) < 0) 
            {
                wchar_t *pTemp = (wchar_t *) m_Array[iBackscan - nInterval];
                m_Array[iBackscan - nInterval] = m_Array[iBackscan];
                m_Array[iBackscan] = pTemp;
                iBackscan -= nInterval;
            }
        }
        nInterval /= 3;
    }
}


//***************************************************************************
//
//  CWStringArray::Difference
//
//  Set-theoretic difference operation on the arrays.
//  
//  Parameters:
//  <Src1>      First array (not modified).
//  <Src2>      Second array which is 'subtracted' from first (not modified).    
//  <Diff>      Receives the difference.  Should be an empty array on entry.
//
//***************************************************************************
void CWStringArray::Difference(
    CWStringArray &Src1, 
    CWStringArray &Src2,
    CWStringArray &Diff
    )
{
    for (int i = 0; i < Src1.Size(); i++)
    {
        if (Src2.FindStr(Src1[i], no_case) == -1)
        {
            if ( Diff.Add(Src1[i]) != no_error )
            {
                throw CX_MemoryException();
            }
        }
    }
}

//***************************************************************************
//
//  CWStringArray::Intersection
//
//  Set-theoretic intersection operation on the arrays.
//  
//  Parameters:
//  <Src1>      First array (not modified).
//  <Src2>      Second array (not modified).    
//  <Diff>      Receives the intersection.  Should be an empty array on entry.

//***************************************************************************

void CWStringArray::Intersection(
    CWStringArray &Src1,
    CWStringArray &Src2,
    CWStringArray &Output
    )
{
    for (int i = 0; i < Src1.Size(); i++)
    {
        if (Src2.FindStr(Src1[i], no_case) != -1)
        {
            if ( Output.Add(Src1[i]) != no_error )
            {
                throw CX_MemoryException();
            }
        }

    }
}    

//***************************************************************************
//
//  CWStringArray::Union
//
//  Set-theoretic union operation on the arrays.
//  
//  Parameters:
//  <Src1>      First array (not modified).
//  <Src2>      Second array (not modified).    
//  <Diff>      Receives the union.  Should be an empty array on entry.
//
//***************************************************************************

void CWStringArray::Union(
    CWStringArray &Src1,
    CWStringArray &Src2,
    CWStringArray &Output
    )
{
    Output = Src1;
    for (int i = 0; i < Src2.Size(); i++)
    {
        if (Output.FindStr(Src2[i], no_case) == not_found)
        {
            if ( Output.Add(Src2[i]) != no_error )
            {
                throw CX_MemoryException();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemtest\wt_flexarry.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FLEXARRAY.H

Abstract:

  CFlexArray and CWStringArray implementation.

  These objects can operate from any allocator, and be constructed
  on arbitrary memory blocks.

History:

  11-Apr-96   a-raymcc    Created.

--*/

#ifndef _FLEXARRY_H_
#define _FLEXARRY_H_

//***************************************************************************
//
//  class CFlexArray
//
//  This class is a generic pointer array.
//
//***************************************************************************

class CFlexArray
{
protected:
    int m_nSize;            // apparent size
    int m_nExtent;          // de facto size
    int m_nGrowByPercent;          
    void** m_pArray;
            
public:
    enum { no_error, failed, out_of_memory, array_full, range_error };

    // Constructs a flex array at an initial size and
    // specifies the initial size and growth-size chunk.
    // =================================================
    CFlexArray(
        IN int nInitialSize = 0, 
        IN int nGrowByPercent = 100
        );

   ~CFlexArray(); 
    CFlexArray(CFlexArray &);
    CFlexArray& operator=(CFlexArray &);

    int CopyDataFrom(const CFlexArray& aOther);
    int EnsureExtent(int nExtent);

    // Gets an element at a particular location.
    // =========================================
    inline void *  GetAt(int nIndex) const { return m_pArray[nIndex]; }

    // Returns a ptr in the array; allows use on left-hand side of assignment.
    // =======================================================================
    inline void * operator[](int nIndex) const { return m_pArray[nIndex]; }
    inline void *& operator[](int nIndex) { return m_pArray[nIndex]; }

    // Sets the element at the requested location.
    // ===========================================
    void inline SetAt(int nIndex, void *p) { m_pArray[nIndex] = p; }

    // Removes an element.
    // ====================
    int   RemoveAt(int nIndex);

    // Inserts an element.
    // ===================
    int   InsertAt(int nIndex, void *);

    // Removes all zero entries (null ptrs) and shrinks the array size.
    // ================================================================
    void  Compress();    

    // Removes all zero entries from the end of the array and shrinks it
    // =================================================================

    void Trim();

    // Adds a new element to the end of the array.
    // ===========================================
    int inline Add(void *pSrc) { return InsertAt(m_nSize, pSrc); }    

    // Gets the apparent size of the array (number of used elements)
    // =============================================================
    int inline Size() const { return m_nSize; }

    // Sets the apparent size of the array
    // ===================================
    void inline SetSize(int nNewSize) { m_nSize = nNewSize;}

    // Removes all entries and reduces array size to zero. The elements
    // are simply removed; not deallocated (this class doesn't know what
    // they are).
    // =================================================================
    void  Empty();

    // Gets a pointer to the internal array.
    // =====================================
    inline void**  GetArrayPtr() { return m_pArray; }
    inline void* const*  GetArrayPtr() const { return m_pArray; }
    
    // Gets a pointer to the internal array and Resets the contents to none
    // ====================================================================

    void** UnbindPtr();

    // For debugging.
    // ==============
    void  DebugDump();

    void Sort();

protected:
    static int __cdecl CompareEls(const void* pelem1, const void* pelem2);
};

//***************************************************************************
//
//  class CWStringArray
//
//  This class is a generic wide-string array.
//
//***************************************************************************


class CWStringArray
{
    CFlexArray m_Array;
    
public:
    enum { no_error, failed, out_of_memory, array_full, range_error };
    enum { not_found = -1, no_case, with_case };
        
    CWStringArray(
        int nSize = 0, 
        int nGrowBy = 100
        );

    CWStringArray(CWStringArray &Src);
   ~CWStringArray();
            
    CWStringArray& operator =(CWStringArray &Src);

    // Gets the read-only ptr to the string at the requested index.
    // =============================================================    
    inline wchar_t *GetAt(int nIndex) const { return (wchar_t *) m_Array[nIndex]; }

    // Same as GetAt().
    // ================
    inline wchar_t *operator[](int nIndex) const{ return (wchar_t *) m_Array[nIndex]; }

    // Appends a new element to the end of the array. Copies the param.
    // ================================================================
    int  Add(const wchar_t *pStr);

    // Inserts a new element within the array.
    // =======================================
    int  InsertAt(int nIndex, const wchar_t *pStr);

    // Removes an element at the specified index.  Takes care of
    // cleanup.
    // =========================================================
    int  RemoveAt(int nIndex);

    // Inserts a copy of <pStr> at that location after removing
    // the prior string and deallocating it.
    // ========================================================
    int  SetAt(int nIndex, const wchar_t *pStr);

    // Directly replaces the pointer at the specified location
    // with the ptr value in <pStr>. No allocs or deallocs are done.
    // =============================================================
    int  ReplaceAt(int nIndex, wchar_t *pStr);
        // Unchecked replacement

    // Deletes the string at the location and sets the entry to zero
    // without compressing the array.
    // =============================================================
    int  DeleteStr(int nIndex);  

    // Returns the 'apparent' size of the array.
    // =========================================
    inline int  Size() const { return m_Array.Size(); }

    // Empties the array by cleaning up after all strings and
    // setting the size to zero.
    // ======================================================
    void Empty();

    // Locates a string or returns -1 if not found.
    // ============================================
    int  FindStr(const wchar_t *pTarget, int nFlags);  

    // Compresses the array by removing all zero elements.
    // ===================================================
    inline void Compress() { m_Array.Compress(); }

    // Sorts the array according to UNICODE order.
    // ===========================================
    void Sort();

    inline LPCWSTR*  GetArrayPtr() { return (LPCWSTR*) m_Array.GetArrayPtr(); }

    // Standard set-theoretic operations.
    // ==================================
    static void Difference(
        CWStringArray &Src1, 
        CWStringArray &Src2,
        CWStringArray &Diff
        );

    static void Intersection(
        CWStringArray &Src1,
        CWStringArray &Src2,
        CWStringArray &Output
        );

    static void Union(
        CWStringArray &Src1,
        CWStringArray &Src2,
        CWStringArray &Output
        );
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemtest\wt_safearry.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SAFEARRY.H

Abstract:

  CSafeArray implementation.

History:

	08-Apr-96   a-raymcc    Created.
	18-Mar-99	a-dcrews	Added out-of-memory exception handling

--*/

#ifndef _SAFEARRY_H_
#define _SAFEARRY_H_


typedef union 
{ 
    double dblVal; 
    float fltVal; 
    short iVal; 
    long lVal; 
    BYTE bVal; 
    VARIANT_BOOL boolVal;
}   SA_ArrayScalar;            

// Conversion functions due to VC 5.0 Optimizer Problems
inline SA_ArrayScalar ToSA_ArrayScalar( double dblVal )
{	SA_ArrayScalar sa;	sa.dblVal = dblVal;	return sa;	}

inline SA_ArrayScalar ToSA_ArrayScalar( float fltVal )
{	SA_ArrayScalar sa;	sa.fltVal = fltVal;	return sa;	}

inline SA_ArrayScalar ToSA_ArrayScalar( short iVal )
{	SA_ArrayScalar sa;	sa.iVal = iVal;	return sa;	}

inline SA_ArrayScalar ToSA_ArrayScalar( long lVal )
{	SA_ArrayScalar sa;	sa.lVal = lVal;	return sa;	}

inline SA_ArrayScalar ToSA_ArrayScalar( BYTE bVal )
{	SA_ArrayScalar sa;	sa.bVal = bVal;	return sa;	}

inline SA_ArrayScalar ToSA_ArrayScalarBool( VARIANT_BOOL boolVal )
{	SA_ArrayScalar sa;	sa.boolVal = boolVal;	return sa;	}


class  CSafeArray
{
    int m_nMaxElementUsed;
    int m_nFlags;
    int m_nGrowBy;
    int m_nStatus;
    int m_nVarType;
    SAFEARRAYBOUND m_bound;    
    SAFEARRAY *m_pArray;
    
    void Empty();                    // Empty array
    void Fatal(const char *);
    void CheckType(int n);
    int  AddScalar(IN SA_ArrayScalar val);
    int  SetScalarAt(IN int nIndex, IN SA_ArrayScalar val);
    SA_ArrayScalar GetScalarAt(IN int nIndex);
        
public:
    enum { no_error, failed, range_error };
    enum { no_delete = 0x1, auto_delete = 0x2, bind = 0x4 };

    
    // Construction, destruction, and assignment.
    // ==========================================
        
    CSafeArray(
        IN int vt, 
        IN int nFlags,          // no_delete|auto_delete
        IN int nSize = 32, 
        IN int nGrowBy = 32
        );

    CSafeArray(
        IN SAFEARRAY *pSrc, 
        IN int nType,           // VT_ type of SAFEARRAY.
        IN int nFlags,          // no_delete|auto_delete [|bind]
        IN int nGrowBy = 32
        );

    CSafeArray &operator =(IN CSafeArray &Src);
    CSafeArray(IN CSafeArray &Src);
   ~CSafeArray();
    
    // Get functions.
    // ==============    

    BYTE    GetByteAt(IN int nIndex)
        { return GetScalarAt(nIndex).bVal; }
    LONG    GetLongAt(IN int nIndex)
        { return GetScalarAt(nIndex).lVal; }
    SHORT   GetShortAt(IN int nIndex)
        { return GetScalarAt(nIndex).iVal; }
    double  GetDoubleAt(IN int nIndex)
        { return GetScalarAt(nIndex).dblVal; }
    float   GetFloatAt(IN int nIndex)
        { return GetScalarAt(nIndex).fltVal; }
    VARIANT_BOOL GetBoolAt(IN int nIndex)
        { return GetScalarAt(nIndex).boolVal; }        

    BSTR    GetBSTRAt(IN int nIndex);          // Caller must use SysFreeString
    VARIANT GetVariantAt(IN int nIndex);      // 
    IDispatch* GetDispatchAt(IN int nIndex);
    IUnknown* GetUnknownAt(IN int nIndex);

    // Set functions.
    // ==============
        
    int SetByteAt(IN int nIndex, IN BYTE byVal)
        { return SetScalarAt(nIndex, ToSA_ArrayScalar(byVal)); }
    int SetLongAt(IN int nIndex, IN LONG lVal)
        { return SetScalarAt(nIndex, ToSA_ArrayScalar(lVal)); }
    int SetFloatAt(IN int nIndex, IN float fltVal)
        { return SetScalarAt(nIndex, ToSA_ArrayScalar(fltVal)); }
    int SetDoubleAt(IN int nIndex, IN double dVal)
        { return SetScalarAt(nIndex, ToSA_ArrayScalar(dVal)); }    
    int SetShortAt(IN int nIndex, IN SHORT iVal)
        { return SetScalarAt(nIndex, ToSA_ArrayScalar(iVal)); }        
    int SetBoolAt(IN int nIndex, IN VARIANT_BOOL boolVal)
        { return SetScalarAt(nIndex, ToSA_ArrayScalarBool(boolVal)); }        

    int SetBSTRAt(IN int nIndex, IN BSTR Str);     // A copy of the BSTR is made
    int SetVariantAt(IN int nIndex, IN VARIANT *pSrc);
    int SetDispatchAt(IN int nIndex, IN IDispatch* pDisp);
    int SetUnknownAt(IN int nIndex, IN IUnknown* pUnk);
    
    // Add (append) functions.
    // =======================
    
    int AddByte(IN BYTE byVal)  { return AddScalar(ToSA_ArrayScalar(byVal)); }
    int AddLong(IN LONG lVal)   { return AddScalar(ToSA_ArrayScalar(lVal)); }
    int AddFloat(IN float fltVal) { return AddScalar(ToSA_ArrayScalar(fltVal)); }
    int AddDouble(IN double dVal) { return AddScalar(ToSA_ArrayScalar(dVal)); }
    int AddShort(IN SHORT iVal)  { return AddScalar(ToSA_ArrayScalar(iVal)); }
    int AddBool(IN VARIANT_BOOL boolVal) { return AddScalar(ToSA_ArrayScalarBool(boolVal)); }
    int AddBSTR(IN BSTR Str);
    int AddVariant(IN VARIANT *pData);
    int AddDispatch(IN IDispatch* pDisp);
    int AddUnknown(IN IUnknown* pUnk);
    
    // Operations the array as a whole. 
    // ================================

    int RemoveAt(IN int nIndex);                    
    int Size()    { return m_nMaxElementUsed + 1; }
    int GetType() { return m_nVarType; }
    int Status()  { return m_nStatus; }
    int Trim();                    
    void SetGrowGranularity(IN int n)  { m_nGrowBy = n; }
    void SetDestructorPolicy(IN int n) { m_nFlags = n; }   // auto_delete|no_delete
            
    SAFEARRAY *GetArrayCopy();                 // Returns a copy of the array
    SAFEARRAY *GetArray() { return m_pArray; }

    int TextDump(IN FILE *fStream);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemtest\wt_safearry.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SAFEARRY.CPP

Abstract:

  CSafeArray implementation.

  Notes:
  (1) Support only for arrays with origin at 0 or 1.
      Can VB deal with a SAFEARRAY of origin zero?

  (2) Support only for the following OA types:
        VT_BSTR, VT_VARIANT,
        VT_UI1, VT_I2, VT_I4, VT_R8

History:

    08-Apr-96   a-raymcc    Created.
    18-Mar-99   a-dcrews    Added out-of-memory exception handling

--*/

#include "precomp.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <WT_safearry.h>
#include <WT_arrtempl.h>

typedef struct 
{
    DWORD m_nMaxElementUsed;
    DWORD m_nFlags;
    DWORD m_nGrowBy;
    DWORD m_nStatus;
    DWORD m_nVarType;
    SAFEARRAYBOUND m_bound;    
}   PersistHeaderBlock;


//***************************************************************************
//  
//  CSafeArray::CheckType
//
//  Verifies that the constructor is being invoked with a supported type.
//
//  PARAMETERS:
//  nTest
//      One of the supported OLE VT_ constants.
//
//***************************************************************************
void CSafeArray::CheckType(int nTest)
{
    if (nTest != VT_BSTR &&
        nTest != VT_VARIANT &&
        nTest != VT_UI1 &&
        nTest != VT_I2 &&
        nTest != VT_I4 &&
        nTest != VT_R4 &&
        nTest != VT_R8 &&
        nTest != VT_BOOL &&
        nTest != VT_DISPATCH &&
        nTest != VT_UNKNOWN        
        )
        Fatal("Caller attempted to use unsupported OLE Automation Type (VT_*)");
}

//***************************************************************************
//
//  CSafeArray::CSafeArray
//
//  Constructor which creates a new SAFEARRAY.
//
//  PARAMETERS:
//  vt
//      An OLE VT_ type indicator, indicating the element type.
//  nFlags
//      The destruct policy, either <no_delete> or <auto_delete>.  With
//      <no_delete>, the underlying SAFEARRAY is not deallocated, whereas
//      with <auto_delete> the destructor destroys the SAFEARRAY.
//  nSize
//      The initial size of the SAFEARRAY.
//  nGrowBy
//      The amount the SAFEARRAY should grow by when the user attempts to
//      add elements to a full array.
//
//***************************************************************************

CSafeArray::CSafeArray(
    IN int vt,
    IN int nFlags,
    IN int nSize,
    IN int nGrowBy
    )
{
    CheckType(vt);

    m_nMaxElementUsed = -1;
    m_nFlags = nFlags;
    m_nGrowBy = nGrowBy;
    m_nVarType = vt;

    // Allocate the array.
    // ===================

    m_bound.cElements = nSize;
    m_bound.lLbound = 0;

    m_pArray = SafeArrayCreate(vt, 1, &m_bound);

    if (m_pArray == 0)
        m_nStatus = failed;
    else
        m_nStatus = no_error;
}

//***************************************************************************
//
//  CSafeArray::CSafeArray
//
//  Constructor based on an existing SAFEARRAY.
//
//  PARAMETERS:
//  pSrc
//      A pointer to an existing SAFEARRAY which is used as a source
//      during object construction.
//  nType
//      One of the OLE VT_ type indicators.
//  nFlags
//      OR'ed Bit flags indicating the bind vs. copy, and the 
//      object destruct policy.
//
//      The destruct policy is either <no_delete> or <auto_delete>.  With
//      <no_delete>, the underlying SAFEARRAY is not deallocated, whereas
//      with <auto_delete> the destructor destroys the SAFEARRAY.
//
//      Binding is indicated by <bind>, in which case the SAFEARRAY
//      pointed to by <pSrc> becomes the internal SAFEARRAY of the
//      object.  Otherwise, this constructor makes a new copy of the
//      SAFEARRAY for internal use.
//  nGrowBy
//      How much to grow the array by when it fills and the user attempts
//      to add more elements.  This allows the array to grow in chunks
//      so that continuous Add() operations do not operate slowly on
//      large arrays.
//
//***************************************************************************

CSafeArray::CSafeArray(
    IN SAFEARRAY *pSrcCopy,
    IN int nType,
    IN int nFlags,
    IN int nGrowBy
    )
{
    m_nStatus = no_error;

    CheckType(nType);

    // Verify that this is only a 1-dimensional array.
    // ===============================================

    if (1 != SafeArrayGetDim(pSrcCopy))
        m_nStatus = failed;

    // Now copy the source or 'bind' the incoming array.
    // ====================================================

    if (nFlags & bind)
        m_pArray = pSrcCopy;
    else if (SafeArrayCopy(pSrcCopy, &m_pArray) != S_OK)
        m_nStatus = failed;

    // Get bound information.
    // ======================

    LONG uBound = 0;
    if (S_OK != SafeArrayGetUBound(m_pArray, 1, &uBound))
        m_nStatus = failed;

    // Correct the Upper Bound into a size.
    // ====================================

    m_bound.cElements = uBound + 1;
    m_bound.lLbound = 0;
    m_nMaxElementUsed = uBound;
    m_nVarType = nType;
    m_nGrowBy = nGrowBy;
    m_nFlags = nFlags & 3;  // Mask out the acquire & copy bits.
}


//***************************************************************************
//
//  CSafeArray::GetScalarAt
//
//  For class internal use.  This function returns the element at
//  the specified index.
//  
//  PARAMETERS:
//  nIndex
//      The index at which to retrieve the scalar.
//
//  RETURN VALUE:
//  The scalar at the specified the location.
//
//***************************************************************************
SA_ArrayScalar CSafeArray::GetScalarAt(IN int nIndex)
{
    SA_ArrayScalar retval = {0};

    // Check for out-of-range condition.
    // =================================

    if (nIndex > m_nMaxElementUsed + 1)
        return retval;

    SafeArrayGetElement(m_pArray, (long *) &nIndex, &retval);
    return retval;
}


//***************************************************************************
//
//  CSafeArray assignment operator.
//
//***************************************************************************

CSafeArray& CSafeArray::operator =(IN CSafeArray &Src)
{
    Empty();

    m_nMaxElementUsed = Src.m_nMaxElementUsed;
    m_nFlags = Src.m_nFlags;
    m_nGrowBy = Src.m_nGrowBy;
    m_nStatus = Src.m_nStatus;
    m_nVarType = Src.m_nVarType;
    m_bound = Src.m_bound;

    if (SafeArrayCopy(Src.m_pArray, &m_pArray) != S_OK)
        m_nStatus = failed;

    return *this;
}

//***************************************************************************
//
//  Copy constructor.
//
//  This is implemented primarily via the assignment operator.
//
//***************************************************************************

CSafeArray::CSafeArray(CSafeArray &Src)
{
    m_nMaxElementUsed = 0;
    m_nFlags = 0;
    m_nGrowBy = 0;
    m_nStatus = no_error;
    m_nVarType = VT_NULL;
    m_pArray = 0;
    m_bound.cElements = 0;
    m_bound.lLbound = 0;

    *this = Src;
}


//***************************************************************************
//
//  CSafeArray::Add
//
//  Adds the BSTR to the array, growing the array if required.
//
//  PARAMETERS:
//  Src
//      The source BSTR to add to the array.  If NULL, then a
//      blank string is added by the underlying SAFEARRAY implementation.
//      (there is no way to prevent this).  This can point to 
//      an LPWSTR as well.
//
//  RETURN VALUE:
//  <no_error> or <failed>.
//
//***************************************************************************

int CSafeArray::AddBSTR(IN BSTR Src)
{
    // If there is no more room in the array, then expand it.
    // ======================================================

    if (m_nMaxElementUsed == (int) m_bound.cElements - 1) {

        if (m_nGrowBy == 0)
            return range_error;

        m_bound.cElements += m_nGrowBy;

        if (S_OK != SafeArrayRedim(m_pArray, &m_bound))
            m_nStatus = failed;
    }

    m_nMaxElementUsed++;

    BSTR Copy = SysAllocString(Src);
    CSysFreeMe auto1(Copy);

    if (SafeArrayPutElement(m_pArray, (long *) &m_nMaxElementUsed, Copy) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CSafeArray::AddVariant
//
//  Adds the specified VARIANT to the array.
//
//  PARAMETERS:
//  pSrc
//      A pointer to the source VARIANT, which is copied.
//
//  RETURN VALUE:
//  range_error, failed, no_error
//
//***************************************************************************

int CSafeArray::AddVariant(IN VARIANT *pSrc)
{
    // If there is no more room in the array, then expand it.
    // ======================================================

    if (m_nMaxElementUsed == (int) m_bound.cElements - 1) {

        if (m_nGrowBy == 0)
            return range_error;
            
        m_bound.cElements += m_nGrowBy;

        if (S_OK != SafeArrayRedim(m_pArray, &m_bound))
            m_nStatus = failed;
    }

    m_nMaxElementUsed++;

    if (SafeArrayPutElement(m_pArray, (long *) &m_nMaxElementUsed, pSrc) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CSafeArray::AddDispatch
//
//  Adds the specified IDispatch* to the array.
//
//  PARAMETERS:
//  pSrc
//      A pointer to the source IDispatch*, which is AddRefed.
//
//  RETURN VALUE:
//  range_error, failed, no_error
//
//***************************************************************************

int CSafeArray::AddDispatch(IN IDispatch *pDisp)
{
    // If there is no more room in the array, then expand it.
    // ======================================================

    if (m_nMaxElementUsed == (int) m_bound.cElements - 1) {

        if (m_nGrowBy == 0)
            return range_error;
            
        m_bound.cElements += m_nGrowBy;

        if (S_OK != SafeArrayRedim(m_pArray, &m_bound))
            m_nStatus = failed;
    }

    m_nMaxElementUsed++;

    if (SafeArrayPutElement(m_pArray, (long *) &m_nMaxElementUsed, pDisp) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CSafeArray::AddUnknown
//
//  Adds the specified IUnknown* to the array.
//
//  PARAMETERS:
//  pSrc
//      A pointer to the source IUnknown*, which is AddRefed.
//
//  RETURN VALUE:
//  range_error, failed, no_error
//
//***************************************************************************

int CSafeArray::AddUnknown(IN IUnknown *pUnk)
{
    // If there is no more room in the array, then expand it.
    // ======================================================

    if (m_nMaxElementUsed == (int) m_bound.cElements - 1) {

        if (m_nGrowBy == 0)
            return range_error;
            
        m_bound.cElements += m_nGrowBy;

        if (S_OK != SafeArrayRedim(m_pArray, &m_bound))
            m_nStatus = failed;
    }

    m_nMaxElementUsed++;

    if (SafeArrayPutElement(m_pArray, (long *) &m_nMaxElementUsed, pUnk) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}



//***************************************************************************
//
//  CSafeArray::GetBSTRAt
//
//  If the array type is VT_BSTR, this returns the string at the specified
//  index.
//
//  PARAMETERS:
//  nIndex
//      The array index for which the string is requried.
//
//  RETURN VALUE:
//  A dynamically allocated BSTR which must be freed with SysFreeString.
//  NULL is returned on error. If NULL was originally added at this
//  location, a string with zero length will be returned, which still
//  must be freed with SysFreeString.
//
//***************************************************************************

BSTR CSafeArray::GetBSTRAt(int nIndex)
{
    BSTR StrPtr = 0;

    if (nIndex >= (int) m_bound.cElements)
        return NULL;

    if (S_OK != SafeArrayGetElement(m_pArray, (long *) &nIndex, &StrPtr))
        return NULL;

    return StrPtr;
}


//***************************************************************************
//
//  CSafeArray::GetVariantAt
//
//  PARAMETERS:
//  nIndex
//      The array index from which to retrieve the VARIANT.
//  
//  RETURN VALUE:
//  Returns a new VARIANT at the specified location.  The receiver must
//  call VariantClear() on this VARIANT when it is no longer used.
//
//***************************************************************************

VARIANT CSafeArray::GetVariantAt(int nIndex)
{
    VARIANT Var;
    VariantInit(&Var);

    if (nIndex >= (int) m_bound.cElements)
        return Var;

    if (S_OK != SafeArrayGetElement(m_pArray, (long *) &nIndex, &Var))
        return Var;

    return Var;
}

//***************************************************************************
//
//  CSafeArray::GetDispatchAt
//
//  PARAMETERS:
//  nIndex
//      The array index from which to retrieve the IDispatch*.
//  
//  RETURN VALUE:
//  Returns the IDispatch* at the specified location.  The receiver must
//  call Release on this pointer (if not NULL) when it is no longer used.
//
//***************************************************************************

IDispatch* CSafeArray::GetDispatchAt(int nIndex)
{
    IDispatch* pDisp;
    if (nIndex >= (int) m_bound.cElements)
        return NULL;

    if (S_OK != SafeArrayGetElement(m_pArray, (long *) &nIndex, &pDisp))
        return NULL;

    return pDisp;
}

//***************************************************************************
//
//  CSafeArray::GetUnknownAt
//
//  PARAMETERS:
//  nIndex
//      The array index from which to retrieve the IUnknown*.
//  
//  RETURN VALUE:
//  Returns the IUnknown* at the specified location.  The receiver must
//  call Release on this pointer (if not NULL) when it is no longer used.
//
//***************************************************************************

IUnknown* CSafeArray::GetUnknownAt(int nIndex)
{
    IUnknown* pUnk;
    if (nIndex >= (int) m_bound.cElements)
        return NULL;

    if (S_OK != SafeArrayGetElement(m_pArray, (long *) &nIndex, &pUnk))
        return NULL;

    return pUnk;
}

//***************************************************************************
//
//  CSafeArray::SetAt
//
//  Replaces the BSTR value at the specified array index.   The original
//  BSTR value is automatically deallocated and replaced by the new value.
//  You can only call this to replace an existing element or to add a
//  new element to the end (one position past the last element).  If the
//  array size is 10, you can call this with 0..10, but not 11 or higher.
//
//  PARAMETERS:
//  nIndex
//      The position at which to replace the element.
//  Str
//      The new string.
//  nFlags
//      If <acquire> this function acquires ownership of the string and
//      can delete it.  Otherwise, the caller retains ownership of the
//      string.
//
//  RETURN VALUE:
//  no_error
//  range_error
//  failed
//
//***************************************************************************
int CSafeArray::SetBSTRAt(
    IN int nIndex,
    IN BSTR Str
    )
{
    // Check for out-of-range condition.
    // =================================

    if (nIndex > m_nMaxElementUsed + 1)
        return range_error;

    // Check to see if we are adding a new element.
    // ============================================

    if (nIndex == m_nMaxElementUsed + 1)
        return AddBSTR(Str);

    BSTR Copy = SysAllocString(Str);
    CSysFreeMe auto1(Copy);

    // If here, we are replacing an element.
    // =====================================

    if (SafeArrayPutElement(m_pArray, (long *) &nIndex, Copy) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CSafeArray::SetVariantAt
//
//  Sets the VARIANT at the specified index.
//
//  PARAMETERS:
//  nIndex
//      The index at which to set the VARIANT.  The original contents
//      at this location are automatically deallocated and replaced.
//  pVal
//      Used as the source of the new value.  This is treated as read-only.
//  
//  RETURN VALUE:
//  no_error, failed, range_error
//      
//***************************************************************************
int CSafeArray::SetVariantAt(
    IN int nIndex,
    IN VARIANT *pVal
    )
{
    // Check for out-of-range condition.
    // =================================

    if (nIndex > m_nMaxElementUsed + 1)
        return range_error;

    // Check to see if we are adding a new element.
    // ============================================

    if (nIndex == m_nMaxElementUsed + 1)
        return AddVariant(pVal);

    // If here, we are replacing an element.
    // =====================================

    if (SafeArrayPutElement(m_pArray, (long *) &nIndex, pVal) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CSafeArray::SetDispatchAt
//
//  Sets the IDispatch* at the specified index.
//
//  PARAMETERS:
//  nIndex
//      The index at which to set the IDispatch*.  The original contents
//      at this location are automatically Released and replaced.
//  pVal
//      Used as the source of the new value.  This is treated as read-only.
//  
//  RETURN VALUE:
//  no_error, failed, range_error
//      
//***************************************************************************
int CSafeArray::SetDispatchAt(
    IN int nIndex,
    IN IDispatch *pDisp
    )
{
    // Check for out-of-range condition.
    // =================================

    if (nIndex > m_nMaxElementUsed + 1)
        return range_error;

    // Check to see if we are adding a new element.
    // ============================================

    if (nIndex == m_nMaxElementUsed + 1)
        return AddDispatch(pDisp);

    // If here, we are replacing an element.
    // =====================================

    if (SafeArrayPutElement(m_pArray, (long *) &nIndex, pDisp) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CSafeArray::SetUnknownAt
//
//  Sets the IUnknown* at the specified index.
//
//  PARAMETERS:
//  nIndex
//      The index at which to set the IUnknown*.  The original contents
//      at this location are automatically Released and replaced.
//  pVal
//      Used as the source of the new value.  This is treated as read-only.
//  
//  RETURN VALUE:
//  no_error, failed, range_error
//      
//***************************************************************************
int CSafeArray::SetUnknownAt(
    IN int nIndex,
    IN IUnknown *pUnk
    )
{
    // Check for out-of-range condition.
    // =================================

    if (nIndex > m_nMaxElementUsed + 1)
        return range_error;

    // Check to see if we are adding a new element.
    // ============================================

    if (nIndex == m_nMaxElementUsed + 1)
        return AddUnknown(pUnk);

    // If here, we are replacing an element.
    // =====================================

    if (SafeArrayPutElement(m_pArray, (long *) &nIndex, pUnk) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CSafeArray::RemoveAt
//
//  Removes the element at the specified index.  After a series of these
//  operations, the caller should call the Trim() function.
//
//  PARAMETERS:
//  nIndex
//      The target index for element removal.
//
//  RETURN VALUE:
//      no_error, range_error
//
//***************************************************************************
int CSafeArray::RemoveAt(IN int nIndex)
{
    // Check for out-of-range condition.
    // =================================

    if (nIndex > m_nMaxElementUsed + 1)
        return range_error;

    // Copy element n+1 into n.
    // ========================

    BSTR strVal;
    VARIANT v;
    SA_ArrayScalar scalar;
    IDispatch* pDisp;
    IUnknown* pUnk;

    for (long i = nIndex; i < m_nMaxElementUsed; i++) {
        long nNext = i + 1;

        if (m_nVarType == VT_BSTR) {
            SafeArrayGetElement(m_pArray, &nNext, &strVal);
            SafeArrayPutElement(m_pArray, &i, strVal);
            SysFreeString(strVal);
        }
        else if (m_nVarType == VT_VARIANT) {
            SafeArrayGetElement(m_pArray, &nNext, &v);
            SafeArrayPutElement(m_pArray, &i, &v);
            VariantClear(&v);
        }
        else if (m_nVarType == VT_DISPATCH) {
            SafeArrayGetElement(m_pArray, &nNext, &pDisp);
            SafeArrayPutElement(m_pArray, &i, pDisp);
            if(pDisp) pDisp->Release();
        }            
        else if (m_nVarType == VT_UNKNOWN) {
            SafeArrayGetElement(m_pArray, &nNext, &pUnk);
            SafeArrayPutElement(m_pArray, &i, pUnk);
            if(pUnk) pUnk->Release();
        }            
        else {
            SafeArrayGetElement(m_pArray, &nNext, &scalar);
            SafeArrayPutElement(m_pArray, &i, &scalar);
        }
    }

    m_nMaxElementUsed--;
    return no_error;
}

//***************************************************************************
//
//  CSafeArray::SetScalarAt
//
//  For class internal use.  Sets the scalar type at the specified index.
//  
//  PARAMETERS:
//  nIndex
//      The target index.
//  val
//      The new value.
//
//  RETURN VALUES:
//  range_error, failed, no_error    
//
//***************************************************************************
int CSafeArray::SetScalarAt(IN int nIndex, IN SA_ArrayScalar val)
{
    // Check for out-of-range condition.
    // =================================

    if (nIndex > m_nMaxElementUsed + 1)
        return range_error;

    // Check to see if we are adding a new element.
    // ============================================

    if (nIndex == m_nMaxElementUsed + 1)
        return AddScalar(val);

    // If here, we are replacing an element.
    // =====================================

    if (SafeArrayPutElement(m_pArray, (long *) &nIndex, &val) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CSafeArray::AddScalar
//
//  For class internal use only.
//
//  Adds a new scalar to the 'end' of the array, growing it if required
//  and if possible.
//
//  PARAMETERS:
//  val
//      The new value.
//
//  RETURN VALUE:
//  no_error, range_error, failed
//
//***************************************************************************
int CSafeArray::AddScalar(IN SA_ArrayScalar val)
{
    // If there is no more room in the array, then expand it.
    // ======================================================

    if (m_nMaxElementUsed == (int) m_bound.cElements - 1) {

        if (m_nGrowBy == 0)
            return range_error;

        m_bound.cElements += m_nGrowBy;

        if (S_OK != SafeArrayRedim(m_pArray, &m_bound))
            m_nStatus = failed;
    }

    m_nMaxElementUsed++;

    if (SafeArrayPutElement(m_pArray, (long *) &m_nMaxElementUsed, &val) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}



//***************************************************************************
//
//  CSafeArray::Empty
//
//  Empties the SAFEARRAY.
//
//***************************************************************************
void CSafeArray::Empty()
{
    m_nMaxElementUsed = 0;
    m_nFlags = 0;
    m_nGrowBy = 0;
    m_nStatus = no_error;
    m_nVarType = VT_NULL;
    if (m_pArray)
        SafeArrayDestroy(m_pArray);
    m_pArray = 0;
    m_bound.cElements = 0;
    m_bound.lLbound = 0;
}

//***************************************************************************
//
//  CSafeArray::GetArrayCopy
//
//  RETURN VALUE:
//  A copy of the internal SAFEARRAY or NULL on error.
//
//***************************************************************************
SAFEARRAY *CSafeArray::GetArrayCopy()
{
    SAFEARRAY *pCopy = 0;
    if (SafeArrayCopy(m_pArray, &pCopy) != S_OK)
        return 0;
    return pCopy;
}

//***************************************************************************
//
//  CSafeArray destructor.
//
//  If the internal flags are set to auto_delete, then the internal
//  SAFEARRAY is destroyed during destruction.
//
//***************************************************************************
CSafeArray::~CSafeArray()
{
    if (m_nFlags == auto_delete)
        SafeArrayDestroy(m_pArray);
}


//***************************************************************************
//
//  CSafeArray::Trim
//
//***************************************************************************
int CSafeArray::Trim()
{                                           
    m_bound.cElements = m_nMaxElementUsed + 1;

    // HACK for NT 3.51: may not redimention to size 0
    // ===============================================

    if(m_bound.cElements == 0)
    {
        SafeArrayDestroy(m_pArray);
        m_pArray = SafeArrayCreate(m_nVarType, 1, &m_bound);
    }
    else
    {
        SafeArrayRedim(m_pArray, &m_bound);
    }

    return no_error;
}

//***************************************************************************
//
//***************************************************************************
void CSafeArray::Fatal(const char *pszMsg)
{
//    MessageBox(0, pszMsg, "CSafeArray FATAL Error",
//        MB_OK | MB_SYSTEMMODAL | MB_ICONEXCLAMATION);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemtest\wt_var.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    VAR.H

Abstract:

  CVar & CVarVector.


  These are thread-safe translators for VARIANT and SAFEARRAY
  and represent all types support by WBEM.

  These are mutually nestable to any level.  A CVarVector can contain 
  an array of CVar, and a CVar can contain a CVarVector.    One CVar
  can therefore contain a whole tree of CVar objects, themselves
  containing homogeneous or heterogeneous arrays of CVar objects.

  Note: CVar should not be bound to one type and then immediately
  coerced to a new type.  This object is designed for speed, not safety,
  so there is no checking to see if this has been done.  A memory leak
  is likely to occur.

  The assignment operator and copy constructors are the only method
  of changing the type on a CVar.  Do NOT construct the object as
  a BSTR, for example, and then call SetDWORD.

History:

	16-Apr-96   a-raymcc    Created.
	12//17/98	sanjes -	Partially Reviewed for Out of Memory.
	18-Mar-99	a-dcrews	Added out-of-memory exception handling

--*/

#ifndef _VAR_H_
#define _VAR_H_

#include <WT_flexarry.h>
//#include <safearry.h>


#define VT_EX_CVAR           (VT_USERDEFINED | 0x80010000)
#define VT_EX_CVARVECTOR     (VT_USERDEFINED | 0x80010002)


class CVarVector;

typedef union
{
    char     cVal;          // VT_I1
    BYTE     bVal;          // VT_UI1
    SHORT    iVal;          // VT_I2
    WORD     wVal;          // VT_UI2
    LONG     lVal;          // VT_I4
    DWORD    dwVal;         // VT_UI4
    VARIANT_BOOL boolVal;   // VT_BOOL    

    float    fltVal;        // VT_R4
    double   dblVal;        // VT_R8

    LPSTR    pStr;          // VT_LPSTR
    LPWSTR   pWStr;         // VT_LPWSTR
    BSTR     Str;           // VT_BSTR      (stored as VT_LPWSTR)
    
    FILETIME Time;          // VT_FILETIME
    BLOB   Blob;            // VT_BLOB        
    LPCLSID  pClsId;        // VT_CLSID
    IUnknown* pUnk;         // VT_UNKNOWN
    IDispatch* pDisp;       // VT_DISPATCH
    CVarVector *pVarVector; // VT_EX_CVARVECTOR
        
}   METAVALUE;


class CVar  
{
    int m_vt;
    METAVALUE m_value;
    int m_nStatus;    
    BOOL m_bCanDelete;
    
    void Init();
public:
    enum { no_error, unsupported, failed };
    
    CVar() { Init(); } 
   ~CVar();
    CVar(CVar &);
    CVar& operator =(CVar &);

    CVar(char c)            { Init(); SetChar(c); }
    CVar(BYTE b)            { Init(); SetByte(b); }
    CVar(SHORT s)           { Init(); SetShort(s); }
    CVar(WORD w)            { Init(); SetWord(w); }
    CVar(LONG l)            { Init(); SetLong(l); }
    CVar(DWORD dw)          { Init(); SetDWORD(dw); }     
    CVar(float f)           { Init(); SetFloat(f); }
    CVar(double d)          { Init(); SetDouble(d); }
    CVar(VARIANT_BOOL b,int){ Init(); SetBool(b); }

    CVar(LPSTR p, BOOL bAcquire = FALSE)  
        { Init(); SetLPSTR(p, bAcquire); }

    CVar(LPWSTR p, BOOL bAcquire = FALSE)          
        { Init(); SetLPWSTR(p, bAcquire); }
        
    CVar(int, BSTR b, BOOL bAcquire = FALSE)       
        { Init(); SetBSTR(b, bAcquire); }      
        // Dummy int required for context, since BSTR is also LPWSTR
        // from Win32 point of view, although the VT_ indicators differ.
        
    CVar(CLSID *p, BOOL bAcquire = FALSE)  
        { Init(); SetClsId(p, bAcquire); }

    CVar(BLOB *p, BOOL bAcquire = FALSE)           
        { Init(); SetBlob(p, bAcquire); }
        
    CVar(FILETIME *p)       { Init(); SetFileTime(p); }

    CVar(CVarVector *p, BOOL bAcquire = FALSE) { Init(); SetVarVector(p, bAcquire); }
    CVar(VARIANT *p)        { Init(); SetVariant(p); }    
    CVar(int nType, SAFEARRAY *p) { Init(); SetSafeArray(nType, p); }
    int Status() { return m_nStatus; }

    int  DumpText(FILE *fStream);
    int  GetType() { return m_vt; }
    int  GetOleType();
    void Empty();

    int operator ==(CVar &Other);
    BOOL CompareTo(CVar& Other, BOOL bIgnoreCase);


    void SetRaw(int vt, void* pvData, int nDataLen);
    void* GetRawData() {return (void*)&m_value;}
    BOOL CanDelete() {return m_bCanDelete;}
    void SetCanDelete(BOOL bCanDelete) {m_bCanDelete = bCanDelete;}

    // Numeric types.
    // ==============
    
    void SetAsNull() { m_vt = VT_NULL; m_value.lVal = 0; }
    BOOL IsNull() {return m_vt == VT_NULL;}
    BOOL IsDataNull();
    
    void SetChar(char c) { m_vt = VT_I1; m_value.cVal = c; }
    char GetChar() { return m_value.cVal; }
    operator char() { return m_value.cVal; }
    
    void SetByte(BYTE b) { m_vt = VT_UI1; m_value.bVal = b; }
    BYTE GetByte() { return m_value.bVal; }
    operator BYTE() { return m_value.bVal; }
    
    void  SetShort(SHORT iVal) { m_vt = VT_I2; m_value.iVal = iVal; }
    SHORT GetShort() { return m_value.iVal; }
    operator SHORT() { return m_value.iVal; }
    
    void SetWord(WORD wVal) { m_vt = VT_UI2; m_value.wVal = wVal; }
    WORD GetWord() { return m_value.wVal; }
    operator WORD() { return m_value.wVal; }
    
    void SetLong(LONG lVal) { m_value.lVal = lVal; m_vt = VT_I4; }
    LONG GetLong() { return m_value.lVal; }
    operator LONG() { return m_value.lVal; }
    
    void SetDWORD(DWORD dwVal) { m_value.dwVal = dwVal; m_vt = VT_UI4; }
    DWORD GetDWORD() { return m_value.dwVal; }
    operator DWORD() { return m_value.dwVal; }
    
    void SetBool(VARIANT_BOOL b) { m_value.boolVal = b; m_vt = VT_BOOL; }
    VARIANT_BOOL GetBool() { return m_value.boolVal; }

    void SetFloat(float f) { m_value.fltVal = f; m_vt = VT_R4; }
    float GetFloat() { return m_value.fltVal; }
    operator float() { return m_value.fltVal; }
    
    void   SetDouble(double dblVal) { m_value.dblVal = dblVal; m_vt = VT_R8; }
    double GetDouble() { return m_value.dblVal; }
    operator double() { return m_value.dblVal; }

    void SetDispatch(IDispatch* pDisp);
    IDispatch* GetDispatch() 
    {if(m_value.pDisp) m_value.pDisp->AddRef(); return m_value.pDisp;}
    
    void SetUnknown(IUnknown* pUnk);
    IUnknown* GetUnknown() 
    {if(m_value.pUnk) m_value.pUnk->AddRef(); return m_value.pUnk;}

    void SetEmbeddedObject(IUnknown* pUnk) {SetUnknown(pUnk);}
    IUnknown* GetEmbeddedObject() {return GetUnknown();}

    int SetVariant(VARIANT *pSrc);

    void FillVariant(VARIANT* pDest);
    VARIANT *GetNewVariant();    
    
    // String types.
    // =============
    
    BOOL  SetLPWSTR(LPWSTR pVal, BOOL bAcquire = FALSE);
    wchar_t *GetLPWSTR() { return m_value.pWStr; }
    operator LPWSTR() { return m_value.pWStr; }    
    
    BOOL  SetLPSTR(LPSTR pStr, BOOL bAcquire = FALSE);
    LPSTR GetLPSTR() { return m_value.pStr; }
    operator LPSTR() { return m_value.pStr; }
    
    BOOL SetBSTR(BSTR str, BOOL bAcquire = FALSE);
    BSTR GetBSTR();     // Makes a dynamic copy which must be freed.
    
    // Misc. types.
    // ============
    
    void SetFileTime(FILETIME *pft) { m_value.Time = *pft; m_vt = VT_FILETIME; }
    FILETIME GetFileTime() { return m_value.Time; }
    operator FILETIME() { return m_value.Time; }    
    
    void SetBlob(BLOB *pBlob, BOOL bAcquire = FALSE);
    BLOB *GetBlob() { return &m_value.Blob; }
    operator BLOB *() { return &m_value.Blob; }        
    
    void SetClsId(CLSID *pClsId, BOOL bAcquire);
    CLSID* GetClsId() { return m_value.pClsId; }    // Return value is read-only
    operator CLSID*() { return m_value.pClsId; }    // Return value is read-only    
    
    void SetVarVector(CVarVector *pVec, BOOL bAcquire);
    CVarVector *GetVarVector()  { return m_value.pVarVector; }  
    operator CVarVector *()  { return m_value.pVarVector; }  
    
    void SetSafeArray(int nType, SAFEARRAY *pArray); // Copies the source
    SAFEARRAY *GetNewSafeArray();   // New SAFEARRAY which must be released

    static BSTR TypeToText(int nType);
    BSTR GetTypeText();
    BSTR GetText(long lFlags, long lType = 0);

    BOOL ChangeTypeTo(VARTYPE vtNew);
    BOOL ChangeTypeToEx(VARTYPE vtNew, LCID lcid = 0x409 );
    BOOL ToSingleChar();
    BOOL ToUI4();
};


class  CVarVector
{
    int         m_nType;
    CFlexArray  m_Array;
    int         m_nStatus;
public:
    enum { no_error, failed, unsupported };

    CVarVector();    
    CVarVector(int nVarType, int nInitSize = 32, int nGrowBy = 32);

    // These two only support limited SAFEARRAY types.
    // ===============================================

    CVarVector(int nVarType, SAFEARRAY *pSrc);
    SAFEARRAY *GetNewSafeArray();

    int  GetType() { return m_nType; }        
    int  Status() { return m_nStatus; }
    void Empty();
                    
   ~CVarVector();
    CVarVector(CVarVector &Src);
    CVarVector& operator =(CVarVector &Src);
    int operator ==(CVarVector &Src);     
    BOOL CompareTo(CVarVector& Other, BOOL bIgnoreCase);
    int Size() { return m_Array.Size(); }

    int    Add(CVar &Value);  
    int    Add(CVar *pAcquiredPtr);
    CVar&  GetAt(int nIndex) { return *(CVar *) m_Array[nIndex]; }
    CVar&  operator [](int nIndex)  { return *(CVar *) m_Array[nIndex]; }
    int    RemoveAt(int nIndex);
    int    InsertAt(int nIndex, CVar &Value);

    BSTR GetText(long lFlags, long lType = 0);
    BOOL ToSingleChar();
    BOOL ToUI4();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemtest\wt_strutils.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    STRUTILS.H

Abstract:

	String utilities

History:

--*/

#ifndef __WBEM_STRING_UTILS__H_
#define __WBEM_STRING_UTILS__H_

#pragma optimize("gt", on)

/*
inline int wbem_towlower(wint_t c)
{
    if(c >= 0 && c <= 127)
    {
        if(c >= 'A' && c <= 'Z')
            return c + ('a' - 'A');
        else
            return c;
    }
    else return towlower(c);
}
*/

#define wbem_towlower(C) \
    (((C) >= 0 && (C) <= 127)?          \
        (((C) >= 'A' && (C) <= 'Z')?          \
            ((C) + ('a' - 'A')):          \
            (C)          \
        ):          \
        towlower(C)          \
    )          

inline int wbem_towupper(wint_t c)
{
    if(c >= 0 && c <= 127)
    {
        if(c >= 'a' && c <= 'z')
            return c + ('A' - 'a');
        else
            return c;
    }
    else return towupper(c);
}

inline int wbem_tolower(int c)
{
    if(c >= 0 && c <= 127)
    {
        if(c >= 'A' && c <= 'Z')
            return c + ('a' - 'A');
        else
            return c;
    }
    else return tolower(c);
}

inline int wbem_toupper(int c)
{
    if(c >= 0 && c <= 127)
    {
        if(c >= 'a' && c <= 'z')
            return c + ('A' - 'a');
        else
            return c;
    }
    else return toupper(c);
}

inline int wbem_wcsicmp(const wchar_t* wsz1, const wchar_t* wsz2)
{
    while(*wsz1 || *wsz2)
    {
        int diff = wbem_towlower(*wsz1) - wbem_towlower(*wsz2);
        if(diff) return diff;
        wsz1++; wsz2++;
    }

    return 0;
}

// just like wcsicmp, but first 0 of unicode chracters have been omitted
inline int wbem_ncsicmp(const char* wsz1, const char* wsz2)
{
    while(*wsz1 || *wsz2)
    {
        int diff = wbem_towlower((unsigned char)*wsz1) - 
                    wbem_towlower((unsigned char)*wsz2);
        if(diff) return diff;
        wsz1++; wsz2++;
    }

    return 0;
}

inline int wbem_wcsnicmp(const wchar_t* wsz1, const wchar_t* wsz2, size_t n)
{
    while(n-- && (*wsz1 || *wsz2))
    {
        int diff = wbem_towlower(*wsz1) - wbem_towlower(*wsz2);
        if(diff) return diff;
        wsz1++; wsz2++;
    }

    return 0;
}

inline int wbem_stricmp(const char* sz1, const char* sz2)
{
    while(*sz1 || *sz2)
    {
        int diff = wbem_tolower(*sz1) - wbem_tolower(*sz2);
        if(diff) return diff;
        sz1++; sz2++;
    }

    return 0;
}

inline int wbem_strnicmp(const char* sz1, const char* sz2, size_t n)
{
    while(n-- && (*sz1 || *sz2))
    {
        int diff = wbem_tolower(*sz1) - wbem_tolower(*sz2);
        if(diff) return diff;
        sz1++; sz2++;
    }

    return 0;
}

#pragma optimize("", off)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemtest\wt_var.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    VAR.H

Abstract:

  CVar & CVarVector implemntation

History:

    16-Apr-96   a-raymcc    Created.
    12//17/98   sanjes -    Partially Reviewed for Out of Memory.
    18-Mar-99   a-dcrews    Added out-of-memory exception handling

--*/

#include "precomp.h"
#include <stdio.h>
#include <stdlib.h>

#include <WT_var.h>
#include <wbemidl.h>
#include <WT_arrtempl.h>
//#include <olewrap.h>
#include "WT_SafeArry.h"
class CX_MemoryException
{
};
class CX_Exception
{
};
typedef BYTE* LPMEMORY;
BLOB BlobCopy(BLOB *pSrc)
{
    BLOB Blob;
    BYTE *p = new BYTE[pSrc->cbSize];

    // Check for allocation failure
    if ( NULL == p )
    {
        throw CX_MemoryException();
    }

    Blob.cbSize = pSrc->cbSize;
    Blob.pBlobData = p;
    memcpy(p, pSrc->pBlobData, Blob.cbSize);
    return Blob;
}
#define BlobLength(p)  ((p)->cbSize)
#define BlobDataPtr(p) ((p)->pBlobData)
void  BlobClear(BLOB *pSrc)
{
    if (pSrc->pBlobData) 
        delete pSrc->pBlobData;

    pSrc->pBlobData = 0;
    pSrc->cbSize = 0;
}
HRESULT WbemVariantChangeType(VARIANT* pvDest, VARIANT* pvSrc, 
                                        VARTYPE vtNew)
{
    HRESULT hres;

    if(V_VT(pvSrc) == VT_NULL)
    {
        return VariantCopy(pvDest, pvSrc);
    }

    if(vtNew & VT_ARRAY)
    {
        // It's an array, we have to do our own conversion
        // ===============================================

        if((V_VT(pvSrc) & VT_ARRAY) == 0)
            return DISP_E_TYPEMISMATCH;

        SAFEARRAY* psaSrc = V_ARRAY(pvSrc);

        SAFEARRAYBOUND aBounds[1];

        long lLBound;
        SafeArrayGetLBound(psaSrc, 1, &lLBound);

        long lUBound;
        SafeArrayGetUBound(psaSrc, 1, &lUBound);

        aBounds[0].cElements = lUBound - lLBound + 1;
        aBounds[0].lLbound = lLBound;

        SAFEARRAY* psaDest = SafeArrayCreate(vtNew & ~VT_ARRAY, 1, aBounds);

        // Stuff the individual data pieces
        // ================================

        for(long lIndex = lLBound; lIndex <= lUBound; lIndex++)
        {
            // Load the initial data element into a VARIANT
            // ============================================

            VARIANT vSrcEl;
            V_VT(&vSrcEl) = V_VT(pvSrc) & ~VT_ARRAY;
            SafeArrayGetElement(psaSrc, &lIndex, &V_UI1(&vSrcEl));

            // Cast it to the new type
            // =======================

            hres = VariantChangeType(&vSrcEl, &vSrcEl, 0, vtNew & ~VT_ARRAY);
            if(FAILED(hres)) 
            {
                SafeArrayDestroy(psaDest);
                return hres;
            }

            // Put it into the new array
            // =========================

            if(V_VT(&vSrcEl) == VT_BSTR)
            {
                hres = SafeArrayPutElement(psaDest, &lIndex, V_BSTR(&vSrcEl));
            }
            else
            {
                hres = SafeArrayPutElement(psaDest, &lIndex, &V_UI1(&vSrcEl));
            }
            if(FAILED(hres)) 
            {
                SafeArrayDestroy(psaDest);
                return hres;
            }
        }

        if(pvDest == pvSrc)
        {
            VariantClear(pvSrc);
        }

        V_VT(pvDest) = vtNew;
        V_ARRAY(pvDest) = psaDest;

        return TRUE;
    }
    else
    {
        // Not an array. Can use OLE functions
        // ===================================

        return VariantChangeType(pvDest, pvSrc, VARIANT_NOVALUEPROP, vtNew);
    }
}


//***************************************************************************
//
//  CVar::Empty
//
//  Constructor helper.
//
//  This merely clears everything.  VT_EMPTY is the default.
//
//***************************************************************************

void CVar::Init()
{
    m_nStatus = no_error; 
    m_vt = VT_EMPTY;
    m_bCanDelete = TRUE;
    memset(&m_value, 0, sizeof(METAVALUE));
}


//***************************************************************************
//
//  CVar::~CVar
//
//  Destructor.
//
//***************************************************************************

CVar::~CVar()
{
    Empty();
}



//***************************************************************************
//
//  CVar::CVar
//
//  Copy constructor.  This is implemented via the assignment operator.
//  
//***************************************************************************

CVar::CVar(CVar &Src)
{
    m_vt = VT_EMPTY;
    m_nStatus = no_error; 
    memset(&m_value, 0, sizeof(METAVALUE));
    *this = Src;
}

//***************************************************************************
//
//  CVar::operator =
//
//  NOTES:
//  Observe that VT_EX_CVARVECTOR is dedicated to embedded CVarVector objects.
//  Also, only pointer types require a new allocation + copy, whereas
//  most of the simple types are directly assignable, in the <default>
//  label of the switch statement.
//
//***************************************************************************

CVar& CVar::operator =(CVar &Src)
{
    Empty();

    m_vt = Src.m_vt;
    m_nStatus = m_nStatus;
    m_bCanDelete = TRUE;

    switch (m_vt) {
        case VT_LPSTR:

            // Check for an allocation failure
            if ( NULL != Src.m_value.pStr )
            {
                m_value.pStr = new char[strlen(Src.m_value.pStr) + 1];

                if ( NULL == m_value.pStr )
                {
                    throw CX_MemoryException();
                }
                strcpy( m_value.pStr, Src.m_value.pStr );
            }
            else
            {
                m_value.pStr = NULL;
            }

            break;

        case VT_LPWSTR:
        case VT_BSTR:
            // Check for an allocation failure
            if ( NULL != Src.m_value.pWStr )
            {
                m_value.pWStr = new wchar_t[wcslen(Src.m_value.pWStr) + 1];

                if ( NULL == m_value.pWStr )
                {
                    throw CX_MemoryException();
                }
                wcscpy( m_value.pWStr, Src.m_value.pWStr );
            }
            else
            {
                m_value.pWStr = NULL;
            }

            break;

        case VT_BLOB:
            // This will natively throw an exception, but make sure the
            // original value is cleared in case an exception is thrown
            // so we don't AV destructing this object
            ZeroMemory( &m_value.Blob, sizeof( m_value.Blob ) );
            m_value.Blob = BlobCopy(&Src.m_value.Blob);
            break;

        case VT_CLSID:
            m_value.pClsId = new CLSID(*Src.m_value.pClsId);

            // Check for a failed allocation
            if ( NULL == m_value.pClsId )
            {
                throw CX_MemoryException();
            }

            break;

        case VT_DISPATCH:
            m_value.pDisp = Src.m_value.pDisp;
            if(m_value.pDisp) m_value.pDisp->AddRef();
            break;

        case VT_UNKNOWN:
            m_value.pUnk = Src.m_value.pUnk;
            if(m_value.pUnk) m_value.pUnk->AddRef();
            break;

        // CVarVector
        // ==========

        case VT_EX_CVARVECTOR:
            m_value.pVarVector = new CVarVector(*Src.m_value.pVarVector);

            // Check for a failed allocation
            if ( NULL == m_value.pVarVector )
            {
                throw CX_MemoryException();
            }

            break;

        // All remaining simple types. 
        // ===========================
        default:        
            m_value = Src.m_value;
    }

    return *this;
}

//***************************************************************************
//
//  CVar::operator ==
//
//  Equality test operator.
//
//***************************************************************************

int CVar::operator ==(CVar &Src)
{
    return CompareTo(Src, TRUE);
}

BOOL CVar::CompareTo(CVar& Src, BOOL bIgnoreCase)
{
    // If types are not the same, forget the test.
    // ===========================================

    if (m_vt != Src.m_vt)
        return 0;

    // If here, the types are the same, so test
    // the fields.
    // ========================================

    switch (m_vt) {
        case VT_LPSTR:
            if(bIgnoreCase)
            {
                if (_stricmp(m_value.pStr, Src.m_value.pStr) == 0)
                    return 1;
            }
            else
            {
                if (strcmp(m_value.pStr, Src.m_value.pStr) == 0)
                    return 1;
            }

            break;

        case VT_LPWSTR:
        case VT_BSTR:
            if(bIgnoreCase)
            {
                if (wbem_wcsicmp(m_value.pWStr, Src.m_value.pWStr) == 0)
                    return 1;
            }
            else
            {
                if (wcscmp( m_value.pWStr, Src.m_value.pWStr) == 0)
                    return 1;
            }
            break;

        case VT_BLOB:
            if (BlobLength(&m_value.Blob) != BlobLength(&Src.m_value.Blob))
                return 0;
            if (memcmp(BlobDataPtr(&m_value.Blob), BlobDataPtr(&Src.m_value.Blob),
                BlobLength(&m_value.Blob)) == 0)
                return 1;                            
            break;

        case VT_CLSID:
            if (memcmp(m_value.pClsId, Src.m_value.pClsId, sizeof(CLSID)) == 0)
                return 1;
            break;
    
        // CVarVector
        // ==========

        case VT_EX_CVARVECTOR:
            if (m_value.pVarVector == Src.m_value.pVarVector)
                return 1;
            if (m_value.pVarVector == 0 || Src.m_value.pVarVector == 0)
                return 0;
            return *m_value.pVarVector == *Src.m_value.pVarVector;

        // All remaining simple types. 
        // ===========================

        case VT_I1: 
            return m_value.cVal == Src.m_value.cVal;
        case VT_UI1:
            return m_value.bVal == Src.m_value.bVal;
        case VT_I2:
            return m_value.iVal == Src.m_value.iVal;
        case VT_UI2:
            return m_value.wVal == Src.m_value.wVal;
        case VT_I4:
            return m_value.lVal == Src.m_value.lVal;
        case VT_UI4:
            return m_value.dwVal == Src.m_value.dwVal;
        case VT_BOOL:
            return m_value.boolVal == Src.m_value.boolVal;
        case VT_R8:
            return m_value.dblVal == Src.m_value.dblVal;
        case VT_R4:
            return m_value.fltVal == Src.m_value.fltVal;
        case VT_DISPATCH:
            // Note: no proper comparison of embedded objects.
            return m_value.pDisp == Src.m_value.pDisp;
        case VT_UNKNOWN:
            // Note: no proper comparison of embedded objects.
            return m_value.pUnk == Src.m_value.pUnk;
        case VT_FILETIME:
            if (memcmp(&m_value.Time, &Src.m_value.Time, sizeof(FILETIME)) == 0)
                return 1;
        case VT_NULL:
            return 1;
    }

    return 0;    
}


//***************************************************************************
//
//  CVar::Empty
//
//  Clears the CVar to 'empty', deallocates any objects based on pointers, 
//  unless bCanDelete is set to FALSE, indicating that the stored pointer
//  is owned by somebody else.
//
//***************************************************************************

void CVar::Empty()
{
    if(m_bCanDelete)
    {
        // Only pointer types require a deallocation phase.
        // =================================================

        switch (m_vt) {
            case VT_LPSTR:       delete m_value.pStr; break;
            case VT_LPWSTR:      delete m_value.pWStr; break;
            case VT_BSTR:        delete m_value.Str; break;
            case VT_BLOB:        BlobClear(&m_value.Blob); break;
            case VT_CLSID:       delete m_value.pClsId; break;
            case VT_EX_CVARVECTOR: delete m_value.pVarVector; break;
            case VT_DISPATCH:    if(m_value.pDisp) m_value.pDisp->Release(); break;
            case VT_UNKNOWN:    if(m_value.pUnk) m_value.pUnk->Release(); break;
        }
    }

    memset(&m_value, 0, sizeof(METAVALUE)); 
    m_vt = VT_EMPTY;
    m_nStatus = no_error;
    m_bCanDelete = TRUE;
}

//***************************************************************************
//
//  CVar::IsDataNull
//
//  Determines if this CVar contains a NULL pointer.
//
//***************************************************************************
BOOL CVar::IsDataNull()
{
    if(m_vt == VT_LPWSTR && m_value.pWStr == NULL)
        return TRUE;
    if(m_vt == VT_LPSTR && m_value.pStr == NULL)
        return TRUE;
    if(m_vt == VT_BSTR && m_value.Str == NULL)
        return TRUE;
    if(m_vt == VT_DISPATCH && m_value.pDisp == NULL)
        return TRUE;
    if(m_vt == VT_UNKNOWN && m_value.pUnk == NULL)
        return TRUE;

    return FALSE;
}
//***************************************************************************
//
//  CVar::SetRaw
//
//  Creates a CVar from raw data. Sets the type and copies the right
//  number of bytes from the source to METAVALUE.
//
//***************************************************************************

void CVar::SetRaw(int vt, void* pvData, int nDataLen)
{
    m_vt = vt;
    memcpy(&m_value, pvData, nDataLen);
    m_nStatus = no_error;
    m_bCanDelete = TRUE;
}

//***************************************************************************
//
//  CVar::SetSafeArray
//
//  PARAMETERS:
//  nType  
//      This is the VT_ type indicator of the SAFEARRAY.    
//  pArray 
//      This is the pointer to the SAFEARRAY which will be used as
//      a source.  The SAFEARRAY is not acquired; it is copied.
//
//***************************************************************************

void CVar::SetSafeArray(int nType, SAFEARRAY *pArray)
{
    CVarVector *pVec = NULL;
    m_nStatus = no_error;

    try
    {
        pVec = new CVarVector(nType, pArray);

        // Check for a failed allocation
        if ( NULL == pVec )
        {
            throw CX_MemoryException();
        }

        SetVarVector(pVec, TRUE);
    }
    catch (CX_MemoryException)
    {
        // SetVarVector can throw an exception
        // m_value aquires the pVec pointer, so auto delete will not work

        if (NULL != pVec)
        {
            delete pVec;
            pVec = NULL;
        }

        throw;
    }
}


//***************************************************************************
//
//  CVar::GetNewSafeArray
//
//  RETURN VALUE:
//  A pointer to newly allocated SAFEARRAY which must be released by
//  SafeArrayDestroy.
//
//***************************************************************************

SAFEARRAY *CVar::GetNewSafeArray()
{
    CVarVector *p = (CVarVector *) GetVarVector();
    return p->GetNewSafeArray();
}


//***************************************************************************
//
//  CVar::SetValue
//  
//  Sets the value based on an incoming VARIANT.  A VARIANT containing
//  a SAFEARRAY is supported as long as it is not an array of VARIANTs.
//  Some of the other VARIANT types, such as IUnknown, Currency, etc.,
//  are not supported.  The complete list is:
//      VT_UI1, VT_I2, VT_I4, VT_BSTR, VT_BOOL
//      VT_R4, VT_R8, or SAFEARRAY of any of these.
//
//  PARAMETERS:
//  pSrc 
//      A pointer to the source VARIANT.  This is treated as read-only.
//
//  RETURN VALUES:
//  no_error
//      Returned on succcess.
//  unsupported
//      Returned if the VARIANT contains unsupported types.
//
//***************************************************************************

int CVar::SetVariant(VARIANT *pSrc)
{
    if(pSrc == NULL)
    {
        SetAsNull();
        return no_error;
    }

    // If a SAFEARRAY, check it.
    // =========================

    if (pSrc->vt & VT_ARRAY) 
    {
        CVarVector *pVec = NULL;

        try
        {
            int nType = pSrc->vt & 0xFF;    // Find the type of the array

            // BEGIN MODIFIED by a-levn

            // First, check if the incoming SAFEARRAY is NULL
            // ==============================================

            SAFEARRAY *pSafeArr;
    /*
            if(pSrc->parray == NULL)
            {
                pSafeArr = NULL;
            }
            else
            {
                // Make a copy of the SAFEARRAY using CSafeArray which will NOT 
                // autodestruct
                // ============================================================

                CSafeArray array(pSrc->parray, nType, CSafeArray::no_delete, 0);
                pSafeArr = array.GetArray();
            }

    */
            pSafeArr = pSrc->parray;

            // Goal: Convert the SAFEARRAY to a CVarVector.
            // Use CVarVector itself to do the conversion.
            // ===========================================

            pVec = new CVarVector(nType, pSafeArr);

            // Check for an allocation failure.
            if ( NULL == pVec )
            {
                throw CX_MemoryException();
            }

            // END MODIFIED

            if (pVec->Status() != no_error) 
            {

                // If here, the SAFEARRAY was not compatible.
                // ==========================================
  
                delete pVec;
                pVec = NULL;
                m_nStatus = unsupported;
                m_vt = VT_EMPTY;
                return unsupported;
            }

            SetVarVector(pVec, TRUE);
            return no_error;
        }
        catch(CX_MemoryException)
        {
            // new and SetVarVector can throw exceptions
            // m_value aquires the pVec pointer, so an auto delete will not work

            if (NULL != pVec)
            {
                delete pVec;
                pVec = NULL;
            }

            throw;
        }
    }

    // Simple copies.
    // ==============

    switch (pSrc->vt) {
        case VT_NULL:
            SetAsNull();
            return no_error;

        case VT_UI1:
            SetByte(pSrc->bVal);
            return no_error;

        case VT_I2:
            SetShort(pSrc->iVal);
            return no_error;
        
        case VT_I4:
            SetLong(pSrc->lVal);
            return no_error;

        case VT_R4:
            SetFloat(pSrc->fltVal);
            return no_error;

        case VT_R8:        
            SetDouble(pSrc->dblVal);
            return no_error;

        case VT_BSTR:
            SetBSTR(pSrc->bstrVal);
            return no_error;

        case VT_BOOL:
            SetBool(pSrc->boolVal);
            return no_error;

        case VT_DISPATCH:
            SetDispatch(V_DISPATCH(pSrc));
            return no_error;

        case VT_UNKNOWN:
            SetUnknown(V_UNKNOWN(pSrc));
            return no_error;
    }

    m_nStatus = unsupported;
    return unsupported;
}

//***************************************************************************
//
//  CVar::GetNewVariant
//  
//  RETURN VALUE:
//  A pointer to a new VARIANT which contains the value of object.
//  If the original value was a SAFEARRAY, then the VARIANT will contain
//  the embedded SAFEARRAY.
//      
//***************************************************************************

void CVar::FillVariant(VARIANT* pNew)
{
    switch (m_vt) {
        case VT_NULL:
            V_VT(pNew) = VT_NULL;
            break;

        case VT_BOOL:
            V_VT(pNew) = VT_BOOL;
            V_BOOL(pNew) = (m_value.boolVal ? VARIANT_TRUE : VARIANT_FALSE);
            break;
            
        case VT_BSTR:

            // Set type afterwards here so if the SysAlloc throws an exception, the
            // type will not have been reset to a VT_BSTR which could cause a subtle
            // memory corruption (or worse) if VariantClear is called - SJS

            V_BSTR(pNew) = SysAllocString(m_value.Str);
            V_VT(pNew) = VT_BSTR;
            break;

        case VT_DISPATCH:
            V_VT(pNew) = VT_DISPATCH;
            V_DISPATCH(pNew) = m_value.pDisp;
            if(m_value.pDisp) m_value.pDisp->AddRef();
            break;

        case VT_UNKNOWN:
            V_VT(pNew) = VT_UNKNOWN;
            V_UNKNOWN(pNew) = m_value.pUnk;
            if(m_value.pUnk) m_value.pUnk->AddRef();
            break;

        case VT_UI1:
            V_VT(pNew) = VT_UI1;
            V_UI1(pNew) = m_value.bVal;
            break;

        case VT_I4:
            V_VT(pNew) = VT_I4;
            V_I4(pNew) = m_value.lVal;
            break;

        case VT_I2:
            V_VT(pNew) = VT_I2;
            V_I2(pNew) = m_value.iVal;
            break;

        case VT_R4:
            V_VT(pNew) = VT_R4;
            V_R4(pNew) = m_value.fltVal;
            break;

        case VT_R8:        
            V_VT(pNew) = VT_R8;
            V_R8(pNew) = m_value.dblVal;
            break;

        // An embedded CVarVector which must be converted
        // to a SAFEARRAY.
        // ==============================================

        case VT_EX_CVARVECTOR:
            {
                // Set type afterwards here so if GetNewSafeArray throws an exception, the
                // type will not have been reset to an Array which could cause a subtle
                // memory corruption (or worse) if VariantClear is called - SJS

                V_ARRAY(pNew) = m_value.pVarVector->GetNewSafeArray();
                V_VT(pNew) = m_value.pVarVector->GetType() | VT_ARRAY;
            }
            break;
                                   
        default:
            VariantClear(pNew);        
    }
}

VARIANT *CVar::GetNewVariant()
{
    VARIANT *pNew = new VARIANT;

    // Check for an allocation failure.
    if ( NULL == pNew )
    {
        throw CX_MemoryException();
    }

    VariantInit(pNew);
    
    FillVariant(pNew);       
    return pNew;    
}
    
//***************************************************************************
//
//***************************************************************************

int CVar::DumpText(FILE *fStream)
{
    return unsupported;
}

//***************************************************************************
//
//  CVar::SetLPWSTR
//
//  Sets the value of the CVar to the indicated LPWSTR.
//
//  PARAMETERS:
//  pStr
//      A pointer to the source string.
//  bAcquire
//      If TRUE, then the ownership of pStr is trasferred and becomes
//      the internal pointer to the string. If FALSE, then the string
//      is copied.
//      
//***************************************************************************

BOOL CVar::SetLPWSTR(LPWSTR pStr, BOOL bAcquire)
{
    m_vt = VT_LPWSTR;
    if (bAcquire)
    {
        m_value.pWStr = pStr;
        return TRUE;
    }
    else            
    {
        // Check for an allocation failure
        if ( NULL != pStr )
        {
            m_value.pWStr = new wchar_t[wcslen(pStr) + 1];

            if ( NULL == m_value.pWStr )
            {
                throw CX_MemoryException();
            }
            wcscpy( m_value.pWStr, pStr );
        }
        else
        {
            m_value.pWStr = NULL;
        }

        return TRUE;
    }
}

//***************************************************************************
//
//  CVar::SetLPSTR
//
//  Sets the value of the CVar to the indicated LPSTR.
//
//  PARAMETERS:
//  pStr
//      A pointer to the source string.
//  bAcquire
//      If TRUE, then the ownership of pStr is trasferred and becomes
//      the internal pointer to the string. If FALSE, then the string
//      is copied (it must have been allocated with operator new).
//    
//***************************************************************************
    
BOOL CVar::SetLPSTR(LPSTR pStr, BOOL bAcquire)
{
    m_vt = VT_LPSTR;
    if (bAcquire)
    {
        m_value.pStr = pStr;
        return TRUE;
    }
    else        
    {
        if ( NULL != pStr)
        {
            m_value.pStr = new char[strlen(pStr) + 1];

            // On failure, throw an exception
            if ( NULL == m_value.pStr )
            {
                throw CX_MemoryException();
            }

            strcpy( m_value.pStr, pStr );
        }
        else
        {
            m_value.pStr = NULL;
        }
        
        return TRUE;

    }
}

//***************************************************************************
//
//  CVar::SetBSTR
//
//  Sets the value of the CVar to the indicated BSTR.
//
//  NOTE: This BSTR value is actually stored as an LPWSTR to avoid 
//  apartment-threading restrictions on real BSTR objects allocated 
//  with SysAllocString.
//
//  PARAMETERS:
//  str
//      A pointer to the string, which is copied into an internal LPWSTR.
//  bAcquire
//      If FALSE, then the BSTR is treated as read-only and copied.
//      If TRUE, then this function becomes owner of the BSTR and
//      frees it after the copy is made.
//
//***************************************************************************

BOOL CVar::SetBSTR(BSTR str, BOOL bAcquire)
{
    m_vt = VT_BSTR;

    if (str == 0) {
        m_value.pWStr = 0;
        return TRUE;
    }
        
    // Check for an allocation failure
    if ( NULL != str )
    {
        m_value.pWStr = new wchar_t[wcslen(str) + 1];

        // If allocation fails, throw an exception
        if ( NULL == m_value.pWStr )
        {
            throw CX_MemoryException();
        }
        wcscpy( m_value.pWStr, str );
    }
    else
    {
        m_value.pWStr = NULL;
    }


    // Check that this succeeded before we free
    // the string passed into us
    if ( NULL != m_value.pWStr )
    {
        if (bAcquire)
            SysFreeString(str);
    }

    // return whether or not we obtained a value
    return ( NULL != m_value.pWStr );
}

//***************************************************************************
//
//  CVar::GetBSTR
//
//  Returns the BSTR value of the current object.  
//
//  RETURN VALUE:
//  A newly allocated BSTR which must be freed with SysFreeString().
//
//***************************************************************************

BSTR CVar::GetBSTR()
{
    if (m_vt != VT_BSTR)
        return NULL;
    return SysAllocString(m_value.pWStr);
}
    
void CVar::SetDispatch(IDispatch* pDisp) 
{
    m_vt = VT_DISPATCH; 
    m_value.pDisp = pDisp; 

    if(pDisp) 
    {
        pDisp->AddRef();
    }
}

void CVar::SetUnknown(IUnknown* pUnk) 
{
    m_vt = VT_UNKNOWN; 
    m_value.pUnk = pUnk; 

    if(pUnk) 
    {
        pUnk->AddRef();
    }
}

//***************************************************************************
//
//  CVar::SetBlob
//
//  Sets the object to the value of the BLOB object.
//
//  PARAMETERS:
//  pBlob
//      A pointer to a valid VT_BLOB object.
//  bAcquire
//      If TRUE, then the pointer to the data will be acquired. It must
//      have been allocated with operator new in the current process, 
//      since operator delete will be used to free it.
//      
//***************************************************************************
    
void CVar::SetBlob(BLOB *pBlob, BOOL bAcquire)
{
    m_vt = VT_BLOB;
    if (pBlob == 0) 
        BlobClear(&m_value.Blob);
    else if (!bAcquire)
        m_value.Blob = BlobCopy(pBlob);        
    else
        m_value.Blob = *pBlob;        
}

//***************************************************************************
//
//  CVar::SetClsId
//
//  Sets the value of the object to a CLSID.
//  
//  PARAMETERS:
//  pClsId
//      Points the source CLSID.
//  bAcquire
//      If TRUE, the ownership of the pointer is transferred to the
//      object.  The CLSID must have been allocated with operator new.
//      If FALSE, the caller retains ownership and a copy is made.
//
//***************************************************************************
        
void CVar::SetClsId(CLSID *pClsId, BOOL bAcquire)
{
    m_vt = VT_CLSID;
    if (pClsId == 0)
        m_value.pClsId = 0;
    else
    {
        m_value.pClsId = new CLSID(*pClsId);

        // Check for an allocation failure.
        if ( NULL == m_value.pClsId )
        {
            throw CX_MemoryException();
        }

    }
}

//***************************************************************************
//
//  CVar::SetVarVector
//
//  Sets the value of the object to the specified CVarVector.  This
//  allows the CVar to contain a complete array.
//  
//  PARAMETERS:
//  pVec
//      A pointer to the CVarVector object which is the source.
//  bAcquire
//      If TRUE, then ownership of the CVarVector is transferred to
//      the object.  If FALSE, a new copy of the CVarVector is made and
//      the caller retains ownership.
//
//***************************************************************************
    
void CVar::SetVarVector(CVarVector *pVec, BOOL bAcquire)
{
    m_vt = VT_EX_CVARVECTOR;

    if (bAcquire) {
        // If here, we acquire the caller's pointer.
        // =========================================
        m_value.pVarVector = pVec;
        return;
    }

    // If here, make a copy.
    // =====================

    m_value.pVarVector = new CVarVector(*pVec);

    // Check for an allocation failure.
    if ( NULL == m_value.pVarVector )
    {
        throw CX_MemoryException();
    }


}

int CVar::GetOleType() 
{ 
    if(m_vt == VT_EX_CVARVECTOR)
    {
        if(m_value.pVarVector == NULL) return VT_ARRAY;
        else return VT_ARRAY | m_value.pVarVector->GetType();
    }
    else
    {
        return m_vt;
    }
}        


//***************************************************************************
//
//  CVar::GetText
//
//  Produces textual representation of the Var's type and data
//
//  PARAMETERS:
//  long lFlags     reseved, must be 0
//  BSTR* pstrType  destination for the type representation
//  BSTR* pstrValue destination for the value representation.
//
//***************************************************************************

BSTR CVar::GetText(long lFlags, long lType)
{
    if(m_vt == VT_EX_CVARVECTOR)
    {
        // When we get the text for the array, make sure the CIM_FLAG_ARRAY is masked out
        BSTR strTemp = GetVarVector()->GetText(lFlags, lType & ~CIM_FLAG_ARRAY);
        CSysFreeMe auto1(strTemp);

        WCHAR* wszValue = new WCHAR[SysStringLen(strTemp) + 3];

        // Check for allocation failures
        if ( NULL == wszValue )
        {
            throw CX_MemoryException();
        }

        CVectorDeleteMe<WCHAR> auto2(wszValue);

        wcscpy(wszValue, L"{");
        wcscat(wszValue, strTemp);
        wcscat(wszValue, L"}");

        BSTR strRet = SysAllocString(wszValue);

        return strRet;
    }
        
    WCHAR* wszValue = new WCHAR[100];

    // Check for allocation failures
    if ( NULL == wszValue )
    {
        throw CX_MemoryException();
    }


    WCHAR* pwc;
    int i;

    if(m_vt == VT_NULL)
        return NULL;

    if(lType == 0)
        lType = m_vt;

    try
    {
        switch(lType)
        {
        case CIM_SINT8:
            swprintf(wszValue, L"%d", (long)(signed char)GetByte());
            break;

        case CIM_UINT8:
            swprintf(wszValue, L"%d", GetByte());
            break;

        case CIM_SINT16:
            swprintf(wszValue, L"%d", (long)GetShort());
            break;

        case CIM_UINT16:
            swprintf(wszValue, L"%d", (long)(USHORT)GetShort());
            break;

        case CIM_SINT32:
            swprintf(wszValue, L"%d", GetLong());
            break;

        case CIM_UINT32:
            swprintf(wszValue, L"%lu", (ULONG)GetLong());
            break;

        case CIM_BOOLEAN:
            swprintf(wszValue, L"%s", (GetBool()?L"TRUE":L"FALSE"));
            break;

        case CIM_REAL32:
            {
                // Since the decimal point can be localized, and MOF text should
                // always be english, we will return values localized to 0x409,

                CVar    var( GetFloat() );

                // If this fails, we can't guarantee a good value,
                // so throw an exception.

                if ( !var.ChangeTypeToEx( VT_BSTR ) )
                {
                    throw CX_Exception();
                }

                wcscpy( wszValue, var.GetLPWSTR() );
            }
            break;

        case CIM_REAL64:
            {
                // Since the decimal point can be localized, and MOF text should
                // always be english, we will return values localized to 0x409,

                CVar    var( GetDouble() );

                // If this fails, we can't guarantee a good value,
                // so throw an exception.

                if ( !var.ChangeTypeToEx( VT_BSTR ) )
                {
                    throw CX_Exception();
                }

                wcscpy( wszValue, var.GetLPWSTR() );
            }
            break;

        case CIM_CHAR16:
            if(GetShort() == 0)
                wcscpy(wszValue, L"0x0");
            else
                swprintf(wszValue, L"'\\x%X'", (WCHAR)GetShort());
            break;

        case CIM_OBJECT:
            swprintf(wszValue, L"\"not supported\"");
            break;

        case CIM_REFERENCE:
        case CIM_DATETIME:
        case CIM_STRING:
        case CIM_SINT64:
        case CIM_UINT64:
        {
            // Escape all the quotes
            // =====================

            int nStrLen = wcslen(GetLPWSTR());
            delete [] wszValue;
            wszValue = NULL;

            wszValue = new WCHAR[nStrLen*2+10];

            // Check for allocation failures
            if ( NULL == wszValue )
            {
                throw CX_MemoryException();
            }

            wszValue[0] = L'"';
            pwc = wszValue+1;
            for(i = 0; i < (int)nStrLen; i++)
            {    
                WCHAR wch = GetLPWSTR()[i];
                if(wch == L'\n')
                {
                    *(pwc++) = L'\\';
                    *(pwc++) = L'n';
                }
                else if(wch == L'\t')
                {
                    *(pwc++) = L'\\';
                    *(pwc++) = L't';
                }
                else if(wch == L'"' || wch == L'\\')
                {
                    *(pwc++) = L'\\';
                    *(pwc++) = wch;
                }
                else
                {
                    *(pwc++) = wch;
                }
            }
            *(pwc++) = L'"';
            *pwc = 0;
        }
            break;
        default:
            swprintf(wszValue, L"\"not supported\"");
            break;
        }
        
        BSTR strRes = SysAllocString(wszValue);

        // Still need to clean up this value
        delete [] wszValue;

        return strRes;
    }
    catch (...)
    {
        // Cleanup always if this has a value
        if ( NULL != wszValue )
        {
            delete [] wszValue;
        }

        // Rethrow the exception
        throw;
    }

}


BSTR CVar::TypeToText(int nType)
{
    const WCHAR* pwcType;

    switch(nType)
    {
    case VT_I1:
        pwcType = L"sint8";
        break;

    case VT_UI1:
        pwcType = L"uint8";
        break;

    case VT_I2:
        pwcType = L"sint16";
        break;

    case VT_UI2:
        pwcType = L"uint16";
        break;

    case VT_I4:
        pwcType = L"sint32";
        break;

    case VT_UI4:
        pwcType = L"uint32";
        break;

    case VT_I8:
        pwcType = L"sint64";
        break;

    case VT_UI8:
        pwcType = L"uint64";
        break;

    case VT_BOOL:
        pwcType = L"boolean";
        break;

    case VT_R4:
        pwcType = L"real32";
        break;

    case VT_R8:
        pwcType = L"real64";
        break;    

    case VT_BSTR:
        pwcType = L"string";
        break;

    case VT_DISPATCH:
        pwcType = L"object";
        break;

    case VT_UNKNOWN:
        pwcType = L"object";
        break;

    default:
        return NULL;
    }

    return SysAllocString(pwcType);
}

BSTR CVar::GetTypeText() 
{
    if(m_vt != VT_EX_CVARVECTOR)
    {
        return TypeToText(m_vt);
    }
    else
    {
        return TypeToText(GetVarVector()->GetType());
    }
}

BOOL CVar::ChangeTypeTo(VARTYPE vtNew)
{
    // TBD: there are more efficient ways!
    // ===================================

    // Create a VARIANT
    // ================

    VARIANT v;
    CClearMe auto1(&v);

    VariantInit(&v);
    FillVariant(&v);

    // Coerce it
    // =========

    HRESULT hres = WbemVariantChangeType(&v, &v, vtNew);
    if(FAILED(hres))
        return FALSE;

    // Load it back in
    // ===============

    Empty();
    SetVariant(&v);
    return TRUE;
}

// Performs localized changes (defaults to 0x409 for this)
BOOL CVar::ChangeTypeToEx(VARTYPE vtNew, LCID lcid /*=0x409*/)
{
    // TBD: there are more efficient ways!
    // ===================================

    // Create a VARIANT
    // ================

    VARIANT v;
    CClearMe auto1(&v);

    VariantInit(&v);
    FillVariant(&v);

    // Coerce it
    // =========

    try
    {
        HRESULT hres = VariantChangeTypeEx(&v, &v, lcid, 0L, vtNew);
        if(FAILED(hres))
            return FALSE;
    }
    catch(...)
    {
        return FALSE;
    }

    // Load it back in
    // ===============

    Empty();
    SetVariant(&v);
    return TRUE;
}

BOOL CVar::ToSingleChar()
{
    // Defer to CVarVector for arrays
    // ==============================

    if(m_vt == VT_EX_CVARVECTOR)
    {
        return GetVarVector()->ToSingleChar();
    }

    // Anything that's not a string follows normal OLE rules
    // =====================================================

    if(m_vt != VT_BSTR)
    {
        return ChangeTypeTo(VT_I2);
    }
    
    // It's a string. Make sure the length is 1
    // ========================================

    LPCWSTR wsz = GetLPWSTR();
    if(wcslen(wsz) != 1)
        return FALSE;

    // Take the first character
    // ========================
    
    WCHAR wc = wsz[0];
    Empty();

    SetShort(wc);
    return TRUE;
}

BOOL CVar::ToUI4()
{
    // Defer to CVarVector for arrays
    // ==============================

    if(m_vt == VT_EX_CVARVECTOR)
    {
        return GetVarVector()->ToSingleChar();
    }

    // Create a VARIANT
    // ================

    VARIANT v;
    CClearMe auto1(&v);

    VariantInit(&v);
    FillVariant(&v);

    // Coerce it
    // =========

    HRESULT hres = WbemVariantChangeType(&v, &v, VT_UI4);
    if(FAILED(hres))
        return FALSE;

    // Load it back in
    // ===============

    Empty();

    // Here we cheat and reset to VT_I4 so we can natively reset
    V_VT(&v) = VT_I4;
    SetVariant(&v);
    return TRUE;
}

//***************************************************************************
//
//  CVarVector::CVarVector
//
//  Default constructor.  The caller should not attempt to add any
//  elements when the internal type is VT_EMPTY.  Objects constructed
//  with this constructor should only be used as l-values in an 
//  assignment of CVarVector objects.
//
//***************************************************************************

CVarVector::CVarVector()
{
    m_Array.Empty();
    m_nType = VT_EMPTY;
    m_nStatus = no_error;
}

//***************************************************************************
//
//  CVarVector::CVarVector
//
//  This is the standard constructor.
//
//  PARAMETERS:
//  nVarType
//      An OLE VT_ type indicator.  Heterogeneous arrays are possible
//      if the type VT_EX_CVAR is used.  Embedded CVarVectors can
//      occur, since a CVar can in turn hold a CVarVector.
//  
//  nInitSize
//      The starting size of the internal CFlexArray. See FLEXARRY.CPP.
//  nGrowBy
//      The "grow by" factor of the internal CFlexArray. See FLEXARRAY.CPP.
//          
//***************************************************************************

CVarVector::CVarVector(
    int nVarType, 
    int nInitSize, 
    int nGrowBy
    ) :
    m_Array(nInitSize, nGrowBy)
{
    m_nType = nVarType;
    m_nStatus = no_error;
}

//***************************************************************************
//
//  CVarVector::CVarVector
//
//  Alternate constructor to build a new CVarVector based on a 
//  SAFEARRAY object.  The only supported types for the SAFEARRAY
//  are VT_BSTR, VT_UI1, VT_I2, VT_I4, VT_R4, and VT_R8.
//
//  PARAMETERS:
//  nVarType
//      The VT_ type indicator of the incoming SAFEARRAY.
//  pSrc
//      A pointer to a SAFEARRAY, which is treated as read-only.
//
//  NOTES:
//  This will set the internal m_nStatus variable to <unsupported> if
//  an unsupported VT_ type is in the SAFEARRAY.  The caller can immediately
//  call CVarVector::Status() after construction to see if the operation
//  was successful.
//
//***************************************************************************

CVarVector::CVarVector(int nVarType, SAFEARRAY *pSrc)
{
    SAFEARRAY* pNew = NULL;

    try
    {
        m_nType = nVarType;
        if(pSrc == NULL)
        {
            // NULL safearray --- empty
            // ========================

            m_nStatus = no_error;
            return;
        }

        // Bind to the incoming SAFEARRAY, but don't delete it during destruct.
        // ====================================================================
    
        if(SafeArrayGetDim(pSrc) != 1)
        {
            m_nStatus = unsupported;
            return;
        }

        long lLBound, lUBound;
        SafeArrayGetLBound(pSrc, 1, &lLBound);
        SafeArrayGetUBound(pSrc, 1, &lUBound);

        if(lLBound != 0)
        {
            // Non-0-based safearray --- since CSafeArray doesn't support that, and
            // we can't change pSrc, create a copy
            // ====================================================================
    
            if(FAILED(SafeArrayCopy(pSrc, &pNew)))
            {
                m_nStatus = failed;
                return;
            }
        
            SAFEARRAYBOUND sfb;
            sfb.cElements = (lUBound - lLBound) + 1;
            sfb.lLbound = 0;
            SafeArrayRedim(pNew, &sfb);
        }
        else
        {
            pNew = pSrc;
        }
        
        CSafeArray sa(pNew, nVarType, CSafeArray::no_delete | CSafeArray::bind);
    
        for (int i = 0; i < sa.Size(); i++) {

            CVar*   pVar = NULL;
        
            switch (m_nType) {
                case VT_BOOL:
                    {
                        VARIANT_BOOL boolVal = sa.GetBoolAt(i);

                        pVar = new CVar(boolVal, VT_BOOL);

                        // Check for allocation failure
                        if ( NULL == pVar )
                        {
                            throw CX_MemoryException();
                        }

                        if ( m_Array.Add( pVar ) != CFlexArray::no_error )
                        {
                            delete pVar;
                            throw CX_MemoryException();
                        }

                        break;
                    }

                case VT_UI1: 
                    {
                        BYTE b = sa.GetByteAt(i);

                        pVar = new CVar(b);

                        // Check for allocation failure
                        if ( NULL == pVar )
                        {
                            throw CX_MemoryException();
                        }

                        if ( m_Array.Add( pVar ) != CFlexArray::no_error )
                        {
                            delete pVar;
                            throw CX_MemoryException();
                        }
                        break;
                    }

                case VT_I2:  
                    {
                        SHORT s = sa.GetShortAt(i);

                        pVar = new CVar(s);

                        // Check for allocation failure
                        if ( NULL == pVar )
                        {
                            throw CX_MemoryException();
                        }

                        if ( m_Array.Add( pVar ) != CFlexArray::no_error )
                        {
                            delete pVar;
                            throw CX_MemoryException();
                        }
                        break;
                    }

                case VT_I4:
                    {
                        LONG l = sa.GetLongAt(i);

                        pVar = new CVar(l);

                        // Check for allocation failure
                        if ( NULL == pVar )
                        {
                            throw CX_MemoryException();
                        }

                        if ( m_Array.Add( pVar ) != CFlexArray::no_error )
                        {
                            delete pVar;
                            throw CX_MemoryException();
                        }
                        break;
                    }

                case VT_R4:
                    {
                        float f = sa.GetFloatAt(i);

                        pVar = new CVar(f);

                        // Check for allocation failure
                        if ( NULL == pVar )
                        {
                            throw CX_MemoryException();
                        }

                        if ( m_Array.Add( pVar ) != CFlexArray::no_error )
                        {
                            delete pVar;
                            throw CX_MemoryException();
                        }
                        break;
                    }

                case VT_R8:
                    {
                        double d = sa.GetDoubleAt(i);

                        pVar = new CVar(d);

                        // Check for allocation failure
                        if ( NULL == pVar )
                        {
                            throw CX_MemoryException();
                        }

                        if ( m_Array.Add( pVar ) != CFlexArray::no_error )
                        {
                            delete pVar;
                            throw CX_MemoryException();
                        }
                        break;
                    }

                case VT_BSTR:
                    {
                        BSTR bstr = sa.GetBSTRAt(i);
                        CSysFreeMe auto1(bstr);

                        pVar = new CVar(VT_BSTR, bstr, FALSE);

                        // Check for allocation failure
                        if ( NULL == pVar )
                        {
                            throw CX_MemoryException();
                        }

                        if ( m_Array.Add( pVar ) != CFlexArray::no_error )
                        {
                            delete pVar;
                            throw CX_MemoryException();
                        }

                        break;
                    }
                case VT_DISPATCH:
                    {
                        IDispatch* pDisp = sa.GetDispatchAt(i);
                        CReleaseMe auto2(pDisp);

                        pVar = new CVar;

                        // Check for allocation failure
                        if ( NULL == pVar )
                        {
                            throw CX_MemoryException();
                        }

                        pVar->SetDispatch(pDisp);
                        if ( m_Array.Add( pVar ) != CFlexArray::no_error )
                        {
                            delete pVar;
                            throw CX_MemoryException();
                        }
                        break;
                    }
                case VT_UNKNOWN:
                    {
                        IUnknown* pUnk = sa.GetUnknownAt(i);
                        CReleaseMe auto3(pUnk);
                        pVar = new CVar;

                        // Check for allocation failure
                        if ( NULL == pVar )
                        {
                            throw CX_MemoryException();
                        }

                        pVar->SetUnknown(pUnk);
                        if ( m_Array.Add( pVar ) != CFlexArray::no_error )
                        {
                            delete pVar;
                            throw CX_MemoryException();
                        }
                        break;
                    }

                default:
                    m_nStatus = unsupported;
                    if(pNew != pSrc)
                        SafeArrayDestroy(pNew);
                    return;
            }
        }

        if(pNew != pSrc)
            SafeArrayDestroy(pNew);

        m_nStatus = no_error;
    }
    catch (CX_MemoryException)
    {
        // SafeArrayCopy, GetBSTRAt, new can all throw exceptions

        m_nStatus = failed;

        if(pNew != pSrc)
            SafeArrayDestroy(pNew);

        throw;
    }
}

//***************************************************************************
//
//  CVarVector::GetNewSafeArray
//
//  Allocates a new SAFEARRAY equivalent to the current CVarVector.
//  
//  RETURN VALUE:
//  A new SAFEARRAY pointer which must be deallocated with 
//  SafeArrayDestroy().  Returns NULL on error or unsupported types.
//
//***************************************************************************

SAFEARRAY *CVarVector::GetNewSafeArray()
{
    CSafeArray *pArray = new CSafeArray(m_nType, CSafeArray::no_delete);

    // Check for an allocation failure
    if ( NULL == pArray )
    {
        throw CX_MemoryException();
    }

    CDeleteMe<CSafeArray> auto1(pArray);

    for (int i = 0; i < m_Array.Size(); i++) {
        CVar &v = *(CVar *) m_Array[i];
        switch (m_nType) {
            case VT_UI1:
                pArray->AddByte(v.GetByte());
                break;

            case VT_I2:
                pArray->AddShort(v.GetShort());
                break;

            case VT_I4:
                pArray->AddLong(v.GetLong());
                break;

            case VT_R4:
                pArray->AddFloat(v.GetFloat());
                break;

            case VT_R8:
                pArray->AddDouble(v.GetDouble());
                break;

            case VT_BOOL:
                pArray->AddBool(v.GetBool());
                break;
                
            case VT_BSTR:
                {
                    BSTR s = v.GetBSTR();
                    CSysFreeMe auto2(s);
                    pArray->AddBSTR(s);
                    break;
                }
            case VT_DISPATCH:
                {
                    IDispatch* pDisp = v.GetDispatch();
                    CReleaseMe auto3(pDisp);
                    pArray->AddDispatch(pDisp);
                    break;
                }
            case VT_UNKNOWN:
                {
                    IUnknown* pUnk = v.GetUnknown();
                    CReleaseMe auto4(pUnk);
                    pArray->AddUnknown(pUnk);
                    break;
                }
            default:
                // For unsupported types, return a NULL.
                // Since we constructed the SAFEARRAY object to
                // not delete the SAFEARRAY and we have encountered
                // a condition where the internal SAFEARRAY of
                // CSafeArray should not be returned, we have
                // to switch our destruct policy.
                // ================================================
                pArray->SetDestructorPolicy(CSafeArray::auto_delete);
                return 0;
        }
    }

    // Final cleanup.  Get the SAFEARRAY pointer, and delete
    // the wrapper.
    // =====================================================
    
    pArray->Trim();
    
    SAFEARRAY *pRetValue = pArray->GetArray();
    return pRetValue;
}

//***************************************************************************
//
//  CVarVector::~CVarVector
//
//  Destructor.
//
//***************************************************************************

CVarVector::~CVarVector()
{
    Empty();
}

//***************************************************************************
//
//  CVarVector::Empty
//
//***************************************************************************

void CVarVector::Empty()
{
    for (int i = 0; i < m_Array.Size(); i++)  {
        delete (CVar *) m_Array[i];
    }
    m_Array.Empty();
    m_nType = VT_EMPTY;
    m_nStatus = no_error;
}


//***************************************************************************
//
//  CVarVector::CVarVector
//   
//  Copy constructor.  This is implemented via the assignment operator.
// 
//***************************************************************************

CVarVector::CVarVector(CVarVector &Src)
{
    m_nType = 0;
    m_nStatus = no_error;    
    *this = Src;
}

//***************************************************************************
//
//  CVarVector::operator =
//
//  Assignment operator.
//
//***************************************************************************

CVarVector& CVarVector::operator =(CVarVector &Src)
{
    Empty();

    for (int i = 0; i < Src.m_Array.Size(); i++) 
    {
        CVar* pVar = new CVar(*(CVar *) Src.m_Array[i]);

        // Check for an allocation failure
        if ( NULL == pVar )
        {
            throw CX_MemoryException();
        }

        if ( m_Array.Add( pVar ) != CFlexArray::no_error )
        {
            delete pVar;
            throw CX_MemoryException();
        }
    }

    m_nStatus = Src.m_nStatus;
    m_nType = Src.m_nType;

    return *this;
}

//***************************************************************************
//
//  CVarVector::operator ==
//
//  Equality test operator.
//
//***************************************************************************

int CVarVector::operator ==(CVarVector &Src)
{
    return CompareTo(Src, TRUE);
}

BOOL CVarVector::CompareTo(CVarVector& Src, BOOL bIgnoreCase)
{
    if (m_nType != Src.m_nType)
        return 0;

    if (m_Array.Size() != Src.m_Array.Size())
        return 0;

    for (int i = 0; i < Src.m_Array.Size(); i++)  {
        CVar *pThisVar = (CVar *) m_Array[i];
        CVar *pThatVar = (CVar *) Src.m_Array[i];

        if (!pThisVar->CompareTo(*pThatVar, bIgnoreCase))
            return 0;
    }

    return 1;
}

//***************************************************************************
//
//  CVarVector::Add
//
//  Adds a new CVar to the array.  A reference is used so that anonymous
//  objects can be constructed in the Add() call:
//
//      pVec->Add(CVar(33));
//
//  PARAMETERS:
//  Value
//      A reference to a CVar object of the correct type for the array.
//      No type checking is done. 
//
//  RETURN VALUE:
//  no_error
//  failed
//
//***************************************************************************

int CVarVector::Add(CVar &Value)
{
    CVar *p = new CVar(Value);

    // Check for allocation failures
    if ( NULL == p )
    {
        return failed;
    }

    if (m_Array.Add(p) != CFlexArray::no_error)
    {
        delete p;
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CVarVector::Add
//
//  Adds a new CVar to the array.  This overload simply takes ownership
//  of the incoming pointer and adds it directly.
//
//  PARAMETERS:
//  pAcquiredPtr
//      A pointer to a CVar object which is acquired by the vector.
//
//  RETURN VALUE:
//  no_error
//  failed
//
//***************************************************************************

int CVarVector::Add(CVar *pAcquiredPtr)
{
    if (m_Array.Add(pAcquiredPtr) != CFlexArray::no_error)
    {
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CVarVector::RemoveAt
//
//  Removes the array element at the specified index.
//
//  PARAMETERS:
//  nIndex
//      The location at which to remove the element.
//
//  RETURN VALUE:
//  no_error
//      On success.
//  failed
//      On range errors, etc.
//
//***************************************************************************

int CVarVector::RemoveAt(int nIndex)
{
    CVar *p = (CVar *) m_Array[nIndex];
    delete p;
    if (m_Array.RemoveAt(nIndex) != CFlexArray::no_error)
        return failed;

    return no_error;
}

//***************************************************************************
//
//  CVarVector::InsertAt
//
//  Inserts the new element at the specified location.
//  
//  PARAMETERS:
//  nIndex
//      The location at which to add the new element.
//  Value
//      A reference to the new value.
//
//  RETURN VALUE:
//  no_error
//      On success.
//  failed
//      An invalid nIndex value was specified.      
//
//***************************************************************************

int CVarVector::InsertAt(int nIndex, CVar &Value)
{
    CVar *pNew = new CVar(Value);

    // Check for allocation failures
    if ( NULL == pNew )
    {
        return failed;
    }

    if (m_Array.InsertAt(nIndex, pNew) != CFlexArray::no_error)
    {
        delete pNew;
        return failed;
    }
    return no_error;
}


BSTR CVarVector::GetText(long lFlags, long lType/* = 0 */)
{
    // Construct an array of values
    // ============================

    BSTR* aTexts = NULL;
    int i;

    try
    {
        aTexts = new BSTR[Size()];

        // Check for allocation failures
        if ( NULL == aTexts )
        {
            throw CX_MemoryException();
        }

        memset(aTexts, 0, Size() * sizeof(BSTR));

        int nTotal = 0;
        for(i = 0; i < Size(); i++)
        {
            aTexts[i] = GetAt(i).GetText(lFlags, lType);
            nTotal += SysStringLen(aTexts[i]) + 2; // 2: for ", "
        }

        // Allocate a BSTR to contain them all
        // ===================================

        BSTR strRes = SysAllocStringLen(NULL, nTotal);
        CSysFreeMe auto2(strRes);
        *strRes = 0;

        for(i = 0; i < Size(); i++)
        {
            if(i != 0)
            {
                wcscat(strRes, L", ");
            }

            wcscat(strRes, aTexts[i]);
            SysFreeString(aTexts[i]);
        }

        delete [] aTexts;
        aTexts = NULL;
        BSTR strPerfectRes = SysAllocString(strRes);
        return strPerfectRes;
    }
    catch(CX_MemoryException)
    {
        // new, GetText, SysAllocStringLen and SysAllocString can all throw exceptions
        if (NULL != aTexts)
        {
            for(int x = 0; x < Size(); x++)
            {
                if (NULL != aTexts[x])
                    SysFreeString(aTexts[x]);
            }
            delete [] aTexts;
            aTexts = NULL;
        }

        throw;
    }
}

BOOL CVarVector::ToSingleChar()
{
    for(int i = 0; i < Size(); i++)
    {
        if(!GetAt(i).ToSingleChar())
            return FALSE;
    }

    // Since all of the conversions succeeded, we will
    // assume the vector type is now VT_I2.

    m_nType = VT_I2;
    return TRUE;
}

BOOL CVarVector::ToUI4()
{
    for(int i = 0; i < Size(); i++)
    {
        if(!GetAt(i).ToUI4())
            return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemtest\wt_wstring.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WSTRING.CPP

Abstract:

    Utility string class

History:

    a-raymcc    30-May-96       Created.
    a-dcrews    16-Mar-99       Added out-of-memory exception handling

--*/

#include "precomp.h"
#include <stdio.h>
#include <WT_wstring.h>

class CX_MemoryException
{
};

static wchar_t g_szNullString[1] = {0};

inline void WString::DeleteString(wchar_t *pStr)
{
    if (pStr != g_szNullString)
        delete [] pStr;
}

WString::WString()
{ 
    m_pString = g_szNullString; 
}
WString::WString(wchar_t *pSrc, BOOL bAcquire)
{
    if (bAcquire) {
        m_pString = pSrc;
        if (m_pString == 0)
            m_pString = g_szNullString;
        return;            
    }

    if (pSrc == 0) {
        m_pString = g_szNullString;
        return;
    }

    m_pString = new wchar_t[wcslen(pSrc) + 1];

    // Watch for allocation failures
    if ( NULL == m_pString )
    {
        throw CX_MemoryException();
    }

    wcscpy(m_pString, pSrc);
}

WString::WString(DWORD dwResourceID, HMODULE hMod)
{
    int iSize = 100;
    BOOL bNotDone = TRUE;
    TCHAR* pTemp = NULL;

    // load the string from the string table.  Since we dont know what size, try increasing the
    // buffer till it works, or until the clearly obsurd case is hit

    while (iSize < 10240)
    {
        pTemp = new TCHAR [iSize];

        // Watch for allocation failures
        if ( NULL == pTemp )
        {
            throw CX_MemoryException();
        }

        int iRead = LoadString(hMod, dwResourceID, pTemp, iSize);
        if(iRead == 0)
        {
            // Bad string

            m_pString = g_szNullString;
            delete [] pTemp;
            return;
        }
        if(iRead +1 < iSize)
            break;      // all is well;
        iSize += 100;    // Try again
        delete [] pTemp;
        pTemp = NULL;
    }

#ifdef UNICODE
//For unicode, this is the string we need!
    m_pString = pTemp;
#else
//Only have to convert if we are not using unicode, otherwise it is already in wide mode!
    if(pTemp)
    {   
        // got a narrow string, allocate a large string buffer and convert

        long len = mbstowcs(NULL, pTemp, lstrlen(pTemp)+1) + 1;
        m_pString = new wchar_t[len];

        // Watch for allocation failures
        if ( NULL == m_pString )
        {
            delete [] pTemp;
            throw CX_MemoryException();
        }

        mbstowcs(m_pString, pTemp, lstrlen(pTemp)+1);
        delete [] pTemp;
    }
    else
        m_pString = g_szNullString;
#endif

}


WString::WString(const wchar_t *pSrc)
{
    if (pSrc == 0) {
        m_pString = g_szNullString;
        return;
    }

    m_pString = new wchar_t[wcslen(pSrc) + 1];

    // Watch for allocation failures
    if ( NULL == m_pString )
    {
        throw CX_MemoryException();
    }

    wcscpy(m_pString, pSrc);
}

WString::WString(const char *pSrc)
{
    m_pString = new wchar_t[strlen(pSrc) + 1];

    // Watch for allocation failures
    if ( NULL == m_pString )
    {
        throw CX_MemoryException();
    }

    mbstowcs(m_pString, pSrc, strlen(pSrc) + 1);
//    swprintf(m_pString, L"%S", pSrc);
}

LPSTR WString::GetLPSTR() const
{
    long len = 2*(wcslen(m_pString) + 1);
    char *pTmp = new char[len];

    // Watch for allocation failures
    if ( NULL == pTmp )
    {
        throw CX_MemoryException();
    }

    wcstombs(pTmp, m_pString, len);
//    sprintf(pTmp, "%S", m_pString);
    return pTmp;
}

WString& WString::operator =(const WString &Src)
{
    DeleteString(m_pString);
    m_pString = new wchar_t[wcslen(Src.m_pString) + 1];

    // Watch for allocation failures
    if ( NULL == m_pString )
    {
        throw CX_MemoryException();
    }

    wcscpy(m_pString, Src.m_pString);
    return *this;    
}

WString& WString::operator =(LPCWSTR pSrc)
{
    DeleteString(m_pString);
    m_pString = new wchar_t[wcslen(pSrc) + 1];

    // Watch for allocation failures
    if ( NULL == m_pString )
    {
        throw CX_MemoryException();
    }

    wcscpy(m_pString, pSrc);
    return *this;    
}

WString& WString::operator +=(const wchar_t *pOther)
{
    wchar_t *pTmp = new wchar_t[wcslen(m_pString) + 
            wcslen(pOther) + 1];

    // Watch for allocation failures
    if ( NULL == pTmp )
    {
        throw CX_MemoryException();
    }

    wcscpy(pTmp, m_pString);
    wcscat(pTmp, pOther);
    DeleteString(m_pString);
    m_pString = pTmp;
    return *this;            
}

WString& WString::operator +=(wchar_t NewChar)
{
    wchar_t Copy[2];
    Copy[0] = NewChar;
    Copy[1] = 0;
    wchar_t *pTmp = new wchar_t[wcslen(m_pString) + 2];

    // Watch for allocation failures
    if ( NULL == pTmp )
    {
        throw CX_MemoryException();
    }

    wcscpy(pTmp, m_pString);
    wcscat(pTmp, Copy);
    DeleteString(m_pString);
    m_pString = pTmp;
    return *this;            
}


WString& WString::operator +=(const WString &Other)
{
    wchar_t *pTmp = new wchar_t[wcslen(m_pString) + 
            wcslen(Other.m_pString) + 1];

    // Watch for allocation failures
    if ( NULL == pTmp )
    {
        throw CX_MemoryException();
    }

    wcscpy(pTmp, m_pString);
    wcscat(pTmp, Other.m_pString);
    DeleteString(m_pString);
    m_pString = pTmp;
    return *this;            
}


wchar_t WString::operator[](int nIndex) const
{
    if (nIndex >= (int) wcslen(m_pString))
        return 0;
    return m_pString[nIndex];        
}


WString& WString::TruncAtRToken(wchar_t Token)
{
    for (int i = (int) wcslen(m_pString); i >= 0; i--) {
        wchar_t wc = m_pString[i];
        m_pString[i] = 0;
        if (wc == Token)
            break;
    }
    
    return *this;        
}


WString& WString::TruncAtLToken(wchar_t Token)
{
    int nStrlen = wcslen(m_pString);
    for (int i = 0; i < nStrlen ; i++) 
    {
        if (Token == m_pString[i])
        {
            m_pString[i] = 0;
            break;
        }        
    }
    
    return *this;        
}


WString& WString::StripToToken(wchar_t Token, BOOL bIncludeToken)
{
    int nStrlen = wcslen(m_pString);
    wchar_t *pTmp = new wchar_t[nStrlen + 1];

    // Watch for allocation failures
    if ( NULL == pTmp )
    {
        throw CX_MemoryException();
    }

    *pTmp = 0;

    BOOL bFound = FALSE;
        
    for (int i = 0; i < nStrlen; i++) {
        if (m_pString[i] == Token) {
            bFound = TRUE;
            break;    
        }            
    }    

    if (!bFound)
        return *this;
        
    if (bIncludeToken) i++;
    wcscpy(pTmp, &m_pString[i]);
    DeleteString(m_pString);
    m_pString = pTmp;
    return *this;
}

LPWSTR WString::UnbindPtr()
{
    if (m_pString == g_szNullString)
    {
        m_pString = new wchar_t[1];

        // Watch for allocation failures
        if ( NULL == m_pString )
        {
            throw CX_MemoryException();
        }

        *m_pString = 0;
    }
    wchar_t *pTmp = m_pString;
    m_pString = g_szNullString;
    return pTmp;
}

WString& WString::StripWs(int nType)
{
    if (nType & leading)
    {
        wchar_t *pTmp = new wchar_t[wcslen(m_pString) + 1];

        // Watch for allocation failures
        if ( NULL == pTmp )
        {
            throw CX_MemoryException();
        }

        int i = 0;
        while (iswspace(m_pString[i]) && m_pString[i]) i++;
        wcscpy(pTmp, &m_pString[i]);
        DeleteString(m_pString);
        m_pString = pTmp;
    }
               
    if (nType & trailing)
    {
        wchar_t *pCursor = m_pString + wcslen(m_pString) - 1;
        while (pCursor >= m_pString && iswspace(*pCursor)) 
            *pCursor-- = 0;
    }
    return *this;
}

wchar_t *WString::GetLToken(wchar_t Tok) const
{
    wchar_t *pCursor = m_pString;
    while (*pCursor && *pCursor != Tok) pCursor++;
    if (*pCursor == Tok)
        return pCursor;
    return 0;                
}

WString WString::operator()(int nLeft, int nRight) const
{
    wchar_t *pTmp = new wchar_t[wcslen(m_pString) + 1];

    // Watch for allocation failures
    if ( NULL == pTmp )
    {
        throw CX_MemoryException();
    }

    wchar_t *pCursor = pTmp;
        
    for (int i = nLeft; i < (int) wcslen(m_pString) && i <= nRight; i++)
        *pCursor++ = m_pString[i];
    *pCursor = 0;

    return WString(pTmp, TRUE);        
}

BOOL WString::ExtractToken(const wchar_t * pDelimiters, WString &Extract)
{
    if(pDelimiters == NULL)
    {
        Extract.Empty();
        return FALSE;
    }

    // Find which character in the list works.  Use the first if none are
    // present

    int nLen = wcslen(m_pString);
    int nDimLen = wcslen(pDelimiters);

    for (int i = 0; i < nLen; i++)
        for(int j = 0; j < nDimLen; j++)
            if (m_pString[i] == pDelimiters[j])
                return ExtractToken(pDelimiters[j], Extract);

    // If none were found, just use the first.

    return ExtractToken(*pDelimiters, Extract);

}
 
BOOL WString::ExtractToken(wchar_t Delimiter, WString &Extract)
{
    int i, i2;
    BOOL bTokFound = FALSE;
    Extract.Empty();
    int nLen = wcslen(m_pString);
    wchar_t *pTmp = new wchar_t[nLen + 1];
    
    // Watch for allocation failures
    if ( NULL == pTmp )
    {
        throw CX_MemoryException();
    }

    for (i = 0; i < nLen; i++)
        if (m_pString[i] == Delimiter) {
            bTokFound = TRUE;
            break;    
        }            
        else
            pTmp[i] = m_pString[i];            

    pTmp[i] = 0;
    Extract.BindPtr(pTmp);                      
                                              
    // Now make *this refer to any leftover stuff.
    // ===========================================
    pTmp = new wchar_t[nLen - wcslen(pTmp) + 1];

    // Watch for allocation failures
    if ( NULL == pTmp )
    {
        throw CX_MemoryException();
    }

    *pTmp = 0;

    for (i2 = 0, i++; i <= nLen; i++)
        pTmp[i2++] = m_pString[i];

    DeleteString(m_pString);
    m_pString = pTmp;
    
    // Return TRUE if the token was encountered, FALSE if not.
    // =======================================================
    return bTokFound;
}

void WString::Empty()
{
    DeleteString(m_pString);
    m_pString = g_szNullString;
}

static int _WildcardAux(const wchar_t *pszWildstr, const wchar_t *pszTargetstr, 
    int iGreedy)
{
    enum { start, wild, strip } eState;
    wchar_t cInput, cInputw, cLaToken;
    
    if (!wcslen(pszTargetstr) || !wcslen(pszWildstr))
        return 0;
                
    for (eState = start;;)
        switch (eState)
        {
            case start:
                cInputw = *pszWildstr++;        // wildcard input 
                cInput = *pszTargetstr;         // target input 

                if (!cInputw)                   // at end of wildcard string? 
                    goto EndScan;

                // Check for wildcard chars first 
                   
                if (cInputw == L'?') {          // Simply strips both inputs 
                    if (!cInput)                // If end of input, error 
                        return 0;
                    pszTargetstr++;
                    continue;
                }
                if (cInputw == L'*')  {
                    eState = wild;                
                    break;
                }

                // If here, an exact match is required.                 

                if (cInput != cInputw)
                    return 0;
                    
                // Else remain in same state, since match succeeded 
                pszTargetstr++;
                break;

            case wild:
                cLaToken = *pszWildstr++;   // Establish the lookahead token 
                eState = strip;
                break;

            case strip:
                cInput = *pszTargetstr;

                if (cInput == cLaToken) {
                    if (!cInput)            // Match on a NULL 
                        goto EndScan;
                    ++pszTargetstr;  

                    // If there is another occurrence of the lookahead 
                    // token in the string, and we are in greedy mode,
                    // stay in this state 

                    if (!iGreedy)
                        eState = start;

                    if (!wcschr(pszTargetstr, cLaToken))
                        eState = start;

                    break;
                }
                    
                if (cLaToken && !cInput)    // End of input with a non-null la token 
                    return 0;

                ++pszTargetstr;             // Still stripping input 
                break;
        }


    //  Here if the wildcard input is exhausted.  If the
    //  target string is also empty, we have a match,
    //  otherwise not. 

EndScan:
    if (wcslen(pszTargetstr))
        return 0; 

    return 1;   
}

// Run the test both with greedy and non-greedy matching, allowing the
// greatest possible chance of a match. 

BOOL WString::WildcardTest(const wchar_t *pszWildstr) const
{
    return (_WildcardAux(pszWildstr, m_pString, 0) | 
            _WildcardAux(pszWildstr, m_pString, 1));
}


void WString::Unquote()
{
    if (!m_pString)
        return;
    int nLen = wcslen(m_pString);
    if (nLen == 0)
        return;

    // Remove trailing quote.
    // ======================
    
    if (m_pString[nLen - 1] == L'"')
        m_pString[nLen - 1] = 0;

    // Remove leading quote.
    // =====================
    
    if (m_pString[0] == L'"')
    {
        for (int i = 0; i < nLen; i++)
            m_pString[i] = m_pString[i + 1];
    }
}

WString WString::EscapeQuotes() const
{
    WString ws;

    int nLen = Length();
    for(int i = 0; i < nLen; i++)
    {
        if(m_pString[i] == '"' || m_pString[i] == '\\')
        {
            ws += L'\\';
        }

        ws += m_pString[i];
    }

    return ws;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\winmgmt2\localloc.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include <arena.h>

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\winmgmt2\cntserv.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    CNTSERV.H

Abstract:


History:

  a-davj      20-June-96  Created.
  ivanbrug    30-Aug-2000 modified for SvcHost

--*/

#ifndef _CNTSERV_H_
#define _CNTSERV_H_

#define DEFAULT_WAIT_HINT 30000


class CNtService {
public: 

    CNtService(DWORD ControlAccepted);
    ~CNtService();

    // Starts up the service.  This must be called to start the service.
    //==================================================================

    virtual DWORD Run(LPWSTR pszServiceName,
              DWORD dwNumServicesArgs,
              LPWSTR *lpServiceArgVectors,
              PVOID lpData);

    // This MUST be overridden since this is where the actual work is done
    //====================================================================

    virtual DWORD WorkerThread() = 0;

    // This MUST be overridden to signal the worker thread to exit its routine
    //=========================================================================

    virtual void Stop(BOOL bSystemShutDownCalled) = 0;

    // If there is some lengthy initialization, it should be done by 
    // overriding this routine.
    //===============================================================

    virtual BOOL Initialize(DWORD dwNumServicesArgs,
                            LPWSTR *lpServiceArgVectors){return TRUE;};
    virtual void FinalCleanup(){};

    // These routines are optional and should be overridden if the features
    // are desired.  Note that supporting Pause and Continue also require a
    // call to SetPauseContinue()
    //=====================================================================

    virtual void Pause(){return;};
    virtual void Continue(){return;};

    // dumps messages to the event log.  Can be overriden if there is 
    // another diagnostic in place.
    //===============================================================

    virtual VOID Log(LPCTSTR lpszMsg);

private:

    static DWORD WINAPI _HandlerEx(DWORD dwControl,
                                  DWORD dwEventType, 
                                  LPVOID lpEventData,
                                  LPVOID lpContext);

    BOOL m_bStarted;
    TCHAR * m_pszServiceName;
    DWORD m_dwCtrlAccepted;
    SERVICE_STATUS          ssStatus;       // current status of the service
    SERVICE_STATUS_HANDLE   sshStatusHandle;
                                                                                         
    virtual DWORD WINAPI HandlerEx(DWORD dwControlCode,
                         DWORD dwEventType, 
                         LPVOID lpEventData,
                         LPVOID lpContext);
    
protected:

    // this might come in handy if the derived class needs to communicate
    // with the SCM.
    //===================================================================

    BOOL ReportStatusToSCMgr(DWORD dwCurrentState,
         DWORD dwWin32ExitCode, DWORD dwCheckPoint, DWORD dwWaitHint);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\winmgmt2\list_entry.h ===
#include <winnt.h>

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))


//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wbemtest\wt_wstring.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WSTRING.H

Abstract:

    Utility string class

History:

	a-raymcc    30-May-96       Created.
	a-dcrews	16-Mar-99		Added out-of-memory exception handling

--*/

#ifndef _WSTRING_H_
#define _WSTRING_H_

#include "WT_strutils.h"

class WString
{
    wchar_t *m_pString;

    void DeleteString(wchar_t *pStr);

public:
    enum { leading = 0x1, trailing = 0x2 };

    WString(wchar_t *pSrc, BOOL bAcquire = FALSE);
    WString(DWORD dwResourceID, HMODULE hMod);      // creates from resource string
    WString(const wchar_t *pSrc);
    WString(const char *pSrc);
//    inline WString() { m_pString = g_szNullString; }
	WString();
    inline WString(const WString &Src) {  m_pString = 0; *this = Src; }
    WString& operator =(const WString &);
    WString& operator =(LPCWSTR);
   inline ~WString() { DeleteString(m_pString); }
    inline int Length() const { return wcslen(m_pString); }

    WString& operator +=(const WString &Other);
    WString& operator +=(const wchar_t *);
    WString& operator +=(wchar_t);
    
    inline operator const wchar_t *() const { return m_pString; } 
    inline operator wchar_t *() { return m_pString; } 
    wchar_t operator[](int nIndex) const;
    LPSTR GetLPSTR() const;

    inline BOOL Equal(const wchar_t *pTarget) const
        { return wcscmp(m_pString, pTarget) == 0; }
    inline BOOL EqualNoCase(const wchar_t *pTarget) const
        { return wbem_wcsicmp(m_pString, pTarget) == 0; }

    inline BOOL operator< (LPCWSTR wszTarget) const
        { return wcscmp(m_pString, wszTarget) < 0; }
    inline BOOL operator> (LPCWSTR wszTarget) const
        { return wcscmp(m_pString, wszTarget) > 0; }
    inline BOOL operator<= (LPCWSTR wszTarget) const
        { return wcscmp(m_pString, wszTarget) <= 0; }
    inline BOOL operator>= (LPCWSTR wszTarget) const
        { return wcscmp(m_pString, wszTarget) >= 0; }
        

    LPWSTR UnbindPtr();
    inline void BindPtr(LPWSTR ptr) { DeleteString(m_pString); m_pString = ptr; }
    void Empty();
    WString& StripWs(int nType);
        // Strip whitespace, use with a combination
        // of leading | trailing
        
    WString& TruncAtRToken(wchar_t Token);
        // Truncates the string at the token starting from the
        // right end. The token itself is also wiped out.

    WString& TruncAtLToken(wchar_t Token);
          
    WString& StripToToken(wchar_t Token, BOOL bIncludeToken);
        // Strips leading chars until the token is encountered.
        // If bIncludeTok==TRUE, strips the token too.

    wchar_t *GetLToken(wchar_t wcToken) const;
        // Gets the first occurrence of wcToken in the string or NULL
        
    WString operator()(int, int) const;
        // Returns a new WString based on the slice
        
    BOOL ExtractToken(const wchar_t * pDelimiters, WString &Extract);
        // Extracts the leading chars up to the token delimiter,
        // Removing the token from *this, and assigning the extracted
        // part to <Extract>.

    BOOL ExtractToken(wchar_t Delimiter, WString &Extract);
        // Extracts the leading chars up to the token delimiter,
        // Removing the token from *this, and assigning the extracted
        // part to <Extract>.
        
    BOOL WildcardTest(const wchar_t *pTestStr) const;
        // Tests *this against the wildcard string.  If a match,
        // returns TRUE, else FALSE.        
        
    void Unquote();        
        // Removes leading/trailing quotes, if any. 
        // Leaves escaped quotes intact.

    WString EscapeQuotes() const;
};

class WSiless
{
public:
    inline bool operator()(const WString& ws1, const WString& ws2) const
        {return wbem_wcsicmp(ws1, ws2) < 0;}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\winmgmt2\cntserv.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    CNTSERV.CPP

Abstract:

    A class which allows easy creation of Win32 Services.   This class
    only allows one service per .EXE file.  The process can be run as a
    service or a regular non-service EXE, a runtime option.

    This class is largly based on the SMS CService class which was created by
    a-raymcc.  This differs in that it is simplified in two ways; First, it 
    does not keep track of the worker threads since that is the responsibility
    of the derived code, and second, it doesnt use some SMS specific diagnostics

    NOTE: See the file SERVICE.TXT for details on how to use this class.
    There are a number of issues which cannot be conveyed by simply studying
    the class declaration.

History:

  a-davj      20-June-96  Created.

--*/

#include "precomp.h"
#include <wtypes.h>
#include <stdio.h>
#include "cntserv.h"

//****************************************************************************
//
//  CNtService::CNtService
//  CNtService::~CNtService
//
//  Constructor and destructor.
//
//****************************************************************************

CNtService::CNtService(DWORD ControlAccepted)
{
    m_dwCtrlAccepted = ControlAccepted;
    m_bStarted = FALSE;
    m_pszServiceName = NULL;
}

CNtService::~CNtService()
{
    if(m_pszServiceName)
        delete m_pszServiceName;
}

//
//
//  CNtService::Run
//
//
//////////////////////////////////////////////////////////////////

DWORD CNtService::Run(LPWSTR pszServiceName,
                      DWORD dwNumServicesArgs,
                      LPWSTR *lpServiceArgVectors,
                      PVOID lpData)
{


    m_pszServiceName = new TCHAR[lstrlen(pszServiceName)+1];
    if(m_pszServiceName == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;
    lstrcpyW(m_pszServiceName,pszServiceName);
    
    // Register our service control handler.
    // =====================================

    sshStatusHandle = RegisterServiceCtrlHandlerEx(m_pszServiceName, 
                                                   (LPHANDLER_FUNCTION_EX)CNtService::_HandlerEx,
                                                   lpData);

    if (!sshStatusHandle)
    {
        Log(TEXT("Initial call to RegisterServiceCtrlHandler failed"));
        goto cleanup;
    }

    ssStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
    ssStatus.dwServiceSpecificExitCode = 0;

    // Report the status to the service control manager.
    // =================================================

    if (!ReportStatusToSCMgr(
        SERVICE_START_PENDING,                // service state
        NO_ERROR,                             // exit code
        1,                                    // checkpoint
        DEFAULT_WAIT_HINT))                   // wait hint
        goto cleanup;


    if (!Initialize(dwNumServicesArgs, lpServiceArgVectors))
    {
        Log(TEXT("Initialize call failed, bailing out"));
        goto cleanup;
    }


    // Report the status to the service control manager.
    // =================================================

    if (!ReportStatusToSCMgr(
        SERVICE_RUNNING,       // service state
        NO_ERROR,              // exit code
        0,                     // checkpoint
        0))                    // wait hint
            goto cleanup;

    m_bStarted = TRUE;

    // The next routine is always over ridden and is 
    // where the acutal work of the service is done.
    // =============================================

    WorkerThread();     

    // Service is done, send last report to SCM.
    // =========================================

cleanup:
    m_bStarted = FALSE;

    //
    //
    //  we cannot rely on the distructor to be called after
    //  the SetServiceStatus(STOPPED) to perform operations
    //
    /////////////////////////////////////////////////////////

    FinalCleanup();

    ReportStatusToSCMgr(
        SERVICE_STOPPED,                 // service state
        NO_ERROR,                        // exit code
        0,                               // checkpoint
        0);                              // wait hint

    return 0;

}


//
//
//  CNtService::Log
//
//
//////////////////////////////////////////////////////////////////

VOID CNtService::Log(LPCTSTR lpszMsg)
{
    TCHAR   szMsg[256];
    HANDLE  hEventSource;
    LPCTSTR  lpszStrings[2];


    DWORD dwErr = GetLastError();
    wsprintf(szMsg, TEXT("%s error: %d"), m_pszServiceName, dwErr);

    // Dump the error code and text message out to the event log

    hEventSource = RegisterEventSource(NULL, m_pszServiceName);

    lpszStrings[0] = szMsg;
    lpszStrings[1] = lpszMsg;

    if (hEventSource != NULL) {
         ReportEvent(hEventSource, // handle of event source
                     EVENTLOG_ERROR_TYPE,  // event type
                     0,                    // event category
                     0,                    // event ID
                     NULL,                 // current user's SID
                     2,                    // strings in lpszStrings
                     0,                    // no bytes of raw data
                     lpszStrings,          // array of error strings
                     NULL);                // no raw data

            (VOID) DeregisterEventSource(hEventSource);
    }
    
}

//****************************************************************************
//
//  CNtService::_Handler
//
//  Entry points for calls from the NT service control manager.  These entry
//  points just call the actual functions using the default object.
//
//****************************************************************************


DWORD WINAPI CNtService::_HandlerEx(
  DWORD dwControl,     // requested control code
  DWORD dwEventType,   // event type
  LPVOID lpEventData,  // event data
  LPVOID lpContext     // user-defined context data
)
{
    if (lpContext)
    {
        return ((CNtService *)lpContext)->HandlerEx(dwControl,dwEventType,lpEventData,lpContext);
    }
    else
    {
        DebugBreak();
        return ERROR_INVALID_PARAMETER;
    }
}


//****************************************************************************
//
//  CNtService::ReportStatusToSCMgr
//
//  Used by other member functions to report their status to the
//  service control manager.
//
//  Parameters:
//      DWORD dwCurrentState            One of the SERVICE_ codes.
//      DWORD dwWin32ExitCode           A Win32 Error code; usually 0.
//      DWORD dwCheckPoint              Checkpoint value (not used).
//      DWORD dwWaitHint                Milliseconds before Service Control
//                                      Manager gets worried.
//  Returns:
//
//      BOOL fResult                    Whatever code was returned
//                                      by SetServiceStatus().
//
//****************************************************************************

BOOL CNtService::ReportStatusToSCMgr(DWORD dwCurrentState,
    DWORD dwWin32ExitCode, DWORD dwCheckPoint, DWORD dwWaitHint)
{
    BOOL fResult;

    // Disable control requests until the service is started.
    // ======================================================

    if (dwCurrentState == SERVICE_START_PENDING)
    {
        ssStatus.dwControlsAccepted = 0;
    }
    else if (dwCurrentState == SERVICE_STOPPED)
    {
        ssStatus.dwControlsAccepted = 0;    
    }
    else
    {
        ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN |
            m_dwCtrlAccepted;
    }

    // These SERVICE_STATUS members are set from parameters.
    // =====================================================

    ssStatus.dwCurrentState  = dwCurrentState;
    ssStatus.dwWin32ExitCode = dwWin32ExitCode;
    ssStatus.dwCheckPoint    = dwCheckPoint;
    ssStatus.dwWaitHint      = dwWaitHint;

    // Report the status of the service to the service control manager.
    // ================================================================

    if (!(fResult = SetServiceStatus(
        sshStatusHandle,    // service reference handle
        &ssStatus)))
    {

        // If an error occurs, log it.
        // =====================================
        
        Log(TEXT("Could not SetServiceStatus"));

    }

    //Sleep(250);     // Give SC Man a chance to read this

    return fResult;
}

//*****************************************************************************
//
//  CNtService::Handler
//
//  This handles incoming messages from the Service Controller.
//
//  Parameters:
//
//      DWORD dwControlCode             One of the SERVICE_CONTROL_
//                                      codes or a user defined code 125..255.
//
//*****************************************************************************

DWORD WINAPI 
CNtService::HandlerEx(  DWORD dwControl,     // requested control code
                             DWORD dwEventType,   // event type
                             LPVOID lpEventData,  // event data
                             LPVOID lpContext     // user-defined context data
)
{
    switch(dwControl) {

        // Pause, set initial status, call overriden function and set final status
        //========================================================================

        case SERVICE_CONTROL_PAUSE:

            ReportStatusToSCMgr(
                    SERVICE_PAUSE_PENDING,     // current state
                    NO_ERROR,                  // exit code
                    1,                         // checkpoint
                    DEFAULT_WAIT_HINT);        // wait hint
            Pause();
            ReportStatusToSCMgr(
                    SERVICE_PAUSED,            // current state
                    NO_ERROR,                  // exit code
                    0,                         // checkpoint
                    0);                        // wait hint    
            break;


        // Continue, set initial status, call overriden function and set final status
        //===========================================================================

        case SERVICE_CONTROL_CONTINUE:

            ReportStatusToSCMgr(
                    SERVICE_CONTINUE_PENDING,  // current state
                    NO_ERROR,                  // exit code
                    1,                         // checkpoint
                    DEFAULT_WAIT_HINT);      // wait hint

            Continue(); 

            ReportStatusToSCMgr(
                    SERVICE_RUNNING,           // current state
                    NO_ERROR,                  // exit code
                    0,                         // checkpoint
                    0);                        // wait hint

            break;

        // Stop the service.  Note that the Stop function is supposed
        // to signal the worker thread which should return which then
        // causes the StartMain() function to end which sends the
        // final status!  
        //==========================================================

        case SERVICE_CONTROL_SHUTDOWN:
        case SERVICE_CONTROL_STOP:

            ReportStatusToSCMgr(
                    SERVICE_STOP_PENDING,      // current state
                    NO_ERROR,                  // exit code
                    1,                         // checkpoint
                    DEFAULT_WAIT_HINT);        // wait hint

            Stop((dwControl == SERVICE_CONTROL_SHUTDOWN)?TRUE:FALSE);
            
            break;

        // Could get an interrogate at any time, just report the current status.
        //======================================================================

        case SERVICE_CONTROL_INTERROGATE:
            ReportStatusToSCMgr(
                    ssStatus.dwCurrentState,   // current state
                    NO_ERROR,                  // exit code
                    1,                         // checkpoint
                    DEFAULT_WAIT_HINT);        // wait hint
            break;

        // Some user defined code.  Call the overriden function and report status.
        //========================================================================

        default:
            ReportStatusToSCMgr(
                    ssStatus.dwCurrentState,   // current state
                    NO_ERROR,                  // exit code
                    1,                         // checkpoint
                    DEFAULT_WAIT_HINT);        // wait hint
            return ERROR_CALL_NOT_IMPLEMENTED;
    }

    return NO_ERROR;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\winmgmt2\backuprestore.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    BackupRestore.H

Abstract:

    Backup Restore Interface.

History:

--*/

#ifndef __BACKUPRESTORE_H__
#define __BACKUPRESTORE_H__ 

#include "precomp.h"

#include <sync.h>

interface IWmiDbController;
class CWbemBackupRestore : IWbemBackupRestoreEx
{
public:
	enum CallerType
	{
	    VssWriter = 'wssV',
	    NtBackup = 'kcaB'
	};
	enum Traces 
	{
    	MaxTraceSize = 8
	};
	enum MethodTypes 
	{
	    mBackup = 1,
	    mRestore = 2,
	    mPause = 4,
	    mResume = 8
	};
protected:
    long   m_cRef;    	
    TCHAR *m_pDbDir;
	TCHAR *m_pWorkDir;
    HINSTANCE m_hInstance;
	// used by extended interface
	IWmiDbController* m_pController;
	LONG m_PauseCalled;

    static LIST_ENTRY s_ListHead;
    static CCritSec s_CritSec;

    LIST_ENTRY m_ListEntry;
    //CallerType m_Caller;
    int m_Method;
    DWORD    m_CallerId;
    PVOID    m_Trace[MaxTraceSize];
    

public:
        CWbemBackupRestore(HINSTANCE hInstance);

        virtual ~CWbemBackupRestore(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID riid, LPVOID *ppv)
		{
	
			if (IID_IUnknown==riid || 
			  IID_IWbemBackupRestore==riid || 
			  IID_IWbemBackupRestoreEx==riid)
			{
				*ppv=this;
			}
			else
			{
         		*ppv=NULL;			
    			return E_NOINTERFACE;
			}

			((IUnknown*)(*ppv))->AddRef();
			return NOERROR;
		};

        STDMETHODIMP_(ULONG) AddRef(void)
		{    
			return ++m_cRef;
		};
        STDMETHODIMP_(ULONG) Release(void)
		{
			long lRef = InterlockedDecrement(&m_cRef);
			if (0L == lRef)
				delete this;
			return lRef;
		};

		HRESULT STDMETHODCALLTYPE Backup(
			LPCWSTR   strBackupToFile,
			long   lFlags);
		
		HRESULT STDMETHODCALLTYPE Restore(
			LPCWSTR   strRestoreFromFile,
			long   lFlags);


        void InitEmpty(){};
		TCHAR *GetDbDir();
		TCHAR *GetFullFilename(const TCHAR *pszFilename);
		TCHAR *GetExePath(const TCHAR *pszFilename);
		HRESULT GetDefaultRepDriverClsId(CLSID &clsid);

		// EXTENDED interface
		HRESULT STDMETHODCALLTYPE Pause();
		HRESULT STDMETHODCALLTYPE Resume();
		
};

#endif /*__BACKUPRESTORE_H__*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\winmgmt2\mofdutil.cpp ===
#include "precomp.h"
#include <tchar.h>
#include <malloc.h>

#include <mofcomp.h> // for AUTORECOVERY_REQUIRED

#include "winmgmt.h"   // this project
#include "arrtempl.h" // for CDeleteMe

//
//
//  CheckNoResyncSwitch
//
//////////////////////////////////////////////////////////////////

BOOL CheckNoResyncSwitch( void )
{
    BOOL bRetVal = TRUE;
    DWORD dwVal = 0;
    Registry rCIMOM(WBEM_REG_WINMGMT);
    if (rCIMOM.GetDWORDStr( WBEM_NORESYNCPERF, &dwVal ) == Registry::no_error)
    {
        bRetVal = !dwVal;

        if ( bRetVal )
        {
            DEBUGTRACE((LOG_WBEMCORE, "NoResyncPerf in CIMOM is set to TRUE - ADAP will not be shelled\n"));
        }
    }

    // If we didn't get anything there, we should try the volatile key
    if ( bRetVal )
    {
        Registry rAdap( HKEY_LOCAL_MACHINE, KEY_READ, WBEM_REG_ADAP);

        if ( rAdap.GetDWORD( WBEM_NOSHELL, &dwVal ) == Registry::no_error )
        {
            bRetVal = !dwVal;

            if ( bRetVal )
            {
                DEBUGTRACE((LOG_WBEMCORE, 
                    "NoShell in ADAP is set to TRUE - ADAP will not be shelled\n"));
            }

        }
    }

    return bRetVal;
}

//
//
//  CheckNoResyncSwitch
//
//////////////////////////////////////////////////////////////////

BOOL 
CheckSetupSwitch( void )
{
    BOOL bRetVal = FALSE;
    DWORD dwVal = 0;
    Registry r(WBEM_REG_WINMGMT);
    if (r.GetDWORDStr( WBEM_WMISETUP, &dwVal ) == Registry::no_error)
    {
        bRetVal = dwVal;
        DEBUGTRACE((LOG_WBEMCORE, "Registry entry is indicating a setup is running\n"));
    }
    return bRetVal;
}

//
//
//  CheckGlobalSetupSwitch
//
//////////////////////////////////////////////////////////////////

BOOL 
CheckGlobalSetupSwitch( void )
{
    BOOL bRetVal = FALSE;
    DWORD dwVal = 0;
    Registry r(_T("system\\Setup"));
    if (r.GetDWORD(_T("SystemSetupInProgress"), &dwVal ) == Registry::no_error)
    {
        if(dwVal == 1)
            bRetVal = TRUE;
    }
    return bRetVal;
}

//
//
//
// This function will place a volatile registry key under the 
// CIMOM key in which we will write a value indicating 
// we should not shell ADAP.  This way, after a setup runs, WINMGMT
// will NOT automatically shell ADAP dredges of the registry, 
// until the system is rebooted and the volatile registry key is removed.
//
//
///////////////////////////////////////////////////////////////////////////

void SetNoShellADAPSwitch( void )
{
    HKEY    hKey = NULL;
    DWORD   dwDisposition = 0;

    Registry  r( HKEY_LOCAL_MACHINE, 
                 REG_OPTION_VOLATILE, KEY_ALL_ACCESS, WBEM_REG_ADAP );

    if ( ERROR_SUCCESS == r.GetLastError() )
    {

        if ( r.SetDWORD( WBEM_NOSHELL, 1 ) != Registry::no_error )
        {
            DEBUGTRACE( ( LOG_WINMGMT, "Failed to create NoShell value in volatile reg key: %d\n",
                        r.GetLastError() ) );
        }

        RegCloseKey( hKey );
    }
    else
    {
        DEBUGTRACE( ( LOG_WINMGMT, "Failed to create volatile ADAP reg key: %d\n", r.GetLastError() ) );
    }

}

//
//
//  bool IsValidMulti
//
//
//  Does a sanity check on a multstring.
//
//////////////////////////////////////////////////////////////////////


BOOL IsValidMulti(TCHAR * pMultStr, DWORD dwSize)
{
    // Divide the size by the size of a tchar, in case these
    // are WCHAR strings
    dwSize /= sizeof(TCHAR);

    if(pMultStr && dwSize >= 2 && pMultStr[dwSize-2]==0 && pMultStr[dwSize-1]==0)
        return TRUE;
    return FALSE;
}

//
//
//  BOOL IsStringPresetn
//
//
//  Searches a multstring for the presense of a string.
//
//
////////////////////////////////////////////////////////////////////

BOOL IsStringPresent(TCHAR * pTest, TCHAR * pMultStr)
{
    TCHAR * pTemp;
    for(pTemp = pMultStr; *pTemp; pTemp += lstrlen(pTemp) + 1)
        if(!lstrcmpi(pTest, pTemp))
            return TRUE;
    return FALSE;
}


//
//
//  AddToAutoRecoverList
//
//
////////////////////////////////////////////////////////////////////

void AddToAutoRecoverList(TCHAR * pFileName)
{
    TCHAR cFullFileName[MAX_PATH+1];
    TCHAR * lpFile;
    DWORD dwSize;
    TCHAR * pNew = NULL;
    TCHAR * pTest;
    DWORD dwNewSize = 0;

    // Get the full file name

    long lRet = GetFullPathName(pFileName, MAX_PATH, cFullFileName, &lpFile);
    if(lRet == 0)
        return;

    BOOL bFound = FALSE;
    Registry r(WBEM_REG_WINMGMT);
    TCHAR *pMulti = r.GetMultiStr(__TEXT("Autorecover MOFs"), dwSize);

    // Ignore the empty string case

    if(dwSize == 1)
    {
        delete pMulti;
        pMulti = NULL;
    }
    if(pMulti)
    {
        if(!IsValidMulti(pMulti, dwSize))
        {
            delete pMulti;
            return;             // bail out, messed up multistring
        }
        bFound = IsStringPresent(cFullFileName, pMulti);
        if(!bFound)
            {

            // The registry entry does exist, but doesnt have this name
            // Make a new multistring with the file name at the end

            dwNewSize = dwSize + ((lstrlen(cFullFileName) + 1) * sizeof(TCHAR));
            pNew = new TCHAR[dwNewSize / sizeof(TCHAR)];
            if(!pNew)
                return;
            memcpy(pNew, pMulti, dwSize);

            // Find the double null

            for(pTest = pNew; pTest[0] || pTest[1]; pTest++);     // intentional semi

            // Tack on the path and ensure a double null;

            pTest++;
            lstrcpy(pTest, cFullFileName);
            pTest+= lstrlen(cFullFileName)+1;
            *pTest = 0;         // add second numm
        }
    }
    else
    {
        // The registry entry just doesnt exist.  
        // Create it with a value equal to our name

        dwNewSize = ((lstrlen(cFullFileName) + 2) * sizeof(TCHAR));
        pNew = new TCHAR[dwNewSize / sizeof(TCHAR)];
        if(!pNew)
            return;
        lstrcpy(pNew, cFullFileName);
        pTest = pNew + lstrlen(pNew) + 1;
        *pTest = 0;         // add second null
    }

    if(pNew)
    {
        // We will cast pNew, since the underlying function will have to cast to
        // LPBYTE and we will be WCHAR if UNICODE is defined
        r.SetMultiStr(__TEXT("Autorecover MOFs"), pNew, dwNewSize);
        delete pNew;
    }

    FILETIME ftCurTime;
    LARGE_INTEGER liCurTime;
    TCHAR szBuff[50];
    GetSystemTimeAsFileTime(&ftCurTime);
    liCurTime.LowPart = ftCurTime.dwLowDateTime;
    liCurTime.HighPart = ftCurTime.dwHighDateTime;
    _ui64tot(liCurTime.QuadPart, szBuff, 10);
    r.SetStr(__TEXT("Autorecover MOFs timestamp"), szBuff);

}


//
//  LoadMofsInDirectory
//
//
////////////////////////////////////////////////////////////////////////////////////////

void LoadMofsInDirectory(const TCHAR *szDirectory)
{
    if (NULL == szDirectory)
        return;
    
    if(CheckGlobalSetupSwitch())
        return;                     // not hot compiling during setup!
        
    TCHAR *szHotMofDirFF = new TCHAR[lstrlen(szDirectory) + lstrlen(__TEXT("\\*")) + 1];
    if(!szHotMofDirFF)return;
    CDeleteMe<TCHAR> delMe1(szHotMofDirFF);

    TCHAR *szHotMofDirBAD = new TCHAR[lstrlen(szDirectory) + lstrlen(__TEXT("\\bad\\")) + 1];
    if(!szHotMofDirBAD)return;
    CDeleteMe<TCHAR> delMe2(szHotMofDirBAD);

    TCHAR *szHotMofDirGOOD = new TCHAR[lstrlen(szDirectory) + lstrlen(__TEXT("\\good\\")) + 1];
    if(!szHotMofDirGOOD)return;
    CDeleteMe<TCHAR> delMe3(szHotMofDirGOOD);

    IWinmgmtMofCompiler * pCompiler = NULL;

    //Find search parameter
    lstrcpy(szHotMofDirFF, szDirectory);
    lstrcat(szHotMofDirFF, __TEXT("\\*"));

    //Where bad mofs go
    lstrcpy(szHotMofDirBAD, szDirectory);
    lstrcat(szHotMofDirBAD, __TEXT("\\bad\\"));

    //Where good mofs go
    lstrcpy(szHotMofDirGOOD, szDirectory);
    lstrcat(szHotMofDirGOOD, __TEXT("\\good\\"));

    //Make sure directories exist
    WbemCreateDirectory(szDirectory);
    WbemCreateDirectory(szHotMofDirBAD);
    WbemCreateDirectory(szHotMofDirGOOD);

    //Find file...
    WIN32_FIND_DATA ffd;
    HANDLE hFF = FindFirstFile(szHotMofDirFF, &ffd);

    if (hFF != INVALID_HANDLE_VALUE)
    {
        do
        {
            //We only process if this is a file
            if (!(ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                //Create a full filename with path
                TCHAR *szFullFilename = new TCHAR[lstrlen(szDirectory) + lstrlen(__TEXT("\\")) + lstrlen(ffd.cFileName) + 1];
                if(!szFullFilename) return;
                CDeleteMe<TCHAR> delMe4(szFullFilename);
                lstrcpy(szFullFilename, szDirectory);
                lstrcat(szFullFilename, __TEXT("\\"));
                lstrcat(szFullFilename, ffd.cFileName);


                TRACE((LOG_WBEMCORE,"Auto-loading MOF %s\n", szFullFilename));

                //We need to hold off on this file until it has been finished writing
                //otherwise the CompileFile will not be able to read the file!
                HANDLE hMof = INVALID_HANDLE_VALUE;
                DWORD dwRetry = 10;
                while (hMof == INVALID_HANDLE_VALUE)
                {
                    hMof = CreateFile(szFullFilename, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

                    //If cannot open yet sleep for a while
                    if (hMof == INVALID_HANDLE_VALUE)
                    {
                        if (--dwRetry == 0)
                            break;
                        Sleep(1000);
                    }
                }

                DWORD dwRetCode;
                WBEM_COMPILE_STATUS_INFO Info;
                DWORD dwAutoRecoverRequired = 0;
                if (hMof == INVALID_HANDLE_VALUE)
                {
                    TRACE((LOG_WBEMCORE,"Auto-loading MOF %s failed because we could not open it for exclusive access\n", szFullFilename));
                    dwRetCode = 1;
                }
                else
                {
                    CloseHandle(hMof);

                    //Load the MOF file
                    if(szFullFilename)
                    {

                        if (pCompiler == 0)
                        {
                            SCODE sc = CoCreateInstance(CLSID_WinmgmtMofCompiler, 
                                                        0, 
                                                        CLSCTX_INPROC_SERVER,
                                                        IID_IWinmgmtMofCompiler, 
                                                        (LPVOID *) &pCompiler);
                            if(sc != S_OK)
                                return;
                        }
                        dwRetCode = pCompiler->WinmgmtCompileFile(
                                szFullFilename,
                                NULL,
                                WBEM_FLAG_DONT_ADD_TO_LIST,             // autocomp, check, etc
                                0,
                                0,
                                NULL, NULL, &Info);
                    }
                }
                
                TCHAR *szNewDir = (dwRetCode?szHotMofDirBAD:szHotMofDirGOOD);
                TCHAR *szNewFilename = new TCHAR[lstrlen(szNewDir)  + lstrlen(ffd.cFileName) + 1];
                if(!szNewFilename) return;
                CDeleteMe<TCHAR> delMe5(szNewFilename);

                lstrcpy(szNewFilename, szNewDir);
                lstrcat(szNewFilename, ffd.cFileName);

                //Make sure we have access to delete the old file...
                DWORD dwOldAttribs = GetFileAttributes(szNewFilename);

                if (dwOldAttribs != -1)
                {
                    dwOldAttribs &= ~FILE_ATTRIBUTE_READONLY;
                    SetFileAttributes(szNewFilename, dwOldAttribs);

                    //Move it to directory
                    if (DeleteFile(szNewFilename))
                    {
                        TRACE((LOG_WBEMCORE, "Removing old MOF %s\n", szNewFilename));
                    }
                }
                
                TRACE((LOG_WBEMCORE, "Loading of MOF %s was %s.  Moving to %s\n", szFullFilename, dwRetCode?"unsuccessful":"successful", szNewFilename));
                MoveFile(szFullFilename, szNewFilename);

                //Now mark the file as read only so no one deletes it!!!
                //Like that stops anyone deleting files :-)
                dwOldAttribs = GetFileAttributes(szNewFilename);

                if (dwOldAttribs != -1)
                {
                    dwOldAttribs |= FILE_ATTRIBUTE_READONLY;
                    SetFileAttributes(szNewFilename, dwOldAttribs);
                }

                if ((dwRetCode == 0) && (Info.dwOutFlags & AUTORECOVERY_REQUIRED))
                {
                    //We need to add this item into the registry for auto-recovery purposes
                    TRACE((LOG_WBEMCORE, "MOF %s had an auto-recover pragrma.  Updating registry.\n", szNewFilename));
                    AddToAutoRecoverList(szNewFilename);
                }
            }

        } while (FindNextFile(hFF, &ffd));

        FindClose(hFF);
    }
    if (pCompiler)
        pCompiler->Release();
}


//
//
//  bool InitHotMofStuff
//
//
//////////////////////////////////////////////////////////////////

BOOL InitHotMofStuff( IN OUT struct _PROG_RESOURCES * pProgRes)
{

    // Get the installation directory

    if (pProgRes->szHotMofDirectory)
    {
        delete [] pProgRes->szHotMofDirectory;
    }

    Registry r1(WBEM_REG_WBEM);

    if (r1.GetStr(__TEXT("MOF Self-Install Directory"), &pProgRes->szHotMofDirectory) == Registry::failed)
    {
        // Look for the install directory
        TCHAR * pWorkingDir;

        if (r1.GetStr(__TEXT("Installation Directory"), &pWorkingDir))
        {
            ERRORTRACE((LOG_WINMGMT,"Unable to read 'Installation Directory' from registry\n"));
            return false;
        }

        pProgRes->szHotMofDirectory = new TCHAR [lstrlen(pWorkingDir) + lstrlen(__TEXT("\\MOF")) +1];
        if(!pProgRes->szHotMofDirectory)return false;
        _stprintf(pProgRes->szHotMofDirectory, __TEXT("%s\\MOF"), pWorkingDir);
        delete pWorkingDir;
        if(r1.SetStr(__TEXT("MOF Self-Install Directory"), pProgRes->szHotMofDirectory)  == Registry::failed)
        {
            ERRORTRACE((LOG_WINMGMT,"Unable to create 'Hot MOF Directory' in the registry\n"));
            return false;
        }
    }

    // Construct the path to the database.
    // ===================================

    WbemCreateDirectory(pProgRes->szHotMofDirectory);


    //Create an event on change notification for the MOF directory

    pProgRes->ghMofDirChange = FindFirstChangeNotification(pProgRes->szHotMofDirectory, 
                                                 FALSE, 
                                                 FILE_NOTIFY_CHANGE_FILE_NAME);
                                                 
    if (pProgRes->ghMofDirChange == INVALID_HANDLE_VALUE)
    {
        pProgRes->ghMofDirChange = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (pProgRes->ghMofDirChange == NULL)
            return false;
    }
    
    return true;
}


DWORD
BuildSD( OUT PSECURITY_DESCRIPTOR *ppSD,
         DWORD dwSids,
         PSID * ArraySids,
         DWORD AccessType)
{
    BOOL Status;
    ULONG SDLength;
    PACL pEventDacl = NULL;
    PSECURITY_DESCRIPTOR pEventSD = NULL;
    ULONG ulWorldAccess = 0;
    ULONG ulAdminAccess = 0;

    if (!ppSD)
    {
        return ERROR_INVALID_PARAMETER;
    }

    DWORD i;
    DWORD dwLenSids = 0;
    for (i=0;i<dwSids;i++)
    {
        dwLenSids += GetLengthSid(ArraySids[i]);
    }

    SDLength = sizeof(SECURITY_DESCRIPTOR) +
                   (ULONG) sizeof(ACL) +
                   (dwSids * ((ULONG) sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG))) + dwLenSids;


    pEventSD = (PSECURITY_DESCRIPTOR) HeapAlloc(GetProcessHeap(),0,SDLength);

    if (pEventSD == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pEventDacl = (PACL) ((PBYTE) pEventSD + sizeof(SECURITY_DESCRIPTOR));

    Status = InitializeAcl( pEventDacl,
                            SDLength - sizeof(SECURITY_DESCRIPTOR),
                            ACL_REVISION);

    if (Status) 
    {
        for (i=0; (i<dwSids) && Status; i++)
        {
		    Status = AddAccessAllowedAce (
		                 pEventDacl,
		                 ACL_REVISION,
		                 AccessType,
		                 ArraySids[i]);    
        }
    }

    //
    // Now initialize security descriptors
    // that export this protection
    //

    if (Status)
    {
	    Status = InitializeSecurityDescriptor(pEventSD,
                                              SECURITY_DESCRIPTOR_REVISION1);

        if (Status)
        {
		    Status = SetSecurityDescriptorDacl(
		                 pEventSD,
		                 TRUE,                       // DaclPresent
		                 pEventDacl,
		                 FALSE);                       // DaclDefaulted
	    }
    }

    if (Status)
    {
	    *ppSD = pEventSD;
	    return NO_ERROR;
    }
    else
    {
        HeapFree(GetProcessHeap(),0,pEventSD);
        return GetLastError();
    }
}

BOOL
SetEventDacl(HANDLE hEvent,DWORD Permission){

    BOOL bRet = FALSE;
    
    PSID pSidLocalSvc = NULL;
    SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;
	
    bRet = AllocateAndInitializeSid( &id, 1,
                              SECURITY_LOCAL_SERVICE_RID,0,0,0,0,0,0,0,&pSidLocalSvc);

    PSID pSidSystem = NULL;
    SID_IDENTIFIER_AUTHORITY id2 = SECURITY_NT_AUTHORITY;

	if (bRet)
	{
        bRet = AllocateAndInitializeSid( &id2, 1,
                              SECURITY_LOCAL_SYSTEM_RID,0,0,0,0,0,0,0,&pSidSystem);
    };

    PSID pSidAdmins = NULL;
    SID_IDENTIFIER_AUTHORITY id3 = SECURITY_NT_AUTHORITY;

	if (bRet)
	{
        bRet = AllocateAndInitializeSid( &id3, 2,
                              SECURITY_BUILTIN_DOMAIN_RID,DOMAIN_ALIAS_RID_ADMINS,0,0,0,0,0,0,&pSidAdmins);
    };


    PSID ArraySid[] = {pSidLocalSvc,pSidSystem,pSidAdmins};

    if (bRet)
    {
        PSECURITY_DESCRIPTOR pSD = NULL;
        if (NO_ERROR == BuildSD(&pSD,sizeof(ArraySid)/sizeof(PSID),ArraySid,Permission))
        {
            bRet = SetKernelObjectSecurity(hEvent,
                                           DACL_SECURITY_INFORMATION,
                                           pSD);

            HeapFree(GetProcessHeap(),0,pSD);
        }
    }

    DWORD i;
    for (i=0;i<sizeof(ArraySid)/sizeof(PSID);i++)
    {
        if (ArraySid[i])
        {
            FreeSid(ArraySid[i]);
        }
    }

    return bRet;

}


DWORD
BuildACL( DWORD dwSids,
          PSID  * ArraySids,
          DWORD * AccessType,
          DWORD * Flags,
          OUT PACL  * ppACL,
          OUT DWORD * nBytes)
{
    BOOL Status;
    ULONG ACLLength;
    PACL  pDacl = NULL;
    ULONG ulWorldAccess = 0;
    ULONG ulAdminAccess = 0;

    if (!ppACL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    DWORD i;
    DWORD dwLenSids = 0;
    for (i=0;i<dwSids;i++)
    {
        dwLenSids += GetLengthSid(ArraySids[i]);
    }

    ACLLength = (ULONG) sizeof(ACL) +
                   (dwSids * ((ULONG) sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG))) + dwLenSids;


    pDacl = (PACL) HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,ACLLength);

    if (pDacl == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Status = InitializeAcl( pDacl,
                            ACLLength,
                            ACL_REVISION);

    if (Status) 
    {
        for (i=0; (i<dwSids) && Status; i++)
        {
		    Status = AddAccessAllowedAceEx (
		                 pDacl,
		                 ACL_REVISION,
						 Flags[i],
		                 AccessType[i],
		                 ArraySids[i]);    
        }
    }

    if (Status)
    {
	    *ppACL = pDacl;
	    return NO_ERROR;
    }
    else
    {
        HeapFree(GetProcessHeap(),0,pDacl);
        return GetLastError();
    }
}

/*BOOL
AddAccountToDacl(HANDLE hToken,
                 BYTE SubCount,
                 DWORD dw0,
                 DWORD dw1,
                 DWORD dw2,
                 DWORD dw3,
                 DWORD dw4,
                 DWORD dw5,
                 DWORD dw6,
                 DWORD dw7,
                 DWORD dwAccess,
                 DWORD AceFlag){

    BOOL bRet = FALSE;
	DWORD i;
    
    PSID pSidAccount = NULL;
    SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;
	
    bRet = AllocateAndInitializeSid( &id, SubCount,
                                     dw0,dw1,dw2,dw3,dw4,dw5,dw6,dw7,&pSidAccount);

    //
	//
	// 
		
    PACL pDacl;
		
    if (bRet)
    {
        DWORD dwReq = 0;
        bRet = GetTokenInformation(hToken,
                                   TokenDefaultDacl,
                                   NULL,
                                   0,
                                   &dwReq);
        if ((FALSE == bRet) &&
            (ERROR_INSUFFICIENT_BUFFER == GetLastError()))
        {
            TOKEN_DEFAULT_DACL * pTDD = (TOKEN_DEFAULT_DACL *)_alloca(dwReq+sizeof(void*));
            bRet = GetTokenInformation(hToken,
                                       TokenDefaultDacl,
                                       pTDD,
                                       dwReq,
                                       &dwReq);
            pDacl = pTDD->DefaultDacl;
            
        }
    }

	if (!bRet)
	{
	    return FALSE;
	}
	
IVAN, if you plan to use this, please make sure that pDacl is
initialized in all cases.  There was a prefix bug on this

    WORD Count = pDacl->AceCount;
	PSID  * ArraySid = (PSID *)_alloca((Count+1)*sizeof(PSID));
	DWORD * Access   = (DWORD *)_alloca((Count+1)*sizeof(DWORD));
	DWORD * AceFlags   = (DWORD *)_alloca((Count+1)*sizeof(DWORD));


	for(i=0;i<Count;i++)
	{
		ACCESS_ALLOWED_ACE * pAce;
		if (GetAce(pDacl,i,(PVOID *)&pAce))
		{
			PSID pSid;
			AllocateAndInitializeSid(&id,8,0,0,0,0,0,0,0,0,&pSid);
			CopySid(40,pSid,(PSID)(&pAce->SidStart));
            ArraySid[i] = pSid;
			Access[i] = pAce->Mask;
			AceFlags[i] = pAce->Header.AceFlags;
		};	
	};

	ArraySid[i] = pSidAccount;
	Access[i] = dwAccess;
	AceFlags[i] = AceFlag;
	

    PACL pACL = NULL;
    DWORD dwBytes;
    if (NO_ERROR == BuildACL((Count+1),ArraySid,Access,AceFlags,&pACL,&dwBytes))
    {
        TOKEN_DEFAULT_DACL tddNew;
        tddNew.DefaultDacl = pACL;

        bRet = SetTokenInformation(hToken,
                                   TokenDefaultDacl,
                                   &tddNew,
                                   dwBytes);

        HeapFree(GetProcessHeap(),0,pACL);
    }


    
    for (i=0;i<(DWORD)(Count+1);i++)
    {
        if (ArraySid[i])
        {
            FreeSid(ArraySid[i]);
        }
    }

    return bRet;

}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\winmgmt2\backuprestore.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    BackupRestore.CPP

Abstract:

    Backup Restore Interface.

History:

  paulall       08-Feb-99   Implemented the call-outs to do the backup
                            and recovery.  Stole lots of code from the core
                            to get this working!

--*/

#include "precomp.h"
#include <wbemint.h>
#include <reg.h>
#include <cominit.h>  // for WbemCoImpersonate
#include <genutils.h> // for IsPrivilegePresent
#include <arrtempl.h> // for CReleaseMe
#include <CoreX.h>    // for CX_MemoryException
#include <reposit.h>

#include "BackupRestore.h"
#include "winmgmt.h"
#include <tchar.h>
#include <malloc.h>
#include <ScopeGuard.h>

#define RESTORE_FILE L"repdrvfs.rec"
#define DEFAULT_TIMEOUT_BACKUP   (15*60*1000)

HRESULT GetRepositoryDirectory(wchar_t wszRepositoryDirectory[MAX_PATH+1]);
HRESULT DoDeleteRepository(const wchar_t *wszExcludeFile);
HRESULT DoDeleteContentsOfDirectory(const wchar_t *wszExcludeFile, const wchar_t *wszRepositoryDirectory);
HRESULT DoDeleteDirectory(const wchar_t *wszExcludeFile, const wchar_t *wszParentDirectory, wchar_t *wszSubDirectory);
HRESULT GetRepPath(wchar_t wcsPath[MAX_PATH+1], wchar_t * wcsName);
HRESULT WbemPauseService();
HRESULT WbemContinueService();
HRESULT SaveRepository(wchar_t* wszRepositoryOrg, wchar_t* wszRepositoryBackup, const wchar_t* wszRecoveryActual);


BOOL CheckSecurity(LPCTSTR pPriv)
{
    HRESULT hres = WbemCoImpersonateClient();
	if (FAILED(hres))
		return FALSE;

    HANDLE hToken;
    BOOL bRet = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken);
    WbemCoRevertToSelf();
    if(!bRet)
        return FALSE;
    bRet = IsPrivilegePresent(hToken, pPriv);
    CloseHandle(hToken);
    return bRet;
}

//
//
//  Static Initialization
//
//////////////////////////////////////////////////////////////////////

LIST_ENTRY CWbemBackupRestore::s_ListHead = { &CWbemBackupRestore::s_ListHead, &CWbemBackupRestore::s_ListHead };
CCritSec CWbemBackupRestore::s_CritSec;


CWbemBackupRestore::CWbemBackupRestore(HINSTANCE hInstance) : m_pDbDir(0), 
                                            m_pWorkDir(0), m_hInstance(hInstance), 
                                            m_pController(0),m_PauseCalled(0),
                                            m_Method(0)
{
    m_cRef=0L;

    CInCritSec ics(&s_CritSec);
    InsertTailList(&s_ListHead,&m_ListEntry);

    //DBG_PRINTFA((pBuff,"+  (%p)\n",this));    
};

CWbemBackupRestore::~CWbemBackupRestore(void)
{
	if (m_PauseCalled)
		Resume();    // Resume will release the IDbController

	delete [] m_pDbDir;
	delete [] m_pWorkDir;

    CInCritSec ics(&s_CritSec);
    RemoveEntryList(&m_ListEntry);
	
    //DBG_PRINTFA((pBuff,"-  (%p)\n",this));
}

TCHAR *CWbemBackupRestore::GetDbDir()
{
    if (m_pDbDir == NULL)
    {
        if (m_pWorkDir == NULL)
        {
            Registry r1(WBEM_REG_WBEM);
            if (r1.GetStr(__TEXT("Installation Directory"), &m_pWorkDir))
            {
                ERRORTRACE((LOG_WBEMCORE,"Unable to read 'Installation Directory' from registry\n"));
                return NULL;
            }
        }
        Registry r(WBEM_REG_WINMGMT);
        if (r.GetStr(__TEXT("Repository Directory"), &m_pDbDir))
        {
            m_pDbDir = new TCHAR [lstrlen(m_pWorkDir) + lstrlen(__TEXT("\\Repository")) +1];
            wsprintf(m_pDbDir, __TEXT("%s\\REPOSITORY"), m_pWorkDir); 

            r.SetStr(__TEXT("Repository Directory"), m_pDbDir);
        }        
    }
    return m_pDbDir;
}

TCHAR *CWbemBackupRestore::GetFullFilename(const TCHAR *pszFilename)
{
    const TCHAR *pszDirectory = GetDbDir();
    TCHAR *pszPathFilename = new TCHAR[lstrlen(pszDirectory) + lstrlen(pszFilename) + 2];
    if (pszPathFilename == 0)
        return 0;
    lstrcpy(pszPathFilename, pszDirectory);
    if ((lstrlen(pszPathFilename)) && (pszPathFilename[lstrlen(pszPathFilename)-1] != '\\'))
    {
        lstrcat(pszPathFilename, __TEXT("\\"));
    }
    lstrcat(pszPathFilename, pszFilename);

    return pszPathFilename;
}
TCHAR *CWbemBackupRestore::GetExePath(const TCHAR *pszFilename)
{
    TCHAR *pszPathFilename = new TCHAR[lstrlen(m_pWorkDir) + lstrlen(pszFilename) + 2];
    if (pszPathFilename == 0)
        return 0;
    lstrcpy(pszPathFilename, m_pWorkDir);
    lstrcat(pszPathFilename, __TEXT("\\"));
    lstrcat(pszPathFilename, pszFilename);

    return pszPathFilename;
}

HRESULT CWbemBackupRestore::GetDefaultRepDriverClsId(CLSID &clsid)
{
    Registry r(WBEM_REG_WINMGMT);
    TCHAR *pClsIdStr = 0;
    TCHAR *pFSClsId = __TEXT("{7998dc37-d3fe-487c-a60a-7701fcc70cc6}");
    HRESULT hRes;
    TCHAR Buf[128];

    if (r.GetStr(__TEXT("Default Repository Driver"), &pClsIdStr))
    {
        // If here, default to FS for now.
        // =====================================
        r.SetStr(__TEXT("Default Repository Driver"), pFSClsId);
        wsprintf(Buf, __TEXT("%s"), pFSClsId);
        hRes = CLSIDFromString(Buf, &clsid);
        return hRes;
    }

    // If here, we actually retrieved one.
    // ===================================
    wsprintf(Buf, __TEXT("%s"), pClsIdStr);
    hRes = CLSIDFromString(Buf, &clsid);
    delete [] pClsIdStr;
    return hRes;
}

//***************************************************************************
//
//  CWbemBackupRestore::Backup()
//
//  Do the backup.
//
//***************************************************************************
HRESULT CWbemBackupRestore::Backup(LPCWSTR strBackupToFile, long lFlags)
{
#ifdef _X86_
    DWORD * pDW = (DWORD *)_alloca(sizeof(DWORD));   
#endif
    //DBG_PRINTFA((pBuff,"(%p)->Backup\n",this));

    m_Method |= mBackup;
    m_CallerId = GetCurrentThreadId();
    ULONG Hash;
    RtlCaptureStackBackTrace(0,MaxTraceSize,m_Trace,&Hash);

    
	if (m_PauseCalled)
	{
	    // invalid state machine
	    return WBEM_E_INVALID_OPERATION;	
	}
	else
	{   
	    try
	    {
	        // Check security
	        EnableAllPrivileges(TOKEN_PROCESS);
	        if(!CheckSecurity(SE_BACKUP_NAME))
	            return WBEM_E_ACCESS_DENIED;

	        // Check the params
	        if (NULL == strBackupToFile || (lFlags != 0))
	            return WBEM_E_INVALID_PARAMETER;

	        // Use GetFileAttributes to validate the path.
			DWORD dwAttributes = GetFileAttributesW(strBackupToFile);
	        if (dwAttributes == 0xFFFFFFFF)
	        {
				// It failed -- check for a no such file error (in which case, we're ok).
	            if (ERROR_FILE_NOT_FOUND != GetLastError())
	            {
	                return WBEM_E_INVALID_PARAMETER;
	            }
	        }
			else
			{
				// The file already exists -- create mask of the attributes that would make an existing file invalid for use
				DWORD dwMask =	FILE_ATTRIBUTE_DEVICE |
								FILE_ATTRIBUTE_DIRECTORY |
								FILE_ATTRIBUTE_OFFLINE |
								FILE_ATTRIBUTE_READONLY |
								FILE_ATTRIBUTE_REPARSE_POINT |
								FILE_ATTRIBUTE_SPARSE_FILE |
								FILE_ATTRIBUTE_SYSTEM |
								FILE_ATTRIBUTE_TEMPORARY;

				if (dwAttributes & dwMask)
					return WBEM_E_INVALID_PARAMETER;
			}

			// Retrieve the CLSID of the default repository driver
			CLSID clsid;
			HRESULT hRes = GetDefaultRepDriverClsId(clsid);
			if (FAILED(hRes))
				return hRes;

			// Call IWmiDbController to do backup
			IWmiDbController* pController = NULL;
	        _IWmiCoreServices *pCoreServices = NULL;
			int nRet = WBEM_NO_ERROR;
	        IWbemServices *pServices = NULL;

	        //Make sure the core is initialized...
	        hRes = CoCreateInstance(CLSID_IWmiCoreServices, NULL,
	                    CLSCTX_INPROC_SERVER, IID__IWmiCoreServices,
	                    (void**)&pCoreServices);
	        CReleaseMe rm1(pCoreServices);

	        if (SUCCEEDED(hRes))
	        {
	            hRes = pCoreServices->GetServices(L"root", NULL,NULL,0, IID_IWbemServices, (LPVOID*)&pServices);
	        }
	        CReleaseMe rm2(pServices);

	        if (SUCCEEDED(hRes))
	        {
	            hRes = CoCreateInstance(clsid, 0, CLSCTX_INPROC_SERVER, IID_IWmiDbController, (LPVOID *) &pController);
	        }
	        CReleaseMe rm3(pController);

			if (SUCCEEDED(hRes))
			{
			    //DBG_PRINTFA((pBuff,"(%p)->RealBackup\n",this));
				hRes = pController->Backup(strBackupToFile, lFlags);

				if (FAILED(hRes))
				{
					nRet = WBEM_E_FAILED;
				}
			}
			return nRet;
	    }
	    catch (CX_MemoryException)
	    {
	        return WBEM_E_OUT_OF_MEMORY;
	    }
	    catch (...)
	    {
	        return WBEM_E_CRITICAL_ERROR;
	    }
	}
}

//***************************************************************************
//
//  CWbemBackupRestore::Restore()
//
//  Do the restore.
//
//***************************************************************************
HRESULT CWbemBackupRestore::Restore(LPCWSTR strRestoreFromFile, long lFlags)
{
#ifdef _X86_
    DWORD * pDW = (DWORD *)_alloca(sizeof(DWORD));   
#endif
    //DBG_PRINTFA((pBuff,"(%p)->Restore\n",this));

    m_Method |= mRestore;
    m_CallerId = GetCurrentThreadId();
    ULONG Hash;
    RtlCaptureStackBackTrace(0,MaxTraceSize,m_Trace,&Hash);
    
	if (m_PauseCalled)
	{
	    // invalid state machine
	    return WBEM_E_INVALID_OPERATION;	
	}
	else
	{  
	    try
	    {
	        HRESULT hr = WBEM_S_NO_ERROR;

	        // Check security
	        EnableAllPrivileges(TOKEN_PROCESS);
		    if(!CheckSecurity(SE_RESTORE_NAME))
	            hr = WBEM_E_ACCESS_DENIED;

	        // Check the params
	        if (SUCCEEDED(hr) && ((NULL == strRestoreFromFile) || (lFlags & ~WBEM_FLAG_BACKUP_RESTORE_FORCE_SHUTDOWN)))
	            hr = WBEM_E_INVALID_PARAMETER;

	        // Use GetFileAttributes to validate the path.
	        if (SUCCEEDED(hr))
	        {
			    DWORD dwAttributes = GetFileAttributesW(strRestoreFromFile);
	            if (dwAttributes == 0xFFFFFFFF)
	            {
					hr = WBEM_E_INVALID_PARAMETER;
	            }
			    else
			    {
				    // The file exists -- create mask of the attributes that would make an existing file invalid for use
			        DWORD dwMask =	FILE_ATTRIBUTE_DEVICE |
							        FILE_ATTRIBUTE_DIRECTORY |
							        FILE_ATTRIBUTE_OFFLINE |
							        FILE_ATTRIBUTE_REPARSE_POINT |
							        FILE_ATTRIBUTE_SPARSE_FILE;

				    if (dwAttributes & dwMask)
					    hr = WBEM_E_INVALID_PARAMETER;
			    }
	        }

	        //**************************************************
	        // Shutdown the core if it is running
	        // and make sure it does not start up while we are
	        // preparing to restore...
	        //**************************************************
	        if (SUCCEEDED(hr))
	            hr = WbemPauseService();

	        //**************************************************
			// Now we need to copy over the <restore file> into
			// the repository directory
			// This must be done before the repository rename
			// because we don't know if the rename will affect
			// the location of the file, thus making
			// strRestoreFromFile invalid.
	        //**************************************************

	        wchar_t szRecoveryActual[MAX_PATH+1] = { 0 };
	    
	        if (SUCCEEDED(hr))
	            hr = GetRepPath(szRecoveryActual, RESTORE_FILE);

			bool bRestoreFileCopied = false;
	        if (SUCCEEDED(hr))
	        {
	            if(_wcsicmp(szRecoveryActual, strRestoreFromFile))
	            {
	                DeleteFileW(szRecoveryActual);
		            if (!CopyFileW(strRestoreFromFile, szRecoveryActual, FALSE))
						hr = WBEM_E_FAILED;
					else
						bRestoreFileCopied = true;
	            }
	        }

	        //**************************************************
	        // Now we need to rename the existing repository so
			// that we can restore it in the event of a failure.
			// We also need to create a new empty repository 
			// directory and recopy the <restore file> into it
			// from the now renamed original repository directory.
	        //**************************************************

			wchar_t wszRepositoryOrg[MAX_PATH+1] = { 0 };
			wchar_t wszRepositoryBackup[MAX_PATH+1] = { 0 };

			if (SUCCEEDED(hr))
			{
				hr = SaveRepository(wszRepositoryOrg, wszRepositoryBackup, szRecoveryActual);
			}

	        //**************************************************
	        //We now need to restart the core
	        //**************************************************
	        if (SUCCEEDED(hr))
			{
	            hr = WbemContinueService();

				//**************************************************
				//Connecting to winmgmt will now result in this 
				//backup file getting loaded
				//**************************************************
				if (SUCCEEDED(hr))
				{
					{   //Scoping for destruction of COM objects before CoUninitialize!
						IWbemLocator *pLocator = NULL;
						hr = CoCreateInstance(CLSID_WbemLocator,NULL, CLSCTX_ALL, IID_IWbemLocator,(void**)&pLocator);
						CReleaseMe relMe(pLocator);

						if (SUCCEEDED(hr))
						{
							IWbemServices *pNamespace = NULL;
							BSTR tmpStr = SysAllocString(L"root");
							CSysFreeMe sysFreeMe(tmpStr);

							hr = pLocator->ConnectServer(tmpStr, NULL, NULL, NULL, NULL, NULL, NULL, &pNamespace);
							CReleaseMe relMe4(pNamespace);
						}
					}
				}

				if (FAILED(hr))
				{
					// something failed, so we need to put back the original repository
					// - pause service
					// - delete failed repository
					// - rename the backed up repository
					// - restart the service

					HRESULT hres = WbemPauseService();

					if (SUCCEEDED(hres))
						hres = DoDeleteRepository(L"");

					if (SUCCEEDED(hres))
					{
						if (!RemoveDirectoryW(wszRepositoryOrg))
							hres = WBEM_E_FAILED;
					}

					if (SUCCEEDED(hres))
					{
						if (!MoveFileW(wszRepositoryBackup, wszRepositoryOrg))
							hres = WBEM_E_FAILED;
					}

					if (SUCCEEDED(hres))
						hres = WbemContinueService();
				}
				else
				{
					// restore succeeded, so delete the saved original repository
					HRESULT hres = DoDeleteContentsOfDirectory(L"", wszRepositoryBackup);
					if (SUCCEEDED(hres))
					{
						RemoveDirectoryW(wszRepositoryBackup);
					}
				}
			}

			//Delete our copy of the restore file if we made one
			if (bRestoreFileCopied)
			{
				if (*szRecoveryActual)
					DeleteFileW(szRecoveryActual);
			}

	        //**************************************************
	        //All done!
	        //**************************************************
	        return hr;
	    }
	    catch (CX_MemoryException)
	    {
	        return WBEM_E_OUT_OF_MEMORY;
	    }
	    catch (...)
	    {
	        return WBEM_E_CRITICAL_ERROR;
	    }
	}
}

//***************************************************************************
//	
//	EXTENDED Interface
//
//***************************************************************************

HRESULT CWbemBackupRestore::Pause()
{
#ifdef _X86_
    DWORD * pDW = (DWORD *)_alloca(sizeof(DWORD));   
#endif
    //DBG_PRINTFA((pBuff,"(%p)->Pause\n",this));

    m_Method |= mPause;
    m_CallerId = GetCurrentThreadId();
    ULONG Hash;
    RtlCaptureStackBackTrace(0,MaxTraceSize,m_Trace,&Hash);

    if (InterlockedCompareExchange(&m_PauseCalled,1,0))
    	return WBEM_E_INVALID_OPERATION;

    try
    {	
		HRESULT hRes = WBEM_NO_ERROR;

		// determine if we are already paused

        // Check security
		if (SUCCEEDED(hRes))
		{
			EnableAllPrivileges(TOKEN_PROCESS);
			if(!CheckSecurity(SE_BACKUP_NAME))
				hRes = WBEM_E_ACCESS_DENIED;
		}

		// Retrieve the CLSID of the default repository driver
		CLSID clsid;
		if (SUCCEEDED(hRes))
		{
			hRes = GetDefaultRepDriverClsId(clsid);
		}

        //Make sure the core is initialized...
		_IWmiCoreServices *pCoreServices = NULL;
		if (SUCCEEDED(hRes))
		{
			hRes = CoCreateInstance(CLSID_IWmiCoreServices, NULL, CLSCTX_INPROC_SERVER, IID__IWmiCoreServices, (void**)&pCoreServices);
		}
		CReleaseMe rm1(pCoreServices);

        IWbemServices *pServices = NULL;
        if (SUCCEEDED(hRes))
        {
            hRes = pCoreServices->GetServices(L"root", NULL,NULL,0, IID_IWbemServices, (LPVOID*)&pServices);
        }
        CReleaseMe rm2(pServices);

		// Call IWmiDbController to do UnlockRepository
        if (SUCCEEDED(hRes))
        {
            hRes = CoCreateInstance(clsid, 0, CLSCTX_INPROC_SERVER, IID_IWmiDbController, (LPVOID *) &m_pController);
        }

		if (SUCCEEDED(hRes))
		{
			hRes = m_pController->LockRepository();
			//DBG_PRINTFA((pBuff,"(%p)->Pause : LockRepository %08x\n",this,hRes));
			if (FAILED(hRes))
			{
				m_pController->Release();
				m_pController = reinterpret_cast<IWmiDbController*>(-1);	// For debug
			}
		}

		if (FAILED(hRes))
		{
			InterlockedDecrement(&m_PauseCalled);
		}

		return hRes;
    }
    catch (CX_MemoryException)
    {
		InterlockedDecrement(&m_PauseCalled);
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
		InterlockedDecrement(&m_PauseCalled);
        return WBEM_E_CRITICAL_ERROR;
    }
}

HRESULT CWbemBackupRestore::Resume()
{
#ifdef _X86_
    DWORD * pDW = (DWORD *)_alloca(sizeof(DWORD));   
#endif
    //DBG_PRINTFA((pBuff,"(%p)->Resume\n",this));

    m_Method |= mResume;
    m_CallerId = GetCurrentThreadId();
    ULONG Hash;
    RtlCaptureStackBackTrace(0,MaxTraceSize,m_Trace,&Hash);

    if (!m_PauseCalled)
	{
	    // invalid state machine pause without resume
	    return WBEM_E_INVALID_OPERATION;	
	}
    if (0 == m_pController ||
      -1 == (LONG_PTR)m_pController )
        return WBEM_E_INVALID_OPERATION;
	HRESULT hRes = m_pController->UnlockRepository();
	m_pController->Release();
	m_pController = 0;
	InterlockedDecrement(&m_PauseCalled);
	return hRes;
}


/******************************************************************************
 *
 *	GetRepositoryDirectory
 *
 *	Description:
 *		Retrieves the location of the repository directory from the registry.
 *
 *	Parameters:
 *		wszRepositoryDirectory:	Array to store location in.
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT GetRepositoryDirectory(wchar_t wszRepositoryDirectory[MAX_PATH+1])
{
    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                    L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                    0, KEY_READ, &hKey);
    if(lRes)
        return WBEM_E_FAILED;

    wchar_t wszTmp[MAX_PATH + 1];
    DWORD dwLen = MAX_PATH + 1;
    lRes = RegQueryValueExW(hKey, L"Repository Directory", NULL, NULL, 
                (LPBYTE)wszTmp, &dwLen);
	RegCloseKey(hKey);
    if(lRes)
        return WBEM_E_FAILED;

	if (ExpandEnvironmentStringsW(wszTmp,wszRepositoryDirectory, MAX_PATH + 1) == 0)
		return WBEM_E_FAILED;

	return WBEM_S_NO_ERROR;
}

/******************************************************************************
 *
 *	CRepositoryPackager::DeleteRepository
 *
 *	Description:
 *		Delete all files and directories under the repository directory.
 *		The repository directory location is retrieved from the registry.
 *
 *	Parameters:
 *		<none>
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT DoDeleteRepository(const wchar_t *wszExcludeFile)
{
	HRESULT hres = WBEM_S_NO_ERROR;
	wchar_t wszRepositoryDirectory[MAX_PATH+1];

	//Get the root directory of the repository
	hres = GetRepositoryDirectory(wszRepositoryDirectory);

	if (SUCCEEDED(hres))
	{
		hres = DoDeleteContentsOfDirectory(wszExcludeFile, wszRepositoryDirectory);
	}
	
	return hres;
}

/******************************************************************************
 *
 *	DoDeleteContentsOfDirectory
 *
 *	Description:
 *		Given a directory, iterates through all files and directories and
 *		calls into the function to delete it.
 *
 *	Parameters:
 *		wszRepositoryDirectory:	Directory to process
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT DoDeleteContentsOfDirectory(const wchar_t *wszExcludeFile, const wchar_t *wszRepositoryDirectory)
{
	HRESULT hres = WBEM_S_NO_ERROR;

	wchar_t *wszFullFileName = new wchar_t[MAX_PATH+1];
	if (wszFullFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;

	WIN32_FIND_DATAW findFileData;
	HANDLE hff = INVALID_HANDLE_VALUE;

	//create file search pattern...
	wchar_t *wszSearchPattern = new wchar_t[MAX_PATH+1];
	if (wszSearchPattern == NULL)
		hres = WBEM_E_OUT_OF_MEMORY;
	else
	{
		wcscpy(wszSearchPattern, wszRepositoryDirectory);
		wcscat(wszSearchPattern, L"\\*");
	}

	//Start the file iteration in this directory...
	if (SUCCEEDED(hres))
	{
		hff = FindFirstFileW(wszSearchPattern, &findFileData);
		if (hff == INVALID_HANDLE_VALUE)
		{
			hres = WBEM_E_FAILED;
		}
	}
	
	if (SUCCEEDED(hres))
	{
		do
		{
			//If we have a filename of '.' or '..' we ignore it...
			if ((wcscmp(findFileData.cFileName, L".") == 0) ||
				(wcscmp(findFileData.cFileName, L"..") == 0))
			{
				//Do nothing with these...
			}
			else if (findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			{
				//This is a directory, so we need to deal with that...
				hres = DoDeleteDirectory(wszExcludeFile, wszRepositoryDirectory, findFileData.cFileName);
				if (FAILED(hres))
					break;
			}
			else
			{
				//This is a file, so we need to deal with that...
				wcscpy(wszFullFileName, wszRepositoryDirectory);
				wcscat(wszFullFileName, L"\\");
				wcscat(wszFullFileName, findFileData.cFileName);

                //Make sure this is not the excluded filename...
                if (_wcsicmp(wszFullFileName, wszExcludeFile) != 0)
                {
				    if (!DeleteFileW(wszFullFileName))
				    {
					    hres = WBEM_E_FAILED;
					    break;
				    }
                }
			}
			
		} while (FindNextFileW(hff, &findFileData));
	}
	
	if (wszSearchPattern)
		delete [] wszSearchPattern;

	if (hff != INVALID_HANDLE_VALUE)
		FindClose(hff);

	return hres;
}

/******************************************************************************
 *
 *	DoDeleteDirectory
 *
 *	Description:
 *		This is the code which processes a directory.  It iterates through
 *		all files and directories in that directory.
 *
 *	Parameters:
 *		wszParentDirectory:	Full path of parent directory
 *		eszSubDirectory:	Name of sub-directory to process
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT DoDeleteDirectory(const wchar_t *wszExcludeFile, const wchar_t *wszParentDirectory, wchar_t *wszSubDirectory)
{
	HRESULT hres = WBEM_S_NO_ERROR;

	//Get full path of new directory...
	wchar_t *wszFullDirectoryName = NULL;
	if (SUCCEEDED(hres))
	{
		wszFullDirectoryName = new wchar_t[MAX_PATH+1];
		if (wszFullDirectoryName == NULL)
			hres = WBEM_E_OUT_OF_MEMORY;
		else
		{
			wcscpy(wszFullDirectoryName, wszParentDirectory);
			wcscat(wszFullDirectoryName, L"\\");
			wcscat(wszFullDirectoryName, wszSubDirectory);
		}
	}

	//delete the contents of that directory...
	if (SUCCEEDED(hres))
	{
		hres = DoDeleteContentsOfDirectory(wszExcludeFile, wszFullDirectoryName);
	}

	// now that the directory is empty, remove it
	if (!RemoveDirectoryW(wszFullDirectoryName))
    {   //If a remove directory fails, it may be because our excluded file is in it!
//		hres = WBEM_E_FAILED;
    }

	delete [] wszFullDirectoryName;

	return hres;
}

/******************************************************************************
 *
 *	GetRepPath
 *
 *	Description:
 *		Gets the repository path and appends the filename to the end
 *
 *	Parameters:
 *		wcsPath: repository path with filename appended
 *		wcsName: name of file to append
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_FAILED			If anything failed
 *
 ******************************************************************************
 */

HRESULT GetRepPath(wchar_t wcsPath[MAX_PATH+1], wchar_t * wcsName)
{
    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                    L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                    0, KEY_READ, &hKey);
    if(lRes)
        return WBEM_E_FAILED;

    wchar_t wszTmp[MAX_PATH+1];
    DWORD dwLen = MAX_PATH+1;
    lRes = RegQueryValueExW(hKey, L"Repository Directory", NULL, NULL, 
                (LPBYTE)(wchar_t*)wszTmp, &dwLen);
	RegCloseKey(hKey);
    if(lRes)
        return WBEM_E_FAILED;

	if (ExpandEnvironmentStringsW(wszTmp, wcsPath, MAX_PATH+1) == 0)
		return WBEM_E_FAILED;

	if (wcsPath[wcslen(wcsPath)] != L'\\')
		wcscat(wcsPath, L"\\");

	wcscat(wcsPath, wcsName);

    return WBEM_S_NO_ERROR;

}

/******************************************************************************
 *
 *	SaveRepository
 *
 *	Description:
 *		Moves the existing repository to a safe location so that it may be
 *		put back in the event of restore failure.  A new empty repository
 *		directory is then created, and our copy of the restore file is then
 *		recopied into it.
 *
 *	Parameters:
 *		wszRepositoryOrg:		original repository path
 *		wszRepositoryBackup:	saved repository path
 *		wszRecoveryActual:		name of our copy of the restore file
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */

HRESULT SaveRepository(wchar_t* wszRepositoryOrg, wchar_t* wszRepositoryBackup, const wchar_t* wszRecoveryActual)
{
	HRESULT hr = GetRepositoryDirectory(wszRepositoryOrg);

	if (SUCCEEDED(hr))
	{
		if (wszRepositoryOrg[wcslen(wszRepositoryOrg)] == L'\\')
			wszRepositoryOrg[wcslen(wszRepositoryOrg)] = L'\0';

		wcscpy(wszRepositoryBackup, wszRepositoryOrg);
		wcscat(wszRepositoryBackup, L"TempBackup");

		
		DWORD dwAttributes = GetFileAttributesW(wszRepositoryBackup);
        if (dwAttributes != 0xFFFFFFFF)
        {
			// something with this name already exists, find out what it is and get rid of it
			if (dwAttributes & FILE_ATTRIBUTE_DIRECTORY)
			{
				hr = DoDeleteContentsOfDirectory(L"", wszRepositoryBackup);
				if (SUCCEEDED(hr))
				{
					if (!RemoveDirectoryW(wszRepositoryBackup))
						hr = WBEM_E_FAILED;
				}
			}
			else
			{
				if (!DeleteFileW(wszRepositoryBackup))
					hr = WBEM_E_FAILED;
			}
		}
	}

	if (SUCCEEDED(hr))
	{
		if (!MoveFileW(wszRepositoryOrg, wszRepositoryBackup))
			hr = WBEM_E_FAILED;
	}

	if (SUCCEEDED(hr))
	{
		if (!CreateDirectoryW(wszRepositoryOrg, NULL))
			hr = WBEM_E_FAILED;
	}

    wchar_t wszRecoveryBackup[MAX_PATH+1] = { 0 };
	wcscpy(wszRecoveryBackup, wszRepositoryBackup);
	wcscat(wszRecoveryBackup, L"\\");
	wcscat(wszRecoveryBackup, RESTORE_FILE);

    if (SUCCEEDED(hr))
    {
        if (!MoveFileW(wszRecoveryBackup, wszRecoveryActual))
			hr = WBEM_E_FAILED;
    }

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\winmgmt2\factory.cpp ===
#include "precomp.h"

#include "winmgmt.h"
#include "backuprestore.h"

//***************************************************************************
//
//  CForwardFactory::AddRef()
//  CForwardFactory::Release()
//  CForwardFactory::QueryInterface()
//  CForwardFactory::CreateInstance()
//
//  DESCRIPTION:
//
//  Class factory for the exported WbemNTLMLogin interface.  Note that this
//  just serves as a wrapper to the factory inside the core.  The reason for
//  having a wrapper is that the core may not always be loaded.
//
//***************************************************************************

ULONG STDMETHODCALLTYPE CForwardFactory::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CForwardFactory::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

HRESULT STDMETHODCALLTYPE CForwardFactory::QueryInterface(REFIID riid,
                                                            void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IClassFactory)
    {
        *ppv = (IClassFactory*)this;
        AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;
}

#ifdef  INSTRUMENTED_BUILD
#ifdef  _X86_
extern BOOL g_FaultHeapEnabled;
extern BOOL g_FaultFileEnabled;
extern LONG g_nSuccConn;
#endif
#endif


HRESULT STDMETHODCALLTYPE CForwardFactory::CreateInstance(IUnknown* pUnkOuter,
                            REFIID riid, void** ppv)
{
    DEBUGTRACE((LOG_WINMGMT, "\nCreating an instance!\n"));
    SCODE sc = S_OK;
    CInMutex im(g_ProgRes.hMainMutex);

    try {
    
	    if(g_ProgRes.bShuttingDownWinMgmt)
	    {
	        DEBUGTRACE((LOG_WINMGMT, "\nCreateInstance returned CO_E_SERVER_STOPPING"));
	        return CO_E_SERVER_STOPPING;
	    }
	    DWORD dwRes = WaitForSingleObject(g_ProgRes.ghHoldOffNewClients, 1000);
	    if(dwRes != WAIT_OBJECT_0 && dwRes != WAIT_ABANDONED)
	        return CO_E_SERVER_STOPPING;
	    ReleaseMutex(g_ProgRes.ghHoldOffNewClients);

	    if(m_ForwardClsid == CLSID_WbemBackupRestore)
	    {
	        CWbemBackupRestore * pObj = new CWbemBackupRestore(g_hInstance);
	        if (!pObj)
	            return WBEM_E_OUT_OF_MEMORY;

	        sc = pObj->QueryInterface(riid, ppv);
	        if(FAILED(sc))
	            delete pObj;
	    }
	    else 
	    {
		    HMODULE hCoreModule = LoadLibraryEx(__TEXT("wbemcore.dll"),NULL,0);
		    if(hCoreModule)
		    {
		        HRESULT (STDAPICALLTYPE *pfn)(DWORD);
		        pfn = (long (__stdcall *)(DWORD))GetProcAddress(hCoreModule, "Reinitialize");
		        if(pfn == NULL)
     	            sc = WBEM_E_CRITICAL_ERROR;
				else
				{
		            pfn(0);
			        sc = CoCreateInstance(CLSID_InProcWbemLevel1Login, NULL,
			                CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER, IID_IUnknown,
			                (void**)ppv);
			        DEBUGTRACE((LOG_WINMGMT, "\nInner create returned: 0x%X\n", sc));
				}
		        FreeLibrary(hCoreModule);
		     }
		     else
		     	sc = WBEM_E_CRITICAL_ERROR;

#ifdef  INSTRUMENTED_BUILD
#ifdef  _X86_
/*
             if (++g_nSuccConn > 500)
             {
                 g_FaultHeapEnabled = TRUE;
                 g_FaultFileEnabled = TRUE;
             };
*/             
#endif
#endif		     
	    }
	} 
	catch (...) 
	{
	    ERRORTRACE((LOG_WINMGMT,"---------------\nException thrown from CreateInstance\n-------------\n"));
	    sc = E_NOINTERFACE;
	}
	
    return sc;
}

HRESULT STDMETHODCALLTYPE CForwardFactory::LockServer(BOOL fLock)
{
    //return CoLockObjectExternal(this,fLock,FALSE);
    return S_OK;
}

CForwardFactory::~CForwardFactory()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\winmgmt2\resync.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    RESYNC.H

Abstract:

	Declares the various resync primitives.

History:

--*/

#ifndef _RESYNC_H_
#define _RESYNC_H_

typedef WINBASEAPI BOOL (WINAPI * PSETWAITABLETIMER)(
    HANDLE hTimer,
    const LARGE_INTEGER *lpDueTime,
    LONG lPeriod,
    PTIMERAPCROUTINE pfnCompletionRoutine,
    LPVOID lpArgToCompletionRoutine,
    BOOL fResume
    );

typedef WINBASEAPI HANDLE (WINAPI * PCREATEWAITABLETIMERW)(
    LPSECURITY_ATTRIBUTES lpTimerAttributes,
    BOOL bManualReset,
    LPCWSTR lpTimerName
    );

typedef struct 
{
	HANDLE				m_hTerminate;
	HANDLE				m_hWaitableTimer;
	CRITICAL_SECTION*	m_pcs;
	BOOL				m_fFullDredge;
	BOOL                m_bIsLodCtr;
}	RESYNCPERFDATASTRUCT;

void ResyncPerf( HANDLE hTerminate, BOOL bIsLodCtr );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\winmgmt2\regcode.cpp ===
////////////////////////////////////////////////////////////////////////
//
//  regcode.cpp
//
//	Module:	
//
//  History:
//	ivanbrug      17-09-2000		Create
//
//
//  Copyright (c) 1997-2001 Microsoft Corporation, All rights reserved
//
////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <winmgmt.h>
#include <strings.h> // for LoadString
#include <malloc.h>
#include <winntsec.h>
#include <autoptr.h>
#include <helper.h>
#include <tchar.h>


#define SVCHOST_HOME  _T("Software\\Microsoft\\Windows NT\\CurrentVersion\\SvcHost") 
#define SERVICE_PATH  _T("System\\CurrentControlSet\\Services\\")
#define DLL_PATH      _T("%SystemRoot%\\system32\\wbem\\WMIsvc.dll")
#define ENTRY_POINT   _T("ServiceMain")

#define COM_APPID _T("Software\\classes\\AppID\\{8BC3F05E-D86B-11D0-A075-00C04FB68820}")
    //= Windows Management Instrumentation
    //LocalService = WinMgmt

#define COM_APPID_NAME _T("Software\\classes\\AppID\\winmgmt")
    //AppID = {8BC3F05E-D86B-11D0-A075-00C04FB68820}
    
#define SERVICE_CLSID _T("{8BC3F05E-D86B-11D0-A075-00C04FB68820}")


#define SERVICE_NAME_GROUP_ALONE _T("winmgmt")
#define SERVICE_NAME_GROUP _T("netsvcs")
#define SERVICE_NAME_GROUP_TOGETHER _T("netsvcs")


// see winmgmt.h
//#define SERVICE_NAME       _T("winmgmt")

#define VALUE_AUTH   _T("AuthenticationCapabilities")
#define VALUE_COINIT _T("CoInitializeSecurityParam")
#define VALUE_AUTZN  _T("AuthenticationLevel")
#define VALUE_IMPER  _T("ImpersonationLevel") 

#define ACCOUNT_NAME   _T("LocalService") // unused, for now
#define DISPLAY_CLSID        _T("Windows Management and Instrumentation")
#define DISPLAY_BACKUP_CLSID _T("Windows Management Instrumentation Backup and Recovery")

//
// how verbose can PMs be ?
//
#define MAX_BUFF 2048

//
//
// this is the rundll32 interface
//
//
//////////////////////////////////////////////////////////////////

void CALLBACK 
MoveToAlone(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow) //RPC_C_AUTHN_LEVEL_CONNECT
{
    BOOL bRet = TRUE;
    LONG lRet;
    HKEY hKey;

    DWORD dwLevel = RPC_C_AUTHN_LEVEL_CONNECT;
    if (lpszCmdLine)
    {
        dwLevel = atoi(lpszCmdLine);
        if (0 == dwLevel)  // in case of error
        {
            dwLevel = RPC_C_AUTHN_LEVEL_CONNECT;
        }
    }

    // create the new group key under svchost
	if (bRet)
	{
		lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
			                SVCHOST_HOME,
							0,
							KEY_ALL_ACCESS,
							&hKey);
		if (ERROR_SUCCESS == lRet)
		{
			
			// add the group

            LONG lRet2;
            DWORD dwCurrSize;
            DWORD dwType;
            lRet2 = RegQueryValueEx(hKey,SERVICE_NAME_GROUP_ALONE,0,&dwType,NULL,&dwCurrSize);
            if (ERROR_SUCCESS == lRet2)
            {
                // the key is there, append to the multistring
                BYTE * pMulti = new BYTE[(dwCurrSize+sizeof(SERVICE_NAME)+4)];
                wmilib::auto_buffer<BYTE> rm_(pMulti);
                if (pMulti)
                {
	                lRet2 = RegQueryValueEx(hKey,SERVICE_NAME_GROUP_ALONE,0,&dwType,pMulti,&dwCurrSize);                
	                if (ERROR_SUCCESS == lRet2) // add REG_MULITSZ check
	                {
	                    TCHAR * pInsertPoint = (TCHAR *)(pMulti+dwCurrSize-sizeof(TCHAR));
	                    // verify the multisz  
	                    TCHAR *pEnd = (TCHAR *)pMulti;
	                    BOOL bIsThere = FALSE;

	                    while (*pEnd) 
	                    {
	                        if (0 == _tcsicmp(pEnd,SERVICE_NAME))
	                        {
	                            bIsThere = TRUE;  
	                        }
	                        while (*pEnd){
	                            pEnd++;
	                        }
	                        pEnd++; // past the zero who terminates the string
	                    }
	                    if (!bIsThere)
	                    {
		                    if ((ULONG_PTR)pEnd == (ULONG_PTR)pInsertPoint)
		                    {
		                        _tcsncpy(pEnd,SERVICE_NAME _T("\0"),sizeof(SERVICE_NAME)/sizeof(TCHAR)+1);
		                        DWORD dwNowSize = dwCurrSize+sizeof(SERVICE_NAME);
		                        RegSetValueEx(hKey,SERVICE_NAME_GROUP_ALONE,0,REG_MULTI_SZ,pMulti,dwNowSize);
		                    }
		                    else
		                    {
		                        bRet = FALSE;
		                    }
	                    }
		            }
		        }
            }
            else if (ERROR_FILE_NOT_FOUND == lRet2) 
            {
				BYTE * pMulti = (BYTE *)SERVICE_NAME_GROUP_ALONE _T("\0");				
	            RegSetValueEx(hKey,SERVICE_NAME_GROUP_ALONE,0,REG_MULTI_SZ,pMulti,sizeof(SERVICE_NAME_GROUP)+sizeof(_T("")));            
            }
            else
            {
                // what to do ?
            }

			HKEY hKey2;
			DWORD dwDisposistion;
			lRet = RegCreateKeyEx(hKey,
				                  SERVICE_NAME_GROUP_ALONE,
								  0,NULL,
								  REG_OPTION_NON_VOLATILE,
								  KEY_ALL_ACCESS,
								  NULL,
								  &hKey2,
								  &dwDisposistion);
			if (ERROR_SUCCESS == lRet)
			{
				// any value non NULL will work
				DWORD dwVal = 1;
				RegSetValueEx(hKey2,VALUE_COINIT,0,REG_DWORD,(BYTE *)&dwVal,sizeof(DWORD));
                // from packet to connect
				dwVal = dwLevel; //RPC_C_AUTHN_LEVEL_CONNECT;
				RegSetValueEx(hKey2,VALUE_AUTZN,0,REG_DWORD,(BYTE *)&dwVal,sizeof(DWORD));

				dwVal = RPC_C_IMP_LEVEL_IDENTIFY;
				RegSetValueEx(hKey2,VALUE_IMPER,0,REG_DWORD,(BYTE *)&dwVal,sizeof(DWORD));

                dwVal = EOAC_DISABLE_AAA | EOAC_NO_CUSTOM_MARSHAL | EOAC_STATIC_CLOAKING ;
				RegSetValueEx(hKey2,VALUE_AUTH,0,REG_DWORD,(BYTE *)&dwVal,sizeof(DWORD));

				RegCloseKey(hKey2);

				bRet = TRUE;
			}
		}
	}

    if (bRet)
    {
	    SC_HANDLE scHandle;

	    scHandle = OpenSCManager(NULL,SERVICES_ACTIVE_DATABASE,SC_MANAGER_ALL_ACCESS);

	    if (scHandle)
	    {
	        SC_HANDLE scService;

	        scService = OpenService(scHandle,SERVICE_NAME,SERVICE_ALL_ACCESS);

	        if (scService)
	        {
	            DWORD dwNeeded = 0;
	            bRet = QueryServiceConfig(scService,NULL,0,&dwNeeded);
	            
	            if (!bRet && (ERROR_INSUFFICIENT_BUFFER == GetLastError()))
	            {
	                BYTE * pByte = new BYTE[dwNeeded];
	                wmilib::auto_buffer<BYTE> rm_(pByte);
	                QUERY_SERVICE_CONFIG* pConfig = (QUERY_SERVICE_CONFIG *)pByte;
	                if (pConfig)
	                {
		                bRet = QueryServiceConfig(scService,pConfig,dwNeeded,&dwNeeded);
		                if (bRet)
		                {
							  TCHAR BinPath[MAX_PATH];
	                		  wsprintf(BinPath,_T("%%systemroot%%\\system32\\svchost.exe -k %s"),SERVICE_NAME_GROUP_ALONE);

							  bRet = ChangeServiceConfig(scService,
							                             pConfig->dwServiceType,
							                             pConfig->dwStartType,
							                             pConfig->dwErrorControl,
							                             BinPath,
							                             pConfig->lpLoadOrderGroup,
							                             NULL, //&pConfig->dwTagId,
							                             pConfig->lpDependencies,
							                             pConfig->lpServiceStartName,
							                             NULL,
							                             pConfig->lpDisplayName);
							  if (!bRet)
							  {
							      DBG_PRINTFA((pBuff,"ChangeServiceConfig %d\n",GetLastError()));
							  }
		                }
	                }
	                else
	                {
	                    bRet = FALSE;
	                }
	            }
	            
	            CloseServiceHandle(scService);
	        }
	        else
	        {
	            // the service was not there or other error
    	        DBG_PRINTFA((pBuff,"MoveToStandalone OpenService %d\n",GetLastError()));	            
	            bRet = FALSE;
	        }

	        CloseServiceHandle(scHandle);
	    }
	    else
	    {
	        DBG_PRINTFA((pBuff,"MoveToStandalone OpenSCManager %d\n",GetLastError()));
	        bRet = FALSE;
	    }
    }

    if (bRet)
    {
    //
    //  remove the winmgmt string from the multi-sz of winmgmt
    //    

		lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
			                SVCHOST_HOME,
							0,
							KEY_ALL_ACCESS,
							&hKey);
		if (ERROR_SUCCESS == lRet)
		{
			
			// add the group

            LONG lRet2;
            DWORD dwCurrSize;
            DWORD dwType;
            lRet2 = RegQueryValueEx(hKey,SERVICE_NAME_GROUP_TOGETHER,0,&dwType,NULL,&dwCurrSize);
            if (ERROR_SUCCESS == lRet2)
            {
                // the key is there, append to the multistring
                BYTE * pMulti = new BYTE[dwCurrSize+4];
                wmilib::auto_buffer<BYTE> rm1_(pMulti);
                BYTE * pMultiNew = new BYTE[dwCurrSize+4];
                wmilib::auto_buffer<BYTE> rm2_(pMultiNew);
                TCHAR * pMultiNewCopy = (TCHAR *)pMultiNew;

                if (pMulti && pMultiNew)
                {
	                lRet2 = RegQueryValueEx(hKey,SERVICE_NAME_GROUP_TOGETHER,0,&dwType,pMulti,&dwCurrSize);
	                
	                if (ERROR_SUCCESS == lRet2) // add REG_MULITSZ check
	                {
	                    
	                    // verify the multisz  
	                    TCHAR *pEnd = (TCHAR *)pMulti;
	                    BOOL bIsThere = FALSE;

	                    while (*pEnd) 
	                    {
	                        if (0 == _tcsicmp(pEnd,SERVICE_NAME))
	                        {
	                            bIsThere = TRUE; 
	                            while (*pEnd){
	                                pEnd++;
	                            }
	                            pEnd++; // past the zero who terminates the string                            
	                        }
	                        else // copy
	                        {
		                        while (*pEnd){
		                            *pMultiNewCopy++ = *pEnd++;
		                        }
		                        pEnd++; // past the zero who terminates the string
		                        *pMultiNewCopy++ = 0;
	                        }
	                    }
	                    *pMultiNewCopy++ = 0;  // put the double terminator
	                    
	                    if (bIsThere)
	                    {
	                        DWORD dwNowSize = dwCurrSize-sizeof(SERVICE_NAME);
		                    RegSetValueEx(hKey,SERVICE_NAME_GROUP_TOGETHER,0,REG_MULTI_SZ,pMultiNew,dwNowSize);
	                    }
	                }
	            }
	            else
	            {
	                bRet = FALSE;
	            }
            }
            else
            {
                //
                //  the netsvcs multi sz MUST be there !!!!
                //
                bRet = TRUE;
            }

        }
        else
        {
             bRet = FALSE;
        }
    }

    return;
}

//
//
// this is the rundll32 interface
//
//
//////////////////////////////////////////////////////////////////

void CALLBACK 
MoveToShared(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow) //RPC_C_AUTHN_LEVEL_CONNECT
{
    //
    BOOL bRet = TRUE;
    LONG lRet;
    HKEY hKey;

    DWORD dwLevel = RPC_C_PROTECT_LEVEL_PKT;
    if (lpszCmdLine)
    {
        dwLevel = atoi(lpszCmdLine);
        if (0 == dwLevel)  // in case of error
        {
            dwLevel = RPC_C_PROTECT_LEVEL_PKT;
        }
    }

    // create the new group key under svchost
	if (bRet)
	{
		lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
			                SVCHOST_HOME,
							0,
							KEY_ALL_ACCESS,
							&hKey);
		if (ERROR_SUCCESS == lRet)
		{
			
			// add the group

            LONG lRet2;
            DWORD dwCurrSize;
            DWORD dwType;
            lRet2 = RegQueryValueEx(hKey,SERVICE_NAME_GROUP_TOGETHER,0,&dwType,NULL,&dwCurrSize);
            if (ERROR_SUCCESS == lRet2)
            {
                // the key is there, append to the multistring
                BYTE * pMulti = new BYTE[(dwCurrSize+sizeof(SERVICE_NAME)+4)];
                wmilib::auto_buffer<BYTE> rm_(pMulti);
                if (pMulti)
                {
	                lRet2 = RegQueryValueEx(hKey,SERVICE_NAME_GROUP_TOGETHER,0,&dwType,pMulti,&dwCurrSize);
	                
	                if (ERROR_SUCCESS == lRet2) // add REG_MULITSZ check
	                {
	                    TCHAR * pInsertPoint = (TCHAR *)(pMulti+dwCurrSize-sizeof(TCHAR));
	                    // verify the multisz  
	                    TCHAR *pEnd = (TCHAR *)pMulti;
	                    BOOL bIsThere = FALSE;

	                    while (*pEnd) 
	                    {
	                        if (0 == _tcsicmp(pEnd,SERVICE_NAME))
	                        {
	                            bIsThere = TRUE;  
	                        }
	                        while (*pEnd){
	                            pEnd++;
	                        }
	                        pEnd++; // past the zero who terminates the string
	                    }
	                    if (!bIsThere)
	                    {
		                    if ((ULONG_PTR)pEnd == (ULONG_PTR)pInsertPoint)
		                    {
		                        _tcsncpy(pEnd,SERVICE_NAME _T("\0"),sizeof(SERVICE_NAME)/sizeof(TCHAR)+1);
		                        DWORD dwNowSize = dwCurrSize+sizeof(SERVICE_NAME);
		                        RegSetValueEx(hKey,SERVICE_NAME_GROUP_TOGETHER,0,REG_MULTI_SZ,pMulti,dwNowSize);
		                    }
		                    else
		                    {
		                        bRet = FALSE;
		                        DebugBreak();
		                    }
	                    }
	                }
	            }
	            else
	            {
    	            bRet = FALSE;
	            }
            }
            else if (ERROR_FILE_NOT_FOUND == lRet2) 
            {
				BYTE * pMulti = (BYTE *)SERVICE_NAME_GROUP_TOGETHER _T("\0");				
	            RegSetValueEx(hKey,SERVICE_NAME_GROUP_TOGETHER,0,REG_MULTI_SZ,pMulti,sizeof(SERVICE_NAME_GROUP)+sizeof(_T("")));            
            }
            else
            {
                // what to do ?
            }

			HKEY hKey2;
			DWORD dwDisposistion;
			lRet = RegCreateKeyEx(hKey,
				                  SERVICE_NAME_GROUP_TOGETHER,
								  0,NULL,
								  REG_OPTION_NON_VOLATILE,
								  KEY_ALL_ACCESS,
								  NULL,
								  &hKey2,
								  &dwDisposistion);
			if (ERROR_SUCCESS == lRet)
			{
				// any value non NULL will work
				DWORD dwVal = 1;
				RegSetValueEx(hKey2,VALUE_COINIT,0,REG_DWORD,(BYTE *)&dwVal,sizeof(DWORD));
                // from packet to connect
				dwVal = dwLevel; //RPC_C_AUTHN_LEVEL_CONNECT;
				RegSetValueEx(hKey2,VALUE_AUTZN,0,REG_DWORD,(BYTE *)&dwVal,sizeof(DWORD));

				dwVal = RPC_C_IMP_LEVEL_IDENTIFY;
				RegSetValueEx(hKey2,VALUE_IMPER,0,REG_DWORD,(BYTE *)&dwVal,sizeof(DWORD));

                dwVal = EOAC_DISABLE_AAA | EOAC_NO_CUSTOM_MARSHAL | EOAC_STATIC_CLOAKING ;
				RegSetValueEx(hKey2,VALUE_AUTH,0,REG_DWORD,(BYTE *)&dwVal,sizeof(DWORD));

				RegCloseKey(hKey2);

				bRet = TRUE;
			}
			else
			{
			    DebugBreak();
			}
		}
	}

    //
    //  changes the SCM database
    //
    if (bRet)
    {
	    SC_HANDLE scHandle;

	    scHandle = OpenSCManager(NULL,SERVICES_ACTIVE_DATABASE,SC_MANAGER_ALL_ACCESS);

	    if (scHandle)
	    {
	        SC_HANDLE scService;

	        scService = OpenService(scHandle,SERVICE_NAME,SERVICE_ALL_ACCESS);

	        if (scService)
	        {
	            DWORD dwNeeded = 0;
	            bRet = QueryServiceConfig(scService,NULL,0,&dwNeeded);
	            
	            if (!bRet && (ERROR_INSUFFICIENT_BUFFER == GetLastError()))
	            {
	                BYTE * pByte = new BYTE[dwNeeded];
	                wmilib::auto_buffer<BYTE> rm1_(pByte);
	                QUERY_SERVICE_CONFIG* pConfig = (QUERY_SERVICE_CONFIG *)pByte;
	                if (pConfig)
	                {
		                bRet = QueryServiceConfig(scService,pConfig,dwNeeded,&dwNeeded);

		                if (bRet)
		                {
							  TCHAR BinPath[MAX_PATH];
	                		  wsprintf(BinPath,_T("%%systemroot%%\\system32\\svchost.exe -k %s"),SERVICE_NAME_GROUP_TOGETHER);

							  bRet = ChangeServiceConfig(scService,
							                             pConfig->dwServiceType,
							                             pConfig->dwStartType,
							                             pConfig->dwErrorControl,
							                             BinPath,
							                             pConfig->lpLoadOrderGroup,
							                             NULL, //&pConfig->dwTagId,
							                             pConfig->lpDependencies,
							                             pConfig->lpServiceStartName,
							                             NULL,
							                             pConfig->lpDisplayName);
							  if (!bRet)
							  {
							      DBG_PRINTFA((pBuff,"ChangeServiceConfig %d\n",GetLastError()));
							  }
		                }
		            }
		            else
		            {
		                bRet = FALSE;
		            }
	            }
	            
	            CloseServiceHandle(scService);
	        }
	        else
	        {
	            // the service was not there or other error
    	        DBG_PRINTFA((pBuff,"MoveToShared OpenService %d\n",GetLastError()));	            
	            bRet = FALSE;
	        }

	        CloseServiceHandle(scHandle);
	    }
	    else
	    {
	        DBG_PRINTFA((pBuff,"MoveToStandalone OpenSCManager %d\n",GetLastError()));
	        bRet = FALSE;
	    }
    }


    if (bRet)
    {
    //
    //  remove the winmgmt string from the multi-sz of winmgmt
    //    

		lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
			                SVCHOST_HOME,
							0,
							KEY_ALL_ACCESS,
							&hKey);
		if (ERROR_SUCCESS == lRet)
		{
			
			// add the group

            LONG lRet2;
            DWORD dwCurrSize;
            DWORD dwType;
            lRet2 = RegQueryValueEx(hKey,SERVICE_NAME_GROUP_ALONE,0,&dwType,NULL,&dwCurrSize);
            if (ERROR_SUCCESS == lRet2)
            {
                // the key is there, append to the multistring
                BYTE * pMulti = new BYTE[dwCurrSize+4];
                wmilib::auto_buffer<BYTE> rm2_(pMulti);                
                BYTE * pMultiNew = new BYTE[dwCurrSize+4];
                wmilib::auto_buffer<BYTE> rm3_(pMultiNew);
                TCHAR * pMultiNewCopy = (TCHAR *)pMultiNew;

                if (pMulti && pMultiNew)
                {
	                lRet2 = RegQueryValueEx(hKey,SERVICE_NAME_GROUP_ALONE,0,&dwType,pMulti,&dwCurrSize);
	                
	                if (ERROR_SUCCESS == lRet2) // add REG_MULITSZ check
	                {
	                    
	                    // verify the multisz  
	                    TCHAR *pEnd = (TCHAR *)pMulti;
	                    BOOL bIsThere = FALSE;

	                    while (*pEnd) 
	                    {
	                        if (0 == _tcsicmp(pEnd,SERVICE_NAME))
	                        {
	                            bIsThere = TRUE; 
	                            while (*pEnd){
	                                pEnd++;
	                            }
	                            pEnd++; // past the zero who terminates the string                            
	                        }
	                        else // copy
	                        {
		                        while (*pEnd){
		                            *pMultiNewCopy++ = *pEnd++;
		                        }
		                        pEnd++; // past the zero who terminates the string
		                        *pMultiNewCopy++ = 0;
	                        }
	                    }
	                    *pMultiNewCopy++ = 0;  // put the double terminator
	                    
	                    if (bIsThere)
	                    {
	                        DWORD dwNowSize = dwCurrSize-sizeof(SERVICE_NAME);
		                    RegSetValueEx(hKey,SERVICE_NAME_GROUP_ALONE,0,REG_MULTI_SZ,pMultiNew,dwNowSize);
	                    }
	                }
	            }
	            else
	            {
	                bRet = FALSE;
	            }
            }
            else
            {
                //
                //  the netsvcs multi sz MUST be there !!!!
                //
                bRet = TRUE;
            }

        }
        else
        {
             bRet = FALSE;
        }
    }

    
}



//***************************************************************************
//
//  void InitializeLaunchPermissions()
//
//  DESCRIPTION:
//
//  Sets the DCOM Launch permissions.
//
//***************************************************************************

void InitializeLaunchPermissions()
{

    Registry reg(__TEXT("SOFTWARE\\CLASSES\\APPID\\{8bc3f05e-d86b-11d0-a075-00c04fb68820}"));
    if(reg.GetLastError() != 0)
        return;

    // If there already is a SD, then dont overwrite

    BYTE * pData = NULL;
    DWORD dwDataSize = 0;

    int iRet = reg.GetBinary(__TEXT("LaunchPermission"), &pData, &dwDataSize);
    if(iRet == 0)
    {
        delete [] pData;       
        return; // it's already there
    }
    
    PSID pEveryoneSid;
    SID_IDENTIFIER_AUTHORITY id_World = SECURITY_WORLD_SID_AUTHORITY;

    if(!AllocateAndInitializeSid( &id_World, 1,
                                            SECURITY_WORLD_RID,
                                            0,0,0,0,0,0,0,
                                            &pEveryoneSid)) return;
    OnDelete<PSID,PVOID(*)(PSID),FreeSid> freeSid1(pEveryoneSid);

    SID_IDENTIFIER_AUTHORITY  id_NT = SECURITY_NT_AUTHORITY;
    PSID pAdministratorsSid = NULL;
    
    if (!AllocateAndInitializeSid(&id_NT,
                            2,
                            SECURITY_BUILTIN_DOMAIN_RID,
                            DOMAIN_ALIAS_RID_ADMINS,
                            0, 0, 0, 0, 0, 0,
                            &pAdministratorsSid)) return; 
    OnDelete<PSID,PVOID(*)(PSID),FreeSid> freeSid2(pAdministratorsSid);
    
    // Create the class sids for everyone and administrators
    CNtSid SidEveryone(pEveryoneSid);
    CNtSid SidAdmins(pAdministratorsSid);
    
    if(SidEveryone.GetStatus() != 0 || SidAdmins.GetStatus() != 0)
        return;

    // Create a single ACE, and add it to the ACL

    CNtAcl DestAcl;
    CNtAce Users(1, ACCESS_ALLOWED_ACE_TYPE, 0, SidEveryone);
    if(Users.GetStatus() != 0)
        return;
    DestAcl.AddAce(&Users);
    if(DestAcl.GetStatus() != 0)
        return;

    // Set the descresionary acl, and the owner and group sids
    //  Create a sd with a single entry for launch permissions.
    CNtSecurityDescriptor LaunchPermSD;
    LaunchPermSD.SetDacl(&DestAcl);
    LaunchPermSD.SetOwner(&SidAdmins);
    LaunchPermSD.SetGroup(&SidAdmins);
    if(LaunchPermSD.GetStatus() != 0) return;

    // Write it out
    reg.SetBinary(__TEXT("LaunchPermission"), (BYTE *)LaunchPermSD.GetPtr(), LaunchPermSD.GetSize());
}



//***************************************************************************
//
//  DllRegisterServer
//
//  Standard OLE entry point for registering the server.
//
//  RETURN VALUES:
//
//      S_OK        Registration was successful
//      E_FAIL      Registration failed.
//
//***************************************************************************

STDAPI DllRegisterServer(void)
{

	// set the group

    HKEY hKey;
    LONG lRet;
    BOOL bRet = TRUE;

	if (bRet)
	{
		lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
			                SVCHOST_HOME,
							0,
							KEY_ALL_ACCESS,
							&hKey);
		if (ERROR_SUCCESS == lRet)
		{
			
			// add the group

            LONG lRet2;
            DWORD dwCurrSize;
            DWORD dwType;
            lRet2 = RegQueryValueEx(hKey,SERVICE_NAME_GROUP,0,&dwType,NULL,&dwCurrSize);
            if (ERROR_SUCCESS == lRet2)
            {
                // the key is there, append to the multistring
                BYTE * pMulti = new BYTE[(dwCurrSize+sizeof(SERVICE_NAME)+4)];
                wmilib::auto_buffer<BYTE> rm4_(pMulti);
                if (pMulti)
                {
	                lRet2 = RegQueryValueEx(hKey,SERVICE_NAME_GROUP,0,&dwType,pMulti,&dwCurrSize);
	                
	                if (ERROR_SUCCESS == lRet2) // add REG_MULITSZ check
	                {
	                    TCHAR * pInsertPoint = (TCHAR *)(pMulti+dwCurrSize-sizeof(TCHAR));
	                    // verify the multisz  
	                    TCHAR *pEnd = (TCHAR *)pMulti;
	                    BOOL bIsThere = FALSE;

	                    while (*pEnd) 
	                    {
	                        if (0 == _tcsicmp(pEnd,SERVICE_NAME))
	                        {
	                            bIsThere = TRUE;  
	                        }
	                        while (*pEnd){
	                            pEnd++;
	                        }
	                        pEnd++; // past the zero who terminates the string
	                    }
	                    if (!bIsThere)
	                    {
		                    if ((ULONG_PTR)pEnd == (ULONG_PTR)pInsertPoint)
		                    {
		                        _tcsncpy(pEnd,SERVICE_NAME _T("\0"),sizeof(SERVICE_NAME)/sizeof(TCHAR)+1);
		                        DWORD dwNowSize = dwCurrSize+sizeof(SERVICE_NAME);
		                        RegSetValueEx(hKey,SERVICE_NAME_GROUP,0,REG_MULTI_SZ,pMulti,dwNowSize);
		                    }
		                    else
		                    {
		                        DebugBreak();
		                    }
	                    }
	                }
	            }
	            else
	            {
	                bRet = FALSE;
	            }
            }
            else if (ERROR_FILE_NOT_FOUND == lRet2) 
            {
				BYTE * pMulti = (BYTE *)SERVICE_NAME_GROUP _T("\0");				
	            RegSetValueEx(hKey,SERVICE_NAME_GROUP,0,REG_MULTI_SZ,pMulti,sizeof(SERVICE_NAME_GROUP)+sizeof(_T("")));            
            }
            else
            {
                // what to do ?
            }

			HKEY hKey2;
			DWORD dwDisposistion;
			lRet = RegCreateKeyEx(hKey,
				                  SERVICE_NAME_GROUP,
								  0,NULL,
								  REG_OPTION_NON_VOLATILE,
								  KEY_ALL_ACCESS,
								  NULL,
								  &hKey2,
								  &dwDisposistion);
			if (ERROR_SUCCESS == lRet)
			{
				// any value non NULL will work
				DWORD dwVal = 1;
				RegSetValueEx(hKey2,VALUE_COINIT,0,REG_DWORD,(BYTE *)&dwVal,sizeof(DWORD));

				// servicehost default + static cloaking
                dwVal = EOAC_DISABLE_AAA | EOAC_NO_CUSTOM_MARSHAL | EOAC_STATIC_CLOAKING ;
				RegSetValueEx(hKey2,VALUE_AUTH,0,REG_DWORD,(BYTE *)&dwVal,sizeof(DWORD));
				
				RegCloseKey(hKey2);

				bRet = TRUE;
			}
		}
	}

	BOOL bCreated = FALSE;

	if (bRet)
	{
		SC_HANDLE hSCM = NULL;
        hSCM = OpenSCManager(NULL,NULL,SC_MANAGER_ALL_ACCESS);
		if (hSCM)
		{

			DWORD dwTag;
			TCHAR BinPath[MAX_PATH];
			
			wsprintf(BinPath,_T("%%systemroot%%\\system32\\svchost.exe -k %s"),SERVICE_NAME_GROUP);

			TCHAR * pServiceDisplay = new TCHAR[MAX_BUFF];
			if (pServiceDisplay)
			{
			    int nRet = LoadString(g_hInstance,ID_WINMGMT_SERVICE,pServiceDisplay,MAX_BUFF);
			}
			else
			{
			    bRet = FALSE;
			}

			SC_HANDLE hService = NULL;
			if (bRet)
			{
			    hService = OpenService(hSCM,SERVICE_NAME,SERVICE_ALL_ACCESS );
			}
			
		    SC_ACTION ac[2];
		    ac[0].Type = SC_ACTION_RESTART;
		    ac[0].Delay = 60000;
		    ac[1].Type = SC_ACTION_RESTART;
		    ac[1].Delay = 60000;
		            
		    SERVICE_FAILURE_ACTIONS sf;
		    sf.dwResetPeriod = 86400;
		    sf.lpRebootMsg = NULL;
		    sf.lpCommand = NULL;
		    sf.cActions = 2;
		    sf.lpsaActions = ac;			
            			
			if (hService)
			{
				bRet = ChangeServiceConfig(hService,										 
                                         SERVICE_WIN32_SHARE_PROCESS,
										 SERVICE_AUTO_START, //SERVICE_DEMAND_START,
										 SERVICE_ERROR_IGNORE,
										 BinPath,
										 NULL,
										 NULL,
										 _T("RPCSS\0Eventlog\0\0\0"),
										 NULL, //ACCOUNT_NAME,
										 NULL,
										 pServiceDisplay);
                if (bRet)
                {
                    ChangeServiceConfig2(hService, SERVICE_CONFIG_FAILURE_ACTIONS, &sf);										 
				    //
				    //  insert code for description here
				    TCHAR * pBuff = new TCHAR[MAX_BUFF];
				    if (pBuff)
				    {
				        int nRet = LoadString(g_hInstance,ID_WINMGMT_DESCRIPTION,pBuff,MAX_BUFF);
		    		    if (nRet)
		    		    {
		    		        SERVICE_DESCRIPTION sd;
		    		        sd.lpDescription = pBuff;
   		    		        ChangeServiceConfig2(hService, SERVICE_CONFIG_DESCRIPTION,&sd);
		    		    }
		    		    delete [] pBuff;
			        }
				    //
				    //
                    
                }
                else
                {
                    DBG_PRINTFA((pBuff,"ChangeServiceConfig %d\n",GetLastError()));
                }

				CloseServiceHandle(hService);
			}
			else
			{
				// Create it
				hService = CreateService(hSCM,
					                     SERVICE_NAME,
										 pServiceDisplay,
										 SERVICE_ALL_ACCESS,
                                         SERVICE_WIN32_SHARE_PROCESS,
										 SERVICE_AUTO_START, //SERVICE_DEMAND_START,
										 SERVICE_ERROR_IGNORE,
										 BinPath,
										 NULL,
										 NULL,
										 _T("RPCSS\0Eventlog\0\0\0"),
										 NULL, //ACCOUNT_NAME,
										 NULL);
				if (hService)
				{		            
		            ChangeServiceConfig2(hService, SERVICE_CONFIG_FAILURE_ACTIONS, &sf);

				    //
				    //  insert code for description here
				    TCHAR * pBuff = new TCHAR[MAX_BUFF];
				    if (pBuff)
				    {
				        int nRet = LoadString(g_hInstance,ID_WINMGMT_DESCRIPTION,pBuff,MAX_BUFF);
		    		    if (nRet)
		    		    {
		    		        SERVICE_DESCRIPTION sd;
		    		        sd.lpDescription = pBuff;
   		    		        ChangeServiceConfig2(hService, SERVICE_CONFIG_DESCRIPTION,&sd);
		    		    }
		    		    delete [] pBuff;
			        }
				    //
				    //

				
					CloseServiceHandle(hService);
					bRet = TRUE;
				};
				
			}
			
			if (pServiceDisplay)
			{
			    delete [] pServiceDisplay;
			}
			CloseServiceHandle(hSCM);
		}
	}

	if (bRet)
	{
		lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
			                SERVICE_PATH SERVICE_NAME,
							0,
							KEY_ALL_ACCESS,
							&hKey);
		if (ERROR_SUCCESS == lRet)
		{
			HKEY hKey3;
			DWORD dwDisposistion;
			lRet = RegCreateKeyEx(hKey,
				                  _T("Parameters"),
								  0,NULL,
								  REG_OPTION_NON_VOLATILE,
								  KEY_ALL_ACCESS,
								  NULL,
								  &hKey3,
								  &dwDisposistion);
			if (ERROR_SUCCESS == lRet)
			{
				
				
				RegSetValueEx(hKey3,_T("ServiceDll"),0,REG_EXPAND_SZ,(BYTE *)DLL_PATH,sizeof(DLL_PATH)-sizeof(TCHAR));
				
                RegSetValueEx(hKey3,_T("ServiceMain"),0,REG_SZ,(BYTE *)ENTRY_POINT,sizeof(ENTRY_POINT)-sizeof(TCHAR));

				RegCloseKey(hKey3);

				bRet = TRUE;
			};

			RegCloseKey(hKey);
		}
	}

	if (bRet)
	{
		HKEY hKey4;
		DWORD dwDisposistion;
		lRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
				              COM_APPID,
						      0,NULL,
							  REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS,
							  NULL,
							  &hKey4,
							  &dwDisposistion);
		if (ERROR_SUCCESS == lRet)
		{
            RegSetValueEx(hKey4,NULL,0,REG_SZ,(BYTE *)DISPLAY_CLSID,sizeof(DISPLAY_CLSID)-sizeof(TCHAR));
			RegSetValueEx(hKey4,_T("LocalService"),0,REG_SZ,(BYTE *)SERVICE_NAME,sizeof(SERVICE_NAME)-sizeof(TCHAR));
			RegCloseKey(hKey4);
		}

		lRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
				              COM_APPID_NAME,
						      0,NULL,
							  REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS,
							  NULL,
							  &hKey4,
							  &dwDisposistion);
		if (ERROR_SUCCESS == lRet)
		{
            
			RegSetValueEx(hKey4,_T("AppID"),0,REG_SZ,(BYTE *)SERVICE_CLSID,sizeof(SERVICE_CLSID)-sizeof(TCHAR));
			RegCloseKey(hKey4);
		}

        InitializeLaunchPermissions();

        OLECHAR ClsidBuff[40];
        TCHAR * ClsidBuff2;
        TCHAR ClsidPath[MAX_PATH];
                
        StringFromGUID2(CLSID_WbemLevel1Login,ClsidBuff,40);        
#ifdef UNICODE
        ClsidBuff2 = ClsidBuff;
#else
        TCHAR pTmp_[40];
        ClsidPath2 = pTmp_;
        WideCharToMultiByte(CP_ACP,0,ClsidBuff,-1,ClsidBuff2,40,NULL,NULL);
#endif
        
        wsprintf(ClsidPath,_T("software\\classes\\CLSID\\%s"),ClsidBuff2);       
        
		lRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
				              ClsidPath,
						      0,NULL,
							  REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS,
							  NULL,
							  &hKey4,
							  &dwDisposistion);
		if (ERROR_SUCCESS == lRet)
		{
            RegSetValueEx(hKey4,NULL,0,REG_SZ,(BYTE *)DISPLAY_CLSID,sizeof(DISPLAY_CLSID)-sizeof(TCHAR));
			RegSetValueEx(hKey4,_T("AppId"),0,REG_SZ,(BYTE *)SERVICE_CLSID,sizeof(SERVICE_CLSID)-sizeof(TCHAR));
			RegSetValueEx(hKey4,_T("LocalService"),0,REG_SZ,(BYTE *)SERVICE_NAME,sizeof(SERVICE_NAME)-sizeof(TCHAR));
			RegCloseKey(hKey4);
		}

        StringFromGUID2(CLSID_WbemBackupRestore,ClsidBuff,40);
#ifdef UNICODE
        ClsidBuff2 = ClsidBuff;
#else
        // already _alloca-ted at this point
        //ClsidPath2 = (TCHAR *)_alloca(40*sizeof(TCHAR));
        WideCharToMultiByte(CP_ACP,0,ClsidBuff,-1,ClsidBuff2,40,NULL,NULL);
#endif

        wsprintf(ClsidPath,_T("software\\classes\\CLSID\\%s"),ClsidBuff);
        
		lRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
				              ClsidPath,
						      0,NULL,
							  REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS,
							  NULL,
							  &hKey4,
							  &dwDisposistion);
		if (ERROR_SUCCESS == lRet)
		{
            RegSetValueEx(hKey4,NULL,0,REG_SZ,(BYTE *)DISPLAY_BACKUP_CLSID,sizeof(DISPLAY_BACKUP_CLSID)-sizeof(TCHAR));
			RegSetValueEx(hKey4,_T("AppId"),0,REG_SZ,(BYTE *)SERVICE_CLSID,sizeof(SERVICE_CLSID)-sizeof(TCHAR));
			RegSetValueEx(hKey4,_T("LocalService"),0,REG_SZ,(BYTE *)SERVICE_NAME,sizeof(SERVICE_NAME)-sizeof(TCHAR));
			RegCloseKey(hKey4);
		}		

	}

    return S_OK;
}

//***************************************************************************
//
//  DllUnregisterServer
//
//  Standard OLE entry point for unregistering the server.
//
//  RETURN VALUES:
//
//      S_OK        Unregistration was successful
//      E_FAIL      Unregistration failed.
//
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    HKEY hKey;
    LONG lRet;
    BOOL bRet = TRUE;

    if (bRet)
    {
        TCHAR ClsidBuff[40];
        TCHAR ClsidPath[MAX_PATH];

#ifdef UNICODE                
        StringFromCLSID(CLSID_WbemLevel1Login,(LPOLESTR *)ClsidBuff);
#else
        WCHAR ClsidPath2[40];
        StringFromCLSID(CLSID_WbemLevel1Login,(LPOLESTR *)ClsidBuff2);
        MultiByteToWideChar(CP_ACP,0,ClsidBuff2,-1,ClsidBuff,40);
#endif

        wsprintf(ClsidPath,_T("software\\classes\\CLSID\\%s"),ClsidBuff);
        
		lRet = RegDeleteKey(HKEY_LOCAL_MACHINE,ClsidPath);

#ifdef UNICODE
        StringFromCLSID(CLSID_WbemBackupRestore,(LPOLESTR *)ClsidBuff);
#else
        WCHAR ClsidPath2[40];
        StringFromCLSID(CLSID_WbemBackupRestore,(LPOLESTR *)ClsidBuff2);
        MultiByteToWideChar(CP_ACP,0,ClsidBuff2,-1,ClsidBuff,40);
#endif

        wsprintf(ClsidPath,_T("software\\classes\\CLSID\\%s"),ClsidBuff);
        
		lRet = RegDeleteKey(HKEY_LOCAL_MACHINE,ClsidPath);

		lRet = RegDeleteKey(HKEY_LOCAL_MACHINE,COM_APPID);
		
		lRet = RegDeleteKey(HKEY_LOCAL_MACHINE,COM_APPID_NAME);
    
    }

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\winmgmt2\resync.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    RESYNC.CPP

Abstract:


History:

    a-davj   04-Mar-97    Created.
    ivanbrug 01-Sep-2000  changed for svchost migration

--*/

#include "precomp.h"

#include <malloc.h>
#include <tchar.h>

#include "WinMgmt.h"

#include "resync.h"


// Timeout is a 64-bit value.  See documentation on SetWaitableTimer
// for why we are setting it this way.
#define             _SECOND     10000000
#define             RESYNC_TIMEOUT_INTERVAL 10 * _SECOND

DWORD               gdwADAPDelaySec = 0;
DWORD               gdwLodCtrDelaySec = 0;

BOOL                gfResyncInit = FALSE;
HANDLE              ghWaitableTimer = NULL;
BOOL                gfSpawnedResync = FALSE;


HANDLE              ghResyncThreadHandle = NULL;
HANDLE              ghResyncThreadEvent = NULL;
CRITICAL_SECTION*   g_pResyncCs = NULL;
DWORD               gdwResyncThreadId = 0;

// A global handle used to store the last dredger we
// kicked off!
HANDLE              ghChildProcessHandle = NULL;


void ResetResyncTimer( HANDLE hResyncTimer, BOOL bIsLoadCtr )
{
    DWORD dwErr = 0;
    __int64 qwDueTime  = bIsLoadCtr?(gdwLodCtrDelaySec * _SECOND):(gdwADAPDelaySec * _SECOND); // RESYNC_TIMEOUT_INTERVAL;

    // Convert it to relative time
    qwDueTime *= -1;

    // Copy the relative time into a LARGE_INTEGER.
    LARGE_INTEGER   li;

    li.LowPart  = (DWORD) ( qwDueTime & 0xFFFFFFFF );
    li.HighPart = (LONG)  ( qwDueTime >> 32 );

    if ( !SetWaitableTimer( hResyncTimer, &li, 0, NULL, NULL, FALSE ) )
    {
        dwErr = GetLastError();
    }

}

// This thread controls the actual shelling of a resync perf operation
DWORD WINAPI ResyncPerfThread( void* pVoid )
{
    RESYNCPERFDATASTRUCT*   pResyncPerfData = (RESYNCPERFDATASTRUCT*) pVoid;

    // We get the two handles, copy them and wait on them
    // The first handle is the terminate event, the second is the
    // timer on which to spin off the resync

    BOOL bIsLodCtr = pResyncPerfData->m_bIsLodCtr;
    HANDLE  aHandles[2];

    aHandles[0] = pResyncPerfData->m_hTerminate;
    HANDLE  hTimer = pResyncPerfData->m_hWaitableTimer;

    CRITICAL_SECTION*   pcs = pResyncPerfData->m_pcs;

	BOOL	bFullDredge = pResyncPerfData->m_fFullDredge;

    delete pResyncPerfData;
    pResyncPerfData = NULL;

    // Reset the spawned flag
    gfSpawnedResync = FALSE;

    // Okay.  Signal this event so the starting thread can get us going
    SetEvent( ghResyncThreadEvent );

    // Now, if ghChildProcessHandle is not NULL, then we've obviously kicked off a
    // dredge before.  See where the last one is at.  If it's not done, wait for
    // it to finish.  We will always check this at the start of this chunk of code,
    // since we are really the only location in which the process handle can ever get set,
    // and there really shouldn't be more than one thread ever, waiting to start another
    // dredge

    if ( NULL != ghChildProcessHandle )
    {

        aHandles[1] = ghChildProcessHandle;

        DWORD   dwWait = WaitForMultipleObjects( 2, aHandles, FALSE, INFINITE );

        // If abort was signalled, leave!
        if ( dwWait == WAIT_OBJECT_0 )
        {
            return 0;
        }

        // If the process handle was signalled, close the process, reset the timer
        // and we'll get ready to start the next dredge!
        if ( dwWait == WAIT_OBJECT_0 + 1 )
        {
            EnterCriticalSection( pcs );

            CloseHandle( ghChildProcessHandle );
            ghChildProcessHandle = NULL;
            ResetResyncTimer( hTimer, bIsLodCtr );

            LeaveCriticalSection( pcs );

        }

    }
    else
    {
        // If the Child Process Handle is NULL, we've never dredged before, so we'll
        // just reset the timer
        ResetResyncTimer( hTimer, bIsLodCtr );
    }

    BOOL    fHoldOff = TRUE;

    // Reset this handle to the timer now
    aHandles[1] = hTimer;

    while ( fHoldOff )
    {
        // Wait for either the terminate event or the timer
        DWORD   dwWait = WaitForMultipleObjects( 2, aHandles, FALSE, INFINITE );

        // This means the terminate was signaled
        if ( dwWait == WAIT_OBJECT_0 ) 
        {
            break;        
        } else
        // This means the timer was signaled
        if ( dwWait == WAIT_OBJECT_0 + 1 )
        {
            EnterCriticalSection( pcs );

            // Finally, if the current thread id != gdwResyncThreadId, this means another
            // resync perf thread got kicked off, inside of the critical section,
            // so we should just let it wait on the timer.  We don't really need to do
            // this, since the main thread will wait on this thread to complete before
            // it actually kicks off another thread.

            if ( GetCurrentThreadId() != gdwResyncThreadId )
            {
                // Used the following int 3 for debugging
                // _asm int 3;
                LeaveCriticalSection( pcs );
                break;
            }

            // Once we get through the critical section, check that the
            // timer is still signalled.  If it is not, this means that somebody
            // got control of the critical section and reset the timer

            if ( WaitForSingleObject( aHandles[1], 0 ) == WAIT_OBJECT_0 )
            {

                // Last quick sanity check on the abort event
                if ( WaitForSingleObject( aHandles[0], 0 ) == WAIT_OBJECT_0 )
                {
                    // Outa here!
                    LeaveCriticalSection( pcs );
                    break;
                }

                // Okay, we really will try to create the process now.
                gfSpawnedResync = TRUE;

                // We signalled to start the process, so make it so.
                PROCESS_INFORMATION pi;
                STARTUPINFO si;
                memset(&si, 0, sizeof(si));
                si.cb = sizeof(si);

                TCHAR * pWritebleBuffer = (TCHAR *)_alloca(sizeof(__T("WMIADAP.EXE /F"))+2);

                lstrcpy(pWritebleBuffer,(bFullDredge?__T("WMIADAP.EXE /F"):__T("WMIADAP.EXE")));

                BOOL bRes = CreateProcess(NULL, 
										  pWritebleBuffer,
										  NULL, 
										  NULL, 
										  FALSE, 
										  CREATE_NO_WINDOW,
										  NULL, 
										  NULL,  
										  &si, 
										  &pi);
                if(bRes)
                {
                    // Who cares about this one?
                    CloseHandle(pi.hThread);

                    // Clean up our old values
                    if ( NULL != ghChildProcessHandle )
                    {
                        CloseHandle( ghChildProcessHandle );
                        ghChildProcessHandle = NULL;
                    }

                    ghChildProcessHandle = pi.hProcess;
                }

                // We're done
                fHoldOff = FALSE;

            }   // Check that we're still signalled, or we will just have to go back to waiting

            LeaveCriticalSection( pcs );

        }   // IF timer was signalled

    }   // WHILE fHoldOff

    return 0;
}

// For the waitable timer
//#define _SECOND 10000000

// Create all the things we need
BOOL InitResync( void )
{
    if ( gfResyncInit )
        return gfResyncInit;

        
    if ( NULL == ghWaitableTimer )
    {
        ghWaitableTimer = CreateWaitableTimerW( NULL, TRUE, NULL );

        // We gotta big problem
        if ( NULL == ghWaitableTimer )
        {
            // Log an error here
            ERRORTRACE( ( LOG_WINMGMT, "Could not create a waitable timer for Resyncperf.\n" ) );
        }

    }

    if ( NULL == ghResyncThreadEvent )
    {
        ghResyncThreadEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

        // We gotta big problem
        if ( NULL == ghResyncThreadEvent )
        {
            // Log an event here
            ERRORTRACE( ( LOG_WINMGMT, "Could not create a ResyncThreadEvent event for Resyncperf.\n" ) );
        }

    }

    // This critical section won't be freed or deleted because of
    // potential timing issues.  But since it's only one, I think
    // we can live with it.
    if ( NULL == g_pResyncCs )
    {
        g_pResyncCs = new CRITICAL_SECTION;

        // We gotta big problem
        if ( NULL == g_pResyncCs )
        {
            // Log an event here
            ERRORTRACE( ( LOG_WINMGMT, "Could not create a ResyncCs critical section for Resyncperf.\n" ) );
        }
        else
        {
            InitializeCriticalSection( g_pResyncCs );
        }

    }

    gfResyncInit = (    NULL    !=  ghWaitableTimer &&
                        NULL    !=  g_pResyncCs     &&
                        NULL    != ghResyncThreadEvent  );

    // Read the initialization information

    Registry reg;
    
    if ( Registry::no_error == reg.Open( HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\WBEM\\CIMOM" ) )
    {
        long lError = reg.GetDWORD( L"ADAPDelay", &gdwADAPDelaySec );

        if ( Registry::no_error == lError )
        {
            //This is what we want
        }
        else if ( ERROR_FILE_NOT_FOUND == reg.GetLastError() )
        {
            // Not set, so add it
            reg.SetDWORD( L"ADAPDelay", WMIADAP_DEFAULT_DELAY );
            gdwADAPDelaySec = WMIADAP_DEFAULT_DELAY;
        }
        else
        {
            // Error
            ERRORTRACE( ( LOG_WINMGMT, "ResyncPerf experienced an error while attempting to read the WMIADAPDelay value in the CIMOM subkey.  Continuing using a default value.\n" ) );
            gdwADAPDelaySec = WMIADAP_DEFAULT_DELAY;
        }

        lError = reg.GetDWORD( L"LodCtrDelay", &gdwLodCtrDelaySec );

        if ( Registry::no_error == lError )
        {
            //This is what we want
        }
        else if ( ERROR_FILE_NOT_FOUND == reg.GetLastError() )
        {
            // Not set, so add it
            reg.SetDWORD( L"LodCtrDelay", WMIADAP_DEFAULT_DELAY );
            gdwLodCtrDelaySec = WMIADAP_DEFAULT_DELAY_LODCTR;
        }
        else
        {
            // Error
            ERRORTRACE( ( LOG_WINMGMT, "ResyncPerf experienced an error while attempting to read the WMIADAPDelay value in the CIMOM subkey.  Continuing using a default value.\n" ) );
            gdwLodCtrDelaySec = WMIADAP_DEFAULT_DELAY_LODCTR;
        }        
    }
    else
    {
        // Error
        ERRORTRACE( ( LOG_WINMGMT, "ResyncPerf could not open the CIMOM subkey to read initialization data. Continuing using a default value.\n" ) );
        gdwADAPDelaySec = WMIADAP_DEFAULT_DELAY;
        gdwLodCtrDelaySec = WMIADAP_DEFAULT_DELAY_LODCTR;
    }

    return gfResyncInit;
}

// PLEASE NOTE - THIS FUNCTION IS NOT REENTRANT!  PLEASE DO NOT CALL IT ON MULTIPLE THREADS!
void ResyncPerf( HANDLE hTerminate, BOOL bIsLodCtr )
{

    // Assume that we should check the timer
    BOOL    fFirstTime = !gfResyncInit;

    if ( !InitResync() )
        return;

    
    EnterCriticalSection( g_pResyncCs );

    // Now, if this or the first time, or the spawned resyncflag is set to TRUE, then we need
    // to kick off another thread.  By checking gfSpawnedResync in a critical section, since
    // it only gets set in the same critical section, we ensure that we will resignal as needed
    // as well as only kick off a thread when we really need to.

    BOOL    fSpawnThread = ( fFirstTime || gfSpawnedResync );

    if ( !fSpawnThread )
    {
        // We are here because we don't appear to have spawned a resync.
        // This is either because we are servicing many lodctr requests
        // within our time delay, or a dredger was started and
        // a previous request request to dredge is waiting for
        // the process to complete.  If the child process handle
        // is not NULL, there is no real need to reset the
        // waitable timer

        if ( NULL == ghChildProcessHandle && ghResyncThreadHandle )
        {
            // Reset the timer here
            ResetResyncTimer( ghWaitableTimer , bIsLodCtr );
        }

    }

    LeaveCriticalSection( g_pResyncCs );


    if ( fSpawnThread )
    {
        HANDLE  ahHandle[2];

        if ( NULL != ghResyncThreadHandle )
        {
            ahHandle[0] = hTerminate;
            ahHandle[1] = ghResyncThreadHandle;

            // Wait for ten seconds on this handle.  If it is not signalled, something is
            // direly wrong.  We're probably not going to be able to kick off a dredge
            // so put some info to this effect in the error log.  The only time we should
            // have contention here, is when a lodctr event is signalled, just as the timer
            // becomes signalled.  The resync thread will wake up and start another dredge
            // this thread will wait for the other thread to complete before continuing.
            // We will kick off another resync thread, which will start another dredge,
            // but it will wait for the first dredge to continue.  This is a worst case
            // scenario, and arguably kicking off two dredges isn't that bad of a bailout

            DWORD   dwRet = WaitForMultipleObjects( 2, ahHandle, FALSE, 10000 );

            // We're done
            if ( dwRet == WAIT_OBJECT_0 )
            {
                return;
            }

            if ( dwRet != WAIT_OBJECT_0 + 1 )
            {
                ERRORTRACE( ( LOG_WINMGMT, "The wait for a termination event or ResyncThreadHandle timed out in Resyncperf.\n" ) );
                return;
            }

            CloseHandle( ghResyncThreadHandle );
            ghResyncThreadHandle = NULL;
        }

        EnterCriticalSection( g_pResyncCs );

        DWORD   dwThreadId = 0;

        RESYNCPERFDATASTRUCT*   pResyncData = new RESYNCPERFDATASTRUCT;

        // Boy are we low on memory!
        if ( NULL == pResyncData )
        {
            LeaveCriticalSection( g_pResyncCs );

            // Log an event here
            ERRORTRACE( ( LOG_WINMGMT, "Could not create a RESYNCPERFDATASTRUCT in Resyncperf.\n" ) );
            
            return;
        }

        // Store the data for the resync operation
        pResyncData->m_hTerminate = hTerminate;
        pResyncData->m_hWaitableTimer = ghWaitableTimer;
        pResyncData->m_pcs = g_pResyncCs;
		pResyncData->m_fFullDredge = fFirstTime;
		pResyncData->m_bIsLodCtr = bIsLodCtr;

        ghResyncThreadHandle =  CreateThread( NULL, 0, 
                                              (LPTHREAD_START_ROUTINE)ResyncPerfThread, (void*) pResyncData,
                                              0, &gdwResyncThreadId );

        LeaveCriticalSection( g_pResyncCs );


        if ( NULL == ghResyncThreadHandle )
        {
            LeaveCriticalSection( g_pResyncCs );

            // Log an event here
            ERRORTRACE( ( LOG_WINMGMT, "Could not create a ResyncPerfThread thread in Resyncperf.\n" ) );

            return;
        }
        else
        {
            // Wait for the resync thread event to be signalled by the thread we just started.
            // If it doesn't signal in 10 seconds, something is VERY wrong
            DWORD   dwWait = WaitForSingleObject( ghResyncThreadEvent, INFINITE );

            if ( dwWait != WAIT_OBJECT_0 )
            {
                // Log an event
                ERRORTRACE( ( LOG_WINMGMT, "The ResyncPerfThread thread never signaled the ghResyncThreadEvent in Resyncperf.\n" ) );

                return;
            }
        }

    }   // IF fSpawnThread

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\winmgmt2\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define WIN32_NO_STATUS
#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
#define COREPOL_HEADERFILE_IS_INCLUDED

#define COREPROX_POLARITY __declspec( dllimport )

#define COREPOL_HEADERFILE_IS_INCLUDED
#define POLARITY_HEADERFILE_IS_INCLUDED
#define POLARITY __declspec( dllimport )

#include <wbemidl.h>
#include <wbemutil.h>
#include <wbemint.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\winmgmt2\resync2.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    RESYNC2.H

Abstract:

	Declares the various idle task

History:

--*/

#ifndef _RESYNC2_H_
#define _RESYNC2_H_

#include <wmistr.h>
#include <wmium.h>

#include <sync.h>

#define MAX_LOOP 0x100000


#define LOAD_CTR_EVENT_NAME _T("WMI_SysEvent_LodCtr")
#define UNLOAD_CTR_EVENT_NAME _T("WMI_SysEvent_UnLodCtr")

#define REVERSE_DREDGE_EVENT_NAME_SET _T("WMI_RevAdap_Set")
#define REVERSE_DREDGE_EVENT_NAME_ACK _T("WMI_RevAdap_ACK")

//
// these names containd the Idle word just because of a misunderstanding, 
// but we don't have idle task, just pending task at most
//
#define PENDING_TASK_START       _T("WMI_ProcessIdleTasksStart")
#define PENDING_TASK_COMPLETE    _T("WMI_ProcessIdleTasksComplete")

#define SIG_WDMEVENTS_BUSY       ((DWORD)'EMDW')
#define SIG_WDMEVENTS_FREE       ((DWORD)'emdw')

class CWDMListener
{
    enum {
        Type_Added,
        Type_Removed
    };

public:
    CWDMListener();
    ~CWDMListener();

    DWORD OpenAdd();
    DWORD CloseAdd();
    DWORD OpenRemove();
    DWORD CloseRemove();
    
    
    DWORD Register();
    VOID  Unregister();
    
    static VOID NTAPI  EvtCallBackAdd(VOID * pContext,BOOLEAN bTimerFired);
    static VOID NTAPI  EvtCallBackRem(VOID * pContext,BOOLEAN bTimerFired);
    static VOID WINAPI WmiCallBack(PWNODE_HEADER Wnode, UINT_PTR NotificationContext);

    VOID EvtCallThis(BOOLEAN bTimerFired,int Type);
    
private:
    DWORD     m_dwSignature;
    WMIHANDLE m_hEventAdd;
    WMIHANDLE m_hEventRem;
    HANDLE    m_hWaitAdd;
    HANDLE    m_hWaitRem;
    BOOL      m_UnInited;
    CCritSec  m_cs;
    GUID	  m_GuidAdd;// = GUID_MOF_RESOURCE_ADDED_NOTIFICATION ;
	GUID	  m_GuidRem;// = GUID_MOF_RESOURCE_REMOVED_NOTIFICATION ;
    
};

#define SIG_COUNTEEVENTS_BUSY       ((DWORD)'ETNC')
#define SIG_COUNTEEVENTS_FREE       ((DWORD)'etnc')

class CCounterEvts
{
    enum {
       Type_Load,
       Type_Unload
    };
public:
    CCounterEvts();
    ~CCounterEvts();
    DWORD Init();
    VOID UnInit();

    DWORD Register();
    DWORD Unregister();

    static VOID NTAPI EvtCallBackLoad(VOID * pContext,BOOLEAN bTimerFired);
    static VOID NTAPI EvtCallBackUnload(VOID * pContext,BOOLEAN bTimerFired);
    static VOID NTAPI EvtCallBackPendingTask(VOID * pContext,BOOLEAN bTimerFired);

    VOID CallBack(BOOLEAN bTimerFired,int Type);
    VOID CallBackPending(BOOLEAN bTimerFired);    
    BOOL IsInited(){return !m_Uninited; };
    HANDLE GetTaskCompleteEvent(){ return m_hPendingTasksComplete; };
    
private:
    DWORD  m_dwSignature;
    HANDLE m_hTerminateEvt;
    HANDLE m_LoadCtrEvent;
    HANDLE m_UnloadCtrEvent;

    HANDLE m_WaitLoadCtr;
    HANDLE m_WaitUnloadCtr;
    BOOL   m_Uninited;
    HANDLE m_hWmiReverseAdapSetLodCtr;
    HANDLE m_hWmiReverseAdapLodCtrDone;
    HANDLE m_hWaitPendingTasksStart;
    HANDLE m_hPendingTasksStart;
    HANDLE m_hPendingTasksComplete;    
};

DWORD ResyncPerf(DWORD dwReason);

#define MAX_PROCESS_WAIT (10*60*1000)
#define MAX_PROCESS_NUM  (2)

#define RESYNC_FULL_THROTTLE         0
#define RESYNC_DELTA_THROTTLE        1
#define RESYNC_RADAPD_THROTTLE       2
#define RESYNC_FULL_RADAPD_THROTTLE  3
#define RESYNC_DELTA_RADAPD_THROTTLE 4
#define RESYNC_FULL_RADAPD_NOTHROTTLE 5

#define RESYNC_TYPE_INITIAL          0
#define RESYNC_TYPE_LODCTR           1
#define RESYNC_TYPE_WDMEVENT         2
#define RESYNC_TYPE_CLASSCREATION    2  // intentionally duplicated
#define RESYNC_TYPE_PENDING_TASKS    3
#define RESYNC_TYPE_MAX              4

#define SIG_RESYNC_PERF              ((DWORD)'YSER')

class CMonitorEvents;

//
// the gate-ing is implemented with the  ResyncPerfTask::bFree
// The GetAvailable() will set the bFree to FALSE, 
// and any task completion will set that to TRUE.
// A task can be completed:
// immediatly in the Timer-Phase
//  this happens if the task has been disabled by ProcessIdleTasks
//  this happens if the ProcessIdleTasks command 
//      will be re-processed when OutStandingProcess == 0
// A task can be completed in the Event-Call back phase
//  when a process naturally exits or terminate process is invoked.
//  when there is an error in the machinery that creates the process
//
//

class ResyncPerfTask{
public:
    DWORD  dwSig;
    BOOL   bFree;               // set under CritSec
    DWORD  Type;                // set by GetAvailable
    DWORD  CmdType;             // set by GetAvailable or the TimerCallback
    HANDLE hTimer;              // set by the 
    DWORD  dwTimeDue;           // set by GetAvailable
    CMonitorEvents * pMonitor;  // set by the constructor
    HANDLE  hProcess;           // set by the DeltaDredge
    HANDLE  hWaitHandle;        //   
    BOOL    Enabled;            // this is to disable an already scheduled stask
};

//
//
//  MonitorEvents
//  This class monitors the Load-Unlodctr events
//  schedules the ResyncPerf
//  and monitors for WDM events in a Service-friendly way
//
///////////////////////////////////////////////////////////////

class CMonitorEvents
{
public:
    CMonitorEvents();
    ~CMonitorEvents();
    BOOL Init();
    BOOL Uninit();
    DWORD Register();   // called in the running/continue
    DWORD Unregister(BOOL bIsSystemShutDown); // called in the pause/stop
    
    VOID Lock(){ EnterCriticalSection(&m_cs); };
    VOID Unlock(){ LeaveCriticalSection(&m_cs); };

    VOID RegRead();
    ResyncPerfTask * GetAvailable(DWORD dwReason);
    DWORD GetFullTime(){ return m_dwTimeToFull; };
    FILETIME & GetTimeStamp(){ return m_FileTime; };
    static VOID NTAPI TimerCallBack(VOID * pContext,BOOLEAN bTimerFired);
    static VOID NTAPI EventCallBack(VOID * pContext,BOOLEAN bTimerFired);
    BOOL IsRegistred(){ return m_bRegistred; };
    HANDLE GetTaskCompleteEvent(){ return m_CntsEvts.GetTaskCompleteEvent(); };

    static BOOL WINAPI MonitorCtrlHandler( DWORD dwCtrlType );
    static BOOL CreateProcess_(TCHAR * pCmdLine,
	                      CMonitorEvents * pMonitor,
	                      ResyncPerfTask * pPerf);

    // public to avoid accessors
    LONG m_OutStandingProcesses ;
    BOOL m_bFullReverseNeeded;
    
private:

    BOOL m_bRegistred;
    
    DWORD            m_dwSig;
    BOOL             m_bInit;
    CRITICAL_SECTION m_cs;
    CCounterEvts     m_CntsEvts;
    CWDMListener     m_WDMListener;

    ResyncPerfTask   m_ResyncTasks[RESYNC_TYPE_MAX];
    DWORD m_dwADAPDelaySec;
    DWORD m_dwLodCtrDelaySec;
    DWORD m_dwTimeToFull;
    DWORD m_dwTimeToKillAdap;
    FILETIME m_FileTime;

};


#endif /**/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\winmgmt2\sched.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    SCHED.H

Abstract:

	Declares the CSched class which is a crude scheduler.

History:

--*/

#ifndef _sched_H_
#define _sched_H_


enum JobType {
    FirstCoreShutdown = 0, 
    FinalCoreShutdown, 
    CoreMaintLoad, 
    FlushDB, 
    PeriodicBackup, 
    PossibleStartCore, 
    EOL
};

class CSched
{
private:
    DWORD m_dwDue[EOL];
public:
    CSched();
    void SetWorkItem(JobType jt, DWORD dwMsFromNow);
    DWORD GetWaitPeriod();
    bool IsWorkItemDue(JobType jt);
    void ClearWorkItem(JobType jt);
    void StartCoreIfEssNeeded();

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\winmgmt2\resync2.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    RESYNC2.CPP

Abstract:


History:

    ivanbrug 01-Oct-2000  changed for svchost migration

--*/

#include "precomp.h"
#include <winntsec.h>
#include <malloc.h>
#include <tchar.h>
#include <initguid.h>
#include "WinMgmt.h"
#include <Wmistr.h>
#include <wmium.h>
#include <wmicom.h>
#include <wmimof.h>
#include "resync2.h"
#include "wbemdelta.h" // for DeltaDredge
#include "arrtempl.h"

//
//
//   this is because WDMLib is __BADLY__ DESIGNED
//
/////////////////////////////////////////////////////////////

void WINAPI EventCallbackRoutine(PWNODE_HEADER WnodeHeader, ULONG_PTR Context)
{
    return;
}

//
//
//  This class listens on WDM events
//
/////////////////////////////////////////////////////////////

CWDMListener::CWDMListener():
                  m_dwSignature(SIG_WDMEVENTS_BUSY),
                  m_hEventAdd(NULL),
                  m_hEventRem(NULL),
                  m_hWaitAdd(NULL),
                  m_hWaitRem(NULL),
                  m_UnInited(TRUE),
                  m_GuidAdd(GUID_MOF_RESOURCE_ADDED_NOTIFICATION),
                  m_GuidRem(GUID_MOF_RESOURCE_REMOVED_NOTIFICATION)
                  
{
 
}

DWORD 
CWDMListener::OpenAdd()
{
    DWORD dwErr;
    dwErr = WmiOpenBlock(&m_GuidAdd,
                         WMIGUID_NOTIFICATION | SYNCHRONIZE,
                         &m_hEventAdd);
    if (ERROR_SUCCESS == dwErr)
    {

        if (RegisterWaitForSingleObject(&m_hWaitAdd,
                                        m_hEventAdd,
                                        CWDMListener::EvtCallBackAdd,
                                        this,
                                        INFINITE,
                                        WT_EXECUTEONLYONCE))
        {
            return ERROR_SUCCESS;
        }
        else
        {
            dwErr = GetLastError();
        }
    }
    else
    {
        dwErr = GetLastError();
    }

    // if here, some errors
    CloseAdd();
    return dwErr;
}

DWORD 
CWDMListener::OpenRemove()
{
    DWORD dwRet;

    dwRet = WmiOpenBlock(&m_GuidRem,
                         WMIGUID_NOTIFICATION | SYNCHRONIZE,
                         &m_hEventRem);
    if (ERROR_SUCCESS == dwRet)
    {
        if (RegisterWaitForSingleObject(&m_hWaitRem,
                                        m_hEventRem,
                                        CWDMListener::EvtCallBackRem,
                                        this,
                                        INFINITE,
                                        WT_EXECUTEONLYONCE))
        {
            return ERROR_SUCCESS;                    
        }
        else
        {
            dwRet = GetLastError();
        }        
    }
    else
    {
        dwRet = GetLastError();
    }

    CloseRemove();
    return dwRet;

}

DWORD
CWDMListener::CloseAdd()
{
    if (m_hWaitAdd){
        UnregisterWaitEx(m_hWaitAdd,NULL);
        m_hWaitAdd = NULL;
    }
    if (m_hEventAdd){
        WmiCloseBlock(m_hEventAdd);
        m_hEventAdd = NULL;
    }
    return 0;
}

DWORD
CWDMListener::CloseRemove()
{
    if (m_hWaitRem){    
        UnregisterWaitEx(m_hWaitRem,NULL);
        m_hWaitRem = NULL;
    }
    if (m_hEventRem){
        WmiCloseBlock(m_hEventRem);
        m_hEventRem = NULL;
    }
    return 0;    
}


VOID
CWDMListener::Unregister()
{
    CInCritSec ics(&m_cs);
    
    if (m_UnInited)
        return;

    m_UnInited = TRUE;
    m_dwSignature = SIG_WDMEVENTS_FREE;

    CloseAdd();
    CloseRemove();    
}

CWDMListener::~CWDMListener()
{
    Unregister(); 
}

DWORD 
CWDMListener::Register()
{
    CInCritSec ics(&m_cs);

    if (!m_UnInited) // prevent multiple calls
        return 0;

    m_dwSignature = SIG_WDMEVENTS_BUSY;
    
    if (ERROR_SUCCESS == OpenAdd() && ERROR_SUCCESS == OpenRemove())
    {
        // OK here
        m_UnInited = FALSE;
    }
    else
    {
        m_dwSignature = SIG_WDMEVENTS_FREE;            
        m_UnInited = TRUE;
    }

    return GetLastError();
}

VOID NTAPI 
CWDMListener::EvtCallBackAdd(VOID * pContext,BOOLEAN bTimerFired)
{
    if (!GLOB_Monitor_IsRegistred())
    {
        return;
    }
    
    CWDMListener * pThis = (CWDMListener *)pContext;

    if (SIG_WDMEVENTS_BUSY != pThis->m_dwSignature)
    {
        return;
    };

    if (pThis)    
	    pThis->EvtCallThis(bTimerFired,Type_Added);

    //
    // we have process the WDM event
    // since we are in the RtlpWorkerThread and 
    // we are registred with WT_EXECUTEONLYONCE
    // REDO FROM START
    //
	{
    	CInCritSec ics(&pThis->m_cs);
        if (ERROR_SUCCESS == pThis->CloseAdd())
        {
            pThis->OpenAdd();
        }    	
	}
}

VOID NTAPI 
CWDMListener::EvtCallBackRem(VOID * pContext,BOOLEAN bTimerFired)
{
    if (!GLOB_Monitor_IsRegistred())
    {
        return;
    }

    CWDMListener * pThis = (CWDMListener *)pContext;

    if (SIG_WDMEVENTS_BUSY != pThis->m_dwSignature)
    {
        return;
    };
    
    if (pThis)
        pThis->EvtCallThis(bTimerFired,Type_Removed);
        
    //
    // we have process the WDM event
    // since we are in the RtlpWorkerThread and 
    // we are registred with WT_EXECUTEONLYONCE
    // REDO FROM START
    //        
	{
    	CInCritSec ics(&pThis->m_cs);
        if (ERROR_SUCCESS == pThis->CloseRemove())
        {
            pThis->OpenRemove();
        }    	
	}        
}


VOID
CWDMListener::EvtCallThis(BOOLEAN bTimerFired, int Type)
{
    if (bTimerFired)
    {
        // never here
    }
    else
    {
        if (m_UnInited)
            return;
        
        DWORD dwRet;
        if (Type_Added == Type)
        {
            dwRet = WmiReceiveNotifications(1,&m_hEventAdd,CWDMListener::WmiCallBack,(ULONG_PTR)this);
        }
        else if (Type_Removed == Type)
        {
            dwRet = WmiReceiveNotifications(1,&m_hEventRem,CWDMListener::WmiCallBack,(ULONG_PTR)this);
        }
    }
}

VOID WINAPI 
CWDMListener::WmiCallBack(PWNODE_HEADER Wnode, 
                          UINT_PTR NotificationContext)
{

    CWDMListener * pThis = (CWDMListener *)NotificationContext;
    
#ifdef DEBUG_ADAP

    WCHAR pszClsID[40];
    StringFromGUID2(Wnode->Guid,pszClsID,40);
    DBG_PRINTFA((pBuff,"Flag %08x ProvId %08x %p GUID %S\n",
                 Wnode->Flags,Wnode->ProviderId,(ULONG_PTR)Wnode->ClientContext,pszClsID));
    if (WNODE_FLAG_ALL_DATA & Wnode->Flags)
    {
        WNODE_ALL_DATA * pAllData = (WNODE_ALL_DATA *)Wnode;
        DWORD i;
        for (i=0;i<pAllData->InstanceCount;i++)
        {
            WCHAR pTmpBuff[MAX_PATH+1];
            pTmpBuff[MAX_PATH] = 0;
            DWORD dwSize = (pAllData->OffsetInstanceDataAndLength[i].LengthInstanceData>MAX_PATH)?MAX_PATH:pAllData->OffsetInstanceDataAndLength[i].LengthInstanceData;
            memcpy(pTmpBuff,(BYTE*)pAllData+pAllData->OffsetInstanceDataAndLength[i].OffsetInstanceData,dwSize);
            DBG_PRINTFA((pBuff,"%d - %S\n",i,pTmpBuff));
            //DEBUGTRACE((LOG_WMIADAP,"%d - %S\n",i,pTmpBuff));
        }
    };

#endif

#ifdef DBG
    if (!HeapValidate(GetProcessHeap(),0,NULL))
    {
        DebugBreak();
    }
    if (!HeapValidate(CWin32DefaultArena::GetArenaHeap(),0,NULL))
    {
        DebugBreak();
    }    
#endif
    
    CWMIBinMof  WMIBinMof;
	//=============================================================================
	// Note: this combo will always succeed, as all the initialize is doing is 
	// setting a flag to FALSE and returning S_OK
	//=============================================================================
	if( SUCCEEDED( WMIBinMof.Initialize(NULL,FALSE)) )
	{
   		if (WMIBinMof.BinaryMofEventChanged(Wnode))
		{     
#ifdef DEBUG_ADAP		
			DBG_PRINTFA((pBuff,"---- WMIBinMof.BinaryMofEventChanged == CHANGED ----\n"));
#endif
			ERRORTRACE((LOG_WMIADAP,"WDM event && WMIBinMof.BinaryMofEventChanged == TRUE\n"));

			ResyncPerf(RESYNC_TYPE_WDMEVENT);
#ifdef DBG
		    if (!HeapValidate(GetProcessHeap(),0,NULL))
		    {
		        DebugBreak();
		    }
		    if (!HeapValidate(CWin32DefaultArena::GetArenaHeap(),0,NULL))
		    {
		        DebugBreak();
		    }			
#endif
		}
		else
		{
#ifdef DEBUG_ADAP		
			 DBG_PRINTFA((pBuff,"---- WMIBinMof.BinaryMofEventChanged == NOT CHANGED ----\n"));
#endif
		}
	}
    return;
}



CCounterEvts::CCounterEvts():
                 m_dwSignature(SIG_COUNTEEVENTS_BUSY),
                 m_LoadCtrEvent(NULL),
                 m_UnloadCtrEvent(NULL),
                 m_Uninited(TRUE),
                 m_WaitLoadCtr(NULL),
                 m_WaitUnloadCtr(NULL),
                 m_hWmiReverseAdapSetLodCtr(NULL),
                 m_hWmiReverseAdapLodCtrDone(NULL),
                 m_hPendingTasksStart(NULL),
                 m_hPendingTasksComplete(NULL)
{    
}

DWORD g_LocalSystemSD[] = {
0x80040001, 0x00000014, 0x00000020, 0x00000000,
0x0000002c, 0x00000101, 0x05000000, 0x00000012,
0x00000101, 0x05000000, 0x00000012, 0x00300002, 
0x00000001, 0x00140000, 0x001f0003, 0x00000101, 
0x05000000, 0x00000012, 0x00000000, 0x00000000
};

//
// for testing purpose, allow administrators to use the event
//
DWORD g_LocalSystemAdminsSD[] = {
0x80040001, 0x00000014, 0x00000020, 0x00000000,
0x0000002c, 0x00000101, 0x05000000, 0x00000012,
0x00000101, 0x05000000, 0x00000012, 0x00340002, 
0x00000002, 0x00140000, 0x001f0003, 0x00000101, 
0x05000000, 0x00000012, 0x00180000, 0x001f0003, 
0x00000201, 0x05000000, 0x00000020, 0x00000220 
};

DWORD
CCounterEvts::Init()
{
    if (!m_Uninited)
       return 0;
    
    m_LoadCtrEvent = CreateEvent(NULL, FALSE, FALSE,LOAD_CTR_EVENT_NAME);
    if (m_LoadCtrEvent)
        SetObjectAccess2(m_LoadCtrEvent);
    else
        goto end_fail;

    m_UnloadCtrEvent = CreateEvent(NULL, FALSE, FALSE, UNLOAD_CTR_EVENT_NAME);
    
    if (m_UnloadCtrEvent)
        SetObjectAccess2(m_UnloadCtrEvent);
    else
        goto end_fail;    

    m_hWmiReverseAdapSetLodCtr = CreateEvent(NULL,FALSE,FALSE,REVERSE_DREDGE_EVENT_NAME_SET);
    
    if (m_hWmiReverseAdapSetLodCtr)
        SetObjectAccess2(m_hWmiReverseAdapSetLodCtr);
    else
        goto end_fail;    

    m_hWmiReverseAdapLodCtrDone = CreateEvent(NULL,FALSE,FALSE,REVERSE_DREDGE_EVENT_NAME_ACK);
    if (m_hWmiReverseAdapLodCtrDone)
       SetObjectAccess2(m_hWmiReverseAdapLodCtrDone);      
    else
        goto end_fail;    

    SECURITY_ATTRIBUTES sa;
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);    
    //sa.lpSecurityDescriptor = (LPVOID)g_LocalSystemSD;
    // test only
    sa.lpSecurityDescriptor = (LPVOID)g_LocalSystemAdminsSD;
    sa.bInheritHandle = FALSE;

    m_hPendingTasksStart = CreateEvent(&sa,FALSE,FALSE,PENDING_TASK_START);
    if (!m_hPendingTasksStart)
   	    goto end_fail;

    m_hPendingTasksComplete = CreateEvent(&sa,TRUE,TRUE,PENDING_TASK_COMPLETE);
    if (!m_hPendingTasksComplete)
    	goto end_fail;

    m_Uninited = FALSE;
    return NO_ERROR;    
    
end_fail:
    return GetLastError();        
}

VOID NTAPI 
CCounterEvts::EvtCallBackLoad(VOID * pContext,BOOLEAN bTimerFired)
{
    if (!GLOB_Monitor_IsRegistred())
    {
        return;
    }

    CCounterEvts * pCounter = (CCounterEvts *)pContext;

    if (SIG_COUNTEEVENTS_BUSY != pCounter->m_dwSignature)
    {
        return;
    }
    
    pCounter->CallBack(bTimerFired,Type_Load);

}

VOID NTAPI 
CCounterEvts::EvtCallBackUnload(VOID * pContext,BOOLEAN bTimerFired)
{
    if (!GLOB_Monitor_IsRegistred())
    {
        return;
    }

    CCounterEvts * pCounter = (CCounterEvts *)pContext;

    if (SIG_COUNTEEVENTS_BUSY != pCounter->m_dwSignature)
    {
        return;
    }
        
    pCounter->CallBack(bTimerFired,Type_Unload);

}

VOID NTAPI 
CCounterEvts::EvtCallBackPendingTask(VOID * pContext,BOOLEAN bTimerFired)
{
    if (!GLOB_Monitor_IsRegistred())
    {
        return;
    }

    CCounterEvts * pCounter = (CCounterEvts *)pContext;

    if (SIG_COUNTEEVENTS_BUSY != pCounter->m_dwSignature)
    {
        return;
    }
        
    pCounter->CallBackPending(bTimerFired);

}

VOID 
CCounterEvts::CallBack(BOOLEAN bTimerFired,int Type)
{
#ifdef DEBUG_ADAP
    DBG_PRINTFA((pBuff,"CallBack with type %d called\n",Type));
#endif    
    
    if (GLOB_IsResyncAllowed())
    {
        DWORD dwRet = WaitForSingleObject(m_hWmiReverseAdapSetLodCtr,0);
        if (WAIT_OBJECT_0 == dwRet)
        {
            // this is the hack not to spawn a Delta Dredge when there is before a Reverese Dredge
#ifdef DEBUG_ADAP            
            DBG_PRINTFA((pBuff," - SetEvent(m_hWmiReverseAdapLodCtrDone);\n"));
#endif
            SetEvent(m_hWmiReverseAdapLodCtrDone);
        }
        else
        {
#ifdef DEBUG_ADAP        
            DBG_PRINTFA((pBuff," - ResyncPerf(RESYNC_TYPE_LODCTR);\n"));
#endif
            ResyncPerf(RESYNC_TYPE_LODCTR);
        }
    }
}

VOID 
CCounterEvts::CallBackPending(BOOLEAN bTimerFired)
{
    if (GLOB_IsResyncAllowed())
    {
#ifdef DEBUG_ADAP    
        DBG_PRINTFA((pBuff," - PendingTask Start set\n"));
#endif
        ResyncPerf(RESYNC_TYPE_PENDING_TASKS);
    }
}

DWORD 
CCounterEvts::Register()
{
    m_dwSignature = SIG_COUNTEEVENTS_BUSY;

    BOOL LoadUnloadOK = FALSE;
    if (RegisterWaitForSingleObject(&m_WaitLoadCtr,
                                    m_LoadCtrEvent,
                                    CCounterEvts::EvtCallBackLoad,
                                    this,
                                    INFINITE,
                                    WT_EXECUTEDEFAULT)) // automatic reset
    {
        if(RegisterWaitForSingleObject(&m_WaitUnloadCtr,
                                       m_UnloadCtrEvent,
                                       CCounterEvts::EvtCallBackUnload,
                                       this,
                                       INFINITE,
                                       WT_EXECUTEDEFAULT)) // automatic reset
        {
            LoadUnloadOK = TRUE;
        }
        else
        {
            UnregisterWaitEx(m_WaitLoadCtr,NULL);
            m_WaitLoadCtr = NULL;
        }
    }

    if (LoadUnloadOK &&
      RegisterWaitForSingleObject(&m_hWaitPendingTasksStart,
                              m_hPendingTasksStart,
                              CCounterEvts::EvtCallBackPendingTask,
                              this,
                              INFINITE,
                              WT_EXECUTEDEFAULT))
    {
        return ERROR_SUCCESS;
    }
    else
    {
        UnregisterWaitEx(m_WaitLoadCtr,NULL);
        m_WaitLoadCtr = NULL;
        UnregisterWaitEx(m_WaitUnloadCtr,NULL);
        m_WaitUnloadCtr = NULL;            
    }

    return GetLastError();
}

DWORD 
CCounterEvts::Unregister()
{
    m_dwSignature = SIG_COUNTEEVENTS_FREE;

    if (m_WaitLoadCtr)
    {
        UnregisterWaitEx(m_WaitLoadCtr,NULL);
        m_WaitLoadCtr = NULL;
    }
    if (m_WaitUnloadCtr)
    {
        UnregisterWaitEx(m_WaitUnloadCtr,NULL);
        m_WaitUnloadCtr = NULL;
    }
    if (m_hWaitPendingTasksStart)
    {
        UnregisterWaitEx(m_hWaitPendingTasksStart,NULL);
        m_hWaitPendingTasksStart = NULL;
    }
    return 0;
}

VOID
CCounterEvts::UnInit()
{
    if (!m_Uninited)
        return;
        
    if(m_LoadCtrEvent) {
        CloseHandle(m_LoadCtrEvent);
        m_LoadCtrEvent = NULL;
    }
    if(m_UnloadCtrEvent)
    {
        CloseHandle(m_UnloadCtrEvent);
        m_UnloadCtrEvent = NULL;
    }
    if (m_hWmiReverseAdapSetLodCtr)
    {
        CloseHandle(m_hWmiReverseAdapSetLodCtr);
        m_hWmiReverseAdapSetLodCtr = NULL;
    }
    if (m_hWmiReverseAdapLodCtrDone)
    {
        CloseHandle(m_hWmiReverseAdapLodCtrDone);
        m_hWmiReverseAdapLodCtrDone = NULL;
    }
    if (m_hPendingTasksStart)
    {
        CloseHandle(m_hPendingTasksStart);
        m_hPendingTasksStart = NULL;
    }
    if (m_hPendingTasksComplete)
    {
        CloseHandle(m_hPendingTasksComplete);
        m_hPendingTasksComplete = NULL;
    }                                   
    m_Uninited = TRUE;
}

CCounterEvts::~CCounterEvts()
{
    if (!m_Uninited)
        UnInit();
        
    m_dwSignature = SIG_COUNTEEVENTS_FREE;        
}

//
//  this is the main abstraction
//  the child classes will call the ResyncPerf function,
//  as long as the CWbemServices write hook.
//  The ResyncPerf function will grab the global monitor
//  and register a Timer Callback
//  the gate will be implemented in the GetAvailable function
//
//
/////////////////////////////////////////////////////////////////////

CMonitorEvents::CMonitorEvents():
    m_bInit(FALSE),
    m_bRegistred(FALSE)
{
    InitializeCriticalSection(&m_cs);
};

CMonitorEvents::~CMonitorEvents()
{
    DeleteCriticalSection(&m_cs);    
}


BOOL WINAPI
CMonitorEvents::MonitorCtrlHandler( DWORD dwCtrlType )
{
    BOOL bRet = FALSE;
    switch(dwCtrlType)
    {
    case CTRL_SHUTDOWN_EVENT:        
    
        GLOB_GetMonitor()->m_WDMListener.Unregister();
#ifdef DEBUG_ADAP        
        DBG_PRINTFA((pBuff,"WDM Handles closed\n"));
#endif
        bRet = TRUE;
        break;
    default:
        bRet = FALSE;
    };
    return bRet;    
};


BOOL 
CMonitorEvents::Init()
{

    if (m_bInit)
        return TRUE;

    Lock();

    if (m_bInit)
    {
        Unlock();
        return TRUE;
    }

    m_dwSig =  'VEOM';
    m_CntsEvts.Init();
    m_dwADAPDelaySec = WMIADAP_DEFAULT_DELAY;
    m_dwLodCtrDelaySec = WMIADAP_DEFAULT_DELAY_LODCTR;
    m_dwTimeToFull = WMIADAP_DEFAULT_TIMETOFULL;
    m_dwTimeToKillAdap = MAX_PROCESS_WAIT;

    memset(&m_FileTime,0,sizeof(m_FileTime));
    
    RegRead();
    
    for (DWORD i=0;i<RESYNC_TYPE_MAX;i++)
    {
        m_ResyncTasks[i].dwSig       = SIG_RESYNC_PERF;
        m_ResyncTasks[i].bFree       = TRUE;
        m_ResyncTasks[i].pMonitor    = this;
        m_ResyncTasks[i].hTimer      = NULL;
        m_ResyncTasks[i].hWaitHandle = NULL;
        m_ResyncTasks[i].hProcess    = NULL;
        m_ResyncTasks[i].Enabled = TRUE;
    }

    //m_ResyncTasks[RESYNC_TYPE_LODCTR].CmdType // to be decided by DeltaDredge
    m_ResyncTasks[RESYNC_TYPE_INITIAL].dwTimeDue = (m_dwADAPDelaySec)*1000;
    
    m_ResyncTasks[RESYNC_TYPE_LODCTR].CmdType = RESYNC_DELTA_THROTTLE;
    m_ResyncTasks[RESYNC_TYPE_LODCTR].dwTimeDue = (m_dwLodCtrDelaySec)*1000;

    // //RESYNC_TYPE_CLASSCREATION is the same
    m_ResyncTasks[RESYNC_TYPE_WDMEVENT].CmdType = RESYNC_RADAPD_THROTTLE;
    m_ResyncTasks[RESYNC_TYPE_WDMEVENT].dwTimeDue = (m_dwLodCtrDelaySec)*1000;

    m_ResyncTasks[RESYNC_TYPE_PENDING_TASKS].CmdType =   RESYNC_FULL_RADAPD_NOTHROTTLE;
    m_ResyncTasks[RESYNC_TYPE_PENDING_TASKS].dwTimeDue = 500; // hard coded

    //
    // set up the console handler
    //
    SetConsoleCtrlHandler( MonitorCtrlHandler, TRUE );

    //
    // let's asses some initial state for the IdleTask business
    //
    m_OutStandingProcesses = 0;
    m_bFullReverseNeeded = FALSE;

    m_bInit = TRUE;

    Unlock();

    return TRUE;
};


BOOL 
CMonitorEvents::Uninit()
{
    if (!m_bInit)
        return TRUE;

    Lock();

    if (!m_bInit)
    {
        Unlock();
        return TRUE;
    }

    
    for (DWORD i=0;i<RESYNC_TYPE_MAX;i++)
    {
        if (m_ResyncTasks[i].hTimer)
        {
            DeleteTimerQueueTimer(NULL,m_ResyncTasks[i].hTimer,NULL);
            m_ResyncTasks[i].hTimer = NULL;
        }
        if (m_ResyncTasks[i].hWaitHandle)
        {
            UnregisterWaitEx(m_ResyncTasks[i].hWaitHandle,NULL);
            m_ResyncTasks[i].hWaitHandle = NULL;        
        }
        if (m_ResyncTasks[i].hProcess)
        {
            CloseHandle(m_ResyncTasks[i].hProcess);
            m_ResyncTasks[i].hProcess = NULL;
        }
        m_ResyncTasks[i].dwSig = (DWORD)'eerf';
    }

    m_CntsEvts.UnInit();

    //
    // tear-down the console handler
    //
    SetConsoleCtrlHandler( MonitorCtrlHandler, FALSE );

    m_bInit = FALSE;
    m_dwSig = 'veom';
   
    Unlock();
    
    return TRUE;
};


//
//
// called in the running/continue
//
/////////////

DWORD 
CMonitorEvents::Register()
{
    m_CntsEvts.Register();
    m_WDMListener.Register();    

    m_bRegistred = TRUE;
    
    return 0;
};   

//
//
// called in the pause/stop
//
//////////////////////////////////////////////////////////

DWORD 
CMonitorEvents::Unregister(BOOL bIsSystemShutDown)
{

    m_bRegistred = FALSE;

    if (!bIsSystemShutDown)
    {
        m_CntsEvts.Unregister();
        m_WDMListener.Unregister();
    }
    return 0;
};

//
//
//
/////////////////////////////////////////////////////////

VOID
CMonitorEvents::RegRead()
{
    // Read the initialization information

    LONG lRet;
    HKEY hKey;
    DWORD dwTemp;

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        _T("Software\\Microsoft\\WBEM\\CIMOM"),
                        NULL,
                        KEY_READ|KEY_WRITE,
                        &hKey);
    
    
    if (ERROR_SUCCESS == lRet)
    {
        DWORD dwType;
        DWORD dwSize = sizeof(DWORD);
        lRet = RegQueryValueEx(hKey,
                               _T("ADAPDelay"),
                               NULL,
                               &dwType,
                               (BYTE *)&m_dwADAPDelaySec,
                               &dwSize);

        if (ERROR_SUCCESS == lRet)
        {
            //This is what we want
        }
        else if ( ERROR_FILE_NOT_FOUND == lRet )
        {
            dwTemp = WMIADAP_DEFAULT_DELAY;
            RegSetValueEx(hKey,
                          _T("ADAPDelay"),
                          NULL,
                          REG_DWORD,
                          (BYTE *)&dwTemp,
                          sizeof(DWORD));
        }
        else
        {
            // Error
            ERRORTRACE( ( LOG_WINMGMT, "ResyncPerf experienced an error while attempting to read the WMIADAPDelay value in the CIMOM subkey.  Continuing using a default value.\n" ) );
        }

        lRet = RegQueryValueEx(hKey,
                               _T("LodCtrDelay"),
                               NULL,
                               &dwType,
                               (BYTE *)&m_dwLodCtrDelaySec,
                               &dwSize);

        if (ERROR_SUCCESS == lRet)
        {
            //This is what we want
        }
        else if ( ERROR_FILE_NOT_FOUND == lRet )
        {
            dwTemp = WMIADAP_DEFAULT_DELAY_LODCTR;
            RegSetValueEx(hKey,
                          _T("LodCtrDelay"),
                          NULL,
                          REG_DWORD,
                          (BYTE *)&dwTemp,
                          sizeof(DWORD));
        }
        else
        {
            // Error
            ERRORTRACE( ( LOG_WINMGMT, "ResyncPerf experienced an error while attempting to read the WMIADAPDelay value in the CIMOM subkey.  Continuing using a default value.\n" ) );
        }         

        lRet = RegQueryValueEx(hKey,
                               ADAP_TIME_TO_FULL,
                               NULL,
                               &dwType,
                               (BYTE *)&m_dwTimeToFull,
                               &dwSize);

        if (ERROR_SUCCESS == lRet)
        {
            //This is what we want
        }
        else if ( ERROR_FILE_NOT_FOUND == lRet )
        {
            dwTemp = WMIADAP_DEFAULT_TIMETOFULL;
            RegSetValueEx(hKey,
                          ADAP_TIME_TO_FULL,
                          NULL,
                          REG_DWORD,
                          (BYTE *)&dwTemp,
                          sizeof(DWORD));
        }
        else
        {
            // Error
            ERRORTRACE( ( LOG_WINMGMT, "ResyncPerf experienced an error while attempting to read the WMIADAPDelay value in the CIMOM subkey.  Continuing using a default value.\n" ) );
        }

        lRet = RegQueryValueEx(hKey,
                               ADAP_TIME_TO_KILL_ADAP,
                               NULL,
                               &dwType,
                               (BYTE *)&m_dwTimeToKillAdap,
                               &dwSize);

        if (ERROR_SUCCESS == lRet)
        {
            //This is what we want
        }
        else if ( ERROR_FILE_NOT_FOUND == lRet )
        {
            dwTemp = MAX_PROCESS_WAIT;
            RegSetValueEx(hKey,
                          ADAP_TIME_TO_KILL_ADAP,
                          NULL,
                          REG_DWORD,
                          (BYTE *)&dwTemp,
                          sizeof(DWORD));
        }
        else
        {
            // Error
            ERRORTRACE( ( LOG_WINMGMT, "ResyncPerf experienced an error while attempting to read the %S value in the CIMOM subkey.  Continuing using a default value.\n",ADAP_TIME_TO_KILL_ADAP));
        }

        //ADAP_TIMESTAMP_FULL
        dwSize = sizeof(FILETIME);
        lRet = RegQueryValueEx(hKey,
                               ADAP_TIMESTAMP_FULL,
                               NULL,
                               &dwType,
                               (BYTE *)&m_FileTime,
                               &dwSize);


        RegCloseKey(hKey);
    }
    else
    {
        // Error
        ERRORTRACE( ( LOG_WINMGMT, "ResyncPerf could not open the CIMOM subkey to read initialization data. Continuing using a default value.\n" ) );

    }

}

//
//
//
////////////////////////////////////////////////////////

ResyncPerfTask *
CMonitorEvents::GetAvailable(DWORD dwReason)
{
    ResyncPerfTask * pPerf = NULL;
    
    EnterCriticalSection(&m_cs);

    if (m_ResyncTasks[dwReason].bFree)
    {
        m_ResyncTasks[dwReason].bFree = FALSE;
        m_ResyncTasks[dwReason].Type = dwReason;
        pPerf = &m_ResyncTasks[dwReason];
    }
    
    LeaveCriticalSection(&m_cs);
    return pPerf;
}

TCHAR * g_Strings[] = {
    _T("/F /T"),     // FULL            Throttle
    _T("/D /T"),     // DELTA           Throttle    
    _T("/R /T"),     // REVERSE_ADAPTER Throttle        
    _T("/F /R /T"),  // FULL REVERSE_ADAPTER Throttle
    _T("/D /R /T"),  // DELTA REVERSE_ADAPTER Throttle
    _T("/F /R")      // FULL REVERSE no Throttle
};

void inline DoUnThrottleDredges()
{
#ifdef DEBUG_ADAP
    DBG_PRINTFA((pBuff,"DoUnThrottleDredges\n"));
#endif
    RegSetDWORD(HKEY_LOCAL_MACHINE,HOME_REG_PATH,DO_THROTTLE,0);
    return;
}

void inline DoThrottleDredges()
{
#ifdef DEBUG_ADAP
    DBG_PRINTFA((pBuff,"DoThrottleDredges\n"));
#endif
    RegSetDWORD(HKEY_LOCAL_MACHINE,HOME_REG_PATH,DO_THROTTLE,1);    
    return;
}

BOOL 
CMonitorEvents::CreateProcess_(TCHAR * pCmdLine,
                            CMonitorEvents * pMonitor,
                            ResyncPerfTask * pPerf)
{
		    BOOL bRes = FALSE;
		    STARTUPINFO si;
		    PROCESS_INFORMATION ProcInfo;
		    memset(&si,0,sizeof(STARTUPINFO));
		    si.cb = sizeof(STARTUPINFO);
			si.dwFlags = STARTF_FORCEOFFFEEDBACK;

			// Get the appropriate cmdline and attach the proper command line switches
			LPTSTR	pWriteableBuff = GetWMIADAPCmdLine( 64 );
			CVectorDeleteMe<TCHAR>	vdm( pWriteableBuff );

			if ( NULL == pWriteableBuff )
			{
		        ERRORTRACE((LOG_WINMGMT,"Memory Allocation error spawning dredger!\n"));
			    pMonitor->Lock();
			    pPerf->bFree = TRUE;
			    pMonitor->Unlock();		        
				return bRes;
			}


#ifdef DEBUG_ADAP
                  DBG_PRINTFA((pBuff,"Creating process: %S\n",pCmdLine));
#endif 
                  DEBUGTRACE((LOG_WMIADAP,"Creating process: %S\n",pCmdLine));

		    bRes = CreateProcess(pWriteableBuff,
		                         pCmdLine,
		                         NULL,
		                         NULL,
		                         FALSE,
		                         CREATE_NO_WINDOW,
		                         NULL,
		                         NULL,
		                         &si,
		                         &ProcInfo);
		    if (bRes)
		    {
		        CloseHandle(ProcInfo.hThread);

		        pPerf->hProcess = ProcInfo.hProcess;

		        if (RegisterWaitForSingleObject(&pPerf->hWaitHandle,
		                                        pPerf->hProcess,
		                                        CMonitorEvents::EventCallBack,
		                                        pPerf,
		                                        pMonitor->m_dwTimeToKillAdap,
		                                        WT_EXECUTEONLYONCE|WT_EXECUTEINWAITTHREAD))
		        {
		            //
		            // we don't need to free the slot, 
		            // because the event callback will do that
		            //
		        } 
		        else
		        {
		            DEBUGTRACE((LOG_WMIADAP,"Unable to schedule WmiADAP process termination handler: err %d\n",GetLastError()));
		            CloseHandle(pPerf->hProcess);
				    pPerf->hProcess = NULL;
				    pMonitor->Lock();
				    pPerf->bFree = TRUE;
				    pMonitor->Unlock();		            
		        }
		    }
		    else
		    {
		        ERRORTRACE((LOG_WINMGMT,"CreatProcess %S err: %d\n",pWriteableBuff,GetLastError()));
	            pMonitor->Lock();
    	        pPerf->bFree = TRUE;
        	    pMonitor->Unlock();		        
		    }
    return bRes;		    
}

VOID NTAPI 
CMonitorEvents::EventCallBack(VOID * pContext,BOOLEAN bTimerFired)
{
    if (!GLOB_Monitor_IsRegistred())
    {
        return;
    }

    ResyncPerfTask * pPerf = (ResyncPerfTask *)pContext;

    if (!pPerf || (SIG_RESYNC_PERF  != pPerf->dwSig))
    {        
        return;
    }
    
    CMonitorEvents * pMonitor = pPerf->pMonitor;
    HANDLE hProcess = pPerf->hProcess;
    
    if(bTimerFired)
    {
        //
        //    The LONG time-out for our process has expired
        //    Kill The Process
        //
        TerminateProcess(pPerf->hProcess,0);
#ifdef DEBUG_ADAP        
        DBG_PRINTFA((pBuff,"WmiADAP did not finish within %d msec\n",pMonitor->m_dwTimeToKillAdap));
#endif
        ERRORTRACE((LOG_WMIADAP,"the ResyncTask of type %d timed-out and has been killed\n",pPerf->Type));
    }
    else
    {
        //
        // the handle has been signaled, meaning that
        // the process exited normally
        // 
#ifdef DEBUG_ADAP        
        DBG_PRINTFA((pBuff,"ResyncPerf for task %d completed\n",pPerf->Type));
#endif
    }

    CloseHandle(pPerf->hProcess);
    //
    // if there was a call to ProcessIdleTasks
    // if we were forced to unthrottle the running tasks
    // revert back
    //
    if (RESYNC_TYPE_PENDING_TASKS == pPerf->Type)
    {
        pMonitor->m_bFullReverseNeeded = FALSE;
    	DoThrottleDredges();
#ifdef DEBUG_ADAP    	
        DBG_PRINTFA((pBuff,"Setting the WMI_ProcessIdleTasksComplete\n"));    	
#endif
        if (GLOB_GetMonitor()->IsRegistred())        
            SetEvent(GLOB_GetMonitor()->GetTaskCompleteEvent());
    } 
    else // a process has exited or it has been terminated
    {
        LONG nProc = InterlockedDecrement(&pMonitor->m_OutStandingProcesses);
#ifdef DEBUG_ADAP        
        DBG_PRINTFA((pBuff,"(-) Outstanding Tasks %d\n",pMonitor->m_OutStandingProcesses));
#endif
        if (0 == nProc &&
          pMonitor->m_bFullReverseNeeded)
        {
            // Create Here the process
            CMonitorEvents * pMonitor = GLOB_GetMonitor();
            ResyncPerfTask * pPerfTask = pMonitor->GetAvailable(RESYNC_TYPE_PENDING_TASKS);
            if (pPerfTask)
            {
			    TCHAR pCmdLine[64];
			    _tcscpy(pCmdLine,_T("wmiadap.exe "));
	            _tcscat(pCmdLine,g_Strings[pPerfTask->CmdType]);
	            CMonitorEvents::CreateProcess_(pCmdLine,pMonitor,pPerfTask);
            }
            else
            {
#ifdef DEBUG_ADAP            
                DBG_PRINTFA((pBuff,"GetAvailable(RESYNC_TYPE_PENDING_TASKS) returned NULL\n"));
#endif
            }
        }
    }
    
    pPerf->hProcess = NULL;
    pMonitor->Lock();
    pPerf->bFree = TRUE;
    pMonitor->Unlock();

    UnregisterWaitEx(pPerf->hWaitHandle,NULL);
    pPerf->hWaitHandle = NULL;

}

VOID NTAPI
CMonitorEvents::TimerCallBack(VOID * pContext,BOOLEAN bTimerFired)
{
    if (!GLOB_Monitor_IsRegistred())
    {
        return;
    }

    if(bTimerFired)
    {
        ResyncPerfTask * pPerf = (ResyncPerfTask *)pContext;
        CMonitorEvents * pMonitor = pPerf->pMonitor;        
        BOOL bFreeSlot = FALSE;        

#ifdef DEBUG_ADAP
		DBG_PRINTFA((pBuff,"TIMER: Command Type %x\n",pPerf->Type));
#endif

        if (!pPerf->Enabled)
        {
#ifdef DEBUG_ADAP        
            DBG_PRINTFA((pBuff,"Task %d was disabled on the fly\n",pPerf->Type));
#endif
   		    bFreeSlot = TRUE;            
            goto unregister_timer;
        }

        BOOL bDoSomething = TRUE;
		BOOL RunDeltaLogic = TRUE;
		BOOL AddReverseAdapter = FALSE;
		BOOL WDMTriggeredReverseAdapter = FALSE;
		BOOL bDoFullSystemReverseHere = FALSE;

		if (RESYNC_TYPE_PENDING_TASKS == pPerf->Type)
		{
		    pMonitor->Lock();
		    // here disable tasks that are on the wait list
            for (DWORD i=0;i<RESYNC_TYPE_MAX;i++)
            {
                if (RESYNC_TYPE_PENDING_TASKS != i)
                {
                    if (pMonitor->m_ResyncTasks[i].hTimer)
                    {
#ifdef DEBUG_ADAP                    
                        DBG_PRINTFA((pBuff,"Disabling the pending task %d\n",i));
#endif
                        pMonitor->m_ResyncTasks[i].Enabled = FALSE;
                	}
                }
    	    }	    
		    pMonitor->Unlock();
		    // now check if the are processes running
   		    DoUnThrottleDredges();		    
		    if (pMonitor->m_OutStandingProcesses)
		    {
    		    pMonitor->m_bFullReverseNeeded = TRUE;
    		    // no need to CreateProcess, the last outstanding process will do that
#ifdef DEBUG_ADAP    		    
    		    DBG_PRINTFA((pBuff,"OutStandingProcess, no CreateProcessHere\n"));
#endif
    		    bFreeSlot = TRUE;
                goto unregister_timer;		    
		    }
		    else // no processes outstanding, create the process now
	    	{
	    	    bDoFullSystemReverseHere = TRUE;
#ifdef DEBUG_ADAP	    	    
	    	    DBG_PRINTFA((pBuff,"GOTO CreateProcess\n"));
#endif
 			    goto createprocess_label;
	    	}
		}

        if (RESYNC_TYPE_INITIAL == pPerf->Type )
        {
            // check if the Reverse Adapters need a Delta

		    LONG lRet;
		    HKEY hKey;
		    DWORD dwTemp;

		    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                WBEM_REG_REVERSE_KEY,
                                NULL,
                                KEY_READ|KEY_WRITE,
                                &hKey);
    
    
		    if (ERROR_SUCCESS == lRet)
    		{
	    	    DWORD dwType;
    	    	DWORD dwSize = sizeof(DWORD);
    	    	DWORD dwVal;
		        lRet = RegQueryValueEx(hKey,
        		                       WBEM_REG_REVERSE_VALUE,
                		               NULL,
                        		       &dwType,
                               		   (BYTE *)&dwVal,
                                       &dwSize);
                                       
                //    if the key is there, is NULL and it is of the right type
                // OR if the key is not there
                if( ERROR_SUCCESS == lRet &&
                    REG_DWORD == dwType &&
                    dwVal )
                {
                    AddReverseAdapter = TRUE;
#ifdef DEBUG_ADAP                    
                    DBG_PRINTFA((pBuff,"\"Performance Refresh\" key set to %d\n",dwVal));
#endif                    
                    DEBUGTRACE((LOG_WMIADAP,"\"Performance Refresh\" key set to %d\n",dwVal));
                }
                                       
                RegCloseKey(hKey);
            }

            // check the WDM stuff
            if (!AddReverseAdapter)
            {
#ifdef DBG
			    if (!HeapValidate(GetProcessHeap(),0,NULL))
			    {
			        DebugBreak();
			    }
			    if (!HeapValidate(CWin32DefaultArena::GetArenaHeap(),0,NULL))
			    {
			        DebugBreak();
			    }
#endif
            
                            CWMIBinMof BinMof;
				//=============================================================================
				// Note: this combo will always succeed, as all the initialize is doing is 
				// setting a flag to FALSE and returning S_OK
				//=============================================================================
				if( SUCCEEDED( BinMof.Initialize(NULL,FALSE) ) )
				{
					WDMTriggeredReverseAdapter = BinMof.BinaryMofsHaveChanged();
					if (WDMTriggeredReverseAdapter)
					{
						// override the previous decition
						AddReverseAdapter = TRUE; 
#ifdef DEBUG_ADAP						
						DBG_PRINTFA((pBuff,"BinaryMofs DO HAVE changed\n"));
#endif						
						DEBUGTRACE((LOG_WMIADAP,"CWMIBinMof.BinaryMofsHaveChanged == TRUE\n"));
					}

#ifdef DBG
				    if (!HeapValidate(GetProcessHeap(),0,NULL))
				    {
				        DebugBreak();
				    }
				    if (!HeapValidate(CWin32DefaultArena::GetArenaHeap(),0,NULL))
				    {
				        DebugBreak();
				    }				
#endif					
				}
            }
            
            // overrides delta with full, if the case
            if (WMIADAP_DEFAULT_TIMETOFULL == pMonitor->GetFullTime())
            {
                // no override
            }
            else  // read timestamp and decide
            {
                ULARGE_INTEGER li;
                li.LowPart = pMonitor->GetTimeStamp().dwLowDateTime;
                li.HighPart = pMonitor->GetTimeStamp().dwHighDateTime;
                __int64 Seconds = pMonitor->GetFullTime();
                Seconds *= 10000000; // number of 100ns units in 1 second

                ULARGE_INTEGER liNow;
                GetSystemTimeAsFileTime((FILETIME *)&liNow);
                
                if ((li.QuadPart + Seconds) < liNow.QuadPart)
                {
                    pPerf->CmdType = RESYNC_FULL_THROTTLE;
					RunDeltaLogic = FALSE;
                }
            }
        } // end if command type initial

        if ((RESYNC_TYPE_INITIAL == pPerf->Type) && RunDeltaLogic)
        {
             DWORD ret = DeltaDredge2(0,NULL);
             // DBG_PRINTFA((pBuff,"DeltaDredge ret %d\n",ret));
             switch(ret)
             {
             case FULL_DREDGE:
                 pPerf->CmdType = RESYNC_FULL_THROTTLE;
                 break;
             case PARTIAL_DREDGE:
                 pPerf->CmdType = RESYNC_DELTA_THROTTLE;
                 break;
             case NO_DREDGE:
                 //
                 // this is the case where we do nothing
                 ERRORTRACE((LOG_WINMGMT,"No Dredge to run\n"));
                 //
                 bDoSomething = FALSE;
                 break;
             default:
                 //
                 // never here
                 //
                 break;
             }

#ifdef DEBUG_ADAP
             DBG_PRINTFA((pBuff,"DeltaDredge() ret = %d, bDoSomething = %d \n",ret,bDoSomething));
#endif             
             DEBUGTRACE((LOG_WMIADAP,"DeltaDredge() ret = %d, bDoSomething = %d \n",ret,bDoSomething));
        }

        if (bDoSomething || AddReverseAdapter)
        {       
createprocess_label:        
    	    TCHAR pCmdLine[64];
	        _tcscpy(pCmdLine,_T("wmiadap.exe "));
	   		    
		    if (bDoFullSystemReverseHere)
		    {
		        _tcscat(pCmdLine,g_Strings[pPerf->CmdType]);		    
		    }
		    else
		    {
			    if (bDoSomething && AddReverseAdapter)
			    {
			        _tcscat(pCmdLine,g_Strings[pPerf->CmdType]);
			        _tcscat(pCmdLine,_T(" /R"));		        
			    }
			    if (bDoSomething && !AddReverseAdapter)
			    {
			        _tcscat(pCmdLine,g_Strings[pPerf->CmdType]);
			    }
			    if (!bDoSomething && AddReverseAdapter)
			    {
			        _tcscat(pCmdLine,g_Strings[RESYNC_RADAPD_THROTTLE]);
			    }		    
		    }
            CMonitorEvents::CreateProcess_(pCmdLine,pMonitor,pPerf);

            if (GLOB_GetMonitor()->IsRegistred())
            {
                if (!bDoFullSystemReverseHere)
                {
                    InterlockedIncrement(&(GLOB_GetMonitor()->m_OutStandingProcesses));
#ifdef DEBUG_ADAP                    
                    DBG_PRINTFA((pBuff,"(+) Outstanding Tasks %d\n",GLOB_GetMonitor()->m_OutStandingProcesses));                
#endif
                }
                //ResetEvent(GLOB_GetMonitor()->GetTaskCompleteEvent());
            }

            
        }
        else
        {
            pMonitor->Lock();
            pPerf->bFree = TRUE;
            pMonitor->Unlock();
        }

unregister_timer:
	    if (bFreeSlot)
	    {
            pMonitor->Lock();
            pPerf->bFree = TRUE;
            pMonitor->Unlock();	    
	    }
        DeleteTimerQueueTimer(NULL,pPerf->hTimer,NULL);
        pPerf->hTimer = NULL;
        pPerf->Enabled = TRUE;
        
    }
    else
    {
        // never here
        DebugBreak();
    }
}

//
//
//
///////////////////////////////////////////////

DWORD ResyncPerf(DWORD dwReason)
{

    if(!GLOB_IsResyncAllowed())
    {
        ERRORTRACE((LOG_WINMGMT,"ResyncPerf disable g_fSetup or g_fDoResync\n"));
        return 0;
    }
    
    ResyncPerfTask * pPerfTask = GLOB_GetMonitor()->GetAvailable(dwReason);

    if (pPerfTask)
    {   
        // here you have the slot for execution
        // tell Reverse_Adapter that it's scheduled
        if (RESYNC_TYPE_WDMEVENT == dwReason ||  
            RESYNC_TYPE_CLASSCREATION == dwReason)
        {

		    LONG lRet;
		    HKEY hKey;
		    DWORD dwTemp;

		    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                WBEM_REG_REVERSE_KEY,
                                NULL,
                                KEY_READ|KEY_WRITE,
                                &hKey);
    
    
		    if (ERROR_SUCCESS == lRet)
    		{
	    	    DWORD dwType;
    	    	DWORD dwSize = sizeof(DWORD);
    	    	DWORD dwVal;
		        lRet = RegQueryValueEx(hKey,
        		                       WBEM_REG_REVERSE_VALUE,
                		               NULL,
                        		       &dwType,
                               		   (BYTE *)&dwVal,
                                       &dwSize);
                                       
                //    if the key is there, is NULL and it is of the right type
                // OR if the key is not there
                if((ERROR_SUCCESS == lRet &&
                    REG_DWORD == dwType &&
                    0 == dwVal) ||
                    (ERROR_FILE_NOT_FOUND == lRet))
                {
                    dwVal = 1;
                    RegSetValueEx(hKey,
                                  WBEM_REG_REVERSE_VALUE,
                                  0,
                                  REG_DWORD,
                                  (BYTE *)&dwVal,
                                  sizeof(DWORD));
                }
                                       
                RegCloseKey(hKey);
            }
        
        };
        
        if (CreateTimerQueueTimer(&pPerfTask->hTimer,
                                  NULL,
                                  CMonitorEvents::TimerCallBack,
                                  pPerfTask,
                                  pPerfTask->dwTimeDue,
                                  0,
                                  WT_EXECUTEONLYONCE|WT_EXECUTELONGFUNCTION))
        {            
            return 0;
        }
        else
        {
            // ERRORTRACE
            return GetLastError();
        }
    }
    else
    {
        // no slot availables
        return ERROR_BUSY;
    }
}

//
//  
//  This function is called by the Hook installed in wbemcore
//  that monitors class creation
//
///////////////////////////////////////////

DWORD __stdcall
DredgeRA(VOID * pReserved)
{
    //DBG_PRINTFA((pBuff,"Classes\n"));
    return ResyncPerf(RESYNC_TYPE_CLASSCREATION);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\winmgmt2\sched.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    SCHED.CPP

Abstract:

    Implements the CSched class which is a crude schedualer.

History:

--*/

#include "precomp.h"

#include <persistcfg.h>

#include "sched.h"

CSched::CSched()
{
    for(DWORD dwCnt = 0; dwCnt < EOL; dwCnt++)
        m_dwDue[dwCnt] = 0xffffffff;
}

void CSched::SetWorkItem(JobType jt, DWORD dwMsFromNow)
{
    m_dwDue[jt] = GetTickCount() + dwMsFromNow;
}

DWORD CSched::GetWaitPeriod()
{
    DWORD dwCurr = GetTickCount();
    DWORD dwRet = INFINITE;
    for(DWORD dwCnt = 0; dwCnt < EOL; dwCnt++)
    {
        if(m_dwDue[dwCnt] == 0xffffffff)
            continue;
        if(m_dwDue[dwCnt] < dwCurr)
            dwRet = 10;
        else
        {
            DWORD dwGap = m_dwDue[dwCnt] - dwCurr;
            if(dwGap < dwRet)
                dwRet = dwGap;
        }
    }
    return dwRet;
}

bool CSched::IsWorkItemDue(JobType jt)
{
    DWORD dwCurr = GetTickCount();
    if(m_dwDue[jt] == 0xffffffff)
        return FALSE;
    return (m_dwDue[jt] <= dwCurr);
}

void CSched::ClearWorkItem(JobType jt)
{
    m_dwDue[jt] = INFINITE;
}

void CSched::StartCoreIfEssNeeded()
{

    DWORD dwEssNeedsLoading = 0;
    DWORD dwBackupNeeded = 0;

    // Get the values from the configuration time

    CPersistentConfig per;
    per.GetPersistentCfgValue(PERSIST_CFGVAL_CORE_ESS_NEEDS_LOADING, dwEssNeedsLoading);
    per.GetPersistentCfgValue(PERSIST_CFGVAL_CORE_NEEDSBACKUPCHECK, dwBackupNeeded);

    if(dwEssNeedsLoading || dwBackupNeeded)
    {
        IWbemLevel1Login * pCore = NULL;
        
        SCODE sc = CoCreateInstance(CLSID_InProcWbemLevel1Login, 
                                    NULL, 
                                    CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
                                    IID_IUnknown, 
                                    (void**)&pCore);

        if(sc == S_OK)
        {
            IWbemServices * pServ = NULL;
            sc = pCore->NTLMLogin(L"Root", NULL, 0, NULL, &pServ);
            if(SUCCEEDED(sc))
                pServ->Release();

            pCore->Release();
        }
            
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\winmgmt2\strings.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    STRINGS.H

Abstract:

	resource IDs.

History:

	a-davj  04-Mar-97   Created.

--*/

#ifndef _provstub_H_
#define _provstub_H_

#define ID1		101
#define ID2		102
#define ID3		103
#define ID4		104
#define ID5		105
#define ID6		106
#define ID7		107
#define ID8		108
#define ID9		109
#define ID10	110

#define ID_ERROR_SHORT		200
#define ID_ERROR_LONG		201
#define ID_BACKUP_TITLE		202
#define ID_RESTORE_TITLE	203

#define ID_WINMGMT_DESCRIPTION 204
#define ID_WINMGMT_SERVICE     205

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\winmgmt2\winmgmt.h ===
#ifndef __WINMGT_H__
#define __WINMGT_H__

#include <cntserv.h>
#include <reg.h>
#include <stdio.h>

#include "resync2.h"
#include "writer.h"

#define SERVICE_NAME _T("winmgmt")

#define HOME_REG_PATH _T("Software\\Microsoft\\WBEM\\CIMOM")
#define INITIAL_BREAK _T("Break")

#define WBEM_REG_ADAP		   __TEXT("Software\\Microsoft\\WBEM\\CIMOM\\ADAP")
#define WBEM_REG_REVERSE_KEY   __TEXT("SOFTWARE\\Microsoft\\WBEM\\PROVIDERS\\Performance")
#define WBEM_REG_REVERSE_VALUE __TEXT("Performance Refresh")

#define WBEM_NORESYNCPERF	__TEXT("NoResyncPerf")
#define WBEM_NOSHELL		__TEXT("NoShell")
#define WBEM_WMISETUP		__TEXT("WMISetup")
#define WBEM_ADAPEXTDLL		__TEXT("ADAPExtDll")


#define DO_THROTTLE        __TEXT("ThrottleDrege")

//
// CHANGE CHANGE
//
#if 1
#define DBG_PRINTFA( a ) { char pBuff[128]; sprintf a ; OutputDebugStringA(pBuff); }
#else
#define DBG_PRINTFA( a )
#endif


//
// For Fast ShutDown
// 
///////////////////////////////////////

#define SERVICE_SHUTDOWN 0x80000000 

//  prototype for reg code

DWORD RegSetDWORD(HKEY hKey,
                    TCHAR * pName,
                    TCHAR * pValue,
                    DWORD dwValue);

DWORD RegGetDWORD(HKEY hKey,
                    TCHAR * pName,
                    TCHAR * pValue,
                    DWORD * pdwValue);

//
//
//  prototype for the wbemcore!ShutDown function
//
//////////////////////////////////

typedef HRESULT (STDAPICALLTYPE *pfnShutDown)(DWORD,DWORD);

//
// The DeltaDredge Function (implementing the Pre-Delta) will return
//
///////////////////////////////////

#define FULL_DREDGE    2
#define PARTIAL_DREDGE 1
#define NO_DREDGE      0

//
//
/////////////////////////////////////

#define   WMIADAP_DEFAULT_DELAY          240   // 4 minutes
#define   WMIADAP_DEFAULT_DELAY_LODCTR   60    // 1 minute

#define   WMIADAP_DEFAULT_TIMETOFULL     ((DWORD)-1)

#define ADAP_TIMESTAMP_FULL         _T("LastFullDredgeTimestamp")
#define ADAP_TIME_TO_FULL             _T("TimeToFullDredge")
#define ADAP_TIME_TO_KILL_ADAP   _T("TimeToTerminateAdap")

#ifdef COUNTER
//
//  Counter
//
//////////////////////////////////////

class StartStop {  
public:
	static LARGE_INTEGER g_liFreq;
	static char g_pBuff[256];
	LARGE_INTEGER liTimeStart;  
	LARGE_INTEGER liTimeStop; 
	char * m_pString;

	StartStop(char * pString):m_pString(pString)
	{
	    QueryPerformanceCounter(&liTimeStart); 
	};
	~StartStop()
	{
	    QueryPerformanceCounter(&liTimeStop);
	    //__int64 val = 1000000;
		wsprintfA(g_pBuff,"%I64u %I64u %I64u %s\n",
		                  (liTimeStop.QuadPart)/(g_liFreq.QuadPart),
		                  (liTimeStart.QuadPart)/(g_liFreq.QuadPart),
		                  (liTimeStop.QuadPart-liTimeStart.QuadPart)/(g_liFreq.QuadPart),
		                  m_pString); 
   		OutputDebugStringA(g_pBuff);
   		
	};                   
};
              
#endif     

#include <flexarry.h>

//
//  from the old winmgmt.exe
//

//
// _PROG_RESOURCES
//
// Holds various resource that need to be freed at the end of execution.
//
//////////////////////////////////////////////////////////////////

struct _PROG_RESOURCES
{
    HANDLE          m_hExclusive;
    HANDLE          m_hTerminateEvent;
    BOOL            m_bOleInitialized;

    IClassFactory*  m_pLoginFactory;
    IClassFactory*  m_pBackupFactory;
    DWORD           m_dwLoginClsFacReg;
    DWORD           m_dwBackupClsFacReg;

/*
    CFlexArray      m_TransportArray;
*/
    //-----------
    BOOL g_fSetup;
    BOOL g_fDoResync;

    HANDLE hMainMutex;
    BOOL   bShuttingDownWinMgmt;
    BOOL gbCoreLoaded;

	HANDLE ghCoreCanUnload;
	HANDLE ghProviderCanUnload;
	HANDLE ghCoreUnloaded;
	HANDLE ghCoreLoaded;
	HANDLE ghNeedRegistration;
	HANDLE ghRegistrationDone;
	HANDLE ghMofDirChange;
	HANDLE ghLoadCtrEvent;
	HANDLE ghUnloadCtrEvent;
	HANDLE ghHoldOffNewClients;

	TCHAR * szHotMofDirectory;

	CMonitorEvents m_Monitor;

	DWORD ServiceStatus;

	CWbemVssWriter* pWbemVssWriter;
	bool bWbemVssWriterSubscribed;	

//------------------------------

    void Init();
    BOOL Phase1Build();
    BOOL Phase2Build(HANDLE hTerminate);

    BOOL RegisterLogin();
    BOOL RevokeLogin();
    BOOL RegisterBackup();
    BOOL RevokeBackup();
    
    BOOL Phase1Delete(BOOL bIsSystemShutDown);
    BOOL Phase2Delete(BOOL bIsSystemShutdown);
    BOOL Phase3Delete();
    
};


extern struct _PROG_RESOURCES g_ProgRes;

extern HINSTANCE g_hInstance;

inline
BOOL GLOB_Monitor_IsRegistred()
{
    BOOL bRet;
    g_ProgRes.m_Monitor.Lock();
    bRet = g_ProgRes.m_Monitor.IsRegistred();
    g_ProgRes.m_Monitor.Unlock();    
    return bRet;
};

inline 
CMonitorEvents * GLOB_GetMonitor()
{
    return &g_ProgRes.m_Monitor;
}

//
// Adap might be disallowed because of Setup running
// or because of a registry setting
//
/////////////////////////////////////////////////////
inline 
BOOL GLOB_IsResyncAllowed()
{
    return (g_ProgRes.g_fDoResync && !g_ProgRes.g_fSetup);
}


//
//
//  functions exported from mofdutil.cpp
//
//////////////////////////////////////////////////////////////////

BOOL
AddAccountToDacl(HANDLE hToken,
                 BYTE SubCount,
                 DWORD dw0,
                 DWORD dw1,
                 DWORD dw2,
                 DWORD dw3,
                 DWORD dw4,
                 DWORD dw5,
                 DWORD dw6,
                 DWORD dw7,
                 DWORD Access,
                 DWORD AceFlag);
BOOL SetEventDacl(HANDLE hEvent,DWORD Permission = GENERIC_ALL);

BOOL InitHotMofStuff( IN OUT struct _PROG_RESOURCES * pProgRes);
void LoadMofsInDirectory(const TCHAR *szDirectory);

BOOL CheckSetupSwitch( void );
void SetNoShellADAPSwitch( void );
BOOL CheckNoResyncSwitch( void );

void AddToAutoRecoverList(TCHAR * pFileName);
BOOL IsValidMulti(TCHAR * pMultStr, DWORD dwSize);
BOOL IsStringPresent(TCHAR * pTest, TCHAR * pMultStr);

//
//
// yet an other class factory
//
///////////////////////////////////////////////////////////////////

class CForwardFactory : public IClassFactory
{
protected:
    long m_lRef;
    CLSID m_ForwardClsid;

public:
    CForwardFactory(REFCLSID rForwardClsid) 
        : m_lRef(0), m_ForwardClsid(rForwardClsid)
    {}
    ~CForwardFactory();

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);
    HRESULT STDMETHODCALLTYPE CreateInstance(IUnknown* pUnkOuter, 
                                REFIID riid, void** ppv);
    HRESULT STDMETHODCALLTYPE LockServer(BOOL fLock);
};

//
//
// MyService 
//
//
//////////////////////////////////////////////////////////////////

class MyService : public CNtService
{
public:
    MyService(DWORD CtrlAccepted);
    ~MyService();
    
    // CNtService interface
    DWORD WorkerThread();
    void Stop(BOOL bSystemShutDownCalled);
    void Log(LPCSTR lpszMsg);

    VOID Pause();
    VOID Continue();

    //
    VOID FinalCleanup();
private:

    HANDLE m_hStopEvent;
};

//
//
//  yet another smart mutex
//
//
//////////////////////////////////////////////////////////////////

class CInMutex
{
protected:
    HANDLE m_hMutex;
    WCHAR * m_pString;
public:
    CInMutex(HANDLE hMutex) : m_hMutex(hMutex)
    {
        if(m_hMutex)
			WaitForSingleObject(m_hMutex, INFINITE);
    }
    ~CInMutex()
    {
		if(m_hMutex)
			ReleaseMutex(m_hMutex);
    }
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\winmgmt2\wbemdelta.cpp ===
#include "precomp.h"
#include "arrtempl.h" // for CDeleteMe
#include "md5wbem.h"  // for MD5

#include "winmgmt.h"
#include "wbemdelta.h"

#include <tchar.h>
#include <vector>
#include <map>

CPerfLib::CPerfLib(TCHAR * SvcName):
    m_wstrServiceName(NULL),
    m_wstrFull(NULL),
    m_hKey(NULL),
    m_bOK(FALSE),
    m_pwcsLibrary(NULL),
    m_pwcsOpenProc(NULL),
    m_pwcsCollectProc(NULL),
    m_pwcsCloseProc(NULL)
{
    
    if (SvcName)
    {
        DWORD dwLen = _tcslen(SvcName);
        DWORD dwLenPrefix = _tcslen(_T("SYSTEM\\CurrentControlSet\\Services\\"));
        TCHAR * pStart = SvcName+dwLenPrefix;
        TCHAR * pNameEnd = _tcschr(pStart,_T('\\'));
        if (pNameEnd)
        {
	        ULONG_PTR NameLength = (ULONG_PTR)pNameEnd-(ULONG_PTR)pStart;
	        NameLength/=sizeof(TCHAR);
	        m_wstrServiceName = new TCHAR[NameLength+1];
	        if (!m_wstrServiceName)
	        {
	            return; // OUT_OF_MEMORY
	        }
	        m_wstrServiceName[NameLength]=0;
	        memcpy(m_wstrServiceName,pStart,NameLength*sizeof(TCHAR));

	        m_wstrFull = new TCHAR[dwLen+1];
	        if (m_wstrFull)
		    {
			   	lstrcpy(m_wstrFull, SvcName);
			   	
	            m_hKey = NULL;
	            
				if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
	            			                      m_wstrFull,
	                                   			  NULL,
				                                  KEY_READ,
	            			                      &m_hKey))
	            {
	                m_pwcsLibrary = NULL; 
	                m_pwcsOpenProc = NULL;
	                m_pwcsCollectProc = NULL;
	                m_pwcsCloseProc = NULL;
	                m_bOK = TRUE;
	            }
		    }
	    }
    }
}

CPerfLib::~CPerfLib()
{
    if (m_wstrServiceName)
        delete [] m_wstrServiceName;
    if (m_wstrFull)
        delete [] m_wstrFull;
    if (m_pwcsLibrary)
        delete [] m_pwcsLibrary; 
    if (m_pwcsOpenProc)
        delete [] m_pwcsOpenProc;     // not needed as a member
    if (m_pwcsCollectProc)
        delete [] m_pwcsCollectProc;  // not needed as a member
    if (m_pwcsCloseProc)
        delete [] m_pwcsCloseProc;    // not needed as a member

    if (m_hKey)
        RegCloseKey(m_hKey);
}

HRESULT CPerfLib::GetFileSignature( CheckLibStruct * pCheckLib )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (!pCheckLib){
        return WBEM_E_INVALID_PARAMETER;
    }

    // Get the current library's file time
    // ===================================

    HANDLE hFile = NULL;

    DWORD   dwRet = 0;
    WCHAR   wszFullPath[MAX_PATH];
    WCHAR*  pwcsTemp = NULL;

    if ( 0 != SearchPathW( NULL, m_pwcsLibrary, NULL, MAX_PATH, wszFullPath, &pwcsTemp ) )
    {
        hFile = CreateFileW( wszFullPath, GENERIC_READ,FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );

        if ( INVALID_HANDLE_VALUE != hFile )
        {
			DWORD	dwFileSizeLow = 0;
			DWORD	dwFileSizeHigh = 0;
			__int32	nFileSize = 0;
			DWORD	dwNumRead = 0;
			BYTE*	aBuffer = NULL;

			dwFileSizeLow = GetFileSize( hFile, &dwFileSizeHigh );
			nFileSize = ( dwFileSizeHigh << 32 ) + dwFileSizeLow;

			FILETIME ft;
			if (GetFileTime(hFile,&ft,NULL,NULL))
			{
				
				HANDLE hFileMap = NULL;
				hFileMap = CreateFileMapping(hFile,NULL,PAGE_READONLY,dwFileSizeHigh,dwFileSizeLow,NULL);
				if (hFileMap)
				{
                    			aBuffer = (BYTE *)MapViewOfFile(hFileMap,
                                                    FILE_MAP_READ,
                                                    0,0,0);
					if (aBuffer)
					{
                                          // 
						// do the real work
						//
						MD5	md5;
						BYTE aSignature[16];
						md5.Transform( aBuffer, nFileSize, aSignature );

						// return our data
						memcpy(pCheckLib->Signature,aSignature,sizeof(aSignature));
						pCheckLib->FileTime = ft;
						pCheckLib->FileSize = nFileSize;
						                        
						UnmapViewOfFile(aBuffer);
					}
					else
					{
						hr = WBEM_E_OUT_OF_MEMORY;
					}
					CloseHandle(hFileMap);
				}
				else
				{
					hr = WBEM_E_OUT_OF_MEMORY;
				}
				
                /*
				aBuffer = new BYTE[nFileSize];
				CDeleteMe<BYTE> dmBuffer( aBuffer );

				if ( NULL != aBuffer )
				{
					if ( ReadFile( hFile, aBuffer, nFileSize, &dwNumRead, FALSE ) )
					{
						MD5	md5;
						BYTE aSignature[16];
						md5.Transform( aBuffer, dwNumRead, aSignature );

						// return our data
						memcpy(pCheckLib->Signature,aSignature,sizeof(aSignature));
						pCheckLib->FileTime = ft;
						pCheckLib->FileSize = nFileSize;
					}
					else
					{
						hr = WBEM_E_TOO_MUCH_DATA;
					}
				}
				else
				{
					hr = WBEM_E_OUT_OF_MEMORY;
				}			
				*/
			} 
			else 
			{
			    hr = WBEM_E_FAILED;
			}
			
			CloseHandle( hFile );
        }
        else
        {
            hr = WBEM_E_FAILED;
        }		
    }
    else
    {
        hr = WBEM_E_NOT_FOUND;
    }

    return hr;
}


LONG
GetBinary(HKEY hKey, TCHAR * Value, BYTE ** ppBuff, DWORD * pdwSize)
{
    LONG  lRet;
    DWORD dwType;
    DWORD dwSize = 0;

    // null Value is allowed
    if (!ppBuff || !pdwSize)
        return ERROR_INVALID_PARAMETER;

    lRet = RegQueryValueEx(hKey,
                           Value,
                           NULL,
                           &dwType,
                           NULL,
                           &dwSize);
                           
    if ((ERROR_SUCCESS == lRet) &&
        (REG_BINARY == dwType))
    {
        *pdwSize = dwSize;
        
        if (dwSize > 0)
        {
            *ppBuff = new BYTE[dwSize];            
            if (*ppBuff){
            
                lRet = RegQueryValueEx(hKey,
                                       Value,
                                       NULL,
                                       &dwType,
                                       (BYTE *)(*ppBuff),
                                       &dwSize);            
            } else {            
                lRet = ERROR_OUTOFMEMORY;
            }
        }
    }
    else
    {
        lRet = ERROR_INVALID_PARAMETER;
    }

    return lRet;
}

LONG
GetDWORD(HKEY hKey, TCHAR * Value ,DWORD * pDword)
{
    LONG  lRet;
    DWORD dwType = 0;
    DWORD dwSize = sizeof(DWORD);

    if (!pDword)
        return ERROR_INVALID_PARAMETER;

    lRet = RegQueryValueEx(hKey,
                           Value,
                           NULL,
                           &dwType,
                           (BYTE *)pDword,
                           &dwSize);
    if ((REG_DWORD == dwType) &&
        (ERROR_SUCCESS == lRet))
        return lRet;
    else
        return ERROR_INVALID_PARAMETER;
}

LONG
GetStr(HKEY hKey, TCHAR * Value ,TCHAR ** ppStr)
{
    LONG  lRet;
    DWORD dwType;
    DWORD dwSize = 0;

    if (!ppStr)
        return ERROR_INVALID_PARAMETER;

    lRet = RegQueryValueEx(hKey,
                           Value,
                           NULL,
                           &dwType,
                           NULL,
                           &dwSize);
    if ((ERROR_SUCCESS == lRet) &&
        ((REG_SZ == dwType) || (REG_EXPAND_SZ == dwType)))
    {
        if (dwSize > 0)
        {
            TCHAR * pString = new TCHAR[dwSize];
            if (pString)
            {
                lRet = RegQueryValueEx(hKey,
                                       Value,
                                       NULL,
                                       &dwType,
                                       (BYTE *)(pString),
                                       &dwSize);
                if (ERROR_SUCCESS == lRet)
                {
                    if (REG_EXPAND_SZ == dwType)
                    {
                        TCHAR * pExpanded = new TCHAR[dwSize + MAX_PATH];
                        if (pExpanded)
                        {
                            if(ExpandEnvironmentStrings(pString,pExpanded,(dwSize + MAX_PATH)))
                            {
                                *ppStr = pExpanded;
                                delete [] pString;
                                
                            }
                            else
                            {
	                            delete [] pString;
    	                        lRet = ERROR_OUTOFMEMORY;                            
                            }
                        }
                        else
                        {
                            delete [] pString;
                            lRet = ERROR_OUTOFMEMORY;
                        }
                    }
                    else
                    {
                        *ppStr = pString;
                    }
                }
                else
                {
                    goto empty_string;
                }
            }
            else
            {
                lRet = ERROR_OUTOFMEMORY;
            }
        }
        else // empty string
        {
empty_string:        
            *ppStr = new TCHAR[sizeof(_T(""))];
            if (*ppStr) {
                lstrcpy(*ppStr,_T(""));
            } else {
                lRet = ERROR_OUTOFMEMORY;
            }
        }
    }
    else
    {
        lRet = ERROR_INVALID_PARAMETER;
    }

    return lRet;
}



int CPerfLib::CheckFileSignature(HKEY hKey)
{
    int hr = Perf_SeemsNew;

    int         nRet = 0;
	BYTE	cCurrentMD5[16];
	BYTE*	cStoredMD5 = NULL;


        // Get the stored file signature
        // =============================
        CheckLibStruct StoredLibStruct;
        int nRet1;
        int nRet2;
        int nRet3;
        DWORD dwSize;

        nRet1 = GetBinary( hKey, ADAP_PERFLIB_SIGNATURE, (PBYTE*)&cStoredMD5, &dwSize );
		CDeleteMe<BYTE>	dmStoredMD5( cStoredMD5 );
		
		if (cStoredMD5 && (dwSize == sizeof(StoredLibStruct.Signature)))
		{
		    memcpy(&StoredLibStruct.Signature,cStoredMD5,sizeof(StoredLibStruct.Signature));

		    BYTE * pFileTime = NULL;
			nRet2 = GetBinary( hKey, ADAP_PERFLIB_TIME, (PBYTE*)&pFileTime, &dwSize );
	        CDeleteMe<BYTE>	dmFileTime( pFileTime );
	        
	        if (pFileTime)
	        {
	            memcpy(&StoredLibStruct.FileTime,pFileTime,sizeof(FILETIME));
	        }

	        nRet3 = GetDWORD(hKey, ADAP_PERFLIB_SIZE,&StoredLibStruct.FileSize);

	        if((ERROR_SUCCESS == nRet1) &&
	           (ERROR_SUCCESS == nRet2) &&
	    	   (ERROR_SUCCESS == nRet3)) 
			{
				// Get the current library's signature
				// ===================================
				CheckLibStruct CurrentLibStruct;
				memset(&CurrentLibStruct,0,sizeof(CheckLibStruct));
	        
				if (SUCCEEDED(GetFileSignature( &CurrentLibStruct )))
				{
					if ( (StoredLibStruct.FileSize == CurrentLibStruct.FileSize) &&
					     (0 == memcmp( &StoredLibStruct.Signature, &CurrentLibStruct.Signature, sizeof(CurrentLibStruct.Signature) )) &&
					     (0 == memcmp( &StoredLibStruct.FileTime, &CurrentLibStruct.FileTime, sizeof(FILETIME))) )
					{
						hr = Perf_NotChanged;
					}
					else
					{
					    hr = Perf_SeemsNew;
    		            //DBG_PRINTFA((pBuff,"no FileSize or Signature or FIleSuze\n")); 					    
					}
				}
				else
				{
				    hr = Perf_SeemsNew;        		    
	    		    //DBG_PRINTFA((pBuff,"no GetFileSignature\n")); 
				}
			}
			else
			{
			    hr = Perf_SeemsNew;
		        //DBG_PRINTFA((pBuff,"no triple regkey\n"));
			}

		} 
		else
		{
	        //DBG_PRINTFA((pBuff,"no ADAP_PERFLIB_SIGNATURE\n"));
		}

    return hr;
}


int
CPerfLib::VerifyLoaded()
{

    int hr = Perf_Invalid;
    LONG lRet;
                            
    {
        DWORD    dwFirstCtr = 0, 
                 dwLastCtr = 0;
        TCHAR *  wszObjList = NULL;

        if ( ( ERROR_SUCCESS == GetStr( GetHKey(), L"Object List", &wszObjList )) ||
             ( ( ERROR_SUCCESS == GetDWORD( GetHKey(), L"First Counter", &dwFirstCtr )) &&
               ( ERROR_SUCCESS == GetDWORD( GetHKey(), L"Last Counter", &dwLastCtr ))))
        {

            hr = InitializeEntryPoints(GetHKey());   

            if (wszObjList) 
            {
                delete [] wszObjList;
            }
              
        } else { // more special cases

            if (  (0 == _tcsicmp(m_wstrServiceName,_T("TCPIP"))) || 
                  (0 == _tcsicmp(m_wstrServiceName,_T("TAPISRV"))) || 
                  (0 == _tcsicmp(m_wstrServiceName,_T("PERFOS" ))) ||
                  (0 == _tcsicmp(m_wstrServiceName,_T("PERFPROC"))) ||
                  (0 == _tcsicmp(m_wstrServiceName,_T("PERFDISK"))) ||
                  (0 == _tcsicmp(m_wstrServiceName,_T("PERFNET"))) ||
                  (0 == _tcsicmp(m_wstrServiceName,_T("SPOOLER"))) ||
                  (0 == _tcsicmp(m_wstrServiceName,_T("MSFTPSvc"))) ||
                  (0 == _tcsicmp(m_wstrServiceName,_T("RemoteAccess"))) ||
                  (0 == _tcsicmp(m_wstrServiceName,_T("WINS"))) ||
                  (0 == _tcsicmp(m_wstrServiceName,_T("MacSrv"))) ||
                  (0 == _tcsicmp(m_wstrServiceName,_T("AppleTalk"))) ||
                  (0 == _tcsicmp(m_wstrServiceName,_T("NM"))) ||
                  (0 == _tcsicmp(m_wstrServiceName,_T("RSVP"))) )
            {
                  
                 hr = InitializeEntryPoints(GetHKey());     
             
            } 
        }        
    }

    return hr;
}

int
CPerfLib::InitializeEntryPoints(HKEY hKey)
{
    int hr = Perf_SeemsNew;

    // see if someone disabled this library
    DWORD dwDisable = 0;
    if ( ERROR_SUCCESS == GetDWORD( hKey, _T("Disable Performance Counters"), &dwDisable ) && 
         (dwDisable != 0) )
    {
        hr = Perf_Disabled;
    }

    if ((ERROR_SUCCESS == GetDWORD( hKey, _T("WbemAdapStatus"), &dwDisable))
        && (0xFFFFFFFF == dwDisable))
    {
        hr = Perf_Disabled;
    }
    
    // the perflib is OK for the world, see if it os OK for US
                
    if (SUCCEEDED(hr)){
            
        if (!(( ERROR_SUCCESS == GetStr( hKey, _T("Library"), &m_pwcsLibrary ) ) &&
              ( ERROR_SUCCESS == GetStr( hKey, _T("Open"), &m_pwcsOpenProc ) )&&
              ( ERROR_SUCCESS == GetStr( hKey, _T("Collect"), &m_pwcsCollectProc ) ) &&
              ( ERROR_SUCCESS == GetStr( hKey, _T("Close"), &m_pwcsCloseProc ) ) )) 
        {                       
            hr = Perf_Invalid;
        } 
        else 
        {
            hr = Perf_SetupOK;
        }                    
    }

    return hr;

}

int 
CPerfLib::VerifyLoadable()
{
    if (!m_bOK)
        return Perf_Invalid;
        
	int hr;

    hr = VerifyLoaded();

    if ( Perf_SetupOK == hr  )
    {
        hr = CheckFileSignature(GetHKey());
    }

	return hr;
}

TCHAR * g_ExcludeList[] = {
    _T("WMIAPRPL")
};

//
//
//  GetListofSvcs
//
////////////////////////////////////////////////////////////

HRESULT
GetListOfSvcs(LIST_ENTRY * pListServices)
{
    LONG lRet;
    HKEY hKey;
    HRESULT hRes = WBEM_NO_ERROR;

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        SVC_KEY,
                        0,KEY_READ,
                        &hKey);
                        
    if (ERROR_SUCCESS == lRet)
    {
        DWORD dwIndex = 0;
        TCHAR KeyName[MAX_PATH];
        TCHAR * pKeyName = KeyName;
        DWORD dwKeyNameSize = (sizeof(KeyName)/sizeof(TCHAR));
        FILETIME FileTime;

        while (ERROR_SUCCESS == lRet)
        {
            if (pKeyName != KeyName)
            {
                delete [] pKeyName;
                pKeyName = KeyName;
            }
            dwKeyNameSize = (sizeof(KeyName)/sizeof(TCHAR));
            lRet = RegEnumKeyEx(hKey,
                                dwIndex,
                                pKeyName,
                                &dwKeyNameSize,
                                NULL,NULL,NULL,
                                &FileTime);
                                
            if (ERROR_INSUFFICIENT_BUFFER == lRet) 
            {
                pKeyName = new TCHAR[dwKeyNameSize];

				if (pKeyName)
                {
					lRet = RegEnumKeyEx(hKey,
                      					dwIndex,
										pKeyName,
										&dwKeyNameSize,
										NULL,NULL,NULL,
										&FileTime);                
				}
				else
				{
					lRet = ERROR_OUTOFMEMORY;
				}
            }

            if (ERROR_SUCCESS == lRet)
            {
                dwIndex++;
                DWORD i;
                DWORD NumExcluded = sizeof(g_ExcludeList)/sizeof(TCHAR *);
                
                for (i=0; i<NumExcluded; i++)
                {
                    if (0 == _tcsicmp(g_ExcludeList[i],pKeyName)){
                        break;
                    }
                }

                // if we pass all the Excluded Array then we are OK to add
                if (i == NumExcluded)
                {
					DWORD dwSize = _tcslen(pKeyName);
					LinkString * pLinkString = (LinkString *)new BYTE[sizeof(LinkString) + dwSize*sizeof(TCHAR)];

					if (pLinkString)
					{
						pLinkString->Size = dwSize;
						_tcscpy(pLinkString->pString,pKeyName);
						InsertTailList(pListServices,&pLinkString->Entry);
					}
					else
					{
						lRet = ERROR_OUTOFMEMORY;
					}
                }
            }
            //
            // the lack of the else case here will prevent the loop 
            // from completing if only one key is BAD
            //
        }

        if (pKeyName != KeyName)
        {
            delete [] pKeyName;
            pKeyName = KeyName;
        }

        if (ERROR_NO_MORE_ITEMS != lRet)
        {
            hRes = WBEM_E_FAILED;
        }
        
        RegCloseKey(hKey);
    }
    else
    {
        hRes = WBEM_E_FAILED;
    }

    return hRes;
}

//
//
//    GetSvcWithPerf
//
///////////////////////////////////////////////////////////

#define FIXED_SIZE (sizeof(_T("System\\CurrentControlSet\\Services\\%s\\Performance")))

HRESULT
GetSvcWithPerf(/*IN OUT*/ LIST_ENTRY * pListHead)
{
    TCHAR KeyPath[MAX_PATH+1];
    TCHAR * pKeyPath = KeyPath;
	LIST_ENTRY LocalListHead;
    InitializeListHead(&LocalListHead);
    // now change the head to the list
	// assume the list is NOT EMPTY
	LIST_ENTRY * pEntry = pListHead->Flink; // point to the first item
	RemoveEntryList(pListHead);             // remove the head
	InitializeListHead(pListHead);          // clear the head
	InsertTailList(pEntry,&LocalListHead);  // put in the same place the New Local head

    HRESULT hRes = WBEM_NO_ERROR;
    DWORD i;

    for (pEntry = LocalListHead.Flink;
	     pEntry != &LocalListHead;
		 pEntry = pEntry->Flink)
    {
	    LinkString * pLinkString = (LinkString *) pEntry;

	    if ((FIXED_SIZE + pLinkString->Size) < MAX_PATH )
		{
            _stprintf(KeyPath,_T("System\\CurrentControlSet\\Services\\%s\\Performance"),pLinkString->pString);
		}
		else
		{
		    if (pKeyPath != KeyPath && pKeyPath)
		    {
		        delete [] pKeyPath;
		    }
			pKeyPath = new TCHAR[1 + FIXED_SIZE + pLinkString->Size];
			if (pKeyPath)
			{
			    _stprintf(pKeyPath,_T("System\\CurrentControlSet\\Services\\%s\\Performance"),pLinkString->pString);
			}
			else
			{
     			hRes = WBEM_E_OUT_OF_MEMORY;
			    break;
			}
		}
        LONG lRes;
        HKEY hKey;

        lRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            pKeyPath,
                            NULL,KEY_READ,
                            &hKey);
        if (ERROR_SUCCESS == lRes)
        {
            DWORD nSize = _tcslen(pKeyPath);
			LinkString * pLinkString2 = (LinkString *)new BYTE[sizeof(LinkString) + nSize*sizeof(TCHAR)];
			if (pLinkString2)
			{
				pLinkString2->Size = nSize;
				_tcscpy(pLinkString2->pString,pKeyPath);
				InsertTailList(pListHead,&pLinkString2->Entry);
			}
			else
			{
				lRes = ERROR_OUTOFMEMORY;
			}
            RegCloseKey(hKey);
        }        
    }

    for (pEntry = LocalListHead.Flink;
	     pEntry != &LocalListHead;
		 pEntry = pEntry->Flink)
    {
		BYTE * pByte = (BYTE *)pEntry;		
		RemoveEntryList(pEntry);
		pEntry = pEntry->Flink;
		delete [] pByte;
	};

    if (pKeyPath != KeyPath)
    {
        delete [] pKeyPath;
    }
    
    return hRes;
}




//
//
//   Known Service implementation
//
///////////////////////////////////////////////////////////


bool
WCmp::operator()(WString pFirst,WString pSec) const
{
    if (!pFirst || !pSec)
        return false;
        
	int res = _wcsicmp(pFirst,pSec);

	return (res<0);
}



CSvcs::CSvcs():
    m_cRef(1)
{
}

CSvcs::~CSvcs()
{
}

DWORD 
CSvcs::Add(WCHAR * pService)
{
    if (pService)
    {
        try 
        {
	        MapSvc::iterator it = m_SetServices.find(pService);
	        
	        if (it == m_SetServices.end()) // not in the std::map
	        {
	            m_SetServices[pService] = true; // add to the map
	        }
	        return 0;
        } 
        catch (CX_MemoryException) 
        {
            return ERROR_OUTOFMEMORY;
        }
    }
    else
        return ERROR_INVALID_PARAMETER;
}

BOOL 
CSvcs::Find(WCHAR * pService)
{
    if (pService)
    {
        MapSvc::iterator it = m_SetServices.find(pService);
        if (it != m_SetServices.end())
        {
            return TRUE;
        }
    }

    return FALSE;
}

DWORD 
CSvcs::Load()
{
    // get the MULTI_SZ key
    LONG lRet;
    HKEY hKey;
    
    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        WBEM_REG_WINMGMT,
                        NULL,
                        KEY_READ,
                        &hKey);
                        
    if (ERROR_SUCCESS == lRet)
    {
        DWORD dwSize = 0;
        DWORD dwType = REG_MULTI_SZ;

        lRet = RegQueryValueEx(hKey,
                               KNOWN_SERVICES,
                               NULL,
                               &dwType,
                               NULL,
                               &dwSize);
                               
        if (ERROR_SUCCESS == lRet && (dwSize > 0))
        {
            TCHAR * pStr = new TCHAR[dwSize];
            
			if (pStr)
			{
				CDeleteMe<TCHAR> cdm(pStr);

				lRet = RegQueryValueEx(hKey,
								   KNOWN_SERVICES,
								   NULL,
								   &dwType,
								   (BYTE *)pStr,
								   &dwSize);
				if ((ERROR_SUCCESS == lRet) &&
					(REG_MULTI_SZ == dwType))
				{
					DWORD dwLen = 0;
					while(dwLen = lstrlen(pStr))
					{
						try 
						{
							m_SetServices[pStr] = true;
						} 
						catch (CX_MemoryException) 
						{
							lRet = ERROR_OUTOFMEMORY;
							break;
						}
						pStr += (dwLen+1);
					}
				}
			}
			else
			{
				lRet = ERROR_OUTOFMEMORY;
			}
        }

        RegCloseKey(hKey);
    }

    return lRet;
}

// already in winmgmt.h
/*
#define FULL_DREDGE    2
#define PARTIAL_DREDGE 1
#define NO_DREDGE      0
*/

//
//
//  DeltaDredge
//
//  both params are unused
//  operation
//  reads a registry key containing the known Services
//  enumerates the registry keys, and figure-out which ones
//  are the one with "performance" subkey
//
///////////////////////////////////////////////////////////

DWORD WINAPI
DeltaDredge(DWORD dwNumServicesArgs,
             LPWSTR *lpServiceArgVectors)
{
    
    DWORD bDredge = NO_DREDGE;

    CSvcs KnownSvc;

    if (ERROR_SUCCESS == KnownSvc.Load())
    {        
        LIST_ENTRY ListServices;
		InitializeListHead(&ListServices);
        HRESULT hRes;

        hRes = GetListOfSvcs(&ListServices);

        if (SUCCEEDED(hRes))
        {
            hRes = GetSvcWithPerf(&ListServices);

            if (SUCCEEDED(hRes))
            {
                DWORD Status = 0;
				try 
				{

					CSvcs OKServices; // this constructor throws
                                
					LIST_ENTRY * pListEntry;
					DWORD i=0;
					for (pListEntry = ListServices.Flink;
						 pListEntry != &ListServices;
						 pListEntry = pListEntry->Flink)
					{
						LinkString * pLString = (LinkString *)pListEntry;
						CPerfLib PerfLib(pLString->pString);

						if (!PerfLib.IsOK())
						{
							continue;
						}
                    
						int PerfStatus = PerfLib.VerifyLoadable();

#ifdef DEBUG_ADAP
						DBG_PRINTFA((pBuff,"%d Service %S status %d\n",i,pLString->pString,PerfStatus));
#endif                    
						switch (PerfStatus)
						{
						case CPerfLib::Perf_Invalid:
						case CPerfLib::Perf_Disabled:
							//
							// nothing to do with an invalid library
							// or with a disabled library
							//

#ifdef DEBUG_ADAP
                                                 DBG_PRINTFA((pBuff,"Invalid or Disabled Service %S\n",PerfLib.GetServiceName()));
#endif
                                                 DEBUGTRACE((LOG_WMIADAP,"Invalid registration or Disabled Service %S\n",PerfLib.GetServiceName()));
							break;
						case CPerfLib::Perf_NotChanged:
							//
							// this is what we want to hear
							//
							OKServices.Add(PerfLib.GetServiceName());
							break;
						case CPerfLib::Perf_SeemsNew:
							//
							// now we have to do a dredge
							//
#ifdef DEBUG_ADAP							
							DBG_PRINTFA((pBuff,"NewOrChanged Service %S\n",PerfLib.GetServiceName()));
#endif							
                                                 DEBUGTRACE((LOG_WMIADAP,"NewOrChanged Service %S\n",PerfLib.GetServiceName()));
							bDredge = PARTIAL_DREDGE;
							break;
						default:
							//
							//  never here
							//
							break;
						}
						i++;
					}

					if (NO_DREDGE == bDredge)
					{
						//
						// if here, someone might have changed the registry directly
						//
						if (OKServices.GetMap().size() != KnownSvc.GetMap().size())
						{
#ifdef DEBUG_ADAP						
							DBG_PRINTFA((pBuff,"Registry-listed Services and KnownSvcs are not of the same size\n"));
#endif							
							ERRORTRACE((LOG_WMIADAP,"Registry-listed Services and KnownSvcs are not of the same size\n"));
							bDredge = PARTIAL_DREDGE;
						}
						else // same size -> are they the same ?
						{
							MapSvc::iterator it1 = OKServices.GetMap().begin();
							MapSvc::iterator it2 = KnownSvc.GetMap().begin();
							
							while (it1 != OKServices.GetMap().end())
							{
#ifdef DEBUG_ADAP							
								DBG_PRINTFA((pBuff," %S =?= %S \n",(const WCHAR *)(*it1).first,(const WCHAR *)(*it2).first));
#endif								
								if (0 != _wcsicmp((*it1).first,(*it2).first))
								{
									bDredge = PARTIAL_DREDGE;
									break;
								}
								++it1;
								++it2;
							}
						}
					}

				}
				catch (CX_MemoryException & )
				{
					bDredge = PARTIAL_DREDGE;
				}
            }
        }

		LIST_ENTRY * pListEntry;
		for (pListEntry = ListServices.Flink;
		     pListEntry != &ListServices;
			 )
		{
			BYTE * pByte = (BYTE *)pListEntry;			 
            RemoveEntryList(pListEntry);
			pListEntry = pListEntry->Flink;			
			delete [] pByte;
		}
        
    }
    else
    {
        //
        //  There is no valid KNOWN_SERVICES key --- FULL Dredge
        //
        bDredge = FULL_DREDGE;
    }
    
    return bDredge;
}

DWORD WINAPI
DeltaDredge2(DWORD dwNumServicesArgs,
             LPWSTR *lpServiceArgVectors)
{
    
    DWORD bDredge = FULL_DREDGE;

    // check the MULTI_SZ key
    LONG lRet;
    HKEY hKey;
    
    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        WBEM_REG_WINMGMT,
                        NULL,
                        KEY_READ,
                        &hKey);
                        
    if (ERROR_SUCCESS == lRet)
    {
        DWORD dwSize = 0;
        DWORD dwType = REG_MULTI_SZ;

        lRet = RegQueryValueEx(hKey,
                               KNOWN_SERVICES,
                               NULL,
                               &dwType,
                               NULL,
                               &dwSize);
                               
        if (ERROR_SUCCESS == lRet && (dwSize > 2)) // empty MULTI_SZ is 2 bytes
        {
            bDredge = NO_DREDGE;
        }

        RegCloseKey(hKey);
    }

    return bDredge;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\winmgmt2\writer.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

	writer.h

Abstract:

	Volume SnapShot Writer for WMI

History:

	a-shawnb	06-Nov-00	Genesis

--*/

#ifndef _WBEM_WRITER_H_
#define _WBEM_WRITER_H_

#include "precomp.h"
#include "vss.h"
#include "vswriter.h"
#include <lockst.h>

class CWbemVssWriter : public CVssWriter
	{
public:
	CWbemVssWriter();
	~CWbemVssWriter();

	HRESULT Initialize();

	virtual bool STDMETHODCALLTYPE OnIdentify(IN IVssCreateWriterMetadata *pMetadata);

	virtual bool STDMETHODCALLTYPE OnPrepareSnapshot();

	virtual bool STDMETHODCALLTYPE OnFreeze();

	virtual bool STDMETHODCALLTYPE OnThaw();

	virtual bool STDMETHODCALLTYPE OnAbort();

private:
    IWbemBackupRestoreEx* m_pBackupRestore;
    CriticalSection m_Lock;
};
	
#endif // _WBEM_WRITER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\winmgmt2\wbemdelta.h ===
#ifndef __WBEMDELTA_H__
#define __WBEMDELTA_H__

#include "precomp.h"
#include <reg.h>
#include <stdio.h>
#include <map>
#include <wstring.h>
#include <wstlallc.h>

#define SERVICE_NAME _T("winmgmt")

#define SVC_KEY _T("System\\CurrentControlSet\\Services")

#define HOME_REG_PATH  _T("Software\\Microsoft\\WBEM\\CIMOM")
#define KNOWN_SERVICES _T("KnownSvcs")

#define INITIAL_BREAK _T("Break")

#define WBEM_REG_ADAP		__TEXT("Software\\Microsoft\\WBEM\\CIMOM\\ADAP")

#define WBEM_NORESYNCPERF	__TEXT("NoResyncPerf")
#define WBEM_NOSHELL		__TEXT("NoShell")
#define WBEM_WMISETUP		__TEXT("WMISetup")
#define WBEM_ADAPEXTDLL		__TEXT("ADAPExtDll")

typedef struct tagCheckLibStruct {
    BYTE Signature[16];
    FILETIME FileTime;
    DWORD FileSize;
} CheckLibStruct;

#define ADAP_PERFLIB_STATUS_KEY		L"WbemAdapStatus"
#define ADAP_PERFLIB_SIGNATURE		L"WbemAdapFileSignature"
#define ADAP_PERFLIB_SIZE           L"WbemAdapFileSize"
#define ADAP_PERFLIB_TIME           L"WbemAdapFileTime"

//
//
//  Linkable string
//
////////////////////////////////

struct LinkString {
	LIST_ENTRY Entry;
	DWORD      Size;
	TCHAR      pString[1]; // just a placeholder
};

//
// this is the version of the function with the actual delta dredge
// but in the current design the delta dredge is fooled by perflibs
// that returns errors from their open function
//
///////////////////////

DWORD WINAPI
DeltaDredge(DWORD dwNumServicesArgs,
             LPWSTR *lpServiceArgVectors);

//
// this is the version of the function without the actual delta dredge
//
///////////////////////

DWORD WINAPI
DeltaDredge2(DWORD dwNumServicesArgs,
             LPWSTR *lpServiceArgVectors);

//
//
//  a class that wraps what we want to know about a perflib
//
/////////////////////////////////////////////////////////////////

class CPerfLib {
private:
    TCHAR * m_wstrServiceName;
    TCHAR * m_wstrFull;
    HKEY    m_hKey;
    BOOL    m_bOK;
    TCHAR * m_pwcsLibrary; 
    TCHAR * m_pwcsOpenProc;
    TCHAR * m_pwcsCollectProc;
    TCHAR * m_pwcsCloseProc;

public:
    enum {
        Perf_Invalid,
        Perf_Disabled,
        Perf_SetupOK,
        Perf_Changed,
        Perf_SeemsNew,
        Perf_NotChanged,
    };

    CPerfLib(TCHAR * SvcName);
    ~CPerfLib();
    HRESULT GetFileSignature( CheckLibStruct * pCheckLib );
    int CheckFileSignature(HKEY hKey);
    int VerifyLoaded();
    int VerifyLoadable();
    int CPerfLib::InitializeEntryPoints(HKEY hKey);
    HKEY GetHKey(){ return m_hKey; };
    TCHAR * GetServiceName(){ return m_wstrServiceName; };
    BOOL IsOK(){ return m_bOK; };
};


//
//
//  a Wrapper class for the std::map
//
/////////////////////////////////////////////////////////////

class BoolAlloc : public wbem_allocator<bool>
{
};

class WCmp{
public:
	bool operator()(WString pFirst,WString pSec) const;
};

typedef std::map<WString,bool,WCmp,BoolAlloc> MapSvc;

class CSvcs
{
public:
    CSvcs();
    ~CSvcs();
    DWORD Load();

    DWORD Add(WCHAR * pService);
    
    LONG AddRef(){
        return InterlockedIncrement(&m_cRef);
    };
    LONG Release(){
        LONG lRet = InterlockedDecrement(&m_cRef);
        if (0 == lRet){
            delete this;
        }
        return lRet;
    };

    BOOL Find(WCHAR * pStr);
    
    MapSvc& GetMap() { return m_SetServices; };
private:
    LONG m_cRef;
    MapSvc m_SetServices; 
};



#ifdef COUNTER
//
//  Counter
//
//////////////////////////////////////

class StartStop {  
public:
	static LARGE_INTEGER g_liFreq;
	static char g_pBuff[256];
	LARGE_INTEGER liTimeStart;  
	LARGE_INTEGER liTimeStop; 
	char * m_pString;

	StartStop(char * pString):m_pString(pString)
	{
	    QueryPerformanceCounter(&liTimeStart); 
	};
	~StartStop()
	{
	    QueryPerformanceCounter(&liTimeStop);
		wsprintfA(g_pBuff,"%I64u %I64u %I64u %s\n",
		                  (liTimeStop.QuadPart)/(g_liFreq.QuadPart),
		                  (liTimeStart.QuadPart)/(g_liFreq.QuadPart),
		                  (liTimeStop.QuadPart-liTimeStart.QuadPart)/(g_liFreq.QuadPart),
		                  m_pString); 
   		OutputDebugStringA(g_pBuff);
   		
	};                   
};
              
#endif     

#endif /*__WBEMDELTA_H__*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\winmgmt2\winmgmt.cpp ===
#include "precomp.h"

#include <winsvc.h>
#include <tchar.h>
#include <persistcfg.h>
#include <winntsec.h>

#include "cntserv.h"
#include "winmgmt.h"
#include "sched.h"
#include "resync2.h"
#include <malloc.h>

//***********************************************************************
//
//  Defines
//
//***********************************************************************

#define CORE_PROVIDER_UNLOAD_TIMEOUT ( 30 * 1000 )

//***********************************************************************
//
//  Globals
//
//***********************************************************************

HINSTANCE g_hInstance;

//***********************************************************************
//
//  Dll  Entry points and export points
//
//***********************************************************************


BOOL APIENTRY DllMain( HINSTANCE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    switch(ul_reason_for_call){
    case DLL_PROCESS_ATTACH:
        g_hInstance = hModule;
        DisableThreadLibraryCalls(hModule);
        break;
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
};

//
// 
//  InitialBreak
//
///////////////////////////////////////////////////////////

BOOL
InitialBreak()
{
    HKEY hKey;
    LONG lRet;
    BOOL bRet = FALSE;

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        HOME_REG_PATH,
                        0,
                        KEY_READ,
                        &hKey);
    if (ERROR_SUCCESS == lRet)
    {
        DWORD dwType;
        DWORD dwVal;
        DWORD dwSize = sizeof(DWORD);
        
        lRet = RegQueryValueEx(hKey,
                               INITIAL_BREAK,
                               NULL,
                               &dwType,
                               (BYTE *)&dwVal,
                               &dwSize);
                               
        if (ERROR_SUCCESS == lRet &&
            dwType == REG_DWORD &&
            dwVal)
        {
             bRet = TRUE;
        }
        
        RegCloseKey(hKey);
    }
    return bRet;
}

//
//  the global structure
//
struct _PROG_RESOURCES g_ProgRes;

void
_PROG_RESOURCES::Init()
{

    m_hExclusive = NULL;
    m_hTerminateEvent = NULL;
    m_bOleInitialized = NULL;

    m_pLoginFactory = NULL;
    m_pBackupFactory = NULL;
    
    m_dwLoginClsFacReg = 0;
    m_dwBackupClsFacReg = 0;

    g_fSetup = FALSE;
    g_fDoResync = TRUE;
    
    hMainMutex = NULL;
    bShuttingDownWinMgmt = FALSE;
    gbCoreLoaded = FALSE;

    ServiceStatus = SERVICE_STOPPED;

	ghCoreCanUnload = NULL;
	ghProviderCanUnload = NULL;
	ghCoreUnloaded = NULL;
	ghCoreLoaded = NULL;	
	ghNeedRegistration = NULL;
	ghRegistrationDone = NULL;
	ghMofDirChange = NULL;
	ghLoadCtrEvent = NULL;
	ghUnloadCtrEvent = NULL;
	ghHoldOffNewClients = NULL;

	szHotMofDirectory = NULL;
		
	pWbemVssWriter = NULL;
	bWbemVssWriterSubscribed = false;
};

BOOL 
_PROG_RESOURCES::Phase1Build()
{
    hMainMutex = CreateMutex(NULL, FALSE, NULL);

    g_fSetup = CheckSetupSwitch();

    if ( g_fSetup )
    {
        SetNoShellADAPSwitch();
    }

    // Look in the registry to decide if we will launch a resync perf or not
    g_fDoResync = CheckNoResyncSwitch();

    //
    //  set this to have the Console Control Handler notification
    //
    SetProcessShutdownParameters(0x400,0);

    //
    // set to some defined value parames that might be outstanding if someone killed us
    //
    RegSetDWORD(HKEY_LOCAL_MACHINE,HOME_REG_PATH,DO_THROTTLE,1);    
    
    return hMainMutex?TRUE:FALSE;
};

BOOL 
_PROG_RESOURCES::Phase2Build(HANDLE hTerminateEvt)
{
    ghCoreCanUnload = CreateEvent(NULL,FALSE,FALSE,
            TEXT("WINMGMT_COREDLL_CANSHUTDOWN"));

    ghProviderCanUnload = CreateEvent(NULL,FALSE,FALSE,
            TEXT("WINMGMT_PROVIDER_CANSHUTDOWN"));
    SetEventDacl(ghProviderCanUnload,EVENT_ALL_ACCESS);

    ghCoreUnloaded = CreateEvent(NULL,FALSE,FALSE,
            TEXT("WINMGMT_COREDLL_UNLOADED"));

    ghCoreLoaded = CreateEvent(NULL,FALSE,FALSE,
            TEXT("WINMGMT_COREDLL_LOADED"));

    m_hTerminateEvent = CreateEvent(NULL,TRUE,FALSE,
        TEXT("WINMGMT_MARSHALLING_SERVER_TERMINATE"));
        
    if(m_hTerminateEvent == NULL)
    {
        TRACE((LOG_WINMGMT,"\nWINMGMT terminating because CreateEvent, last error = 0x%x\n",
                GetLastError()));
        return FALSE;
    }

    
    DWORD dwRet;
    m_hExclusive = CreateMutex( NULL, FALSE, TEXT("WINMGMT_MARSHALLING_SERVER"));
    if(m_hExclusive)
        dwRet = WaitForSingleObject(m_hExclusive, 0);
    if(m_hExclusive == NULL || dwRet != WAIT_OBJECT_0)
    {
        if(m_hExclusive)
            CloseHandle(m_hExclusive);
        m_hExclusive = NULL;
        TRACE((LOG_WINMGMT,"\nWINMGMT terminating an existing copy was detected"));
        return FALSE;
    }

    

    ghNeedRegistration = CreateEvent(NULL,TRUE,FALSE, __TEXT("WINMGMT_NEED_REGISTRATION"));
    SetObjectAccess2(ghNeedRegistration);
    ghRegistrationDone = CreateEvent(NULL,TRUE,FALSE, __TEXT("WINMGMT_REGISTRATION_DONE"));
    SetObjectAccess2(ghRegistrationDone);

    ghHoldOffNewClients = CreateMutex(NULL, FALSE, __TEXT("WINMGMT_KEEP_NEW_CLIENTS_AT_BAY")); 
    if(ghHoldOffNewClients == NULL)
        ghHoldOffNewClients = OpenMutex(SYNCHRONIZE, FALSE, __TEXT("WINMGMT_KEEP_NEW_CLIENTS_AT_BAY")); 

    if(ghNeedRegistration == NULL || ghRegistrationDone == NULL || 
       ghHoldOffNewClients == NULL)
    {
        TRACE((LOG_WINMGMT,"\nWINMGMT couldnt create the sync objects"));
        return FALSE;
    }
    
    if (!m_Monitor.Init())
    {
        return FALSE;
    }

	// don't create a writer if during setup
	if (!g_fSetup)
	{
		pWbemVssWriter = new CWbemVssWriter;
		if (!pWbemVssWriter)
		{
			TRACE((LOG_WINMGMT,"\nWINMGMT could not create the VssWriter"));
			return FALSE;
		}
	}

    return TRUE;
}

BOOL
_PROG_RESOURCES::RegisterLogin()
{
    HRESULT sc;
    DWORD dwFlags = CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER;

    g_ProgRes.m_pLoginFactory = new CForwardFactory(CLSID_InProcWbemLevel1Login);
    g_ProgRes.m_pLoginFactory->AddRef();
    
    sc = CoRegisterClassObject(CLSID_WbemLevel1Login, 
                               g_ProgRes.m_pLoginFactory,
                               dwFlags,
                               REGCLS_MULTIPLEUSE, 
                               &g_ProgRes.m_dwLoginClsFacReg);
    if(sc != S_OK)
    {
        TRACE((LOG_WINMGMT,"\nFailed to register the "
                            "CLSID_WbemLevel1Login class factory, "
                            "sc = 0x%x", sc));
        return FALSE;
    }
    else
    {
        DEBUGTRACE((LOG_WINMGMT, "\nRegistered class factory with flags: 0x%X\n",
                dwFlags));
        return TRUE;
    }
}

BOOL
_PROG_RESOURCES::RevokeLogin()
{
    if(m_pLoginFactory) {
        CoRevokeClassObject(m_dwLoginClsFacReg);
        m_dwLoginClsFacReg = 0;
        m_pLoginFactory->Release();
        m_pLoginFactory = NULL;
    }
    return TRUE;
}

BOOL
_PROG_RESOURCES::RegisterBackup()
{
    HRESULT sc;
    DWORD dwFlags = CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER;

    g_ProgRes.m_pBackupFactory = new CForwardFactory(CLSID_WbemBackupRestore);
    g_ProgRes.m_pBackupFactory->AddRef();

    sc = CoRegisterClassObject(CLSID_WbemBackupRestore, 
                               g_ProgRes.m_pBackupFactory,
                               dwFlags,
                               REGCLS_MULTIPLEUSE, 
                               &g_ProgRes.m_dwBackupClsFacReg);
    if(sc != S_OK)
    {
        TRACE((LOG_WINMGMT,"\nFailed to register the "
                            "Backup/recovery class factory, "
                            "sc = 0x%x", sc));
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

BOOL
_PROG_RESOURCES::RevokeBackup()
{
    if(m_pBackupFactory) {
        CoRevokeClassObject(m_dwBackupClsFacReg);
        m_dwBackupClsFacReg = 0;
        m_pBackupFactory->Release();
        m_pBackupFactory = NULL;
    }
    return TRUE;
}

_PROG_RESOURCES::Phase1Delete(BOOL bIsSystemShutdown)
{

    if (!bIsSystemShutdown)
    {    
	    if(ghCoreCanUnload)
	    {
	        CloseHandle(ghCoreCanUnload);
	        ghCoreCanUnload = NULL;
	    };
	    
	    if(ghProviderCanUnload)
	    {
	        CloseHandle(ghProviderCanUnload);
	        ghProviderCanUnload = NULL;
	    }
	    if(ghCoreUnloaded)
	    {
	        CloseHandle(ghCoreUnloaded);
	        ghCoreUnloaded = NULL;
	    }
	    if(ghCoreLoaded)
	    {
	        CloseHandle(ghCoreLoaded);
	        ghCoreLoaded = NULL;
	    }

	    if(ghNeedRegistration)
	    {
	        CloseHandle(ghNeedRegistration);
	        ghNeedRegistration = NULL;
	    }
	    if(ghRegistrationDone)
	    {
	        CloseHandle(ghRegistrationDone);
	        ghRegistrationDone = NULL;
	    }
	    if(ghMofDirChange)
	    {
	        CloseHandle(ghMofDirChange);
	        ghMofDirChange = NULL;
	    }
    }

    if (m_Monitor.IsRegistred())
    {
        m_Monitor.Unregister(bIsSystemShutdown);
    }
    if (!bIsSystemShutdown)
    {
        m_Monitor.Uninit();

    
	    if(ghHoldOffNewClients)
	    {
	        CloseHandle(ghHoldOffNewClients);
	        ghHoldOffNewClients = NULL;
	    }

	    if(m_hTerminateEvent)
	    {
	        CloseHandle(m_hTerminateEvent);
	        m_hTerminateEvent = NULL;
	    }
	        
	    if(m_hExclusive)
	    {
	        ReleaseMutex(m_hExclusive);
	        CloseHandle(m_hExclusive);
	        m_hExclusive = NULL;
	    }

	    if(szHotMofDirectory)
	    {
	        delete [] szHotMofDirectory;
	        szHotMofDirectory = NULL;
	    }

    }

	// shut down and delete our writer for volume snapshot backup
	if (pWbemVssWriter && !bIsSystemShutdown)
	{
		if (bWbemVssWriterSubscribed)
		{
			HRESULT hRes = pWbemVssWriter->Unsubscribe();
			if (SUCCEEDED(hRes))
			{
				bWbemVssWriterSubscribed = false;
			}
			else
			{
		        TRACE((LOG_WINMGMT,"\nWINMGMT Could not unsubscribe the VssWriter"));
			}
		}

		delete pWbemVssWriter;
		pWbemVssWriter = NULL;
	}

    return TRUE;
}

_PROG_RESOURCES::Phase2Delete(BOOL bIsSystemShutdown)
{

    if (!bIsSystemShutdown)
    {
    
	    if(m_pLoginFactory) {
	        CoRevokeClassObject(m_dwLoginClsFacReg);
	        m_pLoginFactory->Release();
	        m_pLoginFactory = NULL;
	        m_dwLoginClsFacReg = 0;
	    }
	    if(m_pBackupFactory) {
	        CoRevokeClassObject(m_dwBackupClsFacReg);
	        m_pBackupFactory->Release();
	        m_pBackupFactory = NULL;
	        m_dwBackupClsFacReg = 0;
	    }

	    if(m_bOleInitialized)
	    {
	       CoUninitialize();
	       m_bOleInitialized = FALSE;
	    }

    }

    return TRUE;
}

BOOL
_PROG_RESOURCES::Phase3Delete()
{
    if (hMainMutex)
    {
        CloseHandle(hMainMutex);
        hMainMutex = NULL;
    }
    
    return TRUE;
}

//
//
//  ShutDownCore
//
//
/////////////////////////////////////////////////////////////////

bool ShutDownCore(BOOL bProcessShutdown,BOOL bIsSystemShutDown)
{
    SCODE sc = WBEM_E_FAILED;
    HMODULE hCoreModule = LoadLibrary(__TEXT("wbemcore.dll"));
    if(hCoreModule)
    {
        pfnShutDown pfn = (pfnShutDown)GetProcAddress(hCoreModule, "Shutdown");
        if(pfn)
        {
            sc = (pfn)(bProcessShutdown,bIsSystemShutDown);
            DEBUGTRACE((LOG_WINMGMT, "core is being shut down by WinMgmt.exe, it returned 0x%x",sc));
        }

        FreeLibrary(hCoreModule);
     }
    return sc == S_OK;
}


//
//
//  void Cleanup
//
//
//  Release any currently loaded transports and close Ole etc.
//
//
///////////////////////////////////////////////////////////////////

void Cleanup(BOOL bIsSystemShutDown)
{    
    //DBG_PRINTFA((pBuff,"Cleanup called\n"));    
    if (!bIsSystemShutDown)
    {    
    	DEBUGTRACE((LOG_WINMGMT,"\nStarting cleanup, ID = %x", GetCurrentProcessId()));
	    CoFreeUnusedLibrariesEx ( CORE_PROVIDER_UNLOAD_TIMEOUT , 0 ) ;
    	CoFreeUnusedLibrariesEx ( CORE_PROVIDER_UNLOAD_TIMEOUT , 0 ) ;
    }

    g_ProgRes.Phase1Delete(bIsSystemShutDown);

    // If the core is still loaded, call its shutdown function

    ShutDownCore(TRUE,bIsSystemShutDown);

    g_ProgRes.Phase2Delete(bIsSystemShutDown);

    if (!bIsSystemShutDown)
    {
        DEBUGTRACE((LOG_WINMGMT,"\nEnding cleanup"));
    }
    return;
}

//
//
//  BOOL Initialize
//
//
///////////////////////////////////////////////////////////////

BOOL Initialize(HANDLE hTerminateEvt)
{
    
    // Set the error mode.  This is used to provent the system from putting up dialog boxs to
    // open files

    UINT errormode = SetErrorMode(0);
    errormode |= SEM_NOOPENFILEERRORBOX|SEM_FAILCRITICALERRORS;
    SetErrorMode(errormode);

    int iCnt;
    TCHAR tcName[MAX_PATH+1];
    DEBUGTRACE((LOG_WINMGMT,"\nStarting Initialize, ID = %x", GetCurrentProcessId()));

    
    if(!InitHotMofStuff(&g_ProgRes))
        return FALSE;
            

    if (!g_ProgRes.Phase2Build(hTerminateEvt))
        return FALSE;

    // Initialize Ole

    SCODE sc;

    sc = CoInitializeEx(NULL,COINIT_MULTITHREADED);

    if(FAILED(sc))
    {
        TRACE((LOG_WINMGMT,"\nWINMGMT Could not initialize Ole\n"));
        return FALSE;
    }
    else
    {
        g_ProgRes.m_bOleInitialized = TRUE;
    }

    //
    //  Call the initialize function in core
    //
    HMODULE hCoreModule = GetModuleHandle(_T("wbemcore.dll"));
    if(hCoreModule)
    {
        HRESULT (STDAPICALLTYPE *pfn)(DWORD);
        pfn = (long (__stdcall *)(DWORD))GetProcAddress(hCoreModule, "Reinitialize");
        if(pfn)
        {
            sc = (*pfn)(0);
            DEBUGTRACE((LOG_WINMGMT, "core is being resumed: it returned 0x%x",sc));
        }
        else
        {
            DEBUGTRACE((LOG_WINMGMT, "failed to re-initialize core"));
            return FALSE; 
        }
    }
    

    g_ProgRes.RegisterLogin();
    g_ProgRes.RegisterBackup();

    g_ProgRes.ServiceStatus = SERVICE_RUNNING;
    
    // Get the registry key which is the root for all the transports.
    // ==============================================================

    HKEY hKey;

    long lRet = RegOpenKey(HKEY_LOCAL_MACHINE,
                        TEXT("Software\\Microsoft\\WBEM\\CIMOM\\TRANSPORTS"),
                        &hKey);
    if(lRet != ERROR_SUCCESS)
    {
        DEBUGTRACE((LOG_WINMGMT,"\nRegOpenKey returned 0x%x while trying to open the transports node.  Using default transports!",lRet));
    }
    else
    {
/*    
        // Loop through each transport subkey.
        // ===================================

        for(iCnt = 0;ERROR_SUCCESS == RegEnumKey(hKey,iCnt,tcName,MAX_PATH+1);
                                                    iCnt++)
        {
            HKEY hSubKey;
            lRet = RegOpenKey(hKey,tcName,&hSubKey);
            if(lRet != ERROR_SUCCESS)
                continue;
            DWORD bytecount = sizeof(DWORD);
            DWORD dwType;

            // If the Enabled value isnt 1, then the transport is disabled
            // and is ignored.
            // ===========================================================

            char cTemp[20];
            bytecount=20;
            lRet = RegQueryValueEx(hSubKey, TEXT("Enabled"), NULL, &dwType,
                    (LPBYTE) cTemp, &bytecount);
            if(lRet != ERROR_SUCCESS || dwType != REG_SZ || cTemp[0] != '1')
            {
                RegCloseKey(hSubKey);
                continue;
            }

            // Read the CLSID string and convert it into an CLSID structure.
            // =============================================================

            TCHAR szCLSID[50];            
            bytecount = sizeof(szCLSID);
            lRet = RegQueryValueEx(hSubKey, TEXT("CLSID"), NULL, &dwType,
                    (LPBYTE) &szCLSID, &bytecount);

            RegCloseKey(hSubKey);
            if(lRet != ERROR_SUCCESS)
            {
                continue;
            }

            CLSID clsid;

            sc = CLSIDFromString( szCLSID, &clsid);
            if(sc != S_OK)
            {
                continue;
            }

            // Load up the transport object and then initialize it.
            // ====================================================

            IWbemTransport * pTransport =  NULL;
            sc = CoCreateInstance(clsid, 0, CLSCTX_INPROC_SERVER,
                        IID_IWbemTransport, (LPVOID *) &pTransport);
            if(sc != S_OK || pTransport == NULL)
            {
                continue;
            }

            sc = pTransport->Initialize();
            if(sc != S_OK)
                pTransport->Release();
            else
                g_ProgRes.m_TransportArray.Add(pTransport);     // add it to the list
        }
*/
        RegCloseKey(hKey);
    };

	// initialize our writer for volume snapshot backup
	// this must be after CoInitializeEx and after wbem is initialized
	// (this pointer will be NULL during setup)
	if (g_ProgRes.pWbemVssWriter)
	{
		HRESULT hRes = g_ProgRes.pWbemVssWriter->Initialize();
		if (SUCCEEDED(hRes))
		{
			hRes = g_ProgRes.pWbemVssWriter->Subscribe();
			if (SUCCEEDED(hRes))
			{
				g_ProgRes.bWbemVssWriterSubscribed = true;
			}
			else
			{
		        TRACE((LOG_WINMGMT,"\nWINMGMT Could not subscribe the VssWriter"));
			}
		}
		else
		{
	        TRACE((LOG_WINMGMT,"\nWINMGMT Could not initialize the VssWriter"));
		}
	}

    DEBUGTRACE((LOG_WINMGMT,"\nInitialize complete"));

    // TO BE REPLACED WITH PROPER CODING --- FORCE CORE
    // ================================================
    
    
    return TRUE;
}



//
//
//  WaitingFunction
//
//  DESCRIPTION:
//
//  Here is where we wait for messages and events during WinMgmt execution.
//  We return from here when the program/service is being stopped.
//
//////////////////////////////////////////////////////////////////

void WaitingFunction(HANDLE hTerminate)
{

    CSched sched;

    DEBUGTRACE((LOG_WINMGMT,"\nInside the waiting function"));

    HANDLE hEvents[] = {hTerminate, 
                        g_ProgRes.ghCoreCanUnload, 
                        g_ProgRes.ghCoreUnloaded, 
                        g_ProgRes.ghCoreLoaded, 
                        g_ProgRes.ghNeedRegistration,
                        g_ProgRes.ghProviderCanUnload, 
                        g_ProgRes.ghMofDirChange      // important, must be last entry!!!!
                        };
                        
    int iNumEvents = sizeof(hEvents) / sizeof(HANDLE);
    DWORD dwFlags;
    SCODE sc;
    CPersistentConfig per;
    per.TidyUp();

    sched.SetWorkItem(PossibleStartCore, 60000);    

    //Load any MOFs in the MOF directory if needed...
    LoadMofsInDirectory(g_ProgRes.szHotMofDirectory);

    // resync the perf counters if 
    // we haven't turned this off for debugging  AND
    // we are not running during setup
    
    if(GLOB_IsResyncAllowed()) 
    {
        ResyncPerf(RESYNC_TYPE_INITIAL);
        GLOB_GetMonitor()->Register();
    }
    
    while(TRUE)
    {
        DWORD dwDelay = sched.GetWaitPeriod();
        DWORD dwObj = WaitForMultipleObjects(iNumEvents, hEvents, FALSE, dwDelay);
                
        switch (dwObj)
        {
            case 0:     // bail out for terminate event
                {
                
                    if (SERVICE_SHUTDOWN != g_ProgRes.ServiceStatus)
                    {
                        DEBUGTRACE((LOG_WINMGMT,"\nGot a termination event"));
                    }
					{
                        CInMutex im(g_ProgRes.hMainMutex);
                        g_ProgRes.bShuttingDownWinMgmt = TRUE;
					}
					// call cleanup outside of a Mutex
                    Cleanup((g_ProgRes.ServiceStatus == SERVICE_SHUTDOWN)?TRUE:FALSE);
                }
                return;
            case 1:     // core can unload
                DEBUGTRACE((LOG_WINMGMT,"\nGot a core can unload event"));
                sched.SetWorkItem(FirstCoreShutdown, 30000);   // 30 seconds until next unloac;
                break;
            case 2:     // core went away
                DEBUGTRACE((LOG_WINMGMT,"\nGot a core unloaded event"));
                g_ProgRes.gbCoreLoaded = FALSE;
                break;

            case 3:     // core loaded
                DEBUGTRACE((LOG_WINMGMT,"\nGot a core loaded event"));
                g_ProgRes.gbCoreLoaded = TRUE;
                break;

            case 4:     // Need Registration

                DEBUGTRACE((LOG_WINMGMT,"\nGot a NeedRegistration event"));

                if (g_ProgRes.ServiceStatus == SERVICE_RUNNING) 
                {
                    g_ProgRes.RevokeLogin();
                    g_ProgRes.RegisterLogin();
                }
                
                SetEvent(g_ProgRes.ghRegistrationDone);
                ResetEvent(g_ProgRes.ghNeedRegistration);
                
                break;
            case 5:     // provider can unload
                {
                    DEBUGTRACE((LOG_WINMGMT,"\nGot a provider can unload event"));                    
					CoFreeUnusedLibrariesEx ( CORE_PROVIDER_UNLOAD_TIMEOUT , 0 ) ;
                    //
                    // HACKHACK: Call it again to make sure that components that
                    // were released by unloading the first one can be unloaded
                    //
                    CoFreeUnusedLibrariesEx ( CORE_PROVIDER_UNLOAD_TIMEOUT , 0 ) ;
                    sched.SetWorkItem(FinalCoreShutdown, CORE_PROVIDER_UNLOAD_TIMEOUT);   // 11 minutes until next unloac;
                }
                break;

            case 6:     // change in the hot mof directory
                {
                    DEBUGTRACE((LOG_WINMGMT,"\nGot change in the hot mof directory"));
                    LoadMofsInDirectory(g_ProgRes.szHotMofDirectory);

                    //Continue to monitor changes
                    if (!FindNextChangeNotification(g_ProgRes.ghMofDirChange))
                    {
                        iNumEvents--;
                    }
                }
                break;
            case WAIT_TIMEOUT:

                DEBUGTRACE((LOG_WINMGMT,"\nGot a TIMEOUT work item"));
                if(sched.IsWorkItemDue(FirstCoreShutdown))
                {

                    // All the clients have left the core and a decent time interval has passed.  Set the
                    // WINMGMT_CORE_CAN_BACKUP event.  When the core is done, it will set the WINMGMT_CORE_BACKUP_DONE
                    // event which will start the final unloading.

                    DEBUGTRACE((LOG_WINMGMT,"\nGot a FirstCoreShutdown work item"));
                    sched.ClearWorkItem(FirstCoreShutdown);
                    CoFreeUnusedLibrariesEx ( CORE_PROVIDER_UNLOAD_TIMEOUT , 0 ) ;
                    CoFreeUnusedLibrariesEx ( CORE_PROVIDER_UNLOAD_TIMEOUT , 0 ) ;
                }
                if(sched.IsWorkItemDue(FinalCoreShutdown))
                {
                    CInMutex im(g_ProgRes.hMainMutex);
                    DEBUGTRACE((LOG_WINMGMT,"\nGot a FinalCoreShutdown work item"));
                    CoFreeUnusedLibrariesEx ( CORE_PROVIDER_UNLOAD_TIMEOUT , 0 ) ;
                    //
                    // HACKHACK: Call it again to make sure that components that
                    // were released by unloading the first one can be unloaded
                    CoFreeUnusedLibrariesEx ( CORE_PROVIDER_UNLOAD_TIMEOUT , 0 ) ;
                    sched.ClearWorkItem(FinalCoreShutdown);
                }
                if(sched.IsWorkItemDue(PossibleStartCore))
                {                    
                    sched.StartCoreIfEssNeeded();
                    sched.ClearWorkItem(PossibleStartCore);
                }

                break;
        }

    }

}


//***************************************************************************
//
//  MyService::MyService
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

MyService::MyService(DWORD CtrlAccepted):CNtService(CtrlAccepted)
{
    m_hStopEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
    
    if(m_hStopEvent == NULL)
    {
        DEBUGTRACE((LOG_WINMGMT,"\nMyService could not initialize"));
    }
}

//***************************************************************************
//
//  MyService::~MyService
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

MyService::~MyService()
{
    if(m_hStopEvent)
        CloseHandle(m_hStopEvent);
}

//***************************************************************************
//
//  DWORD MyService::WorkerThread
//
//  DESCRIPTION:
//
//  Where the service runs.  In this case, the service just waits for
//  the terminate event to be set.
//
//  RETURN VALUE:
//
//  0
//***************************************************************************

DWORD MyService::WorkerThread()
{
    DEBUGTRACE((LOG_WINMGMT,"\nStarting service worker thread"));
    if(!::Initialize(m_hStopEvent))
        return 0;
    WaitingFunction(m_hStopEvent);

    if (SERVICE_SHUTDOWN != g_ProgRes.ServiceStatus )
    {
        DEBUGTRACE((LOG_WINMGMT,"\nStopping service worker thread"));
    }
    return 0;
}

//
//
//  VOID MyService::Log
//
///////////////////////////////////////////////////////////////////

VOID MyService::Log(
                        IN LPCSTR lpszMsg)
{
    TRACE((LOG_WINMGMT,lpszMsg));
}

//
//
//  the stop function
//
//////////////////////////////////////////////////////////////////

VOID MyService::Stop(BOOL bSystemShutDownCalled)
{
    g_ProgRes.ServiceStatus = (bSystemShutDownCalled)?SERVICE_SHUTDOWN:SERVICE_STOPPED;
    
    SetEvent(m_hStopEvent);
};

//
// MyService::Pause
//
////////////////////////////////////////////////////////////////////

HRESULT WbemPauseService()
{
    HRESULT hr = WBEM_S_NO_ERROR;
    g_ProgRes.ServiceStatus = SERVICE_PAUSED;
    g_ProgRes.RevokeLogin();
    GLOB_GetMonitor()->Unregister(FALSE);

    SCODE sc = WBEM_E_FAILED;
    HMODULE hCoreModule = LoadLibraryEx(__TEXT("wbemcore.dll"),NULL,0);
    if(hCoreModule)
    {        
        pfnShutDown pfn = (pfnShutDown)GetProcAddress(hCoreModule, "Shutdown");
        if(pfn)
        {
            sc = pfn(FALSE,FALSE);
            DEBUGTRACE((LOG_WINMGMT, "core is being shut down by WinMgmt.exe, it returned 0x%x",sc));
        }
        else
            hr = WBEM_E_CRITICAL_ERROR;

        FreeLibrary(hCoreModule);
     }
    else
        hr = WBEM_E_CRITICAL_ERROR;

    return hr;
}
VOID MyService::Pause()
{
    WbemPauseService();
}


//
// MyService::Continue
//
////////////////////////////////////////////////////////////////////

HRESULT WbemContinueService()
{
    HRESULT hr = WBEM_S_NO_ERROR;
    // HRESULT APIENTRY Reinitialize(DWORD dwReserved);

    SCODE sc = WBEM_E_FAILED;
    HMODULE hCoreModule = LoadLibraryEx(__TEXT("wbemcore.dll"),NULL,0);
    if(hCoreModule)
    {
        HRESULT (STDAPICALLTYPE *pfn)(DWORD);
        pfn = (long (__stdcall *)(DWORD))GetProcAddress(hCoreModule, "Reinitialize");
        if(pfn)
        {
            sc = (*pfn)(0);
            DEBUGTRACE((LOG_WINMGMT, "core is being resumed: it returned 0x%x",sc));
        }
        else
            hr = WBEM_E_CRITICAL_ERROR;

        FreeLibrary(hCoreModule);
     }
    else
        hr = WBEM_E_CRITICAL_ERROR;

    g_ProgRes.RegisterLogin();
    GLOB_GetMonitor()->Register();
    g_ProgRes.ServiceStatus = SERVICE_RUNNING;
    
    return hr;
}

VOID MyService::Continue()
{
    WbemContinueService();
}

//
//
//  this function will be executed before
//  the final SetServiceStatus(SERVICE_STOPPED)
//
//////////////////////////////////////////////////////////

VOID MyService::FinalCleanup()
{
    g_ProgRes.Phase3Delete();

    RegSetDWORD(HKEY_LOCAL_MACHINE,
                 HOME_REG_PATH,
                 _T("ProcessID"),
                 0); 
}

//
//  TO be removed before RTM
//     publish process ID in the registry
//
////////////////////////////////////////////////////

DWORD 
RegSetDWORD(HKEY hKey,
             TCHAR * pName,
             TCHAR * pValue,
             DWORD dwValue)
{
    HKEY hKey2;
    LONG lRet;

    lRet = RegOpenKeyEx(hKey,
                        pName,
                        0,
                        KEY_WRITE,
                        &hKey2);
    if (ERROR_SUCCESS == lRet)
    {
        DWORD dwType = REG_DWORD; 
        DWORD dwSize = sizeof(DWORD);
        
        lRet = RegSetValueEx(hKey2,
                             pValue,
                             NULL,
                             dwType,
                             (BYTE *)&dwValue,
                             dwSize);
                                       
        RegCloseKey(hKey2);
    }
    return lRet;

}
                    

DWORD 
RegGetDWORD(HKEY hKey,
             TCHAR * pName,
             TCHAR * pValue,
             DWORD * pdwValue)
{
    HKEY hKey2;
    LONG lRet;

    if (0 == pdwValue)
        return ERROR_INVALID_PARAMETER;


    lRet = RegOpenKeyEx(hKey,
                        pName,
                        0,
                        KEY_READ,
                        &hKey2);
    if (ERROR_SUCCESS == lRet)
    {
        DWORD dwSize = sizeof(DWORD);
        DWORD dwType =0;
        lRet = RegQueryValueEx(hKey2,
                             pValue,
                             NULL,
                             &dwType,
                             (BYTE *)pdwValue,
                             &dwSize);
                                       
        RegCloseKey(hKey2);
    }
    return lRet;

}
                          
//
//
//  Interceptor
//
//
///////////////////////////////////////////////////////////

#ifdef  INSTRUMENTED_BUILD
#ifdef  _X86_

#include <malloc.h>

struct HEAP_ENTRY {
	WORD Size;
	WORD PrevSize;
	BYTE SegmentIndex;
	BYTE Flags;
    BYTE UnusedBytes;
	BYTE SmallTagIndex;
};

#define HEAP_SLOW_FLAGS  0x7d030f60

// only the "header"

typedef struct _HEAP {
    HEAP_ENTRY Entry;
    ULONG Signature;
    ULONG Flags;
    ULONG ForceFlags;
} HEAP;

BOOL   g_FaultHeapEnabled = FALSE;
BOOL   g_FaultFileEnabled = FALSE;
ULONG g_Seed;
ULONG g_Factor  = 100000;
ULONG g_Percent = 0x20;
//ULONG g_RowOfFailures = 10;
//LONG  g_NumFailInARow = 0;
//LONG  g_NumFailedAllocation = 0;
BOOL g_bDisableBreak = FALSE;
LONG g_nSuccConn = 0;

#define SIZE_JUMP_ADR    5
#define SIZE_SAVED_INSTR 12

void
_declspec(naked) Prolog__ReadFile(){
	_asm {
		// this is the space for the "saved istructions"
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;		
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		// this is the place for the JMP
        nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		nop ; // dist
		nop ; // dist		
		nop ; // dist		
		nop ; // dist		
	}
}


BOOL _I_ReadFile(
  HANDLE hFile,               // handle to file
  LPVOID lpBuffer,            // data buffer
  DWORD nNumberOfBytesToRead, // number of bytes to read
  LPDWORD lpNumberOfBytesRead, // number of bytes read  
  LPOVERLAPPED lpOverlapped   // offset
){
	DWORD * pDw = (DWORD *)_alloca(sizeof(DWORD));
    BOOL bRet;

	LONG Ret = RtlRandomEx(&g_Seed);
	if (g_FaultFileEnabled && (Ret%g_Factor < g_Percent))
	{
	    if (lpNumberOfBytesRead)
	        *lpNumberOfBytesRead = 0;
		return FALSE;
	}    
    
    _asm{
		push lpOverlapped;
        push lpNumberOfBytesRead;
		push nNumberOfBytesToRead;
		push lpBuffer;
		push hFile;
		call Prolog__ReadFile;
		mov  bRet,eax
	}

    return bRet;
}


void
_declspec(naked) Prolog__WriteFile(){
	_asm {
		// this is the space for the "saved istructions"
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;		
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		// this is the place for the JMP
        nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		nop ; // dist
		nop ; // dist		
		nop ; // dist		
	}
}

BOOL _I_WriteFile(
  HANDLE hFile,                    // handle to file
  LPCVOID lpBuffer,                // data buffer
  DWORD nNumberOfBytesToWrite,     // number of bytes to write
  LPDWORD lpNumberOfBytesWritten,  // number of bytes written
  LPOVERLAPPED lpOverlapped        // overlapped buffer
){

	DWORD * pDw = (DWORD *)_alloca(sizeof(DWORD));
    BOOL bRet;

	LONG Ret = RtlRandomEx(&g_Seed);
	if (g_FaultFileEnabled && (Ret%g_Factor < g_Percent))
	{
	    if (lpNumberOfBytesWritten)
	        *lpNumberOfBytesWritten = 0;
		return FALSE;
	}    
    
    _asm{
		push lpOverlapped;
        push lpNumberOfBytesWritten;
		push nNumberOfBytesToWrite;
		push lpBuffer;
		push hFile;
		call Prolog__WriteFile;
		mov  bRet,eax
	}

    return bRet;
}


void
_declspec(naked) Prolog__CreateEvent(){
	_asm {
		// this is the space for the "saved istructions"
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;		
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		// this is the place for the JMP
        nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		nop ; // dist
		nop ; // dist		
	}
}

HANDLE _I_CreateEvent(
  LPSECURITY_ATTRIBUTES lpEventAttributes, // SD
  BOOL bManualReset,                       // reset type
  BOOL bInitialState,                      // initial state
  LPCWSTR lpName                           // object name
)
{
	DWORD * pDw = (DWORD *)_alloca(sizeof(DWORD));
	HANDLE hHandle;

	LONG Ret = RtlRandomEx(&g_Seed);
	if (g_FaultFileEnabled && (Ret%g_Factor < g_Percent))
	{
		return NULL;
	}

    _asm{
		push lpName;
        push bInitialState;
		push bManualReset;
		push lpEventAttributes
		call Prolog__CreateEvent;
		mov  hHandle,eax
	}
    
	return hHandle;
}


void
_declspec(naked) Prolog__RtlFreeHeap(){
	_asm {
		// this is the space for the "saved istructions"
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;		
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		// this is the place for the JMP
        nop ;
        nop ;
        nop ;
		nop ;
		nop ;
	}
}

#define SPACE_STACK_ALLOC (4*sizeof(ULONG_PTR))

DWORD _I_RtlFreeHeap(VOID * pHeap,DWORD Flags,VOID * pBlock)
{	
	ULONG * pLong = (ULONG *)_alloca(sizeof(DWORD));
	Flags |= (((HEAP *)pHeap)->Flags) | (((HEAP *)pHeap)->ForceFlags);	
	DWORD dwRet;

	if (pBlock && !(HEAP_SLOW_FLAGS & Flags))
	{
		HEAP_ENTRY * pEntry = (HEAP_ENTRY *)pBlock-1;

              DWORD RealSize = pEntry->Size * sizeof(HEAP_ENTRY);
		DWORD Size = RealSize - pEntry->UnusedBytes;

		ULONG_PTR * pL = (ULONG_PTR *)pBlock;

		if (0 == (pEntry->Flags & 0x01) ||0xf0f0f0f0 == pL[1] )
		{
			if (!g_bDisableBreak)
       			DebugBreak();
		}

		DWORD CanMemset = RealSize-sizeof(HEAP_ENTRY);
		memset(pBlock,0xF0,(CanMemset > SPACE_STACK_ALLOC)?CanMemset-SPACE_STACK_ALLOC:CanMemset);
				
		if (pEntry->Size >=4)
		{		    
		    RtlCaptureStackBackTrace (1,
        		                      (4 == pEntry->Size)?4:6,
                		              (PVOID *)(pEntry+2),
                        		      pLong);		
		}

	}

	_asm {
		push pBlock              ;
		push Flags               ;
		push pHeap               ;
		call Prolog__RtlFreeHeap ;
		mov  dwRet,eax           ;
	}

	return dwRet;
}

void
_declspec(naked) Prolog__RtlAllocateHeap(){
	_asm {
		// this is the space for the "saved istructions"
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;		
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		// this is the place for the JMP
        nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		nop ; // to make this distinct
	}
}



VOID * _I_RtlAllocateHeap(VOID * pHeap,DWORD Flags,DWORD Size)
{
	
	ULONG * pLong = (ULONG *)_alloca(sizeof(DWORD));
	Flags |= (((HEAP *)pHeap)->Flags) | (((HEAP *)pHeap)->ForceFlags);
	VOID * pRet;
	DWORD NewSize = (Size < (3*sizeof(HEAP_ENTRY)))?(3*sizeof(HEAP_ENTRY)+SPACE_STACK_ALLOC):(Size+SPACE_STACK_ALLOC);

/*
       if (g_FaultHeapEnabled && g_NumFailInARow)
       {
       	InterlockedDecrement(&g_NumFailInARow);
       	goto here;
       }
*/       
       
	LONG Ret = RtlRandomEx(&g_Seed);
	if (g_FaultHeapEnabled && (Ret%g_Factor < g_Percent))
	{
//		g_NumFailInARow = g_RowOfFailures;
//here:		
//		InterlockedIncrement(&g_NumFailedAllocation);
		return NULL;
	}
	

	_asm {
		push NewSize                 ;
		push Flags                   ;
		push pHeap                   ;
		call Prolog__RtlAllocateHeap ;
		mov  pRet,eax                ;
	}

	
	if (pRet && !(HEAP_SLOW_FLAGS & Flags) )
	{

	   if (NewSize <= 0xffff)
       	    NewSize = sizeof(HEAP_ENTRY)*((HEAP_ENTRY *)pRet-1)->Size;
		
	    if (!(HEAP_ZERO_MEMORY & Flags))
	    {	
		    memset(pRet,0xc0,NewSize-sizeof(HEAP_ENTRY));
	    }

	    RtlCaptureStackBackTrace(1,
	    	                                     4,
                         		               (PVOID *)((BYTE *)pRet+(NewSize-SPACE_STACK_ALLOC-sizeof(HEAP_ENTRY))),
                        		               pLong);
	    
	}

	return pRet;
	
}

void
_declspec(naked) Prolog__RtlReAllocateHeap(){
	_asm {
		// this is the space for the "saved istructions"
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;		
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		// this is the place for the JMP
        nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		nop ; // dist
		nop ; // dist		
		nop ; // dist		
		nop ; // dist		
		nop ; // dist			
	}
}


VOID *
_I_RtlReAllocateHeap(
  HANDLE pHeap,   // handle to heap block
  DWORD Flags,  // heap reallocation options
  LPVOID lpMem,   // pointer to memory to reallocate
  SIZE_T Size  // number of bytes to reallocate
){
	ULONG * pLong = (ULONG *)_alloca(sizeof(DWORD));
	Flags |= (((HEAP *)pHeap)->Flags) | (((HEAP *)pHeap)->ForceFlags);
	VOID * pRet;

	DWORD NewSize = (Size < (3*sizeof(HEAP_ENTRY)))?(3*sizeof(HEAP_ENTRY)+SPACE_STACK_ALLOC):(Size+SPACE_STACK_ALLOC);
	
	_asm {
		push NewSize                 ;
		push lpMem                   ;
		push Flags                 ;
		push pHeap                   ;
		call Prolog__RtlReAllocateHeap ;
		mov  pRet,eax                ;
	}

	if (pRet && !(HEAP_SLOW_FLAGS & Flags) )
	{

	   if (NewSize <= 0xffff)
       	    NewSize = sizeof(HEAP_ENTRY)*((HEAP_ENTRY *)pRet-1)->Size;
		
	    RtlCaptureStackBackTrace(1,
	    	                                     4,
                         		               (PVOID *)((BYTE *)pRet+(NewSize-SPACE_STACK_ALLOC-sizeof(HEAP_ENTRY))),
                        		               pLong);
	    
	}


       return pRet;
}

void
_declspec(naked) Prolog__RtlValidateHeap(){
	_asm {
		// this is the space for the "saved istructions"
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;		
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		// this is the place for the JMP
        nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		nop ; // dist
		nop ; // dist		
		nop ; // dist		
		nop ; // dist		
		nop ; // dist			
		nop ; // dist			
	}
}

BOOL
_I_RtlValidateHeap(
  HANDLE pHeap,   // handle to heap block
  DWORD dwFlags,  // heap reallocation options
  LPVOID lpMem   // pointer to memory to validate
){
	ULONG * pLong = (ULONG *)_alloca(sizeof(DWORD));
	BOOL bRet;

       g_bDisableBreak = TRUE;
	
	_asm {
		push lpMem                   ;
		push dwFlags                 ;
		push pHeap                   ;
		call Prolog__RtlValidateHeap ;
		mov  bRet,eax                ;
	}

       g_bDisableBreak = FALSE;

       return bRet;
}

#if 0
#define MAX_REMEMBER (1024) 

struct CSCCTrace
{
    VOID * p1;
    VOID * p2;
    DWORD Tid;
    ULONG_PTR Trace[5];
} g_CSCCTrace[MAX_REMEMBER];

LONG g_CSCCIndex = -1;

void
_declspec(naked) Prolog__CoSwitchCallContext(){
	_asm {
		// this is the space for the "saved istructions"
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;		
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		// this is the place for the JMP
        nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		nop ; // dist
		nop ; // dist		
		nop ; // dist		
		nop ; // dist		
		nop ; // dist			
		nop ; // dist			
		nop ; // dist			
	}
}

HRESULT WINAPI
_I_CoSwitchCallContext(IUnknown * pNew,
                     IUnknown ** ppOld)
{
    ULONG * pLong = (ULONG * )_alloca(sizeof(ULONG ));

    long nIndex = InterlockedIncrement(&g_CSCCIndex);
    nIndex %= MAX_REMEMBER;
    CSCCTrace * pTrace = &g_CSCCTrace[nIndex];
    pTrace->p1 = pNew;
    if (ppOld)
        pTrace->p2 = *ppOld;
    else
        pTrace->p2 = 0;
    pTrace->Tid =GetCurrentThreadId();

    RtlCaptureStackBackTrace (1,5,(PVOID *)pTrace->Trace,pLong);    
    
    HRESULT hRes;
    _asm {
    	push ppOld;    	
    	push pNew;
    	call Prolog__CoSwitchCallContext;
    	mov hRes,eax;
    };
    return hRes;
}
#endif

void intercept2(WCHAR * Module,
			   LPSTR Function,
			   VOID * NewRoutine,
			   VOID * pPrologStorage,
			   DWORD Size)    
{
	FARPROC OldRoutine = GetProcAddress(GetModuleHandleW(Module),Function);

	if (OldRoutine)
	{
		MEMORY_BASIC_INFORMATION MemBI;
		DWORD dwOldProtect;
		BOOL bRet, bRet2;
		DWORD dwRet;

		dwRet = VirtualQuery(OldRoutine,&MemBI,sizeof(MemBI));

		bRet = VirtualProtect(MemBI.BaseAddress,
							  MemBI.RegionSize,
							  PAGE_EXECUTE_WRITECOPY,
							  &dwOldProtect);

		dwRet = VirtualQuery(pPrologStorage,&MemBI,sizeof(MemBI));

		bRet2 = VirtualProtect(MemBI.BaseAddress,
							  MemBI.RegionSize,
							  PAGE_EXECUTE_WRITECOPY,
							  &dwOldProtect);

		if (bRet && bRet2)
		{
			VOID * pToJump = (VOID *)NewRoutine;
			BYTE Arr[SIZE_JUMP_ADR] = { 0xe9 };
			
			LONG * pOffset = (LONG *)&Arr[1];
			* pOffset = (LONG)NewRoutine - (LONG)OldRoutine - SIZE_JUMP_ADR ;        
			// save the old code
			
			memcpy(pPrologStorage,OldRoutine,Size); 		
			// put the new code
			memset(OldRoutine,0x90,Size);
			memcpy(OldRoutine,Arr,SIZE_JUMP_ADR);
			// adjust the prolog to continue
			* pOffset = (LONG)OldRoutine + Size - (LONG)pPrologStorage - SIZE_SAVED_INSTR - SIZE_JUMP_ADR; // magic for nops
			memcpy((BYTE *)pPrologStorage+SIZE_SAVED_INSTR,Arr,SIZE_JUMP_ADR);
		}
	}
	else
	{
		OutputDebugStringA("GetProcAddress FAIL\n");
	}
}

void unintercept(WCHAR * Module,
                 LPSTR Function,
			     VOID * pPrologStorage,
			     DWORD Size)
{
    FARPROC OldRoutine = GetProcAddress(GetModuleHandleW(Module),Function);

	if (OldRoutine)
	{
	    memcpy((void *)OldRoutine,pPrologStorage,Size);
	}

}

#endif /*_X86_*/

#ifndef STATUS_POSSIBLE_DEADLOCK
#define STATUS_POSSIBLE_DEADLOCK         (0xC0000194L)
#endif

class CSetVectoredHandler
{
private:
//	static ULONG_PTR Base;
//	static ULONG_PTR Limit;
	PVOID     pVectorHandler;
	enum ExceptionTypes
	{
	    StatusAccessViolation,
	    CXXException,
	    StatusNoMemory,
	    OtherExceptions,
	    LastException
	};
	static LONG ExceptionCounters[LastException];
/*	
	BOOL GetDllLimits(WCHAR * pDllName)
	{
	    UNICODE_STRING DllName;
	    RtlInitUnicodeString(&DllName,pDllName);
	    PEB_LDR_DATA * pLdr = NtCurrentPeb()->Ldr;
	    LIST_ENTRY * pHeadEntry = &pLdr->InLoadOrderModuleList;
	    LIST_ENTRY * pEntry = pLdr->InLoadOrderModuleList.Flink;
	    BOOL bFound = FALSE;
	    while (pHeadEntry != pEntry)
	    {
	        LDR_DATA_TABLE_ENTRY * pData = CONTAINING_RECORD(pEntry,
	        	                                               LDR_DATA_TABLE_ENTRY,
	        	                                               InLoadOrderLinks);
	        if (0 == _wcsicmp(DllName.Buffer,pData->BaseDllName.Buffer))
	        {
	            //OutputDebugStringA("found\n");
	            Base = (ULONG_PTR)pData->DllBase;
	            Limit = Base + (ULONG_PTR)pData->SizeOfImage;
	            bFound = TRUE;
	            break;
	        }
	        pEntry = pEntry->Flink;
	    }
	    return bFound;
	}
*/	
public:
	CSetVectoredHandler()
	{
    	pVectorHandler = NULL;
    	//if (GetDllLimits(L"fastprox.dll"))
    	//{
    	    pVectorHandler = AddVectoredExceptionHandler(TRUE,CSetVectoredHandler::VectoredHandler);
    	//}
	};
	~CSetVectoredHandler()
	{
	    if (pVectorHandler)
	        RemoveVectoredExceptionHandler(pVectorHandler);
	};
	static LONG WINAPI VectoredHandler(PEXCEPTION_POINTERS ExceptionInfo)
	{	    
    	PEXCEPTION_RECORD pExr = ExceptionInfo->ExceptionRecord;
    	PCONTEXT pCxr = ExceptionInfo->ContextRecord; 
    	switch (pExr->ExceptionCode)
    	{
    	case STATUS_PRIVILEGED_INSTRUCTION:
        case STATUS_INVALID_HANDLE:
       	case STATUS_STACK_OVERFLOW:
       	case STATUS_POSSIBLE_DEADLOCK:       		
    	case STATUS_ACCESS_VIOLATION:
    		InterlockedIncrement(&ExceptionCounters[(LONG)StatusAccessViolation]);
       		DebugBreak();  			
    		break;
    	case 0xe06d7363:
    		InterlockedIncrement(&ExceptionCounters[(LONG)CXXException]);
    		break;       		
    	case STATUS_NO_MEMORY:
    		InterlockedIncrement(&ExceptionCounters[(LONG)StatusNoMemory]);
    		break; 		
    	default:
    		InterlockedIncrement(&ExceptionCounters[(LONG)OtherExceptions]);
    		break;
    	}
	    return EXCEPTION_CONTINUE_SEARCH;
	}
} g_C;

LONG CSetVectoredHandler::ExceptionCounters[CSetVectoredHandler::LastException];

#endif

//
//
//  ServiceMain
//
///////////////////////////////////////////////////////////

VOID WINAPI
 ServiceMain(DWORD dwNumServicesArgs,
             LPWSTR *lpServiceArgVectors)
{

#ifdef INSTRUMENTED_BUILD
#ifdef _X86_

	intercept2(L"ntdll.dll","RtlFreeHeap",_I_RtlFreeHeap,Prolog__RtlFreeHeap,5);
	intercept2(L"ntdll.dll","RtlAllocateHeap",_I_RtlAllocateHeap,Prolog__RtlAllocateHeap,5);
	intercept2(L"ntdll.dll","RtlReAllocateHeap",_I_RtlReAllocateHeap,Prolog__RtlReAllocateHeap,5);	
	intercept2(L"ntdll.dll","RtlValidateHeap",_I_RtlValidateHeap,Prolog__RtlValidateHeap,7);
	intercept2(L"kernel32.dll","CreateEventW",_I_CreateEvent,Prolog__CreateEvent,6);	
	intercept2(L"kernel32.dll","WriteFile",_I_WriteFile,Prolog__WriteFile,7);
	intercept2(L"kernel32.dll","ReadFile",_I_ReadFile,Prolog__ReadFile,7);
    g_nSuccConn = 0;
#endif /*_X86_*/
#endif

    RegSetDWORD(HKEY_LOCAL_MACHINE,
                 HOME_REG_PATH,
                 _T("ProcessID"),
                 GetCurrentProcessId());

    if (InitialBreak())
    {
    	DebugBreak();
    }

    g_ProgRes.Init();
    g_ProgRes.Phase1Build();

    MyService ThisService(SERVICE_ACCEPT_STOP|SERVICE_ACCEPT_SHUTDOWN|SERVICE_ACCEPT_PAUSE_CONTINUE);
    
    ThisService.Run(SERVICE_NAME,
                    dwNumServicesArgs,
                    lpServiceArgVectors,
                    (void *)&ThisService);



#ifdef INSTRUMENTED_BUILD
#ifdef _X86_

	unintercept(L"ntdll.dll","RtlFreeHeap",Prolog__RtlFreeHeap,5);	
	unintercept(L"ntdll.dll","RtlAllocateHeap",Prolog__RtlAllocateHeap,5);
	unintercept(L"ntdll.dll","RtlReAllocateHeap",Prolog__RtlReAllocateHeap,5);	
	unintercept(L"ntdll.dll","RtlValidateHeap",Prolog__RtlValidateHeap,7);	
	unintercept(L"kernel32.dll","CreateEventW",Prolog__CreateEvent,6);
	unintercept(L"kernel32.dll","WriteFile",Prolog__WriteFile,7);
	unintercept(L"kernel32.dll","ReadFile",Prolog__ReadFile,7);
	
#endif /*_X86_*/
#endif
        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\winmgmt2\writer.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

	writer.cpp

Abstract:

	Volume SnapShot Writer for WMI

History:

	a-shawnb	06-Nov-00	Created

--*/

#include "precomp.h"
#include "writer.h"
#include <genutils.h> // for EnableAllPrivileges()
#include <malloc.h>

CWbemVssWriter::CWbemVssWriter() : CVssWriter(), 
                                 m_pBackupRestore(NULL),
                                 m_Lock(THROW_LOCK,0x80000000 | 500L)
{
}

CWbemVssWriter::~CWbemVssWriter()
{
	HRESULT hr = WBEM_S_NO_ERROR;

	if (m_pBackupRestore)
	{
		hr = m_pBackupRestore->Resume();
		m_pBackupRestore->Release();
		m_pBackupRestore = NULL;
	}
}

// {A6AD56C2-B509-4e6c-BB19-49D8F43532F0}
static VSS_ID s_WRITERID = {0xa6ad56c2, 0xb509, 0x4e6c, 0xbb, 0x19, 0x49, 0xd8, 0xf4, 0x35, 0x32, 0xf0};
static LPCWSTR s_WRITERNAME = L"WMI Writer";

HRESULT CWbemVssWriter::Initialize()
{
	return CVssWriter::Initialize(s_WRITERID, s_WRITERNAME, VSS_UT_SYSTEMSERVICE, VSS_ST_OTHER);
}

extern HRESULT GetRepositoryDirectory(wchar_t wszRepositoryDirectory[MAX_PATH+1]);

bool STDMETHODCALLTYPE CWbemVssWriter::OnIdentify(IN IVssCreateWriterMetadata *pMetadata)
{
	wchar_t wszRepositoryDirectory[MAX_PATH+1];
	HRESULT hr = GetRepositoryDirectory(wszRepositoryDirectory);
	if (FAILED(hr))
		return false;

	hr = pMetadata->AddComponent(	VSS_CT_FILEGROUP,
									NULL,
									L"WMI",
									L"Windows Managment Instrumentation",
									NULL,
									0, 
									false,
									false,
									false
									);
	if (FAILED(hr))
		return false;

	hr = pMetadata->AddFilesToFileGroup(
									NULL,
									L"WMI",
									wszRepositoryDirectory,
									L"*.*",
									true,
									NULL
									);
	if (FAILED(hr))
		return false;

	hr = pMetadata->SetRestoreMethod(
									VSS_RME_RESTORE_AT_REBOOT,
									NULL,
									NULL,
									VSS_WRE_NEVER,
									true
									);
	if (FAILED(hr))
		return false;
	
	return true;
}

bool STDMETHODCALLTYPE CWbemVssWriter::OnPrepareSnapshot()
{
    return true;
}

//
//  Doing the Job on this method, we will have a time-out guarantee
//  We sync the OnFreeze and the OnAbort/OnThaw calls,
//  so that, if a TimeOut occurs, we are not arbitrarly unlocking the repository
//
///////////////////////////////////////////////////////////////


bool STDMETHODCALLTYPE CWbemVssWriter::OnFreeze()
{
#ifdef _X86_
    DWORD * pDW = (DWORD *)_alloca(sizeof(DWORD));   
#endif
    LockGuard<CriticalSection> lg(m_Lock);
    if (!lg.locked())
    	return false;
    
	// m_pBackupRestore should always be NULL coming into this
	if (m_pBackupRestore)
	{
		return false;
	}

	HRESULT hr = CoCreateInstance(CLSID_WbemBackupRestore, 0, CLSCTX_LOCAL_SERVER,
								IID_IWbemBackupRestoreEx, (LPVOID *) &m_pBackupRestore);
    if (SUCCEEDED(hr))
    {
        if (SUCCEEDED(hr = EnableAllPrivileges(TOKEN_PROCESS)))
        {
	        hr = m_pBackupRestore->Pause();
	        if (FAILED(hr))
	        {
				m_pBackupRestore->Release();
				m_pBackupRestore = NULL;
			}
        }
    }
	return (SUCCEEDED(hr));	
}

bool STDMETHODCALLTYPE CWbemVssWriter::OnThaw()
{
#ifdef _X86_
    DWORD * pDW = (DWORD *)_alloca(sizeof(DWORD));   
#endif
    LockGuard<CriticalSection> lg(m_Lock);
    while (!lg.locked()){
    	Sleep(20);
    	lg.acquire();
    };

    
	if (!m_pBackupRestore)
	{
		// if m_pBackupRestore is NULL, then we haven't been
		// asked to prepare or we failed our preparation
		DebugBreak();
		return false;
	}

    HRESULT hr = m_pBackupRestore->Resume();
	m_pBackupRestore->Release();
	m_pBackupRestore = NULL;

	return (SUCCEEDED(hr));
}

bool STDMETHODCALLTYPE CWbemVssWriter::OnAbort()
{
#ifdef _X86_
    DWORD * pDW = (DWORD *)_alloca(sizeof(DWORD));   
#endif
    LockGuard<CriticalSection> lg(m_Lock);
    while (!lg.locked()){
    	Sleep(20);
    	lg.acquire();
    };
    
	HRESULT hr = WBEM_S_NO_ERROR;

	if (m_pBackupRestore)
	{
		hr = m_pBackupRestore->Resume();
		m_pBackupRestore->Release();
		m_pBackupRestore = NULL;
	}

	return (SUCCEEDED(hr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmicooker\localloc.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include <arena.h>

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmicooker\cache.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


///////////////////////////////////////////////////////////////////////////////
//
//	Cache.cpp
//
///////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <winperf.h>
#include <comdef.h>
#include <algorithm>
#include <wbemint.h>
#include <sync.h>     // for CInCritSec
#include <autoptr.h>

#include "Cache.h"
#include "WMIObjCooker.h"
#include "CookerUtils.h"


///////////////////////////////////////////////////////////////////////////////
//
//	CProperty
//	=========
//
//	The base property - used for raw properties and the base 
//	class for the CookedProperty.
//
///////////////////////////////////////////////////////////////////////////////

CProperty::CProperty( LPWSTR wszName, long lHandle, CIMTYPE ct ) :
  m_wszName( NULL ),
  m_lPropHandle( lHandle ),
  m_ct( ct )
///////////////////////////////////////////////////////////////////////////////
//
//
//
//	Parameters:
//
//
///////////////////////////////////////////////////////////////////////////////
{
	m_wszName = new WCHAR[ wcslen( wszName ) + 1 ];
	if (m_wszName)
	    wcscpy( m_wszName, wszName);
}

CProperty::~CProperty(){
    if (m_wszName) {
        delete [] m_wszName;
    }
}

LPWSTR CProperty::GetName()
{
	return m_wszName?m_wszName:L"";
}

CIMTYPE CProperty::GetType()
{ 
	return m_ct; 
}

long CProperty::GetHandle()
{
	return m_lPropHandle;
}

///////////////////////////////////////////////////////////////////////////////
//
//	CCookingProperty
//	================
//
//	The cooked property - used to model the data required to
//	cook a property of a cooked class
//
///////////////////////////////////////////////////////////////////////////////

CCookingProperty::CCookingProperty( LPWSTR wszName, 
                                    DWORD dwCounterType, 
                                    long lPropHandle, 
                                    CIMTYPE ct, 
                                    DWORD dwReqProp,
                                    BOOL bUseWellKnownIfNeeded) : 
  CProperty( wszName, lPropHandle, ct ),
  m_dwCounterType( dwCounterType ),
  m_dwReqProp(dwReqProp),
  m_nTimeFreq( 0 ),
  m_lScale(0),                 // 10^0 = 1
  m_pRawCounterProp( NULL ),
  m_pTimeProp( NULL ),
  m_pFrequencyProp( NULL ),
  m_pBaseProp( NULL ),
  m_nSampleWindow( 0 ),
  m_nTimeWindow( 0 ),
  m_bUseWellKnownIfNeeded(bUseWellKnownIfNeeded)
///////////////////////////////////////////////////////////////////////////////
//
//	Constructor
//
//	Parameters:
//		wszName			- The property name
//		dwCounterType	- The property's counter type
//		lPropHandle		- The cooking property's WMI Access handle
//		ct				- The CIM type of the property
//
///////////////////////////////////////////////////////////////////////////////
{}

CCookingProperty::~CCookingProperty()
{
    if (m_pRawCounterProp) {
        delete m_pRawCounterProp;        
    }
    
    if (m_pTimeProp){
        delete m_pTimeProp;
    }

    if ( m_pFrequencyProp ){
        delete m_pFrequencyProp;
    }
    if (m_pBaseProp){
        delete m_pBaseProp;
    }
}

WMISTATUS CCookingProperty::Initialize( IWbemQualifierSet* pCookingPropQualifierSet, 
                                        IWbemObjectAccess* pRawAccess,
                                        IWbemQualifierSet* pCookingClassQSet)
///////////////////////////////////////////////////////////////////////////////
//
//
//
//	Parameters:
//		pCookingClassAccess	- The class definition for the cooking class
//
///////////////////////////////////////////////////////////////////////////////
{
	WMISTATUS dwStatus = WBEM_NO_ERROR;

	_variant_t	vVal;

	// Initialize the raw counter property ("Counter")
	// ===============================================
	dwStatus = pCookingPropQualifierSet->Get( WMI_COOKER_RAW_COUNTER, 0, &vVal, NULL );

	if ( SUCCEEDED( dwStatus ) && ( vVal.vt != VT_BSTR ) )
	{
		dwStatus = E_FAIL;
	}

	if ( SUCCEEDED( dwStatus ) )
	{
		// Get the raw data properties
		// ===========================

		CIMTYPE	ct;
		
		long	lHandle = 0;
		WCHAR*	wszRawCounterName = vVal.bstrVal;

		// Get the raw counter property
		// ============================

		dwStatus = pRawAccess->GetPropertyHandle( wszRawCounterName, &ct, &lHandle );

		if ( SUCCEEDED( dwStatus ) )
		{
			m_pRawCounterProp = new CProperty( wszRawCounterName, lHandle, ct );

			if ( NULL == m_pRawCounterProp )
			{
				dwStatus = WBEM_E_OUT_OF_MEMORY;
			}
		}

		// Get the raw base property
		// =========================

		if ( SUCCEEDED( dwStatus ) )
		{
    		_variant_t	vProp;
			dwStatus = pCookingPropQualifierSet->Get( WMI_COOKER_RAW_BASE, 0, &vProp, NULL );

			if ( SUCCEEDED( dwStatus ) )
			{			
				if ( vProp.vt == VT_BSTR )
				{
					dwStatus = pRawAccess->GetPropertyHandle( vProp.bstrVal, &ct, &lHandle );

					if ( SUCCEEDED( dwStatus ) )
					{
						m_pBaseProp = new CProperty( vProp.bstrVal, lHandle, ct );

						if ( NULL == m_pBaseProp )
						{
							dwStatus = WBEM_E_OUT_OF_MEMORY;
						}
					}
				}
				else
				{
					dwStatus = WBEM_E_TYPE_MISMATCH;
				}
			}
			else
			{
                // the property qualifier set failed, try the class one
			    _variant_t varProp; // does not throw, simple container
			    dwStatus = pCookingClassQSet->Get( WMI_COOKER_RAW_BASE, 0, &varProp, NULL );
			    
			    if ( SUCCEEDED( dwStatus ) )
				{			
					if ( varProp.vt == VT_BSTR )
					{
						dwStatus = pRawAccess->GetPropertyHandle( varProp.bstrVal, &ct, &lHandle );

						if ( SUCCEEDED( dwStatus ) )
						{
							m_pBaseProp = new CProperty( varProp.bstrVal, lHandle, ct );

							if ( NULL == m_pBaseProp )
							{
								dwStatus = WBEM_E_OUT_OF_MEMORY;
							}
						}
					}
					else
					{
						dwStatus = WBEM_E_TYPE_MISMATCH;
					}
				}
				else
				{
					dwStatus = WBEM_NO_ERROR;
				}
			}
			//
			// no error so far, the BASE qulifier is REQUIRED, but none is found
			//
			if ( SUCCEEDED( dwStatus ) && 
			     IsReq(REQ_BASE) && 
			     (NULL == m_pBaseProp))
			{
			    dwStatus = WBEM_E_INVALID_CLASS;
			}
		} 

		// Get the raw timestamp property record
		// =====================================

		if ( SUCCEEDED( dwStatus ) )
		{
		    _variant_t vProp2;
			dwStatus = pCookingPropQualifierSet->Get( WMI_COOKER_RAW_TIME, 0, &vProp2, NULL );

			if ( SUCCEEDED( dwStatus ) )
			{
				if ( vProp2.vt == VT_BSTR )
				{
					dwStatus = pRawAccess->GetPropertyHandle( vProp2.bstrVal, &ct, &lHandle );

					if ( SUCCEEDED( dwStatus ) )
					{
						m_pTimeProp = new CProperty( vProp2.bstrVal, lHandle, ct );

						if ( NULL == m_pTimeProp )
						{
							dwStatus = WBEM_E_OUT_OF_MEMORY;
						}
					}
				}
				else
				{
					dwStatus = WBEM_E_TYPE_MISMATCH;
				}
			}
			else
			{

                // the property qualifier set failed, try the class one
                
                //PERF_TIMER_TICK 
                //PERF_TIMER_100NS  
                //PERF_OBJECT_TIMER
                
			    _variant_t varProp; // does not throw, simple container
			    if (m_dwCounterType & PERF_OBJECT_TIMER)
			    {
			        dwStatus = pCookingClassQSet->Get( WMI_COOKER_RAW_TIME_OBJ, 0, &varProp, NULL );
			        if (FAILED(dwStatus) && m_bUseWellKnownIfNeeded)
			        {
			            dwStatus = WBEM_NO_ERROR;
			            varProp = WMI_COOKER_REQ_TIMESTAMP_PERFTIME;
			        }
			    } 
			    else if (m_dwCounterType & PERF_TIMER_100NS)
			    {
			        dwStatus = pCookingClassQSet->Get( WMI_COOKER_RAW_TIME_100NS, 0, &varProp, NULL );
			        if (FAILED(dwStatus) && m_bUseWellKnownIfNeeded)
			        {
			            dwStatus = WBEM_NO_ERROR;
			            varProp = WMI_COOKER_REQ_TIMESTAMP_SYS100NS;
			        }			        
			    } else 
			    {
			        dwStatus = pCookingClassQSet->Get( WMI_COOKER_RAW_TIME_SYS, 0, &varProp, NULL );
			        if (FAILED(dwStatus) && m_bUseWellKnownIfNeeded)
			        {
			            dwStatus = WBEM_NO_ERROR;
			            varProp = WMI_COOKER_REQ_TIMESTAMP_OBJECT;
			        }			        
			    }
			    
			    if ( SUCCEEDED( dwStatus ) )
				{			
					if ( varProp.vt == VT_BSTR )
					{
						dwStatus = pRawAccess->GetPropertyHandle( varProp.bstrVal, &ct, &lHandle );

						if ( SUCCEEDED( dwStatus ) )
						{
							m_pTimeProp = new CProperty( varProp.bstrVal, lHandle, ct );

							if ( NULL == m_pTimeProp )
							{
								dwStatus = WBEM_E_OUT_OF_MEMORY;
							}
						}
					}
					else
					{
						dwStatus = WBEM_E_TYPE_MISMATCH;
					}
				}
				else
				{
					dwStatus = WBEM_NO_ERROR;
				}
			}

            // get in cascade the frequency property
			if (SUCCEEDED(dwStatus))
			{
			    _variant_t VarFreqName; // simple container, does not throw
			    dwStatus = pCookingPropQualifierSet->Get( WMI_COOKER_RAW_FREQUENCY, 0, &VarFreqName, NULL );
			    			    
			    if (SUCCEEDED(dwStatus))
			    { 
			        if (VarFreqName.vt == VT_BSTR)
			        {			        
				        dwStatus = pRawAccess->GetPropertyHandle( VarFreqName.bstrVal, &ct, &lHandle );
			        
				        if (SUCCEEDED(dwStatus))
				        {
        	                m_pFrequencyProp = new CProperty( VarFreqName.bstrVal, lHandle, ct );

							if ( NULL == m_pFrequencyProp )
							{
								dwStatus = WBEM_E_OUT_OF_MEMORY;
							}			        
				        }

				    } else {
				        dwStatus = WBEM_E_TYPE_MISMATCH;
				    }
			    } 
			    else 
			    {
				    if (m_dwCounterType & PERF_OBJECT_TIMER)
				    {
				        dwStatus = pCookingClassQSet->Get( WMI_COOKER_RAW_FREQ_OBJ, 0, &VarFreqName, NULL );
			        	if (FAILED(dwStatus) && m_bUseWellKnownIfNeeded)
			        	{
			            	dwStatus = WBEM_NO_ERROR;
			            	VarFreqName = WMI_COOKER_REQ_FREQUENCY_PERFTIME;
			        	}				        
				    } 
				    else if (m_dwCounterType & PERF_TIMER_100NS)
				    {
				        dwStatus = pCookingClassQSet->Get( WMI_COOKER_RAW_FREQ_100NS, 0, &VarFreqName, NULL );
			        	if (FAILED(dwStatus) && m_bUseWellKnownIfNeeded)
			        	{
			            	dwStatus = WBEM_NO_ERROR;
			            	VarFreqName = WMI_COOKER_REQ_FREQUENCY_SYS100NS;
			        	}				        
				    } else 
				    {
				        dwStatus = pCookingClassQSet->Get( WMI_COOKER_RAW_FREQ_SYS, 0, &VarFreqName, NULL );
			        	if (FAILED(dwStatus) && m_bUseWellKnownIfNeeded)
			        	{
			            	dwStatus = WBEM_NO_ERROR;
			            	VarFreqName = WMI_COOKER_REQ_FREQUENCY_OBJECT;
			        	}				        
				    }

				    
				    if (SUCCEEDED(dwStatus))
				    { 
				        if (VarFreqName.vt == VT_BSTR)
				        {
					        dwStatus = pRawAccess->GetPropertyHandle( VarFreqName.bstrVal, &ct, &lHandle );
				        
					        if (SUCCEEDED(dwStatus))
					        {
	        	                m_pFrequencyProp = new CProperty( VarFreqName.bstrVal, lHandle, ct );

								if ( NULL == m_pFrequencyProp )
								{
									dwStatus = WBEM_E_OUT_OF_MEMORY;
								}			        
					        }

					    } else {
					        dwStatus = WBEM_E_TYPE_MISMATCH;
					    }
				    } else {
				        dwStatus = WBEM_S_NO_ERROR;
				    }
			    }
			}
		}

        //
        //  Get the Scale factor from ONLY the property Qualifier
        //
		if ( SUCCEEDED( dwStatus ) )
		{
		    _variant_t VarScale; // does not throw, simple container
			dwStatus = pCookingPropQualifierSet->Get( WMI_COOKER_SCALE_FACT, 0, &VarScale, NULL );

			if ( SUCCEEDED( dwStatus ) && (V_VT(&VarScale) == VT_I4))			 
			{
			    m_lScale = VarScale.intVal;			    
			}
			else 
			{
			    dwStatus = WBEM_S_NO_ERROR;
			}
		}


		// Get the Sample and Time windows value
		// =====================================

		if ( SUCCEEDED( dwStatus ) )
		{
			DWORD	dwSampleStatus = WBEM_NO_ERROR,
					dwTimeStatus = WBEM_NO_ERROR;

			_variant_t	vSampleProp; // does not throw, simple container
			_variant_t	vTimeProp;   // does not throw, simple container

			dwSampleStatus = pCookingPropQualifierSet->Get( WMI_COOKER_SAMPLE_WINDOW, 0, &vSampleProp, NULL );
			dwTimeStatus = pCookingPropQualifierSet->Get( WMI_COOKER_TIME_WINDOW, 0, &vTimeProp, NULL );


			if ( SUCCEEDED( dwSampleStatus ) && SUCCEEDED( dwTimeStatus ) )
			{
				dwStatus = WBEM_E_INVALID_PROPERTY;
			}
			else if ( SUCCEEDED( dwSampleStatus ) )
			{
				if ( vSampleProp.vt != VT_I4 )
				{
					dwStatus = E_FAIL;
				}
				else 
				{
					m_nSampleWindow = vSampleProp.intVal;					
			    }
			}
			else if ( SUCCEEDED( dwTimeStatus ) )
			{
				if ( vTimeProp.vt != VT_I4 )
					dwStatus = E_FAIL;
				else
					m_nTimeWindow = vTimeProp.intVal;
			}
			else
			{
				m_nSampleWindow = WMI_DEFAULT_SAMPLE_WINDOW;
			}
		}
	}

	return dwStatus;
}

WMISTATUS CCookingProperty::Cook( DWORD dwNumSamples, __int64* aRawCounter, __int64* aBaseCounter, __int64* aTimeStamp, __int64* pnResult )
{
	WMISTATUS dwStatus = WBEM_NO_ERROR;

	dwStatus = m_Cooker.CookRawValues( m_dwCounterType,
									   dwNumSamples,
									   aTimeStamp,
									   aRawCounter,
									   aBaseCounter,
									   m_nTimeFreq,
									   m_lScale,
									   pnResult );

	return dwStatus;
}

CProperty* CCookingProperty::GetRawCounterProperty()
{ 
	return m_pRawCounterProp; 
}

CProperty* CCookingProperty::GetBaseProperty()
{ 
	return m_pBaseProp; 
}

CProperty* CCookingProperty::GetTimeProperty()
{ 
	return m_pTimeProp; 
}

HRESULT 
CCookingProperty::SetFrequency(IWbemObjectAccess * pObjAcc){

    if (m_nTimeFreq == 0){
        // get the Frequency from the Raw Object
        if (m_pFrequencyProp){

            return GetPropValue(m_pFrequencyProp,pObjAcc,(__int64 *)&m_nTimeFreq);
            
        } else if (!(m_dwReqProp & REQ_FREQ)) { 
        
            return WBEM_NO_ERROR;
        } else {
        
            LARGE_INTEGER li;
            if (QueryPerformanceFrequency(&li)){
            
                m_nTimeFreq = li.QuadPart;
                return WBEM_NO_ERROR;
                
            } else {
                return  WBEM_E_INVALID_PARAMETER;
            }
            
        }        
    } else {
        return WBEM_NO_ERROR;
    }
    
}

unsigned __int64 CCookingProperty::GetFrequency(void){
    return m_nTimeFreq;
}


///////////////////////////////////////////////////////////////////////////////
//
//	CPropertySampleCache
//	====================
//
//	This class caches the sample data for a single property for a single 
//	instance
//
///////////////////////////////////////////////////////////////////////////////

CPropertySampleCache::CPropertySampleCache():
      m_aRawCounterVals(NULL),
	  m_aBaseCounterVals(NULL),
	  m_aTimeStampVals(NULL),
	  m_dwRefreshID(0)
{
}

CPropertySampleCache::~CPropertySampleCache(){

    if (m_aRawCounterVals) {
        delete [] m_aRawCounterVals;
    }
    if (m_aBaseCounterVals) {
        delete [] m_aBaseCounterVals;
    }
    if (m_aTimeStampVals) {
        delete [] m_aTimeStampVals;
    }
}


WMISTATUS CPropertySampleCache::SetSampleInfo( DWORD dwNumActiveSamples, DWORD dwMinReqSamples )
{
	WMISTATUS dwStatus = WBEM_NO_ERROR;

	m_dwNumSamples = 0;
	m_dwTotSamples = dwNumActiveSamples;

	m_aRawCounterVals = new __int64[dwNumActiveSamples];
	if (!m_aRawCounterVals)
		return WBEM_E_OUT_OF_MEMORY;
	memset( m_aRawCounterVals, 0, sizeof(__int64) *  dwNumActiveSamples );

	m_aBaseCounterVals = new __int64[dwNumActiveSamples];
	if (!m_aBaseCounterVals)
			return WBEM_E_OUT_OF_MEMORY;
	memset( m_aBaseCounterVals, 0, sizeof(__int64) *  dwNumActiveSamples );

	m_aTimeStampVals = new __int64[dwNumActiveSamples];
	if (!m_aTimeStampVals)
			return WBEM_E_OUT_OF_MEMORY;
	memset( m_aBaseCounterVals, 0, sizeof(__int64) *  dwNumActiveSamples );

	return dwStatus;
}

WMISTATUS CPropertySampleCache::SetSampleData( DWORD dwRefreshID, __int64 nRawCounter, __int64 nRawBase, __int64 nTimeStamp )
{
	WMISTATUS dwStatus = WBEM_NO_ERROR;

	if (dwRefreshID <= m_dwRefreshID){
	    return dwStatus;
	} else {
	    m_dwRefreshID = dwRefreshID;
	}

	if ( m_dwNumSamples < m_dwTotSamples )
	{
		m_dwNumSamples++;
	}
    
    if ( m_dwTotSamples >= 2 ) {
	    for (LONG i = (LONG)(m_dwTotSamples-2); i>=0; i--){
	        m_aRawCounterVals[i+1] = m_aRawCounterVals[i];
	        m_aBaseCounterVals[i+1] = m_aBaseCounterVals[i];
	        m_aTimeStampVals[i+1] = m_aTimeStampVals[i];
	    }
	}

	m_aRawCounterVals[0] = nRawCounter;
	m_aBaseCounterVals[0] = nRawBase;
	m_aTimeStampVals[0] = nTimeStamp;

	return dwStatus;
}

WMISTATUS CPropertySampleCache::GetData( DWORD* pdwNumSamples, __int64** paRawCounter, __int64** paBaseCounter, __int64** paTimeStamp )
{
	WMISTATUS dwStatus = WBEM_NO_ERROR;

	*pdwNumSamples = m_dwNumSamples;
	*paRawCounter = m_aRawCounterVals;
	*paBaseCounter = m_aBaseCounterVals;
	*paTimeStamp = m_aTimeStampVals;

	return dwStatus;
}

///////////////////////////////////////////////////////////////////////////////
//
//	CCookingInstance
//	================
//
//	The cooking instance - used to model an instance of a cooked object.  Each 
//	property maintains a cache of values that will be used to compute the 
//	final cooked value.
//
///////////////////////////////////////////////////////////////////////////////

CCookingInstance::CCookingInstance( IWbemObjectAccess *pCookingInstance, DWORD dwNumProps ) :
  m_wszKey( NULL ),
  m_aPropertySamples( NULL ),
  m_pCookingInstance( pCookingInstance ),
  m_pRawInstance( NULL ),
  m_dwNumProps( dwNumProps )
///////////////////////////////////////////////////////////////////////////////
//
//
//
//	Parameters:
//
//
///////////////////////////////////////////////////////////////////////////////
{
	if ( NULL != m_pCookingInstance ) 
	{
		m_pCookingInstance->AddRef(); 
		m_wszKey = ::GetKey( m_pCookingInstance );
	}

    if (dwNumProps) {
	    m_aPropertySamples = new CPropertySampleCache[dwNumProps];
	};
}


CCookingInstance::~CCookingInstance()
{
	if ( NULL != m_wszKey )
		delete [] m_wszKey;

	if ( NULL != m_pCookingInstance ) {
		m_pCookingInstance->Release(); 
    }

	if ( NULL != m_aPropertySamples )
		delete [] m_aPropertySamples;

	if ( NULL != m_pRawInstance ) {
		m_pRawInstance->Release();
    }
}

WMISTATUS CCookingInstance::InitProperty( DWORD dwProp, DWORD dwNumActiveSamples, DWORD dwMinReqSamples )
{
	return m_aPropertySamples[dwProp].SetSampleInfo( dwNumActiveSamples, dwMinReqSamples );
}

WMISTATUS CCookingInstance::SetRawSourceInstance( IWbemObjectAccess* pRawSampleSource )
{
	WMISTATUS dwStatus = WBEM_NO_ERROR;

	if ( NULL != m_pRawInstance )
	{
		m_pRawInstance->Release();
	}

	m_pRawInstance = pRawSampleSource;

	if ( NULL != m_pRawInstance )
	{
		m_pRawInstance->AddRef();
	}

	return dwStatus;
}

WMISTATUS CCookingInstance::GetRawSourceInstance( IWbemObjectAccess** ppRawSampleSource ) 
{ 
	WMISTATUS dwStatus = WBEM_NO_ERROR;

	*ppRawSampleSource = m_pRawInstance;

	if ( NULL != m_pRawInstance )
	{
		m_pRawInstance->AddRef();
	}

	return dwStatus;
}

IWbemObjectAccess* CCookingInstance::GetInstance() 
{ 
	if ( NULL != m_pCookingInstance ) 
		m_pCookingInstance->AddRef();

	return m_pCookingInstance; 
}

WMISTATUS CCookingInstance::AddSample( DWORD dwRefreshStamp, DWORD dwProp, __int64 nRawCounter, __int64 nRawBase, __int64 nTimeStamp )
{
	return m_aPropertySamples[dwProp].SetSampleData( dwRefreshStamp, nRawCounter, nRawBase, nTimeStamp );
}

WMISTATUS CCookingInstance::Refresh( IWbemObjectAccess* pRawData, IWbemObjectAccess** ppCookedData )
{
	WMISTATUS dwStatus = WBEM_NO_ERROR;

	return dwStatus;
}

WMISTATUS CCookingInstance::UpdateSamples()
{
	WMISTATUS dwStatus = WBEM_NO_ERROR;
	
	return dwStatus;
}

WMISTATUS CCookingInstance::CookProperty( DWORD dwProp, CCookingProperty* pProperty )
///////////////////////////////////////////////////////////////////////////////
//
//
//
//	Parameters:
//
//
///////////////////////////////////////////////////////////////////////////////
{
	WMISTATUS dwStatus = WBEM_NO_ERROR;
	
	DWORD		dwNumSamples = 0;
	__int64*	aRawCounter;
	__int64*	aBaseCounter;
	__int64*	aTimeStamp;
	__int64		nResult = 0;

	long lHandle = pProperty->GetHandle();

	dwStatus = m_aPropertySamples[dwProp].GetData( &dwNumSamples, &aRawCounter, &aBaseCounter, &aTimeStamp );

	if ( SUCCEEDED( dwStatus ) )
	{
#ifdef _VERBOSE	
	    {
	        WCHAR pBuff[256];
	        unsigned __int64 Freq = pProperty->GetFrequency();
	        wsprintfW(pBuff,L"PropName %s sample %d\n"
	                        L"Raw  %I64d %I64d\n"
	                        L"Base %I64d %I64d\n"
  	                        L"Time %I64d %I64d\n"
  	                        L"Freq %I64d\n",
	                 pProperty->GetName(),dwNumSamples,
	                 aRawCounter[0],aRawCounter[1],
	                 aBaseCounter[0],aBaseCounter[1],
	                 aTimeStamp[0],aTimeStamp[1],
	                 Freq);
	        OutputDebugStringW(pBuff);
	    }
#endif	    
	    
	    if (SUCCEEDED(dwStatus = pProperty->SetFrequency(m_pRawInstance))){
	    
		    dwStatus = pProperty->Cook( dwNumSamples, aRawCounter, aBaseCounter, aTimeStamp, &nResult );
		}
#ifdef _VERBOSE			
		{
	        char pBuff[128];
	        wsprintfA(pBuff,"Result %I64d dwStatus %08x\n",nResult,dwStatus);
		    OutputDebugStringA(pBuff);
		}
#endif		
	};

	if ( SUCCEEDED( dwStatus ) )
	{
		switch ( pProperty->GetType() )
		{
		case CIM_UINT32:
  	        dwStatus = m_pCookingInstance->WriteDWORD( lHandle, (DWORD) nResult );
			break;
		case CIM_UINT64:		
			dwStatus = m_pCookingInstance->WriteQWORD( lHandle, nResult );
			break;
		default:
		    dwStatus = WBEM_E_TYPE_MISMATCH;
		}
	};

	return dwStatus;
}

/////////////////////////////////////////////////////////////////////////
//
//
//	CEnumeratorCache
//
//
/////////////////////////////////////////////////////////////////////////

CEnumeratorCache::CEnumeratorCache() :	
	m_dwEnum( 0 )
///////////////////////////////////////////////////////////////////////////////
//
//
//
//	Parameters:
//
//
///////////////////////////////////////////////////////////////////////////////
{
    InitializeCriticalSection(&m_cs);
}

CEnumeratorCache::~CEnumeratorCache()
{
    EnterCriticalSection(&m_cs);
    DWORD i;
    for (i=0;i<m_apEnumerators.size();i++){
        CEnumeratorManager* pEnumMgr = m_apEnumerators[i];
        if (pEnumMgr)
      	    pEnumMgr->Release();
    }
    LeaveCriticalSection(&m_cs);
    DeleteCriticalSection(&m_cs);    
}

WMISTATUS CEnumeratorCache::AddEnum( LPCWSTR wszCookingClass,
									 IWbemClassObject* pCookedClass, 
									 IWbemClassObject* pRawClass,
									 IWbemHiPerfEnum* pCookedEnum, 
									 IWbemHiPerfEnum* pRawEnum, 
									 long lIDRaw, 
									 DWORD* pdwID )
///////////////////////////////////////////////////////////////////////////////
//
//
//
//	Parameters:
//
//
///////////////////////////////////////////////////////////////////////////////
{
	WMISTATUS dwStatus = WBEM_NO_ERROR;

	CEnumeratorManager* pEnumMgr = new CEnumeratorManager( wszCookingClass, pCookedClass, pRawClass, pCookedEnum, pRawEnum, lIDRaw );

    //
    CInCritSec ics(&m_cs);
    //
    
	if (pEnumMgr)
	{
	    if (SUCCEEDED(pEnumMgr->GetInithResult()))
	    {	
		    DWORD i;
		    for (i=0;i<m_apEnumerators.size();i++)
		    {
		        if(m_apEnumerators[i] == NULL)
		        {
		            m_apEnumerators[i] = pEnumMgr;
		            if (pdwID) 
			        {
			        	*pdwID = i;
		        	}
		        	break;
		        }
		    }
		    // we need to expand the array
		    if (i == m_apEnumerators.size())
		    {
		        try 
		        {
				    m_apEnumerators.push_back(pEnumMgr);
				    if (pdwID) 
				    {
				        *pdwID = m_apEnumerators.size()-1;
				    }
			    } 
			    catch (...) 
			    {
			        pEnumMgr->Release();
			        dwStatus = WBEM_E_OUT_OF_MEMORY;
			    }
		    }

	    }
	    else
	    {
    	    dwStatus = pEnumMgr->GetInithResult();
	    }
	    
	} else {
	    dwStatus = WBEM_E_OUT_OF_MEMORY;
	}

	return dwStatus;
}

WMISTATUS CEnumeratorCache::RemoveEnum( DWORD dwID , long * pRawId )
///////////////////////////////////////////////////////////////////////////////
//
//
//
//	Parameters:
//
//
///////////////////////////////////////////////////////////////////////////////
{
	WMISTATUS dwStatus = WBEM_NO_ERROR;

    //
    EnterCriticalSection(&m_cs);
    //
    
	if ( dwID < m_apEnumerators.size() ) {
	
	    CEnumeratorManager* pEnumMgr = m_apEnumerators[dwID];
	    m_apEnumerators[dwID] = NULL;

        *pRawId = pEnumMgr->GetRawId();
        
	    pEnumMgr->Release();
	   
	} else {
	    dwStatus = E_FAIL;
	}

    //
    LeaveCriticalSection(&m_cs);
    //
    
	return dwStatus;
}

WMISTATUS CEnumeratorCache::Refresh(DWORD dwRefreshId)
///////////////////////////////////////////////////////////////////////////////
//
//
//
//	Parameters:
//
//
///////////////////////////////////////////////////////////////////////////////
{
	WMISTATUS	dwStatus = WBEM_NO_ERROR;


    CEnumeratorManager** ppEnumMang =  new CEnumeratorManager*[m_apEnumerators.size()];
    wmilib::auto_buffer<CEnumeratorManager*> rm_(ppEnumMang);
    if (!ppEnumMang)
        return WBEM_E_OUT_OF_MEMORY;
    
    memset(ppEnumMang,0,sizeof(CEnumeratorManager*)*m_apEnumerators.size());
    
    DWORD j=0;
    DWORD i=0;

	{
	    CInCritSec ics(&m_cs);
    	
		for (i=0;i<m_apEnumerators.size();i++){
		
		    CEnumeratorManager*	pEnumMgr = m_apEnumerators[i];
		    if (pEnumMgr) 
		    {
		        pEnumMgr->AddRef();
		        ppEnumMang[j] = pEnumMgr;
		        j++;
		    }
		}
 
    }


	for (i=0;i<j;i++)
	{
	    dwStatus = ppEnumMang[i]->Refresh(dwRefreshId);
	    if (FAILED(dwStatus))
	    {	    
	        break;
	    }
	}

	for (i=0;i<j;i++)
	{
    	ppEnumMang[i]->Release();
	}

	return dwStatus;
}


/////////////////////////////////////////////////////////////////////////
//
//
//	CInstanceRecord
//
//
/////////////////////////////////////////////////////////////////////////

CInstanceRecord::CInstanceRecord( LPWSTR wszName, long lID )
   :m_lID( lID ),
    m_wszName(NULL)
{
	m_wszName = new WCHAR[ wcslen( wszName ) + 1];
	if (m_wszName)
	    wcscpy( m_wszName, wszName );
}

CInstanceRecord::~CInstanceRecord()
{
	if ( NULL != m_wszName )
	{
		delete [] m_wszName;
	}
}

/////////////////////////////////////////////////////////////////////////
//
//
//	CEnumeratorManager
//
//
/////////////////////////////////////////////////////////////////////////



CEnumeratorManager::CEnumeratorManager( LPCWSTR wszCookingClass,
									    IWbemClassObject* pCookedClass,
										IWbemClassObject* pRawClass,
									    IWbemHiPerfEnum* pCookedEnum, 
										IWbemHiPerfEnum* pRawEnum, 
										long lRawID ) 
:	m_pCookedClass( pCookedClass ),
	m_pRawEnum(pRawEnum),
	m_pCookedEnum( pCookedEnum ),
	m_pCooker(NULL),
	m_lRawID(lRawID),
	m_dwSignature('mMnE'),
	m_cRef(1),               //-------------- initial refcount
	m_dwVector(0)
///////////////////////////////////////////////////////////////////////////////
//
//
//
//	Parameters:
//
//
///////////////////////////////////////////////////////////////////////////////
{
#ifdef _VERBOSE
    {
        char pBuff[256];
        wsprintfA(pBuff,"CEnumeratorManager %08x\n",this);
        OutputDebugStringA(pBuff);
    }
#endif
	m_wszCookingClassName = new WCHAR[ wcslen( wszCookingClass ) + 1 ];

	if ( NULL != m_wszCookingClassName )
		wcscpy( m_wszCookingClassName, wszCookingClass );

	if ( NULL != m_pCookedClass )
		m_pCookedClass->AddRef();

	if ( NULL != m_pRawEnum )
		m_pRawEnum->AddRef();

	if ( NULL != m_pCookedEnum )
		m_pCookedEnum->AddRef();

    m_IsSingleton = IsSingleton(pRawClass);

    InitializeCriticalSection(&m_cs);

	m_InithRes = Initialize( pRawClass );
}

CEnumeratorManager::~CEnumeratorManager()
{
    m_dwSignature = 'gmne';
    
	if ( NULL != m_wszCookingClassName )
		delete m_wszCookingClassName;

    // one reference is hold by the CWMISimpleObjectCooker
	if ( NULL != m_pCookedClass ) {
		m_pCookedClass->Release();
    }

	if ( NULL != m_pRawEnum ) {
		m_pRawEnum->Release();
	}

	if ( NULL != m_pCookedEnum ){
		m_pCookedEnum->Release();
	}

    if (m_pCooker)
        delete m_pCooker;

    DeleteCriticalSection(&m_cs);        

#ifdef _VERBOSE
    {
        char pBuff[256];
        wsprintfA(pBuff,"~CEnumeratorManager %08x\n",this);
        OutputDebugStringA(pBuff);
    }
#endif    
        

}

LONG CEnumeratorManager::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

LONG CEnumeratorManager::Release()
{
    LONG lRet = InterlockedDecrement(&m_cRef);
    if (lRet == 0)
    {
        delete this;
    }

    return lRet;
}


WMISTATUS CEnumeratorManager::Initialize( IWbemClassObject* pRawClass )
///////////////////////////////////////////////////////////////////////////////
//
//
//
//	Parameters:
//
//
///////////////////////////////////////////////////////////////////////////////
{
	WMISTATUS	dwStatus;
	HRESULT hr1,hr2;


	IWbemObjectAccess*	pCookedAccess = NULL;
	IWbemObjectAccess*	pRawAccess = NULL;

	hr1 = m_pCookedClass->QueryInterface( IID_IWbemObjectAccess, (void**)&pCookedAccess );
	CAutoRelease	arCookedAccess( pCookedAccess );
		
	hr2 = pRawClass->QueryInterface( IID_IWbemObjectAccess, (void**)&pRawAccess );
	CAutoRelease	arRawAccess( pRawAccess );

    if (SUCCEEDED(hr1) && SUCCEEDED(hr2))
    { 
		m_pCooker = new CWMISimpleObjectCooker( m_wszCookingClassName, 
		                                        pCookedAccess, // acquired by CWMISimpleObjectCooker
		                                        pRawAccess );
    }

    if (m_pCooker == NULL)
    {
        dwStatus = WBEM_E_OUT_OF_MEMORY;
    } 
    else 
    {
        dwStatus = m_pCooker->GetLastHR();
    }
	
	return dwStatus;
}

ULONG_PTR hash_string (WCHAR * pKey)
{
    ULONG_PTR acc	= 0;
    ULONG_PTR i	= 0;
    WCHAR *this_char	= pKey;

    while (*this_char != NULL) {
        acc ^= *(this_char++) << i;
        i = (i + 1) % sizeof (void *);
    }

    return (acc<<1); // so we can save the LOWEST bit
}


WMISTATUS 
CEnumeratorManager::GetRawEnumObjects(std::vector<IWbemObjectAccess*, wbem_allocator<IWbemObjectAccess*> > & refArray,
                                      std::vector<ULONG_PTR, wbem_allocator<ULONG_PTR> > & refObjHashKeys)

///////////////////////////////////////////////////////////////////////////////
//
//
//
//	Parameters:
//
//
///////////////////////////////////////////////////////////////////////////////
{
	WMISTATUS dwStatus = WBEM_NO_ERROR;

	DWORD	dwRet = 0,
			dwNumRawObjects = 0;

	IWbemObjectAccess**	apObjAccess = NULL;

	dwStatus = m_pRawEnum->GetObjects( 0L, 0, apObjAccess, &dwRet);

	if ( WBEM_E_BUFFER_TOO_SMALL == dwStatus )
	{
		// Set the buffer size
		// ===================
		dwNumRawObjects = dwRet;

		apObjAccess = new IWbemObjectAccess*[dwNumRawObjects];
		memset( apObjAccess, 0, sizeof( apObjAccess ));

		if ( NULL != apObjAccess )
		{
			dwStatus = m_pRawEnum->GetObjects( 0L, dwNumRawObjects, apObjAccess, &dwRet );
		}
		else
		{
			dwStatus = WBEM_E_OUT_OF_MEMORY;
		}

		if ( SUCCEEDED( dwStatus ) )
		{
			try
		    {
		    	refArray.reserve(dwNumRawObjects);
		    	refObjHashKeys.reserve(dwNumRawObjects);
		    }
		    catch (...)
		    {
     		    dwStatus = WBEM_E_OUT_OF_MEMORY;
     		    dwNumRawObjects = 0;
		    }
		    
		    for (DWORD i=0;i<dwNumRawObjects;i++)
		    {
		        HRESULT hr1;
		        _variant_t VarKey; // does not throw, just container
		        hr1 = apObjAccess[i]->Get(L"__RELPATH",0,&VarKey,NULL,NULL);
		        if (SUCCEEDED(hr1))
		        {
		            DWORD Hash = hash_string(VarKey.bstrVal);
		            refObjHashKeys.push_back(Hash);
		            refArray.push_back(apObjAccess[i]);
		        } else {
		            // if we cannot give out the ownership of a pointer, release
		            apObjAccess[i]->Release();
		        }		        
		    }
		    
			delete [] apObjAccess;
		}
	}
	
	return dwStatus;
}


WMISTATUS 
CEnumeratorManager::UpdateEnums(
    std::vector<ULONG_PTR, wbem_allocator<ULONG_PTR> > & apObjKeyHash)
///////////////////////////////////////////////////////////////////////////
//
//
//	Parameters:
//
//
///////////////////////////////////////////////////////////////////////////
{
    // cyclic logic:
    // we have a 'circular array' of std::vector
    // and the m_dwVector is the index
    // circular increment of the index will decide 
    // who is the New and who is the Old
    std::vector<ULONG_PTR, wbem_allocator<ULONG_PTR> > & Old = m_Delta[m_dwVector];    
    m_dwVector = (m_dwVector+1)%2;
    m_Delta[m_dwVector].clear();
    m_Delta[m_dwVector] = apObjKeyHash;
    std::vector<ULONG_PTR, wbem_allocator<ULONG_PTR> > & New = m_Delta[m_dwVector];
    
    DWORD j,k;

    for (j=0;j<New.size();j++)
    {
        BOOL bFound = FALSE;
        for (k=0;k<Old.size();k++)
        {
            if (Old[k] == New[j])
            {
                Old[k] |= 1;
                bFound = TRUE;
                break;
            }           
        }
        if (!bFound)
        {
            New[j] |= 1; // ad the very NEW bit
        }
    }
    
    return WBEM_S_NO_ERROR;

}

WMISTATUS CEnumeratorManager::Refresh( DWORD dwRefreshStamp )
///////////////////////////////////////////////////////////////////////////////
//
//
//
//
///////////////////////////////////////////////////////////////////////////////
{
	WMISTATUS dwStatus = WBEM_NO_ERROR;

	std::vector<IWbemObjectAccess*, wbem_allocator<IWbemObjectAccess*> > apObjAccess;
	std::vector<ULONG_PTR, wbem_allocator<ULONG_PTR> > apObjHashKeys;

	dwStatus = GetRawEnumObjects( apObjAccess, apObjHashKeys );

	// calculate the Delta of the caches
    if (SUCCEEDED(dwStatus))
    {
        dwStatus = UpdateEnums(apObjHashKeys);
    }

    std::vector<ULONG_PTR, wbem_allocator<ULONG_PTR> > & New = m_Delta[m_dwVector];
    std::vector<ULONG_PTR, wbem_allocator<ULONG_PTR> > & Old = m_Delta[(m_dwVector-1)%2];

    {    
	    CInCritSec ics(&m_cs);
	    
		// Merge into the cache	
		if ( SUCCEEDED(dwStatus) )
		{
		    //
		    //  Elements in the New array with the bit set are really new
		    //
	        DWORD j;
	        for (j=0; j< New.size(); j++)
	        {
	            if (New[j] & 1)  // test the very new BIT
	            {
		            EnumCookId thisEnumCookId;
		            dwStatus = InsertCookingRecord( apObjAccess[j], &thisEnumCookId, dwRefreshStamp );
		            if (SUCCEEDED(dwStatus))
		            {
		                try {
		                m_mapID[New[j]] = thisEnumCookId;
		                } catch (...) {
		                    break;
		                }
		            }
		            else 
		            {
		                break;
		            }
		            //remove the bit
		            New[j] &= (~1);
	            }
	        }

	        for (j=0; j<Old.size(); j++)
	        {
	            if (Old[j] & 1)
	            {
	                Old[j] &= (~1); // remove the ALREADY_THERE bit
	            }
	            else
	            {
		            EnumCookId thisEnumCookId;
		            thisEnumCookId = m_mapID[Old[j]];
		            m_mapID.erase(Old[j]);
		            RemoveCookingRecord(&thisEnumCookId);
	            }
	        }
			m_pCooker->Recalc(dwRefreshStamp);		
		}

	}
	
    // in any case ....
	for (DWORD i=0;i<apObjAccess.size();i++)
	{
	    apObjAccess[i]->Release();
	};


	return dwStatus;
}

WMISTATUS 
CEnumeratorManager::InsertCookingRecord(                                         
                                        IWbemObjectAccess* pRawObject,
                                        EnumCookId * pEnumCookId,
                                        DWORD dwRefreshStamp)
///////////////////////////////////////////////////////////////////////////////
//
//
//
//	Parameters:
//
//
///////////////////////////////////////////////////////////////////////////////
{
	WMISTATUS dwStatus = WBEM_NO_ERROR;

	if (!pRawObject || !pEnumCookId)
	{
	    return WBEM_E_INVALID_PARAMETER;
	}

	IWbemObjectAccess*	pCookedObject = NULL;

	long lID = 0;

	dwStatus = CreateCookingObject( pRawObject, &pCookedObject );
	CAutoRelease  rm1(pCookedObject);

	if ( SUCCEEDED( dwStatus ) )
	{
		dwStatus = m_pCooker->SetCookedInstance( pCookedObject, &lID );

		if ( SUCCEEDED( dwStatus ) )
		{
			dwStatus = m_pCooker->BeginCooking( lID, pRawObject,dwRefreshStamp);
		}
	}

	if ( SUCCEEDED( dwStatus ) )
	{
        DWORD dwTarget;
        long EnumId = lID;

	    dwStatus = m_pCookedEnum->AddObjects( 0L, 1, &EnumId, &pCookedObject );
	    if (SUCCEEDED(dwStatus))
	    {
	        pEnumCookId->CookId = lID;
	        pEnumCookId->EnumId = EnumId;
            m_dwUsage++;
	    }
	    else
	    {
	        pEnumCookId->CookId = 0;
	        pEnumCookId->EnumId = 0;		    
	    }
	}

	return dwStatus;
}




WMISTATUS CEnumeratorManager::CreateCookingObject( 
		IWbemObjectAccess* pRawObject, 
		IWbemObjectAccess** ppCookedObject )
///////////////////////////////////////////////////////////////////////////////
//
//	Create a new instance of the cooked object and set the key(s) based on the 
//	raw object's key(s) value.
//
//	Parameters:
//	
//		pRawObject		- The new object's corresponding raw object
//		ppCookedObject	- The new cooked object
//
///////////////////////////////////////////////////////////////////////////////		
{
		
    HRESULT hr = WBEM_E_FAILED;
    IWbemClassObject * pCookedInst = NULL;

    hr = m_pCookedClass->SpawnInstance(0,&pCookedInst);
    CAutoRelease rm1(pCookedInst);
    
    if (SUCCEEDED(hr) &&
        !m_IsSingleton){

        // get the 'list' of all the key property
        // if you haven't got it in the past
        if (m_pKeyProps.size() == 0)
        {
	        hr = pRawObject->BeginEnumeration(WBEM_FLAG_KEYS_ONLY);
	        if (SUCCEEDED(hr))
	        {
	            BSTR bstrName;
	            
	            while(WBEM_S_NO_ERROR == pRawObject->Next(0,&bstrName,NULL,NULL,NULL))
	            {
	                try
	                {
	                    m_pKeyProps.push_back(bstrName);
	                }
	                catch (...)
	                {
	                    hr = WBEM_E_OUT_OF_MEMORY;
	                };
	                SysFreeString(bstrName);
	            };
	            
	            pRawObject->EndEnumeration();
	        }
        }

        // copy all the key properties from the Raw to the cooked instance
        if (m_pKeyProps.size() > 0 && SUCCEEDED(hr))
        {        
            for(int i=0;i<m_pKeyProps.size();i++)
            {
                // does not thorow, just a container
                _variant_t VarVal;
                CIMTYPE ct;
                hr = pRawObject->Get(m_pKeyProps[i],0,&VarVal,&ct,NULL);
                if (SUCCEEDED(hr))
                {
                    hr = pCookedInst->Put(m_pKeyProps[i],0,&VarVal,0);
                    
                    if (FAILED(hr))
                    {
                        break;
                    }
                } 
                else 
                {
                    break;
                }
                VarVal.Clear();
            }
        } else {
        
            hr = WBEM_E_INVALID_CLASS;
            
        }
    };
    
    if (SUCCEEDED(hr)){
        hr = pCookedInst->QueryInterface( IID_IWbemObjectAccess, (void**)ppCookedObject );
    }
 
    return hr;
}

WMISTATUS CEnumeratorManager::RemoveCookingRecord( EnumCookId * pEnumCookID )
///////////////////////////////////////////////////////////////////////////////
//
//
//
//	Parameters:
//
//
///////////////////////////////////////////////////////////////////////////////
{
    if (!pEnumCookID)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    
	WMISTATUS dwStatus = WBEM_NO_ERROR;

	dwStatus = m_pCookedEnum->RemoveObjects( 0L, 1, &pEnumCookID->EnumId );

    m_pCooker->StopCooking(pEnumCookID->CookId);
    
    m_pCooker->Remove(pEnumCookID->CookId);


	--m_dwUsage;
	
	return dwStatus;
}


///////////////////////////////////////////////////////////////////////
//
//
//  Predicate Function for the std::sort
//
///////////////////////////////////////////////////////////////////////

bool Pr(IWbemObjectAccess* pFirst,IWbemObjectAccess* pSec){

    
	WCHAR * pStr1 = GetKey(pFirst);
	WCHAR * pStr2 = GetKey(pSec);

	int res = -1; // to force true when GetKey fails

	if (pStr1 && pStr2) 
	{
	     res = _wcsicmp(pStr1,pStr2);
    }

    if (pStr1){
	    delete [] pStr1;
	}
	if (pStr2){
	    delete [] pStr2;
	}
	
	return (res<0);
}

WMISTATUS CEnumeratorManager::SortRawArray(std::vector<IWbemObjectAccess*, wbem_allocator<IWbemObjectAccess*> > & refArray )
///////////////////////////////////////////////////////////////////////////////
//
//
//
//	Parameters:
//
//
///////////////////////////////////////////////////////////////////////////////
{
	WMISTATUS dwStatus = WBEM_NO_ERROR;

    std::sort(refArray.begin(),refArray.end(),Pr);

	return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmicooker\factory.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    Factory.h

Abstract:

    Standard class factory implementation

History:

    a-dcrews	01-Mar-00	Created

--*/

//////////////////////////////////////////////////////////////
//
//	CClassFactory
//
//////////////////////////////////////////////////////////////

class CClassFactory : public IClassFactory
{
protected:
	long	m_lRef;

public:
	CClassFactory() : m_lRef(0) {}

	// Standard COM methods
	// ====================

	STDMETHODIMP QueryInterface(REFIID riid, void** ppv);
	STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	// IClassFactory COM interfaces
	// ============================

	STDMETHODIMP CreateInstance(
		/* [in] */ IUnknown* pUnknownOuter, 
		/* [in] */ REFIID iid, 
		/* [out] */ LPVOID *ppv);	

	STDMETHODIMP LockServer(
		/* [in] */ BOOL bLock);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmicooker\factory.cpp ===
////////////////////////////////////////////////////////////////////////
//
//	Factory.cpp
//
//	Module:	WMI high performance provider sample code
//
//	This is a standard class factory implementation for the CHiPerfProvider
//	object.  
//
//  History:
//	a-dcrews      12-Jan-99		Created
//
//	
//  Copyright (c) 1999-2001 Microsoft Corporation
//
////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "Provider.h"
#include "Factory.h"

extern long g_lObjects;
extern long g_lLocks;

//////////////////////////////////////////////////////////////
//
//
//	CClassFactory
//
//
//////////////////////////////////////////////////////////////

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void** ppv)
//////////////////////////////////////////////////////////////
//
//	Standard QueryInterface
//
//	Parameters:
//		riid	- the ID of the requested interface
//		ppv		- a pointer to the interface pointer
//
//////////////////////////////////////////////////////////////
{
    if(riid == IID_IUnknown)
        *ppv = (LPVOID)(IUnknown*)this;
    else if(riid == IID_IClassFactory)
        *ppv = (LPVOID)(IClassFactory*)this;
	else return E_NOINTERFACE;

	((IUnknown*)*ppv)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
//////////////////////////////////////////////////////////////
//
//	Standard COM AddRef
//
//////////////////////////////////////////////////////////////
{
    return InterlockedIncrement(&m_lRef);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
//////////////////////////////////////////////////////////////
//
//	Standard COM Release
//
//////////////////////////////////////////////////////////////
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;

    return lRef;
}

STDMETHODIMP CClassFactory::CreateInstance(
		/* [in] */ IUnknown* pUnknownOuter, 
		/* [in] */ REFIID iid, 
		/* [out] */ LPVOID *ppv)
//////////////////////////////////////////////////////////////
//
//	Standard COM CreateInstance
//
//////////////////////////////////////////////////////////////
{
	HRESULT hRes;
	CHiPerfProvider *pProvider = NULL;

	*ppv = NULL;

	// We do not support aggregation
	// =============================

	if (pUnknownOuter)
		return CLASS_E_NOAGGREGATION;

	// Create the provider object
	// ==========================

	pProvider = new CHiPerfProvider;

	if (!pProvider)
		return E_OUTOFMEMORY;

	// Retrieve the requested interface
	// ================================

	hRes = pProvider->QueryInterface(iid, ppv);
	if (FAILED(hRes))
	{
		delete pProvider;
		return hRes;
	}

	return S_OK;
}

STDMETHODIMP CClassFactory::LockServer(
		/* [in] */ BOOL bLock)
//////////////////////////////////////////////////////////////
//
//	Standard COM LockServer
//
//////////////////////////////////////////////////////////////
{
	if (bLock)
		InterlockedIncrement(&g_lLocks);
	else
		InterlockedDecrement(&g_lLocks);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmicooker\cache.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    Cache.h

Abstract:

	Contains all caching classes and objects.

History:

    a-dcrews	01-Mar-00  	Created
    
    ivanbrug    23-Jun-2000  mostly rewritten

--*/

#ifndef _CACHE_H_
#define _CACHE_H_

#include <windows.h>
#include <wbemcli.h>
#include <wbemint.h>
#include <wstlallc.h>

#include "RawCooker.h"
#include "CookerUtils.h"
#include "DynArray.h"

#include <wstring.h>
#include <map>
#include <vector>
#include <functional>

///////////////////////////////////////////////////////////////////////////////
//
//	Macro Definitions
//
///////////////////////////////////////////////////////////////////////////////

#define WMI_COOKER_CACHE_INCREMENT	8	// The cache size adjustment increment 

///////////////////////////////////////////////////////////////////////////////
//
//	CProperty
//	=========
//
//	The base property - used for raw properties and the base 
//	class for the CookedProperty.
//
///////////////////////////////////////////////////////////////////////////////

class CProperty
{
protected:
	LPWSTR				m_wszName;			// The property name
	long				m_lPropHandle;		// The property handle
	CIMTYPE				m_ct;

public:
	CProperty( LPWSTR wszName, long lHandle, CIMTYPE ct );
	~CProperty();

	LPWSTR GetName();
	CIMTYPE GetType();
	long GetHandle();
};

///////////////////////////////////////////////////////////////////////////////
//
//	CCookingProperty
//	================
//
//	The cooked property - used to model the data required to
//	cook a property of a cooekd class
//
///////////////////////////////////////////////////////////////////////////////

class CCookingProperty : public CProperty
{
	DWORD				m_dwCounterType;	// Counter type
	DWORD               m_dwReqProp;        // which property are needed to perform calculation
	CRawCooker			m_Cooker;			// The cooker object

	CProperty*			m_pRawCounterProp;	// The raw counter property
	CProperty*			m_pTimeProp;		// The raw time property
	CProperty*			m_pFrequencyProp;   // The raw frequency property
	
	CProperty*			m_pBaseProp;		// The raw base property OPTIONAL for most counters

	__int32				m_nSampleWindow;	// The number of samples used for the computation
	__int32				m_nTimeWindow;		// The period used for the samples

	unsigned __int64	m_nTimeFreq;		// The timer frequency;
	long                m_lScale;           // The Scale factor (10 ^ (m_lScale))
    BOOL                m_bUseWellKnownIfNeeded;	

public:
	CCookingProperty( LPWSTR wszName, 
	                  DWORD dwCounterType, 
	                  long lPropHandle, 
	                  CIMTYPE ct,
	                  DWORD dwReqProp,
	                  BOOL bUseWellKnownIfNeeded);
	virtual ~CCookingProperty();

	WMISTATUS Initialize( IWbemQualifierSet* pCookingPropQualifierSet, 
	                      IWbemObjectAccess* pRawAccess,
	                      IWbemQualifierSet* pCookingClassQSet);

	WMISTATUS Cook( DWORD dwNumSamples, 
	                __int64* aRawCounter, 
	                __int64* aBaseCounter, 
	                __int64* aTimeStamp, 
	                __int64* pnResult );

	CProperty* GetRawCounterProperty();
	CProperty* GetBaseProperty();
	CProperty* GetTimeProperty();

    HRESULT SetFrequency(IWbemObjectAccess * pObjAcc);
    unsigned __int64 GetFrequency(void);
    BOOL IsReq(DWORD ReqProp) { return (m_dwReqProp&ReqProp); };

	DWORD NumberOfActiveSamples() { return m_nSampleWindow; };
	DWORD MinSamplesRequired() { return m_nSampleWindow; };

};

///////////////////////////////////////////////////////////////////////////////
//
//	CPropertySampleCache
//	====================
//
//	For every property in each instance, we must maintain a history of
//	previous samples for the cooking.  The type of cooking determines the 
//	number of required samples
//
///////////////////////////////////////////////////////////////////////////////

class CPropertySampleCache
{
	DWORD				m_dwNumSamples;		// The number of current samples
	DWORD				m_dwTotSamples;		// The size of the sample array
	DWORD               m_dwRefreshID;

	__int64*			m_aRawCounterVals;	// The array of raw counter values
	__int64*			m_aBaseCounterVals;	// The array of base counter values
	__int64*			m_aTimeStampVals;	// The array of timestamp values

public:
    CPropertySampleCache();
    ~CPropertySampleCache();

	WMISTATUS SetSampleInfo( DWORD dwNumActiveSamples, DWORD dwMinReqSamples );
	WMISTATUS SetSampleData( DWORD dwRefreshID, __int64 nRawCounter, __int64 nRawBase, __int64 nTimeStamp );
	WMISTATUS GetData( DWORD* pdwNumSamples, __int64** paRawCounter, __int64** paBaseCounter, __int64** paTimeStamp );
};

///////////////////////////////////////////////////////////////////////////////
//
//	CCookingInstance
//	================
//
//	The cooking instance - used to model an instance of a cooked object.  Each 
//	property maintains a cache of values that will be used to compute the 
//	final cooked value.
//
///////////////////////////////////////////////////////////////////////////////

class CCookingInstance
{
	LPWSTR					m_wszKey;						// The instance key

	IWbemObjectAccess*		m_pCookingInstance;				// Cooking instance data
	IWbemObjectAccess*		m_pRawInstance;					// Raw sample source

	CPropertySampleCache*	m_aPropertySamples;				// The cache of property samples for this instance
	DWORD					m_dwNumProps;	
	
public:
	CCookingInstance( IWbemObjectAccess *pCookingInstance, DWORD dwNumProps );
	virtual ~CCookingInstance();

	WMISTATUS InitProperty( DWORD dwProp, DWORD dwNumActiveSamples, DWORD dwMinReqSamples );

	WMISTATUS SetRawSourceInstance( IWbemObjectAccess* pRawSampleSource );
	WMISTATUS GetRawSourceInstance( IWbemObjectAccess** ppRawSampleSource );

	WMISTATUS AddSample( DWORD dwRefresherInc, DWORD dwProp, __int64 nRawCounter, __int64 nRawBase, __int64 nTimeStamp );

	WMISTATUS GetCachedSamples( IWbemObjectAccess** ppOldSample, IWbemObjectAccess** ppNewSample );
	IWbemObjectAccess* GetInstance();

	WMISTATUS UpdateSamples();
	WMISTATUS CookProperty( DWORD dwProp, CCookingProperty* pProperty );

	LPWSTR	GetKey() { return m_wszKey; }
	WMISTATUS Refresh( IWbemObjectAccess* pRawData, IWbemObjectAccess** ppCookedData );

       BOOL IsValid() {
               return (m_dwNumProps && m_aPropertySamples);
       };
};

///////////////////////////////////////////////////////////////////////////////
//
//	CRecord
//	=======
//
///////////////////////////////////////////////////////////////////////////////

template<class T>
class CRecord
{
	static long		m_lRefIDGen;			// The ID generator
	long			m_lID;					// Instance ID
	CRecord*		m_pNext;				// The next pointer in the list

public:
	CRecord() : m_lID( m_lRefIDGen++ ), m_pNext( NULL ) {}
	virtual ~CRecord() {}

	void SetNext( CRecord*	pRecord ) { m_pNext = pRecord; }
	void SetID( long lID ) { m_lID = lID; }

	CRecord* GetNext() { return m_pNext; }
	long GetID() { return m_lID; }

	virtual T* GetData() = 0;
};

///////////////////////////////////////////////////////////////////////////////
//
//	CUnkRecord
//	==========
//
///////////////////////////////////////////////////////////////////////////////

template<class T>
class CUnkRecord : public CRecord<T>
{
	T*	m_pUnk;

public:
	CUnkRecord( T* pUnk ) : m_pUnk( pUnk ) {}
	~CUnkRecord(){ if ( NULL != m_pUnk ) m_pUnk->Release(); }

	T* GetData(){ if ( NULL != m_pUnk ) m_pUnk->AddRef(); return m_pUnk; }
};

///////////////////////////////////////////////////////////////////////////////
//
//	CObjRecord
//	==========
//
//	A hidden class used by the cache to manage elements
//
///////////////////////////////////////////////////////////////////////////////

template<class T>
class CObjRecord : public CRecord<T>
{
	WCHAR*	m_wszKey;
	T*	m_pObj;

public:
	CObjRecord( T* pObj, WCHAR* wszKey ) : m_pObj( pObj ), m_wszKey( NULL ) 
	{
		if ( NULL != wszKey )
		{
			m_wszKey = new WCHAR[ wcslen( wszKey ) + 1 ];
			wcscpy( m_wszKey, wszKey );
		}
	}

	~CObjRecord() 
	{ 
		if ( NULL != m_pObj ) delete m_pObj; 
		if ( NULL != m_wszKey ) delete m_wszKey;
	}

	T* GetData(){ return m_pObj; }

	bool IsValueByKey( WCHAR* wszKey )
	{
		return ( 0 == _wcsicmp( m_wszKey, wszKey ) );
	}
};


///////////////////////////////////////////////////////////////////////////////
//
//	CCache
//	======
//
// BT - base type
// RT - record type
//
///////////////////////////////////////////////////////////////////////////////

template<class BT, class RT>
class CCache
{
	RT*		m_pHead;		// Head of list
	RT*		m_pTail;		// Tail of list
	RT*		m_pEnumNode;	// Enumerator pointer

public:

	CCache();
	virtual ~CCache();

	WMISTATUS Add( BT* pData, WCHAR* wszKey, long* plID );
	WMISTATUS Remove( long lID );
	WMISTATUS RemoveAll();

	WMISTATUS	GetData( long lID, BT** ppData );

	WMISTATUS BeginEnum();
	WMISTATUS Next( BT** ppData );
	WMISTATUS EndEnum();

	bool FindByKey( WCHAR* wszKey, BT* pData );
};

template<class T>
long CRecord<T>::m_lRefIDGen = 0;

template<class BT, class RT>
CCache<BT,RT>::CCache() : m_pHead( NULL ), m_pTail( NULL ), m_pEnumNode( NULL )
{
}

template<class BT, class RT>
CCache<BT,RT>::~CCache() 
{
	RT*	pNode = m_pHead;
	RT*	pNext = NULL;

	while ( NULL != pNode )
	{
		pNext = (RT*)pNode->GetNext();
		delete pNode;
		pNode = pNext;
	}
};

template<class BT, class RT>
WMISTATUS CCache<BT,RT>::Add( BT *pData, WCHAR* wszKey, long* plID )
{
	WMISTATUS dwStatus = S_OK;

	if ( NULL == pData )
	{
		dwStatus = WBEM_E_INVALID_PARAMETER;
	}

	if ( SUCCEEDED( dwStatus ) )
	{
		RT* pNewRecord = new RT( pData, wszKey );

		if ( NULL != pNewRecord )
		{
			if ( NULL == m_pHead )
			{
				m_pHead = pNewRecord;
				m_pTail = pNewRecord;
			}
			else
			{
				m_pTail->SetNext( pNewRecord );
				m_pTail = pNewRecord;
			}

			*plID = pNewRecord->GetID();
		}
		else
		{
			dwStatus = WBEM_E_OUT_OF_MEMORY;
		}
	}

	return dwStatus;
};

template<class BT, class RT>
WMISTATUS CCache<BT,RT>::Remove( long lID )
{
	WMISTATUS dwStatus = S_FALSE;

	RT*	pNode = m_pHead;
	RT*	pNext = (RT*)pNode->GetNext();
	RT*	pPrev = NULL;

	while ( NULL != pNode )
	{
		if ( pNode->GetID() == lID )
		{
			if ( NULL == pNext )
				m_pTail = pPrev;

			if ( NULL == pPrev )
				m_pHead = pNext;
			else
				pPrev->SetNext( pNext );

			delete pNode;

			dwStatus = S_OK;
		}

		pPrev = pNode;
		pNode = pNext;

		if ( NULL != pNode )
			pNext = (RT*)pNode->GetNext();
	}

	return dwStatus;
};

template<class BT, class RT>
WMISTATUS CCache<BT,RT>::RemoveAll()
{
	WMISTATUS dwStatus = S_FALSE;

	RT*	pNode = m_pHead;
	RT*	pNext = NULL;

	while ( NULL != pNode )
	{
		pNext = (RT*)pNode->GetNext();
		delete pNode;
		pNode = pNext;
	}

	m_pHead = m_pTail = NULL;
	
	return dwStatus;
};

template<class BT, class RT>
WMISTATUS	CCache<BT,RT>::GetData( long lID, BT** ppData )
{
	WMISTATUS dwStatus = S_FALSE;

	RT*	pNode = m_pHead;

	while ( NULL != pNode )
	{
		if ( pNode->GetID() == lID )
		{
			*ppData = pNode->GetData();
			dwStatus = S_OK;
			break;
		}
		else
		{
			pNode = (RT*)pNode->GetNext();
		}
	}

	return dwStatus;

};

template<class BT, class RT>
WMISTATUS CCache<BT,RT>::BeginEnum()
{
	WMISTATUS dwStatus = S_OK;

	m_pEnumNode = m_pHead;

	return dwStatus;
};

template<class BT, class RT>
WMISTATUS CCache<BT,RT>::Next( BT** ppData )
{
	WMISTATUS dwStatus = WBEM_S_FALSE;

	if ( NULL != m_pEnumNode )
	{
		*ppData = m_pEnumNode->GetData();
		m_pEnumNode = (RT*)m_pEnumNode->GetNext();
		dwStatus = S_OK;
	}

	return dwStatus;
};

template<class BT, class RT>
WMISTATUS CCache<BT,RT>::EndEnum()
{
	WMISTATUS dwStatus = S_OK;

	m_pEnumNode = NULL;

	return dwStatus;
};

template<class BT, class RT>
bool CCache<BT,RT>::FindByKey( WCHAR* wszKey, BT* pData )
{
	BT	Data;
	bool bRet = FALSE;

	BeginEnum();

	while( WBEM_S_FALSE != Next( &Data ) )
	{
		if ( pData->IsValueByKey( wszKey ) )
		{
			*pData = Data;
			bRet = TRUE;
			break;
		}
	}

	EndEnum();

	return bRet;
};

///////////////////////////////////////////////////////////////
//
//	CInstanceCache
//	==============
//
///////////////////////////////////////////////////////////////



class CInstanceCache : public CCache<CCookingInstance,CObjRecord<CCookingInstance> >
{
public:
};


///////////////////////////////////////////////////////////////
//
//	CEnumInstanceRecord
//	===================
//
///////////////////////////////////////////////////////////////

class CInstanceRecord
{
	long	m_lID;
	LPWSTR	m_wszName;

public:
	CInstanceRecord( LPWSTR wszName, long lID );
	virtual ~CInstanceRecord();

	long GetID(){ return m_lID; }
	LPWSTR GetKey(){ return m_wszName; }
};


//
//  used to add/remove an instance from the coooker
//  and from the fastprox enumerator
//

typedef struct tagEnumCookId {
    long CookId;
    long EnumId;
} EnumCookId;


///////////////////////////////////////////////////////////////
//
//	CEnumeratorManager
//	==================
//
///////////////////////////////////////////////////////////////

class CWMISimpleObjectCooker;

class BstrAlloc : public wbem_allocator<WString>
{
};

class CEnumeratorManager
// Manages a single enumerator
{
    DWORD                   m_dwSignature;
    LONG                    m_cRef;
    HRESULT                 m_InithRes;
    CRITICAL_SECTION        m_cs;
	
	CWMISimpleObjectCooker*	m_pCooker;			// The class' cooker
	long					m_lRawID;			// RawID
	IWbemHiPerfEnum*		m_pRawEnum;			// The hiperf cooked enumerator
	IWbemHiPerfEnum*		m_pCookedEnum;		// The hiperf cooked enumerator

	IWbemClassObject*	 	m_pCookedClass;		// The class definition for the cooking class

	std::vector<WString,BstrAlloc>    m_pKeyProps;
	WCHAR*					m_wszCookingClassName;
    BOOL                    m_IsSingleton;

    // to keep track of the differences 
    //  between the raw enum and our enum
    DWORD m_dwUsage;
	std::map< ULONG_PTR , EnumCookId , std::less<ULONG_PTR> ,wbem_allocator<EnumCookId> > m_mapID;
    std::vector< ULONG_PTR , wbem_allocator<ULONG_PTR> > m_Delta[2];
    DWORD m_dwVector;

    // members
	WMISTATUS Initialize( IWbemClassObject* pRawClass );							

	WMISTATUS CreateCookingObject( IWbemObjectAccess* pRawObject, IWbemObjectAccess** ppCookedObject );

	WMISTATUS InsertCookingRecord( IWbemObjectAccess* pRawObject, EnumCookId * pStruct, DWORD dwRefreshStamp );

	WMISTATUS RemoveCookingRecord( EnumCookId * pEnumCookId );

	WMISTATUS GetRawEnumObjects( std::vector<IWbemObjectAccess*, wbem_allocator<IWbemObjectAccess*> > & refArray,
	                             std::vector<ULONG_PTR, wbem_allocator<ULONG_PTR> > & refObjHashKeys);

	WMISTATUS SortRawArray(std::vector<IWbemObjectAccess*, wbem_allocator<IWbemObjectAccess*> > & refArray );

	WMISTATUS UpdateEnums(std::vector<ULONG_PTR, wbem_allocator<ULONG_PTR> > & apObjAccess);
	
public:
	CEnumeratorManager( LPCWSTR wszCookingClass, IWbemClassObject* pCookedClass, IWbemClassObject* pRawClass, IWbemHiPerfEnum* pCookedEnum, IWbemHiPerfEnum* pRawEnum, long lRawID );
	virtual ~CEnumeratorManager();

	HRESULT GetInithResult(){ return m_InithRes; };

	WMISTATUS Refresh( DWORD dwRefreshStamp );
	long GetRawId(void){  return m_lRawID; };
	LONG AddRef();
	LONG Release();
	
};

///////////////////////////////////////////////////////////////
//
//	CEnumeratorCache
//	================
//
///////////////////////////////////////////////////////////////

class CEnumeratorCache
{
	DWORD				m_dwRefreshStamp;			// The refresh counter
	DWORD				m_dwEnum;					// The enumerator index

	std::vector<CEnumeratorManager*, wbem_allocator<CEnumeratorManager*> > m_apEnumerators;
	CRITICAL_SECTION    m_cs;

	WMISTATUS Initialize();

public:
	CEnumeratorCache();
	virtual ~CEnumeratorCache();

	WMISTATUS AddEnum( 
		LPCWSTR wszCookingClass, 
		IWbemClassObject* pCookedClass, 
		IWbemClassObject* pRawClass,
		IWbemHiPerfEnum* pCookedEnum, 
		IWbemHiPerfEnum* pRawEnum, 
		long lID, 
		DWORD* pdwID );

	WMISTATUS RemoveEnum( DWORD dwID , long * pRawId);

	WMISTATUS Refresh(DWORD dwRefreshStamp);
};

//  
//  Simple Cache based on the std::map
//  It will use the ID semantics:
//  Insertion will return an ID that need to be 
//  used for deletion
//  ids are unique for the lifetime of the Cache object
//

template <class T>
class IdCache {

private:

    std::map<DWORD, T> m_map;
    DWORD m_NextId;
	std::map<DWORD, T>::iterator m_it;
	CRITICAL_SECTION m_cs;

public:
	IdCache():m_NextId(0){
	    InitializeCriticalSection(&m_cs);
	};	
	virtual ~IdCache(){
	    DeleteCriticalSection(&m_cs);
	};
	void Lock(){
	    EnterCriticalSection(&m_cs);
	}
	void Unlock(){
	    LeaveCriticalSection(&m_cs);
	};

    // traditional interfaces
    HRESULT Add( DWORD * pId, T Elem);
	HRESULT GetData(DWORD Id, T * pElem);
    HRESULT Remove(DWORD Id, T * pRemovedElem);

    // before calling this, delete the elements !!!!
    HRESULT RemoveAll(void);
    
	// Enumerator Style
    HRESULT BeginEnum(void);
	HRESULT Next(T * pElem);
    HRESULT EndEnum(void);
};


template <class T>
HRESULT
IdCache<T>::Add( DWORD * pId, T Elem){
        HRESULT hr;
        Lock();
		if (pId) {

			std::map<DWORD, T>::iterator it = m_map.find(m_NextId);    

			if (it != m_map.end()) {

				// should never happen
				hr =  E_FAIL;

			} else {
				
                m_map[m_NextId] = Elem;
		        *pId = m_NextId;

		        InterlockedIncrement((PLONG)&m_NextId);

		        hr = WBEM_S_NO_ERROR;
			}
			
		} else {
			hr = WBEM_E_INVALID_PARAMETER;
		}
        Unlock();
		return hr;
}

template <class T>
HRESULT
IdCache<T>::GetData(DWORD Id, T * pElem){

        HRESULT hr = WBEM_S_NO_ERROR;
        Lock();
        std::map<DWORD, T>::iterator it = m_map.find(Id);    

        if (it != m_map.end()){

            *pElem = (*it).second;

		} else {
           hr = WBEM_E_NOT_FOUND;
		}
        Unlock();
        return hr;
}

template <class T>
HRESULT
IdCache<T>::Remove(DWORD Id, T * pRemovedElem){

        HRESULT hr = WBEM_S_NO_ERROR;
        Lock();
        if (pRemovedElem) {

            std::map<DWORD, T>::iterator it = m_map.find(Id);

            if (it != m_map.end()) {

		        *pRemovedElem =  (*it).second;			
                m_map.erase(it);

			} else {
			     hr = WBEM_E_NOT_FOUND;
			}

		} else {
            hr = WBEM_E_INVALID_PARAMETER;
		}
        Unlock();
		return hr;

}

//
// DEVDEV Empty the cache before removing from std::map
//
template <class T>
HRESULT 
IdCache<T>::RemoveAll(void){
        Lock();
		m_map.erase(m_map.begin(),m_map.end());
		Unlock();
		return  WBEM_S_NO_ERROR;
	};

//
// DEVDEV Consider using Lock if no exception ....
//
template <class T>
HRESULT 
IdCache<T>::BeginEnum(void){
    Lock();
	m_it = m_map.begin();
	return WBEM_S_NO_ERROR;
}

template <class T>
HRESULT
IdCache<T>::Next(T * pElem){
        HRESULT hr;
        
        if (pElem){
		    if (m_it == m_map.end()){
			    hr = WBEM_S_NO_MORE_DATA;
			} else {
			    * pElem = (*m_it).second;
				++m_it;
				hr = WBEM_S_NO_ERROR;
			}
		} else {
			hr = WBEM_E_INVALID_PARAMETER;
		}
		
		return hr;
}

template <class T>
HRESULT
IdCache<T>::EndEnum(void){
    Unlock();
    return WBEM_S_NO_ERROR;
}


#endif //_CACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmicooker\cookerutils.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    CookerUtils.h

Abstract:

    Tricks and utilities used by the WMI cooker

History:

    a-dcrews	01-Mar-00	Created

--*/

#ifndef _COOKERUTILS_H_
#define _COOKERUTILS_H_

typedef DWORD WMISTATUS;	

#include <wbemcli.h>

////////////////////////////////////////////////////////////////
//
//	Macro Definitions
//
////////////////////////////////////////////////////////////////

#define WMI_COOKER_VERSION                          (1)

#define AUTOCOOK_RAWDEFAULT_CURRENT_ACCEPTED        (1)

#define WMI_COOKER_HIPERF_QUALIFIER					L"Hiperf"
#define WMI_COOKER_COOKING_QUALIFIER				L"Cooked"
#define WMI_COOKER_AUTOCOOK_QUALIFIER				L"AutoCook"
#define	WMI_COOKER_RAWCLASS_QUALIFIER				L"AutoCook_RawClass"
#define WMI_COOKER_AUTOCOOK_RAWDEFAULT              L"AutoCook_RawDefault" 

// properties required for AutoCook_RawDefault
#define WMI_COOKER_REQ_TIMESTAMP_PERFTIME           L"TimeStamp_PerfTime"
#define WMI_COOKER_REQ_TIMESTAMP_SYS100NS           L"TimeStamp_Sys100ns"
#define WMI_COOKER_REQ_TIMESTAMP_OBJECT             L"TimeStamp_Object"
#define WMI_COOKER_REQ_FREQUENCY_PERFTIME           L"Frequency_PerfTime"
#define WMI_COOKER_REQ_FREQUENCY_SYS100NS           L"Frequency_Sys100ns"
#define WMI_COOKER_REQ_FREQUENCY_OBJECT             L"Frequency_Object"

#define WMI_COOKER_COUNTER_TYPE						L"CounterType"
#define	WMI_COOKER_COOKING_PROPERTY_ATTRIBUTE		L"CookingType"
#define WMI_COOKER_COOKING_PROPERTY_ATTRIBUTE_TYPE	L"VT_I4"
#define	WMI_COOKER_RAW_COUNTER						L"Counter"
#define	WMI_COOKER_RAW_BASE							L"Base"
#define	WMI_COOKER_RAW_TIME							L"PerfTimeStamp"
#define	WMI_COOKER_RAW_FREQUENCY					L"PerfTimeFreq"
#define WMI_COOKER_SAMPLE_WINDOW					L"SampleWindow"
#define WMI_COOKER_TIME_WINDOW						L"TimeWindow"
#define WMI_COOKER_SCALE_FACT                       L"Scale" 

#define WMI_COOKER_RAW_TIME_SYS                     L"PerfSysTimeStamp"
#define WMI_COOKER_RAW_TIME_100NS                   L"Perf100NSTimeStamp"
#define WMI_COOKER_RAW_TIME_OBJ                     L"PerfObjTimeStamp"
#define WMI_COOKER_RAW_FREQ_SYS                     L"PerfSysTimeFreq"
#define WMI_COOKER_RAW_FREQ_100NS                   L"Perf100NSTimeFreq"
#define WMI_COOKER_RAW_FREQ_OBJ                     L"PerfObjTimeFreq"


////////////////////////////////////////////////////////////////
//
//  Which property have to be defined in the Raw class 
//  for the counter to be cooked
//
////////////////////////////////////////////////////////////////

#define REQ_NONE    0x00
#define REQ_1VALUE  0x01
#define REQ_2VALUE  0x02
#define REQ_TIME    0x04 
#define REQ_FREQ    0x08 
#define REQ_BASE    0x10 


////////////////////////////////////////////////////////////////
//
//	Function Definitions
//
////////////////////////////////////////////////////////////////

BOOL IsSingleton(IWbemClassObject * pCls);

LPWSTR GetKey( IWbemObjectAccess* pObj );

WMISTATUS CloneAccess(IWbemObjectAccess* pOriginal, IWbemObjectAccess** ppClone);

WMISTATUS CopyBlob( IWbemClassObject* pSource, IWbemClassObject* pTarget );

BOOL IsCookingClass( IWbemClassObject* pCookingClassObject );
BOOL IsCookingProperty( BSTR strPropName, IWbemClassObject* pCookingClassObject, DWORD* pdwCounterType, DWORD* pdwReqProp);

BOOL IsHiPerfObj(IWbemObjectAccess* pObject);

BOOL IsHiPerf( IWbemServices* pNamespace, LPCWSTR wszObject );

WMISTATUS GetRawClassName( IWbemClassObject* pCookingInst, WCHAR** pwszRawClassName );

WMISTATUS GetClassName( IWbemObjectAccess* pAccess, WCHAR** pwszClassName );

////////////////////////////////////////////////////////////////
//
//	Automatic Scope Classes
//
////////////////////////////////////////////////////////////////

class CAutoRelease
{
	IUnknown*	m_pUnk;

public:
	CAutoRelease( IUnknown* pUnk ):m_pUnk( pUnk ){};

	~CAutoRelease(){
		if ( NULL != m_pUnk ) m_pUnk->Release();
	};
};

class CAutoFree
{
	BSTR	m_strStr;
public:
	CAutoFree( BSTR strStr )
	{
		m_strStr = strStr;
	}
	virtual ~CAutoFree()
	{
		SysFreeString( m_strStr );
	}
};

#endif	// _COOKERUTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmicooker\cookerutils.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//
// CookerUtils.cpp
//

#include "precomp.h"
#include <wbemint.h>
#include "cookerutils.h"
#include "strutils.h"

#include <comdef.h>



//////////////////////////////////////////////////////////////
//
//
//	Helper Functions
//
//
//////////////////////////////////////////////////////////////

BOOL IsCookingClass( IWbemClassObject* pCookingClassObject )
{
	HRESULT hResult = WBEM_NO_ERROR;

	IWbemQualifierSet	*pCookingClassQualifierSet = NULL;
	


	hResult = pCookingClassObject->GetQualifierSet( &pCookingClassQualifierSet );
	
	// Verify "AutoCook" qualifier
	// ===========================

	if ( SUCCEEDED( hResult ) )
	{
		CAutoRelease arQualifierSet( (IUnknown*)pCookingClassQualifierSet );

		_variant_t vVal;

		hResult = pCookingClassQualifierSet->Get( WMI_COOKER_AUTOCOOK_QUALIFIER, 0, &vVal, NULL );

		if ( SUCCEEDED( hResult ) )
		{
		    if ( vVal.vt != VT_I4  )
		    {
    			hResult = WBEM_E_INVALID_QUALIFIER;
    		} 
    		else
    		{
    		    if (WMI_COOKER_VERSION != V_I4(&vVal))
	    			hResult = WBEM_E_INVALID_CLASS;    		    
    		}
		}
	}

	return SUCCEEDED( hResult );
}


// Table of the counter types and their Cooking type values
struct _CookingTypeRec
{
	DWORD dwType;
	WCHAR * wcsName;
	DWORD dwReqProp;
}
g_aCookingRecs[] =
{
	0x00000000, L"PERF_COUNTER_RAWCOUNT_HEX", REQ_1VALUE,
	// BEGIN COOKER_ONLY
    0x00000001, L"COOKER_AVERAGE", REQ_2VALUE,
    0x00000002, L"COOKER_MIN", REQ_2VALUE,
    0x00000003, L"COOKER_MAX", REQ_2VALUE,
    0x00000004, L"COOKER_RANGE", REQ_2VALUE,
    0x00000005, L"COOKER_VARIANCE", REQ_2VALUE,
	// END COOKER_ONLY
	0x00000100,	L"PERF_COUNTER_LARGE_RAWCOUNT_HEX", REQ_1VALUE,
	0x00000B00, L"PERF_COUNTER_TEXT", REQ_NONE,
	0x00010000,	L"PERF_COUNTER_RAWCOUNT", REQ_1VALUE,
	0x00010100, L"PERF_COUNTER_LARGE_RAWCOUNT", REQ_1VALUE,
	0x00012000, L"PERF_DOUBLE_RAW", REQ_1VALUE,
	0x00400400,	L"PERF_COUNTER_DELTA", REQ_2VALUE,
	0x00400500,	L"PERF_COUNTER_LARGE_DELTA", REQ_2VALUE,
	0x00410400,	L"PERF_SAMPLE_COUNTER", REQ_2VALUE|REQ_TIME|REQ_FREQ,
	0x00450400, L"PERF_COUNTER_QUEUELEN_TYPE", REQ_2VALUE|REQ_TIME,
	0x00450500, L"PERF_COUNTER_LARGE_QUEUELEN_TYPE", REQ_2VALUE|REQ_TIME,
	0x00550500,	L"PERF_COUNTER_100NS_QUEUELEN_TYPE", REQ_2VALUE|REQ_TIME,
	0x00650500, L"PERF_COUNTER_OBJ_TIME_QUEUELEN_TYPE", REQ_2VALUE|REQ_TIME,
	0x10410400,	L"PERF_COUNTER_COUNTER", REQ_2VALUE|REQ_TIME|REQ_FREQ,
	0x10410500,	L"PERF_COUNTER_BULK_COUNT", REQ_2VALUE|REQ_TIME|REQ_FREQ,
	0x20020400, L"PERF_RAW_FRACTION", REQ_1VALUE|REQ_BASE,
	0x20410500,	L"PERF_COUNTER_TIMER", REQ_2VALUE|REQ_TIME,
	0x20470500,	L"PERF_PRECISION_SYSTEM_TIMER", REQ_2VALUE|REQ_TIME,
	0x20510500,	L"PERF_100NSEC_TIMER", REQ_2VALUE|REQ_TIME,
	0x20570500,	L"PERF_PRECISION_100NS_TIMER", REQ_2VALUE|REQ_TIME,
	0x20610500,	L"PERF_OBJ_TIME_TIMER", REQ_2VALUE|REQ_TIME,
	0x20670500, L"PERF_PRECISION_OBJECT_TIMER", REQ_2VALUE|REQ_TIME,
	0x20C20400,	L"PERF_SAMPLE_FRACTION", REQ_2VALUE|REQ_BASE,
	0x21410500,	L"PERF_COUNTER_TIMER_INV", REQ_2VALUE|REQ_TIME,
	0x21510500,	L"PERF_100NSEC_TIMER_INV", REQ_2VALUE|REQ_TIME,
	0x22410500, L"PERF_COUNTER_MULTI_TIMER", REQ_2VALUE|REQ_TIME,
	0x22510500,	L"PERF_100NSEC_MULTI_TIMER", REQ_2VALUE|REQ_TIME,
	0x23410500,	L"PERF_COUNTER_MULTI_TIMER_INV", REQ_2VALUE|REQ_TIME,
	0x23510500, L"PERF_100NSEC_MULTI_TIMER_INV", REQ_2VALUE|REQ_TIME,
	0x30020400,	L"PERF_AVERAGE_TIMER", REQ_2VALUE|REQ_BASE|REQ_FREQ,
	0x30240500,	L"PERF_ELAPSED_TIME", REQ_1VALUE|REQ_TIME|REQ_FREQ,
	0x40000200, L"PERF_COUNTER_NODATA", REQ_NONE,
	0x40020500,	L"PERF_AVERAGE_BULK", REQ_2VALUE|REQ_BASE,
	0x40030401,	L"PERF_SAMPLE_BASE", REQ_NONE,
	0x40030402, L"PERF_AVERAGE_BASE", REQ_NONE,
	0x40030403, L"PERF_RAW_BASE", REQ_NONE,
	0x40030500, L"PERF_PRECISION_TIMESTAMP", REQ_NONE,
	0x40030503,	L"PERF_LARGE_RAW_BASE", REQ_NONE,
	0x42030500,	L"PERF_COUNTER_MULTI_BASE", REQ_NONE,
	0x80000000,	L"PERF_COUNTER_HISTOGRAM_TYPE", REQ_NONE,
};

HRESULT FindCounterType( WCHAR* pwcsString, DWORD* pdwType, DWORD *pdwReqProp)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	DWORD	dwLeft = 0,
			dwRight = sizeof( g_aCookingRecs ) / sizeof( _CookingTypeRec );

	while ( ( dwLeft < dwRight ) && SUCCEEDED( hRes ) )
	{
		// Found it
		if ( wbem_wcsicmp( g_aCookingRecs[dwLeft].wcsName, pwcsString ) == 0 )
		{
			*pdwType   = g_aCookingRecs[dwLeft].dwType;
			*pdwReqProp = g_aCookingRecs[dwLeft].dwReqProp;
			break;
		}

		dwLeft++;
	}

	if ( dwLeft >= dwRight )
	{
		hRes = WBEM_E_NOT_FOUND;
	}

	return hRes;
}

BOOL IsSingleton(IWbemClassObject * pCls){

    HRESULT hr;
    
    if (pCls){
        IWbemQualifierSet * pQS = NULL;
        hr = pCls->GetQualifierSet(&pQS);
        CAutoRelease rm1(pQS);
        
        if (SUCCEEDED(hr)){

            _variant_t VarBool;
            hr = pQS->Get(L"singleton",0,&VarBool,NULL);
            
            if (SUCCEEDED(hr) &&
                VarBool.vt == VT_BOOL &&
                V_BOOL(&VarBool) == VARIANT_TRUE){
                
                return TRUE;
                
            }
        }
    };

    return FALSE;
    
}

//
// returns TRUE if the property qualifier set has the CookingType
// qualifier and if the CookingType is recognized
//
///////////////////////////////////////////////////////////////////

BOOL IsCookingProperty( BSTR strPropName, IWbemClassObject* pCookingClassObject, DWORD* pdwCounterType, DWORD * pdwReqProp )
{
	HRESULT hResult = WBEM_NO_ERROR;

	IWbemQualifierSet*	pPropQualSet = NULL;
	_variant_t	vVal;

	hResult = pCookingClassObject->GetPropertyQualifierSet( (LPCWSTR)strPropName, &pPropQualSet );
	
	if ( SUCCEEDED( hResult ) )
	{
		CAutoRelease	arPropQualSet( (IUnknown*)pPropQualSet );

		hResult = pPropQualSet->Get( WMI_COOKER_COOKING_PROPERTY_ATTRIBUTE, 0, &vVal, NULL );

		if ( SUCCEEDED ( hResult ) )
		{
			if ( vVal.vt == VT_BSTR )
			{
 	            hResult = FindCounterType( V_BSTR( &vVal ), pdwCounterType, pdwReqProp );			
			}
			else 
			{
				hResult = E_FAIL;
			}
		}
	}
	
	return SUCCEEDED( hResult );
}

LPWSTR GetKey( IWbemObjectAccess* pObj )
///////////////////////////////////////////////////////////////////////////////
//
//	
//
//	Parameters:
//
//
///////////////////////////////////////////////////////////////////////////////
{
	WMISTATUS dwStatus = WBEM_NO_ERROR;

	IWbemClassObject*	pClassObj = NULL;
	LPWSTR	wszKeyName = NULL;
	LPWSTR	wszTempKeyPtr = NULL;
	_variant_t	var;

	pObj->QueryInterface( IID_IWbemClassObject, (void**)&pClassObj );
	CAutoRelease arClassObj( pClassObj );

	dwStatus = pClassObj->Get( L"__RELPATH", 0, &var, NULL, NULL );

	if ( SUCCEEDED( dwStatus ) )
	{
		if ( var.vt != VT_BSTR )
		{
			dwStatus = WBEM_E_FAILED;
		}
		else
		{
			wszTempKeyPtr = wcsstr( var.bstrVal, L"=" );
			wszTempKeyPtr++;

			wszKeyName = new WCHAR[ wcslen( wszTempKeyPtr ) + 1 ];
			wcscpy( wszKeyName, wszTempKeyPtr );
		}
	}

	return wszKeyName;
}

WMISTATUS CopyBlob( _IWmiObject* pIntSource, _IWmiObject* pIntTarget )
{
	WMISTATUS dwStatus = WBEM_NO_ERROR;

	dwStatus = pIntTarget->CopyInstanceData( 0L, pIntSource );

	return dwStatus;
}

WMISTATUS CopyBlob( IWbemClassObject* pSource, IWbemClassObject* pTarget )
{
	HRESULT dwStatus = E_NOINTERFACE ;
	HRESULT hr1,hr2;
		
	_IWmiObject* pIntTarget = NULL;
	_IWmiObject* pIntSource = NULL;

	hr1 = pTarget->QueryInterface( IID__IWmiObject, (void**)&pIntTarget );
	CAutoRelease arIntTarget( pIntTarget );

	hr2 = pSource->QueryInterface( IID__IWmiObject, (void**)&pIntSource );
	CAutoRelease arIntSource( pIntSource );
	
	if ( SUCCEEDED(hr1) && SUCCEEDED(hr2) )
	{
		dwStatus = CopyBlob( pIntSource, pIntTarget );
	}

	return dwStatus;
}

WMISTATUS CloneAccess(IWbemObjectAccess* pOriginal, IWbemObjectAccess** ppClone)
//////////////////////////////////////////////////////////////
//
//	Returns a IWbemObjectAccess clone of an IWbemObjectAccess
//	object.
//
//	Parameters:
//		pOriginal	- the original object
//		ppClone		- the cloned object
//
//////////////////////////////////////////////////////////////
//ok
{
	WMISTATUS dwStatus = WBEM_NO_ERROR;

	IWbemClassObject*	pOurClassObj = NULL;		
	IWbemClassObject*	pClonedClassObj = NULL;
	IWbemObjectAccess*	pClonedAccessObj = NULL;

	// Get the IWbemClassObject interface for the object
	// =================================================

	dwStatus = pOriginal->QueryInterface(IID_IWbemClassObject, (PVOID*)&pOurClassObj);

	if ( SUCCEEDED( dwStatus ) )
	{
		// Clone the object
		// ================

		dwStatus = pOurClassObj->Clone(&pClonedClassObj);
		pOurClassObj->Release();
	}

	if ( SUCCEEDED( dwStatus ) )
	{
		// Get the IWbemObjectAccess interface for the cloned object
		// =========================================================

		dwStatus = pClonedClassObj->QueryInterface(IID_IWbemObjectAccess, (PVOID*)&pClonedAccessObj);
		pClonedClassObj->Release();
	}

	if ( SUCCEEDED( dwStatus ) )
	{
		// Copy the cloned object into the returned parameter (refcount == 1)
		// ==================================================================

		*ppClone = pClonedAccessObj;
	}

	return dwStatus;
}

BOOL IsHiPerfObj(IWbemObjectAccess* pObject){

    HRESULT hr;
    _variant_t Var;

    hr = pObject->Get(L"__SUPERCLASS",0,&Var,NULL,NULL);

    if (SUCCEEDED(hr))
    {
        if (Var.vt == VT_BSTR) {
        
            hr = (0 == _wcsicmp(Var.bstrVal,L"Win32_PerfFormattedData"))?S_OK:E_FAIL;
            
        } else {        
        
          hr = E_FAIL;
          
        }
    }

    return SUCCEEDED(hr);
}

BOOL IsHiPerf( IWbemObjectAccess* pObject )
{
	WMISTATUS	hr = WBEM_NO_ERROR;
	IWbemQualifierSet*	pQualSet = NULL;

	hr = pObject->GetQualifierSet( &pQualSet );
	CAutoRelease	arQualSet( pQualSet );


	// Verify the "Hiperf" class qualifier
	// ===================================

	if (SUCCEEDED(hr))
	{
		_variant_t	var;

		hr = pQualSet->Get( WMI_COOKER_HIPERF_QUALIFIER, 0, &var, NULL );

		if ( SUCCEEDED(hr) && ( ( var.vt != VT_BOOL ) || ( var.boolVal != VARIANT_TRUE ) ) )
		{
			hr = WBEM_E_INVALID_QUALIFIER;
		}
	}

	// Verify the "Cooked" class qualifier
	// ===================================

	if (SUCCEEDED(hr))
	{
    	_variant_t	var;
    	
		hr = pQualSet->Get( WMI_COOKER_COOKING_QUALIFIER, 0, &var, NULL );
		
		if ( SUCCEEDED(hr) && ( ( var.vt != VT_BOOL ) || ( var.boolVal != VARIANT_TRUE ) ) )
		{
			hr = WBEM_E_INVALID_QUALIFIER;
		}
	}

	// Verify the "AutoCook" class qualifier
	// =====================================

	if (SUCCEEDED(hr))
	{
	    _variant_t	var;
	    
		hr = pQualSet->Get( WMI_COOKER_AUTOCOOK_QUALIFIER, 0, &var, NULL );
		
		if (SUCCEEDED(hr))
		{
		    if ( var.vt != VT_I4 )
		    {
    			hr = WBEM_E_INVALID_QUALIFIER;
    		} 
    		else
    		{
    		    if (WMI_COOKER_VERSION != V_I4(&var))
	    			hr = WBEM_E_INVALID_CLASS;    		    
    		}
		}
	}

	// Verify the "AutoCook_RawClass" class qualifier
	// ==============================================

	if (SUCCEEDED(hr))
	{
	    _variant_t	var;
	    
		hr = pQualSet->Get( WMI_COOKER_RAWCLASS_QUALIFIER, 0, &var, NULL );
		
		if ( SUCCEEDED(hr) && ( var.vt != VT_BSTR ) )
		{
			hr = WBEM_E_INVALID_QUALIFIER;
		}
	}

		// verify the "AutoCook_RawDeafult" class qualifier if there
		// ==========================================================

		if (SUCCEEDED(hr))
		{
			_variant_t	var;
			hr = pQualSet->Get( WMI_COOKER_AUTOCOOK_RAWDEFAULT, 0, &var, NULL );

			if ( SUCCEEDED(hr) )
			{
			    if ((var.vt != VT_I4) || 
			        (V_I4(&var) != AUTOCOOK_RAWDEFAULT_CURRENT_ACCEPTED))
			    {
				    hr = WBEM_E_INVALID_QUALIFIER;
				}
				else // good qualifier, see the properties
				{
				    HRESULT hr1 = pObject->Get(WMI_COOKER_REQ_TIMESTAMP_PERFTIME,0,NULL,NULL,NULL);
				    HRESULT hr2 = pObject->Get(WMI_COOKER_REQ_TIMESTAMP_SYS100NS,0,NULL,NULL,NULL);
				    HRESULT hr3 = pObject->Get(WMI_COOKER_REQ_TIMESTAMP_OBJECT  ,0,NULL,NULL,NULL);
				    HRESULT hr4 = pObject->Get(WMI_COOKER_REQ_FREQUENCY_PERFTIME,0,NULL,NULL,NULL);
				    HRESULT hr5 = pObject->Get(WMI_COOKER_REQ_FREQUENCY_SYS100NS,0,NULL,NULL,NULL);
				    HRESULT hr6 = pObject->Get(WMI_COOKER_REQ_FREQUENCY_OBJECT  ,0,NULL,NULL,NULL);

				    if (SUCCEEDED(hr1) &&
				        SUCCEEDED(hr2) &&
				        SUCCEEDED(hr3) &&
				        SUCCEEDED(hr4) &&
				        SUCCEEDED(hr5) &&
				        SUCCEEDED(hr6))
				    {
				        // ok
				    }
				    else
				    {
    				    hr = WBEM_E_INVALID_CLASS;
				    }
				}
			}
			else
			{
			    // this qualifier is optional
			    hr = WBEM_NO_ERROR;
			}
	   }
	
	return SUCCEEDED(hr);
}

BOOL IsHiPerf( IWbemServices* pNamespace, LPCWSTR wszObject )
{
	IWbemClassObject* pObject = NULL;

	// Get the WMI object	
	BSTR strObject = SysAllocString(wszObject);
	if (!strObject)
	{
		return FALSE;
	}
	CAutoFree fme(strObject);

	HRESULT hr = pNamespace->GetObject( strObject, 0, NULL, &pObject, NULL );
	CAutoRelease	arObject( pObject );

    if (SUCCEEDED(hr)) {

		IWbemQualifierSet*	pQualSet = NULL;

		hr = pObject->GetQualifierSet( &pQualSet );
		CAutoRelease	arQualSet( pQualSet );


		// Verify the "Hiperf" class qualifier
		if ( SUCCEEDED(hr) ){
		
			_variant_t	var;
			hr = pQualSet->Get( WMI_COOKER_HIPERF_QUALIFIER, 0, &var, NULL );

			if ( SUCCEEDED(hr) && 
			     ( (var.vt != VT_BOOL) || 
			       (var.boolVal != VARIANT_TRUE)) ){
				hr = WBEM_E_INVALID_QUALIFIER;
			}
		}

		// Verify the "Cooked" class qualifier
		if ( SUCCEEDED(hr) ){
		
	    	_variant_t	var;	    	
			hr = pQualSet->Get( WMI_COOKER_COOKING_QUALIFIER, 0, &var, NULL );
			
			if ( SUCCEEDED(hr) && 
			     ( (var.vt != VT_BOOL) || 
			       (var.boolVal != VARIANT_TRUE)) ){
				hr = WBEM_E_INVALID_QUALIFIER;
			}
		}

		// Verify the "AutoCook" class qualifier
		if ( SUCCEEDED(hr) ){
		
		    _variant_t	var;    
			hr = pQualSet->Get( WMI_COOKER_AUTOCOOK_QUALIFIER, 0, &var, NULL );
			
			if ( SUCCEEDED(hr) )
			{
			    if (var.vt != VT_I4 )
			    {
				    hr = WBEM_E_INVALID_QUALIFIER;
				}
				else
				{
				    if (WMI_COOKER_VERSION != V_I4(&var))
				        hr = WBEM_E_INVALID_CLASS;
				}
			}
		}

		// Verify the "AutoCook_RawClass" class qualifier
		// ==============================================

		if ( SUCCEEDED(hr) )
		{		
		    _variant_t	varRawClass;
			hr = pQualSet->Get( WMI_COOKER_RAWCLASS_QUALIFIER, 0, &varRawClass, NULL );
			
			if ( SUCCEEDED(hr) )
			{
			    if ( varRawClass.vt == VT_BSTR )
			    {
                    IWbemClassObject * pRawClass = NULL;
                    hr = pNamespace->GetObject(V_BSTR(&varRawClass),0,NULL,&pRawClass,NULL);
                    CAutoRelease rm1(pRawClass);
                    
                    if (SUCCEEDED(hr)){
                    
                        IWbemQualifierSet * pQS = NULL;
                        hr = pRawClass->GetQualifierSet(&pQS);
                        CAutoRelease rm2(pQS);
                        if (SUCCEEDED(hr)){
                        
                            // verify the hiperf qualifier on the RAW class
                            _variant_t varH;
                            hr = pQS->Get(WMI_COOKER_HIPERF_QUALIFIER, 0, &varH, NULL);
                            if ( SUCCEEDED(hr) && 
							     ( (varH.vt != VT_BOOL) || 
			    				   (varH.boolVal != VARIANT_TRUE)) ){
								hr = WBEM_E_INVALID_QUALIFIER;
							};
                        }                        
                        
                    } else {
                        hr = WBEM_E_INVALID_CLASS;
                    }
			    
			    } else {
    				hr = WBEM_E_INVALID_QUALIFIER;
				}
			}
		}

		// verify the "AutoCook_RawDeafult" class qualifier if there
		// ==========================================================

		if ( SUCCEEDED(hr) ){
			_variant_t	var;
			hr = pQualSet->Get( WMI_COOKER_AUTOCOOK_RAWDEFAULT, 0, &var, NULL );

			if ( SUCCEEDED(hr) )
			{
			    if ((var.vt != VT_I4) || 
			        (V_I4(&var) != AUTOCOOK_RAWDEFAULT_CURRENT_ACCEPTED))
			    {
				    hr = WBEM_E_INVALID_QUALIFIER;
				}
				else // good qualifier, see the properties
				{
				    HRESULT hr1 = pObject->Get(WMI_COOKER_REQ_TIMESTAMP_PERFTIME,0,NULL,NULL,NULL);
				    HRESULT hr2 = pObject->Get(WMI_COOKER_REQ_TIMESTAMP_SYS100NS,0,NULL,NULL,NULL);
				    HRESULT hr3 = pObject->Get(WMI_COOKER_REQ_TIMESTAMP_OBJECT  ,0,NULL,NULL,NULL);
				    HRESULT hr4 = pObject->Get(WMI_COOKER_REQ_FREQUENCY_PERFTIME,0,NULL,NULL,NULL);
				    HRESULT hr5 = pObject->Get(WMI_COOKER_REQ_FREQUENCY_SYS100NS,0,NULL,NULL,NULL);
				    HRESULT hr6 = pObject->Get(WMI_COOKER_REQ_FREQUENCY_OBJECT  ,0,NULL,NULL,NULL);

				    if (SUCCEEDED(hr1) &&
				        SUCCEEDED(hr2) &&
				        SUCCEEDED(hr3) &&
				        SUCCEEDED(hr4) &&
				        SUCCEEDED(hr5) &&
				        SUCCEEDED(hr6))
				    {
				        // ok
				    }
				    else
				    {
    				    hr = WBEM_E_INVALID_CLASS;
				    }
				}
			}
			else
			{
  			    // this qualifier is optional
  			    hr = WBEM_NO_ERROR;
			}
		}

		return SUCCEEDED(hr);
	
	}	
	return FALSE;    
}

WMISTATUS GetRawClassName( IWbemClassObject* pCookingInst, WCHAR** pwszRawClassName )
{
	WMISTATUS	dwStatus = WBEM_NO_ERROR;

	IWbemQualifierSet*	pQualSet = NULL;	// The Instance qualifier set
	_variant_t				varRawInstName;		// The raw instance name

	dwStatus = pCookingInst->GetQualifierSet( &pQualSet );
	CAutoRelease adQualSet( pQualSet );

	if ( SUCCEEDED( dwStatus ) )
	{
		dwStatus = pQualSet->Get( WMI_COOKER_RAWCLASS_QUALIFIER, 0, &varRawInstName, NULL );

		if ( SUCCEEDED( dwStatus ) )
		{
			if ( VT_BSTR == varRawInstName.vt )
			{
				// TODO: Is there a more efficient way to pass back the string value than a strcpy?
				// ================================================================================

				WCHAR* wszRawClassName = new WCHAR[wcslen( varRawInstName.bstrVal ) + 1];

				if ( NULL != wszRawClassName )
				{
					wcscpy( wszRawClassName, varRawInstName.bstrVal );
					*pwszRawClassName = wszRawClassName;
				}
				else
				{
					dwStatus = WBEM_E_OUT_OF_MEMORY;
				}
			}
			else
			{
				dwStatus = WBEM_E_TYPE_MISMATCH;
			}
		}
	}

	return dwStatus;
}

WMISTATUS GetClassName( IWbemObjectAccess* pAccess, WCHAR** pwszClassName )
{
	WMISTATUS	dwStatus = WBEM_NO_ERROR;

	IWbemClassObject*	pObject = NULL;
	_variant_t	vVal;

	dwStatus = pAccess->QueryInterface( IID_IWbemClassObject, (void**)&pObject );
	CAutoRelease ar(pObject);

	if ( SUCCEEDED( dwStatus ) )
	{
		dwStatus = pObject->Get(L"__CLASS", 0, &vVal, NULL, NULL );

		if ( vVal.vt != VT_BSTR )
		{
			dwStatus = E_FAIL;
		}

		if ( SUCCEEDED( dwStatus ) )
		{
			WCHAR*	wszClassName = new WCHAR[ wcslen( vVal.bstrVal ) + 1 ];

			if ( NULL != wszClassName )
			{
				wcscpy( wszClassName, vVal.bstrVal );
				*pwszClassName = wszClassName;
			}
			else
			{
				dwStatus = WBEM_E_OUT_OF_MEMORY;
			}
		}
	}

	return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmicooker\main.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/



#define _WIN32_WINNT 0x0400

#define UNICODE

#include "precomp.h"
#include "RawCooker.h"
#include "WMIObjCooker.h"
#include "Refresher.h"

IWbemServices*				g_pNameSpace = NULL;		// A WMI namespace pointer 
IWbemRefresher*				g_pRefresher = NULL;
IWbemConfigureRefresher*	g_pConfig = NULL;
IWbemClassObject*			g_pCookedClass = NULL;
IWbemObjectAccess*			g_pCookingAccess = NULL;

#define WMI_NAMESPACE	L"root\\default"
#define	WMI_RAWCLASS	L"Win32_BasicHiPerf"
#define WMI_COOKEDCLASS	L"Win32_CookingHiPerf"
#define WMI_KEY_PROP	L"ID"
#define	WMI_PROPERTY	L"Counter1"

#define	WMI_NO_OUTPUT
/*
typedef struct tagCookingInst
{
	WCHAR	m_wszCookedInstName[256];
	WCHAR	m_wszRawInstName[256];
	IWbemObjectAccess*	m_pWMICookingInst;

} CookingInstRec;


struct tagCookingClass
{
	WCHAR				m_wszCookedClassName[256];
	WCHAR				m_wszObservedCounter[256];
	long				m_lHandle;
	CookingInstRec		m_aCookingInst[10000];
} g_aCookingData;
*/
/* =
{
	L"Win32_PerfCookedData_PerfProc_Process", 0, L"PercentProcessorTime", 0, { L"Win32_PerfCookedData_PerfProc_Process.Name=\"Idle\"", L"Win32_PerfRawData_PerfProc_Process.Name=\"Idle\""},
	L"Win32_PerfCookedData_PerfProc_Process", 0, L"PercentProcessorTime", 0, { L"Win32_PerfCookedData_PerfProc_Process.Name=\"System\"", L"Win32_PerfRawData_PerfProc_Process.Name=\"System\""},
	L"Win32_PerfCookedData_PerfProc_Process", 0, L"PercentProcessorTime", 0, { L"Win32_PerfCookedData_PerfProc_Process.Name=\"smss\"", L"Win32_PerfRawData_PerfProc_Process.Name=\"smss\""},
	L"Win32_PerfCookedData_PerfProc_Process", 0, L"PercentProcessorTime", 0, { L"Win32_PerfCookedData_PerfProc_Process.Name=\"csrss\"", L"Win32_PerfRawData_PerfProc_Process.Name=\"csrss\""},
	L"Win32_PerfCookedData_PerfProc_Process", 0, L"PercentProcessorTime", 0, { L"Win32_PerfCookedData_PerfProc_Process.Name=\"winlogon\"", L"Win32_PerfRawData_PerfProc_Process.Name=\"winlogon\""},
	L"Win32_PerfCookedData_PerfProc_Process", 0, L"PercentProcessorTime", 0, { L"Win32_PerfCookedData_PerfProc_Process.Name=\"services\"", L"Win32_PerfRawData_PerfProc_Process.Name=\"services\""},
	L"Win32_PerfCookedData_PerfProc_Process", 0, L"PercentProcessorTime", 0, { L"Win32_PerfCookedData_PerfProc_Process.Name=\"lsass\"", L"Win32_PerfRawData_PerfProc_Process.Name=\"lsass\""},
	L"Win32_PerfCookedData_PerfProc_Process", 0, L"PercentProcessorTime", 0, { L"Win32_PerfCookedData_PerfProc_Process.Name=\"svchost\"", L"Win32_PerfRawData_PerfProc_Process.Name=\"svchost\""},
	L"Win32_PerfCookedData_PerfProc_Process", 0, L"PercentProcessorTime", 0, { L"Win32_PerfCookedData_PerfProc_Process.Name=\"winmgmt\"", L"Win32_PerfRawData_PerfProc_Process.Name=\"winmgmt\""},
	L"Win32_PerfCookedData_PerfProc_Process", 0, L"PercentProcessorTime", 0, { L"Win32_PerfCookedData_PerfProc_Process.Name=\"explorer\"", L"Win32_PerfRawData_PerfProc_Process.Name=\"explorer\""},


//	L"Win32_PerfCookedData_PerfProc_Thread", 0, L"PercentProcessorTime" , 0 , { L"Win32_PerfCookedData_PerfProc_Thread.Name=\"Idle/0\"", L"Win32_PerfRawData_PerfProc_Thread.Name=\"Idle/0\""},
//	L"Win32_PerfCookedData_PerfProc_Thread", 0, L"PercentProcessorTime" , 0 , { L"Win32_PerfCookedData_PerfProc_Thread.Name=\"System/0\"", L"Win32_PerfRawData_PerfProc_Thread.Name=\"System/0\"" }
};
*/

HRESULT Init()
{
	HRESULT hResult = S_OK;

	// Setup refresher
	// ===============

	hResult = CoCreateInstance( CLSID_WbemRefresher, 
								 NULL, 
								 CLSCTX_INPROC_SERVER, 
								 IID_IWbemRefresher, 
								 (void**) &g_pRefresher );
	if ( SUCCEEDED( hResult ) )
	{
		hResult = g_pRefresher->QueryInterface( IID_IWbemConfigureRefresher, 
										 (void**) &g_pConfig );
	}

	// Setup Cooking Class
	// ===================

	if ( SUCCEEDED( hResult ) )
	{
		BSTR strCookingObj = SysAllocString( WMI_COOKEDCLASS );
		hResult = g_pNameSpace->GetObject(strCookingObj, 0, NULL, &g_pCookedClass, NULL );
		SysFreeString( strCookingObj );

		if ( SUCCEEDED( hResult ) )
		{
			hResult = g_pCookedClass->QueryInterface( IID_IWbemObjectAccess, (void**)&g_pCookingAccess );

			if ( SUCCEEDED( hResult ) )
			{
//				CIMTYPE	ct;
//				hResult = g_pCookingAccess->GetPropertyHandle( WMI_PROPERTY, &ct, &g_aCookingData.m_lHandle );
			}
		}

	}

	return hResult;
}

HRESULT CreateInstance( int nID, IWbemClassObject** ppCookingInst )
{
	HRESULT hResult = S_OK;

	VARIANT vVar;

	vVar.vt = VT_I4;
	vVar.lVal = nID;

	hResult = g_pCookedClass->SpawnInstance( 0, ppCookingInst );

	if ( SUCCEEDED( hResult ) )
	{
		hResult = (*ppCookingInst)->Put( L"ID", 0, &vVar, CIM_UINT32 );
	}

	if ( SUCCEEDED( hResult ) )
	{
		hResult = g_pNameSpace->PutInstance( *ppCookingInst, WBEM_FLAG_CREATE_ONLY, NULL, NULL );
	}

	return hResult;
}

void TestRefreshCooker()
{
	HRESULT hResult = WBEM_NO_ERROR;

/*	IWbemClassObject*	pClassObj = NULL;
	IWbemClassObject*	pRawClassInstance = NULL;
	IWbemObjectAccess*	pCookingClass = NULL;
	IWbemObjectAccess*	pCookingInstance = NULL;
	IWbemObjectAccess*	pRawAccessInstance = NULL;
	IWbemObjectAccess*	pRefInstance = NULL;

	IEnumWbemClassObject*	pInstEnum = NULL;

	ULONG	uReturned;
	long	nNumCookedInst = 0;
	
	CRefreshableCooker RefreshableCooker;

	IEnumWbemClassObject *pEnum = NULL;

	// Enumerate all of the raw instances
	// ==================================

	BSTR strRawClass = SysAllocString( WMI_RAWCLASS );
	hResult = g_pNameSpace->CreateInstanceEnum( strRawClass, WBEM_FLAG_SHALLOW, NULL, &pInstEnum );
	SysFreeString( strRawClass );

	while ( WBEM_S_NO_ERROR == pInstEnum->Next(WBEM_INFINITE, 1, &pRawClassInstance, &uReturned ) )
	{
		int		nID;
		IWbemClassObject*	pCookedObject = NULL;
		VARIANT	vVal;
		
		hResult = pRawClassInstance->Get( L"ID", 0, &vVal, NULL, NULL );

		nID = vVal.lVal;

		if ( SUCCEEDED( hResult ) )
		{
			WCHAR	wszCookedObjName[256];
			swprintf( wszCookedObjName, L"%s.%s=%d", WMI_COOKEDCLASS, WMI_KEY_PROP, nID );
			BSTR strCookedObjName = SysAllocString(wszCookedObjName);

			hResult = g_pNameSpace->GetObject(strCookedObjName, 0, NULL, &pCookedObject, NULL );

			if ( FAILED(hResult) )
			{
				hResult = CreateInstance( nID, &pCookedObject );
			}

			SysFreeString(strCookedObjName);

			if ( SUCCEEDED( hResult ) )
			{

				// The raw instance
				// ================

				long lID;

				hResult = g_pConfig->AddObjectByTemplate( g_pNameSpace, pRawClassInstance, 0, NULL, &pClassObj, &lID );

				// Add the instance 
				// ================

				hResult = pCookedObject->QueryInterface( IID_IWbemObjectAccess, (void**)&pCookingInstance);
				hResult = pClassObj->QueryInterface( IID_IWbemObjectAccess, (void**)&pRawAccessInstance );

				hResult = RefreshableCooker.AddInstance( g_pCookingAccess, pRawAccessInstance, &pCookingInstance, &lID );

				pRawAccessInstance->Release();
				pCookingInstance->Release();

				nNumCookedInst++;
			}
		}
	}

	printf("Setup complete.  BeginRefreshing...\n");

	unsigned __int64 nVal = 0;
	long	lHandle;
	CIMTYPE ct;
	
	pCookingInstance->GetPropertyHandle(L"Counter1", &ct, &lHandle);

	for (int nRefresh = 0; nRefresh < 1000; nRefresh++)
	{
		Sleep(1000);
//		g_pRefresher->Refresh( 0L );
		hResult = RefreshableCooker.Refresh();

#ifndef WMI_NO_OUTPUT

		printf("%d: ", nRefresh);
		hResult = pCookingInstance->ReadQWORD( lHandle, &nVal );
		printf("\t%I64d", nVal);
		printf("\n");

#endif //WMI_NO_OUTPUT

	}
*/
}

void Test()
{
	HRESULT hResult = WBEM_NO_ERROR;

	IWbemClassObject*	pObject = NULL;
	IWbemClassObject*	pInstance = NULL;
	IWbemObjectAccess*	pInstanceAccess = NULL;
	IWbemObjectAccess* pAccess = NULL;

	BSTR strObject = SysAllocString( L"Win32_Cooking_BasicHiPerf" );

	hResult = g_pNameSpace->GetObject( strObject, 0, NULL, &pObject, NULL );

	SysFreeString( strObject );

	pObject->QueryInterface( IID_IWbemObjectAccess, (void**)&pAccess );

	CWMISimpleObjectCooker ObjCooker;

	hResult = ObjCooker.SetClass( pAccess );

	if ( SUCCEEDED ( hResult ) )
	{
		pObject->SpawnInstance( 0, &pInstance );

		VARIANT vVar;
		vVar.vt = VT_I4;
		vVar.lVal = 1;
		pInstance->Put( L"ID", 0, &vVar, CIM_UINT32);

		long lID = 0;

		pInstance->QueryInterface( IID_IWbemObjectAccess, (void**)&pInstanceAccess );
		pInstance->Release();

		hResult = ObjCooker.SetCookedInstance( pInstanceAccess, &lID );

		if ( SUCCEEDED( hResult ) )
		{
			// Setup refresher
			// ===============

			IWbemRefresher*				pRefresher = NULL;
			IWbemConfigureRefresher*	pConfig = NULL;
			IWbemClassObject*			pRefObj = NULL;
			IWbemObjectAccess*			pRefObjAccess = NULL;

			long lID = 0;

			hResult = CoCreateInstance( CLSID_WbemRefresher, 
									 NULL, 
									 CLSCTX_INPROC_SERVER, 
									 IID_IWbemRefresher, 
									 (void**) &pRefresher );
	
			hResult = pRefresher->QueryInterface( IID_IWbemConfigureRefresher, 
												 (void**) &pConfig );

			WCHAR	wcsObjName[256];
			swprintf( wcsObjName, L"Win32_BasicHiPerf.ID=0" );

			hResult = pConfig->AddObjectByPath( g_pNameSpace, wcsObjName, 0, NULL, &pRefObj, &lID );

			hResult = pRefObj->QueryInterface( IID_IWbemObjectAccess, (void**)&pRefObjAccess );
			hResult = pRefObj->Release();

			hResult = pRefresher->Refresh( 0L );

			hResult = ObjCooker.BeginCooking( lID, pRefObjAccess );

			hResult = pRefresher->Refresh( 0L );

			hResult = ObjCooker.Recalc();

			pRefresher->Release();
			pConfig->Release();
			pRefObjAccess->Release();
		}

		pInstanceAccess->Release();

	}

	pObject->Release();
	pAccess->Release();
}

HRESULT OpenNamespace( WCHAR* wszNamespace )
{
	HRESULT hResult = WBEM_NO_ERROR;

	// Initialize COM
	// ==============

	hResult = CoInitializeEx( NULL, COINIT_MULTITHREADED );
	if ( FAILED( hResult ) )
		return hResult;

	// Setup default security parameters
	// =================================

	hResult = CoInitializeSecurity( NULL, -1, NULL, NULL,
			RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE,
			NULL, EOAC_NONE, NULL );
	if ( FAILED( hResult ) )
		return hResult;

// Attach to WinMgmt
// =================

	// Get the local locator object
	// ============================

	IWbemLocator*	pWbemLocator = NULL;

	hResult = CoCreateInstance( CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (void**) &pWbemLocator );
	if (FAILED(hResult))
		return hResult;

	// Connect to the desired namespace
	// ================================

	BSTR	bstrNameSpace;

	bstrNameSpace = SysAllocString( wszNamespace );

	hResult = pWbemLocator->ConnectServer(	bstrNameSpace,	// NameSpace Name
										NULL,			// UserName
										NULL,			// Password
										NULL,			// Locale
										0L,				// Security Flags
										NULL,			// Authority
										NULL,			// Wbem Context
										&g_pNameSpace	// Namespace
										);

	SysFreeString( bstrNameSpace );

	if ( FAILED( hResult ) )
		return hResult;


	// Before refreshing, we need to ensure that security is correctly set on the
	// namespace as the refresher will use those settings when it communicates with
	// WMI.  This is especially important in remoting scenarios.

	IUnknown*	pUnk = NULL;
	hResult = g_pNameSpace->QueryInterface( IID_IUnknown, (void**) &pUnk );

	if ( SUCCEEDED( hResult ) )
	{
		hResult = CoSetProxyBlanket( g_pNameSpace, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL, 
			RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE,
			NULL, EOAC_NONE );

		if ( SUCCEEDED( hResult ) )
		{
			hResult = CoSetProxyBlanket( pUnk, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL, 
				RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE,
				NULL, EOAC_NONE );
		}

		pUnk->Release();
	}

	if ( NULL != pWbemLocator )
		pWbemLocator->Release();

	return hResult;
}

int main(int argc, char* argv[])
{
	HRESULT hResult = S_OK;

	hResult = OpenNamespace( WMI_NAMESPACE );

	if ( SUCCEEDED( hResult ) )
	{
		if ( SUCCEEDED( Init() ) )
		{
			// Test();
			TestRefreshCooker();
		}
	}


// Cleanup
// =======

	if ( NULL != g_pNameSpace )
		g_pNameSpace->Release();


	CoUninitialize();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmicooker\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
#include <stdio.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmicooker\dynarray.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    DynArray.h

Abstract:

    Implementation of a dynamic array

History:

    a-dcrews	01-Mar-00	Created

--*/

#ifndef _DYNARRAY_H_
#define _DYNARRAY_H_

#include "cookerutils.h"

#define WMI_DEFAULT_CACHE_SIZE	64

enum enumCDynArrayExceptions
{
	WMI_BOUNDARY_VIOLATION
};

class CDynArrayException 
{
private:
    unsigned int nException;
public:
    CDynArrayException(unsigned int n) : nException(n) {}
    ~CDynArrayException() {}
    unsigned int GetException() { return nException; }
};


/////////////////////////////////////////////////////////////////////////
//
//
//	CDynArray
//
//
/////////////////////////////////////////////////////////////////////////

template <class T>
class CDynArray
{
	BOOL	m_bOK;
	HANDLE	m_hHeap;			

	T*		m_aArray;

	DWORD	m_dwSize;		// The total size of the array
	DWORD	m_dwUsage;		// 
	DWORD	m_dwEnum;

	WMISTATUS	Initialize();
	WMISTATUS	Compact();

public:
	CDynArray();
	virtual ~CDynArray();

	WMISTATUS Resize( DWORD dwSize );
	UINT GetCapacity(){ return m_dwSize; }
	UINT GetUsage(){ return m_dwUsage; }

	T& operator[]( DWORD dwIndex);

	WMISTATUS BeginEnum() { m_dwEnum = 0; return WBEM_NO_ERROR; }
	WMISTATUS Next( T* pData ) 
	{ 
		WMISTATUS dwStatus = WBEM_S_FALSE;

		while ( ( m_dwEnum >= 0 ) && ( m_dwEnum < m_dwSize ) )
		{
			if ( NULL != m_aArray[ m_dwEnum ] )
			{
				*pData = m_aArray[ m_dwEnum ];
				dwStatus = WBEM_NO_ERROR;
				m_dwEnum++;
				break;
			}
			else
			{
				m_dwEnum++;
			}
		}
		return dwStatus;
	}

	WMISTATUS EndEnum() { m_dwEnum = -1; return WBEM_NO_ERROR; }

	WMISTATUS Add( T Data, DWORD* pdwID );
	WMISTATUS Remove( DWORD dwID );
};

template <class T>
CDynArray<T>::CDynArray() : 
	m_hHeap( NULL ),
	m_dwSize( WMI_DEFAULT_CACHE_SIZE ),
	m_dwEnum( -1 )
{
	m_bOK = SUCCEEDED( Initialize() );
}

template <class T>
CDynArray<T>::~CDynArray()
{
	try
	{
		HeapFree( m_hHeap, 0, m_aArray );

		HANDLE hHeap = GetProcessHeap();
		
		if (hHeap != m_hHeap){
		    HeapDestroy(m_hHeap);
		}
	}
	catch(...)
	{
		// Just pass it along
		// ==================
		throw;
	}
}

template <class T>
WMISTATUS CDynArray<T>::Initialize()
{
	WMISTATUS	dwStatus = WBEM_NO_ERROR;

	// Create our private heap
	// =======================

	try
	{
		m_hHeap = HeapCreate( HEAP_GENERATE_EXCEPTIONS | HEAP_NO_SERIALIZE, 0, 0 );

		if ( NULL == m_hHeap )
			m_hHeap = GetProcessHeap();
	}
	catch(...)
	{
		dwStatus = WBEM_E_OUT_OF_MEMORY;
	}

	if ( SUCCEEDED( dwStatus ) )
	{
		// Initialize the array size
		// =========================

		try 
		{
			m_aArray = (T*)HeapAlloc( m_hHeap, HEAP_ZERO_MEMORY, ( sizeof(T*) * m_dwSize ) ); 
		}
		catch(...)
		{
			dwStatus = WBEM_E_OUT_OF_MEMORY;
		}

		if ( NULL == m_aArray )
		{
			dwStatus = WBEM_E_OUT_OF_MEMORY;
		}
	}

	return dwStatus;
}

template <class T>
WMISTATUS CDynArray<T>::Add( T Data, DWORD* pdwID )
{
	WMISTATUS dwStatus = WBEM_E_FAILED;
	DWORD dwIndex = 0;

	for ( dwIndex = 0; dwIndex < m_dwSize; dwIndex++ )
	{
		if ( NULL == m_aArray[ dwIndex ] )
		{
			m_aArray[ dwIndex ] = Data;
			*pdwID = dwIndex;
			dwStatus = WBEM_NO_ERROR;
			m_dwUsage++;
			break;
		}
	}

	if ( dwStatus == WBEM_E_FAILED )
	{
		dwIndex = m_dwSize;
		dwStatus = Resize( m_dwSize + 8 );

		if ( SUCCEEDED( dwStatus ) )
		{
			m_aArray[ dwIndex ] = Data;
			*pdwID = dwIndex;
			dwStatus = WBEM_NO_ERROR;
			m_dwUsage++;
		}
	}

	return dwStatus;
}

template <class T>
WMISTATUS CDynArray<T>::Remove( DWORD dwID )
{
	WMISTATUS dwStatus = WBEM_NO_ERROR;

	m_aArray[ dwID ] = NULL;
	m_dwUsage--;

	return dwStatus;
}

template <class T>
WMISTATUS CDynArray<T>::Resize( DWORD dwNewSize )
{
	WMISTATUS dwStatus = WBEM_NO_ERROR;

	if ( !m_bOK )
	{
		dwStatus = WBEM_E_NOT_AVAILABLE;
	}
	else if ( dwNewSize == m_dwSize )	// If the requested size is the same as the current size, then we are done
	{
		dwStatus = WBEM_S_FALSE;
	}
	else if ( dwNewSize < m_dwUsage )	// Are we trying to shrink the array beyond it's current capacity?
	{
		dwStatus = WBEM_E_FAILED;
	}
	else
	{
		m_aArray = (T*)HeapReAlloc( m_hHeap, HEAP_ZERO_MEMORY, m_aArray, sizeof( T* ) * dwNewSize );
		m_dwSize = dwNewSize;
	}

	return dwStatus;
}

template<class T>
T& CDynArray<T>::operator[]( DWORD dwIndex )
{
	if ( m_bOK && ( 0 <= dwIndex ) && ( m_dwSize > dwIndex ) )
		return m_aArray[ dwIndex ];
	else
		throw CDynArrayException( WMI_BOUNDARY_VIOLATION ); 
}




#endif	// _DYNARRAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmicooker\provider.cpp ===
////////////////////////////////////////////////////////////////////////
//
//	Provider.cpp
//
//	Module:	WMI high performance provider 
//
//
//  History:
//	a-dcrews      12-Jan-97		Created
//
//	
//  Copyright (c) 1997-2001 Microsoft Corporation
//
////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <process.h>
#include <autoptr.h>

#include "Provider.h"
#include "CookerUtils.h"

#include <comdef.h>


//////////////////////////////////////////////////////////////
//
//
//	Global, external and static variables
//
//
//////////////////////////////////////////////////////////////

// The COM object counter (declared in server.cpp)
// ===============================================

extern long g_lObjects;	

//////////////////////////////////////////////////////////////
//
//
//	CHiPerfProvider
//
//
//////////////////////////////////////////////////////////////

CHiPerfProvider::CHiPerfProvider() : m_lRef(0)
//////////////////////////////////////////////////////////////
//
//	Constructor
//
//////////////////////////////////////////////////////////////
//ok
{
	// Increment the global COM object counter
	// =======================================

	InterlockedIncrement(&g_lObjects);
}

CHiPerfProvider::~CHiPerfProvider()
//////////////////////////////////////////////////////////////
//
//	Destructor
//
//////////////////////////////////////////////////////////////
//ok
{
	long lObjCount = 0;

	// Decrement the global COM object counter
	// =======================================

	lObjCount = InterlockedDecrement(&g_lObjects);
}

//////////////////////////////////////////////////////////////
//
//					COM methods
//
//////////////////////////////////////////////////////////////

STDMETHODIMP CHiPerfProvider::QueryInterface(REFIID riid, void** ppv)
//////////////////////////////////////////////////////////////
//
//	Standard QueryInterface
//
//	Parameters:
//		riid	- the ID of the requested interface
//		ppv		- a pointer to the interface pointer
//
//////////////////////////////////////////////////////////////
//ok
{
    if(riid == IID_IUnknown)
        *ppv = (LPVOID)(IUnknown*)(IWbemProviderInit*)this;
    else if(riid == IID_IWbemProviderInit)
        *ppv = (LPVOID)(IWbemProviderInit*)this;
	else if (riid == IID_IWbemHiPerfProvider)
		*ppv = (LPVOID)(IWbemHiPerfProvider*)this;
	else return E_NOINTERFACE;

	((IUnknown*)*ppv)->AddRef();
	return WBEM_NO_ERROR;
}

STDMETHODIMP_(ULONG) CHiPerfProvider::AddRef()
//////////////////////////////////////////////////////////////
//
//	Standard COM AddRef
//
//////////////////////////////////////////////////////////////
//ok
{
    return InterlockedIncrement(&m_lRef);
}

STDMETHODIMP_(ULONG) CHiPerfProvider::Release()
//////////////////////////////////////////////////////////////
//
//	Standard COM Release
//
//////////////////////////////////////////////////////////////
//ok
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;

    return lRef;
}

STDMETHODIMP CHiPerfProvider::Initialize( 
    /* [unique][in] */  LPWSTR wszUser,
    /* [in] */          long lFlags,
    /* [in] */          LPWSTR wszNamespace,
    /* [unique][in] */  LPWSTR wszLocale,
    /* [in] */          IWbemServices __RPC_FAR *pNamespace,
    /* [in] */          IWbemContext __RPC_FAR *pCtx,
    /* [in] */          IWbemProviderInitSink __RPC_FAR *pInitSink)
//////////////////////////////////////////////////////////////////////
//
//  Called once during startup for any one-time initialization.  The 
//	final call to Release() is for any cleanup.
//	
//	The parameters indicate to the provider which namespace it is being 
//	invoked for and which User.  It also supplies a back pointer to 
//	WINMGMT so that class definitions can be retrieved.
//
//	Initialize will create a single template object that can be used 
//	by the provider to spawn instances for QueryInstances.  It will 
//	also initialize our mock data source and set the global ID access 
//	handle.
//	
//	Parameters:
//		wszUser			- The current user.
//		lFlags			- Reserved.
//		wszNamespace	- The namespace for which we are being activated.
//		wszLocale		- The locale under which we are to be running.
//		pNamespace		- An active pointer back into the current namespace
//							from which we can retrieve schema objects.
//		pCtx			- The user's context object.  We simply reuse this
//							during any reentrant operations into WINMGMT.
//		pInitSink		- The sink to which we indicate our readiness.
//
//////////////////////////////////////////////////////////////////////
//ok
{
	HRESULT hResult = WBEM_NO_ERROR;

	if (wszNamespace == 0 || pNamespace == 0 || pInitSink == 0)
        hResult = WBEM_E_INVALID_PARAMETER;

	// Add further initialization code here
	// ====================================

    // We now have all the instances ready to go and the name handle 
	// stored.  Tell WINMGMT that we're ready to start 'providing'
	// =============================================================
	
	if ( SUCCEEDED( hResult ) )
	{
		pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
	}

    return hResult;
}

STDMETHODIMP CHiPerfProvider::CreateRefresher( 
     /* [in] */ IWbemServices __RPC_FAR *pNamespace,
     /* [in] */ long lFlags,
     /* [out] */ IWbemRefresher __RPC_FAR *__RPC_FAR *ppRefresher )
//////////////////////////////////////////////////////////////////////
//
//  Called whenever a new refresher is needed by the client.
//
//  Parameters:
//		pNamespace		- A pointer to the relevant namespace.  Not used.
//		lFlags			- Reserved.
//		ppRefresher		- Receives the requested refresher.
//
//////////////////////////////////////////////////////////////////////
//ok
{
	HRESULT hResult = WBEM_NO_ERROR;

    if ( pNamespace == 0 || ppRefresher == 0 )
        hResult = WBEM_E_INVALID_PARAMETER;

	if ( SUCCEEDED( hResult ) )
	{
		// Construct and initialize a new empty refresher
		// ==============================================

		CRefresher* pNewRefresher = new CRefresher;

		if ( NULL == pNewRefresher )
		{
			hResult = WBEM_E_OUT_OF_MEMORY;
		}
		else if ( !pNewRefresher->IsOK() )
		{
			hResult = WBEM_E_CRITICAL_ERROR;
		}

		if ( SUCCEEDED( hResult ) )
		{
			// Follow COM rules and AddRef() the thing before sending it back
			// ==============================================================

			pNewRefresher->AddRef();
			*ppRefresher = pNewRefresher;
		}
		else
		{
			if ( NULL != pNewRefresher )
				delete pNewRefresher;
		}
	}
    
    return hResult;
}

STDMETHODIMP CHiPerfProvider::CreateRefreshableObject( 
    /* [in] */ IWbemServices __RPC_FAR *pNamespace,
    /* [in] */ IWbemObjectAccess __RPC_FAR *pTemplate,
    /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pContext,
    /* [out] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *ppRefreshable,
    /* [out] */ long __RPC_FAR *plId )
//////////////////////////////////////////////////////////////////////
//
//  Called whenever a user wants to include an object in a refresher.
//
//	Note that the object returned in ppRefreshable is a clone of the 
//	actual instance maintained by the provider.  If refreshers shared
//	a copy of the same instance, then a refresh call on one of the 
//	refreshers would impact the state of both refreshers.  This would 
//	break the refresher rules.	Instances in a refresher are only 
//	allowed to be updated when 'Refresh' is called.
//     
//  Parameters:
//		pNamespace		- A pointer to the relevant namespace in WINMGMT.
//		pTemplate		- A pointer to a copy of the object which is to be
//							added.  This object itself cannot be used, as
//							it not owned locally.        
//		pRefresher		- The refresher to which to add the object.
//		lFlags			- Not used.
//		pContext		- Not used here.
//		ppRefreshable	- A pointer to the internal object which was added
//							to the refresher.
//		plId			- The Object Id (for identification during removal).        
//
//////////////////////////////////////////////////////////////////////
//ok
{
	HRESULT hResult = WBEM_NO_ERROR;

    if ( pNamespace == 0 || pTemplate == 0 || pRefresher == 0 )
        hResult = WBEM_E_INVALID_PARAMETER;

	// Verify hi-perf object
	// =====================

	if ( !IsHiPerfObj( pTemplate ) )
		hResult = WBEM_E_INVALID_CLASS;

    _variant_t VarClass;
    hResult = pTemplate->Get(L"__CLASS",0,&VarClass,NULL,NULL);
    
    if ( SUCCEEDED( hResult ) )
    {
        if (VT_BSTR == V_VT(&VarClass))
        {
			if ( !IsHiPerf( pNamespace, V_BSTR(&VarClass) ) )
			{
				hResult = WBEM_E_INVALID_CLASS;        
	        }
        }
        else
        {
            hResult = WBEM_E_INVALID_CLASS;
        }
    }

	if ( SUCCEEDED( hResult ) )
	{
		// The refresher being supplied by the caller is actually
		// one of our own refreshers, so a simple cast is convenient
		// so that we can access private members.
		// =========================================================

		CRefresher *pOurRefresher = ( CRefresher * ) pRefresher;

		// Add the object to the refresher. The ID is set by AddObject
		// ===========================================================
		
		// NB: We are passing a NULL in as the Raw object.  The reason is so we
		// can maintain the interface while we are using a private refresher
		// on the inside of the cooking object refresher.  This will change when 
		// WMI is wired to synchronize raw instances within the client's refresher
		// =======================================================================

		hResult = pOurRefresher->AddInstance( pNamespace, pContext, pTemplate, NULL, ppRefreshable, plId );
	}

    return hResult;
}
   
STDMETHODIMP CHiPerfProvider::CreateRefreshableEnum( 
	/* [in] */ IWbemServices* pNamespace,
	/* [in, string] */ LPCWSTR wszClass,
	/* [in] */ IWbemRefresher* pRefresher,
	/* [in] */ long lFlags,
	/* [in] */ IWbemContext* pContext,
	/* [in] */ IWbemHiPerfEnum* pHiPerfEnum,
	/* [out] */ long* plId )
//////////////////////////////////////////////////////////////////////
//
//  Called when an enumerator is being added to a refresher.  The 
//	enumerator will obtain a fresh set of instances of the specified 
//	class every time that refresh is called.
//     
//  Parameters:
//		pNamespace		- A pointer to the relevant namespace.  
//		wszClass		- The class name for the requested enumerator.
//		pRefresher		- The refresher object for which we will add 
//							the enumerator
//		lFlags			- Reserved.
//		pContext		- Not used here.
//		pHiPerfEnum		- The enumerator to add to the refresher.
//		plId			- A provider specified ID for the enumerator.
//
//////////////////////////////////////////////////////////////////////
//ok
{
	HRESULT hResult = WBEM_NO_ERROR;

    if ( pNamespace == 0 || pRefresher == 0 || pHiPerfEnum == 0 )
        hResult = WBEM_E_INVALID_PARAMETER;

	// Verify hi-perf class
	// =====================

	if ( !IsHiPerf( pNamespace, wszClass ) )
		hResult = WBEM_E_INVALID_CLASS;

	if ( SUCCEEDED( hResult ) )
	{
		// The refresher being supplied by the caller is actually
		// one of our own refreshers, so a simple cast is convenient
		// so that we can access private members.

		CRefresher *pOurRefresher = (CRefresher *) pRefresher;

		// Add the enumerator to the refresher.  The ID is generated by AddEnum
		// ====================================================================

		hResult = pOurRefresher->AddEnum( pNamespace, pContext, wszClass, pHiPerfEnum, plId );
	}

	return hResult;
}

STDMETHODIMP CHiPerfProvider::StopRefreshing( 
    /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
    /* [in] */ long lId,
    /* [in] */ long lFlags )
//////////////////////////////////////////////////////////////////////
//
//  Called whenever a user wants to remove an object from a refresher.
//     
//  Parameters:
//		pRefresher			- The refresher object from which we are to 
//								remove the perf object.
//		lId					- The ID of the object.
//		lFlags				- Not used.
//  
//////////////////////////////////////////////////////////////////////
//ok
{
	HRESULT hResult = WBEM_NO_ERROR;

	if ( pRefresher == 0 )
        hResult = WBEM_E_INVALID_PARAMETER;

	if ( SUCCEEDED( hResult ) )
	{
		// The refresher being supplied by the caller is actually
		// one of our own refreshers, so a simple cast is convenient
		// so that we can access private members.
		// =========================================================

		CRefresher *pOurRefresher = (CRefresher *) pRefresher;

		hResult = pOurRefresher->Remove( lId );
	}

	return hResult;
}

STDMETHODIMP CHiPerfProvider::QueryInstances( 
    /* [in] */          IWbemServices __RPC_FAR *pNamespace,
    /* [string][in] */  WCHAR __RPC_FAR *wszClass,
    /* [in] */          long lFlags,
    /* [in] */          IWbemContext __RPC_FAR *pCtx,
    /* [in] */          IWbemObjectSink __RPC_FAR *pSink )
//////////////////////////////////////////////////////////////////////
//
//  Called whenever a complete, fresh list of instances for a given
//  class is required.   The objects are constructed and sent back to the
//  caller through the sink.  The sink can be used in-line as here, or
//  the call can return and a separate thread could be used to deliver
//  the instances to the sink.
//
//  Parameters:
//		pNamespace		- A pointer to the relevant namespace.  This
//							should not be AddRef'ed.
//		wszClass		- The class name for which instances are required.
//		lFlags			- Reserved.
//		pCtx			- The user-supplied context (not used here).
//		pSink			- The sink to which to deliver the objects.  The objects
//							can be delivered synchronously through the duration
//							of this call or asynchronously (assuming we
//							had a separate thread).  A IWbemObjectSink::SetStatus
//							call is required at the end of the sequence.
//
//////////////////////////////////////////////////////////////////////
//ok
{
	HRESULT hResult = WBEM_NO_ERROR;

    if (pNamespace == 0 || wszClass == 0 || pSink == 0)
        hResult = WBEM_E_INVALID_PARAMETER;

	// Verify hi-perf object
	// =====================

	if ( !IsHiPerf( pNamespace, wszClass ) )
		hResult = WBEM_E_INVALID_CLASS;

	if ( SUCCEEDED( hResult ) )
	{
		IWbemRefresher*	pRefresher = NULL;
		IWbemConfigureRefresher* pConfig = NULL;
		IWbemHiPerfEnum* pHiPerfEnum = NULL;
		IWbemObjectAccess** apAccess = NULL;
		IWbemClassObject** apObject = NULL;

		hResult = CoCreateInstance( CLSID_WbemRefresher, 
									 NULL, 
									 CLSCTX_INPROC_SERVER, 
									 IID_IWbemRefresher, 
									 (void**) &pRefresher );

        CAutoRelease rm1(pRefresher);

		// Get the refresher configuration interface
		// =========================================

		if ( SUCCEEDED( hResult ) )
		{
			hResult = pRefresher->QueryInterface( IID_IWbemConfigureRefresher, (void**)&pConfig );
		}
		CAutoRelease rm2(pConfig);

		if ( SUCCEEDED( hResult ) )
		{
			ULONG	uArraySize = 0,
					uObjRet = 0;

			long	lID = 0;

			hResult = pConfig->AddEnum( pNamespace, wszClass, 0, pCtx, &pHiPerfEnum, &lID );
			CAutoRelease arHiPerfEnum( pHiPerfEnum );

			if ( SUCCEEDED( hResult ) )
			{
				hResult = pRefresher->Refresh( 0L );
				hResult = pRefresher->Refresh( 0L );
			}

			if ( SUCCEEDED( hResult ) )
			{
				hResult = pHiPerfEnum->GetObjects( 0L, 0, NULL, &uObjRet );

				if ( WBEM_E_BUFFER_TOO_SMALL == hResult )
				{
					uArraySize = uObjRet;

					wmilib::auto_buffer<IWbemObjectAccess*>  apAccess( new IWbemObjectAccess*[ uObjRet ]);
					wmilib::auto_buffer<IWbemClassObject*> apObject(new IWbemClassObject*[ uObjRet ]);
					

					if ( (NULL != apObject.get()) && (NULL != apAccess.get()))
					{
						hResult = pHiPerfEnum->GetObjects( 0L, uArraySize, apAccess.get(), &uObjRet );

						for ( ULONG uIndex = 0; uIndex < uArraySize; uIndex++ )
						{
							apAccess[ uIndex ]->QueryInterface( IID_IWbemClassObject, (void**)&( apObject[uIndex] ) );
							apAccess[ uIndex ]->Release();
						}
					}
					else
					{
						hResult = WBEM_E_OUT_OF_MEMORY;
					}

					if ( SUCCEEDED( hResult ) )
					{
						hResult = pSink->Indicate( uArraySize, apObject.get() );

						for ( ULONG uIndex = 0; uIndex < uArraySize; uIndex++ )
						{
							apObject[ uIndex ]->Release();
						}
					}
				}
			}

			if ( SUCCEEDED( hResult ) )
			{
    			pConfig->Remove( lID , 0 );
			}
		}
	}

    pSink->SetStatus(0, hResult, 0, 0);

    return hResult;
} 

STDMETHODIMP CHiPerfProvider::GetObjects( 
    /* [in] */ IWbemServices* pNamespace,
	/* [in] */ long lNumObjects,
	/* [in,size_is(lNumObjects)] */ IWbemObjectAccess** apObj,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext* pContext)
//////////////////////////////////////////////////////////////////////
//
//  Called when a request is made to provide all instances currently 
//	being managed by the provider in the specified namespace.
//     
//  Parameters:
//		pNamespace		- A pointer to the relevant namespace.  
//		lNumObjects		- The number of instances being returned.
//		apObj			- The array of instances being returned.
//		lFlags			- Reserved.
//		pContext		- Not used here.
//
//////////////////////////////////////////////////////////////////////
//ok
{
	// Update objects
	// ==============

	IWbemRefresher*	pRefresher = NULL;
	IWbemConfigureRefresher* pConfig = NULL;
	wmilib::auto_buffer<IWbemClassObject*>	apRefObj(new IWbemClassObject*[lNumObjects]);

	if (0 == apRefObj.get())
	{
	    return WBEM_E_OUT_OF_MEMORY;
	}

	// CoCreate the refresher interface
	// ================================

	HRESULT hResult = CoCreateInstance( CLSID_WbemRefresher, 
								 NULL, 
								 CLSCTX_INPROC_SERVER, 
								 IID_IWbemRefresher, 
								 (void**) &pRefresher );

	CAutoRelease arRefresher( pRefresher );

	// Get the refresher configuration interface
	// =========================================

	if ( SUCCEEDED( hResult ) )
	{
		hResult = pRefresher->QueryInterface( IID_IWbemConfigureRefresher, (void**)&pConfig );
	}

	CAutoRelease arConfig( pConfig );

	// Get the object data
	// ===================

	if ( SUCCEEDED( hResult ) )
	{
		long	lIndex = 0,
				lID = 0;

		// Add all of the requested objects to the refresher
		// =================================================

		for ( lIndex = 0; SUCCEEDED( hResult ) && lIndex < lNumObjects; lIndex++ )
		{
			// Verify hi-perf object
			if ( !IsHiPerfObj( apObj[ lIndex ] ) )
				hResult = WBEM_E_INVALID_CLASS;

#ifdef _VERBOSE
			{
			    _variant_t VarPath;
			    apObj[lIndex]->Get(L"__RELPATH",0,&VarPath,NULL,NULL);
			    _variant_t VarName;
			    apObj[lIndex]->Get(L"Name",0,&VarName,NULL,NULL);			    
			    WCHAR pBuff[256];
			    wsprintfW(pBuff,L"%s %s\n",V_BSTR(&VarPath),V_BSTR(&VarName));
			    OutputDebugStringW(pBuff);
			}
#endif			

			if ( SUCCEEDED( hResult ) )
			{
				hResult = pConfig->AddObjectByTemplate( pNamespace, 
				                                        apObj[ lIndex ], 
				                                        0, 
				                                        NULL, 
				                                        &(apRefObj[ lIndex ]), 
				                                        &lID );
				lID = 0;
			}
		}

		if ( SUCCEEDED( hResult ) )
		{
			hResult = pRefresher->Refresh( 0L );
			hResult = pRefresher->Refresh( 0L );
		}

		for ( lIndex = 0; SUCCEEDED( hResult ) && lIndex < lNumObjects; lIndex++ )
		{
			hResult = CopyBlob( apRefObj[lIndex], apObj[lIndex] );
			apRefObj[lIndex]->Release();
		}
	}

	return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmicooker\provider.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    Provider.h

Abstract:

    Implementation of the high performance provider interface

History:

    a-dcrews	01-Mar-00	Created

--*/

#ifndef _HIPERFPROV_H_
#define _HIPERFPROV_H_

#include <tchar.h> 
#include <wbemprov.h>
#include "Cache.h"
#include "Refresher.h"

class CRefCacheElement;

//////////////////////////////////////////////////////////////
//
//
//	Constants and globals
//
//	
//////////////////////////////////////////////////////////////

#define WMI_HPCOOKER_ENUM_FLAG	0x10000000L

//////////////////////////////////////////////////////////////
//
//	CHiPerfProvider
//
//	The provider maintains a single IWbemClassObject to be used 
//	as a template to spawn instances for the Refresher as well
//	as QueryInstances.  It also maintains the static sample 
//	data source which provides all data to the instances.
//
//////////////////////////////////////////////////////////////

class CHiPerfProvider : public IWbemProviderInit, public IWbemHiPerfProvider
{
	long m_lRef;

public:
	CHiPerfProvider();
	~CHiPerfProvider();

	// Standard COM methods
	// ====================

	STDMETHODIMP QueryInterface(REFIID riid, void** ppv);
	STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	// IWbemProviderInit COM interface
	// ===============================

	STDMETHODIMP Initialize( 
		/* [unique][in] */ LPWSTR wszUser,
		/* [in] */ long lFlags,
		/* [in] */ LPWSTR wszNamespace,
		/* [unique][in] */ LPWSTR wszLocale,
		/* [in] */ IWbemServices __RPC_FAR *pNamespace,
		/* [in] */ IWbemContext __RPC_FAR *pCtx,
		/* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink );

	// IWbemHiPerfProvider COM interfaces
	// ==================================

	STDMETHODIMP CreateRefresher( 
		/* [in] */ IWbemServices __RPC_FAR *pNamespace,
		/* [in] */ long lFlags,
		/* [out] */ IWbemRefresher __RPC_FAR *__RPC_FAR *ppRefresher );
    
	STDMETHODIMP CreateRefreshableObject( 
		/* [in] */ IWbemServices __RPC_FAR *pNamespace,
		/* [in] */ IWbemObjectAccess __RPC_FAR *pTemplate,
		/* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
		/* [in] */ long lFlags,
		/* [in] */ IWbemContext __RPC_FAR *pContext,
		/* [out] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *ppRefreshable,
		/* [out] */ long __RPC_FAR *plId );
    
	STDMETHODIMP StopRefreshing( 
		/* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
		/* [in] */ long lId,
		/* [in] */ long lFlags );

	STDMETHODIMP CreateRefreshableEnum(
		/* [in] */ IWbemServices* pNamespace,
		/* [in, string] */ LPCWSTR wszClass,
		/* [in] */ IWbemRefresher* pRefresher,
		/* [in] */ long lFlags,
		/* [in] */ IWbemContext* pContext,
		/* [in] */ IWbemHiPerfEnum* pHiPerfEnum,
		/* [out] */ long* plId);

	STDMETHODIMP QueryInstances( 
		/* [in] */ IWbemServices __RPC_FAR *pNamespace,
		/* [string][in] */ WCHAR __RPC_FAR *wszClass,
		/* [in] */ long lFlags,
		/* [in] */ IWbemContext __RPC_FAR *pCtx,
		/* [in] */ IWbemObjectSink __RPC_FAR *pSink );

	STDMETHODIMP GetObjects(
        /* [in] */ IWbemServices* pNamespace,
		/* [in] */ long lNumObjects,
		/* [in,size_is(lNumObjects)] */ IWbemObjectAccess** apObj,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext* pContext);
};


#endif // _HIPERFPROV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmicooker\rawcooker.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    RawCooker.h

Abstract:

    The classes required to perform cooking based on a countertype

History:

    a-dcrews	01-Mar-00	Created

--*/

#ifndef _RAWCOOKER_H_
#define _RAWCOOKER_H_

#include <wbemint.h>
#include "CookerUtils.h"

//////////////////////////////////////////////////////////////////
//
//	CEquationRecord
//	
//	Contains all of the required information to describe either
//	a predefined or used defined equation
//
//////////////////////////////////////////////////////////////////

typedef __int64* PINT64;

typedef DWORD (APIENTRY PERFCALC)(DWORD, PINT64, PINT64, PINT64, INT64, PINT64);

class CCalcRecord
{
	DWORD		m_dwID;
	PERFCALC	*m_pCalc;

public:
	void Init( DWORD dwID, PERFCALC *pCalc )
	{
		m_dwID = dwID;
		m_pCalc = pCalc;
	}

	DWORD		GetID(){ return m_dwID; }
	PERFCALC*	GetCalc(){ return m_pCalc; }
};

class CCalcTable
{
	long			m_lSize;		// Size of table
	CCalcRecord		m_aTable[7];	// Lookup table

public:
	CCalcTable();
	virtual ~CCalcTable();

	CCalcRecord* GetCalcRecord( DWORD dwCookingType );
};

//////////////////////////////////////////////////////////////////
//
//	CRawCooker
//
//	Represents the cooking mechanism.
//
//////////////////////////////////////////////////////////////////

class CRawCooker : public IWMISimpleCooker
{
	long			m_lRef;				// Reference counter
	
	CCalcTable		m_CalcTable;		// Equation lookup table

	CCalcRecord*	m_pCalcRecord;	// A cache of the last record

public:
	CRawCooker();
	virtual ~CRawCooker();

	// Standard COM methods
	// ====================

	STDMETHODIMP QueryInterface(REFIID riid, void** ppv);
	STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	// IWMISimpleCooker COM Interface
	// ==============================

	STDMETHODIMP CookRawValues( 	
		/*[in]	*/	DWORD dwCookingType,
        /*[in] */	DWORD dwNumSamples,
        /*[in] */	__int64* anTimeStamp,
        /*[in] */	__int64* anRawValue,
        /*[in] */	__int64* anBase,
        /*[in] */	__int64 nTimeFrequency,
        /*[in] */   long    Scale,
		/*[out]	*/	__int64* pnResult );

	PERFCALC* GetCalc( DWORD dwCookingType );

	static WMISTATUS APIENTRY _Average( DWORD dwNumSamples,
		__int64*	anTimeStamp,
		__int64*	anRawValue,
		__int64*	anBase,
		__int64	nTimeFrequency,
		__int64*	pnResult);

	static WMISTATUS APIENTRY _Min( DWORD dwNumSamples,
		__int64*	anTimeStamp,
		__int64*	anRawValue,
		__int64*	anBase,
		__int64	nTimeFrequency,
		__int64*	pnResult);

	static WMISTATUS APIENTRY _Max( DWORD dwNumSamples,
		__int64*	anTimeStamp,
		__int64*	anRawValue,
		__int64*	anBase,
		__int64	nTimeFrequency,
		__int64*	pnResult);

	static WMISTATUS APIENTRY _Range( DWORD dwNumSamples,
		__int64*	anTimeStamp,
		__int64*	anRawValue,
		__int64*	anBase,
		__int64	nTimeFrequency,
		__int64*	pnResult);
		
	static WMISTATUS APIENTRY _Variance( DWORD dwNumSamples,
		__int64*	anTimeStamp,
		__int64*	anRawValue,
		__int64*	anBase,
		__int64	nTimeFrequency,
		__int64*	pnResult);

};

#endif	//_RAWCOOKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmicooker\refresher.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    RefreshCooker.h

Abstract:

    The implementation of the refresher

History:

    a-dcrews	01-Mar-00	Created

--*/

#ifndef	_REFRESHCOOKER_H_
#define _REFRESHCOOKER_H_

#include "Cache.h"
#include "WMIObjCooker.h"

#define WMI_COOKED_ENUM_MASK	0x70000000

class CRefresher : public IWMIRefreshableCooker, public IWbemRefresher
{
	bool	m_bOK;		// Creation status indicator
	long	m_lRef;		// Object refrence counter

	CCache<CWMISimpleObjectCooker, CObjRecord<CWMISimpleObjectCooker> >	
		m_CookingClassCache;					// The cooking class cache

	IWbemRefresher*				m_pRefresher;	// The internal refrehser for the short term solution
	IWbemConfigureRefresher*	m_pConfig;		// The internal configuration mgr for the short term solution

	CEnumeratorCache			m_EnumCache;

	DWORD                       m_dwRefreshId;

	// Gets the raw class name that is used by the 
	// cooked class in to obtain the raw data values
	// =============================================

/*	WMISTATUS GetRawClassName( IWbemClassObject* pCookingInst, 
			WCHAR** pwszRawClassName );
*/
	WMISTATUS SearchCookingClassCache( WCHAR* wszCookingClass, 
			CWMISimpleObjectCooker** ppObjectCooker );

	WMISTATUS AddRawInstance( IWbemServices* pNamespace,
	        IWbemContext * pContext,
			IWbemObjectAccess* pCookingInst, 
			IWbemObjectAccess** ppRawInst );

	WMISTATUS AddRawEnum( IWbemServices* pNamespace, 
	        IWbemContext * pContext,	
			WCHAR * wszRawClassName,
			IWbemHiPerfEnum** ppRawEnum,
			long* plID );

	WMISTATUS CreateObjectCooker( WCHAR* wszCookingClassName,
			IWbemObjectAccess* pCookingAccess, 
			IWbemObjectAccess* pRawAccess,
			CWMISimpleObjectCooker** ppObjectCooker,
			IWbemServices * pNamespace = NULL);

public:

	CRefresher();
	virtual ~CRefresher();
	
	// Non-interface methods
	// =====================

	bool IsOK(){ return m_bOK; }

	// Standard COM methods
	// ====================

	STDMETHODIMP QueryInterface(REFIID riid, void** ppv);
	STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	// IWMIRefreshableCooker methods
	// =============================

	STDMETHODIMP AddInstance(
			/*[in]  */ IWbemServices* pNamespace,
			/*[in]  */ IWbemContext * pCtx,
			/*[in]  */ IWbemObjectAccess* pCookingClass,
			/*[in]  */ IWbemObjectAccess* pRefreshableRawInstance,
			/*[out] */ IWbemObjectAccess** ppRefreshableInstance,
			/*[out] */ long* plId
		);

	STDMETHODIMP AddEnum(
			/*[in]  */ IWbemServices* pNamespace,
			/*[in]  */ IWbemContext * pCtx,			
			/*[in,string] */ LPCWSTR szCookingClass,
			/*[in]  */ IWbemHiPerfEnum* pRefreshableEnum,
			/*[out] */ long* plId
		);

	STDMETHODIMP Remove(
			/*[in]  */ long lId
		);

	STDMETHODIMP Refresh();

	// IWbemRefresher methods
	// ======================

	STDMETHODIMP Refresh( /* [in] */ long lFlags );
};

#endif	//_REFRESHCOOKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmicooker\refresher.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


// RefreshCooker.cpp

#include "precomp.h"
#include <wbemint.h>
#include <comdef.h>
#include <autoptr.h>

#include "Refresher.h"
#include "CookerUtils.h"

////////////////////////////////////////////////////////////////////////////
//
//	CRefresher
//	==========
//
//	The refresher class implements both the IWbemRefresher and the 
//	IWMIRefreshableCooker interfaces.  It contains an instance cache and 
//	an enumerator cache as well as maintaining an internal refresher to
//	track the raw data.
//
////////////////////////////////////////////////////////////////////////////

CRefresher::CRefresher() : 
  m_pRefresher( NULL ),
  m_pConfig( NULL ),
  m_lRef( 0 ),
  m_bOK( FALSE ),
  m_dwRefreshId(0)
{
	WMISTATUS	dwStatus = WBEM_NO_ERROR;

	// Initialize the internal refresher
	// =================================

	dwStatus = CoCreateInstance( CLSID_WbemRefresher, 
								 NULL, 
								 CLSCTX_INPROC_SERVER, 
								 IID_IWbemRefresher, 
								 (void**) &m_pRefresher );

	// Get the refresher configuration interface
	// =========================================

	if ( SUCCEEDED( dwStatus ) )
	{
		dwStatus = m_pRefresher->QueryInterface( IID_IWbemConfigureRefresher, (void**)&m_pConfig );
	}

	// If there was a problem, cleanup the interface pointers
	// ======================================================

	if ( FAILED( dwStatus ) )
	{
		if ( NULL != m_pRefresher )
		{
			m_pRefresher->Release();
			m_pRefresher = NULL;
		}

		if ( NULL != m_pConfig )
		{
			m_pConfig->Release();
			m_pConfig = NULL;
		}
	}

	m_bOK = SUCCEEDED( dwStatus );

#ifdef _VERBOSE	
	{
	    char pBuff[128];
	    wsprintfA(pBuff,"------------ CRefresher %08x \n",this);
	    OutputDebugStringA(pBuff);
	}
#endif	
}

CRefresher::~CRefresher()
{
	// Cleanup the members
	// ===================

	if ( NULL != m_pRefresher )
	{
		m_pRefresher->Release();
		m_pRefresher = NULL;
	}

	if ( NULL != m_pConfig )
	{
		m_pConfig->Release();
		m_pConfig = NULL;
	}
}

///////////////////////////////////////////////////////////////////////////////
//
//	Private methods
//
///////////////////////////////////////////////////////////////////////////////

WMISTATUS CRefresher::SearchCookingClassCache( 
		WCHAR* wszCookingClass, 
		CWMISimpleObjectCooker** ppObjectCooker )
///////////////////////////////////////////////////////////////////////////////
//
//	SearchCookingClassCache enumerates the cache looking for a class name
//	that matches the wszCookingClass parameter
//
//	Parameters:
//		wszCookingClass	- The name of the WMI cooking class 
//		ppObjectCooker	- The instance of the object cooker
//
///////////////////////////////////////////////////////////////////////////////
{
	WMISTATUS	dwStatus = WBEM_E_NOT_FOUND;

	CWMISimpleObjectCooker*	pObjectCooker = NULL;

	// Enumerate through the cache looking for the record
	// ==================================================
	m_CookingClassCache.BeginEnum();

	while ( S_OK == m_CookingClassCache.Next( &pObjectCooker ) )
	{
		// Compare the names
		// =================
		if ( 0 == _wcsicmp( pObjectCooker->GetCookingClassName(), wszCookingClass ) )
		{
			*ppObjectCooker = pObjectCooker;
			dwStatus = WBEM_NO_ERROR;
			break;
		}
	}

	// We're done
	// ==========
	m_CookingClassCache.EndEnum();

	return dwStatus;
}

WMISTATUS CRefresher::CreateObjectCooker( 
		WCHAR* wszCookingClassName,
		IWbemObjectAccess* pCookingAccess, 
		IWbemObjectAccess* pRawAccess,
		CWMISimpleObjectCooker** ppObjectCooker,
		IWbemServices * pNamespace)
///////////////////////////////////////////////////////////////////////////////
//
//	CreateObjectCooker will create and initialize a new object cooker and add
//	it to the cache
//
//	Parameters:
//		pNamespace		- The namespace pointer where the objects are located
//		pCookingAccess	- The WMI cooking object in need of a cooker
//		wszCookingClassName
//						- The name of the cooking class
//		ppObjectCooker	- The parameter to pass back the new object cooker
//	
///////////////////////////////////////////////////////////////////////////////
{
	WMISTATUS dwStatus = WBEM_NO_ERROR;

	CWMISimpleObjectCooker* pObjectCooker = NULL;
	WCHAR*	wszRawClassName;
	long lID;

	pObjectCooker = new CWMISimpleObjectCooker( wszCookingClassName, pCookingAccess, pRawAccess, pNamespace );

	if ( NULL == pObjectCooker )
	{
		dwStatus = WBEM_E_OUT_OF_MEMORY;
	} 
	else
	{
		dwStatus = pObjectCooker->GetLastHR();
	}

	// Add the object cooker to the cache
	if ( SUCCEEDED( dwStatus ) )
	{
		dwStatus = m_CookingClassCache.Add( pObjectCooker, wszCookingClassName, &lID );
	}
	else
	{
		if (pObjectCooker){
			delete pObjectCooker;
			pObjectCooker = NULL;
		}
	}

	if (SUCCEEDED(dwStatus))
	{
		*ppObjectCooker = pObjectCooker;
	}

	return dwStatus;
}

WMISTATUS CRefresher::AddRawInstance( 
		IWbemServices* pService, 
		IWbemContext * pCtx,
		IWbemObjectAccess* pCookingInst, 
		IWbemObjectAccess** ppRawInst )
///////////////////////////////////////////////////////////////////////////////
//
//	AddRawInstance is called to add the corresponding raw instance of a 
//	cooked object to the internal refresher.  We first extract the key value 
//	from the cooked object and create the raw instance path using the raw
//	class name
//
//	Parameters:
//		pService		- The namespace pointer where the objects are located
//		pCookingInst	- The WMI cooking instance
//		ppRawInst		- The WMI raw instance that was added to the internal 
//							refresher
//
///////////////////////////////////////////////////////////////////////////////
{
	WMISTATUS	dwStatus = WBEM_NO_ERROR;

	IWbemClassObject*	pObj = NULL;	// The alternate representation of pCookingInst
	_variant_t varRelPath;					// The RELPATH value
	WCHAR*	wszRawClassName = NULL;		// The name of the raw class
		
	// Get the fully specified instance path for the cooking object
	// ============================================================

	pCookingInst->QueryInterface( IID_IWbemClassObject, (void**)&pObj );
	CAutoRelease	arObj( pObj );

	dwStatus = pObj->Get( L"__RELPATH", 0, &varRelPath, NULL, NULL );

	if ( SUCCEEDED( dwStatus ) )
	{
		// Verify the property type
		// ========================
		if ( varRelPath.vt != VT_BSTR )
		{
			dwStatus = WBEM_E_TYPE_MISMATCH;
		}

		if ( SUCCEEDED( dwStatus ) )
		{
			IWbemClassObject*	pRawInst = NULL;
			WCHAR*				wszKeys = NULL;
			WCHAR*				wszRawInst = NULL;

			// Extract the key name
			// ====================
			wszKeys = wcsstr( varRelPath.bstrVal, L"=" ) + 1;

			// Get the raw class name
			// ======================
			dwStatus = GetRawClassName( pCookingInst, &wszRawClassName );

			if (SUCCEEDED(dwStatus)) 
			{
			    wmilib::auto_buffer<WCHAR>	adRawClassName( wszRawClassName );


			    // Append the key to the raw class name
			    // ====================================
			    wszRawInst = new WCHAR[ wcslen( wszRawClassName ) + wcslen( wszKeys ) + 10 ];
			    if (!wszRawInst)
			        return WBEM_E_OUT_OF_MEMORY;
			    wmilib::auto_buffer<WCHAR>	adRawInst( wszRawInst );

			    swprintf( wszRawInst, L"%s=%s", wszRawClassName, wszKeys );
			
			    // Add a raw instance to the internal refresher
			    // ============================================

			    dwStatus = m_pConfig->AddObjectByPath( pService, wszRawInst, 0, pCtx, &pRawInst, NULL );
			    CAutoRelease	arRawInst( pRawInst );

                if (SUCCEEDED(dwStatus)) {
			        // Return the IWbemObjectAccess interface of the raw instance
			        // ==========================================================
			        dwStatus = pRawInst->QueryInterface( IID_IWbemObjectAccess, (void**)ppRawInst );			        
			    }
			}
		}
	}
	
	return dwStatus;
}

WMISTATUS CRefresher::AddRawEnum( 
		IWbemServices* pNamespace, 
		IWbemContext * pCtx,
		WCHAR * wszRawClassName,  
		IWbemHiPerfEnum** ppRawEnum,
		long* plID )
///////////////////////////////////////////////////////////////////////////////
//
//	AddRawEnum is called to add the corresponding raw enumerator to the 
//	internal refrehser.  In order to add the raw enumerator to the refresher,
//	we must determine the raw class name, therefore, we must create a
//	cooking class in order to get the AutoCook_RawClass qualifier.
//
//	Parameters:
//		pNamespace		- The namespace pointer where the objects are located
//		wszRawClassName	- The name of the cooking class
//		ppRawEnum		- The raw WMI enumerator that was added to the 
//							internal refresher
//		plID			- The refresher ID of the raw enumerator
//
///////////////////////////////////////////////////////////////////////////////
{
	WMISTATUS dwStatus = WBEM_NO_ERROR;

	// Add the Raw enumerator to the internal refresher
	// ================================================

	if ( SUCCEEDED( dwStatus ) )
	{
		dwStatus = m_pConfig->AddEnum( pNamespace, wszRawClassName, 0, pCtx, ppRawEnum, plID );

#ifdef _VERBOSE	
		{
		    char pBuff[256];
		    wsprintfA(pBuff,"wszRawClassName %S pEnum %08x hr %08x\n",wszRawClassName,*ppRawEnum,dwStatus);
		    OutputDebugStringA(pBuff);
		}
#endif		
	}

	return dwStatus;
}

///////////////////////////////////////////////////////////////////////////////
//
//					COM methods
//
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRefresher::QueryInterface(REFIID riid, void** ppv)
///////////////////////////////////////////////////////////////////////////////
//
//	Standard QueryInterface
//
//	Parameters:
//		riid	- the ID of the requested interface
//		ppv		- a pointer to the interface pointer
//
///////////////////////////////////////////////////////////////////////////////
//ok
{
    if(riid == IID_IUnknown)
        *ppv = (LPVOID)(IUnknown*)(IWMIRefreshableCooker*)this;
    else if(riid == IID_IWMIRefreshableCooker)
        *ppv = (LPVOID)(IWMIRefreshableCooker*)this;
    else if(riid == IID_IWbemRefresher)
        *ppv = (LPVOID)(IWbemRefresher*)this;

	else return E_NOINTERFACE;

	((IUnknown*)*ppv)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG) CRefresher::AddRef()
///////////////////////////////////////////////////////////////////////////////
//
//	Standard COM AddRef
//
///////////////////////////////////////////////////////////////////////////////
//ok
{
    return InterlockedIncrement(&m_lRef);
}

STDMETHODIMP_(ULONG) CRefresher::Release()
///////////////////////////////////////////////////////////////////////////////
//
//	Standard COM Release
//
///////////////////////////////////////////////////////////////////////////////
//ok
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;

    return lRef;
}


STDMETHODIMP CRefresher::AddInstance(
	/*[in]  */ IWbemServices* pNamespace,					// The object's namespace
	/*[in]  */ IWbemContext * pCtx,                         // The Context         	
	/*[in]  */ IWbemObjectAccess* pCookingInstance,			// Cooking class definition
	/*[in]  */ IWbemObjectAccess* pRefreshableRawInstance,	// Raw instance 
	/*[out] */ IWbemObjectAccess** ppRefreshableInstance,	// Cooking instance
	/*[out] */ long* plId )
///////////////////////////////////////////////////////////////////////////////
//
//	AddInstance is called to add a WMI cooking instance to the refresher.  The 
//	refreshable instance is a clone of the WMI instance that is passed in 
//	by pCookingInstance.  Once the instance is cloned, the corresponding raw 
//	instance is added to the internal refresher, and then the cloned 
//	cooked instance and the refreshable raw instance are added to the object
//	cooker.  If a cooker does not already exist in the cooker cache, one 
//	is created.
//
//	Parameters:
//		pNamespace		- The namespace where the objects are located
//      pCtx            - IWbemContext implementation
//		pCookingInstance	- The instance to be cooked
//		pRefreshableRawInstance 
//						-             U N U S E D   P A R A M
//		ppRefreshableInstance
//						- The refreshable cooking instance passed back to 
//							the client                      
//		plId			- The ID of the instance
//
///////////////////////////////////////////////////////////////////////////////
{
	HRESULT hResult = S_OK;

	CWMISimpleObjectCooker*	pObjectCooker = NULL;
	IWbemObjectAccess*		pInternalRawInst = NULL;	// The raw instance for the short term local refresher solution

	// For now, we expect that the pRefreshableRawInstance parameter will be NULL 
	// since we are using an internal refresher to manage the raw instances
	// ==========================================================================

	if ( NULL == pNamespace || NULL == pCookingInstance || NULL != pRefreshableRawInstance )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	IWbemClassObject*	pNewClassObj = NULL;

	IWbemClassObject*	pClassObj = pCookingInstance;
	pClassObj->AddRef();
	CAutoRelease arClassObj( pClassObj );
	
	hResult = pClassObj->Clone( &pNewClassObj );

	CAutoRelease arNewClassObj( pNewClassObj );

	if (SUCCEEDED(hResult)) {

		hResult = pNewClassObj->QueryInterface( IID_IWbemObjectAccess, (void**)ppRefreshableInstance );

    	// Add the instance to the object cooker
	
	    if ( SUCCEEDED( hResult ) ){

		    // Get the raw instance (add it to the internal refresher)
    		hResult = AddRawInstance( pNamespace, pCtx, *ppRefreshableInstance, &pInternalRawInst );
    		CAutoRelease	arInternalRawInst( pInternalRawInst );

	    	 //m_pRefresher->Refresh( 0L );

		     // Retrieve the class cooker
		
    		if ( SUCCEEDED( hResult ) ){
    		
    			WCHAR*	wszClassName = NULL;

    			// Get the cooked class' name
	    		hResult = GetClassName( pCookingInstance, &wszClassName );
		    	wmilib::auto_buffer<WCHAR>	adaClassName( wszClassName );

			    if ( SUCCEEDED( hResult ) ){
			    
					// Search for an existing cooking cache object
					hResult = SearchCookingClassCache( wszClassName, &pObjectCooker );

					// If it does not exist, create a new one
					if ( FAILED ( hResult ) ) {
					
					    hResult = CreateObjectCooker( wszClassName, pCookingInstance, pInternalRawInst, &pObjectCooker, pNamespace );
					}
				}
			}
		}

    	// Add the cooking instance 
	    if ( SUCCEEDED( hResult ) ){
	    
    		hResult = pObjectCooker->SetCookedInstance( *ppRefreshableInstance, plId );

			if ( SUCCEEDED( hResult ) ){
			
				// Add the raw instance to the cooker
				hResult = pObjectCooker->BeginCooking( *plId, pInternalRawInst, m_dwRefreshId );
			}
		}
    }
    
	return hResult;
}

STDMETHODIMP CRefresher::AddEnum(
	/*[in]  */ IWbemServices* pNamespace,
	/*[in]  */ IWbemContext * pContext,
	/*[in, string]  */ LPCWSTR wszCookingClass,
	/*[in]  */ IWbemHiPerfEnum* pRefreshableEnum,
	/*[out] */ long* plId )
///////////////////////////////////////////////////////////////////////////////
//
//	AddEnum is called whenever a new cooked enumerator is added to the 
//	refresher.  WMI passes an IWbemHiPerfEnum object to the provider which
//	will be used for the cooked enumerator.  The corresponding raw enumerator 
//	is obtained when the added to the internal refresher.  Both of these 
//	enumerators as well as a cooking class template is added to the 
//	enumerator cache.
//
//	Parameters:
//		pNamespace		- The namespace where the objects are located
//		wszCookingClass - The name of the enumerators' cooking class 
//		pRefreshableEnum
//						- The enumerator to be used for the cooked classes
//		plId			- The ID of the enumerator
//
///////////////////////////////////////////////////////////////////////////////
{
	HRESULT hResult = WBEM_NO_ERROR;

	IWbemHiPerfEnum*	pRawEnum = NULL;
	long lRawID = 0;

	// Verify our 'in' parameters
	// ==========================

	if ( NULL == pNamespace || NULL == wszCookingClass || NULL == pRefreshableEnum )
	{
		hResult = WBEM_E_INVALID_PARAMETER;
	}

	if ( SUCCEEDED( hResult ) )
	{
		// Get the cooking object
		// ======================

		IWbemClassObject*	pCookedObject = NULL;
		IWbemClassObject*	pRawObject = NULL;

		BSTR strCookedClassName = SysAllocString( wszCookingClass );
		CAutoFree	afCookedClassName( strCookedClassName );

		hResult = pNamespace->GetObject( strCookedClassName, 0, NULL, &pCookedObject, NULL );
		CAutoRelease	arCookedObject( pCookedObject );		

		if ( SUCCEEDED( hResult ) )
		{
			WCHAR*	wszRawClassName = NULL;

			hResult = GetRawClassName( pCookedObject, &wszRawClassName );
			wmilib::auto_buffer<WCHAR> adRawClassName( wszRawClassName );

			if ( SUCCEEDED( hResult ))
			{				
				BSTR strRawClassName = SysAllocString(wszRawClassName);

				if (strRawClassName)
				{
					CAutoFree sfm(strRawClassName);

					hResult = pNamespace->GetObject( strRawClassName, 0, NULL, &pRawObject, NULL );
					CAutoRelease	arRawObject( pRawObject );
			
					if ( SUCCEEDED( hResult ) )
					{
						// Add the raw enumerator to our internal refresher
						// ================================================

						hResult = AddRawEnum( pNamespace, pContext, wszRawClassName, &pRawEnum, &lRawID );
						CAutoRelease arRawEnum( pRawEnum );

						if ( SUCCEEDED( hResult ) )
						{
							// Add the cooked enumerator to the enumerator cache
							// =================================================
							hResult = m_EnumCache.AddEnum( 
								wszCookingClass, 
								pCookedObject,    // this is acquired by CWMISimpleObjectCooker and CEnumeratorManager
								pRawObject,
								pRefreshableEnum, 
								pRawEnum, 
								lRawID, 
								(DWORD*)plId );
							// set the three bits 
							*plId |= WMI_COOKED_ENUM_MASK;
						}
					}
				}
				else
				{
					hResult = WBEM_E_OUT_OF_MEMORY;
				}
			}
		}
	}

	return hResult;
}

STDMETHODIMP CRefresher:: Remove(
			/*[in]  */ long lId )
///////////////////////////////////////////////////////////////////////////////
//
//	Remove is used to remove an object from the refresher.  Depending on the
//	object, the corresponding removal is performed.
//	
//	Parameters:
//		lID			- The ID of the object to be removed
//
///////////////////////////////////////////////////////////////////////////////
{
	HRESULT hResult = S_OK;

	// Is it an instance ID?
	// =====================

	if ( lId == ( lId & ~WMI_COOKED_ENUM_MASK ) )
	{
		CWMISimpleObjectCooker*	pCooker = NULL;

		hResult = m_CookingClassCache.BeginEnum();

		while ( S_OK == m_CookingClassCache.Next( &pCooker ) )
		{
			// TODO: ensure that the ID's are unique over all raw cookers!
			// ===========================================================

			pCooker->Remove( lId );
		}

		hResult = m_CookingClassCache.EndEnum();
	}
	else
	{
	    long RawId;
	    hResult = m_EnumCache.RemoveEnum( (lId & ~WMI_COOKED_ENUM_MASK) , &RawId );
		if (SUCCEEDED(hResult)){
		    m_pConfig->Remove(RawId,0);
		}

	}

	return hResult;
}

STDMETHODIMP CRefresher::Refresh()
///////////////////////////////////////////////////////////////////////////////
//
//	Refresh is called when the refreshers' objects are to be updated.  The 
//	instances are updated by explicitly enumerating through the instance
//	cache.  The enumerators' refresh is performed with the enumerator
//	cache.
//
//	Parameters: (none)
//
///////////////////////////////////////////////////////////////////////////////
{
	HRESULT hResult = S_OK;

	CWMISimpleObjectCooker*	pCooker = NULL;

	// Refresh the internal refresher
	// ==============================

    m_dwRefreshId++;

	hResult = m_pRefresher->Refresh( 0L );

	if ( SUCCEEDED( hResult ) )
	{
		// INSTANCES: Update the instance values for every class
		// =====================================================

		hResult = m_CookingClassCache.BeginEnum();

		while ( S_OK == m_CookingClassCache.Next( &pCooker ) )
		{
			// And update all of the instances
			// ===============================

			pCooker->Recalc(m_dwRefreshId);
		}

		hResult = m_CookingClassCache.EndEnum();

		// ENUMERATORS: Merge and update the values for items in the enumerator
		// ====================================================================

		if ( SUCCEEDED( hResult ) )
		{
			hResult = m_EnumCache.Refresh(m_dwRefreshId);
		}
	}

	return hResult;
}

STDMETHODIMP CRefresher::Refresh( long lFlags )
///////////////////////////////////////////////////////////////////////////////
//
//	This is the IWbemRefresher::Refresh implementation and is simply a call 
//	through.
//
///////////////////////////////////////////////////////////////////////////////
{
	HRESULT hResult = WBEM_NO_ERROR;

	hResult = Refresh();

	return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmicooker\rawcooker.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


// Cooker.cpp

#include "precomp.h"
#include <winperf.h>
#include "pdh.h"
#include "pdhmsg.h"
#include <pdhicalc.h>

#include "RawCooker.h"

CCalcTable::CCalcTable()
{
	m_lSize = 5;

	// Ordered list based on Perf IDs
	// ==============================

	m_aTable[0].Init( 0x00000001,	CRawCooker::_Average );
	m_aTable[1].Init( 0x00000002,	CRawCooker::_Min );	
	m_aTable[2].Init( 0x00000003,	CRawCooker::_Max );	
	m_aTable[3].Init( 0x00000004,	CRawCooker::_Range );	
    m_aTable[4].Init( 0x00000005,	CRawCooker::_Variance );
	
}

CCalcTable::~CCalcTable()
{
}

CCalcRecord* CCalcTable::GetCalcRecord( DWORD dwCookingType )
{
	CCalcRecord* pCalcRecord = NULL;

	long	left = 0,
			right = m_lSize - 1,
			mid = right / 2;

	DWORD	dwMidVal = 0;

	bool	bFound = FALSE;

	while ( !bFound && ( left <= right ) )
	{
		dwMidVal = m_aTable[mid].GetID();

		if ( dwCookingType < dwMidVal )
		{
			right = mid - 1;
			mid = ( left + right ) / 2;
		}
		else if ( dwCookingType > dwMidVal )
		{
			left = mid + 1;
			mid = ( left + right ) / 2;
		}
		else
		{
			bFound = TRUE;
			pCalcRecord = &m_aTable[mid];
		}
	}

	return pCalcRecord;
}

CRawCooker::CRawCooker() : m_lRef( 1 ), m_pCalcRecord( NULL )
{
}

CRawCooker::~CRawCooker()
{
}

//////////////////////////////////////////////////////////////
//
//					COM methods
//
//////////////////////////////////////////////////////////////

STDMETHODIMP CRawCooker::QueryInterface(REFIID riid, void** ppv)
//////////////////////////////////////////////////////////////
//
//	Standard QueryInterface
//
//	Parameters:
//		riid	- the ID of the requested interface
//		ppv		- a pointer to the interface pointer
//
//////////////////////////////////////////////////////////////
//ok
{
    if(riid == IID_IUnknown)
        *ppv = (LPVOID)(IUnknown*)(IWMISimpleCooker*)this;
    else if(riid == IID_IWMISimpleCooker)
        *ppv = (LPVOID)(IWMISimpleCooker*)this;
	else return E_NOINTERFACE;

	((IUnknown*)*ppv)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG) CRawCooker::AddRef()
//////////////////////////////////////////////////////////////
//
//	Standard COM AddRef
//
//////////////////////////////////////////////////////////////
//ok
{
    return InterlockedIncrement(&m_lRef);
}

STDMETHODIMP_(ULONG) CRawCooker::Release()
//////////////////////////////////////////////////////////////
//
//	Standard COM Release
//
//////////////////////////////////////////////////////////////
//ok
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;

    return lRef;
}


STDMETHODIMP CRawCooker::CookRawValues( 	
		/*[in] */	   DWORD dwCookingType,
        /*[in] */	   DWORD dwNumSamples,
        /*[in] */	__int64* anTimeStamp,
        /*[in] */	__int64* anRawValue,
        /*[in] */	__int64* anBase,
        /*[in] */	__int64  nTimeFrequency,
        /*[in] */     long   lScale,
		/*[out]*/	__int64* pnResult )
{
	HRESULT hResult = S_OK;

	PDH_STATUS				lRet = 0;
	LPCOUNTERCALC			pCalcFunction = NULL;
	LPCOUNTERSTAT			pStatFunction = NULL;
	PDH_FMT_COUNTERVALUE	fmtValue;
	memset( &fmtValue, 0, sizeof( PDH_FMT_COUNTERVALUE ) );

	if ( AssignCalcFunction( dwCookingType, &pCalcFunction, &pStatFunction ) && ( 2 == dwNumSamples ) )
	{
		PDH_RAW_COUNTER RawValue1;
    	PDH_RAW_COUNTER RawValue2;

		RawValue1.CStatus = 0;
		RawValue1.MultiCount = 0;

		RawValue2.CStatus = 0;
		RawValue2.MultiCount = 0;		

		if ((dwCookingType == PERF_RAW_FRACTION) ||
		    (dwCookingType == PERF_SAMPLE_FRACTION) ||
		    (dwCookingType == PERF_AVERAGE_TIMER) ||
		    (dwCookingType == PERF_AVERAGE_BULK)) {

		    RawValue1.TimeStamp = *(FILETIME*)&anTimeStamp[0];
			RawValue1.FirstValue = anRawValue[0];
			RawValue1.SecondValue = anBase[0];

		    RawValue2.TimeStamp = *(FILETIME*)&anTimeStamp[1];
			RawValue2.FirstValue = anRawValue[1];
			RawValue2.SecondValue = anBase[1];
		
		} else {

		    RawValue1.TimeStamp = *(FILETIME *)&anBase[0];
			RawValue1.FirstValue = anRawValue[0];
			RawValue1.SecondValue = anTimeStamp[0]; 

		    RawValue2.TimeStamp = *(FILETIME *)&anBase[1]; 
			RawValue2.FirstValue = anRawValue[1];
			RawValue2.SecondValue = anTimeStamp[1]; 

		}

		DWORD dwFormat = PDH_FMT_LARGE;
		// do not scale if lScale is 0
		if (!lScale)
		{
		    dwFormat |= PDH_FMT_NOSCALE;
		}

		lRet = PdhiComputeFormattedValue( 
					pCalcFunction,
					dwCookingType,
					lScale,
					dwFormat, //PDH_FMT_NOSCALE | PDH_FMT_LARGE,
					&RawValue1,
					&RawValue2,
					&nTimeFrequency,
					0,
					&fmtValue );

		if ( 0 == lRet )
			*pnResult = fmtValue.largeValue;
		else if (lRet == PDH_CALC_NEGATIVE_VALUE ||
		         lRet == PDH_CALC_NEGATIVE_DENOMINATOR) {
		    *pnResult = 0;
		} else {
			hResult = lRet; //WBEM_E_FAILED;
	    }
	}
	else
	{
		// The last calculation record is cached in an attempt to avoid a new
		// search. A cooking type of zero means "use the last clac record"
		// ==================================================================

		if ( NULL == m_pCalcRecord || ( m_pCalcRecord->GetID() != dwCookingType ) && 
									  ( m_pCalcRecord->GetID() != 0 ) )
		{
			m_pCalcRecord = m_CalcTable.GetCalcRecord( dwCookingType );

			if ( NULL == m_pCalcRecord )
			{
				hResult = E_FAIL;
			}
		}

		if ( SUCCEEDED( hResult ) )
		{
			// Calculate the result
			// ====================

			PERFCALC*	pCalc = m_pCalcRecord->GetCalc();

			if ( NULL != pCalc )
			{
				hResult = pCalc( dwNumSamples,
								 anTimeStamp, 
								 anRawValue,
								 anBase,
								 nTimeFrequency, 
								 pnResult );
			}
		}
	}

	return hResult;
}

//////////////////////////////////////////////////////////////
//
//	Perf Calculations
//
//////////////////////////////////////////////////////////////

WMISTATUS APIENTRY CRawCooker::_Average( DWORD dwNumSamples,
										 __int64*	anTimeStamp,
										 __int64*	anRawValue,
										 __int64*	anBase,
										 __int64	nTimeFrequency,
										 __int64*	pnResult)
{
	WMISTATUS dwStatus = WBEM_NO_ERROR;

	__int64 nVal = 0;

	if ( 0 == dwNumSamples )
	{
		dwStatus = WBEM_E_FAILED;
	}

	for ( DWORD dwSample = 0; SUCCEEDED( dwStatus ) && dwSample < dwNumSamples; dwSample++ )
	{
		if ( (0x7FFFFFFFFFFFFFFF - nVal) < anRawValue[dwSample] )
			dwStatus = WBEM_E_INVALID_OPERATION;
		else
			nVal += anRawValue[dwSample];
	}
	
	*pnResult = nVal / dwNumSamples;

	return dwStatus;
}

WMISTATUS APIENTRY CRawCooker::_Min( DWORD dwNumSamples,
									 __int64*	anTimeStamp,
									 __int64*	anRawValue,
									 __int64*	anBase,
									 __int64	nTimeFrequency,
									 __int64*	pnResult)
{

	if ( 0 == dwNumSamples ){
		return WBEM_E_FAILED;
	};

	__int64 nVal = anRawValue[0];


	for ( DWORD dwSample = 1;  dwSample < dwNumSamples; dwSample++ ){
		if ( anRawValue[dwSample] < nVal ){
			nVal = anRawValue[dwSample];
		}
	}
	
	*pnResult = nVal;

	return WBEM_NO_ERROR;

}

WMISTATUS APIENTRY CRawCooker::_Max( DWORD dwNumSamples,
									 __int64*	anTimeStamp,
									 __int64*	anRawValue,
									 __int64*	anBase,
									 __int64	nTimeFrequency,
									 __int64*	pnResult)
{

	if ( 0 == dwNumSamples ){
		return WBEM_E_FAILED;
	};

	__int64	nVal = anRawValue[0];

	for ( DWORD dwSample = 1;  dwSample < dwNumSamples; dwSample++ ){
		if ( anRawValue[dwSample] > nVal ){
			nVal = anRawValue[dwSample];
		}
	}
	
	*pnResult = nVal;

	return WBEM_NO_ERROR;
}

WMISTATUS APIENTRY CRawCooker::_Range( DWORD dwNumSamples,
									 __int64*	anTimeStamp,
									 __int64*	anRawValue,
									 __int64*	anBase,
									 __int64	nTimeFrequency,
									 __int64*	pnResult)
{

	if ( 0 == dwNumSamples ){
		return WBEM_E_FAILED;
	};

	__int64	nValMin = anRawValue[0];
	__int64	nValMax = anRawValue[0];


	for ( DWORD dwSample = 1;  dwSample < dwNumSamples; dwSample++ ){
		if ( anRawValue[dwSample] > nValMax ){
			nValMax = anRawValue[dwSample];
		};
		if ( anRawValue[dwSample] < nValMin ){
			nValMin = anRawValue[dwSample];
		};

	}
	
	*pnResult = (nValMax - nValMin);

	return WBEM_NO_ERROR;
}


WMISTATUS APIENTRY CRawCooker::_Variance( DWORD dwNumSamples,
									 __int64*	anTimeStamp,
									 __int64*	anRawValue,
									 __int64*	anBase,
									 __int64	nTimeFrequency,
									 __int64*	pnResult)
{

	if ( 0 == dwNumSamples ){
		return WBEM_E_FAILED;
	};

	double	SumX_i = 0;
	double	Average = 0;
	
	for ( DWORD dwSample = 0;  dwSample < dwNumSamples; dwSample++ ){
	
        SumX_i += (anRawValue[dwSample]*anRawValue[dwSample]);
        Average += anRawValue[dwSample];
	}
	
	double Tmp = (double(SumX_i/dwNumSamples)  - (double(Average/dwNumSamples)*double(Average/dwNumSamples)));
	*pnResult = __int64(Tmp);

	return WBEM_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmicooker\server.cpp ===
////////////////////////////////////////////////////////////////////////
//
//  Server.cpp
//
//	Module:	WMI high performance provider sample code
//
//  Generic COM server framework, adapted for the BasicHiPerf provider 
//	sample.  This module contains nothing specific to the BasicHiPerf 
//	provider except what is defined in the section bracketed by the 
//	CLSID SPECIFIC comments below.
//
//  History:
//  raymcc        25-Nov-97     Created.
//  raymcc        18-Feb-98     Updated for NT5 Beta 2 version.
//	a-dcrews      12-Jan-99		Adapted for BasicHiPerf.dll
//
//
//  Copyright (c) 1997-2001 Microsoft Corporation, All rights reserved
//
////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <time.h>
#include <initguid.h>
#include <autoptr.h>


/////////////////////////////////////////////////////////////////////////////
//
//  BEGIN CLSID SPECIFIC SECTION
//
//

#include "wbemprov.h"
#include "Provider.h"
#include "Factory.h"

#define IMPLEMENTED_CLSID           CLSID_HiPerfCooker_v1
#define SERVER_REGISTRY_COMMENT     L"WMI High Performance Cooker"
#define CPP_CLASS_NAME              CHiPerfProvider
#define INTERFACE_CAST              (IWbemHiPerfProvider*)

// {B0A2AB46-F612-4469-BEC4-7AB038BC476C}
DEFINE_GUID(IMPLEMENTED_CLSID, 
0xb0a2ab46, 0xf612, 0x4469, 0xbe, 0xc4, 0x7a, 0xb0, 0x38, 0xbc, 0x47, 0x6c);



//
//  END CLSID SPECIFIC SECTION
//
/////////////////////////////////////////////////////////////////////////////


HINSTANCE g_hInstance;
long g_lLocks = 0;
long g_lObjects = 0;

//***************************************************************************
//
//  DllMain
//
//  Dll entry point.
//
//  PARAMETERS:
//
//      HINSTANCE hinstDLL      The handle to our DLL.
//      DWORD dwReason          DLL_PROCESS_ATTACH on load,
//                              DLL_PROCESS_DETACH on shutdown,
//                              DLL_THREAD_ATTACH/DLL_THREAD_DETACH otherwise.
//      LPVOID lpReserved       Reserved
//
//  RETURN VALUES:
//
//      TRUE is successful, FALSE if a fatal error occured.
//      NT behaves very ugly if FALSE is returned.
//
//***************************************************************************
BOOL WINAPI DllMain(
    HINSTANCE hinstDLL,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
     if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hInstance = hinstDLL;
    }

    return TRUE;
}



//***************************************************************************
//
//  DllGetClassObject
//
//  Standard OLE In-Process Server entry point to return an class factory
//  instance.
//
//  PARAMETERS:
//
//  RETURNS:
//
//      S_OK                Success
//      E_NOINTERFACE       An interface other that IClassFactory was asked for
//      E_OUTOFMEMORY
//      E_FAILED            Initialization failed, or an unsupported clsid was
//                          asked for.
//
//***************************************************************************

STDAPI DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID * ppv
    )
{
    CClassFactory *pClassFactory = NULL;
	HRESULT hRes;

    //  Verify the caller is asking for our type of object
	// ===================================================

    if (IMPLEMENTED_CLSID == rclsid) 
	{
		// Create the class factory
		// ========================

		pClassFactory = new CClassFactory;

		if (!pClassFactory)
			return E_OUTOFMEMORY;
		
		hRes = pClassFactory->QueryInterface(riid, ppv);
		if (FAILED(hRes))
		{
			delete pClassFactory;
			return hRes;
		}
		hRes = S_OK;
	}
	else 
		hRes = CLASS_E_CLASSNOTAVAILABLE;

    return hRes;
}

//***************************************************************************
//
//  DllCanUnloadNow
//
//  Standard OLE entry point for server shutdown request. Allows shutdown
//  only if no outstanding objects or locks are present.
//
//  RETURN VALUES:
//
//      S_OK        May unload now.
//      S_FALSE     May not.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    HRESULT hRes = S_FALSE;

    if (0 == g_lLocks && 0 == g_lObjects)
        hRes = S_OK;

    return hRes;
}

//***************************************************************************
//
//  DllRegisterServer
//
//  Standard OLE entry point for registering the server.
//
//  RETURN VALUES:
//
//      S_OK        Registration was successful
//      E_FAIL      Registration failed.
//
//***************************************************************************

STDAPI DllRegisterServer(void)
{
    WCHAR * Path = new WCHAR[1024];
    wmilib::auto_buffer<WCHAR> rm1_(Path);
    WCHAR * pGuidStr = 0;
    WCHAR * KeyPath = new WCHAR[1024];
    wmilib::auto_buffer<WCHAR> rm2_(KeyPath);

    if (0 == Path || 0 == KeyPath)
    {
        return E_OUTOFMEMORY;
    }
    
    // Get the dll's filename
    // ======================

    GetModuleFileNameW(g_hInstance, Path, 1024);

    // Convert CLSID to string.
    // ========================

    StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr);
    swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

    // Place it in registry.
    // CLSID\\CLSID_Nt5PerProvider_v1 : <no_name> : "name"
    //      \\CLSID_Nt5PerProvider_v1\\InProcServer32 : <no_name> : "path to DLL"
    //                                    : ThreadingModel : "both"
    // ==============================================================

    HKEY hKey;
    LONG lRes = RegCreateKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    wchar_t *pName = SERVER_REGISTRY_COMMENT; 
    RegSetValueExW(hKey, 0, 0, REG_SZ, (const BYTE *) pName, wcslen(pName) * 2 + 2);

    HKEY hSubkey;
    lRes = RegCreateKey(hKey, _TEXT("InprocServer32"), &hSubkey);

    RegSetValueExW(hSubkey, 0, 0, REG_SZ, (const BYTE *) Path, wcslen(Path) * 2 + 2);
    RegSetValueExW(hSubkey, L"ThreadingModel", 0, REG_SZ, (const BYTE *) L"Both", wcslen(L"Both") * 2 + 2);

    RegCloseKey(hSubkey);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}

//***************************************************************************
//
//  DllUnregisterServer
//
//  Standard OLE entry point for unregistering the server.
//
//  RETURN VALUES:
//
//      S_OK        Unregistration was successful
//      E_FAIL      Unregistration failed.
//
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    wchar_t *pGuidStr = 0;
    HKEY hKey;
    wchar_t KeyPath[256];

    StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr);
    swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

    // Delete InProcServer32 subkey.
    // =============================
    LONG lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, L"InprocServer32");
    RegCloseKey(hKey);

    // Delete CLSID GUID key.
    // ======================

    lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, L"Software\\Classes\\CLSID", &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, pGuidStr);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmicooker\wmicooker.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0334 */
/* Compiler settings for wmicooker.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmicooker_h__
#define __wmicooker_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWMIRefreshableCooker_FWD_DEFINED__
#define __IWMIRefreshableCooker_FWD_DEFINED__
typedef interface IWMIRefreshableCooker IWMIRefreshableCooker;
#endif 	/* __IWMIRefreshableCooker_FWD_DEFINED__ */


#ifndef __IWMISimpleObjectCooker_FWD_DEFINED__
#define __IWMISimpleObjectCooker_FWD_DEFINED__
typedef interface IWMISimpleObjectCooker IWMISimpleObjectCooker;
#endif 	/* __IWMISimpleObjectCooker_FWD_DEFINED__ */


#ifndef __IWMISimpleCooker_FWD_DEFINED__
#define __IWMISimpleCooker_FWD_DEFINED__
typedef interface IWMISimpleCooker IWMISimpleCooker;
#endif 	/* __IWMISimpleCooker_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "wbemcli.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IWMIRefreshableCooker_INTERFACE_DEFINED__
#define __IWMIRefreshableCooker_INTERFACE_DEFINED__

/* interface IWMIRefreshableCooker */
/* [uuid][object][local][restricted] */ 


EXTERN_C const IID IID_IWMIRefreshableCooker;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("13ED7E55-8D63-41b0-9086-D0C5C17364C8")
    IWMIRefreshableCooker : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddInstance( 
            /* [in] */ IWbemServices *pService,
            /* [in] */ IWbemObjectAccess *pCookingClass,
            /* [in] */ IWbemObjectAccess *pCookingInstance,
            /* [out] */ IWbemObjectAccess **ppRefreshableInstance,
            /* [out] */ long *plId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddEnum( 
            /* [in] */ IWbemServices *pService,
            /* [string][in] */ LPCWSTR szCookingClass,
            /* [in] */ IWbemHiPerfEnum *pRefreshableEnum,
            /* [out] */ long *plId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ long lId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMIRefreshableCookerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMIRefreshableCooker * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMIRefreshableCooker * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMIRefreshableCooker * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddInstance )( 
            IWMIRefreshableCooker * This,
            /* [in] */ IWbemServices *pService,
            /* [in] */ IWbemObjectAccess *pCookingClass,
            /* [in] */ IWbemObjectAccess *pCookingInstance,
            /* [out] */ IWbemObjectAccess **ppRefreshableInstance,
            /* [out] */ long *plId);
        
        HRESULT ( STDMETHODCALLTYPE *AddEnum )( 
            IWMIRefreshableCooker * This,
            /* [in] */ IWbemServices *pService,
            /* [string][in] */ LPCWSTR szCookingClass,
            /* [in] */ IWbemHiPerfEnum *pRefreshableEnum,
            /* [out] */ long *plId);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IWMIRefreshableCooker * This,
            /* [in] */ long lId);
        
        HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IWMIRefreshableCooker * This);
        
        END_INTERFACE
    } IWMIRefreshableCookerVtbl;

    interface IWMIRefreshableCooker
    {
        CONST_VTBL struct IWMIRefreshableCookerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMIRefreshableCooker_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMIRefreshableCooker_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMIRefreshableCooker_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMIRefreshableCooker_AddInstance(This,pService,pCookingClass,pCookingInstance,ppRefreshableInstance,plId)	\
    (This)->lpVtbl -> AddInstance(This,pService,pCookingClass,pCookingInstance,ppRefreshableInstance,plId)

#define IWMIRefreshableCooker_AddEnum(This,pService,szCookingClass,pRefreshableEnum,plId)	\
    (This)->lpVtbl -> AddEnum(This,pService,szCookingClass,pRefreshableEnum,plId)

#define IWMIRefreshableCooker_Remove(This,lId)	\
    (This)->lpVtbl -> Remove(This,lId)

#define IWMIRefreshableCooker_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMIRefreshableCooker_AddInstance_Proxy( 
    IWMIRefreshableCooker * This,
    /* [in] */ IWbemServices *pService,
    /* [in] */ IWbemObjectAccess *pCookingClass,
    /* [in] */ IWbemObjectAccess *pCookingInstance,
    /* [out] */ IWbemObjectAccess **ppRefreshableInstance,
    /* [out] */ long *plId);


void __RPC_STUB IWMIRefreshableCooker_AddInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMIRefreshableCooker_AddEnum_Proxy( 
    IWMIRefreshableCooker * This,
    /* [in] */ IWbemServices *pService,
    /* [string][in] */ LPCWSTR szCookingClass,
    /* [in] */ IWbemHiPerfEnum *pRefreshableEnum,
    /* [out] */ long *plId);


void __RPC_STUB IWMIRefreshableCooker_AddEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMIRefreshableCooker_Remove_Proxy( 
    IWMIRefreshableCooker * This,
    /* [in] */ long lId);


void __RPC_STUB IWMIRefreshableCooker_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMIRefreshableCooker_Refresh_Proxy( 
    IWMIRefreshableCooker * This);


void __RPC_STUB IWMIRefreshableCooker_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMIRefreshableCooker_INTERFACE_DEFINED__ */


#ifndef __IWMISimpleObjectCooker_INTERFACE_DEFINED__
#define __IWMISimpleObjectCooker_INTERFACE_DEFINED__

/* interface IWMISimpleObjectCooker */
/* [uuid][object][local][restricted] */ 


EXTERN_C const IID IID_IWMISimpleObjectCooker;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A239BDF1-0AB1-45a0-8764-159115689589")
    IWMISimpleObjectCooker : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetClass( 
            /* [in] */ WCHAR *wszCookingClassName,
            /* [in] */ IWbemObjectAccess *pCookingClass,
            /* [in] */ IWbemObjectAccess *pRawClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCookedInstance( 
            /* [in] */ IWbemObjectAccess *pCookedInstance,
            /* [out] */ long *plId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginCooking( 
            /* [in] */ long lId,
            /* [in] */ IWbemObjectAccess *pSampleInstance,
            /* [in] */ unsigned long dwRefresherId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopCooking( 
            /* [in] */ long lId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Recalc( 
            /* [in] */ unsigned long dwRefresherId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ long lId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMISimpleObjectCookerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMISimpleObjectCooker * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMISimpleObjectCooker * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMISimpleObjectCooker * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetClass )( 
            IWMISimpleObjectCooker * This,
            /* [in] */ WCHAR *wszCookingClassName,
            /* [in] */ IWbemObjectAccess *pCookingClass,
            /* [in] */ IWbemObjectAccess *pRawClass);
        
        HRESULT ( STDMETHODCALLTYPE *SetCookedInstance )( 
            IWMISimpleObjectCooker * This,
            /* [in] */ IWbemObjectAccess *pCookedInstance,
            /* [out] */ long *plId);
        
        HRESULT ( STDMETHODCALLTYPE *BeginCooking )( 
            IWMISimpleObjectCooker * This,
            /* [in] */ long lId,
            /* [in] */ IWbemObjectAccess *pSampleInstance,
            /* [in] */ unsigned long dwRefresherId);
        
        HRESULT ( STDMETHODCALLTYPE *StopCooking )( 
            IWMISimpleObjectCooker * This,
            /* [in] */ long lId);
        
        HRESULT ( STDMETHODCALLTYPE *Recalc )( 
            IWMISimpleObjectCooker * This,
            /* [in] */ unsigned long dwRefresherId);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IWMISimpleObjectCooker * This,
            /* [in] */ long lId);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IWMISimpleObjectCooker * This);
        
        END_INTERFACE
    } IWMISimpleObjectCookerVtbl;

    interface IWMISimpleObjectCooker
    {
        CONST_VTBL struct IWMISimpleObjectCookerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMISimpleObjectCooker_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMISimpleObjectCooker_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMISimpleObjectCooker_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMISimpleObjectCooker_SetClass(This,wszCookingClassName,pCookingClass,pRawClass)	\
    (This)->lpVtbl -> SetClass(This,wszCookingClassName,pCookingClass,pRawClass)

#define IWMISimpleObjectCooker_SetCookedInstance(This,pCookedInstance,plId)	\
    (This)->lpVtbl -> SetCookedInstance(This,pCookedInstance,plId)

#define IWMISimpleObjectCooker_BeginCooking(This,lId,pSampleInstance,dwRefresherId)	\
    (This)->lpVtbl -> BeginCooking(This,lId,pSampleInstance,dwRefresherId)

#define IWMISimpleObjectCooker_StopCooking(This,lId)	\
    (This)->lpVtbl -> StopCooking(This,lId)

#define IWMISimpleObjectCooker_Recalc(This,dwRefresherId)	\
    (This)->lpVtbl -> Recalc(This,dwRefresherId)

#define IWMISimpleObjectCooker_Remove(This,lId)	\
    (This)->lpVtbl -> Remove(This,lId)

#define IWMISimpleObjectCooker_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMISimpleObjectCooker_SetClass_Proxy( 
    IWMISimpleObjectCooker * This,
    /* [in] */ WCHAR *wszCookingClassName,
    /* [in] */ IWbemObjectAccess *pCookingClass,
    /* [in] */ IWbemObjectAccess *pRawClass);


void __RPC_STUB IWMISimpleObjectCooker_SetClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMISimpleObjectCooker_SetCookedInstance_Proxy( 
    IWMISimpleObjectCooker * This,
    /* [in] */ IWbemObjectAccess *pCookedInstance,
    /* [out] */ long *plId);


void __RPC_STUB IWMISimpleObjectCooker_SetCookedInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMISimpleObjectCooker_BeginCooking_Proxy( 
    IWMISimpleObjectCooker * This,
    /* [in] */ long lId,
    /* [in] */ IWbemObjectAccess *pSampleInstance,
    /* [in] */ unsigned long dwRefresherId);


void __RPC_STUB IWMISimpleObjectCooker_BeginCooking_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMISimpleObjectCooker_StopCooking_Proxy( 
    IWMISimpleObjectCooker * This,
    /* [in] */ long lId);


void __RPC_STUB IWMISimpleObjectCooker_StopCooking_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMISimpleObjectCooker_Recalc_Proxy( 
    IWMISimpleObjectCooker * This,
    /* [in] */ unsigned long dwRefresherId);


void __RPC_STUB IWMISimpleObjectCooker_Recalc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMISimpleObjectCooker_Remove_Proxy( 
    IWMISimpleObjectCooker * This,
    /* [in] */ long lId);


void __RPC_STUB IWMISimpleObjectCooker_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMISimpleObjectCooker_Reset_Proxy( 
    IWMISimpleObjectCooker * This);


void __RPC_STUB IWMISimpleObjectCooker_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMISimpleObjectCooker_INTERFACE_DEFINED__ */


#ifndef __IWMISimpleCooker_INTERFACE_DEFINED__
#define __IWMISimpleCooker_INTERFACE_DEFINED__

/* interface IWMISimpleCooker */
/* [uuid][object][local][restricted] */ 


EXTERN_C const IID IID_IWMISimpleCooker;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("510ADF6E-D481-4a64-B74A-CC712E11AA34")
    IWMISimpleCooker : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CookRawValues( 
            /* [in] */ DWORD dwCookingType,
            /* [in] */ DWORD dwNumSamples,
            /* [size_is][in] */ __int64 *anTimeStamp,
            /* [size_is][in] */ __int64 *anRawValue,
            /* [size_is][in] */ __int64 *anBase,
            /* [in] */ __int64 nTimeFrequency,
            /* [out] */ __int64 *pnResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMISimpleCookerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMISimpleCooker * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMISimpleCooker * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMISimpleCooker * This);
        
        HRESULT ( STDMETHODCALLTYPE *CookRawValues )( 
            IWMISimpleCooker * This,
            /* [in] */ DWORD dwCookingType,
            /* [in] */ DWORD dwNumSamples,
            /* [size_is][in] */ __int64 *anTimeStamp,
            /* [size_is][in] */ __int64 *anRawValue,
            /* [size_is][in] */ __int64 *anBase,
            /* [in] */ __int64 nTimeFrequency,
            /* [out] */ __int64 *pnResult);
        
        END_INTERFACE
    } IWMISimpleCookerVtbl;

    interface IWMISimpleCooker
    {
        CONST_VTBL struct IWMISimpleCookerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMISimpleCooker_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMISimpleCooker_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMISimpleCooker_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMISimpleCooker_CookRawValues(This,dwCookingType,dwNumSamples,anTimeStamp,anRawValue,anBase,nTimeFrequency,pnResult)	\
    (This)->lpVtbl -> CookRawValues(This,dwCookingType,dwNumSamples,anTimeStamp,anRawValue,anBase,nTimeFrequency,pnResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMISimpleCooker_CookRawValues_Proxy( 
    IWMISimpleCooker * This,
    /* [in] */ DWORD dwCookingType,
    /* [in] */ DWORD dwNumSamples,
    /* [size_is][in] */ __int64 *anTimeStamp,
    /* [size_is][in] */ __int64 *anRawValue,
    /* [size_is][in] */ __int64 *anBase,
    /* [in] */ __int64 nTimeFrequency,
    /* [out] */ __int64 *pnResult);


void __RPC_STUB IWMISimpleCooker_CookRawValues_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMISimpleCooker_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmicooker\wmiobjcooker.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


// WMIObjCooker.cpp

#include "precomp.h"
#include "WMIObjCooker.h"
#include "RawCooker.h"
#include <comdef.h>

///////////////////////////////////////////////////////////////////////////////
//
//	Helper Functions
//	================
//
///////////////////////////////////////////////////////////////////////////////

WMISTATUS GetPropValue( CProperty* pProp, IWbemObjectAccess* pInstance, __int64* pnResult )
{
	WMISTATUS dwStatus = WBEM_NO_ERROR;

	unsigned __int64 nResult = 0;
	DWORD dwRes = 0;

	switch( pProp->GetType() )
	{
	case CIM_UINT32:
		{
			dwStatus = pInstance->ReadDWORD( pProp->GetHandle(), &dwRes );
			if (pnResult) {
			    *pnResult = dwRes;
			}			
		}break;
	case CIM_UINT64:
		{
			dwStatus = pInstance->ReadQWORD( pProp->GetHandle(), &nResult );
			if (pnResult) {
			    *pnResult = nResult;
			}
		}break;
	default:
	    dwStatus = WBEM_E_TYPE_MISMATCH;
	}

	return dwStatus;
}

//////////////////////////////////////////////////////////////
//
//	CWMISimpleObjectCooker
//
//////////////////////////////////////////////////////////////

CWMISimpleObjectCooker::CWMISimpleObjectCooker( WCHAR* wszCookingClassName, 
                                                IWbemObjectAccess* pCookingClass, 
                                                IWbemObjectAccess* pRawClass, 
                                                IWbemServices * pNamespace ) : 
  m_lRef( 1 ),
  m_pCookingClass( NULL ),
  m_wszClassName(NULL),
  m_pNamespace(NULL),
  m_dwPropertyCacheSize( 16 ),
  m_dwNumProperties( 0 ),
  m_NumInst(0),
  m_InitHR(WBEM_E_INITIALIZATION_FAILURE)  
{
#ifdef _VERBOSE
    {
        char pBuff[128];
        wsprintfA(pBuff,"Cooker %p\n",this);
        OutputDebugStringA(pBuff);
    }
#endif
    
    if (pNamespace){
        m_pNamespace = pNamespace;
        m_pNamespace->AddRef();
    }

	m_InitHR = SetClass( wszCookingClassName, pCookingClass, pRawClass );

    if (m_pNamespace){
        m_pNamespace->Release();
        m_pNamespace = NULL;
    }
	
}

CWMISimpleObjectCooker::~CWMISimpleObjectCooker()
{
    
    Reset();

	// Release the cooking class
	// =========================

	if ( m_pCookingClass ){
		m_pCookingClass->Release();
    }
		
    if (m_pNamespace){
        m_pNamespace->Release();
    }

	// Delete the property cache
	// =========================
	
	for (DWORD i=0;i<m_apPropertyCache.size();i++){
	    CCookingProperty* pCookProp = m_apPropertyCache[i];
	    if (pCookProp)
    	    delete pCookProp;
	}

	if (m_wszClassName)
	    delete [] m_wszClassName;

#ifdef _VERBOSE    
    {
        char pBuff[128];
        wsprintfA(pBuff,"~Cooker %p istances left %d\n",this,m_NumInst);
        OutputDebugStringA(pBuff);
    }
#endif
	    	
}

//////////////////////////////////////////////////////////////
//
//					COM methods
//
//////////////////////////////////////////////////////////////

STDMETHODIMP CWMISimpleObjectCooker::QueryInterface(REFIID riid, void** ppv)
//////////////////////////////////////////////////////////////
//
//	Standard QueryInterface
//
//	Parameters:
//		riid	- the ID of the requested interface
//		ppv		- a pointer to the interface pointer
//
//////////////////////////////////////////////////////////////
//ok
{
    if(riid == IID_IUnknown)
        *ppv = (LPVOID)(IUnknown*)(IWMISimpleCooker*)this;
    else if(riid == IID_IWMISimpleCooker)
        *ppv = (LPVOID)(IWMISimpleCooker*)this;
	else return E_NOINTERFACE;

	((IUnknown*)*ppv)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG) CWMISimpleObjectCooker::AddRef()
//////////////////////////////////////////////////////////////
//
//	Standard COM AddRef
//
//////////////////////////////////////////////////////////////
//ok
{
    return InterlockedIncrement(&m_lRef);
}

STDMETHODIMP_(ULONG) CWMISimpleObjectCooker::Release()
//////////////////////////////////////////////////////////////
//
//	Standard COM Release
//
//////////////////////////////////////////////////////////////
//ok
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;

    return lRef;
}

STDMETHODIMP CWMISimpleObjectCooker::SetClass( 
		/*[in]	*/ WCHAR* wszCookingClassName,
		/*[in]  */ IWbemObjectAccess *pCookingClassAccess,
		/*[in]  */ IWbemObjectAccess *pRawClass )
{
	HRESULT	hResult = S_OK;
	IWbemClassObject * pClass = NULL;

	// Cannot override the original cooking class for now
	// ==================================================

	if ( ( NULL != m_pCookingClass ) || ( NULL == pCookingClassAccess ) )
		hResult = E_FAIL;

    // what we put here MUST be a class, Singletons are OK

    if (m_pNamespace) 
    {
		_variant_t VarGenus;
		hResult = pCookingClassAccess->Get(L"__GENUS",0,&VarGenus,NULL,NULL);
		
		if (SUCCEEDED(hResult))
		{
		    if ((CIM_SINT32 == V_VT(&VarGenus)) &&
		        WBEM_GENUS_CLASS == V_I4(&VarGenus))
			{
		    } 
			else 
			{		        
				BSTR BstrName = SysAllocString(wszCookingClassName);
				if (BstrName)
				{
					CAutoFree sfm(BstrName);
		            m_pNamespace->GetObject(BstrName,0,NULL,&pClass,NULL);	        
				}
				else
				{
                    hResult = WBEM_E_OUT_OF_MEMORY;
				}
		    }
		}
    }

    IWbemClassObject * pCookingClassAccess2;
    pCookingClassAccess2 = (pClass)?pClass:pCookingClassAccess;

	// Verify and process the cooking class
	// ====================================

	
	if ( SUCCEEDED( hResult ) )
	{
		BOOL bRet;
		bRet = IsCookingClass( pCookingClassAccess );

		if ( bRet ){
			// Save the class 
			// ==============
			
			m_pCookingClass = pCookingClassAccess;
			m_pCookingClass->AddRef();
		} else {
		   hResult = WBEM_E_INVALID_CLASS;
		}

		// Set the class name
		// ==================

		if ( SUCCEEDED( hResult ) )
		{
			m_wszClassName = new WCHAR[ wcslen( wszCookingClassName ) + 1 ];
			wcscpy( m_wszClassName, wszCookingClassName );
		}

		// Initialize the cooking properties
		// =================================

		if ( SUCCEEDED( hResult ) )
		{
			hResult = SetProperties( pCookingClassAccess2, pRawClass );
		}				
	}
	
	if (pClass){
	    pClass->Release();
	}

	return hResult;
}

WMISTATUS CWMISimpleObjectCooker::SetProperties( IWbemClassObject* pCookingClassObject, IWbemObjectAccess *pRawClass )
{
	WMISTATUS dwStatus = WBEM_NO_ERROR;

	BSTR	strPropName = NULL;
	long	lHandle = 0;
	CIMTYPE	ct;
	
	BOOL bAtLeastOne = FALSE;

    IWbemObjectAccess * pCookingClassAccess = NULL;
	dwStatus = pCookingClassObject->QueryInterface(IID_IWbemObjectAccess ,(void **)&pCookingClassAccess);
	if (FAILED(dwStatus))
	{
	    return dwStatus;
	}
    CAutoRelease rm(pCookingClassAccess );

    // get only once the qualifier set
    IWbemQualifierSet* pCookingClassQSet = NULL;
    dwStatus = pCookingClassObject->GetQualifierSet(&pCookingClassQSet);
    if (FAILED(dwStatus))
    {
        return dwStatus;
    }
	CAutoRelease rm1(pCookingClassQSet);

    //
    //  should we be using [TimeStamp|Frequency]_[Time|Sys100ns|Object] ?
    //
    BOOL bUseWellKnownIfNeeded = FALSE;
    dwStatus = pCookingClassQSet->Get(WMI_COOKER_AUTOCOOK_RAWDEFAULT,0,NULL,NULL);
    // we have already verified version and property, just test if it's there
	if ( SUCCEEDED(dwStatus) )
	{
        bUseWellKnownIfNeeded = TRUE;
    }
    else // do not propagate this error
    {
        dwStatus = WBEM_NO_ERROR;
    }
	
	// Enumerate and save the autocook properties
	// ==========================================

	pCookingClassObject->BeginEnumeration( WBEM_FLAG_NONSYSTEM_ONLY );
		
	while ( WBEM_S_NO_ERROR == pCookingClassObject->Next(0,&strPropName,NULL,&ct,NULL) &&
	        SUCCEEDED(dwStatus))
	{
		CAutoFree	afPropName( strPropName );

		DWORD dwCounterType = 0;
		DWORD dwReqProp = 0;

		// Determine if it is an autocook property
		// =======================================

		if ( IsCookingProperty( strPropName, pCookingClassObject, &dwCounterType, &dwReqProp ) )
		{
			m_dwNumProperties++;

			// The property is an autocook; save the Name, ObjectAccess handle, type and cooking object
			// ========================================================================================

			dwStatus = pCookingClassAccess->GetPropertyHandle( strPropName, &ct, &lHandle );

			if ( SUCCEEDED( dwStatus ) )
			{
#ifdef _VERBOSE				
			    {
			        char pBuff[128];
			        wsprintfA(pBuff,"%S %08x %08x\n",strPropName,dwCounterType,dwReqProp);
			        OutputDebugStringA(pBuff);
			    }
#endif			    
				CCookingProperty* pProperty = new CCookingProperty( strPropName, 
				                                                    dwCounterType, 
				                                                    lHandle, 
				                                                    ct,
				                                                    dwReqProp,
				                                                    bUseWellKnownIfNeeded);

				// Initialize the property object
				// ==============================

				IWbemQualifierSet*	pCookingPropQualifierSet = NULL;

				dwStatus = pCookingClassObject->GetPropertyQualifierSet( strPropName, &pCookingPropQualifierSet );
				CAutoRelease arQualifierSet( pCookingPropQualifierSet );

				if ( SUCCEEDED( dwStatus ) )
				{
					dwStatus = pProperty->Initialize( pCookingPropQualifierSet, pRawClass, pCookingClassQSet );
				}

				// If everything worked out then add the property to the cache
				// ===========================================================

				if ( SUCCEEDED( dwStatus ) )
				{
				    bAtLeastOne = TRUE;
				    try
				    {
                        m_apPropertyCache.push_back(pProperty);
                    }
                    catch (...)
                    {
                        dwStatus = WBEM_E_OUT_OF_MEMORY;
                    }
				}
				else
				{
					delete pProperty;
				}
			}
		}
	}

	pCookingClassObject->EndEnumeration();

	if (!bAtLeastOne && (SUCCEEDED(dwStatus))){
	    dwStatus = WBEM_E_INVALID_CLASS;
	}


	return dwStatus;
}

STDMETHODIMP CWMISimpleObjectCooker::SetCookedInstance( 
		/*[in]  */ IWbemObjectAccess *pCookedInstance,
		/*[out] */ long *plID)
{
	HRESULT	hResult = S_OK;

	CCookingInstance* pInstance = new CCookingInstance( pCookedInstance, m_apPropertyCache.size() );

	if (!pInstance || !pInstance->IsValid())
	{
	       delete pInstance;
		return WBEM_E_OUT_OF_MEMORY;
	}
	                                                       
	for ( DWORD dwProp = 0; dwProp < m_apPropertyCache.size() && SUCCEEDED(hResult); dwProp++ )
	{
		CCookingProperty* pProp = m_apPropertyCache[dwProp];

		hResult = pInstance->InitProperty( dwProp, pProp->NumberOfActiveSamples(), pProp->MinSamplesRequired() );
	}

	if (FAILED(hResult))
	{
	       delete pInstance;	
		return hResult;
	}

	// Add new cooked instance
	// =======================

	hResult = m_InstanceCache.Add( (DWORD *)plID, pInstance );

	m_NumInst++;

	return hResult;
}
        
STDMETHODIMP CWMISimpleObjectCooker::BeginCooking( 
		/*[in]  */ long lId,
		/*[in]  */ IWbemObjectAccess *pSampleInstance,
		/*[in]  */ DWORD dwRefreshStamp)
{
	HRESULT	hResult = S_OK;

	CCookingInstance*	pCookedInstance = NULL;

	// Add an initial sample to the cache
	// ==================================

	hResult = m_InstanceCache.GetData( lId, &pCookedInstance );

	if ( SUCCEEDED( hResult ) )
	{
		if ( NULL != pCookedInstance )
		{
			hResult = pCookedInstance->SetRawSourceInstance( pSampleInstance );

			if ( SUCCEEDED( hResult ) )
			{
				hResult = UpdateSamples( pCookedInstance, dwRefreshStamp );
			}
		}
		else
		{
			hResult = E_FAIL;
		}
	}

	return hResult;
}
        
STDMETHODIMP CWMISimpleObjectCooker::StopCooking( 
		/*[in]  */ long lId)
{
	HRESULT	hResult = S_OK;

	CCookingInstance*	pInstance = NULL;

    // ????
	hResult = m_InstanceCache.GetData( lId, &pInstance );

	return hResult;
}

        
STDMETHODIMP CWMISimpleObjectCooker::Recalc(DWORD dwRefreshStamp)
{
	HRESULT	hResult = S_OK;

	CCookingInstance*	pInstance = NULL;

	// Cook all of the instances which have a cached sample
	// ====================================================

	m_InstanceCache.BeginEnum();
	DWORD i=0;

	while ( S_OK == m_InstanceCache.Next( &pInstance ) )
	{	
	    // since we are inside a CritSec
	    // we need to ensire that we call
	    // EndEnum, that will release the Lock on the CritSec
		try {
			if ( pInstance )
			{
				hResult = CookInstance( pInstance, dwRefreshStamp );
#ifdef _VERBOSE					
				{
				    char pBuff[128];
				    wsprintfA(pBuff,"%S %p %d\n",pInstance->GetKey(),pInstance,i++);
				    OutputDebugStringA(pBuff);
				}
#endif				
			}
		} catch(...){
#ifdef _VERBOSE			
		    OutputDebugStringA("exception\n");
#endif		    
		}
	}

	m_InstanceCache.EndEnum();

	return hResult;
}
        
STDMETHODIMP CWMISimpleObjectCooker::Remove( 
		/*[in]  */ long lId)
{
	HRESULT	hResult = S_OK;

	// Remove the specified instance from the cache
	// ============================================

    CCookingInstance * pInst = NULL;
	hResult = m_InstanceCache.Remove( lId, &pInst );
	if (pInst){
	    delete pInst;
	    m_NumInst--;
	}

	return hResult;
}
        
STDMETHODIMP CWMISimpleObjectCooker::Reset()
{
	HRESULT	hResult = S_OK;

	// Remove all of the instances from the cache
	// ==========================================
	CCookingInstance * pInstance = NULL;
    m_InstanceCache.BeginEnum();

    while ( S_OK == m_InstanceCache.Next( &pInstance ) )
	{
		if (pInstance){
		    delete pInstance;
		    m_NumInst--;
		    pInstance = NULL;
		}
	}
        
    m_InstanceCache.EndEnum();

	hResult = m_InstanceCache.RemoveAll();

	return hResult;
}

WMISTATUS CWMISimpleObjectCooker::CookInstance( CCookingInstance* pInstance,
                                                DWORD dwRefreshStamp)
{
	WMISTATUS dwStatus = S_OK;

	if ( SUCCEEDED( dwStatus ) )
	{
		dwStatus = UpdateSamples( pInstance, dwRefreshStamp );

		// Loop through the cooking properties
		// ===================================
		
		for ( DWORD dwProp = 0; dwProp < m_apPropertyCache.size(); dwProp++ )
		{
			// Update the cooking instance property
			// ====================================
			pInstance->CookProperty( dwProp, m_apPropertyCache[dwProp] );
		}
	}

	return dwStatus;
}

WMISTATUS CWMISimpleObjectCooker::UpdateSamples( CCookingInstance* pCookedInstance, DWORD dwRefreshStamp )
{
	WMISTATUS dwStatus = WBEM_NO_ERROR;

	IWbemObjectAccess* pRawInstance = NULL;

	if ( NULL == pCookedInstance )
	{
		dwStatus = WBEM_E_INVALID_PARAMETER;
	}

	if ( SUCCEEDED( dwStatus ) )
	{
		dwStatus = pCookedInstance->GetRawSourceInstance( &pRawInstance );
		CAutoRelease	arRawInstance( pRawInstance );

		if ( NULL == pRawInstance )
		{
			dwStatus = WBEM_E_FAILED;
		}

#ifdef _VERBOSE
        {
            WCHAR pBuff[256];
            _variant_t Var;
            HRESULT hr = pRawInstance->Get(L"__RELPATH",0,&Var,NULL,NULL);
            wsprintfW(pBuff,L"%p hr %08x __RELPATH %s Key %s\n",pRawInstance,hr,V_BSTR(&Var),pCookedInstance->GetKey());
            OutputDebugStringW(pBuff);
        }
#endif

		for ( DWORD dwProp = 0; ( SUCCEEDED( dwStatus ) ) && dwProp < m_apPropertyCache.size(); dwProp++ )
		{
			CCookingProperty* pProp = m_apPropertyCache[dwProp];

			CProperty* pRawProp		= pProp->GetRawCounterProperty();
			CProperty* pBaseProp	= pProp->GetBaseProperty();
			CProperty* pTimeProp	= pProp->GetTimeProperty();

			__int64 nRawCounter = 0;
			__int64 nRawBase = 0;
			__int64 nTimeStamp = 0;

			dwStatus = GetPropValue( pRawProp, pRawInstance, &nRawCounter );

			if ( pBaseProp )
			{
				GetPropValue( pBaseProp, pRawInstance, &nRawBase );
			} 
			else if (pProp->IsReq(REQ_BASE))
			{
			    nRawBase = 1;
			}

			if ( pTimeProp )
			{
				GetPropValue( pTimeProp, pRawInstance, &nTimeStamp );
			} 
			else if (pProp->IsReq(REQ_TIME)) 
			{
			    LARGE_INTEGER li;
			    QueryPerformanceCounter(&li);
			    nTimeStamp = li.QuadPart;
			}

			dwStatus = pCookedInstance->AddSample( dwRefreshStamp, dwProp, nRawCounter, nRawBase, nTimeStamp );

#ifdef _VERBOSE	
			{
			    char pBuff[128];
			    wsprintfA(pBuff,"Prop %d status %08x\n"
			                    " counter %I64u base %I64u time %I64u\n",
			                    dwProp, dwStatus, nRawCounter, nRawBase, nTimeStamp);
			    OutputDebugStringA(pBuff);
			}
#endif	

		}
	}

	return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmiexts\data.cpp ===
#define INITGUID

#include <data.h>


ArrayCLSID g_ArrayCLSID[] = { 
{ &CLSID_WmiRepository_SQL, "CLSID_WmiRepository_SQL" },
{ &CLSID_WmiRepository_Jet, "CLSID_WmiRepository_Jet" },
{ &CLSID_WmiRepositoryQuery, "CLSID_WmiRepositoryQuery" },
{ &CLSID_UmiDefURL, "CLSID_UmiDefURL" },
{ &CLSID_PseudoSink, "CLSID_PseudoSink" },
{ &CLSID_WbemClassObjectProxy, "CLSID_WbemClassObjectProxy" },
{ &CLSID_UmiObjectWrapperProxy, "CLSID_UmiObjectWrapperProxy" },
{ &CLSID_WbemEventSubsystem, "CLSID_WbemEventSubsystem" },
{ &CLSID_HmmpEventConsumerProvider, "CLSID_HmmpEventConsumerProvider" },
{ &CLSID_WbemFilterProxy, "CLSID_WbemFilterProxy" },
{ &CLSID_InProcWbemLevel1Login, "CLSID_InProcWbemLevel1Login" },
{ &CLSID__WmiFreeFormObject, "CLSID__WmiFreeFormObject" },
{ &CLSID__WmiObjectFactory, "CLSID__WmiObjectFactory" },
{ &CLSID__WbemUMIContextWrapper, "CLSID__WbemUMIContextWrapper" },
{ &CLSID__WmiErrorObject, "CLSID__WmiErrorObject" },
{ &CLSID__UmiErrorObject, "CLSID__UmiErrorObject" },
{ &CLSID_WinmgmtMofCompiler, "CLSID_WinmgmtMofCompiler" },
{ &CLSID_WbemTokenCache, "CLSID_WbemTokenCache" },
{ &CLSID_WmiESS, "CLSID_WmiESS" },
{ &CLSID_WmiProvSS, "CLSID_WmiProvSS" },
{ &CLSID_WmiProviderBindingFactory, "CLSID_WmiProviderBindingFactory" },
{ &CLSID_WmiProviderSharedFactory, "CLSID_WmiProviderSharedFactory" },
{ &CLSID_WmiProviderDedicatedFactory, "CLSID_WmiProviderDedicatedFactory" },
{ &CLSID_WmiProviderInProcFactory, "CLSID_WmiProviderInProcFactory" },
{ &CLSID_IWmiCoreServices, "CLSID_IWmiCoreServices" },
{ &CLSID__WmiWbemClass, "CLSID__WmiWbemClass" },
{ &CLSID__WmiWbemInstance, "CLSID__WmiWbemInstance" },
{ &CLSID__WmiQuery, "CLSID__WmiQuery" },
{ &CLSID__WbemUMIObjectWrapper, "CLSID__WbemUMIObjectWrapper" },
{ &CLSID__WbemEmptyClassObject, "CLSID__WbemEmptyClassObject" },
{ &CLSID__IWbemCallSec, "CLSID__IWbemCallSec" },
{ &CLSID__WbemConfigureRefreshingSvcs, "CLSID__WbemConfigureRefreshingSvcs" },
{ &CLSID__WbemRefresherMgr, "CLSID__WbemRefresherMgr" },
{ &CLSID__WbemHostedRefresherMgr, "CLSID__WbemHostedRefresherMgr" },
{ &CLSID__WbemComBinding, "CLSID__WbemComBinding" },
{ &CLSID__UmiComBinding, "CLSID__UmiComBinding" },
{ &CLSID_WbemLocator, "CLSID_WbemLocator" },
{ &CLSID_WbemConnection, "CLSID_WbemConnection" },
{ &CLSID_WbemContext, "CLSID_WbemContext" },
{ &CLSID_UnsecuredApartment, "CLSID_UnsecuredApartment" },
{ &CLSID_WbemClassObject, "CLSID_WbemClassObject" },
{ &CLSID_MofCompiler, "CLSID_MofCompiler" },
{ &CLSID_WbemStatusCodeText, "CLSID_WbemStatusCodeText" },
{ &CLSID_WbemBackupRestore, "CLSID_WbemBackupRestore" },
{ &CLSID_WbemRefresher, "CLSID_WbemRefresher" },
{ &CLSID_WbemObjectTextSrc, "CLSID_WbemObjectTextSrc" },
{ &CLSID_WbemAdministrativeLocator, "CLSID_WbemAdministrativeLocator" },
{ &CLSID_WbemAuthenticatedLocator, "CLSID_WbemAuthenticatedLocator" },
{ &CLSID_WbemUnauthenticatedLocator, "CLSID_WbemUnauthenticatedLocator" },
{ &CLSID_WbemDecoupledRegistrar, "CLSID_WbemDecoupledRegistrar" },
{ &CLSID_WbemDecoupledBasicEventProvider, "CLSID_WbemDecoupledBasicEventProvider" },
{ &CLSID_WbemLevel1Login, "CLSID_WbemLevel1Login" },
{ &CLSID_WbemDCOMTransport, "CLSID_WbemDCOMTransport" },
{ &CLSID_WbemLocalAddrRes, "CLSID_WbemLocalAddrRes" },
{ &CLSID_WbemUninitializedClassObject, "CLSID_WbemUninitializedClassObject" },
{ &CLSID_WbemDefPath, "CLSID_WbemDefPath" },
{ &CLSID_WbemQuery, "CLSID_WbemQuery" },
{ &CLSID_WMIExtension, "CLSID_WMIExtension" },
{ &CLSID_SWbemLocator, "CLSID_SWbemLocator" },
{ &CLSID_SWbemLocatorEx, "CLSID_SWbemLocatorEx" },
{ &CLSID_SWbemNamedValueSet, "CLSID_SWbemNamedValueSet" },
{ &CLSID_SWbemNamedValueSetEx, "CLSID_SWbemNamedValueSetEx" },
{ &CLSID_SWbemObjectPath, "CLSID_SWbemObjectPath" },
{ &CLSID_SWbemObjectPathEx, "CLSID_SWbemObjectPathEx" },
{ &CLSID_SWbemLastError, "CLSID_SWbemLastError" },
{ &CLSID_SWbemSink, "CLSID_SWbemSink" },
{ &CLSID_SWbemDateTime, "CLSID_SWbemDateTime" },
{ &CLSID_SWbemRefresher, "CLSID_SWbemRefresher" },
{ &CLSID_SWbemServices, "CLSID_SWbemServices" },
{ &CLSID_SWbemServicesEx, "CLSID_SWbemServicesEx" },
{ &CLSID_SWbemObject, "CLSID_SWbemObject" },
{ &CLSID_SWbemObjectEx, "CLSID_SWbemObjectEx" },
{ &CLSID_SWbemObjectSet, "CLSID_SWbemObjectSet" },
{ &CLSID_SWbemNamedValue, "CLSID_SWbemNamedValue" },
{ &CLSID_SWbemNamedValueEx, "CLSID_SWbemNamedValueEx" },
{ &CLSID_SWbemQualifier, "CLSID_SWbemQualifier" },
{ &CLSID_SWbemQualifierSet, "CLSID_SWbemQualifierSet" },
{ &CLSID_SWbemProperty, "CLSID_SWbemProperty" },
{ &CLSID_SWbemPropertyEx, "CLSID_SWbemPropertyEx" },
{ &CLSID_SWbemPropertySet, "CLSID_SWbemPropertySet" },
{ &CLSID_SWbemMethod, "CLSID_SWbemMethod" },
{ &CLSID_SWbemMethodSet, "CLSID_SWbemMethodSet" },
{ &CLSID_SWbemEventSource, "CLSID_SWbemEventSource" },
{ &CLSID_SWbemSecurity, "CLSID_SWbemSecurity" },
{ &CLSID_SWbemPrivilege, "CLSID_SWbemPrivilege" },
{ &CLSID_SWbemPrivilegeSet, "CLSID_SWbemPrivilegeSet" },
{ &CLSID_SWbemRefreshableItem, "CLSID_SWbemRefreshableItem" },
{ &CLSID_SWbemObjectPathComponents, "CLSID_SWbemObjectPathComponents" },
{ &CLSID_SWbemTransaction, "CLSID_SWbemTransaction" },
{ &CLSID_WmiMessageMsmqSender, "CLSID_WmiMessageMsmqSender" },
{ &CLSID_WmiMessageMsmqReceiver, "CLSID_WmiMessageMsmqReceiver" },
{ &CLSID_WmiMessageDcomSender, "CLSID_WmiMessageDcomSender" },
{ &CLSID_WmiMessageDcomReceiver, "CLSID_WmiMessageDcomReceiver" },
{ &CLSID_WmiMessageMultiSendReceive, "CLSID_WmiMessageMultiSendReceive" },
{ &CLSID_WmiMessageQueue, "CLSID_WmiMessageQueue" },
{ &CLSID_WmiMessageQueueManager, "CLSID_WmiMessageQueueManager" },
{ &CLSID_WmiMessageService, "CLSID_WmiMessageService" },
{ &CLSID_WmiSmartObjectMarshal, "CLSID_WmiSmartObjectMarshal" },
{ &CLSID_MsiMethodStatusSink, "CLSID_MsiMethodStatusSink" },
{ &CLSID_MsiProductMethods, "CLSID_MsiProductMethods" },
{ &CLSID_MsiSoftwareFeatureMethods, "CLSID_MsiSoftwareFeatureMethods" },
{ &CLSID_WMIObjectBroker, "CLSID_WMIObjectBroker" },
{ &CLSID_WMIObjectBrokerRegistration, "CLSID_WMIObjectBrokerRegistration" },
{ &CLSID_CMSnapin, "CLSID_CMSnapin" },
{ &CLSID_CMSnapinAbout, "CLSID_CMSnapinAbout" },
{ &CLSID_NSDrive, "CLSID_NSDrive" },
{ &CLSID_NSDriveAbout, "CLSID_NSDriveAbout" },
{ &CLSID_SDSnapin, "CLSID_SDSnapin" },
{ &CLSID_SDSnapinAbout, "CLSID_SDSnapinAbout" },
{ &CLSID_WMISnapin, "CLSID_WMISnapin" },
{ &CLSID_WMISnapinAbout, "CLSID_WMISnapinAbout" },
//{ &CLSID_HmmLocator, "CLSID_HmmLocator" },
//{ &CLSID_ContinousProvider_v1, "CLSID_ContinousProvider_v1" },
//{ &CLSID_IntProv, "CLSID_IntProv" },
{ &CLSID_MyEventProvider, "CLSID_MyEventProvider" },
//{ &CLSID_HiPerfCounter_v1, "CLSID_HiPerfCounter_v1" },
//{ &CLSID_LogicalDiskProv, "CLSID_LogicalDiskProv" },
//{ &CLSID_PERFSRV_v1, "CLSID_PERFSRV_v1" },
//{ &CLSID_HiPerfProvider_v1, "CLSID_HiPerfProvider_v1" },
//{ &CLSID_instprovider, "CLSID_instprovider" },
//{ &CLSID_PROPNAME, "CLSID_PROPNAME" },
//{ &CLSID_TemplateProvider, "CLSID_TemplateProvider" },
//{ &CLSID_TemplateAssocProvider, "CLSID_TemplateAssocProvider" },
//{ &CLSID_TransientProvider, "CLSID_TransientProvider" },
//{ &CLSID_TransientEventProvider, "CLSID_TransientEventProvider" },
//{ &CLSID_UpdConsProvider, "CLSID_UpdConsProvider" },
//{ &CLSID_UpdConsAssocProvider, "CLSID_UpdConsAssocProvider" },
//{ &CLSID_PseudoProvider, "CLSID_PseudoProvider" },
//{ &CLSID_MofConsumer, "CLSID_MofConsumer" },
//{ &CLSID_FwdConsProvider, "CLSID_FwdConsProvider" },
//{ &CLSID_FwdEventProvider, "CLSID_FwdEventProvider" },
//{ &CLSID_FwdAckEventProvider, "CLSID_FwdAckEventProvider" },
//{ &CLSID_KernelTraceProvider, "CLSID_KernelTraceProvider" },
//{ &CLSID_EventInstanceProvider, "CLSID_EventInstanceProvider" },
//{ &CLSID_NCProvider, "CLSID_NCProvider" },
//{ &CLSID_TestBlobDecoder, "CLSID_TestBlobDecoder" },
//{ &CLSID_ModuleScalar, "CLSID_ModuleScalar" },
//{ &CLSID_ModuleArray, "CLSID_ModuleArray" },
//{ &CLSID_ModuleGeneric, "CLSID_ModuleGeneric" },
//{ &CLSID_WbemConsoleConsumer, "CLSID_WbemConsoleConsumer" },
//{ &CLSID_TestEventProvider1, "CLSID_TestEventProvider1" },
//{ &CLSID_WbemActiveScriptConsumer, "CLSID_WbemActiveScriptConsumer" },
//{ &CLSID_WbemSMTPConsumer, "CLSID_WbemSMTPConsumer" },
//{ &CLSID_NewMail, "CLSID_NewMail" },
//{ &CLSID_WbemPagerConsumer, "CLSID_WbemPagerConsumer" },
//{ &CLSID_WbemLogFileConsumer, "CLSID_WbemLogFileConsumer" },
//{ &CLSID_WbemCommandLineConsumer, "CLSID_WbemCommandLineConsumer" },
//{ &CLSID_WbemNTEventLogConsumer, "CLSID_WbemNTEventLogConsumer" },
//{ &CLSID_WbemMsgBoxConsumer, "CLSID_WbemMsgBoxConsumer" },
//{ &CLSID_WbemPerformanceConsumer, "CLSID_WbemPerformanceConsumer" },
//{ &CLSID_VSAPlugIn, "CLSID_VSAPlugIn" },
//{ &CLSID_VSAToWMIEventProvider, "CLSID_VSAToWMIEventProvider" },
//{ &CLSID_FakeLEC, "CLSID_FakeLEC" },
//{ &CLSID_LECObj, "CLSID_LECObj" },
//{ &CLSID_MyEventConsumer, "CLSID_MyEventConsumer" },
//{ &CLSID_IWbemObjectSinkProxyStub, "CLSID_IWbemObjectSinkProxyStub" },
//{ &CLSID_IEnumWbemClassObjectProxyStub, "CLSID_IEnumWbemClassObjectProxyStub" },
//{ &CLSID_IWbemUnboundObjectSinkProxyStub, "CLSID_IWbemUnboundObjectSinkProxyStub" },
//{ &CLSID_IWbemMultiTargetProxyStub, "CLSID_IWbemMultiTargetProxyStub" },
//{ &CLSID_IWbemServicesExProxyStub, "CLSID_IWbemServicesExProxyStub" },
//{ &CLSID_IWbemServicesProxyStub, "CLSID_IWbemServicesProxyStub" },
//{ &CLSID_IWbemComBindingProxyStub, "CLSID_IWbemComBindingProxyStub" },
//{ &CLSID_DCOMAccessControl, "CLSID_DCOMAccessControl" },
//{ &CLSID_kerberosTest, "CLSID_kerberosTest" },
//{ &CLSID_IWbemLocator_Pipes, "CLSID_IWbemLocator_Pipes" },
//{ &CLSID_IWbemLocator_Tcpip, "CLSID_IWbemLocator_Tcpip" },
//{ &CLSID_IWbemAddressResolver_Tcpip, "CLSID_IWbemAddressResolver_Tcpip" },
//{ &CLSID_WbemTcpip, "CLSID_WbemTcpip" },
//{ &CLSID_WbemPipe, "CLSID_WbemPipe" },
{ &CLSID_WinNTConnectionObject, "CLSID_WinNTConnectionObject" },
{ &CLSID_LDAPConnectionObject, "CLSID_LDAPConnectionObject" },
//{ &CLSID_DcomMsgReceiveStub, "CLSID_DcomMsgReceiveStub" },
//{ &CLSID_ReceiveTest, "CLSID_ReceiveTest" },
//{ &CLSID_NT5PerfProvider_V1, "CLSID_NT5PerfProvider_V1" },
//{ &CLSID_Nt5PerProvider_v1, "CLSID_Nt5PerProvider_v1" },
//{ &CLSID_RayMccProv, "CLSID_RayMccProv" },
//{ &CLSID_WmiProvider, "CLSID_WmiProvider" },
//{ &CLSID_HmmClassInfoFilter, "CLSID_HmmClassInfoFilter" },
//{ &CLSID_HmmSql1Filter, "CLSID_HmmSql1Filter" },
//{ &CLSID_SQLOLEDB, "CLSID_SQLOLEDB" },
//{ &CLSID_testprov, "CLSID_testprov" },
//{ &CLSID_AssociationProvider, "CLSID_AssociationProvider" },
//{ &CLSID_RegProvider, "CLSID_RegProvider" },
//{ &CLSID_RegPropProv, "CLSID_RegPropProv" },
{ &CLSID_PerfProvider, "CLSID_PerfProvider" },
{ &CLSID_PerfPropProv, "CLSID_PerfPropProv" },
{ &CLSID_RegistryEventProvider, "CLSID_RegistryEventProvider" },
{ &CLSID__DSSvcExWrap,"CLSID__DSSvcExWrap"}
}; // end g_ArrayCLSID

DWORD g_nClsids = sizeof(g_ArrayCLSID)/sizeof(ArrayCLSID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmiexts\data.h ===
#ifndef __DATA_H__
#define __DATA_H__

#include <objbase.h>

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)


MIDL_DEFINE_GUID(CLSID, CLSID_WmiRepository_SQL,0x89B9BAF8,0x6A06,0x11d3,0xA5,0xFE,0x00,0x10,0x5A,0x0A,0x31,0x02);
MIDL_DEFINE_GUID(CLSID, CLSID_WmiRepository_Jet,0x89B9BAFC,0x6A06,0x11d3,0xA5,0xFE,0x00,0x10,0x5A,0x0A,0x31,0x02);
MIDL_DEFINE_GUID(CLSID, CLSID_WmiRepositoryQuery,0x29129B3F,0x7899,0x4E82,0xA3,0xC3,0xA9,0x67,0x49,0x58,0x9D,0xCE);
MIDL_DEFINE_GUID(CLSID, CLSID_UmiDefURL,0xd4b21cc2,0xf2a5,0x453e,0x84,0x59,0xb2,0x7f,0x36,0x2c,0xb0,0xe0);
MIDL_DEFINE_GUID(CLSID, CLSID_PseudoSink,0xE002E4F0,0xE6EA,0x11d2,0x9C,0xB3,0x00,0x10,0x5A,0x1F,0x48,0x01);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemClassObjectProxy,0x4590f812,0x1d3a,0x11d0,0x89,0x1f,0x00,0xaa,0x00,0x4b,0x2e,0x24);
MIDL_DEFINE_GUID(CLSID, CLSID_UmiObjectWrapperProxy,0x4E6AC63C,0xBF69,0x495d,0x90,0x00,0xE4,0x5A,0x4E,0x51,0x7B,0x0C);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemEventSubsystem,0x5d08b586,0x343a,0x11d0,0xad,0x46,0x00,0xc0,0x4f,0xd8,0xfd,0xff);
MIDL_DEFINE_GUID(CLSID, CLSID_HmmpEventConsumerProvider,0x08a59b5d,0xdd50,0x11d0,0xad,0x6b,0x00,0xc0,0x4f,0xd8,0xfd,0xff);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemFilterProxy,0x6c19be35,0x7500,0x11d1,0xad,0x94,0x00,0xc0,0x4f,0xd8,0xfd,0xff);
MIDL_DEFINE_GUID(CLSID, CLSID_InProcWbemLevel1Login,0x4fa18276,0x912a,0x11d1,0xad,0x9b,0x00,0xc0,0x4f,0xd8,0xfd,0xff);
MIDL_DEFINE_GUID(CLSID, CLSID__WmiFreeFormObject,0x3252F829,0x8694,0x46a8,0xB4,0xCF,0x83,0xF6,0xA0,0xFF,0xEF,0xA9);
MIDL_DEFINE_GUID(CLSID, CLSID__WmiObjectFactory,0x78103FB7,0xAED7,0x4066,0x8B,0xCD,0x30,0xBB,0x27,0xB0,0x23,0x31);
MIDL_DEFINE_GUID(CLSID, CLSID__WbemUMIContextWrapper,0x390150A7,0xAB20,0x45ff,0xA2,0xE0,0x6B,0x98,0x55,0x54,0xCA,0xA8);
MIDL_DEFINE_GUID(CLSID, CLSID__WmiErrorObject,0xE2569DC9,0x38FA,0x4749,0xBE,0xE5,0xA2,0x63,0xE4,0x03,0x35,0x9F);
MIDL_DEFINE_GUID(CLSID, CLSID__UmiErrorObject,0xF7D04323,0x5378,0x40c1,0xB5,0x88,0xC8,0x4F,0x91,0xE2,0xB8,0x2C);
MIDL_DEFINE_GUID(CLSID, CLSID_WinmgmtMofCompiler,0xC10B4771,0x4DA0,0x11d2,0xA2,0xF5,0x00,0xC0,0x4F,0x86,0xFB,0x7D);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemTokenCache,0xdc923725,0x0fdd,0x45e1,0xae,0x74,0xea,0x09,0x18,0x2e,0x73,0x9b);
MIDL_DEFINE_GUID(CLSID, CLSID_WmiESS,0xf3130cdb,0xaa52,0x4c3a,0xab,0x32,0x85,0xff,0xc2,0x3a,0xf9,0xc1);
MIDL_DEFINE_GUID(CLSID, CLSID_WmiProvSS,0x4de225bf,0xcf59,0x4cfc,0x85,0xf7,0x68,0xb9,0x0f,0x18,0x53,0x55);
MIDL_DEFINE_GUID(CLSID, CLSID_WmiProviderBindingFactory,0xF5A55D36,0x8750,0x432C,0xAB,0x52,0xAD,0x49,0xA0,0x16,0xEA,0xBC);
MIDL_DEFINE_GUID(CLSID, CLSID_WmiProviderSharedFactory,0x24F1D9A7,0xB682,0x4CF3,0x88,0x0C,0x18,0xFD,0x90,0xD5,0x5C,0xD6);
MIDL_DEFINE_GUID(CLSID, CLSID_WmiProviderDedicatedFactory,0x4b4baaa2,0xaaf3,0x4b08,0x9c,0x9e,0xc4,0x67,0x69,0x60,0x7e,0xba);
MIDL_DEFINE_GUID(CLSID, CLSID_WmiProviderInProcFactory,0x8BEBCE8B,0x1AF0,0x4323,0x8B,0x4D,0x36,0x99,0x45,0x67,0xCA,0xE1);
MIDL_DEFINE_GUID(CLSID, CLSID_IWmiCoreServices,0x1860e246,0xe924,0x4f73,0xb2,0xc5,0x93,0xe0,0x57,0x7e,0x3a,0xa1);
MIDL_DEFINE_GUID(CLSID, CLSID__WmiWbemClass,0x0859CCC9,0x209D,0x4110,0x96,0x13,0xDA,0xB6,0xEA,0xF9,0x09,0x3F);
MIDL_DEFINE_GUID(CLSID, CLSID__WmiWbemInstance,0xDD51FE78,0x43E1,0x405a,0xA4,0x4E,0x6C,0x22,0x63,0x91,0xCF,0x0D);
MIDL_DEFINE_GUID(CLSID, CLSID__WmiQuery,0xda1fc6d2,0x40e4,0x4e2f,0xbb,0x42,0xe7,0x0d,0x28,0xc8,0x91,0xb3);
MIDL_DEFINE_GUID(CLSID, CLSID__WbemUMIObjectWrapper,0xC601737E,0x9213,0x489f,0xAD,0xC8,0x92,0x2A,0x89,0x4A,0x4A,0x65);
MIDL_DEFINE_GUID(CLSID, CLSID__WbemEmptyClassObject,0x695B5458,0xD6E9,0x4a6a,0x88,0x1F,0xB6,0x8F,0x95,0x33,0x97,0xD8);
MIDL_DEFINE_GUID(CLSID, CLSID__IWbemCallSec,0x1108be51,0xf58a,0x4cda,0xbb,0x99,0x7a,0x02,0x27,0xd1,0x1d,0x5e);
MIDL_DEFINE_GUID(CLSID, CLSID__WbemConfigureRefreshingSvcs,0xCD1ABFC8,0x6C5E,0x4a8d,0xB9,0x0B,0x2A,0x3B,0x15,0x3B,0x88,0x6D);
MIDL_DEFINE_GUID(CLSID, CLSID__WbemRefresherMgr,0xDCF33DF4,0xB510,0x439f,0x83,0x2A,0x16,0xB6,0xB5,0x14,0xF2,0xA7);
MIDL_DEFINE_GUID(CLSID, CLSID__WbemHostedRefresherMgr,0x288d70f7,0x11c8,0x42d5,0xa6,0x12,0x8e,0x46,0xa7,0xe9,0x22,0xd8);
MIDL_DEFINE_GUID(CLSID, CLSID__WbemComBinding,0xED51D12E,0x511F,0x4999,0x8D,0xCD,0xC2,0xBA,0xC9,0x1B,0xE8,0x6E);
MIDL_DEFINE_GUID(CLSID, CLSID__UmiComBinding,0xD5D3ACEA,0xEEC7,0x4efd,0xA0,0x6D,0xFF,0x54,0xB4,0x27,0x16,0x55);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemLocator,0x4590f811,0x1d3a,0x11d0,0x89,0x1f,0x00,0xaa,0x00,0x4b,0x2e,0x24);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemConnection,0x4c6055d8,0x84b9,0x4111,0xa7,0xd3,0x66,0x23,0x89,0x4e,0xed,0xb3);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemContext,0x674B6698,0xEE92,0x11d0,0xAD,0x71,0x00,0xC0,0x4F,0xD8,0xFD,0xFF);
MIDL_DEFINE_GUID(CLSID, CLSID_UnsecuredApartment,0x49bd2028,0x1523,0x11d1,0xad,0x79,0x00,0xc0,0x4f,0xd8,0xfd,0xff);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemClassObject,0x9A653086,0x174F,0x11d2,0xB5,0xF9,0x00,0x10,0x4B,0x70,0x3E,0xFD);
MIDL_DEFINE_GUID(CLSID, CLSID_MofCompiler,0x6daf9757,0x2e37,0x11d2,0xae,0xc9,0x00,0xc0,0x4f,0xb6,0x88,0x20);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemStatusCodeText,0xeb87e1bd,0x3233,0x11d2,0xae,0xc9,0x00,0xc0,0x4f,0xb6,0x88,0x20);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemBackupRestore,0xC49E32C6,0xBC8B,0x11d2,0x85,0xD4,0x00,0x10,0x5A,0x1F,0x83,0x04);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemRefresher,0xc71566f2,0x561e,0x11d1,0xad,0x87,0x00,0xc0,0x4f,0xd8,0xfd,0xff);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemObjectTextSrc,0x8D1C559D,0x84F0,0x4bb3,0xA7,0xD5,0x56,0xA7,0x43,0x5A,0x9B,0xA6);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemAdministrativeLocator,0xcb8555cc,0x9128,0x11d1,0xad,0x9b,0x00,0xc0,0x4f,0xd8,0xfd,0xff);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemAuthenticatedLocator,0xcd184336,0x9128,0x11d1,0xad,0x9b,0x00,0xc0,0x4f,0xd8,0xfd,0xff);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemUnauthenticatedLocator,0x443E7B79,0xDE31,0x11d2,0xB3,0x40,0x00,0x10,0x4B,0xCC,0x4B,0x4A);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemDecoupledRegistrar,0x4cfc7932,0x0f9d,0x4bef,0x9c,0x32,0x8e,0xa2,0xa6,0xb5,0x6f,0xcb);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemDecoupledBasicEventProvider,0xf5f75737,0x2843,0x4f22,0x93,0x3d,0xc7,0x6a,0x97,0xcd,0xa6,0x2f);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemLevel1Login,0x8BC3F05E,0xD86B,0x11d0,0xA0,0x75,0x00,0xC0,0x4F,0xB6,0x88,0x20);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemDCOMTransport,0xF7CE2E13,0x8C90,0x11d1,0x9E,0x7B,0x00,0xC0,0x4F,0xC3,0x24,0xA8);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemLocalAddrRes,0xA1044801,0x8F7E,0x11d1,0x9E,0x7C,0x00,0xC0,0x4F,0xC3,0x24,0xA8);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemUninitializedClassObject,0x7a0227f6,0x7108,0x11d1,0xad,0x90,0x00,0xc0,0x4f,0xd8,0xfd,0xff);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemDefPath,0xcf4cc405,0xe2c5,0x4ddd,0xb3,0xce,0x5e,0x75,0x82,0xd8,0xc9,0xfa);
MIDL_DEFINE_GUID(CLSID, CLSID_WbemQuery,0xEAC8A024,0x21E2,0x4523,0xAD,0x73,0xA7,0x1A,0x0A,0xA2,0xF5,0x6A);
MIDL_DEFINE_GUID(CLSID, CLSID_WMIExtension,0xf0975afe,0x5c7f,0x11d2,0x8b,0x74,0x00,0x10,0x4b,0x2a,0xfb,0x41);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemLocator,0x76A64158,0xCB41,0x11d1,0x8B,0x02,0x00,0x60,0x08,0x06,0xD9,0xB6);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemLocatorEx,0xBF37162F,0x9E73,0x48ed,0xB0,0x09,0x92,0xE2,0xF7,0x32,0x25,0x2F);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemNamedValueSet,0x9AED384E,0xCE8B,0x11d1,0x8B,0x05,0x00,0x60,0x08,0x06,0xD9,0xB6);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemNamedValueSetEx,0xF9EF137C,0xC934,0x4e55,0x85,0x34,0x20,0x4F,0xEE,0x2E,0xDA,0x77);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemObjectPath,0x5791BC26,0xCE9C,0x11d1,0x97,0xBF,0x00,0x00,0xF8,0x1E,0x84,0x9C);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemObjectPathEx,0x51217565,0xE9CE,0x4534,0xB0,0x68,0x6F,0x50,0xFF,0x77,0xC2,0xC7);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemLastError,0xC2FEEEAC,0xCFCD,0x11d1,0x8B,0x05,0x00,0x60,0x08,0x06,0xD9,0xB6);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemSink,0x75718C9A,0xF029,0x11d1,0xA1,0xAC,0x00,0xC0,0x4F,0xB6,0xC2,0x23);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemDateTime,0x47DFBE54,0xCF76,0x11d3,0xB3,0x8F,0x00,0x10,0x5A,0x1F,0x47,0x3A);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemRefresher,0xD269BF5C,0xD9C1,0x11d3,0xB3,0x8F,0x00,0x10,0x5A,0x1F,0x47,0x3A);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemServices,0x04B83D63,0x21AE,0x11d2,0x8B,0x33,0x00,0x60,0x08,0x06,0xD9,0xB6);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemServicesEx,0x62E522DC,0x8CF3,0x40a8,0x8B,0x2E,0x37,0xD5,0x95,0x65,0x1E,0x40);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemObject,0x04B83D62,0x21AE,0x11d2,0x8B,0x33,0x00,0x60,0x08,0x06,0xD9,0xB6);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemObjectEx,0xD6BDAFB2,0x9435,0x491f,0xBB,0x87,0x6A,0xA0,0xF0,0xBC,0x31,0xA2);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemObjectSet,0x04B83D61,0x21AE,0x11d2,0x8B,0x33,0x00,0x60,0x08,0x06,0xD9,0xB6);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemNamedValue,0x04B83D60,0x21AE,0x11d2,0x8B,0x33,0x00,0x60,0x08,0x06,0xD9,0xB6);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemNamedValueEx,0xEE10B42E,0x02C0,0x4bef,0x80,0xB1,0xAE,0x94,0x92,0x39,0x1E,0x39);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemQualifier,0x04B83D5F,0x21AE,0x11d2,0x8B,0x33,0x00,0x60,0x08,0x06,0xD9,0xB6);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemQualifierSet,0x04B83D5E,0x21AE,0x11d2,0x8B,0x33,0x00,0x60,0x08,0x06,0xD9,0xB6);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemProperty,0x04B83D5D,0x21AE,0x11d2,0x8B,0x33,0x00,0x60,0x08,0x06,0xD9,0xB6);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemPropertyEx,0x00F2D3B2,0x6AC8,0x4406,0xB9,0x8D,0x2D,0x0E,0xA9,0x57,0xC2,0x91);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemPropertySet,0x04B83D5C,0x21AE,0x11d2,0x8B,0x33,0x00,0x60,0x08,0x06,0xD9,0xB6);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemMethod,0x04B83D5B,0x21AE,0x11d2,0x8B,0x33,0x00,0x60,0x08,0x06,0xD9,0xB6);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemMethodSet,0x04B83D5A,0x21AE,0x11d2,0x8B,0x33,0x00,0x60,0x08,0x06,0xD9,0xB6);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemEventSource,0x04B83D58,0x21AE,0x11d2,0x8B,0x33,0x00,0x60,0x08,0x06,0xD9,0xB6);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemSecurity,0xB54D66E9,0x2287,0x11d2,0x8B,0x33,0x00,0x60,0x08,0x06,0xD9,0xB6);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemPrivilege,0x26EE67BC,0x5804,0x11d2,0x8B,0x4A,0x00,0x60,0x08,0x06,0xD9,0xB6);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemPrivilegeSet,0x26EE67BE,0x5804,0x11d2,0x8B,0x4A,0x00,0x60,0x08,0x06,0xD9,0xB6);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemRefreshableItem,0x8C6854BC,0xDE4B,0x11d3,0xB3,0x90,0x00,0x10,0x5A,0x1F,0x47,0x3A);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemObjectPathComponents,0xF575AF1A,0xE58D,0x11d3,0xB3,0x91,0x00,0x10,0x5A,0x1F,0x47,0x3A);
MIDL_DEFINE_GUID(CLSID, CLSID_SWbemTransaction,0x80B736A1,0x75B0,0x471c,0xA7,0xA4,0x85,0x52,0x91,0x7D,0x85,0x39);
MIDL_DEFINE_GUID(CLSID, CLSID_WmiMessageMsmqSender,0x122D47A6,0xCEEC,0x4de1,0x80,0x56,0xB6,0xD1,0x6F,0x29,0xBC,0x97);
MIDL_DEFINE_GUID(CLSID, CLSID_WmiMessageMsmqReceiver,0x9E007F18,0x9C24,0x4630,0x8B,0x3E,0x61,0xF9,0x62,0x80,0xC5,0x93);
MIDL_DEFINE_GUID(CLSID, CLSID_WmiMessageDcomSender,0x622D47B6,0xCEEC,0x4de1,0x80,0x56,0xB6,0xD1,0x6F,0x29,0xBC,0x97);
MIDL_DEFINE_GUID(CLSID, CLSID_WmiMessageDcomReceiver,0x9F007F18,0x9C24,0x4630,0x8B,0x3E,0x61,0xF9,0x62,0x80,0xC5,0x93);
MIDL_DEFINE_GUID(CLSID, CLSID_WmiMessageMultiSendReceive,0x89F9F7B0,0x8DE3,0x4ae0,0x8B,0x41,0x10,0x9A,0xBA,0xB3,0x21,0x51);
MIDL_DEFINE_GUID(CLSID, CLSID_WmiMessageQueue,0xC89DBDC4,0x5491,0x409a,0x8D,0x00,0xE3,0x45,0x38,0x21,0x1F,0xED);
MIDL_DEFINE_GUID(CLSID, CLSID_WmiMessageQueueManager,0xFF10E656,0x2B7C,0x421e,0xB1,0x45,0x7A,0xB3,0x37,0xFB,0x86,0x5F);
MIDL_DEFINE_GUID(CLSID, CLSID_WmiMessageService,0xCE69CC1E,0x1EC0,0x4847,0x9C,0x0D,0xD2,0xF2,0xD8,0x0D,0x07,0xCF);
MIDL_DEFINE_GUID(CLSID, CLSID_WmiSmartObjectMarshal,0xC169CC11,0x1EC1,0x4847,0x9C,0x0D,0xD2,0xF2,0xD8,0x0D,0x07,0xCF);
MIDL_DEFINE_GUID(CLSID, CLSID_MsiMethodStatusSink,0xFDD70FF2,0x0195,0x11d3,0xA9,0x7D,0x00,0xA0,0xC9,0x95,0x49,0x21);
MIDL_DEFINE_GUID(CLSID, CLSID_MsiProductMethods,0xAB4184C0,0xFDAD,0x11D2,0xA9,0x7B,0x00,0xA0,0xC9,0x95,0x49,0x21);
MIDL_DEFINE_GUID(CLSID, CLSID_MsiSoftwareFeatureMethods,0xE9B5C790,0xFDAD,0x11D2,0xA9,0x7B,0x00,0xA0,0xC9,0x95,0x49,0x21);
MIDL_DEFINE_GUID(CLSID, CLSID_WMIObjectBroker,0x4BA59771,0x8FBF,0x4E67,0x99,0x17,0x3B,0xBB,0x39,0xB7,0x43,0xAB);
MIDL_DEFINE_GUID(CLSID, CLSID_WMIObjectBrokerRegistration,0x9ECF8EC8,0xA9ED,0x47DF,0xBB,0x9A,0x81,0xDC,0xB3,0x69,0x85,0x07);
MIDL_DEFINE_GUID(CLSID, CLSID_CMSnapin,0x0F3621F1,0x23C6,0x11D1,0xAD,0x97,0x00,0xAA,0x00,0xB8,0x8E,0x5A);
MIDL_DEFINE_GUID(CLSID, CLSID_CMSnapinAbout,0xA1B9E020,0x3226,0x11D2,0x88,0x3E,0x00,0x10,0x4B,0x2A,0xFB,0x46);
MIDL_DEFINE_GUID(CLSID, CLSID_NSDrive,0x6E8E0081,0x19CD,0x11D1,0xAD,0x91,0x00,0xAA,0x00,0xB8,0xE0,0x5A);
MIDL_DEFINE_GUID(CLSID, CLSID_NSDriveAbout,0x692A8956,0x1089,0x11D2,0x88,0x37,0x00,0x10,0x4B,0x2A,0xFB,0x46);
MIDL_DEFINE_GUID(CLSID, CLSID_SDSnapin,0xBD95BA60,0x2E26,0xAAD1,0xAD,0x99,0x00,0xAA,0x00,0xB8,0xE0,0x5A);
MIDL_DEFINE_GUID(CLSID, CLSID_SDSnapinAbout,0xA1B9E04A,0x3226,0x11D2,0x88,0x3E,0x00,0x10,0x4B,0x2A,0xFB,0x46);
MIDL_DEFINE_GUID(CLSID, CLSID_WMISnapin,0x5C659257,0xE236,0x11D2,0x88,0x99,0x00,0x10,0x4B,0x2A,0xFB,0x46);
MIDL_DEFINE_GUID(CLSID, CLSID_WMISnapinAbout,0x5C659258,0xE236,0x11D2,0x88,0x99,0x00,0x10,0x4B,0x2A,0xFB,0x46);
MIDL_DEFINE_GUID(CLSID, CLSID_PseudoProvider,0xE002E4EE,0xE6EA,0x11d2,0x9C,0xB3,0x00,0x10,0x5A,0x1F,0x48,0x01);
MIDL_DEFINE_GUID(CLSID, CLSID_KernelTraceProvider,0x9877D8A7,0xFDA1,0x43F9,0xAE,0xEA,0xF9,0x07,0x47,0xEA,0x66,0xB0);
MIDL_DEFINE_GUID(CLSID, CLSID_NCProvider,0x29F06F0C,0xFB7F,0x44A5,0x83,0xCD,0xD4,0x17,0x05,0xD5,0xC5,0x25);
MIDL_DEFINE_GUID(CLSID, CLSID_VSAPlugIn,0x2169E810,0xFE80,0x4107,0xAE,0x18,0x79,0x8D,0x50,0x68,0x4A,0x71);
MIDL_DEFINE_GUID(CLSID, CLSID_VSAToWMIEventProvider,0x13A77B61,0x226B,0x46A9,0x91,0xB9,0x22,0x52,0x12,0x79,0x6D,0x92);
MIDL_DEFINE_GUID(CLSID, CLSID_DcomMsgReceiveStub,0x7879B294,0xBF5F,0x476b,0xAB,0xC9,0x9B,0x1F,0x17,0x61,0x6A,0xFB);

MIDL_DEFINE_GUID(CLSID, CLSID_MyEventProvider, 0x4916157a, 0xfbe7, 0x11d1, 0xae, 0xc4, 0x0, 0xc0, 0x4f, 0xb6, 0x88, 0x20);


MIDL_DEFINE_GUID(CLSID, UUID_DCOMName, 0xa2f7d6c1, 0x8dcd, 0x11d1, 0x9e, 0x7c, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0xa8);

MIDL_DEFINE_GUID(CLSID, UUID_LocalAddResName, 0xa1044802, 0x8f7e, 0x11d1, 0x9e, 0x7c, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0xa8);


MIDL_DEFINE_GUID(CLSID, UUID_LocalAddrType, 0xa1044803, 0x8f7e, 0x11d1, 0x9e, 0x7c, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0xa8);


DEFINE_GUID(UUID_LocalAddrTypeName, 0xa1044804, 0x8f7e, 0x11d1, 0x9e, 0x7c, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0xa8);

DEFINE_GUID(CLSID_WinNTConnectionObject,0x7992c6eb,0xd142,0x4332,0x83,0x1e,0x31,0x54,0xc5,0x0a,0x83,0x16);
DEFINE_GUID(CLSID_LDAPConnectionObject,0x7da2a9c4,0x0c46,0x43bd,0xb0,0x4e,0xd9,0x2b,0x1b,0xe2,0x7c,0x45);



MIDL_DEFINE_GUID(CLSID, CLSID_PerfProvider,0xF00B4404L,0xF8F1,0x11CE,0xA5,0xB6,0x00,0xAA,0x00,0x68,0x0C,0x3F);
MIDL_DEFINE_GUID(CLSID, CLSID_PerfPropProv, 0x72967903, 0x68ec, 0x11d0, 0xb7, 0x29, 0x0, 0xaa, 0x0, 0x62, 0xcb, 0xb7);
MIDL_DEFINE_GUID(CLSID, CLSID_RegistryEventProvider,0xfa77a74e,0xe109,0x11d0,0xad,0x6e,0x00,0xc0,0x4f,0xd8,0xfd,0xff);



MIDL_DEFINE_GUID(CLSID, CLSID__DSSvcExWrap,0xFD2057FA,0x99FE,0x4f10,0x89,0x08,0x9A,0xA2,0xAA,0xB3,0x2A,0x6E);
MIDL_DEFINE_GUID(IID, IID_IWMIRefreshableCooker,0x13ED7E55,0x8D63,0x41b0,0x90,0x86,0xD0,0xC5,0xC1,0x73,0x64,0xC8);
MIDL_DEFINE_GUID(IID, IID_IWMISimpleObjectCooker,0xA239BDF1,0x0AB1,0x45a0,0x87,0x64,0x15,0x91,0x15,0x68,0x95,0x89);
MIDL_DEFINE_GUID(IID, IID_IWMISimpleCooker,0x510ADF6E,0xD481,0x4a64,0xB7,0x4A,0xCC,0x71,0x2E,0x11,0xAA,0x34);


typedef struct _ArrayCLSID {
    //REFGUID Clsid; 
    const GUID * pClsid;
    const char * pStrClsid;
} ArrayCLSID;

extern DWORD g_nClsids;

#endif /*__DATA_H__*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmicooker\wmiobjcooker.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    WMIObjCooker.h

Abstract:

    The implementation of per object cooking

History:

    a-dcrews	01-Mar-00	Created

--*/

#ifndef _WMIOBJCOOKER_H_
#define _WMIOBJCOOKER_H_

#include <wbemint.h>
#include <wstlallc.h>
#include "CookerUtils.h"
#include "Cache.h"

#define WMI_DEFAULT_SAMPLE_WINDOW			2

//
//
//
//
//////////////////////////////////////////////////////////////////

WMISTATUS GetPropValue( CProperty* pProp, IWbemObjectAccess* pInstance, __int64* pnResult );


//////////////////////////////////////////////////////////////////
//
//	CWMISimpleObjectCooker
//
//////////////////////////////////////////////////////////////////

class CWMISimpleObjectCooker : public IWMISimpleObjectCooker
{
	long				m_lRef;				// Reference Counter
	HRESULT             m_InitHR;           // to hold the failure within the constructor

	IWbemObjectAccess*	m_pCookingClass;	// The cooking class
	WCHAR*				m_wszClassName;		// The cooking class' name

	IWbemServices * m_pNamespace;

	// Instance Management
	// ===================

    DWORD m_NumInst;
	IdCache<CCookingInstance *>	m_InstanceCache;	// The cooking instance cache

	// Cooking Property Definition Management
	// ======================================
	
	std::vector<CCookingProperty*, wbem_allocator<CCookingProperty*> > m_apPropertyCache;
	DWORD				m_dwPropertyCacheSize;
	DWORD				m_dwNumProperties;	// The number of properties

	// Private Methods
	// ===============

	WMISTATUS GetData( CCookingProperty* pProperty, 
					   __int64** panRawCounter, 
					   __int64** panRawBase, 
					   __int64** panRawTimeStamp,
					   DWORD* pdwNumEls );

	WMISTATUS UpdateSamples( CCookingInstance* pCookedInstance,DWORD dwRefreshStamp);
	WMISTATUS CookInstance( CCookingInstance* pCookingRecord, DWORD dwRefreshStamp);

public:

	CWMISimpleObjectCooker();
	CWMISimpleObjectCooker( WCHAR* wszCookingClassName, 
	                        IWbemObjectAccess* pCookingClass, 
	                        IWbemObjectAccess* pRawClass,
	                        IWbemServices * pNamespace = NULL);
	virtual ~CWMISimpleObjectCooker();
	
	WCHAR* GetCookingClassName(){ return m_wszClassName; }
	HRESULT GetLastHR(){ return m_InitHR; }

	WMISTATUS SetProperties( IWbemClassObject* pCookingClassObject, IWbemObjectAccess *pRawClass );

	// Standard COM methods
	// ====================

	STDMETHODIMP QueryInterface(REFIID riid, void** ppv);
	STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	// IWMISimpleObjectCooker COM Interface
	// ====================================

	STDMETHODIMP SetClass( 
		/*[in]	*/ WCHAR* wszCookingClassName,
		/*[in]  */ IWbemObjectAccess *pCookingClass,
		/*[in]  */ IWbemObjectAccess *pRawClass);
        
	STDMETHODIMP SetCookedInstance( 
		/*[in]  */ IWbemObjectAccess *pCookedInstance,
		/*[out] */ long *plId
		);
        
	STDMETHODIMP BeginCooking( 
		/*[in]  */ long lId,
		/*[in]  */ IWbemObjectAccess *pSampleInstance,
		/*[in]  */ unsigned long dwRefresherId);
        
	STDMETHODIMP StopCooking( 
		/*[in]  */ long lId);
        
	STDMETHODIMP Recalc(/*[in]  */ unsigned long dwRefresherId);
        
	STDMETHODIMP Remove( 
		/*[in]  */ long lId);
        
	STDMETHODIMP Reset();
};

#endif	//_WMIOBJCOOKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmiexts\essutil.cpp ===
#include <wmiexts.h>
#include <malloc.h>

#include <wbemint.h>

#ifdef SetContext
#undef SetContext
#endif

#ifdef GetContext
#undef GetContext
#endif

#ifdef GetExpression
#undef GetExpression
#endif

#include <utilfun.h>

#define COREPROX_POLARITY

#include <esssink.h>
#include <ess.h>
#include <nsrep.h>
#include <equeue.h>

DWORD
CallBackEssNamespace(void * pKey, void * pValue)
{
    WCHAR pName[MAX_PATH+1];
    pName[MAX_PATH] = 0;

    if (pKey && ReadMemory((ULONG_PTR)pKey,pName,MAX_PATH*sizeof(WCHAR),NULL))
    {
        dprintf("      %S\n",pName);
    }

    DEFINE_CPP_VAR(CEssNamespace,varCEssNamespace);
    CEssNamespace * pEssNameSpace = GET_CPP_VAR_PTR(CEssNamespace,varCEssNamespace);

    if (pValue && ReadMemory((ULONG_PTR)pValue,pEssNameSpace,sizeof(CEssNamespace),NULL))
    {
        dprintf("      %p\n",pValue);        
        dprintf("      m_csLevel2: owner %x event %x\n",pEssNameSpace->m_csLevel2.m_dwThreadId,pEssNameSpace->m_csLevel2.m_hEvent);
        dprintf("      m_aDeferredEvents size %x %p\n",pEssNameSpace->m_aDeferredEvents.m_Array.m_nSize,pEssNameSpace->m_aDeferredEvents.m_Array.m_pArray);
        dprintf("      m_wszName          %p\n",pEssNameSpace->m_wszName);
        dprintf("      m_pProviderFactory %p\n",pEssNameSpace->m_pProviderFactory);
        dprintf("      m_pCoreSvc         %p\n",pEssNameSpace->m_pCoreSvc);
        dprintf("      m_pFullSvc         %p\n",pEssNameSpace->m_pFullSvc);
        dprintf("      m_pInternalCoreSvc %p\n",pEssNameSpace->m_pInternalCoreSvc);
        dprintf("      m_pInternalFullSvc %p\n",pEssNameSpace->m_pInternalFullSvc);
        //
        CBindingTable * pBinding = &pEssNameSpace->m_Bindings;
        dprintf("      m_Binding\n");        

        dprintf("        wbemess!CEventFilter\n");        
        _Map * pMapF = (_Map *)((BYTE*)pValue+FIELD_OFFSET(CEssNamespace,m_Bindings)+FIELD_OFFSET(CBindingTable,m_apFilters)+FIELD_OFFSET(CSortedRefedKeyedPointerArray<CEventFilter>,m_t));
        //&pBinding->m_apFilters.m_t;
        PrintMapCB(pMapF,TRUE,CallBackObj); 
        
        dprintf("        wbemess!CEventConsumer\n");        
        _Map * pMapC = (_Map *)((BYTE*)pValue+FIELD_OFFSET(CEssNamespace,m_Bindings)+FIELD_OFFSET(CBindingTable,m_apConsumers)+FIELD_OFFSET(CSortedRefedKeyedPointerArray<CEventConsumer>,m_t));
        PrintMapCB(pMapC,TRUE,CallBackObj); 

        DWORD NumEl = pEssNameSpace->m_ConsumerProviderCache.m_apRecords.m_Array.m_nSize;
        VOID * pVoid = pEssNameSpace->m_ConsumerProviderCache.m_apRecords.m_Array.m_pArray;
        VOID **ppPointers = (VOID **)_alloca(NumEl * sizeof(VOID *));
        dprintf("        wbemess!CConsumerProviderCache %x - %p\n",NumEl,pVoid);
        if (ReadMemory((ULONG_PTR)pVoid,ppPointers,NumEl * sizeof(VOID *),NULL))
        {
            for (DWORD i=0;i<NumEl;i++)
            {
                dprintf("          %x - %p\n",i,ppPointers[i]);
            }
        }
        
        dprintf("          ----------------------- End of Namespace\n");
    }

    return 0;
}

//
// prototype declaration
//
void DumpRecord(ULONG_PTR pRecord_OOP,
                HANDLE hSourceProcess,
                pfnDumpRequest DumpRequest);


DWORD DumpCExecRequest(ULONG_PTR pExecReq_OOP)
{

    DEFINE_CPP_VAR(CEventQueue::CDeliverRequest,varCExecRequest);
    CEventQueue::CDeliverRequest * pExecReq = GET_CPP_VAR_PTR(CEventQueue::CDeliverRequest,varCExecRequest);
    
    ReadMemory((ULONG_PTR)pExecReq_OOP,pExecReq,sizeof(CEventQueue::CDeliverRequest),NULL);

    GetVTable((MEMORY_ADDRESS)pExecReq_OOP);
    dprintf("          %p m_hWhenDone\n",pExecReq->m_hWhenDone);      // Ptr32 to Void
    dprintf("          %p m_pNext\n",pExecReq->m_pNext);          // Ptr32 CCoreExecReq
    dprintf("          %08x m_lPriority\n",pExecReq->m_lPriority);      // Int 4B
    dprintf("          %d m_fOk\n",pExecReq->m_fOk);            // Char
    dprintf("          %p m_pConsumer ",pExecReq->m_pConsumer);         // Ptr32 _IWmiCoreHandle
    if (pExecReq->m_pConsumer){
        GetVTable((MEMORY_ADDRESS)pExecReq->m_pConsumer);    
    }    
    return 0;
}


void
Print_CEventQueue(ULONG_PTR pEventQueue_OOP, HANDLE hCurrentProcess)
{

    DEFINE_CPP_VAR(CEventQueue,varCEventQueue);
    CEventQueue * pEventQueue = GET_CPP_VAR_PTR(CEventQueue,varCEventQueue);
         

    if (ReadMemory(pEventQueue_OOP,pEventQueue,sizeof(CEventQueue),NULL))
    {
        dprintf("    CEventQueue @ %p\n",pEventQueue);
        
        //m_aThreads       : CFlexArray
        dprintf("    elems %d pointer %p\n",pEventQueue->m_aThreads.m_nSize,pEventQueue->m_aThreads.m_pArray);

        CExecQueue::CThreadRecord ** pRecord_OOP = (CExecQueue::CThreadRecord **)_alloca(sizeof(void*)*pEventQueue->m_aThreads.m_nSize);
        if (ReadMemory((ULONG_PTR)pEventQueue->m_aThreads.m_pArray,pRecord_OOP,sizeof(void*)*pEventQueue->m_aThreads.m_nSize,0))
        {

            DWORD i;
            for (i=0;i<pEventQueue->m_aThreads.m_nSize;i++)
            {
                dprintf("      -- CThreadRecord %d\n",i);
                DumpRecord((ULONG_PTR)pRecord_OOP[i],
                           hCurrentProcess,
                           DumpCExecRequest);
            }
        }

        dprintf("    m_pHead %p\n",pEventQueue->m_pHead);
        dprintf("    m_pTail %p\n",pEventQueue->m_pTail);
        // here code for the list
        CEventQueue::CDeliverRequest * pReq = (CEventQueue::CDeliverRequest *)pEventQueue->m_pHead;
            DWORD i = 0;
            while (pReq)
            {
                dprintf(" ---- list - %d\n",i++);
                DEFINE_CPP_VAR(CEventQueue::CDeliverRequest,MyAsyncReq);
                CEventQueue::CDeliverRequest * pReqHERE = GET_CPP_VAR_PTR(CEventQueue::CDeliverRequest,MyAsyncReq);
                ReadMemory((ULONG_PTR)pReq,pReqHERE,sizeof(CEventQueue::CDeliverRequest),NULL);

                //dprintf("   %p %p\n",pReq,pReqHERE->m_pNext);
                DumpCExecRequest((ULONG_PTR)pReq);

                if (pReq == pEventQueue->m_pTail)
                    break;
                
                pReq = (CEventQueue::CDeliverRequest *)pReqHERE->m_pNext;                

                if (CheckControlC())
                    break;                
            }
            //
   
            dprintf("    m_lNumThreads   %d \n",pEventQueue->m_lNumThreads);
            dprintf("    m_lNumIdle      %d\n",pEventQueue->m_lNumIdle);
            dprintf("    m_lNumRequests  %d\n",pEventQueue->m_lNumRequests);   
            dprintf("    m_lMaxThreads   %d\n",pEventQueue->m_lMaxThreads);    
            dprintf("    m_lHiPriBound      %d\n",pEventQueue->m_lHiPriBound);    
            dprintf("    m_lHiPriMaxThreads %d\n",pEventQueue->m_lHiPriMaxThreads); 
            dprintf("    m_lStartSlowdownCount  %d\n",pEventQueue->m_lStartSlowdownCount);
            dprintf("    m_lAbsoluteLimitCount  %d\n",pEventQueue->m_lAbsoluteLimitCount); 
            dprintf("    m_lOneSecondDelayCount %d\n",pEventQueue->m_lOneSecondDelayCount); 
            dprintf("    m_dblAlpha  %f\n",pEventQueue->m_dblAlpha);
            dprintf("    m_dblBeta   %f\n",pEventQueue->m_dblBeta);
            dprintf("    m_dwTimeout %x\n",pEventQueue->m_dwTimeout);
            dprintf("    m_pEss      %p\n",pEventQueue->m_pEss);
            
    }
    else
    {
        dprintf("RM %p\n",pEventQueue_OOP);
    }
}       

DECLARE_API(ess) 
{

    INIT_API();
    
    ULONG_PTR Addr = (ExtensionApis.lpGetExpressionRoutine)("wbemcore!g_pESS");
    VOID * pVoid= NULL;
    if (!Addr)
    {
    	pVoid = (VOID *)(ExtensionApis.lpGetExpressionRoutine)(args);
    }
    if (Addr || pVoid) 
    {
        if (Addr)
            ReadMemory(Addr,&pVoid,sizeof(pVoid),NULL);
    
        DEFINE_CPP_VAR(CEssObjectSink::XNewESS,varImp);
        CEssObjectSink::XNewESS * pImp = GET_CPP_VAR_PTR(CEssObjectSink::XNewESS,varImp);
        if (ReadMemory((ULONG_PTR)pVoid,pImp,sizeof(CEssObjectSink::XNewESS),NULL))
        {
            dprintf(" CEssObjectSink %p\n",pImp->m_pObject);
            DEFINE_CPP_VAR(CEssObjectSink,varCEssObjectSink);
            CEssObjectSink * pEssSink = GET_CPP_VAR_PTR(CEssObjectSink,varCEssObjectSink);
            if (ReadMemory((ULONG_PTR)pImp->m_pObject,pEssSink,sizeof(CEssObjectSink),NULL))
            {
                Print_CEventQueue((ULONG_PTR)pEssSink->m_pEss+FIELD_OFFSET(CEss,m_Queue),hCurrentProcess);
            
                dprintf("    m_pEss          %p\n",pEssSink->m_pEss);
                dprintf("    m_bShutdown     %08x\n",pEssSink->m_bShutdown);
                dprintf("    m_pCoreServices %p\n",pEssSink->m_pCoreServices);
                
                // CEss;
                DEFINE_CPP_VAR(CEss,varCEss);
                CEss * pEss = GET_CPP_VAR_PTR(CEss,varCEss);

                if (ReadMemory((ULONG_PTR)pEssSink->m_pEss,pEss,sizeof(CEss),NULL))
                {
                    _Map * pMap = (_Map *)((BYTE *)pEssSink->m_pEss + FIELD_OFFSET(CEss,m_mapNamespaces));
                    PrintMapCB(pMap,TRUE,CallBackEssNamespace);    
                }
                else
                {
                    dprintf("RM %p err %d\n",pEssSink->m_pEss,GetLastError());
                }
            }
	        else
    	    {
        	    dprintf("RM %p err %d\n",pImp->m_pObject,GetLastError());
	        }            
        }
        else
        {
            dprintf("RM %p err %d\n",Addr,GetLastError());
        }
    }
    else 
    {
        dprintf("invalid address %s\n",args);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmiexts\coreutil.cpp ===
#include <wmiexts.h>
#include <oleauto.h> // for BSTR definition
#include <malloc.h>

#include "utilfun.h"

#ifndef COREPROX_POLARITY
#define COREPROX_POLARITY
#endif


#include <wbemint.h>
#include <var.h>

typedef void IWbemCallSecurity;

#ifndef INTERNAL
#define INTERNAL
#endif

#ifndef ADDREF
#define ADDREF
#endif

#ifndef READONLY
#define READONLY
#endif

#ifdef GetContext
#undef GetContext
#endif

#include <coreq.h>
#include <wbemq.h>

typedef void IWmiDbSession;
typedef void IWmiDbController;
typedef void IWmiDbHandle;
typedef void CComplexProjectionSink;
typedef void CWbemObject;
typedef void CWbemClass;
typedef void CWbemInstance;

#define ReleaseIfNotNULL

class CAsyncReq;
class ParsedObjectPath;

#include <winntsec.h>
#include <wstring.h>
#include <sinks.h>
#include <dynasty.h>
#include <ql.h>
#include <wbemname.h>

#include <wmitask.h>

class CAsyncReq : public CWbemRequest
{
protected:
    CStdSink *m_pHandler;
    long m_lRequestHandle;
};

class CAsyncServiceQueue : public CWbemQueue{
};

/*
class CFlexArray {
private:
   DWORD  m_nSize;
   DWORD  m_nExtent;
   DWORD  m_nGrowByPercent;
   void * m_pArray;
}
*/

/*
typedef 
enum tag_WMI_TASK_TYPE
    {	WMICORE_TASK_NULL	= 0,
	WMICORE_TASK_GET_OBJECT	= 1,
	WMICORE_TASK_GET_INSTANCE	= 2,
	WMICORE_TASK_PUT_INSTANCE	= 3,
	WMICORE_TASK_DELETE_INSTANCE	= 4,
	WMICORE_TASK_ENUM_INSTANCES	= 5,
	WMICORE_TASK_GET_CLASS	= 6,
	WMICORE_TASK_PUT_CLASS	= 7,
	WMICORE_TASK_DELETE_CLASS	= 8,
	WMICORE_TASK_ENUM_CLASSES	= 9,
	WMICORE_TASK_EXEC_QUERY	= 10,
	WMICORE_TASK_EXEC_METHOD	= 11,
	WMICORE_TASK_OPEN	= 12,
	WMICORE_TASK_OPEN_SCOPE	= 13,
	WMICORE_TASK_OPEN_NAMESPACE	= 14,
	WMICORE_TASK_OPEN_COLLECTION	= 15,
	WMICORE_TASK_ADD	= 16,
	WMICORE_TASK_REMOVE	= 17,
	WMICORE_TASK_REFRESH_OBJECT	= 18,
	WMICORE_TASK_RENAME_OBJECT	= 19,
	WMICORE_TASK_ATOMIC_DYN_INST_GET	= 20,
	WMICORE_TASK_ATOMIC_DYN_INST_ENUM	= 21,
	WMICORE_TASK_ATOMIC_DYN_INST_QUERY	= 22,
	WMICORE_TASK_ATOMIC_DYN_INST_PUT	= 23,
	WMICORE_TASK_DYN_CLASS_ENUM	= 24,
	WMICORE_TASK_EXEC_NOTIFICATION_QUERY	= 25,
	WMICORE_TASK_TYPE_SYNC	= 0x1000000,
	WMICORE_TASK_TYPE_SEMISYNC	= 0x2000000,
	WMICORE_TASK_TYPE_ASYNC	= 0x4000000,
	WMICORE_TASK_TYPE_PRIMARY	= 0x10000000,
	WMICORE_TASK_TYPE_SUBTASK	= 0x20000000,
	WMICORE_TASK_TYPE_DEPENDENT	= 0x40000000
    } 	WMI_TASK_TYPE;

typedef 
enum tag_WMICORE_TASK_STATUS
    {	WMICORE_TASK_STATUS_NEW	= 1,
	WMICORE_TASK_STATUS_VALIDATED	= WMICORE_TASK_STATUS_NEW + 1,
	WMICORE_TASK_STATUS_SUSPENDED	= WMICORE_TASK_STATUS_VALIDATED + 1,
	WMICORE_TASK_STATUS_EXECUTING	= WMICORE_TASK_STATUS_SUSPENDED + 1,
	WMICORE_TASK_STATUS_WAITING_ON_SUBTASKS	= WMICORE_TASK_STATUS_EXECUTING + 1,
	WMICORE_TASK_STATUS_TIMED_OUT	= WMICORE_TASK_STATUS_WAITING_ON_SUBTASKS + 1,
	WMICORE_TASK_STATUS_CORE_COMPLETED	= WMICORE_TASK_STATUS_TIMED_OUT + 1,
	WMICORE_TASK_STATUS_CLIENT_COMPLETED	= WMICORE_TASK_STATUS_CORE_COMPLETED + 1,
	WMICORE_TASK_STATUS_CANCELLED	= WMICORE_TASK_STATUS_CLIENT_COMPLETED + 1,
	WMICORE_TASK_STATUS_FAILED	= WMICORE_TASK_STATUS_CANCELLED + 1
    } 	WMICORE_TASK_STATUS;

*/


//typedef void CWbemNamespace;

char * GetTaskStatus(DWORD TaskStatus)
{
    char * p = "<unk>";
    switch(TaskStatus)
    {
        case WMICORE_TASK_STATUS_NEW: p = "WMICORE_TASK_STATUS_NEW"; break;
        case WMICORE_TASK_STATUS_VALIDATED: p = "WMICORE_TASK_STATUS_VALIDATED"; break;
        case WMICORE_TASK_STATUS_SUSPENDED: p = "WMICORE_TASK_STATUS_SUSPENDED"; break;
        case WMICORE_TASK_STATUS_EXECUTING: p = "WMICORE_TASK_STATUS_EXECUTING"; break;
        case WMICORE_TASK_STATUS_WAITING_ON_SUBTASKS: p = "WMICORE_TASK_STATUS_WAITING_ON_SUBTASKS"; break;
        case WMICORE_TASK_STATUS_TIMED_OUT: p = "WMICORE_TASK_STATUS_TIMED_OUT"; break;
        case WMICORE_TASK_STATUS_CORE_COMPLETED: p = "WMICORE_TASK_STATUS_CORE_COMPLETED"; break;
        case WMICORE_TASK_STATUS_CLIENT_COMPLETED: p = "WMICORE_TASK_STATUS_CLIENT_COMPLETED"; break;
        case WMICORE_TASK_STATUS_CANCELLED: p = "WMICORE_TASK_STATUS_CANCELLED"; break;
        case WMICORE_TASK_STATUS_FAILED: p = "WMICORE_TASK_STATUS_FAILED"; 
        break;
    };
    return p;
}

char * GetTaskType(DWORD TaskType)
{
    char * p = "<unk>";
    switch(TaskType & 0xFF)
    {
        case WMICORE_TASK_NULL: p = "WMICORE_TASK_NULL"; break;
        case WMICORE_TASK_GET_OBJECT: p = "WMICORE_TASK_GET_OBJECT"; break;
        case WMICORE_TASK_GET_INSTANCE: p = "WMICORE_TASK_GET_INSTANCE"; break;
        case WMICORE_TASK_PUT_INSTANCE: p = "WMICORE_TASK_PUT_INSTANCE"; break;
        case WMICORE_TASK_DELETE_INSTANCE: p = "WMICORE_TASK_DELETE_INSTANCE"; break;
        case WMICORE_TASK_ENUM_INSTANCES:  p = "WMICORE_TASK_ENUM_INSTANCES"; break;
        case WMICORE_TASK_GET_CLASS:    p = "WMICORE_TASK_GET_CLASS"; break;
        case WMICORE_TASK_PUT_CLASS:    p = "WMICORE_TASK_PUT_CLASS"; break;
        case WMICORE_TASK_DELETE_CLASS: p = "WMICORE_TASK_DELETE_CLASS"; break;
        case WMICORE_TASK_ENUM_CLASSES: p = "WMICORE_TASK_ENUM_CLASSES"; break;
        case WMICORE_TASK_EXEC_QUERY:   p = "WMICORE_TASK_EXEC_QUERY"; break;
        case WMICORE_TASK_EXEC_METHOD:  p = "WMICORE_TASK_EXEC_METHOD"; break;
        case WMICORE_TASK_OPEN:         p = "WMICORE_TASK_OPEN"; break;
        case WMICORE_TASK_OPEN_SCOPE:   p = "WMICORE_TASK_OPEN_SCOPE"; break;
        case WMICORE_TASK_OPEN_NAMESPACE: p = "WMICORE_TASK_OPEN_NAMESPACE"; break;
        case WMICORE_TASK_EXEC_NOTIFICATION_QUERY: p = "WMICORE_TASK_EXEC_NOTIFICATION_QUERY"; break;
    }
    return p;
}

char * GetOpType(DWORD TaskType)
{
    if (TaskType & WMICORE_TASK_TYPE_SYNC)
        return " WMICORE_TASK_TYPE_SYNC";

    if (TaskType & WMICORE_TASK_TYPE_SEMISYNC)
        return " WMICORE_TASK_TYPE_SEMISYNC";

    if (TaskType & WMICORE_TASK_TYPE_ASYNC)
        return " WMICORE_TASK_TYPE_ASYNC";

    if (TaskType & WMICORE_TASK_TYPE_PRIMARY)
        return " WMICORE_TASK_TYPE_PRIMARY";

    if (TaskType & WMICORE_TASK_TYPE_DEPENDENT)
        return " WMICORE_TASK_TYPE_DEPENDENT";

    return "<unk>";
}

void DumpCWmiTask(CWmiTask * pTask_OOP)
{
    DEFINE_CPP_VAR(CWmiTask, MyWmiTask);
    if (ReadMemory((ULONG_PTR)pTask_OOP,&MyWmiTask,sizeof(MyWmiTask),0))
    {
	    CWmiTask * pWmiTask = (CWmiTask *)&MyWmiTask;

	    dprintf("            m_uRefCount        %d\n",pWmiTask->m_uRefCount);        //: 0x3
	    dprintf("            m_uTaskType        %s %s\n",GetTaskType(pWmiTask->m_uTaskType),GetOpType(pWmiTask->m_uTaskType));        //: 0x11000005
	    dprintf("            m_uTaskStatus      %s\n",GetTaskStatus(pWmiTask->m_uTaskStatus));      //: 0x0
	    dprintf("            m_uTaskId          %p\n",pWmiTask->m_uTaskId);          //: 0x17f
	    if (pWmiTask->m_sDebugInfo.m_pString)
	    {
	        WCHAR pString[MAX_PATH+1];
	        pString[MAX_PATH] = 0;
	        if (ReadMemory((ULONG_PTR)pWmiTask->m_sDebugInfo.m_pString,pString,MAX_PATH*sizeof(WCHAR),NULL))
	        {
	            dprintf("            m_sDebugInfo       %S\n",(WCHAR *)pString);
	        }
	    }
	    else
	    {
	        dprintf("            m_sDebugInfo       %p\n",pWmiTask->m_sDebugInfo.m_pString);       //: WString
	    }
	    dprintf("            m_pAsyncClientSink %p\n",pWmiTask->m_pAsyncClientSink); //: (null)
	    dprintf("            m_pReqSink         %p\n",pWmiTask->m_pReqSink);         //: 0x06e0cc80
	    dprintf("            m_pWorkingFnz      %p\n",pWmiTask->m_pWorkingFnz);      //: 0x01395ed8
	    //dprintf("            m_pUser            %p\n",pWmiTask->m_pUser);            //: (null)
	    dprintf("            m_pSec             %p\n",pWmiTask->m_pSec);             //: (null)
	    dprintf("            m_pAsyncClientSink %p\n",pWmiTask->m_pAsyncClientSink);  //: (null)
	    dprintf("            m_pNs              %p\n",pWmiTask->m_pNs);              //: 0x0131a198
	    //dprintf("m_uStartTime     //: 0x10c4a8c6
	    //dprintf("m_uUpdateTime    //: 0x0

	    DWORD i;
	    VOID ** ppPointers = (VOID **)_alloca(max(pWmiTask->m_aTaskProviders.m_nSize,pWmiTask->m_aArbitratees.m_nSize));

	    dprintf("            m_aTaskProviders: size %x p %p\n",
	            pWmiTask->m_aTaskProviders.m_nSize,
	            pWmiTask->m_aTaskProviders.m_pArray);
	    if (pWmiTask->m_aTaskProviders.m_nSize)
	    {
	        if (ReadMemory((ULONG_PTR)pWmiTask->m_aTaskProviders.m_pArray,ppPointers,sizeof(void *)*pWmiTask->m_aTaskProviders.m_nSize,NULL))
	        {
	            for(i=0;i<pWmiTask->m_aTaskProviders.m_nSize;i++)
	            {
	                dprintf("              %p - %x\n",ppPointers[i],i);
	                GetVTable((MEMORY_ADDRESS)ppPointers[i]);
	            }
	        }
	    }
	    dprintf("            m_aArbitratees: size %x p %p\n",
	            pWmiTask->m_aArbitratees.m_nSize,
	            pWmiTask->m_aArbitratees.m_pArray);
	    if (pWmiTask->m_aArbitratees.m_nSize)
	    {
	        if (ReadMemory((ULONG_PTR)pWmiTask->m_aArbitratees.m_pArray,ppPointers,sizeof(void *)*pWmiTask->m_aArbitratees.m_nSize,NULL))
	        {
	            for(i=0;i<pWmiTask->m_aArbitratees.m_nSize;i++)
	            {
	                dprintf("              %p - %x\n",ppPointers[i],i);
	                GetVTable((MEMORY_ADDRESS)ppPointers[i]);
	            }        
	        }    
	    }
    }
    else
    {
    	dprintf("RM %p\n",pTask_OOP);
    }
}

DWORD DumpCAsyncReq(ULONG_PTR pAsyncReq_OOP)
{

    DEFINE_CPP_VAR(CAsyncReq,MyCAsyncReq);
    ReadMemory((ULONG_PTR)pAsyncReq_OOP,&MyCAsyncReq,sizeof(CAsyncReq),NULL);

    CAsyncReq * pAsyncReq = (CAsyncReq *)&MyCAsyncReq;

    GetVTable((MEMORY_ADDRESS)pAsyncReq_OOP);
    dprintf("          %p m_hWhenDone\n",pAsyncReq->m_hWhenDone);      // Ptr32 to Void
    dprintf("          %p m_pNext\n",pAsyncReq->m_pNext);          // Ptr32 CCoreExecReq
    dprintf("          %08x m_lPriority\n",pAsyncReq->m_lPriority);      // Int 4B
    dprintf("          %d m_fOk\n",pAsyncReq->m_fOk);            // Char
    dprintf("          %p m_phTask ",pAsyncReq->m_phTask);         // Ptr32 _IWmiCoreHandle
    if (pAsyncReq->m_phTask){
        DumpCWmiTask((CWmiTask *)pAsyncReq->m_phTask);
    }
    dprintf("          %p m_pContext\n",pAsyncReq->m_pContext);       // Ptr32 IWbemContext
    dprintf("          %p m_pCA\n",pAsyncReq->m_pCA);            // Ptr32 IWbemCausalityAccess
    dprintf("          %p m_pCallSec\n",pAsyncReq->m_pCallSec);       // Ptr32 IWbemCallSecurity
    dprintf("          %p m_pHandler ",pAsyncReq->m_pHandler);       // Ptr32 CStdSink
    //GetVTable(pAsyncReq->m_pHandler);
    dprintf("          %08x m_lRequestHandle\n",pAsyncReq->m_lRequestHandle); // Int 4B

    return 0;
}

void DumpCWbemNamespace(CWbemNamespace * pNamespace_OOP)
{
    DEFINE_CPP_VAR(CWbemNamespace, MyWbemNamespace);
    ReadMemory((ULONG_PTR)pNamespace_OOP,&MyWbemNamespace,sizeof(CWbemNamespace),0);

    CWbemNamespace * pName = (CWbemNamespace *)&MyWbemNamespace;

    dprintf("            m_bShutDown          %d\n",pName->m_bShutDown);
    dprintf("            Status               %d\n",pName->Status);
    dprintf("            m_uSecondaryRefCount %d\n",pName->m_uSecondaryRefCount);
    dprintf("            m_uPrimaryRefCount   %d\n",pName->m_uPrimaryRefCount);

    //
    WCHAR pBuff[MAX_PATH];
    ReadMemory((ULONG_PTR)pName->m_pThisNamespace,pBuff,sizeof(pBuff),0);
    pBuff[MAX_PATH-1] = 0; // in any case
    dprintf("            m_pThisNamespace     %S\n",pBuff);

    dprintf("            m_pProvFact          %p\n",pName->m_pProvFact);
    dprintf("            m_pCoreSvc           %p\n",pName->m_pCoreSvc);
    dprintf("            m_bRepositOnly       %d\n",pName->m_bRepositOnly);
	dprintf("            m_pRefreshingSvc     %p\n",pName->m_pRefreshingSvc);
	dprintf("            m_bESS               %d\n",pName->m_bESS);
    
}


void GetThreadInfo(HANDLE hThread,HANDLE hSourceProcess)
{
    HANDLE hThreadThisProc;

    if (DuplicateHandle(hSourceProcess,
                    hThread,
                    GetCurrentProcess(),
                    &hThreadThisProc,
                    0,
                    FALSE,
                    DUPLICATE_SAME_ACCESS))
    {

	    NTSTATUS Status;
	    ULONG Long;
	    THREAD_BASIC_INFORMATION TBasicInfo;
	    Status = NtQueryInformationThread(hThreadThisProc,
	                                      ThreadBasicInformation,
	                                      &TBasicInfo,
	                                      sizeof(TBasicInfo),
	                                      &Long);
	                                      
	    if ( Status == 0 )
	    {
	        dprintf("        %p %x.%x\n",TBasicInfo.TebBaseAddress,TBasicInfo.ClientId.UniqueProcess,TBasicInfo.ClientId.UniqueThread);
	    }
	    else
	    {
	       dprintf("    NTSTATUS %08x\n",Status);
	    }

	    CloseHandle(hThreadThisProc);
    }
    else
    {
        dprintf("DuplicateHandle %d\n",GetLastError());
    }
}



void DumpRecord(ULONG_PTR pRecord_OOP,
                HANDLE hSourceProcess,
                pfnDumpRequest DumpRequest)
{

    DEFINE_CPP_VAR(CCoreQueue::CThreadRecord,MyThreadRecord);
    ReadMemory((ULONG_PTR)pRecord_OOP,&MyThreadRecord,sizeof(CCoreQueue::CThreadRecord),NULL);

    CCoreQueue::CThreadRecord * pRecord = (CCoreQueue::CThreadRecord *)&MyThreadRecord;

    //dprintf("      %p m_pQueue\n",pRecord->m_pQueue);         //: Ptr32 CCoreQueue
    dprintf("      %p m_pCurrentRequest",pRecord->m_pCurrentRequest);// : Ptr32 CCoreExecReq
    dprintf(" %d m_bReady",pRecord->m_bReady);         //: Int 4B
    dprintf(" %d m_bExitNow",pRecord->m_bExitNow);       //: Int 4B
    dprintf(" %p m_hThread",pRecord->m_hThread);        //: Ptr32 to Void
    dprintf(" %p m_hAttention\n",pRecord->m_hAttention);     //: Ptr32 to Void
    GetThreadInfo(pRecord->m_hThread,hSourceProcess);
    if (pRecord->m_pCurrentRequest)
    {
        //DumpCAsyncReq((CAsyncReq *)pRecord->m_pCurrentRequest);
        if (DumpRequest)
            DumpRequest((ULONG_PTR)pRecord->m_pCurrentRequest);
    }
}


DECLARE_API( q )
{

    INIT_API();

    ULONG_PTR Addr = GetExpression("wbemcore!g_pAsyncSvcQueue");
    if (Addr) 
    {
        CAsyncServiceQueue * pAsyncQueue = NULL;
        ReadMemory(Addr,&pAsyncQueue,sizeof(CAsyncServiceQueue *),0);

        DEFINE_CPP_VAR(CAsyncServiceQueue,MyAsyncServiceQueue);

        if (pAsyncQueue)
        {
            dprintf("CAsyncServiceQueue %p\n",pAsyncQueue);            
            ReadMemory((ULONG_PTR)pAsyncQueue,&MyAsyncServiceQueue,sizeof(CAsyncServiceQueue),NULL);
            pAsyncQueue = (CAsyncServiceQueue *)&MyAsyncServiceQueue;

        
            //m_aThreads       : CFlexArray
            dprintf("    elems %d pointer %p\n",pAsyncQueue->m_aThreads.m_nSize,pAsyncQueue->m_aThreads.m_pArray);

            CCoreQueue::CThreadRecord ** pRecord_OOP = (CCoreQueue::CThreadRecord **)_alloca(sizeof(void*)*pAsyncQueue->m_aThreads.m_nSize);
            ReadMemory((ULONG_PTR)pAsyncQueue->m_aThreads.m_pArray,pRecord_OOP,sizeof(void*)*pAsyncQueue->m_aThreads.m_nSize,0);

            DWORD i;
            for (i=0;i<pAsyncQueue->m_aThreads.m_nSize;i++)
            {
                dprintf("      -- CThreadRecord %p - %d\n",pRecord_OOP[i],i);
                DumpRecord((ULONG_PTR)pRecord_OOP[i],hCurrentProcess,DumpCAsyncReq);
            }

            dprintf("    m_pHead %p\n",pAsyncQueue->m_pHead);
            dprintf("    m_pTail %p\n",pAsyncQueue->m_pTail);
            // here code for the list
            CCoreExecReq * pReq = pAsyncQueue->m_pHead;
            i = 0;
            while (pReq)
            {
                dprintf(" ---- list - %d\n",i++);
                DEFINE_CPP_VAR(CCoreExecReq,MyAsyncReq);
                CCoreExecReq * pReqHERE = GET_CPP_VAR_PTR(CCoreExecReq,MyAsyncReq);
                ReadMemory((ULONG_PTR)pReq,pReqHERE,sizeof(CCoreExecReq),NULL);

                //dprintf("   %p %p\n",pReq,pReqHERE->m_pNext);
                DumpCAsyncReq((ULONG_PTR)pReq);

                if (pReq == pAsyncQueue->m_pTail)
                    break;
                
                pReq = pReqHERE->m_pNext;                

                if (CheckControlC())
                    break;                
            }
            //
   
            dprintf("    m_lNumThreads   %d \n",pAsyncQueue->m_lNumThreads);
            dprintf("    m_lNumIdle      %d\n",pAsyncQueue->m_lNumIdle);
            dprintf("    m_lNumRequests  %d\n",pAsyncQueue->m_lNumRequests);   
            dprintf("    m_lMaxThreads   %d\n",pAsyncQueue->m_lMaxThreads);    
            dprintf("    m_lHiPriBound      %d\n",pAsyncQueue->m_lHiPriBound);    
            dprintf("    m_lHiPriMaxThreads %d\n",pAsyncQueue->m_lHiPriMaxThreads); 
            dprintf("    m_lStartSlowdownCount  %d\n",pAsyncQueue->m_lStartSlowdownCount);
            dprintf("    m_lAbsoluteLimitCount  %d\n",pAsyncQueue->m_lAbsoluteLimitCount); 
            dprintf("    m_lOneSecondDelayCount %d\n",pAsyncQueue->m_lOneSecondDelayCount); 
            dprintf("    m_dblAlpha  %f\n",pAsyncQueue->m_dblAlpha);
            dprintf("    m_dblBeta   %f\n",pAsyncQueue->m_dblBeta);
            dprintf("    m_dwTimeout %x\n",pAsyncQueue->m_dwTimeout);
            // m_dwOverflowTimeout 
            // m_lChildPenalty  
            // m_lSiblingPenalty 
            // m_lPassingPenalty 
            
        }
    } 
    else 
    {
        dprintf("unable to resolve wbemcore!g_pAsyncSvcQueue");
    }
    
}

#include <wmiarbitrator.h>


void Dump_CWmiFinalizer()
{
    DWORD Val;
    ULONG_PTR pAddr;

    pAddr = GetExpression("wbemcore!s_Finalizer_ObjectCount");
    ReadMemory(pAddr,&Val,sizeof(DWORD),NULL);
    dprintf("  s_Finalizer_ObjectCount             = %d\n",Val);

    pAddr = GetExpression("wbemcore!s_FinalizerCallResult_ObjectCount");
    ReadMemory(pAddr,&Val,sizeof(DWORD),NULL);
    dprintf("  s_FinalizerCallResult_ObjectCount   = %d\n",Val);
    
    pAddr = GetExpression("wbemcore!s_FinalizerEnum_ObjectCount");
    ReadMemory(pAddr,&Val,sizeof(DWORD),NULL);
    dprintf("  s_FinalizerEnum_ObjectCount         = %d\n",Val);
    
    pAddr = GetExpression("wbemcore!s_FinalizerEnumSink_ObjectCount");
    ReadMemory(pAddr,&Val,sizeof(DWORD),NULL);
    dprintf("  s_FinalizerEnumSink_ObjectCount     = %d\n",Val);
    
    pAddr = GetExpression("wbemcore!s_FinalizerInBoundSink_ObjectCount");
    ReadMemory(pAddr,&Val,sizeof(DWORD),NULL);
    dprintf("  s_FinalizerInBoundSink_ObjectCount  = %d\n\n",Val);
}

void
DumpCProvSink(CProviderSink * pProvSink)
{
	dprintf("            Total Indicates = %d\n", pProvSink->m_lIndicateCount);
	WCHAR pString[MAX_PATH+1];
	pString[MAX_PATH] = 0;
	if (ReadMemory((ULONG_PTR)pProvSink->m_pszDebugInfo,pString,MAX_PATH*sizeof(WCHAR),NULL))
	{
	    dprintf("            Debug Info = %S\n",pString);
	}
    dprintf("            SetStatus called? %d\n", pProvSink->m_bDone);
    dprintf("            hRes = 0x%x\n", pProvSink->m_hRes);
    dprintf("            m_pNextSink = %p\n", pProvSink->m_pNextSink);
}

DECLARE_API( arb )
{

    INIT_API();

    ULONG_PTR Addr = GetExpression("wbemcore!CWmiArbitrator__m_pArb");
    if (Addr) 
    {
        DWORD Val;
        ULONG_PTR pAddr;        

        pAddr = GetExpression("wbemcore!g_nSinkCount");
        ReadMemory(pAddr,&Val,sizeof(DWORD),NULL);
        dprintf("Total sinks active     = %d\n",Val);
        
        pAddr = GetExpression("wbemcore!g_nStdSinkCount");
        ReadMemory(pAddr,&Val,sizeof(DWORD),NULL);
        dprintf("Total std sink objects = %d\n",Val);

        pAddr = GetExpression("wbemcore!g_nSynchronousSinkCount");
        ReadMemory(pAddr,&Val,sizeof(DWORD),NULL);
        dprintf("Total Sync sink objects = %d\n",Val);

        pAddr = GetExpression("wbemcore!g_nProviderSinkCount");
        ReadMemory(pAddr,&Val,sizeof(DWORD),NULL);
        dprintf("Total Prov sink objects = %d\n",Val);

        pAddr = GetExpression("wbemcore!g_lCoreThreads");
        ReadMemory(pAddr,&Val,sizeof(DWORD),NULL);
        dprintf("Total Core Threads = %d\n",Val);

        pAddr = GetExpression("fastprox!g_lDebugObjCount");
        ReadMemory(pAddr,&Val,sizeof(DWORD),NULL);
        dprintf("Total Obj-QualSets = %d\n",Val);
                
        Dump_CWmiFinalizer();
    
        CWmiArbitrator * pArbit_OOP = NULL;
        ReadMemory(Addr,&pArbit_OOP,sizeof(CWmiArbitrator *),0);

        DEFINE_CPP_VAR(CWmiArbitrator,MyWmiArbitrator);

        if (pArbit_OOP)
        {
            dprintf("CWmiArbitrator %p\n",pArbit_OOP);
            ReadMemory((ULONG_PTR)pArbit_OOP,&MyWmiArbitrator,sizeof(CWmiArbitrator),NULL);
            CWmiArbitrator * pArbit = (CWmiArbitrator *)&MyWmiArbitrator;

            dprintf("    m_lRefCount          %d\n",pArbit->m_lRefCount);
            dprintf("    m_uTotalTasks        %d\n",pArbit->m_uTotalTasks);
            dprintf("    m_uTotalPrimaryTasks %d\n",pArbit->m_uTotalPrimaryTasks);

            DWORD dwTot = pArbit->m_aTasks.m_nSize*sizeof(void*);
            void ** pMem = new void *[dwTot];
            DWORD i;

            dprintf("    m_aTasks P %p S %x\n",pArbit->m_aTasks.m_pArray,pArbit->m_aTasks.m_nSize);
            
            if (ReadMemory((ULONG_PTR)pArbit->m_aTasks.m_pArray,pMem,dwTot,0))
            {
	            for (i=0;i<pArbit->m_aTasks.m_nSize;i++)
	            {
	                dprintf("     - CWmiTask %d - %p\n",i,pMem[i]);
	                if (pMem[i])
	                {
	                    DumpCWmiTask((CWmiTask *)pMem[i]);
	                }
	                else
	                {
	                    dprintf("      <NULL>\n");
	                }
	            }
            }
            else
            {
                dprintf("RM %p\n",pArbit->m_aTasks.m_pArray);
            }
            delete [] pMem;

            //m_aNamespaces
            DWORD dwTot2 = pArbit->m_aNamespaces.m_nSize*sizeof(void*);
            void ** pMem2 = new void *[dwTot2];

            dprintf("    m_aNamespaces P %p S %x\n",pArbit->m_aNamespaces.m_pArray,pArbit->m_aNamespaces.m_nSize);
            if (ReadMemory((ULONG_PTR)pArbit->m_aNamespaces.m_pArray,pMem2,dwTot2,0))
            {
	            for (i=0;i<pArbit->m_aNamespaces.m_nSize;i++)
	            {
	                dprintf("     - CWbemNamespace %d - %p\n",i,pMem2[i]);
	                if (pMem2[i])
	                {
	                    DumpCWbemNamespace((CWbemNamespace *)pMem2[i]);
	                }
	            }
            }
            else
            {
                dprintf("RM %p\n",pArbit->m_aNamespaces.m_pArray);
            }
            delete [] pMem2;
            

        }

        //g_aProviderSinks
        DEFINE_CPP_VAR(CFlexArray,varCFlexArray);
        CFlexArray * pFlexArray = GET_CPP_VAR_PTR(CFlexArray,varCFlexArray);

        Addr = GetExpression("wbemcore!g_aProviderSinks");
        if (Addr)
        {
            if (ReadMemory(Addr,pFlexArray,sizeof(CFlexArray),NULL))
            {
                VOID ** ppPointers = (VOID **)_alloca(pFlexArray->m_nSize*sizeof(void *));
                if (ReadMemory((ULONG_PTR)pFlexArray->m_pArray,ppPointers,pFlexArray->m_nSize*sizeof(void *),NULL))
                {
                    for(DWORD i =0 ;i<pFlexArray->m_nSize;i++)
                    {
                        
                        dprintf("    - CProviderSink %d - %p\n",i,ppPointers[i]);
                        GetVTable((MEMORY_ADDRESS)ppPointers[i]);

                        DEFINE_CPP_VAR(CProviderSink,varCProviderSink);
                        CProviderSink * pProvSink = GET_CPP_VAR_PTR(CProviderSink,varCProviderSink);
                        if (ppPointers[i] && ReadMemory((ULONG_PTR)ppPointers[i],pProvSink,sizeof(CProviderSink),NULL))
                        {
                            DumpCProvSink(pProvSink);
                        }
                        else
                        {
                            dprintf("RM %p\n",ppPointers[i]);
                        }
                    }
                }
            }
        }
    
    }
    else
    {
        dprintf("unable to resolve wbemcore!CWmiArbitrator__m_pArb\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmiexts\dumpwc.cpp ===
#include <wmiexts.h>

#include <oleauto.h>

#ifndef COREPROX_POLARITY
#define COREPROX_POLARITY
#endif

#include <arena.h>
#include <faster.h>
#include <faststr.h>
#include <wbemint.h>
#include <fastcls.h>
#include <var.h>
#include <fastinst.h>
#include <wbemdatapacket.h>

//#include <smartnextpacket.h>

#pragma pack( push )
#pragma pack( 1 )

// IWbemWCOSmartEnum::Next() Header.  Changing this will
// cause the main version to change
typedef struct tagWBEM_DATAPACKET_SMARTENUM_NEXT
{
	DWORD	dwSizeOfHeader;	// Size of the header struct.  Data immediately follows header.
	DWORD	dwDataSize;		// Size of Data following header.
} WBEM_DATAPACKET_SMARTENUM_NEXT;

typedef WBEM_DATAPACKET_SMARTENUM_NEXT* PWBEM_DATAPACKET_SMARTENUM_NEXT;

// restore packing
#pragma pack( pop )


//#include <objarraypacket.h>

#pragma pack( push )
#pragma pack( 1 )

// IWbemClassObject Array Header.  Changing this will
// cause the main version to change
typedef struct tagWBEM_DATAPACKET_OBJECT_ARRAY
{
	DWORD	dwSizeOfHeader;	// Size of the header struct.  Data immediately follows header.
	DWORD	dwDataSize;		// Size of Data following header.
	DWORD	dwNumObjects;	// Number of objects in the array
} WBEM_DATAPACKET_OBJECT_ARRAY;

typedef WBEM_DATAPACKET_OBJECT_ARRAY* PWBEM_DATAPACKET_OBJECT_ARRAY;

// restore packing
#pragma pack( pop )


#pragma pack( push )
#pragma pack( 1 )

// IWbemObjectSink::Indicate() Header.  Changing this will
// cause the main version to change
typedef struct tagWBEM_DATAPACKET_OBJECTSINK_INDICATE
{
	DWORD	dwSizeOfHeader;	// Size of the header struct.  Data immediately follows header.
	DWORD	dwDataSize;		// Size of Data following header.
} WBEM_DATAPACKET_OBJECTSINK_INDICATE;

typedef WBEM_DATAPACKET_OBJECTSINK_INDICATE* PWBEM_DATAPACKET_OBJECTSINK_INDICATE;

// restore packing
#pragma pack( pop )

#pragma pack( push )
#pragma pack( 1 )

// IWbemObjectSink::Indicate() Header.  Changing this will
// cause the main version to change
typedef struct tagWBEM_DATAPACKET_UNBOUNDSINK_INDICATE
{
	DWORD	dwSizeOfHeader;	// Size of the header struct.  Data immediately follows header.
	DWORD	dwDataSize;		// Size of Data following header.
	DWORD	dwLogicalConsumerSize;	// Size of Logical Consumer Object
} WBEM_DATAPACKET_UNBOUNDSINK_INDICATE;

#ifdef _WIN64
typedef UNALIGNED WBEM_DATAPACKET_UNBOUNDSINK_INDICATE * PWBEM_DATAPACKET_UNBOUNDSINK_INDICATE;
#else
typedef WBEM_DATAPACKET_UNBOUNDSINK_INDICATE * PWBEM_DATAPACKET_UNBOUNDSINK_INDICATE;
#endif

// restore packing
#pragma pack( pop )



#include <wbemobjpacket.h>

#include <malloc.h>

#ifndef HEAP_ENTRY

typedef struct _HEAP_ENTRY 
{
    USHORT Size;
    USHORT PreviousSize;
    UCHAR SegmentIndex;
    UCHAR Flags;
    UCHAR UnusedBytes;
    UCHAR SmallTagIndex;
#if defined(_WIN64)
    ULONGLONG Reserved1;
#endif

} HEAP_ENTRY, *PHEAP_ENTRY;

#endif

void GetCompressedString(ULONG_PTR pRemoteAddr,
                         BYTE  * pBuff,
                         DWORD Size){

    if (pRemoteAddr) {
                         
        CCompressedString * pCS = (CCompressedString *)_alloca(Size*2);   
        ReadMemory(pRemoteAddr,pCS,Size*2,0);

        pBuff[Size-2]=0;
        pBuff[Size-1]=0;
        if (pCS->m_fFlags == STRING_FLAG_UNICODE){
           WideCharToMultiByte(CP_ACP,0,(WCHAR *)&(pCS->m_cFirstByte),-1,(LPSTR)pBuff,Size-2,NULL,NULL);
        } else {
            memcpy(pBuff,&(pCS->m_cFirstByte),Size-2);
        }
    } else {
        lstrcpyA((LPSTR)pBuff,"<NULL>");
    }

}

/*
protected:
    length_t m_nTotalLength;
    //CDecorationPart m_DecorationPart;
    CClassAndMethods m_ParentPart;
    CClassAndMethods m_CombinedPart;

    int m_nCurrentMethod;
	CLimitationMapping*	m_pLimitMapping;
    friend class CWbemInstance;

*/

/*
    CClassPart m_ClassPart;
    CMethodPart m_MethodPart;
    CWbemClass* m_pClass;
*/


void
DumpClass(CClassPart * pCls){

    BYTE pBuff[256];

    dprintf("     m_pContainer %p m_pParent %p m_pHeader %p\n",pCls->m_pContainer,pCls->m_pParent,pCls->m_pHeader);
    
    DEFINE_CPP_VAR(CClassPart::CClassPartHeader,varHeader);
    CClassPart::CClassPartHeader * pHeader = GET_CPP_VAR_PTR( CClassPart::CClassPartHeader , varHeader );

    if (pCls->m_pHeader){
        ReadMemory((ULONG_PTR)pCls->m_pHeader,pHeader,sizeof(CClassPart::CClassPartHeader),0);

        dprintf("      nLength %x fFlags %02x ptrClassName %08x nDataLength %x\n",pHeader->nLength,pHeader->fFlags,pHeader->ptrClassName,pHeader->nDataLength);
    }

    dprintf("   DL m_nNumStrings %x %08x\n",pCls->m_Derivation.m_nNumStrings,pCls->m_Derivation.m_pnLength);

    dprintf("   QS m_nLength %x m_pOthers %08x m_pHeap %08x\n",pCls->m_Qualifiers.m_nLength,pCls->m_Qualifiers.m_pOthers,pCls->m_Qualifiers.m_pHeap);

    DEFINE_CPP_VAR(CFastHeap,varCFastHeap);
    CFastHeap * pFHeap = GET_CPP_VAR_PTR( CFastHeap , varCFastHeap );
    ReadMemory((ULONG_PTR)pCls->m_Qualifiers.m_pHeap,pFHeap,sizeof(CFastHeap),0);
    dprintf("      FH  m_pHeapData %08x m_pHeapHeader %08x m_pContainer %08x\n",pFHeap->m_pHeapData,pFHeap->m_pHeapHeader,pFHeap->m_pContainer);
    
    dprintf("      m_nPropagationFlag %x m_nRef %x\n",pCls->m_Qualifiers.m_nPropagationFlag,pCls->m_Qualifiers.m_nRef);
    dprintf("      m_pControl %08x m_pContainer %08x m_pSecondarySet %08x\n",pCls->m_Qualifiers.m_pControl,pCls->m_Qualifiers.m_pContainer,pCls->m_Qualifiers.m_pSecondarySet);

    dprintf("      BA m_nSize %x m_astrStrings %08x\n",pCls->m_Qualifiers.m_astrCurrentNames.m_nSize,pCls->m_Qualifiers.m_astrCurrentNames.m_astrStrings);

    int nProp;
    if (pCls->m_Properties.m_pnProps) {

        ReadMemory((ULONG_PTR)pCls->m_Properties.m_pnProps,&nProp,sizeof(int),0);
        dprintf("   PR m_pnProps %08x %x m_pContainer %08x\n",pCls->m_Properties.m_pnProps,nProp,pCls->m_Properties.m_pContainer);

        CPropertyLookup * pPropLook = (CPropertyLookup *)_alloca(nProp*sizeof(CPropertyLookup));
        ReadMemory((ULONG_PTR)pCls->m_Properties.m_pnProps+sizeof(int),pPropLook,nProp*sizeof(CPropertyLookup),0);

        DWORD i;
        for (i=0;i<nProp;i++){

            pBuff[0]=0;
            if ((ULONG_PTR)(pCls->m_Heap.m_pHeapData+pPropLook[i].ptrName) != 0xffffffff){
                GetCompressedString((ULONG_PTR)(pCls->m_Heap.m_pHeapData+pPropLook[i].ptrName),pBuff,sizeof(pBuff));
            }

            DEFINE_CPP_VAR(CPropertyInformation,varCPropertyInformation);
            CPropertyInformation * pPropInfo = GET_CPP_VAR_PTR( CPropertyInformation , varCPropertyInformation );
            ReadMemory((ULONG_PTR)pCls->m_Heap.m_pHeapData+pPropLook[i].ptrInformation,pPropInfo ,sizeof(CPropertyInformation),0);


            dprintf("        prop %d %s Type %08x DataIdx %04x DataOff %08x Origin %08x\n",i,
                                          pBuff,
                                          pPropInfo->nType,
                                          pPropInfo->nDataIndex,
                                          pPropInfo->nDataOffset,
                                          pPropInfo->nOrigin);
            if (CheckControlC())
                break;
        }

    } else {
        dprintf("   PR m_pnProps %08x m_pContainer %08x\n",pCls->m_Properties.m_pnProps,pCls->m_Properties.m_pContainer);
    }    

    CDataTable * pCData = &pCls->m_Defaults;
    dprintf("   DT m_pNullness %08x m_pData %08x m_nLength %x m_nProps %x m_pContainer %08x\n",pCData->m_pNullness,pCData->m_pData,pCData->m_nLength,pCData->m_nProps,pCData->m_pContainer);

    dprintf("   FH m_pHeapData %08x m_pHeapHeader %08x m_pContainer %08x\n",pCls->m_Heap.m_pHeapData,pCls->m_Heap.m_pHeapHeader,pCls->m_Heap.m_pContainer);
    //CHeapHeader m_LocalHeapHeader;
    
    BYTE * pHeap = pCls->m_Heap.m_pHeapData;
    pBuff[0]=0;
    if ((DWORD)(pHeader->ptrClassName) != 0xffffffff){
        GetCompressedString((ULONG_PTR)(pHeap+pHeader->ptrClassName),pBuff,sizeof(pBuff));
    }
    dprintf("      __RELPATH %s\n",pBuff);
    

}

DECLARE_API(wc) {

    INIT_API();

    DEFINE_CPP_VAR( CWbemClass, varCWbemClass);
    CWbemClass * pCls = GET_CPP_VAR_PTR( CWbemClass , varCWbemClass );
    
    ULONG_PTR pByte = 0;
    pByte = GetExpression(args);
    
    if (pByte){
        ReadMemory(pByte,pCls,sizeof(CWbemClass),0);

        dprintf(" m_nRef %d m_bOwnMemory %d\n",pCls->m_nRef,pCls->m_bOwnMemory);
        dprintf(" m_nCurrentProp %08x m_lEnumFlags %08x m_lExtEnumFlags %08x\n",pCls->m_nCurrentProp,pCls->m_lEnumFlags,pCls->m_lExtEnumFlags);
        dprintf(" m_dwInternalStatus %08x m_pMergedClassObject %08x\n",pCls->m_dwInternalStatus,pCls->m_pMergedClassObject);
        
        BYTE * pData = pCls->m_DecorationPart.m_pfFlags;
        BYTE pBuff1[256];
        GetCompressedString((ULONG_PTR)pCls->m_DecorationPart.m_pcsServer,pBuff1,sizeof(pBuff1));
        BYTE pBuff2[256];
        GetCompressedString((ULONG_PTR)pCls->m_DecorationPart.m_pcsNamespace,pBuff2,sizeof(pBuff2));

        BYTE b=0xff;
        if (pData){
            ReadMemory((ULONG_PTR)pData,&b,sizeof(b),0);
        }
        dprintf("  m_DecorationPart.m_pfFlags %p FLAG %02x\n",pData,b);
        dprintf("  Server: %s Namespace: %s\n",pBuff1,pBuff2);

        dprintf("  m_LockData: m_lLock %d m_lLockCount %d m_dwThreadId %x\n",pCls->m_LockData.m_lLock,pCls->m_LockData.m_lLockCount,pCls->m_LockData.m_dwThreadId);

        dprintf("  m_Lock.m_pData %p\n",pCls->m_Lock.m_pData);

        //dprintf("  m_pBlobControl %08x m_refDataTable %08x m_refDataHeap %08x m_refDerivationList %08x\n",pCls->m_pBlobControl,((void *)&pCls->m_refDataTable),((void *)&pCls->m_refDataHeap),((void *)&pCls->m_refDerivationList));
        dprintf("  m_pBlobControl %p\n",pCls->m_pBlobControl);

        DEFINE_CPP_VAR( CDataTable,varCDataTable);
        CDataTable * pCData = GET_CPP_VAR_PTR(CDataTable,varCDataTable);
        if(pCData){
            ReadMemory((ULONG_PTR)(&(pCls->m_refDataTable)),pCData,sizeof(CDataTable),0);
            dprintf("     m_pNullness %p m_pData %p m_nLength %x m_nProps %x m_pContainer %08x\n",pCData->m_pNullness,pCData->m_pData,pCData->m_nLength,pCData->m_nProps,pCData->m_pContainer);
        }

        DEFINE_CPP_VAR(CFastHeap,varCFastHeap);
        CFastHeap * pFHeap = GET_CPP_VAR_PTR( CFastHeap , varCFastHeap );
        DWORD * pFoo = (DWORD *)&(pCls->m_refDataHeap);
        ReadMemory((ULONG_PTR )pFoo,pFHeap,sizeof(CFastHeap),0);
        dprintf("  FH m_pHeapData %p m_pHeapHeader %p m_pContainer %p\n",pFHeap->m_pHeapData,pFHeap->m_pHeapHeader,pFHeap->m_pContainer);
        
        dprintf("  m_nTotalLength %x\n",pCls->m_nTotalLength);

        dprintf("  m_ParentPart at offset %x\n",(ULONG_PTR)&pCls->m_ParentPart-(ULONG_PTR)pCls);
        dprintf("  m_ParentPart.m_pClassPart at offset %x\n",(ULONG_PTR)&(pCls->m_ParentPart.m_ClassPart)-(ULONG_PTR)pCls);


        DumpClass(&(pCls->m_ParentPart.m_ClassPart));

        dprintf("  m_CombinedPart at offset %x\n",(ULONG_PTR)&pCls->m_CombinedPart-(ULONG_PTR)pCls);

        DumpClass(&(pCls->m_CombinedPart.m_ClassPart));

        dprintf("  m_pClass %08x\n",pCls->m_ParentPart.m_pClass);
        
    } else {
        dprintf("invalid address %s\n",args);
    }

}

void
DumpInstance(CInstancePart * pIns){

    BYTE pBuff[256];
    dprintf("     m_pContainer %08x m_pHeader %08x\n",pIns->m_pContainer,pIns->m_pHeader);

    dprintf("  DT m_DataTable m_pNullness %08x m_pData %08x\n",pIns->m_DataTable.m_pNullness,pIns->m_DataTable.m_pData);
    dprintf("     m_nLength %x m_nProps %x m_pContainer %08x\n",pIns->m_DataTable.m_nLength,pIns->m_DataTable.m_nProps,pIns->m_DataTable.m_pContainer);

    dprintf("  Q  m_Qualifiers m_nPropagationFlag %08x m_nRef %x m_pControl %08x\n",pIns->m_Qualifiers.m_nPropagationFlag,pIns->m_Qualifiers.m_nRef,pIns->m_Qualifiers.m_pControl);
    dprintf("     m_pContainer %08x m_pSecondarySet %08x\n",pIns->m_Qualifiers.m_pContainer,pIns->m_Qualifiers.m_pSecondarySet);
    CFixedBSTRArray * pArr = &(pIns->m_Qualifiers.m_astrCurrentNames);
    dprintf("     m_nCurrentIndex %x\n",pIns->m_Qualifiers.m_nCurrentIndex);



    DEFINE_CPP_VAR(CInstancePart::CInstancePartHeader,varHeader);
    CInstancePart::CInstancePartHeader * pHeader = GET_CPP_VAR_PTR( CInstancePart::CInstancePartHeader , varHeader );

    if (pIns->m_pHeader){
        ReadMemory((ULONG_PTR)pIns->m_pHeader,pHeader,sizeof(CInstancePart::CInstancePartHeader),0);

        dprintf("     nLength %x fFlags %02x ptrClassName %08x \n",pHeader->nLength,pHeader->fFlags,pHeader->ptrClassName);
    }

    dprintf("  FH m_pHeapData %08x m_pHeapHeader %08x m_pContainer %08x\n",pIns->m_Heap.m_pHeapData,pIns->m_Heap.m_pHeapHeader,pIns->m_Heap.m_pContainer);
    
}


DECLARE_API(wi) {

    INIT_API();

    DEFINE_CPP_VAR( CWbemInstance, varCWbemInstance);
    CWbemInstance * pCls = GET_CPP_VAR_PTR( CWbemInstance , varCWbemInstance );
    
    ULONG_PTR pByte = 0;
    pByte = GetExpression(args);
    
    if (pByte){
        ReadMemory(pByte,pCls,sizeof(CWbemInstance),0);

        //length_t m_nTotalLength;
        //dprintf("    m_nTotalLength %08x\n",pCls->m_nTotalLength);

        BYTE * pData = pCls->m_DecorationPart.m_pfFlags;
        BYTE pBuff1[256];
        GetCompressedString((ULONG_PTR)pCls->m_DecorationPart.m_pcsServer,pBuff1,sizeof(pBuff1));
        BYTE pBuff2[256];
        GetCompressedString((ULONG_PTR)pCls->m_DecorationPart.m_pcsNamespace,pBuff2,sizeof(pBuff2));

        BYTE b=0xff;
        if (pData){
            ReadMemory((ULONG_PTR)pData,&b,sizeof(b),0);
        }
        dprintf("  m_DecorationPart.m_pfFlags %p FLAG %02x\n",pData,b);
        dprintf("  Server: %s Namespace: %s\n",pBuff1,pBuff2);

        //CClassPart m_ClassPart;
        DumpClass(&(pCls->m_ClassPart));

        //CInstancePart m_InstancePart;
        DumpInstance(&(pCls->m_InstancePart));
        

        //CVar m_CachedKey;
        dprintf("    m_vt %08x m_value %08x m_nStatus %08x m_bCanDelete %08x\n",pCls->m_CachedKey.m_vt,pCls->m_CachedKey.m_value.pUnk,pCls->m_CachedKey.m_nStatus,pCls->m_CachedKey.m_bCanDelete);

    } else {
        dprintf("invalid address %s\n",args);
    }
}


DECLARE_API(cp) {

    INIT_API();

    DEFINE_CPP_VAR( CClassPart, varCClassPart);
    CClassPart * pCls = GET_CPP_VAR_PTR( CClassPart , varCClassPart );
    
    ULONG_PTR pByte = 0;
    pByte = GetExpression(args);
    
    if (pByte){
        ReadMemory(pByte,pCls,sizeof(CClassPart),0);

        DumpClass(pCls);
                
    } else {
        dprintf("invalid address %s\n",args);
    }

}

/*
typedef union
{
    char     cVal;          // VT_I1
    BYTE     bVal;          // VT_UI1
    SHORT    iVal;          // VT_I2
    WORD     wVal;          // VT_UI2
    LONG     lVal;          // VT_I4
    DWORD    dwVal;         // VT_UI4
    VARIANT_BOOL boolVal;   // VT_BOOL    

    float    fltVal;        // VT_R4
    double   dblVal;        // VT_R8

    LPSTR    pStr;          // VT_LPSTR
    LPWSTR   pWStr;         // VT_LPWSTR
    BSTR     Str;           // VT_BSTR      (stored as VT_LPWSTR)
    
    FILETIME Time;          // VT_FILETIME
    BLOB   Blob;            // VT_BLOB        
    LPCLSID  pClsId;        // VT_CLSID
    IUnknown* pUnk;         // VT_UNKNOWN
    IDispatch* pDisp;       // VT_DISPATCH
    CVarVector *pVarVector; // VT_EX_CVARVECTOR
        
}   METAVALUE;

    int m_vt;
    METAVALUE m_value;
    int m_nStatus;    
    BOOL m_bCanDelete;


*/

DECLARE_API(cvar) {

    INIT_API();

    DEFINE_CPP_VAR( CVar, varCVar);
    CVar * pVar = GET_CPP_VAR_PTR( CVar , varCVar );
    
    WCHAR pwBuff[128];
    CHAR  pBuff[128];
    
    ULONG_PTR pByte = 0;
    pByte = GetExpression(args);
    
    if (pByte){
        ReadMemory(pByte,pVar,sizeof(CVar),0);

        switch(pVar->m_vt){
        case VT_I1:
            dprintf("VT_I1 %02x\n",pVar->m_value.cVal);
            break;
        case VT_UI1:
            dprintf("VT_UI1 %02x\n",pVar->m_value.bVal);
            break;

        case VT_I2:
            dprintf("VT_I2 %04x\n",pVar->m_value.iVal);
            break;

        case VT_UI2:
            dprintf("VT_UI2 %04x\n",pVar->m_value.wVal);
            break;

        case VT_I4:
            dprintf("VT_I4 %08x\n",pVar->m_value.lVal);
            break;

        case VT_UI4:
            dprintf("VT_UI4 %08x\n",pVar->m_value.dwVal);
            break;
            
        case VT_BOOL:
            dprintf("VT_BOOL  %04x\n",pVar->m_value.boolVal);
            break;

        case VT_R4:
            dprintf("VT_R4 %f\n",pVar->m_value.fltVal);
            break;
            
        case VT_R8:
            dprintf("VT_R8 %e\n",pVar->m_value.dblVal);
            break;
    
        case VT_LPSTR:
            ReadMemory((ULONG_PTR)pVar->m_value.pStr,pBuff,sizeof(pBuff),0);
            pBuff[sizeof(pBuff)-1]=0;
            dprintf("VT_LPSTR %s\n",pBuff);
            break;
            
        case VT_LPWSTR:
        case VT_BSTR:
            ReadMemory((ULONG_PTR)pVar->m_value.pWStr,pwBuff,sizeof(pwBuff),0);
            pwBuff[sizeof(pwBuff)-1]=0;
            WideCharToMultiByte(CP_ACP,0,pwBuff,-1,pBuff,sizeof(pBuff),NULL,NULL);
            pBuff[sizeof(pBuff)-1]=0;
            dprintf("VT_BSTR %s\n",pBuff);
            break;
/*
    
    FILETIME Time;          // VT_FILETIME
    BLOB   Blob;            // VT_BLOB        
    LPCLSID  pClsId;        // VT_CLSID
    IUnknown* pUnk;         // VT_UNKNOWN
    IDispatch* pDisp;       // VT_DISPATCH
  */    
        case VT_EX_CVARVECTOR:
        //CVarVector *pVarVector; // VT_EX_CVARVECTOR
            dprintf("VT_EX_CVARVECTOR %08x\n",pVar->m_value.pVarVector);
            break;
        default:
            dprintf("m_vt %08x\n",pVar->m_vt);
        }
        
    } else {
        dprintf("invalid address %s\n",args);
    }

}

/*
class POLARITY CVarVector
{
    int         m_nType;
    CFlexArray  m_Array;
    int         m_nStatus;
*/



LPSTR g_QualStrings[] = {
    "", // nothing for index 0
    "key", 
    "",
    "read", 
    "write",
    "volatile",
    "provider",
    "dynamic",
    "cimwin32",
    "DWORD",
    "CIMTYPE"
};

DWORD g_ValLengths[128] =
{
    /* 0*/ 0, 0, 2, 4, 4, 8, 0, 0, 4, 0,
    /*10*/ 0, 2, 0, 4, 0, 0, 1, 1, 2, 4,
    /*20*/ 8, 8, 0, 0, 0, 0, 0, 0, 0, 0,
    /*30*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /*40*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /*50*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /*60*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /*70*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /*80*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /*90*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /*100*/0, 4, 4, 2, 0, 0, 0, 0, 0, 0,
    /*110*/0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /*120*/0, 0, 0, 0, 0, 0, 0, 0
};

int lstrlenWunal( WCHAR UNALIGNED * pStr)
{
    int ret = 0;
    while (*pStr++) ret++;
    return ret;
};

VOID
ParseBlob(BYTE * pMemOrg,ULONG_PTR Addr)
{
    DWORD ClassPartLength = 0;
    DWORD i;
    BYTE * pMem = pMemOrg;
    BYTE Flags;
    BOOL IsInstance = FALSE;    
    BOOL SkipDecoration = TRUE;

    BYTE BFlags = *pMem;
    pMem++;
    if (WBEM_GENUS_CLASS & BFlags )
    {
        dprintf("CLASS\n");
    }
    if (WBEM_GENUS_INSTANCE & BFlags )
    {
        dprintf("INSTANCE\n");
        IsInstance = TRUE;
    }
    if (OBJECT_FLAG_LIMITED & BFlags)
    {
        dprintf("LIMITED\n");
    }
    if (OBJECT_FLAG_CLIENT_ONLY & BFlags)
    {
        dprintf("CLIENT_ONLY\n");
    }
    
    if (BFlags & OBJECT_FLAG_DECORATED)
    {
        SkipDecoration = FALSE;
        //dprintf("decoration:\n");
        Flags = *pMem;
        pMem++;
        if (Flags == STRING_FLAG_UNICODE)
        {
            dprintf("SERVER   : %S\n",pMem);
            pMem+=(1+2*lstrlenWunal((WCHAR UNALIGNED *)pMem));
        }
        else
        {
            dprintf("SERVER   : %s\n",pMem);        
            pMem+=(1+lstrlenA((CHAR *)pMem));            
        }
        Flags = *pMem;
        pMem++;
        if (Flags == STRING_FLAG_UNICODE)
        {
            dprintf("namespace: %S\n",pMem);
            pMem+=(1+2*lstrlenWunal((WCHAR UNALIGNED *)pMem));
        }
        else
        {
            dprintf("NAMESPACE: %s\n",pMem);        
            pMem+=(1+lstrlenA((CHAR *)pMem));            
        }
    };

    ClassPartLength = *((DWORD UNALIGNED *)pMem);
    pMem += sizeof(DWORD);
    
    BYTE Unused = *pMem;
    pMem++;

    DWORD HeapPtrName = *((DWORD UNALIGNED *)pMem);
    pMem += sizeof(DWORD);

    DWORD NullDefaultSize = *((DWORD UNALIGNED *)pMem);
    pMem += sizeof(DWORD);

    DWORD DerivationSize = *((DWORD UNALIGNED *)pMem);
    DerivationSize &= 0xFFFF;

    //dprintf("D %08x\n",DerivationSize);
    
    DWORD QualSetSize    = *((DWORD UNALIGNED *)(pMem+DerivationSize));
    //dprintf("Q %08x\n",QualSetSize);
    QualSetSize &= 0xFFFF;
    DWORD NumProps       = *((DWORD UNALIGNED *)(pMem+DerivationSize+QualSetSize));
    
    DWORD UNALIGNED * pPropLookup  = (DWORD UNALIGNED *)(pMem+DerivationSize+QualSetSize+sizeof(DWORD));
    BYTE * pPropLookup_OOP = (BYTE *)Addr + (pMem - pMemOrg) + DerivationSize+QualSetSize;
    BYTE * HeapPtr = pMem + DerivationSize + QualSetSize + sizeof(DWORD) + NumProps*(2*sizeof(DWORD)) + NullDefaultSize;
    BYTE * HeapPtr_OOP = (BYTE *)Addr + (pMem - pMemOrg) + DerivationSize + QualSetSize + sizeof(DWORD) + NumProps*(2*sizeof(DWORD)) + NullDefaultSize;

    //dprintf("CPLen %p N %p D %p Q %p Prop %p Heap %p\n",
    //       ClassPartLength,
    //       NullDefaultSize,
    //       DerivationSize,QualSetSize,NumProps,*((DWORD UNALIGNED *)HeapPtr));

    dprintf("    class_and_method\n");

    dprintf("      class_Part\n");

    if (0xFFFFFFFF != HeapPtrName)
    {
        BYTE * pName = HeapPtr + sizeof(DWORD) + HeapPtrName;
        Flags = *pName;
        pName++;
        if (Flags == STRING_FLAG_UNICODE)
        {
            dprintf("        class   : %S\n",pName);
        }
        else
        {
            dprintf("        class   : %s\n",pName);        
        }        
    }
    else
    {
        dprintf("        class   : %08x\n",HeapPtrName);
    }
    // QualSet
    dprintf("        qualifierset %p\n",Addr+(pMem + DerivationSize - pMemOrg));
    ULONG_PTR pEndQualSet = (ULONG_PTR)pMem + DerivationSize + QualSetSize;
    BYTE * pQualSet = pMem + DerivationSize + sizeof(DWORD);

    //dprintf(" %p %p\n",pQualSet,pEndQualSet);
    while((ULONG_PTR)pQualSet < pEndQualSet)
    {
        DWORD dwHeapPtr = (*((DWORD UNALIGNED *)pQualSet));
        pQualSet += sizeof(DWORD);
        BYTE Flavor = *pQualSet;
        pQualSet += sizeof(BYTE);
        DWORD Type = (*((DWORD UNALIGNED *)pQualSet));
        pQualSet += sizeof(DWORD);
        BYTE * pData = pQualSet;
        pQualSet += g_ValLengths[Type&0x7F];

        if (dwHeapPtr & 0x80000000)
        {
            dprintf("            %s %02x %08x %p\n",g_QualStrings[dwHeapPtr&0x7fffffff],Flavor,Type,*(DWORD UNALIGNED *)pData);
        }
        else
        {
            dprintf("            %s %02x %08x %p\n",HeapPtr+dwHeapPtr+1+sizeof(DWORD),Flavor,Type,*(DWORD UNALIGNED *)pData);        
        }

        if (CheckControlC())
            break;
    }
    // property lookup table
    dprintf("        propertylookup %p\n",pPropLookup_OOP);
    for (i=0;i<NumProps;i++)
    {
        WORD UNALIGNED * pPropInfo = (WORD UNALIGNED *)(HeapPtr+sizeof(DWORD)+pPropLookup[1]);
        dprintf("            %08x %08x %s %08x %04x %08x %08x\n",
                 pPropLookup[0],pPropLookup[1],
                 HeapPtr+pPropLookup[0]+1+sizeof(DWORD),
                 *((DWORD UNALIGNED *)pPropInfo),
                 *(pPropInfo+2),
                 *(DWORD UNALIGNED *)(pPropInfo+3),
                 *(DWORD UNALIGNED *)(pPropInfo+5));
        pPropLookup += 2;
    }
    DWORD dwHeapSize_ClassPart = (*((DWORD UNALIGNED *)HeapPtr))&0x7FFFFFFF;
    dprintf("        Heap %p size %08x\n",HeapPtr_OOP,dwHeapSize_ClassPart);

    dprintf("      method_Part\n");
    BYTE * pMethodPart = HeapPtr + sizeof(DWORD) + dwHeapSize_ClassPart;
    BYTE * pMethodPart_OOP = HeapPtr_OOP + sizeof(DWORD) + dwHeapSize_ClassPart;

    DWORD dwSizeMethodPart = *((DWORD UNALIGNED *)pMethodPart);
    DWORD NumMethods = *((DWORD UNALIGNED *)(pMethodPart+sizeof(DWORD)));
    BYTE * pMethodDescription= pMethodPart + 2*sizeof(DWORD);
    BYTE * pMethodDescription_OOP = pMethodPart_OOP + 2*sizeof(DWORD);

    //BYTE * pHeapMethod_OOP = ;
    dprintf("        num_methods   : %08x\n",NumMethods);
    dprintf("        methods_descr : %p\n",pMethodDescription_OOP);
    //dprintf("        heap          : %p\n");

    BYTE * pCombinedPart = pMethodPart + dwSizeMethodPart;
    BYTE * pCombinedPart_OOP = pMethodPart_OOP + dwSizeMethodPart;

        if (IsInstance)
        {
            dprintf("    instance\n");

            DWORD dwHeapSize = 4 + (*((DWORD UNALIGNED *)HeapPtr)) & 0x7fffffff;
            //BYTE * HeapPtr_OOP 
            BYTE * pInstancePart = HeapPtr+dwHeapSize;
            BYTE * pInstancePart_OOP = HeapPtr_OOP+dwHeapSize;

            DWORD dwSize = *((DWORD UNALIGNED *)pInstancePart);
            pInstancePart += sizeof(DWORD);
            BYTE IFlag = *pInstancePart;
            pInstancePart++;
            DWORD dwClassNameOffset = *((DWORD UNALIGNED *)pInstancePart);
            pInstancePart += sizeof(DWORD);

            BYTE * pDataTable = pInstancePart;
            BYTE * pDataTable_OOP = pInstancePart_OOP + 2*sizeof(DWORD) + sizeof(BYTE);

            DWORD NumBytedNullNess = ((NumProps*2)%8)?(1+((NumProps*2)/8)):((NumProps*2)/8);
            BYTE * pDataTableData = pInstancePart + NumBytedNullNess;
            BYTE * pDataTableData_OOP = pDataTable_OOP + NumBytedNullNess;

            pInstancePart += NullDefaultSize; // this is crucial

            BYTE * pQualSet     = pInstancePart;
            BYTE * pQualSet_OOP = pDataTable_OOP + NullDefaultSize;
            DWORD  dwQualSetSize = *((DWORD UNALIGNED *)pQualSet);
            pInstancePart += dwQualSetSize;
            
            BYTE * pQualSetList = pInstancePart;
            BYTE * pInstanceHeap;
            BYTE * pInstanceHeap_OOP;
            if (0x01 == *pQualSetList)
            {
                // empty qual set OK
                pInstancePart++;
                pInstanceHeap = pInstancePart;
                pInstanceHeap_OOP = pQualSet_OOP+dwQualSetSize+sizeof(BYTE);
            } 
            else if (0x02 == *pQualSetList)
            {
                // multiple qualifier set 
                dprintf("unimplemented");
                return;
            }
            else
            {
                // invalid qualset
            }
            

            //NullDefaultSize

            dprintf("        begin            %p\n",pInstancePart_OOP);
            dprintf("        data_table: null %p data %p\n",pDataTable_OOP,pDataTableData_OOP);
            dprintf("        qual_set         %p\n",pQualSet_OOP);
            dprintf("        heap             %p\n",pInstanceHeap_OOP);
        }
        else
        {
            dprintf("    class_and_method\n");

            dprintf("      start : %p\n",pCombinedPart_OOP);
        
        }
}

DECLARE_API(blob) 
{
    INIT_API();

    char * pArgs = (char *)_alloca(strlen(args)+1);
    lstrcpy(pArgs,args);

    ULONG_PTR pByte = 0;
    ULONG_PTR Size = 0;

    while (isspace(*pArgs)) pArgs++;
    char * pAddress = pArgs;
        // skip good chars
    while(!isspace(*pArgs)) pArgs++;

    if(*pArgs) // if there are more chars
    {
	    *pArgs = 0; //terminate string
	    pArgs++;
    	// skip spaces
	    while(isspace(*pArgs)) pArgs++;
	    Size = GetExpression(pArgs);
    }
        
    pByte = GetExpression(pAddress);
    if (pByte)
    {        
        if (Size)
        {            
            BYTE * pHereMem = (BYTE *)HeapAlloc(GetProcessHeap(),0,Size*2);
            ReadMemory(pByte,pHereMem,Size*2,0); // to be safe on the size
            //dprintf("    object @ %p size %x\n",pByte,Size);
            ParseBlob(pHereMem,pByte);

            HeapFree(GetProcessHeap(),0,pHereMem);            
        }
        else
        {
            HEAP_ENTRY HeapEntry;
            ReadMemory(pByte-(sizeof(HEAP_ENTRY)),&HeapEntry,sizeof(HEAP_ENTRY),0);
            Size = HeapEntry.Size*sizeof(HEAP_ENTRY);

            BYTE * pHereMem = (BYTE *)HeapAlloc(GetProcessHeap(),0,Size);
            ReadMemory(pByte,pHereMem,Size,0);

            ParseBlob(pHereMem,pByte);

            HeapFree(GetProcessHeap(),0,pHereMem);
        }
    }

}


DECLARE_API(datap) 
{
    INIT_API();

    ULONG_PTR Addr = GetExpression(args);
    if (Addr)
    {

        DWORD dwSize =  256; // and let's hope
        	                      //sizeof(WBEM_DATAPACKET_HEADER) +
        	                      //sizeof(WBEM_DATAPACKET_SMARTENUM_NEXT) + 
        	                      //sizeof(WBEM_DATAPACKET_OBJECT_ARRAY) +
        	                      //sizeof(WBEM_DATAPACKET_OBJECT_HEADER);
        WBEM_DATAPACKET_HEADER * pData = (WBEM_DATAPACKET_HEADER *)_alloca(dwSize);
        if (ReadMemory(Addr,pData,dwSize,NULL))
        {
            dprintf("    Order %08x\n",pData->dwByteOrdering);
            dprintf("    Header %08x DSize %08x Flags %08x %02x ",
            	        pData->dwSizeOfHeader,
            	        pData->dwDataSize,
            	        pData->dwFlags,
            	        pData->bVersion);
            switch(pData->bPacketType)
            {
	     case WBEM_DATAPACKETTYPE_OBJECTSINK_INDICATE:
	     	  {
           	      dprintf("WBEM_DATAPACKETTYPE_OBJECTSINK_INDICATE\n");

           	      WBEM_DATAPACKET_OBJECTSINK_INDICATE UNALIGNED * pIndicate = (WBEM_DATAPACKET_OBJECTSINK_INDICATE UNALIGNED *)((BYTE *)pData + pData->dwSizeOfHeader);
                    dprintf("        Header %08x Size %08x\n",pIndicate->dwSizeOfHeader,pIndicate->dwDataSize);

	             WBEM_DATAPACKET_OBJECT_ARRAY UNALIGNED * pArrayPacket = (WBEM_DATAPACKET_OBJECT_ARRAY UNALIGNED *)((BYTE * )pIndicate+pIndicate->dwSizeOfHeader);
	             dprintf("            Header %08x Size %08x NumObj %08x\n",
	            	          pArrayPacket->dwSizeOfHeader,
	            	          pArrayPacket->dwDataSize,
	            	          pArrayPacket->dwNumObjects);
	             
	             WBEM_DATAPACKET_OBJECT_HEADER UNALIGNED * pObjHeader = (WBEM_DATAPACKET_OBJECT_HEADER UNALIGNED *)((BYTE*)pArrayPacket+pArrayPacket->dwSizeOfHeader);
	             dprintf("                Header %08x dwSizeOfData %08x bObjectType ",pObjHeader->dwSizeOfHeader,pObjHeader->dwSizeOfData);

	             switch(pObjHeader->bObjectType)	
	             {
	             	case WBEMOBJECT_NONE:
	             		dprintf("WBEMOBJECT_NONE\n");
	             		break;
 	              case WBEMOBJECT_CLASS_FULL:
	             		dprintf("WBEMOBJECT_CLASS_FULL\n");
	             		break; 	              	
	              case WBEMOBJECT_INSTANCE_FULL:
	             		dprintf("WBEMOBJECT_INSTANCE_FULL\n");
	             		break;	              	
                     case WBEMOBJECT_INSTANCE_NOCLASS:
	             		dprintf("WBEMOBJECT_INSTANCE_NOCLASS\n");
	             		break;                     	
	             };
	            
	             dprintf("    data: %p\n",Addr+pData->dwSizeOfHeader+pIndicate->dwSizeOfHeader+pArrayPacket->dwSizeOfHeader+pObjHeader->dwSizeOfHeader);                    
	     	  }
	         break;	     	
	     case WBEM_DATAPACKETTYPE_SMARTENUM_NEXT:
	     	  {
           	      dprintf("WBEM_DATAPACKETTYPE_SMARTENUM_NEXT\n");
           	      
	             WBEM_DATAPACKET_SMARTENUM_NEXT UNALIGNED * pSNext = (WBEM_DATAPACKET_SMARTENUM_NEXT UNALIGNED *)((BYTE *)pData + pData->dwSizeOfHeader);
	             dprintf("        Header %08x dwDataSize %08x\n",pSNext->dwSizeOfHeader,pSNext->dwDataSize);

	             WBEM_DATAPACKET_OBJECT_ARRAY UNALIGNED * pArrayPacket = (WBEM_DATAPACKET_OBJECT_ARRAY UNALIGNED *)((BYTE * )pSNext+pSNext->dwSizeOfHeader);
	             dprintf("            Header %08x Size %08x NumObj %08x\n",
	            	          pArrayPacket->dwSizeOfHeader,
	            	          pArrayPacket->dwDataSize,
	            	          pArrayPacket->dwNumObjects);
	             
	             WBEM_DATAPACKET_OBJECT_HEADER UNALIGNED * pObjHeader = (WBEM_DATAPACKET_OBJECT_HEADER UNALIGNED *)((BYTE*)pArrayPacket+pArrayPacket->dwSizeOfHeader);
	             dprintf("                Header %08x dwSizeOfData %08x bObjectType ",pObjHeader->dwSizeOfHeader,pObjHeader->dwSizeOfData);

	             switch(pObjHeader->bObjectType)	
	             {
	             	case WBEMOBJECT_NONE:
	             		dprintf("WBEMOBJECT_NONE\n");
	             		break;
 	              case WBEMOBJECT_CLASS_FULL:
	             		dprintf("WBEMOBJECT_CLASS_FULL\n");
	             		break; 	              	
	              case WBEMOBJECT_INSTANCE_FULL:
	             		dprintf("WBEMOBJECT_INSTANCE_FULL\n");
	             		break;	              	
                     case WBEMOBJECT_INSTANCE_NOCLASS:
	             		dprintf("WBEMOBJECT_INSTANCE_NOCLASS\n");
	             		break;                     	
	             };
	            
	             dprintf("    data: %p\n",Addr+pData->dwSizeOfHeader+pSNext->dwSizeOfHeader+pArrayPacket->dwSizeOfHeader+pObjHeader->dwSizeOfHeader);
	     	  }
	         break;	     	
	     case WBEM_DATAPACKETTYPE_UNBOUNDSINK_INDICATE:
	     	{
           	    dprintf("WBEM_DATAPACKETTYPE_UNBOUNDSINK_INDICATE\n");	     		
	     		WBEM_DATAPACKET_UNBOUNDSINK_INDICATE UNALIGNED * pUnBoundI = (WBEM_DATAPACKET_UNBOUNDSINK_INDICATE UNALIGNED *)((BYTE *)pData + pData->dwSizeOfHeader);
	     		dprintf("        Header %08x dwDataSize %08x dwLogicalConsumerSize %08x\n",pUnBoundI->dwSizeOfHeader,pUnBoundI->dwDataSize,pUnBoundI->dwLogicalConsumerSize);

	     	}
	        break;	     	
	     case WBEM_DATAPACKETTYPE_MULTITARGET_DELIVEREVENT:
           	  dprintf("WBEM_DATAPACKETTYPE_MULTITARGET_DELIVEREVENT\n");
	         break;	     	
	     case WBEM_DATAPACKETTYPE_LAST:
           	  dprintf("WBEM_DATAPACKETTYPE_LAST\n");
	         break;
            }
            	
        }
        else
        {
            dprintf("RM %p\n",Addr);
        }
    }
    else
    {
        dprintf("unable to resolve %s\n",args);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmiexts\heap.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    heap.h

Abstract:

    This is the header file that describes the constants and data
    structures used by the user mode heap manager, exported by ntdll.dll
    and ntrtl.lib

    Procedure prototypes are defined in ntrtl.h

Author:

    Steve Wood (stevewo) 21-Aug-1992

Revision History:

--*/

#ifndef _RTL_HEAP_
#define _RTL_HEAP_

#define HEAP_LARGE_TAG_MASK 0xFF000000

#define ROUND_UP_TO_POWER2( x, n ) (((ULONG_PTR)(x) + ((n)-1)) & ~((ULONG_PTR)(n)-1))
#define ROUND_DOWN_TO_POWER2( x, n ) ((ULONG_PTR)(x) & ~((ULONG_PTR)(n)-1))

typedef struct _HEAP_ENTRY {

    //
    //  This field gives the size of the current block in allocation
    //  granularity units.  (i.e. Size << HEAP_GRANULARITY_SHIFT
    //  equals the size in bytes).
    //
    //  Except if this is part of a virtual alloc block then this
    //  value is the difference between the commit size in the virtual
    //  alloc entry and the what the user asked for.
    //

    USHORT Size;

    //
    // This field gives the size of the previous block in allocation
    // granularity units. (i.e. PreviousSize << HEAP_GRANULARITY_SHIFT
    // equals the size of the previous block in bytes).
    //

    USHORT PreviousSize;

    //
    // This field contains the index into the segment that controls
    // the memory for this block.
    //

    UCHAR SegmentIndex;

    //
    // This field contains various flag bits associated with this block.
    // Currently these are:
    //
    //  0x01 - HEAP_ENTRY_BUSY
    //  0x02 - HEAP_ENTRY_EXTRA_PRESENT
    //  0x04 - HEAP_ENTRY_FILL_PATTERN
    //  0x08 - HEAP_ENTRY_VIRTUAL_ALLOC
    //  0x10 - HEAP_ENTRY_LAST_ENTRY
    //  0x20 - HEAP_ENTRY_SETTABLE_FLAG1
    //  0x40 - HEAP_ENTRY_SETTABLE_FLAG2
    //  0x80 - HEAP_ENTRY_SETTABLE_FLAG3
    //

    UCHAR Flags;

    //
    // This field contains the number of unused bytes at the end of this
    // block that were not actually allocated.  Used to compute exact
    // size requested prior to rounding requested size to allocation
    // granularity.  Also used for tail checking purposes.
    //

    UCHAR UnusedBytes;

    //
    // Small (8 bit) tag indexes can go here.
    //

    UCHAR SmallTagIndex;

#if defined(_WIN64)
    PVOID SubSegment;
#endif

} HEAP_ENTRY, *PHEAP_ENTRY;


//
//  This block describes extra information that might be at the end of a
//  busy block.
//  Note: The heap code is assuming that:
//      sizeof( HEAP_ENTRY_EXTRA ) == sizeof( HEAP_ENTRY )
//

typedef struct _HEAP_ENTRY_EXTRA {
    union {
        struct {
            //
            // This field is for debugging purposes.  It will normally contain a
            // stack back trace index of the allocator for x86 systems.
            //

            USHORT AllocatorBackTraceIndex;

            //
            // This field is currently unused, but is intended for storing
            // any encoded value that will give the that gives the type of object
            // allocated.
            //

            USHORT TagIndex;

            //
            // This field is a 32-bit settable value that a higher level heap package
            // can use.  The Win32 heap manager stores handle values in this field.
            //

            ULONG_PTR Settable;
        };
#if defined(_WIN64)
        struct {
            ULONGLONG ZeroInit;
            ULONGLONG ZeroInit1;
        };
#else
        ULONGLONG ZeroInit;
#endif
    };
} HEAP_ENTRY_EXTRA, *PHEAP_ENTRY_EXTRA;

//
// This structure is present at the end of a free block if HEAP_ENTRY_EXTRA_PRESENT
// is set in the Flags field of a HEAP_FREE_ENTRY structure.  It is used to save the
// tag index that was associated with the allocated block after it has been freed.
// Works best when coalesce on free is disabled, along with decommitment.
//

typedef struct _HEAP_FREE_ENTRY_EXTRA {
    USHORT TagIndex;
    USHORT FreeBackTraceIndex;
} HEAP_FREE_ENTRY_EXTRA, *PHEAP_FREE_ENTRY_EXTRA;

//
// This structure describes a block that lies outside normal heap memory
// as it was allocated with NtAllocateVirtualMemory and has the
// HEAP_ENTRY_VIRTUAL_ALLOC flag set.
//

typedef struct _HEAP_VIRTUAL_ALLOC_ENTRY {
    LIST_ENTRY Entry;
    HEAP_ENTRY_EXTRA ExtraStuff;
    SIZE_T CommitSize;
    SIZE_T ReserveSize;
    HEAP_ENTRY BusyBlock;
} HEAP_VIRTUAL_ALLOC_ENTRY, *PHEAP_VIRTUAL_ALLOC_ENTRY;

typedef struct _HEAP_FREE_ENTRY {
    //
    // This field gives the size of the current block in allocation
    // granularity units.  (i.e. Size << HEAP_GRANULARITY_SHIFT
    // equals the size in bytes).
    //

    USHORT Size;

    //
    // This field gives the size of the previous block in allocation
    // granularity units. (i.e. PreviousSize << HEAP_GRANULARITY_SHIFT
    // equals the size of the previous block in bytes).
    //

    USHORT PreviousSize;

    //
    // This field contains the index into the segment that controls
    // the memory for this block.
    //

    UCHAR SegmentIndex;

    //
    // This field contains various flag bits associated with this block.
    // Currently for free blocks these can be:
    //
    //  0x02 - HEAP_ENTRY_EXTRA_PRESENT
    //  0x04 - HEAP_ENTRY_FILL_PATTERN
    //  0x10 - HEAP_ENTRY_LAST_ENTRY
    //

    UCHAR Flags;

    //
    // Two fields to encode the location of the bit in FreeListsInUse
    // array in HEAP_SEGMENT for blocks of this size.
    //

    UCHAR Index;
    UCHAR Mask;

    //
    // Free blocks use these two words for linking together free blocks
    // of the same size on a doubly linked list.
    //
    LIST_ENTRY FreeList;

#if defined(_WIN64)
    ULONGLONG Reserved1;
#endif

} HEAP_FREE_ENTRY, *PHEAP_FREE_ENTRY;



#define HEAP_GRANULARITY            ((LONG) sizeof( HEAP_ENTRY ))
#if defined(_WIN64)
#define HEAP_GRANULARITY_SHIFT      4   // Log2( HEAP_GRANULARITY )
#else
#define HEAP_GRANULARITY_SHIFT      3   // Log2( HEAP_GRANULARITY )
#endif

#define HEAP_MAXIMUM_BLOCK_SIZE     (USHORT)(((0x10000 << HEAP_GRANULARITY_SHIFT) - PAGE_SIZE) >> HEAP_GRANULARITY_SHIFT)

#define HEAP_MAXIMUM_FREELISTS 128
#define HEAP_MAXIMUM_SEGMENTS 64

#define HEAP_ENTRY_BUSY             0x01
#define HEAP_ENTRY_EXTRA_PRESENT    0x02
#define HEAP_ENTRY_FILL_PATTERN     0x04
#define HEAP_ENTRY_VIRTUAL_ALLOC    0x08
#define HEAP_ENTRY_LAST_ENTRY       0x10
#define HEAP_ENTRY_SETTABLE_FLAG1   0x20
#define HEAP_ENTRY_SETTABLE_FLAG2   0x40
#define HEAP_ENTRY_SETTABLE_FLAG3   0x80
#define HEAP_ENTRY_SETTABLE_FLAGS   0xE0

//
// HEAP_SEGMENT defines the structure used to describe a range of
// contiguous virtual memory that has been set aside for use by
// a heap.
//

typedef struct _HEAP_UNCOMMMTTED_RANGE {
    struct _HEAP_UNCOMMMTTED_RANGE *Next;
    ULONG_PTR Address;
    SIZE_T Size;
    ULONG filler;
} HEAP_UNCOMMMTTED_RANGE, *PHEAP_UNCOMMMTTED_RANGE;

typedef struct _HEAP_SEGMENT {
    HEAP_ENTRY Entry;

    ULONG Signature;
    ULONG Flags;
    struct _HEAP *Heap;
    SIZE_T LargestUnCommittedRange;

    PVOID BaseAddress;
    ULONG NumberOfPages;
    PHEAP_ENTRY FirstEntry;
    PHEAP_ENTRY LastValidEntry;

    ULONG NumberOfUnCommittedPages;
    ULONG NumberOfUnCommittedRanges;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRanges;
    USHORT AllocatorBackTraceIndex;
    USHORT Reserved;
    PHEAP_ENTRY LastEntryInSegment;
} HEAP_SEGMENT, *PHEAP_SEGMENT;

#define HEAP_SEGMENT_SIGNATURE  0xFFEEFFEE
#define HEAP_SEGMENT_USER_ALLOCATED (ULONG)0x00000001

//
// HEAP defines the header for a heap.
//

typedef struct _HEAP_LOCK {
    union {
        RTL_CRITICAL_SECTION CriticalSection;
        ERESOURCE Resource;
    } Lock;
} HEAP_LOCK, *PHEAP_LOCK;

typedef struct _HEAP_UCR_SEGMENT {
    struct _HEAP_UCR_SEGMENT *Next;
    SIZE_T ReservedSize;
    SIZE_T CommittedSize;
    ULONG filler;
} HEAP_UCR_SEGMENT, *PHEAP_UCR_SEGMENT;


typedef struct _HEAP_TAG_ENTRY {
    ULONG Allocs;
    ULONG Frees;
    SIZE_T Size;
    USHORT TagIndex;
    USHORT CreatorBackTraceIndex;
    WCHAR TagName[ 24 ];
} HEAP_TAG_ENTRY, *PHEAP_TAG_ENTRY;     // sizeof( HEAP_TAG_ENTRY ) must divide page size evenly

typedef struct _HEAP_PSEUDO_TAG_ENTRY {
    ULONG Allocs;
    ULONG Frees;
    SIZE_T Size;
} HEAP_PSEUDO_TAG_ENTRY, *PHEAP_PSEUDO_TAG_ENTRY;


typedef struct _HEAP {
    HEAP_ENTRY Entry;

    ULONG Signature;
    ULONG Flags;
    ULONG ForceFlags;
    ULONG VirtualMemoryThreshold;

    SIZE_T SegmentReserve;
    SIZE_T SegmentCommit;
    SIZE_T DeCommitFreeBlockThreshold;
    SIZE_T DeCommitTotalFreeThreshold;

    SIZE_T TotalFreeSize;
    SIZE_T MaximumAllocationSize;
    USHORT ProcessHeapsListIndex;
    USHORT HeaderValidateLength;
    PVOID HeaderValidateCopy;

    USHORT NextAvailableTagIndex;
    USHORT MaximumTagIndex;
    PHEAP_TAG_ENTRY TagEntries;
    PHEAP_UCR_SEGMENT UCRSegments;
    PHEAP_UNCOMMMTTED_RANGE UnusedUnCommittedRanges;

    //
    //  The following two fields control the alignment for each new heap entry
    //  allocation.  The round is added to each size and the mask is used to
    //  align it.  The round value includes the heap entry and any tail checking
    //  space
    //

    SIZE_T AlignRound;
    SIZE_T AlignMask;

    LIST_ENTRY VirtualAllocdBlocks;

    PHEAP_SEGMENT Segments[ HEAP_MAXIMUM_SEGMENTS ];

    union {
        ULONG FreeListsInUseUlong[ HEAP_MAXIMUM_FREELISTS / 32 ];
        UCHAR FreeListsInUseBytes[ HEAP_MAXIMUM_FREELISTS / 8 ];
    } u;

    union {

        USHORT FreeListsInUseTerminate;
        USHORT DecommitCount;
    } u2;

    USHORT AllocatorBackTraceIndex;

    ULONG NonDedicatedListLength;
    PVOID LargeBlocksIndex;
    PHEAP_PSEUDO_TAG_ENTRY PseudoTagEntries;

    LIST_ENTRY FreeLists[ HEAP_MAXIMUM_FREELISTS ];

    PHEAP_LOCK LockVariable;
    PRTL_HEAP_COMMIT_ROUTINE CommitRoutine;

    //
    //  The following field is used to manage the heap lookaside list.  The
    //  pointer is used to locate the lookaside list array.  If it is null
    //  then the lookaside list is not active.
    //
    //  The lock count is used to denote if the heap is locked.  A zero value
    //  means the heap is not locked.  Each lock operation increments the
    //  heap count and each unlock decrements the counter
    //
    
    PVOID FrontEndHeap;
    
    USHORT FrontHeapLockCount;
    UCHAR FrontEndHeapType;
    UCHAR LastSegmentIndex;

} HEAP, *PHEAP;

#define HEAP_SIGNATURE                      (ULONG)0xEEFFEEFF
#define HEAP_LOCK_USER_ALLOCATED            (ULONG)0x80000000
#define HEAP_VALIDATE_PARAMETERS_ENABLED    (ULONG)0x40000000
#define HEAP_VALIDATE_ALL_ENABLED           (ULONG)0x20000000
#define HEAP_SKIP_VALIDATION_CHECKS         (ULONG)0x10000000
#define HEAP_CAPTURE_STACK_BACKTRACES       (ULONG)0x08000000

#define CHECK_HEAP_TAIL_SIZE HEAP_GRANULARITY
#define CHECK_HEAP_TAIL_FILL 0xAB
#define FREE_HEAP_FILL 0xFEEEFEEE
#define ALLOC_HEAP_FILL 0xBAADF00D

#define HEAP_MAXIMUM_SMALL_TAG              0xFF
#define HEAP_SMALL_TAG_MASK                 (HEAP_MAXIMUM_SMALL_TAG << HEAP_TAG_SHIFT)
#define HEAP_NEED_EXTRA_FLAGS ((HEAP_TAG_MASK ^ HEAP_SMALL_TAG_MASK)  | \
                               HEAP_CAPTURE_STACK_BACKTRACES          | \
                               HEAP_SETTABLE_USER_VALUE                 \
                              )
#define HEAP_NUMBER_OF_PSEUDO_TAG           (HEAP_MAXIMUM_FREELISTS+1)


#if (HEAP_ENTRY_SETTABLE_FLAG1 ^    \
     HEAP_ENTRY_SETTABLE_FLAG2 ^    \
     HEAP_ENTRY_SETTABLE_FLAG3 ^    \
     HEAP_ENTRY_SETTABLE_FLAGS      \
    )
#error Invalid HEAP_ENTRY_SETTABLE_FLAGS
#endif

#if ((HEAP_ENTRY_BUSY ^             \
      HEAP_ENTRY_EXTRA_PRESENT ^    \
      HEAP_ENTRY_FILL_PATTERN ^     \
      HEAP_ENTRY_VIRTUAL_ALLOC ^    \
      HEAP_ENTRY_LAST_ENTRY ^       \
      HEAP_ENTRY_SETTABLE_FLAGS     \
     ) !=                           \
     (HEAP_ENTRY_BUSY |             \
      HEAP_ENTRY_EXTRA_PRESENT |    \
      HEAP_ENTRY_FILL_PATTERN |     \
      HEAP_ENTRY_VIRTUAL_ALLOC |    \
      HEAP_ENTRY_LAST_ENTRY |       \
      HEAP_ENTRY_SETTABLE_FLAGS     \
     )                              \
    )
#error Conflicting HEAP_ENTRY flags
#endif

//#if ((HEAP_SETTABLE_USER_FLAGS >> 4) ^ HEAP_ENTRY_SETTABLE_FLAGS)
//#error HEAP_SETTABLE_USER_FLAGS in ntrtl.h conflicts with HEAP_ENTRY_SETTABLE_FLAGS in heap.h
//#endif

typedef struct _HEAP_STOP_ON_TAG {
    union {
        ULONG HeapAndTagIndex;
        struct {
            USHORT TagIndex;
            USHORT HeapIndex;
        };
    };
} HEAP_STOP_ON_TAG, *PHEAP_STOP_ON_TAG;

typedef struct _HEAP_STOP_ON_VALUES {
    SIZE_T AllocAddress;
    HEAP_STOP_ON_TAG AllocTag;
    SIZE_T ReAllocAddress;
    HEAP_STOP_ON_TAG ReAllocTag;
    SIZE_T FreeAddress;
    HEAP_STOP_ON_TAG FreeTag;
} HEAP_STOP_ON_VALUES, *PHEAP_STOP_ON_VALUES;

#ifndef NTOS_KERNEL_RUNTIME

extern BOOLEAN RtlpDebugHeap;
extern BOOLEAN RtlpValidateHeapHdrsEnable; // Set to TRUE if headers are being corrupted
extern BOOLEAN RtlpValidateHeapTagsEnable; // Set to TRUE if tag counts are off and you want to know why
extern PHEAP RtlpGlobalTagHeap;
extern HEAP_STOP_ON_VALUES RtlpHeapStopOn;

BOOLEAN
RtlpHeapIsLocked(
    IN PVOID HeapHandle
    );

//
// Page heap external interface.
//

#include <heappage.h>

#endif // NTOS_KERNEL_RUNTIME

#endif //  _RTL_HEAP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmiexts\heappage.h ===
/*++

Copyright (c) 1994-2000  Microsoft Corporation

Module Name:

    heappage.h

Abstract:

    External interface for page heap manager.
    
Author:

    Tom McGuire (TomMcg) 06-Jan-1995
    Silviu Calinoiu (SilviuC) 22-Feb-2000

Revision History:

--*/

#ifndef _HEAP_PAGE_H_
#define _HEAP_PAGE_H_

//
//  #defining DEBUG_PAGE_HEAP will cause the page heap manager
//  to be compiled.  Only #define this flag if NOT kernel mode.
//  Probably want to define this just for checked-build (DBG).
//

#ifndef NTOS_KERNEL_RUNTIME
#define DEBUG_PAGE_HEAP 1
#endif

//silviuc: #include "heappagi.h"

#ifndef DEBUG_PAGE_HEAP

//
//  These macro-based hooks should be defined to nothing so they
//  simply "go away" during compile if the debug heap manager is
//  not desired (retail builds).
//

#define IS_DEBUG_PAGE_HEAP_HANDLE( HeapHandle ) FALSE
#define IF_DEBUG_PAGE_HEAP_THEN_RETURN( Handle, ReturnThis )
#define IF_DEBUG_PAGE_HEAP_THEN_CALL( Handle, CallThis )
#define IF_DEBUG_PAGE_HEAP_THEN_BREAK( Handle, Text, ReturnThis )

#define HEAP_FLAG_PAGE_ALLOCS 0

#define RtlpDebugPageHeapValidate( HeapHandle, Flags, Address ) TRUE

#else // DEBUG_PAGE_HEAP

//
//  The following definitions and prototypes are the external interface
//  for hooking the debug heap manager in the retail heap manager.
//

#define HEAP_FLAG_PAGE_ALLOCS       0x01000000

#define HEAP_PROTECTION_ENABLED     0x02000000
#define HEAP_BREAK_WHEN_OUT_OF_VM   0x04000000
#define HEAP_NO_ALIGNMENT           0x08000000


#define IS_DEBUG_PAGE_HEAP_HANDLE( HeapHandle ) \
            (((PHEAP)(HeapHandle))->ForceFlags & HEAP_FLAG_PAGE_ALLOCS )


#define IF_DEBUG_PAGE_HEAP_THEN_RETURN( Handle, ReturnThis )                \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                return ReturnThis;                                          \
                }                                                           \
            }


#define IF_DEBUG_PAGE_HEAP_THEN_CALL( Handle, CallThis )                    \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                CallThis;                                                   \
                return;                                                     \
                }                                                           \
            }


#define IF_DEBUG_PAGE_HEAP_THEN_BREAK( Handle, Text, ReturnThis )           \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                RtlpDebugPageHeapBreak( Text );                             \
                return ReturnThis;                                          \
                }                                                           \
            }


PVOID
RtlpDebugPageHeapCreate(
    IN ULONG Flags,
    IN PVOID HeapBase,
    IN SIZE_T ReserveSize,
    IN SIZE_T CommitSize,
    IN PVOID Lock,
    IN PRTL_HEAP_PARAMETERS Parameters
    );

PVOID
RtlpDebugPageHeapAllocate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN SIZE_T Size
    );

BOOLEAN
RtlpDebugPageHeapFree(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

PVOID
RtlpDebugPageHeapReAllocate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN SIZE_T Size
    );

PVOID
RtlpDebugPageHeapDestroy(
    IN PVOID HeapHandle
    );

SIZE_T
RtlpDebugPageHeapSize(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

ULONG
RtlpDebugPageHeapGetProcessHeaps(
    ULONG NumberOfHeaps,
    PVOID *ProcessHeaps
    );

ULONG
RtlpDebugPageHeapCompact(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

BOOLEAN
RtlpDebugPageHeapValidate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

NTSTATUS
RtlpDebugPageHeapWalk(
    IN PVOID HeapHandle,
    IN OUT PRTL_HEAP_WALK_ENTRY Entry
    );

BOOLEAN
RtlpDebugPageHeapLock(
    IN PVOID HeapHandle
    );

BOOLEAN
RtlpDebugPageHeapUnlock(
    IN PVOID HeapHandle
    );

BOOLEAN
RtlpDebugPageHeapSetUserValue(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN PVOID UserValue
    );

BOOLEAN
RtlpDebugPageHeapGetUserInfo(
    IN  PVOID  HeapHandle,
    IN  ULONG  Flags,
    IN  PVOID  Address,
    OUT PVOID* UserValue,
    OUT PULONG UserFlags
    );

BOOLEAN
RtlpDebugPageHeapSetUserFlags(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN ULONG UserFlagsReset,
    IN ULONG UserFlagsSet
    );

BOOLEAN
RtlpDebugPageHeapSerialize(
    IN PVOID HeapHandle
    );

NTSTATUS
RtlpDebugPageHeapExtend(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Base,
    IN SIZE_T Size
    );

NTSTATUS
RtlpDebugPageHeapZero(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

NTSTATUS
RtlpDebugPageHeapReset(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

NTSTATUS
RtlpDebugPageHeapUsage(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN OUT PRTL_HEAP_USAGE Usage
    );

BOOLEAN
RtlpDebugPageHeapIsLocked(
    IN PVOID HeapHandle
    );

VOID
RtlpDebugPageHeapBreak(
    PCH Text
    );

//
// Page Heap Global Flags
//
// These flags are kept in a global variable that can be set from
// debugger. During heap creation these flags are stored in a per heap
// structure and control the behavior of that particular heap.
//
// PAGE_HEAP_ENABLE_PAGE_HEAP
//
//     This flag is set by default. It means that page heap allocations
//     should be used always. The flag is useful if we want to use page
//     heap only for certain heaps and stick with normal heaps for the
//     others. It can be changed on the fly (after heap creation) to direct
//     allocations in one heap or another.
//
// PAGE_HEAP_CATCH_BACKWARD_OVERRUNS
//
//     Places the N/A page at the beginning of the block.
//
// PAGE_HEAP_UNALIGNED_ALLOCATIONS
//
//     For historical reasons (related to RPC) by default page heap
//     aligns allocations at 8 byte boundaries. With this flag set
//     this does not happen and we can catch instantly off by one
//     errors for unaligned allocations.
//
// PAGE_HEAP_SMART_MEMORY_USAGE
//
//     This flag reduces the committed memory consumption in half
//     by using decommitted ranges (reserved virtual space) instead
//     of N/A committed pages. This flag is disabled by catch backward
//     overruns.
//
// PAGE_HEAP_USE_SIZE_RANGE
//
//     Use page heap for allocations in the size range specified by:
//     RtlpDphSizeRangeStart..RtlpDphSizeRangeEnd.
//
// PAGE_HEAP_USE_DLL_RANGE
//
//     Use page heap for allocations in the address range specified by:
//     RtlpDphDllRangeStart..RtlpDphDllRangeEnd. If the stack trace
//     of the allocation contains one address in this range then
//     allocation will be made from page heap.
//
// PAGE_HEAP_USE_RANDOM_DECISION
//
//     Use page heap if we randomly decide so.
//
// PAGE_HEAP_USE_DLL_NAMES
//
//     Use page heap if allocation call was generated from on of the
//     target dlls.
//
// PAGE_HEAP_USE_FAULT_INJECTION
//
//     Fault inject heap allocation calls based on a simple 
//     probabilistic model (see FaultProbability and FaultTimeOut).
//
// PAGE_HEAP_PROTECT_META_DATA
//
//     Keep page heap metadata read only if we are not executing inside
//     the page heap code.
//

#define PAGE_HEAP_ENABLE_PAGE_HEAP          0x0001
#define PAGE_HEAP_COLLECT_STACK_TRACES      0x0002
#define PAGE_HEAP_RESERVED_04               0x0004
#define PAGE_HEAP_RESERVED_08               0x0008
#define PAGE_HEAP_CATCH_BACKWARD_OVERRUNS   0x0010
#define PAGE_HEAP_UNALIGNED_ALLOCATIONS     0x0020
#define PAGE_HEAP_SMART_MEMORY_USAGE        0x0040
#define PAGE_HEAP_USE_SIZE_RANGE            0x0080
#define PAGE_HEAP_USE_DLL_RANGE             0x0100
#define PAGE_HEAP_USE_RANDOM_DECISION       0x0200
#define PAGE_HEAP_USE_DLL_NAMES             0x0400
#define PAGE_HEAP_USE_FAULT_INJECTION       0x0800
#define PAGE_HEAP_PROTECT_META_DATA         0x1000

//
// Is page heap enabled for this process?
//

extern BOOLEAN RtlpDebugPageHeap;

//
// `RtlpDphGlobalFlags' stores the global page heap flags.
// The value of this variable is copied into the per heap
// flags (ExtraFlags field) during heap creation. This variable 
// might get its value from the `PageHeap' ImageFileOptions
// registry key. 
//

extern ULONG RtlpDphGlobalFlags;

//
// Page heap global flags. They might be read from the
// `ImageFileOptions' registry key.
//

extern ULONG RtlpDphSizeRangeStart;
extern ULONG RtlpDphSizeRangeEnd;
extern ULONG RtlpDphDllRangeStart;
extern ULONG RtlpDphDllRangeEnd;
extern ULONG RtlpDphRandomProbability;
extern WCHAR RtlpDphTargetDlls[];

//
// If not zero controls the probability with which
// allocations will be failed on purpose by page heap
// manager. Timeout represents the initial period during
// process initialization when faults are not allowed.
//

extern ULONG RtlpDphFaultProbability;
extern ULONG RtlpDphFaultTimeOut;

//
// Stuff needed for per dll logic implemented in the loader
//

const WCHAR *
RtlpDphIsDllTargeted (
    const WCHAR * Name
    );

VOID
RtlpDphTargetDllsLoadCallBack (
    PUNICODE_STRING Name,
    PVOID Address,
    ULONG Size
    );

//
// Functions needed to turn on/off fault injection.
// They are needed in the loader so that allocations
// succeed while in LdrLoadDll code path.
//

VOID
RtlpDphDisableFaultInjection (
    );

VOID
RtlpDphEnableFaultInjection (
    );

#endif // DEBUG_PAGE_HEAP

#endif // _HEAP_PAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmiexts\utilfun.cpp ===
#include <wmiexts.h>
#include <malloc.h>
#include <objbase.h>

//IID_IStdIdentity {0000001B-0000-0000-C000-000000000046}
const GUID IID_IStdIdentity = {0x0000001B,0x0000,0x0000,{0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

#include <data.h>

#include <utilfun.h>

DECLARE_API(iid) {

    INIT_API();

    GUID CurrUUID;
    
    ULONG_PTR pUUID = 0;
    pUUID = GetExpression(args);
    if (pUUID){
        ReadMemory(pUUID,&CurrUUID,sizeof(GUID),0);

        WCHAR pszClsID[40];
        StringFromGUID2(CurrUUID,pszClsID,40);
        WCHAR pszFullPath[MAX_PATH];
        lstrcpyW(pszFullPath,L"Interface\\");
        lstrcatW(pszFullPath,pszClsID);

        char pDataA[MAX_PATH];
        HKEY hKey;
        LONG lRes;

        lRes = RegOpenKeyExW(HKEY_CLASSES_ROOT,
                             pszFullPath,
                             0,
                             KEY_READ,
                             &hKey);

        if (lRes == ERROR_SUCCESS){
            DWORD dwType;
            WCHAR pData[MAX_PATH];
            DWORD dwSize=sizeof(pData);
            
            lRes = RegQueryValueExW(hKey,
                                    NULL, // default
                                    NULL,
                                    &dwType,
                                    (BYTE *)pData,
                                    &dwSize);
            if (lRes == ERROR_SUCCESS) {
                
                WideCharToMultiByte(CP_ACP,0,pData,-1,pDataA,sizeof(pDataA),NULL,NULL);
                dprintf("   IID_%s\n",pDataA);
            }
            RegCloseKey(hKey);
            
        } else {
            
            if (IsEqualGUID(CurrUUID,IID_IMarshal)){
            
               dprintf("    IID_IMarshal\n");
               
            } else if (IsEqualGUID(CurrUUID,IID_IStdIdentity)) {
            
               dprintf("    IID_IStdIdentity\n");    
               
            } else if (IsEqualGUID(CurrUUID,IID_ICallFactory)) {
            
               dprintf("    IID_ICallFactory\n");    
               
            } else {
            
               WideCharToMultiByte(CP_ACP,0,pszClsID,-1,pDataA,sizeof(pDataA),NULL,NULL);
               dprintf("unable to open key %s\n",pDataA);
               
            }
        }

    } else {
      dprintf("unable to resolve %s\n",args);
    }

}

extern ArrayCLSID g_ArrayCLSID[];

DECLARE_API(clsid) {

    INIT_API();

    GUID CurrUUID;
    
    ULONG_PTR pUUID = 0;
    pUUID = GetExpression(args);
    if (pUUID){
        ReadMemory(pUUID,&CurrUUID,sizeof(GUID),0);

        WCHAR pszClsID[40];
        StringFromGUID2(CurrUUID,pszClsID,40);

        // look-up known
        DWORD i;
        for (i=0;i<g_nClsids;i++){
            if(IsEqualGUID(CurrUUID,*g_ArrayCLSID[i].pClsid)){
                dprintf("    CLSID : %s\n",g_ArrayCLSID[i].pStrClsid);
                break;
            }
        }
        
        WCHAR pszFullPath[MAX_PATH];
        lstrcpyW(pszFullPath,L"CLSID\\");
        lstrcatW(pszFullPath,pszClsID);

        char pDataA[MAX_PATH];
        HKEY hKey;
        LONG lRes;

        lRes = RegOpenKeyExW(HKEY_CLASSES_ROOT,
                             pszFullPath,
                             0,
                             KEY_READ,
                             &hKey);

        if (lRes == ERROR_SUCCESS){
            DWORD dwType;
            WCHAR pData[MAX_PATH];
            DWORD dwSize=sizeof(pData);
            
            lRes = RegQueryValueExW(hKey,
                                    NULL, // default
                                    NULL,
                                    &dwType,
                                    (BYTE *)pData,
                                    &dwSize);
            if (lRes == ERROR_SUCCESS) {
                
                WideCharToMultiByte(CP_ACP,0,pData,-1,pDataA,sizeof(pDataA),NULL,NULL);
                dprintf("    ProgID %s\n",pDataA);
                
            };
            RegCloseKey(hKey);
            
            // no open InProcServer32
            WCHAR pszFullPathDll[MAX_PATH];
            lstrcpyW(pszFullPathDll,pszFullPath);
            lstrcatW(pszFullPathDll,L"\\InprocServer32");

            lRes = RegOpenKeyExW(HKEY_CLASSES_ROOT,
                                 pszFullPathDll,
                                 0,
                                 KEY_READ,
                                 &hKey);
            if (lRes == ERROR_SUCCESS){

                dwSize = sizeof(pData);
                lRes = RegQueryValueExW(hKey,
                                        NULL, // default
                                        NULL,
                                        &dwType,
                                        (BYTE *)pData,
                                        &dwSize);
                                    
                if (lRes == ERROR_SUCCESS) {
                
                    WideCharToMultiByte(CP_ACP,0,pData,-1,pDataA,sizeof(pDataA),NULL,NULL);
                    dprintf("    Path: %s\n",pDataA);
                
                };
            
                RegCloseKey(hKey);
            }
            
        } else {
            
            WideCharToMultiByte(CP_ACP,0,pszClsID,-1,pDataA,sizeof(pDataA),NULL,NULL);
            dprintf("unable to open key %s\n",pDataA);
               
        }

    } else {
      dprintf("unable to resolve %s\n",args);
    }

}

//
//
// Dumps a SAFE_ARRAY
//
//

DECLARE_API(sa) {

    INIT_API();

    SAFEARRAY SA;
    
    ULONG_PTR pSA = 0;
    pSA = GetExpression(args);
    
    if (pSA){
        ReadMemory(pSA,&SA,sizeof(SA),0);

        dprintf(" cDims %d cbElements %d pvData %08x\n",SA.cDims,SA.cbElements,SA.pvData);
        dprintf("rgsabound.cElements %d lLbound %d\n",SA.rgsabound[0].cElements,SA.rgsabound[0].lLbound);
        
    } else {
        dprintf("invalid address %s\n",args);
    }
}

//
//   help for the extension
//   may commands are not listed here
//
//

DECLARE_API(help) {

    INIT_API();

    dprintf("     WMI debugger extension\n");
    dprintf("     iid     : print the human readable IID_xxx\n");
    dprintf("     clsid   : print the human readable CLSID_xxx\n");
    dprintf("     rot     : print the human readable rpcss!gpClassTable\n");
    dprintf("     ipidl   : print the list of IPIDEntry");
    dprintf("     llc     : print linked list count\n");     
    dprintf("     cs      : print the list of CRITICAL_SECTION\n");    
    dprintf("     std_map : print the first 3 DWORD of a std::map<K,V>\n");
    dprintf("     std_queue: print the first ULONG_PTR of a std::queue<V>\n");    
    dprintf("     mapobj  : print a std::map<IUnk,bool>\n");    
    dprintf("     -------- HEAP family\n");
    dprintf("     he      : print the HEAP_ENTRY\n");  
    dprintf("     hef     : walks the HEAP_ENTRY list forward\n");
    dprintf("     hef     : walks the HEAP_ENTRY list backward\n");    
    dprintf("     hs      : print the HEAP_SEGMENT\n");
    dprintf("     hp      : print the HEAP\n");    
    dprintf("     hps     : print a summary for all the HEAP in the process\n");
    dprintf("     shp     : <HEAP> <ADDR> search heap HEAP for address ADDR\n");    
    dprintf("     rllc    : <ADDR> prints the free list in reverse order\n");
    dprintf("     hpf     : <HEAP> prints the free list of the heap at HEAP\n");    
    dprintf("     php     : <HEAP> [s ADDR] prints the pageheap and searches\n");      
    dprintf("     -------- FASTPROX family\n");    
    dprintf("     wc      : print the human readable WbemClass\n");
    dprintf("     wi      : print the human readable WbemClass\n");    
    dprintf("     blob    : ADDR [size] print (part of) the ClassObject BLOB\n");    
    dprintf("     datap   : ADDR print the WBEMDATA marshaling BLOB\n");    
    dprintf("     cp      : print the human readable CClassPart\n");    
    dprintf("     cvar    : print the CVar\n");     
    dprintf("     -------- WBEMCORE\n");
    dprintf("     q       : print wbemcore!g_pAsyncSvcQueue\n"); 
    dprintf("     arb     : print wbemcore!CWmiArbitrator__m_pArb\n");
    dprintf("     -------- REPDRVFS\n");
    dprintf("     tmpall  : print the Allocators in repdrvfs\n");    
    dprintf("     forestc : [Addr] print the repdrvfs!CForestCache at Addr\n");
    dprintf("     filec   : [Addr] print repdrvfs!CFileCache at Addr\n");
    dprintf("     fmap    : \\fs\\[objects|index].map dumps the .MAP file from disk \n");
    dprintf("     btr     : dumps the index.btr/index.map file from disk \n");    
    dprintf("     varobj  : dumps part of objects.data file from disk \n");    
    dprintf("     -------- THREAD family\n");
    dprintf("     t       : print RPC and OLE data for each thread\n");
    dprintf("     inv     : <addr> [param] invokes a function in the remote thread\n");
    dprintf("     bs      : <teb> rebuilds the stack from the info in the TEB\n");
    dprintf("     st      : <addr> <num> prints the num DWORD saved by RtlCaptureStackBackTrace\n");
    dprintf("     lpp     : print linked list and unassemble backtrace\n");    
    dprintf("     vq      : -a <addr> | -f Flag : calls VirtualQuery on the addr\n");
    dprintf("     srt     : <addr> searches the stacks of all threads for addr\n");    
    dprintf("     ksrt    : <addr> searches the stacks of all threads for addr - KD only\n");    
    dprintf("     el      : <TEB> prints the exception list of the current thread x86 only\n");
    dprintf("     -------- ESS\n");
    dprintf("     ess     : print wbemcore!g_pNewESS\n"); 
    dprintf("     -------- PROVSS\n");
    dprintf("     pc      : print wbemcore!CCoreServices__m_pProvSS\n"); 
    dprintf("     pf      : print CServerObject_BindingFactory\n");
    dprintf("     -------- 32-K-64\n");
    dprintf("     hef64   : <addr> HEAP_ENTRY list forward\n");
    dprintf("     heb64   : <addr> HEAP_ENTRY list backward\n");
    dprintf("     hps64   : print heap summary\n");
    dprintf("     cs64    : print CritSec list\n");    
}

void
EnumLinkedListCB(IN LIST_ENTRY  * pListHead,
                 IN DWORD         cbSizeOfStructure,
                 IN DWORD         cbListEntryOffset,
                 IN pfnCallBack2  CallBack)
{
    LIST_ENTRY   ListHead;
    LIST_ENTRY * pListEntry;
    DWORD        cItems = 0;
    
    void * pStorage = (void *)_alloca(cbSizeOfStructure);
    LIST_ENTRY * pListEntryLocal = (LIST_ENTRY *)((BYTE *)pStorage + cbListEntryOffset);
       
    if (ReadMemory((ULONG_PTR)pListHead,&ListHead,sizeof(LIST_ENTRY),NULL))
    {

        if (CallBack)
        {
        }
        else
        {
            dprintf("    H %p -> %p <-\n",ListHead.Flink,ListHead.Blink);
        }
        
	    for ( pListEntry  = ListHead.Flink;
	          pListEntry != pListHead;)
	    {
	        if (CheckControlC())
                break;

	        ULONG_PTR pStructure_OOP = (ULONG_PTR)((BYTE *) pListEntry - cbListEntryOffset);

	        // make a local copy of the debuggee structure
	        if (ReadMemory(pStructure_OOP,pStorage,cbSizeOfStructure,NULL))
	        {
                if (CallBack)
                {
                    CallBack((VOID *)pStructure_OOP,pStorage);
                }
                else
                {
                    dprintf("    %p -> %p <- - %p\n",pListEntryLocal->Flink,pListEntryLocal->Blink,pStructure_OOP);
                }
	        
	            pListEntry = pListEntryLocal->Flink;
	            cItems++;	        
	        }
	        else
	        {
	            dprintf("RM %p\n",pStructure_OOP);
                break;
	        }	       
	    } 

        dprintf( "%d entries traversed\n", cItems );
    }
    else
    {
        dprintf("RM %p\n",pListHead);
    }    

}

void
EnumReverseLinkedListCB(IN LIST_ENTRY  * pListHead,
                        IN DWORD         cbSizeOfStructure,
                        IN DWORD         cbListEntryOffset,
                        IN pfnCallBack2  CallBack)
{
    LIST_ENTRY   ListHead;
    LIST_ENTRY * pListEntry;
    DWORD        cItems = 0;
    
    void * pStorage = (void *)_alloca(cbSizeOfStructure);
    LIST_ENTRY * pListEntryLocal = (LIST_ENTRY *)((BYTE *)pStorage + cbListEntryOffset);
       
    if (ReadMemory((ULONG_PTR)pListHead,&ListHead,sizeof(LIST_ENTRY),NULL))
    {

        if (CallBack)
        {
        }
        else
        {
            dprintf("    H %p -> %p <-\n",ListHead.Flink,ListHead.Blink);
        }
        
	    for ( pListEntry  = ListHead.Blink;
	          pListEntry != pListHead;)
	    {
	        if (CheckControlC())
                break;

	        ULONG_PTR pStructure_OOP = (ULONG_PTR)((BYTE *) pListEntry - cbListEntryOffset);

	        // make a local copy of the debuggee structure
	        if (ReadMemory(pStructure_OOP,pStorage,cbSizeOfStructure,NULL))
	        {
                if (CallBack)
                {
                    CallBack((VOID *)pStructure_OOP,pStorage);
                }
                else
                {
                    dprintf("    %p -> %p <- - %p\n",pListEntryLocal->Flink,pListEntryLocal->Blink,pStructure_OOP);
                }
	        
	            pListEntry = pListEntryLocal->Blink;
	            cItems++;	        
	        }
	        else
	        {
	            dprintf("RM %p\n",pStructure_OOP);
                break;
	        }	       
	    } 

        dprintf( "%d entries traversed\n", cItems );
    }
    else
    {
        dprintf("RM %p\n",pListHead);
    }    

}


//
//
// NO-OP callback just for getting the number of items
//
///////////////////////////////////////////////////////////

DWORD
CallBackListCount(VOID * pStructure_OOP,
                  VOID * pLocalCopy)
{
    return 0;
}

DECLARE_API( llc )
{
    INIT_API();

    ULONG_PTR Addr = GetExpression(args);

    if (Addr)
    {
        EnumLinkedListCB((LIST_ENTRY *)Addr,sizeof(LIST_ENTRY),0,CallBackListCount);
    }
    else
    {
        dprintf("cannot resolve %s\n",args);
    }
}

void
PrintStackTrace(ULONG_PTR ArrayAddr_OOP,DWORD dwNum,BOOL bOOP)
{
    ULONG_PTR * pArray;
    BOOL bRet = FALSE;
    if (bOOP)
    {
        pArray = ( ULONG_PTR *)_alloca(dwNum*sizeof(ULONG_PTR));
        bRet = ReadMemory(ArrayAddr_OOP,pArray,dwNum*sizeof(ULONG_PTR),NULL);
    }
    else
    {
        pArray = (ULONG_PTR *)ArrayAddr_OOP;
        bRet = TRUE;
    }
    
    if (bRet)
    {
        DWORD i;
        for (i=0;i<dwNum;i++)
        {
	        BYTE pString[256];
	        pString[0] = 0;

#ifdef KDEXT_64BIT        
	        ULONG64 Displ = 0;
#else
    	    ULONG Displ = 0;
#endif
            if (pArray[i])
            {
	        	GetSymbol(pArray[i],(PCHAR)pString,&Displ);
		        pString[255] = 0;
    		    dprintf("    %s+%x\n",pString,Displ);
    	    }
        }
    }
}

//
// printf stack trace
//
DECLARE_API( st )
{
    INIT_API();
    
    int Len = strlen(args);
    CHAR * pArgs = (CHAR *)_alloca((Len+1));
    lstrcpy(pArgs,(CHAR *)args);

    ULONG_PTR NumInst = 6;
    ULONG_PTR pAddr = 0;
    
    while (isspace(*pArgs))
    {
        pArgs++;
    }
     
    CHAR * pFirst = pArgs;
    
    while(!isspace(*pArgs)) pArgs++;
    // terminate string, if possible    
    if (isspace(*pArgs))
    {
        *pArgs = 0;
        pArgs++;
    }
    else
    {
        pArgs = NULL;
    }

    pAddr = GetExpression(pFirst);

    if (pArgs)
    {
        NumInst = GetExpression(pArgs);
    }

    if (pAddr)
    {
        dprintf("StackTrace @ %p num %d\n",pAddr,NumInst);
        PrintStackTrace(pAddr,(DWORD)NumInst,TRUE);
    }
    else
    {
        dprintf("usage: address num\n");
    }    
}

//
//
//  this is the CallBack called by the enumerator
//  of a Double-Liked list of objects with
//  struct _Instrument 
//  {
//      LIST_ENTRY ListEntry;
//      ULONG_PTR  ArrayFuncts[32];
//  }
//
//////////////////////////////////////////////////////////

DWORD
CallBackCreateStacks(VOID * pStructure_OOP,
                     VOID * pLocalStructure)
{
    dprintf("    ----- %p \n",pStructure_OOP);
    PrintStackTrace((ULONG_PTR)((BYTE *)pLocalStructure+sizeof(LIST_ENTRY)),6,FALSE);
    return 0;
} 

DECLARE_API( lpp )
{
    INIT_API();

    ULONG_PTR Addr = GetExpression(args);
    
    if (Addr)
    {
	    EnumLinkedListCB((LIST_ENTRY *)Addr,
	                     sizeof(LIST_ENTRY)+32*sizeof(ULONG_PTR),
	                     0,
	                     CallBackCreateStacks);
    }
    else
    {
        dprintf("cannot resolve %s\n",args);
    }

}   



// left parent right

BOOL
IsNil(_BRN * pNode){

    _BRN_HEAD BRN;
    ReadMemory((ULONG_PTR)pNode,&BRN,sizeof(_BRN_HEAD),NULL);

	return ((BRN._Left == NULL) && 		    
			(BRN._Right == NULL));
}

void 
PrintTree(_BRN * pNode,
          DWORD * pNum,
          BOOL Verbose,
          ULONG_PTR Size,
          pfnCallBack2 CallBack){

    //dprintf(" Node %p\n",pNode);
    _BRN BRN;
    if (ReadMemory((ULONG_PTR)pNode,&BRN,sizeof(_BRN),NULL))
    {    
		if (!IsNil(BRN._Left)){
			PrintTree(BRN._Left,pNum,Verbose,Size,CallBack);
		};

	    if (CheckControlC())
	        return;
	    
	    if (pNum){
	      (*pNum)++;
	    }

	    if (*pNum > Size) 
	    {
	        dprintf("invalid tree\n");
	        return;
	    }
	         
	    if (Verbose) {
		    dprintf("    %p %p (%p,%p,%p) - %p %p %p\n",
		             (*pNum)-1,
		             pNode,
		             BRN._Left,BRN._Parent,BRN._Right,
		             BRN.Values[0],
		             BRN.Values[1],
		             BRN.Values[2]);
		    if (CallBack)
		    {
		        //dprintf("CAllBack\n");
		        CallBack((VOID *)BRN.Values[0],(VOID *)BRN.Values[1]);
		    }
		}

		if (!IsNil(BRN._Right)){
			PrintTree(BRN._Right,pNum,Verbose,Size,CallBack);
		};
	}
	else
	{
	    dprintf("    RM %p err %d\n",pNode,GetLastError());
	}
}


void
PrintMapCB(_Map * pMap,BOOL Verbose, pfnCallBack2 CallBack)
{

    _Map MAP;
    
    if (ReadMemory((ULONG_PTR)pMap,&MAP,sizeof(_Map),NULL))
    {
        if (MAP.pQm)
        {
            dprintf("    std::map at %p : size %p\n",pMap,MAP.Size);
                        
            _QM QM;
                                 
            if (ReadMemory((ULONG_PTR)MAP.pQm,&QM,sizeof(QM),NULL))
            {
	            if (QM._Parent && !IsNil(QM._Parent))
	            {
	                DWORD Num = 0;
	                PrintTree(QM._Parent,&Num,Verbose,MAP.Size,CallBack);
	                dprintf("    traversed %d nodes\n",Num);
	            }
            } 
            else
            {
                dprintf("RM %p err %d\n",MAP.pQm,GetLastError());
            }
        } else {
           dprintf("empty tree\n");
        }
    }
    else
    {
        dprintf("RM %p\n",pMap);
    }
}


//
//
// prints a generic std::map
//
////////////////////////////////////


DECLARE_API( std_map )
{

    INIT_API();

    _Map * pMap = (_Map *)GetExpression( args );

    if (pMap){
    
        PrintMapCB(pMap,TRUE,NULL);
        
    } else {
        dprintf("invalid address %s\n",args);
    }
    
}

void
PrintListCB(_List * pList_OOP, pfnCallBack1 CallBack)
{
    _List List;
    if (ReadMemory((ULONG_PTR)pList_OOP,&List,sizeof(_List),NULL))
    {
        dprintf("    std::queue @ %p _Allocator %p _Head %p _Size %p\n",pList_OOP,List._Allocator,List._Head,List._Size);
        _Node_List NodeList;
        
        if (ReadMemory((ULONG_PTR)List._Head,&NodeList,sizeof(_Node_List),NULL))
        {
	        _Node_List * pNodeList = NodeList._Next;
	        
	        DWORD i = 0;
	        
	        while (pNodeList != List._Head)
	        {
	            if (CheckControlC())
	                break;
	                
	            if (ReadMemory((ULONG_PTR)pNodeList,&NodeList,sizeof(_Node_List),NULL))
	            {
	                dprintf("    %x %p (%p, %p) - %p\n",i++,pNodeList,NodeList._Next,NodeList._Prev,NodeList._Value);
	                if (CallBack)
	                {
	                    CallBack(NodeList._Value);
	                }

	                pNodeList = NodeList._Next; 
	            }
	            else
	            {
	                dprintf("RM %p\n",pNodeList);
	            }
	        }
        }
        else
	    {
	        dprintf("RM %p\n",List._Head);
	    }        
    }
    else
    {
        dprintf("RM %p\n",pList_OOP);
    }
}


//
//
//  prints a generic std::list
//
//////////////////////////////////////

DECLARE_API( std_queue)
{
    INIT_API();

    _List * pList = (_List *)GetExpression( args );

    if (pList){
    
        PrintListCB(pList,NULL);
        
    } else {
        dprintf("invalid address %s\n",args);
    }

}

//
//
//  this is for Pat
//  he has a std::map<pObject,BOOL>
//
//////////////////////////////////////////////////

DWORD
CallBackObj(void * pKey, void * pValue)
{
    GetVTable((MEMORY_ADDRESS)pKey);
    return 0;
}

DECLARE_API( mapobj )
{

    INIT_API();


    _Map * pMap = (_Map *)GetExpression( args );

    if (pMap){
    
        PrintMapCB(pMap,TRUE,CallBackObj);
        
    } else {
        dprintf("invalid address %s\n",args);
    }
    
}


void PrintIID(GUID & CurrUUID){

        WCHAR pszClsID[40];
        StringFromGUID2(CurrUUID,pszClsID,40);
        WCHAR pszFullPath[MAX_PATH];
        lstrcpyW(pszFullPath,L"Interface\\");
        lstrcatW(pszFullPath,pszClsID);

        char pDataA[MAX_PATH];
        HKEY hKey;
        LONG lRes;

        lRes = RegOpenKeyExW(HKEY_CLASSES_ROOT,
                             pszFullPath,
                             0,
                             KEY_READ,
                             &hKey);

        if (lRes == ERROR_SUCCESS){
            DWORD dwType;
            WCHAR pData[MAX_PATH];
            DWORD dwSize=sizeof(pData);
            
            lRes = RegQueryValueExW(hKey,
                                    NULL, // default
                                    NULL,
                                    &dwType,
                                    (BYTE *)pData,
                                    &dwSize);
            if (lRes == ERROR_SUCCESS) {
                
                WideCharToMultiByte(CP_ACP,0,pData,-1,pDataA,sizeof(pDataA),NULL,NULL);
                dprintf("        IID_%s\n",pDataA);
            }
            RegCloseKey(hKey);
            
        } else {
            
            if (IsEqualGUID(CurrUUID,IID_IMarshal)){
            
               dprintf("        IID_IMarshal\n");
               
            } else if (IsEqualGUID(CurrUUID,IID_IStdIdentity)) {
            
               dprintf("        IID_IStdIdentity\n");    
               
            } else if (IsEqualGUID(CurrUUID,IID_ICallFactory)) {
            
               dprintf("        IID_ICallFactory\n");    
               
            } else {
            
               WideCharToMultiByte(CP_ACP,0,pszClsID,-1,pDataA,sizeof(pDataA),NULL,NULL);
               dprintf("        %s\n",pDataA);
               
            }
        }

}

class OXIDEntry;
class CCtxComChnl;
class IRCEntry;

typedef GUID IPID;

typedef struct tagIPIDEntry
{
    struct tagIPIDEntry *pNextIPID;  // next IPIDEntry for same object

// WARNING: next 6 fields must remain in their respective locations
// and in the same format as the IPIDTmp structure above.
    DWORD                dwFlags;      // flags (see IPIDFLAGS)
    ULONG                cStrongRefs;  // strong reference count
    ULONG                cWeakRefs;    // weak reference count
    ULONG                cPrivateRefs; // private reference count
    void                *pv;           // real interface pointer
    IUnknown            *pStub;        // proxy or stub pointer
    OXIDEntry           *pOXIDEntry;   // ptr to OXIDEntry in OXID Table
// WARNING: previous 7 fields must remain in their respective locations
// and in the same format as the IPIDTmp structure above.

    IPID                 ipid;         // interface pointer identifier
    IID                  iid;          // interface iid
    CCtxComChnl         *pChnl;        // channel pointer
    IRCEntry            *pIRCEntry;    // reference cache line
    struct tagIPIDEntry *pOIDFLink;    // In use OID list
    struct tagIPIDEntry *pOIDBLink;
} IPIDEntry;


DECLARE_API( ipidl )
{
    INIT_API();

    IPIDEntry  IpId;
    ULONG_PTR Addr = GetExpression(args);
    
    if (Addr) 
    {
    
        DWORD nCount=0;

        while (Addr &&
               ReadMemory(Addr,&IpId,sizeof(IpId),NULL))
        {
            dprintf("    -- %x\n",nCount);
	        dprintf("    pNextIPID    %p\n",IpId.pNextIPID);
	        dprintf("    dwFlags      %08x\n",IpId.dwFlags);      
	        dprintf("    cStrongRefs  %08x\n",IpId.cStrongRefs);  
	        dprintf("    cWeakRefs    %08x\n",IpId.cWeakRefs);
	        dprintf("    cPrivateRefs %08x\n",IpId.cPrivateRefs);
	        dprintf("    pv           %p\n",IpId.pv);
	        dprintf("    pStub        %p\n",IpId.pStub);
	        dprintf("    pOXIDEntry   %p\n",IpId.pOXIDEntry);
	        PrintIID(IpId.ipid);
	        PrintIID(IpId.iid);
	        dprintf("    pChnl        %p\n",IpId.pChnl);
	        dprintf("    pIRCEntry    %p\n",IpId.pIRCEntry);
	        dprintf("    pOIDFLink    %p\n",IpId.pOIDFLink);
	        dprintf("    pOIDBLink    %p\n",IpId.pOIDBLink);

            Addr = (ULONG_PTR)IpId.pNextIPID;
            nCount++;

            if (CheckControlC())
                break;
            
        };        
    } 
    else 
    {
        dprintf(" unable to resolve %s\n",args);
    }
    
}


void PrintCLSID(GUID & CurrUUID){

        WCHAR pszClsID[40];
        StringFromGUID2(CurrUUID,pszClsID,40);

        // look-up known
        DWORD i;
        for (i=0;i<g_nClsids;i++){
            if(IsEqualGUID(CurrUUID,*g_ArrayCLSID[i].pClsid)){
                dprintf("    CLSID : %s\n",g_ArrayCLSID[i].pStrClsid);
                break;
            }
        }
        
        WCHAR pszFullPath[MAX_PATH];
        lstrcpyW(pszFullPath,L"CLSID\\");
        lstrcatW(pszFullPath,pszClsID);

        char pDataA[MAX_PATH];
        HKEY hKey;
        LONG lRes;

        lRes = RegOpenKeyExW(HKEY_CLASSES_ROOT,
                             pszFullPath,
                             0,
                             KEY_READ,
                             &hKey);

        if (lRes == ERROR_SUCCESS){
            DWORD dwType;
            WCHAR pData[MAX_PATH];
            DWORD dwSize=sizeof(pData);
            
            lRes = RegQueryValueExW(hKey,
                                    NULL, // default
                                    NULL,
                                    &dwType,
                                    (BYTE *)pData,
                                    &dwSize);
            if (lRes == ERROR_SUCCESS) {
                
                WideCharToMultiByte(CP_ACP,0,pData,-1,pDataA,sizeof(pDataA),NULL,NULL);
                dprintf("    ProgID %s\n",pDataA);
                
            };
            RegCloseKey(hKey);
            
            // no open InProcServer32
            WCHAR pszFullPathDll[MAX_PATH];
            lstrcpyW(pszFullPathDll,pszFullPath);
            lstrcatW(pszFullPathDll,L"\\InprocServer32");

            lRes = RegOpenKeyExW(HKEY_CLASSES_ROOT,
                                 pszFullPathDll,
                                 0,
                                 KEY_READ,
                                 &hKey);
            if (lRes == ERROR_SUCCESS){

                dwSize = sizeof(pData);
                lRes = RegQueryValueExW(hKey,
                                        NULL, // default
                                        NULL,
                                        &dwType,
                                        (BYTE *)pData,
                                        &dwSize);
                                    
                if (lRes == ERROR_SUCCESS) {
                
                    WideCharToMultiByte(CP_ACP,0,pData,-1,pDataA,sizeof(pDataA),NULL,NULL);
                    dprintf("    Path: %s\n",pDataA);
                
                };
            
                RegCloseKey(hKey);
            }
            
        } else {
            
            WideCharToMultiByte(CP_ACP,0,pszClsID,-1,pDataA,sizeof(pDataA),NULL,NULL);
            dprintf("unable to open key %s\n",pDataA);
               
        }


}

class CTableElement;

class CHashTable
{
private:    
    DWORD _cBuckets;
    DWORD _cElements;
    CTableElement **_buckets;
    CTableElement *_last;
};

typedef int EnumEntryType;
typedef void CSharedLock;
typedef void CServerTable;
typedef void CProcess;

class CServerTableEntry{
private:
    void * pvtable;
    DWORD _references;
    CServerTableEntry * _pnext;
    //DWORD padding;
    //CLSID _GUID;
    unsigned __int64 _id1;
    unsigned __int64 _id2;

    EnumEntryType       _EntryType;

    CSharedLock       * _pParentTableLock;
    CServerTable      * _pParentTable;
    BOOL                _bComPlusProcess;
    LONG                _lThreadToken;
    DWORD               _dwProcessId;
    HANDLE              _hProcess;
    CProcess*           _pProcess;
    void              * _pvRunAsHandle;
    BOOL                _bSuspendedClsid;
    BOOL                _bSuspendedApplication;

    // the _bRetired flag exists per-running process/application

    //CServerList         _ServerList;
    //CSharedLock         _ServerLock;

    
};

/*
0:002> dt rpcss!CServerTableEntry 6fb`ffcdb170
   +0x000 __VFN_table : 0x00000000`702a2b60
   +0x008 _references      :
   +0x010 _pnext           : (null)
   +0x018 _id              : 0x11d0f196`61738644
   +0x020 _id2             : 0xc119d94f`c0005399
   +0x028 _EntryType       : 0 ( ENTRY_TYPE_CLASS )
   +0x030 _pParentTableLock : 0x000006fb`ffc9d590
   +0x038 _pParentTable    : 0x000006fb`ffc9d700
   +0x040 _bComPlusProcess : 0
   +0x044 _lThreadToken    : 0
   +0x048 _dwProcessId     : 0
   +0x050 _hProcess        : (null)
   +0x058 _pProcess        : (null)
   +0x060 _pvRunAsHandle   : (null)
   +0x068 _bSuspendedClsid : 0
   +0x06c _bSuspendedApplication : 0
   +0x070 _ServerList      : CServerList
   +0x080 _ServerLock      : CSharedLock
*/

DECLARE_API( rot )
{

    INIT_API();

    CHashTable * pChashTable;
    ULONG_PTR Addr = GetExpression("rpcss!gpClassTable");
    if (Addr) 
    {
        CHashTable * pChashTable;    
        ReadMemory(Addr,&pChashTable,sizeof(CHashTable *),0);
        CHashTable MyHashTable;
        if (pChashTable)
        {
            dprintf("CServerTable %p\n",pChashTable);
            
            ReadMemory((ULONG_PTR)pChashTable,&MyHashTable,sizeof(CHashTable),NULL);
            CTableElement ** StackArray = (CTableElement **)_alloca(MyHashTable._cBuckets * sizeof(CTableElement *));
            
            ReadMemory((ULONG_PTR)MyHashTable._buckets,StackArray,MyHashTable._cBuckets * sizeof(CTableElement *),NULL);            

            DWORD i;
            for (i=0;i<MyHashTable._cBuckets;i++)
            {
                CServerTableEntry * pEntry = (CServerTableEntry *)StackArray[i];
                
                while (pEntry){                
                    CheckControlC();
                    CServerTableEntry ClassEntry;
                    ReadMemory((ULONG_PTR)pEntry,&ClassEntry,sizeof(ClassEntry),NULL);
                    
                    dprintf("CServerTableEntry %p\n",pEntry);
                    PrintCLSID(*(GUID *)(&(ClassEntry._id1)));

                    pEntry = ClassEntry._pnext;
                }
            }
        }
    } 
    else 
    {
        dprintf("unable to resolve rpcss!gpClassTable");
    }
    
}

/*
struct RTL_CRITICAL_SECTION_DEBUG {
   USHORT Type;             //: 0x0
   USHORT CreatorBackTraceIndex; //: 0x0
   CRITICAL_SECTION * CriticalSection;  //: 0x77fcae40
   LIST_ENTRY ProcessLocksList; //:
   DWORD EntryCount;       //: 0x0
   DWORD ContentionCount;  //: 0x0
   DWORD Spare[2];         //:0x0
};
*/

//
//
//  CallBack for enumeration of critical section
//
//
/////////////////////////////////////////////////////////////

DWORD
EnumListCritSec(VOID * pStructure_OOP,
                VOID * pLocalStructure)
{

    RTL_CRITICAL_SECTION_DEBUG * pDebugInfo = (RTL_CRITICAL_SECTION_DEBUG *)pLocalStructure;
    dprintf("    CS %p DI %p \n",pDebugInfo->CriticalSection,pStructure_OOP);

    RTL_CRITICAL_SECTION CritSec;

    if (ReadMemory((ULONG_PTR)pDebugInfo->CriticalSection,&CritSec,sizeof(RTL_CRITICAL_SECTION),NULL))
    {
        dprintf("       - %p %x %x %x\n",
                CritSec.DebugInfo,
                CritSec.LockCount,
                CritSec.RecursionCount,
                CritSec.OwningThread);
    }
    else
    {
         dprintf("RM %p\n",pDebugInfo->CriticalSection);
    }
    return 0;
}

#define ARRAY_TO_GO_BACK   16

DWORD
EnumListCritSec2(VOID * pStructure_OOP,
                VOID * pLocalStructure)
{

    RTL_CRITICAL_SECTION_DEBUG * pDebugInfo = (RTL_CRITICAL_SECTION_DEBUG *)pLocalStructure;
    dprintf("    CS %p DI %p \n",pDebugInfo->CriticalSection,pStructure_OOP);

    struct _TmpStr {
        ULONG_PTR    Array[ARRAY_TO_GO_BACK];
        RTL_CRITICAL_SECTION CritSec;
    } TmpStr;

    if (ReadMemory(((ULONG_PTR)pDebugInfo->CriticalSection) - FIELD_OFFSET(_TmpStr,CritSec),&TmpStr,sizeof(_TmpStr),NULL))
    {
        dprintf("       - %p %x %x %x\n",
                TmpStr.CritSec.DebugInfo,
                TmpStr.CritSec.LockCount,
                TmpStr.CritSec.RecursionCount,
                TmpStr.CritSec.OwningThread);

        for (int i=(ARRAY_TO_GO_BACK-1);i>=0;i--)
        {
            if (GetVTable((MEMORY_ADDRESS)TmpStr.Array[i]))
            {
                break; // don't be too verbose
            }
        }
    }
    else
    {
         dprintf("RM around %p\n",pDebugInfo->CriticalSection);
    }
    return 0;
}


DECLARE_API( cs )
{
    INIT_API();

    ULONG_PTR Addr = GetExpression("ntdll!RtlCriticalSectionList");

    ULONG_PTR bGoAndFindVTable = TRUE;

    if (!Addr)
    {
        Addr = GetExpression(args);
    }
    else
    {
        bGoAndFindVTable = GetExpression(args);
    }
    
    if (Addr) 
    {
        if (bGoAndFindVTable)
        {
	        EnumLinkedListCB((LIST_ENTRY  *)Addr,
	                         sizeof(RTL_CRITICAL_SECTION_DEBUG),
	                         FIELD_OFFSET(RTL_CRITICAL_SECTION_DEBUG,ProcessLocksList),	                         
	                         EnumListCritSec2);        
        }
        else
        {       
	        EnumLinkedListCB((LIST_ENTRY  *)Addr,
	                         sizeof(RTL_CRITICAL_SECTION_DEBUG),
	                         FIELD_OFFSET(RTL_CRITICAL_SECTION_DEBUG,ProcessLocksList),	                         
	                         EnumListCritSec);
        }	                         
    } 
    else 
    {
        dprintf("unable to resolve ntdll!RtlCriticalSectionList\n");
    }
    
}


BOOL
GetVTable(MEMORY_ADDRESS pThis_OOP){

    MEMORY_ADDRESS pVTable;
    ReadMemory(pThis_OOP,&pVTable,sizeof(pVTable),0);
    
    BYTE pString[256];
    pString[0]=0;

#ifdef KDEXT_64BIT
        ULONG64 Displ;
#else
        ULONG Displ;
#endif
    
    GetSymbol(pVTable,(PCHAR)pString,&Displ);
    if (lstrlenA((CHAR *)pString))
    {
        dprintf("          %s+%x\n",pString,Displ);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

/*
kd> dt ntdll!RTL_CRITICAL_SECTION
   +0x000 DebugInfo        : Ptr64 _RTL_CRITICAL_SECTION_DEBUG
   +0x008 LockCount        : Int4B
   +0x00c RecursionCount   : Int4B
   +0x010 OwningThread     : Ptr64 Void
   +0x018 LockSemaphore    : Ptr64 Void
   +0x020 SpinCount        : Uint8B
kd> dt ntdll!_RTL_CRITICAL_SECTION_DEBUG
   +0x000 Type             : Uint2B
   +0x002 CreatorBackTraceIndex : Uint2B
   +0x008 CriticalSection  : Ptr64 _RTL_CRITICAL_SECTION
   +0x010 ProcessLocksList : _LIST_ENTRY
   +0x020 EntryCount       : Uint4B
   +0x024 ContentionCount  : Uint4B
   +0x028 Spare            : [2] Uint4B
kd>
*/

#ifdef KDEXT_64BIT

struct _LIST_ENTRY_64
{
    ULONG64 Flink;
    ULONG64 Blink;
};

struct _RTL_CRITICAL_SECTION_64 
{
   ULONG64 DebugInfo;
   DWORD   LockCount;
   DWORD   RecursionCount;
   ULONG64 OwningThread;
   ULONG64 LockSemaphore;
   ULONG64 SpinCount;
};

struct _RTL_CRITICAL_SECTION_DEBUG_64
{
   WORD    Type;             
   WORD    CreatorBackTraceIndex;
   ULONG64 CriticalSection;  
   _LIST_ENTRY_64 ProcessLocksList;
   DWORD EntryCount;     
   DWORD ContentionCount;
   DWORD Spare;
};

#endif /*KDEXT_64BIT*/

DECLARE_API(cs64)
{
    INIT_API();
#ifdef KDEXT_64BIT

    _RTL_CRITICAL_SECTION_DEBUG_64 DebugInfo;
    _RTL_CRITICAL_SECTION_64 CritSec;
    _LIST_ENTRY_64 ListEntry;
    ULONG64  MemAddr = GetExpression(args);

    if (MemAddr)
    {
        ULONG64 AddrHead = MemAddr;
        if (ReadMemory(MemAddr,&ListEntry,sizeof(ListEntry),NULL))
        {
            DebugInfo.ProcessLocksList.Flink = ListEntry.Flink;
            while (DebugInfo.ProcessLocksList.Flink != AddrHead)
            {
        		if (CheckControlC())
        		    break;

        		MemAddr = DebugInfo.ProcessLocksList.Flink - FIELD_OFFSET(_RTL_CRITICAL_SECTION_DEBUG_64,ProcessLocksList);

        		if (ReadMemory((MEMORY_ADDRESS)MemAddr,&DebugInfo,sizeof(DebugInfo),NULL))
        		{
        		    dprintf("    C %p D %p\n",DebugInfo.CriticalSection,MemAddr);
        		    
                    if (ReadMemory((MEMORY_ADDRESS)DebugInfo.CriticalSection,&CritSec,sizeof(CritSec),NULL))
                    {
                        dprintf("    - CS %p %x %x %p\n",
                                CritSec.DebugInfo,
                                CritSec.LockCount,
                                CritSec.RecursionCount,
                                CritSec.OwningThread);
                    }
                    else
                    {
                        dprintf("RM %p\n",DebugInfo.CriticalSection);
                    }
        		}
        		else
        		{
        		    break;
        		}
            }
        }
        else
        {
            dprintf("RM %p\n",MemAddr);
        }
    }
    else
    {
        dprintf("unable to resolve %s\n",args);
    }
    
#endif /*KDEXT_64BIT*/    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmiexts\utilfun.h ===
#ifndef __UTILFUN_H__
#define __UTILFUN_H__

//
//
//  attempt to imitate the std::tree structures
//

class _BRN {
public:
	_BRN * _Left;
	_BRN * _Parent;
	_BRN * _Right;
	ULONG_PTR Values[3]; // Key Value Color
};

class _BRN_HEAD {
public:
	_BRN * _Left;
	_BRN * _Parent;
	_BRN * _Right;
};


class _QM {
public:
    _BRN * _Left;
	_BRN * _Parent;
	_BRN * _Right;
};

class _Map {
public:
	ULONG_PTR Unused;
	_QM * pQm;
	bool  b;
	ULONG_PTR Size;
};

//
//
//
class _Node_List {
public:
    _Node_List * _Next;
    _Node_List * _Prev;
    void *       _Value;
};

class _List {
public:
    void * _Allocator;
    _Node_List * _Head;
    SIZE_T _Size;
};

class _Vector{
public:
    void * _Allocator;
    void * _First;
    void * _Last;
    void * _End;    
};

typedef DWORD (WINAPI * pfnCallBack1)(VOID * pData1);
typedef DWORD (WINAPI * pfnCallBack2)(VOID * pData1,VOID * pData2);

void
PrintMapCB(_Map * pMap,BOOL Verbose, pfnCallBack2 CallBack);

void
PrintMap(_Map * pMap,BOOL Verbose);

DWORD
CallBackObj(void * pKey, void * pValue);

void
PrintListCB(_List * pList_OOP, pfnCallBack1 CallBack);

BOOL
GetVTable(MEMORY_ADDRESS pThis_OOP);

void
EnumReverseLinkedListCB(IN LIST_ENTRY  * pListHead,
                        IN DWORD         cbSizeOfStructure,
                        IN DWORD         cbListEntryOffset,
                        IN pfnCallBack2  CallBack);

//
// For Dumping CThreadRecord
//
typedef DWORD (WINAPI * pfnDumpRequest)(ULONG_PTR pRequest);

#endif /*__UTILFUN_H__*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmiexts\heappagi.h ===
/*++

Copyright (c) 1994-2000  Microsoft Corporation

Module Name:

    heappagi.h

Abstract:

    The following definitions are internal to the debug heap manager,
    but are placed in this include file so that debugger extensions
    can reference the same structure definitions.  The following
    definitions are not intended to be referenced externally except
    by debugger extensions.

Author:

    Tom McGuire (TomMcg) 06-Jan-1995
    Silviu Calinoiu (SilviuC) 22-Feb-2000

Revision History:

--*/

#ifndef _HEAP_PAGE_I_
#define _HEAP_PAGE_I_

#ifdef DEBUG_PAGE_HEAP

#include "heap.h"

#define DPH_INTERNAL_DEBUG      0   // change to 0 or #undef for production code

//
// Stack trace size. 
//
                                
#define DPH_MAX_STACK_LENGTH   16

//
// Capture stacktraces in any context (x86/alpha, fre/chk). On alpha
// the stack acquisition function will fail and no stack trace will be
// acquired but in case we will find a better algorithm the page heap
// code will automatically take advantage of that.
//

#define DPH_CAPTURE_STACK_TRACE 1

//
// DPH_HEAP_BLOCK
//

typedef struct _DPH_HEAP_BLOCK DPH_HEAP_BLOCK, *PDPH_HEAP_BLOCK;

struct _DPH_HEAP_BLOCK {

    //
    //  Singly linked list of allocations (pNextAlloc must be
    //  first member in structure).
    //

    PDPH_HEAP_BLOCK pNextAlloc;

    //
    //   | PAGE_READWRITE          | PAGE_NOACCESS           |
    //   |____________________|___||_________________________|
    //
    //   ^pVirtualBlock       ^pUserAllocation
    //
    //   |---------------- nVirtualBlockSize ----------------|
    //
    //   |---nVirtualAccessSize----|
    //
    //                        |---|  nUserRequestedSize
    //
    //                        |----|  nUserActualSize
    //

    PUCHAR pVirtualBlock;
    SIZE_T  nVirtualBlockSize;

    SIZE_T  nVirtualAccessSize;
    PUCHAR pUserAllocation;
    SIZE_T  nUserRequestedSize;
    SIZE_T  nUserActualSize;
    PVOID  UserValue;
    ULONG  UserFlags;

    PRTL_TRACE_BLOCK StackTrace_;
};


typedef struct _DPH_HEAP_ROOT DPH_HEAP_ROOT, *PDPH_HEAP_ROOT;

struct _DPH_HEAP_ROOT {

    //
    //  Maintain a signature (DPH_HEAP_SIGNATURE) as the
    //  first value in the heap root structure.
    //

    ULONG                 Signature;
    ULONG                 HeapFlags;

    //
    //  Access to this heap is synchronized with a critical section.
    //

    PRTL_CRITICAL_SECTION HeapCritSect;
    ULONG                 nRemoteLockAcquired;

    //
    //  The "VirtualStorage" list only uses the pVirtualBlock,
    //  nVirtualBlockSize, and nVirtualAccessSize fields of the
    //  HEAP_ALLOCATION structure.  This is the list of virtual
    //  allocation entries that all the heap allocations are
    //  taken from.
    //

    PDPH_HEAP_BLOCK  pVirtualStorageListHead;
    PDPH_HEAP_BLOCK  pVirtualStorageListTail;
    ULONG                 nVirtualStorageRanges;
    SIZE_T                 nVirtualStorageBytes;

    //
    //  The "Busy" list is the list of active heap allocations.
    //  It is stored in LIFO order to improve temporal locality
    //  for linear searches since most initial heap allocations
    //  tend to remain permanent throughout a process's lifetime.
    //

    PDPH_HEAP_BLOCK  pBusyAllocationListHead;
    PDPH_HEAP_BLOCK  pBusyAllocationListTail;
    ULONG                 nBusyAllocations;
    SIZE_T                 nBusyAllocationBytesCommitted;

    //
    //  The "Free" list is the list of freed heap allocations, stored
    //  in FIFO order to increase the length of time a freed block
    //  remains on the freed list without being used to satisfy an
    //  allocation request.  This increases the odds of catching
    //  a reference-after-freed bug in an app.
    //

    PDPH_HEAP_BLOCK  pFreeAllocationListHead;
    PDPH_HEAP_BLOCK  pFreeAllocationListTail;
    ULONG                 nFreeAllocations;
    SIZE_T                 nFreeAllocationBytesCommitted;

    //
    //  The "Available" list is stored in address-sorted order to facilitate
    //  coalescing.  When an allocation request cannot be satisfied from the
    //  "Available" list, it is attempted from the free list.  If it cannot
    //  be satisfied from the free list, the free list is coalesced into the
    //  available list.  If the request still cannot be satisfied from the
    //  coalesced available list, new VM is added to the available list.
    //

    PDPH_HEAP_BLOCK  pAvailableAllocationListHead;
    PDPH_HEAP_BLOCK  pAvailableAllocationListTail;
    ULONG                 nAvailableAllocations;
    SIZE_T                 nAvailableAllocationBytesCommitted;

    //
    //  The "UnusedNode" list is simply a list of available node
    //  entries to place "Busy", "Free", or "Virtual" entries.
    //  When freed nodes get coalesced into a single free node,
    //  the other "unused" node goes on this list.  When a new
    //  node is needed (like an allocation not satisfied from the
    //  free list), the node comes from this list if it's not empty.
    //

    PDPH_HEAP_BLOCK  pUnusedNodeListHead;
    PDPH_HEAP_BLOCK  pUnusedNodeListTail;
    ULONG                 nUnusedNodes;

    SIZE_T                 nBusyAllocationBytesAccessible;

    //
    //  Node pools need to be tracked so they can be protected
    //  from app scribbling on them.
    //

    PDPH_HEAP_BLOCK  pNodePoolListHead;
    PDPH_HEAP_BLOCK  pNodePoolListTail;
    ULONG                 nNodePools;
    SIZE_T                 nNodePoolBytes;

    //
    //  Doubly linked list of DPH heaps in process is tracked through this.
    //

    PDPH_HEAP_ROOT        pNextHeapRoot;
    PDPH_HEAP_ROOT        pPrevHeapRoot;

    ULONG                 nUnProtectionReferenceCount;
    ULONG                 InsideAllocateNode;           // only for debugging

    //
    // These are extra flags used to control page heap behavior.
    // During heap creation the current value of the global page heap
    // flags (process wise) is written into this field.
    //

    ULONG                 ExtraFlags;

    //
    // Seed for the random generator used to decide from where
    // should we make an allocation (normal or verified heap).
    // The field is protected by the critical section associated
    // with each page heap.
    //

    ULONG                  Seed;

    //
    // `NormalHeap' is used in case we want to combine verified allocations
    // with normal ones. This is useful to minimize memory impact. Without
    // this feature certain processes that are very heap intensive cannot
    // be verified at all.
    //

    PVOID                 NormalHeap;

    //
    // Heap creation stack trace.
    //

    PRTL_TRACE_BLOCK      CreateStackTrace;

    //
    // Thread ID of the first thread inside the heap.
    //

    HANDLE FirstThread;
};


//
// DPH_BLOCK_INFORMATION
//
// This structure is stored in every page heap allocated block.
// This information is not saved if the catch backward overruns
// flag is set.
//

#define DPH_NORMAL_BLOCK_START_STAMP_ALLOCATED   0xABCDAAAA
#define DPH_NORMAL_BLOCK_END_STAMP_ALLOCATED     0xDCBAAAAA
#define DPH_NORMAL_BLOCK_START_STAMP_FREE        (0xABCDAAAA - 1)
#define DPH_NORMAL_BLOCK_END_STAMP_FREE          (0xDCBAAAAA - 1)

#define DPH_PAGE_BLOCK_START_STAMP_ALLOCATED     0xABCDBBBB
#define DPH_PAGE_BLOCK_END_STAMP_ALLOCATED       0xDCBABBBB
#define DPH_PAGE_BLOCK_START_STAMP_FREE          (0xABCDBBBB - 1)
#define DPH_PAGE_BLOCK_END_STAMP_FREE            (0xDCBABBBB - 1)

#define DPH_NORMAL_BLOCK_SUFFIX 	0xA0
#define DPH_PAGE_BLOCK_PREFIX 	    0xB0
#define DPH_PAGE_BLOCK_INFIX 	    0xC0
#define DPH_PAGE_BLOCK_SUFFIX 	    0xD0
#define DPH_NORMAL_BLOCK_INFIX 	    0xE0
#define DPH_FREE_BLOCK_INFIX 	    0xF0

typedef struct _DPH_BLOCK_INFORMATION {

    ULONG StartStamp;

    PVOID Heap;
    SIZE_T RequestedSize;
    SIZE_T ActualSize;

    union {
        LIST_ENTRY FreeQueue;
        USHORT TraceIndex;
    };

    PVOID StackTrace_;
    
    ULONG EndStamp;

    //
    // (SilviuC): This structure needs to be 8-byte aligned.
    // If it is not, applications expecting aligned blocks will get
    // unaligned ones because this structure will prefix their
    // allocations. Internet Explorer is one such application
    // that stops working in these conditions.
    //

} DPH_BLOCK_INFORMATION, * PDPH_BLOCK_INFORMATION;

//
// Error reasons used in debug messages
//

#define DPH_SUCCESS                           0x0000
#define DPH_ERROR_CORRUPTED_START_STAMP       0x0001
#define DPH_ERROR_CORRUPTED_END_STAMP         0x0002
#define DPH_ERROR_CORRUPTED_HEAP_POINTER      0x0004
#define DPH_ERROR_CORRUPTED_PREFIX_PATTERN    0x0008
#define DPH_ERROR_CORRUPTED_SUFFIX_PATTERN    0x0010
#define DPH_ERROR_RAISED_EXCEPTION            0x0020
#define DPH_ERROR_NO_NORMAL_HEAP              0x0040
#define DPH_ERROR_CORRUPTED_INFIX_PATTERN     0x0080
#define DPH_ERROR_DOUBLE_FREE                 0x0100


#endif // DEBUG_PAGE_HEAP

#endif // _HEAP_PAGE_I_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmiexts\threadutil.cpp ===
#include <wmiexts.h>
#include <malloc.h>


void GetTeb(HANDLE hThread,TEB ** ppTeb)
{
	NTSTATUS Status;
	ULONG Long;
	THREAD_BASIC_INFORMATION TBasicInfo;
	Status = NtQueryInformationThread(hThread,
	                                  ThreadBasicInformation,
	                                  &TBasicInfo,
	                                  sizeof(TBasicInfo),
	                                  &Long);
	                                      
	if ( Status == 0 )
	{
	    //dprintf("        %p %x.%x\n",TBasicInfo.TebBaseAddress,TBasicInfo.ClientId.UniqueProcess,TBasicInfo.ClientId.UniqueThread);
	    if (ppTeb)
	    {
	        *ppTeb = TBasicInfo.TebBaseAddress;
	    }
	}
	else
	{
	   dprintf("    NtQueryInformationThread %08x\n",Status);
	}
}

void GetCid(HANDLE hThread,CLIENT_ID * pCid)
{
	NTSTATUS Status;
	ULONG Long;
	THREAD_BASIC_INFORMATION TBasicInfo;
	Status = NtQueryInformationThread(hThread,
	                                  ThreadBasicInformation,
	                                  &TBasicInfo,
	                                  sizeof(TBasicInfo),
	                                  &Long);
	                                      
	if ( Status == 0 )
	{
	    //dprintf("        %p %x.%x\n",TBasicInfo.TebBaseAddress,TBasicInfo.ClientId.UniqueProcess,TBasicInfo.ClientId.UniqueThread);
	    if (pCid)
	    {
	        memcpy(pCid,&TBasicInfo.ClientId, sizeof(CLIENT_ID));
	    }
	}
	else
	{
	   dprintf("    NtQueryInformationThread %08x\n",Status);
	}
}

void GetPeb(HANDLE hSourceProcess, PEB ** ppPeb, ULONG_PTR * pId)
{
    NTSTATUS Status;
    ULONG Long;
    PROCESS_BASIC_INFORMATION PBasicInfo;
    Status = NtQueryInformationProcess(hSourceProcess,
	                                  ProcessBasicInformation,
	                                  &PBasicInfo,
	                                  sizeof(PBasicInfo),
	                                  &Long);
	                                      
    if ( Status == 0 )
    {
        if (ppPeb)
        {
            *ppPeb = PBasicInfo.PebBaseAddress;
        }
        if (pId)
        {
            *pId = PBasicInfo.UniqueProcessId;
        }
    }
    else
    {
       dprintf("    NTSTATUS %08x\n",Status);
    }
 }

//
void PrintHandleBackTrace(HANDLE hHandle,WCHAR * pFileName)
{
    WCHAR pPath[MAX_PATH+1];
    GetEnvironmentVariableW(L"windir",pPath,MAX_PATH);
    lstrcatW(pPath,L"\\system32\\");
    lstrcatW(pPath,pFileName);
    
    HANDLE hFile = NULL; 
    hFile = CreateFileW(pPath,
                       GENERIC_READ,
                       FILE_SHARE_READ|FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       0,NULL);
                       
    if (INVALID_HANDLE_VALUE != hFile)
    {
	    DWORD dwSize = GetFileSize(hFile,NULL);
    	HANDLE hFileMap = CreateFileMapping(hFile,
                                            NULL,
                                            PAGE_READONLY,
                                            0,
                                            dwSize,
                                            NULL);
        if (hFileMap)
        {
       		HANDLE * pHandle = (HANDLE *)MapViewOfFile(hFileMap,
                                        FILE_MAP_READ,
                                        0,0,0);
            
            if(pHandle)
            {
                //dprintf("hEvent %p dwSize %x\n",hEvent,dwSize);
                DWORD SizeRecord = 8*sizeof(HANDLE);
                DWORD nRecord = dwSize/SizeRecord;
                HANDLE * pThisHandle = NULL;
                DWORD i;

                if (hHandle)
                {
	                for(i=0;i<nRecord;i++)
	                {
	                    if (hHandle == pHandle[(SizeRecord/sizeof(HANDLE))*(nRecord-1-i)])
	                    {
	                        pThisHandle = &pHandle[(SizeRecord/sizeof(HANDLE))*(nRecord-1-i)];
	                        break;
	                    }
	                    else
	                    {
	                        //dprintf(" %d %p\n",nRecord-1-i,pHandle[(SizeRecord/sizeof(HANDLE))*(nRecord-1-i)]);
	                    }
	                }
	                if(pThisHandle)
	                {
	                    dprintf(" found rec %x handle %p\n",nRecord-1-i,*pThisHandle);
	                    PrintStackTrace((ULONG_PTR)pThisHandle+sizeof(HANDLE),7,FALSE);
	                }
	                else
	                {
	                    dprintf("handle %x not found\n",hHandle);
	                }
                }
                else // print all of them
                {
                    dprintf("all records\n");
	                for(i=0;i<nRecord;i++)
	                {
		                pThisHandle = &pHandle[(SizeRecord/sizeof(HANDLE))*(nRecord-1-i)];
		                dprintf(" ------ %p\n",*pThisHandle);
   	                    PrintStackTrace((ULONG_PTR)pThisHandle+sizeof(HANDLE),7,FALSE);
   	                    
   	                    if (CheckControlC())
   	                        break;
                    }                    
                }
                UnmapViewOfFile(pHandle);
            }
            else
            {
	            dprintf("MapViewOfFile %d\n",GetLastError());
            }
            CloseHandle(hFileMap);
        }
        else
        {
	        dprintf("CreateFileMapping %d\n",GetLastError());
        };
        
        CloseHandle(hFile);
    }
    else
    {
        dprintf("CreateFile %S %d\n",pPath,GetLastError());
    }

}

//

DECLARE_API( refcnt )
{
    INIT_API();
    PrintHandleBackTrace(NULL,L"refcount.dat");
}

//

DECLARE_API( evtst )
{
    INIT_API();

    ULONG_PTR Addr = GetExpression(args);
    HANDLE hEvent = (HANDLE)Addr;

    if (hEvent)
    {
        PrintHandleBackTrace(hEvent,L"events.dat");
    }
}

#define INCREMENT_ALLOC (4*1024)

char * g_HandleType[] = 
{
    "",
    "",
    "",
    "",
    "Event",
    "",
    "",
    "",
    "",
    "Token",
    "",
    "",
    "",
    "",
    "",
    "", // 15
    "", 
    "",
    "",
    "",
    "Port",
    "", 
    "",
    "",
    "",
    "", 
    "",
    "",
    "",
    "", 
    "",
    "",
    "",
    "", 
    "",
    "",
    ""
};

DECLARE_API( handle )
{
    INIT_API();

    NTSTATUS Status;
    SYSTEM_HANDLE_INFORMATION * pSysHandleInfo = NULL;
    DWORD dwSize = INCREMENT_ALLOC;
    DWORD nReturned;

    ULONG_PTR lProcId;
    GetPeb(hCurrentProcess,NULL,&lProcId);
    USHORT ProcId = (USHORT)lProcId;


alloc_again:

    pSysHandleInfo = (SYSTEM_HANDLE_INFORMATION *)HeapAlloc(GetProcessHeap(),0,dwSize);

    if (pSysHandleInfo)
    {
        Status = NtQuerySystemInformation(SystemHandleInformation,
                                          pSysHandleInfo,
                                          dwSize,
                                          &nReturned);
    }
    else
    {
         goto leave;
    }

    if (STATUS_INFO_LENGTH_MISMATCH == Status)
    {
        HeapFree(GetProcessHeap(),0,pSysHandleInfo);
        dwSize += INCREMENT_ALLOC;
        goto alloc_again;
    }
    else if (0 == Status)
    {
        // we have all the handles
        // SYSTEM_HANDLE_TABLE_ENTRY_INFO

        for (DWORD i=0; i < pSysHandleInfo->NumberOfHandles; i++)
        {
            if (ProcId == pSysHandleInfo->Handles[i].UniqueProcessId)
            {
                //dprintf(" %s - %x\n",
                //        g_HandleType[pSysHandleInfo->Handles[i].ObjectTypeIndex],
                //        pSysHandleInfo->Handles[i].HandleValue);
                if (4 == pSysHandleInfo->Handles[i].ObjectTypeIndex) 
                {
                    PrintHandleBackTrace((HANDLE)(pSysHandleInfo->Handles[i].HandleValue),L"events.dat");
                }
            }
            if (CheckControlC())
                break;
        }
    }
    else
    {
        dprintf("");
    }

leave:   
    if (pSysHandleInfo)
    {
        HeapFree(GetProcessHeap(),0,pSysHandleInfo);
    }
    return;
}
//
//
// Invoke a function in the remote process
//
//////////////////////////////////////////

DECLARE_API( inv )
{
    INIT_API();

    int Len = strlen(args);
    CHAR * pArgs = (CHAR *)_alloca((Len+1));
    lstrcpy(pArgs,(CHAR *)args);
    
    ULONG_PTR pFunction = 0;
    ULONG_PTR pArgument = 0;
    
    while (isspace(*pArgs))
    {
        pArgs++;
    }
     
    CHAR * pSaved = pArgs;
    
    while(!isspace(*pArgs)) pArgs++;
    // terminate string, if possible    
    if (isspace(*pArgs))
    {
        *pArgs = 0;
        pArgs++;
    }
    else
    {
        pArgs = NULL;
    }

    pFunction = GetExpression(pSaved);

    if (pArgs)
    {
        pArgument = GetExpression(pArgs);
    }

    dprintf("invoking %s(%p) @ %p\n",pSaved,pArgument,pFunction);

    DWORD dwID;
    HANDLE hThread = CreateRemoteThread(hCurrentProcess,
                                        NULL,
                                        0,
                                        (LPTHREAD_START_ROUTINE )pFunction,
                                        (LPVOID)pArgument,
                                        0,
                                        &dwID);
    if (hThread)
    {
        CLIENT_ID Cid;
        GetCid(hThread,&Cid);

        DEBUG_EVENT de;
        BOOL bRet = FALSE;
        BOOL StatusRemoteThreadCreated = FALSE;

wait_again:

        bRet = WaitForDebugEvent(&de,INFINITE);

        if (bRet)
        {            
    	            switch(de.dwDebugEventCode)
    	            {
    	            case OUTPUT_DEBUG_STRING_EVENT:
    	                {
    	                    OUTPUT_DEBUG_STRING_INFO * pDbgStr = &de.u.DebugString;
    	                    WCHAR * pData = new WCHAR[pDbgStr->nDebugStringLength+1];
    	                    if(pDbgStr->fUnicode)
    	                    {
    	                        ReadMemory((ULONG_PTR)pDbgStr->lpDebugStringData,pData,pDbgStr->nDebugStringLength*sizeof(WCHAR),NULL);
    	                        dprintf("%S",pData);    	                        
    	                    }
    	                    else
    	                    {
    	                        ReadMemory((ULONG_PTR)pDbgStr->lpDebugStringData,pData,pDbgStr->nDebugStringLength*sizeof(CHAR),NULL);
    	                        dprintf("%s",pData);
    	                    }
    	                    delete [] pData;
    	                }

                      	bRet = ContinueDebugEvent((DWORD)((DWORD_PTR)Cid.UniqueProcess),(DWORD)((DWORD_PTR)Cid.UniqueThread),DBG_CONTINUE);
                       	if (bRet)
                      	{
  	                        goto wait_again;
  	                    }
    	                break;
    	            case CREATE_THREAD_DEBUG_EVENT:
    	                if ((DWORD)((DWORD_PTR)Cid.UniqueProcess) == de.dwProcessId &&
        	        		(DWORD)((DWORD_PTR)Cid.UniqueThread) == de.dwThreadId)
        	    		{
        	    		    if (!StatusRemoteThreadCreated)
        	    		    {
            	    		    StatusRemoteThreadCreated = TRUE;
        	    		    }
        	    		}
        	    		else
        	    		{
		                    dprintf("%x.%x != %x.%x\n",
        	                    de.dwProcessId,de.dwThreadId,
            	                (DWORD)((DWORD_PTR)Cid.UniqueProcess),(DWORD)((DWORD_PTR)Cid.UniqueThread));
        	    		}
    	            	bRet = ContinueDebugEvent((DWORD)((DWORD_PTR)Cid.UniqueProcess),(DWORD)((DWORD_PTR)Cid.UniqueThread),DBG_CONTINUE);
                   		if (bRet)
                  		{
	                       	goto wait_again;
 	                    };
    	                break;
    	            case CREATE_PROCESS_DEBUG_EVENT:
    	            case EXIT_PROCESS_DEBUG_EVENT:

          	            //dprintf("DebugEventCode %08x for %x.%x\n",de.dwDebugEventCode,de.dwProcessId,de.dwThreadId);
   	                	bRet = ContinueDebugEvent((DWORD)((DWORD_PTR)Cid.UniqueProcess),(DWORD)((DWORD_PTR)Cid.UniqueThread),DBG_CONTINUE);
                   		if (bRet)
                  		{
	                       	goto wait_again;
 	                    };
          	            break;
    	            case EXCEPTION_DEBUG_EVENT:
    	                {
    	                    EXCEPTION_DEBUG_INFO  * pExcDebug = &de.u.Exception;
    	                    dprintf("%08x %08x FIRST? %d\n",
    	                            pExcDebug->ExceptionRecord.ExceptionCode,
    	                            pExcDebug->ExceptionRecord.ExceptionAddress,
    	                            pExcDebug->dwFirstChance);
    	                    bRet = ContinueDebugEvent((DWORD)((DWORD_PTR)Cid.UniqueProcess),(DWORD)((DWORD_PTR)Cid.UniqueThread),DBG_TERMINATE_THREAD);
    	                    if (bRet)
         	             	{
  	        	                goto wait_again;
  	            	        }
    	                }
    	                break;
    	            case EXIT_THREAD_DEBUG_EVENT:
    	                if ((DWORD)((DWORD_PTR)Cid.UniqueProcess) == de.dwProcessId &&
                  	        (DWORD)((DWORD_PTR)Cid.UniqueThread) == de.dwThreadId)
    	                {
    	                    if (StatusRemoteThreadCreated)
    	                    {
    	                        // ok
    	                    }
    	                    else
    	                    {
        	                    dprintf("EXIT_THREAD_DEBUG_EVENT %x.%x =?= %x.%x\n",
        	                            de.dwProcessId,de.dwThreadId,(DWORD)((DWORD_PTR)Cid.UniqueProcess),(DWORD)((DWORD_PTR)Cid.UniqueThread));
    	                    }
    	                    //
    	                    // we are done
    	                    //
    	                }
    	                else
    	                {
    	                	bRet = ContinueDebugEvent((DWORD)((DWORD_PTR)Cid.UniqueProcess),(DWORD)((DWORD_PTR)Cid.UniqueThread),DBG_CONTINUE);
                       		if (bRet)
                      		{
  	                        	goto wait_again;
	  	                    }    	                
    	                }
    	                break;
    	            case LOAD_DLL_DEBUG_EVENT:
    	            case UNLOAD_DLL_DEBUG_EVENT:
    	                //dprintf("DebugEventCode %08x for %x.%x CONTINUE\n",de.dwDebugEventCode,de.dwProcessId,de.dwThreadId);
    	                bRet = ContinueDebugEvent((DWORD)((DWORD_PTR)Cid.UniqueProcess),(DWORD)((DWORD_PTR)Cid.UniqueThread),DBG_CONTINUE);
                       	if (bRet)
                      	{
  	                        goto wait_again;
  	                    }
                        break;
    	            default:
    	                dprintf("DebugEventCode %08x\n ?????",de.dwDebugEventCode);        
    	                //ContinueDebugEvent((DWORD)Cid.UniqueProcess,(DWORD)Cid.UniqueThread,DBG_TERMINATE_THREAD);
    	            }    	                         
        }
        else
        {
            dprintf("WaitForDebugEvent err: %d\n",GetLastError());
        }
                
        CloseHandle(hThread);
    }
    else
    {
        dprintf("CreateRemoteThread %d\n",GetLastError());
    }

}



//
//
//  Dumps the thread list with some info on OLE and RPC
//
//

//
//
//   rpcrt4!THREAD
//   ole32!SOleTlsData
//

void 
DumpRpcOle(ULONG_PTR pRpc,ULONG_PTR pOle)
{
    if (pRpc)
    {

        ULONG OffsetContext;
        ULONG_PTR pRpcLRPC = 0;
        if (0 != GetFieldOffset("rpcrt4!THREAD","Context",&OffsetContext))
        {
        #ifdef _WIN64
            OffsetContext = 0x18;
        #else
            OffsetContext = 0x10;
        #endif
        }
        
        ReadMemory(pRpc+OffsetContext,&pRpcLRPC,sizeof(ULONG_PTR),0);
        
        ULONG_PTR pFirstVoid = 0;
        ReadMemory((ULONG_PTR)pRpcLRPC,&pFirstVoid,sizeof(ULONG_PTR),0);

        BYTE pString[256];
	    pString[0]=0;

#ifdef KDEXT_64BIT
        ULONG64 Displ;
#else
        ULONG Displ;
#endif
        if (pFirstVoid)
    	    GetSymbol(pFirstVoid,(PCHAR)pString,&Displ);
	    if (lstrlenA((CHAR *)pString))
	    {
	        dprintf("        %s+%x %p\n",pString,Displ,pRpcLRPC);
	        if (strstr((const char *)pString,"LRPC_SCALL"))
	        {
	            ULONG OffsetCID;
	            if (0 != GetFieldOffset("rpcrt4!LRPC_SCALL","ClientId",&OffsetCID))
        		{
#ifdef _WIN64
		            OffsetCID = 0x100;
#else
        		    OffsetCID = 0xa0;
#endif
        		}
                CLIENT_ID CID;
                ReadMemory(pRpcLRPC+OffsetCID,&CID,sizeof(CLIENT_ID),NULL);
                dprintf("        - - - - called from: %x.%x\n",CID.UniqueProcess,CID.UniqueThread);
        		
	        }
	    } 
	    else
	    {        
            dprintf("        rpcrt4!THREAD.Context %p\n",pRpcLRPC);
        }
    }
    if (pOle)
    {
        ULONG OffsetCallContext;
        ULONG_PTR pCallCtx = 0;
        if (0 != GetFieldOffset("ole32!SOleTlsData","pCallContext",&OffsetCallContext))
        {
        #ifdef _WIN64
            OffsetCallContext = 0x88;
        #else
            OffsetCallContext = 0x54;
        #endif
        }
        ReadMemory(pOle+OffsetCallContext,&pCallCtx,sizeof(ULONG_PTR),0);
        
        dprintf("        ole32!CServerSecurity %p\n",pCallCtx);
    }
}

//
//
// call HeapFree(GetProcessHeap) on the OUT pointers
//
//////////////////////////////////////////////////////

DWORD
GetThreadArrays(HANDLE hCurrentProcess,
                DWORD * pdwThreads,
                SYSTEM_EXTENDED_THREAD_INFORMATION ** ppExtThreadInfo,
                TEB *** pppTebs)
{

    if (!pdwThreads || !ppExtThreadInfo || !pppTebs)
    {
        return ERROR_INVALID_PARAMETER;
    };

    NTSTATUS Status;
    DWORD dwInc = 8*1024;
    DWORD dwSize = dwInc;
    VOID * pData = NULL;
    DWORD dwReturned;

loop_realloc:    
    pData = HeapAlloc(GetProcessHeap(),0,dwSize);
    if (!pData)
    {
        return ERROR_OUTOFMEMORY;
    }
    
    Status = NtQuerySystemInformation(SystemExtendedProcessInformation,
                                      pData,
                                      dwSize,
                                      &dwReturned);
                                      
    if (STATUS_INFO_LENGTH_MISMATCH == Status)
    {
        HeapFree(GetProcessHeap(),0,pData);    
        dwSize += dwInc;
        goto loop_realloc;
    } 
    else if (STATUS_SUCCESS == Status)
    {
        // here we have the snapshot:parse it
        SYSTEM_PROCESS_INFORMATION * pProcInfo = (SYSTEM_PROCESS_INFORMATION *)pData;
        SYSTEM_EXTENDED_THREAD_INFORMATION * pThreadInfo;

        // get the process id;
        
        ULONG_PTR IdProc;
        GetPeb(hCurrentProcess,NULL,&IdProc);
        
        while (TRUE)
        {
            //dprintf("    process %p curr %p\n",pProcInfo->UniqueProcessId,IdProc);
            if (IdProc == (ULONG_PTR)pProcInfo->UniqueProcessId)
            {
                DWORD Threads = pProcInfo->NumberOfThreads;
                *pdwThreads = Threads;
                DWORD i;
                pThreadInfo = (SYSTEM_EXTENDED_THREAD_INFORMATION *)((ULONG_PTR)pProcInfo+sizeof(SYSTEM_PROCESS_INFORMATION));

                SYSTEM_EXTENDED_THREAD_INFORMATION * pOutThreadInfo = NULL;
                TEB ** ppOutTebs = NULL;
                
                pOutThreadInfo = (SYSTEM_EXTENDED_THREAD_INFORMATION *)HeapAlloc(GetProcessHeap(),0,Threads*sizeof(SYSTEM_EXTENDED_THREAD_INFORMATION));
                if (pOutThreadInfo)
                {
                    ppOutTebs = (TEB **)HeapAlloc(GetProcessHeap(),0,Threads*sizeof(TEB *));
                    if (!ppOutTebs)
                    {
                        HeapFree(GetProcessHeap(),0,pOutThreadInfo);
	                    Status = ERROR_OUTOFMEMORY;
    	                Threads = 0; // to stop loop            
                    }
                    else
                    {
                        memcpy(pOutThreadInfo,pThreadInfo,Threads*sizeof(SYSTEM_EXTENDED_THREAD_INFORMATION));
                    }
                }
                else
                {
                    Status = ERROR_OUTOFMEMORY;
                    Threads = 0; // to stop loop
                }
                                               
                for (i=0;i<Threads;i++)
                {
                    //dprintf("    %x.%x\n",pThreadInfo->ThreadInfo.ClientId.UniqueProcess,pThreadInfo->ThreadInfo.ClientId.UniqueThread);

                    NTSTATUS StatusThread;
                    HANDLE hThread;
                    OBJECT_ATTRIBUTES Obja = {sizeof( OBJECT_ATTRIBUTES ), 0, 0, 0 ,0 };
                        
                    StatusThread = NtOpenThread(&hThread,THREAD_QUERY_INFORMATION,&Obja,&(pThreadInfo->ThreadInfo.ClientId));
                    if (((NTSTATUS)0L) == StatusThread)
                    {
                        TEB * pTeb = NULL;
                        GetTeb(hThread,&pTeb);

                        ppOutTebs[i] = pTeb;
                        
                        CloseHandle(hThread);
                    }
                    else
                    {
                        dprintf("NtOpenThread %d\n",StatusThread);
                    }
                    
                    pThreadInfo++;
                }
                // once found our process, 
                // don't bother with the others
                *pppTebs = ppOutTebs;
                *ppExtThreadInfo = pOutThreadInfo;
                Status = NO_ERROR;
                break;
            }
            if (0 == pProcInfo->NextEntryOffset)
            {
                break;
            }
            else
            {
                pProcInfo = (SYSTEM_PROCESS_INFORMATION *)((ULONG_PTR)pProcInfo+pProcInfo->NextEntryOffset);
            }
        }
        
    } 
    else // other cases
    {
        dprintf("NtQuerySystemInformation %08x\n",Status);
        return Status;
    }

    return Status;
}

DECLARE_API(t)
{
    INIT_API();

    DWORD dwThreads;
    TEB ** ppTebs;
    SYSTEM_EXTENDED_THREAD_INFORMATION * pSysThreadInfo;

    // get the offsets only once 
    ULONG OffsetRPC;
    ULONG_PTR pRpcThread;
    if (0 != GetFieldOffset("ntdll!TEB","ReservedForNtRpc",&OffsetRPC))
    {
    #ifdef _WIN64
        OffsetRPC = 0x1698;
    #else
        OffsetRPC = 0xf1c;
    #endif
    }    
    ULONG OffsetOLE;
    ULONG_PTR pOleThread;
    if (0 != GetFieldOffset("ntdll!TEB","ReservedForOle",&OffsetOLE))
    {
    #ifdef _WIN64
        OffsetOLE = 0x1758;
    #else
        OffsetOLE = 0xf80;
    #endif                        
    }    

    if (NO_ERROR == GetThreadArrays(hCurrentProcess,&dwThreads,
                                    &pSysThreadInfo,&ppTebs))
    {
        for (DWORD i=0;i<dwThreads;i++)
        {
            TEB * pTeb = ppTebs[i];
            SYSTEM_EXTENDED_THREAD_INFORMATION * pThreadInfo = &pSysThreadInfo[i];
            
            if (ReadMemory((ULONG_PTR)pTeb+OffsetOLE,&pOleThread,sizeof(ULONG_PTR),0) &&
                ReadMemory((ULONG_PTR)pTeb+OffsetRPC,&pRpcThread,sizeof(ULONG_PTR),0))
            {

                        NT_TIB NtTib;
                        ReadMemory((ULONG_PTR)pTeb,&NtTib,sizeof(NT_TIB),NULL);

                        dprintf("    %03d %x.%x Addr: %p TEB:  %p FiberData %p\n"
                                "                   limit %p base  %p\n"
                                "                   RPC   %p OLE   %p\n",
                                i,
                                pThreadInfo->ThreadInfo.ClientId.UniqueProcess,pThreadInfo->ThreadInfo.ClientId.UniqueThread,
                                pThreadInfo->Win32StartAddress,
                                pTeb,NtTib.FiberData,
                                NtTib.StackLimit,NtTib.StackBase,
                                pRpcThread,
                                pOleThread);

#ifdef _WIN64

//   +0x1788 DeallocationBStore : (null)
//   +0x1790 BStoreLimit      : 0x000006fb`faba2000

                        ULONG_PTR lDeAlloc;
                        ULONG_PTR lBPLimit;
                        ULONG Offset_DeallocationBStore = 0x1788;
                        ReadMemory((ULONG_PTR)pTeb+Offset_DeallocationBStore,&lDeAlloc,sizeof(ULONG_PTR),0);

                        ULONG Offset_BStoreLimit = 0x1790;
                        ReadMemory((ULONG_PTR)pTeb+Offset_BStoreLimit,&lBPLimit,sizeof(ULONG_PTR),0);

                        dprintf("               DAll  %p BStL %p\n",lDeAlloc,lBPLimit);
#endif

                        DumpRpcOle(pRpcThread,pOleThread);
            }
            else
            {
                dprintf("RM %p %p\n",(ULONG_PTR)pTeb+OffsetOLE,(ULONG_PTR)pTeb+OffsetRPC);
            }
        }
        
        HeapFree(GetProcessHeap(),0,ppTebs);
        HeapFree(GetProcessHeap(),0,pSysThreadInfo);
        
    }

}


DECLARE_API(srt)
{
    INIT_API();

    DWORD dwThreads;
    TEB ** ppTebs;
    SYSTEM_EXTENDED_THREAD_INFORMATION * pSysThreadInfo;

    ULONG_PTR Addr = GetExpression(args);
    ULONG_PTR * ThreadMem = NULL;
    ULONG_PTR Size = 0;

    if (NO_ERROR == GetThreadArrays(hCurrentProcess,&dwThreads,
                                    &pSysThreadInfo,&ppTebs))
    {
        for (DWORD i=0;i<dwThreads;i++)
        {
            TEB * pTeb = ppTebs[i];
            SYSTEM_EXTENDED_THREAD_INFORMATION * pThreadInfo = &pSysThreadInfo[i];

            NT_TIB NtTib;
            ReadMemory((ULONG_PTR)pTeb,&NtTib,sizeof(NT_TIB),NULL);
            
            ULONG_PTR Base  = (ULONG_PTR)NtTib.StackBase;
            ULONG_PTR Limit = (ULONG_PTR)NtTib.StackLimit;
            ULONG_PTR CurrSize = Base-Limit;

            //dprintf("searching %p between %p and %p\n",Addr,Limit,Base);

            if (CurrSize > Size)
            {
                Size = CurrSize;
                if (ThreadMem)
                {
                    HeapFree(GetProcessHeap(),0,ThreadMem);
                    ThreadMem = NULL;
                }
                ThreadMem = (ULONG_PTR *)HeapAlloc(GetProcessHeap(),0,Size);
                
            }
            if (ThreadMem)
            {
                if (ReadMemory(Limit,ThreadMem,(ULONG)CurrSize,NULL))
                {
                    for(DWORD j=0;j<CurrSize/sizeof(ULONG_PTR);j++)
                    {
                        if (Addr == ThreadMem[j])
                        {
                            dprintf("    %x.%x  %p\n",
                                    pThreadInfo->ThreadInfo.ClientId.UniqueProcess,pThreadInfo->ThreadInfo.ClientId.UniqueThread,
                                    Limit+((ULONG_PTR)&ThreadMem[j]-(ULONG_PTR)ThreadMem));
                        }
                    }
                }
            };            
        }

        HeapFree(GetProcessHeap(),0,ppTebs);
        HeapFree(GetProcessHeap(),0,pSysThreadInfo);
        
    }    

    if (ThreadMem)
        HeapFree(GetProcessHeap(),0,ThreadMem);
}


#if defined(_X86_)
    #ifndef PAGE_SIZE
    #define PAGE_SIZE   0x1000
    #endif
    #define USER_ALIGNMENT 8

#elif defined(_IA64_)
    #ifndef PAGE_SIZE
    #define PAGE_SIZE   0x2000
    #endif
    #define USER_ALIGNMENT 16

#elif defined(_AMD64_)
    #ifndef PAGE_SIZE
    #define PAGE_SIZE   0x1000
    #endif
    #define USER_ALIGNMENT 16

#else
    #error  // platform not defined
#endif

DECLARE_API(ksrt)
{
    INIT_API();

    char * pArgs = (char *)args;
    while(isspace(*pArgs)) pArgs++;

    ULONG_PTR EProcess = GetExpression(pArgs);

    while(!isspace(*pArgs)) pArgs++;

    ULONG_PTR SearchFor = GetExpression(pArgs);
    
    ULONG OffsetProcessThreadList;
    
    if (0 != GetFieldOffset("nt!_KPROCESS","ThreadListHead",&OffsetProcessThreadList))
    {
    #ifdef _WIN64
        OffsetProcessThreadList = 0x0;  // BUGBUG
    #else
        OffsetProcessThreadList = 0x050;
    #endif    
    }
    
    ULONG OffsetThreadThreadList;
    if (0 != GetFieldOffset("nt!_KTHREAD","ThreadListEntry",&OffsetThreadThreadList))
    {
    #ifdef _WIN64
        OffsetThreadThreadList = 0x0;
    #else
        OffsetThreadThreadList = 0x1b0; // BUGBUG
    #endif    
    }

    ULONG OffsetThreadTEB;
    if (0 != GetFieldOffset("nt!_KTHREAD","Teb",&OffsetThreadTEB))
    {
    #ifdef _WIN64
        OffsetThreadTEB = 0x0;
    #else
        OffsetThreadTEB = 0x020;        // BUGBUG
    #endif    
    }
    
    if (EProcess)
    {
        LIST_ENTRY HeadList;
        LIST_ENTRY * pListEntry = &HeadList;
        EProcess += OffsetProcessThreadList;

        DWORD SizeToRead = max(OffsetThreadTEB,OffsetThreadThreadList)+sizeof(LIST_ENTRY);
        ULONG_PTR KThreadAddr;
        ULONG_PTR Teb;
        
        ULONG_PTR * pKTHREAD = (ULONG_PTR *)_alloca(SizeToRead);
     
        if (ReadMemory(EProcess,&HeadList,sizeof(LIST_ENTRY),NULL))
        {
            DWORD i = 0;        
            while ((LIST_ENTRY *)EProcess != pListEntry->Flink)
            {
                //dprintf("pListEntry->Flink %p\n",pListEntry->Flink);
                
                KThreadAddr = (ULONG_PTR)pListEntry->Flink - (ULONG_PTR)OffsetThreadThreadList;
                if (ReadMemory((ULONG_PTR)KThreadAddr,pKTHREAD,SizeToRead,NULL))
                {
                    // do useful work
                    Teb = *((ULONG_PTR *)((BYTE *)pKTHREAD+OffsetThreadTEB));
                    dprintf("    %d - _KTHREAD %p TEB %p\n",i++,KThreadAddr,Teb);

                    NT_TIB ThreadTib;
                    if (ReadMemory(Teb,&ThreadTib,sizeof(NT_TIB),NULL))
                    {
                        dprintf("        EL %p B %p L %p\n",ThreadTib.ExceptionList,ThreadTib.StackBase,ThreadTib.StackLimit);

                        ULONG_PTR Current = (ULONG_PTR)ThreadTib.StackLimit;
                        ULONG_PTR nPages = (ULONG_PTR)ThreadTib.StackBase-(ULONG_PTR)ThreadTib.StackLimit;
                        nPages /= PAGE_SIZE;
                        ULONG_PTR j;
                        for (j=0;j<nPages;j++)
                        {
                            ULONG_PTR pPage[PAGE_SIZE/sizeof(ULONG_PTR)];
                            if (ReadMemory(Current,pPage,sizeof(pPage),NULL))
                            {
                                for(DWORD k=0;k<(PAGE_SIZE/sizeof(ULONG_PTR));k++)
                                {
                                    if(SearchFor == pPage[k])
                                    {
                                        dprintf("            %p\n",Current+k*sizeof(ULONG_PTR));
                                    }
					                if (CheckControlC())
                    					break;                                    
                                }
                            }
                            else
                            {
                                dprintf("    page @ %p not paged-in\n",Current);
                            }
                            Current += PAGE_SIZE;
                            
			                if (CheckControlC())
            			        break;                            
                        }
                    }
                    else
                    {
                        dprintf("    RM Teb %p\n",Teb);
                    }
                    
                    // equivalent of i++
                    pListEntry = (LIST_ENTRY *)((BYTE *)pKTHREAD+OffsetThreadThreadList);                    
                }
                else
                {
                    dprintf("RM %p\n",KThreadAddr);
                    break;
                }
                if (CheckControlC())
                    break;
            }
        }
        else
        {
            dprintf("RM %p\n",EProcess);
        }
    }
    else
    {
        dprintf("unable to resolve %s\n",args);
    }
}


#ifdef i386
#define MAGIC_START (16+2)
#endif

char *
GetCall(ULONG_PTR Addr)
{
    static char pBuff[1024];
    
#ifdef KDEXT_64BIT
    ULONG64   ThisAddr = Addr-2;
#else
    ULONG_PTR ThisAddr = Addr-2;
#endif    
    
    Disasm(&ThisAddr,pBuff,FALSE);
    if (strstr(pBuff,"call"))
    {
        dprintf("    %s\n",pBuff);
        return pBuff;
    }

    ThisAddr = Addr-3;
    Disasm(&ThisAddr,pBuff,FALSE);
    if (strstr(pBuff,"call"))
    {
        dprintf("    %s\n",pBuff);
        return pBuff;   
    }

    ThisAddr = Addr-5;
    Disasm(&ThisAddr,pBuff,FALSE);
    if (strstr(pBuff,"call"))
    {
        dprintf("    %s\n",pBuff);
        return pBuff;   
    }

    ThisAddr = Addr-6;
    Disasm(&ThisAddr,pBuff,FALSE);
    if (strstr(pBuff,"call"))
    {
        dprintf("    %s\n",pBuff);
        return pBuff;   
    }

    return NULL;
}

DECLARE_API(bs)
{

#ifdef i386
    INIT_API();

    ULONG_PTR pTeb = GetExpression(args);
    if (pTeb)
    {
        NT_TIB Tib;
        ReadMemory(pTeb,&Tib,sizeof(Tib),NULL);
        dprintf("    exception %p base %p limit %p\n",
                Tib.ExceptionList,Tib.StackBase,Tib.StackLimit);
                       
        ULONG_PTR dwSize = (ULONG_PTR)Tib.StackBase-(ULONG_PTR)Tib.StackLimit;
        BYTE * pStack = new BYTE[dwSize];
        ULONG_PTR OldEBP = 0;

        if (pStack)
        {
            ULONG_PTR * pBase  = (ULONG_PTR *)(pStack+dwSize);
            ULONG_PTR * pLimit = (ULONG_PTR *)pStack;
            
            ReadMemory((ULONG_PTR)Tib.StackLimit,pStack,(ULONG_PTR)Tib.StackBase-(ULONG_PTR)Tib.StackLimit,NULL);

            ULONG_PTR EBP = (ULONG_PTR)(Tib.StackBase)-(MAGIC_START*sizeof(ULONG_PTR));
            ULONG_PTR * pEBP = (ULONG_PTR *)pBase-MAGIC_START;
            BOOL bGoOn = TRUE;
            BOOL bRpcRt4Fix = FALSE;

            while(bGoOn)
            {
                dprintf("%p %p\n",pEBP[0],pEBP[1]);
                char * pFunction = GetCall(pEBP[1]);
                BOOL bFound = FALSE;

                if (pFunction)
                {
                    if (strstr(pFunction,"ComInvokeWithLockAndIPID"))
                    {
                        EBP -= 0x70;
                    }
                }
                else // try to move back
                {
                    pEBP--;
                    EBP = OldEBP;
                }
                
                //dprintf("looking for %p = cmp %p \n",EBP,pEBP[0]);                
                
                if (!bRpcRt4Fix)
                {
	                if (pEBP[0] < (ULONG_PTR)Tib.StackLimit || pEBP[0] > (ULONG_PTR)Tib.StackBase)
	                {
	                    bRpcRt4Fix = TRUE;
	                    // rpcrt4 call_stack fix
	                    EBP = (ULONG_PTR)(Tib.StackBase) - 0x6c;
	                }
                }
                //dprintf("looking for %p\n",EBP);                
                
                while ((ULONG_PTR)pEBP > (ULONG_PTR)pLimit){
                    if (*pEBP-- == EBP){
                        bFound = TRUE;
                        break;
                    }
                }
                if (bFound)
                {
                    pEBP++;
                    OldEBP = EBP;
                    EBP = (ULONG_PTR)(Tib.StackBase)-((ULONG_PTR)pBase-(ULONG_PTR)pEBP);
                }
                else
                {
                    bGoOn = FALSE;
                }
            }
            
            delete [] pStack;
        }
        
    }
    else
    {
        dprintf("%s cannot be interpreted\b",args);
    }
#endif    
}    

//
// given the TEB, prints the ExceptionList
//

struct _C9_REGISTRATION_RECORD
{
    _C9_REGISTRATION_RECORD * prev;
    void * handler;
    void * scopetable;
    void * trylevel;
    void * pSpare0;    
    void * pSpare1;      
};

DECLARE_API(el)
{
    INIT_API();

#ifndef _X86_
    dprintf("unsupported on this platform\n");
    return;
#endif
    
    ULONG_PTR pTeb = GetExpression(args);
    if (pTeb)
    {
        NT_TIB Tib;
        if (ReadMemory(pTeb,&Tib,sizeof(Tib),NULL))
        {
            //Tib.ExceptionList,Tib.StackBase,Tib.StackLimit);
            _C9_REGISTRATION_RECORD ExRegRec;
            ExRegRec.prev = (_C9_REGISTRATION_RECORD *)Tib.ExceptionList;
            do 
            {
   	            _C9_REGISTRATION_RECORD   * pThis = ExRegRec.prev;
	            if (ReadMemory((MEMORY_ADDRESS)pThis,&ExRegRec,sizeof(ExRegRec),NULL))
	            {
                    dprintf("  %p (%p %p %p %p)\n",pThis,ExRegRec.prev,ExRegRec.handler,ExRegRec.scopetable,ExRegRec.trylevel);

#ifdef KDEXT_64BIT
                    ULONG64 Displ;
#else
                    ULONG Displ;
#endif
                    char pString[256];
                    pString[0]=0;
             	    GetSymbol((ULONG_PTR)ExRegRec.handler,(PCHAR)pString,&Displ);
	                if (lstrlenA((CHAR *)pString))
              	        dprintf("    %s+%x\n",pString,Displ);

                    
                    if (!GetCall((ULONG_PTR)ExRegRec.pSpare1))
                    {
                        GetCall((ULONG_PTR)ExRegRec.pSpare0);
                    }
	            }
	            else
	            {
	                dprintf("RM %p\n",Tib.ExceptionList);
	                break;
	            }
            } while((ULONG_PTR)(-1) != (ULONG_PTR)ExRegRec.prev);
        }
        else
        {
            dprintf("RM %p\n",pTeb);
        }
    }
    else
    {
        dprintf("invalid TEB %s\n",args);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmiexts\provutil.cpp ===
/*++

Copyright (c) 2001-2001  Microsoft Corporation

Module Name:

    provutil.cpp
    
Revision History:

    ivanbrug     jan 2001 created

--*/

#include <wmiexts.h>
#include <utilfun.h>
#include <malloc.h>

#include <wbemint.h>

#ifdef SetContext
#undef SetContext
#endif

#include <ProvSubS.h>

//#include <provregdecoupled.h>
//#include <provdcaggr.h>

typedef ULONG_PTR CServerObject_DecoupledClientRegistration_Element;
typedef ULONG_PTR CDecoupledAggregator_IWbemProvider;

#include <provfact.h>


//
//
// Dump the Provider cache
//

typedef WCHAR * WmiKey;
typedef void *  WmiElement;
typedef WmiAvlTree<WmiKey,WmiElement>::WmiAvlNode  Node;

/*
class Node {
public:
    VOID * m_Key;
    Node * m_Left;
    Node * m_Right;
    Node * m_Parent;
    int    m_Status;
    VOID * m_Element;
};
*/

class NodeBind;
VOID DumpTreeBind(NodeBind * pNode_OOP,DWORD * pCount,BOOL * pbStop);

VOID
DumpTree(Node * pNode_OOP,DWORD * pCount,BOOL * pbStop)
{
    if (!pNode_OOP)
        return;

    if (CheckControlC())
    {
        if(pbStop)
            *pbStop = TRUE;
    }

    if (pbStop)
    {
        if (*pbStop) 
            return;
    }
    
    DEFINE_CPP_VAR(Node,MyNode);
    WCHAR pBuff[MAX_PATH+1];
	Node * pNode = GET_CPP_VAR_PTR(Node,MyNode);
    BOOL bRet;

    bRet = ReadMemory((ULONG_PTR)pNode_OOP,pNode,sizeof(Node),NULL);
    if (bRet)
    {
        
        DumpTree(pNode->m_Left,pCount,pbStop);
        
        //dprintf("--------\n");
        
        if (pCount) {
            *pCount++;
        };
                
        dprintf("    (L %p R %p P %p) %p\n",
                 //pNode->m_Key,
                 pNode->m_Left,
                 pNode->m_Right,
                 pNode->m_Parent,
                 pNode->m_State);                 
                 

        if (pNode->m_Key)
        {
            ReadMemory((ULONG_PTR)pNode->m_Key,pBuff,MAX_PATH*sizeof(WCHAR),NULL);
            pBuff[MAX_PATH] = 0;
            dprintf("    %S\n",pBuff);
        }

        dprintf("    - %p real %p\n",pNode->m_Element,((ULONG_PTR *)pNode->m_Element-4));
        if (pNode->m_Element)
        {
            GetVTable((MEMORY_ADDRESS)(pNode->m_Element));
            //
            // attention to the vtable trick !!!!
            //                  
	        DEFINE_CPP_VAR(CServerObject_BindingFactory,MyFactory);
    	    CServerObject_BindingFactory * pBindF = GET_CPP_VAR_PTR(CServerObject_BindingFactory,MyFactory);
        	BOOL bRet;
	        bRet = ReadMemory((ULONG_PTR)((ULONG_PTR *)pNode->m_Element-4),pBindF,sizeof(CServerObject_BindingFactory),NULL);
    	    if (bRet)
        	{
            	DumpTreeBind((NodeBind *)pBindF->m_Cache.m_Root,pCount,pbStop);
            }
        }
                  

        DumpTree(pNode->m_Right,pCount,pbStop);

    }    
}

DECLARE_API(pc) 
{

    INIT_API();

    ULONG_PTR Addr = GetExpression("wbemcore!CCoreServices__m_pProvSS");
    if (Addr) 
    {
        CServerObject_ProviderSubSystem * pProvSS_OOP = NULL;
        ReadMemory(Addr,&pProvSS_OOP,sizeof(void *),NULL);
        if (pProvSS_OOP)
        {
            dprintf("pProvSS %p\n",pProvSS_OOP);
            BOOL bRet;
	        DEFINE_CPP_VAR(CServerObject_ProviderSubSystem,MyProvSS);
	        CServerObject_ProviderSubSystem * pProvSS = GET_CPP_VAR_PTR(CServerObject_ProviderSubSystem,MyProvSS);

            bRet = ReadMemory((ULONG_PTR)pProvSS_OOP,pProvSS,sizeof(CServerObject_ProviderSubSystem),NULL);
            if (bRet)
            {
                DEFINE_CPP_VAR(CWbemGlobal_IWmiFactoryController_Cache,MyCacheNode);
                CWbemGlobal_IWmiFactoryController_Cache * pNodeCache = NULL; //GET_CPP_VAR_PTR(CWbemGlobal_IWmiFactoryController_Cache CacheNode,MyCacheNode);

                pNodeCache = &pProvSS->m_Cache;

                //dprintf("  root %p\n",pNodeCache->m_Root);
                DWORD Count = 0;
                BOOL  bStop = FALSE;
                DumpTree((Node *)pNodeCache->m_Root,&Count,&bStop);
                //dprintf("traversed %d nodes\n",Count);
            }            
        }
    } 
    else 
    {
        dprintf("invalid address %s\n",args);
    }
}

//
//
// CServerObject_BindingFactory
//
//////////////

class NodeBind 
{
public:
    ProviderCacheKey m_Key;
    NodeBind * m_Left;
    NodeBind * m_Right;
    NodeBind * m_Parent;
    int    m_State;
    //WmiCacheController<ProviderCacheKey>::WmiCacheElement 
    void * m_Element;
};


VOID
DumpTreeBind(NodeBind * pNode_OOP,DWORD * pCount,BOOL * pbStop)
{

    //dprintf("%p ????\n",pNode_OOP);

    if (!pNode_OOP)
        return;

    if (CheckControlC())
    {
        if(pbStop)
            *pbStop = TRUE;
    }

    if (pbStop)
    {
        if (*pbStop) 
            return;
    }
    
    DEFINE_CPP_VAR(NodeBind,MyNode);
    static WCHAR pBuff[MAX_PATH+1];
	NodeBind * pNode = GET_CPP_VAR_PTR(NodeBind,MyNode);
    BOOL bRet;

    bRet = ReadMemory((ULONG_PTR)pNode_OOP,pNode,sizeof(NodeBind),NULL);
    if (bRet)
    {
        
        DumpTreeBind(pNode->m_Left,pCount,pbStop);
        
        //dprintf("--------\n");
        
        if (pCount) {
            *pCount++;
        };
                
        dprintf("      - (L %p R %p P %p) %p\n",
                 pNode->m_Left,
                 pNode->m_Right,
                 pNode->m_Parent,
                 pNode->m_State);                 
                 

        if (pNode->m_Key.m_Provider)
        {
            ReadMemory((ULONG_PTR)pNode->m_Key.m_Provider,pBuff,MAX_PATH*sizeof(WCHAR),NULL);
            pBuff[MAX_PATH] = 0;
            dprintf("        Provider: %S\n",pBuff);
        }
        else
        {
	        dprintf("        Provider: %p\n",0);
        }
        dprintf("        Hosting : %08x\n",pNode->m_Key.m_Hosting);
        if (pNode->m_Key.m_Group)
        {
            ReadMemory((ULONG_PTR)pNode->m_Key.m_Group,pBuff,MAX_PATH*sizeof(WCHAR),NULL);
            pBuff[MAX_PATH] = 0;
            dprintf("        Group   : %S\n",pBuff);            
        }
        else
        {
            dprintf("        Group   : %p\n",0);
        }

        dprintf("        - %p\n",pNode->m_Element);
        if (pNode->m_Element)
        {
            GetVTable((MEMORY_ADDRESS)(pNode->m_Element));
        }

        DumpTreeBind(pNode->m_Right,pCount,pbStop);

    }    
}




DECLARE_API(pf) 
{

    INIT_API();
    
    ULONG_PTR Addr = GetExpression(args);
    if (Addr) 
    {
        DEFINE_CPP_VAR(CServerObject_BindingFactory,MyFactory);
        CServerObject_BindingFactory * pBindF = GET_CPP_VAR_PTR(CServerObject_BindingFactory,MyFactory);
        BOOL bRet;
        bRet = ReadMemory(Addr,pBindF,sizeof(CServerObject_BindingFactory),NULL);
        if (bRet)
        {
            dprintf("        root %p\n",pBindF->m_Cache.m_Root);
            DWORD Count = 0;
            BOOL  bStop = FALSE;
            DumpTreeBind((NodeBind *)pBindF->m_Cache.m_Root,&Count,&bStop);
        }
    }
    else 
    {
        dprintf("invalid address %s\n",args);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmiexts\repositutil.cpp ===
#include <wmiexts.h>

#include <utilfun.h>

#include <wbemint.h>
#include <tchar.h>

#include <sync.h>
#include <flexq.h>
#include <arrtempl.h>
#include <newnew.h>

#include <malloc.h>

#ifndef POLARITY
#define POLARITY
#endif

#ifndef RELEASE_ME
#define RELEASE_ME
#endif

#ifndef DELETE_ME
#define DELETE_ME
#endif

#ifndef INTERNAL
#define INTERNAL
#endif

#include <wstring.h>
#include <filecach.h>

#include <flexq.h>
#include <arrtempl.h>
#include <hiecache.h>
#include <creposit.h>

void
DumpMemManager(ULONG_PTR pByte)
{
        DEFINE_CPP_VAR( CTempMemoryManager, varCTempMemoryManager);
        CTempMemoryManager * pTmpAll = GET_CPP_VAR_PTR( CTempMemoryManager , varCTempMemoryManager );

        ReadMemory(pByte,pTmpAll,sizeof(CTempMemoryManager),0);

        dprintf("    m_dwTotalUsed       %08x\n",pTmpAll->m_dwTotalUsed);
        dprintf("    m_dwTotalAllocated  %08x\n",pTmpAll->m_dwTotalAllocated);
        dprintf("    m_dwNumAllocations  %08x\n",pTmpAll->m_dwNumAllocations);
        dprintf("    m_dwNumMisses       %08x\n",pTmpAll->m_dwNumMisses);

        DEFINE_CPP_VAR( CFlexArray, varArr);
        CFlexArray * pArr = GET_CPP_VAR_PTR(CFlexArray,varArr);
        
        DWORD i;
        ReadMemory((ULONG_PTR)pTmpAll->m_pAllocations,pArr,sizeof(CFlexArray),0);

        CTempMemoryManager::CAllocation ** pAllocs = (CTempMemoryManager::CAllocation **)_alloca(pArr->m_nSize*sizeof(void*));
        ReadMemory((ULONG_PTR)pArr->m_pArray,pAllocs,pArr->m_nSize*sizeof(void*),0);

        dprintf("    m_pArray %p %d\n",pArr->m_pArray,pArr->m_nSize);
        DWORD dwTotal = 0;
        for (i=0;i<pArr->m_nSize;i++)        
        {
            dprintf("    CAllocation %d - %p\n",i,pAllocs[i]);

            DEFINE_CPP_VAR( CTempMemoryManager::CAllocation, varCAllocation );
            CTempMemoryManager::CAllocation * pCAll = GET_CPP_VAR_PTR( CTempMemoryManager::CAllocation, varCAllocation );

            ReadMemory((ULONG_PTR)pAllocs[i],pCAll,sizeof(CTempMemoryManager::CAllocation),0);
            
            dprintf("      m_dwAllocationSize %p\n",pCAll->m_dwAllocationSize);
            dprintf("      m_dwUsed           %p\n",pCAll->m_dwUsed);
            dprintf("      m_dwFirstFree      %p\n",pCAll->m_dwFirstFree);
            dwTotal += pCAll->m_dwAllocationSize;

        }
        dprintf("      TOT %p\n",dwTotal);

}

//
//
// dumps the CTempMemoryManagers in repdrvfs
//
//////////////////////////////////////////////////////

DECLARE_API(tmpall) 
{
    INIT_API();

    ULONG_PTR pByte = GetExpression(args);

    if (pByte)
    {
        DumpMemManager(pByte);
        return;
    }
    
    pByte = GetExpression("repdrvfs!g_Manager");
    dprintf("repdrvfs!g_Manager @ %p\n",pByte);
    if (pByte)
    {
        DumpMemManager(pByte);
    }
}

//
//
//  this enum is copyed from btr.h
//
//

    enum { const_DefaultPageSize = 0x2000, const_CurrentVersion = 0x101 };

    enum {
        PAGE_TYPE_IMPOSSIBLE = 0x0,       // Not supposed to happen
        PAGE_TYPE_ACTIVE = 0xACCC,        // Page is active with data
        PAGE_TYPE_DELETED = 0xBADD,       // A deleted page on free list
        PAGE_TYPE_ADMIN = 0xADDD,         // Page zero only

        // All pages
        OFFSET_PAGE_TYPE = 0,             // True for all pages
        OFFSET_PAGE_ID = 1,               // True for all pages
        OFFSET_NEXT_PAGE = 2,             // True for all pages (Page continuator)

        // Admin Page (page zero) only
        OFFSET_LOGICAL_ROOT = 3,          // Root of database
        };

#define PS_PAGE_SIZE  (8192)

#define MIN_ARRAY_KEYS (256)
/*
void
DumpFile(HANDLE hFile,DWORD * pPage)
{
    // read the AdminPage
    BOOL bRet;
    DWORD nRead;
    bRet = ReadFile(hFile,pPage,PS_PAGE_SIZE,&nRead,0);

    if (bRet && (PS_PAGE_SIZE == nRead))
    {
        dprintf("    A %08x %08x %08x R %08x F %08x T %08x %08x %08x\n",
                pPage[OFFSET_PAGE_TYPE],
                pPage[OFFSET_PAGE_ID],
                pPage[OFFSET_NEXT_PAGE],
                pPage[OFFSET_LOGICAL_ROOT],
                pPage[OFFSET_FREE_LIST_ROOT],
                pPage[OFFSET_TOTAL_PAGES],
                pPage[OFFSET_PAGE_SIZE],
                pPage[OFFSET_IMPL_VERSION ]);
    }
    else
    {
        dprintf(" ReadFile %d\n",GetLastError());
    }

    // read the other pages
    DWORD i;
    DWORD dwTotPages = pPage[OFFSET_TOTAL_PAGES];
    for (i=1;i<dwTotPages;i++)
    {
        bRet = ReadFile(hFile,pPage,PS_PAGE_SIZE,&nRead,0);

        if (bRet && (PS_PAGE_SIZE == nRead))
        {
            dprintf("   %02x %08x %08x %08x - P %08x %08x %08x %08x\n",
                i,
                pPage[OFFSET_PAGE_TYPE],
                pPage[OFFSET_PAGE_ID],
                pPage[OFFSET_NEXT_PAGE],
                pPage[OFFSET_NEXT_PAGE+1], // Parent
                pPage[OFFSET_NEXT_PAGE+2], // NumKey
                pPage[OFFSET_NEXT_PAGE+2+pPage[OFFSET_NEXT_PAGE+2]], // UserData
                pPage[OFFSET_NEXT_PAGE+2+pPage[OFFSET_NEXT_PAGE+2]+1]); //ChildPageMap
        }
    }
    DWORD dwFileSize = GetFileSize(hFile,NULL);
    if (dwFileSize != (dwTotPages)*PS_PAGE_SIZE)
    {
        dprintf("    filesize %d expected %d\n",dwFileSize,((1+dwTotPages)*PS_PAGE_SIZE));
    }
}
*/

void PrintDWORDS(DWORD * pDW,DWORD nSize)
{
    DWORD i;
    for (i=0;i<(nSize/4);i++)
    {
        dprintf("    %08x  %08x %08x %08x %08x\n",i,
                pDW[0+i*4],pDW[1+i*4],pDW[2+i*4],pDW[3+i*4]);
    }

    if (nSize%4)
    {
	    DWORD dwPAD[4];
	    memset(dwPAD,0xff,sizeof(dwPAD));
	    memcpy(dwPAD,pDW+i*4,(nSize%4)*sizeof(DWORD));
	    
	    dprintf("    %08x  %08x %08x %08x %08x\n",i,
	                dwPAD[0],dwPAD[1],dwPAD[2],dwPAD[3]);
    }
}

void PrintWORDS(WORD * pDW,DWORD nSize)
{
    DWORD i;
    for (i=0;i<(nSize/8);i++)
    {
        dprintf("    %08x  %04x %04x %04x %04x %04x %04x %04x %04x\n",i,
                pDW[0+i*8],pDW[1+i*8],pDW[2+i*8],pDW[3+i*8],
                pDW[4+i*8],pDW[5+i*8],pDW[6+i*8],pDW[7+i*8]);
    }

    if (nSize%8)
    {
	    WORD dwPAD[8];
	    memset(dwPAD,0xff,sizeof(dwPAD));
	    memcpy(dwPAD,pDW+i*8,(nSize%8)*sizeof(WORD));
	    
	    dprintf("    %08x  %04x %04x %04x %04x %04x %04x %04x %04x\n",i,
	                dwPAD[0],dwPAD[1],dwPAD[2],dwPAD[3],
	                dwPAD[4],dwPAD[5],dwPAD[6],dwPAD[7]);
    }
}


void
DumpPage(DWORD * pPage)
{
    
    if (TRUE)
    {
        // here we've read the page

        if (0xACCC != pPage[OFFSET_PAGE_TYPE])
        {
            return;
        }
        
        dprintf("    SIGN %08x PAGE %08x NEXT %08x\n",
                pPage[OFFSET_PAGE_TYPE],pPage[OFFSET_PAGE_ID],pPage[OFFSET_NEXT_PAGE]);
        pPage+=3;

        dprintf("    PAR  %08x NUM  %08x\n",pPage[0],pPage[1]);
        DWORD dwParent = pPage[0];
        DWORD dwNumKey = pPage[1];
        pPage+=2;

        //DWORD dwAlloc = (dwNumKey<=MIN_ARRAY_KEYS)?MIN_ARRAY_KEYS:dwNumKey;

        //DWORD * m_pdwUserData     = HeapAlloc(GetProcessHeap(),0,sizeof(DWORD) *());
        //DWORD * m_pdwChildPageMap = HeapAlloc(GetProcessHeap(),0,sizeof(DWORD) *(1+));
        //WORD * m_pwKeyLookup     =  HeapAlloc(GetProcessHeap(),0,sizeof(WORD) * ());

        // dwNumKey   DWORD USER_DATA        
        // dwNumKey+1 DWORD CHILD_PAGE_MAP
        // dwNumKey   WORD  KEY_LOOKUP
        dprintf("    User Data\n");
        PrintDWORDS(pPage,dwNumKey);

        pPage+=dwNumKey;
        dprintf("    Child PageMap\n");
        PrintDWORDS(pPage,dwNumKey+1);
        
        pPage+=(dwNumKey+1);
        WORD * pKeyLookup = (WORD *)pPage;
        dprintf("    Key Lookup\n");
        PrintWORDS((WORD *)pPage,dwNumKey);

        WORD * pWPage = ((WORD *)pPage + dwNumKey);
        dprintf("    KEY CODE %08x\n",*pWPage);

        DWORD dwKeyUsed = *pWPage;
        pWPage++;
        WORD * pKeyCodes = pWPage;
        dprintf("    Key Codes\n");
        PrintWORDS((WORD *)pWPage,dwKeyUsed);

        pWPage += dwKeyUsed;
        DWORD dwNumStrings = *pWPage++; 
        dprintf("    NUM STRINGS %08x\n",dwNumStrings);

        WORD * ArrayOffsets = pWPage;
        dprintf("    Strings Offsets\n");
        PrintWORDS((WORD *)pWPage,dwNumStrings);
        
        pWPage += dwNumStrings;
        DWORD dwPoolUsed = *pWPage++;
        dprintf("    POOL USED %08x\n",dwPoolUsed);

        //
        DWORD i;
        LPSTR pStrings = (LPSTR)pWPage;

        for (i=0;i<dwNumStrings;i++)
        {
            dprintf("    %08x %04x %s\n",i,ArrayOffsets[i],pStrings+ArrayOffsets[i]);
        }
        //
        // better view
        //
        for (i=0;i<dwNumKey;i++)
        {
            DWORD j;
            WORD NumToken = pKeyCodes[pKeyLookup[i]];
            dprintf("        ( ");
            for (j=0;j<NumToken;j++)
            {
                dprintf("%04x ",pKeyCodes[pKeyLookup[i]+1+j]);
            }
            dprintf(")\n"); 

            dprintf("        - "); 
            for (j=0;j<NumToken;j++)
            {
                //pStrings+ArrayOffsets[i]
                dprintf("%s\\",pStrings+ArrayOffsets[pKeyCodes[pKeyLookup[i]+1+j]]);
            }
            dprintf("\n"); 
        }
    }
}


/*
void
DumpAllPages(HANDLE hFile,DWORD * pPage)
{
    // read the AdminPage
    BOOL bRet;
    DWORD nRead;
    bRet = ReadFile(hFile,pPage,PS_PAGE_SIZE,&nRead,0);

    if (bRet && (PS_PAGE_SIZE == nRead))
    {
        dprintf("    A %08x %08x %08x R %08x F %08x T %08x %08x %08x\n",
                pPage[OFFSET_PAGE_TYPE],
                pPage[OFFSET_PAGE_ID],
                pPage[OFFSET_NEXT_PAGE],
                pPage[OFFSET_LOGICAL_ROOT],
                pPage[OFFSET_FREE_LIST_ROOT],
                pPage[OFFSET_TOTAL_PAGES],
                pPage[OFFSET_PAGE_SIZE],
                pPage[OFFSET_IMPL_VERSION ]);
    }
    else
    {
        dprintf(" ReadFile %d\n",GetLastError());
        return;
    }

    // read the other pages
    DWORD i;
    DWORD dwTotPages = pPage[OFFSET_TOTAL_PAGES];
    for (i=1;i<dwTotPages;i++)
    {
        DumpPage(hFile,i,pPage);
    }
    DWORD dwFileSize = GetFileSize(hFile,NULL);
    if (dwFileSize != (dwTotPages)*PS_PAGE_SIZE)
    {
        dprintf("    filesize %d expected %d\n",dwFileSize,((1+dwTotPages)*PS_PAGE_SIZE));
    }
}
*/

//
// performs the same operations of CPageFile::ReadMap with a buffer
//

struct debugCPageFile
{
        DWORD dwSign;
        DWORD dwTrans;
        DWORD dwPhysical;
        DWORD dwNumPagesA;
        DWORD * pPagesA;
        DWORD dwPagesFreeList;
        DWORD * pFreePages;
        DWORD dwSignTail;	

	debugCPageFile(BYTE * pMap)
	{
        	DWORD * pCurrent = (DWORD *)pMap;
              dwSign = *pCurrent++;
              dwTrans = *pCurrent++;
              dwPhysical = *pCurrent++;
              dwNumPagesA = *pCurrent++;
              pPagesA = pCurrent;
              pCurrent+=dwNumPagesA;
              dwPagesFreeList = *pCurrent++;
               pFreePages = pCurrent;
               pCurrent += dwPagesFreeList;
              dwSignTail = *pCurrent;		
	};
};

struct debugBtrPage
{
	DWORD dwPageType;
	DWORD dwPageId;
	DWORD dwNextPage;
	DWORD dwLogicalRoot;
	debugBtrPage(BYTE * pBtr)
	{
		DWORD * pdwCurrent = (DWORD *)pBtr;
		dwPageType = *pdwCurrent++;
		dwPageId = *pdwCurrent++;
		dwNextPage = *pdwCurrent++;
		dwLogicalRoot = *pdwCurrent++;
	}
};

#define MAP_LEADING_SIGNATURE   0xABCD
#define MAP_TRAILING_SIGNATURE  0xDCBA

void
Dump_Map(HANDLE hFile)
{
    HANDLE hFileMap = NULL;
    BYTE * pMap = NULL;

    DWORD dwSize = 0;
    
    dwSize = GetFileSize(hFile,NULL);
    hFileMap = CreateFileMapping(hFile,
                                    NULL,
                                    PAGE_READONLY,
                                    0,
                                    dwSize,
                                    NULL);
    if (hFileMap)
    {
        pMap = (BYTE *)MapViewOfFile(hFileMap,
                                        FILE_MAP_READ,
                                        0,0,0);
    }
    else
    {
        dprintf("MapViewOfFile(hFileMap) %d\n",GetLastError());
        goto cleanup;
    };

    dwSize = GetFileSize(hFile,NULL);
    hFileMap = CreateFileMapping(hFile,
                                    NULL,
                                    PAGE_READONLY,
                                    0,
                                    dwSize,
                                    NULL);

    if (hFileMap)
    {
        pMap = (BYTE *)MapViewOfFile(hFileMap,
                                        FILE_MAP_READ,
                                        0,0,0);
    }
    else
    {
        dprintf("MapViewOfFile(hFileMapFre) %d\n",GetLastError());
        goto cleanup;
    };

    if (pMap)
    {
    	 debugCPageFile a(pMap);
        dprintf("    %08x SIGN HEAD\n",a.dwSign);
        dprintf("    %08x Trans\n",a.dwTrans);
        dprintf("    %08x m_dwPhysPagesA\n",a.dwPhysical);
        dprintf("    %08x m_aPageMapA.size()\n",a.dwNumPagesA);
        PrintDWORDS(a.pPagesA,a.dwNumPagesA);
        dprintf("    %08x m_aPhysFreeListA.size()\n",a.dwPagesFreeList);
        PrintDWORDS(a.pFreePages,a.dwPagesFreeList);
        dprintf("    %08x SIGN TAIL\n",a.dwSignTail);        
    }

cleanup:
    if (pMap)
        UnmapViewOfFile(pMap);
    if (hFileMap)
        CloseHandle(hFileMap);
};

void
Dump_AdminPage(BYTE * pMap,BYTE * pObj)
{
    if (pMap && pObj)
    {
    	 debugCPageFile a(pMap);
    	
        DWORD i;
        DWORD AdminIndex = 0;        
        do {
        	if (WMIREP_INVALID_PAGE == a.pPagesA[AdminIndex] ||
        	    WMIREP_RESERVED_PAGE  == a.pPagesA[AdminIndex])
        	{
        		dprintf("BAD dwNextAdminPage %08x index %x\n",a.pPagesA[AdminIndex],AdminIndex);
        		break;
        	}
        	BYTE * pAdminPage = pObj + (a.pPagesA[AdminIndex]*PS_PAGE_SIZE);
	        VarObjHeapAdminPage * pAdmin = (VarObjHeapAdminPage *)pAdminPage;
       	 AdminIndex = pAdmin->dwNextAdminPage;
	        dprintf("    ver %08x Next %08x Ent %08x\n",pAdmin->dwVersion,pAdmin->dwNextAdminPage,pAdmin->dwNumberEntriesOnPage);
	        VarObjHeapFreeList * pFreeEntry = (VarObjHeapFreeList *)(pAdmin+1);
       	 dprintf("                    dwPageId dwFreeSp dwCRC32\n");
       	 if (pAdmin->dwNumberEntriesOnPage > (PS_PAGE_SIZE/sizeof(VarObjHeapFreeList)))
       	 {
       	 	dprintf("Suspicious dwNumberEntriesOnPage %08x on page %x\n",pAdmin->dwNumberEntriesOnPage,AdminIndex);
       	 	break;
       	 }
	        for (i=0;i<pAdmin->dwNumberEntriesOnPage;i++)
       	 {
        		dprintf("         %08x - %08x %08x %08X\n",i,pFreeEntry->dwPageId,pFreeEntry->dwFreeSpace,pFreeEntry->dwCRC32);
	        	pFreeEntry++;
       	 }
        } while(AdminIndex);
    }
};

void
Dump_Index(BYTE * pMap,BYTE * pBtr)
{
	if (pMap && pBtr)
	{
		debugCPageFile a(pMap);
		BYTE * pStart = pBtr + (a.pPagesA[0]*PS_PAGE_SIZE);
		debugBtrPage b(pStart);
		dprintf("        %08x %08x %08x %08x - %08X\n",b.dwPageType,b.dwPageId,b.dwNextPage,b.dwLogicalRoot,a.pPagesA[0]);

		//other pages
		DWORD i;
		for (i=0;i<a.dwNumPagesA;i++)
		{
			dprintf("        ---- %08x - %08x\n",i,a.pPagesA[i]);
			if (WMIREP_INVALID_PAGE != a.pPagesA[i] &&
			    WMIREP_RESERVED_PAGE != a.pPagesA[i])
			{
				pStart = pBtr + (a.pPagesA[i]*PS_PAGE_SIZE);
				DumpPage((DWORD *)pStart );
			}
		}
	}
}


#define INDEX_FILE         _T("\\FS\\index.btr")
#define INDEX_FILE_MAP _T("\\FS\\index.map")
#define HEAP_FILE           _T("\\FS\\Objects.data")
#define HEAP_FILE_MAP   _T("\\FS\\Objects.map")

#define REG_WBEM   _T("Software\\Microsoft\\WBEM\\CIMOM")
#define REG_DIR _T("Repository Directory")

HANDLE 
GetRepositoryFile(TCHAR * pFileName)
{
    HKEY hKey;
    LONG lRet;
    HANDLE hFile = INVALID_HANDLE_VALUE;    

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        REG_WBEM,
                        NULL,
                        KEY_READ,
                        &hKey);
    if (ERROR_SUCCESS == lRet)
    {
        TCHAR pPath[MAX_PATH];
        DWORD dwType;
        DWORD dwLen = MAX_PATH;
        lRet = RegQueryValueEx(hKey,
                               REG_DIR,
                               NULL,
                               &dwType,
                               (BYTE*)pPath,
                               &dwLen);
        if (ERROR_SUCCESS == lRet)
        {
            TCHAR pPath2[MAX_PATH];
            
            ExpandEnvironmentStrings(pPath,pPath2,MAX_PATH);
            lstrcat(pPath2,pFileName);

            hFile = CreateFile(pPath2,
                               GENERIC_READ,
                               FILE_SHARE_WRITE|FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               0,NULL);

            if (INVALID_HANDLE_VALUE != hFile)
            {
                // this is the OK path
            }
            else
            {
                dprintf("CreateFile(%s) %d\n",pPath2,GetLastError());
            }
        }
        else
        {
            dprintf("unable to RegQueryValueEx: %d\n",GetLastError());
        }    
        RegCloseKey(hKey);
    }
    else
    {
        dprintf("unable to RegOpenKeyEx: %d\n",GetLastError());
    }	

    return hFile;
}

//
//  Dumps the .MAP file as a CPageFile
//
/////////////////////////////////////////////

DECLARE_API(fmap)
{
    INIT_API();

    if (strlen(args))
    {
        char * pArgs = (char *)args;
        while (isspace(*pArgs)) pArgs++;
        
	    HANDLE hFile;
	    hFile = GetRepositoryFile((TCHAR *)pArgs);
	    if (INVALID_HANDLE_VALUE != hFile)
	    {
	        Dump_Map(hFile);
	        CloseHandle(hFile);
	    }
	    else
	    {
	        dprintf("GetRepositoryFile %d\n",GetLastError());
	    }
    }
    else
    {
        dprintf("!wmiexts.fmap \\FS\\index.map || \\FS\\objects.map\n");
    }
}

//
// Dump the Admin page of the objects.data
//
//////////////////////////////////////////

DECLARE_API(varobj)
{
    INIT_API();

    HANDLE hFileMap = INVALID_HANDLE_VALUE; 
    HANDLE hFileObj = INVALID_HANDLE_VALUE;
    HANDLE hMappingMap = NULL;
    HANDLE hMappingObj = NULL;
    DWORD dwSizeMap = 0;
    DWORD dwSizeObj = 0;    
    BYTE * pMap;
    BYTE * pObj;    
    
    hFileMap =	GetRepositoryFile(HEAP_FILE_MAP);    

    if (INVALID_HANDLE_VALUE == hFileMap)
    {
    	//dprintf("");
        goto Cleanup;
    }

    dwSizeMap = GetFileSize(hFileMap,NULL);
    hMappingMap = CreateFileMapping(hFileMap,
                                    NULL,
                                    PAGE_READONLY,
                                    0,
                                    dwSizeMap,
                                    NULL);
    if (hFileMap)
    {
        pMap = (BYTE *)MapViewOfFile(hMappingMap,
                                        FILE_MAP_READ,
                                        0,0,0);
    }
    else
    {
        dprintf("MapViewOfFile(hMappingMap) %d\n",GetLastError());
        goto Cleanup;
    };
    	    
    hFileObj = GetRepositoryFile(HEAP_FILE);
    if (INVALID_HANDLE_VALUE == hFileObj)
    {
    	//dprintf("");    	
        goto Cleanup;
    }

    dwSizeObj = GetFileSize(hFileObj,NULL);
    hMappingObj = CreateFileMapping(hFileObj,
                                    NULL,
                                    PAGE_READONLY,
                                    0,
                                    dwSizeObj,
                                    NULL);
    if (hMappingObj)
    {
        pObj = (BYTE *)MapViewOfFile(hMappingObj,
                                        FILE_MAP_READ,
                                        0,0,0);
    }
    else
    {
        dprintf("MapViewOfFile(hMappingObj) %d\n",GetLastError());
        goto Cleanup;
    };

    if (pMap && pObj)
    {
        Dump_AdminPage(pMap,pObj);
    }
    
Cleanup:
    if (pMap)
    	UnmapViewOfFile(pMap);
    if (hMappingMap)
    	CloseHandle(hMappingMap);
    if (INVALID_HANDLE_VALUE != hFileMap)
	 CloseHandle(hFileMap);      
    if (pObj)
    	UnmapViewOfFile(pObj);
    if (hMappingObj)
    	CloseHandle(hMappingObj);
    if (INVALID_HANDLE_VALUE != hFileObj)
    	CloseHandle(hFileObj);
    
}


//
// Dump the Admin page of the btr
//
//////////////////////////////////////////

DECLARE_API(btr)
{
    INIT_API();

    HANDLE hFileMap = INVALID_HANDLE_VALUE; 
    HANDLE hFileBtr = INVALID_HANDLE_VALUE;
    HANDLE hMappingMap = NULL;
    HANDLE hMappingBtr = NULL;
    DWORD dwSizeMap = 0;
    DWORD dwSizeBtr = 0;    
    BYTE * pMap;
    BYTE * pBtr;    
    
    hFileMap =	GetRepositoryFile(INDEX_FILE_MAP);    

    if (INVALID_HANDLE_VALUE == hFileMap)
    {
    	//dprintf("");
        goto Cleanup;
    }

    dwSizeMap = GetFileSize(hFileMap,NULL);
    hMappingMap = CreateFileMapping(hFileMap,
                                    NULL,
                                    PAGE_READONLY,
                                    0,
                                    dwSizeMap,
                                    NULL);
    if (hFileMap)
    {
        pMap = (BYTE *)MapViewOfFile(hMappingMap,
                                        FILE_MAP_READ,
                                        0,0,0);
    }
    else
    {
        dprintf("MapViewOfFile(hMappingMap) %d\n",GetLastError());
        goto Cleanup;
    };
    	    
    hFileBtr = GetRepositoryFile(INDEX_FILE);
    if (INVALID_HANDLE_VALUE == hFileBtr)
    {
    	//dprintf("");    	
        goto Cleanup;
    }

    dwSizeBtr = GetFileSize(hFileBtr,NULL);
    hMappingBtr = CreateFileMapping(hFileBtr,
                                    NULL,
                                    PAGE_READONLY,
                                    0,
                                    dwSizeBtr,
                                    NULL);
    if (hMappingBtr)
    {
        pBtr = (BYTE *)MapViewOfFile(hMappingBtr,
                                        FILE_MAP_READ,
                                        0,0,0);
    }
    else
    {
        dprintf("MapViewOfFile(hMappingBtr) %d\n",GetLastError());
        goto Cleanup;
    };

    if (pMap && pBtr)
    {
        Dump_Index(pMap,pBtr);
    }
    
Cleanup:
    if (pMap)
    	UnmapViewOfFile(pMap);
    if (hMappingMap)
    	CloseHandle(hMappingMap);
    if (INVALID_HANDLE_VALUE != hFileMap)
	 CloseHandle(hFileMap);      
    if (pBtr)
    	UnmapViewOfFile(pBtr);
    if (hMappingBtr)
    	CloseHandle(hMappingBtr);
    if (INVALID_HANDLE_VALUE != hFileBtr)
    	CloseHandle(hFileBtr);
    
}



//
//
//  dumps the g_FileCache
//
//


/*
DWORD WINAPI 
CallBackWriteInst(VOID * pData1)
{
    DEFINE_CPP_VAR(CWriteFileInstruction,varCWriteFileInstruction);
    CWriteFileInstruction * pWriteInst = GET_CPP_VAR_PTR(CWriteFileInstruction,varCWriteFileInstruction);
    
    if (ReadMemory((ULONG_PTR)pData1,pWriteInst,sizeof(CWriteFileInstruction),NULL))
    {
    	dprintf("      m_lStageOffset %p m_bCommitted %d\n",pWriteInst->m_lStageOffset,pWriteInst->m_bCommitted);
    	dprintf("      m_dwLen %08x m_Location.m_nFileId %02x m_Location.m_lStartOffset %I64x\n",pWriteInst->m_dwLen,pWriteInst->m_Location.m_nFileId,pWriteInst->m_Location.m_lStartOffset);
	    dprintf("      m_lZOrder %x m_bReuse %02x\n",pWriteInst->m_lZOrder,pWriteInst->m_bReuse);
    }
    return 0;
}

void DumpLongStage(ULONG_PTR Addr, // FileCache OOP pointer
                   CFileCache * pFileCache, // inproc pointer
                   ULONG_PTR Verbose) 
{
   	        //
   	        //  CAbstractSource
   	        //
            dprintf("    + CLongFileStagingFile %p\n",Addr+FIELD_OFFSET(CFileCache,m_AbstractSource)); 
       		CAbstractFileSource * pAbsS = &pFileCache->m_AbstractSource;
            CLongFileStagingFile * pLongStage = &pAbsS->m_Stage;
            CLongFileStagingFile * pLongStag_OOP = (CLongFileStagingFile *)(Addr + FIELD_OFFSET(CFileCache,m_AbstractSource) + FIELD_OFFSET(CAbstractFileSource,m_Stage));
            
   	        // CStageMgr members
   	        dprintf("        m_hFile %x m_hFlushFile %x\n",pLongStage->m_hFile,pLongStage->m_hFlushFile);
		    //long m_lFirstFreeOffset;

		    //CCritSec m_cs;
		    dprintf("        m_qToWrite\n");
		    _List * pList_OOP = (_List *)((BYTE *)pLongStag_OOP + FIELD_OFFSET(CLongFileStagingFile,m_qToWrite));
            PrintListCB(pList_OOP,CallBackWriteInst);
            
		    dprintf("        m_stReplacedInstructions\n");
		    pList_OOP = (_List *)((BYTE *)pLongStag_OOP + FIELD_OFFSET(CLongFileStagingFile,m_stReplacedInstructions));
            PrintListCB(pList_OOP,NULL);
		    
		    dprintf("        m_qTransaction\n");
		    pList_OOP = (_List *)((BYTE *)pLongStag_OOP + FIELD_OFFSET(CLongFileStagingFile,m_qTransaction));
            PrintListCB(pList_OOP,CallBackWriteInst);

		    
		    dprintf("        TransIdx %I64d m_lTransactionStartOffset %x\n",pLongStage->m_nTransactionIndex,pLongStage->m_lTransactionStartOffset);
		    //BYTE m_TransactionHash[16];
		    dprintf("        bInTransaction %d bFailedBefore %d lStatus %d\n",pLongStage->m_bInTransaction,pLongStage->m_bFailedBefore,pLongStage->m_lStatus);
		    //pStage->m_lMaxFileSize;
		    //pStage->m_lAbortTransactionFileSize;
            // bool m_bMustFail;
            // bool m_bNonEmptyTransaction;

        if (Verbose)
        {
            // the multimap has the compare function
            _Map * pMapStarts = (_Map *)((BYTE*)pLongStag_OOP + sizeof(void *) + FIELD_OFFSET(CLongFileStagingFile,m_mapStarts));
            dprintf("          m_mapStarts\n");
            dprintf("          std::multimap< { CFileLocation::m_nFileId, CFileLocation::m_lStartOffset }, CWriteFileInstruction* >\n");
            PrintMapCB(pMapStarts,TRUE,NULL);
                    
            _Map * pMapEnds = (_Map *)((BYTE*)pLongStag_OOP + sizeof(void *) + FIELD_OFFSET(CLongFileStagingFile,m_mapEnds));
            dprintf("          m_mapEnds\n");                    
            dprintf("          std::multimap< { CFileLocation::m_nFileId, CFileLocation::m_lStartOffset }, CWriteFileInstruction* >\n");
            PrintMapCB(pMapEnds,TRUE,NULL);
        }
}

DECLARE_API( stage )
{
    INIT_API();

    ULONG_PTR Addr = 0;
    
    ULONG_PTR Verbose = GetExpression(args);
    
    Addr = GetExpression("repdrvfs!g_Glob");
    if (Addr)
    {
        Addr += FIELD_OFFSET(CGlobals,m_FileCache);
    }
     
    if (Addr) 
    {
        DEFINE_CPP_VAR(CFileCache,varCFileCache);
        CFileCache * pFileCache = GET_CPP_VAR_PTR(CFileCache,varCFileCache);

        dprintf("CFileCache @ %p\n",Addr);

        if (ReadMemory((ULONG_PTR)Addr,pFileCache,sizeof(CFileCache),0))
        {
            DumpLongStage(Addr,pFileCache,Verbose);
        }
        else
        {
            dprintf("RM %p\n",Addr);
        }
    }
    else
    {
        dprintf("unable to resolve repdrvfs!g_Glob\n");
    }
    
}

*/

/*
DECLARE_API( filec_old )
{

    INIT_API();

    ULONG_PTR Addr = 0;
    
    if (0 != strlen(args))
    {
        Addr = GetExpression(args);
    }
    else
    {
        Addr = GetExpression("repdrvfs!g_Glob");
        if (Addr)
        {
            Addr += FIELD_OFFSET(CGlobals,m_FileCache);
        }
    }
    
    if (Addr) 
    {
        DEFINE_CPP_VAR(CFileCache,varCFileCache);
        CFileCache * pFileCache = GET_CPP_VAR_PTR(CFileCache,varCFileCache);

        dprintf("CFileCache @ %p\n",Addr);

        if (ReadMemory((ULONG_PTR)Addr,pFileCache,sizeof(CFileCache),0))
        {
            dprintf("    m_lRef %d\n",pFileCache->m_lRef);

            DumpLongStage(Addr,pFileCache,TRUE);
                    
            //
            //  CObjectHeap
            //
            dprintf("    + CObjectHeap %p\n",Addr+FIELD_OFFSET(CFileCache,m_ObjectHeap));
            CObjectHeap * pObjectHeap_OOP = (CObjectHeap *)(Addr+FIELD_OFFSET(CFileCache,m_ObjectHeap));
            
            DEFINE_CPP_VAR(CFileHeap,varCFileHeap);
            CFileHeap * pFileHeap = GET_CPP_VAR_PTR(CFileHeap,varCFileHeap);

            CFileHeap * pFileHeap_OOP = (CFileHeap *)((ULONG_PTR)pObjectHeap_OOP+FIELD_OFFSET(CObjectHeap,m_Heap));
            dprintf("    +++ CFileHeap %p\n",pFileHeap_OOP);

            if (ReadMemory((ULONG_PTR)pFileHeap_OOP,pFileHeap,sizeof(CFileHeap),NULL))
            {

                DEFINE_CPP_VAR(CAbstractFile,varCAbstractFile);
                CAbstractFile * pAbstract = GET_CPP_VAR_PTR(CAbstractFile,varCAbstractFile);
            
	            dprintf("        m_pMainFile    %p\n",pFileHeap->m_pMainFile);	            
                ReadMemory((ULONG_PTR)pFileHeap->m_pMainFile,pAbstract,sizeof(CAbstractFile),NULL);
                dprintf("          m_pStage %p m_nId %d\n",pAbstract->m_pStage,pAbstract->m_nId);	            
                
    	        dprintf("        m_pFreeFile    %p\n",pFileHeap->m_pFreeFile);
                ReadMemory((ULONG_PTR)pFileHeap->m_pFreeFile,pAbstract,sizeof(CAbstractFile),NULL);
                dprintf("          m_pStage %p m_nId %d\n",pAbstract->m_pStage,pAbstract->m_nId);
    	       
	            dprintf("        m_mapFree\n");
                dprintf("        std::map< DWORD , { CRecordInfo::m_dwIndex, CRecordInfo::m_nOffset } >\n");
	            _Map * pMapFree = (_Map *)((BYTE *)pFileCache->m_ObjectHeap.m_pHeap+FIELD_OFFSET(CFileHeap,m_mapFree));
	            PrintMapCB(pMapFree,TRUE,NULL);

	            dprintf("        m_mapFreeOffset\n");
                dprintf("        std::map< TOffset , DWORD >\n");
	            _Map * pMapOffset = (_Map *)((BYTE *)pFileCache->m_ObjectHeap.m_pHeap+FIELD_OFFSET(CFileHeap,m_mapFreeOffset));
                PrintMapCB(pMapOffset,TRUE,NULL);
            }
            else
            {
                dprintf("RM %p %d\n",Addr,GetLastError());
            }

            CBtrIndex * pBtrIndex_OOP = (CBtrIndex *)((ULONG_PTR)pObjectHeap_OOP+FIELD_OFFSET(CObjectHeap,m_Index));
            dprintf("    +++ CBtrIndex %p\n",pBtrIndex_OOP);
            
        }
        else
        {
            dprintf("RM %p %d\n",Addr,GetLastError());
        }
    }
    else
    {
        dprintf("cannot resolve repdrvfs!g_Glob\n");
    }
}
*/

/*
    long m_lRef;
    BOOL m_bInit;
    CPageSource m_TransactionManager;
    CObjectHeap m_ObjectHeap;
*/

void
Print_CPageCache(ULONG_PTR pPageCache_OOP)
{
    DEFINE_CPP_VAR(CPageCache,varCPageCache);
    CPageCache * pPageCache = GET_CPP_VAR_PTR(CPageCache,varCPageCache);    

    dprintf("                + CPageCache @ %p\n",pPageCache_OOP);
    
    if (ReadMemory(pPageCache_OOP,pPageCache,sizeof(CPageCache),NULL))
    {
/*
    DWORD   m_dwStatus;

    DWORD   m_dwPageSize;
    DWORD   m_dwCacheSize;

    DWORD   m_dwCachePromoteThreshold;
    DWORD   m_dwCacheSpillRatio;

    DWORD   m_dwLastFlushTime;
    DWORD   m_dwWritesSinceFlush;
    DWORD   m_dwLastCacheAccess;
    DWORD   m_dwReadHits;
    DWORD   m_dwReadMisses;
    DWORD   m_dwWriteHits;
    DWORD   m_dwWriteMisses;

    HANDLE  m_hFile;

    std::vector <SCachePage *, wbem_allocator<SCachePage *> > m_aCache;
*/
        dprintf("                m_dwStatus       %08x\n",pPageCache->m_dwStatus);
        dprintf("                m_dwPageSize   %08x\n",pPageCache->m_dwPageSize);
        dprintf("                m_dwCacheSize %08x\n",pPageCache->m_dwCacheSize);
        dprintf("                m_hFile %p\n",pPageCache->m_hFile);

        _Vector * pVector;
        ULONG_PTR Size;
        SCachePage ** ppSCachePage;

        pVector = (_Vector *)&pPageCache->m_aCache;
        Size = ((ULONG_PTR)pVector->_Last - (ULONG_PTR)pVector->_First)/sizeof(SCachePage *);
        dprintf("                m_aCache - S %x - P %p\n",Size,pVector->_First);
        ppSCachePage = new SCachePage *[Size];
        if(ppSCachePage)
        {
            if (ReadMemory((ULONG_PTR)pVector->_First,ppSCachePage,sizeof(SCachePage *)*Size,NULL))
            {
                for (ULONG_PTR i=0;i<Size;i++)
                {
                    //dprintf("                - %p - %d\n",ppSCachePage[i],i);
                    
                    DEFINE_CPP_VAR(SCachePage,varSCachePage);
                    SCachePage * pSCachePage = GET_CPP_VAR_PTR(SCachePage,varSCachePage);

                    if (ReadMemory((ULONG_PTR)ppSCachePage[i],pSCachePage,sizeof(SCachePage),NULL))
                    {
                        dprintf("                  D %d %08x - %p\n",pSCachePage->m_bDirty,pSCachePage->m_dwPhysId,pSCachePage->m_pPage);
                    }
                };
            }
            delete [] ppSCachePage;
        };
        
    }
    else
    {
        dprintf("RM %p\n",pPageCache_OOP);
    }    
};

void
Print_CPageFile(ULONG_PTR pPageFile_OOP, BOOL bVerbose)
{
    DEFINE_CPP_VAR(CPageFile,varCPageFile);
    CPageFile * pPageFile = GET_CPP_VAR_PTR(CPageFile,varCPageFile);    

    dprintf("        + CPageFile @ %p\n",pPageFile_OOP);
    
    if (ReadMemory(pPageFile_OOP,pPageFile,sizeof(CPageFile),NULL))
    {
/*
    LONG              m_lRef;
    DWORD             m_dwStatus;
    DWORD             m_dwPageSize;

	CRITICAL_SECTION  m_cs;

    WString      m_sDirectory;
    WString      m_sMapFile;
    WString      m_sMainFile;

    CPageCache       *m_pCache;
    BOOL              m_bInTransaction;
    DWORD             m_dwLastCheckpoint;
    DWORD             m_dwTransVersion;

    // Generation A Mapping
    std::vector <DWORD, wbem_allocator<DWORD> > m_aPageMapA;
    std::vector <DWORD, wbem_allocator<DWORD> > m_aPhysFreeListA;
    std::vector <DWORD, wbem_allocator<DWORD> > m_aLogicalFreeListA;
    std::vector <DWORD, wbem_allocator<DWORD> > m_aReplacedPagesA;
    DWORD m_dwPhysPagesA;

    // Generation B Mapping
    std::vector <DWORD, wbem_allocator<DWORD> > m_aPageMapB;
    std::vector <DWORD, wbem_allocator<DWORD> > m_aPhysFreeListB;
    std::vector <DWORD, wbem_allocator<DWORD> > m_aLogicalFreeListB;
    std::vector <DWORD, wbem_allocator<DWORD> > m_aReplacedPagesB;
    DWORD m_dwPhysPagesB;
*/

        dprintf("            m_lRef       %08x\n",pPageFile->m_lRef);
        dprintf("            m_dwStatus   %08x\n",pPageFile->m_dwStatus);
        dprintf("            m_dwPageSize %08x\n",pPageFile->m_dwPageSize);

        dprintf("            m_pCache           %p\n",pPageFile->m_pCache);
        Print_CPageCache((ULONG_PTR)pPageFile->m_pCache);
        dprintf("            m_bInTransaction   %08x\n",pPageFile->m_bInTransaction);
        dprintf("            m_dwLastCheckpoint %08x\n",pPageFile->m_dwLastCheckpoint);
        dprintf("            m_dwTransVersion   %08x\n",pPageFile->m_dwTransVersion);

        _Vector * pVector;
        ULONG_PTR Size;
        DWORD * pDW;

        pVector = (_Vector *)&pPageFile->m_aPageMapA;
        Size = ((ULONG_PTR)pVector->_Last - (ULONG_PTR)pVector->_First)/sizeof(DWORD);
        dprintf("            m_aPageMapA         - S %x - P %p\n",Size,pVector->_First);
        if (bVerbose)
        {        
	        pDW = new DWORD[Size];
	        if(pDW)
	        {
	            if (ReadMemory((ULONG_PTR)pVector->_First,pDW,sizeof(DWORD)*Size,NULL))
	            {
	                PrintDWORDS(pDW,Size);
	            }
	            delete [] pDW;
	        };
        }
        
        pVector = (_Vector *)&pPageFile->m_aPhysFreeListA;
        Size = ((ULONG_PTR)pVector->_Last - (ULONG_PTR)pVector->_First)/sizeof(DWORD);
        dprintf("            m_aPhysFreeListA    - S %x - P %p\n",Size,pVector->_First);
        if (bVerbose)
        {
	        pDW = new DWORD[Size];
	        if(pDW)
	        {
	            if (ReadMemory((ULONG_PTR)pVector->_First,pDW,sizeof(DWORD)*Size,NULL))
	            {
	                PrintDWORDS(pDW,Size);
	            }
	            delete [] pDW;
	        };
        };
        
        pVector = (_Vector *)&pPageFile->m_aLogicalFreeListA;
        Size = ((ULONG_PTR)pVector->_Last - (ULONG_PTR)pVector->_First)/sizeof(DWORD);
        dprintf("            m_aLogicalFreeListA - S %x - P %p\n",Size,pVector->_First);
        if (bVerbose)
        {
	     pDW = new DWORD[Size];
	     if(pDW)
	     {
	         if (ReadMemory((ULONG_PTR)pVector->_First,pDW,sizeof(DWORD)*Size,NULL))
	         {
	             PrintDWORDS(pDW,Size);
	         }
	         delete [] pDW;
	     };
        }

        pVector = (_Vector *)&pPageFile->m_aReplacedPagesA;
        Size = ((ULONG_PTR)pVector->_Last - (ULONG_PTR)pVector->_First)/sizeof(DWORD);
        dprintf("            m_aReplacedPagesA   - S %x - P %p\n",Size,pVector->_First);
        if (bVerbose)
        {        
	        pDW = new DWORD[Size];
	        if(pDW)
	        {
	            if (ReadMemory((ULONG_PTR)pVector->_First,pDW,sizeof(DWORD)*Size,NULL))
	            {
	                PrintDWORDS(pDW,Size);
	            }
	            delete [] pDW;
	        };
        }
        
        dprintf("            m_dwPhysPagesA     %08x\n",pPageFile->m_dwPhysPagesA);

        pVector = (_Vector *)&pPageFile->m_aPageMapB;
        Size = ((ULONG_PTR)pVector->_Last - (ULONG_PTR)pVector->_First)/sizeof(DWORD);
        dprintf("            m_aPageMapB         - S %x - P %p\n",Size,pVector->_First);
        if (bVerbose)
        {        
	        pDW = new DWORD[Size];
	        if(pDW)
	        {
	            if (ReadMemory((ULONG_PTR)pVector->_First,pDW,sizeof(DWORD)*Size,NULL))
	            {
	                PrintDWORDS(pDW,Size);
	            }
	            delete [] pDW;
	        };
        }
        
        pVector = (_Vector *)&pPageFile->m_aPhysFreeListB;
        Size = ((ULONG_PTR)pVector->_Last - (ULONG_PTR)pVector->_First)/sizeof(DWORD);
        dprintf("            m_aPhysFreeListB    - S %x - P %p\n",Size,pVector->_First);
        if (bVerbose)
        {        
	        pDW = new DWORD[Size];
	        if(pDW)
	        {
	            if (ReadMemory((ULONG_PTR)pVector->_First,pDW,sizeof(DWORD)*Size,NULL))
	            {
	                PrintDWORDS(pDW,Size);
	            }
	            delete [] pDW;
	        };
        }
        
        pVector = (_Vector *)&pPageFile->m_aLogicalFreeListB;
        Size = ((ULONG_PTR)pVector->_Last - (ULONG_PTR)pVector->_First)/sizeof(DWORD);
        dprintf("            m_aLogicalFreeListB - S %x - P %p\n",Size,pVector->_First);
        if (bVerbose)
        {        
	        pDW = new DWORD[Size];
	        if(pDW)
	        {
	            if (ReadMemory((ULONG_PTR)pVector->_First,pDW,sizeof(DWORD)*Size,NULL))
	            {
	                PrintDWORDS(pDW,Size);
	            }
	            delete [] pDW;
	        };
        }

        pVector = (_Vector *)&pPageFile->m_aReplacedPagesB;
        Size = ((ULONG_PTR)pVector->_Last - (ULONG_PTR)pVector->_First)/sizeof(DWORD);
        dprintf("            m_aReplacedPagesB   - S %x - P %p\n",Size,pVector->_First);
        if (bVerbose)
        {        
	        pDW = new DWORD[Size];
	        if(pDW)
	        {
	            if (ReadMemory((ULONG_PTR)pVector->_First,pDW,sizeof(DWORD)*Size,NULL))
	            {
	                PrintDWORDS(pDW,Size);
	            }
	            delete [] pDW;
	        };
        }
        
        dprintf("            m_dwPhysPagesB     %08x\n",pPageFile->m_dwPhysPagesB);

    }
    else
    {
        dprintf("RM %p\n",pPageFile_OOP);
    }
}

DECLARE_API( filec )
{

    INIT_API();

    ULONG_PTR Addr = 0;
    
    if (0 != strlen(args))
    {
        Addr = GetExpression(args);
    }
    else
    {
        Addr = GetExpression("repdrvfs!g_Glob");
        if (Addr)
        {
            Addr += FIELD_OFFSET(CGlobals,m_FileCache);
        }
    }
    
    if (Addr) 
    {
        DEFINE_CPP_VAR(CFileCache,varCFileCache);
        CFileCache * pFileCache = GET_CPP_VAR_PTR(CFileCache,varCFileCache);

        dprintf("CFileCache @ %p\n",Addr);

        if (ReadMemory((ULONG_PTR)Addr,pFileCache,sizeof(CFileCache),0))
        {
            dprintf("    m_lRef %d m_bInit %d\n",pFileCache->m_lRef,pFileCache->m_bInit);

            //
            // CPageSource
            //
            dprintf("    + CPageSource %p\n",Addr+FIELD_OFFSET(CFileCache,m_TransactionManager));
            CPageSource * pPageSource_OOP = (CPageSource *)(Addr+FIELD_OFFSET(CFileCache,m_TransactionManager)); 

            CPageSource * pPageSource = (CPageSource *)((BYTE *)pFileCache+FIELD_OFFSET(CFileCache,m_TransactionManager));

            //dprintf();
            dprintf("        m_dwPageSize           %08x\n",pPageSource->m_dwPageSize);
            dprintf("        m_dwLastCheckpoint     %08x\n",pPageSource->m_dwLastCheckpoint);
            dprintf("        m_dwCheckpointInterval %08x\n",pPageSource->m_dwCheckpointInterval);
            //    WString m_sDirectory;
            //    WString m_sBTreeMap;
            //    WString m_sObjMap;
            // CPageFile *
            dprintf("        m_pBTreePF  %p\n",pPageSource->m_pBTreePF);

            Print_CPageFile((ULONG_PTR)pPageSource->m_pBTreePF,FALSE);

            dprintf("        m_pObjPF    %p\n",pPageSource->m_pObjPF);           
            Print_CPageFile((ULONG_PTR)pPageSource->m_pObjPF,FALSE);
                  
            //
            //  CObjectHeap
            //
            dprintf("    + CObjectHeap %p\n",Addr+FIELD_OFFSET(CFileCache,m_ObjectHeap));
            CObjectHeap * pObjectHeap_OOP = (CObjectHeap *)(Addr+FIELD_OFFSET(CFileCache,m_ObjectHeap));
            
            DEFINE_CPP_VAR(CVarObjHeap,varCVarObjHeap);
            CVarObjHeap * pVarObjHeap = GET_CPP_VAR_PTR(CVarObjHeap,varCVarObjHeap);

            CVarObjHeap * pVarObjHeap_OOP = (CVarObjHeap *)((ULONG_PTR)pObjectHeap_OOP+FIELD_OFFSET(CObjectHeap,m_Heap));
            dprintf("    +++ CVarObjHeap %p\n",pVarObjHeap_OOP);

            if (ReadMemory((ULONG_PTR)pVarObjHeap_OOP,pVarObjHeap,sizeof(CVarObjHeap),NULL))
            {
                // this pagefile is the same as CPageSource::m_pObjPF
                VarObjAdminPageEntry ** ppEntries = (VarObjAdminPageEntry **)_alloca(sizeof(VarObjAdminPageEntry *)*pVarObjHeap->m_aAdminPages.m_nSize);
              
                if (ReadMemory((ULONG_PTR)pVarObjHeap->m_aAdminPages.m_pArray,ppEntries,sizeof(VarObjAdminPageEntry *)*pVarObjHeap->m_aAdminPages.m_nSize,NULL))
                {
                    for(DWORD i=0;i<pVarObjHeap->m_aAdminPages.m_nSize;i++)
                    {
                        //VarObjAdminPageEntry
                        //dprintf("        - %x P %p\n",i,ppEntries[i]);
                        VarObjAdminPageEntry Entry;
                        if (ReadMemory((ULONG_PTR)ppEntries[i],&Entry,sizeof(Entry),NULL))
                        {
                        	dprintf("        %08x %p %d\n",Entry.dwPageId,Entry.pbPage,Entry.bDirty);
                        }
                        else
                        {
                        	dprintf("RM %p\n",ppEntries[i]);
                        }
                    }
                }
                else
                {
                    dprintf("RM %p\n",pVarObjHeap->m_aAdminPages.m_pArray);
                }
            }
            else
            {
                dprintf("RM %p %d\n",pVarObjHeap_OOP,GetLastError());
            }

            DEFINE_CPP_VAR(CBtrIndex,varCBtrIndex);
            CBtrIndex * pBtrIndex = GET_CPP_VAR_PTR(CBtrIndex,varCBtrIndex);

            CBtrIndex * pBtrIndex_OOP = (CBtrIndex *)((ULONG_PTR)pObjectHeap_OOP+FIELD_OFFSET(CObjectHeap,m_Index));
            dprintf("    +++ CBtrIndex %p\n",pBtrIndex_OOP);

            if (ReadMemory((ULONG_PTR)pBtrIndex_OOP,pBtrIndex,sizeof(CBtrIndex),NULL))
            {
            }
            else
            {
                dprintf("RM %p %d\n",pBtrIndex_OOP,GetLastError());
            }
            
        }
        else
        {
            dprintf("RM %p %d\n",Addr,GetLastError());
        }
    }
    else
    {
        dprintf("cannot resolve repdrvfs!g_Glob\n");
    }
}


DWORD
Dump_CClassRecord(void * pKey,void * pData)
{

    //dprintf("Dump_CClassRecord\n");

    DEFINE_CPP_VAR(CClassRecord,MyClassRecord);
    CClassRecord * pClassRecord = GET_CPP_VAR_PTR(CClassRecord,MyClassRecord);

    if (pData)
    {
        ReadMemory((ULONG_PTR)pData,pClassRecord,sizeof(CClassRecord),NULL);
        WCHAR pName[MAX_PATH];
        ReadMemory((ULONG_PTR)pClassRecord->m_wszClassName,pName,MAX_PATH,NULL);
        pName[MAX_PATH-1]=0;
        dprintf("    %p - %S\n",pClassRecord->m_pClassDef,pName);
    }
    return 0;
}

DWORD
Dump_CHierarchyCacheMap(void * pKey,void * pData)
{
    //dprintf("Dump_CHierarchyCacheMap\n");
    DEFINE_CPP_VAR(CHierarchyCache,MyHierarchyCache);
    CHierarchyCache * pHieCache = GET_CPP_VAR_PTR(CHierarchyCache,MyHierarchyCache);

    if (pKey)
    {
        WCHAR pString[MAX_PATH+1];
        pString[MAX_PATH]=0;
        if (ReadMemory((MEMORY_ADDRESS)pKey,pString,MAX_PATH*sizeof(WCHAR),NULL))
        {
            dprintf("    - %S\n",pString);
        }
    }
    if (pData)
    {
        DWORD Num;
        PrintMapCB((_Map *)((ULONG_PTR)pData+FIELD_OFFSET(CHierarchyCache,m_map)),TRUE,Dump_CClassRecord);
    }

    return 0;
};

//
//
//  dumps the Forest Cache
//
//


DECLARE_API( forestc )
{
    INIT_API();
    ULONG_PTR Addr = 0;
    
    if (0 != strlen(args))
    {
        Addr = GetExpression(args);
    }
    else
    {
        Addr = GetExpression("repdrvfs!g_Glob");
        if (Addr)
        {
            Addr += FIELD_OFFSET(CGlobals,m_ForestCache);
        }       
    }
        
    if (Addr) 
    {
        CForestCache * pForestCache_OOP = (CForestCache *)Addr;

        if (pForestCache_OOP)
        {
            dprintf("CForestCache @ %p\n",pForestCache_OOP);
            
            DEFINE_CPP_VAR(CForestCache,varCForestCache);
            CForestCache * pForestCache = GET_CPP_VAR_PTR(CForestCache,varCForestCache);
            ReadMemory((ULONG_PTR)pForestCache_OOP,pForestCache,sizeof(CForestCache),0);


            
            DWORD Num;
            PrintMapCB((_Map *)((ULONG_PTR)pForestCache_OOP+FIELD_OFFSET(CForestCache,m_map)),TRUE,Dump_CHierarchyCacheMap);

	        dprintf(" CClassRecord list\n");

	        CClassRecord * pCRec = pForestCache->m_pMostRecentlyUsed;
	        Num = 0;
	        while(pCRec)
	        {
	            DEFINE_CPP_VAR(CClassRecord,CRec);
	            
	            ReadMemory((ULONG_PTR)pCRec,&CRec,sizeof(CClassRecord),0);
	            pCRec = ((CClassRecord *)&CRec)->m_pLessRecentlyUsed;
	            dprintf("    %d - %p\n",Num,pCRec);
	            Num++;
	            if (CheckControlC())
	                break;
	        };
	        dprintf("    T %d CClassRecord\n",Num);
            
        }
        
    } else {
        dprintf(" unable to resolve repdrvfs!g_Glob\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmiexts\heaputil.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    heaputil.cpp
    
Revision History:

    ivanbrug     oct 2000 created

--*/

#include <wmiexts.h>
#include <utilfun.h>
#include <malloc.h>

/*
#if defined(_WIN64)
#define HEAP_GRANULARITY_SHIFT      4   // Log2( HEAP_GRANULARITY )
#else
#define HEAP_GRANULARITY_SHIFT      3   // Log2( HEAP_GRANULARITY )
#endif

#define HEAP_ENTRY_BUSY             0x01
#define HEAP_ENTRY_EXTRA_PRESENT    0x02
#define HEAP_ENTRY_FILL_PATTERN     0x04
#define HEAP_ENTRY_VIRTUAL_ALLOC    0x08
#define HEAP_ENTRY_LAST_ENTRY       0x10
#define HEAP_ENTRY_SETTABLE_FLAG1   0x20
#define HEAP_ENTRY_SETTABLE_FLAG2   0x40
#define HEAP_ENTRY_SETTABLE_FLAG3   0x80
#define HEAP_ENTRY_SETTABLE_FLAGS   0xE0


typedef struct _HEAP_ENTRY {

    //
    //  This field gives the size of the current block in allocation
    //  granularity units.  (i.e. Size << HEAP_GRANULARITY_SHIFT
    //  equals the size in bytes).
    //
    //  Except if this is part of a virtual alloc block then this
    //  value is the difference between the commit size in the virtual
    //  alloc entry and the what the user asked for.
    //

    USHORT Size;

    //
    // This field gives the size of the previous block in allocation
    // granularity units. (i.e. PreviousSize << HEAP_GRANULARITY_SHIFT
    // equals the size of the previous block in bytes).
    //

    USHORT PreviousSize;

    //
    // This field contains the index into the segment that controls
    // the memory for this block.
    //

    UCHAR SegmentIndex;

    //
    // This field contains various flag bits associated with this block.
    // Currently these are:
    //
    //  0x01 - HEAP_ENTRY_BUSY
    //  0x02 - HEAP_ENTRY_EXTRA_PRESENT
    //  0x04 - HEAP_ENTRY_FILL_PATTERN
    //  0x08 - HEAP_ENTRY_VIRTUAL_ALLOC
    //  0x10 - HEAP_ENTRY_LAST_ENTRY
    //  0x20 - HEAP_ENTRY_SETTABLE_FLAG1
    //  0x40 - HEAP_ENTRY_SETTABLE_FLAG2
    //  0x80 - HEAP_ENTRY_SETTABLE_FLAG3
    //

    UCHAR Flags;

    //
    // This field contains the number of unused bytes at the end of this
    // block that were not actually allocated.  Used to compute exact
    // size requested prior to rounding requested size to allocation
    // granularity.  Also used for tail checking purposes.
    //

    UCHAR UnusedBytes;

    //
    // Small (8 bit) tag indexes can go here.
    //

    UCHAR SmallTagIndex;

#if defined(_WIN64)
    ULONGLONG Reserved1;
#endif

} HEAP_ENTRY, *PHEAP_ENTRY;

typedef struct _HEAP_UNCOMMMTTED_RANGE {
    struct _HEAP_UNCOMMMTTED_RANGE *Next;
    ULONG_PTR Address;
    SIZE_T Size;
    ULONG filler;
} HEAP_UNCOMMMTTED_RANGE, *PHEAP_UNCOMMMTTED_RANGE;


typedef struct _HEAP_SEGMENT {
    HEAP_ENTRY Entry;

    ULONG Signature;
    ULONG Flags;
    struct _HEAP *Heap;
    SIZE_T LargestUnCommittedRange;

    PVOID BaseAddress;
    ULONG NumberOfPages;
    PHEAP_ENTRY FirstEntry;
    PHEAP_ENTRY LastValidEntry;

    ULONG NumberOfUnCommittedPages;
    ULONG NumberOfUnCommittedRanges;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRanges;
    USHORT AllocatorBackTraceIndex;
    USHORT Reserved;
    PHEAP_ENTRY LastEntryInSegment;
} HEAP_SEGMENT, *PHEAP_SEGMENT;
*/


typedef ULONG_PTR ERESOURCE_THREAD;
typedef ERESOURCE_THREAD *PERESOURCE_THREAD;

typedef struct _OWNER_ENTRY {
    ERESOURCE_THREAD OwnerThread;
    union {
        LONG OwnerCount;
        ULONG TableSize;
    };

} OWNER_ENTRY, *POWNER_ENTRY;


typedef void * PKSEMAPHORE;
typedef void * PKEVENT;

typedef struct _ERESOURCE {
    LIST_ENTRY SystemResourcesList;
    POWNER_ENTRY OwnerTable;
    SHORT ActiveCount;
    USHORT Flag;
    PKSEMAPHORE SharedWaiters;
    PKEVENT ExclusiveWaiters;
    OWNER_ENTRY OwnerThreads[2];
    ULONG ContentionCount;
    USHORT NumberOfSharedWaiters;
    USHORT NumberOfExclusiveWaiters;
    union {
        PVOID Address;
        ULONG_PTR CreatorBackTraceIndex;
    };

    KSPIN_LOCK SpinLock;
} ERESOURCE, *PERESOURCE;

//typedef void * PRTL_TRACE_BLOCK;

#include "heap.h"
#include "heappagi.h"

#define HE_VERBOSITY_FLAGS   1
#define HE_VERBOSITY_NUMERIC 2
#define HE_VERBOSITY_VTABLE  4

#if defined(_X86_)
    #ifndef PAGE_SIZE
    #define PAGE_SIZE   0x1000
    #endif
    #define USER_ALIGNMENT 8

#elif defined(_IA64_)
    #ifndef PAGE_SIZE
    #define PAGE_SIZE   0x2000
    #endif
    #define USER_ALIGNMENT 16

#elif defined(_AMD64_)
    #ifndef PAGE_SIZE
    #define PAGE_SIZE   0x1000
    #endif
    #define USER_ALIGNMENT 16

#else
    #error  // platform not defined
#endif


//
//
//
//
//

typedef DWORD (__stdcall * fnCallBack)(ULONG_PTR pParam1,ULONG_PTR pParam2);



void
PrintHeapEntry(HEAP_ENTRY * pEntry,void * pAddr)
{

    BYTE varEntry[sizeof(HEAP_ENTRY)+2*sizeof(void *)];
    LIST_ENTRY * pListEntry = (LIST_ENTRY *)((HEAP_ENTRY *)varEntry+1);

    DWORD PrintSize = 0;
    BOOL bIsPossiblePageHeap = FALSE;
    if (pEntry->Flags & HEAP_ENTRY_BUSY)
    {
        // re-read the entry, to get if it's on the LookAside
        if (ReadMemory((MEMORY_ADDRESS)pAddr,varEntry,sizeof(varEntry),NULL))
        {
            if (0xf0f0f0f0 == (ULONG_PTR)pListEntry->Blink )
            {
                PrintSize = 0xf7eef7ee;
            }
            else 
            {
                PrintSize = (pEntry->Size<<HEAP_GRANULARITY_SHIFT)-pEntry->UnusedBytes;
            }

            DWORD Sign = *((DWORD *)pListEntry);
            //dprintf("Sign %08x\n",Sign);
            if (0xabcdaaaa == Sign)
            {
                bIsPossiblePageHeap = TRUE;
            }            
        }
        else
        {
            PrintSize = (pEntry->Size<<HEAP_GRANULARITY_SHIFT)-pEntry->UnusedBytes;
        }
    }
    else
    {
        PrintSize = 0xf7eef7ee;
    }

    dprintf("      %p: %04x . %04x [%02x] - (%x)\n",
            pAddr,pEntry->Size,pEntry->PreviousSize,pEntry->Flags,PrintSize);

    if (bIsPossiblePageHeap)
   	{
   	    //dprintf("Possible %p\n",(MEMORY_ADDRESS)((BYTE*)pAddr+sizeof(HEAP_ENTRY)+sizeof(DPH_BLOCK_INFORMATION)));
    	GetVTable((MEMORY_ADDRESS)((BYTE*)pAddr+sizeof(HEAP_ENTRY)+sizeof(DPH_BLOCK_INFORMATION)));
    }
    else
        GetVTable((MEMORY_ADDRESS)((BYTE*)pAddr+sizeof(HEAP_ENTRY)));    
};

//
//
// print the HEAP_ENTRY structure
//

DECLARE_API(he) {

    INIT_API();

    DEFINE_CPP_VAR( HEAP_ENTRY, varHEAP_ENTRY);
    HEAP_ENTRY * pEntry = GET_CPP_VAR_PTR( HEAP_ENTRY , varHEAP_ENTRY );
    memset(pEntry,0xfe,sizeof(HEAP_ENTRY));
    
    ULONG_PTR pByte = GetExpression(args);
    
    if (pByte)
    {
        if (ReadMemory((MEMORY_ADDRESS)pByte,pEntry ,sizeof(HEAP_ENTRY),NULL))
        {
            PrintHeapEntry(pEntry,(void *)pByte);
        }
        else
        {
            dprintf("ReadMemory %p %d\n",pByte,GetLastError());
        }
    } else {
        dprintf("invalid HEAP_ENTRY address %s\n",args);
    }
}

//
// HEAP_ENTRY list
// finds the beginning of the "list" of HEAP_ENTRYs
//

DECLARE_API(heb) {

    INIT_API();
    
    MEMORY_ADDRESS pEntry = GetExpression(args);
    
    if (pEntry){
       HEAP_ENTRY HeapEntry;
       ReadMemory((MEMORY_ADDRESS)pEntry,&HeapEntry,sizeof(HeapEntry),0);

       PrintHeapEntry(&HeapEntry,(void *)pEntry);

       while (HeapEntry.PreviousSize)
       {
           pEntry = (MEMORY_ADDRESS)((HEAP_ENTRY*)pEntry - HeapEntry.PreviousSize);
           if (ReadMemory((MEMORY_ADDRESS)pEntry,&HeapEntry,sizeof(HeapEntry),0))
           {
           	PrintHeapEntry(&HeapEntry,(void *)pEntry);
           }
           else
           {
               dprintf("RM %p\n",pEntry);
               break;
           }

           if (CheckControlC())
               break;           
       }

       dprintf(" begin %08x\n",pEntry);
    } else {
        dprintf("invalid address %s\n",args);
    };

}

//
//
//  HEAP_ENTRY forward
//  
//////////////////////////////////////////////////////

DECLARE_API(hef) {

    INIT_API();

    DWORD BeginNum=0;

    MEMORY_ADDRESS pEntry = GetExpression(args);

    if (pEntry)
    {
       HEAP_ENTRY HeapEntry;
       ReadMemory((MEMORY_ADDRESS)pEntry,&HeapEntry,sizeof(HeapEntry),0);

       PrintHeapEntry(&HeapEntry,(void *)pEntry);

       while (!(HeapEntry.Flags & HEAP_ENTRY_LAST_ENTRY))
       {
           pEntry = (MEMORY_ADDRESS)((HEAP_ENTRY*)pEntry + HeapEntry.Size);
           if (ReadMemory((MEMORY_ADDRESS)pEntry,&HeapEntry,sizeof(HeapEntry),0))
           {
  	           PrintHeapEntry(&HeapEntry,(void *)pEntry);
           }
           else
           {
               dprintf("RM %p\n",pEntry);
               break;
           }
                      
           if (CheckControlC())
               break;
           
       }

       dprintf(" end %08x\n",pEntry);
    } else {
        dprintf("invalid address %s\n",args);
    };

}

DWORD EnumEntries(HEAP_ENTRY * pEntry,DWORD * pSize,fnCallBack CallBack,ULONG_PTR Addr){

       DWORD i=0;
       HEAP_ENTRY HeapEntry;
       DWORD Size=0;
       ReadMemory((MEMORY_ADDRESS)pEntry,&HeapEntry,sizeof(HeapEntry),0);

       if (CallBack)
       {
           CallBack((ULONG_PTR)pEntry,Addr);
       }
       else
       {
           PrintHeapEntry(&HeapEntry,pEntry);
       };

       while (!(HeapEntry.Flags & HEAP_ENTRY_LAST_ENTRY))
       {
           if (0 == HeapEntry.Size)
           {
               dprintf("HEAP_ENTRY %p with zero Size\n",pEntry);
               break;
           }
           pEntry = (HEAP_ENTRY*)pEntry + HeapEntry.Size;
           if (ReadMemory((MEMORY_ADDRESS)pEntry,&HeapEntry,sizeof(HeapEntry),0))
           {
	           if (CallBack)
	           {
	               CallBack((ULONG_PTR)pEntry,Addr);
	           }
	           else
	           {
	               PrintHeapEntry(&HeapEntry,pEntry);
	           };
           }
           else
           {
               dprintf("RM %p\n",pEntry);
               break;
           }

           i++;
           Size += ((HeapEntry.Size<<HEAP_GRANULARITY_SHIFT)-HeapEntry.UnusedBytes);

           if (CheckControlC())
               break;
           
       }

    if (pSize){
        *pSize = Size;
    }

    return i;
}

void
PrintHEAP_SEGMENT(HEAP_SEGMENT * pSeg_OOP, 
                  fnCallBack CallBack, 
                  ULONG_PTR Addr)
{
    DEFINE_CPP_VAR( HEAP_SEGMENT, varHEAP_SEGMENT);
    HEAP_SEGMENT * pSeg = GET_CPP_VAR_PTR( HEAP_SEGMENT , varHEAP_SEGMENT );

    BOOL bRet = ReadMemory((MEMORY_ADDRESS)pSeg_OOP,pSeg ,sizeof(HEAP_SEGMENT),0);

    if (bRet)
    {
        if (!CallBack)
    	    dprintf("    Flags %08x HEAP %p\n",pSeg->Flags,pSeg->Heap);

	    //SIZE_T LargestUnCommittedRange;

	    //PVOID BaseAddress;
	    //ULONG NumberOfPages;
	    //PHEAP_ENTRY FirstEntry;
	    //PHEAP_ENTRY LastValidEntry;

	    //ULONG NumberOfUnCommittedPages;
	        DWORD unComm = pSeg->NumberOfUnCommittedRanges;
	    //PHEAP_UNCOMMMTTED_RANGE UnCommittedRanges;
	    //USHORT AllocatorBackTraceIndex;
	    //USHORT Reserved;
	    //PHEAP_ENTRY LastEntryInSegment;

        HEAP_UNCOMMMTTED_RANGE UncRange;   
        HEAP_UNCOMMMTTED_RANGE * pUncRange = pSeg->UnCommittedRanges;
        HEAP_ENTRY ** pCommRange = (HEAP_ENTRY **)_alloca(sizeof(HEAP_ENTRY *)*(unComm+1));

        DWORD Size=0;
        DWORD Num=0;

        pCommRange[0] = (HEAP_ENTRY *)pSeg->FirstEntry;

        Num = EnumEntries(pCommRange[0],&Size,CallBack,Addr);

        if (!CallBack)
            dprintf("    - %p Size %p entries %d \n",pCommRange[0],Size,Num);
            
        for (DWORD i=0; i<unComm; i++)
        {

            
            bRet = ReadMemory((MEMORY_ADDRESS)pUncRange,&UncRange,sizeof(UncRange),NULL);
            if (bRet)
            {
	            pUncRange = UncRange.Next;                
	            pCommRange[1+i] = (HEAP_ENTRY *)(UncRange.Address + UncRange.Size);

	            if (NULL == pUncRange)
	            {
	                if ((ULONG_PTR)pCommRange[1+i] == (ULONG_PTR)pSeg->LastValidEntry)
	                    break;
	            }
	           
	            Num = EnumEntries(pCommRange[1+i],&Size,CallBack,Addr);

	            if (!CallBack)
    	            dprintf("    - %p Size %p entries %d\n",pCommRange[1+i],Size,Num);
            }
            else
            {
                dprintf("RM %p\n",pUncRange);
            }
        }
    } else {
        dprintf("RM %p\n",pSeg_OOP);
    }

}

//
//
// Dump the HEAP_SEGMENT
//

DECLARE_API(hs) {

    INIT_API();
        
    ULONG_PTR pByte = 0;
    pByte = GetExpression(args);
    
    if (pByte)
    {
        PrintHEAP_SEGMENT((HEAP_SEGMENT *)pByte,NULL,NULL);
    } 
    else 
    {
        dprintf("invalid address %s\n",args);
    }
}

//
// Define heap lookaside list allocation functions.
//

typedef struct _HEAP_LOOKASIDE {
    SLIST_HEADER ListHead;

    USHORT Depth;
    USHORT MaximumDepth;

    ULONG TotalAllocates;
    ULONG AllocateMisses;
    ULONG TotalFrees;
    ULONG FreeMisses;

    ULONG LastTotalAllocates;
    ULONG LastAllocateMisses;

    ULONG Counters[2];

} HEAP_LOOKASIDE, *PHEAP_LOOKASIDE;



void Dump_LookAside(ULONG_PTR pLookAside_OOP)
{
#ifndef _WIN64
    DWORD dwSize = sizeof(HEAP_LOOKASIDE) * HEAP_MAXIMUM_FREELISTS ;

    BYTE * pData = new BYTE[dwSize];

    if (pData)
    {
        if (ReadMemory(pLookAside_OOP,pData,dwSize,NULL))
        {
            DWORD i;
            HEAP_LOOKASIDE * pLookAsideElem = NULL;
		    BYTE varHEAP_ENTRY[sizeof(HEAP_ENTRY)+sizeof(void *)];
		    HEAP_ENTRY * pEntry = GET_CPP_VAR_PTR( HEAP_ENTRY , varHEAP_ENTRY );

            
            for(i=0;i<HEAP_MAXIMUM_FREELISTS;i++)
            {
                dprintf("    entry %i\n",i);
	            pLookAsideElem = (HEAP_LOOKASIDE *)pData+i;
	            HEAP_ENTRY * pEntry_OOP = (HEAP_ENTRY *)pLookAsideElem->ListHead.Next.Next;	            
                BOOL bRet = FALSE;

                if (pEntry_OOP)
                {
                    pEntry_OOP--;
                    bRet = ReadMemory((MEMORY_ADDRESS)pEntry_OOP,pEntry,sizeof(HEAP_ENTRY)+sizeof(void *),NULL);
                }
                else
                {
                    bRet = TRUE;
                }
	            
	            while(bRet && pEntry_OOP)
	            {
	                //dprintf("pEntry_OOP %p\n",pEntry_OOP);
	                PrintHeapEntry(pEntry,pEntry_OOP);
	                pEntry_OOP = *((HEAP_ENTRY **)(pEntry+1));
	                	                
					if (pEntry_OOP)
	                {
    	                pEntry_OOP--;
	                	bRet = ReadMemory((MEMORY_ADDRESS)pEntry_OOP,pEntry,sizeof(HEAP_ENTRY)+sizeof(void *),NULL);
	                }
	                else
	                {
	                    bRet = TRUE;
	                }
	            }
	            if (!bRet && pEntry_OOP)
	                dprintf("RM %d\n",GetLastError());
            }
        }
        else
        {
            dprintf("RM %d\n",GetLastError());
        }
        delete [] pData;
    }
#endif    
}

//
//
// dump the HEAP, incomplete
//
//

DECLARE_API(hp) 
{
    INIT_API();

    DEFINE_CPP_VAR( HEAP, varHEAP);
    HEAP * pHeap = GET_CPP_VAR_PTR( HEAP , varHEAP );    
    ULONG_PTR pByte = GetExpression(args);
    DWORD i;

    if (pByte)
    {     
        if (ReadMemory(pByte,pHeap ,sizeof(HEAP),NULL))
        {

            //dprintf("-----  LookAside %p\n",pHeap->FrontEndHeap);
            //Dump_LookAside((ULONG_PTR)pHeap->FrontEndHeap);
            
	        for (i=0;i<HEAP_MAXIMUM_SEGMENTS;i++)
	        {
	            if (pHeap->Segments[i])
	                PrintHEAP_SEGMENT(pHeap->Segments[i],NULL,NULL);
	            //    dprintf(" seg %i - %p\n",i,pHeap->Segments[i]);
	            
	        }
        }
        else
        {
            dprintf("RM %p %d\n",pByte,GetLastError());
        }
    }
    else
    {
        dprintf("invalid address %s\n",args);
    }
}

//
//
//
/////////////////////////////////////////////////////////////

DWORD       g_BlockSize;
ULONG_PTR * g_pBlockBlob;

DWORD CallBackSearch(ULONG_PTR pHeapEntry_OOP,ULONG_PTR Addr)
{
    if (!g_pBlockBlob)
    {
        dprintf("no GLOBAL search block\n");
        return STATUS_NO_MEMORY;
    }
    HEAP_ENTRY Entry;
    if (ReadMemory(pHeapEntry_OOP,&Entry,sizeof(HEAP_ENTRY),NULL))
    {
        HEAP_ENTRY * pEntry = (HEAP_ENTRY *)&Entry;        
        DWORD Size = (pEntry->Flags & HEAP_ENTRY_BUSY)?(pEntry->Size<<HEAP_GRANULARITY_SHIFT)-pEntry->UnusedBytes:0;
        if (Size)
        {
            if (Size < g_BlockSize)
            {
                ULONG_PTR * pData = (ULONG_PTR *)g_pBlockBlob;
                ReadMemory(pHeapEntry_OOP+sizeof(HEAP_ENTRY),pData,Size,NULL);
                
                // here is the assumption that pointers are aligned
                DWORD nTimes = Size/sizeof(ULONG_PTR);
                DWORD i;
                for (i=0;i<nTimes;i++)
                {
                    if (Addr == pData[i])
                    {
                        dprintf("- %p off %p\n",pHeapEntry_OOP,sizeof(ULONG_PTR)*i);
                        PrintHeapEntry((HEAP_ENTRY *)pEntry,(void *)pHeapEntry_OOP);
                    }
                }
            }
            else
            {
                dprintf("        entry %p too big\n",pHeapEntry_OOP);
            }
        }         
    }
    else
    {
        dprintf("RM %p\n",pHeapEntry_OOP);
    }
    return 0;
}

//
//
// search the HEAP, incomplete
//
///////////////////////////////////////////////

DECLARE_API(shp) 
{
    INIT_API();

    DEFINE_CPP_VAR( HEAP, varHEAP);
    HEAP * pHeap = GET_CPP_VAR_PTR( HEAP , varHEAP );    
    

    char * pArgs = (char *)args;
    while(isspace(*pArgs)) pArgs++;

    ULONG_PTR pByte = GetExpression(pArgs);

    while(!isspace(*pArgs)) pArgs++;

    ULONG_PTR Addr = GetExpression(pArgs);
    
    DWORD i;

    if (pByte && Addr)
    {
        g_BlockSize = 0x10000*sizeof(HEAP_ENTRY);
        g_pBlockBlob = (ULONG_PTR *)VirtualAlloc(NULL,g_BlockSize,MEM_COMMIT,PAGE_READWRITE);

        if (!g_pBlockBlob)
        {
            dprintf("VirtualAlloc err %d\n",GetLastError());
            return;
        }        
             
        if (ReadMemory(pByte,pHeap ,sizeof(HEAP),NULL))
        {
            
	        for (i=0;i<HEAP_MAXIMUM_SEGMENTS;i++)
	        {
	            if (pHeap->Segments[i])
	                PrintHEAP_SEGMENT(pHeap->Segments[i],CallBackSearch,Addr);
	            //    dprintf(" seg %i - %p\n",i,pHeap->Segments[i]);
	            
	        }
        }
        else
        {
            dprintf("RM %p %d\n",pByte,GetLastError());
        }

        if (g_pBlockBlob)
        {
            VirtualFree(g_pBlockBlob,g_BlockSize,MEM_DECOMMIT|MEM_RELEASE);
            g_pBlockBlob = NULL;
            g_BlockSize = 0;
        }
    }
    else
    {
        dprintf("invalid heap address pair in%s\n",args);
    }
}

//
//  decode heap flags
//
/*
#define HEAP_NO_SERIALIZE               0x00000001      // winnt
#define HEAP_GROWABLE                   0x00000002      // winnt
#define HEAP_GENERATE_EXCEPTIONS        0x00000004      // winnt
#define HEAP_ZERO_MEMORY                0x00000008      // winnt
#define HEAP_REALLOC_IN_PLACE_ONLY      0x00000010      // winnt
#define HEAP_TAIL_CHECKING_ENABLED      0x00000020      // winnt
#define HEAP_FREE_CHECKING_ENABLED      0x00000040      // winnt
#define HEAP_DISABLE_COALESCE_ON_FREE   0x00000080      // winnt

#define HEAP_SETTABLE_USER_VALUE        0x00000100
#define HEAP_SETTABLE_USER_FLAG1        0x00000200
#define HEAP_SETTABLE_USER_FLAG2        0x00000400
#define HEAP_SETTABLE_USER_FLAG3        0x00000800

#define HEAP_CLASS_0                    0x00000000      // process heap
#define HEAP_CLASS_1                    0x00001000      // private heap
#define HEAP_CLASS_2                    0x00002000      // Kernel Heap
#define HEAP_CLASS_3                    0x00003000      // GDI heap
#define HEAP_CLASS_4                    0x00004000      // User heap
#define HEAP_CLASS_5                    0x00005000      // Console heap
#define HEAP_CLASS_6                    0x00006000      // User Desktop heap
#define HEAP_CLASS_7                    0x00007000      // Csrss Shared heap
#define HEAP_CLASS_8                    0x00008000      // Csr Port heap
*/
#define HEAP_LOCK_USER_ALLOCATED            (ULONG)0x80000000
#define HEAP_VALIDATE_PARAMETERS_ENABLED    (ULONG)0x40000000
#define HEAP_VALIDATE_ALL_ENABLED           (ULONG)0x20000000
#define HEAP_SKIP_VALIDATION_CHECKS         (ULONG)0x10000000
#define HEAP_CAPTURE_STACK_BACKTRACES       (ULONG)0x08000000

#define HEAP_FLAG_PAGE_ALLOCS       0x01000000

#define HEAP_PROTECTION_ENABLED     0x02000000
#define HEAP_BREAK_WHEN_OUT_OF_VM   0x04000000
#define HEAP_NO_ALIGNMENT           0x08000000



void DecodeFlags(ULONG Flags)
{
    dprintf("           Flags: %08x ",Flags);
    if (Flags & HEAP_NO_SERIALIZE)
	   	dprintf("HEAP_NO_SERIALIZE ");
    if (Flags & HEAP_GROWABLE)
    	dprintf("HEAP_GROWABLE ");
    if (Flags & HEAP_GENERATE_EXCEPTIONS)
    	dprintf("HEAP_GENERATE_EXCEPTIONS ");
    if (Flags & HEAP_ZERO_MEMORY)
    	dprintf("HEAP_ZERO_MEMORY ");
    
    if (Flags & HEAP_REALLOC_IN_PLACE_ONLY)
    	dprintf("HEAP_REALLOC_IN_PLACE_ONLY ");
    if (Flags & HEAP_TAIL_CHECKING_ENABLED)
    	dprintf("HEAP_TAIL_CHECKING_ENABLED ");
    if (Flags & HEAP_FREE_CHECKING_ENABLED)
    	dprintf("HEAP_FREE_CHECKING_ENABLED ");
    if (Flags & HEAP_DISABLE_COALESCE_ON_FREE)
    	dprintf("HEAP_DISABLE_COALESCE_ON_FREE ");
    
    if (Flags & HEAP_SETTABLE_USER_VALUE)
    	dprintf("HEAP_SETTABLE_USER_VALUE ");    
    if (Flags & HEAP_SETTABLE_USER_FLAG1)
    	dprintf("HEAP_SETTABLE_USER_FLAG1 ");
    if (Flags & HEAP_SETTABLE_USER_FLAG2)
    	dprintf("HEAP_SETTABLE_USER_FLAG2 ");
    if (Flags & HEAP_SETTABLE_USER_FLAG3)
    	dprintf("HEAP_SETTABLE_USER_FLAG3 ");

    if (Flags & HEAP_CLASS_MASK)
    	dprintf("HEAP_CLASS %d",(Flags&HEAP_CLASS_MASK)>>12);
/*    
    if (Flags & HEAP_CLASS_1)
    	dprintf("HEAP_CLASS_1 ");
    if (Flags & HEAP_CLASS_2)
    	dprintf("HEAP_CLASS_2 ");
    if (Flags & HEAP_CLASS_3)
    	dprintf("HEAP_CLASS_3 ");
    if (Flags & HEAP_CLASS_4)
    	dprintf("HEAP_CLASS_4 ");
    if (Flags & HEAP_CLASS_5)
    	dprintf("HEAP_CLASS_5 ");
    if (Flags & HEAP_CLASS_6)
    	dprintf("HEAP_CLASS_6 ");
    if (Flags & HEAP_CLASS_7)
    	dprintf("HEAP_CLASS_7 ");
*/    	

    //if (Flags & HEAP_CAPTURE_STACK_BACKTRACES)
    //	dprintf("HEAP_CAPTURE_STACK_BACKTRACES ");    
    if (Flags &HEAP_SKIP_VALIDATION_CHECKS)
    	dprintf("HEAP_SKIP_VALIDATION_CHECKS ");
    if (Flags &HEAP_VALIDATE_ALL_ENABLED)
    	dprintf("HEAP_VALIDATE_ALL_ENABLED ");
    if (Flags &HEAP_VALIDATE_PARAMETERS_ENABLED)
    	dprintf("HEAP_VALIDATE_PARAMETERS_ENABLED ");
    if (Flags &HEAP_LOCK_USER_ALLOCATED)
    	dprintf("HEAP_LOCK_USER_ALLOCATED ");

    if (Flags &HEAP_FLAG_PAGE_ALLOCS)
    	dprintf("HEAP_FLAG_PAGE_ALLOCS "); 
    if (Flags &HEAP_PROTECTION_ENABLED)
    	dprintf("HEAP_PROTECTION_ENABLED "); 
    if (Flags &HEAP_BREAK_WHEN_OUT_OF_VM)
    	dprintf("HEAP_BREAK_WHEN_OUT_OF_VM "); 
    if (Flags &HEAP_NO_ALIGNMENT)
    	dprintf("HEAP_NO_ALIGNMENT ");     
    
    //if (Flags &)
    //	dprintf(" ");    
    dprintf("\n");
}

//
//  Get all the heaps
//

DECLARE_API(hps)
{
    INIT_API();

    PEB * pPeb = NULL;
    PEB   ThisPeb;
    GetPeb(hCurrentProcess,&pPeb);

    if(!pPeb)
    {
#ifdef  _WIN64
        pPeb = (PEB *)0x6fbfffde000;
#else
        pPeb = (PEB *)0x7ffdf000;
#endif
    }
    
    if (pPeb)
    {
        ReadMemory((MEMORY_ADDRESS)pPeb,&ThisPeb,sizeof(PEB),0);
        void ** pHeaps = (void**)_alloca(ThisPeb.NumberOfHeaps*sizeof(void*));
        DWORD i,j;
        ULONG_PTR TotCommitSize = 0;
        ULONG_PTR TotVirtSize = 0;        

        if (ReadMemory((MEMORY_ADDRESS)ThisPeb.ProcessHeaps,pHeaps,ThisPeb.NumberOfHeaps*sizeof(void*),0))
        {
	        for(i=0;i<ThisPeb.NumberOfHeaps;i++)
	        {
	            DEFINE_CPP_VAR( HEAP, varHEAP);
	            HEAP * pHeap = GET_CPP_VAR_PTR( HEAP , varHEAP );
	            ULONG_PTR TotHeapCommitSize = 0;
	            ULONG_PTR TotHeapVirtSize = 0;

	            if (ReadMemory((MEMORY_ADDRESS)pHeaps[i],pHeap ,sizeof(HEAP),0))
	            {
		            for (j=0;j<HEAP_MAXIMUM_SEGMENTS;j++)
		            {
		                if (pHeap->Segments[j])
		                {
		                    DEFINE_CPP_VAR( HEAP_SEGMENT, varHEAP_SEGMENT);
		                    HEAP_SEGMENT * pHeapSeg = GET_CPP_VAR_PTR( HEAP_SEGMENT , varHEAP_SEGMENT ); 

		                    if (ReadMemory((MEMORY_ADDRESS)pHeap->Segments[j],pHeapSeg,sizeof(HEAP_SEGMENT),0))
		                    {
			                    dprintf("       - %p (C %p - R %p)\n",
			                            pHeap->Segments[j],
			                            (pHeapSeg->NumberOfPages - pHeapSeg->NumberOfUnCommittedPages) * PAGE_SIZE,
			                            (pHeapSeg->NumberOfPages) * PAGE_SIZE);
			                    
			                    TotHeapCommitSize += ((pHeapSeg->NumberOfPages - pHeapSeg->NumberOfUnCommittedPages) * PAGE_SIZE);
			                    TotHeapVirtSize += ((pHeapSeg->NumberOfPages) * PAGE_SIZE);
			                    // now print the beggining of a committed range
			                    dprintf("            CR %p\n",pHeapSeg->BaseAddress);
			                    HEAP_UNCOMMMTTED_RANGE * pUncomm_OOP = pHeapSeg->UnCommittedRanges;
			                    for (DWORD i=0;i<pHeapSeg->NumberOfUnCommittedRanges && pUncomm_OOP;i++)			                    	
			                    {
			                        HEAP_UNCOMMMTTED_RANGE UncommRange;
			                        if (ReadMemory((MEMORY_ADDRESS)pUncomm_OOP,&UncommRange,sizeof(HEAP_UNCOMMMTTED_RANGE),NULL))
			                        {
			                            if (UncommRange.Next)
			                            {
			                                pUncomm_OOP = UncommRange.Next;
			                            }
			                            ULONG_PTR RangeAddr = (ULONG_PTR)UncommRange.Address+UncommRange.Size;
			                            if (RangeAddr != (ULONG_PTR)pHeapSeg->LastEntryInSegment)
			                            dprintf("            CR %p\n",RangeAddr);
			                        }
			                        else
			                        {
			                            dprintf("RM %p\n",pHeapSeg->UnCommittedRanges);
			                            break;
			                        }
			                    }
		                    }
		                    else
		                    {
		                        dprintf("RM %p\n",pHeap->Segments[j]);
		                    }
		                }
		            }
	            }
	            else
	            {
    	            dprintf("RM %p\n",pHeaps[i]);
    	            pHeap = NULL;
	            }	            	
	            dprintf("       HEAP %p - %p\n",pHeaps[i],TotHeapCommitSize);
	            if (pHeap)
    	            DecodeFlags(pHeap->Flags|pHeap->ForceFlags);
	            TotCommitSize += TotHeapCommitSize;
	            TotVirtSize += TotHeapVirtSize;
	        }
	        dprintf("      -- Tot C %p Tot R %p\n",TotCommitSize, TotVirtSize);
       	}
        else
        {
            dprintf("RM %p\n",ThisPeb.ProcessHeaps);
        }
    }
    else
    {
        dprintf("unable to get PEB\n");
    }
}


//
//  reverse heap free list
//
//////////////////

DWORD
CallBackFreeList(VOID * pStructure_OOP,
                 VOID * pLocalCopy)
{
    HEAP_FREE_ENTRY * pFreeEntry = (HEAP_FREE_ENTRY *)pLocalCopy;

    dprintf("    %p (%p,%p): %04x - %04x [%02x] %02x %02x (%x)\n",
            pStructure_OOP,
            pFreeEntry->FreeList.Flink,
            pFreeEntry->FreeList.Blink,
            pFreeEntry->Size,
            pFreeEntry->PreviousSize,
            pFreeEntry->Flags,
            pFreeEntry->Index,
            pFreeEntry->Mask,
            pFreeEntry->Size*sizeof(HEAP_ENTRY));
            
    return 0;    
}


DECLARE_API( rllc )
{
    INIT_API();

    ULONG_PTR Addr = GetExpression(args);

    if (Addr)
    {
        EnumReverseLinkedListCB((LIST_ENTRY *)Addr,
                                sizeof(HEAP_FREE_ENTRY),
                                FIELD_OFFSET(HEAP_FREE_ENTRY,FreeList),
                                CallBackFreeList);
    }
    else
    {
        dprintf("cannot resolve %s\n",args);
    }
}

//
//
//  Print the Free Lists of the Heap
//
/////////////////////////////////////////////////

DWORD
CallBackFreeList2(VOID * pStructure_OOP,
                 VOID * pLocalCopy)
{
    HEAP_FREE_ENTRY * pFreeEntry = (HEAP_FREE_ENTRY *)pLocalCopy;

    dprintf("    %p (%p,%p): %04x - %04x [%02x] %02x %02x (%x)",
            pStructure_OOP,
            pFreeEntry->FreeList.Flink,
            pFreeEntry->FreeList.Blink,
            pFreeEntry->Size,
            pFreeEntry->PreviousSize,
            pFreeEntry->Flags,
            pFreeEntry->Index,
            pFreeEntry->Mask,
            pFreeEntry->Size*sizeof(HEAP_ENTRY));

    MEMORY_ADDRESS pEntry = (MEMORY_ADDRESS)pStructure_OOP;
    
    HEAP_ENTRY HeapEntry;
    ReadMemory((MEMORY_ADDRESS)pEntry,&HeapEntry,sizeof(HeapEntry),0);

    while (HeapEntry.PreviousSize)
    {
        pEntry = (MEMORY_ADDRESS)((HEAP_ENTRY*)pEntry - HeapEntry.PreviousSize);
        if (ReadMemory((MEMORY_ADDRESS)pEntry,&HeapEntry,sizeof(HeapEntry),0))
        {           	
        }
        else
        {
            dprintf("RM %p\n",pEntry);
            break;
        }

        if (CheckControlC())
           break;           
    }
    dprintf(" -B %p\n",pEntry);            
    return 0;    
}


DECLARE_API( hpf )
{
    INIT_API();

    DEFINE_CPP_VAR( HEAP, varHEAP);
    HEAP * pHeap = GET_CPP_VAR_PTR( HEAP , varHEAP );    
    ULONG_PTR pByte = GetExpression(args);

    if (pByte)
    {     
        if (ReadMemory(pByte,pHeap ,sizeof(HEAP),NULL))
        {
            HEAP * pHeap_OOP = (HEAP *)pByte;        
            DWORD i;            
	        for (i=0;i<HEAP_MAXIMUM_FREELISTS;i++)
	        {
	            dprintf("    FreeList[%x] @ %p\n",i,&pHeap_OOP->FreeLists[i]);
                EnumReverseLinkedListCB((LIST_ENTRY *)&pHeap_OOP->FreeLists[i],
                                       sizeof(HEAP_FREE_ENTRY),
                                       FIELD_OFFSET(HEAP_FREE_ENTRY,FreeList),
                                       CallBackFreeList2);	            
	        }
        }
        else
        {
            dprintf("RM %p\n",pByte);
        }
    }
    else
    {
        dprintf("invalid address %s\n",args);
    }
    
}

//
// dumps the DPH_HEAP_ROOT
//
///////////////////////////////////////

DECLARE_API( php )
{
    INIT_API();

    char * pHeapAddr = (char *)args;
    while (isspace(*pHeapAddr)) pHeapAddr++;

    char * pNext = pHeapAddr;
    while (!isspace(*pNext)) pNext++; // skipt the Heap Addr
    if (*pNext)
    {
        *pNext = 0;
        pNext++;
    }    	
    ULONG_PTR Addr = GetExpression(pHeapAddr);    
    while (isspace(*pNext)) pNext++; // skip the other spaces
    ULONG_PTR SearchAddr = 0;
    if (*pNext == 's' ||*pNext == 'S')
    {
        pNext++; // skip the 's'
        if (*pNext)
        {
            while(isspace(*pNext)) pNext++; // skip the spaces
            SearchAddr = GetExpression(pNext);
        } 
    }

    //dprintf("heap %p addr %p\n",Addr,SearchAddr);

    if (Addr)
    {

        g_BlockSize = 0x10000*sizeof(HEAP_ENTRY);
        g_pBlockBlob = NULL;
        if (SearchAddr)
            g_pBlockBlob = (ULONG_PTR *)VirtualAlloc(NULL,g_BlockSize,MEM_COMMIT,PAGE_READWRITE);

        if (SearchAddr && !g_pBlockBlob)
        {
            dprintf("VirtualAlloc err %d\n",GetLastError());
            return;
        }        

        HEAP Heap;
        DPH_HEAP_ROOT HeapPage;
        if (0 == SearchAddr)
            dprintf("  HEAP @ %p\n",Addr);
        if (ReadMemory((MEMORY_ADDRESS)Addr,&Heap,sizeof(HEAP),NULL))
        {
            if (Heap.ForceFlags & HEAP_FLAG_PAGE_ALLOCS)
            {
                Addr += PAGE_SIZE;
                dprintf("  DPH_HEAP_ROOT @ %p\n",Addr);
                if (ReadMemory((MEMORY_ADDRESS)Addr,&HeapPage,sizeof(DPH_HEAP_ROOT),NULL))
                {
                    DPH_HEAP_BLOCK HeapBlock;                
                    DPH_HEAP_BLOCK * pNextBlock;

                    if (0 == SearchAddr)
                    {
	                    pNextBlock = HeapPage.pVirtualStorageListHead;
	                    dprintf("    - pVirtualStorageListHead\n");                    
	                    while(pNextBlock)
	                    {

	                        if (ReadMemory((MEMORY_ADDRESS)pNextBlock,&HeapBlock,sizeof(DPH_HEAP_BLOCK),NULL))
	                        {
	                            dprintf("    %p - (%p) B %p S %p \n",
	                            	   pNextBlock,
	                            	   HeapBlock.pNextAlloc,
	                            	   HeapBlock.pVirtualBlock,
	                            	   HeapBlock.nVirtualBlockSize);
	                            pNextBlock = HeapBlock.pNextAlloc;
	                        }
	                        else
	                        {
	                            pNextBlock = NULL;
	                        }
	                    }
                    }
                
                    pNextBlock = HeapPage.pBusyAllocationListHead;
                    if (0 == SearchAddr)
                        dprintf("    - pBusyAllocationListHead\n");
                    while(pNextBlock)
                    {
                        if (ReadMemory((MEMORY_ADDRESS)pNextBlock,&HeapBlock,sizeof(DPH_HEAP_BLOCK),NULL))
                        {
                            if (0 == SearchAddr)
                            {
	                            dprintf("    %p - (%p) %x %x %x U %p S %p\n",
	                            	   pNextBlock,
	                            	   HeapBlock.pNextAlloc,
	                            	   ULONG_PTR(HeapBlock.pVirtualBlock)/PAGE_SIZE,
	                            	   HeapBlock.nVirtualBlockSize/PAGE_SIZE,
	                            	   HeapBlock.nVirtualAccessSize/PAGE_SIZE,
	                            	   HeapBlock.pUserAllocation,
	                            	   HeapBlock.StackTrace_);
	                            GetVTable((MEMORY_ADDRESS)HeapBlock.pUserAllocation+sizeof(DPH_BLOCK_INFORMATION));
                            }
                            else // do the real search
                            {
                                ULONG_PTR Size = (MEMORY_ADDRESS)HeapBlock.pVirtualBlock+HeapBlock.nVirtualAccessSize-(MEMORY_ADDRESS)HeapBlock.pUserAllocation;
                                if (ReadMemory((MEMORY_ADDRESS)HeapBlock.pUserAllocation,g_pBlockBlob,(ULONG)Size,NULL))
                                {
                                    Size /= sizeof(ULONG_PTR);
                                    BOOL bFound = FALSE;
                                    for (ULONG_PTR j =0;j<Size;j++)
                                    {
                                        if (SearchAddr == g_pBlockBlob[j])
                                        {
                                            bFound = TRUE;
                                        	dprintf("    OFF %p\n",j*sizeof(ULONG_PTR));
                                        }
                                    }
                                    if (bFound)
                                    {
                                        dprintf("    B   %p\n",HeapBlock.pUserAllocation);
                                    }
                                }
                                else
                                {
                                    dprintf("RM %p\n",HeapBlock.pUserAllocation);
                                }
                            }
                            pNextBlock = HeapBlock.pNextAlloc;
                        }
                        else
                        {
                            pNextBlock = NULL;
                        }
                    }

                    if (0 == SearchAddr)
                    {                    
	                    pNextBlock = HeapPage.pFreeAllocationListHead;
	                    dprintf("    - pFreeAllocationListHead\n");
	                    while(pNextBlock)
	                    {
	                        if (ReadMemory((MEMORY_ADDRESS)pNextBlock,&HeapBlock,sizeof(DPH_HEAP_BLOCK),NULL))
	                        {
	                            dprintf("    %p - (%p) %x %x %x U %p S %p\n",
	                            	   pNextBlock,
	                            	   HeapBlock.pNextAlloc,
	                            	   ULONG_PTR(HeapBlock.pVirtualBlock)/PAGE_SIZE,
	                            	   HeapBlock.nVirtualBlockSize/PAGE_SIZE,
	                            	   HeapBlock.nVirtualAccessSize/PAGE_SIZE,
	                            	   HeapBlock.pUserAllocation,
	                            	   HeapBlock.StackTrace_);
	                            pNextBlock = HeapBlock.pNextAlloc;
	                        }
	                        else
	                        {
	                            pNextBlock = NULL;
	                        }
	                    }
                    }

                    if (0 == SearchAddr)
                    {                    
	                    pNextBlock = HeapPage.pAvailableAllocationListHead;
	                    dprintf("    - pAvailableAllocationListHead\n");
	                    while(pNextBlock)
	                    {

	                        if (ReadMemory((MEMORY_ADDRESS)pNextBlock,&HeapBlock,sizeof(DPH_HEAP_BLOCK),NULL))
	                        {
	                            dprintf("    %p - (%p) B %p S %p \n",
	                            	   pNextBlock,
	                            	   HeapBlock.pNextAlloc,
	                            	   HeapBlock.pVirtualBlock,
	                            	   HeapBlock.nVirtualBlockSize);
	                            pNextBlock = HeapBlock.pNextAlloc;
	                        }
	                        else
	                        {
	                            pNextBlock = NULL;
	                        }
	                    }
                    }

                    if (0 == SearchAddr)
                    {
	                    pNextBlock = HeapPage.pNodePoolListHead;
	                    dprintf("    - pNodePoolListHead\n");
	                    while(pNextBlock)
	                    {

	                        if (ReadMemory((MEMORY_ADDRESS)pNextBlock,&HeapBlock,sizeof(DPH_HEAP_BLOCK),NULL))
	                        {
	                            dprintf("    %p - (%p) B %p S %p \n",
	                            	   pNextBlock,
	                            	   HeapBlock.pNextAlloc,
	                            	   HeapBlock.pVirtualBlock,
	                            	   HeapBlock.nVirtualBlockSize);
	                            pNextBlock = HeapBlock.pNextAlloc;
	                        }
	                        else
	                        {
	                            pNextBlock = NULL;
	                        }
	                    }
                    }                    

                    dprintf("  NormalHeap @ %p\n",HeapPage.NormalHeap);
	                if (ReadMemory((ULONG_PTR)HeapPage.NormalHeap,&Heap ,sizeof(HEAP),NULL))
	                {
				        for (DWORD h=0;h<HEAP_MAXIMUM_SEGMENTS;h++)
				        {
				            if (Heap.Segments[h])
				            {
				                if (SearchAddr)
					                PrintHEAP_SEGMENT(Heap.Segments[h],CallBackSearch,SearchAddr);
				                else
				                	PrintHEAP_SEGMENT(Heap.Segments[h],NULL,NULL);
				            }
				        }
			        }
			        else
			        {
			            dprintf("RM %p\n",HeapPage.NormalHeap);
			        }
                    
                }
                else
                {
                    dprintf("RM %p\n",Addr);
                }

            }
            else
            {
                DecodeFlags(Heap.ForceFlags|Heap.Flags);
            }
        }
        else
        {
            dprintf("RM %p\n",Addr);
        }

        if (g_pBlockBlob)
        {
            VirtualFree(g_pBlockBlob,g_BlockSize,MEM_DECOMMIT|MEM_RELEASE);
            g_pBlockBlob = NULL;
            g_BlockSize = 0;
        }
        
    }
    else
    {
        dprintf("unable to resolve %s\n",args);
    }
}

//
//
//  virtual_query helper
//
///////////////////////////////////////////////////////////////

char * GetState(DWORD State)
{
    switch(State)
    {
    case MEM_COMMIT:
        return "MEM_COMMIT";
    case MEM_RESERVE:
        return "MEM_RESERVE";
    case MEM_FREE:
        return "MEM_FREE";
    };
    return "";
}

char * GetType(DWORD Type)
{
    switch(Type)
    {
    case MEM_IMAGE:
        return "MEM_IMAGE";
    case MEM_MAPPED:
        return "MEM_MAPPED";
    case MEM_PRIVATE:
        return "MEM_PRIVATE";
    }
    return "";
}

char * GetProtect(DWORD Protect)
{
    switch(Protect)
    {
    case PAGE_NOACCESS:
        return "PAGE_NOACCESS";
    case PAGE_READONLY:
        return "PAGE_READONLY";
    case PAGE_READWRITE:
        return "PAGE_READWRITE";
    case PAGE_WRITECOPY:
        return "PAGE_WRITECOPY";
    case PAGE_EXECUTE:
        return "PAGE_EXECUTE";
    case PAGE_EXECUTE_READ:
        return "PAGE_EXECUTE_READ";
    case PAGE_EXECUTE_READWRITE:
        return "PAGE_EXECUTE_READWRITE";
    case PAGE_EXECUTE_WRITECOPY:
        return "PAGE_EXECUTE_WRITECOPY";
    case PAGE_GUARD:
        return "PAGE_GUARD";
    case PAGE_NOCACHE:
        return "PAGE_NOCACHE";
    case PAGE_WRITECOMBINE:
        return "PAGE_WRITECOMBINE";
    }
    return "<unk>";
}

//
//
//  VirtualQueryEx
//
//
//  vq -a address
//  vq -f filter <all address space>
//
///////////////////////////////////////////

DECLARE_API(vq)
{
    INIT_API();

    ULONG_PTR pVA = 0;
    SIZE_T Filter = (SIZE_T)-1;
    BOOL bAll = TRUE;

    char * pCurrent = (char *)args;
    
    if(0 < strlen(pCurrent))
    {
        while (isspace(*pCurrent)) pCurrent++;
        if ('-' == *pCurrent  ||
            '/'  == *pCurrent)
        {
            pCurrent++;
            while (isspace(*pCurrent)) pCurrent++;
            if ('a' == *pCurrent)
            {
                pCurrent++;
                while (isspace(*pCurrent)) pCurrent++;
                pVA = GetExpression(pCurrent);
                bAll = FALSE;
            } 
            else if ('f' == *pCurrent)
            {
                pCurrent++;
                while (isspace(*pCurrent)) pCurrent++;
                Filter = GetExpression(args);                
            }
            else
            {
                dprintf("usage: -a ADDR\n"
                        "usage: -F Filter <all address space>\n");
            }
        }
    }
    else
    {
        dprintf("no param\n");
    }


    ULONG_PTR Tot = 0; 
    MEMORY_BASIC_INFORMATION MemInfo;
    SIZE_T dwRet = 0;
    
    do
    {
        dwRet = VirtualQueryEx(hCurrentProcess,(LPCVOID)pVA,&MemInfo,sizeof(MemInfo));
    
        if (dwRet && (MemInfo.AllocationProtect & Filter))
        {
            dprintf("    Base %p Alloc %p Prot %s Size %p %s %s %s\n",
                MemInfo.BaseAddress,
                MemInfo.AllocationBase,
                GetProtect(MemInfo.AllocationProtect),
                MemInfo.RegionSize,
                GetState(MemInfo.State),
                GetProtect(MemInfo.Protect),
                GetType(MemInfo.Type));
            Tot += MemInfo.RegionSize;
        }
        
        pVA = (ULONG_PTR)MemInfo.BaseAddress + (ULONG_PTR)MemInfo.RegionSize;
        
        if (CheckControlC())
            break;
    } while (dwRet && bAll);

    dprintf("    Total %p\n",Tot);

}

//
//
//
//

#ifdef KDEXT_64BIT

struct _HEAP_ENTRY_64 
{
   WORD Size         ;
   WORD PreviousSize ;
   BYTE SegmentIndex ;
   BYTE Flags        ;
   BYTE UnusedBytes  ;
   BYTE SmallTagIndex;
   ULONG64 Pointer;
};

#endif /*KDEXT_64BIT*/

DECLARE_API(hef64)
{
    INIT_API();
#ifdef KDEXT_64BIT

    _HEAP_ENTRY_64 HeapEntry;
    ULONG64  MemAddr = GetExpression(args);
    ULONG64  pVTable = 0;

    if (MemAddr)
    {
        if (ReadMemory(MemAddr,&HeapEntry,sizeof(HeapEntry),NULL))
        {
            dprintf("    %p: %04x - %04x [%02x] (%x)\n",MemAddr,HeapEntry.Size,HeapEntry.PreviousSize,HeapEntry.Flags,HeapEntry.Size*sizeof(_HEAP_ENTRY_64)-HeapEntry.UnusedBytes);
            GetVTable(MemAddr + sizeof(_HEAP_ENTRY_64));
            MemAddr = MemAddr+HeapEntry.Size*sizeof(_HEAP_ENTRY_64);
                        
            // 0x10 is LAST_ENTRY
            while(!(HeapEntry.Flags & 0x10))
            {
        		if (ReadMemory(MemAddr,&HeapEntry,sizeof(HeapEntry),NULL))
		        {
                    dprintf("    %p: %04x - %04x [%02x] (%x)\n",MemAddr,HeapEntry.Size,HeapEntry.PreviousSize,HeapEntry.Flags,HeapEntry.Size*sizeof(_HEAP_ENTRY_64)-HeapEntry.UnusedBytes);
                    GetVTable(MemAddr + sizeof(_HEAP_ENTRY_64));                    
		            MemAddr = MemAddr+HeapEntry.Size*sizeof(_HEAP_ENTRY_64);
		        }
		        else
        		{
		            dprintf("RM %p\n",MemAddr);
        		}
        		if (CheckControlC())
        		    break;
            }
            dprintf("last %p\n",MemAddr);
        }
        else
        {
            dprintf("RM %p\n",MemAddr);
        }
    }
    else
    {
        dprintf("unable to resolve %s\n",args);
    }
    
#endif /*KDEXT_64BIT*/    
}

DECLARE_API(heb64)
{
    INIT_API();
#ifdef KDEXT_64BIT

    _HEAP_ENTRY_64 HeapEntry;
    ULONG64  MemAddr = GetExpression(args);
    ULONG64  pVTable = 0;

    if (MemAddr)
    {
        if (ReadMemory(MemAddr,&HeapEntry,sizeof(HeapEntry),NULL))
        {
            dprintf("    %p: %04x - %04x [%02x] (%x)\n",MemAddr,HeapEntry.Size,HeapEntry.PreviousSize,HeapEntry.Flags,HeapEntry.Size*sizeof(_HEAP_ENTRY_64)-HeapEntry.UnusedBytes);
            GetVTable(MemAddr + sizeof(_HEAP_ENTRY_64));
            MemAddr = MemAddr - HeapEntry.PreviousSize*sizeof(_HEAP_ENTRY_64);
                        
            // 0x10 is LAST_ENTRY
            while(HeapEntry.PreviousSize)
            {
        		if (ReadMemory(MemAddr,&HeapEntry,sizeof(HeapEntry),NULL))
		        {
                    dprintf("    %p: %04x - %04x [%02x] (%x)\n",MemAddr,HeapEntry.Size,HeapEntry.PreviousSize,HeapEntry.Flags,HeapEntry.Size*sizeof(_HEAP_ENTRY_64)-HeapEntry.UnusedBytes);
                    GetVTable(MemAddr + sizeof(_HEAP_ENTRY_64));                    
		            MemAddr = MemAddr - HeapEntry.PreviousSize*sizeof(_HEAP_ENTRY_64);
		        }
		        else
        		{
		            dprintf("RM %p\n",MemAddr);
        		}
        		if (CheckControlC())
        		    break;
            }
                                    
            dprintf("last %p\n",MemAddr);
        }
        else
        {
            dprintf("RM %p\n",MemAddr);
        }
    }
    else
    {
        dprintf("unable to resolve %s\n",args);
    }
    
#endif /*KDEXT_64BIT*/    
}


DECLARE_API(hps64)
{
    INIT_API();
#ifdef KDEXT_64BIT

    ULONG64 Peb = GetExpression(args);

    if (!Peb)
    {
        Peb = 0x6fbfffde000;
    }

    ULONG NumberOfHeapsOffset;
    ULONG HeapsOffset;
    
    ULONG SegmentsOffset;    
    
    if ( Peb &&
         (0 == GetFieldOffset("ntdll!_PEB","NumberOfHeaps",&NumberOfHeapsOffset)) &&
         (0 == GetFieldOffset("ntdll!_PEB","ProcessHeaps",&HeapsOffset)) &&
         (0 == GetFieldOffset("ntdll!_HEAP","Segments",&SegmentsOffset)))
    {
        //dprintf(" %x %x\n",NumberOfHeapsOffset,HeapsOffset);
        ULONG nHeaps;
        ULONG64 MemAddr;
        if (ReadMemory(Peb+NumberOfHeapsOffset,&nHeaps,sizeof(ULONG),NULL))
        {
            //dprintf("nHeaps %08x\n",nHeaps);
            ReadMemory(Peb+HeapsOffset,&MemAddr,sizeof(ULONG64),NULL);
            ULONG64 * pHeaps = (ULONG64 *)_alloca(sizeof(ULONG64)*(DWORD)nHeaps);
            ReadMemory(MemAddr,pHeaps,sizeof(ULONG64)*(DWORD)nHeaps,NULL);

            //  +0x0a0 Segments         : [64] 0x000006fb`f9fa0c50

            ULONG64 Segments[64];
                        
            for(ULONG i=0;i<nHeaps;i++)
            {
                if (ReadMemory(pHeaps[i]+SegmentsOffset,Segments,sizeof(Segments),NULL))
                {
	                for (DWORD j=0;j<64;j++)
	                {
	                    if (Segments[j])
	                    {
	                        dprintf("        S %p\n",Segments[j]);
	                    }
		        		if (CheckControlC())
        				    break;	                    
	                }
                }
                dprintf("    %p\n",pHeaps[i]);
                
        		if (CheckControlC())
        		    break;                
            }
        }
        else
        {
            dprintf("RM %p\n",Peb+NumberOfHeapsOffset);
        }
    }
    else
    {
        dprintf("check symbols for ntdll.dll or validate %p as PEB\n",Peb);
    }
#endif /*KDEXT_64BIT*/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmiexts\wmiexts.cpp ===
/*++


Module Name:

    wmiext.cxx

Abstract:

    This module contains the default ntsd debugger extensions for


Author:

    Ivan Brugiolo 17-05-2000

Revision History:

--*/

#include "wmiexts.h"

# undef DBG_ASSERT



/************************************************************
 *   Debugger Utility Functions
 ************************************************************/



WINDBG_EXTENSION_APIS ExtensionApis;
HANDLE ExtensionCurrentProcess;

USHORT  g_MajorVersion;
USHORT  g_MinorVersion;


/************************************************************
 * The WinDBG required Export
 ************************************************************/
 
LPEXT_API_VERSION
ExtensionApiVersion(
    void
    )

/*++

Function Description:

    Windbg calls this function to match between the version of windbg and the
    extension. If the versions doesn't match, windbg will not load the 
extension.

--*/

{
    static EXT_API_VERSION ApiVersion =
#ifdef KDEXT_64BIT
       { 5, 0, EXT_API_VERSION_NUMBER64, 0 };
#else
       { 5, 0, EXT_API_VERSION_NUMBER, 0 };
#endif       
        

    return &ApiVersion;
}


void
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS  lpExtensionApis,
    USHORT                  MajorVersion,
    USHORT                  MinorVersion
    )

/*++

Function Description:

    When windbg loads the extension, it first call this function. You can
    perform various intialization here.

Arguments:

    lpExtensionApis - A structure that contains the callbacks to functions that
        I can use to do standard operation. I must store this in a global
        variable called 'ExtensionApis'.

    MajorVersion - Indicates if target machine is running checked build or 
free.
        0x0C - Checked build.
        0x0F - Free build.

    MinorVersion - The Windows NT build number (for example, 1381 for NT4).

--*/

{
    ExtensionApis = *lpExtensionApis;

    g_MajorVersion = MajorVersion;
    g_MinorVersion = MinorVersion;
}


void
CheckVersion( void )

/*++

Function Description:

    This function is called before every command. It gives the extension
    a chance to compare between the versions of the target and the extension.
    In this demo, I don't do much with that.

--*/

{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmiperf\datagen.h ===
/*++ 

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

      DATAGEN.h

Abstract:

    Header file for the WINMGMT performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    davj  17-May-2000

Revision History:


--*/

#ifndef _DATAGEN_H_
#define _DATAGEN_H_
 
//
//  insure packing is done to the 8 byte align longlong data values. This
//  will eliminate alignment faults on RISC platforms. The fields can be 
//  manually arranged to minimize or eliminate wasted space if necessary.
//
#pragma pack (8)
#define MAXVALUES 8

//
//  Extensible Object definitions
//

//----------------------------------------------------------------------------


#pragma pack ()

typedef struct _REG_DATA_DEFINITION {
   PERF_OBJECT_TYPE RegObjectType;
   PERF_COUNTER_DEFINITION Value[MAXVALUES];
} REG_DATA_DEFINITION;

#endif //_DATAGEN_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmiexts\wmiexts.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    wmiexts.h

Author:

    Ivan Brugiolo
    
Revision History:

--*/

# ifndef _WMIEXTS_H_
# define _WMIEXTS_H_

#ifdef _WIN64
  #define KDEXT_64BIT
#else
  #define KDEXT_32BIT
#endif

#ifdef KDEXT_64BIT
  #define MEMORY_ADDRESS ULONG64
#else
  #define MEMORY_ADDRESS ULONG_PTR
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>

#ifdef PowerSystemMaximum
#undef PowerSystemMaximum
#endif

#include <windows.h>

#include <wdbgexts.h>


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#include <stdlib.h>


//
// To obtain the private & protected members of C++ class,
// let me fake the "private" keyword
//
# define private    public
# define protected  public


//
// Turn off dllexp et al so this DLL won't export tons of unnecessary garbage.
//



/************************************************************
 *   Macro Definitions
 ************************************************************/

extern WINDBG_EXTENSION_APIS ExtensionApis;
extern HANDLE ExtensionCurrentProcess;
extern USHORT g_MajorVersion;
extern USHORT g_MinorVersion;




#define moveBlock(dst, src, size)\
__try {\
    ReadMemory( (ULONG_PTR)(src), (PVOID)&(dst), (size), NULL);\
} __except (EXCEPTION_EXECUTE_HANDLER) {\
    return;\
}

#define MoveWithRet(dst, src, retVal)\
__try {\
    ReadMemory( (ULONG_PTR)(src), (PVOID)&(dst), sizeof(dst), NULL);\
} __except (EXCEPTION_EXECUTE_HANDLER) {\
    return  retVal;\
}

#define MoveBlockWithRet(dst, src, size, retVal)\
__try {\
    ReadMemory( (ULONG_PTR)(src), (PVOID)&(dst), (size), NULL);\
} __except (EXCEPTION_EXECUTE_HANDLER) {\
    return retVal;\
}

#ifdef _WIN64
#define INIT_API()                                                                       \
    LPSTR lpArgumentString = (LPSTR)args;                                                \
  	ExtensionCurrentProcess = hCurrentProcess;                                           
#else
#define INIT_API()                                                                       \
    LPSTR lpArgumentString = (LPSTR)args;                                                \
  	ExtensionCurrentProcess = hCurrentProcess;                                           \
   	if (ExtensionApis.nSize != sizeof(WINDBG_EXTENSION_APIS)){                           \
   	    WINDBG_OLD_EXTENSION_APIS * pOld = (WINDBG_OLD_EXTENSION_APIS *)&ExtensionApis;  \
   	    *pOld = *((WINDBG_OLD_EXTENSION_APIS *)dwProcessor);                             \
	}
#endif	


# define BoolValue( b) ((b) ? "    TRUE" : "   FALSE")


#define DumpDword( symbol )                                     \
        {                                                       \
            ULONG_PTR dw = 0;                                   \
            if (ExtensionApis.nSize != sizeof(WINDBG_EXTENSION_APIS)){ \
                dw = GetExpression( "&" symbol );               \
            } else {                                            \
                dw = GetExpression( symbol );                   \
            };                                                  \
			                                                    \
            ULONG_PTR dwValue = 0;                              \
            if ( dw )                                           \
            {                                                   \
                if ( ReadMemory( (ULONG_PTR) dw,                \
                                 &dwValue,                      \
                                 sizeof(dwValue),               \
                                 NULL ))                        \
                {                                               \
                    dprintf( "\t" symbol "   = %8d (0x%p)\n",   \
                             dwValue,                           \
                             dwValue );                         \
                }                                               \
            }                                                   \
        }


//
// C++ Structures typically require the constructors and most times
//  we may not have default constructors
//  => trouble in defining a copy of these struct/class inside the
//     Debugger extension DLL for debugger process
// So we will define them as CHARACTER arrays with appropriate sizes.
// This is okay, since we are not really interested in structure as is,
//  however, we will copy over data block from the debuggee process to
//  these structure variables in the debugger process.
//
# define DEFINE_CPP_VAR( className, classVar) \
   CHAR  classVar[sizeof(className)]

# define GET_CPP_VAR_PTR( className, classVar) \
   (className * ) &classVar

//
//
// commonly used functions
//
////////////////////////////////////////////////////////////////

void GetPeb(HANDLE hSourceProcess, PEB ** ppPeb, ULONG_PTR * pId = NULL);
void GetTeb(HANDLE hThread,TEB ** ppTeb);
void GetCid(HANDLE hThread,CLIENT_ID * pCid);

void PrintStackTrace(ULONG_PTR ArrayAddr_OOP,DWORD dwNum,BOOL bOOP);

#ifndef KDEXT_64BIT

/**

   Routine to get offset of a "Field" of "Type" on a debugee machine. This uses
   Ioctl call for type info.
   Returns 0 on success, Ioctl error value otherwise.

 **/

__inline
ULONG
GetFieldOffset (
   IN LPCSTR     Type,
   IN LPCSTR     Field,
   OUT PULONG   pOffset
   )
{
   FIELD_INFO flds = {
       (PUCHAR)Field,
       (PUCHAR)"",
       0,
       DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_RETURN_ADDRESS,
       0,
       NULL};

   SYM_DUMP_PARAM Sym = {
      sizeof (SYM_DUMP_PARAM),
      (PUCHAR)Type,
      DBG_DUMP_NO_PRINT,
      0,
      NULL,
      NULL,
      NULL,
      1,
      &flds
   };

   ULONG Err;

   Sym.nFields = 1;
   Err = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );
   *pOffset = (ULONG) (flds.address - Sym.addr);
   return Err;
}



#endif

# endif //  _WMIEXTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmiperf\genctrs.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    genctrs.h
       (derived from genctrs.mc by the message compiler  )

Abstract:

   Event message definititions used by routines in WMIPerf.DLL

Created:

    davj  17-May-2000

Revision History:

--*/
//
#ifndef _WMIPerfMsg_H_
#define _WMIPerfMsg_H_
//
//
//     Perfutil messages
//
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: UTIL_LOG_OPEN
//
// MessageText:
//
//  An extensible counter has opened the Event Log for WMIPerf.DLL
//
#define UTIL_LOG_OPEN                    ((DWORD)0x4000076CL)

//
//
// MessageId: UTIL_CLOSING_LOG
//
// MessageText:
//
//  An extensible counter has closed the Event Log for WMIPerf.DLL
//
#define UTIL_CLOSING_LOG                 ((DWORD)0x400007CFL)

//
//
// MessageId: GENPERF_UNABLE_OPEN_DRIVER_KEY
//
// MessageText:
//
//  Unable open "Performance" key of WMIPerf driver in registy. Status code is returned in data.
//
#define GENPERF_UNABLE_OPEN_DRIVER_KEY   ((DWORD)0xC00007D0L)

//
//
// MessageId: GENPERF_UNABLE_READ_FIRST_COUNTER
//
// MessageText:
//
//  Unable to read the "First Counter" value under the WMIPerf\Performance Key. Status codes retuened in data.
//
#define GENPERF_UNABLE_READ_FIRST_COUNTER ((DWORD)0xC00007D1L)

//
//
// MessageId: GENPERF_UNABLE_READ_FIRST_HELP
//
// MessageText:
//
//  Unable to read the "First Help" value under the WMIPerf\Performance Key. Status codes retuened in data.
//
#define GENPERF_UNABLE_READ_FIRST_HELP   ((DWORD)0xC00007D2L)

//
#endif // _WMIPerfMsg_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmiperf\datagen.c ===
/*++ 

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    datagen.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for WINMGMT

Created:

    davj  17-May-2000

Revision History:

    None.

--*/

#include <windows.h>
#include <winperf.h>
#include "genctrnm.h"
#include "datagen.h"

// See description of this structure in winperf.h and struct.h
REG_DATA_DEFINITION RegDataDefinition = {

   {   sizeof(REG_DATA_DEFINITION),
   sizeof(REG_DATA_DEFINITION),
   sizeof(PERF_OBJECT_TYPE),
   WMI_OBJECT,
   0,
   WMI_OBJECT,
   0,
   PERF_DETAIL_NOVICE,
   (sizeof(REG_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE)) /
      sizeof(PERF_COUNTER_DEFINITION),
   0,
   PERF_NO_INSTANCES,
   0,
   0,
   0
   },
   {
   {   sizeof(PERF_COUNTER_DEFINITION),
   CNT_USER,
   0,
   CNT_USER,
   0,
   0,
   PERF_DETAIL_NOVICE,
   PERF_COUNTER_RAWCOUNT,
   0,
   0,
   },
   {   sizeof(PERF_COUNTER_DEFINITION),
   CNT_CONNECTION,
   0,
   CNT_CONNECTION,
   0,
   0,
   PERF_DETAIL_NOVICE,
   PERF_COUNTER_RAWCOUNT,
   0,
   0
   },
   {   sizeof(PERF_COUNTER_DEFINITION),
   CNT_TASKSINPROG,
   0,
   CNT_TASKSINPROG,
   0,
   0,
   PERF_DETAIL_NOVICE,
   PERF_COUNTER_RAWCOUNT,
   0,
   0
   },
   {   sizeof(PERF_COUNTER_DEFINITION),
   CNT_TASKSWAITING,
   0,
   CNT_TASKSWAITING,
   0,
   0,
   PERF_DETAIL_NOVICE,
   PERF_COUNTER_RAWCOUNT,
   0,
   0
   },
   {   sizeof(PERF_COUNTER_DEFINITION),
   CNT_DELIVERYBACK,
   0,
   CNT_DELIVERYBACK,
   0,
   0,
   PERF_DETAIL_NOVICE,
   PERF_COUNTER_RAWCOUNT,
   0,
   0
   },
   {   sizeof(PERF_COUNTER_DEFINITION),
   CNT_TOTALAPICALLS,
   0,
   CNT_TOTALAPICALLS,
   0,
   0,
   PERF_DETAIL_NOVICE,
   PERF_COUNTER_RAWCOUNT,
   0,
   0
   },
   {   sizeof(PERF_COUNTER_DEFINITION),
   CNT_INTOBJECT,
   0,
   CNT_INTOBJECT,
   0,
   0,
   PERF_DETAIL_NOVICE,
   PERF_COUNTER_RAWCOUNT,
   0,
   0
   },
   {   sizeof(PERF_COUNTER_DEFINITION),
   CNT_INTSINKS,
   0,
   CNT_INTSINKS,
   0,
   0,
   PERF_DETAIL_NOVICE,
   PERF_COUNTER_RAWCOUNT,
   0,
   0
   }
   },
};


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmiperf\perfmsg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    perfmsg.h  

Abstract:

    This file provides the macros and definitions used by the extensible
    counters for reporting events to the event logging facility

Author:

    davj  17-May-2000

Revision History:


--*/
#ifndef  _PERFMSG_H_
#define  _PERFMSG_H_
//
// Report error message ID's for Counters
//


//
// The constant below defines how many (if any) messages will be reported
// to the event logger. As the number goes up in value more and more events
// will be reported. The purpose of this is to allow lots of messages during
// development and debugging (e.g. a message level of 3) to a minimum of
// messages (e.g. operational messages with a level of 1) or no messages if
// message logging inflicts too much of a performance penalty. Right now
// this is a compile time constant, but could later become a registry entry.
//
//    Levels:  LOG_NONE =    No event log messages ever
//             LOG_ERROR =   User event log messages (e.g. errors)
//             LOG_VERBOSE = Max messages 
//

#define  LOG_NONE       0
#define  LOG_ERROR      1
#define  LOG_VERBOSE    2

#define  MESSAGE_LEVEL_DEFAULT  LOG_ERROR

// define macros
//
// Format for event log calls without corresponding insertion strings is:
//    REPORT_xxx (message_value, message_level)
//       where:   
//          xxx is the severity to be displayed in the event log
//          message_value is the numeric ID from above
//          message_level is the "filtering" level of error reporting
//             using the error levels above.
//
// if the message has a corresponding insertion string whose symbol conforms
// to the format CONSTANT = numeric value and CONSTANT_S = string constant for
// that message, then the 
// 
//    REPORT_xxx_STRING (message_value, message_level)
//
// macro may be used.
//

//
// REPORT_SUCCESS was intended to show Success in the error log, rather it
// shows "N/A" so for now it's the same as information, though it could 
// (should) be changed  in the future
//


#define REPORT_SUCCESS(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_WARNING(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_ERROR(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_WARNING_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_ERROR_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

// External Variables

extern HANDLE hEventLog;   // handle to event log
extern DWORD  dwLogUsers;  // counter of event log using routines
extern DWORD  MESSAGE_LEVEL; // event logging detail level

#endif //_PERFMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmiperf\genctrnm.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


//
//  genctrnm.h
//
//  Offset definition file for exensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 (i.e.
//  even numbers). In the Open Procedure, they will be added to the 
//  "First Counter" and "First Help" values fo the device they belong to, 
//  in order to determine the  absolute location of the counter and 
//  object names and corresponding help text in the registry.
//
//  this file is used by the extensible counter DLL code as well as the 
//  counter name and help text definition file (.INI) file that is used
//  by LODCTR to load the names into the registry.
//

#define WMI_OBJECT          0
#define CNT_USER            2
#define CNT_CONNECTION      4
#define CNT_TASKSINPROG     6
#define CNT_TASKSWAITING    8
#define CNT_DELIVERYBACK    10
#define CNT_TOTALAPICALLS   12
#define CNT_INTOBJECT       14
#define CNT_INTSINKS        16


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmiperf\perfgen.c ===
/*++ 

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    perfgen.c

Abstract:

    This is the main file of the WINMGMT perf library.

Created:    

    davj  17-May-2000

Revision History


--*/

#include <windows.h>
#include <string.h>
#include <winperf.h>
#include <math.h>
#include "genctrs.h" // error message definition
#include "perfmsg.h"
#include "perfutil.h"
#include "datagen.h"

DWORD dwDataSize[MAXVALUES];

// This is the shared data segment which allows wbemcore.dll to be able to set
// the counter values

#pragma data_seg(".shared")
DWORD dwCounterValues[MAXVALUES] = {0,0,0,0,0,0,0,0};
#pragma data_seg()

//
//  References to constants which initialize the Object type definitions
//

extern REG_DATA_DEFINITION RegDataDefinition;
    
DWORD   dwOpenCount = 0;        // count of "Open" threads
BOOL    bInitOK = FALSE;        // true = DLL initialized OK

//
//  Function Prototypes
//
//      these are used to insure that the data collection functions
//      accessed by Perflib will have the correct calling format.
//

PM_OPEN_PROC    OpenWmiPerformanceData;
PM_COLLECT_PROC CollectWmiPerformanceData;
PM_CLOSE_PROC   CloseWmiPerformanceData;


DWORD GetData(DWORD * pData, DWORD dwIndex)
{
    *pData = dwCounterValues[dwIndex];
    return 4;
}


DWORD APIENTRY
OpenWmiPerformanceData(
    LPWSTR lpDeviceNames
    )

/*++

Routine Description:

    This routine will initialize the data structures used to pass
    data back to perfmon

Arguments:

    Pointer to object ID of each device to be opened (WMIPerf)

Return Value:

    None.

--*/

{
    LONG status;
    HKEY hKeyDriverPerf;
    DWORD size, x;
    DWORD type;
    DWORD dwFirstCounter;
    DWORD dwFirstHelp;

    //
    //  Since WINLOGON is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). the registry routines will
    //  limit access to the initialization routine to only one thread 
    //  at a time so synchronization (i.e. reentrancy) should not be 
    //  a problem
    //

    if (!dwOpenCount) {
        // open Eventlog interface

        hEventLog = MonOpenEventLog();

        // get counter and help index base values from registry
        //      Open key to registry entry
        //      read First Counter and First Help values
        //      update static data strucutures by adding base to 
        //          offset value in structure.

        status = RegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
    	    "SYSTEM\\CurrentControlSet\\Services\\Winmgmt\\Performance",
            0L,
	        KEY_READ,
            &hKeyDriverPerf);

        if (status != ERROR_SUCCESS) {
            REPORT_ERROR_DATA (GENPERF_UNABLE_OPEN_DRIVER_KEY, LOG_ERROR,
                &status, sizeof(status));
            // this is fatal, if we can't get the base values of the 
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
            goto OpenExitPoint;
        }

        size = sizeof (DWORD);
        status = RegQueryValueEx(
                    hKeyDriverPerf, 
		            "First Counter",
                    0L,
                    &type,
                    (LPBYTE)&dwFirstCounter,
                    &size);

        if (status != ERROR_SUCCESS) {
            REPORT_ERROR_DATA (GENPERF_UNABLE_READ_FIRST_COUNTER, LOG_ERROR,
                &status, sizeof(status));
            // this is fatal, if we can't get the base values of the 
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
            goto OpenExitPoint;
        }

        size = sizeof (DWORD);
        status = RegQueryValueEx(
                    hKeyDriverPerf, 
        		    "First Help",
                    0L,
                    &type,
                    (LPBYTE)&dwFirstHelp,
		    &size);

        if (status != ERROR_SUCCESS) {
            REPORT_ERROR_DATA (GENPERF_UNABLE_READ_FIRST_HELP, LOG_ERROR,
                &status, sizeof(status));
            // this is fatal, if we can't get the base values of the 
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
            goto OpenExitPoint;
        }
 
      // Set some of the static information into the structure

      RegDataDefinition.RegObjectType.ObjectNameTitleIndex += dwFirstCounter;
      RegDataDefinition.RegObjectType.ObjectHelpTitleIndex += dwFirstHelp;

       for (x=0; x<MAXVALUES; x++) 
       {
             RegDataDefinition.Value[x].CounterNameTitleIndex += dwFirstCounter;
             RegDataDefinition.Value[x].CounterHelpTitleIndex += dwFirstHelp;
       }

        RegCloseKey (hKeyDriverPerf); // close key to registry

        bInitOK = TRUE; // ok to use this function
    }

    dwOpenCount++;  // increment OPEN counter

    status = ERROR_SUCCESS; // for successful exit

OpenExitPoint:

    return status;
}


DWORD APIENTRY
CollectWmiPerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the WINMGMT counters.

Arguments:

   IN       LPWSTR   lpValueName
         pointer to a wide character string passed by registry.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed 
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the 
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the 
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added 
            by this routine 
         OUT: the number of objects added by this routine is writted to the 
            DWORD pointed to by this argument

Return Value:

      ERROR_MORE_DATA if buffer passed is too small to hold data
         any error conditions encountered are reported to the event log if
         event logging is enabled.

      ERROR_SUCCESS  if success or any other error. Errors, however are
         also reported to the event log.

--*/
{
    //  Variables for reformating the data

   ULONG SpaceNeeded;
   PERF_COUNTER_BLOCK *pPerfCounterBlock;
   REG_DATA_DEFINITION *pRegDataDefinition;
   PERF_COUNTER_DEFINITION *pRegCounterDefinition;
   DWORD dwQueryType;
   DWORD x;
   DWORD dwTotSize;
   DWORD dwDataOffset;
   DWORD Data[MAXVALUES];

   // before doing anything else, see if Open went OK

   if (!bInitOK) {
      // unable to continue because open failed
      *lpcbTotalBytes = (DWORD) 0;
      *lpNumObjectTypes = (DWORD) 0;
      return ERROR_SUCCESS; // yes, this is a successful exit
   }

   // see if this is a foreign (ie non-nt) computer data request
   dwQueryType = GetQueryType (lpValueName);
//   REPORT_INFORMATION_DATA (COLLECTION_CALLED, LOG_VERBOSE, lpValueName, wcslen(lpValueName) * 2);

   if (dwQueryType == QUERY_FOREIGN) {
      // this routine does not service requests for data from
      // non-nt computers
      *lpcbTotalBytes = (DWORD) 0;
      *lpNumObjectTypes = (DWORD) 0;
      return ERROR_SUCCESS; // yes, this is a successful exit
   }

   // See if it is asking for our object.

   if (dwQueryType == QUERY_ITEMS) {
      if ( !(IsNumberInUnicodeList (RegDataDefinition.RegObjectType.ObjectNameTitleIndex,
                                    lpValueName))) {
         // request received for data object not provided by this routine
         *lpcbTotalBytes = (DWORD) 0;
         *lpNumObjectTypes = (DWORD) 0;
         return ERROR_SUCCESS; // yes, this is a successful exit
      }
   }

   // It is asking for our data.  Currently, there are no instances and so that returned data has
   // the following layout.
   // PERF_OBJECT_TYPE                      describes object, in RegDataDefinition
   // PERF_COUNTER_DESCRIPTION              describes counter 0, also in RegDataDefinition
   //  .
   //  .
   // PERF_COUNTER_DESCRIPTION              describes counter n, also in RegDataDefinition
   // PERF_COUNTER_BLOCK                    four bytes that has the size of the block and all counters
   // counter 0
   //  .
   //  .
   // counter n

   // Format and collect the data
   dwTotSize = sizeof(PERF_COUNTER_BLOCK);
   for (x=0; x<MAXVALUES; x++) {
      dwDataSize[x] = GetData(&Data[x], x);
      dwTotSize +=  dwDataSize[x];
   }
   SpaceNeeded = sizeof(REG_DATA_DEFINITION) + dwTotSize;

   if (*lpcbTotalBytes < SpaceNeeded ) {
      *lpcbTotalBytes = (DWORD) 0;
      *lpNumObjectTypes = (DWORD) 0;
      return ERROR_MORE_DATA;
   }

   pRegDataDefinition = (REG_DATA_DEFINITION *) *lppData;

   // Copy the (constant, initialized) Object type and counter definitions
   // to the caller's data buffer
   memset(pRegDataDefinition, '\0', SpaceNeeded);

   memmove(pRegDataDefinition,
      &RegDataDefinition,
      sizeof(REG_DATA_DEFINITION));

   // Position to header of performance data (just after counter definition)
   pPerfCounterBlock = (PERF_COUNTER_BLOCK *) &pRegDataDefinition[1];

   // Move the values in
   // Set input parameter to point just after performance
   // data (a requirement for collectdata routines)
   // Total length of returned structure
   // Set length of performance data

   pRegDataDefinition->RegObjectType.TotalByteLength += dwTotSize;
   pRegCounterDefinition = (PERF_COUNTER_DEFINITION *) (
      ((PBYTE) pRegDataDefinition) + pRegDataDefinition->RegObjectType.HeaderLength);

   dwDataOffset = sizeof(PERF_COUNTER_BLOCK);
   pPerfCounterBlock->ByteLength = dwTotSize;

   for (x=0; x<MAXVALUES; x++) {
      pRegCounterDefinition->CounterSize = dwDataSize[x];
      pRegCounterDefinition->CounterOffset = dwDataOffset;

      memcpy((PBYTE) pPerfCounterBlock + dwDataOffset, &Data[x], dwDataSize[x]);

      dwDataOffset += dwDataSize[x];
      pRegCounterDefinition++;
   }

   *lppData = (PBYTE) pRegDataDefinition + pRegDataDefinition->RegObjectType.TotalByteLength;
   *lpcbTotalBytes = pRegDataDefinition->RegObjectType.TotalByteLength;

   // update arguments for return

   *lpNumObjectTypes = 1;  // Number of objects returned (objects, not counters)

   return ERROR_SUCCESS;

}


DWORD APIENTRY
CloseWmiPerformanceData(
)

/*++

Routine Description:

    This routine closes the open handles.

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    if (!(--dwOpenCount)) { // when this is the last thread...

        MonCloseEventLog();
    }

    return ERROR_SUCCESS;

}

DWORD APIENTRY WriteCounter(DWORD dwCountNum, DWORD dwCountValue)
/*++

Routine Description:

    This routine is where wbemcore.dll calls to set a counter value.

Arguments:

   IN       DWORD   dwCountNum
         Counter to be set.
   IN       DWORD   dwCountValue
         New counter value.


Return Value:

    ERROR_SUCCESS

--*/
{
    if(dwCountNum < MAXVALUES)
    {
        dwCounterValues[dwCountNum] = dwCountValue;
        return 0;
    }
    else
        return ERROR_INVALID_PARAMETER;
}

//***************************************************************************
//
//  DllRegisterServer
//
//  Standard OLE entry point for registering the server.
//
//  RETURN VALUES:
//
//      S_OK        Registration was successful
//      E_FAIL      Registration failed.
//
//***************************************************************************

HRESULT APIENTRY DllRegisterServer(void)
{
    HKEY hKey;
    DWORD dw = RegCreateKeyEx(HKEY_LOCAL_MACHINE, 
        "SYSTEM\\CurrentControlSet\\Services\\winmgmt\\Performance", 0, 
        NULL, 0, KEY_ALL_ACCESS, NULL, &hKey, NULL);
    if(dw == ERROR_SUCCESS)
    {
        RegSetValueEx(hKey,"Library", 0, REG_SZ,"wmiperf.dll", 12);
        RegSetValueEx(hKey,"Open", 0, REG_SZ,   "OpenWmiPerformanceData", 23);
        RegSetValueEx(hKey,"Collect", 0, REG_SZ,"CollectWmiPerformanceData", 26);
        RegSetValueEx(hKey,"Close", 0, REG_SZ,  "CloseWmiPerformanceData", 24);
        RegCloseKey(hKey);
    }
    else
        return E_FAIL;

    dw = RegCreateKeyEx(HKEY_LOCAL_MACHINE, 
        "SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\wmiperf", 0, 
        NULL, 0, KEY_ALL_ACCESS, NULL, &hKey, NULL);
    if(dw == ERROR_SUCCESS)
    {
        DWORD dwTemp = 7;
        RegSetValueEx(hKey,"EventMessageFile", 0, REG_EXPAND_SZ,
                                    "%systemroot%\\system32\\wmiperf.dll", 34);
        RegSetValueEx(hKey,"TypesSupported", 0, REG_DWORD, (BYTE *)&dwTemp, 4);
        RegCloseKey(hKey);
    }
    else
        return E_FAIL;
    return S_OK;
}

//***************************************************************************
//
//  DllUnregisterServer
//
//  Standard OLE entry point for unregistering the server.
//
//  RETURN VALUES:
//
//      S_OK        Unregistration was successful
//      E_FAIL      Unregistration failed.
//
//***************************************************************************

HRESULT APIENTRY DllUnregisterServer(void)
{
    DWORD dw = RegDeleteKey(HKEY_LOCAL_MACHINE, 
        "SYSTEM\\CurrentControlSet\\Services\\winmgmt\\Performance");
    if(dw != ERROR_SUCCESS)
        return E_FAIL;
    dw = RegDeleteKey(HKEY_LOCAL_MACHINE, 
        "SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\wmiperf");
    if(dw != ERROR_SUCCESS)
        return E_FAIL;
    else
        return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmiperf\perfutil.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    perfutil.h  

Abstract:

    This file declares some usefule utilities.

Author:

    davj  17-May-2000

Revision History:


--*/
#ifndef _PERFUTIL_H_
#define _PERFUTIL_H_

extern WCHAR  GLOBAL_STRING[];      // Global command (get all local ctrs)
extern WCHAR  FOREIGN_STRING[];           // get data from foreign computers
extern WCHAR  COSTLY_STRING[];      
extern WCHAR  NULL_STRING[];

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

HANDLE MonOpenEventLog ();
VOID MonCloseEventLog ();
DWORD GetQueryType (IN LPWSTR);
BOOL IsNumberInUnicodeList (DWORD, LPWSTR);
#endif  //_PERFUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmiperf\perfutil.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    perfutil.c

Abstract:

    This file implements various utility routines.
                 
Created:    

    davj  17-May-2000

Revision History:

--*/
//
//  include files
//        
#include <windows.h>
#include <string.h>
#include <winperf.h>
#include "genctrs.h"     // error message definition
#include "perfmsg.h"
#include "perfutil.h"

//
// Global data definitions.
//

HANDLE hEventLog = NULL;      // event log handle for reporting events
                              // initialized in Open... routines
DWORD  dwLogUsers = 0;        // count of functions using event log

DWORD MESSAGE_LEVEL = 0;

WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";

WCHAR NULL_STRING[] = L"\0";    // pointer to null string 

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)


HANDLE
MonOpenEventLog (
)
/*++

Routine Description:

    Reads the level of event logging from the registry and opens the
        channel to the event logger for subsequent event log entries.

Arguments:

      None

Return Value:

    Handle to the event log for reporting events.
    NULL if open not successful.

--*/
{
    HKEY hAppKey;

    LONG lStatus;

    DWORD dwLogLevel;
    DWORD dwValueType;
    DWORD dwValueSize;
   
    // if global value of the logging level not initialized or is disabled, 
    //  check the registry to see if it should be updated.

    if (!MESSAGE_LEVEL) {

       lStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                               "SOFTWARE\\Microsoft\\wbem\\cimom",
                               0,                         
                               KEY_READ,
                               &hAppKey);

       dwValueSize = sizeof (dwLogLevel);

       if (lStatus == ERROR_SUCCESS) {
            BYTE bArray[8];
			dwValueSize = 8;
            lStatus = RegQueryValueEx (hAppKey,
                               "Logging",
                               (LPDWORD)NULL,           
                               &dwValueType,
                               (LPBYTE)bArray,
                               &dwValueSize);

            if (lStatus == ERROR_SUCCESS) {
               if(bArray[0] == '2' && bArray[1] == 0)
                   MESSAGE_LEVEL = LOG_VERBOSE;
               else if(bArray[0] == '0' && bArray[1] == 0)
                   MESSAGE_LEVEL = LOG_NONE;
               else
                   MESSAGE_LEVEL = LOG_ERROR;
            } else {
               MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
            }
            RegCloseKey (hAppKey);
       } else {
         MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
       }
    }
       
    if (hEventLog == NULL){
         hEventLog = RegisterEventSource (
            (LPTSTR)NULL,            // Use Local Machine
            "WMIPerf");               // event log app name to find in registry

         if (hEventLog != NULL) {
            REPORT_INFORMATION (UTIL_LOG_OPEN, LOG_VERBOSE);
         }
    }
    
    if (hEventLog != NULL) {
         dwLogUsers++;           // increment count of perfctr log users
    }
    return (hEventLog);
}


VOID
MonCloseEventLog (
)
/*++

Routine Description:

      Closes the handle to the event logger if this is the last caller
      
Arguments:

      None

Return Value:

      None

--*/
{
    if (hEventLog != NULL) {
        dwLogUsers--;         // decrement usage
        if (dwLogUsers <= 0) {    // and if we're the last, then close up log
            REPORT_INFORMATION (UTIL_CLOSING_LOG, LOG_VERBOSE);
            DeregisterEventSource (hEventLog);
        }
    }
}

DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request
    
    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request
    
    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly, 
    // then it must be an item list
    
    return QUERY_ITEMS;

}

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:
        
    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;
    
    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then 
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;
            
            case DELIMITER:
                // a delimter is either the delimiter character or the 
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }
    return FALSE;
}   // IsNumberInUnicodeList
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\arrayitemdlg.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// ArrayItemDlg.cpp : implementation file
//

#include "stdafx.h"
#include "wmitest.h"
#include "ArrayItemDlg.h"
#include "PropUtil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CArrayItemDlg dialog


CArrayItemDlg::CArrayItemDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CArrayItemDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CArrayItemDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CArrayItemDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CArrayItemDlg)
	//}}AFX_DATA_MAP

    if (!pDX->m_bSaveAndValidate)
        m_spropUtil.Init(this);

    m_spropUtil.DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CArrayItemDlg, CDialog)
	//{{AFX_MSG_MAP(CArrayItemDlg)
	ON_BN_CLICKED(IDC_EDIT_OBJ, OnEditEmbedded)
	ON_BN_CLICKED(IDC_CLEAR, OnClearEmbedded)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CArrayItemDlg message handlers

BOOL CArrayItemDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
    m_spropUtil.OnInitDialog();
    m_spropUtil.SetType(m_spropUtil.m_prop.GetRawCIMType());
    	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CArrayItemDlg::OnEditEmbedded() 
{
    m_spropUtil.OnEditEmbedded();
}

void CArrayItemDlg::OnClearEmbedded()
{
    m_spropUtil.OnClearEmbedded();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\bindingpg.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// BindingPg.cpp : implementation file
//

#include "stdafx.h"
#include "wmitest.h"
#include "BindingPg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBindingPg property page

IMPLEMENT_DYNCREATE(CBindingPg, CPropertyPage)

CBindingPg::CBindingPg() : CPropertyPage(CBindingPg::IDD)
{
	//{{AFX_DATA_INIT(CBindingPg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CBindingPg::~CBindingPg()
{
}

void CBindingPg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CBindingPg)
	DDX_Control(pDX, IDC_BINDINGS, m_ctlBindings);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CBindingPg, CPropertyPage)
	//{{AFX_MSG_MAP(CBindingPg)
	ON_BN_CLICKED(IDC_ADD, OnAdd)
	ON_BN_CLICKED(IDC_DELETE, OnDelete)
	ON_BN_CLICKED(IDC_MODIFY, OnModify)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBindingPg message handlers

void CBindingPg::OnAdd() 
{
	// TODO: Add your control notification handler code here
	
}

void CBindingPg::OnDelete() 
{
	// TODO: Add your control notification handler code here
	
}

void CBindingPg::OnModify() 
{
	// TODO: Add your control notification handler code here
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\arrayitemdlg.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#if !defined(AFX_ARRAYITEMDLG_H__EA4C9BEB_9F03_4F6D_8A00_484ABB2E3931__INCLUDED_)
#define AFX_ARRAYITEMDLG_H__EA4C9BEB_9F03_4F6D_8A00_484ABB2E3931__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ArrayItemDlg.h : header file
//

#include "PropUtil.h"

/////////////////////////////////////////////////////////////////////////////
// CArrayItemDlg dialog

class CArrayItemDlg : public CDialog
{
// Construction
public:
	CArrayItemDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CArrayItemDlg)
	enum { IDD = IDD_ARRAY_ITEM };
	CComboBox	m_ctlListValues;
	CListBox	m_ctlBitmaskValues;
	//}}AFX_DATA

    CSinglePropUtil m_spropUtil;

    //BOOL      m_bNewProperty;
    //CPropInfo m_prop;
    //VARIANT   *m_pVar;
    //BOOL      m_bTranslate;

    void SetType(CIMTYPE type);
    void ShowControls(BOOL bShow);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CArrayItemDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	enum VALUE_TYPE
	{
		TYPE_EDIT,
		TYPE_CHECKLISTBOX,
		TYPE_DROPDOWN,
		TYPE_DROPDOWNLIST,
	};

    CWnd        *m_pWnd;
	VALUE_TYPE  m_type;
    DWORD       m_dwScalarID;
    IUnknownPtr m_pObjValue;

    void InitTypeCombo();
    CIMTYPE GetCurrentType();
    void InitControls();

	// Generated message map functions
	//{{AFX_MSG(CArrayItemDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnEditEmbedded();
	afx_msg void OnClearEmbedded();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ARRAYITEMDLG_H__EA4C9BEB_9F03_4F6D_8A00_484ABB2E3931__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\bindingpg.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#if !defined(AFX_BINDINGPG_H__AF348BD0_77B3_4C44_A6F9_70DECA854F55__INCLUDED_)
#define AFX_BINDINGPG_H__AF348BD0_77B3_4C44_A6F9_70DECA854F55__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// BindingPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CBindingPg dialog

class CBindingPg : public CPropertyPage
{
	DECLARE_DYNCREATE(CBindingPg)

// Construction
public:
	CBindingPg();
	~CBindingPg();

// Dialog Data
	//{{AFX_DATA(CBindingPg)
	enum { IDD = IDD_PG_BINDINGS };
	CListCtrl	m_ctlBindings;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CBindingPg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CBindingPg)
	afx_msg void OnAdd();
	afx_msg void OnDelete();
	afx_msg void OnModify();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_BINDINGPG_H__AF348BD0_77B3_4C44_A6F9_70DECA854F55__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\bindingsheet.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// BindingSheet.cpp : implementation file
//

#include "stdafx.h"
#include "wmitest.h"
#include "BindingSheet.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBindingSheet

IMPLEMENT_DYNAMIC(CBindingSheet, CPropertySheet)

CBindingSheet::CBindingSheet(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage) :
    CPropertySheet(nIDCaption, pParentWnd, iSelectPage),
    m_bFirst(TRUE)
{
}

CBindingSheet::CBindingSheet(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage) : 
    CPropertySheet(pszCaption, pParentWnd, iSelectPage),
    m_bFirst(TRUE)
{
}

CBindingSheet::~CBindingSheet()
{
}


BEGIN_MESSAGE_MAP(CBindingSheet, CPropertySheet)
	//{{AFX_MSG_MAP(CBindingSheet)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBindingSheet message handlers

void CBindingSheet::OnPaint() 
{
	CPaintDC dc(this); // device context for painting
	
	// TODO: Add your message handler code here
	
    if (m_bFirst)
    {	
	    CWnd *pwndOK = GetDlgItem(IDOK),
             *pwndCancel = GetDlgItem(IDCANCEL),
             *pwndApply = GetDlgItem(0x3021);
        RECT rectApply;

        pwndApply->GetClientRect(&rectApply);
        pwndApply->MapWindowPoints(this, &rectApply);
        pwndOK->MoveWindow(&rectApply);

        pwndApply->ShowWindow(SW_HIDE);
        pwndCancel->ShowWindow(SW_HIDE);

        m_bFirst = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\classdlg.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#if !defined(AFX_CLASSDLG_H__26DCCFF2_D79B_491E_91D0_56CC185B2036__INCLUDED_)
#define AFX_CLASSDLG_H__26DCCFF2_D79B_491E_91D0_56CC185B2036__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ClassDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CClassDlg dialog

class CClassDlg : public CDialog
{
// Construction
public:
	CClassDlg(CWnd* pParent = NULL);   // standard constructor
    IWbemServices *m_pNamespace;

// Dialog Data
	//{{AFX_DATA(CClassDlg)
	enum { IDD = IDD_CLASS_BROWSE };
	CListBox	m_ctlClasses;
	//}}AFX_DATA
    CString m_strClass;


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CClassDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    void LoadList();

	// Generated message map functions
	//{{AFX_MSG(CClassDlg)
	virtual void OnOK();
	afx_msg void OnSelchangeClasses();
	virtual BOOL OnInitDialog();
	afx_msg void OnDblclkClasses();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CLASSDLG_H__26DCCFF2_D79B_491E_91D0_56CC185B2036__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\consumerpg.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// ConsumerPg.cpp : implementation file
//

#include "stdafx.h"
#include "wmitest.h"
#include "ConsumerPg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConsumerPg property page

IMPLEMENT_DYNCREATE(CConsumerPg, CPropertyPage)

CConsumerPg::CConsumerPg() : CPropertyPage(CConsumerPg::IDD)
{
	//{{AFX_DATA_INIT(CConsumerPg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CConsumerPg::~CConsumerPg()
{
}

void CConsumerPg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CConsumerPg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConsumerPg, CPropertyPage)
	//{{AFX_MSG_MAP(CConsumerPg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConsumerPg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\bindingsheet.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#if !defined(AFX_BINDINGSHEET_H__F14C1C42_B1B8_4B8C_A856_038978FDA57C__INCLUDED_)
#define AFX_BINDINGSHEET_H__F14C1C42_B1B8_4B8C_A856_038978FDA57C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// BindingSheet.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CBindingSheet

class CBindingSheet : public CPropertySheet
{
	DECLARE_DYNAMIC(CBindingSheet)

// Construction
public:
	CBindingSheet(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
	CBindingSheet(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBindingSheet)
	public:
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CBindingSheet();

	// Generated message map functions
protected:
    BOOL m_bFirst;

	//{{AFX_MSG(CBindingSheet)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_BINDINGSHEET_H__F14C1C42_B1B8_4B8C_A856_038978FDA57C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\classdlg.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// ClassDlg.cpp : implementation file
//

#include "stdafx.h"
#include "WMITest.h"
#include "ClassDlg.h"
#include "WMITestDoc.h"
#include "OpView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CClassDlg dialog


CClassDlg::CClassDlg(CWnd* pParent /*=NULL*/) :
	CDialog(CClassDlg::IDD, pParent),
    m_pNamespace(NULL)
{
	//{{AFX_DATA_INIT(CClassDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CClassDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CClassDlg)
	DDX_Control(pDX, IDC_CLASSES, m_ctlClasses);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CClassDlg, CDialog)
	//{{AFX_MSG_MAP(CClassDlg)
	ON_LBN_SELCHANGE(IDC_CLASSES, OnSelchangeClasses)
	ON_LBN_DBLCLK(IDC_CLASSES, OnDblclkClasses)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CClassDlg message handlers

void CClassDlg::LoadList()
{
    CWaitCursor          wait;
    IEnumWbemClassObject *pEnum = NULL;

    HRESULT hr = 
        m_pNamespace->CreateClassEnum(
            NULL,
            WBEM_FLAG_DEEP | WBEM_FLAG_RETURN_IMMEDIATELY | 
                WBEM_FLAG_FORWARD_ONLY,
            NULL,
            &pEnum);

    if (SUCCEEDED(hr))
    {
        IWbemClassObject *pObj = NULL;
        DWORD            nCount;

        g_pOpView->GetDocument()->SetInterfaceSecurity(pEnum);

        while(SUCCEEDED(hr = pEnum->Next(WBEM_INFINITE, 1, &pObj, &nCount)) &&
            nCount > 0)
        {
            CString    strClass;
            _variant_t var;

            if (SUCCEEDED(pObj->Get(L"__CLASS", 0, &var, NULL, NULL)))
            {
                if (var.vt == VT_BSTR)
                {
                    strClass = var.bstrVal;

                    m_ctlClasses.AddString(strClass);
                }

                pObj->Release();
            }
        }

        pEnum->Release();
    }

    OnSelchangeClasses();
}


void CClassDlg::OnOK() 
{
    int iItem = m_ctlClasses.GetCurSel();

    if (iItem != -1)
        m_ctlClasses.GetText(iItem, m_strClass);
	
	CDialog::OnOK();
}

void CClassDlg::OnSelchangeClasses() 
{
    GetDlgItem(IDOK)->EnableWindow(m_ctlClasses.GetCurSel() != -1);
}

BOOL CClassDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	LoadList();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CClassDlg::OnDblclkClasses() 
{
	OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\consumerpg.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#if !defined(AFX_CONSUMERPG_H__17E916BA_F040_4C63_AB8C_D41F009E12AB__INCLUDED_)
#define AFX_CONSUMERPG_H__17E916BA_F040_4C63_AB8C_D41F009E12AB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ConsumerPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CConsumerPg dialog

class CConsumerPg : public CPropertyPage
{
	DECLARE_DYNCREATE(CConsumerPg)

// Construction
public:
	CConsumerPg();
	~CConsumerPg();

// Dialog Data
	//{{AFX_DATA(CConsumerPg)
	enum { IDD = IDD_PG_CONSUMERS };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CConsumerPg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CConsumerPg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CONSUMERPG_H__17E916BA_F040_4C63_AB8C_D41F009E12AB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\classpg.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// ClassPg.cpp : implementation file
//

#include "stdafx.h"
#include "WMITest.h"
#include "ClassPg.h"
#include "WMITestDoc.h"
#include "OpView.h"
#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CClassPg property page

IMPLEMENT_DYNCREATE(CClassPg, CPropertyPage)

CClassPg::CClassPg() : CPropertyPage(CClassPg::IDD)
{
	//{{AFX_DATA_INIT(CClassPg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CClassPg::~CClassPg()
{
}

void CClassPg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CClassPg)
	DDX_Control(pDX, IDC_CLASSES, m_ctlClasses);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CClassPg, CPropertyPage)
	//{{AFX_MSG_MAP(CClassPg)
	ON_LBN_SELCHANGE(IDC_CLASSES, OnSelchangeClasses)
	ON_LBN_DBLCLK(IDC_CLASSES, OnDblclkClasses)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CClassPg message handlers

void CClassPg::OnSelchangeClasses() 
{
	m_pSheet->SetWizardButtons(
        m_ctlClasses.GetCurSel() != -1 ? PSWIZB_NEXT : 0);
}

void CClassPg::OnDblclkClasses() 
{
    m_pSheet->PressButton(PSBTN_NEXT);
}

BOOL CClassPg::OnWizardFinish() 
{
	// TODO: Add your specialized code here and/or call the base class
	
	return CPropertyPage::OnWizardFinish();
}

LRESULT CClassPg::OnWizardNext() 
{
	CString strClass;
    
    int iItem = m_ctlClasses.GetCurSel();

    if (iItem != -1)
        m_ctlClasses.GetText(iItem, strClass);

    if (strClass != m_pSheet->m_strClass)
    {
        m_pSheet->m_strClass = strClass;
        m_pSheet->m_listColums.RemoveAll();
        m_pSheet->m_bColsNeeded = TRUE;
    }
	
	return CPropertyPage::OnWizardNext();
}

BOOL CClassPg::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
	LoadList();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CClassPg::LoadList()
{
    CWaitCursor          wait;
    IEnumWbemClassObject *pEnum = NULL;

    HRESULT hr = 
        m_pSheet->m_pNamespace->CreateClassEnum(
            _bstr_t(m_strSuperClass),
            WBEM_FLAG_DEEP | WBEM_FLAG_RETURN_IMMEDIATELY | 
                WBEM_FLAG_FORWARD_ONLY,
            NULL,
            &pEnum);

    if (SUCCEEDED(hr))
    {
        IWbemClassObject *pObj = NULL;
        DWORD            nCount;

        g_pOpView->GetDocument()->SetInterfaceSecurity(pEnum);

        while(SUCCEEDED(hr = pEnum->Next(WBEM_INFINITE, 1, &pObj, &nCount)) &&
            nCount > 0)
        {
            CString    strClass;
            _variant_t var;

            if (SUCCEEDED(pObj->Get(L"__CLASS", 0, &var, NULL, NULL)))
            {
                if (var.vt == VT_BSTR)
                {
                    strClass = var.bstrVal;

                    m_ctlClasses.AddString(strClass);
                }

                pObj->Release();
            }
        }

        pEnum->Release();
    }

    OnSelchangeClasses();
}

BOOL CClassPg::OnSetActive() 
{
	m_pSheet->SetWizardButtons(m_ctlClasses.GetCurSel() != -1 ? PSWIZB_NEXT : 0);
	
	return CPropertyPage::OnSetActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\classpg.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#if !defined(AFX_CLASSPG_H__D02204D3_6F1E_11D3_BD3F_0080C8E60955__INCLUDED_)
#define AFX_CLASSPG_H__D02204D3_6F1E_11D3_BD3F_0080C8E60955__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ClassPg.h : header file
//

#include "QuerySheet.h"

/////////////////////////////////////////////////////////////////////////////
// CClassPg dialog

class CClassPg : public CPropertyPage
{
	DECLARE_DYNCREATE(CClassPg)

// Construction
public:
	CClassPg();
	~CClassPg();

// Dialog Data
	//{{AFX_DATA(CClassPg)
	enum { IDD = IDD_PG_CLASS };
	CListBox	m_ctlClasses;
	//}}AFX_DATA

    CQuerySheet *m_pSheet;
    CString     m_strSuperClass;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CClassPg)
	public:
	virtual BOOL OnWizardFinish();
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    void LoadList();

	// Generated message map functions
	//{{AFX_MSG(CClassPg)
	afx_msg void OnSelchangeClasses();
	afx_msg void OnDblclkClasses();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CLASSPG_H__D02204D3_6F1E_11D3_BD3F_0080C8E60955__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\deldlg.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// DelDlg.cpp : implementation file
//

#include "stdafx.h"
#include "wmitest.h"
#include "DelDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDelDlg dialog


CDelDlg::CDelDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CDelDlg::IDD, pParent),
    m_bDelFromWMI(TRUE)
{
	//{{AFX_DATA_INIT(CDelDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CDelDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDelDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP

    if (!pDX->m_bSaveAndValidate)
    {
        CheckDlgButton(
            m_bDelFromWMI ? IDC_DEL_FROM_WMI : IDC_DEL_FROM_TREE, 
            TRUE);
    }
    else
    {
        m_bDelFromWMI = IsDlgButtonChecked(IDC_DEL_FROM_WMI);
    }
}


BEGIN_MESSAGE_MAP(CDelDlg, CDialog)
	//{{AFX_MSG_MAP(CDelDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDelDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\deldlg.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#if !defined(AFX_DELDLG_H__DF2E7967_F1B7_4DD9_A814_3A3FB865C157__INCLUDED_)
#define AFX_DELDLG_H__DF2E7967_F1B7_4DD9_A814_3A3FB865C157__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DelDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDelDlg dialog

class CDelDlg : public CDialog
{
// Construction
public:
	CDelDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDelDlg)
	enum { IDD = IDD_DEL_ITEM };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA
    BOOL m_bDelFromWMI;


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDelDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDelDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DELDLG_H__DF2E7967_F1B7_4DD9_A814_3A3FB865C157__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\editqualdlg.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#if !defined(AFX_EDITQUALDLG_H__DC24DD66_C567_4B7E_A80C_DE0598FB4288__INCLUDED_)
#define AFX_EDITQUALDLG_H__DC24DD66_C567_4B7E_A80C_DE0598FB4288__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// EditQualDlg.h : header file
//

#include "PropUtil.h"

/////////////////////////////////////////////////////////////////////////////
// CEditQualDlg dialog

class CEditQualDlg : public CDialog
{
// Construction
public:
	CEditQualDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CEditQualDlg)
	enum { IDD = IDD_EDIT_QUAL };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA
    CPropUtil m_propUtil;
    long      m_lFlavor;
    BOOL      m_bIsInstance;


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEditQualDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CEditQualDlg)
	afx_msg void OnAdd();
	afx_msg void OnEdit();
	afx_msg void OnArray();
	afx_msg void OnDelete();
	afx_msg void OnUp();
	afx_msg void OnDown();
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeArrayValues();
	afx_msg void OnDblclkArrayValues();
	afx_msg void OnSelchangeType();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EDITQUALDLG_H__DC24DD66_C567_4B7E_A80C_DE0598FB4288__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\editqualdlg.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// EditQualDlg.cpp : implementation file
//

#include "stdafx.h"
#include "wmitest.h"
#include "EditQualDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEditQualDlg dialog


CEditQualDlg::CEditQualDlg(CWnd* pParent /*=NULL*/)	: 
    CDialog(CEditQualDlg::IDD, pParent),
    m_bIsInstance(FALSE)
{
	//{{AFX_DATA_INIT(CEditQualDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CEditQualDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CEditQualDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP

	if (!pDX->m_bSaveAndValidate)
    {
        m_propUtil.Init(this);

        CheckDlgButton(IDC_ALLOW_OVERRIDE, 
            (m_lFlavor & WBEM_FLAVOR_NOT_OVERRIDABLE) == 0);

        CheckDlgButton(IDC_TO_INST, 
            (m_lFlavor & WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE) != 0);

        CheckDlgButton(IDC_TO_CLASS, 
            (m_lFlavor & WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS) != 0);

        CheckDlgButton(IDC_AMENDED, 
            (m_lFlavor & WBEM_FLAVOR_AMENDED) != 0);

        CheckDlgButton(IDC_PROPPED, 
            (m_lFlavor & WBEM_FLAVOR_ORIGIN_PROPAGATED) != 0);
    }
    else
    {
        m_lFlavor = 0;

        if (!IsDlgButtonChecked(IDC_ALLOW_OVERRIDE))
            m_lFlavor |= WBEM_FLAVOR_NOT_OVERRIDABLE;

        if (IsDlgButtonChecked(IDC_TO_INST))
            m_lFlavor |= WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE;

        if (IsDlgButtonChecked(IDC_TO_CLASS))
            m_lFlavor |= WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS;

        if (IsDlgButtonChecked(IDC_AMENDED))
            m_lFlavor |= WBEM_FLAVOR_AMENDED;
    }
    
    m_propUtil.DoDataExchange(pDX);
}


BEGIN_MESSAGE_MAP(CEditQualDlg, CDialog)
	//{{AFX_MSG_MAP(CEditQualDlg)
	ON_BN_CLICKED(IDC_ADD, OnAdd)
	ON_BN_CLICKED(IDC_EDIT, OnEdit)
	ON_BN_CLICKED(IDC_ARRAY, OnArray)
	ON_BN_CLICKED(IDC_DELETE, OnDelete)
	ON_BN_CLICKED(IDC_UP, OnUp)
	ON_BN_CLICKED(IDC_DOWN, OnDown)
	ON_LBN_SELCHANGE(IDC_ARRAY_VALUES, OnSelchangeArrayValues)
	ON_LBN_DBLCLK(IDC_ARRAY_VALUES, OnDblclkArrayValues)
	ON_CBN_SELCHANGE(IDC_TYPE, OnSelchangeType)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEditQualDlg message handlers

void CEditQualDlg::OnAdd() 
{
    m_propUtil.OnAdd();
}

void CEditQualDlg::OnEdit() 
{
    m_propUtil.OnEdit();
}

void CEditQualDlg::OnArray() 
{
    m_propUtil.OnArray();
}

void CEditQualDlg::OnDelete() 
{
    m_propUtil.OnDelete();
}

void CEditQualDlg::OnUp() 
{
    m_propUtil.OnUp();
}

void CEditQualDlg::OnDown() 
{
    m_propUtil.OnDown();
}

BOOL CEditQualDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
    if (m_bIsInstance)
    {
        const DWORD dwIDs[] =
        {
            IDC_ALLOW_OVERRIDE,
            IDC_TO_INST,
            IDC_TO_CLASS,
            IDC_AMENDED,
        };

        for (int i = 0; i < sizeof(dwIDs) / sizeof(dwIDs[0]); i++)
            GetDlgItem(dwIDs[i])->EnableWindow(FALSE);
    }

    return m_propUtil.OnInitDialog();
	
	//return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CEditQualDlg::OnSelchangeArrayValues() 
{
    m_propUtil.OnSelchangeValueArray();
}

void CEditQualDlg::OnDblclkArrayValues() 
{
    m_propUtil.OnDblclkArrayValues();
}

void CEditQualDlg::OnSelchangeType() 
{
    m_propUtil.OnSelchangeType();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\errordlg.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// ErrorDlg.cpp : implementation file
//

#include "stdafx.h"
#include "wmitest.h"
#include "ErrorDlg.h"
#include "WMITestDoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CErrorDlg dialog


CErrorDlg::CErrorDlg(CWnd* pParent /*=NULL*/) : 
    CDialog(CErrorDlg::IDD, pParent)
    //m_pResult(NULL)
{
	//{{AFX_DATA_INIT(CErrorDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CErrorDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CErrorDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP

    if (!pDX->m_bSaveAndValidate)
    {
        CString strError,
                strFacility;
	    
        IWbemStatusCodeText *pStatus = NULL;

        SCODE sc = CoCreateInstance(
                      CLSID_WbemStatusCodeText, 
                      0, 
                      CLSCTX_INPROC_SERVER,
				      IID_IWbemStatusCodeText, 
                      (LPVOID *) &pStatus);
	    
	    if (sc == S_OK)
	    {
		    BSTR bstr = NULL;
		    
		    if (SUCCEEDED(pStatus->GetFacilityCodeText(m_hr, 0, 0, &bstr)))
		    {
			    strFacility = bstr;
			    SysFreeString(bstr);
		    }

            if (SUCCEEDED(pStatus->GetErrorCodeText(m_hr, 0, 0, &bstr)))
            {
			    strError = bstr;
                SysFreeString(bstr);
		    }

		    pStatus->Release();
	    }

        if (strError.IsEmpty())
            strError.FormatMessage(IDS_ERROR_FAILED, m_hr);

        SetDlgItemText(IDC_FACILITY, strFacility);
        SetDlgItemText(IDC_DESCRIPTION, strError);

        strError.Format(_T("0x%X"), m_hr);
        SetDlgItemText(IDC_NUMBER, strError);

        if (m_pObj == NULL)
            GetDlgItem(IDC_INFO)->EnableWindow(FALSE);
    }
}


BEGIN_MESSAGE_MAP(CErrorDlg, CDialog)
	//{{AFX_MSG_MAP(CErrorDlg)
	ON_BN_CLICKED(IDC_INFO, OnInfo)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CErrorDlg message handlers

void CErrorDlg::OnInfo() 
{
    if (m_pObj != NULL)
        CWMITestDoc::DisplayWMIErrorDetails(m_pObj);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\errordlg.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#if !defined(AFX_ERRORDLG_H__33EEA154_4B8D_4D58_98A5_59982BBA372B__INCLUDED_)
#define AFX_ERRORDLG_H__33EEA154_4B8D_4D58_98A5_59982BBA372B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ErrorDlg.h : header file
//

#include "OpWrap.h"

/////////////////////////////////////////////////////////////////////////////
// CErrorDlg dialog

class CErrorDlg : public CDialog
{
// Construction
public:
	CErrorDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CErrorDlg)
	enum { IDD = IDD_WMI_ERROR };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

    HRESULT             m_hr;
    //IWbemCallResult     *m_pResult;
    IWbemClassObjectPtr m_pObj;


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CErrorDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CErrorDlg)
	afx_msg void OnInfo();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ERRORDLG_H__33EEA154_4B8D_4D58_98A5_59982BBA372B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\execmethoddlg.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// ExecMethodDlg.cpp : implementation file
//

#include "stdafx.h"
#include "wmitest.h"
#include "WMITestDoc.h"
#include "OpView.h"
#include "OpWrap.h"
#include "ExecMethodDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CExecMethodDlg dialog


CExecMethodDlg::CExecMethodDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CExecMethodDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CExecMethodDlg)
	//}}AFX_DATA_INIT
}


void CExecMethodDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CExecMethodDlg)
	DDX_Control(pDX, IDC_METHOD, m_ctlMethods);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CExecMethodDlg, CDialog)
	//{{AFX_MSG_MAP(CExecMethodDlg)
	ON_BN_CLICKED(IDC_EDIT_INPUT, OnEditInput)
	ON_BN_CLICKED(IDC_EDIT_OUT, OnEditOut)
	ON_BN_CLICKED(IDC_CLEAR_IN, OnClearIn)
	ON_BN_CLICKED(IDOK, OnExecute)
	ON_CBN_SELCHANGE(IDC_METHOD, OnSelchangeMethod)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CExecMethodDlg message handlers

void CExecMethodDlg::OnEditInput() 
{
    CWMITestDoc::EditGenericObject(IDS_EDIT_IN_PARAMS, m_pObjIn);
}

void CExecMethodDlg::OnEditOut() 
{
    CWMITestDoc::EditGenericObject(IDS_EDIT_OUT_PARAMS, m_pObjOut);
}

void CExecMethodDlg::OnClearIn() 
{
    //m_pObjIn = NULL;

    //UpdateButtons();
    OnSelchangeMethod();
}

void CExecMethodDlg::OnExecute() 
{
    CString strMethod;
    int     iItem = m_ctlMethods.GetCurSel();
    HRESULT hr;

    m_ctlMethods.GetLBText(iItem, strMethod);
    
    hr =
        g_pOpView->GetDocument()->m_pNamespace->ExecMethod(
            _bstr_t(m_strObjPath),
            _bstr_t(strMethod),
            0,
            NULL,
            m_pObjIn,
            &m_pObjOut,
            NULL);

    if (SUCCEEDED(hr))
        AfxMessageBox(IDS_EXEC_SUCCEEDED, MB_ICONINFORMATION | MB_OK);
    else
        CWMITestDoc::DisplayWMIErrorBox(hr);

    UpdateButtons();
}

void CExecMethodDlg::OnSelchangeMethod() 
{
    LoadParams();

    m_pObjOut = NULL;

    UpdateButtons();
}

void CExecMethodDlg::UpdateButtons()
{
    GetDlgItem(IDC_EDIT_INPUT)->EnableWindow(m_pObjIn != NULL);
    GetDlgItem(IDC_CLEAR_IN)->EnableWindow(m_pObjIn != NULL);
    GetDlgItem(IDC_EDIT_OUT)->EnableWindow(m_pObjOut != NULL);
}

void CExecMethodDlg::LoadParams()
{
    CString strMethod;
    int     iItem = m_ctlMethods.GetCurSel();
    HRESULT hr;

    // Clear these out.
    m_pObjIn = NULL;
    m_pObjOut = NULL;

    if (iItem != -1)
    {
        m_ctlMethods.GetLBText(iItem, strMethod);
    
        hr =
            m_pClass->GetMethod(
                _bstr_t(strMethod),
                0,
                &m_pObjIn,
                NULL);

        if (FAILED(hr))
            CWMITestDoc::DisplayWMIErrorBox(hr);
    }

    UpdateButtons();
}

BOOL CExecMethodDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	CString strClass = m_pInfo->GetStringPropValue(L"__CLASS");
    HRESULT hr;

    // Setup the controls.
    m_strObjPath = m_pInfo->GetObjText();
    SetDlgItemText(IDC_NAME, m_strObjPath);
        
    // Setup the combo box.
    CPropInfoArray *pProps = m_pInfo->GetProps();
    POSITION       pos = pProps->m_listMethods.GetHeadPosition();

    while (pos)
    {
        CMethodInfo &info = pProps->m_listMethods.GetNext(pos);

        m_ctlMethods.AddString(info.m_strName);
    }

    if (m_ctlMethods.SelectString(-1, m_strDefaultMethod) == -1)
        m_ctlMethods.SetCurSel(0);

    // Get the class definition.
    hr = 
        g_pOpView->GetDocument()->m_pNamespace->GetObject(
            _bstr_t(strClass),
            WBEM_FLAG_RETURN_WBEM_COMPLETE,
            NULL,
            &m_pClass,
            NULL);

    if (SUCCEEDED(hr))
    {
        // Fake a selchange.
        OnSelchangeMethod();
    }
    else
    {
        CWMITestDoc::DisplayWMIErrorBox(hr);

        GetDlgItem(IDC_METHOD)->EnableWindow(FALSE);
        GetDlgItem(IDOK)->EnableWindow(FALSE);

        UpdateButtons();
    }
        
    	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\execmethoddlg.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#if !defined(AFX_EXECMETHODDLG_H__C47A8666_0A8E_4781_839F_B5EC1F695ED0__INCLUDED_)
#define AFX_EXECMETHODDLG_H__C47A8666_0A8E_4781_839F_B5EC1F695ED0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ExecMethodDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CExecMethodDlg dialog

class CExecMethodDlg : public CDialog
{
// Construction
public:
	CExecMethodDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CExecMethodDlg)
	enum { IDD = IDD_EXEC_METHOD };
	CComboBox	m_ctlMethods;
	//}}AFX_DATA
	CString	 m_strDefaultMethod;
    CObjInfo *m_pInfo;


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CExecMethodDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    CString             m_strObjPath;
    IWbemClassObjectPtr m_pClass,
                        m_pObjIn,
                        m_pObjOut;

	void UpdateButtons();
    void LoadParams();

    // Generated message map functions
	//{{AFX_MSG(CExecMethodDlg)
	afx_msg void OnEditInput();
	afx_msg void OnEditOut();
	afx_msg void OnClearIn();
	afx_msg void OnExecute();
	afx_msg void OnSelchangeMethod();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EXECMETHODDLG_H__C47A8666_0A8E_4781_839F_B5EC1F695ED0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\exportdlg.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#if !defined(AFX_EXPORTDLG_H__E1FAA1D0_7B5E_40EC_BC7B_C69B63BAB4C2__INCLUDED_)
#define AFX_EXPORTDLG_H__E1FAA1D0_7B5E_40EC_BC7B_C69B63BAB4C2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ExportDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CExportDlg dialog

class CExportDlg : public CFileDialog
{
	DECLARE_DYNAMIC(CExportDlg)

public:
	CExportDlg(BOOL bOpenFileDialog, // TRUE for FileOpen, FALSE for FileSaveAs
		LPCTSTR lpszDefExt = NULL,
		LPCTSTR lpszFileName = NULL,
		DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
		LPCTSTR lpszFilter = NULL,
		CWnd* pParentWnd = NULL);

    BOOL m_bShowSystemProps,
         m_bTranslate;

protected:
	//{{AFX_MSG(CExportDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
    virtual BOOL OnFileNameOK();

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EXPORTDLG_H__E1FAA1D0_7B5E_40EC_BC7B_C69B63BAB4C2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\exportdlg.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// ExportDlg.cpp : implementation file
//

#include "stdafx.h"
#include "wmitest.h"
#include "ExportDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CExportDlg

IMPLEMENT_DYNAMIC(CExportDlg, CFileDialog)

CExportDlg::CExportDlg(BOOL bOpenFileDialog, LPCTSTR lpszDefExt, LPCTSTR lpszFileName,
    DWORD dwFlags, LPCTSTR lpszFilter, CWnd* pParentWnd) :
	CFileDialog(bOpenFileDialog, lpszDefExt, lpszFileName, dwFlags, lpszFilter, pParentWnd),
    m_bShowSystemProps(TRUE),
    m_bTranslate(TRUE)
{
    m_ofn.lpTemplateName = MAKEINTRESOURCE(IDD_EXPORT);
    m_ofn.Flags |= OFN_ENABLETEMPLATE;
}


BEGIN_MESSAGE_MAP(CExportDlg, CFileDialog)
	//{{AFX_MSG_MAP(CExportDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CExportDlg::OnInitDialog() 
{
	CFileDialog::OnInitDialog();
	
    CheckDlgButton(IDC_SYSTEM_PROPS, m_bShowSystemProps);
    CheckDlgButton(IDC_TRANSLATE, m_bTranslate);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CExportDlg::OnFileNameOK()
{
    m_bShowSystemProps = IsDlgButtonChecked(IDC_SYSTEM_PROPS);
    m_bTranslate = IsDlgButtonChecked(IDC_TRANSLATE);

    return CFileDialog::OnFileNameOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\filterdlg.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// FilterDlg.cpp : implementation file
//

#include "stdafx.h"
#include "wmitest.h"
#include "FilterDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFilterDlg dialog


CFilterDlg::CFilterDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CFilterDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CFilterDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CFilterDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFilterDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFilterDlg, CDialog)
	//{{AFX_MSG_MAP(CFilterDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFilterDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\filterpg.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#if !defined(AFX_FILTERPG_H__625EBE33_028F_4157_A100_A14041AE7BE9__INCLUDED_)
#define AFX_FILTERPG_H__625EBE33_028F_4157_A100_A14041AE7BE9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// FilterPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CFilterPg dialog

class CFilterPg : public CPropertyPage
{
	DECLARE_DYNCREATE(CFilterPg)

// Construction
public:
	CFilterPg();
	~CFilterPg();

// Dialog Data
	//{{AFX_DATA(CFilterPg)
	enum { IDD = IDD_PG_FILTERS };
	CListCtrl	m_ctlFilters;
	//}}AFX_DATA

    void InitListCtrl();
    void LoadList();

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFilterPg)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFilterPg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FILTERPG_H__625EBE33_028F_4157_A100_A14041AE7BE9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\gettextdlg.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// GetTextDlg.cpp : implementation file
//

#include "stdafx.h"
#include "WMITest.h"
#include "GetTextDlg.h"
#include "ClassDlg.h"

#include "QuerySheet.h"
#include "QueryColPg.h"
#include "ClassPg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGetTextDlg dialog


CGetTextDlg::CGetTextDlg(CWnd* pParent /*=NULL*/) : 
    CDialog(CGetTextDlg::IDD, pParent),
    m_dwTitleID(0),
    m_dwPromptID(0),
    m_dwOptionID(0),
    m_bEmptyOK(FALSE),
    m_bAllowClassBrowse(FALSE),
    m_bAllowQueryBrowse(FALSE),
    m_pNamespace(NULL)
{
	//{{AFX_DATA_INIT(CGetTextDlg)
	m_bOptionChecked = FALSE;
	//}}AFX_DATA_INIT
}


void CGetTextDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGetTextDlg)
	DDX_Control(pDX, IDC_STRINGS, m_ctlStrings);
	DDX_Check(pDX, IDC_OPTION, m_bOptionChecked);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGetTextDlg, CDialog)
	//{{AFX_MSG_MAP(CGetTextDlg)
	ON_BN_CLICKED(IDOK, OnOk)
	ON_CBN_EDITCHANGE(IDC_STRINGS, OnEditchangeStrings)
	ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGetTextDlg message handlers

void CGetTextDlg::OnOk() 
{
    GetDlgItemText(IDC_STRINGS, m_strText);

    // If we need to save this into the registry, do so.
    if (!m_strSection.IsEmpty())
    {
        POSITION pos;

        // See if the item already exists in the list.
        if ((pos = m_listItems.Find(m_strText)) != NULL)
            m_listItems.RemoveAt(pos);

        m_listItems.AddHead(m_strText);

        SaveListToReg();
    }

    CDialog::OnOK();
}

void CGetTextDlg::LoadListViaReg(LPCTSTR szSection, int nItems)
{
    m_listItems.RemoveAll();

    m_nItems = nItems;
    m_strSection = szSection;

    for (int i = 0; i < nItems; i++)
    {
        CString strItem,
                strTag;

        strTag.Format(_T("f%d"), i);

        strItem = theApp.GetProfileString(szSection, strTag, _T("\n"));

        if (strItem == _T("\n"))
            break;

        m_listItems.AddTail(strItem);
    }
}

void CGetTextDlg::SaveListToReg()
{
    for (int i = 0; i < m_nItems && m_listItems.GetCount(); i++)
    {
        CString strItem,
                strTag;

        strTag.Format(_T("f%d"), i);

        strItem = m_listItems.RemoveHead();

        if (m_bEmptyOK || !strItem.IsEmpty())
            theApp.WriteProfileString(m_strSection, strTag, strItem);
    }
}

void CGetTextDlg::OnEditchangeStrings() 
{
    if (!m_bEmptyOK)
    {
        GetDlgItemText(IDC_STRINGS, m_strText);

        GetDlgItem(IDOK)->EnableWindow(!m_strText.IsEmpty());
    }
}

BOOL CGetTextDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	//m_ctlStrings.LimitText(32000);

    for (POSITION pos = m_listItems.GetHeadPosition(); pos != NULL;
        m_listItems.GetNext(pos))
    {
        m_ctlStrings.AddString(m_listItems.GetAt(pos));
    }

    // Select the first one.
    m_ctlStrings.SetCurSel(0);

    CString strTemp;

    strTemp.LoadString(m_dwTitleID);
    SetWindowText(strTemp);

    strTemp.LoadString(m_dwPromptID);
    SetDlgItemText(IDS_TEXT_PROMPT, strTemp);

    if (m_dwOptionID)
    {
        strTemp.LoadString(m_dwOptionID);
        SetDlgItemText(IDC_OPTION, strTemp);
        GetDlgItem(IDC_OPTION)->ShowWindow(SW_SHOWNORMAL);
    }

    if (m_bAllowClassBrowse || m_bAllowQueryBrowse)
        GetDlgItem(IDC_BROWSE)->ShowWindow(SW_SHOWNORMAL);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CGetTextDlg::OnBrowse() 
{
    if (m_bAllowClassBrowse)
    {
        CClassDlg dlg;

        dlg.m_pNamespace = m_pNamespace;

        if (dlg.DoModal() == IDOK)
            m_ctlStrings.SetWindowText(dlg.m_strClass);
    }
    else if (m_bAllowQueryBrowse)
    {
    	CQuerySheet sheet(IDS_QUERY_WIZARD, this);
        CClassPg    pgClass;
        CQueryColPg pgCols;

        sheet.m_psh.dwFlags &= ~PSH_HASHELP;
        sheet.m_pNamespace = m_pNamespace;

        pgClass.m_psp.dwFlags &= ~PSH_HASHELP;
        pgClass.m_pSheet = &sheet;
        pgClass.m_strSuperClass = m_strSuperClass;
        sheet.AddPage(&pgClass);

        pgCols.m_psp.dwFlags &= ~PSH_HASHELP;
        pgCols.m_pSheet = &sheet;
        sheet.AddPage(&pgCols);

        sheet.SetWizardMode();
	    
        if (sheet.DoModal() == ID_WIZFINISH)
            m_ctlStrings.SetWindowText(sheet.m_strQuery);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\filterpg.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// FilterPg.cpp : implementation file
//

#include "stdafx.h"
#include "wmitest.h"
#include "FilterPg.h"
#include "OpView.h"
#include "WmiTestDoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFilterPg property page

IMPLEMENT_DYNCREATE(CFilterPg, CPropertyPage)

CFilterPg::CFilterPg() : CPropertyPage(CFilterPg::IDD)
{
	//{{AFX_DATA_INIT(CFilterPg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CFilterPg::~CFilterPg()
{
}

void CFilterPg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFilterPg)
	DDX_Control(pDX, IDC_FILTERS, m_ctlFilters);
	//}}AFX_DATA_MAP

    //if (!pDX->m_bSaveAndValidate)
    //    LoadList();
}


BEGIN_MESSAGE_MAP(CFilterPg, CPropertyPage)
	//{{AFX_MSG_MAP(CFilterPg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFilterPg message handlers

BOOL CFilterPg::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
    InitListCtrl();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CFilterPg::InitListCtrl()
{
    RECT    rect;
    CString strTemp;
            
	m_ctlFilters.SetExtendedStyle(LVS_EX_FULLROWSELECT);

    m_ctlFilters.SetImageList(&((CMainFrame *) AfxGetMainWnd())->m_imageList, 
		LVSIL_SMALL);
    m_ctlFilters.GetClientRect(&rect);

    strTemp.LoadString(IDS_NAME);
    m_ctlFilters.InsertColumn(0, strTemp, LVCFMT_LEFT, rect.right * 25 / 100);
            
    strTemp.LoadString(IDS_QUERY);
    m_ctlFilters.InsertColumn(1, strTemp, LVCFMT_LEFT, rect.right * 75 / 100);
}

void CFilterPg::LoadList()
{
    CWaitCursor          wait;
    HRESULT              hr;
    IEnumWbemClassObject *pEnum = NULL;

    m_ctlFilters.DeleteAllItems();

    hr =
        g_pOpView->GetDocument()->m_pNamespace->CreateInstanceEnum(
            _bstr_t(L"__EVENTFILTER"),
            WBEM_FLAG_DEEP,
            NULL,
            &pEnum);

    if (SUCCEEDED(hr))
    {        
        IWbemClassObject *pObj = NULL;
        DWORD            nCount;
        int              nItems = 0;

        g_pOpView->GetDocument()->SetInterfaceSecurity(pEnum);

        while (SUCCEEDED(hr = pEnum->Next(WBEM_INFINITE, 1, &pObj, &nCount)) &&
            nCount > 0)
        {
            _variant_t var;

            if (SUCCEEDED(pObj->Get(L"NAME", 0, &var, NULL, NULL)))
            {
                CString strTemp;

                if (var.vt == VT_BSTR)
                    strTemp = var.bstrVal;
                else
                    strTemp.LoadString(IDS_NULL);

                m_ctlFilters.InsertItem(nItems, strTemp, IMAGE_OBJECT);

                if (SUCCEEDED(pObj->Get(L"QUERY", 0, &var, NULL, NULL)))
                {
                    if (var.vt == VT_BSTR)
                        strTemp = var.bstrVal;
                    else
                        strTemp.LoadString(IDS_NULL);

                    m_ctlFilters.SetItemText(nItems, 1, strTemp);
                }

                nItems++;
            }

            pObj->Release();
        }

        pEnum->Release();
    }
}

BOOL CFilterPg::OnSetActive() 
{
	LoadList();
	
	return CPropertyPage::OnSetActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\filterdlg.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#if !defined(AFX_FILTERDLG_H__045701B6_0CAF_44DF_89C6_B0307F6EDFE1__INCLUDED_)
#define AFX_FILTERDLG_H__045701B6_0CAF_44DF_89C6_B0307F6EDFE1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// FilterDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CFilterDlg dialog

class CFilterDlg : public CDialog
{
// Construction
public:
	CFilterDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CFilterDlg)
	enum { IDD = IDD_FILTER };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFilterDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CFilterDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FILTERDLG_H__045701B6_0CAF_44DF_89C6_B0307F6EDFE1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\logindlg.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// LoginDlg.cpp : implementation file
//

#include "stdafx.h"
#include "WMITest.h"
#include "LoginDlg.h"
#include "NamespaceDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLoginDlg dialog


CLoginDlg::CLoginDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CLoginDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CLoginDlg)
	m_strNamespace = _T("");
	m_strUser = _T("");
	m_strPassword = _T("");
	m_strAuthority = _T("");
	m_strLocale = _T("");
	m_bNullPassword = FALSE;
	//}}AFX_DATA_INIT
}


void CLoginDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(CLoginDlg)
	DDX_Control(pDX, IDC_IMP2, m_ctlAuth);
	DDX_Control(pDX, IDC_IMP, m_ctlImp);
	DDX_Text(pDX, IDC_NAMESPACE, m_strNamespace);
	DDX_Text(pDX, IDC_USER, m_strUser);
	DDX_Text(pDX, IDC_PASSWORD, m_strPassword);
	DDX_Text(pDX, IDC_LOCALE, m_strLocale);
	DDX_Check(pDX, IDC_NULL, m_bNullPassword);
	//}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
        if (IsDlgButtonChecked(IDC_CURRENT_NTLM))
            m_strAuthority = _T("");
        else
        {
            CString strEnd;

        	GetDlgItemText(IDC_AUTHORITY, strEnd);

            if (IsDlgButtonChecked(IDC_NTLM))
                m_strAuthority.Format(_T("NTLMDOMAIN:%s"), (LPCTSTR) strEnd);
            else
                m_strAuthority.Format(_T("Kerberos:%s"), (LPCTSTR) strEnd);
        }

        m_dwAuthLevel = (DWORD) m_ctlAuth.GetItemData(m_ctlAuth.GetCurSel());
        m_dwImpLevel = (DWORD) m_ctlImp.GetItemData(m_ctlImp.GetCurSel());
    }
    else
    {
        int     iWhere,
                iWhich;
        CString strTemp = m_strAuthority;

        strTemp.MakeUpper();

        if ((iWhere = strTemp.Find(_T("NTLMDOMAIN:"))) == 0)
        {
            iWhich = IDC_NTLM;
            m_strAuthority = strTemp.Mid((sizeof(_T("NTLMDOMAIN:")) - 1) / sizeof(TCHAR));
            OnNtlm();
        }
        else if ((iWhere = strTemp.Find(_T("KERBEROS:"))) == 0)
        {
            iWhich = IDC_KERBEROS;
            m_strAuthority = strTemp.Mid((sizeof(_T("KERBEROS:")) - 1) / sizeof(TCHAR));
            OnKerberos();
        }
        else
        {
            iWhich = IDC_CURRENT_NTLM;
            m_strAuthority = _T("");
            OnCurrentNtlm();
        }

        SetDlgItemText(IDC_AUTHORITY, m_strAuthority);
        CheckRadioButton(IDC_CURRENT_NTLM, IDC_KERBEROS, iWhich);

        if (m_bNullPassword)
            GetDlgItem(IDC_PASSWORD)->EnableWindow(FALSE);

#define NUM_IMP  3
DWORD dwImp[] = 
{ 
    RPC_C_IMP_LEVEL_IDENTIFY, 
    RPC_C_IMP_LEVEL_IMPERSONATE,
    RPC_C_IMP_LEVEL_DELEGATE
};

#define NUM_AUTH 6
DWORD dwAuth[] =
{
    RPC_C_AUTHN_LEVEL_NONE,
    RPC_C_AUTHN_LEVEL_CONNECT,
    RPC_C_AUTHN_LEVEL_CALL,
    RPC_C_AUTHN_LEVEL_PKT,
    RPC_C_AUTHN_LEVEL_PKT_INTEGRITY,
    RPC_C_AUTHN_LEVEL_PKT_PRIVACY
};

        for (int i = 0; i < NUM_IMP; i++)
        {
            CString strName;
            int     iWhere;

            strName.LoadString(IDS_IMP_NAME1 + i);
            iWhere = m_ctlImp.AddString(strName);
            m_ctlImp.SetItemData(iWhere, dwImp[i]);

            if (dwImp[i] == m_dwImpLevel)
                m_ctlImp.SetCurSel(iWhere);
        }

        // Make sure something is selected.
        if (m_ctlImp.GetCurSel() == -1)
            m_ctlImp.SetCurSel(0);


        for (i = 0; i < NUM_AUTH; i++)
        {
            CString strName;
            int     iWhere;

            strName.LoadString(IDS_AUTH_NAME1 + i);
            iWhere = m_ctlAuth.AddString(strName);
            m_ctlAuth.SetItemData(iWhere, dwAuth[i]);

            if (dwAuth[i] == m_dwAuthLevel)
                m_ctlAuth.SetCurSel(iWhere);
        }

        // Make sure something is selected.
        if (m_ctlAuth.GetCurSel() == -1)
            m_ctlAuth.SetCurSel(0);
    }
}


BEGIN_MESSAGE_MAP(CLoginDlg, CDialog)
	//{{AFX_MSG_MAP(CLoginDlg)
	ON_BN_CLICKED(IDC_CURRENT_NTLM, OnCurrentNtlm)
	ON_BN_CLICKED(IDC_NTLM, OnNtlm)
	ON_BN_CLICKED(IDC_KERBEROS, OnKerberos)
	ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
	ON_BN_CLICKED(IDC_ADVANCED, OnAdvanced)
	ON_BN_CLICKED(IDC_NULL, OnNull)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLoginDlg message handlers

void CLoginDlg::OnCurrentNtlm() 
{
    GetDlgItem(IDC_AUTHORITY)->EnableWindow(FALSE);
}

void CLoginDlg::OnNtlm() 
{
    GetDlgItem(IDC_AUTHORITY)->EnableWindow(TRUE);
}

void CLoginDlg::OnKerberos() 
{
    GetDlgItem(IDC_AUTHORITY)->EnableWindow(TRUE);
}

void CLoginDlg::OnBrowse() 
{
    CNamespaceDlg dlg;

    UpdateData(TRUE);

    dlg.m_strAuthority = m_strAuthority;
    dlg.m_strNamespace = m_strNamespace;
    dlg.m_strPassword = m_strPassword;
    dlg.m_strUser = m_strUser;
    dlg.m_dwAuthLevel = m_dwAuthLevel;
    dlg.m_dwImpLevel = m_dwImpLevel;
    dlg.m_bNullPassword = m_bNullPassword;

    if (dlg.DoModal() == IDOK)
    {
        m_strNamespace = dlg.m_strNamespace;
        SetDlgItemText(IDC_NAMESPACE, m_strNamespace);
    }
}

#define BORDER_SIZE 5

BOOL CLoginDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
    RECT rectAdvanced,
         rectBorder;
    CWnd *pOK = GetDlgItem(IDOK),
         *pAdvanced = GetDlgItem(IDC_ADVANCED);
    int  iBorder;

    // Save this off in case the user hits Advanced...
    GetWindowRect(&m_rectLarge);

    pOK->GetClientRect(&rectBorder);
    pOK->MapWindowPoints(this, &rectBorder);

    iBorder = rectBorder.top;

    pAdvanced->GetWindowRect(&rectAdvanced);

    SetWindowPos(
        NULL, 
        0, 0, 
        (rectAdvanced.right + iBorder) - m_rectLarge.left, 
        (rectAdvanced.bottom + iBorder) - m_rectLarge.top,
        SWP_NOMOVE | SWP_NOZORDER);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CLoginDlg::OnAdvanced() 
{
    SetWindowPos(
        NULL, 
        0, 0, 
        m_rectLarge.right - m_rectLarge.left, 
        m_rectLarge.bottom - m_rectLarge.top, 
        SWP_NOMOVE | SWP_NOZORDER);

    GetDlgItem(IDC_ADVANCED)->EnableWindow(FALSE);
}

void CLoginDlg::OnNull() 
{
	m_bNullPassword = IsDlgButtonChecked(IDC_NULL);

    GetDlgItem(IDC_PASSWORD)->EnableWindow(!m_bNullPassword);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\gettextdlg.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#if !defined(AFX_GETTEXTDLG_H__CFC1C8AB_E4F4_43F7_9CAA_DF7667AE011A__INCLUDED_)
#define AFX_GETTEXTDLG_H__CFC1C8AB_E4F4_43F7_9CAA_DF7667AE011A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// GetTextDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CGetTextDlg dialog

class CGetTextDlg : public CDialog
{
// Construction
public:
	CGetTextDlg(CWnd* pParent = NULL);   // standard constructor

    CStringList m_listItems;

// Dialog Data
	//{{AFX_DATA(CGetTextDlg)
	enum { IDD = IDD_GET_TEXT };
	CComboBox	m_ctlStrings;
	BOOL	m_bOptionChecked;
	//}}AFX_DATA

    IWbemServices *m_pNamespace; // For the class browser
    DWORD   m_dwTitleID,
            m_dwPromptID,
            m_dwOptionID;
    CString m_strText;
    BOOL    m_bEmptyOK,
            m_bAllowClassBrowse,
            m_bAllowQueryBrowse;
    CString m_strSuperClass;
    void LoadListViaReg(LPCTSTR szSection, int nItems = 10);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGetTextDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    CString m_strSection;
    int     m_nItems;

    void SaveListToReg();

	// Generated message map functions
	//{{AFX_MSG(CGetTextDlg)
	afx_msg void OnOk();
	afx_msg void OnEditchangeStrings();
	virtual BOOL OnInitDialog();
	afx_msg void OnBrowse();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GETTEXTDLG_H__CFC1C8AB_E4F4_43F7_9CAA_DF7667AE011A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\logindlg.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#if !defined(AFX_LOGINDLG_H__E6E9382F_BC68_448F_9DDD_0C490C61C894__INCLUDED_)
#define AFX_LOGINDLG_H__E6E9382F_BC68_448F_9DDD_0C490C61C894__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// LoginDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CLoginDlg dialog

class CLoginDlg : public CDialog
{
// Construction
public:
	CLoginDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CLoginDlg)
	enum { IDD = IDD_LOGIN };
	CComboBox m_ctlAuth;
	CComboBox m_ctlImp;
	CString	m_strNamespace;
	CString	m_strUser;
	CString	m_strPassword;
	CString	m_strAuthority;
	CString	m_strLocale;
	BOOL	m_bNullPassword;
	//}}AFX_DATA
    DWORD m_dwImpLevel,
          m_dwAuthLevel;


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLoginDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    RECT m_rectLarge;

	// Generated message map functions
	//{{AFX_MSG(CLoginDlg)
	afx_msg void OnCurrentNtlm();
	afx_msg void OnNtlm();
	afx_msg void OnKerberos();
	afx_msg void OnBrowse();
	virtual BOOL OnInitDialog();
	afx_msg void OnAdvanced();
	afx_msg void OnNull();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LOGINDLG_H__E6E9382F_BC68_448F_9DDD_0C490C61C894__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\mainfrm.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "WMITest.h"

#include "MainFrm.h"
#include "OpView.h"
#include "ObjVw.h"
#include "WMITestDoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static TCHAR szWindowPos[] = _T("WindowPos");
static TCHAR szFormat[] = _T("%u,%u,%d,%d,%d,%d,%d,%d,%d,%d");

BOOL ReadWindowPlacement(LPCTSTR szSection, 
	LPCTSTR szValueName, LPWINDOWPLACEMENT pwp)
{
	CString strBuffer = AfxGetApp()->GetProfileString(szSection, szValueName);
	if (strBuffer.IsEmpty())
		return FALSE;

	WINDOWPLACEMENT wp;
	int nRead = _stscanf(strBuffer, szFormat,
		&wp.flags, &wp.showCmd,
		&wp.ptMinPosition.x, &wp.ptMinPosition.y,
		&wp.ptMaxPosition.x, &wp.ptMaxPosition.y,
		&wp.rcNormalPosition.left, &wp.rcNormalPosition.top,
		&wp.rcNormalPosition.right, &wp.rcNormalPosition.bottom);

	if (nRead != 10)
		return FALSE;

	wp.length = sizeof wp;
	*pwp = wp;
	return TRUE;
}

void WriteWindowPlacement(LPCTSTR szSection,
	LPCTSTR szValueName, LPWINDOWPLACEMENT pwp)
	// write a window placement to settings section of app's ini file
{
	TCHAR szBuffer[sizeof("-32767")*8 + sizeof("65535")*2];

	wsprintf(szBuffer, szFormat,
		pwp->flags, pwp->showCmd,
		pwp->ptMinPosition.x, pwp->ptMinPosition.y,
		pwp->ptMaxPosition.x, pwp->ptMaxPosition.y,
		pwp->rcNormalPosition.left, pwp->rcNormalPosition.top,
		pwp->rcNormalPosition.right, pwp->rcNormalPosition.bottom);
	AfxGetApp()->WriteProfileString(szSection, szValueName, szBuffer);
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_CREATE()
	ON_WM_CLOSE()
	ON_UPDATE_COMMAND_UI(ID_STATUS_NUM_OBJECTS, OnUpdateStatusNumberObjects)
	ON_WM_DESTROY()
	ON_WM_INITMENUPOPUP()
	//}}AFX_MSG_MAP
	//ON_WM_INITMENU()
    ON_MESSAGE(WM_ENTERMENULOOP, OnEnterMenuLoop)
    ON_MESSAGE(WM_EXITMENULOOP, OnExitMenuLoop)
END_MESSAGE_MAP()

/*
static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};
*/

static UINT indicatorsMenuActive[] =
{
	ID_SEPARATOR, // status line indicator
};

static UINT indicatorsMenuGone[] =
{
	ID_STATUS_NUM_OBJECTS,
	ID_STATUS1,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
	// TODO: add member initialization code here
	
}

CMainFrame::~CMainFrame()
{
}

#define STATUS_SIZE_NUM_OBJ	    200
#define STATUS_SIZE_PROGRESS	100

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	// Setup the image list.
	m_imageList.Create(16, 16, TRUE, 4, 1); 
    AddImage(IDB_ROOT, RGB(0, 0, 255));
    
    AddImageAndBusyImage(IDB_QUERY, RGB(0, 255, 0));
    AddImageAndBusyImage(IDB_EVENT_QUERY, RGB(0, 255, 0));
    AddImageAndBusyImage(IDB_ENUM_OBJ, RGB(0, 255, 0));
    AddImageAndBusyImage(IDB_ENUM_CLASS, RGB(0, 255, 0));
    AddImageAndBusyImage(IDB_CLASS, RGB(0, 255, 0));
    AddOverlayedImage(IDB_CLASS, IDB_MODIFIED, RGB(0, 255, 0)); 
    AddImageAndBusyImage(IDB_OBJECT, RGB(0, 255, 0));
    AddOverlayedImage(IDB_OBJECT, IDB_MODIFIED, RGB(0, 255, 0)); 

    AddImageAndKeyImage(IDB_OBJECT, RGB(0, 255, 0));
    AddImageAndKeyImage(IDB_TEXT, RGB(0, 255, 0));
    AddImageAndKeyImage(IDB_BINARY, RGB(0, 255, 0));

    
    // Restore the window placement.
    WINDOWPLACEMENT wp;
	wp.length = sizeof wp;
	if (ReadWindowPlacement(_T("Settings"), _T("WindowPos"), &wp))
	{
		theApp.m_nCmdShow = wp.showCmd;
		
		//wp.showCmd = SW_SHOWNORMAL; 
		// This makes it look better when it starts.
		wp.showCmd = SW_HIDE; 
		SetWindowPlacement(&wp);
	}

	if (!m_wndToolBar.CreateEx(this) ||
		!m_wndToolBar.LoadToolBarEx(MAKEINTRESOURCE(IDR_MAINFRAME)))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}

	if (!m_wndReBar.Create(this) ||
		!m_wndReBar.AddBar(&m_wndToolBar))
		//!m_wndReBar.AddBar(&m_wndDlgBar))
	{
		TRACE0("Failed to create rebar\n");
		return -1;      // fail to create
	}

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicatorsMenuGone,
		  sizeof(indicatorsMenuGone)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	// TODO: Remove this if you don't want tool tips
	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY);

    //LoadBarState(_T("Settings"));
	m_wndStatusBar.SetPaneInfo(0, indicatorsMenuGone[0], SBPS_STRETCH, 0);
	m_wndStatusBar.SetPaneInfo(1, indicatorsMenuGone[1], SBPS_NORMAL, STATUS_SIZE_PROGRESS);

	return 0;
}

BOOL CMainFrame::OnCreateClient(LPCREATESTRUCT /*lpcs*/,
	CCreateContext* pContext)
{
	// create splitter window
	if (!m_wndSplitter.CreateStatic(this, 1, 2))
		return FALSE;

	int	cxCur = AfxGetApp()->GetProfileInt(_T("Settings"), 
                    _T("Pane 0 cxCur"), 100);

	if (!m_wndSplitter.CreateView(0, 0, RUNTIME_CLASS(COpView), CSize(cxCur, 100), pContext) ||
		!m_wndSplitter.CreateView(0, 1, RUNTIME_CLASS(CObjView), CSize(100, 100), pContext))
	{
		m_wndSplitter.DestroyWindow();
		return FALSE;
	}

	return TRUE;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	if( !CFrameWnd::PreCreateWindow(cs) )
		return FALSE;
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

CObjView* CMainFrame::GetRightPane()
{
	CWnd* pWnd = m_wndSplitter.GetPane(0, 1);
	CObjView* pView = DYNAMIC_DOWNCAST(CObjView, pWnd);
	return pView;
}

void CMainFrame::OnClose() 
{
	//SaveBarState("Settings");

	// Main window placement
	WINDOWPLACEMENT wp;

	wp.length = sizeof wp;
	if (GetWindowPlacement(&wp))
	{
		wp.flags = 0;
		if (IsZoomed())
			wp.flags |= WPF_RESTORETOMAXIMIZED;
		
		// and write it to registry
		WriteWindowPlacement(_T("Settings"), _T("WindowPos"), &wp);
	}				
	
	
	int cxCur,
        cxMin;

    m_wndSplitter.GetColumnInfo(0, cxCur, cxMin);
	AfxGetApp()->WriteProfileInt(_T("Settings"), _T("Pane 0 cxCur"), cxCur);

/*
    CWMITestDoc *pDoc = (CWMITestDoc*) GetActiveDocument();

    pDoc->Disconnect();
*/

	CFrameWnd::OnClose();
}

void CMainFrame::AddImage(DWORD dwID, COLORREF cr)
{
	CBitmap	bmp;

	bmp.LoadBitmap(dwID);
	m_imageList.Add(&bmp, cr);
	bmp.DeleteObject();
}

void CMainFrame::AddOverlayedImage(int iImage, int iOverlay, COLORREF cr)
{
	CBitmap    bmpImage,
               bmpOverlay,
               *pbmpOld;
	CImageList listTemp;
    HDC        hdcScreen = ::GetDC(NULL);
	CDC        dc,
               *pdcScreen = CDC::FromHandle(hdcScreen);
    POINT      pt = {0, 0};

	// Get our image list ready.
    dc.CreateCompatibleDC(NULL);
	listTemp.Create(16, 16, TRUE, 1, 1); 

	// Paint the busy image onto the normal image.
    bmpOverlay.LoadBitmap(iOverlay);
	listTemp.Add(&bmpOverlay, RGB(0, 255, 0));

	bmpImage.LoadBitmap(iImage);
	pbmpOld = dc.SelectObject(&bmpImage);	
	listTemp.Draw(&dc, 0, pt, ILD_TRANSPARENT);
	dc.SelectObject(pbmpOld);	
	m_imageList.Add(&bmpImage, cr);

	dc.DeleteDC();
	::ReleaseDC(NULL, hdcScreen);

	bmpImage.DeleteObject();
	bmpOverlay.DeleteObject();
}

void CMainFrame::AddImageAndBusyImage(int iImage, COLORREF cr)
{
    AddImage(iImage, cr);
    AddOverlayedImage(iImage, IDB_BUSY, cr); 
    AddOverlayedImage(iImage, IDB_ERROR, cr); 
}

void CMainFrame::AddImageAndKeyImage(int iImage, COLORREF cr)
{
    AddImage(iImage, cr);
    AddOverlayedImage(iImage, IDB_KEY, cr); 
}

void CMainFrame::OnUpdateStatusNumberObjects(CCmdUI* pCmdUI)
{
    pCmdUI->SetText(m_strStatus);
}

/*
void CMainFrame::OnInitMenu(CMenu* pMenu) 
{
	CFrameWnd::OnInitMenu(pMenu);
}

BOOL CMainFrame::OnCommand(WPARAM wParam, LPARAM lParam) 
{
    return CFrameWnd::OnCommand(wParam, lParam);
}
*/

LRESULT CMainFrame::OnEnterMenuLoop(WPARAM wParam, LPARAM lParam)
{
    m_wndStatusBar.SetIndicators(indicatorsMenuActive, 1);

    return 0;
}

LRESULT CMainFrame::OnExitMenuLoop(WPARAM wParam, LPARAM lParam)
{
    m_wndStatusBar.SetIndicators(indicatorsMenuGone, 2);
	m_wndStatusBar.SetPaneInfo(0, indicatorsMenuGone[0], SBPS_STRETCH, 0);
	m_wndStatusBar.SetPaneInfo(1, indicatorsMenuGone[1], SBPS_NORMAL, STATUS_SIZE_PROGRESS);

    return 0;
}

void CMainFrame::SetStatusText(LPCTSTR szText)
{
    m_strStatus = szText;
}

void CMainFrame::OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu) 
{
	CFrameWnd::OnInitMenuPopup(pPopupMenu, nIndex, bSysMenu);
	
	DWORD dwID = pPopupMenu->GetMenuItemID(0);

    if (dwID == ID_NO_METHODS_FOUND || dwID == ID_NO_S_METHODS)
	{
        CWMITestDoc *pDoc = (CWMITestDoc*) GetActiveDocument();
        CObjInfo    *pInfo = pDoc->GetCurrentObj();
		    
	    if (pInfo)
	    {
            CPropInfoArray *pProps = pInfo->GetProps();
            BOOL           bStatic = dwID == ID_NO_S_METHODS;

		    if (pProps && (bStatic && pProps->GetStaticMethodCount()) ||
                (!bStatic && pProps->GetMethodCount()))
            {
				// Get rid of the first item since it's only a placeholder.
				pPopupMenu->DeleteMenu(0, MF_BYPOSITION);

                POSITION pos = pProps->m_listMethods.GetHeadPosition();
                DWORD    dwID = IDC_EXECUTE_METHOD_FIRST;

                while (pos)
                {
                    CMethodInfo &info = pProps->m_listMethods.GetNext(pos);

                    // We only add it if we're not in static mode or if
                    // the method is static anyway.
                    if (!bStatic || info.m_bStatic)
                    {
                        pPopupMenu->AppendMenu(MF_STRING, dwID, info.m_strName);
                    }

                    dwID++;
                }
            }
	    }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\mainfrm.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__4419F1A8_692B_11D3_BD30_0080C8E60955__INCLUDED_)
#define AFX_MAINFRM_H__4419F1A8_692B_11D3_BD30_0080C8E60955__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "ToolBarEx.h"

class CObjView;

enum IMAGE_INDEXES
{
	IMAGE_ROOT,
    
    // Operation images
    IMAGE_QUERY,
    IMAGE_QUERY_BUSY,
    IMAGE_QUERY_ERROR,

    IMAGE_EVENT_QUERY,
    IMAGE_EVENT_QUERY_BUSY,
    IMAGE_EVENT_QUERY_ERROR,
    
    IMAGE_ENUM_OBJ,
    IMAGE_ENUM_OBJ_BUSY,
    IMAGE_ENUM_OBJ_ERROR,

    IMAGE_ENUM_CLASS,
    IMAGE_ENUM_CLASS_BUSY,
    IMAGE_ENUM_CLASS_ERROR,

    IMAGE_CLASS,
    IMAGE_CLASS_BUSY,
    IMAGE_CLASS_ERROR,
    IMAGE_CLASS_MODIFIED,

	IMAGE_OBJECT,
    IMAGE_OBJECT_BUSY,
    IMAGE_OBJECT_ERROR,
    IMAGE_OBJECT_MODIFIED,

    // Property images
	IMAGE_PROP_OBJECT,
	IMAGE_PROP_OBJECT_KEY,

    IMAGE_PROP_TEXT,
    IMAGE_PROP_TEXT_KEY,

    IMAGE_PROP_BINARY,
    IMAGE_PROP_BINARY_KEY,
};

class CMainFrame : public CFrameWnd
{
	
protected: // create from serialization only
	CMainFrame();
	DECLARE_DYNCREATE(CMainFrame)

// Attributes
protected:
	CSplitterWnd m_wndSplitter;
public:
	CImageList m_imageList;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	public:
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	//}}AFX_VIRTUAL
	//virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);

// Implementation
public:
	virtual ~CMainFrame();
	CObjView* GetRightPane();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

    void SetStatusText(LPCTSTR szText);

protected:  // control bar embedded members
	CStatusBar m_wndStatusBar;
	CToolBarEx m_wndToolBar;
	CReBar     m_wndReBar;
    CString    m_strStatus;

    void AddImage(DWORD dwID, COLORREF cr);
    void AddOverlayedImage(int iImage, int iOverlay, COLORREF cr);
    void AddImageAndBusyImage(int iImage, COLORREF cr);
    void AddImageAndKeyImage(int iImage, COLORREF cr);

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnClose();
    afx_msg void OnUpdateStatusNumberObjects(CCmdUI* pCmdUI);
	afx_msg void OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu);
	//}}AFX_MSG
	//afx_msg void OnInitMenu(CMenu* pMenu);
    afx_msg LRESULT OnEnterMenuLoop(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnExitMenuLoop(WPARAM wParam, LPARAM lParam);
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__4419F1A8_692B_11D3_BD30_0080C8E60955__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\mofdlg.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#if !defined(AFX_MOFDLG_H__BDFC722B_91DE_4278_B817_3DA6FFC099C5__INCLUDED_)
#define AFX_MOFDLG_H__BDFC722B_91DE_4278_B817_3DA6FFC099C5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// MofDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMofDlg dialog

class CMofDlg : public CDialog
{
// Construction
public:
	CMofDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CMofDlg)
	enum { IDD = IDD_MOF };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA
    IWbemClassObject *m_pObj;


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMofDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CMofDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MOFDLG_H__BDFC722B_91DE_4278_B817_3DA6FFC099C5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\methodspg.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/
// MethodsPg.cpp : implementation file
//

#include "stdafx.h"
#include "wmitest.h"
#include "MethodsPg.h"
#include "WMITestDoc.h"
#include "MainFrm.h"
#include "OpWrap.h"
#include "ParamsPg.h"
#include "PropQualsPg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMethodsPg property page

IMPLEMENT_DYNCREATE(CMethodsPg, CPropertyPage)

CMethodsPg::CMethodsPg() : CPropertyPage(CMethodsPg::IDD)
{
	//{{AFX_DATA_INIT(CMethodsPg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CMethodsPg::~CMethodsPg()
{
}

void CMethodsPg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMethodsPg)
	DDX_Control(pDX, IDC_METHODS, m_ctlMethods);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMethodsPg, CPropertyPage)
	//{{AFX_MSG_MAP(CMethodsPg)
	ON_BN_CLICKED(IDC_ADD, OnAdd)
	ON_BN_CLICKED(IDC_EDIT, OnEdit)
	ON_BN_CLICKED(IDC_DELETE, OnDelete)
	ON_NOTIFY(NM_DBLCLK, IDC_METHODS, OnDblclkMethods)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_METHODS, OnItemchangedMethods)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMethodsPg message handlers

void CMethodsPg::OnAdd() 
{
    CPropertySheet sheet(IDS_EDIT_NEW_METHOD);
    CParamsPg      pgParams;

    pgParams.m_bNewMethod = TRUE;
    pgParams.m_pClass = m_pObj;
    sheet.AddPage(&pgParams);

    if (sheet.DoModal() == IDOK)
    {
        HRESULT hr;

        hr = 
            m_pObj->PutMethod(
                _bstr_t(pgParams.m_strName),
                0,
                pgParams.m_pObjIn,
                pgParams.m_pObjOut);

        if (SUCCEEDED(hr))
            AddMethod(pgParams.m_strName);
        else
            CWMITestDoc::DisplayWMIErrorBox(hr);
    }
}

void CMethodsPg::OnEdit() 
{
    int iItem = GetSelectedItem();

    if (iItem != -1)
    {
        CPropertySheet sheet(IDS_EDIT_METHOD);
        CParamsPg      pgParams;
        CPropQualsPg   pgQuals;

        pgParams.m_strName = m_ctlMethods.GetItemText(iItem, 0);
        pgParams.m_bNewMethod = FALSE;
        pgParams.m_pClass = m_pObj;
        sheet.AddPage(&pgParams);

        pgQuals.m_pObj = m_pObj;
        pgQuals.m_bIsInstance = FALSE;
        pgQuals.m_mode = CPropQualsPg::QMODE_METHOD;
        pgQuals.m_strMethodName = pgParams.m_strName;
        sheet.AddPage(&pgQuals);

        if (sheet.DoModal() == IDOK)
        {
            HRESULT hr;

            hr = 
                m_pObj->PutMethod(
                    _bstr_t(pgParams.m_strName),
                    0,
                    pgParams.m_pObjIn,
                    pgParams.m_pObjOut);

            if (SUCCEEDED(hr))
            {
                LV_ITEM item;

                item.mask = LVIF_IMAGE;
                item.iItem = iItem;
                item.iImage = GetMethodImage(pgParams.m_strName);

                m_ctlMethods.SetItem(&item);
            }
            else
                CWMITestDoc::DisplayWMIErrorBox(hr);
        }
    }
}

void CMethodsPg::OnDelete() 
{
    int iItem = GetSelectedItem();

    if (iItem != -1)
    {
        HRESULT hr;
        CString strName = m_ctlMethods.GetItemText(iItem, 0);
        
        if (SUCCEEDED(hr =
            m_pObj->DeleteMethod(_bstr_t(strName))))
        {
            m_ctlMethods.DeleteItem(iItem);

            int nItems = m_ctlMethods.GetItemCount();

            if (iItem >= nItems)
                iItem--;

            if (iItem >= 0)
                m_ctlMethods.SetItemState(iItem, LVIS_SELECTED, LVIS_SELECTED);
        }
        else
            CWMITestDoc::DisplayWMIErrorBox(hr);
    }
}

void CMethodsPg::OnDblclkMethods(NMHDR* pNMHDR, LRESULT* pResult) 
{
	OnEdit();
	
	*pResult = 0;
}

void CMethodsPg::OnItemchangedMethods(NMHDR* pNMHDR, LRESULT* pResult) 
{
    UpdateButtons();
	
	*pResult = 0;
}

BOOL CMethodsPg::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
    InitListCtrl();

    LoadMethods();
    	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CMethodsPg::UpdateButtons()
{
    int iIndex = GetSelectedItem();

    GetDlgItem(IDC_DELETE)->EnableWindow(iIndex != -1);
    GetDlgItem(IDC_EDIT)->EnableWindow(iIndex != -1);
}

int CMethodsPg::GetSelectedItem()
{
    POSITION pos = m_ctlMethods.GetFirstSelectedItemPosition();

    if (pos)
        return m_ctlMethods.GetNextSelectedItem(pos);
    else
        return -1;
}

void CMethodsPg::InitListCtrl()
{
    RECT    rect;
    CString strTemp;
            
	m_ctlMethods.SetExtendedStyle(LVS_EX_FULLROWSELECT);

    m_ctlMethods.SetImageList(&((CMainFrame *) AfxGetMainWnd())->m_imageList, 
		LVSIL_SMALL);
    m_ctlMethods.GetClientRect(&rect);

    strTemp.LoadString(IDS_NAME);
    m_ctlMethods.InsertColumn(0, strTemp, LVCFMT_LEFT, rect.right);
}

void CMethodsPg::LoadMethods()
{
    HRESULT hr;

    m_ctlMethods.DeleteAllItems();

    int iItem = 0;

    if (SUCCEEDED(hr = m_pObj->BeginMethodEnumeration(0)))
    {
        BSTR pName = NULL;

        while(1)
        {
            hr = 
                m_pObj->NextMethod(
                    0,
                    &pName,
                    NULL,
                    NULL);

            if (FAILED(hr) || hr == WBEM_S_NO_MORE_DATA)
                break;

            AddMethod(_bstr_t(pName));

            SysFreeString(pName);
        }
    }
            
    UpdateButtons();

    if (FAILED(hr))
        CWMITestDoc::DisplayWMIErrorBox(hr);
}

int CMethodsPg::GetMethodImage(LPCTSTR szName)
{
    IWbemQualifierSetPtr pQuals;
    HRESULT              hr;
    int                  iImage = IMAGE_OBJECT;

    if (SUCCEEDED(hr = m_pObj->GetMethodQualifierSet(
        _bstr_t(szName),
        &pQuals)))
    {
        _variant_t vStatic;

        if (SUCCEEDED(hr = pQuals->Get(
            L"static",
            0,
            &vStatic,
            NULL)) && vStatic.vt == VT_BOOL && (bool) vStatic == true)
        {
            iImage = IMAGE_CLASS;
        }
    }

    return iImage;
}

void CMethodsPg::AddMethod(LPCTSTR szName)
{
    int iImage = GetMethodImage(szName),
        iItem = m_ctlMethods.GetItemCount();

    m_ctlMethods.InsertItem(iItem, szName, iImage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\namespacedlg.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// NamespaceDlg.cpp : implementation file
//

#include "stdafx.h"
#include "wmitest.h"
#include "WMITestDoc.h"
#include "NamespaceDlg.h"
#include "MainFrm.h"
//#include <cominit.h>
#include "utils.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNamespaceDlg dialog


CNamespaceDlg::CNamespaceDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CNamespaceDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CNamespaceDlg)
	m_strNamespace = _T("");
	//}}AFX_DATA_INIT
}


void CNamespaceDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNamespaceDlg)
	DDX_Control(pDX, IDC_NAMESPACE_TREE, m_ctlNamespace);
	DDX_Text(pDX, IDC_NAMESPACE, m_strNamespace);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNamespaceDlg, CDialog)
	//{{AFX_MSG_MAP(CNamespaceDlg)
	ON_NOTIFY(TVN_SELCHANGED, IDC_NAMESPACE_TREE, OnSelchangedNamespaceTree)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNamespaceDlg message handlers

BOOL CNamespaceDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
    m_ctlNamespace.SetImageList(
        &((CMainFrame *) AfxGetMainWnd())->m_imageList, 
		TVSIL_NORMAL);
	
	if (!PopulateTree())
        OnCancel();

    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

_COM_SMARTPTR_TYPEDEF(IWbemLocator, __uuidof(IWbemLocator));
_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject, __uuidof(IEnumWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));

typedef CList<_bstr_t, LPCWSTR> CBstrList;

BOOL CNamespaceDlg::AddNamespaceToTree(
    HTREEITEM hitemParent,
    LPCWSTR szNamespace, 
    IWbemLocator *pLocator, 
    BSTR pUser, 
    BSTR pPassword, 
    BSTR pAuthority,
    DWORD dwImpLevel,
    DWORD dwAuthLevel)
{
    HRESULT          hr;
    IWbemServicesPtr pNamespace;

    if (SUCCEEDED(hr = pLocator->ConnectServer(
        _bstr_t(szNamespace),
		pUser,      // username
		pPassword,	// password
		0,		    // locale
		0,		    // securityFlags
		pAuthority,	// authority (domain for NTLM)
		NULL,	    // context
		&pNamespace))) 
    {	
        SetSecurityHelper(
            pNamespace,
            pAuthority,
            pUser,
            pPassword,
            dwImpLevel,
            dwAuthLevel);
        
        IEnumWbemClassObjectPtr pEnum;

        if (SUCCEEDED(hr = 
            pNamespace->ExecQuery(
                _bstr_t(L"WQL"),
                _bstr_t(L"SELECT NAME FROM __NAMESPACE"),
                WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                NULL,
                &pEnum)))
        {
            IWbemClassObjectPtr pObj;
            DWORD               dwCount;
            CBstrList           listNamespaces;
            _variant_t          vNamespace;
            HTREEITEM           hitem;
            LPCWSTR             szBaseName = wcsrchr(szNamespace, '\\');

            if (szBaseName)
                szBaseName++;
            else
                szBaseName = szNamespace;

            // Insert the parent into the tree.
            hitem = 
                m_ctlNamespace.InsertItem(
                    _bstr_t(szBaseName),
                    IMAGE_ROOT,
                    IMAGE_ROOT,
                    hitemParent);

            SetSecurityHelper(
                pEnum,
                pAuthority,
                pUser,
                pPassword,
                dwImpLevel,
                dwAuthLevel);

            // Enum the child namespace names and put them into a list.  We're
            // putting them into a list so we don't have a bunch of namespaces
            // open like we would if we were to recursively call this function
            // without first building a list and then closing the currently
            // open namespace.
            while (SUCCEEDED(hr =
                pEnum->Next(
                    WBEM_INFINITE,
                    1,
                    &pObj,
                    &dwCount)) &&
                dwCount == 1 &&
                SUCCEEDED(hr = 
                pObj->Get(
                    L"NAME",
                    0,
                    &vNamespace,
                    NULL,
                    NULL)))
            {
                listNamespaces.AddTail(V_BSTR(&vNamespace));
            }

            // This will release it.
            pNamespace = NULL;

            POSITION pos = listNamespaces.GetHeadPosition();

            while (pos)
            {
                WCHAR szNewNamespace[256];

                swprintf(
                    szNewNamespace, 
                    L"%s\\%s", 
                    szNamespace, 
                    (LPWSTR) listNamespaces.GetNext(pos));

                if (!AddNamespaceToTree(
                        hitem,
                        szNewNamespace, 
                        pLocator, 
                        pUser, 
                        pPassword, 
                        pAuthority,
                        dwImpLevel,
                        dwAuthLevel))
                {
                    hr = WBEM_E_FAILED;
                    break;
                }
            }

            m_ctlNamespace.SortChildren(hitem);
        }
    }

    if (FAILED(hr))
        CWMITestDoc::DisplayWMIErrorBox(hr);
        
    return SUCCEEDED(hr);
}

BOOL CNamespaceDlg::PopulateTree()
{
    HRESULT          hr;
    IWbemLocatorPtr  pLocator;
    IWbemServicesPtr pSvc;
    CWaitCursor      wait;
    CString          strNamespace = m_strNamespace;
    int              iWhere;
    BOOL             bRet;

    strNamespace.MakeUpper();

    // See if we can find a server name.
    if ((iWhere = strNamespace.Find("\\ROOT")) != -1 && iWhere != 0)
        m_strServer = m_strNamespace.Left(iWhere);

    // If we get something like \\server\root\blah we need to strip off
    // everything after the \\server\root.
    if ((iWhere = strNamespace.Find("ROOT\\")) != -1)
        strNamespace = m_strNamespace.Left(iWhere + 4);
    


    if ((hr = CoCreateInstance(
        CLSID_WbemLocator,
		NULL,
		CLSCTX_INPROC_SERVER,
		IID_IWbemLocator,
		(LPVOID *) &pLocator)) == S_OK)
    {
	    // Using the locator, connect to CIMOM in the given namespace.
        BSTR pUser = m_strUser.IsEmpty() ? NULL : 
                         m_strUser.AllocSysString(),
             pPassword = m_bNullPassword || !pUser ? NULL : 
                            m_strPassword.AllocSysString(),
             pAuthority = m_strAuthority.IsEmpty() ? NULL : 
                              m_strAuthority.AllocSysString();

        bRet = 
            AddNamespaceToTree(
                TVI_ROOT, 
                _bstr_t(strNamespace), 
                pLocator, pUser, pPassword, pAuthority,
                m_dwImpLevel,
                m_dwAuthLevel);

        m_ctlNamespace.Expand(m_ctlNamespace.GetRootItem(), TVE_EXPAND);

        // Done with BSTR vars.
        if (pUser)
            SysFreeString(pUser);

		if (pPassword)
            SysFreeString(pPassword);

		if (pAuthority)
            SysFreeString(pAuthority);
    }
    else
    {
        CWMITestDoc::DisplayWMIErrorBox(hr);

        bRet = FALSE;
    }

    return bRet;
}

void CNamespaceDlg::RefreshNamespaceText()
{
    CString   strNamespace;
    HTREEITEM hitem = m_ctlNamespace.GetSelectedItem();

    while (hitem != NULL)
    {
        CString strItem = m_ctlNamespace.GetItemText(hitem);

        if (!strNamespace.IsEmpty())
            strNamespace = strItem + "\\" + strNamespace;
        else
            strNamespace = strItem;

        hitem = m_ctlNamespace.GetParentItem(hitem);
    }

    if (!m_strServer.IsEmpty())
        strNamespace = m_strServer + "\\" + strNamespace;

    SetDlgItemText(IDC_NAMESPACE, strNamespace);
}

void CNamespaceDlg::OnSelchangedNamespaceTree(NMHDR* pNMHDR, LRESULT* pResult) 
{
    NM_TREEVIEW *pNMTreeView = (NM_TREEVIEW*)pNMHDR;

    if ((pNMTreeView->itemNew.state & TVIS_SELECTED))
        RefreshNamespaceText();

    *pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\mofdlg.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/
// MofDlg.cpp : implementation file
//

#include "stdafx.h"
#include "wmitest.h"
#include "MofDlg.h"
#include "WMITestDoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMofDlg dialog


CMofDlg::CMofDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CMofDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CMofDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void FixCRs(CString &strText)
{
	CString strTemp = strText;

	strText = "";
	while (strTemp.GetLength())
	{
		int iWhere = strTemp.Find('\n');

		if (iWhere == -1)
		{
			strText += strTemp;
			strTemp = "";
		}
		else
		{
			strText += strTemp.Left(iWhere);
			strText += "\r\n";
			strTemp = strTemp.Mid(iWhere + 1);
		}
	}
}

void CMofDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMofDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP

    if (!pDX->m_bSaveAndValidate)
    {
        BSTR    bstrText;
        HRESULT hr;

        if (SUCCEEDED(hr = m_pObj->GetObjectText(
            0,
            &bstrText)))
        {
            CString strText = bstrText;

            FixCRs(strText);

            SetDlgItemText(IDC_MOF, strText);

            SysFreeString(bstrText);
        }
        else
        {
            CWMITestDoc::DisplayWMIErrorBox(hr);

            OnCancel();
        }
    }
}


BEGIN_MESSAGE_MAP(CMofDlg, CDialog)
	//{{AFX_MSG_MAP(CMofDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMofDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\methodspg.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/
#if !defined(AFX_METHODSPG_H__E986F30F_9737_4F89_8EFD_571B852DD02D__INCLUDED_)
#define AFX_METHODSPG_H__E986F30F_9737_4F89_8EFD_571B852DD02D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// MethodsPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMethodsPg dialog

class CMethodsPg : public CPropertyPage
{
	DECLARE_DYNCREATE(CMethodsPg)

// Construction
public:
	CMethodsPg();
	~CMethodsPg();

// Dialog Data
	//{{AFX_DATA(CMethodsPg)
	enum { IDD = IDD_METHODS };
	CListCtrl	m_ctlMethods;
	//}}AFX_DATA
    IWbemClassObject *m_pObj;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMethodsPg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void InitListCtrl();
    void LoadMethods();
    void UpdateButtons();
    void AddMethod(LPCTSTR szName);
    int GetSelectedItem();
    int GetMethodImage(LPCTSTR szName);

	// Generated message map functions
	//{{AFX_MSG(CMethodsPg)
	afx_msg void OnAdd();
	afx_msg void OnEdit();
	afx_msg void OnDelete();
	afx_msg void OnDblclkMethods(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemchangedMethods(NMHDR* pNMHDR, LRESULT* pResult);
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_METHODSPG_H__E986F30F_9737_4F89_8EFD_571B852DD02D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\namespacedlg.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#if !defined(AFX_NAMESPACEDLG_H__DFA6B3D0_FDAA_4E25_BFC8_32B1C4E1A932__INCLUDED_)
#define AFX_NAMESPACEDLG_H__DFA6B3D0_FDAA_4E25_BFC8_32B1C4E1A932__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// NamespaceDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CNamespaceDlg dialog

class CNamespaceDlg : public CDialog
{
// Construction
public:
	CNamespaceDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	CString m_strUser,
	        m_strPassword,
	        m_strAuthority;
    BOOL    m_bNullPassword;
    DWORD   m_dwAuthLevel,
            m_dwImpLevel;

	//{{AFX_DATA(CNamespaceDlg)
	enum { IDD = IDD_NAMESPACE };
	CTreeCtrl	m_ctlNamespace;
	CString	m_strNamespace;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNamespaceDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    CString m_strServer;

    BOOL PopulateTree();
    void RefreshNamespaceText();
    BOOL AddNamespaceToTree(
        HTREEITEM hitemParent,
        LPCWSTR szNamespace, 
        IWbemLocator *pLocator, 
        BSTR pUser, 
        BSTR pPassword, 
        BSTR pAuthority,
        DWORD dwImpLevel,
        DWORD dwAuthLevel);

	// Generated message map functions
	//{{AFX_MSG(CNamespaceDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangedNamespaceTree(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NAMESPACEDLG_H__DFA6B3D0_FDAA_4E25_BFC8_32B1C4E1A932__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\newpropdlg.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// NewPropDlg.cpp : implementation file
//

#include "stdafx.h"
#include "wmitest.h"
#include "NewPropDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewPropDlg dialog


CNewPropDlg::CNewPropDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CNewPropDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CNewPropDlg)
	m_strName = _T("");
	//}}AFX_DATA_INIT
}

#define IDS_FIRST_TYPE      IDS_CIM_SINT8
#define IDS_LAST_TYPE       IDS_CIM_OBJECT

static DWORD dwTypes[] =
{
    CIM_SINT8,
    CIM_UINT8,
    CIM_SINT16,
    CIM_UINT16,
    CIM_SINT32,
    CIM_UINT32,
    CIM_SINT64,
    CIM_UINT64,
    CIM_REAL32,
    CIM_REAL64,
    CIM_BOOLEAN,
    CIM_STRING,
    CIM_DATETIME,
    CIM_REFERENCE,
    CIM_CHAR16,
    CIM_OBJECT,
};

void CNewPropDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNewPropDlg)
	DDX_Control(pDX, IDC_TYPE, m_ctlTypes);
	DDX_Text(pDX, IDC_NAME, m_strName);
	//}}AFX_DATA_MAP

    if (!pDX->m_bSaveAndValidate)
    {
        CString strType;

        for (int i = IDS_FIRST_TYPE; i <= IDS_LAST_TYPE; i++)
        {
            int iWhere;

            strType.LoadString(i);
            iWhere = m_ctlTypes.AddString(strType);

            m_ctlTypes.SetItemData(iWhere, dwTypes[i - IDS_FIRST_TYPE]);
        }

        // Select CIM_STRING as our default type.
        strType.LoadString(IDS_CIM_STRING);
        m_ctlTypes.SelectString(-1, strType);

        // Make OK disabled until we get a property name.
        GetDlgItem(IDOK)->EnableWindow(FALSE);
    }
    else
    {
        m_type = m_ctlTypes.GetItemData(m_ctlTypes.GetCurSel());
        
        if (IsDlgButtonChecked(IDC_ARRAY))
            m_type |= CIM_FLAG_ARRAY;    
    }
}


BEGIN_MESSAGE_MAP(CNewPropDlg, CDialog)
	//{{AFX_MSG_MAP(CNewPropDlg)
	ON_EN_CHANGE(IDC_NAME, OnChangeName)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewPropDlg message handlers

void CNewPropDlg::OnChangeName() 
{
    GetDlgItem(IDOK)->EnableWindow(
        SendDlgItemMessage(IDC_NAME, WM_GETTEXTLENGTH, 0, 0) != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\newpropdlg.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/
#if !defined(AFX_NEWPROPDLG_H__6DA24B90_235B_4795_A263_E5CBD8B8829C__INCLUDED_)
#define AFX_NEWPROPDLG_H__6DA24B90_235B_4795_A263_E5CBD8B8829C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// NewPropDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CNewPropDlg dialog

class CNewPropDlg : public CDialog
{
// Construction
public:
	CNewPropDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CNewPropDlg)
	enum { IDD = IDD_NEW_PROPERTY };
	CComboBox m_ctlTypes;
	CString	m_strName;
	//}}AFX_DATA

    CIMTYPE m_type;


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewPropDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNewPropDlg)
	afx_msg void OnChangeName();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NEWPROPDLG_H__6DA24B90_235B_4795_A263_E5CBD8B8829C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\wmitest\objvw.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// ObjVw.cpp : implementation of the CObjView class
//

#include "stdafx.h"
#include "WMITest.h"

#include "MainFrm.h"
#include "WMITestDoc.h"
#include "OpView.h"
#include "ObjVw.h"
#include "ValuePg.h"
#include "PropQualsPg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CObjView

IMPLEMENT_DYNCREATE(CObjView, CListView)

BEGIN_MESSAGE_MAP(CObjView, CListView)
	//{{AFX_MSG_MAP(CObjView)
	ON_WM_SIZE()
	ON_NOTIFY_REFLECT(LVN_GETDISPINFO, OnGetDispInfo)
	ON_NOTIFY_REFLECT(NM_RCLICK, OnRclick)
	ON_NOTIFY_REFLECT(NM_DBLCLK, OnDblclk)
	ON_COMMAND(ID_MODIFY, OnModify)
	ON_UPDATE_COMMAND_UI(ID_MODIFY, OnUpdateModify)
	ON_COMMAND(ID_NEW_PROP, OnNewProp)
	ON_UPDATE_COMMAND_UI(ID_NEW_PROP, OnUpdateNewProp)
	ON_COMMAND(ID_DELETE, OnDelete)
	ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
	ON_WM_DESTROY()
	ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditCopy)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

#define DEF_NAME_COL_CX     175
#define DEF_TYPE_COL_CX     150
#define DEF_VAL_COL_CX      250
#define DEF_SINGLE_COL_CX   300

/////////////////////////////////////////////////////////////////////////////
// CObjView construction/destruction

CObjView::CObjView() :
    m_pList(NULL),
    m_hitemLastChildUpdate(NULL),
    m_hitemLastParentUpdate(NULL),
    m_nCols(0),
    m_iColHint(0),
    m_pWrap(NULL)
{
    CString strCols;

    strCols = 
        theApp.GetProfileString(_T("Settings"), _T("ColWidths"), _T("175 150 250 300"));
    
    if (_stscanf(
        strCols,
        _T("%d %d %d %d"),
        &m_cxPropertyCols[0],
        &m_cxPropertyCols[1],
        &m_cxPropertyCols[2],
        &m_cxSingleCol) != 4)
    {
        m_cxPropertyCols[0] = DEF_NAME_COL_CX;
        m_cxPropertyCols[1] = DEF_TYPE_COL_CX;
        m_cxPropertyCols[2] = DEF_VAL_COL_CX;

        m_cxSingleCol = DEF_SINGLE_COL_CX;
    }
}

CObjView::~CObjView()
{
}

BOOL CObjView::PreCreateWindow(CREATESTRUCT& cs)
{
	cs.style |= WS_CHILD | WS_VISIBLE | LVS_REPORT | LVS_SHAREIMAGELISTS;

	return CListView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CObjView drawing

void CObjView::OnInitialUpdate()
{
	CListView::OnInitialUpdate();

	m_pList->SetExtendedStyle(LVS_EX_FULLROWSELECT);

    m_pList->SetImageList(&((CMainFrame *) GetParentFrame())->m_imageList, 
		LVSIL_SMALL);

    GetDocument()->m_pObjView = this;
}

/////////////////////////////////////////////////////////////////////////////
// CObjView diagnostics

#ifdef _DEBUG
void CObjView::AssertValid() const
{
	CListView::AssertValid();
}

void CObjView::Dump(CDumpContext& dc) const
{
	CListView::Dump(dc);
}

CWMITestDoc* CObjView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CWMITestDoc)));
	return (CWMITestDoc*)m_pDocument;
}
#endif //_DEBUG


void CObjView::OnSize(UINT nType, int cx, int cy) 
{
	CListView::OnSize(nType, cx, cy);
	
	if (!m_pList)
		m_pList = &GetListCtrl();
}

void CObjView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint) 
{
	CTreeCtrl *pTree = GetDocument()->m_pOpView->m_pTree;
    HTREEITEM hItem = (HTREEITEM) pHint;
    CObjInfo  *pInfo = NULL;

    if (!pTree)
        return;

    switch(lHint)
    {
        case HINT_NEW_CHILD:
        {
            // A child was added.  We only need to do stuff if the child's 
            // parent is the same one that's selected.
            if (m_hitemLastParentUpdate == pTree->GetParentItem(hItem))
            {
		        int  iImage;
                
                pTree->GetItemImage(hItem, iImage, iImage);

                if (!m_nCols || 
                    (m_pWrap && m_pWrap->m_piDisplayCols.GetUpperBound() >= 
                    m_nCols))
                {
                    // Don't need to remove columns here.
                    AddColumns(m_hitemLastParentUpdate);
                }

                m_pList->InsertItem(
			        LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE, 
			        m_pList->GetItemCount(),	
			        LPSTR_TEXTCALLBACK,
			        0, 
			        0,
			        iImage,
			        (LPARAM) hItem);
            }

            break;
        }

        case HINT_NEW_OP:   
            // We don't care unless we start to display stuff for the root 
            // item.
            break;

        case HINT_OP_SEL:
        {
            COpWrap *pWrap = (COpWrap*) pTree->GetItemData(hItem);

            if (!pWrap->IsObject())
            {
                m_hitemLastParentUpdate = hItem;
                m_hitemLastChildUpdate = NULL;

                // Need to get rid of all columns.
                RemoveColumns();

                m_iColHint = HINT_OP_SEL;
                AddColumns(hItem);

                // So we don't have to keep asking for this.
                m_pWrap = (COpWrap*) pTree->GetItemData(m_hitemLastParentUpdate);
                
                // Fill the list with all the items in this parent.
                AddChildItems(hItem);

                break;
            }
            else
            {
                // If we're an op that's itself an object (Get Obj and Get 
                // Class).
                
                // Fake an object selection.
                pInfo = pWrap->GetObjInfo();

                // Fall through to finish our fakery.
            }   
        }

        case HINT_OBJ_SEL:
            m_hitemLastParentUpdate = NULL;

            if (m_iColHint != HINT_OBJ_SEL || !m_nCols)
            {
                RemoveColumns();

                m_iColHint = HINT_OBJ_SEL;
                AddColumns();
            }

            m_pWrap = NULL;
            m_hitemLastChildUpdate = hItem;

            if (!pInfo)
                pInfo = (CObjInfo*) pTree->GetItemData(hItem);

            AddObjValues(pInfo);
            
            break;

        case HINT_ROOT_SEL:
            m_hitemLastParentUpdate = NULL;
            m_hitemLastChildUpdate = NULL;
            
            if (m_iColHint != HINT_ROOT_SEL)
            {
                RemoveColumns();

                m_iColHint = HINT_ROOT_SEL;

                // Need to get rid of all columns.
                AddColumns();
            }

            m_pWrap = NULL;

            break;
    }
}

void CObjView::OnGetDispInfo(NMHDR* pNMHDR, LRESULT* pResult) 
{
	LV_DISPINFO *pDispInfo = (LV_DISPINFO*) pNMHDR;
	int			iItem = pDispInfo->item.iItem,
				iSubItem = pDispInfo->item.iSubItem;
	CString		str;
    HTREEITEM   hitem = (HTREEITEM) m_pList->GetItemData(iItem);
	
	// Op node selected in tree?
	if (m_hitemLastParentUpdate)
	{
		pDispInfo->item.mask |= LVIF_DI_SETITEM;

        if (pDispInfo->item.mask & LVIF_IMAGE)
		{
			pDispInfo->item.iImage = m_iItemImage;
		}

		if (pDispInfo->item.mask & LVIF_TEXT)
		{
            CObjInfo *pInfo = (CObjInfo*) GetDocument()->m_pOpView->m_pTree->
                                    GetItemData(hitem);

            if (!m_pWrap->ShowPathsOnly())
            {
                int iProperty = m_piDisplayCols[iSubItem];

			    pDispInfo->item.pszText[pDispInfo->item.cchTextMax - 1] = '\0';
            
                if (pInfo)
                {
                    CString strValue;

                    m_pWrap->GetPropValue(
                        pInfo, iProperty, strValue, theApp.m_bTranslateValues);

                    lstrcpyn(pDispInfo->item.pszText, strValue, pDispInfo->item.cchTextMax - 1);
                }            						
            }
            else
            {
                CString strName = pInfo->GetStringPropValue(L"__RELPATH");

                lstrcpyn(pDispInfo->item.pszText, strName, pDispInfo->item.cchTextMax - 1);
            }
		}
	}
	
	*pResult = 0;
}

void CObjView::SaveColumns()
{
    if (m_iColHint == HINT_OP_SEL)
    {
        if (m_pWrap->ShowPathsOnly())
            m_cxSingleCol = m_pList->GetColumnWidth(0);
        else
        {    
            for (int i = 0; i < m_nCols; i++)
                m_pWrap->m_piDisplayColsWidth[i] = m_pList->GetColumnWidth(i);
        }
    }
    else if (m_iColHint == HINT_OBJ_SEL)
    {
        for (int i = 0; i < 3; i++)
            m_cxPropertyCols[i] = m_pList->GetColumnWidth(i);
    }
}

void CObjView::RemoveColumns()
{ 
    while (m_nCols > 0)
        m_pList->DeleteColumn(--m_nCols);

    m_pList->DeleteAllItems();
}

void CObjView::AddColumns(HTREEITEM hItem)
{
    //if (bRemovePrevCols)
    //    RemoveAllColumns();

    switch(m_iColHint)
    {
        case HINT_OBJ_SEL:
        {
            CString strTemp;
            
            strTemp.LoadString(IDS_NAME);
            m_pList->InsertColumn(0, strTemp, LVCFMT_LEFT, m_cxPropertyCols[0]);
            
            strTemp.LoadString(IDS_TYPE);
            m_pList->InsertColumn(1, strTemp, LVCFMT_LEFT, m_cxPropertyCols[1]);
            
            strTemp.LoadString(IDS_VALUE);
            m_pList->InsertColumn(2, strTemp, LVCFMT_LEFT, m_cxPropertyCols[2]);

            m_nCols = 3;
            break;
        }

        case HINT_OP_SEL:
        {
            CTreeCtrl *pTree = GetDocument()->m_pOpView->m_pTree;
            COpWrap   *pWrap = (COpWrap*) pTree->GetItemData(hItem);
            
            if (!pWrap->ShowPathsOnly())
            {
                int nItems = pWrap->m_piDisplayCols.GetUpperBound() + 1;
            
                m_piDisplayCols.SetSize(nItems);

                for (int i = m_nCols; i < nItems; i++)
                {
                    CString &strClass = pWrap->m_strProps[pWrap->m_piDisplayCols[i]];

                    m_piDisplayCols[i] = pWrap->m_piDisplayCols[i];
                    m_pList->InsertColumn(
                        i, 
                        strClass, 
                        LVCFMT_LEFT, 
                        pWrap->m_piDisplayColsWidth[i]);
                }

                // Set the number of columns to nItems.
                m_nCols = nItems;
            }
            else
            {
                if (m_nCols == 0)
                {
                    CString strClass;

                    strClass.LoadString(pWrap->HoldsObjects() ? IDS_OBJ_PATH : IDS_CLASS);

                    m_pList->InsertColumn(m_nCols++, strClass, LVCFMT_LEFT, m_cxSingleCol);
                }
            }

            break;
        }
    }
}

void CObjView::AddChildItems(HTREEITEM hItem)
{
    CTreeCtrl *pTree = GetDocument()->m_pOpView->m_pTree;
    
    for (HTREEITEM itemChild = pTree->GetChildItem(hItem);
        itemChild != NULL;
        itemChild = pTree->GetNextSiblingItem(itemChild))
    {
        int iImage;

        pTree->GetItemImage(itemChild, iImage, iImage);

        m_pList->InsertItem(
		    LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE, 
			m_pList->GetItemCount(),	
			LPSTR_TEXTCALLBACK,
			0, 
			0,
			iImage,
			(LPARAM) itemChild);
    }
}

void CObjView::AddObjValues(HTREEITEM hItem)
{
    CTreeCtrl *pTree = GetDocument()->m_pOpView->m_pTree;
    CObjInfo  *pInfo = (CObjInfo*) pTree->GetItemData(hItem);

    AddObjValues(pInfo);
}

void CObjView::AddObjValues(CObjInfo *pInfo)
{
    m_pList->DeleteAllItems();

    CPropInfoArray *pProps = pInfo->GetProps();

    if (pInfo->m_pObj != NULL && pProps != NULL)
    {
        for (int i = 0; i <= pProps->GetUpperBound(); i++)
        {
            int     iFlavor,
                    iImage;
            CString strType,
                    strValue;

            pInfo->GetPropInfo(i, strValue, strType, &iImage, &iFlavor, 
                theApp.m_bTranslateValues);

            if ((theApp.m_bShowSystemProperties ||
                iFlavor != WBEM_FLAVOR_ORIGIN_SYSTEM) &&
                (theApp.m_bShowInheritedProperties ||
                iFlavor != WBEM_FLAVOR_ORIGIN_PROPAGATED))
            {
                int iIndex;

                iIndex =
                    m_pList->InsertItem(
		                LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE, 
			            m_pList->GetItemCount(),	
			            (*pProps)[i].m_strName,
			            0, 
			            0,
			            iImage,
			            i);

                m_pList->SetItemText(iIndex, 1, strType);
                m_pList->SetItemText(iIndex, 2, strValue);
            }
        }
    }
}

void CObjView::Flush()
{
    CString strCols;

    strCols.Format(
        _T("%d %d %d %d"),
        m_cxPropertyCols[0],
        m_cxProper