: the long integer

 NOTES	    :

---------------------------------------------------------------------------*/

long FAR osAtoL (LPXSTR lpsz)
  {

#ifdef OAU
      char szlTmp[20];

      WideCharToMultiByte(CP_ACP,
			  0,
                          lpsz,
			  -1,
                          szlTmp,
                          20,
			  NULL,
			  NULL);

     return atol(szlTmp) ;
#else
     return atol(lpsz) ;
#endif

  }


/*---------------------------------------------------------------------------
 NAME	    : osGetNetDrive

 PURPOSE    : Establish/Break a net connection

 INPUTS     : lpszNetDir - string to receieve the network drive letter
	      bnAct - flag for establishing or breaking the net connection
		      TRUE: establish a net connection
		      FALSE: break a net connection

 OUTPUT     : True if net connect is established/broken successfully

 NOTES	    : Since Win32s has no API's that support net work action; this
	      routine does nothing for right now.  It can be modified to
	      establish/break a net connection programmatically in the future.

---------------------------------------------------------------------------*/

BOOL FAR osGetNetDrive(LPXSTR lpszNetDir, LPXSTR lpUNCDir, BOOL /*bnAct*/)	// [4]
  {
     osStrCpy(lpszNetDir, XSTR("z:\\tmp\\")) ;
     osStrCpy(lpUNCDir, XSTR("\\\\apputest\\slm\\tmp\\")) ;

     return TRUE ;
  }


/*---------------------------------------------------------------------------
 NAME	    : osCreateGuid

 PURPOSE    : Converts a GUID value from string to GUID format

 INPUTS     : lpszGuid - string contains the desired GUID value

 OUTPUT     : pointer to the GUID structure

 NOTES	    : caller is responsible to free up the memory after used

---------------------------------------------------------------------------*/

GUID FAR * osCreateGuid(LPXSTR lpszGuid)
   {

     GUID    FAR * lpGuid ;
     HRESULT hRes ;

     lpGuid = (GUID FAR *) osAllocSpaces(sizeof(GUID)*2) ;// allocate space
							  // for the Guid
     if ( lpGuid )
       {					// convert string to GUID format
	  hRes = CLSIDFromStringX(lpszGuid, (LPCLSID)lpGuid);
	  if ( LOWORD (hRes) )
	    {
	      osDeAllocSpaces ((LPXSTR)lpGuid) ; // release space before exit
	      return NULL ;
	    }
	  else
	      return lpGuid ;		  // return pointer to the
       }				  // GUID structure
     else
       return NULL ;			  // no space is allocated

   }

/*---------------------------------------------------------------------------
 NAME	    : osRetrieveGuid

 PURPOSE    : Converts a GUID structure to a readable string format

 INPUTS     : lpszGuid - string representation of the GUID will be returned
	      GUID     - the GUID structure in concern

 OUTPUT     : True if conversion is succeed

 NOTES	    :

---------------------------------------------------------------------------*/

BOOL FAR osRetrieveGuid (LPXSTR lpszGuid, GUID inGuid)
   {
     LPOLESTR   lpszTmp ;
     HRESULT hRes ;
					    // allocate memory for the string
     hRes = StringFromCLSID((REFCLSID) inGuid, &lpszTmp) ;
      if ( LOWORD (hRes) )		    // representation
	{
	   ppmalloc->Free(lpszTmp) ;
	   return FALSE ;
	}
      else
	{
#ifdef OAU
	   osStrCpy (lpszGuid, lpszTmp) ;
#else
	   WideCharToMultiByte(CP_ACP,
			       0,
			       lpszTmp,
			       -1,
			       lpszGuid,
			       40,
			       NULL,
			       NULL);
#endif
	   ppmalloc->Free(lpszTmp) ;
	   return TRUE ;
	}
   }

/*---------------------------------------------------------------------------
 NAME	    : osGetSize

 PURPOSE    : returns size of the input data

 INPUTS     : inVT - data type; WORD

 OUTPUT     : size of inVT; WORD

 NOTES	    :

---------------------------------------------------------------------------*/

WORD FAR osGetSize (WORD inVT)
   {
      WORD tSize ;

      switch ( inVT )
       {
	 case VT_I2:
	   tSize = sizeof(short) ;
	   break ;
	 case VT_I4:
	   tSize = sizeof(long) ;
	   break ;
	 case VT_R4:
	   tSize = sizeof(float) ;
	   break ;
	 case VT_R8:
	   tSize = sizeof(double) ;
	   break ;
	 case VT_CY:
	   tSize = sizeof(CY) ;
	   break ;
	 case VT_DATE:
	   tSize = sizeof(DATE) ;
	   break ;
	 case VT_BSTR:
	   tSize = sizeof(BSTR) ;
	   break ;
	 case VT_ERROR:
	   tSize = sizeof(SCODE) ;
	   break ;
	 case VT_BOOL:
	   tSize = sizeof(VARIANT_BOOL) ;
	   break ;
	 case VT_VARIANT:
	   tSize = sizeof(VARIANT) ;
	   break ;
	 case VT_I1:
	   tSize = sizeof(char) ;
	   break ;
	 case VT_UI1:
	   tSize = sizeof(char) ;
	   break ;
	 case VT_UI2:
	   tSize = sizeof(short) ;
	   break ;
	 case VT_UI4:
	   tSize = sizeof(long) ;
	   break ;
	 case VT_I8:
	   tSize = sizeof(long)*2 ;
	   break ;
	 case VT_UI8:
	   tSize = sizeof(long)*2 ;
	   break ;
	 case VT_INT:
	   tSize = sizeof(int) ;
	   break ;
	 case VT_UINT:
	   tSize = sizeof(int) ;
	   break ;
	 case VT_VOID:
	   tSize = 0 ;
	   break ;
	 case VT_HRESULT:
	   tSize = sizeof(HRESULT) ;
	   break ;
	 case VT_LPSTR:
	   tSize = sizeof(LPSTR) ;
	   break ;
	 case VT_PTR:
	   tSize = 4 ;
	   break ;
	 case VT_SAFEARRAY:
	   tSize = sizeof(ARRAYDESC FAR *) ;
           break ;
         case VT_DISPATCH:
           tSize = 4 ;
           break ;
         case VT_UNKNOWN:
           tSize = 4 ;
	   break ;
	 default:
	   tSize = 1 ;
	   break ;
       }

      return tSize ;
}

/*---------------------------------------------------------------------------
 NAME	    : osGetAlignment

 PURPOSE    : returns value of the alignment

 INPUTS     : inVT - data type; WORD
              mAlign - max possible alignment; WORD

 OUTPUT     : value of the aliangment; WORD

 NOTES	    : value is machine dependent:
		 Win16 = 1 (everything is packed -> always = 1)
                 Win32 = natural alignment; max is 4-byte align
		 mac   = everything is on the even-byte boundary
	      see silver\cl\clutil.cxx for a table of the alignement information
---------------------------------------------------------------------------*/

WORD FAR osGetAlignment (WORD inVT, WORD mAlign)
  {
     WORD expAlign ;

     expAlign = osGetSize(inVT) ;         // check size of the data

     return ( expAlign <= mAlign ? expAlign : mAlign ) ;
  }

/*---------------------------------------------------------------------------
 NAME	    : osGetEnumType

 PURPOSE    : return the type of an enum member

 INPUTS     : none

 OUTPUT     : VT_I2 for Win16; VARTYPE

 NOTES	    :

---------------------------------------------------------------------------*/

VARTYPE FAR osGetEnumType ()
  {
     return VT_I4 ;
  }

/*---------------------------------------------------------------------------
 NAME	    : osOleInit

 PURPOSE    : Calls OleInitialize and returns its return code

 INPUTS     : none

 OUTPUT     : return code from calling OleInitialize; HRESULT

 NOTES	    :

---------------------------------------------------------------------------*/

HRESULT FAR osOleInit ()
  {
     HRESULT hRes ;

     hRes = OleInitialize(NULL) ;      // Ole initialization

#ifdef DEBUG
     if ( hRes != NOERROR )
       return hRes ;

     hRes = GetMallocSpy(&g_IMallocSpy) ;   // [5]
     hRes = CoRegisterMallocSpy(g_IMallocSpy) ;

     if ( hRes != NOERROR )
       OleUninitialize ;
     else
       hRes = CoGetMalloc(MEMCTX_TASK, &ppmalloc) ;
#else
     if ( !LOWORD(hRes) )	       // allocate memory for use in the
       hRes = CoGetMalloc(MEMCTX_TASK, &ppmalloc) ;  // the program
#endif

     return hRes ;

  }

/*---------------------------------------------------------------------------
 NAME	    : osOleUninit

 PURPOSE    : Calls OleUnInitialize

 INPUTS     : none

 OUTPUT     : none

 NOTES	    :

---------------------------------------------------------------------------*/

VOID FAR osOleUninit ()
  {

     ppmalloc->Release () ;	       // release memory that was been
     OleUninitialize ();	       // allocated at OleInitialize
#ifdef DEBUG
     CoRevokeMallocSpy () ;	       // [5]
#endif
  }

/*---------------------------------------------------------------------------
 NAME	    : osMessage

 PURPOSE    : Displays a MessageBox

 INPUTS     : Message to be displayed; a string of characters

 OUTPUT     : none

 NOTES	    :

---------------------------------------------------------------------------*/

VOID FAR osMessage (LPXSTR lpszMsg, LPXSTR lpszTitle)
  {
#if defined (OAU) && !defined (UNICODE)// [1]
      char szBufferM[256];
      char szBufferT[256];

      WideCharToMultiByte(CP_ACP,
			  0,
			  lpszMsg,
			  -1,
			  szBufferM,
			  256,
			  NULL,
			  NULL);

      WideCharToMultiByte(CP_ACP,
			  0,
			  lpszTitle,
			  -1,
			  szBufferT,
			  256,
			  NULL,
			  NULL);
    MessageBox (NULL, szBufferM, szBufferT, MB_OK) ;
#else				       // if OAU && ! UNICODE
    MessageBox (NULL, lpszMsg, lpszTitle, MB_OK) ;
#endif				       // if OAU && ! UNICODE
  }

/*---------------------------------------------------------------------------
 NAME       : osSetErrorMode

 PURPOSE    : For Win16 compatibility

 INPUTS     : eFlag - UINT

 OUTPUT     : UINT

 NOTES      : This routine is for Win16 compatibility purposes

---------------------------------------------------------------------------*/

UINT FAR osSetErrorMode (UINT eFlag)
  {
    return eFlag ;
  }

/*---------------------------------------------------------------------------
 NAME	    : WinMain

 PURPOSE    : Entry point of the test

 INPUTS     : standard inputs

 OUTPUT     : None

 NOTES	    :
---------------------------------------------------------------------------*/
int FAR pascal WinMain(HINSTANCE /*hInstanceCur*/, HINSTANCE /*hInstancePrev*/, LPSTR lpCmdLineA, int /*nCmdShow*/)
   {
#ifdef OAU
	XCHAR lpCmdLine[128];

        MultiByteToWideChar(CP_ACP,
			  MB_PRECOMPOSED,
			  lpCmdLineA,
			  -1,
			  lpCmdLine,
			  128);
#else				      //OAU
#define lpCmdLine	lpCmdLineA
#endif				      //OAU
      mainEntry (lpCmdLine) ;	      // entry point for all programs

      return 1 ;
   }


//======================= Wrapper functions ==================================

#if !defined(OAU)
/*---------------------------------------------------------------------------
 NAME	    : CreateTypeLibA

 PURPOSE    : Creates a typelib name of which is an ANSI string

 INPUTS     : syskind - os that the type library is created on; SYSKIND
	      szFile - name of type library; ANSI string
	      ppctlib - pointer to the created library

 OUTPUT     : None

 NOTES	    :
---------------------------------------------------------------------------*/
STDAPI
CreateTypeLibA(SYSKIND syskind, char * szFile, ICreateTypeLibA * * ppctlib)
  {				      // [1]
    OLECHAR	   szFileW[_MAX_PATH] ;
    ICreateTypeLib * ptlibW ;
    HRESULT	   hresult ;

    MultiByteToWideChar(CP_ACP,
			MB_PRECOMPOSED,
			szFile,
			-1,
			szFileW,
			_MAX_PATH);

    hresult = CreateTypeLib(syskind, szFileW, &ptlibW);

    if (hresult == NOERROR)
      {
	hresult = ptlibW->QueryInterface(IID_ICreateTypeLibA, (VOID **)ppctlib);
        ptlibW->Release();
      }
    return hresult;
  }

/*---------------------------------------------------------------------------
 NAME       : LHashValOfNameSysA

 PURPOSE    : Finds the hash value for a given string

 INPUTS     : syskind - current operating system
              lcid - lcid of the currenet system
              szName - string in concern; ANSI string

 OUTPUT     : Return LHashValOfNameSys

 NOTES	    :
---------------------------------------------------------------------------*/
STDAPI_(unsigned long)
LHashValOfNameSysA(SYSKIND syskind, LCID lcid, char * szName)
  {
    OLECHAR szNameW[_MAX_PATH];

    if ( szName )
      {
         MultiByteToWideChar(CP_ACP,
			MB_PRECOMPOSED,
			szName,
			-1,
			szNameW,
			_MAX_PATH);

         return LHashValOfNameSys(syskind, lcid, szNameW) ;
      }
    else
         return LHashValOfNameSys(syskind, lcid, NULL) ;

  }

/*---------------------------------------------------------------------------
 NAME	    : LoadTypeLibA

 PURPOSE    : Loads a typelib name of which is an ANSI string

 INPUTS     : szFile - name of type library; ANSI string
	      pptlib - pointer to the loaded library

 OUTPUT     : None

 NOTES	    :
---------------------------------------------------------------------------*/
STDAPI
LoadTypeLibA(char * szFile, ITypeLibA * * pptlib)
  {
    OLECHAR szFileW[_MAX_PATH];
    ITypeLib * ptlibW;
    HRESULT hresult = (HRESULT) E_INVALIDARG ;

    if ( szFile && pptlib )
      {
         MultiByteToWideChar(CP_ACP,
			MB_PRECOMPOSED,
			szFile,
			-1,
			szFileW,
			_MAX_PATH);

         hresult = LoadTypeLibEx(szFileW, REGKIND_NONE, &ptlibW);

         if (hresult == NOERROR)       // convert the wide pointer to a narrow
           {                           // one
              hresult = ptlibW->QueryInterface(IID_ITypeLibA, (VOID **)pptlib);
              ptlibW->Release();
           }
       }

    return hresult;
  }


/*---------------------------------------------------------------------------
 NAME       : LoadRegTypeLibA

 PURPOSE    : Loads a typelib according to the info from the registry

 INPUTS     : rguid - GUID of the library
              wVerMajor - Major version number of the library
              wVerMinor - Minor version number of the library
              pptlib - pointer to receive the library; an ANSI pointer

 OUTPUT     : result from LoadRegTypeLib

 NOTES	    :
---------------------------------------------------------------------------*/
STDAPI
LoadRegTypeLibA(REFGUID rguid, unsigned short wVerMajor, unsigned short wVerMinor, LCID lcid, ITypeLibA * * pptlib)
  {
    ITypeLib * ptlibW;
    HRESULT hresult;

    hresult = LoadRegTypeLib(rguid, wVerMajor, wVerMinor, lcid, &ptlibW);

    if (hresult == NOERROR) {         // convert the wide pointer to a narrow
	hresult = ptlibW->QueryInterface(IID_ITypeLibA, (VOID **)pptlib);
        ptlibW->Release();            // one
    }
    return hresult;
  }


/*---------------------------------------------------------------------------
 NAME       : RegisterTypeLibA

 PURPOSE    : Adds information of a library to the system registry

 INPUTS     : ptlib - pointer to the library; an ANSI pointer
              szFullPath - pathspec of the library; ANSI string
              szHelpDir - pathspec of the help file; ANSI string

 OUTPUT     : result from RegisterTypeLib

 NOTES	    :
---------------------------------------------------------------------------*/
STDAPI
RegisterTypeLibA(ITypeLibA FAR * ptlib, char * szFullPath,  char * szHelpDir)
  {
    OLECHAR  szPathW[_MAX_PATH];
    OLECHAR  szHelpW[_MAX_PATH];
    ITypeLib FAR * ptlibW = NULL ;
    BOOL     PathOk = FALSE , HelpOk = FALSE ;
    HRESULT  hresult = (HRESULT) TYPE_E_LIBNOTREGISTERED ;

    if ( !ptlib )                     // ptlib == NULL
      return (HRESULT) E_INVALIDARG ;

    ptlibW = ITypeLibWFromA(ptlib) ;  // convert the narrow pointer to a wide
                                      // one
    if ( ptlibW )                     // check if the pathspec is NULL or not
      {                               // if it is not, convert the ANSI path
        if ( szFullPath )             // to an UNICODE path
            {
               MultiByteToWideChar(CP_ACP,
			MB_PRECOMPOSED,
			szFullPath,
			-1,
			szPathW,
                        _MAX_PATH);
               PathOk = TRUE ;
            }

        if ( szHelpDir )
            {
               MultiByteToWideChar(CP_ACP,
			MB_PRECOMPOSED,
			szHelpDir,
			-1,
			szHelpW,
                        _MAX_PATH);
               HelpOk = TRUE ;
            }

        if ( PathOk && HelpOk )       // if both pathspec's are not NULL
           hresult = RegisterTypeLib(ptlibW, szPathW, szHelpW);
        else
          {
             if ( PathOk )            // here if helpdir is NULL
                hresult = RegisterTypeLib(ptlibW, szPathW, NULL);
             else                     // here if pathspec of library is NULL
                hresult = RegisterTypeLib(ptlibW, NULL, szHelpW);
          }

        ptlibW->Release();
     }

    return hresult;
  }

/*---------------------------------------------------------------------------
 NAME	    : CLSIDFromStringA

 PURPOSE    : Converts an ANSI string to a UUID

 INPUTS     : szG - string that represents a UUID; ANSI string
	      lpG - pointer to the UUID

 OUTPUT     : return code form CLSIDFromString

 NOTES	    :
---------------------------------------------------------------------------*/
STDAPI
CLSIDFromStringA(char * szG, LPCLSID lpG)
  {
    OLECHAR szGW[100];

    MultiByteToWideChar(CP_ACP,
			MB_PRECOMPOSED,
			szG,
			-1,
			szGW,
			100);

    return CLSIDFromString(szGW, (LPCLSID)lpG) ;
  }


/*---------------------------------------------------------------------------
 NAME	    : IIDFromStringA

 PURPOSE    : Converts an ANSI string to an IID

 INPUTS     : szA   - string that represents a IID; ANSI string
	      lpiid - pointer to the iid

 OUTPUT     : Return code form IIDFromString

 NOTES	    :
---------------------------------------------------------------------------*/
STDAPI
IIDFromStringA(LPSTR lpszA, LPIID lpiid)
  {
    OLECHAR szAW[100];

    MultiByteToWideChar(CP_ACP,
			MB_PRECOMPOSED,
			lpszA,
			-1,
			szAW,
			100);

    return IIDFromString(szAW, (LPIID)lpiid) ;
  }


/*---------------------------------------------------------------------------
 NAME       : StgCreateDocfileA

 PURPOSE    : Creates a doc file

 INPUTS     : pwcsName - name of the doc file; ANSI string
              grfMode - creation mode
              ppstgOpenA - pointer the storage

 OUTPUT     : Return code from StgCreateDocfile

 NOTES	    :
---------------------------------------------------------------------------*/
STDAPI StgCreateDocfileA(LPCSTR pwcsName, DWORD grfMode, DWORD reserved, IStorage * *ppstgOpenA)
  {
    OLECHAR szNameW[100];

    MultiByteToWideChar(CP_ACP,
			MB_PRECOMPOSED,
			pwcsName,
			-1,
			szNameW,
			100);

    return StgCreateDocfile(szNameW, grfMode, reserved, ppstgOpenA) ;
  }


/*---------------------------------------------------------------------------
 NAME       : CreateFileMonikerA

 PURPOSE    : Creates a doc file

 INPUTS     : szfName - name of the file spec; ANSI string
              pmk - pointer the moniker

 OUTPUT     : Return code from CreateFileMoniker

 NOTES	    :
---------------------------------------------------------------------------*/
STDAPI CreateFileMonikerA (char * szfName, LPMONIKER FAR * pmk)  // [2]
 {
    OLECHAR szNameW[128];

    MultiByteToWideChar(CP_ACP,
			MB_PRECOMPOSED,
                        szfName,
			-1,
			szNameW,
                        128);

    return CreateFileMoniker(szNameW, pmk) ;
  }

#endif				      // if !OAU


#if defined(OAU) && !defined(UNICODE) // [1]
/*---------------------------------------------------------------------------
 NAME	    : osKillFile

 PURPOSE    : Removes a specific file from the disk

 INPUTS     : szFile - name of file to be removed; UNICODE string

 OUTPUT     : Output from DeleteFile

 NOTES	    :
---------------------------------------------------------------------------*/
int osKillFile (XCHAR * szFile)
  {
      char szBuffer[256];

      WideCharToMultiByte(CP_ACP,
			  0,
			  szFile,
			  -1,
			  szBuffer,
			  256,
			  NULL,
			  NULL);

      return DeleteFile (szBuffer) ;
  }

/*---------------------------------------------------------------------------
 NAME	    : osRmDir

 PURPOSE    : Removes a specific directory from the disk

 INPUTS     : szDir - name of directory to be removed; UNICODE string

 OUTPUT     : Output from RemoveDirectory

 NOTES	    :
---------------------------------------------------------------------------*/
int osRmDir    (XCHAR * szDir)
  {
      char szBuffer[256];

      WideCharToMultiByte(CP_ACP,
			  0,
			  szDir,
			  -1,
			  szBuffer,
			  256,
			  NULL,
			  NULL);

      return RemoveDirectory(szBuffer) ;
  }

/*---------------------------------------------------------------------------
 NAME	    : LCMapStringX

 PURPOSE    : Converts one string of characters to another

 INPUTS     : lcid - Locale context fo the mapping; LCID
	      dw1  - type of mapping; unsigned long
	      sz1  - string for conversion; UNICODE string
	      i1   - number of characters in sz1; int
	      sz2  - buffer to store the resulting string; UNICODE string
	      i2   - number of characters converted

 OUTPUT     : Output from LCMapStringA

 NOTES	    :
---------------------------------------------------------------------------*/
int LCMapStringX  (LCID lcid, DWORD dw1, LPXSTR sz1, int i1, LPXSTR sz2, int i2) // [3]
  {
      char szBuf1[300];
      char szBuf2[300];
      int  retval ;

      WideCharToMultiByte(CP_ACP,
			  0,
			  sz1,
			  -1,
			  szBuf1,
			  300,
			  NULL,
			  NULL);

      retval = LCMapStringA(lcid, dw1, szBuf1, i1, szBuf2, i2) ;

      MultiByteToWideChar(CP_ACP,
			  MB_PRECOMPOSED,
			  szBuf2,
			  -1,
			  sz2,
			  300);

      return retval ;
  }

#endif				      // if OAU && !UNICODE

#ifdef OAU


/*---------------------------------------------------------------------------
 NAME       : fopenX

 PURPOSE    : Opens a file for read/write

 INPUTS     : szFilName - name of file to be open; UNICODE string
              szMode - purpose for the file; UNICODE string

 OUTPUT     : Return code from fopen

 NOTES	    :
---------------------------------------------------------------------------*/
FILE * fopenX(XCHAR * szFilName, XCHAR * szMode)
  {
      char  szANSITmp1[256];
      char  szANSITmp2[256];

      WideCharToMultiByte(CP_ACP,
			  0,
			  szFilName,
			  -1,
			  szANSITmp1,
			  256,
			  NULL,
			  NULL);

      WideCharToMultiByte(CP_ACP,
			  0,
			  szMode,
			  -1,
			  szANSITmp2,
			  256,
			  NULL,
			  NULL);

      return fopen(szANSITmp1, szANSITmp2) ;  // open output as an ANSI file
  }


/*---------------------------------------------------------------------------
 NAME       : fputsX

 PURPOSE    : Writes to a file for read/write

 INPUTS     : szBuf - data to be written; UNICODE string
              hFile - handle of the output file

 OUTPUT     : Return code from fputs

 NOTES	    :
---------------------------------------------------------------------------*/
int fputsX(XCHAR *szBuf, FILE *hFile)
   {
      char  szANSITmp[512];

      WideCharToMultiByte(CP_ACP,
			  0,
			  szBuf,
			  -1,
			  szANSITmp,
			  512,
			  NULL,
			  NULL);

     return fputs(szANSITmp, hFile)  ;
  }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\btools\tlviewer\apglobal.h ===
/*** 
*apglobal.h - Header file for the C/C++ version of the apglobal functions 
*
*  Copyright (C) 1992, Microsoft Corporation.  All Rights Reserved.
*  Information Contained Herein Is Proprietary and Confidential.
*
*Purpose: Defines the apglobal functions 
*
*Revision History:
*
* [00]	25-Nov-92      ChrisKau : created
* [01]	13-Dec-92      Brandonb : changed to DLL, added apLogExtra
* [02]  04-Jan-93      ChrisKau : added apSPrintf
* [03]  19-Jan-94	   MesfinK  : added WriteDebugStr lWriteAnsi
*	
*Implementation Notes:
*
*****************************************************************************/

#define E_TEST_FAILED 	MAKE_SCODE(SEVERITY_ERROR, FACILITY_DISPATCH, 1024)
#define E_BAD_TEST 		MAKE_SCODE(SEVERITY_ERROR, FACILITY_DISPATCH, 1025)


#ifdef _MAC
//  ************************* MAC MAC MAC **************************
#ifdef __cplusplus
extern "C" {
#endif


#define XCHAR		char
#define LPXSTR 		char *
#define XSTR(x)		x
#define SYSCHAR		char
#define LPSYSSTR 	char *
#define SYSSTR(x)	x

int apLogFailInfo(char FAR *szDescription, char FAR *szExpected, char FAR *szActual, char FAR *szBugNum);
int apInitTest(char FAR *szTestName);
int apInitScenario(char FAR *szScenario);
void apEndTest();
int apWriteDebug(char FAR *szFormat, ...);

#define osStrCpy  strcpy
#define osStrCmp  strcmp
#define osStrCmpi strcmpi
#define osStrCat  strcat
#define osStrLen  strlen
#define apSPrintf sprintf

short FSpFileExists(FSSpec *f);
short FSpOpenForAppend(FSSpec *fs);
short FSpOpenForOutput( FSSpec *fs );
OSErr FSpAppend(FSSpec *fileA, FSSpec *fileB);
OSErr WriteLn(short fRefNum, StringPtr s);
void Yield();	

#ifdef __cplusplus
}
#endif

#else  // ******************* NOT MAC ******************************

#ifdef OAU
#define XCHAR   WCHAR
#define LPXSTR  LPWSTR
#define XSTR(x) L##x
#else	
#define XCHAR   char
#define LPXSTR  LPSTR
#define XSTR(x) x
#endif	


#ifdef UNICODE
#define SYSCHAR     WCHAR
#define LPSYSSTR    LPWSTR
#define SYSSTR(x)   L##x
#else	
#define SYSCHAR     char
#define LPSYSSTR    LPSTR
#define SYSSTR(x)   x
#endif	

#if defined(WIN16)
#define lstrcpyA lstrcpy
#define lstrcatA lstrcat
#define FILETHING HFILE
#else
#define FILETHING FILE *
#endif


#ifdef __cplusplus
extern "C" {
#endif

void    FAR PASCAL  apEndTest           ();
int     FAR PASCAL  apInitTestCore      (SYSCHAR FAR * szTestName);
int     FAR PASCAL  apLogFailInfoCore   (LPSYSSTR szDescription, LPSYSSTR szExpected, LPSYSSTR szActual, LPSYSSTR szBugNum);
int     FAR PASCAL  apInitScenarioCore  (SYSCHAR FAR * szScenarioName);
int     FAR __cdecl apWriteDebugCore    (SYSCHAR FAR *szFormat, ...);
int     FAR PASCAL  apInitPerfCore      (SYSCHAR FAR * szServerType, SYSCHAR FAR * szProcType, int bitness, int server_bitness);
int     FAR PASCAL  apLogPerfCore       (SYSCHAR FAR * szTestType, DWORD microsecs, float std_deviation);


// wrap function with pascal calling convention so you can call from vb3
#if defined(WIN16)
DATE FAR PASCAL apDateFromStr(char FAR *str, LCID lcid);
#endif

#if defined(_NTWIN)

int     FAR PASCAL  apInitTestA     (LPSTR szTestName);
int     FAR PASCAL  apLogFailInfoA  (LPSTR szDescription, LPSTR szExpected, LPSTR szActual, LPSTR szBugNum);
int     FAR PASCAL  apInitScenarioA (LPSTR szScenarioName);
int     FAR __cdecl apWriteDebugA   (char FAR *szFormat, ...);
int     FAR PASCAL  apInitPerfA     (char FAR * szServerType, char FAR * szProcType, int bitness, int server_bitness);
int     FAR PASCAL  apLogPerfA      (char FAR * szTestType, DWORD microsecs, float std_deviation);

#else // win16 || chicago || win32s

#if defined(WIN32)

int     FAR PASCAL  apInitTestW     (LPWSTR szTestName);
int     FAR PASCAL  apLogFailInfoW  (LPWSTR szDescription, LPWSTR szExpected, LPWSTR szActual, LPWSTR szBugNum);
int     FAR PASCAL  apInitScenarioW (LPWSTR szScenarioName);
int     FAR __cdecl apWriteDebugW   (LPWSTR szFormat, ...);
int     FAR PASCAL  apInitPerfW     (LPWSTR szServerType, LPWSTR szProcType, int bitness, int server_bitness);
int     FAR PASCAL  apLogPerfW      (LPWSTR szTestType, DWORD microsecs, float std_deviation);
LPWSTR  FAR PASCAL  lstrcatWrap     (LPWSTR sz1, LPWSTR sz2);
LPWSTR  FAR PASCAL  lstrcpyWrap     (LPWSTR sz1, LPWSTR sz2);
int     FAR PASCAL  lstrcmpWrap     (LPWSTR sz1, LPWSTR sz2);
int     FAR PASCAL  lstrcmpiWrap    (LPWSTR sz1, LPWSTR sz2);
SIZE_T     FAR PASCAL  lstrlenWrap     (LPWSTR sz1);
int     FAR __cdecl wsprintfWrap    (LPWSTR szDest, WCHAR FAR *szFormat, ...);
#endif //win32
#endif //_ntwin


#if !defined(_APGLOBAL_)
#if defined(_NTWIN)
#if defined (OAU)
#define     apInitTest      apInitTestCore
#define     apLogFailInfo   apLogFailInfoCore
#define     apInitScenario  apInitScenarioCore
#define     apWriteDebug    apWriteDebugCore
#define     apInitPerf		apInitPerfCore
#define		apLogPerf		apLogPerfCore
#define     osStrCmp        lstrcmp
#define     osStrCmpi       lstrcmpi
#define     osStrCpy        lstrcpy
#define     osStrCat        lstrcat
#define     osStrLen        lstrlen
#define     apSPrintf       wsprintf
#define     apSPrintfA      wsprintfA
#else
#define     osStrCmp        lstrcmpA
#define     osStrCmpi       lstrcmpiA
#define     osStrCpy        lstrcpyA
#define     osStrCat        lstrcatA
#define     osStrLen        lstrlenA
#define     apSPrintf       wsprintfA
#define     apSPrintfW      wsprintf
#define     apInitTest      apInitTestA
#define     apLogFailInfo   apLogFailInfoA
#define     apInitScenario  apInitScenarioA
#define     apWriteDebug    apWriteDebugA
#define     apInitPerf		apInitPerfA
#define		apLogPerf		apLogPerfA
#endif // OAU
#else // win16 || chicago || win32s
#if defined (OAU)
#define     osStrCmp        lstrcmpWrap
#define     osStrCmpi       lstrcmpiWrap
#define     osStrCpy        lstrcpyWrap
#define     osStrCat        lstrcatWrap
#define     osStrLen        lstrlenWrap
#define     apInitTestA     apInitTestCore
#define     apLogFailInfoA  apLogFailInfoCore
#define     apInitScenarioA apInitScenarioCore
#define     apWriteDebugA   apWriteDebugCore
#define     apInitTest      apInitTestW
#define     apLogFailInfo   apLogFailInfoW
#define     apInitScenario  apInitScenarioW
#define     apWriteDebug    apWriteDebugW
#define     apInitPerf		apInitPerfW
#define		apLogPerf		apLogPerfW
#define     apSPrintf       wsprintfWrap
#define     apSPrintfA      wsprintf
#else
#define     apInitTest      apInitTestCore
#define     apLogFailInfo   apLogFailInfoCore
#define     apInitScenario  apInitScenarioCore
#define     apWriteDebug    apWriteDebugCore
#define     apInitPerf		apInitPerfCore
#define		apLogPerf		apLogPerfCore
#define     osStrCmp        lstrcmp
#define     osStrCmpi       lstrcmpi
#define     osStrCpy        lstrcpy
#define     osStrCat        lstrcat
#define     osStrLen        lstrlen
#define     apSPrintf       wsprintf
#define     apSPrintfW      wsprintfWrap
#endif // OAU
#endif
#endif // !_APGLOBAL_

// functions internal to apglobal
#if defined(_APGLOBAL_)
#if defined(WIN32)
extern "C"
BOOL WINAPI _CRT_INIT(HINSTANCE, DWORD, LPVOID);
#endif

LPSTR       Unicode2Ansi    (SYSCHAR FAR *);
SIZE_T         lWriteAnsi      (FILETHING , SYSCHAR FAR *, int);
FILETHING   lOpenAnsi       (char FAR *);
int _cdecl  FilePrintf      (FILETHING, SYSCHAR FAR *, ...);
int         lCloseAnsi      (FILETHING f);

#endif // _APGLOBAL_

#ifdef __cplusplus
}
#endif

#endif // !_MAC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\btools\tlviewer\tlviewer.cpp ===
/* 
    Related Files:
	[Section=Compile]
		%TlViewerDir%:tlviewer.hxx
	  	[Platform= 3] %ApGlobalSrcDir%:apglobal.h
		%OsUtilDir%:osutil.hxx
	[Section=Link]
		[Options=NO_COPY] tlviewer.obj
		OsUtil.obj %OsUtilDir%:OsUtil.cpp
		[Platform= 6,7,8 Options=CVTRES] _resfile.obj %TlViewerDir%:RcBuild.ins
		[Platform= 6,7,8 Options=product] ole32.lib
		[Platform= 6,7,8 Options=product] oleaut32.lib
		[Platform= 6,7,8 Options=product] uuid.lib
		[Platform= 6,7,8 Options=SYSTEM_LIB] kernel32.lib
		[Platform= 6,7,8 Options=SYSTEM_LIB] user32.lib
		[Platform= 6,7,8 Options=C_LIB] libc.lib

               [Platform= 3 Options=C_LIB] libw.lib
               [Platform= 3 Options=C_LIB] mlibcew.lib
               [Platform= 3 Options=Product] typelib.lib
               [Platform= 3 Options=Product] ole2disp.lib
               [Platform= 3 Options=Product] ole2.lib
        	[Platform= 3 Options=DEFFILE] %TlViewerDir%:%platform%:tlviewer.def

		[Platform= 1] %BuildLibs%:Ole2Auto.far.debug.o
		[Platform= 1] %BuildLibs%:Ole2Lib.far.debug.o
		[Platform= 1] %BuildLibs%:StdCLib.o
		[Platform= 1] %BuildLibs%:Stubs.o
		[Platform= 1] %BuildLibs%:Runtime.o
		[Platform= 1] %BuildLibs%:Interface.o
       [Section=end]

    [ 0]		  Created			   AngelaCh
    [ 1]		  Added additional attributes	   ChrisK
    [ 2]  17-Mar-1994	  Added support for Win32s	   AngelaCh
    [ 3]  08-Apr-1994     Added LPWSTR                     AngelaCh
    [ 4]  08-Apr-1994     Added check for Licensed attr    AngelaCh
    [ 5]  20-Apr-1994     Added check for Alignment        AngelaCh
    [ 6]  24-May-1994     Added check for Source in method AngelaCh
    [ 7]  25-May-1994     Added checks for diff attributes AngelaCh
    [ 8]  19-Dec-1994	  Fixed problem in tOutDaul	   AngelaCh
    [ 9]  08-Feb-1995	  Added support for Null str const AngelaCh
    [10]  08-Feb-1995	  Added support for typeinfo level AngelaCh
			  Restricted attribute
    [11]  08-Feb-1995	  Added support for GetLastError   Angelach
    [12]  18-Apr-1995	  Added support for float's        Angelach
============================================================================== */

#include	"tlviewer.hxx"

const IID IID_ITypeLib2 = {0x00020411,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
const IID IID_ITypeInfo2 = {0x00020412,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

ITypeInfo2 * ptinfo2 = NULL;
ITypeLib2 * ptlib2 = NULL;
BSTRX    g_bstrHelpDll = NULL;		    // name of help DLL

VOID FAR mainEntry (LPXSTR lpCmd)
{
    if ( *lpCmd )
       {
	 ParseCmdLine (lpCmd) ;		     // get name of in/output files
	 ProcessInput () ;		     // read input file
       }
    else
       osMessage(XSTR("Usage: tlviewer <tlbfile> [<outputfile> [Alignment] [</o]]"), XSTR("Tlviewer")) ; // [5]

}

VOID NEAR ParseCmdLine (LPXSTR lpsz)
  {
      XCHAR  szlTmp[fMaxBuffer] ;
      LPXSTR lpszTmp ;			     // name of input type library
					     // is expected to be in the
      lpszTmp = lpsz ;			     // first substring; name of
      lpszTmp = fGetFileName (lpszTmp,  szInputFile) ;
      lpszTmp = fGetFileName (lpszTmp,  szOutputFile) ;
					     // output is in the second
					     // substring if specified
      if ( !*szOutputFile )		     // if no ouput file is
	 osStrCpy ( szOutputFile, defaultOutput ) ;
					     // specified; use default
      lpszTmp = fGetFileName (lpszTmp,  szlTmp) ;  // see if /o
					     // option is given

      isOut = TRUE;		// always as if /o was specified

      if ( osStrCmp(szlTmp, outOpt) == 0 )
         isOut = TRUE ;
      else                                   // if may be specifying an [5]
        if ( *szlTmp )                       // alignment value
          {
             inAlign = (unsigned short) osAtoL(szlTmp); // get alignment value
             lpszTmp = fGetFileName (lpszTmp, szlTmp) ; // see if /o
             if ( osStrCmp(szlTmp, outOpt) == 0 )       // option is given
               isOut = TRUE ;
          }
  }


LPXSTR NEAR fGetFileName (LPXSTR lpszIn, LPXSTR lpszOut)
  {
      int    i = 0 ;
      LPXSTR lpszTmp ;

      lpszTmp = lpszIn ;

      while ( *lpszTmp == ' ' )		     // remove leading spaces
	   lpszTmp++ ;

      while ( *lpszTmp != '\0' && *lpszTmp != ' ') // copy the substring (up
	{					   // to the first space) or
	   lpszOut[i] = *lpszTmp ;		   // the entire string of
	   lpszTmp++ ;				   // lpszIn to lpszOut
	   i++ ;
	}
      lpszOut[i] = '\0' ;

      return lpszTmp ;			     // return the remaining string
  }

VOID NEAR ProcessInput()
  {
      HRESULT	   hRes ;		     // return code
      XCHAR	   szTmp[fMaxBuffer] ;

      hRes = osOleInit () ;		     // ole initialization
      if ( !hRes )
	{				     // load the file
	   hRes = LoadTypeLibX( szInputFile, &ptLib) ; // [2]
	   OutToFile (hRes) ;		     // print result to the
					     // output file
	   osStrCpy(szTmp, szOutputFile) ;
	   osStrCat(szTmp, szOutSuccess) ;

	   if ( isOut )
             {
                 mFile = fopenX(szOutMsgFile, fnWrite);// open message file [2]
                 if (mFile == NULL)
                    {
                       osMessage (XSTR("Fail to open the message file"), XSTR("Tlviewer")) ;
                       osMessage (szTmp, XSTR("Tlviewer")) ;
                    }
                 else
                    {
                       WriteOut(mFile, szTmp) ;
                       fclose(mFile) ;       // finish writing to message file
                       mFile = NULL ;        // close done
                    }
	     }
	   else
	     osMessage (szTmp, XSTR("Tlviewer")) ;

	   osOleUninit () ;
	}
      else
	{
          if ( isOut )
             {
                mFile = fopenX(szOutMsgFile, fnWrite);// open message file [2]
                if (mFile == NULL)
                   {
                      osMessage (XSTR("Fail to open the message file"), XSTR("Tlviewer")) ;
                      osMessage (XSTR("OleInitialize fails"), XSTR("Tlviewer")) ;
                   }
                 else
                   {
                      WriteOut(mFile, XSTR("OleInitialize fails")) ;
                      fclose(mFile) ;
                      mFile = NULL ;
                    }
             }
	  else
	    osMessage (XSTR("OleInitialize fails"), XSTR("Tlviewer")) ;
	}
   }


VOID NEAR OutToFile(HRESULT hRes)
   {
      FILE  *hFile ;			     // file handle
      UINT  tInfoCount ;		     // total number of type info
      int   i ; 			     // note: szTmp is either UNICODE
      XCHAR  szTmp[fMaxBuffer] ;	     //       or ANSI

      hFile = fopenX(szOutputFile, fnWrite); // but we want to open output file [2]
      if (hFile == NULL)                     // as an ANSI file regardless
	{
	   osStrCpy(szTmp, XSTR("Fail to open the output file")) ;
	   osStrCat(szTmp, szOutputFile) ;
           if ( isOut )
             {
                mFile = fopenX(szOutMsgFile, fnWrite);// open message file [2]
                if (mFile == NULL)
                   {
                      osMessage (XSTR("Fail to open the message file"), XSTR("Tlviewer")) ;
                      osMessage (szTmp, XSTR("Tlviewer")) ;
                   }
                 else
                   {
                      WriteOut(mFile, szTmp) ;
                      fclose(mFile) ;
                      mFile = NULL ;
                    }
             }
	   else
	     osMessage (szTmp, XSTR("Tlviewer")) ;
	}
      else
	{
	 WriteOut(hFile, szFileHeader) ;     // output file header

         OLECHAR FAR* pchDir;

         // remove the path.
#if WIN32
         wcscpy(szTmp, szInputFile);
         pchDir = wcsrchr(szTmp, '\\');

         if (pchDir) {
           wcscpy(szTmp, pchDir + 1);
         }
#else // !WIN32
         _fstrcpy(szTmp, szInputFile);

         pchDir = _fstrrchr(szTmp, '\\');

         if (pchDir) {
           _fstrcpy(szTmp, pchDir + 1);
         }
#endif // !WIN32

	 // force path to lower case
#if WIN16
	 AnsiLower(szTmp);
#else //WIN16
	 WCHAR * pch;
	 for (pch = szTmp; *pch != 0; pch++) {
	   if (*pch >= OLECHAR('A') && *pch <= OLECHAR('Z'))
	     *pch = *pch + 'a' - 'A';
	 }
#endif //WIN16

	 WriteOut(hFile, szTmp) ;
	 WriteOut(hFile, szEndStr) ;

	 if ( FAILED(hRes) )		     // if it is not a valid type ****
	    WriteOut(hFile, szInputInvalid) ;// library
	 else
	   {
             // try to QI the typelib for ITypeLib2
             ptLib->QueryInterface(IID_ITypeLib2, (void **)&ptlib2);

      	     if ( fOutLibrary(hFile) )
	       {
		 tInfoCount = ptLib->GetTypeInfoCount() ;
		 for (i = 0 ; i < (int) tInfoCount ; i++)
		   {
		      if ( FAILED(ptLib->GetTypeInfo(i, &ptInfo)) )
			{
			   WriteOut(hFile, szReadFail) ;
			   WriteOut(hFile, XSTR("type info\n\n")) ;
			}
		      else
			{
			  // try to QI it for ITypeInfo2
	   		  ptInfo->QueryInterface(IID_ITypeInfo2, (void **)&ptinfo2);
			  if ( FAILED(ptInfo->GetTypeAttr(&lpTypeAttr)) )
			    {
			      WriteOut(hFile, szReadFail) ;
			      WriteOut(hFile, XSTR("attributes of type info\n\n")) ;
			    }
			  else
                            {
                              expAlign = 0 ;
                              alignFound = FALSE ;
			      switch (lpTypeAttr->typekind)
				{
				  case TKIND_ENUM:
				    tOutEnum(hFile, i) ;
				    break ;

				  case TKIND_RECORD:
				    tOutRecord(hFile, i) ;
				    break ;

				  case TKIND_MODULE:
				    tOutModule(hFile, i) ;
				    break ;

				  case TKIND_INTERFACE:
				    tOutInterface(hFile, i) ;
				    break ;

				  case TKIND_DISPATCH:
				    tOutDispatch(hFile, i) ;
				    break ;

				  case TKIND_COCLASS:
				    tOutCoclass(hFile, i) ;
				    break ;

				  case TKIND_ALIAS:
				    tOutAlias(hFile, i) ;
				    break ;

				  case TKIND_UNION:
				    tOutUnion(hFile, i) ;
				    break ;

			     /*	  case TKIND_ENCUNION:
				    tOutEncunion(hFile, i) ;
				    break ; */

				  default:
				    WriteOut(hFile,  XSTR("Type of definition is unknown\n\n")) ;
				}	     // switch
                               ptInfo->ReleaseTypeAttr (lpTypeAttr) ;
			    }		     // if gettypeattr
			  ptInfo->Release() ;// release the current TypeInfo
	 		  if (ptinfo2) {
			    ptinfo2->Release();
			  }
			}		     // if gettypeinfo
		   }			     // for i
		 WriteOut(hFile, XSTR("}\n")) ; // output the closing }
					     // if fOutLibrary
		 ptLib->Release();	     // clean up before exit
	       }
	    }

	 fclose(hFile);			     // finish writing to the output
	 hFile = NULL;			     // close done

	}
	if (ptlib2) {
	  ptlib2->Release();
	}
	SysFreeString((BSTR)g_bstrHelpDll) ;
  }


VOID  NEAR tOutCustData (FILE *hFile, LPCUSTDATA pCustData)
   {
      XCHAR  szTmp[50] ;
      UINT i;

      for (i = 0; i < pCustData->cCustData; i++) {
					    // get a string representation
					    // for the incoming Guid value
        if ( !(osRetrieveGuid (szTmp, pCustData->prgCustData[i].guid)) )
	   { WriteOut(hFile, szReadFail) ;
	   WriteOut(hFile, XSTR("insufficient memory")) ;
	   }
        else
	 {	    // string is in {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
	   szTmp[37] = '\0' ;	    // format, need to remove the {}
	   WriteAttr(hFile, XSTR("CustomGuid"), &szTmp[1], numValue) ;
	   
           VARIANT * pvar;
	   pvar = &pCustData->prgCustData[i].varValue;
           if ( FAILED(VariantChangeType(pvar, pvar, VARIANT_NOVALUEPROP,  VT_BSTR)) )
	     WriteOut(hFile, XSTR("VariantChangeType fails\n")) ;
	   else {
               WriteAttr(hFile, XSTR("CustomValue"), (BSTRX)pvar->bstrVal, strValue) ;
	   }

	 }
      }
      // done with it -- release all the memory
      ClearCustData(pCustData);
   }

BOOL NEAR fOutLibrary(FILE *hFile)
  {
      TLIBATTR FAR *lpLibAttr ;		     // attributes of the library
      XCHAR    szTmp[16] ;
      BOOL     retval = FALSE ;

      if ( FAILED( ptLib->GetLibAttr(&lpLibAttr) ) )

	{
	   WriteOut(hFile, szReadFail) ;
	   WriteOut(hFile, XSTR("attributes of library\n\n")) ;
	}
      else
	{				     // output documentational
	   tOutAttr(hFile, -1) ;	     // attributes first
					     // output id-related attributes
	   osLtoA((long)lpLibAttr->lcid, szTmp) ; // output lcid;
	   WriteAttr(hFile, attrLcid, szTmp, numValue) ; // default is 0
	   GetVerNumber (lpLibAttr->wMajorVerNum, lpLibAttr->wMinorVerNum, szTmp) ;
	   WriteAttr(hFile, attrVer, szTmp, numValue) ; // output version
	   tOutUUID(hFile, lpLibAttr->guid) ;
					     // output restricted attribute
           if ( (lpLibAttr->wLibFlags & LIBFLAG_FRESTRICTED) == LIBFLAG_FRESTRICTED )
	     WriteAttr(hFile, attrRestrict, NULL, noValue) ;
           if ( (lpLibAttr->wLibFlags & LIBFLAG_FCONTROL) == LIBFLAG_FCONTROL )  // [7]
             WriteAttr(hFile, attrControl, NULL, noValue) ;
           if ( (lpLibAttr->wLibFlags & LIBFLAG_FHIDDEN) == LIBFLAG_FHIDDEN )    // [7]
             WriteAttr(hFile, attrHidden, NULL, noValue) ;

	   if (ptlib2) {
	     // new-format typelib
             XCHAR szTmp[16] ;
	     DWORD cUniqueNames;
	     DWORD cchUniqueNames;
             HRESULT hresult;
	     hresult = ptlib2->GetLibStatistics(&cUniqueNames, &cchUniqueNames);

             osLtoA(cUniqueNames, szTmp);
	     WriteAttr(hFile, XSTR("cUniqueNames"), szTmp, numValue) ;
             osLtoA(cchUniqueNames, szTmp);
	     WriteAttr(hFile, XSTR("cchUniqueNames"), szTmp, numValue) ;

	     CUSTDATA custdata;
	     ptlib2->GetAllCustData(&custdata);
	     tOutCustData(hFile, &custdata);
	   }
	   if ( endAttrFlag )
	     {
	       WriteOut(hFile, szEndAttr) ;
	       endAttrFlag = FALSE ;
	     }
	   ptLib->ReleaseTLibAttr(lpLibAttr) ;	// de-allocate attribute

	   WriteOut(hFile, XSTR("\nlibrary ")) ;
	   tOutName(hFile, MEMBERID_NIL) ;	// output name of library
	   WriteOut(hFile, XSTR("{\n\n")) ;
	   retval = TRUE ;
	}					// if GetLibAttributes
      return (retval) ; 			// before exit
  }

VOID NEAR tOutEnum (FILE *hFile, int iTypeId)
   {
      WriteOut(hFile,  XSTR("\ntypedef\n")); // output typedef first
      tOutAttr(hFile, (int)iTypeId) ;	     // output attribute
      tOutMoreAttr(hFile) ;
      WriteOut(hFile,  XSTR("\nenum {\n")) ;
      tOutVar(hFile) ;                       // output enum members

      WriteOut(hFile,  XSTR("} ")) ;         // close the definition and
      tOutName(hFile, iTypeId) ;             // output name of the enum type
      WriteOut(hFile,  XSTR(" ;")) ;
      if ( inAlign )                         // [5]
        if ( lpTypeAttr->cbAlignment != osGetAlignment(VT_INT, inAlign) )
          tOutAlignError (hFile) ;

      WriteOut(hFile,  XSTR("\n\n")) ;
    }

VOID NEAR tOutRecord (FILE *hFile, int iTypeId)
   {
      WriteOut(hFile,  XSTR("\ntypedef\n")); // output typedef first
      tOutAttr(hFile, (int)iTypeId) ;        // output attribute
      tOutMoreAttr(hFile) ;
      WriteOut(hFile,  XSTR("\nstruct {\n")) ;
      tOutVar (hFile) ;                      // output members

      WriteOut(hFile,  XSTR("} ")) ;
      tOutName(hFile, iTypeId) ;
      WriteOut(hFile,  XSTR(" ;")) ;
      if ( inAlign )                         // [5]
        if ( lpTypeAttr->cbAlignment != expAlign )
           tOutAlignError (hFile) ;
      WriteOut(hFile,  XSTR("\n\n")) ;
   }

VOID  NEAR tOutModule	(FILE *hFile, int iTypeId)
   {
      tOutAttr(hFile, (int)iTypeId) ;	     // output attribute first
      tOutMoreAttr(hFile) ;
      WriteOut(hFile,  XSTR("\nmodule ")) ;
      tOutName(hFile, iTypeId) ;
      WriteOut(hFile, XSTR(" {\n")) ;

      tOutVar (hFile) ; 		     // output each const

      tOutFunc (hFile) ;		     // output each member function
      WriteOut(hFile,  XSTR("}\n\n")) ;
    }

VOID  NEAR tOutInterface(FILE *hFile, int iTypeId)
   {
      HREFTYPE	phRefType ;

      tOutAttr(hFile, (int)iTypeId) ;	     // output attribute first

      tOutMoreAttr(hFile) ;

      WriteOut(hFile,  XSTR("\ninterface ")) ;
      tOutName(hFile, iTypeId) ;
                                             // find out if the interface
      if ( !FAILED(ptInfo->GetRefTypeOfImplType(0, &phRefType)) )
	 {
	   isInherit = TRUE ;
           tOutAliasName(hFile, phRefType) ; // is inherited from some other
           isInherit = FALSE ;               // interface
	 }
      WriteOut(hFile, XSTR(" {\n")) ;

      tOutFunc (hFile) ;                     // output each member function
      if ( inAlign )                         // [5]
         {
           if ( expAlign )                   // is base-interface exists
             {                               // alignment depends on the base-
               if ( lpTypeAttr->cbAlignment != expAlign ) // interface
                 tOutAlignError (hFile) ;
             }
           else                              // otherwise, it depends on
             if ( lpTypeAttr->cbAlignment != osGetAlignment(VT_PTR, inAlign) )
                tOutAlignError (hFile) ;     // size of a pointer
         }
      WriteOut(hFile,  XSTR("}\n\n")) ;
    }

VOID  NEAR tOutDual (FILE *hFile, int iTypeId)  // [7]
   {
      ITypeInfoX FAR *lptInfo ;
      TYPEATTR   FAR *lpAttr ;
      HREFTYPE   phRefType ;

                                             // obtain reference to the
       if ( FAILED(ptInfo->GetRefTypeOfImplType((UINT)MEMBERID_NIL, &phRefType)) )
          {                                  // dual interface
             WriteOut(hFile, szReadFail) ;
             WriteOut(hFile, XSTR("tOutDispach: GetRefTypeOfImpType\n")) ;
          }
       else
          {                                  // get a pointer to the dual
             if ( FAILED(ptInfo->GetRefTypeInfo(phRefType, &lptInfo)) )
               {                             // interface
                 WriteOut(hFile, szReadFail) ;
                 WriteOut(hFile, XSTR("tOutDispatch: GetRefTypeInfo\n")) ;
               }
             else
               {
                 if ( FAILED(lptInfo->GetTypeAttr(&lpAttr)) )
                   {
                     WriteOut(hFile, szReadFail) ;
                     WriteOut(hFile, XSTR("attribute of reftype in tOutDual\n\n")) ;
		     lptInfo->Release () ;   // [8]
                   }
                 else
                   {
                     if ( lpAttr->typekind != TKIND_INTERFACE )
                       {
                         WriteOut(hFile, szReadFail) ;
                         WriteOut(hFile, XSTR("attribute of reftype in tOutDual\n\n")) ;
                         lptInfo->ReleaseTypeAttr (lpAttr) ;
			 lptInfo->Release () ; // [8]
                       }
                     else
		       {
			 ptInfo->ReleaseTypeAttr (lpTypeAttr) ;
			 ptInfo->Release () ;  // release the Dispinterface [8]
			 lpTypeAttr = lpAttr ;
			 ptInfo = lptInfo ;  // now points to the interface
			 tOutInterface(hFile, iTypeId) ; // output the dual interface
                       }
                   }                         // if typekind

               }                             // if GetRefTypeInfo
         }                                   // if GetRefTypeOfImplType
   }

VOID  NEAR tOutDispatch	(FILE *hFile, int iTypeId)
   {
      // dump the dispinterface, and dispinterface versions of dual interfaces
      tOutAttr(hFile, (int)iTypeId) ;   // output attribute first
      tOutMoreAttr(hFile) ;

      WriteOut(hFile,  XSTR("\ndispinterface ")) ;
      tOutName(hFile, iTypeId) ;
      WriteOut(hFile,  XSTR(" {\n")) ;
                                             // if there is no data nor function
      WriteOut(hFile,  XSTR("\nproperties:\n")) ;
      tOutVar (hFile) ;                 // output each date member

      WriteOut(hFile,  XSTR("\nmethods:\n")) ;
      tOutFunc (hFile) ;                // output each member function

                                             // alignment depends on the base-
      if ( inAlign )                    // interface which is stdole.tlb
         if ( lpTypeAttr->cbAlignment != osGetAlignment(VT_PTR, MaxAlignment) )
             tOutAlignError (hFile)  ;  // on that particular system [5]

      WriteOut(hFile,  XSTR("}\n\n")) ;

      // also dump the interface version of dual interfaces
      if ( ( lpTypeAttr->wTypeFlags & TYPEFLAG_FDUAL ) == TYPEFLAG_FDUAL ) // [7]
	{
	  // if dual, also dump the interface portion
	  tOutDual (hFile, iTypeId) ;
	}
    }

VOID  NEAR tOutCoclass	(FILE *hFile, int iTypeId)
   {

      HREFTYPE	phRefType ;
      WORD	i ;
      int	iFlags ;

      tOutAttr(hFile, (int)iTypeId) ;	    // output attribute first
					    // output appobject attribute if
      if ( ( lpTypeAttr->wTypeFlags & TYPEFLAG_FCANCREATE ) == 0 )
           WriteAttr(hFile, XSTR("noncreatable"), NULL, noValue) ;
      tOutMoreAttr(hFile) ;

      WriteOut(hFile,  XSTR("\ncoclass ")) ;// well
      tOutName(hFile, iTypeId) ;
      WriteOut(hFile,  XSTR(" {\n")) ;

      for ( i = 0 ; i < lpTypeAttr->cImplTypes; i++ )
	{
	  if ( FAILED(ptInfo->GetRefTypeOfImplType(i, &phRefType)) )
	    {
	       WriteOut(hFile, szReadFail) ;
	       WriteOut(hFile, XSTR("GetRefTypeOfImpType\n")) ;
	     }
	  else
	    {
	      if ( FAILED(ptInfo->GetImplTypeFlags(i, &iFlags)) )
		{
		  WriteOut(hFile, szReadFail) ;
		  WriteOut(hFile, XSTR("GetImplTypeFlags\n")) ;
		}
	      else
		{			     // output attribute(s)
		   if ( (iFlags & IMPLTYPEFLAG_FDEFAULT) == IMPLTYPEFLAG_FDEFAULT )
		     WriteAttr(hFile, attrDefault, NULL, noValue) ;

		   if ( (iFlags & IMPLTYPEFLAG_FRESTRICTED) == IMPLTYPEFLAG_FRESTRICTED )
		     WriteAttr(hFile, attrRestrict, NULL, noValue) ;

		   if ( (iFlags & IMPLTYPEFLAG_FSOURCE) == IMPLTYPEFLAG_FSOURCE )
		     WriteAttr(hFile, attrSource, NULL, noValue) ;
		   if ( (iFlags & IMPLTYPEFLAG_FDEFAULTVTABLE) == IMPLTYPEFLAG_FDEFAULTVTABLE)
		     WriteAttr(hFile, XSTR("defaultvtable"), NULL, noValue) ;


      		   if (ptinfo2) {
	 	     // new-format typelib -- output more stuff
	 	     CUSTDATA custdata;
	 	     ptinfo2->GetAllImplTypeCustData(i, &custdata);
	 	     tOutCustData(hFile, &custdata);
      		   }

		   if ( endAttrFlag )
		     {
			WriteOut(hFile, szEndAttr) ;
			endAttrFlag = FALSE ;
		     }
		}

	      tOutAliasName(hFile, phRefType) ;
	   }
	}

      if ( inAlign )                        // alignment depends on the base-
        if ( lpTypeAttr->cbAlignment != expAlign ) // interface [5]
           tOutAlignError (hFile) ;
      WriteOut(hFile,  XSTR("}\n\n")) ;
    }

VOID  NEAR tOutAlias	(FILE *hFile, int iTypeId)
   {
      XCHAR szTmp[16] ;

      WriteOut(hFile,  XSTR("\ntypedef ")) ;
      tOutAttr(hFile, (int)iTypeId) ;	    // output attribute first
      WriteAttr(hFile, attrPublic, szTmp, noValue) ; // public attr
      tOutMoreAttr(hFile) ;

      tOutType(hFile, lpTypeAttr->tdescAlias) ;  // output name of base-type

      tOutName(hFile, iTypeId) ;		 // output name of new type
      WriteOut(hFile,  XSTR(";")) ;
      if ( inAlign )                        // alignment of the alias with
        if ( lpTypeAttr->cbAlignment != expAlign )
            tOutAlignError (hFile) ;        // that of the basetype [5]

      WriteOut(hFile,  XSTR("\n\n")) ;
    }

VOID NEAR tOutUnion (FILE *hFile, int iTypeId)
   {
      WriteOut(hFile,  XSTR("\ntypedef\n")); // output typedef first
      tOutAttr(hFile, (int)iTypeId) ;	    // output attribute
      tOutMoreAttr(hFile) ;
      WriteOut(hFile,  XSTR("\nunion {\n")) ;
      tOutVar (hFile) ; 		    // output members

      WriteOut(hFile,  XSTR("} ")) ;
      tOutName(hFile, iTypeId) ;
      WriteOut(hFile,  XSTR(" ;")) ;
      if ( inAlign )                        // [5]
         if ( lpTypeAttr->cbAlignment != expAlign )
            tOutAlignError (hFile) ;

      WriteOut(hFile,  XSTR("\n\n")) ;
   }


VOID NEAR tOutEncunion (FILE *hFile, int iTypeId)
   {
      WriteOut(hFile,  XSTR("\ntypedef\n")); // output typedef first
      tOutAttr(hFile, (int)iTypeId) ;	    // output attribute
      tOutMoreAttr(hFile) ;
      WriteOut(hFile,  XSTR("\nencunion {\n")) ;
      tOutVar (hFile) ; 		    // output members

      WriteOut(hFile,  XSTR("} ")) ;
      tOutName(hFile, iTypeId) ;
      WriteOut(hFile,  XSTR(" ;\n\n")) ;
   }


VOID NEAR tOutName (FILE *hFile, int iTypeId)
   {
      BSTRX bstrName ;

      if ( FAILED(ptLib->GetDocumentation(iTypeId, &bstrName, NULL, NULL, NULL)) )
	{
	   WriteOut(hFile, szReadFail) ;
	   WriteOut(hFile, XSTR("name of type definition")) ;
	}
      else
	{
	   WriteOut(hFile,  bstrName) ;
	   WriteOut(hFile,  XSTR(" ")) ;

	   if ( iTypeId == -1 ) 	    // record name of the library
	     osStrCpy(szLibName, bstrName) ;

	   SysFreeString((BSTR)bstrName) ;
	}
   }

VOID NEAR tOutType (FILE *hFile, TYPEDESC tdesc)
   {
      XCHAR szTmp[20] ;

      if ( inAlign && tdesc.vt != VT_USERDEFINED && tdesc.vt != VT_CARRAY && !alignFound )  // [5]
         {
            if ( expAlign < osGetAlignment(tdesc.vt, inAlign) )
               expAlign = osGetAlignment(tdesc.vt, inAlign) ;
            alignFound = TRUE ;
         }

      switch (tdesc.vt)
	{
	  case VT_EMPTY:
	    osStrCpy ( szTmp,  XSTR("notSpec ") ) ;
	    break ;
	  case VT_NULL:
	    osStrCpy ( szTmp,  XSTR("NULL ") ) ;
	    break ;
	  case VT_I2:
	    osStrCpy ( szTmp,  XSTR("short ") ) ;
	    break ;
	  case VT_I4:
	    osStrCpy ( szTmp,  XSTR("long ") ) ;
	    break ;
	  case VT_R4:
	    osStrCpy ( szTmp,  XSTR("float ") ) ;
	    break ;
	  case VT_R8:
	    osStrCpy ( szTmp,  XSTR("double ") ) ;
	    break ;
	  case VT_CY:
	    osStrCpy ( szTmp,  XSTR("CURRENCY ") ) ;
	    break ;
	  case VT_DATE:
	    osStrCpy ( szTmp,  XSTR("DATE ") ) ;
	    break ;
	  case VT_BSTR:
	    osStrCpy ( szTmp,  XSTR("BSTR ") ) ;
	    break ;
	  case VT_DISPATCH:
	    osStrCpy ( szTmp,  XSTR("IDispatch * ") ) ;
	    break ;
	  case VT_ERROR:
	    osStrCpy ( szTmp,  XSTR("scode ") ) ;
	    break ;
	  case VT_BOOL:
	    osStrCpy ( szTmp,  XSTR("boolean ") ) ;
	    break ;
	  case VT_VARIANT:
	    osStrCpy ( szTmp,  XSTR("VARIANT ") ) ;
	    break ;
	  case VT_UNKNOWN:
	    osStrCpy ( szTmp,  XSTR("IUnknown * ") ) ;
	    break ;
	  case VT_DECIMAL:
	    osStrCpy ( szTmp,  XSTR("DECIMAL ") ) ;
	    break ;
	  case VT_I1:
	    osStrCpy ( szTmp,  XSTR("char ") ) ;
	    break ;
	  case VT_UI1:
	    osStrCpy ( szTmp,  XSTR("unsigned char ") ) ;
	    break ;
	  case VT_UI2:
	    osStrCpy ( szTmp,  XSTR("unsigned short ") ) ;
	    break ;
	  case VT_UI4:
	    osStrCpy ( szTmp,  XSTR("unsigned long ") ) ;
	    break ;
	  case VT_I8:
	    osStrCpy ( szTmp,  XSTR("long long ") ) ;
	    break ;
	  case VT_UI8:
	    osStrCpy ( szTmp,  XSTR("unsigned long long ") ) ;
	    break ;
	  case VT_INT:
	    osStrCpy ( szTmp,  XSTR("int ") ) ;
	    break ;
	  case VT_UINT:
	    osStrCpy ( szTmp,  XSTR("unsigned int ") ) ;
	    break ;
	  case VT_VOID:
	    osStrCpy ( szTmp,  XSTR("void ") ) ;
	    break ;
	  case VT_HRESULT:
	    osStrCpy ( szTmp,  XSTR("HRESULT ") ) ;
	    break ;
	  case VT_PTR:
	    tOutType (hFile, *(tdesc.lptdesc)) ;
	    osStrCpy ( szTmp,  XSTR("* ") ) ;
	    break ;
	  case VT_SAFEARRAY:
	    if ( endAttrFlag )
	      {
		WriteOut(hFile, szEndAttr) ;
		endAttrFlag = FALSE ;
	      }
	    WriteOut(hFile, XSTR("SAFEARRAY ( ")) ;
	    tOutType (hFile, *(tdesc.lptdesc)) ;
	    break ;
	  case VT_CARRAY:
	    cArrFlag = tdesc.lpadesc->cDims ;  // get dimemsion of array
	    tOutType (hFile, tdesc.lpadesc->tdescElem) ;
	    break ;
	  case VT_USERDEFINED:
	    if ( endAttrFlag )
	      {
		WriteOut(hFile, szEndAttr) ;
		endAttrFlag = FALSE ;
	      }
	    tOutAliasName (hFile, tdesc.hreftype) ;
	    break ;			    // output name of the user-defined type
	  case VT_LPSTR:
	    osStrCpy ( szTmp,  XSTR("LPSTR ") ) ;
	    break ;
          case VT_LPWSTR:                   // [3]
            osStrCpy ( szTmp,  XSTR("LPWSTR ") ) ;
	    break ;
	  default:
	    osStrCpy ( szTmp,  XSTR("unknown type ") ) ;
	}

      if ( endAttrFlag )
	{
	  WriteOut(hFile, szEndAttr) ;
	  endAttrFlag = FALSE ;
	}

      if ( tdesc.vt != VT_CARRAY && tdesc.vt != VT_USERDEFINED && tdesc.vt != VT_SAFEARRAY )
	WriteOut(hFile, szTmp) ;

      if ( tdesc.vt == VT_SAFEARRAY )
	WriteOut(hFile, XSTR(") ")) ;

   }

VOID  NEAR tOutCDim (FILE *hFile, TYPEDESC tdesc)
   {
      USHORT i ;
      ULONG  l ;
      XCHAR  szTmp[16] ;

      for ( i = 0 ; i < cArrFlag ; i++ )
	 {
	   l = tdesc.lpadesc->rgbounds[i].cElements ;
	   osLtoA(l, szTmp) ;
	   WriteOut(hFile, XSTR("[")) ;
	   WriteOut(hFile, szTmp) ;
	   WriteOut(hFile, XSTR("]")) ;
	 }

      cArrFlag = 0 ;
   }

VOID NEAR tOutAliasName (FILE *hFile, HREFTYPE phRefType)
   {
      ITypeInfoX FAR *lpInfo ;		    // pointer to the type definition
      ITypeLibX  FAR *lpLib ;		    // pointer to a type library
      TYPEATTR	 FAR *lptAttr ;
      BSTRX	 bstrName ;
      UINT	 iTypeId ;
      HRESULT	 hRes;

     hRes = ptInfo->GetRefTypeInfo(phRefType, &lpInfo);
      if ( FAILED(hRes) )
	{				    // get TypeInfo of the alias
	  WriteOut(hFile, szReadFail) ;
	  WriteOut(hFile, XSTR("GetRefTypeInfo\n")) ;
	}
      else
	{
          if ( FAILED(lpInfo->GetTypeAttr(&lptAttr)) )
            {
              WriteOut(hFile, szReadFail) ;
              WriteOut(hFile, XSTR("attribute of reftype\n\n")) ;
            }
          else
            {
              if ( inAlign && !alignFound && (lpTypeAttr->typekind != TKIND_DISPATCH) )
                 {                          // [5]
                   if ( expAlign < lptAttr->cbAlignment )
                      expAlign = lptAttr->cbAlignment ;
                   alignFound = TRUE ;
                 }

               switch ( lpTypeAttr->typekind )
                  {
                      case TKIND_INTERFACE:
                        if ( isInherit )    // output name of base-interface
                           WriteOut(hFile, XSTR(" : ")) ;
                        break ;
		      default:
			if (lpTypeAttr->typekind == TKIND_COCLASS ||
			    lptAttr->wTypeFlags & TYPEFLAG_FDUAL) {
                          // output type of the referenced interface if we
			  // are a coclass or if we are referencing a dual
			  // interface.
                          if ( lptAttr->typekind == TKIND_INTERFACE )
                            WriteOut(hFile, XSTR("interface ")) ;
                          else if ( lptAttr->typekind == TKIND_DISPATCH )
                             WriteOut(hFile, XSTR("dispinterface ")) ;
			}

                  }

               lpInfo->ReleaseTypeAttr(lptAttr) ;
            }

	  if ( FAILED(lpInfo->GetContainingTypeLib(&lpLib, &iTypeId)) )
	    {				    // get id of the alias
	      WriteOut(hFile, szReadFail) ;
	      WriteOut(hFile, XSTR("GetAlias: containing typelib\n\n")) ;
	    }
	  else
	    {				    // check origin of the alias
	      if ( FAILED(lpLib->GetDocumentation(MEMBERID_NIL, &bstrName, NULL, NULL, NULL)) )
		{
		  WriteOut(hFile, szReadFail) ;
		  WriteOut(hFile, XSTR("name of import library")) ;
		}
	      else
		{			    // if it is not defined locally
		  if ( osStrCmp(szLibName, bstrName) != 0 )
		    {			    // i.e. name of origin is diff
		       WriteOut(hFile,  bstrName) ;
		       WriteOut(hFile, XSTR(".")) ;
		    }			    // from the name of library;
					    // output its origin
		  SysFreeString((BSTR)bstrName) ;
		}

	      if ( FAILED(lpLib->GetDocumentation((int)iTypeId, &bstrName, NULL, NULL, NULL)) )
		{			    // retrieve name of the alias
		  WriteOut(hFile, szReadFail) ;
		  WriteOut(hFile, XSTR("name of alias")) ;
		}
	      else
		{
		  WriteOut(hFile, bstrName) ;

		  if ( lpTypeAttr->typekind == TKIND_COCLASS ||
		       (lpTypeAttr->typekind == TKIND_DISPATCH && isInherit) )
		     WriteOut(hFile, XSTR(" ;\n")) ;
		  else
		     WriteOut(hFile, XSTR(" ")) ;

		  SysFreeString((BSTR)bstrName) ;
		}

	      lpLib->Release () ;
	    }

	  lpInfo->Release () ;
	}
   }

VOID  NEAR tOutValue(FILE *hFile, BSTRX bstrName, VARDESCX FAR *lpVarDesc)
  {
       VARTYPE	vvt ;
       VARIANTX varTmp ;		    // [12]
       XCHAR	szTmp[25] ;

       if ( endAttrFlag )
	 {
	    WriteOut(hFile, szEndAttr) ;
	    endAttrFlag = FALSE ;
	 }

       if ( lpTypeAttr->typekind == TKIND_MODULE )
	{
	  WriteOut(hFile, XSTR("const ")) ; // output the const keyword
	  tOutType(hFile, lpVarDesc->elemdescVar.tdesc) ; // output its type
	}

       WriteOut(hFile, bstrName) ;	    // output name of member
       WriteOut(hFile, XSTR(" = ")) ;

       vvt = lpVarDesc->lpvarValue->vt ;

       if ( vvt == VT_VARIANT )
	 {
	   vvt = lpVarDesc->lpvarValue->pvarVal->vt ;
	   switch ( vvt )
	     {
	       case VT_I1:
		 osItoA((int)lpVarDesc->lpvarValue->pvarVal->cVal, szTmp) ;
		 break ;
	       case VT_UI1:
		 osItoA((int)lpVarDesc->lpvarValue->pvarVal->bVal, szTmp) ;
		 break ;
	       case VT_UI2:
		 osItoA((int)lpVarDesc->lpvarValue->pvarVal->uiVal, szTmp) ;
		 break ;
	       case VT_BOOL:
		 osItoA((int)lpVarDesc->lpvarValue->pvarVal->boolVal, szTmp) ;
		 break ;
	       case VT_I2:
		 if ( ( lpVarDesc->elemdescVar.tdesc.vt == VT_UI2 || lpVarDesc->elemdescVar.tdesc.vt == VT_UINT ) && lpVarDesc->lpvarValue->iVal < 0 )
		   osLtoA((long)65536+(lpVarDesc->lpvarValue->pvarVal->iVal), szTmp) ;
		 else
		   osItoA((int)lpVarDesc->lpvarValue->pvarVal->iVal, szTmp) ;
		 break ;
	       case VT_R4:		    // [12]
	       case VT_R8:
	       case VT_CY:
               case VT_UI4:
               case VT_UINT:
               case VT_DECIMAL:
		 varTmp.vt = VT_EMPTY ;
		 if ( FAILED(VariantChangeType(&varTmp, lpVarDesc->lpvarValue->pvarVal, VARIANT_NOVALUEPROP,  VT_BSTR)) )
		    WriteOut(hFile, XSTR("VariantChangeType fails\n")) ;
		 else
		    {
		      osStrCpy(szTmp, varTmp.bstrVal) ;
		      SysFreeStringX(varTmp.bstrVal) ;
		    }
		 break ;
	       case VT_DATE:		    // [12]
		 varTmp.vt = VT_EMPTY ;
		 if ( FAILED(VariantChangeType(&varTmp, lpVarDesc->lpvarValue, VARIANT_NOVALUEPROP,  VT_BSTR)) )
		    WriteOut(hFile, XSTR("VariantChangeType fails\n")) ;
		 else
		    {
		      WriteOut(hFile, XSTR("\"")) ;
		      WriteOut(hFile, (LPXSTR)varTmp.bstrVal) ;
		      WriteOut(hFile, XSTR("\"")) ;
		      SysFreeStringX(varTmp.bstrVal) ;
		    }
		 break ;
	       case VT_BSTR:
		 if ( lpVarDesc->lpvarValue->pvarVal->bstrVal != NULL )  // [9]
		   {
		     WriteOut(hFile, XSTR("\"")) ;
		     WriteOut(hFile, (LPXSTR)lpVarDesc->lpvarValue->pvarVal->bstrVal) ;
		     WriteOut(hFile, XSTR("\"")) ;
		   }
		 else							 // [9]
		     WriteOut(hFile, XSTR("0")) ;
		 break ;
	       default:
		 osLtoA((long)lpVarDesc->lpvarValue->pvarVal->lVal, szTmp) ;
		 break ;
	      }
	}
      else
	{
	   switch ( vvt )
	     {
               case VT_I1:
		 osItoA((int)lpVarDesc->lpvarValue->cVal, szTmp) ;
		 break ;
               case VT_UI1:
		 osItoA((int)lpVarDesc->lpvarValue->bVal, szTmp) ;
		 break ;
               case VT_BOOL:
		 osItoA((int)lpVarDesc->lpvarValue->boolVal, szTmp) ;
		 break ;
               case VT_UI2:
		 osItoA((int)lpVarDesc->lpvarValue->uiVal, szTmp) ;
		 break ;
	       case VT_I2:
		 if ( ( lpVarDesc->elemdescVar.tdesc.vt == VT_UI2 || lpVarDesc->elemdescVar.tdesc.vt == VT_UINT ) && lpVarDesc->lpvarValue->iVal < 0 )
		   osLtoA((long)65536+(lpVarDesc->lpvarValue->iVal), szTmp) ;
		 else
		   osItoA((int)lpVarDesc->lpvarValue->iVal, szTmp) ;
		 break ;
	       case VT_R4:		    // [12]
	       case VT_R8:
	       case VT_CY:
               case VT_UI4:
               case VT_UINT:
               case VT_DECIMAL:
		 varTmp.vt = VT_EMPTY ;
		 if ( FAILED(VariantChangeType(&varTmp, lpVarDesc->lpvarValue, VARIANT_NOVALUEPROP,  VT_BSTR)) )
		    WriteOut(hFile, XSTR("VariantChangeType fails\n")) ;
		 else
		    {
		      osStrCpy(szTmp, varTmp.bstrVal) ;
		      SysFreeStringX(varTmp.bstrVal) ;
		    }
		 break ;
	       case VT_DATE:		    // [12]
		 varTmp.vt = VT_EMPTY ;
		 if ( FAILED(VariantChangeType(&varTmp, lpVarDesc->lpvarValue, VARIANT_NOVALUEPROP,  VT_BSTR)) )
		    WriteOut(hFile, XSTR("VariantChangeType fails\n")) ;
		 else
		    {
		      WriteOut(hFile, XSTR("\"")) ;
		      WriteOut(hFile, (LPXSTR)varTmp.bstrVal) ;
		      WriteOut(hFile, XSTR("\"")) ;
		      SysFreeStringX(varTmp.bstrVal) ;
		    }
		 break ;
	       case VT_BSTR:
		 if ( lpVarDesc->lpvarValue->bstrVal != NULL )	// [9]
		   {
		     WriteOut(hFile, XSTR("\"")) ;
		     WriteOut(hFile, (LPXSTR)lpVarDesc->lpvarValue->bstrVal) ;
		     WriteOut(hFile, XSTR("\"")) ;
		   }
		 else						// [9]
		     WriteOut(hFile, XSTR("0")) ;
		 break ;
	       default:
		 osLtoA((long)lpVarDesc->lpvarValue->lVal, szTmp) ;
		 break ;
	      }
	}

	 if ( vvt != VT_BSTR && vvt != VT_DATE )
	   WriteOut(hFile, szTmp) ; // output value of member

       if ( lpTypeAttr->typekind == TKIND_MODULE )
	 WriteOut(hFile, XSTR(" ;\n")) ;
       else
	 WriteOut(hFile, XSTR(" ,\n")) ;
}


VOID  NEAR tOutMember(FILE *hFile, LONG idMember, BSTRX bstrName, TYPEDESC tdesc)
  {
       XCHAR szTmp[16] ;

       if ( lpTypeAttr->typekind == TKIND_DISPATCH )
	 {
           osLtoA(idMember, szTmp) ;        // output id
	   WriteAttr(hFile, attrId, szTmp, numValue) ;
         }
       else				    // [5]
         if ( inAlign )
            alignFound = FALSE ;
					   // output name of base-type
       tOutType(hFile, tdesc) ;
       WriteOut(hFile, bstrName) ;         // output name of member
       if ( cArrFlag != 0 )		   // it is a c-array; output
	 tOutCDim (hFile, tdesc) ;
					   // dimensions of the array
       WriteOut(hFile, XSTR(" ;\n")) ;
  }

VOID  NEAR tOutVar(FILE *hFile)
   {
      VARDESCX FAR *ptVarDesc ; 	    // [2]
      BSTRX    bstrName ;		    // name of member
      BSTRX    bstrDoc ;		    // file string
      DWORD    hContext ;		    // help context
      XCHAR    szTmp[16] ;
      WORD     i ;
      LONG     idMember ;
      BSTRX    rgNames[MAX_NAMES];
      UINT     cNames, j ;

	for (i = 0 ; i < lpTypeAttr->cVars; i++) // for every member
	{
	   if ( FAILED(ptInfo->GetVarDesc(i, &ptVarDesc)) )
	     {
		WriteOut(hFile, szReadFail) ;
		WriteOut(hFile, XSTR("variables\n")) ;
	     }
	   else
	     {
		idMember = ptVarDesc->memid ;
					    // this is readonly var
		if ( (ptVarDesc->wVarFlags & VARFLAG_FREADONLY) == VARFLAG_FREADONLY )	   // CK [ 1]
		   WriteAttr(hFile, attrReadonly, NULL, noValue) ;

					    // output source attribute									 // CK [ 2]
		if (( ptVarDesc->wVarFlags & VARFLAG_FSOURCE ) == VARFLAG_FSOURCE)	   // CK [ 1]
		   WriteAttr(hFile, attrSource, NULL, noValue) ;			   // CK [ 1]

					    // output bindable attribute								 // CK [ 2]
		if (( ptVarDesc->wVarFlags & VARFLAG_FBINDABLE)== VARFLAG_FBINDABLE )	   // CK [ 1]
		   WriteAttr(hFile, attrBindable, NULL, noValue) ;			   // CK [ 1]

					    // output requestedit attribute								 // CK [ 2]
		if (( ptVarDesc->wVarFlags & VARFLAG_FREQUESTEDIT)== VARFLAG_FREQUESTEDIT )// CK [ 1]
		   WriteAttr(hFile, attrRequestedit, NULL, noValue) ;			   // CK [ 1]

					    // output displaybind attribute								 // CK [ 2]
		if (( ptVarDesc->wVarFlags & VARFLAG_FDISPLAYBIND)== VARFLAG_FDISPLAYBIND )// CK [ 1]
		   WriteAttr(hFile, attrDisplaybind, NULL, noValue) ;			   // CK [ 1]

					    // output defaultbind attribute								 // CK [ 2]
		if (( ptVarDesc->wVarFlags & VARFLAG_FDEFAULTBIND)== VARFLAG_FDEFAULTBIND )// CK [ 1]
		   WriteAttr(hFile, attrDefaultbind, NULL, noValue) ;			   // CK [ 1]
		if (( ptVarDesc->wVarFlags & VARFLAG_FIMMEDIATEBIND)== VARFLAG_FIMMEDIATEBIND )// CK [ 1]
		   WriteAttr(hFile, XSTR("immediatebind"), NULL, noValue) ;			   // CK [ 1]
					    // output hidden attribute
                if (( ptVarDesc->wVarFlags & VARFLAG_FHIDDEN)== VARFLAG_FHIDDEN )          // [7]
                   WriteAttr(hFile, attrHidden, NULL, noValue) ;                      // CK [ 1]
                if (( ptVarDesc->wVarFlags & VARFLAG_FDEFAULTCOLLELEM)== VARFLAG_FDEFAULTCOLLELEM)
                   WriteAttr(hFile, XSTR("defaultcollelem"), NULL, noValue) ;
                if (( ptVarDesc->wVarFlags & VARFLAG_FUIDEFAULT)== VARFLAG_FUIDEFAULT)
                   WriteAttr(hFile, XSTR("uidefault"), NULL, noValue) ;
                if (( ptVarDesc->wVarFlags & VARFLAG_FNONBROWSABLE)== VARFLAG_FNONBROWSABLE)
                   WriteAttr(hFile, XSTR("nonbrowsable"), NULL, noValue) ;
                if (( ptVarDesc->wVarFlags & VARFLAG_FREPLACEABLE)== VARFLAG_FREPLACEABLE)
                   WriteAttr(hFile, XSTR("replaceable"), NULL, noValue) ;

      		// also dump out the varkind
      		osItoA(ptVarDesc->varkind, szTmp) ;
      		WriteAttr(hFile, XSTR("varkind"), szTmp, numValue) ;

      		// also dump out the oInst
		if (ptVarDesc->varkind != VAR_CONST) {
      		  osItoA(ptVarDesc->oInst, szTmp) ;
      		  WriteAttr(hFile, XSTR("oInst"), szTmp, numValue) ;
		}


      		if (ptinfo2) {
	 	  // new-format typelib -- output more stuff
	 	  CUSTDATA custdata;
	 	  ptinfo2->GetAllVarCustData(i, &custdata);
	 	  tOutCustData(hFile, &custdata);


      		  BSTRX    bstrHelpDll;
		    if ( FAILED(ptinfo2->GetDocumentation2(idMember, 0x409, &bstrDoc, &hContext, &bstrHelpDll)) )
		    {
	    	      WriteOut(hFile, szReadFail);
	    	      WriteOut(hFile, XSTR("GetDocumentation2 failed\n\n")) ;
	  	    } else {
		      if (hContext != 0) {
	    	        osLtoA((long)hContext, szTmp) ;
	    	        WriteAttr(hFile, XSTR("helpstringcontext"), szTmp, numValue) ;
		      }

	    	      if ( bstrDoc != NULL )	    // output helpstring if exists
	      	        WriteAttr(hFile, XSTR("localizedhelpstring"), bstrDoc, strValue) ;

		      // output help dll name if exists && different from main
	    	      if (bstrHelpDll && (g_bstrHelpDll == NULL || osStrCmp(bstrHelpDll, g_bstrHelpDll)))
	      	        WriteAttr(hFile, XSTR("helpstringdll"), bstrHelpDll, strValue) ;
	    	      SysFreeString((BSTR)bstrDoc) ;    // release local bstr's
	    	      SysFreeString((BSTR)bstrHelpDll) ;
	  	    }
      		}

		if ( FAILED(ptInfo->GetDocumentation(idMember, &bstrName, &bstrDoc, &hContext, NULL)) )
		  {
		     WriteOut(hFile, szReadFail) ;
		     WriteOut(hFile, XSTR("attributes of variable\n")) ;
		  }
		else
		  {				  // output helpcontext; default is 0
		     osLtoA((long)hContext, szTmp) ;
		     WriteAttr(hFile, attrHelpCont, szTmp, numValue) ;

		     if ( bstrDoc != NULL )	  // output helpstring if exists
		       WriteAttr(hFile, attrHelpStr, bstrDoc, strValue) ;

		     // typedef enum or const in module
		     if ( lpTypeAttr->typekind == TKIND_ENUM || lpTypeAttr->typekind == TKIND_MODULE )
		       tOutValue (hFile, bstrName, ptVarDesc) ;
		     else			  // typedef struct or dispinterface
		       tOutMember (hFile, idMember, bstrName, ptVarDesc->elemdescVar.tdesc) ;

		     SysFreeString((BSTR)bstrDoc) ;	   // release local bstr
						   // also checking the name
		     if ( FAILED(ptInfo->GetNames(idMember, rgNames, MAX_NAMES, &cNames)) )
		       {			   // with GetNames
			 WriteOut(hFile, szReadFail) ;
			 WriteOut(hFile, XSTR("name of variable\n")) ;
		       }
		     else
		       {
			 if ( cNames != 1 )
			   {
			     WriteOut(hFile, szReadFail) ;
			     WriteOut(hFile, XSTR("GetNames return more than one name\n")) ;
			   }
			 else
			   {
			     if ( osStrCmp(rgNames[0], bstrName) != 0 )
			       {
				 WriteOut(hFile, szReadFail) ;
				 WriteOut(hFile, XSTR("name of variable inconsistent\n")) ;
			       }
			   }

			 for ( j = 0 ; j < cNames ; j++ )
			   SysFreeString((BSTR)rgNames[j]) ;
		       }

		     SysFreeString((BSTR)bstrName) ;
		  }

	     }
	   ptInfo->ReleaseVarDesc(ptVarDesc) ;
	   ptVarDesc = NULL ;
	}				   // for i
   }


VOID  NEAR tOutFuncAttr(FILE *hFile, FUNCDESC FAR *lpFuncDesc, DWORD hContext, BSTRX bstrDoc)
  {
      XCHAR szTmp[16] ;

      osLtoA((long)hContext, szTmp) ;// output helpcontext; default is 0
      WriteAttr(hFile, attrHelpCont, szTmp, numValue) ;

      if ( bstrDoc != NULL )		   // output helpstring if exists
	WriteAttr(hFile, attrHelpStr, bstrDoc, strValue) ;
					   // output restricted attribute
      if (( lpFuncDesc->wFuncFlags & FUNCFLAG_FRESTRICTED)== FUNCFLAG_FRESTRICTED )
	WriteAttr(hFile, attrRestrict, NULL, noValue) ;
					   // output usesgetlasterror attribute [11]
      if (( lpFuncDesc->wFuncFlags & FUNCFLAG_FUSESGETLASTERROR)== FUNCFLAG_FUSESGETLASTERROR )
	WriteAttr(hFile, attrGetLastErr, NULL, noValue) ;
                                           // output soruce attribute
      if (( lpFuncDesc->wFuncFlags & FUNCFLAG_FSOURCE ) == FUNCFLAG_FSOURCE ) // [6]
         WriteAttr(hFile, attrSource, NULL, noValue) ;
					   // output bindable attribute
      if (( lpFuncDesc->wFuncFlags & FUNCFLAG_FBINDABLE)== FUNCFLAG_FBINDABLE )
	WriteAttr(hFile, attrBindable, NULL, noValue) ;
					   // output requestedit attribute
      if (( lpFuncDesc->wFuncFlags & FUNCFLAG_FREQUESTEDIT)== FUNCFLAG_FREQUESTEDIT )
	WriteAttr(hFile, attrRequestedit, NULL, noValue) ;
					   // output displaybind attribute
      if (( lpFuncDesc->wFuncFlags & FUNCFLAG_FDISPLAYBIND)== FUNCFLAG_FDISPLAYBIND )
	WriteAttr(hFile, attrDisplaybind, NULL, noValue) ;
					   // output defaultbind attribute
      if (( lpFuncDesc->wFuncFlags & FUNCFLAG_FDEFAULTBIND)== FUNCFLAG_FDEFAULTBIND )
	WriteAttr(hFile, attrDefaultbind, NULL, noValue) ;
      if (( lpFuncDesc->wFuncFlags & FUNCFLAG_FIMMEDIATEBIND)== FUNCFLAG_FIMMEDIATEBIND )
	WriteAttr(hFile, XSTR("immediatebind"), NULL, noValue) ;
                                           // output hidden attribute
      if (( lpFuncDesc->wFuncFlags & FUNCFLAG_FHIDDEN)== FUNCFLAG_FHIDDEN ) // [7]
        WriteAttr(hFile, attrHidden, NULL, noValue) ;

      if (( lpFuncDesc->wFuncFlags & FUNCFLAG_FDEFAULTCOLLELEM)== FUNCFLAG_FDEFAULTCOLLELEM )
        WriteAttr(hFile, XSTR("defaultcollelem"), NULL, noValue) ;
      if (( lpFuncDesc->wFuncFlags & FUNCFLAG_FUIDEFAULT)== FUNCFLAG_FUIDEFAULT )
        WriteAttr(hFile, XSTR("uidefault"), NULL, noValue) ;
      if (( lpFuncDesc->wFuncFlags & FUNCFLAG_FNONBROWSABLE)== FUNCFLAG_FNONBROWSABLE )
        WriteAttr(hFile, XSTR("nonbrowsable"), NULL, noValue) ;
      if (( lpFuncDesc->wFuncFlags & FUNCFLAG_FREPLACEABLE)== FUNCFLAG_FREPLACEABLE )
        WriteAttr(hFile, XSTR("replaceable"), NULL, noValue) ;
      
      // also dump the funckind
      osItoA(lpFuncDesc->funckind, szTmp) ;
      WriteAttr(hFile, XSTR("funckind"), szTmp, numValue) ;

      // also dump out the oVft.  Only do this if not FUNC_DISPATCH
      // if (lpFuncDesc->funckind != FUNC_DISPATCH)
      {
        osItoA((int)lpFuncDesc->oVft, szTmp) ;
        WriteAttr(hFile, XSTR("oVft"), szTmp, numValue) ;
      }

					   // last parm is optional array
      if ( lpFuncDesc->cParamsOpt == -1 )  // of Variants
	WriteAttr(hFile, attrVar, NULL, noValue) ;

      if ( lpFuncDesc->memid == DISPID_VALUE ) // DISPID designates the
	 {				       // default function
	    osLtoA((long)DISPID_VALUE, szTmp) ;
	    WriteAttr(hFile, attrId, szTmp, numValue) ;
	 }
      else
	if ( lpTypeAttr->typekind == TKIND_DISPATCH )
	 {
	    osLtoA(lpFuncDesc->memid, szTmp) ;	 // output id
	    WriteAttr(hFile, attrId, szTmp, numValue) ;
	 }

      switch ( lpFuncDesc->invkind )	   // Note: if one of these
	{				   // flag is set, name of
	  case INVOKE_FUNC:		   // parm can't be set: i.e.
//	     WriteAttr(hFile, XSTR("invoke_func", NULL, noValue)) ;
	     break ;			   // GetNames only returns name
	  case INVOKE_PROPERTYGET:	   // of the function
	     WriteAttr(hFile, attrPropget, NULL, noValue) ;
	     break ;
	  case INVOKE_PROPERTYPUT:
	     WriteAttr(hFile, attrPropput, NULL, noValue) ;
	     break ;
	  case INVOKE_PROPERTYPUTREF:
	     WriteAttr(hFile, attrProppr, NULL, noValue) ;
	     break ;
	  default:
	     WriteAttr(hFile, XSTR("unknown invkind"), NULL, noValue) ;
	}
   }

VOID  NEAR tOutCallConv(FILE *hFile, FUNCDESC FAR *lpFuncDesc, TYPEKIND tkind)
   {
      switch ( lpFuncDesc->callconv )
	{
	  case CC_MSCPASCAL:
#if WIN16
	     if (tkind == TKIND_MODULE)
	       WriteOut(hFile, XSTR("STDAPICALLTYPE ")) ;
	     else
#endif //WIN16
	       WriteOut(hFile, XSTR("__pascal ")) ;
	     break ;
	  case CC_MACPASCAL:
	     WriteOut(hFile, XSTR("__pascal ")) ;
	     break ;
	  case CC_STDCALL:
#if WIN32
	     if (tkind == TKIND_MODULE)
	       WriteOut(hFile, XSTR("STDAPICALLTYPE ")) ;
	     else
	       WriteOut(hFile, XSTR("STDMETHODCALLTYPE ")) ;
#else //WIN32
	     WriteOut(hFile, XSTR("__stdcall ")) ;
#endif //WIN32
	     break ;
	  case CC_SYSCALL:
	     WriteOut(hFile, XSTR("__syscall ")) ;
	     break ;
	  case CC_CDECL:
#if WIN16
	     if (tkind != TKIND_MODULE)
	       WriteOut(hFile, XSTR("STDMETHODCALLTYPE ")) ;
	     else
#endif //WIN16
	     WriteOut(hFile, XSTR("__cdecl ")) ;
	     break ;

	  case CC_FASTCALL:
	     WriteOut(hFile, XSTR("__fastcall ")) ;
	     break ;
	  case CC_FPFASTCALL:
	     WriteOut(hFile, XSTR("__fpfastcall ")) ;
	     break ;

	  default:
	     WriteOut(hFile, XSTR("unknown calling convention ")) ;
	     break ;
	}
    }

VOID  NEAR tOutParams(FILE *hFile, FUNCDESC FAR *lpFuncDesc, UINT iFunc, BSTRX bstrName)
   {
      BSTRX    rgNames[MAX_NAMES];
      UINT     cNames ;
      SHORT    i ;
      SHORT    iArgOptLast;

      WriteOut(hFile, XSTR("(")) ;

      if ( lpFuncDesc->cParams == 0 )
	WriteOut(hFile, XSTR("void")) ;
      else
	{
	  if ( FAILED(ptInfo->GetNames(lpFuncDesc->memid, rgNames, MAX_NAMES, &cNames)) )
	    {
	      WriteOut(hFile, szReadFail) ;
	      WriteOut(hFile, XSTR("parm of func in definition\n")) ;
	    }
	  else
	    {
	      if (bstrName && osStrCmp(rgNames[0], bstrName) != 0 )
		{
		  WriteOut(hFile, szReadFail) ;
		  WriteOut(hFile, XSTR("name of function inconsistent\n")) ;
		}
	      SysFreeString((BSTR)rgNames[0]) ;  // release name of function

	      // figure out the last parameter to be given the [optional]
	      // attribute
	      iArgOptLast = lpFuncDesc->cParams;
	      if ( ( lpFuncDesc->invkind == INVOKE_PROPERTYPUT
		   || lpFuncDesc->invkind == INVOKE_PROPERTYPUTREF)) {
		iArgOptLast--;
	      }
	      for (i = 1; i <= lpFuncDesc->cParams; i++)
		{
                   if ( ( lpFuncDesc->lprgelemdescParam[i-1].idldesc.wIDLFlags & IDLFLAG_FRETVAL ) == IDLFLAG_FRETVAL ) // [7]
		       iArgOptLast--;
                   if ( ( lpFuncDesc->lprgelemdescParam[i-1].idldesc.wIDLFlags & IDLFLAG_FLCID ) == IDLFLAG_FLCID ) // [7]
		       iArgOptLast--;
		}

	      for (i = 1; i <= lpFuncDesc->cParams; i++)
		{
		  if ( i != 1 )
		    WriteOut(hFile, XSTR(", ")) ;
					   // output in/out attribute
		  if ( lpFuncDesc->lprgelemdescParam[i-1].idldesc.wIDLFlags != 0 )
		    {
		      if ( ( lpFuncDesc->lprgelemdescParam[i-1].idldesc.wIDLFlags & IDLFLAG_FIN ) == IDLFLAG_FIN )
			WriteAttr(hFile, attrIn, NULL, noValue) ;

		      if ( ( lpFuncDesc->lprgelemdescParam[i-1].idldesc.wIDLFlags & IDLFLAG_FOUT ) == IDLFLAG_FOUT )
                        WriteAttr(hFile, attrOut, NULL, noValue) ;

                      if ( ( lpFuncDesc->lprgelemdescParam[i-1].idldesc.wIDLFlags & IDLFLAG_FRETVAL ) == IDLFLAG_FRETVAL ) // [7]
                        WriteAttr(hFile, attrRetval, NULL, noValue) ;

                      if ( ( lpFuncDesc->lprgelemdescParam[i-1].idldesc.wIDLFlags & IDLFLAG_FLCID ) == IDLFLAG_FLCID ) // [7]
                        WriteAttr(hFile, attrLcid, NULL, noValue) ;

                      if ( ( lpFuncDesc->lprgelemdescParam[i-1].idldesc.wIDLFlags & PARAMFLAG_FHASDEFAULT ) == PARAMFLAG_FHASDEFAULT ) {
			VARIANT varTmp;
			VARIANT *pVarDefault;
			pVarDefault = &(lpFuncDesc->lprgelemdescParam[i-1].paramdesc.pparamdescex->varDefaultValue);
		 	varTmp.vt = VT_EMPTY ;
			
		        if ( FAILED(VariantChangeType(&varTmp, pVarDefault, VARIANT_NOVALUEPROP,  VT_BSTR)) )
		    	   WriteOut(hFile, XSTR("VariantChangeType fails\n")) ;
		        else {
                           WriteAttr(hFile, XSTR("defaultvalue"), (BSTRX)varTmp.bstrVal, strValue) ;
		           SysFreeStringX(varTmp.bstrVal) ;
		        }
		      }
                      if ( ( lpFuncDesc->lprgelemdescParam[i-1].idldesc.wIDLFlags & PARAMFLAG_FOPT ) == PARAMFLAG_FOPT ) // [7]
                        WriteAttr(hFile, XSTR("PARAMFLAG_FOPT"), NULL, noValue) ;
                      if ( ( lpFuncDesc->lprgelemdescParam[i-1].idldesc.wIDLFlags & PARAMFLAG_FHASCUSTDATA ) == PARAMFLAG_FHASCUSTDATA ) // [7]
                        WriteAttr(hFile, XSTR("PARAMFLAG_FHASCUSTDATA"), NULL, noValue) ;

      		      if (ptinfo2) {
	 		  // new-format typelib -- output more stuff
	 		  CUSTDATA custdata;
	 		  ptinfo2->GetAllParamCustData(iFunc, i-1, &custdata);
	 		  tOutCustData(hFile, &custdata);
      		      }
		    }
					   // check for optional parm
		  if ( lpFuncDesc->cParamsOpt > 0) {
		    if ( ( lpFuncDesc->cParamsOpt + i ) > iArgOptLast
			   && i <= iArgOptLast )
		      WriteAttr(hFile, attrOption, NULL, noValue) ;
					   // and output optional attr
		  }
					   // output name of base-type
		  tOutType(hFile, lpFuncDesc->lprgelemdescParam[i-1].tdesc) ;
		  if ( i < (SHORT) cNames )// output name of parm if its is
		    {			   // not property-accessor function
		      if (rgNames[i] == NULL)
		        WriteOut(hFile, XSTR("_NONAME_")) ;
		      else
		        WriteOut(hFile, rgNames[i]) ;
		      SysFreeString((BSTR)rgNames[i]) ;  // release name of parm's
		    }
		  else
		    WriteOut(hFile, XSTR("PseudoName")) ;

		  if ( cArrFlag != 0 )	   // it is a c-array; output
		    tOutCDim (hFile, lpFuncDesc->lprgelemdescParam[i-1].tdesc) ;
					   // dimension of the array
		}			   // for i = 1
	    }				   // GetNames

	}				   // if (ptFunDesc->cParams)

      WriteOut(hFile, XSTR(") ;\n")) ;
   }


VOID  NEAR tOutFunc(FILE *hFile)
   {
      FUNCDESC FAR *ptFuncDesc ;
      BSTRX    bstrName ;		    // name of member
      BSTRX    bstrDoc ;		    // file string
      DWORD    hContext ;		    // help context
      BSTRX    bstrDllName;
      BSTRX    bstrEntryName;
      WORD     wOrdinal;
      XCHAR    szTmp[16] ;
      WORD     i ;
      LONG     idMember ;

      alignFound = TRUE ;                   // turn off align checking [5]

      for (i = 0 ; i < lpTypeAttr->cFuncs; i++) // for every member function
	{
	   if ( FAILED(ptInfo->GetFuncDesc(i, &ptFuncDesc)) )
	     {
		WriteOut(hFile, szReadFail) ;
		WriteOut(hFile, XSTR("function of definition\n")) ;
	     }
	   else
	     {
		idMember = ptFuncDesc->memid ;
		if ( FAILED(ptInfo->GetDocumentation(ptFuncDesc->memid, &bstrName, &bstrDoc, &hContext, NULL)) )
		  {
		     WriteOut(hFile, szReadFail) ;
		     WriteOut(hFile, XSTR("attributes of function\n")) ;
		  }
		else
		  {
		     if ( lpTypeAttr->typekind == TKIND_MODULE )
			if( !FAILED(ptInfo->GetDllEntry(ptFuncDesc->memid, ptFuncDesc->invkind, &bstrDllName, &bstrEntryName, &wOrdinal)) )
			 {		   // check for Dll entry
			    WriteAttr(hFile, attrDllName, bstrDllName, strValue) ;
			    SysFreeString((BSTR)bstrDllName) ;

			    if ( bstrEntryName != NULL )
			      {
				WriteAttr(hFile, attrEntry, bstrEntryName, strValue) ;
				SysFreeString((BSTR)bstrEntryName) ;
			      }
			    else
			      {
				osItoA((int)wOrdinal, szTmp) ;
				WriteAttr(hFile, attrEntry, szTmp, numValue) ;
			      }
			  }

      		      if (ptinfo2) {
	 		  // new-format typelib -- output more stuff
	 		  CUSTDATA custdata;
	 		  ptinfo2->GetAllFuncCustData(i, &custdata);
	 		  tOutCustData(hFile, &custdata);

	 	     // new-format typelib -- output more stuff
      		    BSTRX    bstrHelpDll;
		    BSTRX    bstrLocalDoc;
		    DWORD    hStringContext;
		    if ( FAILED(ptinfo2->GetDocumentation2(idMember, 0x409, &bstrLocalDoc, &hStringContext, &bstrHelpDll)) )
		    {
	    	      WriteOut(hFile, szReadFail);
	    	      WriteOut(hFile, XSTR("GetDocumentation2 failed\n\n")) ;
	  	    } else {
		      if (hStringContext != 0) {
	    	        osLtoA((long)hStringContext, szTmp) ;
	    	        WriteAttr(hFile, XSTR("helpstringcontext"), szTmp, numValue) ;
		      }

	    	      if ( bstrLocalDoc != NULL )	    // output helpstring if exists
	      	        WriteAttr(hFile, XSTR("localizedhelpstring"), bstrLocalDoc, strValue) ;

		      // output help dll name if exists && different from main
	    	      if (bstrHelpDll && (g_bstrHelpDll == NULL || osStrCmp(bstrHelpDll, g_bstrHelpDll)))
	      	        WriteAttr(hFile, XSTR("helpstringdll"), bstrHelpDll, strValue) ;

	    	      SysFreeString((BSTR)bstrLocalDoc);
	    	      SysFreeString((BSTR)bstrHelpDll) ;
	  	    }

      		      }

						   // output attr for function
		     tOutFuncAttr(hFile, ptFuncDesc, hContext, bstrDoc) ;
						  // output return type
		     tOutType(hFile, ptFuncDesc->elemdescFunc.tdesc) ;
						  // output calling convention
		     tOutCallConv(hFile, ptFuncDesc, lpTypeAttr->typekind) ;
	      	     if (bstrName == NULL)
		         WriteOut(hFile, XSTR("_NONAME_")) ;
	      	     else
		         WriteOut(hFile, bstrName) ; // output name of member function
		     tOutParams(hFile, ptFuncDesc, i, bstrName) ;
							// output parameters
		     SysFreeString((BSTR)bstrDoc) ;	// release local bstr's
		     SysFreeString((BSTR)bstrName) ;
		  }
	        ptInfo->ReleaseFuncDesc(ptFuncDesc) ;

	     }
	   ptFuncDesc = NULL ;
        }                                   // for i

      alignFound = FALSE ;                  // turn align checking back on [5]
    }

VOID  NEAR tOutUUID (FILE *hFile, GUID inGuid)
   {
      XCHAR  szTmp[50] ;
					    // get a string representation
					    // for the incoming Guid value
      if ( !(osRetrieveGuid (szTmp, inGuid)) )
	 { WriteOut(hFile, szReadFail) ;
	   WriteOut(hFile, XSTR("insufficient memory")) ;
	 }
      else
	 {	    // string is in {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
	   szTmp[37] = '\0' ;	    // format, need to remove the {}
	   WriteAttr(hFile, attrUuid, &szTmp[1], numValue) ;
	 }
   }

VOID NEAR tOutAttr (FILE *hFile, int iTypeId)
   {
      BSTRX    bstrDoc ;		    // file string
      BSTRX    bstrHelp ;		    // name of help file
      DWORD    hContext ;		    // help context
      XCHAR    szTmp[16] ;

      if ( FAILED(ptLib->GetDocumentation(iTypeId, NULL, &bstrDoc, &hContext, &bstrHelp)) )
	{
	  WriteOut(hFile, szReadFail) ;
	  WriteOut(hFile, XSTR("documentational attribute\n\n")) ;
	}
      else
	{				    // output helpcontext; default is 0
	  osLtoA((long)hContext, szTmp) ;
	  WriteAttr(hFile, attrHelpCont, szTmp, numValue) ;

	  if ( bstrDoc != NULL )	    // output helpstring if exists
	    WriteAttr(hFile, attrHelpStr, bstrDoc, strValue) ;

	  if ( bstrHelp != NULL ) {	    // output helpfile if exists
            OLECHAR FAR* pchDir;

            // remove the path.
#if WIN32
            pchDir = wcsrchr(bstrHelp, '\\');

            if (pchDir) {
              wcscpy(bstrHelp, pchDir);
            }
#else // !WIN32
            pchDir = _fstrrchr(bstrHelp, '\\');

            if (pchDir) {
              _fstrcpy(bstrHelp, pchDir);
            }
#endif // !WIN32

	    // force path to lower case
#if WIN16
	    AnsiLower(bstrHelp);
#else //WIN16
	    WCHAR * pch;
	    for (pch = bstrHelp; *pch != 0; pch++) {
	      if (*pch >= OLECHAR('A') && *pch <= OLECHAR('Z'))
		*pch = *pch + 'a' - 'A';
	    }
#endif //WIN16
	    WriteAttr(hFile, attrHelpFile, bstrHelp, strValue) ;
	  }

	  SysFreeString((BSTR)bstrDoc) ;    // release local bstr's
	  SysFreeString((BSTR)bstrHelp) ;
	}  

        if (ptlib2) {
	  // new-format typelib -- output more stuff
          if ( FAILED(ptlib2->GetDocumentation2(iTypeId, 0x409, &bstrDoc, &hContext, &bstrHelp)) )
	{
	    WriteOut(hFile, szReadFail);
	    WriteOut(hFile, XSTR("GetDocumentation2 failed\n\n")) ;
	  } else {
	    if (hContext != 0) {
	      osLtoA((long)hContext, szTmp) ;
	      WriteAttr(hFile, XSTR("helpstringcontext"), szTmp, numValue) ;
	    }

	    if ( bstrDoc != NULL )	    // output helpstring if exists
	      WriteAttr(hFile, XSTR("localizedhelpstring"), bstrDoc, strValue) ;

	    // output help dll name if exists && different from main one
	    if (bstrHelp && (!g_bstrHelpDll || osStrCmp(bstrHelp, g_bstrHelpDll)))
	      WriteAttr(hFile, XSTR("helpstringdll"), bstrHelp, strValue) ;

	    SysFreeString((BSTR)bstrDoc) ;    // release local bstr's
	    if (iTypeId == -1) {
	      g_bstrHelpDll = bstrHelp;
	    } else {
	      SysFreeString((BSTR)bstrHelp) ;
	    }
	  }
	}
   }

VOID NEAR tOutMoreAttr (FILE *hFile)
   {
      XCHAR szTmp[16] ;

      if ( ( lpTypeAttr->wTypeFlags & TYPEFLAG_FDUAL ) == TYPEFLAG_FDUAL ) {
         WriteAttr(hFile, attrDual, NULL, noValue) ;
      }
      if ( ( lpTypeAttr->wTypeFlags & TYPEFLAG_FOLEAUTOMATION ) == TYPEFLAG_FOLEAUTOMATION ) // [7]
           WriteAttr(hFile, attrOleAuto, NULL, noValue) ; // check for oleautomation attr

      if ( ( lpTypeAttr->wTypeFlags & TYPEFLAG_FNONEXTENSIBLE ) == TYPEFLAG_FNONEXTENSIBLE ) // [7]
           WriteAttr(hFile, attrNonExt, NULL, noValue) ;  // check for nonextensible attr
#if 0	// messes up old vs new typelib diffs
      if ( ( lpTypeAttr->wTypeFlags & TYPEFLAG_FDISPATCHABLE ) == TYPEFLAG_FDISPATCHABLE )
           WriteAttr(hFile, XSTR("dispatchable"), NULL, noValue) ;
#endif //0
      if ( ( lpTypeAttr->wTypeFlags & TYPEFLAG_FREPLACEABLE ) == TYPEFLAG_FREPLACEABLE )
           WriteAttr(hFile, XSTR("replaceable"), NULL, noValue) ;
      if ( ( lpTypeAttr->wTypeFlags & TYPEFLAG_FAPPOBJECT ) == TYPEFLAG_FAPPOBJECT )
           WriteAttr(hFile, attrAppObj, NULL, noValue) ;
      if ( ( lpTypeAttr->wTypeFlags & TYPEFLAG_FLICENSED ) == TYPEFLAG_FLICENSED ) // [4]
           WriteAttr(hFile, attrLic, NULL, noValue) ;  // check for license
      if ( ( lpTypeAttr->wTypeFlags & TYPEFLAG_FCONTROL ) == TYPEFLAG_FCONTROL ) // [7]
           WriteAttr(hFile, attrControl, NULL, noValue) ;  // check for control attr
      if ( ( lpTypeAttr->wTypeFlags & TYPEFLAG_FAGGREGATABLE ) == TYPEFLAG_FAGGREGATABLE )
           WriteAttr(hFile, XSTR("aggregatable"), NULL, noValue) ;
      if ( ( lpTypeAttr->wTypeFlags & TYPEFLAG_FPROXY ) == TYPEFLAG_FPROXY )
           WriteAttr(hFile, XSTR("proxy"), NULL, noValue) ;

      GetVerNumber (lpTypeAttr->wMajorVerNum, lpTypeAttr->wMinorVerNum, szTmp) ;
      WriteAttr(hFile, attrVer, szTmp, numValue) ; // output version
      tOutUUID(hFile, lpTypeAttr->guid) ;

      if ( ( lpTypeAttr->wTypeFlags & TYPEFLAG_FHIDDEN ) == TYPEFLAG_FHIDDEN ) // [7]
           WriteAttr(hFile, attrHidden, NULL, noValue) ;  // check for hidden attr

      if ( ( lpTypeAttr->wTypeFlags & TYPEFLAG_FRESTRICTED ) == TYPEFLAG_FRESTRICTED ) // [10]
	   WriteAttr(hFile, attrRestrict, NULL, noValue) ;  // check for restricted attr
      osItoA((int)lpTypeAttr->cbSizeVft, szTmp) ;
      WriteAttr(hFile, XSTR("cbSizeVft"), szTmp, numValue) ;
      osItoA(lpTypeAttr->cbSizeInstance, szTmp) ;
      WriteAttr(hFile, XSTR("cbSizeInstance"), szTmp, numValue) ;
      osItoA((int)lpTypeAttr->cbAlignment, szTmp) ;
      WriteAttr(hFile, XSTR("cbAlignment"), szTmp, numValue) ;

      if (ptinfo2) {
	 // new-format typelib -- output more stuff
	 CUSTDATA custdata;
	 ptinfo2->GetAllCustData(&custdata);
	 tOutCustData(hFile, &custdata);
      }

      if ( endAttrFlag )
	 {
	   WriteOut(hFile, szEndAttr) ;
	   endAttrFlag = FALSE ;
	 }
   }


VOID NEAR WriteAttr(FILE *hFile, LPXSTR lpszAttr, LPXSTR lpszStr, int ivalType)
   {
       BOOL firstAttr = FALSE ;

       if ( !endAttrFlag )
	  {
	    WriteOut(hFile, szBeginAttr) ;	// output "[" first
	    endAttrFlag = TRUE ;
	    firstAttr = TRUE ;
	  }
						// this is not the first
       if ( !firstAttr )			// attribute to be written;
	  WriteOut(hFile, XSTR(", ")) ; 	// need to put a , before
						// output name of attribute
       WriteOut(hFile, lpszAttr) ;
       if ( ivalType != noValue )		// attribute has a value
	 {
	    WriteOut(hFile, XSTR("(")) ;
	    if ( ivalType != numValue )		// value is a string
	       WriteOut(hFile, XSTR("\"")) ;

	    WriteOut(hFile, lpszStr) ;		// output value of attribute
	    if ( ivalType != numValue )		// close the string value
	       WriteOut(hFile, XSTR("\"")) ;
	    WriteOut(hFile, XSTR(")")) ;
	 }
   }


VOID NEAR GetVerNumber (WORD wMajorNum, WORD wMinorNum, LPXSTR szVersion)
  {
      XCHAR szTmp[6] ;

      osLtoA((long)wMajorNum, szVersion) ;
      osLtoA((long)wMinorNum, szTmp) ;

      osStrCat(szVersion, XSTR(".")) ;	    // major.
      osStrCat(szVersion, szTmp) ;	    // major.minor
   }

VOID NEAR tOutAlignError (FILE * hFile)     // [5]
   {
      XCHAR szTmp1[30] ;
      XCHAR szTmp2[15] ;

      WriteOut(hFile, szAlignErr) ;
      osLtoA((long)inAlign, szTmp2) ;
      osStrCpy(szTmp1, XSTR("inAlign = ")) ;
      osStrCat(szTmp1, szTmp2) ;
      WriteOut(hFile, szTmp1) ;
   }

VOID NEAR WriteOut(FILE *hFile, LPXSTR lpszData)
  {					    // Note: szBuffer is either UNICODE
					    // or ANSI depending of the UNICODE
      XCHAR szBuffer[fMaxBuffer];	    // compiler switch

      if ( fputsX(lpszData, hFile) < 0 )    // [2]
	 {				    // regardless the OS enviornment
	   osStrCpy(szBuffer, XSTR("Fail to write to file ")) ;
	   osStrCat(szBuffer, lpszData) ;
           if ( isOut )
             {
                mFile = fopenX(szOutMsgFile, fnWrite);// open message file [2]
                if (mFile == NULL)
                   {
                      osMessage (XSTR("Fail to open the message file"), XSTR("Tlviewer")) ;
                      osMessage (szBuffer, XSTR("Tlviewer")) ;
                   }
                 else
                   {
                      WriteOut(mFile, szBuffer) ;
                      fclose(mFile) ;
                      mFile = NULL ;
                    }
             }
	   else
	     osMessage (szBuffer, XSTR("Tlviewer")) ;
	 }
  }


// test routine for use in the typelib dumping routines.  Supposed to
// return a help string from a resource.   (Called as a result of doing
// a GetDocumentation2).  We just fake something out here.
extern "C" HRESULT __declspec(dllexport) DLLGetDocumentation
(
    ITypeLib * /*ptlib*/,
    ITypeInfo * /*ptinfo*/,
    LCID lcid,
    DWORD dwHelpStringContext,
    BSTR * pbstrHelpString
)
{
    switch (dwHelpStringContext) {
      case 99:
	if (lcid == 0x409) {
          *pbstrHelpString = SysAllocString(OLESTR("English help for context 99"));
	} else
	if (lcid == 0) {
          *pbstrHelpString = SysAllocString(OLESTR("Default help for context 99"));
	} else {
          *pbstrHelpString = SysAllocString(OLESTR("Foreign help for context 99"));
	}
	break;
      default:
	*pbstrHelpString = NULL;	// no help for this item
    }
   return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\f3ctx.h ===
#define f3evtAddControl 2000010
#define f3evtAfterUpdate 2000020
#define f3evtBeforeDragOver 2000030
#define f3evtBeforeDropOrPaste 2000040
#define f3evtBeforeUpdate 2000050
#define f3evtChange 2000060
#define f3evtClick 2000070
#define f3evtDblClick 2000080
#define f3evtDropButtonClick 2000090
#define f3evtError 2000100
#define f3evtGotFocus 2000110
#define f3evtKeyDown 2000120
#define f3evtKeyPress 2000130
#define f3evtKeyUp 2000140
#define f3evtLayout 2000150
#define f3evtLostFocus 2000160
#define f3evtMouseDown 2000170
#define f3evtMouseMove 2000180
#define f3evtMouseUp 2000190
#define f3evtRemoveControl 2000200
#define f3evtScroll 2000210
#define f3evtSpinDown 2000220
#define f3evtSpinUp 2000230
#define f3evtZoom 2000240
#define f3mthAdd 2000250
#define f3mthAddItem 2000260
#define f3mthClear 2000270
#define f3mthCopy 2000280
#define f3mthCut 2000290
#define f3mthDropDown 2000300
#define f3mthItem 2000310
#define f3mthMove 2000320
#define f3mthPaste 2000330
#define f3mthRedoAction 2000340
#define f3mthRefresh 2000350
#define f3mthRemove 2000360
#define f3mthRemoveItem 2000370
#define f3mthRepaint 2000380
#define f3mthScroll 2000390
#define f3mthSelect 2000400
#define f3mthSelectAll 2000410
#define f3mthSetDefaultTabOrder 2000420
#define f3mthSetFocus 2000430
#define f3mthStartDrag 2000440
#define f3mthUndoAction 2000450
#define f3mthZOrder 2000460
#define f3objCheckBox 2000470
#define f3objComboBox 2000480
#define f3objCommandButton 2000490
#define f3objControls 2000500
#define f3objDataObject 2000510
#define f3objFont 2000520
#define f3objForm 2000530
#define f3objFrame 2000535                     // Manually added
#define f3objImage 2000540
#define f3objLabel 2000550
#define f3objListBox 2000560
#define f3objMultiPage 2000570
#define f3objOptionButton 2000580
#define f3objPage 2000590
#define f3objPages 2000600
#define f3objScrollBar 2000610
#define f3objSelected 2000620
#define f3objSpinButton 2000630
#define f3objTab 2000640
#define f3objTabs 2000650
#define f3objTabStrip 2000660
#define f3objTextBox 2000670
#define f3objToggleButton 2000680
#define f3proAccelerator 2000690
#define f3proActiveControl 2000700
#define f3proAlignment 2000710
#define f3proApplication 2000720
#define f3proAutoSelectChild 2000730
#define f3proAutoSize 2000740
#define f3proAutoTab 2000750
#define f3proAutoWordSelect 2000760
#define f3proBackColor 2000770
#define f3proBackStyle 2000780
#define f3proBold 2000790
#define f3proBorderColor 2000800
#define f3proBordersSuppress 2000810
#define f3proBorderStyle 2000820
#define f3proBoundColumn 2000830
#define f3proCancel 2000840
#define f3proCanPaste 2000850
#define f3proCanRedo 2000860
#define f3proCanUndo 2000870
#define f3proCaption 2000880
#define f3proClientHeight 2000890
#define f3proClientLeft 2000900
#define f3proClientTop 2000910
#define f3proClientWidth 2000920
#define f3proColumn 2000930
#define f3proColumnCount 2000940
#define f3proColumnHeads 2000950
#define f3proColumnWidths 2000960
#define f3proControls 2000970
#define f3proControlSource 2000980
#define f3proControlTipText 2000990
#define f3proCount 2001000
#define f3proCurLine 2001010
#define f3proCurTargetX 2001020
#define f3proCurTargetY 2001030
#define f3proCurX 2001040
#define f3proCurY 2001050
#define f3proCycle 2001060
#define f3proDefault 2001070
#define f3proDelay 2001080
#define f3proDragBehavior 2001085               // Added manually
#define f3proDrawBuffer 2001087                  // Added manually
#define f3proDesignMode 2001090
#define f3proDirty 2001100
#define f3proDropButtonStyle 2001110
#define f3proEnabled 2001120
#define f3proEnterFieldBehavior 2001125 // Added manually
#define f3proEnterKeyBehavior 2001130
#define f3proFont 2001140
#define f3proFontBold 2001150
#define f3proFontItalic 2001160
#define f3proFontName 2001170
#define f3proFontSize 2001180
#define f3proFontStrikethru 2001190
#define f3proFontUnderline 2001200
#define f3proFontWeight 2001210
#define f3proForeColor 2001220
#define f3proGridX 2001230
#define f3proGridY 2001240
#define f3proGroupName 2001245          // Added manually, AndrewL, 3/31/96
#define f3proHeight 2001250
#define f3proHelpContextID 2001260
#define f3proHideSelection 2001270
#define f3proIndex 2001280
#define f3proInSelection 2001290
#define f3proInsideHeight 2001300
#define f3proInsideWidth 2001310
#define f3proIntegralHeight 2001320
#define f3proItalic 2001330
#define f3proKeepFocusOnClick 2001340
#define f3proKeepScrollbarsVisible 2001350
#define f3proLargeChange 2001360
#define f3proLayoutEffect 2001370
#define f3proLeft 2001380
#define f3proLineCount 2001390
#define f3proList 2001400
#define f3proListCount 2001410
#define f3proListCursor 2001420
#define f3proListIndex 2001430
#define f3proListRows 2001440
#define f3proListStyle 2001450
#define f3proListWidth 2001460
#define f3proLocked 2001470
#define f3proMatchEntry 2001480
#define f3proMatchFound 2001490
#define f3proMatchRequired 2001500
#define f3proMax 2001510
#define f3proMaxLength 2001520
#define f3proMin 2001530
#define f3proMouseIcon 2001540
#define f3proMousePointer 2001550
#define f3proMultiLine 2001560
#define f3proMultiRow 2001570
#define f3proMultiSelect 2001580
#define f3proName 2001590
#define f3pronewEnum 2001600
#define f3proObject 2001610
#define f3proOldHeight 2001620
#define f3proOldLeft 2001630
#define f3proOldTop 2001640
#define f3proOldWidth 2001650
#define f3proOrientation 2001660
#define f3proPages 2001670
#define f3proParent 2001680
#define f3proPasswordChar 2001690
#define f3proPictureAlignment 2001700
#define f3proPictureData 2001710
#define f3proPicturePosition 2001720
#define f3proPictureSizeMode 2001730
#define f3proPictureTiling 2001740
#define f3proProportionalThumb 2001750
#define f3proRowSource 2001760
#define f3proRowSourceType 2001770
#define f3proScrollBars 2001780
#define f3proScrollHeight 2001790
#define f3proScrollLeft 2001800
#define f3proScrollTop 2001810
#define f3proScrollWidth 2001820
#define f3proSelected 2001830
#define f3proSelectedCount 2001840
#define f3proSelectedItem 2001850
#define f3proSelectionMargin 2001860
#define f3proSelLength 2001870
#define f3proSelStart 2001880
#define f3proSelText 2001890
#define f3proShowDropButtonWhen 2001900
#define f3proShowGridDots 2001910
#define f3proSize 2001920
#define f3proSizeMode 2001930
#define f3proSmallChange 2001940
#define f3proSnapToGrid 2001950
#define f3proSpecialEffect 2001960
#define f3proStrikeThrough 2001970
#define f3proStyle 2001980
#define f3proTabFixedHeight 2001990
#define f3proTabFixedWidth 2002000
#define f3proTabIndex 2002010
#define f3proTabKeyBehavior 2002020
#define f3proTabOrientation 2002030
#define f3proTabs 2002040
#define f3proTabStop 2002050
#define f3proTag 2002060
#define f3proText 2002070
#define f3proTextAlign 2002080
#define f3proTextColumn 2002090
#define f3proTextLength 2002100
#define f3proTop 2002110
#define f3proTopIndex 2002120
#define f3proTransitionEffect 2002130
#define f3proTransitionPeriod 2002140
#define f3proTripleState 2002150
#define f3proUnderline 2002160
#define f3proValid 2002170
#define f3proValue 2002180
#define f3proVerticalScrollbarSide 2002190
#define f3proVisible 2002200
#define f3proWeight 2002210
#define f3proWidth 2002220
#define f3proWordWrap 2002230
#define f3proZoom 2002240
#define IDH_f3defControl 2002250
#define IDH_f3defANSICharacterSet 2002260
#define IDH_f3defAcceleratorKey 2002270
#define IDH_f3defActive 2002280
#define IDH_f3defArgument 2002290
#define IDH_f3defArray 2002300
#define IDH_f3defBackgroundColor 2002310
#define IDH_f3defBound 2002320
#define IDH_f3defCaption 2002330
#define IDH_f3defClass 2002340
#define IDH_f3defClassIdentifier 2002350
#define IDH_f3defClear 2002360
#define IDH_f3defClientRegion 2002370
#define IDH_f3defClip 2002380
#define IDH_f3defCollection 2002390
#define IDH_f3defContainer 2002400
#define IDH_f3defContextID 2002410
#define IDH_f3defControlGroup 2002420
#define IDH_f3defCycle 2002430
#define IDH_f3defDataSource 2002440
#define IDH_f3defDefault 2002450
#define IDH_f3defDesignTime 2002460
#define IDH_f3defDisable 2002470
#define IDH_f3defDoubleclickSpeedSetting 2002480
#define IDH_f3defDraganddropOperation 2002490
#define IDH_f3defDropSource 2002500
#define IDH_f3defDropdownList 2002510
#define IDH_f3defEnable 2002520
#define IDH_f3defEvent 2002530
#define IDH_f3defEventProcedure 2002540
#define IDH_f3defFocus 2002550
#define IDH_f3defForegroundColor 2002560
#define IDH_f3defForm 2002570
#define IDH_f3defFormat 2002580
#define IDH_f3defIME 2002590
#define IDH_f3defInheritedProperty 2002600
#define IDH_f3defInputArea 2002610
#define IDH_f3defInsertionPoint 2002620
#define IDH_f3defKeyboardState 2002630
#define IDH_f3defLabel 2002640
#define IDH_f3defMember 2002650
#define IDH_f3defMemberName 2002660
#define IDH_f3defMethod 2002670
#define IDH_f3defModule 2002680
#define IDH_f3defNamedArgument 2002690
#define IDH_f3defNull 2002700
#define IDH_f3defOLEContainerControls 2002710
#define IDH_f3defOLEObject 2002720
#define IDH_f3defOLEStatusCode 2002730
#define IDH_f3defObject 2002740
#define IDH_f3defObjectBrowser 2002750
#define IDH_f3defPage 2002760
#define IDH_f3defPlaceholder 2002770
#define IDH_f3defPoint 2002780
#define IDH_f3defProcedure 2002790
#define IDH_f3defProject 2002800
#define IDH_f3defProperty 2002810
#define IDH_f3defPropertyPage 2002820
#define IDH_f3defRGB 2002830
#define IDH_f3defRunTime 2002840
#define IDH_f3defSelection 2002850
#define IDH_f3defSendKeysStatement 2002860
#define IDH_f3defSeparator 2002870
#define IDH_f3defSingleprecisionValue 2002880
#define IDH_f3defSizingHandles 2002890
#define IDH_f3defStatement 2002900
#define IDH_f3defSystemColors 2002910
#define IDH_f3defTabOrder 2002920
#define IDH_f3defTarget 2002930
#define IDH_f3defToolbar 2002940
#define IDH_f3defTransparent 2002950
#define IDH_f3defUnbound 2002960
#define IDH_f3defUserInterface 2002970
#define IDH_f3defValue 2002980
#define IDH_f3defVisualBasicForApplications 2002990
#define IDH_f3defVisualGroup 20023000
#define IDH_f3defZorder 20023010
#define f3defDataFormat 20023020        //Added manually 5/17/96
#define f3defDominantControl  20023030  //Added manually 5/17/96
#define f3defGridBlock  20023040        //Added manually 5/17/96
// ***** Begin Dialog Box context IDs
#define f3dlgRename 2010010
#define f3dlgPageOrder 2010020
#define f3dlgCustomControls 2010030
#define f3dlgCustomizeControl 2010040
#define IDH_f3defDataFormat 2010050
#define IDH_f3defDominantControl 2010060
#define IDH_f3defGridBlock 2010070
#define IDH_f3defControlTip 2010080
#define IDH_f3defCursor 2010090
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\handler.h ===
#ifndef HANDLER_H
#define HANDLER_H



interface IScriptletHandlerConstructor;
interface IScriptletHandler;

/***************************************************************************
	Scriptlet Interface Handlers
	============================
	This is a preliminary draft. Changes may need to be made based on
	review feedback, support needed for client side security, and support
	for MTS scalability.
	
	The primary responsibility of a scriptlet interface handler is to 
	aggregate a set of COM interfaces with the scriptlet base runtime
	and translate calls made on those COM interfaces into calls to the
	script name space.
	
	Interface handlers are created using a constructor object. The 
	constructor object takes on the role similar to that of class
	objects in most other languages. It is intialized with the XML
	data nested in the implements element and then can be used for:	
		1. Execution - creating handler objects for scriptlet instances
		2. Registration - performing handler specific registration for an object
		3. Type library generation - generating a typelibrary for use with MTS
***************************************************************************/
typedef WORD PK;

#define pkELEMENT	0
#define pkATTRIBUTE	1
#define pkTEXT		2
#define pkCOMMENT	3
#define pkPI		4
#define pkXMLDECL	5
#define pkVALUE		6

#define fcompileIsXML		0x0001
#define fcompileValidate	0x0002
#define fcompileAllowDebug	0x8000
	
struct PNODE
	{
	PK pk;
	ULONG line;
	ULONG column;
	ULONG cchToken;
	LPCOLESTR pstrToken;
	PNODE *pnodeNext;
	union
		{
		struct
			{
			PNODE *pnodeAttr;
			PNODE *pnodeData;
			void *pvLim; // Used to calc amount of memory to allocate
			} element;
		
		struct 
			{
			PNODE *pnodeAttr;
			void *pvLim;
			} xmldecl;
			
		struct
			{
			PNODE *pnodeValue;
			void *pvLim; // Used to calc amount of memory to allocate
			} attribute, pi;

		struct
			{
			void *pvLim; // Used to calc amount of memory to allocate
			} text, comment, value;
		
		};
	};


DEFINE_GUID(IID_IScriptletHandlerConstructor, 0xa3d52a50, 0xb7ff, 0x11d1, 0xa3, 0x5a, 0x0, 0x60, 0x8, 0xc3, 0xfb, 0xfc);
interface IScriptletHandlerConstructor : public IUnknown
	{
    STDMETHOD(Load)(WORD wFlags, PNODE *pnode) PURE;
	STDMETHOD(Create)(IUnknown *punkContext, IUnknown *punkOuter,
			IUnknown **ppunkHandler) PURE;
	STDMETHOD(Register)(LPCOLESTR pstrPath, REFCLSID rclisid, 
			LPCOLESTR pstrProgId) PURE;
	STDMETHOD(Unregister)(REFCLSID rclsid, LPCOLESTR pstrProgId) PURE;
	STDMETHOD(AddInterfaceTypeInfo)(ICreateTypeLib *ptclib, 
			ICreateTypeInfo *pctiCoclass, UINT *puiImplIndex) PURE;
	};

DEFINE_GUID(IID_IScriptletHandler, 0xa001a870, 0xa7df, 0x11d1, 0x89, 0xbe, 0x0, 0x60, 0x8, 0xc3, 0xfb, 0xfc);
interface IScriptletHandler : public IUnknown
	{
	STDMETHOD(GetNameSpaceObject)(IUnknown **ppunk) PURE;
	STDMETHOD(SetScriptNameSpace)(IUnknown *punkNameSpace) PURE;
	};


#define IScriptletHandlerConstructorNew IScriptletHandlerConstructor
#define IID_IScriptletHandlerConstructorNew IID_IScriptletHandlerConstructorNew









/***************************************************************************
	Scriptlet XML Object Model Interfaces
	
	In an ideal world, we would be using a standard IPersistXML interface
	with a standardized XML DOM to load interface handlers from the XML
	data stream. Unfortunately, these interface definitions will not be ready
	in time for our ship date. As a result, we define our own private 
	intefaces which we will use until the official stuff becomes available.
	
	These interfaces are designed to provide the minimal set of methods
	needed to implement persistence support for scriptlet interface handlers.
	Matching the proposed XML interfaces was a consideration, but not an
	overwhelming factor. The main constraint in this design is the time
	required to implement.
	
	The return values of the methods name and data depend on the node 
	type. Here's a table that describes the return values for each of the
	types. NOTHING is signalled by the method returning S_FALSE and setting
	the bstr pointer to NULL.
	
	Type		name method					data method
	====		===========					===========
	ELEMENT		Tag name					NOTHING
	ATTRIBUTE	Attribute name				NOTHING or attribute value if exists
	TEXT		NOTHING						Characters in text
	COMMENT		NOTHING						Characters in comment
	PI			Processing instruction		Data for the PI.
	XMLDECL		NOTHING						NOTHING
	
	The getFirstChild and getAttributes methods are only valid for
	nodes of type ELEMENT. The nodes returned by getFirstAttribute will
	always be of type ScriptletXML_ATTRIBUTE.
	
	The getNext method gets the next sibling. The grfxml parameter allows
	you to filter out the types of nodes you're interested in. The flag
	fxmlText will only return only those text sequences that are not
	all white space. Passing in fxmlAllText will get all text nodes.
***************************************************************************/
interface IScriptletXML;

typedef enum
	{
	ScriptletXML_ELEMENT,
	ScriptletXML_ATTRIBUTE,
	ScriptletXML_TEXT,
	ScriptletXML_COMMENT,
	ScriptletXML_PI,
	ScriptletXML_XMLDECL,
	} ScriptletXMLNodeType;	

#define fxmlElement		(1<<ScriptletXML_ELEMENT)
#define fxmlAttribute 	(1<<ScriptletXML_ATTRIBUTE)
#define fxmlText		(1<<ScriptletXML_TEXT)
#define fxmlComment		(1<<ScriptletXML_COMMENT)
#define fxmlPI			(1<<ScriptletXML_PI)
#define fxmlXMLDecl		(1<<ScriptletXML_XMLDECL)
#define fxmlHasText		0x0100

#define kgrfxmlNormal	(fxmlElement|fxmlHasText)
#define kgrfxmlAll		(fxmlElement|fxmlAttribute|fxmlText|fxmlComment| \
							fxmlPI|fxmlXMLDecl)

#define fattrFailOnUnknown	0x0001
							
							
DEFINE_GUID(IID_IScriptletXML, 0xddd30cc0, 0xa3fe, 0x11d1, 0xb3, 0x82, 0x0, 0xa0, 0xc9, 0x11, 0xe8, 0xb2);

interface IScriptletXML : public IUnknown
    {
	STDMETHOD(getNodeType)(long *ptype) PURE;
	STDMETHOD(getPosition)(ULONG *pline, ULONG *pcolumn) PURE;
	STDMETHOD(getName)(BSTR *pbstrName) PURE;
	STDMETHOD(getData)(BSTR *pbstrValue) PURE; 
	STDMETHOD(getNext)(WORD grfxmlFilter, IScriptletXML **ppxml) PURE;
	STDMETHOD(getFirstChild)(WORD grfxmlFilter, IScriptletXML **ppxml) PURE;
	STDMETHOD(getFirstAttribute)(IScriptletXML **ppxml) PURE;
	STDMETHOD(getAttributes)(WORD grfattr, long cattr, 
			LPCOLESTR *prgpstrAttributes, BSTR *prgbstrValues) PURE;
    };



DEFINE_GUID(IID_IScriptletHandlerConstructorOld, 0x67463cd0, 0xb371, 0x11d1, 0x89, 0xca, 0x0, 0x60, 0x8, 0xc3, 0xfb, 0xfc);
interface IScriptletHandlerConstructorOld : public IUnknown
	{
    STDMETHOD(Load)(WORD wFlags, IScriptletXML *pxmlElement) PURE;
	STDMETHOD(Create)(IUnknown *punkContext, IUnknown *punkOuter,
			IUnknown **ppunkHandler) PURE;
	STDMETHOD(Register)(LPCOLESTR pstrPath, REFCLSID rclisid, 
			LPCOLESTR pstrProgId) PURE;
	STDMETHOD(Unregister)(REFCLSID rclsid, LPCOLESTR pstrProgId) PURE;
	STDMETHOD(AddInterfaceTypeInfo)(ICreateTypeLib *ptclib, 
			ICreateTypeInfo *pctiCoclass, UINT *puiImplIndex) PURE;
	};



#endif // HANDLER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\jgtypes.h ===
/*----------------------------------------------------------------------------
;
; Start of jgtypes.h - Definitions for common types and macros
;
; Copyright (c) 1994-1996 Johnson-Grace Company, all rights reserved
;
;---------------------------------------------------------------------------*/

#ifndef JGTYPES_INCLUDED
#define JGTYPES_INCLUDED

#ifdef __cplusplus
  extern "C" {                  // indicate C declarations if C++
#endif

// Determine if 32-bit architecture (vs. 16-bit segmented).  If segmented,
// determine if using a small data model (tiny model is not supported).

#if defined(__FLAT__) || defined(_WIN32) || defined(unix) || defined(_MAC)
  #define JGMACH32
#elif defined(__SMALL__) || defined(__MEDIUM__) // Borland
  #define JGSMALLDATA
#elif defined(_M_I86SM) || defined(_M_I86MM)    // Microsoft
  #define JGSMALLDATA
#endif

#define JGCONST const
#define JGVOLATILE volatile

// These defines declare the native int.  These are the fastest ints
// available (of at least 16 bits) for a given environment.

#ifdef JGINTW32
  typedef long INTW;
  typedef unsigned long UINTW;
#else
  typedef int INTW;
  typedef unsigned int UINTW;
#endif

// These ints are for known lengths.
// Note that they work for both 16 and 32 machines...
// (at least for WATCOM, BORLAND and Microsoft compilers)

#ifndef _BASETSD_H_
typedef signed char    INT8;
typedef signed short   INT16;
typedef signed long    INT32;
typedef unsigned char  UINT8;
typedef unsigned short UINT16;
typedef unsigned long  UINT32;
#endif

// Pointers, calling conventions.

#ifdef JGSTATIC
  #define JGIMPORT
  #define JGEXPORT
#endif

#ifdef JGMACH32
  #define JGHUGE
  #define JGFAR
  #define JGNEAR
  #ifndef JGCCONV
	#if defined(unix) || defined(_MAC)
		#define JGCCONV
	#else
		#define JGCCONV __cdecl
	#endif
  #endif
  #ifndef JGEXPORT
	#if defined(unix) || defined(_MAC)
		#define JGEXPORT
	#else
		#define JGEXPORT __declspec(dllexport)
	#endif
  #endif
  #ifndef JGIMPORT
	#if defined(unix) || defined(_MAC)
		#define JGIMPORT
	#else
		#define JGIMPORT __declspec(dllimport)
		#pragma warning(disable:4273)
	#endif
  #endif
#else
  #define JGHUGE _huge
  #define JGFAR  _far
  #define JGNEAR _near
  #ifndef JGCCONV
    #define JGCCONV __pascal
  #endif
  #ifndef JGEXPORT
	#define JGEXPORT __export
  #endif
  #ifndef JGIMPORT
	#define JGIMPORT __export
  #endif
#endif

#define JGPTR JGFAR *
#define JGHPTR JGHUGE *
#ifndef JGNFUNC
  #define JGNFUNC JGNEAR JGCCONV
#endif
#ifndef JGFFUNC
  #define JGFFUNC JGFAR JGCCONV
#endif
#ifndef JGFUNC
  #define JGFUNC JGCCONV
#endif

// Other simple types.

typedef int JGBOOL;
typedef UINTW JGERR;

// Type-checked handle creation macro
#define JG_DECLARE_HANDLE(id) \
  struct id##_DUMMY { UINTW dummy[16]; }; \
  typedef const struct id##_DUMMY JGPTR id

// Generic JG handle
JG_DECLARE_HANDLE(JGHANDLE);

/******************************************
MEMORY MANIPULATION
******************************************/

typedef void (JGFUNC JGPTR JG_HMEMCPY_FN)(void JGHPTR, void JGHPTR, UINT32);

 #if defined(JGMACH32)
  #if defined(_MAC)
    #define JG_HMEMCPY(Dst, Src, n) memmove(Dst, Src, (UINTW)(n))
    #define JG_FMEMCPY(Dst, Src, n)  memmove(Dst, Src, (UINTW)(n))
    #define JG_FMEMMOVE(Dst, Src, n)  memmove(Dst, Src, (UINTW)(n))
  #else
    #define JG_HMEMCPY(Dst, Src, n) memcpy(Dst, Src, (UINTW)(n))
    #define JG_FMEMCPY memcpy
    #define JG_FMEMMOVE memmove
  #endif
  #define JG_FMEMCMP memcmp
  #define JG_FMEMSET memset
  #define JG_FSTRNCPY strncpy
  #define JG_FSTRCPY strcpy
  #define JG_FSTRCAT strcat
  #define JG_FSTRLEN strlen
  #define JG_FSTRCHR strchr
  #define JG_FSTRRCHR strrchr
#else
  #define JG_HMEMCPY Jghmemcpy		// Defined by user.
  void JGFUNC Jghmemcpy(void JGHPTR, void JGHPTR, UINT32);
  #define JG_FMEMCPY Jgfmemcpy
  void JGFUNC Jgfmemcpy(void JGPTR, void JGPTR, UINTW);
  #define JG_FMEMCMP _fmemcmp
  #define JG_FMEMMOVE _fmemmove
  #define JG_FMEMSET _fmemset
  #define JG_FSTRNCPY _fstrncpy
  #define JG_FSTRCPY _fstrcpy
  #define JG_FSTRCAT _fstrcat
  #define JG_FSTRLEN _fstrlen
  #define JG_FSTRCHR _fstrchr
  #define JG_FSTRRCHR _fstrrchr
#endif

/**************************************
* Resource Management Definitions     *
**************************************/

typedef void JGPTR (JGFFUNC *JG_FMALLOC_FN)(UINT32 n);
typedef void (JGFFUNC *JG_FFREE_FN)(void JGPTR p);

typedef void (JGFFUNC *JG_ENTERCS_FN)(void);
typedef void (JGFFUNC *JG_LEAVECS_FN)(void);

JG_DECLARE_HANDLE(JG_LIBHANDLE);
typedef JG_LIBHANDLE (JGFFUNC *JG_LOADLIB_FN)(char JGPTR LibFileName);
typedef void (JGFFUNC *JG_FREELIB_FN)(JG_LIBHANDLE LibHandle);
typedef void JGPTR (JGFFUNC *JG_GETLIBFN_FN)
	(JG_LIBHANDLE LibHandle, char JGPTR FuncName);

typedef struct {				// JG System Services override structure
	UINT32 Flags;				// override selection flags (defined below)
	JG_FMALLOC_FN	Jgfmalloc;	// mem alloc (16-bit: 0-offset, >64k allowed)
	JG_FFREE_FN		Jgffree;	// frees Jgfmalloc'd block
	JG_ENTERCS_FN	JgEnterCs;	// enter thread critical section
	JG_LEAVECS_FN	JgLeaveCs;	// leave thread critical section
	JG_LOADLIB_FN	JgLoadLib;	// explicitly load library
	JG_FREELIB_FN	JgFreeLib;	// free explicitly-loaded library
	JG_GETLIBFN_FN	JgGetLibFn;	// get explicitly-loaded library function ptr
} JG_SYS_SERVICES;

#define JG_SYSFL_ALLOC		1	// override Jgfmalloc/Jgffree
#define JG_SYSFL_CRITSEC	2	// override JgEnterCs/JgLeaveCs
#define JG_SYSFL_LOADLIB	4	// override JgLoadLib/JgFreeLib/JgGetLibFn

#ifdef	JGMACH32				// if 32-bit (true multi-tasking w/threads),
  void JGFUNC JgEnterCs(void);
  #define JG_ENTERCS JgEnterCs();
  void JGFUNC JgLeaveCs(void);
  #define JG_LEAVECS JgLeaveCs();
#else							// else 16-bit (cooperative multi-tasking),
  #define JG_ENTERCS
  #define JG_LEAVECS
#endif

#ifndef JGSTATIC
  #define JG_LOADLIB(LibFileName) JgLoadLib(LibFileName)
  JG_LIBHANDLE JGFUNC JgLoadLib(char JGPTR LibFileName);
  #define JG_FREELIB(LibHandle) JgFreeLib(LibHandle)
  void JGFUNC JgFreeLib(JG_LIBHANDLE LibHandle);
  #define JG_GETLIBFN(LibHandle, FuncName) JgGetLibFn(LibHandle, #FuncName)
  void JGPTR JGFUNC JgGetLibFn(JG_LIBHANDLE LibHandle, char JGPTR FuncName);
#else
  #define JG_LOADLIB(LibFileName) ((JG_LIBHANDLE) (UINT32) (LibFileName))
  #define JG_FREELIB(LibHandle) { LibHandle = LibHandle; }
  #define JG_GETLIBFN(LibHandle, FuncName) (LibHandle = LibHandle, FuncName)
#endif


#ifndef JGNOMEMDEF
 #ifdef JGMACH32
  #define JG_FMALLOC(n) Jgmalloc((UINTW)(n))
  #define JG_ZFMALLOC(n) Jgmalloc((UINTW)(n))
  #define JG_MALLOC     Jgmalloc
  void * JGFUNC         Jgmalloc(UINT32 n);
  #define JG_FFREE      Jgfree
  #define JG_ZFFREE     Jgfree
  #define JG_FREE       Jgfree
  void JGFUNC           Jgfree(void *p);
  #ifdef JGMEMCALL
	#define JG_MAKEEXEPTR JgMakeExePtr
	void JGPTR JGFUNC     JgMakeExePtr(void JGPTR p);
	#define JG_FREEEXEPTR JgFreeExePtr
	void JGFUNC JgFreeExePtr(void JGPTR p);
  #else
	#define JG_MAKEEXEPTR(a) (a)
	#define JG_FREEEXEPTR(a)
  #endif
 #else
  #ifndef JGMEMCALL
    #define JGMEMCALL
  #endif
    #define JG_MALLOC   Jgmalloc
    void * JGFUNC       Jgmalloc(UINT32 n);
    #define JG_FREE     Jgfree
    void JGFUNC         Jgfree(void *p);

    #define JG_FMALLOC  Jgfmalloc       // note: must return 0-offset pointers
    void JGPTR JGFUNC   Jgfmalloc(UINT32 n);
    #define JG_ZFMALLOC Jgsvfmalloc
    void JGPTR JGFUNC Jgsvfmalloc(UINT32 n);
    #define JG_FFREE    Jgffree
    void JGFUNC         Jgffree(void JGPTR p);
    #define JG_ZFFREE   Jgffree
    void JGFUNC         Jgsvffree(void JGPTR p);
	#define JG_MAKEEXEPTR JgMakeExePtr
	void JGPTR JGFUNC     JgMakeExePtr(void JGPTR p);
	#define JG_FREEEXEPTR JgFreeExePtr
	void JGFUNC JgFreeExePtr(void JGPTR p);

 #endif
#endif

/**************************************
* ERROR CLASSIFICATIONS               *
**************************************/

#define JG_ERR_SHIFT (12)
#define JG_ERR_MASK  (0x000F)

#define JG_ERR_UNKNOWN (0<<JG_ERR_SHIFT) // (Place holder, don't use this)
#define JG_ERR_STATUS  (1<<JG_ERR_SHIFT) // Exceptions that may not be errors
#define JG_ERR_MEMORY  (2<<JG_ERR_SHIFT) // Memory allocation errors
#define JG_ERR_FILEIO  (3<<JG_ERR_SHIFT) // File IO Errors
#define JG_ERR_ARG     (4<<JG_ERR_SHIFT) // Errors due to passing bad args
#define JG_ERR_VERSION (5<<JG_ERR_SHIFT) // Errors due to version mismatch
#define JG_ERR_DATA    (6<<JG_ERR_SHIFT) // Errors due to corrupted data
#define JG_ERR_CHECK   (7<<JG_ERR_SHIFT) // Internal consistency checks
#define JG_ERR_STATE   (8<<JG_ERR_SHIFT) // State invalid to perform operation

#define JGERR_BASE			0x0f00		// JGERR-type standard error code base
#define JGERR_NOMEM			/* insufficient memory */	\
							(JG_ERR_MEMORY	| JGERR_BASE | 0)
#define JGERR_BADARG		/* bad function argument */	\
							(JG_ERR_ARG		| JGERR_BASE | 4)
#define JGERR_BADHANDLE		/* invalid/corrupt handle */ \
							(JG_ERR_ARG		| JGERR_BASE | 5)
#define JGERR_BADVERSION	/* unknown/obsolete version */ \
							(JG_ERR_DATA	| JGERR_BASE | 6)
#define JGERR_BADDATA		/* data block is corrupt */ \
							(JG_ERR_DATA	| JGERR_BASE | 7)
#define JGERR_BADSTREAM		/* data stream corrupt/out-of-order */ \
							(JG_ERR_DATA	| JGERR_BASE | 8)
#define JGERR_BUFOVERFLOW	/* output buffer too small */ \
							(JG_ERR_DATA	| JGERR_BASE | 9)
#define JGERR_SHORTBUF		/* insufficient input data */ \
							(JG_ERR_DATA	| JGERR_BASE | 10)
#define JGERR_BADSTATE		/* improper state for operation */ \
							(JG_ERR_STATE	| JGERR_BASE | 13)
#define JGERR_WAITING		/* system waiting caller action */ \
							(JG_ERR_STATE	| JGERR_BASE | 14)
#define JGERR_DONE			/* cannot proceed - process complete */ \
							(JG_ERR_STATE	| JGERR_BASE | 15)
#define JGERR_INTERNAL		/* fatal internal error */ \
							(JG_ERR_CHECK	| JGERR_BASE | 16)
#define JGERR_LIBNOTFOUND	/* DLL library not found */ \
							(JG_ERR_CHECK	| JGERR_BASE | 17)

/**************************************
* COMPLEX STRUCTURES                  *
**************************************/

// More complex structures/types.

typedef UINT32 JGFOURCHAR;		// Four character code
#define JG_MAKEFOURCHAR(a,b,c,d) \
	(((UINT32)(UINT8)(a) << 24) | ((UINT32)(UINT8)(b) << 16) | \
	((UINT32)(UINT8)(c) << 8) | (UINT32)(UINT8)(d))
#define JG4C_AUTO JG_MAKEFOURCHAR('a','u','t','o')	// image formats
#define JG4C_ART  JG_MAKEFOURCHAR('A','R','T','f')
#define JG4C_GIF  JG_MAKEFOURCHAR('G','I','F','f')
#define JG4C_BMP  JG_MAKEFOURCHAR('B','M','P',' ')
#define JG4C_JPEG JG_MAKEFOURCHAR('J','P','E','G')
#define JG4C_ART_GT8	JG_MAKEFOURCHAR('G','T','8',' ') // .ART sub-formats
#define JG4C_ART_GT24	JG_MAKEFOURCHAR('G','T','2','4')
#define JG4C_ART_CT	JG_MAKEFOURCHAR('C','T',' ',' ')
#define JG4C_ART_WAVE	JG_MAKEFOURCHAR('W','A','V','E')

typedef struct {		// component decoder stream type descriptor
    UINTW nSize;		// sizeof() this structure, in bytes
    JGFOURCHAR	ImageFormat;	// main format (JPEG, GIF, etc)
    JGFOURCHAR	SubFormat;	// sub-format (e.g. ART: GT, WAVE, etc), or 0
    char JGPTR	Extension;	// common three character file extension
    char JGPTR	Description;	// short format description string
} JG_READER_DESC;

typedef struct {                // bit-stream pointer structure
    UINT8 JGPTR BitPtr;         // pointer to next byte to access
    UINTW  BitCnt;              // next *BitPtr bit, 7(hi bit) to 0(low bit)
} BIT_STREAM;

typedef struct {                // bit-stream pointer structure
    UINT8 JGPTR BitPtr;         // pointer to next byte to access
    UINTW  BitCnt;              // next *BitPtr bit, 7(hi bit) to 0(low bit)
} JG_BIT_PTR;

typedef struct {                // "new" bit-block bit-stream pointer
    UINT8 JGPTR BitPtr;         // pointer to next byte to access in bit-block
    UINTW BitCnt;               // next *BitPtr bit, 7(hi bit) to 0(low bit)
    UINTW ByteCnt;              // bytes remaining in blk (including *BitPtr)
} JG_BIT_STREAM;

typedef struct {
	UINT8 JGPTR BufPtr;			// buffer pointer
	UINTW BufLeft;				// bytes remaining (0-n) starting at BufPtr
} JG_SIZED_PTR;

typedef struct {                // Vector description structure
    INT16 JGPTR Codebook;       // 4x4 block code book table
    UINT8 JGPTR Data;           // ptr to vector of CodeBook indexes
} VQ_DATA;

typedef struct {                // edge information structure
    UINT16 FirstBlock;          // absolute 1st-panel-block index
    UINT16 BlocksPerPanel;      // blocks per panel
    UINT16 NEdges;              // ??? undocumented ???
    UINT16 BlocksPerRow;        // number of blocks per panel row
    UINT16 NextEdgeBlock;       // next edge block's absolute position
    UINT16 JGPTR Offsets;       // ptr to offsets of following blocks
} EDGE_INFO;

// Portable color representations - when viewed as 32-bit values:
//
//   JG0RGB:   [31..24] = 0, [23..16] = Red, [15..8] = Green, [7..0] = Blue.
//   JG0YUV:   [31..24] = 0, [23..16] = Y,   [15..8] = U,     [7..0] = V.
//   JG0RGB16: [15..15] = 0, [14..10] = Red, [ 9..5] = Green, [4..0] = Blue.
//   JGRGB8:   [7..5] = Red, [ 4..2] = Green, [1..0] = Blue.

#define JG0RGB_UNDEFINED 0xffffffff

typedef UINT32 JG0RGB;
typedef UINT32 JG0YUV;
typedef UINT16 JG0RGB16;
typedef UINT8  JGRGB8;

// Structures for palettes, color data, ...
// If you are going to used these in arrays, (for palettes or images),
// make sure the 3 byte structures are packed tightly.

typedef struct {        // Used to define an RGB color in 3 bytes.
    UINT8 red;
    UINT8 green;
    UINT8 blue;
} JG_RGB;

typedef struct {        // Used to define an RGB color in 4 bytes.
    UINT8 red;
    UINT8 green;
    UINT8 blue;
    UINT8 flags;        // Don't care field. Named "flags" after Windows.
} JG_RGBX;

typedef struct {        // Used to define a color in 3 bytes. (RGB backwards)
    UINT8 blue;
    UINT8 green;
    UINT8 red;
} JG_BGR;

typedef struct {        // Used to define a color in 4 bytes. (RGB backwards)
    UINT8 blue;
    UINT8 green;
    UINT8 red;
    UINT8 flags;        // Don't care field.  Named "flags" after windows.
} JG_BGRX;

typedef struct {
    UINT8 y;            // Luminance Component.
    UINT8 u;            // U. Color difference. Usually offset by +128.
    UINT8 v;            // V. Color difference. Usually offset by +128.
} JG_YUV;

// JG_CCCXPAL is used to define 4 byte palette entry where the first three
// components may be any colorspace/order and the fourth is ignored.
typedef struct {
	UINT8   c0;
	UINT8   c1;
	UINT8   c2;
	UINT8   flags;
} JG_CCCXPAL;

// JG_CCCPAL is used to define 3 byte palette entry where the components
// may be any colorspace/order.
typedef struct {
	UINT8   c0;
	UINT8   c1;
	UINT8   c2;
} JG_CCCPAL;

// Pixel Formats
#define JG_PIXEL_UNDEFINED   0 // Undefined
#define JG_PIXEL_1BIT        1 // 1-bit index into a 2 color palette
#define JG_PIXEL_4BIT        2 // 4-bit index into a 16 color palette
#define JG_PIXEL_8BIT        3  // 8-bit index into a 256 color palette
#define JG_PIXEL_555         4  // JG0RGB16
#define JG_PIXEL_BGR         5  // JG_BGR
#define JG_PIXEL_YUV         6  // JG_YUV
#define JG_PIXEL_0RGB        7  // JG0RGB
#define JG_PIXEL_SPLIT_RGB   8  // Separate 8-bit components: R, G, then B
#define JG_PIXEL_SPLIT_YUV   9  // Separate 8-bit components: Y, U, then V
#define JG_PIXEL_332         10 // JGRGB8
#define JG_PIXEL_MASK        11 // 1-bit mask (1=image)


#ifdef __cplusplus
  }
#endif

#endif

/*----------------------------------------------------------------------------
;
; End of jgtypes.h
;
;---------------------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msdaipper.h ===
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: IPP_E_FIRST
//
// MessageText:
//
//  Internet Publishing Provider first error message
//
#define IPP_E_FIRST                      0x40048000L

//
// MessageId: IPP_E_SYNCCONFLICT
//
// MessageText:
//
//  The server resource has changed since the local copy on your computer was obtained.
//
#define IPP_E_SYNCCONFLICT               0xC0048003L

//
// MessageId: IPP_E_FILENOTDIRTY
//
// MessageText:
//
//  The copy of the resource on your computer has not been modified since it was downloaded from the server.
//
#define IPP_E_FILENOTDIRTY               0xC0048004L

//
// MessageId: IPP_E_MARKFOROFFLINE_FAILED
//
// MessageText:
//
//  The attempt to mark or unmark the resource for offline use failed.
//
#define IPP_E_MARKFOROFFLINE_FAILED      0xC0048006L

//
// MessageId: IPP_E_OFFLINE
//
// MessageText:
//
//  The requested operation could not be completed because the resource is offline.
//
#define IPP_E_OFFLINE                    0xC0048007L

//
// MessageId: IPP_E_UNSYNCHRONIZED
//
// MessageText:
//
//  The requested operation could not be completed because the resource has been modified
//  on your computer but has not been synchronized with the server.
//
#define IPP_E_UNSYNCHRONIZED             0xC0048008L

//
// MessageId: IPP_E_SERVERTYPE_NOT_SUPPORTED
//
// MessageText:
//
//  This server type is not currently supported.
//
#define IPP_E_SERVERTYPE_NOT_SUPPORTED   0xC004800AL

//
// MessageId: IPP_E_MDAC_VERSION
//
// MessageText:
//
//  The Microsoft Data Access Components (MDAC) are either not present on this computer or are an old version. (MSDAIPP 1.0 requires MDAC 2.1)
//
#define IPP_E_MDAC_VERSION               0xC004800DL

//
// MessageId: IPP_E_COLLECTIONEXISTS
//
// MessageText:
//
//  The move or copy operation failed because a collection with that name already exists.
//
#define IPP_E_COLLECTIONEXISTS           0xC004800EL

//
// MessageId: IPP_E_CANNOTCREATEOFFLINE
//
// MessageText:
//
//  The requested resource could not be created because parent cache entry does not exist.
//
#define IPP_E_CANNOTCREATEOFFLINE        0xC004800FL

//
// MessageId: IPP_E_STATUS_CANNOTCOMPLETE
//
// MessageText:
//
//  This is an internal MSDAIPP.DLL error.
//
#define IPP_E_STATUS_CANNOTCOMPLETE      0xC0048101L

//
// MessageId: IPP_E_RESELECTPROVIDER
//
// MessageText:
//
//  This is an internal MSDAIPP.DLL error.
//
#define IPP_E_RESELECTPROVIDER           0xC0048102L

//
// MessageId: IPP_E_CLIENTMUSTEMULATE
//
// MessageText:
//
//  This is an internal MSDAIPP.DLL error.
//
#define IPP_E_CLIENTMUSTEMULATE          0xC0048103L

//
// MessageId: IPP_S_WEAKRESERVE
//
// MessageText:
//
//  This is an internal MSDAIPP.DLL error.
//
#define IPP_S_WEAKRESERVE                0x00048104L

//
// MessageId: IPP_S_TRUNCATED
//
// MessageText:
//
//  This is an internal MSDAIPP.DLL error.
//
#define IPP_S_TRUNCATED                  0x00048105L

//
// MessageId: IPP_E_LAST
//
// MessageText:
//
//  Internet Publishing Provider last error message
//
#define IPP_E_LAST                       0x40048106L
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\jgdw.h ===
/*----------------------------------------------------------------------------
;
; jgdw.h -- JGDW decoder API
;
; Copyright (c) 1994-1996 Johnson-Grace Company, all rights reserved
;
; This file contains all the defines necessary to interface the
; Johnson-Grace decompressor.
;
;---------------------------------------------------------------------------*/

#ifndef JGDW_H
#define JGDW_H 1

#ifdef _MAC
#include <Types.h>
#include <Palettes.h>
#include <QuickDraw.h>
#include <QDOffscreen.h>
#else
#pragma warning(disable:4201)
#include <windows.h>
#pragma warning(default:4201)
#endif

#include "jgtypes.h"

#ifdef __cplusplus
extern "C" {         /* Indicate C declarations for C++ */
#endif


#define JG_ARTIMAGE_INFO		JG_RAWIMAGE_INFO
#define JgGetImageHandleDIB		JgGetImage
#define JgGetMaskDIB			JgGetMask
#define NormalUpdateRect		OldRect

#ifdef _MAC

#define JGDW_CALL

typedef struct JGDW_RECORD_TAG JGDW_RECORD;
typedef JGDW_RECORD JGPTR	JGDW_HDEC;

typedef GWorldPtr			JGDW_HBITMAP;
typedef Rect				JGDW_RECT;
typedef RGBColor			JGDW_COLOR;
typedef ColorInfo			JGDW_PALETTEENTRY;

#else

#if defined(_WIN32) || defined(__FLAT__) /* 16/32 bit compatibility */
  #ifndef JGDW_DECLSPEC
    #define JGDW_DECLSPEC __declspec(dllimport)
  #endif
  #define JGDW_CALL JGDW_DECLSPEC WINAPI
#else
  #ifndef JGDW_DECLSPEC
    #define JGDW_DECLSPEC _export
  #endif
  #define JGDW_CALL JGDW_DECLSPEC WINAPI
#endif

typedef HGLOBAL				JGDW_HDEC;
typedef HGLOBAL				JGDW_HBITMAP;
typedef RECT				JGDW_RECT;
typedef PALETTEENTRY		JGDW_COLOR;
typedef PALETTEENTRY		JGDW_PALETTEENTRY;

#endif

typedef struct JGDW_CONTEXT JGDW_CONTEXT;
typedef JGDW_CONTEXT JGPTR JGDW_HCONTEXT;


#define JG_HEADER_SIZE      40  /* Min # of bytes for JgQueryArtImage() */

/*
** Note: the Decode library returns status codes as integers.
** Zero is returned for success.  A non-zero return means that some
** exception occurred.  Non-documented exceptions should be treated as
** non-recoverable errors.  In this case the application should print the
** full integer value to aid support after the product is in the field.
**
** The application can determine the class of the exception by masking
** off the high order bits of the word. See JgTypes.h for JG_ERR_xxx
** defines.
**
** Final Note: Currently all nonzero returns should be treated as
** non-recoverable errors.
*/

#define JGD_STATUS_SUCCESS      0
#define JGD_STATUS_MEMERR       (300 | JG_ERR_MEMORY)
#define JGD_STATUS_BADARG       (301 | JG_ERR_ARG)
#define JGD_STATUS_ERROR        (302 | JG_ERR_STATUS)
#define JGD_STATUS_NOPALETTE    (303 | JG_ERR_STATUS)
#define JGD_STATUS_BADDATA      (304 | JG_ERR_DATA)
#define JGD_STATUS_IERROR       (305 | JG_ERR_CHECK)
#define JGD_STATUS_TOOWIDE      (306 | JG_ERR_ARG)

                                /* Not Valid because not enough data */
#define JGD_STATUS_INVALID      (307 | JG_ERR_ARG)      

                                /* Unsupported version of compression */
#define JGD_STATUS_BADVERSION   (308 | JG_ERR_VERSION)   
                                /* Unsupported Sub Version of file */
#define JGD_STATUS_BADSUBVER    (309 | JG_ERR_VERSION)  
                                /* File segments in wrong order */
#define JGD_STATUS_BADORDER     (310 | JG_ERR_DATA)     
                                /* Segment is shorter than expected */
#define JGD_STATUS_SHORTSEG     (311 | JG_ERR_DATA)     
                                /* Input Buffer is shorter than necessary */
#define JGD_STATUS_SHORTBUF     (312 | JG_ERR_DATA)     
                                /* Decodeable with some degradation */ 
#define JGD_STATUS_OLDRESOURCE  (313 | JG_ERR_STATUS)   
                                /* Decodeable with extreme degradation */
#define JGD_STATUS_NORESOURCE   (314 | JG_ERR_STATUS)   
                                /* Not decodeable because missing resource */
#define JGD_STATUS_BADRESOURCE  (315 | JG_ERR_STATUS)   
                                /* Resource not found */
#define JGD_STATUS_NOTFOUND     (316 | JG_ERR_STATUS)   
                                /* The Resource data is corrupted */
#define JGD_STATUS_BADRCDATA    (317 | JG_ERR_DATA)     

#define JGD_STATUS_READY        (318 | JG_ERR_STATUS)
#define JGD_STATUS_WAITING      (319 | JG_ERR_STATUS)
#define JGD_STATUS_DONE         (320 | JG_ERR_STATUS)

                                /* CB Patterns Missing */
#define JGD_STATUS_NOPATTERNS   (321 | JG_ERR_STATUS)
                                /* Data is not in ART format */
#define JGD_STATUS_NOTART       (322 | JG_ERR_STATUS)
                                /* End of file found */
#define JGD_STATUS_EOF          (323 | JG_ERR_STATUS)
                                /* Result is too big */
#define JGD_STATUS_TOOBIG       (324 | JG_ERR_STATUS) 
				/* Invalid state for requested operation */
#define JGD_STATUS_BADSTATE     (325 | JG_ERR_STATE)
				/* Invalid or corrupted handle */
#define JGD_STATUS_BADHANDLE	(326 | JGD_STATUS_BADARG)
#define JGD_STATUS_LIB_NOT_FOUND (327 | JG_ERR_STATUS)
#define JGD_STATUS_UNSUPPORTED	(328 | JG_ERR_DATA)
#define JGD_STATUS_UNKNOWN		(329 | JG_ERR_DATA)
#define JGD_STATUS_OBSOLETE	(330 | JG_ERR_VERSION)
#define JGD_STATUS_BADGAMMA	(331 | JG_ERR_ARG) /* Bad gamma argument(s) */

/*
** These defines are used to select the various image decoding options.
*/

#define JG_OPTION_DITHER        0x0001  /* To Request dithering */
#define JG_OPTION_USEDEFAULT_PALETTE 0x0002  /* To force Default Palette */
#define JG_OPTION_FULLIMAGE     0x0008  /* To request full image */
#define JG_OPTION_BACKGROUNDCOLOR 0x10  /* To enable Background color */
#define JG_OPTION_INHIBIT_AUDIO   0x20  /* To disable audio, if any */
#define JG_OPTION_ONEPASS       0x0080  /* To request one pass decoding. */
#define JG_OPTION_MASK_BITMAP   0x0100  /* Create transparency mask 1=opaque */
#define JG_OPTION_IMAGEFORMAT	0x0200  /* Decode specific image format */
#define JG_OPTION_GAMMACORRECT	0x0400  /* Perform gamma correction */
#define JG_OPTION_COMMONDEVICE	0x0800  /* Mac only: use common GDevice */
#define JG_OPTION_TRANSINDEX	0x1000  /* Enables TransIndex field */


/*
** These defines indicate the type of palettizing actually done by
** the decoder.  They are returned in JgGetImageInfo().
*/

#define JG_PALETTE_MODE_OFF     0  /* No Palette, 24-bit */
#define JG_PALETTE_MODE_OPT     1  /* Use Optimal Palette, if Possible */
#define JG_PALETTE_MODE_DEFAULT 2  /* Use the input default palette */
#define JG_PALETTE_MODE_332     3  /* Use the standard 332 palette */

#define JG_POSTSCALE_LONGSIDE   0x0001  /* Do Post Scaling by long side */
#define JG_POSTSCALE_X          0x0002  /* Do Post Scaling in X */
#define JG_POSTSCALE_Y          0x0004  /* Do Post Scaling in Y */
#define JG_POSTSCALE_BESTFIT    0x0008  /* Do Post Scale with BestFit method */

// Use these defines for both GammaIn and GammaOut
#define JG_GAMMA_NONE			100  /* No gamma correction */
#define JG_GAMMA_MAC			180  /* Correction required for Mac = 1.8 */
#define JG_GAMMA_PC				250  /* Correction required for PC = 2.5 */

typedef struct {
    UINTW nSize;            /* Size of this structure, set be caller */
    UINTW ColorDepth;       /* Color depth to use (4, 8, or 24) */
    UINTW DecodeOptions;    /* Decoding Options */
    JGDW_PALETTEENTRY JGPTR DefaultPalette; /* Default Palette, or NULL if none */
    UINTW PaletteSize;      /* Size of Default Palette, if any */
    UINTW SplashDupFactor;  /* Replication Factor of Miniature in Full */
                           /*    image; 0=Off, >100=Full Size */
    JGBOOL bTrueSplash;      /* Save splash image until completely rdy */
    UINTW PostScaleFlags;   /* Defines Post Scale.  Or of JG_POSTSCALE_xxx */ 
    UINTW ScaledLongSide;   /* Used for Post scale, for JG_POSTSCALE_LONGSIDE */
    UINTW ScaledX;          /* Used for Post scale, for JG_POSTSCALE_X */
    UINTW ScaledY;          /* Used for Post scale, for JG_POSTSCALE_Y */
    JGDW_COLOR BackgroundColor; /* Used to specify background color */
    UINTW AudioOptions;     /* Defined elsewhere (in JGAW.H) */
	JGFOURCHAR ImageFormat;/* Specify image format or 'auto' for autodetect */
	UINTW GammaIn;          /* Default input gamma correction */
	UINTW GammaOut;         /* Desired output gamma correction */
    UINTW TransIndex;       /* Make this color transparent */
} JG_DECOMPRESS_INIT;

typedef struct {
    UINTW  nSize;                /* Size of this structure, set by caller */
    JGBOOL  bError;              /* Out: True if error detected which
                                    prevents further decoding */
    JGBOOL  bImageDone;          /* True if no further input required */
    JGBOOL  bNewNormalPixels;    /* True if Pixels ready in normal image */
    JGBOOL  Reserved1;
    JGDW_RECT  OldRect;          /* For compatibility */
    JGDW_RECT  UpdateRect;       /* Update region of image */
    UINTW  PaletteMode;          /* Type of palettizing being done */
    JGERR  iErrorReason;         /* Status code for error, if any */
    JGFOURCHAR ImageFormat;      /* Format of compressed image */
    UINTW	PaletteColors;	     /* Number of colors in palette */
    UINTW TransIndex;		     /* Index of transparent color (0xffff=none) */
} JG_DECOMPRESS_INFO;

typedef struct {
    UINTW  nSize;                /* Size of this structure, set by caller */
    UINTW  Version;              /* File's Version */
    UINTW  SubVersion;           /* File's SubVersion */
    JGBOOL  Decodeable;          /* Nonzero if file can be decoded */
                                 /* The following elements are only */
                                 /* Valid if the image is decodeable */
    UINTW  Rows;                 /* Actual Rows at compress time */
    UINTW  Cols;                 /* Actual Cols at compress time */
    JGBOOL  HasPalette;          /* If Nonzero, image contains a palette */
    JGBOOL  HasOverlays;         /* If Nonzero, image has enhancements */
    JGFOURCHAR ImageFormat;      /* Four-character image type code */
    UINTW  ColorDepth;           /* Native color depth of image */
} JG_RAWIMAGE_INFO;

/*
** The following are prototypes to Decoder functions.
*/

#ifdef __CFM68K__
 #pragma import on
#endif

//JGERR JGDW_CALL JgSetMemCallbacks(
//	void * (* JGFUNC memAlloc)(UINT32 size),	/* malloc */
//	void (* JGFUNC memFree)(void *ptr)			/* free */
//);

JGERR JGDW_CALL JgSetDecompressResourceBuffer(
    UINT8 JGPTR pBuffer,               /* The pointer to the resource buffer */
    UINT32 BufSize                 /* The size of the buffer */
);


/* The pointer returned by JgGetDecompressCaps points to an array of */
/* JG_READER_DESC structures.  A last dummy element exists with .nSize == 0 */
JGERR JGDW_CALL JgGetDecompressCaps(
	JG_READER_DESC JGPTR JGPTR FormatList /* Pointer to reader list. */
);


JGERR JGDW_CALL JgCreateDecompressContext(
    JGDW_HCONTEXT JGPTR hContext,        // OUT: context handle
    JG_DECOMPRESS_INIT JGPTR InitStruct  // IN: filled init structure
);

JGERR JGDW_CALL JgCreateDecompressor(
    JGDW_HDEC JGPTR hDec,                // OUT: decompression handle
    JGDW_HCONTEXT hContext,              // IN: context handle
    JG_DECOMPRESS_INIT JGPTR Init        // IN: null, or override of context
);

JGERR JGDW_CALL JgDestroyDecompressor(
    JGDW_HDEC hDec                       // IN: decompression handle
);

JGERR JGDW_CALL JgDestroyDecompressContext(
    JGDW_HCONTEXT hContext               // IN: context handle
);

JGERR JGDW_CALL JgInitDecompress(
    JGDW_HDEC JGPTR hJgImageOutput,        /* A pntr to recve the Img handle. */
    JG_DECOMPRESS_INIT JGPTR InitStruct  /* A filled init structure */
);

JGERR JGDW_CALL JgQueryArtImage(
    UINT8 JGHPTR pBuf,      /* First bytes of the compressed image */
    UINT32 nBufSize              /* Size of Buffer */
);

JGERR JGDW_CALL JgGetImageInfo(
    UINT8 JGHPTR pBuf,      /* First bytes of the compressed image */
    UINT32 nBufSize,             /* Number of bytes in buffer */
    JG_RAWIMAGE_INFO JGPTR Info
);

JGERR JGDW_CALL JgDecompressDone(
    JGDW_HDEC hJgImage              /* Handle to Decompress Struct */
);

JGERR JGDW_CALL JgGetImage(
    JGDW_HDEC hJgImage,             /* Handle to Decompression Structure */
    JGDW_HBITMAP JGPTR hBitmap      /* Output Handle to bitmap, if it exists */
);

JGERR JGDW_CALL JgDecompressImageBlock(
    JGDW_HDEC hJgImage,           /* Handle to Decompress Struct */
    UINT8 JGHPTR pImageBuf, /* Input buffer of compressed image data */
    UINT32 nBufSize,             /* Number of bytes of data in buffer */
    JGBOOL JGPTR bNewData          /* True if new data are available */
);

JGERR JGDW_CALL JgGetDecompressInfo(
    JGDW_HDEC hJgImage,             /* Handle to Decompress Struct */
    JG_DECOMPRESS_INFO JGPTR Info  /* Out: Filled Info struct */
);

JGERR JGDW_CALL JgGetDecoderVersion(
    char JGPTR Version
);

JGERR JGDW_CALL JgGetMiniatureOffset(
    UINT8 JGHPTR pBuf,      /* Entire compressed image */
    UINT32 nBufSize,             /* Size of compressed image */
    UINT32 JGPTR Offset              /* Output Offset to End of Miniature */
);

JGERR JGDW_CALL JgGetMask(
	JGDW_HDEC hJgImage,           /* Handle to Decompression Structure */
    JGDW_HBITMAP JGPTR hMask      /* Output Handle to Mask, if it exists */
);


JGERR JGDW_CALL JgSetDebug(JGDW_HDEC hJgVars,
                        UINTW DebugOptions);

/*
** New (8/95) Lossless decompression definitions.
*/

#ifndef JG_LOSSLESS_INFO_DEFINED // (also defined in jgew.h)
#define JG_LOSSLESS_INFO_DEFINED 1
typedef struct {
	UINT16 nSize;                /* Size of structure in bytes */
	INT16  SearchSize;           /* (Compression control) */
	UINT32 CompressedSize;       /* Total compressed block bytes */
	UINT32 CompressedSoFar;      /* Compressed processed so far */
	UINT32 CompressedLastCall;   /* Compressed processed last call */
	UINT32 DecompressedSize;     /* Total decompressed block bytes */
	UINT32 DecompressedSoFar;    /* Decompressed processed so far */
	UINT32 DecompressedLastCall; /* Decompressed processed last call */
} JG_LOSSLESS_INFO;
#endif

typedef void JGPTR JG_LOSSLESS_HDEC; /* lossless decompression handle type */

JGERR JGDW_CALL JgLosslessDecompressQuery(  /* Interrogate lossless stream */
    UINT8 JGHPTR InBuffer,   /* IN: Beginning of compressed stream */
    UINT32 InBufferSize,         /* IN: Bytes in InBuffer (0-n) */
    JG_LOSSLESS_INFO JGPTR LosslessInfo); /* OUT: Stream info returned here */

JGERR JGDW_CALL JgLosslessDecompressCreate( /* Create decompression handle */
    JG_LOSSLESS_HDEC JGPTR DecHandle);    /* IN: Pointer to new handle */

void JGDW_CALL JgLosslessDecompressDestroy( /* Destroy decompression handle */
    JG_LOSSLESS_HDEC DecHandle); /* IN: Handle from decompress create */

JGERR JGDW_CALL JgLosslessDecompressReset( /* Reset existing handle */
    JG_LOSSLESS_HDEC DecHandle); /* IN: Handle from decompress create */

JGERR JGDW_CALL JgLosslessDecompressBlock( /* decompress block of data */
    JG_LOSSLESS_HDEC DecHandle,  /* IN: Handle from decompress create */
    UINT8 JGHPTR InBuffer,    /* IN: Input (compressed) data */
    UINT32 InBufferSize,          /* IN: Bytes at *InBuffer (0-n) */
    UINT8 JGHPTR OutBuffer,   /* OUT: Output (decompressed result) buff */
    UINT32 OutBufferSize,         /* IN: Free bytes at *OutBuffer */
    JG_LOSSLESS_INFO JGPTR LosslessInfo); /* OUT: Updated info returned here */

JGERR JGDW_CALL JgLosslessDecompressPartitionReset( /* new partition reset */
    JG_LOSSLESS_HDEC DecHandle);  /* IN: Handle from decompress create */

#ifdef __CFM68K__
 #pragma import off
#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\mshtmsvr.h ===
/*++

     Copyright (c) 1998 Microsoft Corporation

     Module Name:
         mshtmsvr.h

     Abstract:
         This header file declares the API for connecting IIS to MSHTML.DLL

     Authors:
         Anand Ramakrishna (anandra)
         Dmitry Robsman (dmitryr)

     Revision History:

--*/

#ifndef _MSHTMSVR_H_
#define _MSHTMSVR_H_

//
//  Callback definitions
//
//

typedef BOOL
(WINAPI *PFN_SVR_WRITER_CALLBACK)(
    VOID *pvSvrContext,             // [in] passed to GetDLText
    void *pvBuffer,                 // [in] data
    DWORD cbBuffer                  // [in] data length (bytes)
    );

typedef BOOL
(WINAPI *PFN_SVR_MAPPER_CALLBACK)(
    VOID *pvSvrContext,             // [in] passed to GetDLText
    CHAR *pchVirtualFileName,       // [in] virtual file name to map
    CHAR *pchPhysicalFilename,      // [in, out] physical file name
    DWORD cchMax                    // [in] buffer size
    );

typedef BOOL
(WINAPI *PFN_SVR_GETINFO_CALLBACK)(
    VOID *pvSvrContext,             // [in] passed to GetDLText
    DWORD dwInfo,                   // [in] One of the SVRINFO_XXXX contants
    CHAR *pchBuffer,                // [in, out] buffer
    DWORD cchMax                    // [in] buffer size
    );

//
//  Constants for GETINFO callback
//
                                        // Example          http://host/page.htm?a=v
#define SVRINFO_PROTOCOL        1       // SERVER_PROTOCOL  HTTP/1.1
#define SVRINFO_HOST            2       // SERVER_NAME      host
#define SVRINFO_PATH            3       // PATH_INFO        /page.htm
#define SVRINFO_PATH_TRANSLATED 4       // PATH_TRANSLATED  c:\wwwroot\page.htm
#define SVRINFO_QUERY_STRING    5       // QUERY_STRING     a=v
#define SVRINFO_PORT            6       // SERVER_PORT      80
#define SVRINFO_METHOD          7       // REQUEST_METHOD   GET
#define SVRINFO_USERAGENT       8       // HTTP_USER_AGENT  Mozilla/4.0 ...

//
//  Constants for Normalized User Agent
//

#define USERAGENT_RESERVED  0xffffffff
#define USERAGENT_DEFAULT   0
#define USERAGENT_IE3       1
#define USERAGENT_IE4       2
#define USERAGENT_NAV5      3
#define USERAGENT_NAV4      4
#define USERAGENT_NAV3      5
#define USERAGENT_IE5       10000

//
//  The API
//
//

#ifdef __cplusplus
extern "C" {
#endif

BOOL WINAPI 
SvrTri_NormalizeUA(
    CHAR  *pchUA,                      // [in] User agent string
    DWORD *pdwUA                       // [out] User agend id
    );

BOOL WINAPI
SvrTri_GetDLText(
    VOID *pvSrvContext,                // [in] Server Context
    DWORD dwUA,                        // [in] User Agent (Normalized)
    CHAR *pchFileName,                 // [in] Physical file name of htm file
    IDispatch *pdisp,                  // [in] OA 'Server' object for scripting
    PFN_SVR_GETINFO_CALLBACK pfnInfo,  // [in] GetInfo callback
    PFN_SVR_MAPPER_CALLBACK pfnMapper, // [in] Mapper callback
    PFN_SVR_WRITER_CALLBACK pfnWriter, // [in] Writer callback
    DWORD *rgdwUAEquiv,                // [in, out] Array of ua equivalences
    DWORD cUAEquivMax,                 // [in] Size of array of ua equiv
    DWORD *pcUAEquiv                   // [out] # of UA Equivalencies filled in
    );

#ifdef __cplusplus
};
#endif

#endif // _MSHTMSVR_H_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\jgplay.h ===
// jgplay.h -- Public Header for ART 3.5 Player
// --------------------------------------------------------------------
// Copyright (c) 1995 Johnson-Grace Company, all rights reserved
//
// Change History
// --------------
// 950820 DLB Original File
// 960426 Eric Rodriguez-Diaz
//		- For Mac only, added import pragmas.
// 960429 Eric Rodriguez-Diaz
//		- Improved import pragmas for Mac.
// 960605 Eric Rodriguez-Diaz
//		- Now taking into account the fact that for the Mac symbol
//		  GENERATINGCFM is always defined in the universal headers.
// 960606 SED Added UI hook functions.
// 960613 SED Added Art file attributes; removed HasAudio, HasImage,
//			  HasMIDI. Added memory calls for UI DLL.  Added Lossless
//			  Decompression calls for ARTDoc. Added memory hooks for
//			  MAC.  Also added memory function struct arg to
//			  JgPlayStartUp for MAC.  Added ShowIsOver, TitleReady,
//			  JGPLAY_ERR_FULL and JGPLAY_MAX_INPUT for Slide Shows.
//			  Added JgPlayFreeImage.
// 960617 SED Added JGPLAY_PALETTE and modifed JgPlayGetPalette to
//			  use it.
// 960618 SED Added the UI Report hook and modified the UI Input hook.
// 960619 SED Removed JgPlayFreeImage.  Modified JgPlayGetImage to
//			  use JGPLAY_IMAGE_REF and JgPlayGetPalette to use
//			  JGPLAY_PALETTE_REF.  Added the JgPlayStopPlay element
//			  argument and the element constants.  Added a Size member
//			  to the JGPLAY_MEMORY structure.  Changed the JGPLAY_SETUP
//			  DefaultPalette member to a JGPLAY_PALETTE_REF.
// 960621 SED Added Number of colors parameter to JgPlayGetPalette.
// 960621 SED Changed JGPLAY_ERR_OLDERROR to JGPLAY_ERR_PREVIOUS.
//			  Removed JGPLAY_ERR_IMGDECODER.
// 960625 SED Added JgPlayPausePlay, JgPlayResumePlay, JgPlaySetPosition
//			  and JgPlayGetPosition.  Removed element-to-stop arg from
//			  JgPlayStopPlay.  Removed StopTime from JgPlayStartPlay and
//			  StopTime from JgPlayStopPlay. Added UI hooks defines for
//			  JgPlayPausePlay and JgPlayResumePlay.
// 960626 SED Added JGHandle to JGPLAY_SETUP structure to support reuse
// 			  of the JGDW context.
// 960628 SED Added PaletteMode and IndexOverride and associated constants
//			  to JGPLAY_SETUP structure.  
// 960708 SED Changed JGPLAY_XXX to JGP_XXX and JgPlayXXX to JgpXXXX.
// 960709 SED Changed JGPTR to JGFAR * and JGHPTR to JGHUGE *.  Changed
//			  BOOLW to UINTW and removed convenience typedefs.
// 960710 Eric Rodriguez-Diaz
//	- For the Mac, now have pragmas forcing power structure alignment.
//	  Not using native alignment because it isn't supported by
//	  the Symantec compilers. Not using mac68k alignment because 68k
//	  is a dying breed.
// 960805 SED Added Slide Show support.
// --------------------------------------------------------------------

#ifndef JGPLAY_H
	#define JGPLAY_H 1

	#ifdef _MAC
		#include <Types.h>
		#include <Palettes.h>
		#include <QuickDraw.h>
		#include <QDOffscreen.h>
	#else
		#pragma warning(disable:4201)
		#include <windows.h>
		#pragma warning(default:4201)
	#endif

	#include "jgtypes.h"	// Include this for basic JG Types
	
	#ifdef __cplusplus
		extern "C" {         	// Indicate C declarations if C++
	#endif
	
	#ifdef _MAC
		// make sure GENERATINGCFM is defined
		#include <ConditionalMacros.h>
		#if GENERATINGCFM
			#pragma import on
		#endif
		// select PowerPC structure alignment
		#pragma options align=power
	#endif
	

	// --------------------------------------------------------------------
	// Error Codes

	#define JGP_ERR_BASE    3000  // Get this from the registor. (not yet)
	#define JGP_SUCCESS     0     // Always true at JG.

	#define JGP_ERR_MEM				((JGP_ERR_BASE +  1) | JG_ERR_MEMORY)
	#define JGP_ERR_INIT			((JGP_ERR_BASE +  2) | JG_ERR_CHECK)
	#define JGP_ERR_BADDATA			((JGP_ERR_BASE +  3) | JG_ERR_DATA)
	#define JGP_ERR_BADARG			((JGP_ERR_BASE +  4) | JG_ERR_ARG)
	#define JGP_ERR_CODECHECK		((JGP_ERR_BASE +  5) | JG_ERR_CHECK)
	#define JGP_ERR_PREVIOUS		((JGP_ERR_BASE +  6) | JG_ERR_ARG)
	#define JGP_ERR_NOTREADY		((JGP_ERR_BASE +  7) | JG_ERR_CHECK)
	#define JGP_ERR_RESOURCE		((JGP_ERR_BASE +  8) | JG_ERR_CHECK)
	#define JGP_ERR_BADSTRUCTSIZE	((JGP_ERR_BASE +  9) | JG_ERR_CHECK)
	#define JGP_ERR_AUDIODECODER	((JGP_ERR_BASE + 10) | JG_ERR_CHECK)
	#define JGP_ERR_MIDIDECODER    	((JGP_ERR_BASE + 11) | JG_ERR_CHECK)
	#define JGP_ERR_VOLUME			((JGP_ERR_BASE + 12) | JG_ERR_CHECK)
	#define JGP_ERR_NONOTE			((JGP_ERR_BASE + 13) | JG_ERR_CHECK)
	#define JGP_ERR_UNSUPPORTED		((JGP_ERR_BASE + 14) | JG_ERR_DATA)
	#define JGP_ERR_NOPALETTE		((JGP_ERR_BASE + 15) | JG_ERR_CHECK)
	#define JGP_ERR_FULL			((JGP_ERR_BASE + 16) | JG_ERR_CHECK)
	#define JGP_ERR_OPENHANDLE		((JGP_ERR_BASE + 17) | JG_ERR_CHECK)
	#define JGP_ERR_NOTAVAILABLE    ((JGP_ERR_BASE + 18) | JG_ERR_ARG)
	#define JGP_ERR_BADSTATE        ((JGP_ERR_BASE + 19) | JG_ERR_ARG)
	#define JGP_ERR_UIMODULE        ((JGP_ERR_BASE + 20) | JG_ERR_UNKNOWN)

	// Error Codes dealing with Library Startup/Shutdown
	#define	JGP_ERR_IGNORED_MEMORY_HOOKS	((JGP_ERR_BASE + 21) | JG_ERR_UNKNOWN)
	#define	JGP_ERR_BAD_SHUTDOWN			((JGP_ERR_BASE + 22) | JG_ERR_UNKNOWN)

	// Max number of input bytes accepted at once by JgpInputStream,
	// one-half a mega byte.
	#define JGP_MAX_INPUT 524288

	// Max length of ART Note
	#define JGP_ARTLENGTH 200

	// --------------------------------------------------------------------
	// Options for scaling.

	#define JGP_SCALE_NONE 		  	0	// No Scaling
	#define JGP_SCALE_EXACT        	1	// Scale to ScaleWidth and ScaleHeight
	#define JGP_SCALE_BESTFIT      	2	// Maintain aspect ratio, use best fit

	// --------------------------------------------------------------------
	// Options for gamma correction.

	#define JGP_GAMMA_NONE		0
	#define JGP_GAMMA_UP		1  	
	#define JGP_GAMMA_DOWN 		2

	// --------------------------------------------------------------------
	// File Types

	#define JGP_UNSUPPORTED 0
	#define JGP_ART	JG4C_ART
	#define JGP_BMP	JG4C_BMP
	#define JGP_GIF	JG4C_GIF
	#define JGP_JPG	JG4C_JPEG

	// --------------------------------------------------------------------
	// File Attributes

	#define JGP_HASIMAGE 			1
	#define JGP_HASAUDIO 		    2
	#define JGP_HASMIDI				4
	#define JGP_HASARTNOTE			8
	#define JGP_HASDYNAMICIMAGES	16
	#define JGP_ISTEMPORAL			32
	#define JGP_HASPAUSE			64
	#define JGP_HASTIMELINE			128

	// --------------------------------------------------------------------
	// Audio Modes.  Choose one of these for playback or zero to choose the
	// mode with the lowest processing cost on the CPU (usually 11K, 16bit).

	#define JGP_AUDIO_DEFAULT	0x0000
	#define JGP_AUDIO_11K_8BIT	0x0001
	#define JGP_AUDIO_11K_16BIT	0x0002
	#define JGP_AUDIO_22K_8BIT	0x0004
	#define JGP_AUDIO_22K_16BIT	0x0008

	// --------------------------------------------------------------------
	// Common UI hooks.

	#define JGP_CLOSEUIHOOK		0	// JgPClose HEAD hook
	#define JGP_STARTUIHOOK		1	// JgPStartPlay TAIL hook
	#define JGP_STOPUIHOOK		2	// JgPStopPlay TAIL hook
	#define JGP_PAUSEUIHOOK		3	// JgPPausePlay TAIL hook
	#define JGP_RESUMEUIHOOK	4	// JgPResumePlay TAIL hook
	#define JGP_MAXUIHOOKS		5	// INCREASE if more hooks are allowed


	// --------------------------------------------------------------------
	// PaletteModes.

	#define JGP_PALETTE_AUTO	0	// Use first available: file, input, 332
	#define JGP_PALETTE_INPUT	1	// Use input palette
	#define JGP_PALETTE_332		2	// Use 332

	// --------------------------------------------------------------------
	// Use this constant to turn off IndexOverride option.

	#define JGP_OVERRIDE_NONE	0xFFFF

	// --------------------------------------------------------------------
	// Typedefs for System dependent Image and Palette data types. 

	#ifndef _MAC
		typedef HGLOBAL JGP_IMAGE_REF;
		typedef HGLOBAL JGP_PALETTE_REF;
	#else
		typedef GWorldPtr JGP_IMAGE_REF;
		typedef PaletteHandle JGP_PALETTE_REF;
	#endif

	// These typedefs must match the jgdw lossless typedefs.

	typedef struct {
		UINT16 nSize;                // Size of structure in bytes
		INT16  SearchSize;           // (Compression control)
		UINT32 CompressedSize;       // Total compressed block bytes
		UINT32 CompressedSoFar;      // Compressed processed so far
		UINT32 CompressedLastCall;   // Compressed processed last call
		UINT32 DecompressedSize;     // Total decompressed block bytes
		UINT32 DecompressedSoFar;    // Decompressed processed so far
		UINT32 DecompressedLastCall; // Decompressed processed last call
	} JGP_LOSSLESS;

	// lossless decompression handle type
	typedef void JGFAR * JGP_LOSSLESS_HANDLE; 


	// --------------------------------------------------------------------
	// JGP_IMG -- Defines the exported image format for the ART file Player.
	// This format is designed to be system independent, but it can carry
	// information that is helpful in the system dependent conversion process.
	// It is also  designed to be very close to JG_IMG which is used by JGIPROC.
	// It can also hold the data in the form of a DIB for windows, or a  GWorld
	// for a MAC.

	typedef struct {
		UINTW Rows;				// Rows, in pixels
		UINTW Cols;				// Cols, in pixels
		UINTW Colordepth;		// Colordepth: 4, 8, 16 or 24
		UINT8 JGHUGE *pPixels;	// Pointer to top row of pixels in this image
		INTW  RowDisp;			// Offset between rows in this image
		UINTW nColors;			// Number of colors in the palette.
		JG_BGRX JGFAR *pPalette;// Pointer to list of colors for palette. 
		void JGFAR *pManager;	// Reserved.  (Internally maintained ptr.)
	} JGP_IMG;

	// --------------------------------------------------------------------
	// JGRECT -- A rectangle structure, defined to be equivalent to the
	// Window's RECT.  Used here to avoid machine dependance.  These rects
	// assume that screen coordinates run top (starting at zero) to bottom
	// (positive increase) and from left (starting at zero) to right 
	// (positive increase).  We also assume that the bottom-right border
	// defined by the structure is not part of the rectanglar area.

	typedef struct {
		INTW left;				// Location of left border
		INTW top;				// Location of top border
		INTW right;				// Location of right border, (plus 1)
		INTW bottom;			// Location of bottom border, (plus 1)
	} JGRECT;

	// --------------------------------------------------------------------
	// JGP_REPORT -- This structure is used to obtain information
	// about a specific show which can be idenitified by an instance handle.

	typedef struct {
		UINTW	Size;				// Size of this struct in bytes, set by caller
		UINTW   ImageValid;			// True if the image is valid.
		UINT32  CurrentTime;		// Current Time of play, in ms.
		UINT32  AvailPlayTime;		// Total Play Time in buffer from start to end.	
		UINTW   DoingAudio;			// Non-zero if audio is playing.
		UINTW   DoingMIDI;			// Non-zero if MIDI is playing.
		UINTW   ShowStalled;		// If nothing else to do, ... Waiting for input
		UINTW   GotEOF;				// If this show has received an EOF mark
		UINTW   IsDone;				// The presentation is finished.
		UINTW   UpdateImage;		// Non-zero if the image needs an update.
		UINTW   TransparentIndex;	// Index of transparent color.
		JGRECT	UpdateRect;			// Area in image that has changed.
		UINTW	ShowIsOver;			// The show is finished playing.
		UINTW	TitleReady;			// Title page is ready.
		UINTW	IsPaused;			// The show is paused.
		UINTW   IsPlaying;			// The show is playing
	} JGP_REPORT;

	// --------------------------------------------------------------------
	// JGP_SETUP -- This structure is used to communicate the input parameters
	// for the playing of a show.

	typedef struct {
		UINTW Size;				// Size of this struct in bytes, set by caller
		UINTW ColorDepth;		// Output colordepth  (Allowed: 4, 8, 16 or 24)
		UINTW InhibitImage;		// If true, no image returned.
		UINTW InhibitAudio;		// If true, no audio played.
		UINTW InhibitMIDI;		// If true, no MIDI played.
		UINTW InhibitDither;	// If true, no dithering is done
		UINTW InhibitSplash;	// If true, no splash with image	
		UINTW AudioMode;		// Desired Audio mode, or zero for default.
		UINTW CreateMask;		// If true, create mask imacdge
		UINTW ScaleImage;		// Scaling option
		UINTW ScaleWidth;		// Scaled width
		UINTW ScaleHeight;		// Scaled height
		UINTW  GammaAdjust;		// Gamma adjustment value
	    JG_RGBX BackgroundColor;// Background color under the image.
	    JGP_PALETTE_REF DefaultPalette; // Default Palette, NULL if none
		UINTW PaletteSize; 		// Number of Colors in Default Palette, or 0
		JGHANDLE OldHandle;		// Handle for image context reuse
		UINTW	PaletteMode;	// Specifies palette mode
		UINTW	IndexOverride;	// Transparent override/create index
		UINTW	TempMemory;		// TRUE to use temporary memory 
		UINT32  InputBaud;		// Input Baud if known by app. Zero otherwise.
	} JGP_SETUP;

	// --------------------------------------------------------------------
	// JGP_STREAM -- This structure is used to return information
	// about the ART Stream

	typedef struct {
		UINTW Size;				// Size of this struct in bytes, set by caller
		UINTW MajorVersion;		// Major version of the ART tstream.
		UINTW MinorVersion;		// Subversion of the ART stream.
		UINTW CanDecode;		// TRUE if this module can decode the stream.
		UINT32 Filetype;		// JGPL_xxx returned constant
		UINT32 Attributes;		// File attributes	
		UINT32 PlayTime;		// Playtime if temporal, non-realtime stream.
		JGRECT Dimensions;		// Native dimensions of stream if has image(s).
		UINTW  ColorDepth;		// Color Depth of Stream (4,8,16,24)
		UINT32 UpdateRate;		// Minimum ms between heartbeat calls.
		UINT32 Baud;			// Minimum input baud rate.
		UINT32 BytesToTitle;	// Number of bytes needed to get title image.	
		UINTW  SubType;			// ART subtype ID
	} JGP_STREAM;

	// --------------------------------------------------------------------
	// JGP_TEST -- This structure contains the information about the
	// test to see if the CPU and other environment is up to doing the 
	// show in real-time.

	typedef struct {
		UINTW	Size;				// Size of this struct in bytes, set by caller
		UINTW   CanDoAudio;			// Non-zero if audio can be part of the show.
		UINTW   CanDoMIDI;		    // Non-zero if MIDI	 can be part of the show.
		UINTW   PrefAudioMode;		// Preferred audio mode.
	} JGP_TEST;

	// --------------------------------------------------------------------
	// JGP_NOTE -- This structure contains information about the ART note.

	typedef struct {
		UINTW Size;					// Size of this struct in bytes, set by caller
		UINTW Display;				// If true ART note should always be displayed
		UINTW Copyrighted;			// If true the note is copyrighted
	} JGP_NOTE;


	// --------------------------------------------------------------------
	// Generic palette pointer for MAC and Windows

	typedef void JGFAR * JGP_PALETTE;

	// --------------------------------------------------------------------
	// Memory function typedefs

	typedef void JGFAR * (JGFFUNC * JGMEMALLOC) (
		UINT32 RequestedSize		// In: Number of bytes to allocate
	);

	typedef void JGFAR * (JGFFUNC * JGMEMREALLOC) (
		void JGFAR *pBuffer,		// In: Allocated buffer pointer
		UINT32 RequestedSize		// In: Number of bytes to allocate
	);

	typedef void (JGFFUNC * JGMEMFREE) (
		void  JGFAR *pBuffer		// In: Allocated buffer pointer
	);

	typedef struct {
		UINTW Size;					// Size of this struct in bytes, set by caller
		JGMEMALLOC MemAlloc;		// Allocation function pointer
		JGMEMREALLOC MemReAlloc;    // Re-Allocation function pointer
		JGMEMFREE MemFree;          // Free function pointer
	} JGP_MEMORY;

	// --------------------------------------------------------------------
	// UI hooks typedef and constants.

	typedef JGERR (JGFFUNC * JGP_UIHOOK) (
		JGHANDLE Handle,		// In: Instance handle	
		JGERR	 Err			// In: Calling function status
	);

	typedef JGERR (JGFFUNC * JGP_INPUT_UIHOOK) (
		JGHANDLE Handle,		// In: Instance handle
		UINT8  JGHUGE *pARTStream,// In: Pointer to the ART Stream
		UINT32   nBytes,		// In: Number of bytes being input	
		JGERR	 iErr			// In: Calling function status
	);

	typedef JGERR (JGFFUNC * JGP_REPORT_UIHOOK) (
		JGHANDLE Handle,		// In: Instance handle	
		JGP_REPORT JGFAR *pReport,// In: Report structure
		JGERR	 Err			// In: Calling function status
	);

	// --------------------------------------------------------------------
	// JgpStartUp{} -- This function can be called when the library is
	// started.  Under Windows, the LibMain does this.

	JGERR JGFFUNC JgpStartUp(
		JGP_MEMORY JGFAR *pMemFcns);	// In: Memory function struct pointer

	// --------------------------------------------------------------------
	// JgpShutDown{} -- This function can be called to shut the player 
	// down.  Under Windows, the WEP function does this.

	JGERR JGFFUNC JgpShutDown(void);

	// --------------------------------------------------------------------
	// JgpHeartBeat{} -- This function is used to keep the Show going.
	// This function or JgpInputStream must be called every 100 ms.

	JGERR JGFFUNC JgpHeartBeat(
		JGHANDLE SHandle);		// In: Show handle

	// --------------------------------------------------------------------
	// JgpQueryStream{} -- This is a utility function, which if given the
	// first part of an ART Stream will return useful info about it.  Usually,
	// the data to fill the info structure can be found in the first
	// 100 bytes of a Stream, but not necessarily.

	JGERR JGFFUNC JgpQueryStream(
		UINT8 JGHUGE *pARTStream,		// In: ART Stream
		UINT32 nARTStreamBytes,			// In: Size of ARTStream in Bytes
		JGP_STREAM JGFAR *pInfo); 		// Out: Info structure

	// --------------------------------------------------------------------
	// JgpDoTest{} -- Perform a test to determine ability of CPU to do
	// the show in real-time.

	JGERR JGFFUNC JgpDoTest(
		JGP_TEST JGFAR *pInfo);			// In: Info struct to be filled

	// --------------------------------------------------------------------
	// JgpOpen{} -- This function is used to obtain a handle for a
	// show.

	JGERR JGFFUNC JgpOpen(
		JGHANDLE JGFAR *pSHandle,	// Out: Place to receive handle   
		JGP_SETUP JGFAR *pSetup);	// In: The setup structure

	// --------------------------------------------------------------------
	// JgpClose{} -- This function frees all the resources associated
	// with a show.  If the show (and sound) is playing, it is immediately
	// stopped.

	JGERR JGFFUNC JgpClose(
		JGHANDLE SHandle);			// In: Show handle

	// --------------------------------------------------------------------
	// JgpSetEOFMark{} -- Sets and EOF mark for the ART stream.
	// This tells the player that no more data is expected for this stream,
	// and if, during play, the EOF mark is reached, to shut down play.
	// Otherwise, if an out-of-data condition occures, play goes into a
	// suppended state which continues to hold onto output resources of the
	// computer.

	JGERR JGFFUNC JgpSetEOFMark(
		JGHANDLE SHandle);			// In: Show handle

	// --------------------------------------------------------------------
	// JgpInputStream{} -- Accepts the Show stream. Call in a loop!
	// Must be called every XX ms even if there is no new data.
	//
	// Note, by calling this routine, the show does not automatically
	// start.  Call JgpStartShow to do this.

	JGERR JGFFUNC JgpInputStream(
		JGHANDLE SHandle,			// In: Show Handle
		UINT8  JGHUGE *pARTStream,	// In: Pointer to the ART Stream
		UINT32 nBytes);				// In: Number of bytes being input

	// --------------------------------------------------------------------
	// JgpStartPlay{} -- Starts play of a show at an arbitrary point
	// in the stream.  The arbitrary point in the stream can be specifed
	// using the JgpSetPostion. The call can be made anytime after the
	// stream is opened, even if there is no data.  In a download situation,
	// the show is not started until there is enough data to play at the
	// given starttime plus 5 seconds.

	JGERR JGFFUNC JgpStartPlay(
		JGHANDLE SHandle);			// In: Show Handle

	// --------------------------------------------------------------------
	// JgpResumePlay{} -- Starts play of an ART stream at the point
	// in the stream at which it was paused.

	UINTW JGFFUNC JgpResumePlay(
		JGHANDLE SHandle);			// In: Show Handle

	// --------------------------------------------------------------------
	// JgpPausePlay{} -- Causes play of an ART stream to stop.  The
	// stop time is saved for later resuming.
		
	UINTW JGFFUNC JgpPausePlay(
		JGHANDLE SHandle);			// In: Show Handle

	// --------------------------------------------------------------------
	// JgpStopPlay{} -- Stops the play of the show.   

	JGERR JGFFUNC JgpStopPlay(
		JGHANDLE SHandle);			// In: Show Handle
		
	// --------------------------------------------------------------------
	// JgpReleaseSound{} -- Disconnects the instance from the sound devices.

	JGERR JGFFUNC JgpReleaseSound(
		JGHANDLE SHandle);			// In: Show Handle	

	// --------------------------------------------------------------------
	// JgpResumeSound{} -- Reconnects the instance to the sound devices.

	JGERR JGFFUNC JgpResumeSound(
		JGHANDLE SHandle);			// In: Show Handle	
	
#ifdef _MAC
	// --------------------------------------------------------------------
	// JgpGetVolume{} -- Gets sound volume for a show instance.
	
	JGERR JGFFUNC JgpGetVolume(
		JGHANDLE SHandle,
		UINTW JGFAR *pnOutVolume
	);
	
	// --------------------------------------------------------------------
	// JgpSetVolume{} -- Sets sound volume for a show instance.
	
	JGERR JGFFUNC JgpSetVolume(
		JGHANDLE SHandle,
		UINTW nInVolume
	);
#endif

	// --------------------------------------------------------------------
	// JgpSetPosition{} -- This function sets the stop/pause position
	// time associated with the Show instance.
		
	JGERR JGFFUNC JgpSetPosition(
		JGHANDLE SHandle,				// In: Show Handle
		UINT32 nPosition);				// In: Position

	// --------------------------------------------------------------------
	// JgpGetPosition{} -- This function gets the stop/pause position
	// time associated with the Show instance.
		
	JGERR JGFFUNC JgpGetPosition(
		JGHANDLE SHandle,				// In: Show Handle
		UINT32 JGFAR *pPosition);		// Out: Position

	// --------------------------------------------------------------------
	// JgpGetImage{} -- Returns a system independent representation of
	// the image.  
	//
	// Depending on the platform phImg is either a GWorldPtr or a huge
	// pointer to a DIB.  The caller must lock the returned HGLOBAL to use
	// the DIB.

	JGERR JGFFUNC JgpGetImage(
		JGHANDLE SHandle,				// In: Show handle            
		JGP_IMAGE_REF JGFAR *phImg);	// Out: Handle to Image memory

	// --------------------------------------------------------------------
	// JgpGetMask{} -- Returns a system independent representation of
	// the mask image.  
	//
	// Depending on the platform phImg is either a BitMapPtr or a huge
	// pointer to a DIB.  The caller must lock the returned HGLOBAL to use
	// the DIB.

	JGERR JGFFUNC JgpGetMask(
		JGHANDLE SHandle,				// In: Show handle
		JGP_IMAGE_REF JGFAR *phImg);	// Out: Handle to Image memory

	// --------------------------------------------------------------------
	// JgpGetPalette{} -- Returns a system independent representation
	// of the image palette.  
	//
	// The caller is responsible for freeing the memory buffer space.
	// Depending on the platform pPal is either a pointer to a PaletteHandle
	// or a pointer to PALETTEENTRY structures.

	JGERR JGFFUNC JgpGetPalette(
		JGHANDLE SHandle,				// In: Show Handle
		JGP_PALETTE_REF JGFAR *phPal, 	// Out: Palette data	
		UINTW JGFAR	*pnColors);			// Out: Number of colors

	// --------------------------------------------------------------------
	// JgpGetARTNote{} -- Returns the ART note.

	JGERR JGFFUNC JgpGetARTNote(
		UINT8 JGHUGE *pARTStream,		// In: ART Stream
		UINT32 nARTStreamBytes,			// In: Size of ARTStream in Bytes
		JGP_NOTE JGFAR *pNote,			// Out: Info structure
		UINT8 JGFAR *pData);				// Out: Note text

	// --------------------------------------------------------------------
	// JgpGetReport{} -- Reports the activity of a show, given it's handle.
	// This is usually called after 'bImageUpdate' becomes true.

	JGERR JGFFUNC JgpGetReport(
		JGHANDLE SHandle,			// In:  Show Handle
		JGP_REPORT JGFAR *pReport);	// Out: Structure to receive the report
		
	// --------------------------------------------------------------------
	// JgpSetUiHook{} -- This function sets a UI function hook.
		
	JGERR JGFFUNC JgpSetUiHook(
		JGP_UIHOOK pHook,				// In: Ui Hook function
		UINTW UiHook);					// In: Hook tag

	// --------------------------------------------------------------------
	// JgpGetUiHook{} -- This function returns a UI function hook.

	JGERR JGFFUNC JgpGetUiHook(
		JGP_UIHOOK JGFAR *hHook,			// Out: Ui Hook function
		UINTW UiHook);					// In: Hook tag	
		
	// --------------------------------------------------------------------
	// JgpSetUiInputHook{} -- This function sets the JgpInputStream
	// UI function hook.
		
	JGERR JGFFUNC JgpSetUiInputHook(
		JGP_INPUT_UIHOOK pHook);		// In: Ui Hook function

	// --------------------------------------------------------------------
	// JgpGetUiInputHook{} -- This function returns the JgpInputStream
	// UI function hook.

	JGERR JGFFUNC JgpGetUiInputHook(
		JGP_INPUT_UIHOOK JGFAR *hHook);	// Out: Ui Hook function

	// --------------------------------------------------------------------
	// JgpSetUiReportHook{} -- This function sets the JgpGetReport
	// UI function hook.
		
	JGERR JGFFUNC JgpSetUiReportHook(
		JGP_REPORT_UIHOOK pHook);		// In: Ui Hook function

	// --------------------------------------------------------------------
	// JgpGetUiReportHook{} -- This function returns the JgpGetReport
	// UI function hook.

	JGERR JGFFUNC JgpGetUiReportHook(
		JGP_REPORT_UIHOOK JGFAR *hHook);	// Out: Ui Hook function

	// --------------------------------------------------------------------
	// JgpSetUiLong{} -- This function sets a UI long value associated
	// with the Show instance.
		
	JGERR JGFFUNC JgpSetUiLong(
		JGHANDLE SHandle,				// In: Show Handle
		UINT32 LongVal);				// In: Long value

	// --------------------------------------------------------------------
	// JgpGetUiLong{} -- This function returns the UI long value
	// associated with the Show instance.

	JGERR JGFFUNC JgpGetUiLong(
		JGHANDLE SHandle,				// In: Show Handle
		UINT32 JGFAR *pLongVal);		// Out: Long value
		
	// --------------------------------------------------------------------
	// JgpAlloc{} -- This function allocates memory.  The returned
	// JGFAR * can be cast to HUGE.

	void JGFAR * JGFFUNC JgpAlloc(
		JGHANDLE SHandle,               // In: Show Handle
		UINT32 nBytes);					// In: Bytes to allocate

	// --------------------------------------------------------------------
	// JgpReAlloc{} -- This function re-allocates memory.  The returned
	// JGFAR * can be cast to HUGE.

	void JGFAR * JGFFUNC JgpReAlloc(
		JGHANDLE SHandle,               // In: Show Handle
		void JGFAR *pMem,				// In: Old pointer
		UINT32 nBytes);					// In: Bytes to allocate

	// --------------------------------------------------------------------
	// JgpFree{} -- This function frees memory.

	void JGFFUNC JgpFree(
		JGHANDLE SHandle,               // In: Show Handle
		void JGFAR *pMem);				// In: Pointer to free

	// --------------------------------------------------------------------
	// JgpLosslessQuery{} -- This function interrogates a lossless stream.

	JGERR JGFFUNC JgpLosslessQuery(
	    UINT8 JGHUGE *pInBuffer,   		// In: Beginning of compressed stream
	    UINT32 InBufferSize,         	// In: Bytes in InBuffer (0-n)
	    JGP_LOSSLESS JGFAR *pLosslessInfo); // Out: Stream info returned here

	// --------------------------------------------------------------------
	// JgpLosslessCreate{} -- This function creates a decompression handle.

	JGERR JGFFUNC JgpLosslessCreate(
	    JGP_LOSSLESS_HANDLE JGFAR *pDecHandle); // In: Pointer to new handle

	// --------------------------------------------------------------------
	// JgpLosslessDestroy{} -- This function destroys a decompression handle.

	void JGFFUNC JgpLosslessDestroy(
	    JGP_LOSSLESS_HANDLE DecHandle); // In: Handle from decompress create

	// --------------------------------------------------------------------
	// JgpLosslessReset{} -- This function resets an existing handle.

	JGERR JGFFUNC JgpLosslessReset(
	    JGP_LOSSLESS_HANDLE DecHandle); // In: Handle from decompress create

	// --------------------------------------------------------------------
	// JgpLosslessBlock{} -- This function decompresses a block of data.

	JGERR JGFFUNC JgpLosslessBlock(
	    JGP_LOSSLESS_HANDLE DecHandle,	// In: Handle from decompress create
	    UINT8 JGHUGE *pInBuffer,    	// In: Input (compressed) data
	    UINT32 InBufferSize,          	// In: Bytes at *InBuffer (0-n)
	    UINT8 JGHUGE *pOutBuffer,   	// Out: Output (decompressed result) buff
	    UINT32 OutBufferSize,         	// In: Free bytes at *OutBuffer
	    JGP_LOSSLESS JGFAR *pLosslessInfo);// Out: Updated info returned here

	// --------------------------------------------------------------------
	// JgpLosslessPartitionReset{} -- This function does a new partition reset.

	JGERR JGFFUNC JgpLosslessPartitionReset(
	    JGP_LOSSLESS_HANDLE DecHandle);  // In: Handle from decompress create 
	    

	// ====================================================================
	// UNDOCUMENTED/UNSUPPORTED FUNCTIONS (Below) -- (Use at your own risk...)
	// ====================================================================

	// --------------------------------------------------------------------
	// JGP_PERFORMANCE -- This structure returns performance data.  It can
	// be used to map the CPU and Memory requirements for a Slideshow...

	typedef struct {  
		UINTW Size;				// Size of this structure, in bytes, set by caller
		UINTW IsSS;				// If a slideshow is being played
		UINTW IsValidInfo;		// If info in this structure contains valid info.
		UINTW Mode;				// Show Mode: 0=not Init, 1=Preload, 2=Playable
		UINT32 CPUTime;			// CPU Time (of call)
		UINT32 ShowTime;		// ShowTime for this measurement
		UINTW nAssets;			// Number of known assets.               
		UINT32 nAssetBytes;		// Allocated bytes for storing raw assets
		UINTW nVisPics;			// Number of visible pictures
		UINTW nCashedPics;		// Number of cashed pictures
		UINT32 nPixelBytes;		// Number of allocated bytes for pixels        
		UINT32 tCPUUsed;		// Total ms of CPU useage since last call...
	} JGP_PERFORMANCE;


	// --------------------------------------------------------------------
	// JgpGetPerformance{} -- Reports the performance measurement of a show.

	JGERR JGFFUNC JgpGetPerformance(
		JGHANDLE SHandle,						// In:  Show Handle
		JGP_PERFORMANCE JGFAR *pPerformance);	// Out: Structure to receive the report

	
	#ifdef _MAC
		// restore structure alignment mode
		#pragma options align=reset
		#if GENERATINGCFM
			#pragma import reset
		#endif
	#endif

	#ifdef __cplusplus
		}
	#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\objext.h ===
#ifndef UNIX
#pragma pack(push, 8)
#endif 
//+------------------------------------------------------------------------
//  
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//  
//  File:       objext.h
//  
//  Contents:   header file for Object Extensions interfaces
//  
//              6/24/96 (dbau) removed IServiceProvider (to servprov.h)
//-------------------------------------------------------------------------

#ifndef __OBJEXT_H
#define __OBJEXT_H

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

///////////////////////////////////////////////////////////////////////////
//
// forward declares
//
///////////////////////////////////////////////////////////////////////////
#ifdef __cplusplus
interface IFilterMembers;
#else  // __cplusplus
typedef interface IFilterMembers IFilterMembers;
#endif  // __cplusplus

///////////////////////////////////////////////////////////////////////////
//
// Object Extension Interfaces
//
///////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////
//
// Standard Services and Interfaces
//
///////////////////////////////////////////////////////////////////////////

//-------------------------------------------------------------------------
//  SLicensedClassManager
//    VBA provides this service to it's components and hosts to optimize
//    registry access and to insulate them from licensing concerns
//
//  interfaces implemented:
//    ILicensedClassManager
//-------------------------------------------------------------------------
// { 6d5140d0-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_IRequireClasses, 0x6d5140d0, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);

#undef  INTERFACE
#define INTERFACE  IRequireClasses
DECLARE_INTERFACE_(IRequireClasses, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IRequireClasses methods ***
    STDMETHOD(CountRequiredClasses)(THIS_
                    /* [out] */ ULONG * pcClasses ) PURE;
    STDMETHOD(GetRequiredClasses)(THIS_
                  /* [in]  */ ULONG index,
                  /* [out] */ CLSID * pclsid ) PURE;
};

// { 6d5140d4-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_ILicensedClassManager, 0x6d5140d4, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);
#define SID_SLicensedClassManager  IID_ILicensedClassManager

#undef  INTERFACE
#define INTERFACE  ILicensedClassManager
DECLARE_INTERFACE_(ILicensedClassManager, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** ILicensedClassManager methods ***
    STDMETHOD(OnChangeInRequiredClasses)(THIS_
                     /* [in] */ IRequireClasses *pRequireClasses) PURE;
};


//-------------------------------------------------------------------------
//  SLocalRegistry Service
//    VBA provides this service to it's components and hosts to optimize
//    registry access and to insulate them from licensing concerns
//
//  interfaces implemented:
//    ILocalRegistry
//-------------------------------------------------------------------------

// { 6d5140d3-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_ILocalRegistry, 0x6d5140d3, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);
#define SID_SLocalRegistry IID_ILocalRegistry

#undef  INTERFACE
#define INTERFACE  ILocalRegistry
DECLARE_INTERFACE_(ILocalRegistry, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** ILocalRegistry methods ***
    STDMETHOD(CreateInstance)(THIS_
                  /* [in]  */ CLSID      clsid,     
                  /* [in]  */ IUnknown * punkOuter,
                  /* [in]  */ REFIID     riid,
                  /* [in]  */ DWORD      dwFlags,
                  /* [out] */ void **    ppvObj ) PURE;
    STDMETHOD(GetTypeLibOfClsid)(THIS_
                 /* [in]  */ CLSID       clsid,
                 /* [out] */ ITypeLib ** ptlib ) PURE;
    STDMETHOD(GetClassObjectOfClsid)(THIS_
                     /* [in]  */ REFCLSID clsid,
                                 /* [in]  */ DWORD    dwClsCtx,
                     /* [in]  */ LPVOID   lpReserved,
                     /* [in]  */ REFIID   riid,
                     /* [out] */ void **  ppcClassObject ) PURE;
};



#endif // __OBJEXT_H

#ifndef UNIX
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\oledbtri.h ===
/* This file contains a few interfaces that were once part of OLE-DB
    but that Trident still uses.  Cut-and-paste from oledb.h (version below).
*/

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu May 22 17:05:14 1997
 */
/* Compiler settings for C:\oledb\PRIVATE\OLEDB\IDL\oledb.idl:
    Oicf (OptLev=i2), W1, Zp2, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifdef WIN16
#define OLEDBVER 0x0200
#endif

#ifndef __oledbtri_h__
#define __oledbtri_h__

#ifdef __cplusplus
extern "C"{
#endif 

#ifndef __IRowsetExactScroll_FWD_DEFINED__
#define __IRowsetExactScroll_FWD_DEFINED__
typedef interface IRowsetExactScroll IRowsetExactScroll;
#endif 	/* __IRowsetExactScroll_FWD_DEFINED__ */


#ifndef __IRowsetNewRowAfter_FWD_DEFINED__
#define __IRowsetNewRowAfter_FWD_DEFINED__
typedef interface IRowsetNewRowAfter IRowsetNewRowAfter;
#endif 	/* __IRowsetNewRowAfter_FWD_DEFINED__ */


/* header files for imported files */
#ifndef WIN16
#include "wtypes.h"
#endif
#include "oaidl.h"
#include "transact.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


/****************************************
 * Generated header for interface: __MIDL_itf_oledb_0082
 * at Thu May 22 17:05:14 1997
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


#if( OLEDBVER >= 0x0200 )


extern RPC_IF_HANDLE __MIDL_itf_oledb_0082_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oledb_0082_v0_0_s_ifspec;

#ifndef __IRowsetExactScroll_INTERFACE_DEFINED__
#define __IRowsetExactScroll_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowsetExactScroll
 * at Thu May 22 17:05:14 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_IRowsetExactScroll;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a7f-2a1c-11ce-ade5-00aa0044773d")
    IRowsetExactScroll : public IRowsetScroll
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetExactPosition( 
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ DBBKMARK cbBookmark,
            /* [size_is][in] */ const BYTE __RPC_FAR *pBookmark,
            /* [out] */ DBCOUNTITEM __RPC_FAR *pulPosition,
            /* [out] */ DBCOUNTITEM __RPC_FAR *pcRows) = 0;
        
    };
    
#else 	/* C style interface */

#error "C style interface not maintained"

#endif 	/* C style interface */

#endif 	/* __IRowsetExactScroll_INTERFACE_DEFINED__ */
#endif /* OLEDBVER >= 0200 */


/****************************************
 * Generated header for interface: __MIDL_itf_oledb_0087
 * at Thu May 22 17:05:14 1997
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


//@@@+ V2.0
#if( OLEDBVER >= 0x0200 )


extern RPC_IF_HANDLE __MIDL_itf_oledb_0087_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oledb_0087_v0_0_s_ifspec;

#ifndef __IRowsetNewRowAfter_INTERFACE_DEFINED__
#define __IRowsetNewRowAfter_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowsetNewRowAfter
 * at Thu May 22 17:05:14 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_IRowsetNewRowAfter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a71-2a1c-11ce-ade5-00aa0044773d")
    IRowsetNewRowAfter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetNewDataAfter( 
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ DBBKMARK cbbmPrevious,
            /* [size_is][in] */ const BYTE __RPC_FAR *pbmPrevious,
            /* [in] */ HACCESSOR hAccessor,
            /* [in] */ BYTE __RPC_FAR *pData,
            /* [out] */ HROW __RPC_FAR *phRow) = 0;
        
    };
    
#else 	/* C style interface */

#error "C style interface not maintained"

#endif 	/* C style interface */
#endif 	/* __IRowsetNewRowAfter_INTERFACE_DEFINED__ */
#endif /* OLEDBVER >= 0200 */


#if( OLEDBVER >= 0x0200 )
// IID_IRowsetExactScroll		= {0x0c733a7f,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IRowsetNewRowAfter		= {0x0c733a71,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
#endif // OLEDBVER >= 0x0200

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\oleacc.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0158 */
/* at Wed May 13 11:31:10 1998
 */
/* Compiler settings for oleacc.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef UNIX
#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#else
#define MIDL_INTERFACE(x) struct
#endif

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __oleacc_h__
#define __oleacc_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IAccessible_FWD_DEFINED__
#define __IAccessible_FWD_DEFINED__
typedef interface IAccessible IAccessible;
#endif 	/* __IAccessible_FWD_DEFINED__ */


#ifndef __IAccessibleHandler_FWD_DEFINED__
#define __IAccessibleHandler_FWD_DEFINED__
typedef interface IAccessibleHandler IAccessibleHandler;
#endif 	/* __IAccessibleHandler_FWD_DEFINED__ */


#ifndef __IAccessible_FWD_DEFINED__
#define __IAccessible_FWD_DEFINED__
typedef interface IAccessible IAccessible;
#endif 	/* __IAccessible_FWD_DEFINED__ */


#ifndef __IAccessibleHandler_FWD_DEFINED__
#define __IAccessibleHandler_FWD_DEFINED__
typedef interface IAccessibleHandler IAccessibleHandler;
#endif 	/* __IAccessibleHandler_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_oleacc_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// OLEACC.H
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// Typedefs
//=--------------------------------------------------------------------------=

typedef LRESULT (STDAPICALLTYPE *LPFNLRESULTFROMOBJECT)(REFIID riid, WPARAM wParam, LPUNKNOWN punk);
typedef HRESULT (STDAPICALLTYPE *LPFNOBJECTFROMLRESULT)(LRESULT lResult, REFIID riid, WPARAM wParam, void** ppvObject);
typedef HRESULT (STDAPICALLTYPE *LPFNACCESSIBLEOBJECTFROMWINDOW)(HWND hwnd, DWORD dwId, REFIID riid, void** ppvObject);
typedef HRESULT (STDAPICALLTYPE *LPFNACCESSIBLEOBJECTFROMPOINT)(POINT ptScreen, IAccessible** ppacc, VARIANT* pvarChild);
typedef HRESULT (STDAPICALLTYPE *LPFNCREATESTDACCESSIBLEOBJECT)(HWND hwnd, LONG idObject, REFIID riid, void** ppvObject);
typedef HRESULT (STDAPICALLTYPE *LPFNACCESSIBLECHILDREN)(IAccessible* paccContainer, LONG iChildStart,LONG cChildren,VARIANT* rgvarChildren,LONG* pcObtained);

//=--------------------------------------------------------------------------=
// GUIDs
//=--------------------------------------------------------------------------=

DEFINE_GUID(LIBID_Accessibility,	0x1ea4dbf0, 0x3c3b, 0x11cf, 0x81, 0x0c, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(IID_IAccessible,		0x618736e0, 0x3c3d, 0x11cf, 0x81, 0x0c, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(IID_IAccessibleHandler, 0x03022430, 0xABC4, 0x11d0, 0xBD, 0xE2, 0x00, 0xAA, 0x00, 0x1A, 0x19, 0x53);

//=--------------------------------------------------------------------------=
// MSAA API Prototypes
//=--------------------------------------------------------------------------=

STDAPI_(LRESULT) LresultFromObject(REFIID riid, WPARAM wParam, LPUNKNOWN punk);
STDAPI          ObjectFromLresult(LRESULT lResult, REFIID riid, WPARAM wParam, void** ppvObject);
STDAPI          WindowFromAccessibleObject(IAccessible*, HWND* phwnd);
STDAPI          AccessibleObjectFromWindow(HWND hwnd, DWORD dwId, REFIID riid, void **ppvObject);
STDAPI          AccessibleObjectFromEvent(HWND hwnd, DWORD dwId, DWORD dwChildId, IAccessible** ppacc, VARIANT* pvarChild);
STDAPI          AccessibleObjectFromPoint(POINT ptScreen, IAccessible ** ppacc, VARIANT* pvarChild);
STDAPI          CreateStdAccessibleObject(HWND hwnd, LONG idObject, REFIID riid, void** ppvObject);
STDAPI          AccessibleChildren (IAccessible* paccContainer, LONG iChildStart,LONG cChildren, VARIANT* rgvarChildren,LONG* pcObtained);

STDAPI_(UINT)   GetRoleTextA(DWORD lRole, LPSTR lpszRole, UINT cchRoleMax);
STDAPI_(UINT)   GetRoleTextW(DWORD lRole, LPWSTR lpszRole, UINT cchRoleMax);
#ifdef UNICODE
#define GetRoleText     GetRoleTextW
#else
#define GetRoleText     GetRoleTextA
#endif // UNICODE

STDAPI_(UINT)   GetStateTextA(DWORD lStateBit, LPSTR lpszState, UINT cchState);
STDAPI_(UINT)   GetStateTextW(DWORD lStateBit, LPWSTR lpszState, UINT cchState);
#ifdef UNICODE
#define GetStateText    GetStateTextW
#else
#define GetStateText    GetStateTextA
#endif // UNICODE

//=--------------------------------------------------------------------------=
// Interface Definitions
//=--------------------------------------------------------------------------=



extern RPC_IF_HANDLE __MIDL_itf_oleacc_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oleacc_0000_v0_0_s_ifspec;

#ifndef __IAccessible_INTERFACE_DEFINED__
#define __IAccessible_INTERFACE_DEFINED__

/* interface IAccessible */
/* [unique][dual][hidden][uuid][object] */ 

#define	DISPID_ACC_PARENT	( -5000 )

#define	DISPID_ACC_CHILDCOUNT	( -5001 )

#define	DISPID_ACC_CHILD	( -5002 )

#define	DISPID_ACC_NAME	( -5003 )

#define	DISPID_ACC_VALUE	( -5004 )

#define	DISPID_ACC_DESCRIPTION	( -5005 )

#define	DISPID_ACC_ROLE	( -5006 )

#define	DISPID_ACC_STATE	( -5007 )

#define	DISPID_ACC_HELP	( -5008 )

#define	DISPID_ACC_HELPTOPIC	( -5009 )

#define	DISPID_ACC_KEYBOARDSHORTCUT	( -5010 )

#define	DISPID_ACC_FOCUS	( -5011 )

#define	DISPID_ACC_SELECTION	( -5012 )

#define	DISPID_ACC_DEFAULTACTION	( -5013 )

#define	DISPID_ACC_SELECT	( -5014 )

#define	DISPID_ACC_LOCATION	( -5015 )

#define	DISPID_ACC_NAVIGATE	( -5016 )

#define	DISPID_ACC_HITTEST	( -5017 )

#define	DISPID_ACC_DODEFAULTACTION	( -5018 )

typedef /* [unique] */ IAccessible __RPC_FAR *LPACCESSIBLE;

#define	NAVDIR_MIN	( 0 )

#define	NAVDIR_UP	( 0x1 )

#define	NAVDIR_DOWN	( 0x2 )

#define	NAVDIR_LEFT	( 0x3 )

#define	NAVDIR_RIGHT	( 0x4 )

#define	NAVDIR_NEXT	( 0x5 )

#define	NAVDIR_PREVIOUS	( 0x6 )

#define	NAVDIR_FIRSTCHILD	( 0x7 )

#define	NAVDIR_LASTCHILD	( 0x8 )

#define	NAVDIR_MAX	( 0x9 )

#define	SELFLAG_NONE	( 0 )

#define	SELFLAG_TAKEFOCUS	( 0x1 )

#define	SELFLAG_TAKESELECTION	( 0x2 )

#define	SELFLAG_EXTENDSELECTION	( 0x4 )

#define	SELFLAG_ADDSELECTION	( 0x8 )

#define	SELFLAG_REMOVESELECTION	( 0x10 )

#define	SELFLAG_VALID	( 0x1f )

#define	STATE_SYSTEM_UNAVAILABLE	( 0x1 )

#define	STATE_SYSTEM_SELECTED	( 0x2 )

#define	STATE_SYSTEM_FOCUSED	( 0x4 )

#define	STATE_SYSTEM_PRESSED	( 0x8 )

#define	STATE_SYSTEM_CHECKED	( 0x10 )

#define	STATE_SYSTEM_MIXED	( 0x20 )

#define	STATE_SYSTEM_INDETERMINATE	( STATE_SYSTEM_MIXED )

#define	STATE_SYSTEM_READONLY	( 0x40 )

#define	STATE_SYSTEM_HOTTRACKED	( 0x80 )

#define	STATE_SYSTEM_DEFAULT	( 0x100 )

#define	STATE_SYSTEM_EXPANDED	( 0x200 )

#define	STATE_SYSTEM_COLLAPSED	( 0x400 )

#define	STATE_SYSTEM_BUSY	( 0x800 )

#define	STATE_SYSTEM_FLOATING	( 0x1000 )

#define	STATE_SYSTEM_MARQUEED	( 0x2000 )

#define	STATE_SYSTEM_ANIMATED	( 0x4000 )

#define	STATE_SYSTEM_INVISIBLE	( 0x8000 )

#define	STATE_SYSTEM_OFFSCREEN	( 0x10000 )

#define	STATE_SYSTEM_SIZEABLE	( 0x20000 )

#define	STATE_SYSTEM_MOVEABLE	( 0x40000 )

#define	STATE_SYSTEM_SELFVOICING	( 0x80000 )

#define	STATE_SYSTEM_FOCUSABLE	( 0x100000 )

#define	STATE_SYSTEM_SELECTABLE	( 0x200000 )

#define	STATE_SYSTEM_LINKED	( 0x400000 )

#define	STATE_SYSTEM_TRAVERSED	( 0x800000 )

#define	STATE_SYSTEM_MULTISELECTABLE	( 0x1000000 )

#define	STATE_SYSTEM_EXTSELECTABLE	( 0x2000000 )

#define	STATE_SYSTEM_ALERT_LOW	( 0x4000000 )

#define	STATE_SYSTEM_ALERT_MEDIUM	( 0x8000000 )

#define	STATE_SYSTEM_ALERT_HIGH	( 0x10000000 )

#define	STATE_SYSTEM_PROTECTED	( 0x20000000 )

#define	STATE_SYSTEM_ONLY_REDUNDANT	( 0x40000000 )

#define	STATE_SYSTEM_VALID	( 0x7fffffff )

#define	ROLE_SYSTEM_TITLEBAR	( 0x1 )

#define	ROLE_SYSTEM_MENUBAR	( 0x2 )

#define	ROLE_SYSTEM_SCROLLBAR	( 0x3 )

#define	ROLE_SYSTEM_GRIP	( 0x4 )

#define	ROLE_SYSTEM_SOUND	( 0x5 )

#define	ROLE_SYSTEM_CURSOR	( 0x6 )

#define	ROLE_SYSTEM_CARET	( 0x7 )

#define	ROLE_SYSTEM_ALERT	( 0x8 )

#define	ROLE_SYSTEM_WINDOW	( 0x9 )

#define	ROLE_SYSTEM_CLIENT	( 0xa )

#define	ROLE_SYSTEM_MENUPOPUP	( 0xb )

#define	ROLE_SYSTEM_MENUITEM	( 0xc )

#define	ROLE_SYSTEM_TOOLTIP	( 0xd )

#define	ROLE_SYSTEM_APPLICATION	( 0xe )

#define	ROLE_SYSTEM_DOCUMENT	( 0xf )

#define	ROLE_SYSTEM_PANE	( 0x10 )

#define	ROLE_SYSTEM_CHART	( 0x11 )

#define	ROLE_SYSTEM_DIALOG	( 0x12 )

#define	ROLE_SYSTEM_BORDER	( 0x13 )

#define	ROLE_SYSTEM_GROUPING	( 0x14 )

#define	ROLE_SYSTEM_SEPARATOR	( 0x15 )

#define	ROLE_SYSTEM_TOOLBAR	( 0x16 )

#define	ROLE_SYSTEM_STATUSBAR	( 0x17 )

#define	ROLE_SYSTEM_TABLE	( 0x18 )

#define	ROLE_SYSTEM_COLUMNHEADER	( 0x19 )

#define	ROLE_SYSTEM_ROWHEADER	( 0x1a )

#define	ROLE_SYSTEM_COLUMN	( 0x1b )

#define	ROLE_SYSTEM_ROW	( 0x1c )

#define	ROLE_SYSTEM_CELL	( 0x1d )

#define	ROLE_SYSTEM_LINK	( 0x1e )

#define	ROLE_SYSTEM_HELPBALLOON	( 0x1f )

#define	ROLE_SYSTEM_CHARACTER	( 0x20 )

#define	ROLE_SYSTEM_LIST	( 0x21 )

#define	ROLE_SYSTEM_LISTITEM	( 0x22 )

#define	ROLE_SYSTEM_OUTLINE	( 0x23 )

#define	ROLE_SYSTEM_OUTLINEITEM	( 0x24 )

#define	ROLE_SYSTEM_PAGETAB	( 0x25 )

#define	ROLE_SYSTEM_PROPERTYPAGE	( 0x26 )

#define	ROLE_SYSTEM_INDICATOR	( 0x27 )

#define	ROLE_SYSTEM_GRAPHIC	( 0x28 )

#define	ROLE_SYSTEM_STATICTEXT	( 0x29 )

#define	ROLE_SYSTEM_TEXT	( 0x2a )

#define	ROLE_SYSTEM_PUSHBUTTON	( 0x2b )

#define	ROLE_SYSTEM_CHECKBUTTON	( 0x2c )

#define	ROLE_SYSTEM_RADIOBUTTON	( 0x2d )

#define	ROLE_SYSTEM_COMBOBOX	( 0x2e )

#define	ROLE_SYSTEM_DROPLIST	( 0x2f )

#define	ROLE_SYSTEM_PROGRESSBAR	( 0x30 )

#define	ROLE_SYSTEM_DIAL	( 0x31 )

#define	ROLE_SYSTEM_HOTKEYFIELD	( 0x32 )

#define	ROLE_SYSTEM_SLIDER	( 0x33 )

#define	ROLE_SYSTEM_SPINBUTTON	( 0x34 )

#define	ROLE_SYSTEM_DIAGRAM	( 0x35 )

#define	ROLE_SYSTEM_ANIMATION	( 0x36 )

#define	ROLE_SYSTEM_EQUATION	( 0x37 )

#define	ROLE_SYSTEM_BUTTONDROPDOWN	( 0x38 )

#define	ROLE_SYSTEM_BUTTONMENU	( 0x39 )

#define	ROLE_SYSTEM_BUTTONDROPDOWNGRID	( 0x3a )

#define	ROLE_SYSTEM_WHITESPACE	( 0x3b )

#define	ROLE_SYSTEM_PAGETABLIST	( 0x3c )

#define	ROLE_SYSTEM_CLOCK	( 0x3d )


EXTERN_C const IID IID_IAccessible;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("618736e0-3c3d-11cf-810c-00aa00389b71")
    IAccessible : public IDispatch
    {
    public:
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_accParent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispParent) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_accChildCount( 
            /* [retval][out] */ long __RPC_FAR *pcountChildren) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_accChild( 
            /* [in] */ VARIANT varChild,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispChild) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_accName( 
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ BSTR __RPC_FAR *pszName) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_accValue( 
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ BSTR __RPC_FAR *pszValue) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_accDescription( 
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ BSTR __RPC_FAR *pszDescription) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_accRole( 
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarRole) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_accState( 
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarState) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_accHelp( 
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ BSTR __RPC_FAR *pszHelp) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_accHelpTopic( 
            /* [out] */ BSTR __RPC_FAR *pszHelpFile,
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ long __RPC_FAR *pidTopic) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_accKeyboardShortcut( 
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ BSTR __RPC_FAR *pszKeyboardShortcut) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_accFocus( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarChild) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_accSelection( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarChildren) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_accDefaultAction( 
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ BSTR __RPC_FAR *pszDefaultAction) = 0;
        
        virtual /* [id][hidden] */ HRESULT STDMETHODCALLTYPE accSelect( 
            /* [in] */ long flagsSelect,
            /* [optional][in] */ VARIANT varChild) = 0;
        
        virtual /* [id][hidden] */ HRESULT STDMETHODCALLTYPE accLocation( 
            /* [out] */ long __RPC_FAR *pxLeft,
            /* [out] */ long __RPC_FAR *pyTop,
            /* [out] */ long __RPC_FAR *pcxWidth,
            /* [out] */ long __RPC_FAR *pcyHeight,
            /* [optional][in] */ VARIANT varChild) = 0;
        
        virtual /* [id][hidden] */ HRESULT STDMETHODCALLTYPE accNavigate( 
            /* [in] */ long navDir,
            /* [optional][in] */ VARIANT varStart,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarEndUpAt) = 0;
        
        virtual /* [id][hidden] */ HRESULT STDMETHODCALLTYPE accHitTest( 
            /* [in] */ long xLeft,
            /* [in] */ long yTop,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarChild) = 0;
        
        virtual /* [id][hidden] */ HRESULT STDMETHODCALLTYPE accDoDefaultAction( 
            /* [optional][in] */ VARIANT varChild) = 0;
        
        virtual /* [id][propput][hidden] */ HRESULT STDMETHODCALLTYPE put_accName( 
            /* [optional][in] */ VARIANT varChild,
            /* [in] */ BSTR szName) = 0;
        
        virtual /* [id][propput][hidden] */ HRESULT STDMETHODCALLTYPE put_accValue( 
            /* [optional][in] */ VARIANT varChild,
            /* [in] */ BSTR szValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAccessibleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAccessible __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAccessible __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAccessible __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IAccessible __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IAccessible __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IAccessible __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IAccessible __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_accParent )( 
            IAccessible __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispParent);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_accChildCount )( 
            IAccessible __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcountChildren);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_accChild )( 
            IAccessible __RPC_FAR * This,
            /* [in] */ VARIANT varChild,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispChild);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_accName )( 
            IAccessible __RPC_FAR * This,
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ BSTR __RPC_FAR *pszName);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_accValue )( 
            IAccessible __RPC_FAR * This,
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ BSTR __RPC_FAR *pszValue);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_accDescription )( 
            IAccessible __RPC_FAR * This,
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ BSTR __RPC_FAR *pszDescription);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_accRole )( 
            IAccessible __RPC_FAR * This,
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarRole);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_accState )( 
            IAccessible __RPC_FAR * This,
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarState);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_accHelp )( 
            IAccessible __RPC_FAR * This,
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ BSTR __RPC_FAR *pszHelp);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_accHelpTopic )( 
            IAccessible __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pszHelpFile,
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ long __RPC_FAR *pidTopic);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_accKeyboardShortcut )( 
            IAccessible __RPC_FAR * This,
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ BSTR __RPC_FAR *pszKeyboardShortcut);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_accFocus )( 
            IAccessible __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarChild);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_accSelection )( 
            IAccessible __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarChildren);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_accDefaultAction )( 
            IAccessible __RPC_FAR * This,
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ BSTR __RPC_FAR *pszDefaultAction);
        
        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *accSelect )( 
            IAccessible __RPC_FAR * This,
            /* [in] */ long flagsSelect,
            /* [optional][in] */ VARIANT varChild);
        
        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *accLocation )( 
            IAccessible __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *pxLeft,
            /* [out] */ long __RPC_FAR *pyTop,
            /* [out] */ long __RPC_FAR *pcxWidth,
            /* [out] */ long __RPC_FAR *pcyHeight,
            /* [optional][in] */ VARIANT varChild);
        
        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *accNavigate )( 
            IAccessible __RPC_FAR * This,
            /* [in] */ long navDir,
            /* [optional][in] */ VARIANT varStart,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarEndUpAt);
        
        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *accHitTest )( 
            IAccessible __RPC_FAR * This,
            /* [in] */ long xLeft,
            /* [in] */ long yTop,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarChild);
        
        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *accDoDefaultAction )( 
            IAccessible __RPC_FAR * This,
            /* [optional][in] */ VARIANT varChild);
        
        /* [id][propput][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_accName )( 
            IAccessible __RPC_FAR * This,
            /* [optional][in] */ VARIANT varChild,
            /* [in] */ BSTR szName);
        
        /* [id][propput][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_accValue )( 
            IAccessible __RPC_FAR * This,
            /* [optional][in] */ VARIANT varChild,
            /* [in] */ BSTR szValue);
        
        END_INTERFACE
    } IAccessibleVtbl;

    interface IAccessible
    {
        CONST_VTBL struct IAccessibleVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAccessible_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAccessible_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAccessible_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAccessible_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAccessible_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAccessible_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAccessible_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAccessible_get_accParent(This,ppdispParent)	\
    (This)->lpVtbl -> get_accParent(This,ppdispParent)

#define IAccessible_get_accChildCount(This,pcountChildren)	\
    (This)->lpVtbl -> get_accChildCount(This,pcountChildren)

#define IAccessible_get_accChild(This,varChild,ppdispChild)	\
    (This)->lpVtbl -> get_accChild(This,varChild,ppdispChild)

#define IAccessible_get_accName(This,varChild,pszName)	\
    (This)->lpVtbl -> get_accName(This,varChild,pszName)

#define IAccessible_get_accValue(This,varChild,pszValue)	\
    (This)->lpVtbl -> get_accValue(This,varChild,pszValue)

#define IAccessible_get_accDescription(This,varChild,pszDescription)	\
    (This)->lpVtbl -> get_accDescription(This,varChild,pszDescription)

#define IAccessible_get_accRole(This,varChild,pvarRole)	\
    (This)->lpVtbl -> get_accRole(This,varChild,pvarRole)

#define IAccessible_get_accState(This,varChild,pvarState)	\
    (This)->lpVtbl -> get_accState(This,varChild,pvarState)

#define IAccessible_get_accHelp(This,varChild,pszHelp)	\
    (This)->lpVtbl -> get_accHelp(This,varChild,pszHelp)

#define IAccessible_get_accHelpTopic(This,pszHelpFile,varChild,pidTopic)	\
    (This)->lpVtbl -> get_accHelpTopic(This,pszHelpFile,varChild,pidTopic)

#define IAccessible_get_accKeyboardShortcut(This,varChild,pszKeyboardShortcut)	\
    (This)->lpVtbl -> get_accKeyboardShortcut(This,varChild,pszKeyboardShortcut)

#define IAccessible_get_accFocus(This,pvarChild)	\
    (This)->lpVtbl -> get_accFocus(This,pvarChild)

#define IAccessible_get_accSelection(This,pvarChildren)	\
    (This)->lpVtbl -> get_accSelection(This,pvarChildren)

#define IAccessible_get_accDefaultAction(This,varChild,pszDefaultAction)	\
    (This)->lpVtbl -> get_accDefaultAction(This,varChild,pszDefaultAction)

#define IAccessible_accSelect(This,flagsSelect,varChild)	\
    (This)->lpVtbl -> accSelect(This,flagsSelect,varChild)

#define IAccessible_accLocation(This,pxLeft,pyTop,pcxWidth,pcyHeight,varChild)	\
    (This)->lpVtbl -> accLocation(This,pxLeft,pyTop,pcxWidth,pcyHeight,varChild)

#define IAccessible_accNavigate(This,navDir,varStart,pvarEndUpAt)	\
    (This)->lpVtbl -> accNavigate(This,navDir,varStart,pvarEndUpAt)

#define IAccessible_accHitTest(This,xLeft,yTop,pvarChild)	\
    (This)->lpVtbl -> accHitTest(This,xLeft,yTop,pvarChild)

#define IAccessible_accDoDefaultAction(This,varChild)	\
    (This)->lpVtbl -> accDoDefaultAction(This,varChild)

#define IAccessible_put_accName(This,varChild,szName)	\
    (This)->lpVtbl -> put_accName(This,varChild,szName)

#define IAccessible_put_accValue(This,varChild,szValue)	\
    (This)->lpVtbl -> put_accValue(This,varChild,szValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_get_accParent_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispParent);


void __RPC_STUB IAccessible_get_accParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_get_accChildCount_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pcountChildren);


void __RPC_STUB IAccessible_get_accChildCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_get_accChild_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [in] */ VARIANT varChild,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispChild);


void __RPC_STUB IAccessible_get_accChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_get_accName_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [optional][in] */ VARIANT varChild,
    /* [retval][out] */ BSTR __RPC_FAR *pszName);


void __RPC_STUB IAccessible_get_accName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_get_accValue_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [optional][in] */ VARIANT varChild,
    /* [retval][out] */ BSTR __RPC_FAR *pszValue);


void __RPC_STUB IAccessible_get_accValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_get_accDescription_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [optional][in] */ VARIANT varChild,
    /* [retval][out] */ BSTR __RPC_FAR *pszDescription);


void __RPC_STUB IAccessible_get_accDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_get_accRole_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [optional][in] */ VARIANT varChild,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarRole);


void __RPC_STUB IAccessible_get_accRole_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_get_accState_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [optional][in] */ VARIANT varChild,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarState);


void __RPC_STUB IAccessible_get_accState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_get_accHelp_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [optional][in] */ VARIANT varChild,
    /* [retval][out] */ BSTR __RPC_FAR *pszHelp);


void __RPC_STUB IAccessible_get_accHelp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_get_accHelpTopic_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pszHelpFile,
    /* [optional][in] */ VARIANT varChild,
    /* [retval][out] */ long __RPC_FAR *pidTopic);


void __RPC_STUB IAccessible_get_accHelpTopic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_get_accKeyboardShortcut_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [optional][in] */ VARIANT varChild,
    /* [retval][out] */ BSTR __RPC_FAR *pszKeyboardShortcut);


void __RPC_STUB IAccessible_get_accKeyboardShortcut_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_get_accFocus_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarChild);


void __RPC_STUB IAccessible_get_accFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_get_accSelection_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarChildren);


void __RPC_STUB IAccessible_get_accSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_get_accDefaultAction_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [optional][in] */ VARIANT varChild,
    /* [retval][out] */ BSTR __RPC_FAR *pszDefaultAction);


void __RPC_STUB IAccessible_get_accDefaultAction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_accSelect_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [in] */ long flagsSelect,
    /* [optional][in] */ VARIANT varChild);


void __RPC_STUB IAccessible_accSelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_accLocation_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [out] */ long __RPC_FAR *pxLeft,
    /* [out] */ long __RPC_FAR *pyTop,
    /* [out] */ long __RPC_FAR *pcxWidth,
    /* [out] */ long __RPC_FAR *pcyHeight,
    /* [optional][in] */ VARIANT varChild);


void __RPC_STUB IAccessible_accLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_accNavigate_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [in] */ long navDir,
    /* [optional][in] */ VARIANT varStart,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarEndUpAt);


void __RPC_STUB IAccessible_accNavigate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_accHitTest_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [in] */ long xLeft,
    /* [in] */ long yTop,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarChild);


void __RPC_STUB IAccessible_accHitTest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_accDoDefaultAction_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [optional][in] */ VARIANT varChild);


void __RPC_STUB IAccessible_accDoDefaultAction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_put_accName_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [optional][in] */ VARIANT varChild,
    /* [in] */ BSTR szName);


void __RPC_STUB IAccessible_put_accName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_put_accValue_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [optional][in] */ VARIANT varChild,
    /* [in] */ BSTR szValue);


void __RPC_STUB IAccessible_put_accValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAccessible_INTERFACE_DEFINED__ */


#ifndef __IAccessibleHandler_INTERFACE_DEFINED__
#define __IAccessibleHandler_INTERFACE_DEFINED__

/* interface IAccessibleHandler */
/* [unique][oleautomation][hidden][uuid][object] */ 

typedef /* [unique] */ IAccessibleHandler __RPC_FAR *LPACCESSIBLEHANDLER;


EXTERN_C const IID IID_IAccessibleHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03022430-ABC4-11d0-BDE2-00AA001A1953")
    IAccessibleHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AccessibleObjectFromID( 
            /* [in] */ long hwnd,
            /* [in] */ long lObjectID,
            /* [out] */ LPACCESSIBLE __RPC_FAR *pIAccessible) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAccessibleHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAccessibleHandler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAccessibleHandler __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAccessibleHandler __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AccessibleObjectFromID )( 
            IAccessibleHandler __RPC_FAR * This,
            /* [in] */ long hwnd,
            /* [in] */ long lObjectID,
            /* [out] */ LPACCESSIBLE __RPC_FAR *pIAccessible);
        
        END_INTERFACE
    } IAccessibleHandlerVtbl;

    interface IAccessibleHandler
    {
        CONST_VTBL struct IAccessibleHandlerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAccessibleHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAccessibleHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAccessibleHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAccessibleHandler_AccessibleObjectFromID(This,hwnd,lObjectID,pIAccessible)	\
    (This)->lpVtbl -> AccessibleObjectFromID(This,hwnd,lObjectID,pIAccessible)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAccessibleHandler_AccessibleObjectFromID_Proxy( 
    IAccessibleHandler __RPC_FAR * This,
    /* [in] */ long hwnd,
    /* [in] */ long lObjectID,
    /* [out] */ LPACCESSIBLE __RPC_FAR *pIAccessible);


void __RPC_STUB IAccessibleHandler_AccessibleObjectFromID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAccessibleHandler_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_oleacc_0105 */
/* [local] */ 


//=--------------------------------------------------------------------------=
// Type Library Definitions
//=--------------------------------------------------------------------------=



extern RPC_IF_HANDLE __MIDL_itf_oleacc_0105_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oleacc_0105_v0_0_s_ifspec;


#ifndef __Accessibility_LIBRARY_DEFINED__
#define __Accessibility_LIBRARY_DEFINED__

/* library Accessibility */
/* [hidden][version][lcid][uuid] */ 




EXTERN_C const IID LIBID_Accessibility;
#endif /* __Accessibility_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\pstat.h ===
#ifndef _PSTAT_INCLUDED_
#define _PSTAT_INCLUDED_


#define MAX_EVENTS              2
#define MAX_THUNK_COUNTERS     64
#define MAX_PROCESSORS         32


#define PSTAT_READ_STATS    CTL_CODE (FILE_DEVICE_UNKNOWN, 0, METHOD_NEITHER, FILE_ANY_ACCESS)
#define PSTAT_SET_CESR      CTL_CODE (FILE_DEVICE_UNKNOWN, 1, METHOD_NEITHER, FILE_ANY_ACCESS)
#define PSTAT_HOOK_THUNK    CTL_CODE (FILE_DEVICE_UNKNOWN, 2, METHOD_NEITHER, FILE_ANY_ACCESS)
#define PSTAT_REMOVE_HOOK   CTL_CODE (FILE_DEVICE_UNKNOWN, 3, METHOD_NEITHER, FILE_ANY_ACCESS)
#define PSTAT_QUERY_EVENTS  CTL_CODE (FILE_DEVICE_UNKNOWN, 4, METHOD_NEITHER, FILE_ANY_ACCESS)

#define OFFSET(type, field) ((LONG)(&((type *)0)->field))

//
//
//

typedef struct {
    ULONGLONG       Counters[MAX_EVENTS];
    ULONG           EventId[MAX_EVENTS];
    ULONGLONG       TSC;
    ULONG           reserved;
    ULONG           SpinLockAcquires;
    ULONG           SpinLockCollisions;
    ULONG           SpinLockSpins;
    ULONG           Irqls;
    ULONG           ThunkCounters[MAX_THUNK_COUNTERS];
} PSTATS, *pPSTATS;

typedef struct {
    ULONG           EventId;
    BOOLEAN         Active;
    BOOLEAN         UserMode;
    BOOLEAN         KernelMode;
    BOOLEAN         EdgeDetect;
    ULONG           AppReserved;
    ULONG           reserved;
} SETEVENT, *PSETEVENT;

typedef struct {
    PUCHAR          SourceModule;
    ULONG           ImageBase;
    PUCHAR          TargetModule;
    PUCHAR          Function;
    ULONG           TracerId;
} HOOKTHUNK, *PHOOKTHUNK;

typedef struct {
    ULONG           EventId;
    KPROFILE_SOURCE ProfileSource;
    ULONG           DescriptionOffset;
    ULONG           SuggestedIntervalBase;
    UCHAR           Buffer[];
} EVENTID, *PEVENTID;

#endif /* _PSTAT_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\multinfo.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0102 */
/* at Fri Mar 29 16:59:57 1996
 */
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __multinfo_h__
#define __multinfo_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IProvideClassInfo_FWD_DEFINED__
#define __IProvideClassInfo_FWD_DEFINED__
typedef interface IProvideClassInfo IProvideClassInfo;
#endif 	/* __IProvideClassInfo_FWD_DEFINED__ */


#ifndef __IProvideClassInfo2_FWD_DEFINED__
#define __IProvideClassInfo2_FWD_DEFINED__
typedef interface IProvideClassInfo2 IProvideClassInfo2;
#endif 	/* __IProvideClassInfo2_FWD_DEFINED__ */


#ifndef __IProvideMultipleClassInfo_FWD_DEFINED__
#define __IProvideMultipleClassInfo_FWD_DEFINED__
typedef interface IProvideMultipleClassInfo IProvideMultipleClassInfo;
#endif 	/* __IProvideMultipleClassInfo_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Fri Mar 29 16:59:57 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


#ifndef _OLECTL_H_
#include <olectl.h>
#endif
#if 0


extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IProvideClassInfo_INTERFACE_DEFINED__
#define __IProvideClassInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IProvideClassInfo
 * at Fri Mar 29 16:59:57 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IProvideClassInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IProvideClassInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClassInfo( 
            /* [out] */ LPTYPEINFO __RPC_FAR *ppTI) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProvideClassInfoVtbl
    {
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IProvideClassInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IProvideClassInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IProvideClassInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClassInfo )( 
            IProvideClassInfo __RPC_FAR * This,
            /* [out] */ LPTYPEINFO __RPC_FAR *ppTI);
        
    } IProvideClassInfoVtbl;

    interface IProvideClassInfo
    {
        CONST_VTBL struct IProvideClassInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProvideClassInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProvideClassInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProvideClassInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProvideClassInfo_GetClassInfo(This,ppTI)	\
    (This)->lpVtbl -> GetClassInfo(This,ppTI)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IProvideClassInfo_GetClassInfo_Proxy( 
    IProvideClassInfo __RPC_FAR * This,
    /* [out] */ LPTYPEINFO __RPC_FAR *ppTI);


void __RPC_STUB IProvideClassInfo_GetClassInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProvideClassInfo_INTERFACE_DEFINED__ */


#ifndef __IProvideClassInfo2_INTERFACE_DEFINED__
#define __IProvideClassInfo2_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IProvideClassInfo2
 * at Fri Mar 29 16:59:57 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IProvideClassInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IProvideClassInfo2 : public IProvideClassInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetGUID( 
            /* [in] */ DWORD dwGuidKind,
            /* [out] */ GUID __RPC_FAR *pGUID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProvideClassInfo2Vtbl
    {
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IProvideClassInfo2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IProvideClassInfo2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IProvideClassInfo2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClassInfo )( 
            IProvideClassInfo2 __RPC_FAR * This,
            /* [out] */ LPTYPEINFO __RPC_FAR *ppTI);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGUID )( 
            IProvideClassInfo2 __RPC_FAR * This,
            /* [in] */ DWORD dwGuidKind,
            /* [out] */ GUID __RPC_FAR *pGUID);
        
    } IProvideClassInfo2Vtbl;

    interface IProvideClassInfo2
    {
        CONST_VTBL struct IProvideClassInfo2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProvideClassInfo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProvideClassInfo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProvideClassInfo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProvideClassInfo2_GetClassInfo(This,ppTI)	\
    (This)->lpVtbl -> GetClassInfo(This,ppTI)


#define IProvideClassInfo2_GetGUID(This,dwGuidKind,pGUID)	\
    (This)->lpVtbl -> GetGUID(This,dwGuidKind,pGUID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IProvideClassInfo2_GetGUID_Proxy( 
    IProvideClassInfo2 __RPC_FAR * This,
    /* [in] */ DWORD dwGuidKind,
    /* [out] */ GUID __RPC_FAR *pGUID);


void __RPC_STUB IProvideClassInfo2_GetGUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProvideClassInfo2_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0053
 * at Fri Mar 29 16:59:57 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


#endif // 0
// {A7ABA9C1-8983-11cf-8F20-00805F2CD064}
DEFINE_GUID(IID_IProvideMultipleClassInfo,
0xa7aba9c1, 0x8983, 0x11cf, 0x8f, 0x20, 0x0, 0x80, 0x5f, 0x2c, 0xd0, 0x64);


extern RPC_IF_HANDLE __MIDL__intf_0053_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0053_v0_0_s_ifspec;

#ifndef __IProvideMultipleClassInfo_INTERFACE_DEFINED__
#define __IProvideMultipleClassInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IProvideMultipleClassInfo
 * at Fri Mar 29 16:59:57 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


#define MULTICLASSINFO_GETTYPEINFO           0x00000001
#define MULTICLASSINFO_GETNUMRESERVEDDISPIDS 0x00000002
#define MULTICLASSINFO_GETIIDPRIMARY         0x00000004
#define MULTICLASSINFO_GETIIDSOURCE          0x00000008
#define TIFLAGS_EXTENDDISPATCHONLY           0x00000001

EXTERN_C const IID IID_IProvideMultipleClassInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IProvideMultipleClassInfo : public IProvideClassInfo2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMultiTypeInfoCount( 
            /* [out] */ ULONG __RPC_FAR *pcti) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInfoOfIndex( 
            /* [in] */ ULONG iti,
            /* [in] */ DWORD dwFlags,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptiCoClass,
            /* [out] */ DWORD __RPC_FAR *pdwTIFlags,
            /* [out] */ ULONG __RPC_FAR *pcdispidReserved,
            /* [out] */ IID __RPC_FAR *piidPrimary,
            /* [out] */ IID __RPC_FAR *piidSource) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProvideMultipleClassInfoVtbl
    {
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IProvideMultipleClassInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IProvideMultipleClassInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IProvideMultipleClassInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClassInfo )( 
            IProvideMultipleClassInfo __RPC_FAR * This,
            /* [out] */ LPTYPEINFO __RPC_FAR *ppTI);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGUID )( 
            IProvideMultipleClassInfo __RPC_FAR * This,
            /* [in] */ DWORD dwGuidKind,
            /* [out] */ GUID __RPC_FAR *pGUID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMultiTypeInfoCount )( 
            IProvideMultipleClassInfo __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcti);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInfoOfIndex )( 
            IProvideMultipleClassInfo __RPC_FAR * This,
            /* [in] */ ULONG iti,
            /* [in] */ DWORD dwFlags,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptiCoClass,
            /* [out] */ DWORD __RPC_FAR *pdwTIFlags,
            /* [out] */ ULONG __RPC_FAR *pcdispidReserved,
            /* [out] */ IID __RPC_FAR *piidPrimary,
            /* [out] */ IID __RPC_FAR *piidSource);
        
    } IProvideMultipleClassInfoVtbl;

    interface IProvideMultipleClassInfo
    {
        CONST_VTBL struct IProvideMultipleClassInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProvideMultipleClassInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProvideMultipleClassInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProvideMultipleClassInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProvideMultipleClassInfo_GetClassInfo(This,ppTI)	\
    (This)->lpVtbl -> GetClassInfo(This,ppTI)


#define IProvideMultipleClassInfo_GetGUID(This,dwGuidKind,pGUID)	\
    (This)->lpVtbl -> GetGUID(This,dwGuidKind,pGUID)


#define IProvideMultipleClassInfo_GetMultiTypeInfoCount(This,pcti)	\
    (This)->lpVtbl -> GetMultiTypeInfoCount(This,pcti)

#define IProvideMultipleClassInfo_GetInfoOfIndex(This,iti,dwFlags,pptiCoClass,pdwTIFlags,pcdispidReserved,piidPrimary,piidSource)	\
    (This)->lpVtbl -> GetInfoOfIndex(This,iti,dwFlags,pptiCoClass,pdwTIFlags,pcdispidReserved,piidPrimary,piidSource)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IProvideMultipleClassInfo_GetMultiTypeInfoCount_Proxy( 
    IProvideMultipleClassInfo __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcti);


void __RPC_STUB IProvideMultipleClassInfo_GetMultiTypeInfoCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IProvideMultipleClassInfo_GetInfoOfIndex_Proxy( 
    IProvideMultipleClassInfo __RPC_FAR * This,
    /* [in] */ ULONG iti,
    /* [in] */ DWORD dwFlags,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptiCoClass,
    /* [out] */ DWORD __RPC_FAR *pdwTIFlags,
    /* [out] */ ULONG __RPC_FAR *pcdispidReserved,
    /* [out] */ IID __RPC_FAR *piidPrimary,
    /* [out] */ IID __RPC_FAR *piidSource);


void __RPC_STUB IProvideMultipleClassInfo_GetInfoOfIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProvideMultipleClassInfo_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\scrptlet.h ===
#ifndef SCRPTLET_H
#define SCRPTLET_H


// If an error is reported successfully using IScriptletSite, then this
// error code is propagated up the call stack.
#define E_REPORTED	0x80004100L

DEFINE_GUID(CLSID_ScriptletConstructor, 0x21617250, 0xa071, 0x11d1, 0x89, 0xb6, 0x0, 0x60, 0x8, 0xc3, 0xfb, 0xfc);
DEFINE_GUID(SID_ScriptletSite, 0x22a98050, 0xa65d, 0x11d1, 0x89, 0xbe, 0x0, 0x60, 0x8, 0xc3, 0xfb, 0xfc);


/***************************************************************************
	IScriptletConstructor
	
	We need to move these definitions into an idl so we can generate the
	appropriate proxy/stub code.
***************************************************************************/
DEFINE_GUID(IID_IScriptletConstructor, 0xc265fb00, 0x9fa4, 0x11d1, 0x89, 0xb6, 0x0, 0x60, 0x8, 0xc3, 0xfb, 0xfc);
interface IScriptletConstructor : public IUnknown
	{
	STDMETHOD(Load)(LPCOLESTR pstrSource) PURE;
	STDMETHOD(Create)(LPCOLESTR pstrId, IUnknown *punkContext,
			IUnknown *punkOuter, REFIID riid, void **ppv) PURE;
	STDMETHOD(Register)(LPCOLESTR pstrSourceFileName) PURE;
	STDMETHOD(Unregister)(void) PURE;
	STDMETHOD(AddCoclassTypeInfo)(ICreateTypeLib *ptclib) PURE;
	STDMETHOD(IsDefined)(LPCOLESTR pstrId) PURE;
	};


/***************************************************************************
	IScriptletError
***************************************************************************/
DEFINE_GUID(IID_IScriptletError, 0xdf9f3d20, 0xa670, 0x11d1, 0x89, 0xbe, 0x0, 0x60, 0x8, 0xc3, 0xfb, 0xfc);
interface IScriptletError : public IUnknown
    {
	STDMETHOD(GetExceptionInfo)(EXCEPINFO *pexcepinfo) PURE;
	STDMETHOD(GetSourcePosition)(ULONG *pline, ULONG *pcolumn) PURE;
	STDMETHOD(GetSourceLineText)(BSTR *pbstrSourceLine) PURE;
	};


/***************************************************************************
	IScriptletSite
	
	In addition to the dispids defined below, the site may also choose to 
	handle the follwing dispids.
		DISPID_ERROREVENT
		DISPID_AMBIENT_LOCALEID
***************************************************************************/
#define DISPID_SCRIPTLET_ALLOWDEBUG		1

DEFINE_GUID(IID_IScriptletSite, 0xc5f21c30, 0xa7df, 0x11d1, 0x89, 0xbe, 0x0, 0x60, 0x8, 0xc3, 0xfb, 0xfc);
interface IScriptletSite : public IUnknown
	{
	STDMETHOD(OnEvent)(DISPID dispid, int cArg, VARIANT *prgvarArg,
			VARIANT *pvarRes) PURE;
	STDMETHOD(GetProperty)(DISPID dispid, VARIANT *pvarRes) PURE;
	};


		
#endif // SCRPTLET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\shlwrap.h ===
#ifndef I_SHLWRAP_H_
#define I_SHLWRAP_H_

#if defined(_M_IX86) && !defined(WINCE)

#define UNICODE_SHDOCVW
#define POST_IE5_BETA

#ifndef X_W95WRAPS_H_
#define X_W95WRAPS_H_
#include <w95wraps.h>
#endif

// Trident doesn't want certain system functions wrapped

#undef TextOutW
#undef ExtTextOutW

#else

// Manually enable wrapping for certain APIs

// (JBEDA, via DINARTEM)  We may want to take this ifdef out entirely so
// that we always use shlwapi on AMD64/ia64

#define ShellExecuteExW             ShellExecuteExWrapW

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\plugin_i.h ===
/* This header file machine-generated by mktyplib.exe */
/* Interface to type library: ActiveXPlugin */

#ifndef _ActiveXPlugin_H_
#define _ActiveXPlugin_H_

DEFINE_GUID(LIBID_ActiveXPlugin,0x06DD38D0L,0xD187,0x11CF,0xA8,0x0D,0x00,0xC0,0x4F,0xD7,0x4A,0xD8);
#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

DEFINE_GUID(IID_IActiveXPlugin,0x06DD38D1L,0xD187,0x11CF,0xA8,0x0D,0x00,0xC0,0x4F,0xD7,0x4A,0xD8);

/* Definition of interface: IActiveXPlugin */
#undef INTERFACE
#define INTERFACE IActiveXPlugin

DECLARE_INTERFACE_(IActiveXPlugin, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IActiveXPlugin methods */
    STDMETHOD_(void, Load)(THIS_ BSTR bstrUrl, int bDeleteRegistry) PURE;
    STDMETHOD_(void, AddParam)(THIS_ BSTR bstrName, BSTR bstrValue) PURE;
    STDMETHOD_(void, Show)(THIS) PURE;
    STDMETHOD_(void, Hide)(THIS) PURE;
    STDMETHOD_(void, Clear)(THIS) PURE;
    STDMETHOD(get_dispatch)(THIS_ IDispatch * FAR* retval) PURE;
};

DEFINE_GUID(DIID_DActiveXPluginEvents,0x06DD38D2L,0xD187,0x11CF,0xA8,0x0D,0x00,0xC0,0x4F,0xD7,0x4A,0xD8);

/* Definition of dispatch interface: DActiveXPluginEvents */
#undef INTERFACE
#define INTERFACE DActiveXPluginEvents

DECLARE_INTERFACE_(DActiveXPluginEvents, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif
};

DEFINE_GUID(CLSID_ActiveXPlugin,0x06DD38D3L,0xD187,0x11CF,0xA8,0x0D,0x00,0xC0,0x4F,0xD7,0x4A,0xD8);

#ifdef __cplusplus
class ActiveXPlugin;
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\brkkind.h ===
#ifndef BRKKIND_DEFINED
#define BRKKIND_DEFINED

#include "lsdefs.h"

typedef enum
{
	brkkindImposedAfter,
	brkkindPrev,
	brkkindNext,
	brkkindForce

} BRKKIND;


#endif /* !BRKKIND_DEFINED                    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\w95fiber.h ===
//
//  W95FIBER.H
//
//  Copyright (C) Microsoft Corporation, 1996
//
//  Public definitions for the Windows 95 fiber library.
//

#ifndef _W95FIBER_
#define _W95FIBER_

#ifdef __cplusplus
extern "C" {
#endif

typedef VOID (WINAPI *PFIBER_START_ROUTINE)(
    LPVOID lpFiberParameter
    );
typedef PFIBER_START_ROUTINE LPFIBER_START_ROUTINE;

#ifdef _X86_

LPVOID
WINAPI
FbrCreateFiber(
    DWORD dwStackSize,
    LPFIBER_START_ROUTINE lpStartAddress,
    LPVOID lpParameter
    );

VOID
WINAPI
FbrDeleteFiber(
    LPVOID lpFiber
    );

LPVOID
WINAPI
FbrConvertThreadToFiber(
    LPVOID lpParameter
    );

VOID
WINAPI
FbrSwitchToFiber(
    LPVOID lpFiber
    );

LPVOID
WINAPI
FbrGetCurrentFiber(
    VOID
    );

LPVOID
WINAPI
FbrGetFiberData(
    VOID
    );

BOOL
WINAPI
FbrAttachToBase(
    VOID
    );

VOID
WINAPI
FbrDetachFromBase(
    VOID
    );

#else

#define FbrCreateFiber              CreateFiber
#define FbrDeleteFiber              DeleteFiber
#define FbrConvertThreadToFiber     ConvertThreadToFiber
#define FbrSwitchToFiber            SwitchToFiber
#define FbrGetCurrentFiber()        GetCurrentFiber()
#define FbrGetFiberData()           GetFiberData()
#define FbrAttachToBase()           (g_dwPlatformID != VER_PLATFORM_WIN32_WINDOWS)
#define FbrDetachFromBase()

#endif // _X86_

#ifdef __cplusplus
}
#endif

#endif // _W95FIBER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\brkpos.h ===
#ifndef BRKPOS_DEFINED
#define BRKPOS_DEFINED

#include "lsdefs.h"

typedef enum
{
	brkposBeforeFirstDnode,
	brkposInside,
	brkposAfterLastDnode

} BRKPOS;


#endif /* !BRKPOS_DEFINED                    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\brkcls.h ===
#ifndef BRKCLS_DEFINED
#define BRKCLS_DEFINED

#include "lsdefs.h"

typedef DWORD BRKCLS;

#endif /* !BRKCLS_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\brko.h ===
#ifndef BRKO_DEFINED
#define BRKO_DEFINED

#include "lsdefs.h"
#include "pbrko.h"
#include "objdim.h"
#include "posichnk.h"
#include "brkcond.h"

typedef struct brkout						/* break output */ 
{
	BOOL fSuccessful;						/* break result */
	BRKCOND brkcond;						/* iff !fSuccessful, recommendation on the other side */
	POSICHNK posichnk;
	OBJDIM objdim;
} BRKOUT;


#endif /* !BRKO_DEFINED                    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\breakrec.h ===
#ifndef BREAKREC_DEFINED
#define BREAKREC_DEFINED

#include "lsdefs.h"

/* ---------------------------------------------------------------------- */

struct breakrec
{
	DWORD idobj;
	LSCP cpFirst;
};

typedef struct breakrec BREAKREC;

#endif /* !BREAKREC_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\brkcond.h ===
#ifndef BRKCOND_DEFINED
#define BRKCOND_DEFINED

#include "lsdefs.h"

typedef enum
{
	brkcondPlease,
	brkcondCan,
	brkcondNever
} BRKCOND;


#endif /* !BRKCOND_DEFINED                    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\dispi.h ===
#ifndef DISPI_DEFINED
#define DISPI_DEFINED

#include "lsdefs.h"
#include "pdispi.h"
#include "plsrun.h"
#include "plschp.h"
#include "heights.h"
#include "lstflow.h"

typedef struct dispin
{
	POINT 	ptPen;					/* starting pen position (x,y) */
	PCLSCHP plschp;					/* CHP for this display object */
	PLSRUN 	plsrun;					/* client pointer to run */

	UINT 	kDispMode;				/* display mode, opaque, etc */
	LSTFLOW lstflow;	 			/* text direction and orientation */
	RECT* 	prcClip;				/* clip rectangle (x,y) */

	BOOL 	fDrawUnderline;			/* Draw underline while displaying */
	BOOL 	fDrawStrikethrough;		/* Draw strikethrough while Displaying */

	HEIGHTS heightsPres;
	long 	dup;
	long	dupLimUnderline;		/* less than dup if trailing spaces */
} DISPIN;	

#endif /* !DISPI_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\fmti.h ===
#ifndef FMTIO_DEFINED
#define FMTIO_DEFINED

#include "lsdefs.h"
#include "pfmti.h"
#include "plsdnode.h"
#include "lsfgi.h"
#include "lsfrun.h"
#include "lstxm.h"

/* ------------------------------------------------------------------------ */

struct fmtin
{
	LSFGI lsfgi;
	LSFRUN lsfrun;
	PLSDNODE plsdnTop;
	LSTXM lstxmPres;
	LSTXM lstxmRef;
};

/* ------------------------------------------------------------------------ */


#endif /* !FMTIO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\exptype.h ===
#ifndef EXPTYPE_DEFINED
#define EXPTYPE_DEFINED

#include "lsdefs.h"

typedef BYTE EXPTYPE;

/* kinds of glyph expansion */
#define	exptNone  0
#define	exptAddWhiteSpace 1
#define	exptAddInkContinuous 2
#define	exptAddInkDiscrete 3

typedef EXPTYPE* PEXPTYPE;
typedef const EXPTYPE* PCEXPTYPE;


#endif /* !EXPTYPE_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\endres.h ===
#ifndef ENDRES_DEFINED
#define ENDRES_DEFINED

enum endres
{
	endrNormal,
	endrHyphenated,
	endrEndPara,
	endrAltEndPara,
	endrSoftCR,
	endrEndColumn,
	endrEndSection,
	endrEndPage,
	endrEndParaSection,
	endrStopped
};

typedef enum endres ENDRES;

#endif /* ENDRES_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\fmtres.h ===
#ifndef FMTRES_DEFINED
#define FMTRES_DEFINED

/* used in fmtio.h and lsfd.h */

enum fmtres							/* Why did the formatter return? */
{
	fmtrCompletedRun,				/* no problems */
	fmtrExceededMargin,				/* reached right margin */
	fmtrTab,						/* reached tab				  */
	fmtrStopped						
};

typedef enum fmtres FMTRES;

#endif /* !FMTRES_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\heights.h ===
#ifndef HEIGHTS_DEFINED
#define HEIGHTS_DEFINED

#include "lsdefs.h"
#include "pheights.h"

#define dvHeightIgnore 0x7FFFFFFF

typedef struct heights
{
	long dvAscent;
	long dvDescent;
	long dvMultiLineHeight;
} HEIGHTS;

#endif /* !HEIGHTS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\hih.h ===
#ifndef HIH_DEFINED
#define HIH_DEFINED

#include "lsimeth.h"

/*
 *	H(orizontal)I(n)H(orizontal)
 *
 *	This object is designed to help client implementations which use 
 *	Tatenakayoko and wish to be able to convert the display from vertical
 *	to horizontal and then to display the Tatenakayoko text as horizontal.
 *	To do this the client application simply changes the object handler
 *	from the Tatenakayoko handler to this object handler and the text
 *	will be displayed horizontally.
 *	
 */

/* typedef for callback to client for enumeration */
typedef LSERR(WINAPI * PFNHIHENUM)(
	POLS pols,				/*(IN): client context */
	PLSRUN plsrun,			/*(IN): from DNODE */
	PCLSCHP plschp,			/*(IN): from DNODE */
	LSCP cp,				/*(IN): from DNODE */
	LSDCP dcp,				/*(IN): from DNODE */
	LSTFLOW lstflow,		/*(IN): text flow*/
	BOOL fReverse,			/*(IN): enumerate in reverse order */
	BOOL fGeometryNeeded,	/*(IN): */
	const POINT* pt,		/*(IN): starting position (top left), iff fGeometryNeeded */
	PCHEIGHTS pcheights,	/*(IN): from DNODE, relevant iff fGeometryNeeded */
	long dupRun,			/*(IN): from DNODE, relevant iff fGeometryNeeded*/
	PLSSUBL plssubl);		/*(IN): subline in hih object. */

/*
 *
 *	HIH object initialization data that the client application must return
 *	when the HIH object handler calls the GetObjectHandlerInfo callback.
 */

#define HIH_VERSION 0x300

typedef struct HIHINIT
{
	DWORD				dwVersion;		/* Version. Must be HIH_VERSION */
	WCHAR				wchEndHih;		/* Escape for end of HIH object */
	WCHAR				wchUnused1;
	WCHAR				wchUnused2;
	WCHAR				wchUnused3;
	PFNHIHENUM			pfnEnum;		/* Enumeration callback */
} HIHINIT, *PHIHINIT;

LSERR WINAPI LsGetHihLsimethods(
	LSIMETHODS *plsim);

/* GetHihLsimethods
 *	
 *	plsim (OUT): Hih object methods for Line Services
 *
 */

#endif /* HIH_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\gmap.h ===
#ifndef GMAP_DEFINED
#define GMAP_DEFINED

#include "lsdefs.h"

typedef WORD GMAP;
typedef GMAP* PGMAP;
typedef const GMAP* PCGMAP;

#endif /* !GMAP_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\gprop.h ===
#ifndef GPROP_DEFINED
#define GPROP_DEFINED

#include "lsdefs.h"

typedef WORD GPROP;
typedef GPROP* PGPROP;
typedef const GPROP* PCGPROP;

#endif /* !GPROPS_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lsact.h ===
#ifndef LSACT_DEFINED
#define LSACT_DEFINED

#include "lsdefs.h"
#include "kamount.h"

#define sideNone				0		/* means no action				*/
#define sideLeft				1
#define sideRight				2
#define sideLeftRight			3		/* Review(segeyge): how to distribute?*/

typedef struct lsact					/* action							*/
{
	BYTE side;							/* side of action (left/right/both)	*/
	KAMOUNT kamnt;						/* amount of action					*/
} LSACT;


#endif /* !LSACT_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\kamount.h ===
#ifndef KAMOUNT_DEFINED
#define KAMOUNT_DEFINED

#include "lsdefs.h"
/* Interpretation for kamnBy... is as follows:
	Compression			-
	Expansion			+
	PunctStartLine   	-
	ModWidthPairs		-
	ModWidthSpace		+
	ModWidthOnRun		+
*/


typedef BYTE KAMOUNT;

#define kamntNone				0
#define kamntToHalfEm			1
#define kamntToQuarterEm		2
#define kamntToThirdEm			3
#define kamntTo15Sixteenth		4
#define kamntByHalfEm			5
#define kamntByQuarterEm		6
#define kamntByEighthEm			7
#define kamntByUserDefinedExpan	8	
#define kamntByUserDefinedComp	9	
#define kamntToUserDefinedExpan	10	
#define kamntToUserDefinedComp	11	


#endif /* !KAMOUNT_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lsbrk.h ===
#ifndef LSBRK_DEFINED
#define LSBRK_DEFINED

#include "lsdefs.h"

typedef struct lsbrk					/* breaking information unit		*/
{
	BYTE fBreak;						/* break for neibours	*/
	BYTE fBreakAcrossSpaces;			/* break across spaces	*/
} LSBRK;									


#endif /* !LSBRK_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\locchnk.h ===
#ifndef LOCCHNK_DEFINED
#define LOCCHNK_DEFINED

#include "lsdefs.h"
#include "lsfgi.h"
#include "lschnke.h"

typedef struct locchnk					/* located chnk					*/
{
	LSFGI lsfgi;						/* location of chunk			*/
	DWORD clschnk;						/* number of dobj's in chunk	*/
	PLSCHNK plschnk;					/* chunk 						*/
	PPOINTUV ppointUvLoc;				/* location of each chunk's node*/
} LOCCHNK;



#endif /* !LOCCHNK_DEFINED                    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lscell.h ===
#ifndef LSCELL_DEFINED
#define LSCELL_DEFINED

#include "lsdefs.h"
#include "plscell.h"
#include "pcelldet.h"
#include "plscell.h"

struct lstextcell
{
	LSCP cpStartCell;
	LSCP cpEndCell;
 	POINTUV pointUvStartCell;		/* In coordinate system of main line/subline */
	long dupCell;					/* In direction lstflowSubline			*/

	DWORD cCharsInCell;
	DWORD cGlyphsInCell;

	PCELLDETAILS pCellDetails;

};

typedef struct lstextcell LSTEXTCELL;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lschnke.h ===
#ifndef LSCHNKE_DEFINED
#define LSCHNKE_DEFINED

#include "lsdefs.h"
#include "plschp.h"
#include "plsrun.h"
#include "pdobj.h"

typedef struct lschnke
{
	LSCP cpFirst;
	LSDCP dcp;
	PCLSCHP plschp;
	PLSRUN plsrun;
	PDOBJ pdobj;
} LSCHNKE;

typedef LSCHNKE* PLSCHNK;
typedef const LSCHNKE* PCLSCHNK;

#endif  /* !LSCHNKE_DEFINED   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lsbrjust.h ===
#ifndef LSBRJUST_DEFINED
#define LSBRJUST_DEFINED

enum lsbreakjust							/* kinds of breaking/justification */
{
	lsbrjBreakJustify,						/* Regular US */
	lsbrjBreakWithCompJustify,				/* FE & Newspaper */
	lsbrjBreakThenExpand,					/* Arabic			 */
	lsbrjBreakThenSqueeze					/* Word Perfect			 */
};

typedef enum lsbreakjust LSBREAKJUST;

#endif /* !LSBRJUST_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lscbk.h ===
#ifndef LSCBK_DEFINED
#define LSCBK_DEFINED

/* LineServices callbacks */

#include "lsdefs.h"
#include "lsdevice.h"
#include "lsksplat.h"
#include "lskjust.h"
#include "lstflow.h"
#include "endres.h"
#include "mwcls.h"
#include "lsact.h"
#include "lspract.h"
#include "brkcond.h"
#include "brkcls.h"
#include "gprop.h"
#include "gmap.h"
#include "lsexpinf.h"
#include "lskalign.h"
#include "plstabs.h"
#include "pheights.h"
#include "plsrun.h"
#include "plscbk.h"
#include "plschp.h"
#include "plspap.h"
#include "plstxm.h"
#include "plshyph.h"
#include "plsstinf.h"
#include "plsulinf.h"
#include "plsems.h"

#define cpFirstAnm (-0x7FFFFFFF)   /* Used for the fetch of the first Autonumber run */


struct lscbk	/* Interfaces to application-specific callbacks */
{
	/* Dynamic memory APIs */
	void* (WINAPI* pfnNewPtr)(POLS, DWORD);
	void  (WINAPI* pfnDisposePtr)(POLS, void*);
	void* (WINAPI* pfnReallocPtr)(POLS, void*, DWORD);


	LSERR (WINAPI* pfnFetchRun)(POLS, LSCP,
							    LPCWSTR*, DWORD*, BOOL*, PLSCHP, PLSRUN*);
	/* FetchRun:
	 *  pols (IN):
	 *  cp (IN):
	 *  &lpwchRun (OUT): run of characters.
	 *  &cchRun (OUT): number of characters in run
	 *  &fHidden (OUT) : hidden run?
	 *  &lsChp (OUT): char properties of run 
	 *  &plsrun (OUT): abstract representation of run properties
	 */

	LSERR (WINAPI* pfnGetAutoNumberInfo)(POLS, LSKALIGN*, PLSCHP, PLSRUN*, WCHAR*, PLSCHP, PLSRUN*, BOOL*, long*, long*);

	/* GetAutoNumberInfo:
	 *  pols (IN):
	 *  &lskalAnm (OUT):
	 *  &lschpAnm (OUT): lschp for Anm
	 *  &plsrunAnm (OUT): plsrun for Anm
	 *  &wchAdd (OUT): character to add (Nil is treated as none)
	 *  &lschpWch (OUT): lschp for added char
	 *  &plsrunWch (OUT): plsrun for added char
	 *  &fWord95Model(OUT):
	 *  &duaSpaceAnm(OUT):	relevant iff fWord95Model
	 *  &duaWidthAnm(OUT):	relevant iff fWord95Model
	 */

	LSERR (WINAPI* pfnGetNumericSeparators)(POLS, PLSRUN, WCHAR*,WCHAR*);
	/* GetNumericSeparators:
	 *  pols (IN):
	 *  plsrun (IN): run pointer as returned from FetchRun
	 *  &wchDecimal (OUT): decimal separator for this run.
	 *  &wchThousands (OUT): thousands separator for this run
	 */

	LSERR (WINAPI* pfnCheckForDigit)(POLS, PLSRUN, WCHAR, BOOL*);
	/* GetNumericSeparators:
	 *  pols (IN):
	 *  plsrun (IN): run pointer as returned from FetchRun
	 *  wch (IN): character to check
	 *  &fIsDigit (OUT): this character is digit
	 */

	LSERR (WINAPI* pfnFetchPap)(POLS, LSCP, PLSPAP);
	/* FetchPap:
	 *  pols (IN):
	 *  cp (IN): an arbitrary cp value inside the paragraph
	 *  &lsPap (OUT): Paragraph properties.
	 */

	LSERR (WINAPI* pfnFetchTabs)(POLS, LSCP, PLSTABS, BOOL*, long*, WCHAR*);
	/* FetchTabs:
	 *  pols (IN):
	 *  cp (IN): an arbitrary cp value inside the paragraph
	 *  &lstabs (OUT): tabs array
	 *  &fHangingTab (OUT): there is hanging tab
	 *  &duaHangingTab (OUT): dua of hanging tab
	 *  &wchHangingTabLeader (OUT): leader of hanging tab
	 */

	LSERR (WINAPI* pfnGetBreakThroughTab)(POLS, long, long, long*);
	/* GetBreakThroughTab:
	 *  pols (IN):
	 *  uaRightMargin (IN): right margin for breaking
	 *  uaTabPos (IN): breakthrough tab position
	 *  uaRightMarginNew (OUT): new right margin
	 */

	LSERR (WINAPI* pfnFGetLastLineJustification)(POLS, LSKJUST, LSKALIGN, ENDRES, BOOL*, LSKALIGN*);
	/* FGetLastLineJustification:
	 *  pols (IN):
	 *  lskj (IN): kind of justification for the paragraph
	 *  lskal (IN): kind of alignment for the paragraph
	 *  endr (IN): result of formatting
	 *  &fJustifyLastLine (OUT): should last line be fully justified
	 *  &lskalLine (OUT): kind of alignment for this line
	 */

	LSERR (WINAPI* pfnCheckParaBoundaries)(POLS, LSCP, LSCP, BOOL*);
	/* CheckParaBoundaries:
	 *  pols (IN):
	 *  cpOld (IN):
	 *  cpNew (IN):
	 *  &fChanged (OUT): "Dangerous" change between paragraph properties.
	 */

	LSERR (WINAPI* pfnGetRunCharWidths)(POLS, PLSRUN, 
									 	LSDEVICE, LPCWSTR,
										DWORD, long, LSTFLOW,
										int*,long*,long*);
	/* GetRunCharWidths:
	 *  pols (IN):
	 *  plsrun (IN):
	 *  lsDeviceID (IN): presentation or reference
	 *  lpwchRun (IN): run of characters
	 *  cwchRun (IN): number of characters in run
	 *  du (IN): available space for characters
	 *  kTFlow (IN): text direction and orientation
	 *  rgDu (OUT): widths of characters
	 *  &duRun (OUT): sum of widths in rgDx[0] to rgDu[limDx-1]
	 *  &limDu (OUT): number of widths fetched
	 */

	LSERR (WINAPI* pfnCheckRunKernability)(POLS, PLSRUN,PLSRUN, BOOL*);
	/* CheckRunKernability:
	 *  pols (IN):
	 *  plsrunLeft (IN): 1st of pair of adjacent runs
	 *  plsrunRight (IN): 2nd of pair of adjacent runs
	 *  &fKernable (OUT) : if TRUE, Line Service may kern between these runs
	 */

	LSERR (WINAPI* pfnGetRunCharKerning)(POLS, PLSRUN,
										 LSDEVICE, LPCWSTR,
										 DWORD, LSTFLOW, int*);
	/* GetRunCharKerning:
	 *  pols (IN):
	 *  plsrun (IN):
	 *  lsDeviceID (IN): presentation or reference
	 *  lpwchRun (IN): run of characters
	 *  cwchRun (IN): number of characters in run
	 *  kTFlow (IN): text direction and orientation
	 *  rgDu (OUT): widths of characters
	 */

	LSERR (WINAPI* pfnGetRunTextMetrics)(POLS, PLSRUN,
										 LSDEVICE, LSTFLOW, PLSTXM);
	/* GetRunTextMetrics:
	 *  pols (IN):
	 *  plsrun (IN):
	 *  deviceID (IN):  presentation, reference, or absolute
	 *  kTFlow (IN): text direction and orientation
	 *  &lsTxMet (OUT): Text metrics
	 */

	LSERR (WINAPI* pfnGetRunUnderlineInfo)(POLS, PLSRUN, PCHEIGHTS, LSTFLOW,
										   PLSULINFO);
	/* GetRunUnderlineInfo:
	 *  pols (IN):
	 *  plsrun (IN):
	 *  heightsPres (IN):
	 *  kTFlow (IN): text direction and orientation
	 *  &lsUlInfo (OUT): Underline information
	 */

	LSERR (WINAPI* pfnGetRunStrikethroughInfo)(POLS, PLSRUN, PCHEIGHTS, LSTFLOW,
											  PLSSTINFO);
	/* GetRunStrikethroughInfo:
	 *  pols (IN):
	 *  plsrun (IN):
	 *  heightsPres (IN):
	 *  kTFlow (IN): text direction and orientation
	 *  &lsStInfo (OUT): Strikethrough information
	 */

	LSERR (WINAPI* pfnGetBorderInfo)(POLS, PLSRUN, LSTFLOW, long*, long*);
	/* GetBorderInfo:
	 *  pols (IN):
	 *  plsrun (IN):
	 *  kTFlow (IN): text direction and orientation
	 *  &durBorder (OUT): Width of the border on the reference device
	 *  &dupBorder (OUT): Width of the border on the presentation device
	 */


	LSERR (WINAPI* pfnReleaseRun)(POLS, PLSRUN);
	/* ReleaseRun:
	 *  pols (IN):
	 *  plsrun (IN): run to be released, from GetRun() or FetchRun()
	 */

	LSERR (WINAPI* pfnHyphenate)(POLS, PCLSHYPH, LSCP, LSCP, PLSHYPH);
	/* Hyphenate:
	 *  pols (IN):
	 *  &lsHyphLast (IN): last hyphenation found. kysr==kysrNil means "none"
	 *  cpBeginWord (IN): 1st cp in word which exceeds column
	 *  cpExceed (IN): 1st which exceeds column, in this word
	 *  &lsHyph (OUT): hyphenation results. kysr==kysrNil means "none"
	 */

	LSERR (WINAPI* pfnGetHyphenInfo)(POLS, PLSRUN, DWORD*, WCHAR*);
	/* GetHyphenInfo:
	 *  pols (IN):
	 *  plsrun (IN):
     *  kysr (OUT)	  Ysr type - see "lskysr.h"
     *  wchYsr (OUT)  Character code of YSR
	*/

	LSERR (WINAPI* pfnDrawUnderline)(POLS, PLSRUN, UINT,
								const POINT*, DWORD, DWORD, LSTFLOW,
								UINT, const RECT*);
	/* DrawUnderline:
	 *  pols (IN):
	 *  plsrun (IN): run to use for the underlining
	 *  kUlbase (IN): underline kind 
	 *  pptStart (IN): starting position (top left)
	 *  dupUL (IN): underline width
	 *  dvpUL (IN) : underline thickness
	 *  kTFlow (IN): text direction and orientation
	 *  kDisp (IN) : display mode - opaque, transparent
	 *  prcClip (IN) : clipping rectangle
	 */

	LSERR (WINAPI* pfnDrawStrikethrough)(POLS, PLSRUN, UINT,
								const POINT*, DWORD, DWORD, LSTFLOW,
								UINT, const RECT*);
	/* DrawStrikethrough:
	 *  pols (IN):
	 *  plsrun (IN): the run for the strikethrough
	 *  kStbase (IN): strikethrough kind 
	 *  pptStart (IN): starting position (top left)
	 *  dupSt (IN): strikethrough width
	 *  dvpSt (IN) : strikethrough thickness
	 *  kTFlow (IN): text direction and orientation
	 *  kDisp (IN) : display mode - opaque, transparent
	 *  prcClip (IN) : clipping rectangle
	 */

	LSERR (WINAPI* pfnDrawBorder)(POLS, PLSRUN, const POINT*, PCHEIGHTS, PCHEIGHTS,
								  PCHEIGHTS, PCHEIGHTS, long, long, LSTFLOW, UINT, const RECT*);

	/* DrawBorder:
	 *  pols (IN):
	 *  plsrun (IN): plsrun of the first bordered run
	 *  pptStart (IN): starting point for the border
	 *  pheightsLineFull (IN): height of the line including SpaceBefore & SpaceAfter
	 *  pheightsLineWithoutAddedSpace (IN): height of the line without SpaceBefore & SpaceAfter
	 *  pheightsSubline (IN): height of subline
	 *  pheightsRuns (IN): height of collected runs to be bordered
	 *  dupBorder (IN): width of one border
	 *  dupRunsInclBorders (IN): width of collected runs
	 *  kTFlow (IN): text direction and orientation
	 *  kDisp (IN) : display mode - opaque, transparent
	 *  prcClip (IN) : clipping rectangle
	 */

	LSERR (WINAPI* pfnDrawUnderlineAsText)(POLS, PLSRUN, const POINT*,
										   long, LSTFLOW, UINT, const RECT*);
	/* DrawUnderlineAsText:
	 *  pols (IN):
	 *  plsrun (IN): run to use for the underlining
	 *  pptStart (IN): starting pen position
	 *  dupLine (IN): length of UL
	 *  kTFlow (IN): text direction and orientation
	 *  kDisp (IN) : display mode - opaque, transparent
	 *  prcClip (IN) : clipping rectangle
	 */

	LSERR (WINAPI* pfnFInterruptUnderline)(POLS, PLSRUN, LSCP, PLSRUN, LSCP,BOOL*);
	/* FInterruptUnderline:
	 *  pols (IN):
	 *  plsrunFirst (IN): run pointer for the previous run
	 *  cpLastFirst (IN): cp of the last character of the previous run
	 *  plsrunSecond (IN): run pointer for the current run
	 *  cpStartSecond (IN): cp of the first character of the current run
	 *  &fInterruptUnderline (OUT): do you want to interrupt drawing of the underline between these runs
	 */

	LSERR (WINAPI* pfnFInterruptShade)(POLS, PLSRUN, PLSRUN, BOOL*);
	/* FInterruptShade:
	 *  pols (IN):
	 *  plsrunFirst (IN): run pointer for the previous run
	 *  plsrunSecond (IN): run pointer for the current run
	 *  &fInterruptShade (OUT): do you want to interrupt shading between these runs
	 */

	LSERR (WINAPI* pfnFInterruptBorder)(POLS, PLSRUN, PLSRUN, BOOL*);
	/* FInterruptBorder:
	 *  pols (IN):
	 *  plsrunFirst (IN): run pointer for the previous run
	 *  plsrunSecond (IN): run pointer for the current run
	 *  &fInterruptBorder (OUT): do you want to interrupt border between these runs
	 */


	LSERR (WINAPI* pfnShadeRectangle)(POLS, PLSRUN, const POINT*, PCHEIGHTS, PCHEIGHTS,
								  PCHEIGHTS, PCHEIGHTS, PCHEIGHTS, long, long, LSTFLOW, UINT, const RECT*);

	/* ShadeRectangle:
	 *  pols (IN):
	 *  plsrun (IN): plsrun of the first shaded run
	 *  pptStart (IN): starting point for the shading rectangle
	 *  pheightsLineWithAddSpace(IN): height of the line including SpaceBefore & SpaceAfter (main baseline, 
	 *						lstflow of main line)
	 *  pheightsLineWithoutAddedSpace (IN): height of the line without SpaceBefore & SpaceAfter
	 *  pheightsSubline (IN): height of subline (local baseline, lstflow of subline)
	 *  pheightsRunsExclTrail (IN): height of collected runs to be shaded excluding 
	 *									trailing spaces area (local baseline, lstflow of subline)
	 *  pheightsRunsInclTrail (IN): height of collected runs to be shaded including
	 *									trailing spaces area (local baseline, lstflow of subline)
	 *  dupRunsExclTrail (IN): width of collected runs excluding trailing spaces area
	 *  dupRunsInclTrail (IN): width of collected runs including trailing spaces area
	 *  kTFlow (IN): text direction and orientation of subline
	 *  kDisp (IN) : display mode - opaque, transparent
	 *  prcClip (IN) : clipping rectangle
	 */

	LSERR (WINAPI* pfnDrawTextRun)(POLS, PLSRUN, BOOL, BOOL, 
								   const POINT*, LPCWSTR, const int*, DWORD, 
								   LSTFLOW, UINT, const POINT*, PCHEIGHTS, long, long, const RECT*);
	/* DrawTextRun:
	 *  pols (IN):
	 *  plsrun (IN):
	 *  fStrikeout (IN) :
	 *  fUnderline (IN) :
	 *  pptText (IN): starting point for the text output
	 *  lpwchRun (IN): run of characters
	 *  rgDupRun (IN): widths of characters
	 *  cwchRun (IN): number of characters in run
	 *  kTFlow (IN): text direction and orientation
	 *  kDisp (IN): display mode - opaque, transparent
	 *  pptRun (IN): starting point of the run
	 *  heightsPres (IN): presentation heights for this run
	 *  dupRun (IN): presentation width for this run
	 *  dupLimUnderline (IN): underlining limit
	 *  pRectClip (IN): clipping rectangle
	 */

    LSERR (WINAPI* pfnDrawSplatLine)(POLS, enum lsksplat, LSCP, const POINT*,
									 PCHEIGHTS, PCHEIGHTS, PCHEIGHTS, long, LSTFLOW,
									 UINT, const RECT*);
	/* DrawSplatLine:
	 *  pols (IN):
	 *  ksplat (IN): See definitions in lsksplat.h
	 *  cpSplat (IN): location of the break character which caused the splat.
	 *  pptSplatLine (IN) : starting position of the splat line
	 *  pheightsLineFull (IN): height of the line including SpaceBefore & SpaceAfter
	 *  pheightsLineWithoutAddedSpace (IN): height of the line without SpaceBefore & SpaceAfter
	 *  pheightsSubline (IN): height of subline
	 *  dup (IN): distance to right margin
	 *  kTFlow (IN): text direction and orientation
	 *  kDisp (IN): display mode - opaque, transparent
	 *  &rcClip (IN) : clipping rectangle
	 */


/* Advanced typography enabling API's */

	/* Glyph enabling */

	LSERR (WINAPI* pfnFInterruptShaping)(POLS, LSTFLOW, PLSRUN, PLSRUN, BOOL*);
	/* FInterruptShaping:
	 *  pols (IN):
	 *  kTFlow (IN): text direction and orientation
	 *  plsrunFirst (IN): run pointer for the previous run
	 *  plsrunSecond (IN): run pointer for the current run
	 *  &fInterruptShaping (OUT): do you want to interrupt character shaping between these runs
	*/

	LSERR (WINAPI* pfnGetGlyphs)(POLS, PLSRUN, LPCWSTR, DWORD, LSTFLOW, PGMAP, PGINDEX*, PGPROP*, DWORD*);
	/* GetGlyphs:
	 *  pols (IN):
	 *  plsrun (IN): run pointer of the first run
	 *  pwch (IN): pointer to the string of character codes
	 *  cwch (IN): number of characters to be shaped
	 *  kTFlow (IN): text direction and orientation
	 *  rgGmap (OUT): parallel to the char codes mapping wch->glyph info
	 *  &rgGindex (OUT): array of output glyph indices
	 *  &rgGprop (OUT): array of output glyph properties
	 *  &cgindex (OUT): number of output glyph indices
	 */

	LSERR (WINAPI* pfnGetGlyphPositions)(POLS, PLSRUN, LSDEVICE, LPWSTR, PCGMAP, DWORD,
											PCGINDEX, PCGPROP, DWORD, LSTFLOW, int*, PGOFFSET);
	/* GetGlyphPositions:
	 *  pols (IN):
	 *  plsrun (IN): run pointer of the first run
	 *  lsDeviceID (IN): presentation or reference
	 *  pwch (IN): pointer to the string of character codes
	 *  pgmap (IN): array of wch->glyph mapping
	 *  cwch (IN): number of characters to be shaped
	 *  rgGindex (IN): array of glyph indices
	 *  rgGprop (IN): array of glyph properties
	 *  cgindex (IN): number glyph indices
	 *  kTFlow (IN): text direction and orientation
	 *  rgDu (OUT): array of widths of glyphs
	 *  rgGoffset (OUT): array of offsets of glyphs
	 */

	LSERR (WINAPI* pfnResetRunContents)(POLS, PLSRUN, LSCP, LSDCP, LSCP, LSDCP);
	/* ResetRunContents:
	 *  pols (IN):
	 *  plsrun (IN): run pointer as returned from FetchRun
	 *  cpFirstOld (IN): cpFirst before shaping
	 *  dcpOld (IN): dcp before shaping
	 *  cpFirstNew (IN): cpFirst after shaping
	 *  dcpNew (IN): dcp after shaping
	 */

	LSERR (WINAPI* pfnDrawGlyphs)(POLS, PLSRUN, BOOL, BOOL, PCGINDEX, const int*, const int*,
						PGOFFSET, PGPROP, PCEXPTYPE, DWORD,
						LSTFLOW, UINT, const POINT*, PCHEIGHTS, long, long, const RECT*);
	/* DrawGlyphs:
	 *  pols (IN):
	 *  plsrun (IN): run pointer of the first run
	 *  fStrikeout (IN) :
	 *  fUnderline (IN) :
	 *  pglyph (IN): array of glyph indices
	 *  rgDu (IN): array of widths of glyphs
	 *  rgDuBeforeJust (IN): array of widths of glyphs before justification
	 *  rgGoffset (IN): array of offsets of glyphs
	 *  rgGprop (IN): array of glyph properties
	 *  rgExpType (IN): array of glyph expansion types
	 *  cglyph (IN): number glyph indices
	 *  kTFlow (IN): text direction and orientation
	 *  kDisp (IN): display mode - opaque, transparent
	 *  pptRun (IN): starting point of the run
	 *  heightsPres (IN): presentation heights for this run
	 *  dupRun (IN): presentation width for this run
	 *  dupLimUnderline (IN): underlining limit
	 *  pRectClip (IN): clipping rectangle
	 */

	/* Glyph justification */

	LSERR (WINAPI* pfnGetGlyphExpansionInfo)(POLS, PLSRUN, LSDEVICE, LPCWSTR, PCGMAP, DWORD, 
							PCGINDEX, PCGPROP, DWORD, LSTFLOW, BOOL, PEXPTYPE, LSEXPINFO*);
	/* GetGlyphExpansionInfo:
	 *  pols (IN):
	 *  plsrun (IN): run pointer of the first run
	 *  lsDeviceID (IN): presentation or reference
	 *  pwch (IN): pointer to the string of character codes
	 *  rggmap (IN): array of wchar->glyph mapping
	 *  cwch (IN): number of characters to be shaped
	 *  rgglyph (IN): array of glyph indices
	 *  rgProp (IN): array of glyph properties
	 *  cglyph (IN): number glyph indices
	 *  kTFlow (IN): text direction and orientation
	 *  fLastTextChunkOnLine (IN): Last text chunk on line?
	 *  rgExpType (OUT): array of glyph expansion types
	 *  rgexpinfo (OUT): array of glyph expansion info
	 */

	LSERR (WINAPI* pfnGetGlyphExpansionInkInfo)(POLS, PLSRUN, LSDEVICE, GINDEX, GPROP, LSTFLOW, DWORD, long*);
	/* GetGlyphExpansionInkInfo:
	 *  pols (IN):
	 *  plsrun (IN): run pointer of the first run
	 *  lsDeviceID (IN): presentation or reference
	 *  gindex (IN): glyph index
	 *  gprop (IN): glyph properties
	 *  kTFlow (IN): text direction and orientation
	 *  cAddInkDiscrete (IN): number of discrete values (minus 1, because maximum is already known)
	 *  rgDu (OUT): array of discrete values
	 */

	/* FarEast realted typograpy issues */

	LSERR (WINAPI* pfnGetEms)(POLS, PLSRUN, LSTFLOW, PLSEMS);
	/* GetEms:
	 *  pols (IN):
	 *  plsrun (IN): run pointer as returned from FetchRun
	 *  kTFlow (IN): text direction and orientation
	 *  &lsems (OUT): different fractions of EM in appropriate pixels
	 */

	LSERR (WINAPI* pfnPunctStartLine)(POLS, PLSRUN, MWCLS, WCHAR, LSACT*);
	/* PunctStartLine:
	 *  pols (IN):
	 *  plsrun (IN): run pointer for the char
	 *  mwcls (IN): mod width class for the char
	 *  wch (IN): char
	 *  &lsact (OUT): action on the first char on the line
	 */

	LSERR (WINAPI* pfnModWidthOnRun)(POLS, PLSRUN, WCHAR, PLSRUN, WCHAR,
									   LSACT*);
	/* ModWidthOnRun:
	 *  pols (IN):
	 *  plsrunFirst (IN): run pointer for the first char
	 *  wchFirst (IN): first char
	 *  plsrunSecond (IN): run pointer for the second char
	 *  wchSecond (IN): second char
	 *  &lsact (OUT): action on the last char in 1st run
	 */

	LSERR (WINAPI* pfnModWidthSpace)(POLS, PLSRUN, PLSRUN, WCHAR, PLSRUN, WCHAR,
									 LSACT*);
	/* ModWidthSpace:
	 *  pols (IN):
	 *  plsrunCur (IN): run pointer for the current run
	 *  plsrunPrev (IN): run pointer for the previous char
	 *  wchPrev (IN): previous char
	 *  plsrunNext (IN): run pointer for the next char
	 *  wchNext (IN): next char
	 *  &lsact (OUT): action on space's width
	 */

	LSERR (WINAPI* pfnCompOnRun)(POLS, PLSRUN, WCHAR, PLSRUN, WCHAR,
								   LSPRACT*);
	/* CompOnRun:
	 *  pols (IN):
	 *  plsrunFirst (IN): run pointer for the first char
	 *  wchFirst (IN): first char
	 *  plsrunSecond (IN): run pointer for the second char
	 *  wchSecond (IN): second char
	 *  &lspract (OUT): prioritized action on the last char in 1st run
	 */

	LSERR (WINAPI* pfnCompWidthSpace)(POLS, PLSRUN, PLSRUN, WCHAR, PLSRUN, WCHAR,
									  LSPRACT*);
	/* CompWidthSpace:
	 *  pols (IN):
	 *  plsrunCur (IN): run pointer for the current run
	 *  plsrunPrev (IN): run pointer for the previous char
	 *  wchPrev (IN): previous char
	 *  plsrunNext (IN): run pointer for the next char
	 *  wchNext (IN): next char
	 *  &lspract (OUT): prioritized action on space's width
	 */


	LSERR (WINAPI* pfnExpOnRun)(POLS, PLSRUN, WCHAR, PLSRUN, WCHAR,
								  LSACT*);
	/* ExpOnRun:
	 *  pols (IN):
	 *  plsrunFirst (IN): run pointer for the first char
	 *  wchFirst (IN): first char
	 *  plsrunSecond (IN): run pointer for the second char
	 *  wchSecond (IN): second char
	 *  &lsact (OUT): action on the last run char from 1st run
	 */

	LSERR (WINAPI* pfnExpWidthSpace)(POLS, PLSRUN, PLSRUN, WCHAR, PLSRUN,
									   WCHAR, LSACT*);
	/* ExpWidthSpace:
	 *  pols (IN):
	 *  plsrunCur (IN): run pointer for the current run
	 *  plsrunPrev (IN): run pointer for the previous char
	 *  wchPrev (IN): previous char
	 *  plsrunNext (IN): run pointer for the next char
	 *  wchNext (IN): next char
	 *  &lsact (OUT): action on space's width
	 */

	LSERR (WINAPI* pfnGetModWidthClasses)(POLS, PLSRUN, const WCHAR*, DWORD, MWCLS*);
	/* GetModWidthClasses:
	 *  pols (IN):
	 *  plsrun (IN): run pointer for the characters
	 *  rgwch (IN): array of characters
	 *  cwch (IN): number of characters in the rgwch array
	 *  rgmwcls(OUT): array of ModWidthClass's for chars from the rgwch array
	 */

	LSERR (WINAPI* pfnGetBreakingClasses)(POLS, PLSRUN, LSCP, WCHAR, BRKCLS*, BRKCLS*);
	/* GetBreakingClasses:
	 *  pols (IN):
	 *  plsrun (IN): run pointer for the char
	 *  cp (IN): cp of the character
	 *  wch (IN): character
	 *  &brkclsFirst (OUT): breaking class for this char as the leading one in a pair
	 *  &brkclsSecond (OUT): breaking class for this char as the following one in a pair
	 */

	LSERR (WINAPI* pfnFTruncateBefore)(POLS, PLSRUN, LSCP, WCHAR, long, PLSRUN, LSCP, WCHAR, long, long, BOOL*);
	/* FTruncateBefore:
	 *  pols (IN):
	 *	plsrunCur (IN): plsrun of the current character 
	 *  cpCur (IN): cp of truncation char
	 *  wchCur (IN): truncation character 
	 *  durCur (IN): width of truncation character
	 *	plsrunPrev (IN): plsrun of the previous character 
	 *  cpPrev (IN): cp of the previous character
	 *  wchPrev (IN): previous character 
	 *  durPrev (IN): width of truncation character
	 *  durCut (IN): width from the RM until the end of the current character
	 *  &fTruncateBefore (OUT): truncation point is before this character
	 * 			(if it exceeds RM)
	 */
	
	LSERR (WINAPI* pfnCanBreakBeforeChar)(POLS, BRKCLS, BRKCOND*);
	/* CanBreakBeforeChar:
	 *  pols (IN):
	 *	brkcls (IN): breaking class for the char as the following one in a pair
	 *  &brktxtBefore (OUT): break condition before the character
	 */

	LSERR (WINAPI* pfnCanBreakAfterChar)(POLS, BRKCLS, BRKCOND*);
	/* CanBreakAfterChar:
	 *  pols (IN):
	 *  brkcls (IN): breaking class for the char as the leading one in a pair
	 *  &brktxtAfter (OUT): break text condition after the character
	 */


	LSERR (WINAPI* pfnFHangingPunct)(POLS, PLSRUN, MWCLS, WCHAR, BOOL*);
	/* FHangingPunct:
	 *  pols (IN):
	 *  plsrun (IN): run pointer for the char
	 *  mwcls (IN): mod width class of this char
	 *  wch (IN): character
	 *  &fHangingPunct (OUT): can be pushed to the right margin?
	 */

	LSERR (WINAPI* pfnGetSnapGrid)(POLS, WCHAR*, PLSRUN*, LSCP*, DWORD, BOOL*, DWORD*);
	/* GetGridInfo:
	 *  pols (IN):
	 *  rgwch (IN): array of characters
	 *  rgplsrun (IN): array of corresponding plsrun's
	 *  rgcp (IN): array of corresponding cp's
	 *  iwch (IN): number of characters
	 *	rgfSnap (OUT): array of fSnap flags for all characters
	 *	pwGridNumber (OUT): number of grid points on the line
	 */

	LSERR (WINAPI* pfnDrawEffects)(POLS, PLSRUN, UINT,
								   const POINT*, LPCWSTR, const int*, const int*, DWORD, 
								   LSTFLOW, UINT, PCHEIGHTS, long, long, const RECT*);
	/* DrawTextRun:
	 *  pols (IN):
	 *  plsrun (IN):
	 *  EffectsFlags (IN): set of client defined special effects bits
	 *  ppt (IN): output location
	 *  lpwchRun (IN): run of characters
	 *  rgDupRun (IN): widths of characters
	 *  rgDupLeftCut (IN): dup cut from the left side of the char
	 *  cwchRun (IN): number of characters in run
	 *  kTFlow (IN): text direction and orientation
	 *  kDisp (IN): display mode - opaque, transparent
	 *  heightsPres (IN): presentation heights for this run
	 *  dupRun (IN): presentation width for this run
	 *  dupLimUnderline (IN): underlining limit
	 *  pRectClip (IN): clipping rectangle
	 */

	LSERR (WINAPI* pfnFCancelHangingPunct)(POLS, LSCP, LSCP, WCHAR, MWCLS, BOOL*);

	/* FCancelHangingPunct:
	 *  pols (IN):
	 *  cpLim (IN): cpLim of the line
	 *  cpLastAdjustable (IN): cp of the last adjustable character on the line
	 *  wch (IN): last character
	 *  mwcls (IN): mod width class of this char
	 *  pfCancelHangingPunct (OUT): cancel hanging punctuation?
	*/

	LSERR (WINAPI* pfnModifyCompAtLastChar)(POLS, LSCP, LSCP, WCHAR, MWCLS, long, long, long*);

	/* ModifyCompAtLastChar:
	 *  pols (IN):
	 *  cpLim (IN): cpLim of the line
	 *  cpLastAdjustable (IN): cp of the last adjustable character on the line
	 *  wch (IN): last character
	 *  mwcls (IN): mod width class of this char
	 *  durCompLastRight (IN): suggested compression on the right side
	 *  durCompLastLeft (IN): suggested compression on the left side
	 *  pdurCahngeComp (OUT): change compression amount on the last char
	*/

	/* Enumeration callbacks */

	LSERR (WINAPI* pfnEnumText)(POLS, PLSRUN, LSCP, LSDCP, LPCWSTR, DWORD, LSTFLOW, BOOL,
											BOOL, const POINT*, PCHEIGHTS, long, BOOL, long*);
	/* EnumText:
	 *  pols (IN):
	 *  plsrun (IN): from DNODE
	 *  cpFirst (IN): from DNODE
	 *  dcp (IN): from DNODE
	 *  rgwch(IN): array of characters
	 *  cwch(IN): number of characters
	 *  lstflow (IN): text flow
	 *  fReverseOrder (IN): enumerate in reverse order
	 *  fGeometryProvided (IN):
	 *  pptStart (IN): starting position, iff fGeometryProvided
	 *  pheightsPres(IN): from DNODE, relevant iff fGeometryProvided
	 *  dupRun(IN): from DNODE, relevant iff fGeometryProvided
	 *  fCharWidthProvided (IN):
	 *  rgdup(IN): array of character widths, iff fCharWidthProvided
	*/

	LSERR (WINAPI* pfnEnumTab)(POLS, PLSRUN, LSCP, LPCWSTR, WCHAR, LSTFLOW, BOOL,
													BOOL, const POINT*, PCHEIGHTS, long);
	/* EnumTab:
	 *  pols (IN):
	 *  plsrun (IN): from DNODE
	 *  cpFirst (IN): from DNODE
	 *  rgwch(IN): Pointer to one Tab character
	 *  wchTabLeader (IN): tab leader
	 *  lstflow (IN): text flow
	 *  fReverseOrder (IN): enumerate in reverse order
	 *  fGeometryProvided (IN):
	 *  pptStart (IN): starting position, iff fGeometryProvided
	 *  pheightsPres(IN): from DNODE, relevant iff fGeometryProvided
	 *  dupRun(IN): from DNODE, relevant iff fGeometryProvided
	*/

	LSERR (WINAPI* pfnEnumPen)(POLS, BOOL, LSTFLOW, BOOL, BOOL, const POINT*, long, long);
	/* EnumPen:
	 *  pols (IN):
	 *  fBorder (IN):
	 *  lstflow (IN): text flow
	 *  fReverseOrder (IN): enumerate in reverse order
	 *  fGeometryProvided (IN):
	 *  pptStart (IN): starting position, iff fGeometryProvided
	 *  dup(IN): from DNODE iff fGeometryProvided
	 *  dvp(IN): from DNODE iff fGeometryProvided
	*/

	/* Objects bundling */

	LSERR (WINAPI* pfnGetObjectHandlerInfo)(POLS, DWORD, void*);
	/* GetObjectHandlerInfo:
	 *  pols (IN):
	 *  idObj (IN): id of the object handler
	 *  pObjectInfo (OUT): initialization information of the specified object
	*/


	/* Debugging APIs */
	void (WINAPI *pfnAssertFailed)(char*, char*, int);

};
typedef struct lscbk LSCBK;

#endif /* !LSCBK_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lscontxt.h ===
#ifndef LSCONTXT_DEFINED
#define LSCONTXT_DEFINED

#include "lsdefs.h"
#include "lscbk.h"
#include "lstxtcfg.h"
#include "lsimeth.h"


typedef struct 
{
	DWORD version;						/* version number	*/
	DWORD cInstalledHandlers;
	const LSIMETHODS* pInstalledHandlers; /* Installed handlers */
	LSTXTCFG lstxtcfg;					/* Straight-text configuration data */
	POLS pols;							/* Client data for this context */
	LSCBK lscbk;						/* LineServices client callbacks */
	BOOL fDontReleaseRuns;				/* Optimization---don't call pfnReleaseRun */
} LSCONTEXTINFO;


LSERR WINAPI LsCreateContext(const LSCONTEXTINFO*, PLSC*);
LSERR WINAPI LsDestroyContext(PLSC);

#endif /* LSCONTXT_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lschp.h ===
#ifndef LSCHP_DEFINED
#define LSCHP_DEFINED

#include "lsdefs.h"
#include "plschp.h"

#define idObjTextChp	((WORD)~0)		/* idObj for FetchRun to use  */
										/*  when returning a text run */
										/*  (Internal id will differ.) */

/* LS expects that for GlyphBased runs the following flags are set to FALSE:
			fApplyKern
			fModWidthSpace
			fModWidthPairs
			fCompressTable
*/

struct lschp							/* Character properties */
{
	WORD idObj;							/* Object type */
	BYTE dcpMaxContext;

	BYTE EffectsFlags;

    /* Property flags */
	UINT fApplyKern : 1;
	UINT fModWidthOnRun:1;
	UINT fModWidthSpace:1;
	UINT fModWidthPairs:1;
	UINT fCompressOnRun:1;
	UINT fCompressSpace:1;
	UINT fCompressTable:1;
	UINT fExpandOnRun:1;
	UINT fExpandSpace:1;
	UINT fExpandTable:1;
	UINT fGlyphBased : 1;

	UINT pad1:5;

	UINT fInvisible : 1;
	UINT fUnderline : 1;				
	UINT fStrike : 1;
	UINT fShade : 1;				
	UINT fBorder : 1;				
	UINT fHyphen : 1;					/* Hyphenation opportunity (YSR info) */
	UINT fCheckForReplaceChar : 1;		/* Activate the replace char mechanizm for Yen	*/

	UINT pad2:9;
										/* for dvpPos values, */
										/*  pos => raised, neg => lowered, */
	long dvpPos;
};

typedef struct lschp LSCHP;

#endif /* !LSCHP_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lscrline.h ===
#ifndef LSCRLINE_DEFINED
#define LSCRLINE_DEFINED

#include "lsdefs.h"
#include "plsline.h"
#include "breakrec.h"
#include "lslinfo.h"

LSERR WINAPI LsCreateLine(PLSC,				/* IN: ptr to line services context		*/
						  LSCP,				/* IN: cpFirst							*/
						  long,				/* IN: duaColumn						*/
						  const BREAKREC*,	/* IN: input array of break records		*/
						  DWORD,			/* IN: number of records in input array	*/
						  DWORD,			/* IN: size of the output array			*/
						  BREAKREC*,		/* OUT: output array of break records	*/
						  DWORD*,			/* OUT:actual number of records in array*/
						  LSLINFO*,			/* OUT: visible line info				*/
						  PLSLINE*);		/* OUT: ptr to line opaque to client	*/

LSERR WINAPI LsModifyLineHeight(PLSC,		/* IN: ptr to line services context 	*/
								PLSLINE,	/* IN: ptr to line -- opaque to client	*/
								long,		/* IN: dvpAbove							*/
								long,		/* IN: dvpAscent						*/
								long,		/* IN: dvpDescent						*/	
								long);		/* IN: dvpBelow							*/	

LSERR WINAPI LsDestroyLine(PLSC,			/* IN: ptr to line services context		*/
						   PLSLINE);		/* IN: ptr to line -- opaque to client	*/

LSERR WINAPI LsGetLineDur(PLSC,				/* IN: ptr to line services context 	*/
						  PLSLINE,			/* IN: ptr to line -- opaque to client	*/
						  long*,			/* OUT: dur of line incl. trailing area	*/
						  long*);			/* OUT: dur of line excl. trailing area	*/

LSERR WINAPI LsGetMinDurBreaks(PLSC,		/* IN: ptr to line services context 	*/
						  	   PLSLINE,		/* IN: ptr to line -- opaque to client	*/
						  	   long*,		/* OUT: min dur between breaks including 
																	trailing area	*/
						  	   long*);		/* OUT: min dur between breaks excluding 
																	trailing area	*/

#endif /* !LSCRLINE_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lsdevice.h ===
#ifndef LSDEVICE_DEFINED
#define LSDEVICE_DEFINED

enum lsdevice				/* Parameter for pfnGetRunTextMetrics callback */
{
	lsdevPres,
	lsdevReference
};

typedef enum lsdevice LSDEVICE;

#endif /* !LSDEVICE_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lsdevres.h ===
#ifndef LSDEVRES_DEFINED
#define LSDEVRES_DEFINED

typedef struct
{
	long dxpInch, dypInch;				/* resolution of preview device */
	long dxrInch, dyrInch;				/* resolution of reference device */
} LSDEVRES;

#endif /* !LSDEVRES_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lscrsubl.h ===
#ifndef LSCRSUBL_DEFINED
#define LSCRSUBL_DEFINED

/* Line services formatter fetch/dispatcher interface (to LsCreateLine())
 */

#include "lsdefs.h"
#include "lsfrun.h"
#include "lsesc.h"
#include "plssubl.h"
#include "plsdnode.h"
#include "fmtres.h"
#include "objdim.h"
#include "lstflow.h"
#include "lskjust.h"
#include "breakrec.h"
#include "brkkind.h"
#include "brkpos.h"

LSERR WINAPI LsCreateSubline(
							PLSC,			/* IN: LS context						*/
							LSCP,			/* IN: cpFirst							*/
						    long,			/* IN: urColumnMax						*/
							LSTFLOW,		/* IN: text flow						*/
							BOOL);			/* IN: fContiguous						*/

LSERR WINAPI LsFetchAppendToCurrentSubline(
							PLSC,			/* IN: LS context						*/
							LSDCP,			/* IN:Increase cp before fetching		*/
						    const LSESC*,	/* IN: escape characters				*/
						    DWORD,			/* IN: # of escape characters			*/
							BOOL*,			/* OUT: Successful?---if not, finish 
												subline, destroy it and start anew	*/
						    FMTRES*,		/* OUT: result of last formatter		*/
						    LSCP*,			/* OUT: cpLim							*/
						    PLSDNODE*,		/* OUT: First DNODE created				*/
						 	PLSDNODE*);		/* OUT: Last DNODE created				*/

LSERR WINAPI LsFetchAppendToCurrentSublineResume(
							PLSC,			/* IN: LS context						*/
							const BREAKREC*,/* IN: array of break records			*/
							DWORD,			/* IN: number of records in array		*/
							LSDCP,			/* IN:Increase cp before fetching		*/
						    const LSESC*,	/* IN: escape characters				*/
						    DWORD,			/* IN: # of escape characters			*/
							BOOL*,			/* OUT: Successful?---if not, finish 
												subline, destroy it and start anew	*/
						    FMTRES*,		/* OUT: result of last formatter		*/
						    LSCP*,			/* OUT: cpLim							*/
						    PLSDNODE*,		/* OUT: First DNODE created				*/
						 	PLSDNODE*);		/* OUT: Last DNODE created				*/

LSERR WINAPI LsAppendRunToCurrentSubline(		/* Simple runs only	*/
							PLSC,			/* IN: LS context						*/
						    const LSFRUN*,	/* IN: given run						*/
							BOOL*,			/* OUT: Successful?---if not, finish 
												subline, destroy it and start anew	*/
						    FMTRES*,		/* OUT: result of last formatter		*/
						    LSCP*,			/* OUT: cpLim							*/
						    PLSDNODE*);		/* OUT: DNODE created					*/

LSERR WINAPI LsResetRMInCurrentSubline(
							PLSC,			/* IN: LS context						*/
						    long);			/* IN: urColumnMax						*/

LSERR WINAPI LsFinishCurrentSubline(
							PLSC,			/* IN: LS context						*/
							PLSSUBL*);		/* OUT: subline context					*/


LSERR WINAPI LsTruncateSubline(
							PLSSUBL,		/* IN: subline context					*/
							long,			/* IN: urColumnMax						*/
							LSCP*);			/* OUT: cpTruncate 						*/

LSERR WINAPI LsFindPrevBreakSubline(
							PLSSUBL,		/* IN: subline context					*/
							BOOL,			/* IN: fFirstSubline					*/
							LSCP,			/* IN: truncation cp					*/
						    long,			/* IN: urColumnMax						*/
							BOOL*,			/* OUT: fSuccessful?					*/
							LSCP*,			/* OUT: cpBreak							*/
							POBJDIM,		/* OUT: objdimSub up to break			*/
							BRKPOS*);		/* OUT: Before/Inside/After				*/

LSERR WINAPI LsFindNextBreakSubline(
							PLSSUBL,		/* IN: subline context					*/
							BOOL,			/* IN: fFirstSubline					*/
							LSCP,			/* IN: truncation cp					*/
						    long,			/* IN: urColumnMax						*/
							BOOL*,			/* OUT: fSuccessful?					*/
							LSCP*,			/* OUT: cpBreak							*/
							POBJDIM,		/* OUT: objdimSub up to break			*/			
							BRKPOS*);		/* OUT: Before/Inside/After				*/

LSERR WINAPI LsForceBreakSubline(
							PLSSUBL,		/* IN: subline context					*/
							BOOL,			/* IN: fFirstSubline					*/
							LSCP,			/* IN: truncation cp					*/
						    long,			/* IN: urColumnMax						*/
							LSCP*,			/* OUT: cpBreak							*/
							POBJDIM,		/* OUT: objdimSub up to break			*/			
							BRKPOS*);		/* OUT: Before/Inside/After				*/

LSERR WINAPI LsSetBreakSubline(
							PLSSUBL,		/* IN: subline context					*/
							BRKKIND,		/* IN: Prev/Next/Force/Imposed			*/			
							DWORD,			/* IN: size of array					*/
							BREAKREC*, 		/* OUT: array of break records			*/
							DWORD*);		/* OUT: number of used elements of the array*/

LSERR WINAPI LsDestroySubline(PLSSUBL);

LSERR WINAPI LsMatchPresSubline(
							  PLSSUBL);		/* IN: subline context		*/

LSERR WINAPI LsExpandSubline(
							  PLSSUBL,		/* IN: subline context		*/
							  LSKJUST,		/* IN: justification type	*/
							  long);		/* IN: dup					*/

LSERR WINAPI LsCompressSubline(
							  PLSSUBL,		/* IN: subline context		*/
							  LSKJUST,		/* IN: justification type	*/
							  long);		/* IN: dup					*/

LSERR WINAPI LsSqueezeSubline(
							  PLSSUBL,		/* IN: subline context		*/
							  long,			/* IN: durTarget			*/
							  BOOL*,		/* OUT: fSuccessful?		*/
							  long*);		/* OUT: if nof successful, 
													extra dur 			*/

LSERR WINAPI LsGetSpecialEffectsSubline(
							  PLSSUBL,		/* IN: subline context		*/
							  UINT*);		/* OUT: special effects		*/

#endif /* !LSCRSUBL_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lsdnfin.h ===
#ifndef LSDNFIN_DEFINED
#define LSDNFIN_DEFINED

/* Access routines for contents of DNODES */

#include "lsdefs.h"
#include "plsrun.h"
#include "plsfrun.h"
#include "plschp.h"
#include "pobjdim.h"
#include "pdobj.h"


LSERR WINAPI LsdnFinishRegular(
							  PLSC,				/* IN: Pointer to LS Context */
							  LSDCP,     		/* IN: dcp adopted           */
							  PLSRUN,   		/* IN: PLSRUN  		         */
							  PCLSCHP,  		/* IN: CHP          	     */
							  PDOBJ,    		/* IN: PDOBJ             	 */ 
							  PCOBJDIM);		/* IN: OBJDIM      		     */

LSERR WINAPI LsdnFinishRegularAddAdvancePen(
							  PLSC,				/* IN: Pointer to LS Context */
							  LSDCP,     		/* IN: dcp adopted           */
							  PLSRUN,   		/* IN: PLSRUN  		         */
							  PCLSCHP,  		/* IN: CHP          	     */
							  PDOBJ,    		/* IN: PDOBJ             	 */ 
							  PCOBJDIM,			/* IN: OBJDIM      		     */
							  long,				/* IN: durPen				 */
							  long,				/* IN: dvrPen				 */
							  long);			/* IN: dvpPen 				 */

LSERR WINAPI LsdnFinishByPen(PLSC,				/* IN: Pointer to LS Context */
						   LSDCP, 	    		/* IN: dcp	adopted          */
						   PLSRUN,		   		/* IN: PLSRUN  		         */
						   PDOBJ,	    		/* IN: PDOBJ             	 */ 
						   long,    	 		/* IN: dur         		     */
						   long,     			/* IN: dvr             		 */
						   long);   			/* IN: dvp          	     */

LSERR WINAPI LsdnFinishDeleteAll(PLSC,			/* IN: Pointer to LS Context */
					  			LSDCP);			/* IN: dcp adopted			 */

#endif /* !LSDNFIN_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lsdefs.h ===
/* Common definitions for line services
 */

#ifndef LSDEFS_DEFINED
#define LSDEFS_DEFINED

#ifdef UNIX
#include <wchar.h>
#endif

#ifndef WINVER	/* defined in <windows.h> */

/* <windows.h> must be included FIRST, if at all. */
/* We define basic types if <windows.h> is not included. */

#ifndef NULL
#define NULL    ((void *)0)
#endif /* NULL */

#ifdef UNDER_CE
#define WINAPI __cdecl	/* CE converts all stdcall's to cdecl's */
#else
#define WINAPI __stdcall
#endif

#define FALSE	0
#define TRUE	1

typedef int BOOL;
typedef long LONG;
typedef unsigned long DWORD;
typedef unsigned short WORD;
typedef unsigned int UINT;
typedef unsigned char BYTE;
typedef int INT;
#ifdef UNIX
typedef wchar_t WCHAR;
#else
typedef WORD WCHAR;
#endif
typedef const WCHAR* LPCWSTR;
typedef WCHAR* LPWSTR;

typedef struct tagRECT
{
    LONG    left;
    LONG    top;
    LONG    right;
    LONG    bottom;
} RECT;

typedef struct tagPOINT
{
    LONG  x;
    LONG  y;
} POINT;

#endif /* WINVER */


/* Line services definitions */
struct lscontext;					/* Opaque to clients */
typedef struct lscontext* PLSC;
typedef const struct lscontext* PCLSC;

struct ols;								/* Owner of LineServices */
typedef struct ols* POLS;				/*  (Opaque to LineService) */

typedef long LSCP;
typedef DWORD LSDCP;

typedef WORD GINDEX;
typedef GINDEX* PGINDEX;
typedef const GINDEX* PCGINDEX;

typedef struct tagPOINTUV
{
    LONG  u;
    LONG  v;
} POINTUV;

typedef POINTUV* PPOINTUV;
typedef const POINTUV* PCPOINTUV;

#ifndef __usp10__   // defined in usp10.h
typedef struct tagGOFFSET
{
    LONG  du;
    LONG  dv;
} GOFFSET;
#endif

typedef GOFFSET* PGOFFSET;
typedef const GOFFSET* PCGOFFSET;

/* Line services error codes */
typedef long LSERR;
#define lserrNone						( 0L)
#ifdef LSERRSTOP				/* stop immediately, don't return error */
#define lserrInvalidParameter   		AssertErr("lserrInvalidParameter")  	
#define lserrOutOfMemory    			AssertErr("lserrOutOfMemory")
#define lserrNullOutputParameter  		AssertErr("lserrNullOutputParameter") 
#define lserrInvalidContext    			AssertErr("lserrInvalidContext") 
#define lserrInvalidLine    			AssertErr("lserrInvalidLine")
#define lserrInvalidDnode    			AssertErr("lserrInvalidDnode")    
#define lserrInvalidDeviceResolution 	AssertErr("lserrInvalidDeviceResolution")
#define lserrInvalidRun  			   	AssertErr("lserrInvalidRun")
#define lserrMismatchLineContext  		AssertErr("lserrMismatchLineContext")
#define lserrContextInUse    			AssertErr("lserrContextInUse")
#define lserrDuplicateSpecialCharacter 	AssertErr("lserrDuplicateSpecialCharacter")
#define lserrInvalidAutonumRun  		AssertErr("lserrInvalidAutonumRun")
#define lserrFormattingFunctionDisabled AssertErr("lserrFormattingFunctionDisabled")
#define lserrUnfinishedDnode   			AssertErr("lserrUnfinishedDnode")
#define lserrInvalidDnodeType   		AssertErr("lserrInvalidDnodeType")
#define lserrInvalidPenDnode   			AssertErr("lserrInvalidPenDnode")   
#define lserrInvalidNonPenDnode   		AssertErr("lserrInvalidNonPenDnode")
#define lserrInvalidBaselinePenDnode 	AssertErr("lserrInvalidBaselinePenDnode")
#define lserrInvalidFormatterResult  	AssertErr("lserrInvalidFormatterResult")
#define lserrInvalidObjectIdFetched  	AssertErr("lserrInvalidObjectIdFetched")
#define lserrInvalidDcpFetched   		AssertErr("lserrInvalidDcpFetched")
#define lserrInvalidCpContentFetched 	AssertErr("lserrInvalidCpContentFetched")
#define lserrInvalidBookmarkType  		AssertErr("lserrInvalidBookmarkType")
#define lserrSetDocDisabled    			AssertErr("lserrSetDocDisabled")
#define lserrFiniFunctionDisabled  		AssertErr("lserrFiniFunctionDisabled")
#define lserrCurrentDnodeIsNotTab  		AssertErr("lserrCurrentDnodeIsNotTab")
#define lserrPendingTabIsNotResolved	AssertErr("lserrPendingTabIsNotResolved")
#define lserrWrongFiniFunction 			AssertErr("lserrWrongFiniFunction")
#define lserrInvalidBreakingClass		AssertErr("lserrInvalidBreakingClass")
#define lserrBreakingTableNotSet		AssertErr("lserrBreakingTableNotSet")
#define lserrInvalidModWidthClass		AssertErr("lserrInvalidModWidthClass")
#define lserrModWidthPairsNotSet		AssertErr("lserrModWidthPairsNotSet")
#define lserrWrongTruncationPoint 		AssertErr("lserrWrongTruncationPoint")
#define lserrWrongBreak 				AssertErr("lserrWrongBreak")
#define lserrDupInvalid 				AssertErr("lserrDupInvalid")
#define lserrRubyInvalidVersion			AssertErr("lserrRubyVersionInvalid")
#define lserrTatenakayokoInvalidVersion	AssertErr("lserrTatenakayokoInvalidVersion")
#define lserrWarichuInvalidVersion		AssertErr("lserrWarichuInvalidVersion")
#define lserrWarichuInvalidData			AssertErr("lserrWarichuInvalidData")
#define lserrCreateSublineDisabled		AssertErr("lserrCreateSublineDisabled")
#define lserrCurrentSublineDoesNotExist	AssertErr("lserrCurrentSublineDoesNotExist")
#define lserrCpOutsideSubline			AssertErr("lserrCpOutsideSubline")
#define lserrHihInvalidVersion			AssertErr("lserrHihInvalidVersion")
#define lserrInsufficientQueryDepth		AssertErr("lserrInsufficientQueryDepth")
#define lserrInsufficientBreakRecBuffer	AssertErr("lserrInsufficientBreakRecBuffer")
#define lserrInvalidBreakRecord			AssertErr("lserrInvalidBreakRecord")
#define lserrInvalidPap					AssertErr("lserrInvalidPap")
#define lserrContradictoryQueryInput	AssertErr("lserrContradictoryQueryInput")
#define lserrLineIsNotActive			AssertErr("lserrLineIsNotActive")
#define lserrTooLongParagraph			AssertErr("lserrTooLongParagraph")
#else
#define lserrInvalidParameter			(-1L)
#define lserrOutOfMemory				(-2L)
#define lserrNullOutputParameter		(-3L)
#define lserrInvalidContext				(-4L)
#define lserrInvalidLine				(-5L)
#define lserrInvalidDnode				(-6L)
#define lserrInvalidDeviceResolution	(-7L)
#define lserrInvalidRun					(-8L)
#define lserrMismatchLineContext		(-9L)
#define lserrContextInUse				(-10L)
#define lserrDuplicateSpecialCharacter	(-11L)
#define lserrInvalidAutonumRun			(-12L)
#define lserrFormattingFunctionDisabled	(-13L)
#define lserrUnfinishedDnode			(-14L)
#define lserrInvalidDnodeType			(-15L)
#define lserrInvalidPenDnode			(-16L)
#define lserrInvalidNonPenDnode			(-17L)
#define lserrInvalidBaselinePenDnode	(-18L)
#define lserrInvalidFormatterResult		(-19L)
#define lserrInvalidObjectIdFetched		(-20L)
#define lserrInvalidDcpFetched			(-21L)
#define lserrInvalidCpContentFetched	(-22L)
#define lserrInvalidBookmarkType		(-23L)
#define lserrSetDocDisabled				(-24L)
#define lserrFiniFunctionDisabled		(-25L)
#define lserrCurrentDnodeIsNotTab		(-26L)
#define lserrPendingTabIsNotResolved    (-27L)
#define lserrWrongFiniFunction 			(-28L)
#define lserrInvalidBreakingClass		(-29L)
#define lserrBreakingTableNotSet		(-30L)
#define lserrInvalidModWidthClass		(-31L)
#define lserrModWidthPairsNotSet		(-32L)
#define lserrWrongTruncationPoint 		(-33L)
#define lserrWrongBreak 				(-34L)
#define	lserrDupInvalid					(-35L)
#define lserrRubyInvalidVersion			(-36L)
#define lserrTatenakayokoInvalidVersion	(-37L)
#define lserrWarichuInvalidVersion		(-38L)
#define lserrWarichuInvalidData			(-39L)
#define lserrCreateSublineDisabled		(-40L)
#define lserrCurrentSublineDoesNotExist	(-41L)
#define lserrCpOutsideSubline			(-42L)
#define lserrHihInvalidVersion			(-43L)
#define lserrInsufficientQueryDepth		(-44L)
#define lserrInsufficientBreakRecBuffer	(-45L)
#define lserrInvalidBreakRecord			(-46L)
#define lserrInvalidPap					(-47L)
#define lserrContradictoryQueryInput	(-48L)
#define lserrLineIsNotActive			(-49L)
#define lserrTooLongParagraph			(-50L)
#endif	/* LSERRORSTOP */


#ifndef fTrue
#define fTrue	1
#define fFalse	0
#endif

#define uLsInfiniteRM	0x3FFFFFFF

#define czaUnitInch					(1440L) /* 1440 absolute units per inch */

#endif /* LSDEFS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lsdocinf.h ===
#ifndef LSDOCINF_DEFINED
#define LSDOCINF_DEFINED

#include "lsdefs.h"
#include "plsdocin.h"
#include "lsdevres.h"

typedef struct lsdocinf
{
	BOOL fDisplay;
	BOOL fPresEqualRef;
	LSDEVRES lsdevres;
} LSDOCINF;

#endif /* !LSDOCINF_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lsdsply.h ===
#ifndef LSDSPLY_DEFINED
#define LSDSPLY_DEFINED

#include "lsdefs.h"
#include "plsline.h"

LSERR WINAPI LsDisplayLine(PLSLINE, const POINT*, UINT, const RECT*);
/* LsDisplayLine
 *  pline (IN)
 *  ppt (IN)
 *  kDisp (IN): transparent or opaque
 *  &rcClip (IN): clipping rect
 */

#endif /* !LSDSPLY_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lsems.h ===
#ifndef LSEMS_DEFINED
#define LSEMS_DEFINED

#include "lsdefs.h"

typedef struct lsems
{
	long em;		/* one em			*/
	long em2;		/* half em			*/
	long em3;		/* third em			*/
	long em4;		/* quater em		*/
	long em8;		/* eighth em		*/
	long em16;		/* 15/16 of em		*/
	long udExp;		/* user defined expansion	*/
	long udComp;	/* user defined compression*/
} LSEMS;



#endif /* !LSEMS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lsdssubl.h ===
#ifndef LSDSSUBL_DEFINED
#define LSDSSUBL_DEFINED

/* Line services formatter fetch/dispatcher interface (to LsCreateLine())
 */

#include "lsdefs.h"
#include "plssubl.h"


LSERR WINAPI LsDisplaySubline(
							PLSSUBL,			/* IN: subline context			*/
							const POINT*,		/* IN: starting position(xp, yp)*/
							UINT,				/* IN: display mode, opaque, etc */
							const RECT*);		/* IN: clip rectangle (xp, yp,...) */

#endif /* !LSDSSUBL_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lsensubl.h ===
#ifndef LSENSUBL_DEFINED
#define LSENSUBL_DEFINED

/* Line services formatter fetch/dispatcher interface (to LsCreateLine())
 */

#include "lsdefs.h"
#include "plssubl.h"


LSERR WINAPI LsEnumSubline(PLSSUBL,
						   BOOL,			/* IN: enumerate in reverse order?					*/
						   BOOL,			/* IN: geometry needed?								*/
						   const POINT*);	/* IN: starting position(xp, yp) iff fGeometryNeeded*/
#endif /* !LSENSUBL_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lsdnset.h ===
#ifndef LSDNSET_DEFINED
#define LSDNSET_DEFINED

/* Access routines for contents of DNODES */

#include "lsdefs.h"
#include "plssubl.h"
#include "plsdnode.h"
#include "pobjdim.h"
#include "lsktab.h"
#include "lskeop.h"

LSERR WINAPI LsdnQueryObjDimRange(
								  PLSC,			/* IN: Pointer to LS Context */
							 	  PLSDNODE,		/* IN: plsdnFirst -- First DNODE in range */
								  PLSDNODE,		/* IN: plsdnLast -- Last DNODE in range */
							 	  POBJDIM);		/* OUT: dimensions of range */


LSERR WINAPI LsdnResetObjDim(
								 PLSC,			/* IN: Pointer to LS Context	*/
								 PLSDNODE,		/* IN: plsdnFirst 				*/
								 PCOBJDIM);		/* IN: dimensions of dnode 		*/


LSERR WINAPI LsdnQueryPenNode(
							  PLSC,				/* IN: Pointer to LS Context*/
						  	  PLSDNODE,			/* IN: DNODE queried		*/
						  	  long*,			/* OUT: &dvpPen				*/
						  	  long*,			/* OUT: &durPen				*/
						  	  long*);			/* OUT: &dvrPen				*/


LSERR WINAPI LsdnResetPenNode(
							  PLSC,				/* IN: Pointer to LS Context */
						  	  PLSDNODE,			/* IN: DNODE to be modified */
						  	  long,				/* IN: dvpPen */
						  	  long,				/* IN: durPen */
						  	  long);			/* IN: dvrPen */

LSERR WINAPI LsdnSetRigidDup(
							 PLSC,				/* IN: Pointer to LS Context */
							 PLSDNODE,			/* IN: DNODE to be modified	 */
							 long);				/* IN: dup					 */

LSERR WINAPI LsdnGetDup(
							 PLSC,				/* IN: Pointer to LS Context */
							 PLSDNODE,			/* IN: DNODE queried		 */
							 long*);			/* OUT: dup					 */

LSERR WINAPI LsdnSetAbsBaseLine(
								PLSC,			/* IN: Pointer to LS Context */
							  	long);    		/* IN: new vaBase            */

LSERR WINAPI LsdnModifyParaEnding(
								PLSC,			/* IN: Pointer to LS Context */
								LSKEOP);		/* IN: Kind of line ending			*/

LSERR WINAPI LsdnResolvePrevTab(PLSC);			/* IN: Pointer to LS Context */

LSERR WINAPI LsdnGetCurTabInfo(
							PLSC,				/* IN: Pointer to LS Context */
							LSKTAB*);			/* OUT: Type of current tab  */

LSERR WINAPI LsdnSkipCurTab(PLSC);					/* IN: Pointer to LS Context */

LSERR WINAPI LsdnDistribute(
							PLSC,				/* IN: Pointer to LS Context	*/
							PLSDNODE,			/* IN: First DNODE				*/
							PLSDNODE,			/* IN: Last DNODE				*/
							long);				/* IN: durToDistribute			*/

LSERR WINAPI LsdnSubmitSublines(
							PLSC,				/* IN: Pointer to LS Context	*/
							PLSDNODE,			/* IN: DNODE					*/
							DWORD,				/* IN: cSublinesSubmitted		*/
							PLSSUBL*,			/* IN: rgpsublSubmitted			*/
							BOOL,				/* IN: fUseForJustification		*/
							BOOL,				/* IN: fUseForCompression		*/
							BOOL,				/* IN: fUseForDisplay			*/
							BOOL,				/* IN: fUseForDecimalTab		*/
							BOOL				/* IN: fUseForTrailingArea		*/
							);											
LSERR WINAPI LsdnGetFormatDepth(
							PLSC,				/* IN: Pointer to LS Context	*/
							DWORD*);			/* OUT: nDepthFormatLineMax		*/

#endif /* !LSDNSET_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lsenum.h ===
#ifndef LSENUM_DEFINED
#define LSENUM_DEFINED

#include "lsdefs.h"
#include "plsline.h"

LSERR WINAPI LsEnumLine(PLSLINE,
					   	BOOL,			/* IN: enumerate in reverse order?					*/
						BOOL,			/* IN: geometry needed?								*/
						const POINT*);	/* IN: starting position(xp, yp) iff fGeometryNeeded*/

#endif /* LSENUM_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lsesc.h ===
#ifndef LSESC_DEFINED
#define LSESC_DEFINED

/* Definition of Line Services escape characters.
 * Used for LsFetchDispatchEsc().
 */

#include "lsdefs.h"

typedef struct
{
	WCHAR wchFirst, wchLast;			/* Range of chars codes */
} LSESC;


#endif /* !LSESC_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lsfgi.h ===
#ifndef LSFGI_DEFINED
#define LSFGI_DEFINED

#include "lsdefs.h"
#include "lstflow.h"
#include "plsfgi.h"

/* ------------------------------------------------------------------------ */

struct lsfgi							/* Formatter geometry input */
{
	BOOL fFirstOnLine;	/* REVIEW sergeyge(elik): Query instead of this member? */
	LSCP cpFirst;
	long urPen,vrPen;
	long urColumnMax;
	LSTFLOW lstflow;
};
typedef struct lsfgi LSFGI;

#endif /* !LSFGI_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lsfrun.h ===
#ifndef LSFRUN_DEFINED
#define LSFRUN_DEFINED

#include "lsdefs.h"
#include "plschp.h"
#include "plsrun.h"
#include "plsfrun.h"

struct lsfrun							/* Formatter run */
{
	PCLSCHP plschp;
	PLSRUN plsrun;
	LPCWSTR lpwchRun;
	DWORD cwchRun;
};
typedef struct lsfrun LSFRUN;

#endif /* !LSFRUN_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lshyph.h ===
#ifndef LSHYPH_DEFINED
#define LSHYPH_DEFINED

#include "lsdefs.h"
#include "plshyph.h"

struct lshyph							/* Output of pfnHyphenate callback */
{
	UINT kysr;							/* Kind of Ysr - see "lskysr.h" */
	LSCP cpYsr;							/* cp value of YSR */
	WCHAR wchYsr;						/* YSR char code  */
};

#endif /* !LSHYPH_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lsffi.h ===
#ifndef LSFFI_DEFINED
#define LSFFI_DEFINED


/* Line Services "format flags" (from LSPAP ) */

/* Visi flags	*/
#define fFmiVisiCondHyphens			0x00000001L
#define fFmiVisiParaMarks			0x00000002L
#define fFmiVisiSpaces				0x00000004L
#define fFmiVisiTabs				0x00000008L
#define fFmiVisiSplats				0x00000010L
#define fFmiVisiBreaks				0x00000020L


/* Advanced typography enabling    */
#define fFmiPunctStartLine			0x00000040L
#define fFmiHangingPunct			0x00000080L
#define fFmiApplyBreakingRules		0x00000100L

/* WYSIWYG flags */
#define fFmiPresSuppressWiggle		0x00000200L
#define fFmiPresExactSync			0x00000400L

/* Autonumbering flags */
#define fFmiAnm						0x00000800L

/* Miscellaneous flags */
#define fFmiAutoDecimalTab			0x00001000L
#define fFmiUnderlineTrailSpacesRM	0x00002000L

#define fFmiSpacesInfluenceHeight	0x00004000L

#define fFmiIgnoreSplatBreak		0x00010000L
#define fFmiLimSplat				0x00020000L
#define fFmiAllowSplatLine			0x00040000L

#define	fFmiForceBreakAsNext		0x00080000L
#define fFmiFCheckTruncateBefore	0x00100000L

#define fFmiDoHyphenation			0x00200000L

#define fFmiDrawInCharCodes			0x00400000L

#define	fFmiTreatHyphenAsRegular	0x00800000L
#define fFmiWrapTrailingSpaces		0x01000000L
#define fFmiWrapAllSpaces			0x02000000L

/* Compatibility flags for bugs in older versions of WORD */
#define fFmiForgetLastTabAlignment	0x10000000L
#define fFmiIndentChangesHyphenZone	0x20000000L
#define fFmiNoPunctAfterAutoNumber	0x40000000L
#define fFmiResolveTabsAsWord97		0x80000000L

#endif /* !LSFFI_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lsexpan.h ===
#ifndef LSEXPAN_DEFINED
#define LSEXPAN_DEFINED

#include "lsdefs.h"
#include "lsact.h"

typedef struct lsexpan					/* expansion information unit		*/
{
	BYTE fFullScaled;					/* expand for full justification	*/
	BYTE fFullInterletter;				/* expand for distributed justification	*/
} LSEXPAN;									


#endif /* !LSEXPAN_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lsexpinf.h ===
#ifndef LSEXPINF_DEFINED
#define LSEXPINF_DEFINED

#include "lsdefs.h"
#include "exptype.h"

#define lsexpinfInfinity	0x1FFFFF

/* ------------------------------------------------------------------------ */

struct lsexpinfo							/* Expansion info */
{
	long duMax;
	union
	{
		struct
		{
			long duMin;
		} AddInkContinuous;
	
		struct
		{
			DWORD cwidths;
		} AddInkDiscrete;

	} u;

	BYTE prior;
	BYTE fCanBeUsedForResidual;
	WORD pad;
};

typedef struct lsexpinfo LSEXPINFO;

#endif /* !LSEXPINFO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lskeop.h ===
#ifndef LSKEOP_DEFINED
#define LSKEOP_DEFINED

enum lskeop							/* kinds of para ending */
{
	lskeopEndPara1,
	lskeopEndPara2,
	lskeopEndPara12,
	lskeopEndParaAlt
};

typedef enum lskeop LSKEOP;

#endif /* !LSKEOP_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lskjust.h ===
#ifndef LSKJUST_DEFINED
#define LSKJUST_DEFINED

enum lskjust							/* kinds of para justification */
{
	lskjNone,
	lskjFullInterWord,
	lskjFullInterLetterAligned,
	lskjFullScaled,
	lskjFullGlyphs,
	lskjSnapGrid
};

typedef enum lskjust LSKJUST;

#endif /* !LSKJUST_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lsksplat.h ===
#ifndef LSKSPLAT_DEFINED
#define LSKSPLAT_DEFINED

enum lsksplat							/* Kind of splat */
{
	lsksplPageBreak,
	lsksplColumnBreak,
	lsksplSectionBreak
};

#endif /* !LSKSPLAT_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lsimeth.h ===
#ifndef LSIMETH_DEFINED
#define LSIMETH_DEFINED

#include "lsdefs.h"

#include "plscbk.h"
#include "plsrun.h"
#include "pilsobj.h"
#include "plnobj.h"
#include "pdobj.h"
#include "pfmti.h"
#include "pbrko.h"
#include "pobjdim.h"
#include "pdispi.h"
#include "plsdocin.h"
#include "pposichn.h"
#include "plocchnk.h"
#include "plsfgi.h"
#include "pheights.h"
#include "plsqin.h"
#include "plsqout.h"
#include "plssubl.h"
#include "plschp.h"
#include "lstflow.h"
#include "lskjust.h"
#include "breakrec.h"
#include "brkcond.h"
#include "brkkind.h"
#include "fmtres.h"
#include "mwcls.h"

typedef struct
{
	LSERR (WINAPI* pfnCreateILSObj)(POLS, PLSC,  PCLSCBK, DWORD, PILSOBJ*);
	/* CreateILSObj
	 *  pols (IN):
	 *  plsc (IN): LS context
	 *  plscbk (IN): callbacks
	 *  idObj (IN): id of the object
	 *  &pilsobj (OUT): object ilsobj
	*/

	LSERR (WINAPI* pfnDestroyILSObj)(PILSOBJ);
	/* DestroyILSObj
	 *  pilsobj (IN): object ilsobj
	*/

	LSERR (WINAPI* pfnSetDoc)(PILSOBJ, PCLSDOCINF);
	/* SetDoc
	 *  pilsobj (IN): object ilsobj
	 *  lsdocinf (IN): initialization data at document level
	*/

	LSERR (WINAPI* pfnCreateLNObj)(PCILSOBJ, PLNOBJ*);
	/* CreateLNObj
	 *  pilsobj (IN): object ilsobj
	 *  &plnobj (OUT): object lnobj
	*/

	LSERR (WINAPI* pfnDestroyLNObj)(PLNOBJ);
	/* DestroyLNObj
	 *  plnobj (OUT): object lnobj
	*/

	LSERR (WINAPI* pfnFmt)(PLNOBJ, PCFMTIN, FMTRES*);
	/* Fmt
	 *  plnobj (IN): object lnobj
	 *  pfmtin (IN): formatting input
	 *  &fmtres (OUT): formatting result
	*/

	LSERR (WINAPI* pfnFmtResume)(PLNOBJ, const BREAKREC*, DWORD, PCFMTIN, FMTRES*);
	/* FmtResume
	 *  plnobj (IN): object lnobj
	 *  rgBreakRecord (IN): array of break records
	 *	nBreakRecord (IN): size of the break records array
	 *  pfmtin (IN): formatting input
	 *  &fmtres (OUT): formatting result
	*/

	LSERR (WINAPI* pfnGetModWidthPrecedingChar)(PDOBJ, PLSRUN, PLSRUN, PCHEIGHTS, WCHAR, MWCLS, long*);
	/* GetModWidthPrecedingChar
	 *  pdobj (IN): dobj
     *  plsrun (IN): plsrun of the object
     *  plsrunText (IN): plsrun of the preceding char
     *  heightsRef (IN): height info about character
	 *  wchar (IN): preceding character
	 *  mwcls (IN): ModWidth class of preceding character
	 *  &durChange (OUT): amount by which width of the preceding char is to be changed
	*/

	LSERR (WINAPI* pfnGetModWidthFollowingChar)(PDOBJ, PLSRUN, PLSRUN, PCHEIGHTS, WCHAR, MWCLS, long*);
	/* GetModWidthPrecedingChar
	 *  pdobj (IN): dobj
     *  plsrun (IN): plsrun of the object
     *  plsrunText (IN): plsrun of the following char
     *  heightsRef (IN): height info about character
	 *  wchar (IN): following character
	 *  mwcls (IN): ModWidth class of the following character
	 *  &durChange (OUT): amount by which width of the following char is to be changed
	*/

	LSERR (WINAPI* pfnTruncateChunk)(PCLOCCHNK, PPOSICHNK);
	/* Truncate
	 *  plocchnk (IN): locchnk to truncate
	 *  posichnk (OUT): truncation point
	*/

	LSERR (WINAPI* pfnFindPrevBreakChunk)(PCLOCCHNK, PCPOSICHNK, BRKCOND, PBRKOUT);
	/* FindPrevBreakChunk
	 *  plocchnk (IN): locchnk to break
	 *  pposichnk (IN): place to start looking for break
	 *  brkcond (IN): recommmendation about the break after chunk
	 *  &brkout (OUT): results of breaking
	*/

	LSERR (WINAPI* pfnFindNextBreakChunk)(PCLOCCHNK, PCPOSICHNK, BRKCOND, PBRKOUT);
	/* FindNextBreakChunk
	 *  plocchnk (IN): locchnk to break
	 *  pposichnk (IN): place to start looking for break
	 *  brkcond (IN): recommmendation about the break before chunk
	 *  &brkout (OUT): results of breaking
	*/

	LSERR (WINAPI* pfnForceBreakChunk)(PCLOCCHNK, PCPOSICHNK, PBRKOUT);
	/* ForceBreakChunk
	 *  plocchnk (IN): locchnk to break
	 *  pposichnk (IN): place to start looking for break
	 *  &brkout (OUT): results of breaking
	*/

	LSERR (WINAPI* pfnSetBreak)(PDOBJ, BRKKIND, DWORD, BREAKREC*, DWORD*);
	/* SetBreak
	 *  pdobj (IN): dobj which is broken
	 *  brkkind (IN): Previous/Next/Force/Imposed was chosen
	 *	nBreakRecord (IN): size of array
	 *  rgBreakRecord (OUT): array of break records
	 *	nActualBreakRecord (OUT): actual number of used elements in array
	*/

	LSERR (WINAPI* pfnGetSpecialEffectsInside)(PDOBJ, UINT*);
	/* GetSpecialEffects
	 *  pdobj (IN): dobj
	 *  &EffectsFlags (OUT): Special effects inside of this object
	*/

	LSERR (WINAPI* pfnFExpandWithPrecedingChar)(PDOBJ, PLSRUN, PLSRUN, WCHAR, MWCLS, BOOL*);
	/* FExpandWithPrecedingChar
	 *  pdobj (IN): dobj
     *  plsrun (IN): plsrun of the object
     *  plsrunText (IN): plsrun of the preceding char
	 *  wchar (IN): preceding character
	 *  mwcls (IN): ModWidth class of preceding character
	 *  &fExpand (OUT): expand preceding character?
	*/

	LSERR (WINAPI* pfnFExpandWithFollowingChar)(PDOBJ, PLSRUN, PLSRUN, WCHAR, MWCLS, BOOL*);
	/* FExpandWithFollowingChar
	 *  pdobj (IN): dobj
     *  plsrun (IN): plsrun of the object
     *  plsrunText (IN): plsrun of the following char
	 *  wchar (IN): following character
	 *  mwcls (IN): ModWidth class of the following character
	 *  &fExpand (OUT): expand object?
	*/
	LSERR (WINAPI* pfnCalcPresentation)(PDOBJ, long, LSKJUST, BOOL);
	/* CalcPresentation
	 *  pdobj (IN): dobj
	 *  dup (IN): dup of dobj
	 *  lskj (IN): current justification mode
	 *  fLastVisibleOnLine (IN): this object is last visible object on line
	*/

	LSERR (WINAPI* pfnQueryPointPcp)(PDOBJ, PCPOINTUV, PCLSQIN, PLSQOUT);
	/* QueryPointPcp
	 *  pdobj (IN): dobj to query
	 * 	ppointuvQuery (IN): query point (uQuery,vQuery)
     *	plsqin (IN): query input
     *	plsqout (OUT): query output
	*/
	
	LSERR (WINAPI* pfnQueryCpPpoint)(PDOBJ, LSDCP, PCLSQIN, PLSQOUT);
	/* QueryCpPpoint
	 *  pdobj (IN): dobj to query
	 *  dcp (IN):  dcp for the query
     *	plsqin (IN): query input
     *	plsqout (OUT): query output
	*/

	LSERR (WINAPI* pfnEnum)(PDOBJ, PLSRUN, PCLSCHP, LSCP, LSDCP, LSTFLOW, BOOL,
												BOOL, const POINT*, PCHEIGHTS, long);
	/* Enum object
	 *  pdobj (IN): dobj to enumerate
	 *  plsrun (IN): from DNODE
	 *  plschp (IN): from DNODE
	 *  cpFirst (IN): from DNODE
	 *  dcp (IN): from DNODE
	 *  lstflow (IN): text flow
	 *  fReverseOrder (IN): enumerate in reverse order
	 *  fGeometryNeeded (IN):
	 *  pptStart (IN): starting position, iff fGeometryNeeded
	 *  pheightsPres(IN): from DNODE, relevant iff fGeometryNeeded
	 *  dupRun(IN): from DNODE, relevant iff fGeometryNeeded
	*/

	LSERR (WINAPI* pfnDisplay)(PDOBJ, PCDISPIN);
	/* Display
	 *  pdobj (IN): dobj to display
	 *  pdispin (IN): input display info
	*/

	LSERR (WINAPI* pfnDestroyDObj)(PDOBJ);
	/* DestroyDObj
	 *  pdobj (IN): dobj to destroy
	*/

} LSIMETHODS;

#endif /* LSIMETH_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lsktab.h ===
#ifndef LSKTAB_DEFINED
#define LSKTAB_DEFINED

#include "lsdefs.h"


enum lsktab								/* Kinds of tabs */
{
	lsktLeft,
	lsktCenter,
	lsktRight,
	lsktDecimal,
	lsktChar
};

typedef enum lsktab LSKTAB;


#endif  /* !LSKTAB_DEFINED     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lskalign.h ===
#ifndef LSKALIGN_DEFINED
#define LSKALIGN_DEFINED

enum lskalign							/* kinds of para alignment */
{
	lskalLeft,
	lskalCentered,
	lskalRight,
};

typedef enum lskalign LSKALIGN;

#endif /* !LSKALIGN_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lskysr.h ===
#ifndef LSKYSR_DEFINED
#define LSKYSR_DEFINED

/* kysr codes: for LSCHP.kysr - Kind of YSR */
#define	kysrNil				0		/* No Hyphenation				*/
#define kysrNormal			1		/* Normal Hyphenation			*/
#define kysrAddBefore		2		/* Add letter before hyphen		*/
#define kysrChangeBefore	3		/* Change letter before hyphen	*/
#define kysrDeleteBefore	4		/* Delete letter before hyphen	*/
#define kysrChangeAfter		5		/* Change letter after hyphen	*/
#define kysrDelAndChange	6		/* Delete letter before the hyphen and */
									/* change the letter preceding the ... */

#endif /* !LSKYSR_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lslinfo.h ===
#ifndef LSLINFO_DEFINED
#define LSLINFO_DEFINED

#include "lsdefs.h"
#include "endres.h"

typedef struct
{
	long dvpAscent;
	long dvrAscent;
	long dvpDescent;
	long dvrDescent;

	long dvpMultiLineHeight;
	long dvrMultiLineHeight;

	long dvpAscentAutoNumber;
	long dvrAscentAutoNumber;
	long dvpDescentAutoNumber;
	long dvrDescentAutoNumber;

	LSCP cpLim;					/* First cp which is NOT on this line */
	LSDCP dcpDepend;			/* # of chars wrapped to next line  */
	LSCP cpFirstVis;			/* First actual (not hidden) character in a line*/
								/* allows client to use character properties from the correct paragraph */


	ENDRES endr;				/* How line ended */
	BOOL fAdvanced;
	long vaAdvance;				/* Valid iff (fAdvanced != 0) */

	BOOL fFirstLineInPara;
	BOOL fTabInMarginExLine;
	BOOL fForcedBreak;

	DWORD nDepthFormatLineMax;  /* Formatting depth of the line (1--for plain line) */

	UINT EffectsFlags;			/* set of client defined special effects flags */
} LSLINFO;

#endif /* !LSLINFO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lspairac.h ===
#ifndef LSPAIRAC_DEFINED
#define LSPAIRAC_DEFINED

#include "lsdefs.h"
#include "lsact.h"


typedef struct lspairact				/* Mod width pair unit				*/
{
	LSACT lsactFirst;					/* Action on first char				*/
	LSACT lsactSecond;					/* Action on second char			*/
} LSPAIRACT;									


#endif /* !LSPAIRAC_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lspract.h ===
#ifndef LSPRACT_DEFINED
#define LSPRACT_DEFINED

#include "lsdefs.h"
#include "lsact.h"

#define prior0					0		/* means priority is not defined	*/
#define prior1					1
#define prior2					2
#define prior3					3
#define prior4					4
#define prior5					5

typedef struct lspract					/* prioritized action 				*/
{
	BYTE prior;							/* priority							*/
	LSACT lsact;						/* action							*/
} LSPRACT;									


#endif /* !LSPRACTION_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lspap.h ===
#ifndef LSPAP_DEFINED
#define LSPAP_DEFINED

#include "lsdefs.h"
#include "plspap.h"
#include "lskjust.h"
#include "lskalign.h"
#include "lsbrjust.h"
#include "lskeop.h"
#include "lstflow.h"

/* ---------------------------------------------------------------------- */

struct lspap
{
	LSCP cpFirst;						/* 1st cp for this paragraph */
	LSCP cpFirstContent;				/* 1st cp of "content" in the para */

	DWORD grpf;							/* line services format flags (lsffi.h)*/

	long uaLeft;						/* left boundary for line				*/
	long uaRightBreak;					/* right boundary for break */
	long uaRightJustify;					/* right boundary for justification */
	long duaIndent;
	long duaHyphenationZone;

	LSBREAKJUST lsbrj;					/* Break/Justification behavior	*/
	LSKJUST lskj;						/* Justification type */
	LSKALIGN lskal;						/* Alignment type */

	long duaAutoDecimalTab;

	LSKEOP lskeop;						/* kind of paragraph ending */
	
	LSTFLOW lstflow;					/* Main text flow direction */

};

typedef struct lspap LSPAP;

#endif /* !LSPAP_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lsqout.h ===
#ifndef LSQOUT_DEFINED
#define LSQOUT_DEFINED

#include "lsdefs.h"
#include "heights.h"
#include "lscell.h"
#include "plssubl.h"
#include "plsqout.h"


typedef struct lsqout			
{
 	POINTUV pointUvStartObj;		/* In coordinate system of parent subline
										relative to the beginning of dnode	*/
	HEIGHTS	heightsPresObj;			/* In direction of parent subline */
	long dupObj;					/* In direction lstflowSubline			*/

	LSTEXTCELL lstextcell;			/* in coordinate system of parent subline,
										relative to the beginning of dnode	*/

	PLSSUBL plssubl;
 	POINTUV pointUvStartSubline;	/* In coordinate system of parent subline
										relative to the beginning of dnode	*/

} LSQOUT;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lsqline.h ===
#ifndef LSQLINE_DEFINED
#define LSQLINE_DEFINED

#include "lsdefs.h"
#include "plsline.h"
#include "plsqsinf.h"
#include "plscell.h"
#include "pcelldet.h"
#include "gprop.h"

LSERR WINAPI  LsQueryLineCpPpoint(
							PLSLINE,	/* IN: pointer to line info -- opaque to client	*/
							LSCP,		/* IN: cpQuery									*/
							DWORD,      /* IN: nDepthQueryMax							*/
							PLSQSUBINFO,/* OUT: array[nDepthQueryMax] of LSQSUBINFO		*/
							DWORD*,		 /* OUT: nActualDepth							*/
							PLSTEXTCELL);/* OUT: Text cell info							*/


LSERR WINAPI LsQueryLinePointPcp(
							PLSLINE,	/* IN: pointer to line -- opaque to client			*/
						 	PCPOINTUV,	/* IN: query point (uQuery,vQuery) (line text flow)	*/
							DWORD,      /* IN: nDepthQueryMax								*/
							PLSQSUBINFO,/* OUT: array[nDepthQueryMax] of LSQSUBINFO			*/
							DWORD*,      /* OUT: nActualDepth	*/
							PLSTEXTCELL);/* OUT: Text cell info */

LSERR WINAPI LsQueryTextCellDetails(
							PLSLINE,	/* IN: pointer to line -- opaque to client				*/
						 	PCELLDETAILS,/* IN: query point (uQuery,vQuery) (line text flow)	*/
							LSCP,		/* IN: cpStartCell										*/
							DWORD,		/* IN: nCharsInContext									*/
							DWORD,		/* IN: nGlyphsInContext									*/
							WCHAR*,		/* OUT: pointer array[nCharsInContext] of char codes	*/
							PGINDEX,	/* OUT: pointer array[nGlyphsInContext] of glyph indices*/
							long*,		/* OUT: pointer array[nGlyphsInContext] of glyph widths	*/
							PGOFFSET,	/* OUT: pointer array[nGlyphsInContext] of glyph offsets*/
							PGPROP);	/* OUT: pointer array[nGlyphsInContext] of glyph handles*/

/*
 *	Query point and output point are in the coordinate system of the line.
 *	Text flow is the text flow of the line, zero point is at the starting point of the line. 
 */


LSERR WINAPI LsQueryLineDup(PLSLINE,	/* IN: pointer to line -- opaque to client	*/
							long*,		/* OUT: upStartAutonumberingText			*/
							long*,		/* OUT: upLimAutonumberingText				*/
							long*,		/* OUT: upStartMainText						*/
							long*,		/* OUT: upStartTrailing						*/
							long*);		/* OUT: upLimLine							*/

LSERR WINAPI LsQueryFLineEmpty(
							PLSLINE,	/* IN: pointer to line -- opaque to client 	*/
							BOOL*);		/* OUT: Is line empty? 						*/

#endif /* !LSQLINE_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lsqsinfo.h ===
#ifndef LSQSINFO_DEFINED
#define LSQSINFO_DEFINED

#include "lsdefs.h"
#include "heights.h"
#include "lstflow.h"
#include "plsrun.h"
#include "plsqsinf.h"


typedef struct lsqsubinfo			
{
	LSTFLOW	lstflowSubline;
	LSCP cpFirstSubline;
	LSDCP dcpSubline;
 	POINTUV pointUvStartSubline;	/* In coordinate system of main line/subline */
	HEIGHTS	heightsPresSubline;		/* In direction lstflowSubline */
	long dupSubline;				/* In direction lstflowSubline			*/


	DWORD idobj;
	PLSRUN plsrun;
	LSCP cpFirstRun;
	LSDCP dcpRun;
 	POINTUV pointUvStartRun;		/* In coordinate system of main line/subline */
	HEIGHTS	heightsPresRun;			/* In direction lstflowSubline */
	long dupRun;					/* In direction lstflowSubline			*/
	long dvpPosRun;					/* in direction of lstflowSubline	*/

	long dupBorderBefore;			/* in direction of lstflowSubline	*/
	long dupBorderAfter;			/* in direction of lstflowSubline	*/

 	POINTUV pointUvStartObj;		/* Set by Object, translated to coord system of main line/subline */
	HEIGHTS	heightsPresObj;			/* Set by Object, in direction lstflowSubline */
	long dupObj;					/* Set by Object, in direction lstflowSubline			*/


} LSQSUBINFO;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lsqin.h ===
#ifndef LSQIN_DEFINED
#define LSQIN_DEFINED

#include "lsdefs.h"
#include "heights.h"
#include "lstflow.h"
#include "plsrun.h"
#include "plsqin.h"

typedef struct lsqin			
{
	LSTFLOW	lstflowSubline;
	PLSRUN plsrun;					/* PLSRUN this cp belongs to */
	LSCP cpFirstRun;
	LSDCP dcpRun;
	HEIGHTS	heightsPresRun;			/* In direction lstflowSubline */
	long dupRun;					/* In direction lstflowSubline			*/
	long dvpPosRun;					/* in direction of lstflowSubline	*/

} LSQIN;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lsqsubl.h ===
#ifndef LSQSUBL_DEFINED
#define LSQSUBL_DEFINED

/* Line services formatter fetch/dispatcher interface (to LsCreateLine())
 */

#include "lsdefs.h"
#include "plssubl.h"
#include "plsqsinf.h"
#include "plscell.h"

LSERR WINAPI LsQueryCpPpointSubline(
							PLSSUBL,		/* IN: subline context			*/
							LSCP, 			/* IN: cpQuery 					*/
							DWORD,      	/* IN: nDepthQueryMax			*/
							PLSQSUBINFO,	/* OUT: array[nDepthQueryMax] of LSQSUBINFO	*/
							DWORD*,			/* OUT: nActualDepth			*/
							PLSTEXTCELL);	/* OUT: Text cell info			*/
							
LSERR WINAPI LsQueryPointPcpSubline(
							PLSSUBL,		/* IN: subline context			*/
						 	PCPOINTUV,		/* IN: query point from the subline beginning */
							DWORD,      	/* IN: nDepthQueryMax			*/
							PLSQSUBINFO,	/* OUT: array[nDepthQueryMax] of LSQSUBINFO */
							DWORD*,		 	/* OUT: nActualDepth			*/
							PLSTEXTCELL);	/* OUT: Text cell info			*/


#endif /* !LSQSUBL_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lssetdoc.h ===
#ifndef LSSETDOC_DEFINED
#define LSSETDOC_DEFINED

#include "lsdefs.h"
#include "lsdevres.h"
#include "lspract.h"
#include "lspairac.h"
#include "lsexpan.h"
#include "lsbrk.h"

LSERR WINAPI LsSetDoc(PLSC,				/* IN: ptr to line services context */
					  BOOL,				/* IN: Intend to display? 			*/
					  BOOL,				/* IN: Ref & Pres Devices are equal?*/
					  const LSDEVRES*); /* IN: device resolutions 			*/

LSERR WINAPI LsSetModWidthPairs(
					  PLSC,				/* IN: ptr to line services context */
					  DWORD,			/* IN: Number of mod pairs info units*/ 
					  const LSPAIRACT*,	/* IN: Mod pairs info units array  */
					  DWORD,			/* IN: Number of Mod Width classes	*/
					  const BYTE*);		/* IN: Mod width information(square):
											  indexes in the LSPAIRACT array */
LSERR WINAPI LsSetCompression(
					  PLSC,				/* IN: ptr to line services context */
					  DWORD,			/* IN: Number of compression priorities*/
					  DWORD,			/* IN: Number of compression info units*/
					  const LSPRACT*,	/* IN: Compession info units array 	*/
					  DWORD,			/* IN: Number of Mod Width classes	*/
					  const BYTE*);		/* IN: Compression information:
											  indexes in the LSPRACT array  */
LSERR WINAPI LsSetExpansion(
					  PLSC,				/* IN: ptr to line services context */
					  DWORD,			/* IN: Number of expansion info units*/
					  const LSEXPAN*,	/* IN: Expansion info units array	*/
					  DWORD,			/* IN: Number of Mod Width classes	*/
					  const BYTE*);		/* IN: Expansion information(square):
											  indexes in the LSEXPAN array  */
LSERR WINAPI LsSetBreaking(
					  PLSC,				/* IN: ptr to line services context */
					  DWORD,			/* IN: Number of breaking info units*/
					  const LSBRK*,		/* IN: Breaking info units array	*/
					  DWORD,			/* IN: Number of breaking classes	*/
					  const BYTE*);		/* IN: Breaking information(square):
											  indexes in the LSBRK array  */


#endif /* !LSSETDOC_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lsstinfo.h ===
#ifndef LSSTINFO_DEFINED
#define LSSTINFO_DEFINED

#include "lsdefs.h"
#include "plsstinf.h"

/* 
 * all strikethrough offsets are relative to the baseline and positive upwards (filled page direction),
 * so normally dvpLowerStrikethroughOffset > 0 and if cNumberOfLines == 2
 * dvpLowerStrikethroughOffset < dvpUpperStrikethroughOffset
 */

struct lsstinfo
{
    UINT  kstbase;						/* base kind of strikethrough  */
    DWORD cNumberOfLines;				/* number of lines: possible values 1,2*/

	long dvpLowerStrikethroughOffset ;	/* if NumberOfLines != 2 only data for 
											lower line should be filled in */
	long dvpLowerStrikethroughSize;
	long dvpUpperStrikethroughOffset;	
	long dvpUpperStrikethroughSize;

};
typedef struct lsstinfo LSSTINFO;


#endif /* !LSSTINFO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lstabs.h ===
#ifndef LSTABS_DEFINED
#define LSTABS_DEFINED

#include "lsdefs.h"
#include "lsktab.h"

/* ---------------------------------------------------------------------- */


/* ---------------------------------------------------------------------- */

typedef struct
{
	enum lsktab lskt;					/* Kind of tab */
	long ua;							/* tab position */
	WCHAR wchTabLeader;					/* character for tab leader */
										/*   if 0, no leader is used*/
	WCHAR wchCharTab;					/* Character for CharTab	*/
} LSTBD;

/* ---------------------------------------------------------------------- */

typedef struct lstabs
{
	long duaIncrementalTab;				/* "Default" tab behavior */
	DWORD iTabUserDefMac;
	LSTBD* pTab;				
} LSTABS;


#endif /* !LSTABS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lstflow.h ===
#ifndef LSTFLOW_DEFINED
#define LSTFLOW_DEFINED

#include "lsdefs.h"

typedef DWORD  LSTFLOW;

#define lstflowDefault	0  

#define lstflowES		0  
#define lstflowEN		1  
#define lstflowSE		2  
#define lstflowSW		3  
#define lstflowWS		4  
#define lstflowWN		5  
#define lstflowNE		6  
#define lstflowNW		7  

/*
 *	The eight possible text flows are listed clockwise starting with default (Latin) one.
 *
 *	lstflowES is the coordinate system used when line grows to East and text grows to South.
 *	(Next letter is to the right (east) of previous, next line is created below (south) the previous.) 
 *
 *	For lstflowES positive u moves to the right, positive v moves up. (V axis is always in the direction
 *	of ascender, opposite to text growing direction.
 *
 *	Notice it is not the way axes are pointing in the default Windows mapping mode MM_TEXT. 
 *	In MM_TEXT vertical (y) axis increase from top to bottom, 
 *	in lstflowES vertical (v) axis increase from bottom to top.
 */
 
#define fUDirection			0x00000004L
#define fVDirection			0x00000001L
#define fUVertical			0x00000002L

/*
 *	The three bits that constitute lstflow happens to have well defined meanings.
 *
 *	Middle bit: on for vertical writing, off for horizontal.
 *	First (low value) bit: "on" means v-axis points right or down (positive).
 *	Third bit: "off" means u-axis points right or down (positive).
 *
 * See examples of usage in lstfset.c
 *
 */


#endif /* !LSTFLOW_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lssubset.h ===
#ifndef LSSUBSET_DEFINED
#define LSSUBSET_DEFINED

/* Access routines for contents of DNODES */

#include "lsdefs.h"
#include "plsrun.h"
#include "plssubl.h"
#include "pobjdim.h"
#include "lstflow.h"

			
LSERR WINAPI LssbGetObjDimSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							LSTFLOW*,			/* OUT: subline's lstflow		*/
					 	    POBJDIM);			/* OUT: dimensions of subline	*/
							
LSERR WINAPI LssbGetDupSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							LSTFLOW*,			/* OUT: subline's lstflow		*/
					 	    long*);				/* OUT: dup of subline			*/

LSERR WINAPI LssbFDonePresSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							BOOL*);				/* OUT: Is it CalcPres'd		*/

LSERR WINAPI LssbFDoneDisplay(
							PLSSUBL,			/* IN: Subline Context			*/
							BOOL*);				/* OUT: Is it displayed			*/

LSERR WINAPI LssbGetPlsrunsFromSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							DWORD,				/* IN: N of DNODES in subline	*/
							PLSRUN*);			/* OUT: array of PLSRUN's		*/

LSERR WINAPI LssbGetNumberDnodesInSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							DWORD*);			/* OUT: N of DNODES in subline	*/

LSERR WINAPI LssbGetVisibleDcpInSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							LSDCP*);			/* OUT: N of characters			*/

LSERR WINAPI LssbGetDurTrailInSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							long*);				/* OUT: width of trailing area	*/
	
LSERR WINAPI LssbGetDurTrailWithPensInSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							long*);				/* OUT: width of trailing area
													including pens in subline	*/
LSERR WINAPI LssbFIsSublineEmpty(
							PLSSUBL plssubl,	/* IN: subline					*/
							BOOL*  pfEmpty);	/* OUT:is this subline empty	*/


#endif /* !LSSUBSET_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lstfset.h ===
#ifndef LSTFSET_DEFINED
#define LSTFSET_DEFINED

/* Service routines for some standard text flow change tasks */

#include "lsdefs.h"
#include "lstflow.h"

/* 
 * LsPointXYFromPointUV calculates pointxyOut given (x,y) pointxyIn and (u,v) vector 
 *  
 *  (pointxyOut = pointxyIn + vectoruv)
 */

LSERR WINAPI LsPointXYFromPointUV(const POINT*, 	/* IN: input point (x,y) */
									LSTFLOW,	 	/* IN: text flow for */
									PCPOINTUV,		/* IN: vector in (u,v) */
									POINT*);		/* OUT: (x,y) point */


/* 
 * LsPointUV1FromPointUV2 calculates vector in uv2 coordinates given begin and end of it in uv1.
 *  
 *  (vectorUV22 = pointUV1b - pointUV1a)
 *
 *	Usually pointUV1a is the starting point of uv2 coordinate system and it is easier to think 
 *		about output vector as a point in it.
 */

LSERR WINAPI LsPointUV2FromPointUV1(LSTFLOW,	 	/* IN: text flow 1 (TF1) */
									PCPOINTUV,	 	/* IN: starting point (TF1) */
									PCPOINTUV,		/* IN: ending point (TF1) */
									LSTFLOW,	 	/* IN: text flow 2 (TF2) */
									PPOINTUV);		/* OUT: vector in TF2 */


#endif /* !LSTFSET_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lstxm.h ===
#ifndef LSTXM_DEFINED
#define LSTXM_DEFINED

#include "lsdefs.h"
#include "plstxm.h"
/*igorzv** good explanation according text flow issue is needed here /
/* A few words about the v-vector and the sign bit: 
 *
 * dvDescent is positive downwards.		
 * v is positive upwards during formatting.
 */

struct lstxm
{
	long dvAscent;
	long dvDescent;

	long dvMultiLineHeight;
	BOOL fMonospaced;
};
typedef struct lstxm LSTXM;


#endif /* !LSTXM_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lstxtcfg.h ===
#ifndef LSTXTCFG_DEFINED
#define LSTXTCFG_DEFINED

#include "lsdefs.h"
#include "plstxtcf.h"

typedef struct lstxtcfg
{
	long cEstimatedCharsPerLine;

	WCHAR wchUndef;
	WCHAR wchNull;
	WCHAR wchSpace;
	WCHAR wchHyphen;
	WCHAR wchTab;
	WCHAR wchEndPara1;
	WCHAR wchEndPara2;
	WCHAR wchAltEndPara;
	WCHAR wchEndLineInPara;				/* Word "CCRJ", */
	WCHAR wchColumnBreak;
	WCHAR wchSectionBreak;
	WCHAR wchPageBreak;
	WCHAR wchNonBreakSpace;				/* char code of non-breaking space */
	WCHAR wchNonBreakHyphen;
	WCHAR wchNonReqHyphen;				/* discretionary hyphen */
	WCHAR wchEmDash;
	WCHAR wchEnDash;
	WCHAR wchEmSpace;
	WCHAR wchEnSpace;
	WCHAR wchNarrowSpace;
	WCHAR wchOptBreak;
	WCHAR wchNoBreak;
	WCHAR wchFESpace;
	WCHAR wchJoiner;
	WCHAR wchNonJoiner;
	WCHAR wchToReplace;					/* backslash in FE Word				*/
	WCHAR wchReplace;					/* Yen in FE Word				*/


	WCHAR wchVisiNull;					/* visi char for wch==wchNull		*/
	WCHAR wchVisiAltEndPara;			/* visi char for end "table cell"	*/
	WCHAR wchVisiEndLineInPara;			/* visi char for wchEndLineInPara	*/
	WCHAR wchVisiEndPara;				/* visi char for "end para"			*/
	WCHAR wchVisiSpace;					/* visi char for "space"			*/
	WCHAR wchVisiNonBreakSpace;			/* visi char for wchNonBreakSpace	*/
	WCHAR wchVisiNonBreakHyphen;		/* visi char for wchNonBreakHyphen	*/
	WCHAR wchVisiNonReqHyphen;			/* visi char for wchNonReqHyphen	*/
	WCHAR wchVisiTab;					/* visi char for "tab"				*/
	WCHAR wchVisiEmSpace;				/* visi char for wchEmSpace			*/
	WCHAR wchVisiEnSpace;				/* visi char for wchEnSpace			*/
	WCHAR wchVisiNarrowSpace;			/* visi char for wchNarrowSpace		*/
	WCHAR wchVisiOptBreak;              /* visi char for wchOptBreak		*/
	WCHAR wchVisiNoBreak;				/* visi char for wchNoBreak			*/
	WCHAR wchVisiFESpace;				/* visi char for wchOptBreak		*/

	WCHAR wchEscAnmRun;

	WCHAR wchPad;
} LSTXTCFG;

#endif /* !LSTXTCFG_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\objdim.h ===
#ifndef OBJDIM_DEFINED
#define OBJDIM_DEFINED

#include "lsdefs.h"
#include "pobjdim.h"
#include "heights.h"

typedef struct objdim							/* Object dimensions */
{
	HEIGHTS heightsRef;	
	HEIGHTS heightsPres;	
	long dur;
} OBJDIM;

#endif /* !OBJDIM_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\lsulinfo.h ===
#ifndef LSULINFO_DEFINED
#define LSULINFO_DEFINED

#include "lsdefs.h"
#include "plsulinf.h"

/* 
 * Both Offsets are relative to the local baseline and positive "down" (towards blank page), 
 * so in horizontal Latin case dvpFirstUnderlineOffset usually is bigger than zero. 
 *
 * dvpUnderlineOrigin points to UnderlineOrigin - the place where (main part of the) letter ends and 
 * area for underlining begins. For Latin letters it is the Latin baseline. UnderlineOrigin shows if
 * one run of two runs is higher; runs with the same UnderlineOrigin can have their underlines averaged.
 *
 * dvpFirstUnderlineOffset points to the beginning of the closest to the UnderlineOrigin underline.
 * You have "underlining from above" case if dvpUnderlineOrigin > dvpFirstUnderlineOffset.
 *
 * Everything else should be positive. Instead of dvpSecondUnderlineOffset of the previous version dvpGap 
 * is used. Second underline is further away from the UnderlineOrigin than first underline, so
 * dvpSecondUnderlineOffset = dvpFirstUnderlineOffset + dvpFirstUnderlineSize + dvpGap in normal case.
 * In "underlining from above" case there will be minuses instead of pluses.
 *
 * Main merging rules: 
 *
 * LS will not merge runs with different kulbase or different cNumberOfLines.
 * LS will not merge runs with different negative dvpPos (subscripts)
 * LS will not merge subscripts with superscripts or baseline runs
 * LS will not merge "underlined above" run with "underlined below" run.
 *
 * If merging is possible: 
 * Runs with the same UnderlineOrigin are averaged.
 * If UnderlineOrigins are different, the run with higher UnderlineOrigin takes metrics from neighbor.
 */

struct lsulinfo
{
    UINT  kulbase;						/* base kind of underline */
    DWORD cNumberOfLines;				/* number of lines: possible values 1,2*/

	long dvpUnderlineOriginOffset;		/* UnderlineOrigin decides which run is higher */
	long dvpFirstUnderlineOffset;		/* offset for start of the (first) underline */
	long dvpFirstUnderlineSize;			/* width of the (first) underline */
	
	long dvpGapBetweenLines;			/* If NumberOfLines != 2, dvpGapBetweenLines */
	long dvpSecondUnderlineSize;		/* 	and dvpSecondUnderlineSize are ignored. */
	
};
typedef struct lsulinfo LSULINFO;


#endif /* !LSULINFO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\mwcls.h ===
#ifndef MWCLS_DEFINED
#define MWCLS_DEFINED

#include "lsdefs.h"

typedef BYTE MWCLS;

#endif /* !MWCLS_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\pdobj.h ===
#ifndef PDOBJ_DEFINED
#define PDOBJ_DEFINED

struct dobj;
typedef struct dobj* PDOBJ;

#endif /* PDOBJ_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\pbrko.h ===
#ifndef PBRKO_DEFINED
#define PBRKO_DEFINED

struct brkout;
typedef struct brkout* PBRKOUT;

#endif /* !PBRKO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\pdispi.h ===
#ifndef PDISPI_DEFINED
#define PDISPI_DEFINED

struct dispin;
typedef const struct dispin *PCDISPIN;

#endif /* !PDISPI_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\pcelldet.h ===
#ifndef PCELLDET_DEFINED
#define PCELLDET_DEFINED

struct celldetails;
typedef struct celldetails* PCELLDETAILS;

#endif /* !PCELLDET_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\pheights.h ===
#ifndef PHEIGHTS_DEFINED
#define PHEIGHTS_DEFINED

struct heights;
typedef struct heights* PHEIGHTS;
typedef const struct heights* PCHEIGHTS;

#endif /* !POBJDIME_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\pfmti.h ===
#ifndef PFMTI_DEFINED
#define PFMTI_DEFINED

struct fmtin;
typedef const struct fmtin *PCFMTIN;

#endif /* !PFMTI_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\plnobj.h ===
#ifndef PLNOBJ_DEFINED
#define PLNOBJ_DEFINED

struct lnobj;
typedef struct lnobj* PLNOBJ;

#endif /* PLNOBJ_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\plschp.h ===
#ifndef PLSCHP_DEFINED
#define PLSCHP_DEFINED

struct lschp;
typedef struct lschp* PLSCHP;
typedef const struct lschp* PCLSCHP;

#endif /* !PLSCHP_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\plscell.h ===
#ifndef PLSCELL_DEFINED
#define PLSCELL_DEFINED

struct lstextcell;
typedef struct lstextcell* PLSTEXTCELL;
typedef const struct lstextcell* PCLSTEXTCELL;

#endif /* !PLSCELL_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\pilsobj.h ===
#ifndef PILSOBJ_DEFINED
#define PILSOBJ_DEFINED

struct ilsobj;

typedef struct ilsobj* PILSOBJ;
typedef const PILSOBJ PCILSOBJ;

#endif /* PILSOBJ_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\plscbk.h ===
#ifndef PLSCBK_DEFINED
#define PLSCBK_DEFINED

struct lscbk;
typedef struct lscbk* PLSCBK;
typedef const struct lscbk* PCLSCBK;

#endif /* !PLSCBK_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\plocchnk.h ===
#ifndef PLOCCHNK_DEFINED
#define PLOCCHNK_DEFINED

struct locchnk;
typedef const struct locchnk* PCLOCCHNK;
typedef struct locchnk* PLOCCHNK;

#endif /* !PLSLOCCH_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\plspap.h ===
#ifndef PLSPAP_DEFINED
#define PLSPAP_DEFINED

struct lspap;
typedef struct lspap* PLSPAP;

#endif /* !PLSPAP_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\plsdocin.h ===
#ifndef PLSDOCINF_DEFINED
#define PLSDOCINF_DEFINED

struct lsdocinf;
typedef const struct lsdocinf* PCLSDOCINF;
#endif /* !PLSDOCINF_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\plsline.h ===
#ifndef PLSLINE_DEFINED
#define PLSLINE_DEFINED

struct lsline;
typedef struct lsline* PLSLINE;

#endif /* PLSLINE_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\plshyph.h ===
#ifndef PLSHYPH_DEFINED
#define PLSHYPH_DEFINED

struct lshyph;
typedef struct lshyph* PLSHYPH;
typedef const struct lshyph* PCLSHYPH;

#endif /* !PLSHYPH_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\plsfrun.h ===
#ifndef PLSFRUN_DEFINED
#define PLSFRUN_DEFINED

struct lsfrun;
typedef struct lsfrun* PLSFRUN;
typedef const struct lsfrun* PCLSFRUN;

#endif /* PLSRUN_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\plsfgi.h ===
#ifndef PLSFGI_DEFINED
#define PLSFGI_DEFINED

struct lsfgi;
typedef struct lsfgi* PLSFGI;

#endif /* !PLSFGI_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\plsems.h ===
#ifndef PLSEMS_DEFINED
#define PLSEMS_DEFINED

struct lsems;

typedef struct lsems* PLSEMS;

#endif /* !PLSEMS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\plsdnode.h ===
#ifndef PLSDNODE_DEFINED
#define PLSDNODE_DEFINED

struct lsdnode;
typedef struct lsdnode* PLSDNODE;

#endif /* PLSDNODE_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\plsqout.h ===
#ifndef PLSQOUT_DEFINED
#define PLSQOUT_DEFINED

struct lsqout;
typedef struct lsqout* PLSQOUT;

#endif /* !PLSQOUT_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\plsstinf.h ===
#ifndef PLSSTINFO_DEFINED
#define PLSSTINFO_DEFINED

struct lsstinfo;
typedef struct lsstinfo* PLSSTINFO;

#endif /* !PLSSTINFO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\plsqin.h ===
#ifndef PLSQIN_DEFINED
#define PLSQIN_DEFINED

struct lsqin;
typedef struct lsqin* PLSQIN;
typedef const struct lsqin* PCLSQIN;

#endif /* !PLSQIN_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\plstxm.h ===
#ifndef PLSTXM_DEFINED
#define PLSTXM_DEFINED

struct lstxm;
typedef struct lstxm* PLSTXM;

#endif /* !PLSTXM_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\plssubl.h ===
#ifndef PLSSUBL_DEFINED
#define PLSSUBL_DEFINED

struct lssubl;
typedef struct lssubl* PLSSUBL;

#endif /* PLSSUBL_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\plsqsinf.h ===
#ifndef PLSQSINF_DEFINED
#define PLSQSINF_DEFINED

struct lsqsubinfo;
typedef struct lsqsubinfo* PLSQSUBINFO;
typedef const struct lsqsubinfo* PCLSQSUBINFO;

#endif /* !PLSQSINF_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\plsrun.h ===
#ifndef PLSRUN_DEFINED
#define PLSRUN_DEFINED

struct lsrun;
typedef struct lsrun* PLSRUN;

#endif /* PLSRUN_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\plstabs.h ===
#ifndef PLSTABS_DEFINED
#define PLSTABS_DEFINED

struct lstabs;
typedef struct lstabs* PLSTABS;
typedef const struct lstabs* PCLSTABS;

#endif /* PLSTABS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\pobjdim.h ===
#ifndef POBJDIM_DEFINED
#define POBJDIM_DEFINED

struct objdim;
typedef struct objdim* POBJDIM;
typedef const struct objdim* PCOBJDIM;

#endif /* !POBJDIM_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\pposichn.h ===
#ifndef PPOSICHN_DEFINED
#define PPOSICHN_DEFINED

struct posichnk;
typedef const struct posichnk* PCPOSICHNK;
typedef struct posichnk* PPOSICHNK;

#endif /* !PPOSICHN_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\plsulinf.h ===
#ifndef PLSULINFO_DEFINED
#define PLSULINFO_DEFINED

struct lsulinfo;
typedef struct lsulinfo* PLSULINFO;

#endif /* !PLSULINFO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\posichnk.h ===
#ifndef POSICHNK_DEFINED
#define POSICHNK_DEFINED

#include "lsdefs.h"
#include "pposichn.h"

#define ichnkOutside 0xFFFFFFFF

typedef struct posichnk					/* position in chunk		*/
{
	long ichnk;							/* index in the chunk array	*/
	LSDCP dcp;							/* from beginning of dobj	*/
} POSICHNK;



#endif /* !POSICHNK_DEFINED                    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\plstxtcf.h ===
#ifndef PLSTXTCF_DEFINED
#define PLSTXTCF_DEFINED

struct lstxtcfg;
typedef struct lstxtcfg *PLSTXTCFG;
typedef const struct lstxtcfg *PCLSTXTCFG;

#endif /* PLSTXTCF_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\robj.h ===
#ifndef ROBJ_DEFINED
#define ROBJ_DEFINED

#include "lsimeth.h"

#define REVERSE_VERSION 0x300

/* Prototype for Reverse Object enumeration callback */
typedef LSERR (WINAPI * PFNREVERSEENUM)(
	POLS pols,				/*(IN): client context */
	PLSRUN plsrun,			/*(IN): from DNODE */
	PCLSCHP plschp,			/*(IN): from DNODE */
	LSCP cp,				/*(IN): from DNODE */
	LSDCP dcp,				/*(IN): from DNODE */
	LSTFLOW lstflow,		/*(IN): text flow */
	BOOL fReverse,			/*(IN): enumerate in reverse order */
	BOOL fGeometryNeeded,	/*(IN): */
	const POINT* pt,		/*(IN): starting position (top left), iff fGeometryNeeded */
	PCHEIGHTS pcheights,	/*(IN): from DNODE, relevant iff fGeometryNeeded */
	long dupRun,			/*(IN): from DNODE, relevant iff fGeometryNeeded */
	LSTFLOW lstflowSubline,	/*(IN): lstflow of subline in reverse object */
	PLSSUBL plssubl);		/*(IN): subline in reverse object. */

/*
 *
 *	Reverse Object initialization data that the client application must return
 *	when the Reverse Object handler calls the GetObjectHandlerInfo callback.
 *
 */


/* Prototype for Reverse Object get info */

typedef LSERR (WINAPI * PFNREVERSEGETINFO)
(
	POLS	pols,
	LSCP	cp,
	PLSRUN	plsrun,

	BOOL	* pfDoNotBreakAround,
	BOOL	* pfSuppressTrailingSpaces
);

typedef struct REVERSEINIT
{
        DWORD					dwVersion;		/* Version. Must be REVERSE_VERSION */
        WCHAR					wchEndReverse;	/* Escape char for end of Reverse Object */

		WCHAR					wchUnused1;		/* Unused for alignment */
		PFNREVERSEGETINFO		pfnGetRobjInfo;	/* Callback GetInfo */
		PFNREVERSEENUM			pfnEnum;		/* Enumeration callback */

} REVERSEINIT;

LSERR WINAPI LsGetReverseLsimethods(
        LSIMETHODS *plsim);

/* GetReverseLsimethods
 *
 *	plsim (OUT): Reverse Object Handler methods for Line Services.
 *
 */

#endif /* ROBJ_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\tatenak.h ===
#ifndef TATENAKYOKO_DEFINED
#define TATENAKYOKO_DEFINED

#include "lsimeth.h"

/*
 *
 *	Tatenakayoko object callbacks to client application
 *
 */
typedef struct TATENAKYOKOCBK
{
	LSERR (WINAPI *pfnGetTatenakayokoLinePosition)(
		POLS pols,
		LSCP cp,
		LSTFLOW lstflow,
		PLSRUN plsrun,
		long dvr,
		PHEIGHTS pheightsRef,
		PHEIGHTS pheightsPres,
		long *pdvpDescentReservedForClient);

	/* GetTatenakayokoLinePosition
	 *  pols (IN): The client context for the request.
	 *
	 *  cp (IN): the cp of the Tatenakayoko object.
	 *
	 *  lstflow (IN): the lstflow of Tatenakayoko parent subline
	 *
	 *	plsrun (IN): the plsrun of the Tatenakayoko object.
	 *
	 *	dvr	(IN): the total height of the tatenakayoko object with respect to 
	 *			the current flow of the line in reference units.
	 *
	 *	pheightsRef	(OUT): specifies heights of Tatenakayoko object in reference
	 *			device units. 
	 *
	 *	pdvrDescentReservedForClient (OUT): specifies the part of the descent area 
	 *			that the client is reserving for its own use (usually for the purpose 
	 *			of underlining) in reference device units. The object will begin its 
	 *			display area below the baseline at the difference between *pdvrDescent 
	 *			and *pdvrDescentReservedForClient. 
	 *
	 *	pheightsPres (OUT): specifies heights of Tatenakayoko object in presenatation
	 *			device units. 
	 *
	 *	pdvpDescentReservedForClient (OUT): specifies the part of the descent area 
	 *			that the client is reserving for its own use (usually for the purpose 
	 *			of underlining) in presentation device units. The object will begin its 
	 *			display area below the baseline at the difference between *pdvpDescent 
	 *			and pheightsPres.dvDescent. 
	 *
	 */

	LSERR (WINAPI* pfnTatenakayokoEnum)(
		POLS pols,
		PLSRUN plsrun,		
		PCLSCHP plschp,	
		LSCP cp,		
		LSDCP dcp,		
		LSTFLOW lstflow,	
		BOOL fReverse,		
		BOOL fGeometryNeeded,	
		const POINT* pt,		
		PCHEIGHTS pcheights,	
		long dupRun,
		LSTFLOW lstflowT,
		PLSSUBL plssubl);

	/* TatenakayokoEnum
	 * 
	 *	pols (IN): client context.
	 *
	 *  plsrun (IN): plsrun for the entire Tatenakayoko Object.
	 *
	 *	plschp (IN): is lschp for lead character of Tatenakayoko Object.
	 *
	 *	cp (IN): is cp of first character of Tatenakayoko Object.
	 *
	 *	dcp (IN): is number of characters in Tatenakayoko Object
	 *
	 *	lstflow (IN): is text flow at Tatenakayoko Object.
	 *
	 *	fReverse (IN): is whether text should be reversed for visual order.
	 *
	 *	fGeometryNeeded (IN): is whether Geometry should be returned.
	 *
	 *	pt (IN): is starting position , iff fGeometryNeeded .
	 *
	 *	pcheights (IN):	is height of Tatenakayoko object, iff fGeometryNeeded.
	 *
	 *	dupRun (IN): is length of Tatenakayoko Object, iff fGeometryNeeded.
	 *
	 *	lstflowT (IN): is text flow for Tatenakayoko object.
	 *
	 *	plssubl (IN): is subline for Tatenakayoko object.
	 */

} TATENAKAYOKOCBK;

/*
 *
 *	Tatenakayoko object initialization data that the client application must return
 *	when the Tatenakayoko object handler calls the GetObjectHandlerInfo callback.
 */

#define TATENAKAYOKO_VERSION 0x300

typedef struct TATENAKAYOKOINIT
{
	DWORD				dwVersion;			/* Version. Only TATENAKAYOKO_VERSION is valid. */
	WCHAR				wchEndTatenakayoko;	/* Character marking end of Tatenakayoko object */
	WCHAR				wchUnused1;			/* For alignment */
	WCHAR				wchUnused2;			/* For alignment */
	WCHAR				wchUnused3;			/* For alignment */
	TATENAKAYOKOCBK		tatenakayokocbk;	/* Client application callbacks */
} TATENAKAYOKOINIT, *PTATENAKAYOKOINIT;

LSERR WINAPI LsGetTatenakayokoLsimethods(
	LSIMETHODS *plsim);

/* GetTatenakayokoLsimethods
 *	
 *	plsim (OUT): Tatenakayoko object methods for Line Services
 *
 */

#endif /* TATENAKYOKO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\ruby.h ===
#ifndef RUBY_DEFINED
#define RUBY_DEFINED

#include	"lsimeth.h"

/* Only valid version number for Ruby initialization */
#define RUBY_VERSION 0x300

/* Used for intialization to tell Ruby object which line comes first */
typedef enum rubysyntax { RubyPronunciationLineFirst, RubyMainLineFirst } RUBYSYNTAX;


/* Type of Adjustment for Ruby text returned by FetchRubyPosition callback */
enum rubycharjust { 
	rcjCenter, 		/* Centering occurs on longer text line */

	rcj010, 		/* Difference in space between longer text
					 * and shorter is distributed in the shorter
					 * string evenly between each character 
					 */

	rcj121,			/* Difference in space between longer string
					 * and shorter is distributed in the shorter
					 * using a ratio of 1:2:1 which corresponds
					 * to lead : inter-character : end.
					 */

	rcjLeft,		/* Align ruby with the left of the main line.
					 */

	rcjRight		/* Align ruby with the right of the main line.
					 */
};

/* Location of character input to FetchRubyWidthAdjust callback */
enum rubycharloc {
	rubyBefore,		/* Character preceeds Ruby object */
	rubyAfter		/* Character follows Ruby object */
};

/*
 *
 *	Ruby Object callbacks to client application
 *
 */
typedef struct RUBYCBK
{
	LSERR (WINAPI *pfnFetchRubyPosition)(
		POLS pols,
		LSCP cp,
		LSTFLOW lstflow,
		DWORD cdwMainRuns,
		const PLSRUN *pplsrunMain,
		PCHEIGHTS pcheightsRefMain,
		PCHEIGHTS pcheightsPresMain,
		DWORD cdwRubyRuns,
		const PLSRUN *pplsrunRuby,
		PCHEIGHTS pcheightsRefRuby,
		PCHEIGHTS pcheightsPresRuby,
		PHEIGHTS pheightsRefRubyObj,
		PHEIGHTS pheightsPresRubyObj,
		long *pdvpOffsetMainBaseline,
		long *pdvrOffsetRubyBaseline,
		long *pdvpOffsetRubyBaseline,
		enum rubycharjust *prubycharjust,
		BOOL *pfSpecialLineStartEnd);

	/* FetchRubyPosition
	 *  pols (IN): The client context for the request.
	 *
	 *  cp (IN): the cp of the Ruby object.
	 *
	 *  lstflow (IN): the lstflow of Ruby parent subline
	 *
	 *	pplsrunMain	(IN): array of PLSRUNs created by the client application 
	 *			for each of the runs in the main text for the Ruby object.
	 *
	 *	pcheightsRefMain (IN): height of the line of the main text in reference 
	 *			device units.
	 *
	 *	pcheightsPresMain (IN): height of the line of the main text in presentation
	 *			device units.
	 *
	 *	cdwRubyRuns	(IN): count of pronunciation runs supplied in the following 
	 *			parameter.
	 *
	 *	pplsrunRuby	(IN): array of PLSRUNS created by the client application for 
	 *			each of the runs in the pronunciation text for the Ruby object.
	 *
	 *	pcheightsRefRuby (IN): height of the line of the Ruby pronunciation text in 
	 *			reference device units.
	 *
	 *	pcheightsPresRuby (IN): height of the line of the Ruby pronunciation text in 
	 *			presentation device units.
	 *
	 *	pheightsRefRubyObj	(OUT): returned height values in reference device units
	 *			that ruby object will report back to line services.
	 *
	 *	pheightsPresRubyObj	(OUT): returned height values in presentation device units
	 *			that ruby object will report back to line services.
	 *
	 *	pdvpOffsetMainBaseline (OUT): offset of baseline of main line of Ruby
	 *			text from base line of Ruby object in presentation units. Note
	 *			a negative value puts the baseline of the main line below the 
	 *			base line of the Ruby object.
	 *
	 *	pdvrOffsetRubyBaseline (OUT): offset of baseline of pronunciation line
	 *			of Ruby text from base line of Ruby object in reference units. 
	 *			Note a negative value puts the baseline of the pronunciation line 
	 *			below the base line of the Ruby object.
	 *
	 *	pdvpOffsetRubyBaseline (OUT): offset of baseline of pronunciation line
	 *			of Ruby text from base line of Ruby object in presentation units. 
	 *			Note a negative value puts the baseline of the pronunciation line 
	 *			below the base line of the Ruby object.
	 *
	 *	prubycharjust (OUT): type of justification to use for Ruby Object.
	 *
	 *	pfSpecialLineStartEnd (OUT): specifies that the optional alignment that 
	 *			overrides the usual centering algorithm when the Ruby is the 
	 *			first or last character of the line.
	 *
	 */

	LSERR (WINAPI *pfnFetchRubyWidthAdjust)(
		POLS pols,
		LSCP cp,
		PLSRUN plsrunForChar,
		WCHAR wch,
		MWCLS mwclsForChar,
		PLSRUN plsrunForRuby,
		enum rubycharloc rcl,
		long durMaxOverhang,
		long *pdurAdjustChar,
		long *pdurAdjustRuby);

	/* FetchRubyWidthAdjust
	 *  pols (IN): The client context for the request.
	 *
	 *  cp (IN): the cp of the Ruby object.
	 *
	 *	plsrunForChar (IN): the run that is either previous or following the 
	 *			Ruby object.
	 *
	 *	wch (IN): character that is either before or after the Ruby object.
	 *
	 *	mwcls (IN): mod width class for the character.
	 *
	 *	plsrunForRuby (IN): plsrun for entire ruby object.
	 *
	 *	rcl	(IN): tells the location of the character.
	 *
	 *	durMaxOverhang (IN): designates the maximum amount of overhang that is 
	 *			possible following the JIS spec with respect to overhang. 
	 *			Adjusting the Ruby object by a negative value whose absolute 
	 *			value is greater than durMaxOverhang will cause part of the 
	 *			main text to be clipped. If the value of this parameter is 0, 
	 *			this indicates that there is no possible overhang.
	 *
	 *	pdurAdjustChar (OUT): designates the amount to adjust the width of the 
	 *			character prior to or following the Ruby object. Returing a negative 
	 *			value will decrease the size of the character preceeding or following 
	 *			the Ruby while returning a positive value will increase the size 
	 *			of that character.
	 *
	 *	pdurAdjustRuby (OUT): designates the amount adjust the width of the Ruby 
	 *			object. Returing a negative value will decrease the size of the 
	 *			Ruby object and potentially cause the Ruby pronunciation text to 
	 *			overhang the preceeding or following character while returning a 
	 *			positive value will increase the size of the Ruby object.
	 */

	LSERR (WINAPI* pfnRubyEnum)(
		POLS pols,
		PLSRUN plsrun,		
		PCLSCHP plschp,	
		LSCP cp,		
		LSDCP dcp,		
		LSTFLOW lstflow,	
		BOOL fReverse,		
		BOOL fGeometryNeeded,	
		const POINT* pt,		
		PCHEIGHTS pcheights,	
		long dupRun,		
		const POINT *ptMain,	
		PCHEIGHTS pcheightsMain,
		long dupMain,		
		const POINT *ptRuby,	
		PCHEIGHTS pcheightsRuby,
		long dupRuby,	
		PLSSUBL plssublMain,	
		PLSSUBL plssublRuby);	

	/* RubyEnum
	 * 
	 *	pols (IN): client context.
	 *
	 *  plsrun (IN): plsrun for the entire Ruby Object.
	 *
	 *	plschp (IN): is lschp for lead character of Ruby Object.
	 *
	 *	cp (IN): is cp of first character of Ruby Object.
	 *
	 *	dcp (IN): is number of characters in Ruby Object
	 *
	 *	lstflow (IN): is text flow at Ruby Object.
	 *
	 *	fReverse (IN): is whether text should be reversed for visual order.
	 *
	 *	fGeometryNeeded (IN): is whether Geometry should be returned.
	 *
	 *	pt (IN): is starting position , iff fGeometryNeeded .
	 *
	 *	pcheights (IN):	is height of Ruby object, iff fGeometryNeeded.
	 *
	 *	dupRun (IN): is length of Ruby Object, iff fGeometryNeeded.
	 *
	 *	ptMain (IN): is starting point for main line iff fGeometryNeeded
	 *
	 *	pcheightsMain (IN): is height of main line iff fGeometryNeeded
	 *
	 *	dupMain (IN): is length of main line iff fGeometryNeeded
	 *
	 *	ptRuby (IN): is point for Ruby pronunciation line iff fGeometryNeeded
	 *
	 *	pcheightsRuby (IN): is height for ruby line iff fGeometryNeeded
	 *
	 *	dupRuby (IN): is length of Ruby line iff fGeometryNeeded
	 *
	 *	plssublMain (IN): is main subline.
	 *
	 *	plssublRuby (IN): is Ruby subline.
	 *
	 */

} RUBYCBK;

/*
 *
 *	Ruby Object initialization data that the client application must return
 *	when the Ruby object handler calls the GetObjectHandlerInfo callback.
 *
 */
typedef struct RUBYINIT
{
	DWORD				dwVersion;		/* Version of the structure */
	RUBYSYNTAX			rubysyntax;		/* Used to determine order of lines during format */
	WCHAR				wchEscRuby;		/* Escape char for end of Ruby pronunciation line */
	WCHAR				wchEscMain;		/* Escape char for end of main text */
	WCHAR				wchUnused1;		/* For aligment */
	WCHAR				wchUnused2;		/* For aligment */
	RUBYCBK				rcbk;			/* Ruby callbacks */
} RUBYINIT;

LSERR WINAPI LsGetRubyLsimethods(
	LSIMETHODS *plsim);

/* GetRubyLsimethods
 *
 *	plsim (OUT): Ruby object methods for Line Services.
 *
 */

#endif /* RUBY_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\vbcursor\msr2c.h ===
//---------------------------------------------------------------------------
// MSR2C.h : Main header file for Viaduct phase II
//
// Copyright (c) 1996, 1997 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

  /////////////////////////////////////////////////////////////////////////
  // NOTE - you must define VD_INCLUDE_ROWPOSITION before including this //
  //        header for ICursorFromRowPosition to be defined in your code //
  /////////////////////////////////////////////////////////////////////////

#ifndef __MSR2C_H__
#define __MSR2C_H__

// {5B5E7E70-E653-11cf-84A5-0000C08C00C4}
const GUID CLSID_CCursorFromRowset =	
	{ 0x5b5e7e70, 0xe653, 0x11cf, { 0x84, 0xa5, 0x0, 0x0, 0xc0, 0x8c, 0x0, 0xc4 } };

// {5B5E7E72-E653-11cf-84A5-0000C08C00C4}
const IID IID_ICursorFromRowset = 
	{ 0x5b5e7e72, 0xe653, 0x11cf, { 0x84, 0xa5, 0x0, 0x0, 0xc0, 0x8c, 0x0, 0xc4 } };

#ifdef VD_INCLUDE_ROWPOSITION

// {5B5E7E73-E653-11cf-84A5-0000C08C00C4}
const IID IID_ICursorFromRowPosition = 
	{ 0x5b5e7e73, 0xe653, 0x11cf, { 0x84, 0xa5, 0x0, 0x0, 0xc0, 0x8c, 0x0, 0xc4 } };

#endif //VD_INCLUDE_ROWPOSITION

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ICursorFromRowset : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCursor( 
            /* [in]  */ IRowset __RPC_FAR *pRowset,
            /* [out] */ ICursor __RPC_FAR **ppCursor,
            /* [in]  */ LCID lcid) = 0;
    };
    
#ifdef VD_INCLUDE_ROWPOSITION

    interface ICursorFromRowPosition : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCursor( 
            /* [in]  */ IRowPosition __RPC_FAR *pRowPosition,
            /* [out] */ ICursor __RPC_FAR **ppCursor,
            /* [in]  */ LCID lcid) = 0;
    };

#endif //VD_INCLUDE_ROWPOSITION

#else 	/* C style interface */

    typedef struct ICursorFromRowset
    {
        BEGIN_INTERFACE
        
        HRESULT (STDMETHODCALLTYPE __RPC_FAR *QueryInterface)( 
            ICursorFromRowset __RPC_FAR *This,
            /* [in]  */ REFIID riid,
            /* [out] */ void __RPC_FAR **ppvObject);
        
        ULONG (STDMETHODCALLTYPE __RPC_FAR *AddRef)( 
            ICursorFromRowset __RPC_FAR *This);
        
        ULONG (STDMETHODCALLTYPE __RPC_FAR *Release)( 
            ICursorFromRowset __RPC_FAR *This);
        
        HRESULT (STDMETHODCALLTYPE __RPC_FAR *GetCursor)( 
            ICursorFromRowset __RPC_FAR *This,
            /* [in]  */ IRowset __RPC_FAR *pRowset,
            /* [out] */ ICursor __RPC_FAR **ppCursor,
            /* [in]  */ LCID lcid);
        
        END_INTERFACE
    } ICursorFromRowsetVtbl;

    interface ICursorFromRowset
    {
        CONST_VTBL struct ICursorFromRowsetVtbl __RPC_FAR *lpVtbl;
    };

#ifdef VD_INCLUDE_ROWPOSITION

    typedef struct ICursorFromRowPosition
    {
        BEGIN_INTERFACE
        
        HRESULT (STDMETHODCALLTYPE __RPC_FAR *QueryInterface)( 
            ICursorFromRowPosition __RPC_FAR *This,
            /* [in]  */ REFIID riid,
            /* [out] */ void __RPC_FAR **ppvObject);
        
        ULONG (STDMETHODCALLTYPE __RPC_FAR *AddRef)( 
            ICursorFromRowPosition __RPC_FAR *This);
        
        ULONG (STDMETHODCALLTYPE __RPC_FAR *Release)( 
            ICursorFromRowPosition __RPC_FAR *This);
        
        HRESULT (STDMETHODCALLTYPE __RPC_FAR *GetCursor)( 
            ICursorFromRowPosition __RPC_FAR *This,
            /* [in]  */ IRowPosition __RPC_FAR *pRowPosition,
            /* [out] */ ICursor __RPC_FAR **ppCursor,
            /* [in]  */ LCID lcid);
        
        END_INTERFACE
    } ICursorFromRowPositionVtbl;

    interface ICursorFromRowPosition
    {
        CONST_VTBL struct ICursorFromRowPositionVtbl __RPC_FAR *lpVtbl;
    };

#endif //VD_INCLUDE_ROWPOSITION

#endif 	/* C style interface */

#ifdef __cplusplus
extern "C" {
#endif
// old entry point
HRESULT WINAPI VDGetICursorFromIRowset(IRowset * pRowset, 
                                       ICursor ** ppCursor,
                                       LCID lcid);
#ifdef __cplusplus
}
#endif

//
// MessageId: VD_E_CANNOTGETMANDATORYINTERFACE
//
// MessageText:
//
//  Unable to get required interface
//
#define VD_E_CANNOTGETMANDATORYINTERFACE        ((HRESULT)0x80050E00L)

//
// MessageId: VD_E_CANNOTCONNECTIROWSETNOTIFY
//
// MessageText:
//
//  Unable to connect IRowsetNotify
//
#define VD_E_CANNOTCONNECTIROWSETNOTIFY         ((HRESULT)0x80050E31L)

//
// MessageId: VD_E_CANNOTGETCOLUMNINFO
//
// MessageText:
//
//  Unable to get column information
//
#define VD_E_CANNOTGETCOLUMNINFO                ((HRESULT)0x80050E32L)

//
// MessageId: VD_E_CANNOTCREATEBOOKMARKACCESSOR
//
// MessageText:
//
//  Unable to create bookmark accessor
//
#define VD_E_CANNOTCREATEBOOKMARKACCESSOR       ((HRESULT)0x80050E33L)

//
// MessageId: VD_E_REQUIREDPROPERTYNOTSUPPORTED
//
// MessageText:
//
//  Require rowset property is not supported
//
#define VD_E_REQUIREDPROPERTYNOTSUPPORTED       ((HRESULT)0x80050E34L)

//
// MessageId: VD_E_CANNOTGETROWSETINTERFACE
//
// MessageText:
//
//  Unable to get rowset interface
//
#define VD_E_CANNOTGETROWSETINTERFACE			((HRESULT)0x80050E35L)

//
// MessageId: VD_E_CANNOTCONNECTIROWPOSITIONCHANGE
//
// MessageText:
//
//  Unable to connect IRowPositionChange
//
#define VD_E_CANNOTCONNECTIROWPOSITIONCHANGE	((HRESULT)0x80050E36L)

#endif //__MSR2C_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\warichu.h ===
#ifndef WARICHU_DEFINED
#define WARICHU_DEFINED

#include	"lsimeth.h"

/* Character location for pfnFetchWarichuWidthAdjust callback */
enum warichucharloc {
	warichuBegin,				/* Character preceeds Warichu object */
	warichuEnd					/* Character follows Warichu object */
};

/*
 *
 * Warichu Object Callbacks to Client
 *
 */
typedef struct WARICHUCBK
{
	LSERR (WINAPI* pfnGetWarichuInfo)(
		POLS pols,
		LSCP cp,
		LSTFLOW lstflow,
		PCOBJDIM pcobjdimFirst,
		PCOBJDIM pcobjdimSecond,
		PHEIGHTS pheightsRef,
		PHEIGHTS pheightsPres,
		long *pdvpDescentReservedForClient);

	/* GetWarichuInfo
	 *  pols (IN): The client context for the request.
	 *
	 *  cp (IN): the cp of the Warichu object.
	 *
     *  lstflow (IN): the lstflow of Warichu parent subline
	 *
	 *	pcobjdimFirst (IN): dimensions of first line of Warichu.
	 *
	 *	pcobjdimSecond (IN): dimensions of second line of Warichu.
	 *
	 *	pheightsRef (OUT): specifies heights for Warichu object in reference
	 *			device units.
	 *
	 *	pheightsPres (OUT): specifies heights for Warichu object in presentation
	 *			device units.
	 *
	 *	pdvpDescentReservedForClient (OUT): specifies the part of the descent area 
	 *			that the client is reserving for its own use (usually for the purpose 
	 *			of underlining) in presentation device units. The object will begin its 
	 *			display area below the baseline at the difference between 
	 *			pheightsRef->dvDescent and *pdvpDescentReservedForClient. 
	 *
	 */

	LSERR (WINAPI* pfnFetchWarichuWidthAdjust)(
		POLS pols,
		LSCP cp,
		enum warichucharloc wcl,
		PLSRUN plsrunForChar,
		WCHAR wch,
		MWCLS mwclsForChar,
		PLSRUN plsrunWarichuBracket,
		long *pdurAdjustChar,
		long *pdurAdjustBracket);

	/* FetchWarichuWidthAdjust
	 *  pols (IN): The client context for the request.
	 *
	 *  cp (IN): the cp of the Warichu object.
	 *
	 *  wcl (IN): specifies the location of the character and bracket.
	 *
	 *  plsrunForChar (IN): the run of the character that is either previous or 
	 *		following the Warichu object. Whether preceeding or following is 
	 *		determined by value of the wcl parameter above.
	 *
	 *	wch (IN): character that is either preceeding or following the Warichu 
	 *		object.
	 *
	 *	mwclsForChar (IN): mod width class for the wch parameter.
	 *
	 *	plsrunWarichuBracket (IN): plsrun for leading or following bracket of 
	 *		the Warichu.
	 *
	 *	pdurAdjustChar (OUT): the amount that the width of the input character 
	 *		should be adjusted. A negative value means the width of the input 
	 *		character should be made smaller.
	 *
	 *	pdurAdjustBracket (OUT): the amount that the width of the Warichu bracket
	 *		should be adjusted.  A negative value means the width of the Warichu 
	 *		bracket should be made smaller.
	 */

	LSERR (WINAPI* pfnWarichuEnum)(
		POLS pols,
		PLSRUN plsrun,		
		PCLSCHP plschp,	
		LSCP cp,		
		LSDCP dcp,		
		LSTFLOW lstflow,	
		BOOL fReverse,		
		BOOL fGeometryNeeded,	
		const POINT* pt,		
		PCHEIGHTS pcheights,	
		long dupRun,		
		const POINT *ptLeadBracket,	
		PCHEIGHTS pcheightsLeadBracket,
		long dupLeadBracket,		
		const POINT *ptTrailBracket,	
		PCHEIGHTS pcheightsTrailBracket,
		long dupTrailBracket,
		const POINT *ptFirst,	
		PCHEIGHTS pcheightsFirst,
		long dupFirst,		
		const POINT *ptSecond,	
		PCHEIGHTS pcheightsSecond,
		long dupSecond,
		PLSSUBL plssublLeadBracket,
		PLSSUBL plssublTrailBracket,
		PLSSUBL plssublFirst,	
		PLSSUBL plssublSecond);	

	/* WarichuEnum
	 * 
	 *	pols (IN): client context.
	 *
	 *  plsrun (IN): plsrun for the entire Warichu Object.
	 *
	 *	plschp (IN): is lschp for lead character of Warichu Object.
	 *
	 *	cp (IN): is cp of first character of Warichu Object.
	 *
	 *	dcp (IN): is number of characters in Warichu Object
	 *
	 *	lstflow (IN): is text flow at Warichu Object.
	 *
	 *	fReverse (IN): is whether text should be reversed for visual order.
	 *
	 *	fGeometryNeeded (IN): is whether Geometry should be returned.
	 *
	 *	pt (IN): is starting position , iff fGeometryNeeded .
	 *
	 *	pcheights (IN):	is height of Warichu object, iff fGeometryNeeded.
	 *
	 *	dupRun (IN): is length of Warichu Object, iff fGeometryNeeded.
	 *
	 *	ptLeadBracket (IN):	is point for second line iff fGeometryNeeded and 
	 *		plssublLeadBracket not NULL.
	 *
	 *	pcheightsLeadBracket (IN): is height for Warichu line iff fGeometryNeeded 
	 *		and plssublLeadBracket not NULL.
	 *
	 *	dupLeadBracket (IN): is length of Warichu line iff fGeometryNeeded and 
	 *		plssublLeadBracket not NULL.
	 *
	 *	ptTrailBracket (IN): is point for second line iff fGeometryNeeded and 
	 *		plssublLeadBracket not NULL.
	 *
	 *	pcheightsTrailBracket (IN):	is  height for Warichu  line iff fGeometryNeeded 
	 *		and plssublTrailBracket not NULL.
	 *
	 *	dupTrailBracket (IN): is length of Warichu line iff fGeometryNeeded and 
	 *		plssublTrailBracket not NULL.
	 *
	 *	ptFirst (IN): is starting point for main line iff fGeometryNeeded
	 *
	 *	pcheightsFirst (IN): is height of main line iff fGeometryNeeded
	 *
	 *	dupFirst (IN): is length of main line iff fGeometryNeeded
	 *
	 *	ptSecond (IN): is point for second line iff fGeometryNeeded and 
	 *		plssublSecond not NULL.
	 *
	 *	pcheightsSecond (IN): is height for Warichu line iff fGeometryNeeded 
	 *		and plssublSecond not NULL.
	 *
	 *	dupSecond (IN):	is length of Warichu line iff fGeometryNeeded and 
	 *		plssublSecond not NULL.
	 *
	 *	plssublLeadBracket (IN): is subline for lead bracket.
	 *
	 *	plssublTrailBracket (IN): is subline for trail bracket.
	 *
	 *	plssublFirst (IN): is first subline in Warichu object.
	 *
	 *	plssublSecond (IN):	is second subline in Warichu object.
	 *
	 */

} WARICHUCBK;

#define WARICHU_VERSION 0x300

/*
 * 
 *	Warichi object initialization data that the client application must return
 *	when the Warichu object handler calls the GetObjectHandlerInfo callback.
 */
typedef struct WARICHUINIT
{
	DWORD				dwVersion;			/* Version must be WARICHU_VERSION */
	WCHAR				wchEndFirstBracket;	/* Escape char to end first bracket */
	WCHAR				wchEndText;			/* Escape char to end text */
	WCHAR				wchEndWarichu;		/* Escape char to end object */
	WCHAR				wchUnused;			/* For alignment */
	WARICHUCBK			warichcbk;			/* Callbacks */
	BOOL				fContiguousFetch;	/* Always refetch whole subline & closing brace
											   after reformatting inside warichu */
} WARICHUINIT;

LSERR WINAPI LsGetWarichuLsimethods(
	LSIMETHODS *plsim);

/* GetWarichuLsimethods
 *
 *	plsim (OUT): Warichu object callbacks.
 */

#endif /* WARICHU_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\vbcursor\ocdbid.h ===
/*=--------------------------------------------------------------------------=
 * ocdbid.h
 *=--------------------------------------------------------------------------=
 * defines all the guids for OLE Controls Data Binding Interfaces interfaces.
 *
 * Copyright (c) 1994-1995 Microsoft Corporation, All Rights Reserved.
 *
 */

/* {9F6AA700-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursor,
0x9f6aa700, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {ACFF0690-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursorMove,
0xacff0690, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {BB87E420-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursorScroll,
0xbb87e420, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {D14216A0-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursorUpdateARow,
0xd14216a0, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {DB526CC0-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_INotifyDBEvents,
0xdb526cc0, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {E01D7850-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursorFind,
0xe01d7850, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {E4D19810-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_IEntryID,
0xe4d19810, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {E8BF1170-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(_GUID_NAMEONLY,
0xe8bf1170, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {F6304BB0-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(_DBBMKGUID,
0xf6304bb0, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {FE284700-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(_OCDBCIDGUID,
0xfe284700, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\vbcursor\olebind.h ===
/*****************************************************************************\
*                                                                             *
* olebind.h     Data binding interfaces for OLE                               *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1994, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

#if !defined( _OLEBIND_H_ )
#define _OLEBIND_H_

#if !defined( INITGUID )
#include <olectl.h>
#endif

DEFINE_GUID(IID_IBoundObject,
	0x9BFBBC00,0xEFF1,0x101A,0x84,0xED,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IBoundObjectSite,
	0x9BFBBC01,0xEFF1,0x101A,0x84,0xED,0x00,0xAA,0x00,0x34,0x1D,0x07);

typedef interface IBoundObject FAR* LPBOUNDOBJECT;
typedef interface IBoundObjectSite FAR* LPBOUNDOBJECTSITE;

typedef interface ICursor FAR* LPCURSOR;
typedef interface ICursor FAR* FAR* LPLPCURSOR;
typedef interface ICursorMove FAR* LPCURSORMOVE;
typedef interface ICursorScroll FAR* LPCURSORSCROLL;
typedef interface ICursorFind FAR* LPCURSORFIND;
typedef interface ICursorUpdateARow FAR* LPCURSORUPDATEAROW;


//////////////////////////////////////////////////////////////////////////////
//
//  IBoundObject interface
//
//////////////////////////////////////////////////////////////////////////////

#undef  INTERFACE
#define INTERFACE IBoundObject

DECLARE_INTERFACE_(IBoundObject, IUnknown)
{
    //
    //  IUnknown methods
    //
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    //
    //  IBoundObject methods
    //
    STDMETHOD(OnSourceChanged)(THIS_ DISPID dispid, BOOL fBound, BOOL FAR* lpfOwnXferOut) PURE;
    STDMETHOD(IsDirty)(THIS_ DISPID dispid) PURE;
};
//////////////////////////////////////////////////////////////////////////////
//
//  IBoundObjectSite interface
//
//////////////////////////////////////////////////////////////////////////////

#undef  INTERFACE
#define INTERFACE IBoundObjectSite

DECLARE_INTERFACE_(IBoundObjectSite, IUnknown)
{
    //
    //  IUnknown methods
    //
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    //
    //  IBoundObjectSite methods
    //
    STDMETHOD(GetCursor)(THIS_ DISPID dispid, LPLPCURSOR ppCursor, LPVOID FAR* ppcidOut) PURE;
};


#endif // !defined( _OLEBIND_H_ )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\vbcursor\msc2r.h ===
//---------------------------------------------------------------------------
// MSC2R.h : Main header file for the MSC2R DLL
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#ifndef __MSC2R_H__
#define __MSC2R_H__

// {E55A7600-E666-11cf-84A5-0000C08C00C4}
const GUID CLSID_CRowsetFromCursor =	
	{ 0xe55a7600, 0xe666, 0x11cf, { 0x84, 0xa5, 0x0, 0x0, 0xc0, 0x8c, 0x0, 0xc4 } };

// {E55A7601-E666-11cf-84A5-0000C08C00C4}
const IID IID_IRowsetFromCursor = 
	{ 0xe55a7601, 0xe666, 0x11cf, { 0x84, 0xa5, 0x0, 0x0, 0xc0, 0x8c, 0x0, 0xc4 } };

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRowsetFromCursor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRowset( 
            /* [in] */ ICursor __RPC_FAR *pCursor,
            /* [out] */ IRowset __RPC_FAR **ppRowset,
            /* [in] */ LCID lcid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowsetFromCursor
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRowsetFromCursor __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRowsetFromCursor __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRowsetFromCursor __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRowset )( 
            IRowsetFromCursor __RPC_FAR * This,
            /* [in] */ ICursor __RPC_FAR *pCursor,
            /* [out] */ IRowset __RPC_FAR **ppRowset,
            /* [in] */ LCID lcid);
        
        END_INTERFACE
    } IRowsetFromCursorVtbl;

    interface IRowsetFromCursor
    {
        CONST_VTBL struct IRowsetFromCursorVtbl __RPC_FAR *lpVtbl;
    };

#endif 	/* C style interface */

#ifdef __cplusplus
extern "C" {
#endif
// MSC2R entry point
HRESULT WINAPI VDGetIRowsetFromICursor(ICursor * pCursor,
									   IRowset ** ppRowset,
									   LCID lcid);
#ifdef __cplusplus
}
#endif

//
// MessageId: VD_E_CANNOTGETMANDATORYINTERFACE
//
// MessageText:
//
//  Unable to get required interface
//
#define VD_E_CANNOTGETMANDATORYINTERFACE        ((HRESULT)0x80050E00L)

//
// MessageId: VD_E_CANNOTCONNECTINOTIFYDBEVENTS
//
// MessageText:
//
//  Unable to connect INotifyDBEvents
//
#define VD_E_CANNOTCONNECTINOTIFYDBEVENTS       ((HRESULT)0x80050E01L)

//
// MessageId: VD_E_CANNOTSETBINDINGSONCOLUMNSCURSOR
//
// MessageText:
//
//  Unable to set bindings on columns cursor
//
#define VD_E_CANNOTSETBINDINGSONCOLUMNSCURSOR   ((HRESULT)0x80050E02L)

//
// MessageId: VD_E_CANNOTSETBINDINGSONCLONECURSOR
//
// MessageText:
//
//  Unable to set bindings on clone cursor
//
#define VD_E_CANNOTSETBINDINGSONCLONECURSOR     ((HRESULT)0x80050E03L)

#endif //__MSC2R_H__
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\vruby.h ===
/* Vertical ruby interfaces */
/* Contact: antons */

#ifndef VRUBY_DEFINED
#define VRUBY_DEFINED

#include "lsimeth.h"

/* Only valid version number for Ruby initialization */

#define VRUBY_VERSION 0x300

/* Used for intialization to tell Ruby object which line comes first */

typedef enum vrubysyntax { VRubyPronunciationLineFirst, VRubyMainLineFirst } VRUBYSYNTAX;

/*
 *
 *	Vertical Ruby Object callbacks to client application
 *
 */

typedef struct VRUBYCBK
{
	LSERR (WINAPI *pfnFetchVRubyPosition)
	(
		/* in */

		POLS			pols,
		LSCP			cp,
		LSTFLOW			lstflow,
		PLSRUN			plsrun,
		PCHEIGHTS		pcheightsRefMain,
		PCHEIGHTS		pcheightsPresMain,
		long			dvrRuby,

		/* out */

		PHEIGHTS		pheightsPresRubyT,
		PHEIGHTS		pheightsRefRubyT,
		LONG*			 pdurAdjust
	);

	LSERR (WINAPI* pfnVRubyEnum)
	(
		POLS pols,
		PLSRUN plsrun,		
		PCLSCHP plschp,	
		LSCP cp,		
		LSDCP dcp,		
		LSTFLOW lstflow,	
		BOOL fReverse,		
		BOOL fGeometryNeeded,	
		const POINT* pt,		
		PCHEIGHTS pcheights,	
		long dupRun,		
		const POINT *ptMain,	
		PCHEIGHTS pcheightsMain,
		long dupMain,		
		const POINT *ptRuby,	
		PCHEIGHTS pcheightsRuby,
		long dupRuby,	
		PLSSUBL plssublMain,	
		PLSSUBL plssublRuby
	);

} VRUBYCBK;

/*
 *
 *	Ruby Object initialization data that the client application must return
 *	when the Ruby object handler calls the GetObjectHandlerInfo callback.
 *
 */
typedef struct VRUBYINIT
{
	DWORD				dwVersion;		/* Version of the structure (must be VRUBY_VERSION) */
	VRUBYSYNTAX			vrubysyntax;	/* Used to determine order of lines during format */
	WCHAR				wchEscRuby;		/* Escape char for end of Ruby pronunciation line */
	WCHAR				wchEscMain;		/* Escape char for end of main text */
	VRUBYCBK			vrcbk;			/* Ruby callbacks */

} VRUBYINIT;


LSERR WINAPI LsGetVRubyLsimethods ( LSIMETHODS *plsim );

/* GetRubyLsimethods
 *
 *	plsim (OUT): Ruby object methods for Line Services.
 *
 */


#endif /* VRUBY_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\vbcursor\vbdsc.h ===
/*****************************************************************************\
*                                                                             *
* vbdsc.h       DSC interfaces for OLE                                        *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1994, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

#if !defined( _VBDSC_H_ )
#define _VBDSC_H_

//#if !defined( INITGUID )
//#include <olectl.h>
//#endif

DEFINE_GUID(IID_IVBDSC,
        0x1ab42240, 0x8c70, 0x11ce, 0x94, 0x21, 0x0, 0xaa, 0x0, 0x62, 0xbe, 0x57);

typedef interface IVBDSC FAR *LPVBDSC;


typedef enum _tagDSCERROR
  {
  DSCERR_BADDATAFIELD = 0
  }
DSCERROR;


//////////////////////////////////////////////////////////////////////////////
//
//  IVBDSC interface
//
//////////////////////////////////////////////////////////////////////////////

#undef INTERFACE
#define INTERFACE IVBDSC

DECLARE_INTERFACE_(IVBDSC, IUnknown)
{
    //
    //  IUnknown methods
    //
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    //
    //  IVBDSC methods
    //
    STDMETHOD(CancelUnload)(THIS_ BOOL FAR *pfCancel) PURE;
    STDMETHOD(Error)(THIS_ DWORD dwErr, BOOL FAR *pfShowError) PURE;
    STDMETHOD(CreateCursor)(THIS_ ICursor FAR * FAR *ppCursor) PURE;
};

#endif // !defined( _VBDSC_H_ )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\msls\zqfromza.h ===
#ifndef ZQFROMZQ_DEFINED
#define ZQFROMZQ_DEFINED

#include "lsdefs.h"

#define zqLim	1491309L				/* higher resolution will overflow */

long ZqFromZa_C (long, long);

#ifdef _X86_

long ZqFromZa_Asm (long, long);
__int64 Div64_Asm (__int64, __int64);
__int64 Mul64_Asm (__int64, __int64);

#define ZqFromZa(dzqInch,za) ZqFromZa_Asm ((dzqInch),(za))

#define Div64(DVND,DVSR) Div64_Asm ((DVND),(DVSR))
#define Mul64(A,B) Mul64_Asm ((A),(B))

#else

#define ZqFromZa(dzqInch,za) ZqFromZa_C ((dzqInch),(za))

#define Div64(DVND,DVSR) ((__int64) (DVND) / (__int64) (DVSR))
#define Mul64(A,B) ((__int64) (A) * (__int64) (B))

#endif

long ZaFromZq(long, long);
long LsLwMultDivR(long, long, long);

#define I_UpFromUa(pdevres,ua)	(ZqFromZa((pdevres)->dxpInch, (ua)))
#define I_UrFromUa(pdevres,ua)	(ZqFromZa((pdevres)->dxrInch, (ua)))
#define I_VpFromVa(pdevres,va)	(ZqFromZa((pdevres)->dypInch, (va)))
#define I_VrFromVa(pdevres,va)	(ZqFromZa((pdevres)->dyrInch, (va)))
#define I_UaFromUp(pdevres,up)	(ZaFromZq((pdevres)->dxpInch, (up)))
#define I_VaFromVp(pdevres,vp)	(ZaFromZq((pdevres)->dypInch, (vp)))
#define I_UaFromUr(pdevres,ur)	(ZaFromZq((pdevres)->dxrInch, (ur)))
#define I_VaFromVr(pdevres,vr)	(ZaFromZq((pdevres)->dyrInch, (vr)))



#define UpFromUa(tfl,pdevres,ua) (((tfl) & fUVertical) ? \
		I_VpFromVa(pdevres,ua) :\
		I_UpFromUa(pdevres,ua) \
)

#define UrFromUa(tfl,pdevres,ua) (((tfl) & fUVertical) ? \
		I_VrFromVa(pdevres,ua) :\
		I_UrFromUa(pdevres,ua) \
)

#define VpFromVa(tfl,pdevres,va) ((tfl) & fUVertical) ? \
		I_UpFromUa(pdevres,va) :\
		I_VpFromVa(pdevres,va) \
)

#define VrFromVa(tfl,pdevres,va) (((tfl) & fUVertical) ? \
		I_UrFromUa(pdevres,va) :\
		I_VrFromVa(pdevres,va) \
)

#define UaFromUp(tfl,pdevres,up) (((tfl) & fUVertical) ? \
		I_VaFromVp(pdevres,up) :\
		I_UaFromUp(pdevres,up) \
)

#define VaFromVp(tfl,pdevres,vp)	(((tfl) & fUVertical) ? \
		I_UaFromUp(pdevres,vp) :\
		I_VaFromVp(pdevres,vp) \
)

#define UaFromUr(tfl,pdevres,ur)	(((tfl) & fUVertical) ?	\
		I_VaFromVr(pdevres,ur) :\
		I_UaFromUr(pdevres,ur) \
)

#define VaFromVr(tfl,pdevres,vr)	(((tfl) & fUVertical) ?	\
		I_UaFromUr(pdevres,vr) :\
		I_VaFromVr(pdevres,vr) \
)

/*
#define UpFromUr(pdevres,ur)	UpFromUa(pdevres, UaFromUr(pdevres, ur))
#define VpFromVr(pdevres,vr)	VpFromVa(pdevres, VaFromVr(pdevres, vr))
*/
#define UpFromUr(tfl,pdevres,ur)	(((tfl) & fUVertical) ? \
								LsLwMultDivR(ur, (pdevres)->dypInch, (pdevres)->dyrInch): \
								LsLwMultDivR(ur, (pdevres)->dxpInch, (pdevres)->dxrInch) \
									)
#define VpFromVr(tfl,pdevres,vr)	(((tfl) & fUVertical) ? \
								LsLwMultDivR(vr, (pdevres)->dxpInch, (pdevres)->dxrInch): \
								LsLwMultDivR(vr, (pdevres)->dypInch, (pdevres)->dyrInch) \
									)
#define UrFromUp(tfl,pdevres,up)	(((tfl) & fUVertical) ? \
								LsLwMultDivR(up, (pdevres)->dyrInch, (pdevres)->dypInch): \
								LsLwMultDivR(up, (pdevres)->dxrInch, (pdevres)->dxpInch) \
									)
#define VrFromVp(tfl,pdevres,vp)	(((tfl) & fUVertical) ? \
								LsLwMultDivR(vp, (pdevres)->dxrInch, (pdevres)->dxpInch): \
								LsLwMultDivR(vp, (pdevres)->dyrInch, (pdevres)->dypInch) \
									)

#endif /* ZQFROMZQ_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\external\inc\vbcursor\ocdb.h ===
/*=--------------------------------------------------------------------------=
 * ocdb.h
 *=--------------------------------------------------------------------------=
 * defines the interfaces and constants for use with the OLE Controls Data
 * binding interfaces.
 *
 * Copyright (c) 1994-1995 Microsoft Corporation, All Rights Reserved.
 *
 *
 *
 */
#ifndef __OCDB_H_

#undef Delete
#ifdef __cplusplus
extern "C" {
#endif

/* LPDBSTRs are MultiByte in 16bits, and Unicode in 32bits.
 */
#ifdef WIN16

#define LPDBSTR           LPSTR
#define DBCHAR            char
#define ldbstrlen(str)    lstrlen(str)
#define ldbstrcpy(a, b)   lstrcpy((a), (b))
#define ldbstrcpyn(a,b,n) lstrcpyn((a), (b), (n))
#define ldbstrcmp(a, b)   lstrcmp((a), (b))
#define ldbstrcat(a, b)   lstrcat((a), (b))
#define ldbstrcmpi(a,b)   lstrcmpi((a),(b))
#define DBTEXT(quote)     quote

#else

#define LPDBSTR           LPWSTR
#define DBCHAR            WCHAR
#define ldbstrlen(str)    wcslen(str)
#define ldbstrcpy(a, b)   wcscpy((a), (b))
#define ldbstrcpyn(a,b,n) wcsncpy((a), (b), (n))
#define ldbstrcmp(a, b)   wcscmp((a), (b))
#define ldbstrcat(a, b)   wcscat((a), (b))
#define ldbstrcmpi(a,b)   wcsicmp((a),(b))
#define DBTEXT(quote)     L##quote

#endif /* WIN16 */

typedef LPDBSTR FAR *  LPLPDBSTR;


/* Many systems don't have BLOBs defined.
 */
#ifndef _tagBLOB_DEFINED
#define _tagBLOB_DEFINED
#define _BLOB_DEFINED
#define _LPBLOB_DEFINED

typedef struct tagBLOB {

    ULONG cbSize;
    BYTE *pBlobData;

} BLOB, *LPBLOB;

#endif

/*----------------------------------------------------------------------------
 *
 *	dbvar.h
 *
 *----------------------------------------------------------------------------
 */
#ifndef _DBCOLUMNID_DEFINED
#define _DBCOLUMNID_DEFINED
typedef enum tagDBCOLKIND
  {
	DBCOLKIND_GUID_NAME = 0,
	DBCOLKIND_GUID_NUMBER = 1,
        DBCOLKIND_NAME = 2
  }
DBCOLKIND;

#define GUID_NAMEONLY	{0x88c8d398,0x863c,0x101b,{0xac,0x3b,0x00,0xaa,0x00,0x44,0x77,0x3d}}
#define GUID_NUMBERONLY	{0x88c8d399,0x863c,0x101b,{0xac,0x3b,0x00,0xaa,0x00,0x44,0x77,0x3d}}

typedef struct tagDBCOLUMNID
  {
  GUID guid;
  DBCOLKIND dwKind;
union
    {
    LONG lNumber;
    LPDBSTR lpdbsz;
    }
  ;
  }
DBCOLUMNID;
#endif   /* ndef _COLUMNID_DEFINED */

/* "DB" replaced by "OCDB" to avoid conflict with <oledb.h> */
#ifndef _DBVARENUM_DEFINED
#define _DBVARENUM_DEFINED
enum DBVARENUM
  {
	OCDBTYPE_EMPTY = 0,
	OCDBTYPE_NULL = 1,
	OCDBTYPE_I2 = 2,
	OCDBTYPE_I4 = 3,
	OCDBTYPE_R4 = 4,
	OCDBTYPE_R8 = 5,
	OCDBTYPE_CY = 6,
	OCDBTYPE_DATE = 7,
	OCDBTYPE_BOOL = 11,
	OCDBTYPE_UI2 = 18,
	OCDBTYPE_UI4 = 19,
        OCDBTYPE_I8 = 20,
        OCDBTYPE_UI8 = 21,
	OCDBTYPE_HRESULT = 25,
	OCDBTYPE_LPSTR = 30,
	OCDBTYPE_LPWSTR = 31,
	OCDBTYPE_FILETIME = 64,
	OCDBTYPE_BLOB = 65,
	OCDBTYPE_UUID = 72,
	OCDBTYPE_DBEXPR = 503,
	OCDBTYPE_COLUMNID = 507,
	OCDBTYPE_BYTES = 508,
	OCDBTYPE_CHARS = 509,
	OCDBTYPE_WCHARS = 510,
	OCDBTYPE_ANYVARIANT = 511
  }
;
#endif   /* ndef _DBVARENUM_DEFINED */

#define DBTYPE_EXT      0x100
#define DBTYPE_VECTOR	0x1000

typedef struct tagDBVARIANT DBVARIANT;

struct FARSTRUCT tagDBVARIANT{
    VARTYPE vt;
    unsigned short wReserved1;
    unsigned short wReserved2;
    unsigned short wReserved3;
    union {
      unsigned char bVal;	     /* VT_UI1               */
      short	   iVal;             /* VT_I2                */
      long	   lVal;             /* VT_I4                */
      float	   fltVal;           /* VT_R4                */
      double	   dblVal;           /* VT_R8                */
      VARIANT_BOOL boolVal;          /* VT_BOOL              */
      SCODE	   scode;            /* VT_ERROR             */
      CY	   cyVal;            /* VT_CY                */
      DATE	   date;             /* VT_DATE              */
      BSTR	   bstrVal;          /* VT_BSTR              */
      IUnknown	   FAR* punkVal;     /* VT_UNKNOWN           */
      IDispatch	   FAR* pdispVal;    /* VT_DISPATCH          */
      SAFEARRAY	   FAR* parray;	     /* VT_ARRAY|*           */

      unsigned char FAR *pbVal;      /* VT_BYREF|VT_UI1      */
      short	   FAR* piVal;       /* VT_BYREF|VT_I2	     */
      long	   FAR* plVal;       /* VT_BYREF|VT_I4	     */
      float	   FAR* pfltVal;     /* VT_BYREF|VT_R4       */
      double	   FAR* pdblVal;     /* VT_BYREF|VT_R8       */
      VARIANT_BOOL FAR* pbool;       /* VT_BYREF|VT_BOOL     */
      SCODE	   FAR* pscode;      /* VT_BYREF|VT_ERROR    */
      CY	   FAR* pcyVal;      /* VT_BYREF|VT_CY       */
      DATE	   FAR* pdate;       /* VT_BYREF|VT_DATE     */
      BSTR	   FAR* pbstrVal;    /* VT_BYREF|VT_BSTR     */
      IUnknown  FAR* FAR* ppunkVal;  /* VT_BYREF|VT_UNKNOWN  */
      IDispatch FAR* FAR* ppdispVal; /* VT_BYREF|VT_DISPATCH */
      SAFEARRAY FAR* FAR* pparray;   /* VT_BYREF|VT_ARRAY|*  */
      VARIANT	   FAR* pvarVal;     /* VT_BYREF|VT_VARIANT  */

      void	   FAR* byref;	     /* Generic ByRef        */

      // types new to DBVARIANTs
      //
      BLOB         blob;             /* VT_BLOB              */
      DBCOLUMNID  *pColumnid;        /* DBTYPE_COLUMNID      */
      LPSTR        pszVal;           /* VT_LPSTR             */
#ifdef WIN32
      LPWSTR       pwszVal;          /* VT_LPWSTR            */
      LPWSTR FAR  *ppwszVal;         /* VT_LPWSTR|VT_BYREF   */
#endif /* WIN32 */
      BLOB FAR    *pblob;            /* VT_BYREF|VT_BLOB     */
      DBCOLUMNID **ppColumnid;       /* VT_BYREF|DBTYPE_COLID*/
      DBVARIANT   *pdbvarVal;        /* VT_BYREF|DBTYPE_VARIANT */
    }
#if defined(NONAMELESSUNION) || (defined(_MAC) && !defined(__cplusplus) && !defined(_MSC_VER))
    u
#endif
    ;
};

/*----------------------------------------------------------------------------
 *
 *	dbs.h
 *
 *----------------------------------------------------------------------------
 */
typedef enum tagDBROWFETCH
  {
	DBROWFETCH_DEFAULT = 0,
	DBROWFETCH_CALLEEALLOCATES = 1,
	DBROWFETCH_FORCEREFRESH = 2
  }
DBROWFETCH;

typedef struct tagDBFETCHROWS
  {
  ULONG      cRowsRequested;
  DWORD      dwFlags;
  VOID HUGEP *pData;
  VOID HUGEP *pVarData;
  ULONG      cbVarData;
  ULONG      cRowsReturned;
  }
DBFETCHROWS;

#define DB_NOMAXLENGTH   (DWORD)0
#define DB_NOVALUE       (DWORD)0xFFFFFFFF
#define DB_NULL          (DWORD)0xFFFFFFFF
#define DB_EMPTY         (DWORD)0xFFFFFFFE
#define DB_USEENTRYID    (DWORD)0xFFFFFFFD
#define DB_CANTCOERCE    (DWORD)0xFFFFFFFC
#define DB_TRUNCATED     (DWORD)0xFFFFFFFB
#define DB_UNKNOWN       (DWORD)0xFFFFFFFA
#define DB_NOINFO        (DWORD)0xFFFFFFF9

/* "DB" replaced by "OCDB" to avoid conflict with <oledb.h> */
typedef enum tagOCDBBINDING
  {
	OCDBBINDING_DEFAULT = 0,
	OCDBBINDING_VARIANT = 1,
	OCDBBINDING_ENTRYID = 2
  }
OCDBBINDING;

typedef enum tagDBBINDTYPE
  {
        DBBINDTYPE_DATA    = 0,
	DBBINDTYPE_ENTRYID = 1,
	DBBDINTYPE_EITHER  = 2,
	DBBINDTYPE_BOTH    = 3
  }
DBBINDTYPE;

typedef enum tagDBCOMPUTED
  {
	DBCOMPUTED_COMPUTED = 0,
	DBCOMPUTED_DYNAMIC = 1,
	DBCOMPUTED_NOTCOMPUTED =2
  }
DBCOMPUTED;

typedef struct tagDBCOLUMNBINDING
  {
  DBCOLUMNID columnID;
  ULONG obData;
  ULONG cbMaxLen;
  ULONG obVarDataLen;
  ULONG obInfo;
  DWORD dwBinding;
  DWORD dwDataType;
  }
DBCOLUMNBINDING;

typedef struct tagDBBINDPARAMS
  {
  ULONG cbMaxLen;
  DWORD dwBinding;
  DWORD dwDataType;
  ULONG cbVarDataLen;
  DWORD dwInfo;
  void *pData;
  }
DBBINDPARAMS;

#define CID_NUMBER_INVALID            -1
#define CID_NUMBER_AUTOINCREMENT       0
#define CID_NUMBER_BASECOLUMNNAME      1
#define CID_NUMBER_BASENAME            2
#define CID_NUMBER_BINARYCOMPARABLE    3
#define CID_NUMBER_BINDTYPE            4
#define CID_NUMBER_CASESENSITIVE       5
#define CID_NUMBER_COLLATINGORDER      6
#define CID_NUMBER_COLUMNID            7
#define CID_NUMBER_CURSORCOLUMN        8
#define CID_NUMBER_DATACOLUMN          9
#define CID_NUMBER_DEFAULTVALUE        10
#define CID_NUMBER_ENTRYIDMAXLENGTH    11
#define CID_NUMBER_FIXED               12
#define CID_NUMBER_HASDEFAULT          13
#define CID_NUMBER_MAXLENGTH           14
#define CID_NUMBER_MULTIVALUED         15
#define CID_NUMBER_NAME                16
#define CID_NUMBER_NULLABLE            17
#define CID_NUMBER_PHYSICALSORT        18
#define CID_NUMBER_NUMBER              19
#define CID_NUMBER_ROWENTRYID          20
#define CID_NUMBER_SCALE               21
#define CID_NUMBER_SEARCHABLE          22
#define CID_NUMBER_TYPE                23
#define CID_NUMBER_UNIQUE              24
#define CID_NUMBER_UPDATABLE           25
#define CID_NUMBER_VERSION             26
#define CID_NUMBER_STATUS              27

/* c and C++ have different meanings for const.
 */
#ifdef __cplusplus
#define EXTERNAL_DEFN    extern const
#else
#define EXTERNAL_DEFN    const
#endif /* __cplusplus */



/* "DB" replaced by "OCDB" to avoid conflict with <oledb.h> */
#define OCDBCIDGUID {0xfe284700L,0xd188,0x11cd,{0xad,0x48, 0x0,0xaa, 0x0,0x3c,0x9c,0xb6}}
#ifdef DBINITCONSTANTS

EXTERNAL_DEFN DBCOLUMNID NEAR COLUMNID_INVALID         = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, -1};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_AUTOINCREMENT     = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 0};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BASECOLUMNNAME    = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 1};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BASENAME          = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 2};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BINARYCOMPARABLE  = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 3};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BINDTYPE          = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 4};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_CASESENSITIVE     = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 5};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_COLLATINGORDER    = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 6};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_COLUMNID          = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 7};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_CURSORCOLUMN      = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 8};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_DATACOLUMN        = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 9};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_DEFAULTVALUE      = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 10};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_ENTRYIDMAXLENGTH  = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 11};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_FIXED             = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 12};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_HASDEFAULT        = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 13};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_MAXLENGTH         = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 14};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_MULTIVALUED       = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 15};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_NAME              = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 16};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_NULLABLE          = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 17};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_PHYSICALSORT      = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 18};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_NUMBER            = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 19};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_ROWENTRYID        = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 20};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_SCALE             = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 21};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_SEARCHABLE        = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 22};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_TYPE              = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 23};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_UNIQUE            = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 24};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_UPDATABLE         = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 25};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_VERSION           = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 26};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_STATUS            = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 27};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_COMPUTED          = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 28};
#else
extern const DBCOLUMNID NEAR COLUMNID_INVALID;
extern const DBCOLUMNID NEAR COLUMN_AUTOINCREMENT;
extern const DBCOLUMNID NEAR COLUMN_BASECOLUMNNAME;
extern const DBCOLUMNID NEAR COLUMN_BASENAME;
extern const DBCOLUMNID NEAR COLUMN_BINARYCOMPARABLE;
extern const DBCOLUMNID NEAR COLUMN_BINDTYPE;
extern const DBCOLUMNID NEAR COLUMN_CASESENSITIVE;
extern const DBCOLUMNID NEAR COLUMN_COLLATINGORDER;
extern const DBCOLUMNID NEAR COLUMN_COLUMNID;
extern const DBCOLUMNID NEAR COLUMN_CURSORCOLUMN;
extern const DBCOLUMNID NEAR COLUMN_DATACOLUMN;
extern const DBCOLUMNID NEAR COLUMN_DEFAULTVALUE;
extern const DBCOLUMNID NEAR COLUMN_ENTRYIDMAXLENGTH;
extern const DBCOLUMNID NEAR COLUMN_FIXED;
extern const DBCOLUMNID NEAR COLUMN_HASDEFAULT;
extern const DBCOLUMNID NEAR COLUMN_MAXLENGTH;
extern const DBCOLUMNID NEAR COLUMN_MULTIVALUED;
extern const DBCOLUMNID NEAR COLUMN_NAME;
extern const DBCOLUMNID NEAR COLUMN_NULLABLE;
extern const DBCOLUMNID NEAR COLUMN_PHYSICALSORT;
extern const DBCOLUMNID NEAR COLUMN_NUMBER;
extern const DBCOLUMNID NEAR COLUMN_ROWENTRYID;
extern const DBCOLUMNID NEAR COLUMN_SCALE;
extern const DBCOLUMNID NEAR COLUMN_SEARCHABLE;
extern const DBCOLUMNID NEAR COLUMN_TYPE;
extern const DBCOLUMNID NEAR COLUMN_UNIQUE;
extern const DBCOLUMNID NEAR COLUMN_UPDATABLE;
extern const DBCOLUMNID NEAR COLUMN_VERSION;
extern const DBCOLUMNID NEAR COLUMN_STATUS;
extern const DBCOLUMNID NEAR COLUMN_COMPUTED;
#endif

#define BMK_NUMBER_BMKTEMPORARY    0
#define BMK_NUMBER_BMKTEMPORARYREL 1
#define BMK_NUMBER_BMKCURSOR       2
#define BMK_NUMBER_BMKCURSORREL    3
#define BMK_NUMBER_BMKSESSION      4
#define BMK_NUMBER_BMKSESSIONREL   5
#define BMK_NUMBER_BMKPERSIST      6
#define BMK_NUMBER_BMKPERSISTREL   7


#define DBBMKGUID {0xf6304bb0L,0xd188,0x11cd,{0xad,0x48, 0x0,0xaa, 0x0,0x3c,0x9c,0xb6}}
#ifdef DBINITCONSTANTS
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKTEMPORARY      = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 0};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKTEMPORARYREL   = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 1};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKCURSOR         = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 2};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKCURSORREL      = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 3};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKSESSION        = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 4};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKSESSIONREL     = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 5};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKPERSIST        = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 6};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKPERSISTREL     = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 7};
#else
extern const DBCOLUMNID NEAR COLUMN_BMKINVALID;
extern const DBCOLUMNID NEAR COLUMN_BMKTEMPORARY;
extern const DBCOLUMNID NEAR COLUMN_BMKTEMPORARYREL;
extern const DBCOLUMNID NEAR COLUMN_BMKCURSOR;
extern const DBCOLUMNID NEAR COLUMN_BMKCURSORREL;
extern const DBCOLUMNID NEAR COLUMN_BMKSESSION;
extern const DBCOLUMNID NEAR COLUMN_BMKSESSIONREL;
extern const DBCOLUMNID NEAR COLUMN_BMKPERSIST;
extern const DBCOLUMNID NEAR COLUMN_BMKPERSISTREL;
#endif

/* "DB" replaced by "OCDB" to avoid conflict with <oledb.h> */
#define DB_BMK_SIZE        sizeof(BYTE)
#ifdef DBINITCONSTANTS
EXTERNAL_DEFN BYTE NEAR OCDBBMK_INVALID   = 0x0;
EXTERNAL_DEFN BYTE NEAR OCDBBMK_CURRENT   = 0x1;
EXTERNAL_DEFN BYTE NEAR OCDBBMK_BEGINNING = 0x2;
EXTERNAL_DEFN BYTE NEAR OCDBBMK_END       = 0x3;
#else
extern const BYTE NEAR OCDBBMK_INVALID;
extern const BYTE NEAR OCDBBMK_CURRENT;
extern const BYTE NEAR OCDBBMK_BEGINNING;
extern const BYTE NEAR OCDBBMK_END;
#endif

typedef enum tagDBCOLUMNBINDOPTS
  {
	DBCOLUMNBINDOPTS_REPLACE = 0,
	DBCOLUMNBINDOPTS_ADD = 1
  }
DBCOLUMNBINDOPTS;

typedef enum tagDBUPDATELOCK
  {
	DBUPDATELOCK_PESSIMISTIC = 0,
	DBUPDATELOCK_OPTIMISTIC = 1
  }
DBUPDATELOCK;

typedef enum tagDBCOLUMNDATA
  {
	DBCOLUMNDATA_UNCHANGED = 0,
	DBCOLUMNDATA_CHANGED = 1,
        DBCOLUMNDATA_UNKNOWN = 2
  }
DBCOLUMNDATA;

typedef enum tagDBROWACTION
  {
	DBROWACTION_IGNORE = 0,
	DBROWACTION_UPDATE = 1,
	DBROWACTION_DELETE = 2,
	DBROWACTION_ADD = 3,
	DBROWACTION_LOCK = 4,
	DBROWACTION_UNLOCK = 5
  }
DBROWACTION;

typedef enum tagDBUPDATEABLE
  {
	DBUPDATEABLE_UPDATEABLE = 0,
	DBUPDATEABLE_NOTUPDATEABLE = 1,
	DBUPDATEABLE_UNKNOWN = 2
  }
DBUPDATEABLE;

typedef struct tagOCDBROWSTATUS
  {
  HRESULT hrStatus;
  BLOB Bookmark;
  }
OCDBROWSTATUS;

typedef enum tagDBEVENTWHATS
  {
	DBEVENT_CURRENT_ROW_CHANGED = 1,
	DBEVENT_CURRENT_ROW_DATA_CHANGED = 2,
	DBEVENT_NONCURRENT_ROW_DATA_CHANGED = 4,
	DBEVENT_SET_OF_COLUMNS_CHANGED = 8,
	DBEVENT_ORDER_OF_COLUMNS_CHANGED = 16,
	DBEVENT_SET_OF_ROWS_CHANGED = 32,
	DBEVENT_ORDER_OF_ROWS_CHANGED = 64,
	DBEVENT_METADATA_CHANGED = 128,
	DBEVENT_ASYNCH_OP_FINISHED = 256,
	DBEVENT_FIND_CRITERIA_CHANGED = 512
  }
DBEVENTWHATS;

/* "DB" replaced by "OCDB" to avoid conflict with <oledb.h> */
typedef enum tagOCDBREASON
  {
	OCDBREASON_DELETED = 1,
	OCDBREASON_INSERTED = 2,
	OCDBREASON_MODIFIED = 3,
	OCDBREASON_REMOVEDFROMCURSOR = 4,
	OCDBREASON_MOVEDINCURSOR = 5,
	OCDBREASON_MOVE = 6,
	OCDBREASON_FIND = 7,
	OCDBREASON_NEWINDEX = 8,
	OCDBREASON_ROWFIXUP = 9,
	OCDBREASON_RECALC = 10,
	OCDBREASON_REFRESH = 11,
	OCDBREASON_NEWPARAMETERS = 12,
	OCDBREASON_SORTCHANGED = 13,
	OCDBREASON_FILTERCHANGED = 14,
	OCDBREASON_QUERYSPECCHANGED = 15,
	OCDBREASON_SEEK = 16,
	OCDBREASON_PERCENT = 17,
	OCDBREASON_FINDCRITERIACHANGED = 18,
	OCDBREASON_SETRANGECHANGED = 19,
	OCDBREASON_ADDNEW = 20,
	OCDBREASON_MOVEPERCENT = 21,
	OCDBREASON_BEGINTRANSACT = 22,
	OCDBREASON_ROLLBACK = 23,
	OCDBREASON_COMMIT = 24,
	OCDBREASON_CLOSE = 25,
	OCDBREASON_BULK_ERROR = 26,
	OCDBREASON_BULK_NOTTRANSACTABLE = 27,
	OCDBREASON_BULK_ABOUTTOEXECUTE = 28,
        OCDBREASON_CANCELUPDATE = 29,
        OCDBREASON_SETCOLUMN = 30,
        OCDBREASON_EDIT = 31,
        OCDBREASON_UNLOAD = 32
  }
OCDBREASON;

// Arg1 values for DBREASON_FIND
typedef enum tagDBFINDTYPES
  {
  DB_FINDFIRST = 1,
  DB_FINDLAST = 2,
  DB_FINDNEXT = 3,
  DB_FINDPRIOR = 4,
  DB_FIND = 5
  }
DBFINDTYPES;

typedef struct tagDBNOTIFYREASON
  {
  DWORD dwReason;
  DBVARIANT arg1;
  DBVARIANT arg2;
  }
DBNOTIFYREASON;

#define OCDB_E_BADBINDINFO           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e00)
#define OCDB_E_BADBOOKMARK           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e01)
#define OCDB_E_BADCOLUMNID           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e02)
#define OCDB_E_BADCRITERIA           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e03)
#define OCDB_E_BADENTRYID            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e04)
#define OCDB_E_BADFRACTION           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e05)
#define OCDB_E_BADINDEXID            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e06)
#define OCDB_E_BADQUERYSPEC          MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e07)
#define OCDB_E_BADSORTORDER          MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e08)
#define OCDB_E_BADVALUES             MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e09)
#define OCDB_E_CANTCOERCE            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0a)
#define OCDB_E_CANTLOCK              MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0b)
#define OCDB_E_COLUMNUNAVAILABLE     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0c)
#define OCDB_E_DATACHANGED           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0d)
#define OCDB_E_INVALIDCOLUMNORDINAL  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0e)
#define OCDB_E_INVALIDINTERFACE      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0f)
#define OCDB_E_LOCKFAILED            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e10)
#define OCDB_E_ROWDELETED            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e11)
#define OCDB_E_ROWTOOSHORT           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e12)
#define OCDB_E_SCHEMAVIOLATION       MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e13)
#define OCDB_E_SEEKKINDNOTSUPPORTED  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e14)
#define OCDB_E_UPDATEINPROGRESS      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e15)
#define OCDB_E_USEENTRYID            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e16)
#define OCDB_E_STATEERROR            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e17)
#define OCDB_E_BADFETCHINFO          MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e18)
#define OCDB_E_NOASYNC               MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e19)
#define OCDB_E_ENTRYIDOPEN           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e1a)
#define OCDB_E_BUFFERTOOSMALL        MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e1b)
#define OCDB_S_BUFFERTOOSMALL        MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec0)
#define OCDB_S_CANCEL                MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec1)
#define OCDB_S_DATACHANGED           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec2)
#define OCDB_S_ENDOFCURSOR           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec3)
#define OCDB_S_ENDOFRESULTSET        MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec4)
#define OCDB_S_OPERATIONCANCELLED    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec5)
#define OCDB_S_QUERYINTERFACE        MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec6)
#define OCDB_S_WORKINGASYNC          MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec7)

#define OCDB_S_MOVEDTOFIRST          MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec9)
#define OCDB_S_CURRENTROWUNCHANGED   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0eca)
#define OCDB_S_ROWADDED              MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ecb)
#define OCDB_S_ROWUPDATED            MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ecc)
#define OCDB_S_ROWDELETED            MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ecd)

/*----------------------------------------------------------------------------
 *
 *	ICursor
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface ICursor ICursor;

#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_ICursor;

interface ICursor : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE GetColumnsCursor
    (
	REFIID riid,
	IUnknown **ppvColumnsCursor,
	ULONG *pcRows
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetBindings
    (
	ULONG cCol,
	DBCOLUMNBINDING rgBoundColumns[],
	ULONG cbRowLength,
	DWORD dwFlags
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetBindings
    (
	ULONG *pcCol,
	DBCOLUMNBINDING *prgBoundColumns[],
	ULONG *pcbRowLength
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetNextRows
    (
	LARGE_INTEGER udlRowsToSkip,
	DBFETCHROWS *pFetchParams
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Requery
    (
        void
    ) = 0;

};

#else

/* C Language Binding */
//extern const IID IID_ICursor;

typedef struct ICursorVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        ICursor FAR *this,
	REFIID riid,
	void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        ICursor FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        ICursor FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetColumnsCursor)
    (
        ICursor FAR *this,
	REFIID riid,
	IUnknown **ppvColumnsCursor,
	ULONG *pcRows
    );

    HRESULT (STDMETHODCALLTYPE FAR *SetBindings)
    (
        ICursor FAR *this,
	ULONG cCol,
	DBCOLUMNBINDING rgBoundColumns[],
	ULONG cbRowLength,
	DWORD dwFlags
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetBindings)
    (
        ICursor FAR *this,
	ULONG *pcCol,
	DBCOLUMNBINDING *prgBoundColumns[],
	ULONG *pcbRowLength
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetNextRows)
    (
        ICursor FAR *this,
	LARGE_INTEGER udlRowsToSkip,
	DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *Requery)
    (
        ICursor FAR *this
    );

} ICursorVtbl;

interface ICursor
{
    ICursorVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define ICursor_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define ICursor_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define ICursor_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define ICursor_GetColumnsCursor(pI, riid, ppvColumnsCursor, pcRows) \
    (*(pI)->lpVtbl->GetColumnsCursor)((pI), riid, ppvColumnsCursor, pcRows)

#define ICursor_SetBindings(pI, cCol, rgBoundColumns, cbRowLength, dwFlags) \
    (*(pI)->lpVtbl->SetBindings)((pI), cCol, rgBoundColumns, cbRowLength, dwFlags)

#define ICursor_GetBindings(pI, pcCol, prgBoundColumns, pcbRowLength) \
    (*(pI)->lpVtbl->GetBindings)((pI), pcCol, prgBoundColumns, pcbRowLength)

#define ICursor_GetNextRows(pI, udlRowsToSkip, pFetchParams) \
    (*(pI)->lpVtbl->GetNextRows)((pI), udlRowsToSkip, pFetchParams)

#define ICursor_Requery(pI) \
    (*(pI)->lpVtbl->Requery)((pI))

#endif /* COBJMACROS */

#endif

/*----------------------------------------------------------------------------
 *
 *	ICursorMove
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface ICursorMove ICursorMove;

typedef enum tagDBCLONEOPTS
  {
	DBCLONEOPTS_DEFAULT = 0,
	DBCLONEOPTS_SAMEROW = 1
  }
DBCLONEOPTS;


#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_ICursorMove;

interface ICursorMove : public ICursor
{
public:
    virtual HRESULT STDMETHODCALLTYPE Move
    (
	ULONG cbBookmark,
	void *pBookmark,
	LARGE_INTEGER dlOffset,
	DBFETCHROWS *pFetchParams
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetBookmark
    (
	DBCOLUMNID *pBookmarkType,
	ULONG cbMaxSize,
	ULONG *pcbBookmark,
	void *pBookmark
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Clone
    (
	DWORD dwFlags,
	REFIID riid,
	IUnknown **ppvClonedCursor
    ) = 0;

};

#else

/* C Language Binding */
//extern const IID IID_ICursorMove;

typedef struct ICursorMoveVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        ICursorMove FAR *this,
	REFIID riid,
	void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        ICursorMove FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        ICursorMove FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetColumnsCursor)
    (
        ICursorMove FAR *this,
	REFIID riid,
	IUnknown **ppvColumnsCursor,
	ULONG *pcRows
    );

    HRESULT (STDMETHODCALLTYPE FAR *SetBindings)
    (
        ICursorMove FAR *this,
	ULONG cCol,
	DBCOLUMNBINDING rgBoundColumns[],
	ULONG cbRowLength,
	DWORD dwFlags
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetBindings)
    (
        ICursorMove FAR *this,
	ULONG *pcCol,
	DBCOLUMNBINDING *prgBoundColumns[],
	ULONG *pcbRowLength
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetNextRows)
    (
        ICursorMove FAR *this,
	LARGE_INTEGER udlRowsToSkip,
	DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *Requery)
    (
        ICursorMove FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *Move)
    (
        ICursorMove FAR *this,
	ULONG cbBookmark,
	void *pBookmark,
	LARGE_INTEGER dlOffset,
	DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetBookmark)
    (
        ICursorMove FAR *this,
	DBCOLUMNID *pBookmarkType,
	ULONG cbMaxSize,
	ULONG *pcbBookmark,
	void *pBookmark
    );

    HRESULT (STDMETHODCALLTYPE FAR *Clone)
    (
        ICursorMove FAR *this,
	DWORD dwFlags,
	REFIID riid,
	IUnknown **ppvClonedCursor
    );

} ICursorMoveVtbl;

interface ICursorMove
{
    ICursorMoveVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define ICursorMove_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define ICursorMove_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define ICursorMove_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define ICursorMove_GetColumnsCursor(pI, riid, ppvColumnsCursor, pcRows) \
    (*(pI)->lpVtbl->GetColumnsCursor)((pI), riid, ppvColumnsCursor, pcRows)

#define ICursorMove_SetBindings(pI, cCol, rgBoundColumns, cbRowLength, dwFlags) \
    (*(pI)->lpVtbl->SetBindings)((pI), cCol, rgBoundColumns, cbRowLength, dwFlags)

#define ICursorMove_GetBindings(pI, pcCol, prgBoundColumns, pcbRowLength) \
    (*(pI)->lpVtbl->GetBindings)((pI), pcCol, prgBoundColumns, pcbRowLength)

#define ICursorMove_GetNextRows(pI, udlRowsToSkip, pFetchParams) \
    (*(pI)->lpVtbl->GetNextRows)((pI), udlRowsToSkip, pFetchParams)

#define ICursorMove_Requery(pI) \
    (*(pI)->lpVtbl->Requery)((pI))

#define ICursorMove_Move(pI, cbBookmark, pBookmark, dlOffset, pFetchParams) \
    (*(pI)->lpVtbl->Move)((pI), cbBookmark, pBookmark, dlOffset, pFetchParams)

#define ICursorMove_GetBookmark(pI, pBookmarkType, cbMaxSize, pcbBookmark, pBookmark) \
    (*(pI)->lpVtbl->GetBookmark)((pI), pBookmarkType, cbMaxSize, pcbBookmark, pBookmark)

#define ICursorMove_Clone(pI, dwFlags, riid, ppvClonedCursor) \
    (*(pI)->lpVtbl->Clone)((pI), dwFlags, riid, ppvClonedCursor)
#endif /* COBJMACROS */

#endif

/*----------------------------------------------------------------------------
 *
 *	ICursorScroll
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface ICursorScroll ICursorScroll;

typedef enum tagDBCURSORPOPULATED
  {
	DBCURSORPOPULATED_FULLY = 0,
	DBCURSORPOPULATED_PARTIALLY = 1
  }
DBCURSORPOPULATED;


#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_ICursorScroll;

interface ICursorScroll : public ICursorMove
{
public:
    virtual HRESULT STDMETHODCALLTYPE Scroll
    (
	ULONG ulNumerator,
	ULONG ulDenominator,
	DBFETCHROWS *pFetchParams
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetApproximatePosition
    (
	ULONG cbBookmark,
	void *pBookmark,
	ULONG *pulNumerator,
	ULONG *pulDenominator
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetApproximateCount
    (
	LARGE_INTEGER *pudlApproxCount,
	DWORD *pdwFullyPopulated
    ) = 0;

};

#else

/* C Language Binding */
//extern const IID IID_ICursorScroll;

typedef struct ICursorScrollVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        ICursorScroll FAR *this,
	REFIID riid,
	void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        ICursorScroll FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        ICursorScroll FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetColumnsCursor)
    (
        ICursorScroll FAR *this,
	REFIID riid,
	IUnknown **ppvColumnsCursor,
	ULONG *pcRows
    );

    HRESULT (STDMETHODCALLTYPE FAR *SetBindings)
    (
        ICursorScroll FAR *this,
	ULONG cCol,
	DBCOLUMNBINDING rgBoundColumns[],
	ULONG cbRowLength,
	DWORD dwFlags
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetBindings)
    (
        ICursorScroll FAR *this,
	ULONG *pcCol,
	DBCOLUMNBINDING *prgBoundColumns[],
	ULONG *pcbRowLength
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetNextRows)
    (
        ICursorScroll FAR *this,
	LARGE_INTEGER udlRowsToSkip,
	DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *Requery)
    (
        ICursorScroll FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *Move)
    (
        ICursorScroll FAR *this,
	ULONG cbBookmark,
	void *pBookmark,
	LARGE_INTEGER dlOffset,
	DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetBookmark)
    (
        ICursorScroll FAR *this,
	DBCOLUMNID *pBookmarkType,
	ULONG cbMaxSize,
	ULONG *pcbBookmark,
	void *pBookmark
    );

    HRESULT (STDMETHODCALLTYPE FAR *Clone)
    (
        ICursorScroll FAR *this,
	DWORD dwFlags,
	REFIID riid,
	IUnknown **ppvClonedCursor
    );

    HRESULT (STDMETHODCALLTYPE FAR *Scroll)
    (
        ICursorScroll FAR *this,
	ULONG ulNumerator,
	ULONG ulDenominator,
	DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetApproximatePosition)
    (
        ICursorScroll FAR *this,
	ULONG cbBookmark,
	void *pBookmark,
	ULONG *pulNumerator,
	ULONG *pulDenominator
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetApproximateCount)
    (
        ICursorScroll FAR *this,
	LARGE_INTEGER *pudlApproxCount,
	DWORD *pdwFullyPopulated
    );

} ICursorScrollVtbl;

interface ICursorScroll
{
    ICursorScrollVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define ICursorScroll_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define ICursorScroll_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define ICursorScroll_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define ICursorScroll_GetColumnsCursor(pI, riid, ppvColumnsCursor, pcRows) \
    (*(pI)->lpVtbl->GetColumnsCursor)((pI), riid, ppvColumnsCursor, pcRows)

#define ICursorScroll_SetBindings(pI, cCol, rgBoundColumns, cbRowLength, dwFlags) \
    (*(pI)->lpVtbl->SetBindings)((pI), cCol, rgBoundColumns, cbRowLength, dwFlags)

#define ICursorScroll_GetBindings(pI, pcCol, prgBoundColumns, pcbRowLength) \
    (*(pI)->lpVtbl->GetBindings)((pI), pcCol, prgBoundColumns, pcbRowLength)

#define ICursorScroll_GetNextRows(pI, udlRowsToSkip, pFetchParams) \
    (*(pI)->lpVtbl->GetNextRows)((pI), udlRowsToSkip, pFetchParams)

#define ICursorScroll_Requery(pI) \
    (*(pI)->lpVtbl->Requery)((pI))

#define ICursorScroll_Move(pI, cbBookmark, pBookmark, dlOffset, pFetchParams) \
    (*(pI)->lpVtbl->Move)((pI), cbBookmark, pBookmark, dlOffset, pFetchParams)

#define ICursorScroll_GetBookmark(pI, pBookmarkType, cbMaxSize, pcbBookmark, pBookmark) \
    (*(pI)->lpVtbl->GetBookmark)((pI), pBookmarkType, cbMaxSize, pcbBookmark, pBookmark)

#define ICursorScroll_Clone(pI, dwFlags, riid, ppvClonedCursor) \
    (*(pI)->lpVtbl->Clone)((pI), dwFlags, riid, ppvClonedCursor)

#define ICursorScroll_Scroll(pI, ulNumerator, ulDenominator, pFetchParams) \
    (*(pI)->lpVtbl->Scroll)((pI), ulNumerator, ulDenominator, pFetchParams)

#define ICursorScroll_GetApproximatePosition(pI, cbBookmark, pBookmark, pulNumerator, pulDenominator) \
    (*(pI)->lpVtbl->GetApproximatePosition)((pI), cbBookmark, pBookmark, pulNumerator, pulDenominator)

#define ICursorScroll_GetApproximateCount(pI, pudlApproxCount, pdwFullyPopulated) \
    (*(pI)->lpVtbl->GetApproximateCount)((pI), pudlApproxCount, pdwFullyPopulated)
#endif /* COBJMACROS */

#endif

/*----------------------------------------------------------------------------
 *
 *	ICursorUpdateARow
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface ICursorUpdateARow ICursorUpdateARow;

typedef enum tagDBEDITMODE
  {
	DBEDITMODE_NONE = 1,
	DBEDITMODE_UPDATE = 2,
	DBEDITMODE_ADD = 3
  }
DBEDITMODE;


#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_ICursorUpdateARow;

interface ICursorUpdateARow : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE BeginUpdate
    (
	DWORD dwFlags
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetColumn
    (
	DBCOLUMNID *pcid,
	DBBINDPARAMS *pBindParams
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetColumn
    (
	DBCOLUMNID *pcid,
	DBBINDPARAMS *pBindParams,
	DWORD *pdwFlags
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetEditMode
    (
	DWORD *pdwState
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Update
    (
	DBCOLUMNID *pBookmarkType,
	ULONG *pcbBookmark,
	void **ppBookmark
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Cancel
    (
        void
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Delete
    (
	void
    ) = 0;

};

#else

/* C Language Binding */
//extern const IID IID_ICursorUpdateARow;

typedef struct ICursorUpdateARowVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        ICursorUpdateARow FAR *this,
	REFIID riid,
	void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        ICursorUpdateARow FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        ICursorUpdateARow FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *BeginUpdate)
    (
        ICursorUpdateARow FAR *this,
	DWORD dwFlags
    );

    HRESULT (STDMETHODCALLTYPE FAR *SetColumn)
    (
        ICursorUpdateARow FAR *this,
	DBCOLUMNID *pcid,
	DBBINDPARAMS *pBindParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetColumn)
    (
        ICursorUpdateARow FAR *this,
	DBCOLUMNID *pcid,
	DBBINDPARAMS *pBindParams,
	DWORD *pdwFlags
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetEditMode)
    (
        ICursorUpdateARow FAR *this,
	DWORD *pdwState
    );

    HRESULT (STDMETHODCALLTYPE FAR *Update)
    (
        ICursorUpdateARow FAR *this,
	DBCOLUMNID *pBookmarkType,
	ULONG *pcbBookmark,
	void **ppBookmark
    );

    HRESULT (STDMETHODCALLTYPE FAR *Cancel)
    (
        ICursorUpdateARow FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *Delete)
    (
        ICursorUpdateARow FAR *this
    );

} ICursorUpdateARowVtbl;

interface ICursorUpdateARow
{
    ICursorUpdateARowVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define ICursorUpdateARow_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define ICursorUpdateARow_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define ICursorUpdateARow_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define ICursorUpdateARow_BeginUpdate(pI, dwFlags) \
    (*(pI)->lpVtbl->BeginUpdate)((pI), dwFlags)

#define ICursorUpdateARow_SetColumn(pI, pcid, pBindParams) \
    (*(pI)->lpVtbl->SetColumn)((pI), pcid, pBindParams)

#define ICursorUpdateARow_GetColumn(pI, pcid, pBindParams, pdwFlags) \
    (*(pI)->lpVtbl->GetColumn)((pI), pcid, pBindParams, pdwFlags)

#define ICursorUpdateARow_GetEditMode(pI, pdwState) \
    (*(pI)->lpVtbl->GetEditMode)((pI), pdwState)

#define ICursorUpdateARow_Update(pI, pBookmarkType, pcbBookmark, ppBookmark) \
    (*(pI)->lpVtbl->Update)((pI), pBookmarkType, pcbBookmark, ppBookmark)

#define ICursorUpdateARow_Cancel(pI) \
    (*(pI)->lpVtbl->Cancel)((pI))

#define ICursorUpdateARow_Delete(pI) \
    (*(pI)->lpVtbl->Delete)((pI))


#endif /* COBJMACROS */

#endif

/*----------------------------------------------------------------------------
 *
 *	ICursorFind
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface ICursorFind ICursorFind;

typedef enum tagDBFINDFLAGS
  {
	DBFINDFLAGS_FINDNEXT = 1,
	DBFINDFLAGS_FINDPRIOR = 2,
	DBFINDFLAGS_INCLUDECURRENT = 4
  }
DBFINDFLAGS;


/* "DB" replaced by "OCDB" to avoid conflict with <oledb.h> */
typedef enum tagOCDBSEEKFLAGS
  {
	OCDBSEEK_LT	 = 1,
	OCDBSEEK_LE	 = 2,
	OCDBSEEK_EQ	 = 3,		// EXACT EQUALITY
	OCDBSEEK_GT	 = 4,
	OCDBSEEK_GE	 = 5,
	OCDBSEEK_PARTIALEQ = 6             // only for strings
  }
OCDBSEEKFLAGS;

#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_ICursorFind;

interface ICursorFind : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE FindByValues
    (
	ULONG            cbBookmark,
	LPVOID           pBookmark,
	DWORD            dwFindFlags,
	ULONG            cValues,
        DBCOLUMNID       rgColumns[],
	DBVARIANT        rgValues[],
	DWORD            rgdwSeekFlags[],
        DBFETCHROWS FAR *pFetchParams
    ) = 0;
};

#else

/* C Language Binding */
//extern const IID IID_ICursorFind;

typedef struct ICursorFindVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        ICursorFind FAR *this,
	REFIID riid,
	void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        ICursorFind FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        ICursorFind FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *FindByValues)
    (
        ICursorFind FAR *this,
	ULONG            cbBookmark,
	LPVOID           pBookmark,
	DWORD            dwFindFlags,
	ULONG            cValues,
        DBCOLUMNID       rgColumns[],
	DBVARIANT        rgValues[],
	DWORD            rgdwSeekFlags[],
        DBFETCHROWS      pFetchParams
    );


} ICursorFindVtbl;

interface ICursorFind
{
    ICursorFindVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define ICursorFind_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define ICursorFind_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define ICursorFind_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define ICursorFind_FindByValues(pI, cbB, pB, dwFF, cV, rgC, rgV, rgSF, pF) \
    (*(pI)->lpVtbl->FindByValues)((pI), cbB, pB, dwFF, cB, rgC, rgV, rgSF, pF)

#endif /* COBJMACROS */

#endif


/*----------------------------------------------------------------------------
 *
 *	IEntryID
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface IEntryID IEntryID;

#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_IEntryID;

interface IEntryID : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE GetInterface
    (
	ULONG cbEntryID,
	void *pEntryID,
        DWORD dwFlags,
        REFIID riid,
	IUnknown **ppvObj
    ) = 0;

};

#else

/* C Language Binding */
//extern const IID IID_IEntryID;

typedef struct IEntryIDVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        IEntryID FAR *this,
	REFIID riid,
	void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        IEntryID FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        IEntryID FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetInterface)
    (
        IEntryID FAR *this,
	ULONG cbEntryID,
	void *pEntryID,
        REFIID riid,
	IUnknown **ppvObj
    );

} IEntryIDVtbl;

interface IEntryID
{
    IEntryIDVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define IEntryID_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define IEntryID_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define IEntryID_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define IEntryID_GetInterface(pI, cbEntryID, pEntryID, riid, ppvObj) \
    (*(pI)->lpVtbl->GetInterface)((pI), cbEntryID, pEntryID, riid, ppvObj)
#endif /* COBJMACROS */

#endif


/*----------------------------------------------------------------------------
 *
 *	INotifyDBEvents
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface INotifyDBEvents INotifyDBEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_INotifyDBEvents;

interface INotifyDBEvents : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE OKToDo
    (
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Cancelled
    (
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE SyncBefore
    (
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE AboutToDo
    (
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE FailedToDo
    (
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE SyncAfter
    (
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE DidEvent
    (
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
    ) = 0;

};

#else

/* C Language Binding */
extern const IID IID_INotifyDBEvents;

typedef struct INotifyDBEventsVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        INotifyDBEvents FAR *this,
	REFIID riid,
	void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        INotifyDBEvents FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        INotifyDBEvents FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *OKToDo)
    (
        INotifyDBEvents FAR *this,
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *Cancelled)
    (
        INotifyDBEvents FAR *this,
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *SyncBefore)
    (
        INotifyDBEvents FAR *this,
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *AboutToDo)
    (
        INotifyDBEvents FAR *this,
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *FailedToDo)
    (
        INotifyDBEvents FAR *this,
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *SyncAfter)
    (
        INotifyDBEvents FAR *this,
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *DidEvent)
    (
        INotifyDBEvents FAR *this,
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
    );

} INotifyDBEventsVtbl;

interface INotifyDBEvents
{
    INotifyDBEventsVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define INotifyDBEvents_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define INotifyDBEvents_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define INotifyDBEvents_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define INotifyDBEvents_OKToDo(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->OKToDo)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_Cancelled(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->Cancelled)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_SyncBefore(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->SyncBefore)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_AboutToDo(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->AboutToDo)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_FailedToDo(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->FailedToDo)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_SyncAfter(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->SyncAfter)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_DidEvent(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->DidEvent)((pI), dwEventWhat, cReasons, rgReasons)
#endif /* COBJMACROS */

#endif


#ifdef __cplusplus
}
#endif

#define __OCDB_H_
#endif // __OCDB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\ccaps.cxx ===
// ClientCaps.cpp : Implementation of CClientCaps
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "iextag.h"
#include "ccaps.h"

typedef HRESULT STDAPICALLTYPE SHOWHTMLDIALOGFN (HWND hwndParent, IMoniker *pmk, 
                                                 VARIANT *pvarArgIn, WCHAR* pchOptions, 
                                                 VARIANT *pvArgOut);
#define REGKEY_ACTIVESETUP   "Software\\Microsoft\\Active Setup"

/////////////////////////////////////////////////////////////////////////////
// CClientCaps


STDMETHODIMP CClientCaps::get_javaEnabled(VARIANT_BOOL * pVal)
{
    IOmNavigator *pClientInformation;
    HRESULT hr = GetClientInformation(&pClientInformation);

    if (SUCCEEDED(hr))
    {
        hr = pClientInformation->javaEnabled(pVal);
        pClientInformation->Release();
    }
        return hr;
}

STDMETHODIMP CClientCaps::get_cookieEnabled(VARIANT_BOOL * pVal)
{
    IOmNavigator *pClientInformation;
    HRESULT hr = GetClientInformation(&pClientInformation);

    if (SUCCEEDED(hr))
    {
        hr = pClientInformation->get_cookieEnabled(pVal);
        pClientInformation->Release();
    }
        return hr;

}

STDMETHODIMP CClientCaps::get_cpuClass(BSTR * p)
{
    IOmNavigator *pClientInformation;
    HRESULT hr = GetClientInformation(&pClientInformation);

    if (SUCCEEDED(hr))
    {
        hr = pClientInformation->get_cpuClass(p);
        pClientInformation->Release();
    }
        return hr;

}

STDMETHODIMP CClientCaps::get_systemLanguage(BSTR * p)
{
    IOmNavigator *pClientInformation;
    HRESULT hr = GetClientInformation(&pClientInformation);

    if (SUCCEEDED(hr))
    {
        hr = pClientInformation->get_systemLanguage(p);
        pClientInformation->Release();
    }
        return hr;

}

STDMETHODIMP CClientCaps::get_userLanguage(BSTR * p)
{
    IOmNavigator *pClientInformation;
    HRESULT hr = GetClientInformation(&pClientInformation);

    if (SUCCEEDED(hr))
    {
        hr = pClientInformation->get_userLanguage(p);
        pClientInformation->Release();
    }
        return hr;

}

STDMETHODIMP CClientCaps::get_platform(BSTR * p)
{
    IOmNavigator *pClientInformation;
    HRESULT hr = GetClientInformation(&pClientInformation);

    if (SUCCEEDED(hr))
    {
        hr = pClientInformation->get_platform(p);
        pClientInformation->Release();
    }
        return hr;

}

STDMETHODIMP CClientCaps::get_connectionSpeed(long * p)
{
    IOmNavigator *pClientInformation;
    HRESULT hr = GetClientInformation(&pClientInformation);

    if (SUCCEEDED(hr))
    {
        hr = pClientInformation->get_connectionSpeed(p);
        pClientInformation->Release();
    }
        return hr;

}

STDMETHODIMP CClientCaps::get_onLine(VARIANT_BOOL *p)
{
    IOmNavigator *pClientInformation;
    HRESULT hr = GetClientInformation(&pClientInformation);

    if (SUCCEEDED(hr))
    {
        hr = pClientInformation->get_onLine(p);
        pClientInformation->Release();
    }
        return hr;

}

STDMETHODIMP CClientCaps::get_colorDepth(long * p)
{
    IHTMLScreen *pScreen;
    HRESULT hr = GetScreen(&pScreen);

    if (SUCCEEDED(hr))
    {
        hr = pScreen->get_colorDepth(p);
        pScreen->Release();
    }
        return hr;

}

STDMETHODIMP CClientCaps::get_bufferDepth(long * p)
{
    IHTMLScreen *pScreen;
    HRESULT hr = GetScreen(&pScreen);

    if (SUCCEEDED(hr))
    {
        hr = pScreen->get_bufferDepth(p);
        pScreen->Release();
    }
        return hr;

}

STDMETHODIMP CClientCaps::get_width(long * p)
{
    IHTMLScreen *pScreen;
    HRESULT hr = GetScreen(&pScreen);

    if (SUCCEEDED(hr))
    {
        hr = pScreen->get_width(p);
        pScreen->Release();
    }
        return hr;

}

STDMETHODIMP CClientCaps::get_height(long * p)
{
    IHTMLScreen *pScreen;
    HRESULT hr = GetScreen(&pScreen);

    if (SUCCEEDED(hr))
    {
        hr = pScreen->get_height(p);
        pScreen->Release();
    }
        return hr;

}

STDMETHODIMP CClientCaps::get_availHeight(long * p)
{
    IHTMLScreen *pScreen;
    HRESULT hr = GetScreen(&pScreen);

    if (SUCCEEDED(hr))
    {
        hr = pScreen->get_availHeight(p);
        pScreen->Release();
    }
        return hr;

}

STDMETHODIMP CClientCaps::get_availWidth(long * p)
{
    IHTMLScreen *pScreen;
    HRESULT hr = GetScreen(&pScreen);

    if (SUCCEEDED(hr))
    {
        hr = pScreen->get_availWidth(p);
        pScreen->Release();
    }
        return hr;

}

STDMETHODIMP CClientCaps::get_connectionType(BSTR *pbstr)
{
    DWORD dwFlags = 0;
    BOOL bConnected;
    HRESULT hr = S_OK;
    DWORD dwState = 0;
    DWORD dwSize = sizeof(dwState);
    BOOL bGlobalOffline = FALSE ;  // Has the user gone into offline mode, inspite of having a connection.       

    if (InternetQueryOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState, &dwSize))
    {
        if (dwState &  INTERNET_STATE_DISCONNECTED_BY_USER)
            bGlobalOffline = TRUE;
    }

    bConnected = InternetGetConnectedStateEx(&dwFlags, NULL, 0, 0);


    // NOTE: We use literal strings in code and resources so these don't get localized.
    if (bConnected && !bGlobalOffline)
    {
        // If we are connected figure out how.
        if (dwFlags &  INTERNET_CONNECTION_MODEM )
        {
            *pbstr = SysAllocString(L"modem"); 
        }
        else if (dwFlags & INTERNET_CONNECTION_LAN )
        {
            *pbstr = SysAllocString(L"lan");
        }
        else 
        {
            // Don't know what to do here. 
            *pbstr = SysAllocString(L"");
            hr = S_FALSE;
        }
    }
    else 
    {
        *pbstr = SysAllocString(L"offline");
    }                    

    if (!*pbstr)
        hr = E_OUTOFMEMORY;
        
    return hr;
}
        
STDMETHODIMP CClientCaps::isComponentInstalled(BSTR bstrName, BSTR bstrType, BSTR bstrVersion, VARIANT_BOOL *pVal)
{

    if (pVal == NULL)
    {
        return E_POINTER;
    }

    DWORD dwVersionMS;
    DWORD dwVersionLS;
    HRESULT hr = GetVersion(bstrName, bstrType, &dwVersionMS, &dwVersionLS);
    HRESULT hrRet;

    if (hr == S_OK)
    {
        if (bstrVersion && bstrVersion[0] != L'\0')
        {
            // User wants us to check for minimum version number.
            DWORD dwVersionReqdMS;
            DWORD dwVersionReqdLS;
            hr = GetVersionFromString(bstrVersion, &dwVersionReqdMS, &dwVersionReqdLS);
            if (SUCCEEDED(hr))
            {
                if ( (dwVersionMS > dwVersionReqdMS) || 
                     (dwVersionMS == dwVersionReqdMS && dwVersionLS >= dwVersionReqdLS)
                   )
                {
                    *pVal = TRUE;
                }
                else 
                {
                    *pVal = FALSE;
                }
                hrRet = S_OK;
            }
            else
            {
                *pVal = FALSE;
                hrRet = S_FALSE; 
            }
        }
        else 
        {                      
            *pVal = TRUE;
            hrRet = S_OK;
        }
    }
    else if (hr == S_FALSE)
    {
        *pVal = FALSE;
        hrRet = S_OK;
    }
    else
    {
        // This is really an error, but to avoid script error dialogs we still return a success
        // code, but indicate that the component is not installed.
        *pVal = FALSE;
        hrRet = S_FALSE;
    }
                         
        return hrRet;
}

STDMETHODIMP CClientCaps::getComponentVersion(BSTR bstrName, BSTR bstrType, BSTR* pbstrVersion)
{
    if (pbstrVersion == NULL)
        return E_POINTER;

    DWORD dwVersionMS;
    DWORD dwVersionLS;
    HRESULT hr = GetVersion(bstrName, bstrType, &dwVersionMS, &dwVersionLS);

    if (hr == S_OK)
    {
        hr = GetStringFromVersion(dwVersionMS, dwVersionLS, pbstrVersion); 
    }
    else 
    {
        *pbstrVersion = SysAllocString(L"");
        hr = S_OK;
    }                      
         
        return hr;
}

STDMETHODIMP CClientCaps::compareVersions(BSTR bstrVer1, BSTR bstrVer2, long *p)
{
    if ( p == NULL)
        return E_POINTER;

    HRESULT hr = S_OK;
    if (bstrVer1 == NULL || bstrVer2 == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        DWORD dwMS1 = 0 , dwLS1 = 0, dwMS2 = 0, dwLS2 = 0;

        HRESULT hr1 = GetVersionFromString(bstrVer1, &dwMS1, &dwLS1);
        HRESULT hr2 = GetVersionFromString(bstrVer2, &dwMS2, &dwLS2);

        if (SUCCEEDED(hr1) && SUCCEEDED(hr2))
        {
            if (dwMS1 > dwMS2)
                *p = 1;
            else if (dwMS1 < dwMS2)
                *p = -1;
            else  /* dwMS1 == dwMS2 */
            {
                if (dwLS1 > dwLS2)
                    *p = 1;
                else if (dwLS1 < dwLS2)
                    *p = -1;
                else
                    *p = 0;
            }
            hr = S_OK;
        }
        else
        {
            *p = 1;         // ISSUE: what is the right thing to do here.
            hr = S_FALSE;
        }
    }
    return hr;
}


STDMETHODIMP CClientCaps::addComponentRequest(BSTR bstrName, BSTR bstrType, BSTR bstrVer)
// Checks if the passed component is installed (optionally at or above the passed version)
// and if not, adds it to a list of components to be added at a call to DoComponentRequest
{
    HRESULT hr = 0;
    VARIANT_BOOL bInstalled;
    uCLSSPEC classspec;
    int iLength;
    int iRes;
    LPWSTR pwszComponentID = NULL;

    LPSTR pszComponentID = NULL;



    hr = isComponentInstalled(bstrName, bstrType, bstrVer, &bInstalled);

    // Unknown Error
    if(! SUCCEEDED(hr))
    {
        goto Exit;
    }
    // Component is already installed
    if(bInstalled)
    {
        hr = S_OK;
        goto Exit;
    }
    // otherwise, add the comnponent to the list of components to be installed


    // First figure out the type of the component and populate the CLSSPEC appropriately.
    if (0 == StrCmpICW(bstrType, L"mimetype"))
    {
        classspec.tyspec =  TYSPEC_MIMETYPE;
        classspec.tagged_union.pMimeType = bstrName;
    }
    else if (0 == StrCmpICW(bstrType, L"progid"))
    {
        classspec.tyspec = TYSPEC_PROGID;
        classspec.tagged_union.pProgId = bstrName;
    }
    else if (0 == StrCmpICW(bstrType, L"clsid"))
    {
        classspec.tyspec = TYSPEC_CLSID;
        // Convert class-id string to GUID.
        hr = CLSIDFromString(bstrName, &classspec.tagged_union.clsid);
        if (FAILED(hr))
            goto Exit;
    }
    else if (0 == StrCmpICW(bstrType, L"componentid")) //internally called a FeatureID
    {
        classspec.tyspec = TYSPEC_FILENAME;
        classspec.tagged_union.pFileName = bstrName;
    }
    else
    {
        hr = E_INVALIDARG;
        goto Exit;
    }
    
    // Get a ComponentID from the uCLSSPEC
    hr = GetComponentIDFromCLSSPEC(&classspec, &pszComponentID);
    if(FAILED(hr))
    {
        goto Exit;
    }


    // Convert the ComponentID to a wide character string (wide expected by ShowHTMLDialog)
    iLength = lstrlenA(pszComponentID) + 1;
    pwszComponentID = new WCHAR[iLength];
    if(pwszComponentID == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    iRes = MultiByteToWideChar(CP_ACP,0,pszComponentID, iLength,
                             pwszComponentID, iLength);
    if(iRes == 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        if(pwszComponentID)
        {
            delete [] pwszComponentID;
            pwszComponentID = NULL;
        }
        goto Exit;
    }


    // initialize array for first time
    if(ppwszComponents == NULL)
    {
        // Hard coded initial size of 10; It's in the right order of magnitude
        // Maybe this should be in a constant, but that seems a lot of overhead
        // for such a small feature
        ppwszComponents = new LPWSTR[10];
        iComponentNum = 0;
        iComponentCap = 10;
    }

    // Resizing the array of Components
    if(iComponentNum >= iComponentCap)
    {
        iComponentCap *= 2;
        LPWSTR * ppwszOldComponents = ppwszComponents;
        ppwszComponents = NULL;
        ppwszComponents = new LPWSTR[iComponentCap];
        if(ppwszComponents == NULL)
        {
            hr = E_OUTOFMEMORY;
            ppwszComponents = ppwszOldComponents;
            if(pwszComponentID)
            {
                delete [] pwszComponentID;
                pwszComponentID = NULL;
            }
            goto Exit;
        }
        for(int i = 0; i < iComponentNum; i++)
        {
            ppwszComponents[i] = ppwszOldComponents[i];
        }
        delete [] ppwszOldComponents;
    }

    ppwszComponents[iComponentNum++] =  pwszComponentID;
    hr = S_OK;    

Exit:

    if(pszComponentID)
    {
        CoTaskMemFree(pszComponentID);
    }
    return hr;
}

STDMETHODIMP CClientCaps::doComponentRequest(VARIANT_BOOL * pVal)
// Uses the url in HKLM\Software\Microsoft\Active Setup\JITSetupPage 
// to add the list of components logged using AddComponentRequest
{
    SHOWHTMLDIALOGFN *pfnShowHTMLDialog = NULL;
    HINSTANCE hInst = 0;
    HRESULT hr = 0;
    LPWSTR pwszFeatures = NULL;
    IMoniker *pMk = NULL;
    VARIANT vtDialogArg;
    VariantInit(&vtDialogArg);
    VARIANT vtRetVal;
    VariantInit(&vtRetVal);
    int i,j,k,iFeatureArgLength;
    TCHAR *pszSETUPPAGE = _T("JITSetupPage");
    WCHAR wszDownLoadPage[MAX_PATH];
    WCHAR wszDownLoadPageReg[MAX_PATH];
//    LPWSTR pwszDownLoadPage = NULL;
    HKEY hkeyActiveSetup = 0;
    LONG lResult = 0;
    DWORD dwType;
    DWORD dwSize = INTERNET_MAX_URL_LENGTH;
    int iLength = 0;
    int iRes = 0;
    OSVERSIONINFO osvi;


    // NT5 should never show JIT dialog.

    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionEx(&osvi);

    if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT &&
        osvi.dwMajorVersion >= 5) {
        hr = E_ACCESSDENIED;
        goto Exit;
    }

    // No Component Requests to process.  Return success and exit
    if(iComponentNum <= 0)
    {
        if(pVal)
            *pVal = TRUE;
        hr = S_OK;
        goto Exit;
    }


    // calculate space needed
    iFeatureArgLength = 0;
    // Length for the characters in the ComponentIDs
    for(k = 0; k < iComponentNum; k++)
    {
        iFeatureArgLength += lstrlenW(ppwszComponents[k]);
    }
    iFeatureArgLength += 9*iComponentNum - 1;  // "Feature="s and &'s
    iFeatureArgLength += 10;                 // breathing room
    pwszFeatures = new WCHAR[iFeatureArgLength];
    if(!pwszFeatures)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // copy the individual strings to one big string, seperated by "&feature="
    // i.e. "feature=JavaVM&feature=MOBILEPKx86"
    // i is the position in the full string
    // k is the current substring
    for(i = k = 0; k < iComponentNum; k++)
    {
        // "feature="
        StrCpyW(pwszFeatures + i, L"feature=");
        i += 8;
        iLength = lstrlenW(ppwszComponents[k]);
        // componentID
        StrCpyW(pwszFeatures + i, ppwszComponents[k]);
        i += iLength;
        // "&" || '\0'
        if(k + 1 < iComponentNum)
        {
            pwszFeatures[i] = L'&';
            i++;
        }
        else
        {
            pwszFeatures[i] = L'\0';
            i++;
        }
    }

    // Change string to variant
    vtDialogArg.vt = VT_BSTR;
    vtDialogArg.bstrVal = SysAllocString(pwszFeatures);
    if(! vtDialogArg.bstrVal)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // get the download dialog page from the registry
    if ((lResult = RegOpenKeyExA( HKEY_LOCAL_MACHINE, 
            REGKEY_ACTIVESETUP, 0, KEY_READ,
            &hkeyActiveSetup)) != ERROR_SUCCESS) 
    {
        hr = HRESULT_FROM_WIN32(lResult);
        goto Exit;
    }

    if (lResult = SHQueryValueEx(hkeyActiveSetup, pszSETUPPAGE, NULL, 
        &dwType, wszDownLoadPageReg, &dwSize) != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lResult);
        goto Exit;
    }

    if (wszDownLoadPageReg) {
        WCHAR             *wszDownLoadPageFile = NULL;

        wszDownLoadPageFile = PathFindFileNameW(wszDownLoadPageReg);
        hr = SHGetWebFolderFilePathW(wszDownLoadPageFile, wszDownLoadPage, MAX_PATH);
        if (FAILED(hr)) {
            goto Exit;
        }
    }

/*    iLength = lstrlenA(szDownLoadPage) + 1;
    pwszDownLoadPage = new WCHAR[iLength];
    iRes = MultiByteToWideChar(CP_ACP,0,szDownLoadPage, iLength,
                             pwszDownLoadPage, iLength);
    if(iRes == 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

*/
    // Get Moniker to The JIT Dialog page
    hr =  CreateURLMoniker(NULL, wszDownLoadPage, &pMk);
    if (FAILED(hr))
        goto Exit;


    // Get the ShowHTMLDialog function from the mshtml dll
    hInst = LoadLibraryEx(TEXT("MSHTML.DLL"), NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
    if (!hInst)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    pfnShowHTMLDialog = (SHOWHTMLDIALOGFN *)GetProcAddress(hInst, "ShowHTMLDialog");
    if (!pfnShowHTMLDialog) 
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }    

    
    // Show the JIT download page; the rest of the work is accomplished there
    hr = (*pfnShowHTMLDialog)(NULL, pMk, &vtDialogArg, NULL, &vtRetVal);

    if(FAILED(hr))
    {
        goto Exit;
    }


    // Process the return value
    if ((vtRetVal.vt == VT_I4) && vtRetVal.lVal != S_OK ) 
    {
        hr = S_FALSE;
        if(pVal)
            *pVal = FALSE;
    }
    else if(vtRetVal.vt != VT_I4)
    {
        hr = S_FALSE;
        if(pVal)
            *pVal = FALSE;
    }
    else
    {
        hr = S_OK;
        if(pVal)
           *pVal = TRUE;
    }

    // Since everything was successful, clear the component list
    clearComponentRequest();



Exit:    // Goto needed because these resources must be cleaned up on all errors and successes

    // clear string
    if(pwszFeatures)
        delete [] pwszFeatures;
    if(pMk)
    {
        pMk->Release();
    }
//    if(pwszDownLoadPage)
//    {
//        delete [] pwszDownLoadPage;
//        pwszDownLoadPage = NULL;
//    }
    VariantClear(&vtRetVal);
    VariantClear(&vtDialogArg);
    if(hInst)
    {
         FreeLibrary(hInst);
    }

    return hr;
}

STDMETHODIMP CClientCaps::clearComponentRequest()
// Clears the list of components logged using AddComponentRequest
{
    int i;
    for(i = 0; i < iComponentNum; i++)
    {
        if(ppwszComponents[i] != NULL)
        {
            // delete the wide string
            delete [] ppwszComponents[i];
            ppwszComponents[i] = NULL;
        }
    }
    iComponentNum = 0;
    return S_OK;
}

    
// IElementBehavior methods

STDMETHODIMP CClientCaps::Init(IElementBehaviorSite *pSite)
{
    HRESULT hr = E_INVALIDARG;

    if (pSite != NULL)
    {
        m_pSite = pSite;
        m_pSite->AddRef();
        hr = S_OK;
    }

    return hr;  
}

STDMETHODIMP CClientCaps::Notify(LONG lNotify, VARIANT * pVarNotify)
{
    return S_OK;
}

// Helper functions for internal use only

STDMETHODIMP CClientCaps::GetHTMLDocument(IHTMLDocument2 **ppDoc)
{
    HRESULT hr = E_FAIL;

    if (m_pSite != NULL)
    {
        IHTMLElement *pElement = NULL;
        hr = m_pSite->GetElement(&pElement);
        if (SUCCEEDED(hr))
        {
            IDispatch * pDispDoc = NULL;
            hr = pElement->get_document(&pDispDoc);
            if (SUCCEEDED(hr))
            {
                hr = pDispDoc->QueryInterface(IID_IHTMLDocument2, (void **)ppDoc);
                pDispDoc->Release();
            }
            pElement->Release();
        }
    }

    return hr;
}


STDMETHODIMP CClientCaps::GetHTMLWindow(IHTMLWindow2 **ppWindow)
{
    HRESULT hr = E_FAIL;
    IHTMLDocument2 *pDoc = NULL;

    hr = GetHTMLDocument(&pDoc);

    if (SUCCEEDED(hr))
    {
        hr = pDoc->get_parentWindow(ppWindow);
        pDoc->Release();
    }

    return hr;
}

STDMETHODIMP CClientCaps::GetClientInformation(IOmNavigator **ppNav)
{
    HRESULT hr = E_FAIL;
    IHTMLWindow2 *pWindow = NULL;

    hr = GetHTMLWindow(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->get_clientInformation(ppNav);
        pWindow->Release();
    }

    return hr ;
}

STDMETHODIMP CClientCaps::GetScreen(IHTMLScreen **ppScreen)
{
    HRESULT hr = E_FAIL;
    IHTMLWindow2 *pWindow = NULL;

    hr = GetHTMLWindow(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->get_screen(ppScreen);
        pWindow->Release();
    }

    return hr ;
}

// Returns S_OK if component is installed and the version # in pbstrVersion.
// Returns S_FALSE if component is not installed.
// E_INVALIDARG if the input args are ill-formed or not an IE component.
// E_* if it encounters an error. 

STDMETHODIMP CClientCaps::GetVersion(BSTR bstrName, BSTR bstrType, LPDWORD pdwFileVersionMS, LPDWORD pdwFileVersionLS)
{
    if (bstrName == NULL || bstrType == NULL)
        return E_INVALIDARG;
        
    uCLSSPEC classspec;
    HRESULT hr = E_FAIL;
    QUERYCONTEXT qc = {0};

    // First figure out the type of the component and populate the CLSSPEC appropriately.
    if (0 == StrCmpICW(bstrType, L"mimetype"))
    {
        classspec.tyspec =  TYSPEC_MIMETYPE;
        classspec.tagged_union.pMimeType = bstrName;
    }
    else if (0 == StrCmpICW(bstrType, L"progid"))
    {
        classspec.tyspec = TYSPEC_PROGID;
        classspec.tagged_union.pProgId = bstrName;
    }
    else if (0 == StrCmpICW(bstrType, L"clsid"))
    {
        classspec.tyspec = TYSPEC_CLSID;
        // Convert class-id string to GUID.
        hr = CLSIDFromString(bstrName, &classspec.tagged_union.clsid);
        if (FAILED(hr))
            goto Exit;
    }
    else if (0 == StrCmpICW(bstrType, L"componentid"))
    {
        classspec.tyspec = TYSPEC_FILENAME;
        classspec.tagged_union.pFileName = bstrName;
    }
    else
    {
        hr = E_INVALIDARG;
        goto Exit;
    }                


    hr = FaultInIEFeature(NULL, &classspec, &qc, FIEF_FLAG_PEEK);

    if (hr == S_OK || (qc.dwVersionHi != 0 || qc.dwVersionLo != 0))
    {
        // Put the version #'s that we found in the out args.
        if (pdwFileVersionMS != NULL)
            *pdwFileVersionMS = qc.dwVersionHi;
        if (pdwFileVersionLS != NULL)
            *pdwFileVersionLS = qc.dwVersionLo;

        hr = S_OK;         
    }
    else if ( hr == S_FALSE)
    {
        // this implies the component is not recognized as an IE component.
        // The input argument must be incorrect in this case.
        hr = E_INVALIDARG;
    }
    else if ( hr == HRESULT_FROM_WIN32(ERROR_PRODUCT_UNINSTALLED))
    {
        hr = S_FALSE;
    }

Exit:
    return hr;
} 


// ---------------------------------------------------------------------------
// %%Function: GetVersionFromString
//
//    converts version in text format (a,b,c,d) into two dwords (a,b), (c,d)
//    The printed version number is of format a.b.d (but, we don't care)
// ---------------------------------------------------------------------------
HRESULT
CClientCaps::GetVersionFromString(LPCOLESTR szBuf, LPDWORD pdwFileVersionMS, LPDWORD pdwFileVersionLS)
{
    LPCOLESTR pch = szBuf;
    OLECHAR ch;

    *pdwFileVersionMS = 0;
    *pdwFileVersionLS = 0;

    if (!pch)            // default to zero if none provided
        return S_OK;

    if (StrCmpCW(pch, L"-1,-1,-1,-1") == 0) {
        *pdwFileVersionMS = 0xffffffff;
        *pdwFileVersionLS = 0xffffffff;
        return S_OK;
    }

    USHORT n = 0;

    USHORT a = 0;
    USHORT b = 0;
    USHORT c = 0;
    USHORT d = 0;

    enum HAVE { HAVE_NONE, HAVE_A, HAVE_B, HAVE_C, HAVE_D } have = HAVE_NONE;


    for (ch = *pch++;;ch = *pch++) {

        if ((ch == L',') || (ch == L'\0')) {

            switch (have) {

            case HAVE_NONE:
                a = n;
                have = HAVE_A;
                break;

            case HAVE_A:
                b = n;
                have = HAVE_B;
                break;

            case HAVE_B:
                c = n;
                have = HAVE_C;
                break;

            case HAVE_C:
                d = n;
                have = HAVE_D;
                break;

            case HAVE_D:
                return E_INVALIDARG; // invalid arg
            }

            if (ch == L'\0') {
                // all done convert a,b,c,d into two dwords of version

                *pdwFileVersionMS = ((a << 16)|b);
                *pdwFileVersionLS = ((c << 16)|d);

                return S_OK;
            }

            n = 0; // reset

        } else if ( (ch < L'0') || (ch > L'9'))
            return E_INVALIDARG;    // invalid arg
        else
            n = n*10 + (ch - L'0');


    } /* end forever */

    // NEVERREACHED
}


// ---------------------------------------------------------------------------
// %%Function: GetStringFromVersion
//
//    converts version from two DWORD's to the string format a,b,c,d
// ---------------------------------------------------------------------------

HRESULT CClientCaps::GetStringFromVersion(DWORD dwVersionMS, DWORD dwVersionLS, BSTR *pbstrVersion)
{
    if (pbstrVersion == NULL)
        return E_POINTER;

    // 16-bits is a max of 5 decimal digits * 4 + 3 ','s  + null terminator    
    const int maxStringSize = 5 * 4 + 3 * 1 + 1;                            
    OLECHAR rgch[maxStringSize];

    USHORT a = (USHORT)(dwVersionMS >> 16);
    USHORT b = (USHORT)(dwVersionMS & 0xffff);
    USHORT c = (USHORT)(dwVersionLS >> 16);
    USHORT d = (USHORT)(dwVersionLS & 0xffff);

    OLECHAR rgchFormat[] = L"%hu,%hu,%hu,%hu";

    int nRet = wnsprintfW(rgch, maxStringSize, rgchFormat, a, b, c, d);

    HRESULT hr;
    if (nRet < 7 ) // 0,0,0,0
    {
        hr = E_FAIL;
    }
    else
    {
        *pbstrVersion = SysAllocString(rgch);
        if (*pbstrVersion == NULL)
            hr = E_OUTOFMEMORY;
        else
            hr = S_OK;
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\help\f3ctx.h ===
#define f3evtAddControl 2000010
#define f3evtAfterUpdate 2000020
#define f3evtBeforeDragOver 2000030
#define f3evtBeforeDropOrPaste 2000040
#define f3evtBeforeUpdate 2000050
#define f3evtChange 2000060
#define f3evtClick 2000070
#define f3evtDblClick 2000080
#define f3evtDropButtonClick 2000090
#define f3evtError 2000100
#define f3evtGotFocus 2000110
#define f3evtKeyDown 2000120
#define f3evtKeyPress 2000130
#define f3evtKeyUp 2000140
#define f3evtLayout 2000150
#define f3evtLostFocus 2000160
#define f3evtMouseDown 2000170
#define f3evtMouseMove 2000180
#define f3evtMouseUp 2000190
#define f3evtRemoveControl 2000200
#define f3evtScroll 2000210
#define f3evtSpinDown 2000220
#define f3evtSpinUp 2000230
#define f3evtZoom 2000240
#define f3mthAdd 2000250
#define f3mthAddItem 2000260
#define f3mthClear 2000270
#define f3mthCopy 2000280
#define f3mthCut 2000290
#define f3mthDropDown 2000300
#define f3mthItem 2000310
#define f3mthMove 2000320
#define f3mthPaste 2000330
#define f3mthRedoAction 2000340
#define f3mthRefresh 2000350
#define f3mthRemove 2000360
#define f3mthRemoveItem 2000370
#define f3mthRepaint 2000380
#define f3mthScroll 2000390
#define f3mthSelect 2000400
#define f3mthSelectAll 2000410
#define f3mthSetDefaultTabOrder 2000420
#define f3mthSetFocus 2000430
#define f3mthStartDrag 2000440
#define f3mthUndoAction 2000450
#define f3mthZOrder 2000460
#define f3objCheckBox 2000470
#define f3objComboBox 2000480
#define f3objCommandButton 2000490
#define f3objControls 2000500
#define f3objDataObject 2000510
#define f3objFont 2000520
#define f3objForm 2000530
#define f3objFrame 2000535                     // Manually added
#define f3objImage 2000540
#define f3objLabel 2000550
#define f3objListBox 2000560
#define f3objMultiPage 2000570
#define f3objOptionButton 2000580
#define f3objPage 2000590
#define f3objPages 2000600
#define f3objScrollBar 2000610
#define f3objSelected 2000620
#define f3objSpinButton 2000630
#define f3objTab 2000640
#define f3objTabs 2000650
#define f3objTabStrip 2000660
#define f3objTextBox 2000670
#define f3objToggleButton 2000680
#define f3proAccelerator 2000690
#define f3proActiveControl 2000700
#define f3proAlignment 2000710
#define f3proApplication 2000720
#define f3proAutoSelectChild 2000730
#define f3proAutoSize 2000740
#define f3proAutoTab 2000750
#define f3proAutoWordSelect 2000760
#define f3proBackColor 2000770
#define f3proBackStyle 2000780
#define f3proBold 2000790
#define f3proBorderColor 2000800
#define f3proBordersSuppress 2000810
#define f3proBorderStyle 2000820
#define f3proBoundColumn 2000830
#define f3proCancel 2000840
#define f3proCanPaste 2000850
#define f3proCanRedo 2000860
#define f3proCanUndo 2000870
#define f3proCaption 2000880
#define f3proClientHeight 2000890
#define f3proClientLeft 2000900
#define f3proClientTop 2000910
#define f3proClientWidth 2000920
#define f3proColumn 2000930
#define f3proColumnCount 2000940
#define f3proColumnHeads 2000950
#define f3proColumnWidths 2000960
#define f3proControls 2000970
#define f3proControlSource 2000980
#define f3proControlTipText 2000990
#define f3proCount 2001000
#define f3proCurLine 2001010
#define f3proCurTargetX 2001020
#define f3proCurTargetY 2001030
#define f3proCurX 2001040
#define f3proCurY 2001050
#define f3proCycle 2001060
#define f3proDefault 2001070
#define f3proDelay 2001080
#define f3proDragBehavior 2001085               // Added manually
#define f3proDrawBuffer 2001087                  // Added manually
#define f3proDesignMode 2001090
#define f3proDirty 2001100
#define f3proDropButtonStyle 2001110
#define f3proEnabled 2001120
#define f3proEnterFieldBehavior 2001125 // Added manually
#define f3proEnterKeyBehavior 2001130
#define f3proFont 2001140
#define f3proFontBold 2001150
#define f3proFontItalic 2001160
#define f3proFontName 2001170
#define f3proFontSize 2001180
#define f3proFontStrikethru 2001190
#define f3proFontUnderline 2001200
#define f3proFontWeight 2001210
#define f3proForeColor 2001220
#define f3proGridX 2001230
#define f3proGridY 2001240
#define f3proGroupName 2001245          // Added manually, AndrewL, 3/31/96
#define f3proHeight 2001250
#define f3proHelpContextID 2001260
#define f3proHideSelection 2001270
#define f3proIndex 2001280
#define f3proInSelection 2001290
#define f3proInsideHeight 2001300
#define f3proInsideWidth 2001310
#define f3proIntegralHeight 2001320
#define f3proItalic 2001330
#define f3proKeepFocusOnClick 2001340
#define f3proKeepScrollbarsVisible 2001350
#define f3proLargeChange 2001360
#define f3proLayoutEffect 2001370
#define f3proLeft 2001380
#define f3proLineCount 2001390
#define f3proList 2001400
#define f3proListCount 2001410
#define f3proListCursor 2001420
#define f3proListIndex 2001430
#define f3proListRows 2001440
#define f3proListStyle 2001450
#define f3proListWidth 2001460
#define f3proLocked 2001470
#define f3proMatchEntry 2001480
#define f3proMatchFound 2001490
#define f3proMatchRequired 2001500
#define f3proMax 2001510
#define f3proMaxLength 2001520
#define f3proMin 2001530
#define f3proMouseIcon 2001540
#define f3proMousePointer 2001550
#define f3proMultiLine 2001560
#define f3proMultiRow 2001570
#define f3proMultiSelect 2001580
#define f3proName 2001590
#define f3pronewEnum 2001600
#define f3proObject 2001610
#define f3proOldHeight 2001620
#define f3proOldLeft 2001630
#define f3proOldTop 2001640
#define f3proOldWidth 2001650
#define f3proOrientation 2001660
#define f3proPages 2001670
#define f3proParent 2001680
#define f3proPasswordChar 2001690
#define f3proPictureAlignment 2001700
#define f3proPictureData 2001710
#define f3proPicturePosition 2001720
#define f3proPictureSizeMode 2001730
#define f3proPictureTiling 2001740
#define f3proProportionalThumb 2001750
#define f3proRowSource 2001760
#define f3proRowSourceType 2001770
#define f3proScrollBars 2001780
#define f3proScrollHeight 2001790
#define f3proScrollLeft 2001800
#define f3proScrollTop 2001810
#define f3proScrollWidth 2001820
#define f3proSelected 2001830
#define f3proSelectedCount 2001840
#define f3proSelectedItem 2001850
#define f3proSelectionMargin 2001860
#define f3proSelLength 2001870
#define f3proSelStart 2001880
#define f3proSelText 2001890
#define f3proShowDropButtonWhen 2001900
#define f3proShowGridDots 2001910
#define f3proSize 2001920
#define f3proSizeMode 2001930
#define f3proSmallChange 2001940
#define f3proSnapToGrid 2001950
#define f3proSpecialEffect 2001960
#define f3proStrikeThrough 2001970
#define f3proStyle 2001980
#define f3proTabFixedHeight 2001990
#define f3proTabFixedWidth 2002000
#define f3proTabIndex 2002010
#define f3proTabKeyBehavior 2002020
#define f3proTabOrientation 2002030
#define f3proTabs 2002040
#define f3proTabStop 2002050
#define f3proTag 2002060
#define f3proText 2002070
#define f3proTextAlign 2002080
#define f3proTextColumn 2002090
#define f3proTextLength 2002100
#define f3proTop 2002110
#define f3proTopIndex 2002120
#define f3proTransitionEffect 2002130
#define f3proTransitionPeriod 2002140
#define f3proTripleState 2002150
#define f3proUnderline 2002160
#define f3proValid 2002170
#define f3proValue 2002180
#define f3proVerticalScrollbarSide 2002190
#define f3proVisible 2002200
#define f3proWeight 2002210
#define f3proWidth 2002220
#define f3proWordWrap 2002230
#define f3proZoom 2002240
#define IDH_f3defControl 2002250
#define IDH_f3defANSICharacterSet 2002260
#define IDH_f3defAcceleratorKey 2002270
#define IDH_f3defActive 2002280
#define IDH_f3defArgument 2002290
#define IDH_f3defArray 2002300
#define IDH_f3defBackgroundColor 2002310
#define IDH_f3defBound 2002320
#define IDH_f3defCaption 2002330
#define IDH_f3defClass 2002340
#define IDH_f3defClassIdentifier 2002350
#define IDH_f3defClear 2002360
#define IDH_f3defClientRegion 2002370
#define IDH_f3defClip 2002380
#define IDH_f3defCollection 2002390
#define IDH_f3defContainer 2002400
#define IDH_f3defContextID 2002410
#define IDH_f3defControlGroup 2002420
#define IDH_f3defCycle 2002430
#define IDH_f3defDataSource 2002440
#define IDH_f3defDefault 2002450
#define IDH_f3defDesignTime 2002460
#define IDH_f3defDisable 2002470
#define IDH_f3defDoubleclickSpeedSetting 2002480
#define IDH_f3defDraganddropOperation 2002490
#define IDH_f3defDropSource 2002500
#define IDH_f3defDropdownList 2002510
#define IDH_f3defEnable 2002520
#define IDH_f3defEvent 2002530
#define IDH_f3defEventProcedure 2002540
#define IDH_f3defFocus 2002550
#define IDH_f3defForegroundColor 2002560
#define IDH_f3defForm 2002570
#define IDH_f3defFormat 2002580
#define IDH_f3defIME 2002590
#define IDH_f3defInheritedProperty 2002600
#define IDH_f3defInputArea 2002610
#define IDH_f3defInsertionPoint 2002620
#define IDH_f3defKeyboardState 2002630
#define IDH_f3defLabel 2002640
#define IDH_f3defMember 2002650
#define IDH_f3defMemberName 2002660
#define IDH_f3defMethod 2002670
#define IDH_f3defModule 2002680
#define IDH_f3defNamedArgument 2002690
#define IDH_f3defNull 2002700
#define IDH_f3defOLEContainerControls 2002710
#define IDH_f3defOLEObject 2002720
#define IDH_f3defOLEStatusCode 2002730
#define IDH_f3defObject 2002740
#define IDH_f3defObjectBrowser 2002750
#define IDH_f3defPage 2002760
#define IDH_f3defPlaceholder 2002770
#define IDH_f3defPoint 2002780
#define IDH_f3defProcedure 2002790
#define IDH_f3defProject 2002800
#define IDH_f3defProperty 2002810
#define IDH_f3defPropertyPage 2002820
#define IDH_f3defRGB 2002830
#define IDH_f3defRunTime 2002840
#define IDH_f3defSelection 2002850
#define IDH_f3defSendKeysStatement 2002860
#define IDH_f3defSeparator 2002870
#define IDH_f3defSingleprecisionValue 2002880
#define IDH_f3defSizingHandles 2002890
#define IDH_f3defStatement 2002900
#define IDH_f3defSystemColors 2002910
#define IDH_f3defTabOrder 2002920
#define IDH_f3defTarget 2002930
#define IDH_f3defToolbar 2002940
#define IDH_f3defTransparent 2002950
#define IDH_f3defUnbound 2002960
#define IDH_f3defUserInterface 2002970
#define IDH_f3defValue 2002980
#define IDH_f3defVisualBasicForApplications 2002990
#define IDH_f3defVisualGroup 20023000
#define IDH_f3defZorder 20023010
#define f3defDataFormat 20023020        //Added manually 5/17/96
#define f3defDominantControl  20023030  //Added manually 5/17/96
#define f3defGridBlock  20023040        //Added manually 5/17/96
// ***** Begin Dialog Box context IDs
#define f3dlgRename 2010010
#define f3dlgPageOrder 2010020
#define f3dlgCustomControls 2010030
#define f3dlgCustomizeControl 2010040
#define IDH_f3defDataFormat 2010050
#define IDH_f3defDominantControl 2010060
#define IDH_f3defGridBlock 2010070
#define IDH_f3defControlTip 2010080
#define IDH_f3defCursor 2010090
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\basectl.cxx ===
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#include "iextag.h"

#include "utils.hxx"

#include "basectl.hxx"

/////////////////////////////////////////////////////////////////////////////
//
// CBaseCtl - Base class for control behaviors
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////

CBaseCtl::CBaseCtl()
{
}

/////////////////////////////////////////////////////////////////////////////

CBaseCtl::~CBaseCtl()
{
    ReleaseInterface(_pSite);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CBaseCtl::Init(IElementBehaviorSite *pSite)
{
    HRESULT hr = S_OK;

    if (!pSite)
        return E_INVALIDARG;

    _pSite = pSite;
    _pSite->AddRef();

    hr = Init();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CBaseCtl::Notify(LONG lEvent, VARIANT * pVarNotify)
{
    HRESULT     hr = S_OK;

    switch (lEvent)
    {
    case BEHAVIOREVENT_CONTENTREADY:
        hr = OnContentReady();
        break;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
//  IPersistPropertyBag2 implementataion
//
/////////////////////////////////////////////////////////////////////////////
//+----------------------------------------------------------------------------
//
//  Member : Load  - IPersistPropertyBag2 property impl
//
//  Synopsis : This gives us a chance to pull properties from the property bag
//      created when the element's attributes were parsed in. Since we handle
//      all the getter/putter logic, our copy of the value will always be the 
//      current one.  This gives this behavior full control over the attribures
//      that it is interested in.
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CBaseCtl::Load ( IPropertyBag2 *pPropBag, IErrorLog *pErrLog)
{
    HRESULT          hr = S_OK;
    const PROPDESC * ppropdesc = BaseDesc();
    CDataObj *       pAttribute = GetProps();
    IPropertyBag *   pBag = NULL;

    if (!pPropBag)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = pPropBag->QueryInterface(IID_IPropertyBag, (void**) &pBag);
    if (hr || !pBag)
        goto Cleanup;

    // loop through all the attributes and load them
    while (ppropdesc->_bstrPropName)
    {
        pBag->Read(ppropdesc->_bstrPropName, 
                   &pAttribute->_varValue,
                   pErrLog);

        hr = CheckAttributeType(&pAttribute->_varValue, ppropdesc->_vt);
        // TODO: What should we do if the value is out of range? Right now, 
        // we set it to the default.
        if (hr && !(hr == DISP_E_OVERFLOW))
            goto Cleanup;

        hr = CheckDefaultValue(ppropdesc, pAttribute);
        if (hr)
            goto Cleanup;

        pAttribute++;
        ppropdesc++;
    }


Cleanup:
    ReleaseInterface(pBag);
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member : CheckAttributeType 
//
//  Synopsis : This is a helper function to convert the attribute to 
//  the appropriate type. We need this because many attributes
//  are loaded as VT_BSTR, but we want VT_I4.
//
//-----------------------------------------------------------------------------

HRESULT
CBaseCtl::CheckAttributeType(VARIANT * pvar, VARTYPE vt)
{
    HRESULT hr = S_OK;

    if (V_VT(pvar) != vt && V_VT(pvar) != VT_EMPTY)
    {
        CVariant cvar(vt);
        hr = cvar.CoerceVariantArg(pvar, vt);
        if (hr) 
            goto Cleanup;
        *pvar = cvar;
    }

Cleanup:
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member : CheckDefaultValue
//
//  Synopsis : Checks to see whether the value of an attribute has been set.
//  If not, set it to it's default value.
//
//-----------------------------------------------------------------------------

HRESULT
CBaseCtl::CheckDefaultValue(const PROPDESC * ppropdesc, CDataObj * pAttribute)
{
    HRESULT hr = S_OK;

    if (V_VT(&pAttribute->_varValue) == VT_EMPTY)
    {
        V_VT(&pAttribute->_varValue) = ppropdesc->_vt;

        switch (ppropdesc->_vt)
        {
        case VT_BSTR:
            V_BSTR(&pAttribute->_varValue) = SysAllocString(ppropdesc->_bstrDefault);
            break;
        case VT_I4:
            V_I4(&pAttribute->_varValue) = ppropdesc->_lDefault;
            break;
        case VT_BOOL:
            V_BOOL(&pAttribute->_varValue) = ppropdesc->_fDefault;
            break;
        default:
            Assert(FALSE);
        }
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member : Save  - IPersistPropertyBag2 property impl
//
//  Synopsis : Like the load, above, this allows us to save the attributes which
//      we control.  This is all part of fully owning our element's behavior, OM
//      and attributes. 
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CBaseCtl::Save ( IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    HRESULT          hr = S_OK;
    IPropertyBag *   pBag = NULL;
    const PROPDESC * ppropdesc = BaseDesc();
    CDataObj *       pAttribute = GetProps();
    long             i=0;

    // verify parameters
    if (!pPropBag)
    {
        hr = E_POINTER;
        goto Cleanup;
    }


    // now go through our properties and save them if they are dirty, or if
    // a save-All is required.
    //---------------------------------------------------------------------

    hr = pPropBag->QueryInterface(IID_IPropertyBag, (void**) &pBag);
    if (hr || !pBag)
        goto Cleanup;


    while (ppropdesc->_bstrPropName)
    {
        if (pAttribute->IsDirty() || fSaveAllProperties)
        {
            if (V_VT(&pAttribute->_varValue) != VT_DISPATCH)
            {
                pBag->Write(ppropdesc->_bstrPropName, &pAttribute->_varValue);

                if (fClearDirty)
                    pAttribute->_fDirty = FALSE;
            }
        }

        pAttribute++;
        ppropdesc++;
    }

Cleanup:
    ReleaseInterface(pBag);
    return hr;
}

HRESULT 
CBaseCtl::RegisterEvent(IElementBehaviorSiteOM * pSiteOM,
              BSTR   bstrEventName,
              LONG * plBehaviorID,
              LONG   lFlags /*= 0*/)
{
    HRESULT hr = S_OK;

    Assert(pSiteOM);

    Assert(_tcsspn(bstrEventName, L"on") == 2);

    hr = pSiteOM->RegisterEvent (bstrEventName, lFlags, plBehaviorID);
    if (hr)
        goto Cleanup;

Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CBaseCtl::FireEvent(long lCookie, 
                    VARIANT_BOOL * pfContinue /*=NULL*/,
                    BSTR bstrEventName /*=NULL*/)
{
    HRESULT                  hr         = S_OK;
    IHTMLEventObj  *         pEventObj  = NULL;
    IHTMLEventObj2 *         pEventObj2 = NULL;
    IElementBehaviorSiteOM * pSiteOM    = NULL;
    VARIANT                  varRet;

    hr = _pSite->QueryInterface(IID_IElementBehaviorSiteOM, (void **) &pSiteOM);
    if (hr)
        goto Cleanup;

    VariantInit(&varRet);

    // create an event object
    hr = pSiteOM->CreateEventObject(&pEventObj);
    if (hr)
        goto Cleanup;

    // ISSUE: (85045) We need a way put the event name in the event object.
    // Shouldn't FireEvent do this for us? For now, if bstrEventName is 
    // supplied, we'll use it. This is needed for the CIESelectElement::CEventSink::Invoke.
    if (bstrEventName)
    {
        hr = pEventObj->QueryInterface(IID_IHTMLEventObj2, (void**)&pEventObj2);
        if (hr)
            goto Cleanup;

        pEventObj2->put_type( bstrEventName );
    }

    hr = pSiteOM->FireEvent (lCookie, pEventObj);

    if (pfContinue)
    {
        hr = pEventObj->get_returnValue(&varRet);
        if (!hr)
            *pfContinue =  ((V_VT(&varRet) == VT_BOOL) && 
            (V_BOOL(&varRet) == VB_FALSE))? VB_FALSE : VB_TRUE;
    }

Cleanup:
    VariantClear(&varRet);
    ReleaseInterface(pSiteOM);
    ReleaseInterface(pEventObj);
    ReleaseInterface(pEventObj2);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////

HRESULT
CBaseCtl::AttachEvent(ENUM_EVENTS event, CContextAccess * pa)
{
    HRESULT                         hr = S_OK;
    IConnectionPointContainer *     pCPC = NULL;
    IConnectionPoint *              pCP = NULL;

    Assert (pa);

    // ( EVENT_SINK_ADDING_STEP ) expand the switch below

    switch (event)
    {
    case EVENT_ONCLICK:
    case EVENT_ONKEYPRESS:
    case EVENT_ONKEYDOWN:
    case EVENT_ONKEYUP:
    case EVENT_ONFOCUS:
    case EVENT_ONBLUR:
    case EVENT_ONPROPERTYCHANGE:
    case EVENT_ONMOUSEOVER:
    case EVENT_ONMOUSEOUT:
    case EVENT_ONMOUSEDOWN:
    case EVENT_ONMOUSEUP:
    case EVENT_ONMOUSEMOVE:
    case EVENT_ONSELECTSTART:
    case EVENT_ONSCROLL:
    case EVENT_ONCONTEXTMENU:


        if (!_fElementEventSinkConnected)
        {
            _fElementEventSinkConnected = TRUE;

            hr = pa->Open(CA_ELEM);
            if (hr)
                goto Cleanup;

            hr = pa->Elem()->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
            if (hr)
                goto Cleanup;
            hr = pCPC->FindConnectionPoint(DIID_HTMLElementEvents2, &pCP);
            if (hr)
                goto Cleanup;

            hr = pCP->Advise((HTMLElementEvents2*)(&_EventSink), &_dwCookie);
            if (hr)
                goto Cleanup;
        }

        break;

    default:
        Assert(FALSE && "missing implementation");
        hr = E_INVALIDARG;
        goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pCPC);
    ReleaseInterface(pCP);

    return hr;   
}

/////////////////////////////////////////////////////////////////////////////
//
//  CBaseCtl::CEventSink
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////

CBaseCtl::CEventSink::CEventSink ()
{
}

/////////////////////////////////////////////////////////////////////////////

CBaseCtl::CEventSink::~CEventSink ()
{
}

/////////////////////////////////////////////////////////////////////////////

ULONG
CBaseCtl::CEventSink::AddRef(void)
{
    return ((IElementBehavior*)Target())->AddRef();
}

/////////////////////////////////////////////////////////////////////////////

ULONG
CBaseCtl::CEventSink::Release(void)
{
    return ((IElementBehavior*)Target())->Release();
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CBaseCtl::CEventSink::QueryInterface(REFIID riid, void ** ppUnk)
{
    if (IsEqualGUID(riid, IID_IUnknown) ||
        IsEqualGUID(riid, IID_IDispatch) ||
        IsEqualGUID(riid, DIID_HTMLElementEvents2))
    {
        *ppUnk = this;
        AddRef();
        return S_OK;
    }

    *ppUnk = NULL;

    return E_NOINTERFACE;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CBaseCtl::CEventSink::Invoke(
    DISPID          dispid,
    REFIID          riid,
    LCID            lcid,
    WORD            wFlags,
    DISPPARAMS  *   pDispParams,
    VARIANT  *      pVarResult,
    EXCEPINFO *     pExcepInfo,
    UINT *          puArgErr)
{
    HRESULT             hr = S_OK;
    CEventObjectAccess  eoa(pDispParams);
    LONG                l;
    BSTR                bstr = NULL;

    hr = eoa.Open(EOA_EVENTOBJ);
    if (hr)
        goto Cleanup;

    // ( EVENT_SINK_ADDING_STEP ) expand the switch below

    switch (dispid)
    {
    case DISPID_HTMLELEMENTEVENTS2_ONCLICK:                 hr = Target()->OnClick(&eoa);         break;
    case DISPID_HTMLELEMENTEVENTS2_ONFOCUS:                 hr = Target()->OnFocus(&eoa);         break;
    case DISPID_HTMLELEMENTEVENTS2_ONBLUR:                  hr = Target()->OnBlur(&eoa);          break;

    case DISPID_HTMLELEMENTEVENTS2_ONMOUSEOVER:             hr = Target()->OnMouseOver(&eoa);     break;
    case DISPID_HTMLELEMENTEVENTS2_ONMOUSEOUT:              hr = Target()->OnMouseOut(&eoa);      break;
    case DISPID_HTMLELEMENTEVENTS2_ONMOUSEDOWN:             hr = Target()->OnMouseDown(&eoa);     break;
    case DISPID_HTMLELEMENTEVENTS2_ONMOUSEUP:               hr = Target()->OnMouseUp(&eoa);       break;
    case DISPID_HTMLELEMENTEVENTS2_ONMOUSEMOVE:             hr = Target()->OnMouseMove(&eoa);     break;

    case DISPID_HTMLELEMENTEVENTS2_ONKEYDOWN:               hr = Target()->OnKeyDown(&eoa);       break;
    case DISPID_HTMLELEMENTEVENTS2_ONKEYUP:                 hr = Target()->OnKeyUp(&eoa);         break;
    case DISPID_HTMLELEMENTEVENTS2_ONKEYPRESS:              hr = Target()->OnKeyPress(&eoa);      break;
    case DISPID_HTMLELEMENTEVENTS2_ONSELECTSTART:           hr = Target()->OnSelectStart(&eoa);   break;
    case DISPID_HTMLELEMENTEVENTS2_ONSCROLL:                hr = Target()->OnScroll(&eoa);        break;
    case DISPID_HTMLELEMENTEVENTS2_ONCONTEXTMENU:           hr = Target()->OnContextMenu(&eoa);   break;

    case DISPID_HTMLELEMENTEVENTS2_ONPROPERTYCHANGE:
        hr = eoa.Open(EOA_EVENTOBJ2);
        if (hr)
            goto Cleanup;

        hr = eoa.EventObj2()->get_propertyName(&bstr);
        if (hr)
            goto Cleanup;

        hr = Target()->OnPropertyChange(&eoa, bstr);
        if (hr)
            goto Cleanup;

        break;
    }

Cleanup:
    SysFreeString(bstr);

    return hr;
}

//+------------------------------------------------------------------------
//
//  CBaseCtl::CDataObj : Member function implmentations
//
//-------------------------------------------------------------------------
HRESULT 
CBaseCtl::CDataObj::Set (BSTR bstrValue)
{
    VariantClear(&_varValue);
    _fDirty = TRUE;

    V_VT(&_varValue)   = VT_BSTR;
    if (!bstrValue)
    {
        V_BSTR(&_varValue) = NULL;
        return S_OK;
    }
    else
    {
        V_BSTR(&_varValue) = SysAllocStringLen(bstrValue, SysStringLen(bstrValue));

        return (V_BSTR(&_varValue)) ? S_OK : E_OUTOFMEMORY;
    }
}

HRESULT 
CBaseCtl::CDataObj::Set (VARIANT_BOOL vBool)
{
    VariantClear(&_varValue);
    _fDirty = TRUE;

    V_VT(&_varValue)   = VT_BOOL;
    V_BOOL(&_varValue) = vBool;

    return S_OK;
}

HRESULT
CBaseCtl::CDataObj::Set(IDispatch * pDisp)
{
    VariantClear(&_varValue);
    _fDirty = TRUE;

    V_VT(&_varValue)   = VT_DISPATCH;
    V_DISPATCH(&_varValue) = pDisp;

    if (pDisp)
        pDisp->AddRef();

    return S_OK;
}

HRESULT
CBaseCtl::CDataObj::Set(long l)
{
    VariantClear(&_varValue);
    _fDirty = TRUE;

    V_VT(&_varValue)  = VT_I4;
    V_I4(&_varValue) = l;

    return S_OK;
}

HRESULT 
CBaseCtl::CDataObj::Get (BSTR * pbstr)
{
    HRESULT hr = S_OK;

    Assert(pbstr) ;

    *pbstr = NULL;

    if (V_VT(&_varValue) == VT_BSTR)
    {
        *pbstr = SysAllocStringLen(V_BSTR(&_varValue), 
                                   SysStringLen(V_BSTR(&_varValue)));

        if (!*pbstr)
            hr = E_OUTOFMEMORY;
    }

    return hr;
};


HRESULT 
CBaseCtl::CDataObj::Get (VARIANT_BOOL * pVB)
{
    HRESULT hr = S_OK;

    Assert(pVB); 

    if (V_VT(&_varValue) != VT_BOOL)
    {
        *pVB = VB_FALSE;
        hr = S_FALSE;
    }
    else
    {
        *pVB =  V_BOOL(&_varValue);
    }

    return hr;
};

HRESULT
CBaseCtl::CDataObj::Get (long * pl)
{
    HRESULT hr = S_OK;

    Assert(pl);

    if (V_VT(&_varValue) != VT_I4)
    {
        *pl = 0;
        hr = S_FALSE;
    }
    else
    {
        *pl = V_I4(&_varValue);
    }

    return hr;
}

HRESULT
CBaseCtl::CDataObj::Get (IDispatch ** ppDisp)
{
    HRESULT hr = S_OK;

    Assert(ppDisp);

    *ppDisp = NULL;

    if (V_VT(&_varValue)!= VT_DISPATCH)
    {
        hr = S_FALSE;
    }
    else
    {
        *ppDisp = V_DISPATCH(&_varValue);
        if (*ppDisp)
            (*ppDisp)->AddRef();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\ccaps.h ===
// CCaps.h : Declaration of the CClientCaps

#ifndef __CCAPS_H_
#define __CCAPS_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CClientCaps
class ATL_NO_VTABLE CClientCaps : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CClientCaps, &CLSID_ClientCaps>,
    public IDispatchImpl<IClientCaps, &IID_IClientCaps, &LIBID_IEXTagLib>,

    public IElementBehavior
{
public:
    CClientCaps()
    {
        m_pSite = NULL;
        iComponentNum = 0;
        iComponentCap = 0;
        ppwszComponents = NULL;
    }
    ~CClientCaps()
    {
        if (m_pSite)
            m_pSite->Release();
        if(ppwszComponents)
        {
            clearComponentRequest();
            delete [] ppwszComponents;
        }
    }

DECLARE_REGISTRY_RESOURCEID(IDR_CLIENTCAPS)
DECLARE_NOT_AGGREGATABLE(CClientCaps)

BEGIN_COM_MAP(CClientCaps)
    COM_INTERFACE_ENTRY(IClientCaps)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IElementBehavior)
END_COM_MAP()

// IClientCaps
public:
    STDMETHOD(get_javaEnabled)(/*[out, retval]*/ VARIANT_BOOL *pVal);
    STDMETHOD(get_cookieEnabled)(/*[out, retval]*/ VARIANT_BOOL *pVal);
    STDMETHOD(get_cpuClass)(/*[out, retval]*/ BSTR * p);      
    STDMETHOD(get_systemLanguage)(/*[out, retval]*/ BSTR * p);
    STDMETHOD(get_userLanguage)(/*[out, retval]*/ BSTR * p);  
    STDMETHOD(get_platform)(/*[out, retval]*/ BSTR * p);      
    STDMETHOD(get_connectionSpeed)(/*[out, retval]*/ long * p);
    STDMETHOD(get_onLine)(/*[out, retval]*/ VARIANT_BOOL * p);
    STDMETHOD(get_colorDepth)(/*[out, retval]*/ long * p);    
    STDMETHOD(get_bufferDepth)(/*[out, retval]*/ long * p);   
    STDMETHOD(get_width)(/*[out, retval]*/ long * p);         
    STDMETHOD(get_height)(/*[out, retval]*/ long * p);        
    STDMETHOD(get_availHeight)(/*[out, retval]*/ long * p);   
    STDMETHOD(get_availWidth)(/*[out, retval]*/ long * p); 
    STDMETHOD(get_connectionType)(/*[out, retval]*/ BSTR * p); 
    STDMETHOD(getComponentVersion)(/*[in]*/ BSTR bstrName, /*[in]*/ BSTR bstrType, /*[out,retval]*/ BSTR *pbstrVer);
    STDMETHOD(isComponentInstalled)(/*[in]*/ BSTR bstrName, /*[in]*/ BSTR bstrType, /*[in,optional]*/ BSTR bStrVer, /*[out,retval]*/ VARIANT_BOOL *p);
    STDMETHOD(compareVersions)(/*[in]*/ BSTR bstrVer1, /*[in]*/ BSTR bstrVer2, /*[out,retval]*/long *p); 
    STDMETHOD(addComponentRequest)(/*[in]*/ BSTR bstrName, /*[in]*/ BSTR bstrType, /*[in, optional]*/ BSTR bstrVer);
    STDMETHOD(doComponentRequest)(/*[out]*/ VARIANT_BOOL * pVal);
    STDMETHOD(clearComponentRequest)();

    //IHTMLPeerElement methods
    STDMETHOD(Init)(IElementBehaviorSite *pSite);
    STDMETHOD(Notify)(LONG lNotify, VARIANT * pVarNotify);
    STDMETHOD(Detach)() { return S_OK; };

private:
    STDMETHOD(GetHTMLWindow)(/* out */ IHTMLWindow2 **ppWindow);
    STDMETHOD(GetHTMLDocument)(/* out */IHTMLDocument2 **ppDoc);
    STDMETHOD(GetClientInformation)(/* out */IOmNavigator **ppClientInformation);
    STDMETHOD(GetScreen)(/* out */ IHTMLScreen **ppScreen);
    STDMETHOD(GetVersion)(BSTR bstrName, BSTR bstrType, LPDWORD pdwMS, LPDWORD pdwLS);

private: // helpers functions to convert between version strings and DWORD's
    static HRESULT GetVersionFromString(LPCOLESTR psz, LPDWORD pdwMS, LPDWORD pdwLS);
    static HRESULT GetStringFromVersion(DWORD dwMS, DWORD dwLS, BSTR *pbstrVersion);

private:
    IElementBehaviorSite * m_pSite;
    int iComponentNum;
    int iComponentCap;
    LPWSTR * ppwszComponents;

};

#endif //__CCAPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\ancrclk.h ===
// AnchorClick.h
// behavior that grabs a tag and makes it navigate to a folder view

#ifndef __ANCHORCLICK_H__
#define __ANCHORCLICK_H__

#include "iextag.h"
#include "resource.h"

class CAnchorClick :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CAnchorClick, &CLSID_AnchorClick>,
    public IDispatchImpl<IAnchorClick, &IID_IAnchorClick, &LIBID_IEXTagLib>,
    public IElementBehavior
{
public:

    class CEventSink;

    CAnchorClick ();
    ~CAnchorClick ();

DECLARE_REGISTRY_RESOURCEID(IDR_WFOLDERS)

BEGIN_COM_MAP(CAnchorClick) 
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IAnchorClick)
    COM_INTERFACE_ENTRY(IElementBehavior)
END_COM_MAP()

    // IAnchorClick
    STDMETHOD(ProcOnClick)();
    // IElementBehavior
    STDMETHOD(Init)(IElementBehaviorSite *pSite);
    STDMETHOD(Notify)(LONG lNotify, VARIANT * pVarNotify);
    STDMETHOD(Detach)() { return S_OK; };

private:
    // Client site
    IElementBehaviorSite *m_pSite;
    // Event sink
    CEventSink *m_pSink;
    CEventSink *m_pSinkContextMenu;

    // Helper Functions
    HRESULT GetProperty_BSTR  (IDispatch * pDisp, LPWSTR  pchName, LPWSTR * pbstrRes);
    HRESULT GetProperty_Variant  (IDispatch * pDisp, LPWSTR  pchName, VARIANT * pvarRes);

public:

    class CEventSink : public IDispatch
    {
    public:
        CEventSink (CAnchorClick *pAnchorClick);

        STDMETHODIMP QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IDispatch
        STDMETHODIMP GetTypeInfoCount(UINT* pctinfo);
        STDMETHODIMP GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo** ppTInfo);
		STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames,
            LCID lcid, DISPID *rgDispId);
        STDMETHODIMP Invoke(DISPID dispIdMember, REFIID riid,
            LCID lcid, WORD wFlags, DISPPARAMS  *pDispParams, VARIANT  *pVarResult,
            EXCEPINFO *pExcepInfo, UINT *puArgErr);
    private:
        CAnchorClick *m_pParent;
    };

};

#endif  // __ANCHORCLICK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\ancrclk.cxx ===
//=================================================
//
//  File : ancrclk.cxx
//
//  purpose : implementation of the 
//            CAnchorClick class
//            Gives anchor tags the ability to 
//            navigate to web folders
//
//=================================================
// Chad Lindhorst, 1998

#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "ancrclk.h"
#include "httpwfh.h"
#include "utils.hxx"

// ========================================================================
// CAnchorClick
// ========================================================================

//+------------------------------------------------------------------------
//
//  Members:    CAnchorClick::CAnchorClick
//              CAnchorClick::~CAnchorClick
//
//  Synopsis:   Constructor/destructor
//
//-------------------------------------------------------------------------

CAnchorClick::CAnchorClick() 
{
    m_pSite = NULL;
    m_pSink = NULL;
    m_pSinkContextMenu = NULL;
}

CAnchorClick::~CAnchorClick() 
{
    if (m_pSite)
        m_pSite->Release();
    if (m_pSink)
        delete m_pSink;
    if (m_pSinkContextMenu) 
        delete m_pSinkContextMenu;
}

// ========================================================================
// IAnchorClick
// ========================================================================

//+------------------------------------------------------------------------
//
//  Member:     CAnchorClick::ProcOnClick
//
//  Synopsis:   Handles the onclick events.
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE 
CAnchorClick::ProcOnClick () 
{
    //BSTR bstrProtocol = NULL; //bug 50463
    BSTR bstrTarget = NULL;
    BSTR bstrUrl = NULL;
    HRESULT hr = E_FAIL;
    IHTMLElement *pElem = NULL;
    IElementBehavior * pPeer = NULL;
    Iwfolders * pWF = NULL;
    CComObject<Cwfolders> *pInstance = NULL; 
    IHTMLEventObj * pEvent = NULL;
    IHTMLWindow2 * pWin = NULL;

    if (FAILED(hr = m_pSite->GetElement (&pElem)))
        goto cleanup;
    
    if ( SUCCEEDED(hr = GetProperty_BSTR (pElem, L"href", &bstrUrl)))
    //bug 50463 && SUCCEEDED(hr = GetProperty_BSTR (pElem, L"navType", &bstrProtocol)) )
    {
        VARIANT vFalse;
        vFalse.vt = VT_BOOL;
        vFalse.boolVal = FALSE;

        /* //bug 50463
        if ((StrCmpIW (bstrProtocol, L"any")) &&
            (StrCmpIW (bstrProtocol, L"dav")) &&
            (StrCmpIW (bstrProtocol, L"wec")))
        {
            // this is a bad protocol.  Let's get outta here.
            goto cleanup;
        }
        */
        // if we got this far, we are gonna do a folder navigate        
        // prevent us from getting handled by anyone else.
        if (FAILED(hr = GetHTMLWindow (m_pSite, &pWin)))
            goto cleanup;

        if (FAILED(hr = pWin->get_event (&pEvent)) ||
            FAILED(hr = pEvent->put_returnValue(vFalse)))
        {
            goto cleanup;
        }
        
        // sets the target frame
        hr = GetProperty_BSTR (pElem, L"target", &bstrTarget);
        if (FAILED(hr) || !bstrTarget)
            bstrTarget = NULL;

        // get a hold of the httpFolder behavior.
        if (FAILED(hr = CComObject<Cwfolders>::CreateInstance(&pInstance)) ||
            FAILED(hr = pInstance->QueryInterface(IID_Iwfolders, (void **)&pWF)))
        {
            goto cleanup;
        }
       
        {
            IUnknown * punk = NULL;
            HWND hwnd = 0;

            // gets browser window handle (for ui)
            hr = GetClientSiteWindow(m_pSite, &hwnd);
            hr = IUnknown_QueryService(m_pSite, SID_SWebBrowserApp, IID_IUnknown, 
                                       (LPVOID *) &punk);          

            // navigates to the folder view of the url specified

            hr = pWF->navigateNoSite (bstrUrl, bstrTarget, /*bstrProtocol,*/ (DWORD)(DWORD_PTR)hwnd, punk);
        }

    }
    else 
        hr = S_OK;  // since the navType wasn't set, and no we ignore everything 

cleanup:
    SysFreeString (bstrTarget);
    SysFreeString (bstrUrl);
    //SysFreeString (bstrProtocol);

    ReleaseInterface (pEvent);
    ReleaseInterface (pWin);    
    ReleaseInterface (pElem);
    ReleaseInterface (pWF);
    ReleaseInterface (pPeer);

    return hr;
}


// ========================================================================
// IElementBehavior
// ========================================================================

//+------------------------------------------------------------------------
//
//  Member:     CAnchorClick::Init
//
//  Synopsis:   Called when this code is initialized as a behavior
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE 
CAnchorClick::Init (IElementBehaviorSite __RPC_FAR *pBehaviorSite) 
{
    HRESULT hr = E_INVALIDARG;
    BSTR bstrEvent = NULL;
    BSTR bstronContextMenu = NULL;
    BSTR bstrUrl = NULL;
    //bug 50463 BSTR bstrProtocol = NULL;
    VARIANT_BOOL vSuccess = VARIANT_FALSE;
    IHTMLElement *pElem = NULL;
    IHTMLElement2 *pElem2 = NULL;

    // this puppy is ref counted when used.
    m_pSink = new CEventSink (this);
    m_pSinkContextMenu = new CEventSink (this);
    
    if (!m_pSink || !m_pSinkContextMenu)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    if (pBehaviorSite != NULL)
    {
        m_pSite = pBehaviorSite;
        m_pSite->AddRef();
    }

    if (FAILED(hr = m_pSite->GetElement (&pElem)))
        goto cleanup;

    hr = pElem->QueryInterface(IID_IHTMLElement2, (void **)&pElem2);
    if (FAILED(hr))
        goto cleanup;

    // we are adding a phony href attribute to the tag if there is
    // a folder attribute set.  This will make sure that the 
    // browser uses the right underlining and colors for anchors
    // that have no href attribute, but do have a folder attribute.
    if ( SUCCEEDED(hr = GetProperty_BSTR (pElem, L"folder", &bstrUrl))) 
    /*    && (FAILED(hr = GetProperty_BSTR (pElem, L"navType", &bstrProtocol)) ||
             ((!StrCmpIW (bstrProtocol, L"any")) ||
              (!StrCmpIW (bstrProtocol, L"dav")) ||
              (!StrCmpIW (bstrProtocol, L"wec")))) )
    */
    {
        VARIANT vbstrUrl;
        vbstrUrl.vt = VT_BSTR;
        vbstrUrl.bstrVal = bstrUrl;

        pElem->setAttribute (L"href", vbstrUrl, VARIANT_FALSE);
    }
    else 
    {
        // If there is no folder specified then we assume this to be a regular anchor tag
        // Bug 54304
        goto cleanup;
    }

    /*
    // now we add a navtype if one wasn't specified and there is a "folder"
    // we add the default "any" protocol
    if ( bstrUrl && !bstrProtocol)
    {
        VARIANT vbstrUrl;
        vbstrUrl.vt = VT_BSTR;
        vbstrUrl.bstrVal = SysAllocString (L"any");
        if (!V_BSTR(&vbstrUrl))
        {
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
        
        pElem->setAttribute (L"navType", vbstrUrl, VARIANT_FALSE);
        SysFreeString (vbstrUrl.bstrVal);
    }
    */
    // we want to sink a few events.
    // we will take over the click and mouseover events because they
    // act differently for folder view anchors
    bstrEvent = SysAllocString (L"onclick");
    if (!bstrEvent)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }
    pElem2->attachEvent (bstrEvent, (IDispatch *) m_pSink, &vSuccess);
    if (vSuccess == VARIANT_TRUE) 
        hr = S_OK;
    else 
    {
        hr = E_FAIL;
        goto cleanup;
    }

    bstronContextMenu = SysAllocString(L"oncontextmenu");
    if (bstronContextMenu) {
        pElem2->attachEvent (bstronContextMenu, (IDispatch *) m_pSinkContextMenu, &vSuccess);
        if (vSuccess == VARIANT_TRUE) 
            hr = S_OK;
        else 
        {
            hr = E_FAIL;
            goto cleanup;
        }
    }    
    
cleanup:
    ReleaseInterface (pElem);
    ReleaseInterface (pElem2);

    SysFreeString (bstrEvent);
    SysFreeString (bstronContextMenu);
    SysFreeString (bstrUrl);
    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CAnchorClick::Notify
//
//  Synopsis:   Not really used, but needed by the interface...
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE 
CAnchorClick::Notify (LONG lEvent, VARIANT __RPC_FAR *pVar) 
{
    return S_OK;    
}

//+------------------------------------------------------------------------
//
//  Member:     CAnchorClick::GetProperty_Variant
//
//  Synopsis:   Gets a property from the element passed in as pDisp.
//              Taken from \mshtml\src\f3\drt\activex\peerdecl
//
//-------------------------------------------------------------------------

HRESULT
CAnchorClick::GetProperty_Variant (IDispatch * pDisp, LPWSTR  pchName, VARIANT * pvarRes)
{
    HRESULT     hr = S_OK;
    DISPID      dispid;
    EXCEPINFO   excepinfo;
    UINT        nArgErr;
    DISPPARAMS  dispparams = {NULL, NULL, 0, 0};

    if (!pvarRes || !pDisp)
        return E_POINTER;

    hr = pDisp->GetIDsOfNames(IID_NULL, &pchName, 1, LOCALE_SYSTEM_DEFAULT, &dispid);
    if (hr)
        goto Cleanup;

    hr = pDisp->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_PROPERTYGET,
                       &dispparams, pvarRes, &excepinfo, &nArgErr);

 Cleanup:

    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CAnchorClick::GetProperty_BSTR
//
//  Synopsis:   Gets a property from the element passed in as pDisp.
//              Taken from \mshtml\src\f3\drt\activex\peerdecl
//
//-------------------------------------------------------------------------

HRESULT
CAnchorClick::GetProperty_BSTR  (IDispatch * pDisp, LPWSTR  pchName, LPWSTR * pbstrRes)
{
    HRESULT     hr = S_OK;
    VARIANT     varRes;

    if (!pbstrRes)
        return E_POINTER;

    *pbstrRes = NULL;

    hr = GetProperty_Variant (pDisp, pchName, &varRes);
    if (hr)
        goto Cleanup;

    if (VT_BSTR != V_VT(&varRes))
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    (*pbstrRes) = V_BSTR(&varRes);

Cleanup:

    return hr;
}

// ========================================================================
// CEventSink::IDispatch
// ========================================================================

// The event sink's IDispatch interface is what gets called when events
// are fired.

//+------------------------------------------------------------------------
//
//  Member:     CAnchorClick::CEventSink::GetTypeInfoCount
//              CAnchorClick::CEventSink::GetTypeInfo
//              CAnchorClick::CEventSink::GetIDsOfNames
//
//  Synopsis:   We don't really need a nice IDispatch... this minimalist
//              version does just plenty.
//
//-------------------------------------------------------------------------

STDMETHODIMP 
CAnchorClick::CEventSink::GetTypeInfoCount(UINT* /*pctinfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP 
CAnchorClick::CEventSink::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
                                      /* [in] */ LCID /*lcid*/,
                                      /* [out] */ ITypeInfo** /*ppTInfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP 
CAnchorClick::CEventSink::GetIDsOfNames( REFIID          riid,
                                         OLECHAR**       rgszNames,
                                         UINT            cNames,            
                                         LCID            lcid,
                                         DISPID*         rgDispId)
{
    return E_NOTIMPL;
}

//+------------------------------------------------------------------------
//
//  Member:     CAnchorClick::CEventSink::Invoke
//
//  Synopsis:   This gets called for all events on our object.  (it was 
//              registered to do so in Init with attach_event.)  It calls
//              the appropriate parent functions to handle the events.
//
//-------------------------------------------------------------------------

STDMETHODIMP 
CAnchorClick::CEventSink::Invoke( DISPID dispIdMember,
                                  REFIID, LCID,
                                  WORD wFlags,
                                  DISPPARAMS* pDispParams,
                                  VARIANT* pVarResult,
                                  EXCEPINFO*,
                                  UINT* puArgErr)
{
    HRESULT hr = TRUE;
    if (m_pParent && pDispParams && pDispParams->cArgs>=1)
    {
        if (pDispParams->rgvarg[0].vt == VT_DISPATCH)
        {
            IHTMLEventObj *pObj=NULL;

            if (SUCCEEDED(pDispParams->rgvarg[0].pdispVal->QueryInterface(IID_IHTMLEventObj, 
                (void **)&pObj) && pObj))
            {
                BSTR bstrEvent=NULL;

                pObj->get_type(&bstrEvent);

                // user clicked one of our anchors
                if (! StrCmpICW (bstrEvent, L"click"))
                    hr = m_pParent->ProcOnClick();
                else if (! StrCmpICW (bstrEvent, L"ContextMenu")) 
                {
                    VARIANT vboolCancel;
                    vboolCancel.vt = VT_BOOL;
                    vboolCancel.boolVal = FALSE;
                    pObj->put_returnValue(vboolCancel);
                    hr = S_OK;
                }

                pObj->Release();
            }
        }
    }

    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CAnchorClick::CEventSink
//
//  Synopsis:   This is used to allow communication between the parent class
//              and the event sink class.  The event sink will call the ProcOn*
//              methods on the parent at the appropriate times.
//
//-------------------------------------------------------------------------

CAnchorClick::CEventSink::CEventSink (CAnchorClick * pParent)
{
    m_pParent = pParent;
}

// ========================================================================
// CEventSink::IUnknown
// ========================================================================

// Vanilla IUnknown implementation for the event sink.

STDMETHODIMP 
CAnchorClick::CEventSink::QueryInterface(REFIID riid, void ** ppUnk)
{
    void * pUnk = NULL;

    if (riid == IID_IDispatch)
        pUnk = (IDispatch *) this;

    if (riid == IID_IUnknown)
        pUnk = (IUnknown *) this;

    if (pUnk)
    {
        *ppUnk = pUnk;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) 
CAnchorClick::CEventSink::AddRef(void)
{
    return ((IElementBehavior *)m_pParent)->AddRef();
}

STDMETHODIMP_(ULONG) 
CAnchorClick::CEventSink::Release(void)
{
    return ((IElementBehavior *)m_pParent)->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\checkbase.cxx ===
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "iextag.h"

#include "utils.hxx"

#include "checkbase.hxx"

const static SIZE g_sizeStdGlyph    = { 13, 13 };
const static RECT g_offsetsStdGlyph = { 4, 4, 3, 3 };

HRESULT
CCheckBase::Init()
{
    HRESULT         hr = S_OK;
    VARIANT         var;
    CContextAccess  a(_pSite);

    Assert (S_OK == CContextAccess::DbgTest(_pSite));

    hr = a.Open (CA_SITEOM | CA_DEFAULTS | CA_STYLE | CA_DEFSTYLE);
    if (hr)
        goto Cleanup;

    //
    // misc
    //

    hr = a.Defaults()->put_tabStop(VB_TRUE);
    if (hr)
        goto Cleanup;

    //
    // layout
    //

    hr = a.Style()->put_display(_T("inline-block"));
    if (hr)
        goto Cleanup;

    V_VT(&var)  = VT_UI4;
    V_UI4(&var) = g_sizeStdGlyph.cx + g_offsetsStdGlyph.left + g_offsetsStdGlyph.right;

    hr = a.DefStyle()->put_width(var);
    if (hr)
        goto Cleanup;

    V_VT(&var)  = VT_UI4;
    V_UI4(&var) = g_sizeStdGlyph.cy + g_offsetsStdGlyph.top + g_offsetsStdGlyph.bottom;

    hr = a.DefStyle()->put_height(var);
    if (hr)
        goto Cleanup;

    //
    // events
    //

    hr = AttachEvent(EVENT_ONCLICK, &a);
    if (hr)
        goto Cleanup;

    hr = AttachEvent(EVENT_ONKEYPRESS, &a);
    if (hr)
        goto Cleanup;

    hr = Init(&a);
    if (hr)
        goto Cleanup;

Cleanup:

    return hr;
}

///////////////////////////////////////////////////////////////////////////////

HRESULT
CCheckBase::GetRenderInfo(LONG* plRenderInfo)
{
    HRESULT hr = S_OK;

    if (!plRenderInfo)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *plRenderInfo = CHECKBOX_RENDERINFO;

Cleanup:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////

HRESULT
CCheckBase::Draw(HDC hdc, LONG lLayer, LPRECT prc, IUnknown * pReserved)
{
    HRESULT      hr = S_OK;
    UINT         dfcs = 0;
    VARIANT_BOOL fChecked = VB_FALSE;

    Assert (lLayer & CHECKBOX_RENDERINFO);

    hr = AdjustRcToGlyph((CRect*)prc);
    if (hr)
        goto Cleanup;

    dfcs |= GlyphStyle();

    hr = get_checked(&fChecked);
    if (hr)
        goto Cleanup;

    if (fChecked)
        dfcs |= DFCS_CHECKED;

    if (!IsEnabled())
        dfcs |= DFCS_INACTIVE;

    // TODO Trident uses FormsDrawGlyph for this. Investigate what stuff from there should go in here too

    hr = DrawFrameControl(hdc, prc, DFC_BUTTON, dfcs) ? S_OK : E_FAIL;

Cleanup:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////

HRESULT
CCheckBase::AdjustRcToGlyph(CRect * prc)
{
    HRESULT     hr = S_OK;
    INT         cx = prc->width();
    INT         cy = prc->height();
    INT         cxOffsets = g_offsetsStdGlyph.left + g_offsetsStdGlyph.right;
    INT         cyOffsets = g_offsetsStdGlyph.top + g_offsetsStdGlyph.bottom;

    // adjust width

    if (g_sizeStdGlyph.cx + cxOffsets <= cx)
    {
        // completely fits (including std offsets)
        prc->left  += g_offsetsStdGlyph.left;
        prc->right -= g_offsetsStdGlyph.right;
    }
    else if (g_sizeStdGlyph.cx <= cx)
    {
        // completely fits (but std offsets don't fit entirely)
        cxOffsets = (cx - g_sizeStdGlyph.cx) / 2;
        prc->left  += cxOffsets;
        prc->right -= cxOffsets;
    }

    // adjust height

    if (g_sizeStdGlyph.cy + cyOffsets <= cy)
    {
        // completely fits (including std offsets)
        prc->top    += g_offsetsStdGlyph.top;
        prc->bottom -= g_offsetsStdGlyph.bottom;
    }
    else if (g_sizeStdGlyph.cy <= cy)
    {
        // completely fits (but std offsets don't fit entirely)
        cyOffsets = (cy - g_sizeStdGlyph.cy) / 2;
        prc->top    += cyOffsets;
        prc->bottom -= cyOffsets;
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////

HRESULT
CCheckBase::ChangeState()
{
    HRESULT         hr = S_OK;
    CContextAccess  a(_pSite);
    VARIANT_BOOL    fChecked = VB_FALSE;

    hr = a.Open(CA_SITERENDER);
    if (hr)
        goto Cleanup;

    hr = get_checked(&fChecked);
    if (hr)
        goto Cleanup;

    hr = put_checked(fChecked ? VB_FALSE : VB_TRUE);
    if (hr)
        goto Cleanup;

    hr = a.SiteRender()->Invalidate(NULL);

Cleanup:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////

HRESULT
CCheckBase::OnClick(CEventObjectAccess *pEvent)
{
    return ChangeState();
}

///////////////////////////////////////////////////////////////////////////////

HRESULT
CCheckBase::OnKeyPress(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;
    long    lKeyCode;            

    hr = pEvent->GetKeyCode(&lKeyCode);
    if (hr)
        goto Cleanup;

    // TODO is this the right way to check lKey?
    if (_T(' ') == lKeyCode)
    {
        hr = ChangeState();
    }

Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\checkbox.cxx ===
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "iextag.h"

#include "utils.hxx"

#include "checkbox.hxx"

const CBaseCtl::PROPDESC CCheckBox::s_propdesc[] = 
{
    {_T("value"), VT_BSTR},
    {_T("checked"), VT_BOOL, NULL, NULL, VB_FALSE},
    NULL
};

enum
{
    VALUE = 0,
    CHECKED = 1
};


HRESULT
CCheckBox::Init(CContextAccess * pca)
{
    HRESULT         hr = S_OK;

    hr = pca->Open (CA_SITEOM);
    if (hr)
        goto Cleanup;

    hr = pca->SiteOM()->RegisterName(_T("checkbox"));
    if (hr)
        goto Cleanup;

Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CCheckBox::get_value(BSTR * pv)
{
    return GetProps()[VALUE].Get(pv); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CCheckBox::put_value(BSTR v)
{
    return GetProps()[VALUE].Set(v); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CCheckBox::get_checked(VARIANT_BOOL * pv)
{
    return GetProps()[CHECKED].Get(pv);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CCheckBox::put_checked(VARIANT_BOOL v)
{
    return GetProps()[CHECKED].Set(v);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\cvariant.cxx ===
//=================================================
//
//  File : CVariant.cxx
//
//  purpose : implementation of a very usefull VARIANT wrapper class
//
//=================================================


#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "utils.hxx"

#ifndef X_DISPEX_H_
#define X_DISPEX_H_
#include <dispex.h>
#endif



// IEEE format specifies these...
// +Infinity: 7FF00000 00000000
// -Infinity: FFF00000 00000000
//       NAN: 7FF***** ********
//       NAN: FFF***** ********

// We also test for these, because the MSVC 1.52 CRT produces them for things
// like log(0)...
// +Infinity: 7FEFFFFF FFFFFFFF
// -Infinity: FFEFFFFF FFFFFFFF


// returns true for non-infinite nans.
int isNAN(double dbl)
{
    union
    {
        USHORT rgw[4];
        ULONG  rglu[2];
        double dbl;
    } v;

    v.dbl = dbl;

#ifdef BIG_ENDIAN
    return 0 == (~v.rgw[0] & 0x7FF0) &&
        ((v.rgw[0] & 0x000F) || v.rgw[1] || v.rglu[1]);
#else
    return 0 == (~v.rgw[3] & 0x7FF0) &&
        ((v.rgw[3] & 0x000F) || v.rgw[2] || v.rglu[0]);
#endif
}


// returns false for infinities and nans.
int isFinite(double dbl)
{
    union
    {
        USHORT rgw[4];
        ULONG rglu[2];
        double dbl;
    } v;

    v.dbl = dbl;

#ifdef BIG_ENDIAN
    return (~v.rgw[0] & 0x7FE0) ||
        0 == (v.rgw[0] & 0x0010) &&
        (~v.rglu[1] || ~v.rgw[1] || (~v.rgw[0] & 0x000F));
#else
    return (~v.rgw[3] & 0x7FE0) ||
        0 == (v.rgw[3] & 0x0010) &&
        (~v.rglu[0] || ~v.rgw[2] || (~v.rgw[3] & 0x000F));
#endif
}




//+---------------------------------------------------------------------------
//
//  Function:   VARIANTARGChangeTypeSpecial
//
//  Synopsis:   Helper.
//              Converts a VARIANT of arbitrary type to a VARIANT of type VT,
//              using browswer specific conversion rules, which may differ from
//              standard OLE Automation conversion rules (usually because
//              Netscape does something wierd).
//
//              This was pulled out of VARIANTARGToCVar because its also called
//              from CheckBox databinding.
//  
//  Arguments:  [pVArgDest]     -- Destination VARIANT (should already be init'd).
//              [vt]            -- Type to convert to.
//              [pvarg]         -- Variant to convert.
//              [pv]            -- Location to place C-language variable.
//
//  Modifies:   [pv].
//
//  Returns:    HRESULT.
//
//  History:    1-7-96  cfranks pulled out from VARIANTARGToCVar.
//
//----------------------------------------------------------------------------

HRESULT
VariantChangeTypeSpecial(VARIANT *pVArgDest, 
                         VARIANT *pvarg, 
                         VARTYPE vt,
                         IServiceProvider *pSrvProvider, 
                         WORD wFlags)
{
    HRESULT             hr;
    IVariantChangeType *pVarChangeType = NULL;

    if (pSrvProvider)
    {
        hr = pSrvProvider->QueryService(SID_VariantConversion,
                                            IID_IVariantChangeType,
                                            (void **)&pVarChangeType);
        if (hr)
            goto OldWay;

        // Use script engine conversion routine.
    	hr = pVarChangeType->ChangeType(pVArgDest, pvarg, 0, vt);
        if (!hr)
            goto Cleanup;   // ChangeType suceeded we're done...
    }

    // Fall back to our tried & trusted type coercions
OldWay:

    hr = S_OK;

    if (vt == VT_BSTR && V_VT(pvarg) == VT_NULL)
    {
        // Converting a NULL to BSTR
        V_VT(pVArgDest) = VT_BSTR;
        V_BSTR(pVArgDest) = SysAllocString( L"null");
        if (! V_BSTR(pVArgDest) )
            hr = E_OUTOFMEMORY;

        goto Cleanup;
    }
    else if (vt == VT_BSTR && V_VT(pvarg) == VT_EMPTY)
    {
        // Converting "undefined" to BSTR
        V_VT(pVArgDest) = VT_BSTR;
        V_BSTR(pVArgDest) = SysAllocString( L"undefined");
        if (! V_BSTR(pVArgDest) )
            hr = E_OUTOFMEMORY;

        goto Cleanup;
    }
    else if (vt == VT_BOOL && V_VT(pvarg) == VT_BSTR)
    {
        // Converting from BSTR to BOOL
        // To match Navigator compatibility empty strings implies false when
        // assigned to a boolean type any other string implies true.
        V_VT(pVArgDest) = VT_BOOL;
        V_BOOL(pVArgDest) = SysStringLen(V_BSTR(pvarg)) == 0 ? VB_FALSE : VB_TRUE;
        goto Cleanup;
    }
    else if (  V_VT(pvarg) == VT_BOOL && vt == VT_BSTR )
    {
        // Converting from BOOL to BSTR
        // To match Nav we either get "true" or "false"
        V_VT(pVArgDest) = VT_BSTR;
        V_BSTR(pVArgDest) = SysAllocString( V_BOOL(pvarg) == VB_TRUE ? L"true" : L"false");
        if (! V_BSTR(pVArgDest) )
            hr = E_OUTOFMEMORY;

        goto Cleanup;
    }
    // If we're converting R4 or R8 to a string then we need special handling to
    // map Nan and +/-Inf.
    else if (vt == VT_BSTR && (V_VT(pvarg) == VT_R8 || V_VT(pvarg) == VT_R4))
    {
        double  dblValue = V_VT(pvarg) == VT_R8 ? V_R8(pvarg) : (double)(V_R4(pvarg));

        // Infinity or NAN?
        if (!isFinite(dblValue))
        {
            if (isNAN(dblValue))
            {
                // NAN
                V_BSTR(pVArgDest) = SysAllocString(L"NaN");
                if (! V_BSTR(pVArgDest)) 
                    hr = E_OUTOFMEMORY;
            }
            else
            {
                // Infinity
                V_BSTR(pVArgDest) = SysAllocString((dblValue < 0) ? L"-Infinity" : L"Infinity" );
                if (! V_BSTR(pVArgDest)) 
                    hr = E_OUTOFMEMORY;
            }
        }
        else
            goto DefaultConvert;


        // Any error from allocating string?
        if (hr)
           goto Cleanup;

        V_VT(pVArgDest) = vt;
        goto Cleanup;
    }


DefaultConvert:
    //
    // Default VariantChangeTypeEx.
    //

    // VARIANT_NOUSEROVERRIDE flag is undocumented flag that tells OLEAUT to convert to the lcid
    // given. Without it the conversion is done to user localeid
    hr = VariantChangeTypeEx(pVArgDest, 
                             pvarg, 
                             LCID_SCRIPTING, 
                             wFlags|VARIANT_NOUSEROVERRIDE, 
                             vt);

    
    if (hr == DISP_E_TYPEMISMATCH  )
    {
        if ( V_VT(pvarg) == VT_NULL )
        {
            hr = S_OK;
            switch ( vt )
            {
            case VT_BOOL:
                V_BOOL(pVArgDest) = VB_FALSE;
                V_VT(pVArgDest) = VT_BOOL;
                break;

            // For NS compatability - NS treats NULL args as 0
            default:
                V_I4(pVArgDest)=0;
                break;
            }
        }
        else if (V_VT(pvarg) == VT_DISPATCH )
        {
            // Nav compatability - return the string [object] or null 
            V_VT(pVArgDest) = VT_BSTR;
            V_BSTR(pVArgDest) = SysAllocString ( (V_DISPATCH(pvarg)) ? L"[object]" : L"null");
            if (! V_BSTR(pVArgDest) )
                hr = E_OUTOFMEMORY;

        }
        else if ( V_VT(pvarg) == VT_BSTR && V_BSTRREF(pvarg)  &&
            ( (V_BSTR(pvarg))[0] == _T('\0')) && (  vt == VT_I4 || vt == VT_I2 || vt == VT_UI2 || vt == VT_UI4 || vt == VT_I8 ||
                vt == VT_UI8 || vt == VT_INT || vt == VT_UINT ) )
        {
            // Converting empty string to integer => Zero
            hr = S_OK;
            V_VT(pVArgDest) = vt;
            V_I4(pVArgDest) = 0;
            goto Cleanup;
        }    
    }
    else if (hr == DISP_E_OVERFLOW && vt == VT_I4 && (V_VT(pvarg) == VT_R8 || V_VT(pvarg) == VT_R4))
    {
        // Nav compatability - return MAXLONG on overflow
        V_VT(pVArgDest) = VT_I4;
        V_I4(pVArgDest) = MAXLONG;
        hr = S_OK;
        goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pVarChangeType);

    return hr ;
}



//+--------------------------------------------------------
//
//   Method : CVariant::CoerceVariantArg 
//
//  Synopsis : Coerce current variant into itself or 
//      Coerce pArgFrom into this instance from anyvariant 
//      to a given type
//
//+--------------------------------------------------------

HRESULT CVariant::CoerceVariantArg ( VARIANT *pArgFrom, WORD wCoerceToType)
{
    HRESULT hr = S_OK;
    VARIANT *pvar;

    if( V_VT(pArgFrom) == (VT_BYREF | VT_VARIANT) )
        pvar = V_VARIANTREF(pArgFrom);
    else
        pvar = pArgFrom;

    if ( !(pvar->vt == VT_EMPTY || pvar->vt == VT_ERROR ) )
    {
        hr = VariantChangeTypeSpecial ( (VARIANT *)this, 
                                    pvar,  
                                    wCoerceToType );
    }
    else
    {
        return S_FALSE;
    }

    return hr;
}

HRESULT CVariant::CoerceVariantArg (WORD wCoerceToType)
{
    HRESULT hr = S_OK;

    if ( !(vt == VT_EMPTY || vt == VT_ERROR ) )
    {
        hr = VariantChangeTypeSpecial ( (VARIANT *)this, 
                    (VARIANT *)this, wCoerceToType );
    }
    else
    {
        return S_FALSE;
    }

    return hr;
}


//+--------------------------------------------------------
//
//  Method : CVariant::CoerceNumericToI4 
//
//  Synopsis : Coerce any numeric (VT_I* or  VT_UI*) into a 
//      VT_I4 in this instance
//
//+--------------------------------------------------------
BOOL CVariant::CoerceNumericToI4 ()
{
    switch (vt)
    {
    case VT_I1:
    case VT_UI1:
        lVal = 0x000000FF & (DWORD)bVal;
        break;
    
    case VT_UI2:
    case VT_I2:
        lVal = 0x0000FFFF & (DWORD)iVal;
        break;
    
    case VT_UI4:
    case VT_I4:
    case VT_INT: 
    case VT_UINT:
        break;

    case VT_R8:
        lVal = (LONG)dblVal;
        break;

    case VT_R4:
        lVal = (LONG)fltVal;
        break;

    default:
        return FALSE;
    }

    vt = VT_I4;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\headers.h ===
// headers.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__7E8BC444_AEFF_11D1_89C2_00C04FB6BFC4__INCLUDED_)
#define AFX_STDAFX_H__7E8BC444_AEFF_11D1_89C2_00C04FB6BFC4__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// Define the ATL specific macros to get the right set of things
#define _USRDLL

#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#ifndef _ATL_STATIC_REGISTRY
#define _ATL_STATIC_REGISTRY
#endif

#ifndef _ATL_NO_SECURITY
#define _ATL_NO_SECURITY
#endif

// link minimally only in ship mode
#if defined(NOT_NT)
#if DBG != 1
#ifndef _ATL_MIN_CRT
#define _ATL_MIN_CRT
#endif
#endif
#endif

// Map KERNEL32 unicode string functions to SHLWAPI
// This is needed way up here.
#define lstrcmpW    StrCmpW
#define lstrcmpiW   StrCmpIW
#define lstrcpyW    StrCpyW
#define lstrcpynW   StrCpyNW
#define lstrcatW    StrCatW

// Define our own SHGetFolderPathA which will use shell32.dll uplevel and
// shfolder.dll downlevel
#define SHGetFolderPathA DLSHGetFolderPathA


#ifndef X_SHLWRAP_H_
#define X_SHLWRAP_H_
#include "shlwrap.h"
#endif

#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>
#include <atlctl.h>

#include <shlwapi.h>
#include <shlwapip.h>
#include <wininet.h>
#include <winineti.h>
#include <urlmon.h>
#include <mshtml.h>
#include <mshtmdid.h>

// We don't want to have these prototypes declared with __declspec(dllimport)
#define _SHFOLDER_
#include "shlobj.h"
#include "shfolder.h"
#undef _SHFOLDER_



// Internal functions
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);

#define Assert _ASSERTE

#define ARRAY_SIZE(p)    (sizeof(p)/sizeof(p[0]))

void * MemAllocClear(size_t cb);

#define DECLARE_MEMCLEAR_NEW \
    inline void * __cdecl operator new(size_t cb) { return(MemAllocClear(cb)); } \
    inline void * __cdecl operator new[](size_t cb) { return(MemAllocClear(cb)); }

// Global variables
extern HINSTANCE   g_hInst;
extern BOOL        g_fUnicodePlatform;
extern DWORD       g_dwPlatformVersion;            // (dwMajorVersion << 16) + (dwMinorVersion)
extern DWORD       g_dwPlatformID;                 // VER_PLATFORM_WIN32S/WIN32_WINDOWS/WIN32_WINNT
extern DWORD       g_dwPlatformBuild;              // Build number
extern BOOL        g_fUseShell32InsteadOfSHFolder;

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#ifdef UNIX
#ifndef _LPCBYTE_DEFINED
#define _LPCBYTE_DEFINED
typedef const BYTE *LPCBYTE;
#endif
#endif // UNIX

// include conditional code segment pragma definitions
#include "..\src\core\include\markcode.hxx"

#endif // !defined(AFX_STDAFX_H__7E8BC444_AEFF_11D1_89C2_00C04FB6BFC4__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\download.cxx ===
// ClientCaps.cpp : Implementation of CClientCaps
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "iextag.h"

#include "utils.hxx"

#include "download.h"

/////////////////////////////////////////////////////////////////////////////
//
// CDownload
//
/////////////////////////////////////////////////////////////////////////////

CDownload::~CDownload()
{
    ReleaseInterface (_pdispCallback);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CDownload::Download(
    BSTR        bstrURL,
    IDispatch * pdispCallback,
    IUnknown *  pUnkContainer)
{
    HRESULT                 hr;
    CComObject<CDownload> * pDownload;

    hr = CComObject<CDownload>::CreateInstance(&pDownload);
    if (hr)
        goto Cleanup;

    pDownload->_pdispCallback = pdispCallback;
    pdispCallback->AddRef();

    pDownload->StartAsyncDownload(NULL, NULL, bstrURL, pUnkContainer, TRUE);
    // hr can now be S_OK, S_ASYNC, or failure

    // ignore hr
#if 0
    if (FAILED(hr))
    {
        hr = InvokeCallback(NULL, pdispCallback);
    }
#endif

Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// the implementation is similar to CBindStatusCallback::OnDataAvailable,
//  except it waits for the last chunk of data and only then calls OnFinalDataAvailable

HRESULT
CDownload::OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pformatetc, STGMEDIUM *pstgmed)
{
    HRESULT             hr = S_OK;
    DWORD               dwActuallyRead;
    BYTE *              pBytes = NULL;
    CComPtr<IStream>    pStream;

    ATLTRACE(_T("CBindStatusCallback::OnDataAvailable\n"));

    if (!(BSCF_LASTDATANOTIFICATION & grfBSCF))
        goto Cleanup;

    ATLTRACE(_T("CBindStatusCallback::OnDataAvailable FINAL\n"));

    if (pstgmed->tymed != TYMED_ISTREAM)
        goto Cleanup;

    pStream = pstgmed->pstm;
    if (!pStream)
        goto Cleanup;

    pBytes = new BYTE[dwSize + 1];
    if (pBytes == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pStream->Read(pBytes, dwSize, &dwActuallyRead);
    if (hr)
        goto Cleanup;

    pBytes[dwActuallyRead] = 0;
    if (0 < dwActuallyRead)
    {
        OnFinalDataAvailable(pBytes, dwActuallyRead);
    }

Cleanup:
    delete[] pBytes;

    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////

void
CDownload::OnFinalDataAvailable (BYTE * pBytes, DWORD dwSize)
{
    LPTSTR      pchString = NULL;
    ULONG       cchString;

    //
    // get unicode string
    //

    // get length
    cchString = MultiByteToWideChar(CP_ACP, 0, (LPSTR) pBytes, dwSize, NULL, 0);
    if (!cchString)
        goto Cleanup;

    pchString = new TCHAR[cchString + 1];
    if (!pchString)
        goto Cleanup;

    // convert now
    MultiByteToWideChar(CP_ACP, 0, (LPSTR) pBytes, dwSize, pchString, cchString);
    pchString[cchString] = 0;

    //
    // invoke the callback function
    //

    InvokeCallback(pchString, _pdispCallback);

Cleanup:
    ClearInterface (&_pdispCallback);

    delete pchString;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////

HRESULT
CDownload::InvokeCallback(LPTSTR pchString, IDispatch * pdispCallback)
{
    HRESULT     hr = S_OK;

    if (pdispCallback)
    {
        VARIANT     varArg;
        DISPPARAMS  dispparams = {&varArg, NULL, 1, 0};
        EXCEPINFO   excepinfo;
        UINT        nArgErr;

        if (pchString)
        {
            V_VT(&varArg) = VT_BSTR;
            V_BSTR(&varArg) = SysAllocString(pchString);
            if (!V_BSTR(&varArg))
                return E_OUTOFMEMORY;
        }
        else
        {
            V_VT(&varArg) = VT_NULL;
        }

        hr = pdispCallback->Invoke(
            DISPID_VALUE, IID_NULL, LOCALE_SYSTEM_DEFAULT,
            DISPATCH_METHOD, &dispparams, NULL, &excepinfo, &nArgErr);
        SysFreeString(V_BSTR(&varArg));
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CDownloadBehavior
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////

CDownloadBehavior::CDownloadBehavior()
{
    memset (this, 0, sizeof(*this));
}

/////////////////////////////////////////////////////////////////////////////

CDownloadBehavior::~CDownloadBehavior()
{
    ReleaseInterface(_pSite);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CDownloadBehavior::Init(IElementBehaviorSite *pSite)
{
    if (!pSite)
        return E_INVALIDARG;

    _pSite = pSite;
    _pSite->AddRef();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CDownloadBehavior::Notify(LONG lEvent, VARIANT * pVarNotify)
{
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CDownloadBehavior::startDownload(BSTR bstrUrl, IDispatch * pdispCallback)
{
    HRESULT hr;

    if (!bstrUrl || !pdispCallback)
        return E_INVALIDARG;

    if (!AccessAllowed(bstrUrl, _pSite))
        return E_ACCESSDENIED;

    hr = CDownload::Download(bstrUrl, pdispCallback, _pSite);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\combobox.cxx ===
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "iextag.h"

#include "utils.hxx"

#include "combobox.hxx"


/////////////////////////////////////////////////////////////////////////////
//
// CCombobox
//
/////////////////////////////////////////////////////////////////////////////
const CBaseCtl::PROPDESC CCombobox::s_propdesc[] = 
{
    {_T("value"), VT_BSTR},
    NULL
};

enum
{
    VALUE     = 0
};
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Members:    CCombobox::CCombobox
//              CCombobox::~CCombobox
//
//  Synopsis:   Constructor/destructor
//
//-------------------------------------------------------------------------

CCombobox::CCombobox()
{
}

CCombobox::~CCombobox()
{
    int i;

    if (m_pSink)
        delete m_pSink;

    if (_pSinkBody)
    {
        delete _pSinkBody;
    }

    for (i = 0; i < 2; i++)
    {
        if (_apSinkElem[i])
        {
            delete _apSinkElem[i];
        }
    }
}

HRESULT
CCombobox::Detach()
{
    if (_pPrimaryMarkup)
    {
        _pPrimaryMarkup->Release();
    }
    if (m_pHTMLPopup)
        m_pHTMLPopup->Release();

    return S_OK;
}

HRESULT
CCombobox::Init()
{
    HRESULT         hr          = S_OK;
    BSTR            bstrEvent   = NULL;
    VARIANT_BOOL    vSuccess    = VARIANT_FALSE;
    CContextAccess  a(_pSite);

    hr = a.Open(CA_ELEM | CA_ELEM2);
    if (hr)
        goto Cleanup;

    // this puppy is ref counted when used.
    m_pSink = new CEventSink (this);

    if (!m_pSink)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // we want to sink a few events.
    //

    bstrEvent = SysAllocString (L"onclick");
    if (!bstrEvent)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    a.Elem2()->attachEvent (bstrEvent, (IDispatch *) m_pSink, &vSuccess);
    if (vSuccess == VARIANT_TRUE)
    {
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }


Cleanup:
    if (bstrEvent)
    {
        SysFreeString(bstrEvent);
    }

    return hr;
}

HRESULT
CCombobox::put_value(BSTR v)
{
    return GetProps()[VALUE].Set(v);
}

HRESULT
CCombobox::get_value(BSTR * pv)
{
    return GetProps()[VALUE].Get(pv);
}

//+------------------------------------------------------------------------
//
//  Member:     CCombobox::ProcOnClick
//
//  Synopsis:   Handles the onclick events.
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CCombobox::ProcOnClick (CEventSink *pSink)
{
    HRESULT hr = S_OK;
    long    lElemLeft, lElemTop, lElemWidth, lElemHeight;

    IHTMLDocument    *pDoc = NULL;

    IMarkupServices  *pMarkupSrv = NULL;
    IMarkupPointer   *pMarkupPStart = NULL;
    IMarkupPointer   *pMarkupPEnd = NULL;
    IHTMLElement     *pHtml = NULL;
    IHTMLElement     *pBody = NULL;
    IHTMLElement     *pElem = NULL;
    IHTMLElement2    *pElem2 = NULL;
    BSTR              bstrEvent   = NULL;
    VARIANT_BOOL      vSuccess    = VARIANT_FALSE;
    IDispatch        *pDocMain = NULL;
    IOleWindow       *pIOleWnd = NULL;
    HWND              hwndMain;
    RECT              rcClient;

    CContextAccess    a(_pSite);

    hr = a.Open(CA_ELEM);
    if (hr)
        goto Cleanup;

    // VARIANT         var;

    // var.vt == VT_EMPTY;


    if (pSink != m_pSink)
    {
        Assert(m_pHTMLPopup);
        if (pSink == _apSinkElem[0])
        {
            a.Elem()->put_innerText(_T("test1"));
        }
        else
        {
            a.Elem()->put_innerText(_T("test2"));
        }
        m_pHTMLPopup->hide();
        return hr;
    }

    // ISSUE: hr?
    a.Elem()->get_offsetLeft(&lElemLeft);
    a.Elem()->get_offsetTop(&lElemTop);
    a.Elem()->get_offsetWidth(&lElemWidth);
    a.Elem()->get_offsetHeight(&lElemHeight);

    // get the current main doc window location

    // ISSUE: hr?
    a.Elem()->get_document(&pDocMain);

    // get the oleWindow
    hr = pDocMain->QueryInterface(IID_IOleWindow, (void **)&pIOleWnd);

    if (FAILED(hr))
        goto Cleanup;

    pDocMain->Release();

    // this window can be cached
    hr = pIOleWnd->GetWindow(&hwndMain);
    hr = S_OK;

    GetWindowRect(hwndMain, &rcClient);

    lElemTop    = lElemTop + lElemHeight + rcClient.top;
    lElemLeft   = lElemLeft + rcClient.left;

    pIOleWnd->Release();

    if (m_pHTMLPopup)
    {

        //
        // we have the popup
        // just make sure it shows up
        // show it modal
        //

        /*
        hr = m_pHTMLPopup->show(a.Elem(),
                                lElemLeft, lElemTop,
                                lElemWidth, 100,
                                VARIANT_TRUE);
        */

        return hr;
    }

    //
    // create a popup window
    // if there is no window yet
    //

    hr = CoCreateInstance(CLSID_HTMLPopup,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IHTMLPopup,
                              (void **) &m_pHTMLPopup);

    if (FAILED(hr))
        return hr;

    //
    // create elements in the popup doc
    //

    // hr = m_pHTMLPopup->getDoc(&pDoc);
    hr = m_pHTMLPopup->get_document(&pDoc);

    if (FAILED(hr))
        goto Cleanup;

    //
    // get the markup services interface from the doc
    // so that we can construct a markup tree
    //


    hr = pDoc->QueryInterface(IID_IMarkupServices, (void **)&pMarkupSrv);
    if (FAILED(hr))
        goto Cleanup;

    hr = pDoc->QueryInterface(IID_IMarkupContainer, (void **)&_pPrimaryMarkup);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupSrv->CreateMarkupPointer(&pMarkupPStart);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupSrv->CreateMarkupPointer(&pMarkupPEnd);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupPStart->MoveToContainer(_pPrimaryMarkup, TRUE);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupPEnd->MoveToContainer(_pPrimaryMarkup, FALSE);
    if (FAILED(hr))
        goto Cleanup;

#define METHOD1 1

//
//  ISSUE : METHOD 2 crashes in CHtmInfo::Init
//

#ifdef  METHOD2
    hr = pMarkupSrv->ParseString(_T("<HTML><BODY><INPUT></BODY></HTML>"),
                                0,
                                &_pPrimaryMarkup, pMarkupPStart, pMarkupPEnd);
    if (FAILED(hr))
        goto Cleanup;

    ReleaseInterface(pMarkupSrv);
    ReleaseInterface(pMarkupPStart);
    ReleaseInterface(pMarkupPEnd);
#endif

    //
    //  this is the prefered method of creating the content of the popup
    //

#ifdef  METHOD1
    hr = pMarkupSrv->CreateElement(TAGID_HTML, 0, &pHtml);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupSrv->InsertElement(pHtml, pMarkupPStart, pMarkupPEnd);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupSrv->CreateElement(TAGID_BODY,
                                   _T("style='border:solid 1;overflow:hidden'"),
                                   &pBody);
    if (FAILED(hr))
        goto Cleanup;

    pMarkupPStart->MoveAdjacentToElement(pHtml, ELEM_ADJ_AfterBegin);
    if (FAILED(hr))
        goto Cleanup;

    pMarkupPEnd->MoveAdjacentToElement(pHtml, ELEM_ADJ_BeforeEnd);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupSrv->InsertElement(pBody, pMarkupPStart, pMarkupPEnd);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupSrv->CreateElement( TAGID_INPUT,
                                    _T("type=checkbox value='text1' \
                                        style='width:100%;border:0;background:white' \
                                    "),
                                    &pElem);
    if (FAILED(hr))
        goto Cleanup;

    pMarkupPStart->MoveAdjacentToElement(pBody, ELEM_ADJ_AfterBegin);
    if (FAILED(hr))
        goto Cleanup;

    pMarkupPEnd->MoveAdjacentToElement(pBody, ELEM_ADJ_BeforeEnd);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupSrv->InsertElement(pElem, pMarkupPStart, pMarkupPEnd);
    if (FAILED(hr))
        goto Cleanup;

    pMarkupPStart->MoveAdjacentToElement(pElem, ELEM_ADJ_AfterEnd);
    if (FAILED(hr))
        goto Cleanup;

    bstrEvent = SysAllocString (L"onclick");
    if (!bstrEvent)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pElem->QueryInterface(IID_IHTMLElement2, (void **)&pElem2);
    if (FAILED(hr))
        goto Cleanup;

    _apSinkElem[0] = new CEventSink (this);

    if (!_apSinkElem[0])
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pElem2->attachEvent (bstrEvent, (IDispatch *) _apSinkElem[0], &vSuccess);
    if (vSuccess == VARIANT_TRUE)
    {
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    ReleaseInterface(pElem2);
    pElem2 = NULL;
    ReleaseInterface(pElem);
    pElem = NULL;


    hr = pMarkupSrv->CreateElement( TAGID_INPUT,
                                    _T("type=button value='text2' \
                                        style='width:100%;border:0;background:white' \
                                    "),
                                    &pElem);
    if (FAILED(hr))
        goto Cleanup;

    pMarkupPEnd->MoveAdjacentToElement(pBody, ELEM_ADJ_BeforeEnd);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupSrv->InsertElement(pElem, pMarkupPStart, pMarkupPEnd);
    if (FAILED(hr))
        goto Cleanup;

    hr = pElem->QueryInterface(IID_IHTMLElement2, (void **)&pElem2);
    if (FAILED(hr))
        goto Cleanup;

    _apSinkElem[1] = new CEventSink (this);

    if (!_apSinkElem[1])
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pElem2->attachEvent (bstrEvent, (IDispatch *) _apSinkElem[1], &vSuccess);
    if (vSuccess == VARIANT_TRUE)
    {
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
        goto Cleanup;
    }
#endif

    //
    // position the window just under the element
    // not supported due to a pdlparser problem
    //

#ifdef  METHOD3
    var.vt = VT_BSTR;
    var.bstrVal = _T("file://c:\\toto.htm");
#endif

/*
    hr = m_pHTMLPopup->show(a.Elem(),
                            lElemLeft, lElemTop,
                            lElemWidth, 100,
                            VARIANT_TRUE);

    if (FAILED(hr))
        goto Cleanup;
*/

Cleanup:
    if (pDoc)
    {
        pDoc->Release();
    }
    if (bstrEvent)
    {
        SysFreeString(bstrEvent);
    }

    ReleaseInterface(pElem2);
    ReleaseInterface(pElem);
    ReleaseInterface(pMarkupSrv);
    ReleaseInterface(pMarkupPStart);
    ReleaseInterface(pMarkupPEnd);
    ReleaseInterface(pBody);
    ReleaseInterface(pHtml);

    return hr;
}

// ========================================================================
// CEventSink::IDispatch
// ========================================================================

// The event sink's IDispatch interface is what gets called when events
// are fired.

//+------------------------------------------------------------------------
//
//  Member:     CCombobox::CEventSink::GetTypeInfoCount
//              CCombobox::CEventSink::GetTypeInfo
//              CCombobox::CEventSink::GetIDsOfNames
//
//  Synopsis:   We don't really need a nice IDispatch... this minimalist
//              version does just plenty.
//
//-------------------------------------------------------------------------

STDMETHODIMP
CCombobox::CEventSink::GetTypeInfoCount(UINT* /*pctinfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CCombobox::CEventSink::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
                                   /* [in] */ LCID /*lcid*/,
                                   /* [out] */ ITypeInfo** /*ppTInfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CCombobox::CEventSink::GetIDsOfNames( REFIID          riid,
                                         OLECHAR**       rgszNames,
                                         UINT            cNames,
                                         LCID            lcid,
                                         DISPID*         rgDispId)
{
    return E_NOTIMPL;
}

//+------------------------------------------------------------------------
//
//  Member:     CCombobox::CEventSink::Invoke
//
//  Synopsis:   This gets called for all events on our object.  (it was
//              registered to do so in Init with attach_event.)  It calls
//              the appropriate parent functions to handle the events.
//
//-------------------------------------------------------------------------
STDMETHODIMP
CCombobox::CEventSink::Invoke( DISPID dispIdMember,
                                  REFIID, LCID,
                                  WORD wFlags,
                                  DISPPARAMS* pDispParams,
                                  VARIANT* pVarResult,
                                  EXCEPINFO*,
                                  UINT* puArgErr)
{
    HRESULT hr = TRUE;
    if (m_pParent && pDispParams && pDispParams->cArgs>=1)
    {
        if (pDispParams->rgvarg[0].vt == VT_DISPATCH)
        {
            IHTMLEventObj *pObj=NULL;

            if (SUCCEEDED(pDispParams->rgvarg[0].pdispVal->QueryInterface(IID_IHTMLEventObj,
                (void **)&pObj) && pObj))
            {
                BSTR bstrEvent=NULL;

                pObj->get_type(&bstrEvent);

                // user clicked one of our anchors
                if (! StrCmpICW (bstrEvent, L"click"))
                {
                    hr = m_pParent->ProcOnClick(this);
                }

                pObj->Release();
            }
        }
    }

    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CCombobox::CEventSink
//
//  Synopsis:   This is used to allow communication between the parent class
//              and the event sink class.  The event sink will call the ProcOn*
//              methods on the parent at the appropriate times.
//
//-------------------------------------------------------------------------

CCombobox::CEventSink::CEventSink (CCombobox * pParent)
{
    m_pParent = pParent;
}

// ========================================================================
// CEventSink::IUnknown
// ========================================================================

// Vanilla IUnknown implementation for the event sink.

STDMETHODIMP
CCombobox::CEventSink::QueryInterface(REFIID riid, void ** ppUnk)
{
    void * pUnk = NULL;

    if (riid == IID_IDispatch)
        pUnk = (IDispatch *) this;

    if (riid == IID_IUnknown)
        pUnk = (IUnknown *) this;

    if (pUnk)
    {
        *ppUnk = pUnk;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
CCombobox::CEventSink::AddRef(void)
{
    return ((IElementBehavior *)m_pParent)->AddRef();
}

STDMETHODIMP_(ULONG)
CCombobox::CEventSink::Release(void)
{
    return ((IElementBehavior *)m_pParent)->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\download.h ===
#ifndef __DOWNLOAD_H_
#define __DOWNLOAD_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
//
// CDownloadBehavior
//
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CDownloadBehavior : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDownloadBehavior, &CLSID_CDownloadBehavior>,
    public IDispatchImpl<IDownloadBehavior, &IID_IDownloadBehavior, &LIBID_IEXTagLib>,

    public IElementBehavior
{
public:

    //
    // methods
    //

    CDownloadBehavior ();
    ~CDownloadBehavior ();

    //
    // IElementBehavior
    //

    STDMETHOD(Init)(IElementBehaviorSite *pSite);
    STDMETHOD(Notify)(LONG lEvent, VARIANT * pVarNotify);
    STDMETHOD(Detach)() { return S_OK; };

    //
    // IDownloadBehavior
    //

    STDMETHOD(startDownload)(BSTR bstrUrl, IDispatch * pdispCallback);

    //
    // wiring
    //

DECLARE_REGISTRY_RESOURCEID(IDR_DOWNLOADBEHAVIOR)
DECLARE_NOT_AGGREGATABLE(CDownloadBehavior)

BEGIN_COM_MAP(CDownloadBehavior)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IElementBehavior)
    COM_INTERFACE_ENTRY(IDownloadBehavior)
END_COM_MAP()

    //
    // data
    //

    IElementBehaviorSite *  _pSite;
};

/////////////////////////////////////////////////////////////////////////////
//
// CDownload
//
/////////////////////////////////////////////////////////////////////////////

class CDownload : public CBindStatusCallback<CDownloadBehavior>
{
public:

    //
    // methods
    //

    ~CDownload();

    static HRESULT Download(BSTR bstrURL, IDispatch * pdispCallback, IUnknown * pUnkContainer);

    STDMETHOD(OnDataAvailable)(DWORD grfBSCF, DWORD dwSize, FORMATETC *pformatetc, STGMEDIUM *pstgmed);

    void OnFinalDataAvailable (BYTE * pBytes, DWORD dwSize);

    static HRESULT InvokeCallback(LPTSTR pchString, IDispatch * pdispCallback);

    //
    // data
    //

    IDispatch *     _pdispCallback;
};

#endif // __DOWNLOAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\devicerect.cxx ===
//===============================================================
//
//  devicerect.cxx : Implementation of the CDeviceRect Peer
//
//  Synposis : this behavior enables WYSIWYG layout on an element
//
//===============================================================
                                                              
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef __X_IEXTAG_H_
#define __X_IEXTAG_H_
#include "iextag.h"
#endif

#ifndef __X_DEVICERECT_HXX_
#define __X_DEVICERECT_HXX_
#include "devicerect.hxx"
#endif

#include <docobj.h>

#include <mshtmhst.h>

#include <mshtmcid.h>

//
// GUID and DISPID for private command
//

// define GUID right here
#undef DEFINE_GUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID DECLSPEC_SELECTANY name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
                
// GUID for private command group in CProtectedElement::Exec
DEFINE_GUID(CGID_ProtectedElementPrivate, 0x3050f6dd, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

#define IDM_ELEMENTP_SETREFERENCEMEDIA   7002   // set media on element

//+----------------------------------------------------------------------------
//
//  Member : CDeviceRect constructor
//
//-----------------------------------------------------------------------------
CDeviceRect::CDeviceRect()
{
    memset(this, 0, sizeof(CDeviceRect));

    // Other _hpi members are init'ed to zero by memset above
    _hpi.lFlags        = HTMLPAINTER_TRANSPARENT|HTMLPAINTER_HITTEST|HTMLPAINTER_NOSAVEDC|HTMLPAINTER_NOPHYSICALCLIP|HTMLPAINTER_SUPPORTS_XFORM;
    _hpi.lZOrder       = HTMLPAINT_ZORDER_ABOVE_CONTENT;
}

//+----------------------------------------------------------------------------
//
//  Member : Detach - IElementBehavior method impl
//
//  Synopsis : when the peer is detatched, we will take this oppurtunity 
//      to release our various cached pointers.
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CDeviceRect::Detach() 
{ 
    return S_OK; 
}

//+----------------------------------------------------------------------------
//
//  Member : Init - IElementBehavior method impl
//
//  Synopsis : this method is called by MSHTML.dll to initialize peer object.
//      this is where we do all the connection and peer management work.
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CDeviceRect::Init(IElementBehaviorSite * pPeerSite)
{
    HRESULT hr = S_OK;
    IHTMLElement            * pElem     = NULL;
    IElementBehaviorSiteOM2 * pIBS2     = NULL;
    IHTMLElementDefaults    * pIPThis   = NULL;
    IOleCommandTarget       * pOCT      = NULL;
    
    mediaType media = mediaTypeNotSet;
    CVariant varMedia;
    VARIANT varRet;

    if (!pPeerSite)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // get media setting
    hr = pPeerSite->GetElement(&pElem);
    if (hr)
        goto Cleanup;
        
    hr = pElem->getAttribute(_T("media"), 0, &varMedia);
    if (hr)
        goto Cleanup;

    // parse media value
    if (varMedia.bstrVal && 0 == _tcsicmp(_T("print"), varMedia.bstrVal))
    {
        media = mediaTypePrint;
    }
    else
    {
        // do nothing if media is not "print". No other medias ar currently supported
        goto Cleanup;
    }

    // get element defaults
    hr = pPeerSite->QueryInterface(IID_IElementBehaviorSiteOM2, (void**)&pIBS2);
    if (FAILED(hr))
        goto Cleanup;

    hr = pIBS2->GetDefaults(&pIPThis);
    if (FAILED(hr))
        goto Cleanup;

    // get commant target interface
    hr = pIPThis->QueryInterface(IID_IOleCommandTarget, (void**)&pOCT);
    if (FAILED(hr))
        goto Cleanup;

    // set reference media
    hr = pOCT->Exec((GUID *)&CGID_ProtectedElementPrivate, 
                    IDM_ELEMENTP_SETREFERENCEMEDIA,
                    media,
                    NULL, &varRet);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pElem);
    ReleaseInterface(pIPThis);
    ReleaseInterface(pIBS2);
    ReleaseInterface(pOCT);
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member : Notify - IElementBehavior method impl
//
//  Synopsis : peer Interface, called for notification of document events.
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CDeviceRect::Notify(LONG lEvent, VARIANT *pvar)
{
    return S_OK;
}

//+-----------------------------------------------------------------------------
//
//  Method: Draw, IHTMLPainter
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDeviceRect::Draw(RECT rcBounds, RECT rcUpdate, LONG lDrawFlags, HDC hdc,
                         LPVOID pvDrawObject)
{
    return E_NOTIMPL;
}

//+-----------------------------------------------------------------------------
//
//  Method: GetRenderInfo, IHTMLPainter
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDeviceRect::GetPainterInfo(HTML_PAINTER_INFO * pInfo)
{
    Assert(pInfo != NULL);

    *pInfo = _hpi;

    return S_OK;
}


//+-----------------------------------------------------------------------------
//
//  Method: HitTestPoint, IHTMLPainter
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDeviceRect::HitTestPoint(POINT pt, BOOL * pbHit, LONG *plPartID)
{
    Assert(pbHit != NULL);

    *pbHit = TRUE;

    return S_OK;
}

//+-----------------------------------------------------------------------------
//
//  Method: OnResize, IHTMLPainter
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDeviceRect::OnResize(SIZE size)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\homepg.cxx ===
// homepg.cxx : Implementation of CHomePage
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "iextag.h"
#include "homepg.h"
#include "shlwapi.h"
#include "inetreg.h"
#include "wininet.h"
#include "urlmon.h"
#include "resource.h"
#include "shfusion.h"

/////////////////////////////////////////////////////////////////////////////
// CHomePage

STDMETHODIMP CHomePage::Init(IElementBehaviorSite *pSite)
{
    HRESULT hr = E_INVALIDARG;

    if (pSite != NULL)
    {
        m_pSite = pSite;
        m_pSite->AddRef();
        hr = S_OK;
    }

    return hr;  
}

STDMETHODIMP CHomePage::Notify(LONG lNotify, VARIANT * pVarNotify)
{
    return S_OK;
}

// Helper functions for internal use only
STDMETHODIMP CHomePage::GetWindow(HWND *phWnd)
{
    HRESULT hr = E_FAIL;
    IWindowForBindingUI *pWindowForBindingUI = NULL;

    if (m_pSite != NULL) {

        // Get IWindowForBindingUI ptr
        hr = m_pSite->QueryInterface(IID_IWindowForBindingUI,
                (LPVOID *)&pWindowForBindingUI);

        if (FAILED(hr)) {
            IServiceProvider *pServProv;
            hr = m_pSite->QueryInterface(IID_IServiceProvider, (LPVOID *)&pServProv);

            if (hr == NOERROR) {
                pServProv->QueryService(IID_IWindowForBindingUI,IID_IWindowForBindingUI,
                    (LPVOID *)&pWindowForBindingUI);
                pServProv->Release();
            }
        }

        if (pWindowForBindingUI) {
            pWindowForBindingUI->GetWindow(IID_IWindowForBindingUI, phWnd);
            pWindowForBindingUI->Release();
        }
    }

    return hr;
}

STDMETHODIMP CHomePage::GetHTMLDocument(IHTMLDocument2 **ppDoc)
{
    HRESULT hr = E_FAIL;

    if (m_pSite != NULL)
    {
        IHTMLElement *pElement = NULL;
        hr = m_pSite->GetElement(&pElement);
        if (SUCCEEDED(hr))
        {
            IDispatch * pDispDoc = NULL;
            hr = pElement->get_document(&pDispDoc);
            if (SUCCEEDED(hr))
            {
                hr = pDispDoc->QueryInterface(IID_IHTMLDocument2, (void **)ppDoc);
                pDispDoc->Release();
            }
            pElement->Release();
        }
    }

    return hr;
}


STDMETHODIMP CHomePage::GetHTMLWindow(IHTMLWindow2 **ppWindow)
{
    HRESULT hr = E_FAIL;
    IHTMLDocument2 *pDoc = NULL;

    hr = GetHTMLDocument(&pDoc);

    if (SUCCEEDED(hr))
    {
        hr = pDoc->get_parentWindow(ppWindow);
        pDoc->Release();
    }

    return hr;
}

STDMETHODIMP CHomePage::IsSameSecurityID(IInternetSecurityManager *pISM, BSTR bstrURL, BSTR bstrDocBase)
{
    HRESULT hrRet = S_FALSE;
    HRESULT hr = S_OK;
    BYTE pbSecIdURL[INTERNET_MAX_URL_LENGTH];
    BYTE pbSecIdDocBase[INTERNET_MAX_URL_LENGTH];
    DWORD dwSecIdURL = INTERNET_MAX_URL_LENGTH, dwSecIdDocBase = INTERNET_MAX_URL_LENGTH;

    hr = pISM->GetSecurityId(bstrDocBase, pbSecIdDocBase, &dwSecIdDocBase, 0);

    _ASSERTE(hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));

    if (SUCCEEDED(hr)) {

        hr = pISM->GetSecurityId(bstrURL, pbSecIdURL, &dwSecIdURL, 0);
        _ASSERTE(hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));

        if (SUCCEEDED(hr)) {

            if ((dwSecIdURL == dwSecIdDocBase) &&
                (memcmp(pbSecIdURL, pbSecIdDocBase, dwSecIdURL) == 0)) {

                hrRet = S_OK;
            }
        }
    }

    return hrRet;
}

STDMETHODIMP CHomePage::IsAuthorized(BSTR bstrURL)
{
    HRESULT hr = E_FAIL;
    IHTMLDocument2 *pDoc = NULL;
    BSTR bstrDocBase = NULL;
    IInternetSecurityManager *pISM = NULL;

    hr = GetHTMLDocument(&pDoc);

    if (SUCCEEDED(hr))
    {
        hr = pDoc->get_URL(&bstrDocBase);

        if (SUCCEEDED(hr)) {
            if (SUCCEEDED(hr = CoCreateInstance(CLSID_InternetSecurityManager, NULL, CLSCTX_INPROC_SERVER,
                IID_IInternetSecurityManager, (void **)&pISM))) {


                hr = IsSameSecurityID(pISM, bstrURL, bstrDocBase);
                pISM->Release();
            }

            SysFreeString(bstrDocBase);
        }

        pDoc->Release();
    }

    return SUCCEEDED(hr)?hr:S_FALSE;
}


STDMETHODIMP CHomePage::SetUserHomePage(LPCSTR szURL)
{
    HRESULT hr = S_OK;
    LONG    lResult = ERROR_SUCCESS;
    HKEY    hKey    = NULL;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_MAIN, 0, KEY_SET_VALUE, &hKey) == ERROR_SUCCESS)
    {
        if (((lResult = RegSetValueExA (hKey, REGSTRA_VAL_STARTPAGE, 0, REG_SZ,
                (LPCBYTE)szURL, lstrlenA(szURL)+1))) != ERROR_SUCCESS) {

            hr = HRESULT_FROM_WIN32(lResult);
        }
    }

    if (hKey)
        RegCloseKey(hKey);

    return FAILED(hr)?S_FALSE:hr;
}

STDMETHODIMP CHomePage::GetHomePage(BSTR& bstrURL, BSTR& bstrName)
{
    LPWSTR pwszName = L"_top";
    HRESULT hr = E_FAIL;
    WCHAR wszHomePage[INTERNET_MAX_URL_LENGTH];
    DWORD dwType;
    DWORD dwSize = INTERNET_MAX_URL_LENGTH;

    if (SHRegGetUSValueW(REGSTR_PATH_MAIN, 
                        REGSTR_VAL_STARTPAGE, 
                        &dwType, 
                        wszHomePage, 
                        &dwSize, 
                        0, NULL, 0) == ERROR_SUCCESS) 
    {
        bstrURL = SysAllocString(wszHomePage);
    }

    bstrName = SysAllocString(pwszName);

    return (bstrName && bstrURL) ? S_OK : E_FAIL;
}

STDMETHODIMP CHomePage::setHomePage(BSTR bstrURL)
{
    HRESULT hr = S_FALSE;
    char szMsgTitle[MAX_PATH];
    char szMsgFormat[INTERNET_MAX_URL_LENGTH];
    char szURL[INTERNET_MAX_URL_LENGTH];
    char szPageTitle[INTERNET_MAX_URL_LENGTH];
    char szMsg[2*INTERNET_MAX_URL_LENGTH];
    HWND hWnd = NULL;
    DWORD dwValue = 0;
    DWORD dwLen = sizeof(DWORD);
    WCHAR wzEscaped[INTERNET_MAX_URL_LENGTH];
    DWORD dwCount;
    HKEY hkeyRest = 0;

    // Check if setting home page is restricted

    if (RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_SET_HOMEPAGE_RESTRICTION, 0,
                     KEY_READ, &hkeyRest) == ERROR_SUCCESS)
    {
        if (RegQueryValueEx(hkeyRest, REGVAL_HOMEPAGE_RESTRICTION, NULL, NULL,
                            (LPBYTE)&dwValue, &dwLen) == ERROR_SUCCESS
            && dwValue)
        {
            hr = E_ACCESSDENIED;
        }

        RegCloseKey(hkeyRest);

        if (FAILED(hr))
        {
            goto Exit;
        }
    }

    if(FAILED(CoInternetParseUrl(bstrURL, PARSE_CANONICALIZE  , NULL, wzEscaped, ARRAY_SIZE(wzEscaped), &dwCount, 0)))
        goto Exit;
        
    if ( bstrURL && WideCharToMultiByte(CP_ACP, 0, wzEscaped, -1, szURL,
            sizeof(szURL), NULL, NULL) &&
         LoadStringA(g_hInst, IDS_SETHOMEPAGE_TITLE, szMsgTitle, sizeof(szMsgTitle)) &&
         LoadStringA(g_hInst, IDS_SETHOMEPAGE_MSG, szMsgFormat, sizeof(szMsgFormat))) {

         if (wnsprintfA(szMsg, sizeof(szMsg), szMsgFormat, szURL) && GetWindow(&hWnd) == S_OK) {
            MSGBOXPARAMS      mbp;
            WCHAR             wzMsg[MAX_HOMEPAGE_MESSAGE_LEN];
            WCHAR             wzTitle[MAX_HOMEPAGE_TITLE_LEN];

            if (!MultiByteToWideChar(CP_ACP, 0, szMsg, -1, wzMsg,
                                     MAX_HOMEPAGE_MESSAGE_LEN))
            {
                goto Exit;
            }

            if (!MultiByteToWideChar(CP_ACP, 0, szMsgTitle, -1, wzTitle,
                                     MAX_HOMEPAGE_TITLE_LEN))
            {
                goto Exit;
            }
                                                    
            mbp.cbSize = sizeof (MSGBOXPARAMS);
            mbp.hwndOwner = hWnd;
            mbp.hInstance = g_hInst;
            mbp.dwStyle = MB_YESNO | MB_USERICON;
            mbp.lpszCaption = wzTitle;
            mbp.lpszIcon = MAKEINTRESOURCE(IDI_HOMEPAGE);
            mbp.dwContextHelpId = 0;
            mbp.lpfnMsgBoxCallback = NULL;
            mbp.dwLanguageId = MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT);
            mbp.lpszText = wzMsg;

            ULONG_PTR uCookie = 0;
            SHActivateContext(&uCookie);

            if (MessageBoxIndirect(&mbp) == IDYES) {

                // got approval, now stomp the reg key
                hr = SetUserHomePage(szURL);
            }

            if (uCookie)
            {
                SHDeactivateContext(uCookie);
            }
         }
    }

Exit:

    return hr;
}

STDMETHODIMP CHomePage::isHomePage(BSTR bstrURL, VARIANT_BOOL *pVal)
{
    HRESULT hr = S_OK;
    BSTR bstrHome = NULL;
    BSTR bstrName = NULL;

    if (pVal == NULL)
    {
        return E_POINTER;
    }


    hr = GetHomePage(bstrHome, bstrName);
    if (SUCCEEDED(hr)) {

        if (StrCmpIW(bstrHome, bstrURL) == 0) {

            // matches and is the home page
            // now verify that the doc base URL is indeed
            // in the same domain (same security ID and is 
            // therefore authorized to inspect the home page

            hr = IsAuthorized(bstrHome);

        } else {
            hr = S_FALSE;
        }
    }

    if (bstrName)
        SysFreeString(bstrName);

    if (bstrHome)
        SysFreeString(bstrHome);

    hr =  SUCCEEDED(hr)?hr:S_FALSE;

    if (hr == S_FALSE)
        *pVal = FALSE;
    else
        *pVal = TRUE;

    return hr;
}

STDMETHODIMP CHomePage::navigateHomePage()
{
    IHTMLWindow2 *pWindow = NULL;
    IHTMLWindow2 *pWindowNew = NULL;
    HRESULT hr = S_OK;
    BSTR bstrURL = NULL;
    BSTR bstrName = NULL;

    hr = GetHTMLWindow(&pWindow);

    if (SUCCEEDED(hr)) {

        hr = GetHomePage(bstrURL, bstrName);
        if (SUCCEEDED(hr)) {

            hr = pWindow->open(bstrURL, bstrName, NULL, NULL, &pWindowNew);
        }
    }

    if (FAILED(hr))
        hr = S_FALSE;       // script friendly

    if (pWindow)
        pWindow->Release();

    if (pWindowNew)
        pWindowNew->Release();

    if (bstrName)
        SysFreeString(bstrName);

    if (bstrURL)
        SysFreeString(bstrURL);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\headfoot.cxx ===
//===============================================================
//
//  headfoot.cxx : Implementation of the CHeaderFooter
//
//  Synposis : Provides parsing and HTML header/footer building support.
//      The class has a header and footer strings and a shared table of
//      token types and their corresponding values (&p -> a string of the page #).
//      It uses the string & the tables to create an HTML table header/footer.
//
//===============================================================
                                                              
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_HEADFOOT_HXX_
#define X_HEADFOOT_HXX_
#include "headfoot.hxx"
#endif

#ifndef X_IEXTAG_H_
#define X_IEXTAG_H_
#include "iextag.h"
#endif

#ifndef X_UTILS_HXX_
#define X_UTILS_HXX_
#include "utils.hxx"
#endif

TCHAR * aachTokenNames[tokTotal] =
{ _T("Page"),
  _T("PageTotal"),
  _T("Url"),
  _T("Title"),
  _T("TmShort"),
  _T("TmLong"),
  _T("DtShort"),
  _T("DtLong")   };

CHeaderFooter::~CHeaderFooter()
{
    int i;

    //  Dellocate header/footer string
    if (_achTextHead)
        delete []_achTextHead;
    if (_achTextFoot)
        delete []_achTextFoot;

    //  Deallocate the token array.
    if (_ahftTokensHead)
        delete []_ahftTokensHead;
    if (_ahftTokensFoot)
        delete []_ahftTokensFoot;

    //  Deallocate any token-type strings that we may have allocated.
    for (i=0; i<tokTotal; i++)
    {
        if (_aachTokenTypes[i])
            delete []_aachTokenTypes[i];
    }
}


//+----------------------------------------------------------------------------
//
//  Member : Init - IElementBehavior method impl
//
//  Synopsis :  peer Interface, initialization
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CHeaderFooter::Init(IElementBehaviorSite * pPeerSite)
{
    HRESULT hr      = S_OK;
    HKEY    hKey    = NULL;

    if (!pPeerSite)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

Cleanup:
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member : Detach - IElementBehavior method impl
//
//  Synopsis :  peer Interface, destruction work upon detaching from document
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CHeaderFooter::Detach() 
{ 
    return S_OK; 
}

//+----------------------------------------------------------------------------
//
//  Member : Notify - IElementBehavior method impl
//
//  Synopsis : peer Interface, called for notification of document events.
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CHeaderFooter::Notify(LONG lEvent, VARIANT *)
{
    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  (IHeaderFooter) CHeaderFooter::get htmlHead/Foot
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CHeaderFooter::get_htmlHead(BSTR * p)
{
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else
    {
        if (!_fHeadHtmlBuilt)
            BuildHtml(_ahftTokensHead, &_achHtmlHead, _cBreaksHead, _cTokensHead, _T("THeader"));

        _fHeadHtmlBuilt = TRUE;

        *p = SysAllocString(_achHtmlHead);
        if (!p)
            hr = E_OUTOFMEMORY;
    }

    return hr;
}
STDMETHODIMP
CHeaderFooter::get_htmlFoot(BSTR * p)
{
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else
    {
        if (!_fFootHtmlBuilt)
            BuildHtml(_ahftTokensFoot, &_achHtmlFoot, _cBreaksFoot, _cTokensFoot, _T("TFooter"));

        _fFootHtmlBuilt = TRUE;

        *p = SysAllocString(_achHtmlFoot);
        if (!p)
            hr = E_OUTOFMEMORY;
    }

    return hr;
}
//+----------------------------------------------------------------------------
//
//  (IHeaderFooter) CHeaderFooter::get/put textHead/Foot
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CHeaderFooter::get_textHead(BSTR * p)
{
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else
    {
        *p = SysAllocString(_achTextHead);
        if (!p)
            hr = E_OUTOFMEMORY;
    }

    return hr;
}
STDMETHODIMP
CHeaderFooter::get_textFoot(BSTR * p)
{
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else
    {
        *p = SysAllocString(_achTextFoot);
        if (!p)
            hr = E_OUTOFMEMORY;
    }

    return hr;
}
STDMETHODIMP
CHeaderFooter::put_textHead(BSTR v)
{
    HRESULT hr = S_OK;
    TCHAR * achTemp = v;

    if (_achTextHead)
    {
        delete []_achTextHead;
        _achTextHead = NULL;
    }

    if ( !v )
    {
        _fHeadHtmlBuilt = FALSE;
        return hr;
    }

    _achTextHead = new TCHAR[_tcslen(achTemp) + 1];
    if (!_achTextHead)
        hr = E_OUTOFMEMORY;
    else
    {
        _tcscpy(_achTextHead, achTemp);

        hr = DetoxifyString(v, &achTemp, TRUE);     // Reassigns & allocates achTemp.
        if (!hr)
        {
            //  Retokenise for the new string.
            hr = ParseText(achTemp, &_ahftTokensHead, &_cBreaksHead, &_cTokensHead);
            _fHeadHtmlBuilt = FALSE;        //  Need to rebuild HTML because the source string is different
            delete []achTemp;
        }
    }

    return hr;
}
STDMETHODIMP
CHeaderFooter::put_textFoot(BSTR v)
{
    HRESULT hr = S_OK;
    TCHAR * achTemp = v;

    if (_achTextFoot)
    {
        delete []_achTextFoot;
        _achTextFoot = NULL;
    }

    if ( !v )
    {
        _fFootHtmlBuilt = FALSE;
        return hr;
    }

    _achTextFoot = new TCHAR[_tcslen(achTemp) + 1];
    if (!_achTextFoot)
        hr = E_OUTOFMEMORY;
    else
    {
        _tcscpy(_achTextFoot, achTemp);

        hr = DetoxifyString(v, &achTemp, TRUE);     // Reassigns & allocates achTemp.
        if (!hr)
        {
            //  Retokenise for the new string.
            hr = ParseText(achTemp, &_ahftTokensFoot, &_cBreaksFoot, &_cTokensFoot);
            _fFootHtmlBuilt = FALSE;        //  Need to rebuild HTML because the source string is different
            delete []achTemp;
        }
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  (IHeaderFooter) CHeaderFooter::get/put pageNum
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CHeaderFooter::get_page(DWORD * p)
{
    return GetTokenDWORD(p, tokPageNum);
}
STDMETHODIMP
CHeaderFooter::put_page(DWORD v)
{
    return PutTokenDWORD(v, tokPageNum);
}

//+----------------------------------------------------------------------------
//
//  (IHeaderFooter) CHeaderFooter::get/put pageTotal
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CHeaderFooter::get_pageTotal(DWORD * p)
{
    return GetTokenDWORD(p, tokPageTotal);
}
STDMETHODIMP
CHeaderFooter::put_pageTotal(DWORD v)
{
    return PutTokenDWORD(v, tokPageTotal);
}

//+----------------------------------------------------------------------------
//
//  (IHeaderFooter) CHeaderFooter::get/put URL
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CHeaderFooter::get_URL(BSTR * p)
{
    return GetTokenBSTR(p, tokURL);
}
STDMETHODIMP
CHeaderFooter::put_URL(BSTR v)
{
    return PutTokenBSTR(v, tokURL);
}

//+----------------------------------------------------------------------------
//
//  (IHeaderFooter) CHeaderFooter::get/put Title
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CHeaderFooter::get_title(BSTR * p)
{
    return GetTokenBSTR(p, tokTitle);
}
STDMETHODIMP
CHeaderFooter::put_title(BSTR v)
{
    return PutTokenBSTR(v, tokTitle);
}

//+----------------------------------------------------------------------------
//
//  (IHeaderFooter) CHeaderFooter::get/put dateShort
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CHeaderFooter::get_dateShort(BSTR * p)
{
    EnsureDateTime(tokDateShort);
    return GetTokenBSTR(p, tokDateShort);
}
STDMETHODIMP
CHeaderFooter::put_dateShort(BSTR v)
{
    return PutTokenBSTR(v, tokDateShort);
}
//+----------------------------------------------------------------------------
//
//  (IHeaderFooter) CHeaderFooter::get/put dateLong
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CHeaderFooter::get_dateLong(BSTR * p)
{
    EnsureDateTime(tokDateLong);
    return GetTokenBSTR(p, tokDateLong);
}
STDMETHODIMP
CHeaderFooter::put_dateLong(BSTR v)
{
    return PutTokenBSTR(v, tokDateLong);
}
//+----------------------------------------------------------------------------
//
//  (IHeaderFooter) CHeaderFooter::get/put timeShort
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CHeaderFooter::get_timeShort(BSTR * p)
{
    EnsureDateTime(tokTimeShort);
    return GetTokenBSTR(p, tokTimeShort);
}
STDMETHODIMP
CHeaderFooter::put_timeShort(BSTR v)
{
    return PutTokenBSTR(v, tokTimeShort);
}
//+----------------------------------------------------------------------------
//
//  (IHeaderFooter) CHeaderFooter::get/put timeLong
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CHeaderFooter::get_timeLong(BSTR * p)
{
    EnsureDateTime(tokTimeLong);
    return GetTokenBSTR(p, tokTimeLong);
}
STDMETHODIMP
CHeaderFooter::put_timeLong(BSTR v)
{
    return PutTokenBSTR(v, tokTimeLong);
}

//---------------------------------------------------------------------------
//
//  Member:     CHeaderFooter::ParseText
//
//  Synopsis:   Takes a string (achText) and parses it into an array of tokens
//              at (*pphftTokens).  Also sets *cBreaks and *cTokens to the #
//              of &b's and tokens in the array, respectively.
//
//---------------------------------------------------------------------------
HRESULT
CHeaderFooter::ParseText(TCHAR *achText, CHeadFootToken ** pphftTokens, int *cBreaks, int *cTokens)
{  
    HRESULT hr = S_OK;
    int     iLen;

    Assert(achText);
    Assert(pphftTokens);
    Assert(cBreaks);
    Assert(cTokens);

    //  Initialize variables for a new run.
    if (*pphftTokens)            //  If we have a token array, whack it and start over.
        delete [](*pphftTokens);
    *pphftTokens = NULL;
    *cBreaks = 0;               //  Begin a new count of &b's.
    *cTokens = 0;

    iLen = _tcslen(achText);
    if (iLen > 0)
    {
        HEADFOOTTOKENTYPE   hftt;
        TCHAR *             pFront;
        TCHAR *             pRear;
        int                 cMaxTokens;

        //  All that spiffy dynamic array code is privy to Trident.
        //  In place of that, we'll create an array that is at least big enough.
        //  A token is a "special" &n character or literal string.
        //  The most literals are a string like: "(literal) (special) (literal)... (special) (literal)"
        //  which yeilds (specials * 2) + 1 tokens.
        //  So, we count the specials to determine a bounding size.
        for (   pFront = achText, cMaxTokens = 0; (*pFront); pFront++)
        {
            if ((*pFront) == _T('&'))
                cMaxTokens++;
        }
        cMaxTokens = cMaxTokens * 2 + 1;
        *pphftTokens = new CHeadFootToken[cMaxTokens];
        if (!(*pphftTokens))
            return E_OUTOFMEMORY;

        pRear = achText;
        while (*pRear)
        {
            //  Get next position of a '&'
            pFront = _tcschr(pRear, _T('&'));

            //  If there was a literal between us and the '&' or string end, tokenize it.
            if (pFront)
                *pFront = _T('\0');

            if (_tcslen(pRear) > 0)
            {
                Assert((*cTokens) < cMaxTokens);
                (*pphftTokens)[(*cTokens)++].InitText(pRear);
            }
            
            if (pFront)
                *pFront = _T('&');
            else
                break;       // At end of string.  Quit.
        
            //  Move to the character after the '&'.  If we find this is a special character (below),
            //  we'll move pRear in front of it.  Otherwise, we'll leave pRear on it so that it gets included
            //  in the next string literal.
            pFront++;
                pRear = pFront;

            hftt = tokUndefined;
            switch(*pFront)
            {
                case _T('b'):
                    hftt = tokBreak;
                    (*cBreaks)++;
                    break;
                case _T('p'):
                    hftt = tokPageNum;
                    break;
                case _T('P'):
                    hftt = tokPageTotal;
                    break;
                case _T('w'):
                    hftt = tokTitle;
                    break;
                case _T('u'):
                    hftt = tokURL;
                    break;
                case _T('d'):
                    hftt = tokDateShort;
                    break;
                case _T('D'):
                    hftt = tokDateLong;
                    break;
                case _T('t'):
                    hftt = tokTimeShort;
                    break;
                case _T('T'):
                    hftt = tokTimeLong;
                    break;
                case _T('&'):
                    Assert((*cTokens) < cMaxTokens);
                    (*pphftTokens)[(*cTokens)++].InitText(_T("&"));                    
                    pFront++;
                    pRear++;
            }


            if (hftt != tokUndefined)
            {                
                // Pass the token type and (if not a break) the address of entry in our array that
                // contains the token's string.
                Assert((*cTokens) < cMaxTokens);
                (*pphftTokens)[(*cTokens)++].InitSpecial(hftt, (hftt == tokBreak) ? NULL : &_aachTokenTypes[hftt]);

                //  Advance the rear pointer to be in front of the character after the '&'
                pRear++;            
            }
        }
    }

    return hr;
};

//---------------------------------------------------------------------------
//
//  Member:     CHeaderFooter::BuildHtml
//
//  Synopsis:   Takes an array of tokens (ahftTokens) and the # of &b's (cBreaks)
//              and tokens (cTokens) in that array, and builds an HTML table string
//              in the buffered string (*achHtml).
//
//              (greglett)  Backwards compatibility:
//              To bow to compat, we have decided to make (for this release, 5.5) headers and footers
//              one line only, and to apply ellipsis whenever necessary to cut off the header/footer.
//              There are three cases (for back compat):
//              TWO CELLS (xxxx&byyyyy).  yyyy is given as much space as it needs. xxxx gets the rest, and
//                gets ellipsis as necessary.  This is to mimic the behavior for the standard H/F, in which
//                xxxx is a very long title/url.
//              THREE CELLS (&byyyyy&b).  yyyy is given the entire space  This is not true if the first or last
//                cell has contents
//              ANYTHING ELSE.  Cells are given equal amounts of space.
//
//---------------------------------------------------------------------------
HRESULT
CHeaderFooter::BuildHtmlOneBreak(CHeadFootToken * ahftTokens, CBufferedStr *achHtml, int cBreaks, int cTokens, TCHAR *pchTableClass)
{
    HEADFOOTTOKENTYPE hfttContent;
    TCHAR   achCount[MAX_DWORD_ASSTRING];   // For _ltot on the current counter id.
    TCHAR * pchContent;
    int     iBreak;
    int     iToken;

    Assert(cBreaks == 1);       // Function is only for this case.

    _ltot(_cNextId, achCount, 10);   // Get the string for the counter value.

    achHtml->Set(_T("<DIV style=\"text-align:right;position:relative;width:100%;overflow:hidden;text-overflow:ellipsis;font-size:12pt;\" id="));
    WriteElementId(achHtml, pchTableClass, achCount, _T("O"));
    achHtml->QuickAppend(_T(" class="));
    achHtml->QuickAppend(pchTableClass);

    // NB (greglett) Can't use Math.max or other max function here in the expression because of an expressions bug.
    achHtml->QuickAppend(_T("><DIV style=\"position:absolute;width:expression(("));
    WriteElementId(achHtml, pchTableClass, achCount, _T("O"));
    achHtml->QuickAppend(_T(".clientWidth - "));
    WriteElementId(achHtml, pchTableClass, achCount, _T("R"));
    achHtml->QuickAppend(_T(".offsetWidth - 10 > 0) ? ("));
    WriteElementId(achHtml, pchTableClass, achCount, _T("O"));
    achHtml->QuickAppend(_T(".clientWidth - "));
    WriteElementId(achHtml, pchTableClass, achCount, _T("R"));
    achHtml->QuickAppend(_T(".offsetWidth - 10) : 0);overflow:hidden;left:0;text-align:left;text-overflow:ellipsis;\" id="));
    WriteElementId(achHtml, pchTableClass, achCount, _T("L"));
    achHtml->QuickAppend(_T(">"));

    for (iToken=0,iBreak=0; iBreak<=cBreaks; iBreak++)
    {   
        switch (iBreak)
        {
        case 0:
            achHtml->QuickAppend(_T("<NOBR>"));
            break;
        case 1:
            achHtml->QuickAppend(_T("<NOBR id="));
            WriteElementId(achHtml, pchTableClass, achCount, _T("R"));
            achHtml->QuickAppend(_T(">"));
            break;
        }

        // Write contents
        for (;iToken < cTokens; iToken++)
        {                
            hfttContent = ahftTokens[iToken].Type();
            if (hfttContent == tokBreak)
            {
                //  &b, iterate to next table cell.
                iToken++;
                break;
            }
        
            pchContent  = ahftTokens[iToken].Content();
            //  For &d, &D, &t, &T, make a date/time string if we haven't already.
            if (    pchContent == NULL
                &&  (   hfttContent == tokDateShort
                     || hfttContent == tokDateLong
                     || hfttContent == tokTimeShort
                     || hfttContent == tokTimeLong ) )
            {
                EnsureDateTime(hfttContent);
                pchContent = ahftTokens[iToken].Content();
            }

            Assert(hfttContent >= 0 || hfttContent == tokFlatText);

            //  Write this token's content into the cell.
            //  We can be in a state in which we are supposed to print a special token (&w, etc...),
            //  but don't have it's corresponding string value (the title, etc...).  Do pointer check.
            if (hfttContent != tokFlatText)
            {
                achHtml->QuickAppend(_T("<SPAN class=hf"));
                achHtml->QuickAppend(aachTokenNames[hfttContent]);
                achHtml->QuickAppend(_T(">"));
                if (pchContent)
                    achHtml->QuickAppend(pchContent);
                achHtml->QuickAppend(_T("</SPAN>"));
            }
            else if (pchContent)
                achHtml->QuickAppend(pchContent);
        }
        
        achHtml->QuickAppend(_T("</NOBR></DIV>"));  // Either close the HFLeft (iBreak==0) or HFOut (iBreak==1)
    }

    Assert(iBreak == cBreaks+1);
    Assert(iToken == cTokens);

    return S_OK;
}

HRESULT
CHeaderFooter::BuildHtmlCentered(CHeadFootToken * ahftTokens, CBufferedStr *achHtml, int cBreaks, int cTokens, TCHAR *pchTableClass)
{
    HEADFOOTTOKENTYPE hfttContent;
    TCHAR   achCount[MAX_DWORD_ASSTRING];   // For _ltot on the current counter id.
    TCHAR * pchContent;
    int     iBreak;
    int     iToken;

    Assert(cBreaks == 2);       // Function is only for this case.

    _ltot(_cNextId, achCount, 10);   // Get the string for the counter value.

    achHtml->Set(_T("<DIV style=\"text-align:center;overflow:hidden;text-overflow:ellipsis;width:100%;font-size:12pt;\" class="));
    achHtml->QuickAppend(pchTableClass);
    achHtml->QuickAppend(_T("><NOBR>"));

    // <=, because there are (cBreaks + 1) segments to build HTML from
    for (iToken=0,iBreak=0; iBreak<=cBreaks; iBreak++)
    {   
        // Write contents
        for (;iToken < cTokens; iToken++)
        {                
            hfttContent = ahftTokens[iToken].Type();
            if (hfttContent == tokBreak)
            {
                //  &b, iterate to next table cell.
                iToken++;
                break;
            }
        
            pchContent  = ahftTokens[iToken].Content();
            //  For &d, &D, &t, &T, make a date/time string if we haven't already.
            if (    pchContent == NULL
                &&  (   hfttContent == tokDateShort
                     || hfttContent == tokDateLong
                     || hfttContent == tokTimeShort
                     || hfttContent == tokTimeLong ) )
            {
                EnsureDateTime(hfttContent);
                pchContent = ahftTokens[iToken].Content();
            }

            Assert(hfttContent >= 0 || hfttContent == tokFlatText);

            //  Write this token's content into the cell.
            //  We can be in a state in which we are supposed to print a special token (&w, etc...),
            //  but don't have it's corresponding string value (the title, etc...).  Do pointer check.
            if (hfttContent != tokFlatText)
            {
                achHtml->QuickAppend(_T("<SPAN class=hf"));
                achHtml->QuickAppend(aachTokenNames[hfttContent]);
                achHtml->QuickAppend(_T(">"));
                if (pchContent)
                    achHtml->QuickAppend(pchContent);
                achHtml->QuickAppend(_T("</SPAN>"));
            }
            else if (pchContent)
                achHtml->QuickAppend(pchContent);
        }
    }
    achHtml->QuickAppend(_T("</NOBR></DIV>"));

    Assert(iBreak == cBreaks+1);
    Assert(iToken == cTokens);

    return S_OK;
}

HRESULT
CHeaderFooter::BuildHtmlDefault(CHeadFootToken * ahftTokens, CBufferedStr *achHtml, int cBreaks, int cTokens, TCHAR *pchTableClass)
{
    HEADFOOTTOKENTYPE hfttContent;
    TCHAR   achCount[MAX_DWORD_ASSTRING];       // For _ltot on the current counter #.
    TCHAR   achCell[MAX_DWORD_ASSTRING + 1];    // For _ltot on the curren cell #
    TCHAR   achBuf[MAX_DWORD_ASSTRING];         // For _ltot on the width
    TCHAR * pchContent;
    int     iTot = 0;
    int     iInc = 100 / (cBreaks+1);
    int     iBreak;
    int     iToken;

    _ltot(_cNextId, achCount, 10);   // Get the string for the counter value.
    achCell[0] = _T('x');            // Add character to separate this from the counter.

    //  Parse the tokens, creating an HTML table with contents between &b's
    //  in separate table cells.
    achHtml->Set(_T("<TABLE style=\"border:0;width:100%;table-layout:fixed;\""));
    achHtml->QuickAppend(_T(" class="));
    achHtml->QuickAppend(pchTableClass);
    achHtml->QuickAppend(_T("><TR>"));

    // <=, because there are (cBreaks + 1) segments to build HTML from
    for (iToken=0,iBreak=0; iBreak<=cBreaks; iBreak++)
    {
        //  Write this <TD ...>
        if (iBreak == 0)
        {
            //  (greglett)  Backwards compatibility says that we should left align
            //  if _cBreaks = 0, but wouldn't it look more intuitive center aligned?
            achHtml->QuickAppend(_T("<TD style=\"text-align:left;width:"));
            _ltot(iInc, achBuf, 10);

            iTot += iInc;
        }
        else if (iBreak == cBreaks)
        {
            //  (greglett)  We don't distribute in extra percents right now - we just dump all the
            //  extras at the end.  This might look a little weird for (100 % _cBreaks) much larger than 0.
            //  The first two times this happens is at 6 and 11.  Since these are completely unrealistic
            //  cases (I know of *one* person who used 4, once), I don't think we should worry.
            achHtml->QuickAppend(_T("<TD style=\"text-align:right;width:"));
            _ltot(100-iTot, achBuf, 10);
        }
        else
        {                
            achHtml->QuickAppend(_T("<TD style=\"text-align:center;width:"));
            _ltot(iInc, achBuf, 10);

            iTot += iInc;
        }        
        achHtml->QuickAppend(achBuf);
        achHtml->QuickAppend(_T("%;overflow:hidden;text-overflow:ellipsis;font-size:12pt;\"><NOBR>"));
        
        //  Now, write this <TD>'s contents
        for (;iToken < cTokens; iToken++)
        {                
            hfttContent = ahftTokens[iToken].Type();
            if (hfttContent == tokBreak)
            {
                //  &b, iterate to next table cell.
                iToken++;
                break;
            }
        
            pchContent  = ahftTokens[iToken].Content();
            //  For &d, &D, &t, &T, make a date/time string if we haven't already.
            if (    pchContent == NULL
                &&  (   hfttContent == tokDateShort
                     || hfttContent == tokDateLong
                     || hfttContent == tokTimeShort
                     || hfttContent == tokTimeLong ) )
            {
                EnsureDateTime(hfttContent);
                pchContent = ahftTokens[iToken].Content();
            }

            Assert(hfttContent >= 0 || hfttContent == tokFlatText);

            //  Write this token's content into the cell.
            //  We can be in a state in which we are supposed to print a special token (&w, etc...),
            //  but don't have it's corresponding string value (the title, etc...).  Do pointer check.
            if (hfttContent != tokFlatText)
            {
                achHtml->QuickAppend(_T("<SPAN class=hf"));
                achHtml->QuickAppend(aachTokenNames[hfttContent]);
                achHtml->QuickAppend(_T(">"));
                if (pchContent)
                    achHtml->QuickAppend(pchContent);
                achHtml->QuickAppend(_T("</SPAN>"));
            }
            else if (pchContent)
                achHtml->QuickAppend(pchContent);
        }
        
        achHtml->QuickAppend(_T("</NOBR></TD>"));   //  /TD, Unnecessary, but instructive.
    }
    achHtml->QuickAppend(_T("</TR></TABLE>"));      //  /TR, Unnecessary, but instructive.

    Assert(iBreak == cBreaks+1);
    Assert(iToken == cTokens);

    return S_OK;
}

HRESULT
CHeaderFooter::BuildHtml(CHeadFootToken * ahftTokens, CBufferedStr *achHtml, int cBreaks, int cTokens, TCHAR *pchTableClass)
{
    HRESULT hr = S_OK;
    
    Assert(achHtml);
    Assert(cTokens >= cBreaks);
    Assert(pchTableClass);

    if (!ahftTokens)
    {
        achHtml->Set(_T(""));
        goto Cleanup;
    }


    // Case 1 (the default H/F includes this):                  ((~[&b])*)&b((~[&b])*)
    if (cBreaks == 1)
        BuildHtmlOneBreak(ahftTokens, achHtml, cBreaks, cTokens, pchTableClass);

    // Case 2 (centered text with nothing on the right/left):   &b((~[&b])*)&b
    else if (   cBreaks == 2
             && ahftTokens[0].Type() == tokBreak
             && ahftTokens[cTokens-1].Type() == tokBreak)
        BuildHtmlCentered(ahftTokens, achHtml, cBreaks, cTokens, pchTableClass);

    // Case 3 (default)
    else
        BuildHtmlDefault(ahftTokens, achHtml, cBreaks, cTokens, pchTableClass);

    _cNextId++;

Cleanup:
    return hr;
}

//---------------------------------------------------------------------------
//
//  Member:     CHeaderFooter::EnsureDateTime
//
//  Synopsis:   Takes a given date/time token type.  If no string exists for that
//              token type, it ensures the current date/time stamp, and creates
//              the appropriate string.
//
//---------------------------------------------------------------------------
HRESULT
CHeaderFooter::EnsureDateTime(HEADFOOTTOKENTYPE hfttDateTime)
{
    HRESULT hr;
    TCHAR   achDateTime[DATE_STR_LENGTH];

    //  Do we already have a date/time?  If so, we're done.
    if (_aachTokenTypes[hfttDateTime])
    {
        hr = S_OK;
        goto Cleanup;
    }

    //  Get a timestamp, if we don't have one already.
    //  NB  This is so that, when doing something slow like print preview,
    //      a repeated header/footer displays the same time. (greglett)
    if (!_fGotTimeStamp)
    {
        _fGotTimeStamp = TRUE;
        ::GetLocalTime(&_stTimeStamp);
    }

    //  Now, get the string we need to store.
    switch (hfttDateTime)
    {
    // Both date formats should be in sync, otherwise we look bad.
    case tokDateShort:
        {
            hr = ::GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &_stTimeStamp, NULL,
                                 achDateTime, DATE_STR_LENGTH);
        }
        break;
    case tokDateLong:
        {
            hr = ::GetDateFormat(LOCALE_USER_DEFAULT, DATE_LONGDATE, &_stTimeStamp, NULL,
                                 achDateTime, DATE_STR_LENGTH);
        }
        break;
    case tokTimeShort:
        {
            hr = ::GetTimeFormat(LOCALE_USER_DEFAULT, 0, &_stTimeStamp, NULL,
                                 achDateTime, DATE_STR_LENGTH);
        }
        break;
    case tokTimeLong:
        {
            hr = ::GetTimeFormat(LOCALE_USER_DEFAULT, TIME_FORCE24HOURFORMAT, &_stTimeStamp, NULL,
                                 achDateTime, DATE_STR_LENGTH);
        }
        break;
    default:
        Assert(FALSE && "Trying to date/time ensure a non date/time token.");
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Take the string we just generated and stick it in the right pigeonhole.
    if (hr)
    {
        _aachTokenTypes[hfttDateTime] = new TCHAR[_tcslen(achDateTime)+1];
        if (_aachTokenTypes[hfttDateTime])
            _tcscpy(_aachTokenTypes[hfttDateTime], achDateTime);
        hr = S_OK;
    }
    else
        hr = E_FAIL;

Cleanup:
    return hr;
}

//---------------------------------------------------------------------------
//
//  Member:     CHeaderFooter::DetoxifyString
//
//  Synopsis:   Takes the given BSTR, and allocates & generates a TCHAR string
//              that has been secured for writing onto a template.
//
//              Right now, this means NO HTML tags or escaped characters (&...)
//             
//              For a "normal" string, in which ampersand is not special:
//              Replace
//                  "<"     becomes     "&lt" 
//                  "&"     becomes     "&amp"
//              For the "Text" string, where ampersand has a special meaning:
//              Replace
//                  "<"     becomes     "&&lt"
//                  "&&"    becomes     "&&amp"
//
//              (greglett)  This essentially destroys HTML in headers/footers
//              for security.  While this is backward compatible, it isn't nearly
//              as powerful.  A better solution (one that parses out only OBJECTS, or
//              such) should be considered for the post 4/00 release.
//              See (greglett) or (cwilso) for details.
//---------------------------------------------------------------------------
HRESULT
CHeaderFooter::DetoxifyString(BSTR achIn, TCHAR **pachOut, BOOL fAmpSpecial)
{
    HRESULT hr   = S_OK;
    TCHAR * pch;
    TCHAR * pchNew;
    long    cchLen;
#if DBG == 1
    long    cchCheck = 0;   // Make sure we equal length in debug mode.
#endif

    Assert(pachOut);
    *pachOut = NULL;

    if (!achIn)
        goto Cleanup;


    //  How large a string do we need to store the detoxified string?
    // TODO (112557) : BSTRs are not NUL terminated (they may
    // contain embedded NULs).  Use SysStringLen and work with that.  Right now
    // we could AV if we pass the string "&" and fAmpSpecial is true.
    for (pch = achIn, cchLen = 0; *pch != NULL; pch++)
    {
        switch (*pch)
        {
            case _T('<'):       // "<" becomes "&lt" or "&&lt"
                cchLen += (fAmpSpecial) ? 4 : 3;
                break;

            case _T('&'):       // "&" becomes "&amp" or "&&" becomes "&&amp"
                if (fAmpSpecial)
                {
                    if (*(pch + 1) == _T('&'))
                    {
                        cchLen += 5;
                        pch++;
                    }
                    else
                    {
                        cchLen += 1;
                        break;
                    }
                }
                else
                    cchLen += 4;
                break;

            default:
                cchLen++;
                break;
        }
    }

    //  Make the string.
    (*pachOut) = new TCHAR[cchLen+1];
    if (!(*pachOut))
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Now, copy over the string with replacements
    // TODO (112557) Same as above, use SysStringLen.
    for (pch = achIn, pchNew = (*pachOut); *pch != NULL; pch++)
    {
        switch (*pch)
        {
            case _T('<'):       
                if (fAmpSpecial)    // "<" becomes "&&lt"
                {
                    _tcsncpy(pchNew, _T("&&lt"), 4);
                    pchNew += 4;
#if DBG == 1
                    cchCheck += 4;
#endif
                }
                else                // "<" becomes "&lt"
                {
                    _tcsncpy(pchNew, _T("&lt"), 3);
                    pchNew += 3;
#if DBG == 1
                    cchCheck += 3;
#endif
                }
                break;

            case _T('&'):       
                if (fAmpSpecial)
                {
                    (*pchNew) = (*pch);
                    pchNew++;
#if DBG == 1
                    cchCheck++;
#endif
                    if ((*(pch + 1)) != _T('&'))
                        break;

                    pch++;
                }
                _tcsncpy(pchNew, _T("&amp"), 4);
                pchNew += 4;
#if DBG == 1
                cchCheck += 4;
#endif
                break;
                
            default:
                (*pchNew) = (*pch);
                pchNew++;
#if DBG == 1
                cchCheck++;
#endif
                break;
        }
    }
    (*pchNew) = _T('\0');

#if DBG == 1
    Assert(cchCheck == cchLen);
#endif

Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\homepg.h ===
// Homepg.h : Declaration of CHomePage

#ifndef __HOMEPG_H_
#define __HOMEPG_H_

#include "resource.h"       // main symbols

#define REGSTR_SET_HOMEPAGE_RESTRICTION               TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Control Panel")
#define REGVAL_HOMEPAGE_RESTRICTION                   TEXT("HomePage")

#define MAX_HOMEPAGE_MESSAGE_LEN                      (512 + INTERNET_MAX_URL_LENGTH)
#define MAX_HOMEPAGE_TITLE_LEN                        128
            

/////////////////////////////////////////////////////////////////////////////
// CHomePage
class ATL_NO_VTABLE CHomePage : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CHomePage, &CLSID_HomePage>,
    public IDispatchImpl<IHomePage, &IID_IHomePage, &LIBID_IEXTagLib>,

    public IElementBehavior
{
public:
    CHomePage()
    {
        m_pSite = NULL;
    }
    ~CHomePage()
    {
        if (m_pSite)
            m_pSite->Release();
    }

DECLARE_REGISTRY_RESOURCEID(IDR_HOMEPAGE)
DECLARE_NOT_AGGREGATABLE(CHomePage)

BEGIN_COM_MAP(CHomePage)
    COM_INTERFACE_ENTRY(IHomePage)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IElementBehavior)
END_COM_MAP()

// IHomePage
public:
    STDMETHOD(navigateHomePage)();
    STDMETHOD(setHomePage)(/*[in]*/ BSTR bstrURL);
    STDMETHOD(isHomePage)(/*[in]*/ BSTR bstrURL, /*[out,retval]*/ VARIANT_BOOL *p);

    //IHTMLPeerElement methods
    STDMETHOD(Init)(IElementBehaviorSite *pSite);
    STDMETHOD(Notify)(LONG lNotify, VARIANT * pVarNotify);
    STDMETHOD(Detach)() { return S_OK; };

private:
    STDMETHOD(IsSameSecurityID)(IInternetSecurityManager *pISM, BSTR bstrURL, BSTR bstrDocBase);
    STDMETHOD(IsAuthorized)(BSTR bstrURL);
    STDMETHOD(GetWindow)(HWND *phWnd);
    STDMETHOD(GetHTMLWindow)(/* out */ IHTMLWindow2 **ppWindow);
    STDMETHOD(GetHTMLDocument)(/* out */IHTMLDocument2 **ppDoc);
    STDMETHOD(GetHomePage)(BSTR& bstrURL, BSTR& bstrName);
    STDMETHOD(SetUserHomePage)(LPCSTR szURL);
    IElementBehaviorSite * m_pSite;

};

#endif //__HOMEPG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\htmlarea.cxx ===
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "iextag.h"

#include "dispex.h"

#ifndef __X_HTMLAREA_HXX_
#define __X_HTMLAREA_HXX_
#include "htmlarea.hxx"
#endif

const CBaseCtl::PROPDESC CHtmlArea::s_propdesc[] = 
{
    {_T("value"), VT_BSTR},
    NULL
};

enum
{
    VALUE = 0
};

/////////////////////////////////////////////////////////////////////////////
//
// CHtmlArea
//
/////////////////////////////////////////////////////////////////////////////

CHtmlArea::CHtmlArea()
{
}

CHtmlArea::~CHtmlArea()
{
    SysFreeString(_bstrDefaultValue);
}

HRESULT
CHtmlArea::Init()
{
    HRESULT         hr = S_OK;
    CContextAccess  a(_pSite);

    hr = a.Open(CA_ELEM | CA_ELEM2 | CA_ELEM3 | CA_SITEOM | CA_DEFAULTS | CA_DEFSTYLE | CA_DEFSTYLE2 | CA_STYLE);
    if (hr)
        goto Cleanup;

    // By hooking into the onpropertychange event, we can set the _fValueChanged flag.
    hr = AttachEvent(EVENT_ONPROPERTYCHANGE, &a);
    if (hr)
        goto Cleanup;

    // By hooking into the onblur event, we can check the _fValueChanged flag
    // and fire the onchange event.
    hr = AttachEvent(EVENT_ONBLUR, &a);
    if (hr)
        goto Cleanup;

    // By hooking into the onfocus event, we can track whether we have the focus.
    hr = AttachEvent(EVENT_ONFOCUS, &a);
    if (hr)
        goto Cleanup;

    hr = RegisterEvent(a.SiteOM(), L"onchange", &_lOnChangeCookie);
    if (hr)
        goto Cleanup;

    hr = a.Defaults()->put_tabStop(VB_TRUE);
    if (hr)
        goto Cleanup;

    hr = a.Elem3()->put_contentEditable(L"true");
    if (hr)
        goto Cleanup;

    //
    //  Set the default style
    //

    hr = SetDefaultStyle(&a);
    if (hr)
        goto Cleanup;

    // set properties on IHTMLElement
    // pElement->setAttribute(_T("editable"), VB_TRUE);

    // force a layout
    hr =  a.Style()->put_display(_T("inline-block"));

Cleanup:

    return hr;
}

HRESULT
CHtmlArea::SetDefaultStyle(CContextAccess * pa)
{
    HRESULT       hr             = S_OK;
    CVariant      cvarTemp(VT_BSTR);

    hr = pa->DefStyle()->put_fontFamily(L"courier new");
    if (hr)
        goto Cleanup;

    V_BSTR(&cvarTemp) = SysAllocString(L"9.5pt");
    hr = pa->DefStyle()->put_fontSize(cvarTemp);
    if (hr)
        goto Cleanup;

    cvarTemp.Clear();
    V_VT(&cvarTemp) = VT_BSTR;
    // (krisma 6/12/99) Why is the width 14.4? This is what makes 
    // it the same width as a textarea.
    V_BSTR(&cvarTemp) = SysAllocString(L"14.4em");
    hr = pa->DefStyle()->put_width(cvarTemp);
    if (hr)
        goto Cleanup;

    cvarTemp.Clear();
    V_VT(&cvarTemp) = VT_BSTR;
    // (krisma 6/12/99) Why is the height 3? This is what makes 
    // it the same height as a textarea.
    V_BSTR(&cvarTemp) = SysAllocString(L"3em");
    hr = pa->DefStyle()->put_height(cvarTemp);
    if (hr)
        goto Cleanup;

    hr = pa->DefStyle()->put_borderStyle(L"inset");
    if (hr)
        goto Cleanup;
    hr = pa->DefStyle()->put_borderWidth(L"thin");
    if (hr)
        goto Cleanup;

    cvarTemp.Clear();
    V_VT(&cvarTemp) = VT_BSTR;
    V_BSTR(&cvarTemp) = SysAllocString(L"1px");
    hr = pa->DefStyle()->put_paddingLeft(cvarTemp);
    if (hr)
        goto Cleanup;

    hr = pa->DefStyle2()->put_overflowY(L"scroll");
    if (hr)
        goto Cleanup;

Cleanup:
    return hr;
}

HRESULT
CHtmlArea::OnContentReady()
{
    HRESULT        hr = S_OK;
    IHTMLElement * pElem = NULL;
    BSTR           bstrInnerHTML = NULL;

    // Get the default value
    hr = _pSite->GetElement(&pElem);
    if (hr)
        goto Cleanup;
    hr = pElem->get_innerHTML(&bstrInnerHTML);
    if (hr)
        goto Cleanup;
    _bstrDefaultValue = SysAllocString(bstrInnerHTML);
    if (!_bstrDefaultValue)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pElem);
    if (bstrInnerHTML)
    {
        SysFreeString(bstrInnerHTML);
        bstrInnerHTML = NULL;
    }
    return hr;
}

HRESULT
CHtmlArea::OnPropertyChange(CEventObjectAccess *pEvent, BSTR bstrProperty)
{
    if (! StrCmpICW (bstrProperty, L"innerHTML"))
    {
        GetProps()[VALUE].Dirty();
        if (GetHaveFocus())
            SetValueChangedWhileWeHadFocus(TRUE);
    }
    return S_OK;
}

HRESULT
CHtmlArea::OnBlur(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    SetHaveFocus(FALSE);
    if (GetValueChangedWhileWeHadFocus())
    {
        Assert(GetProps()[VALUE].IsDirty());
        SetValueChangedWhileWeHadFocus(FALSE);
        hr = FireEvent(_lOnChangeCookie);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    return hr;
}

HRESULT
CHtmlArea::select()
{
    return S_OK;
}

HRESULT
CHtmlArea::put_value(BSTR v)
{
    HRESULT         hr      = S_OK;
    IHTMLElement *  pElem   = NULL;

    if (!v)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = _pSite->GetElement(&pElem);
    if (hr)
        goto Cleanup;
    hr = pElem->put_innerHTML(v);
    if (hr)
        goto Cleanup;

    hr = GetProps()[VALUE].Set(v);
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pElem);
    return hr;
}

HRESULT
CHtmlArea::get_value(BSTR * pv)
{
    HRESULT         hr      = S_OK;
    IHTMLElement *  pElem   = NULL;

    if (!pv)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pv = NULL;

    hr = _pSite->GetElement(&pElem);
    if (hr)
        goto Cleanup;
    hr = pElem->get_innerHTML(pv);
    if (hr)
        goto Cleanup;
    
Cleanup:
    ReleaseInterface(pElem);
    return hr;
}

// IElementBehaviorSubmit methods
HRESULT
CHtmlArea::Reset()
{
    HRESULT         hr      = S_OK;

    if (GetProps()[VALUE].IsDirty())
    {
        hr = put_value(_bstrDefaultValue);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    return hr;
}

HRESULT
CHtmlArea::GetSubmitInfo(IHTMLSubmitData * pSubmitData)
{
    HRESULT         hr          = S_OK;
    IHTMLElement *  pElem       = NULL; //(krisma) Do we want to (can we?) cache the element?
    BSTR            bstrValue   = NULL;
    CVariant        cvarName;

    // See if we have a name
    hr = _pSite->GetElement(&pElem);
    if (hr)
        goto Cleanup;
    hr = pElem->getAttribute(_T("name"), 0, &cvarName);
    if (hr)
        goto Cleanup;

    if (V_VT(&cvarName) != VT_BSTR)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    //Get our innerHTML
    hr, get_value(&bstrValue);
    if (hr)
        goto Cleanup;

    //append our data
    hr = pSubmitData->appendNameValuePair(V_BSTR(&cvarName), bstrValue);
    if (hr)
        goto Cleanup;

Cleanup:
    if (bstrValue)
    {
        SysFreeString(bstrValue);
        bstrValue = NULL;
    }
    ReleaseInterface(pElem);

    if (hr)
        hr = S_FALSE;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\makefile.inc ===
#MIDL= $(DEVTOOLS)\midl.exe

$O\iextag.h $O\iextag.tlb iextag.cxx : $(SDK_INC_PATH)\iextag.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\iextag.cxx ===
// iextag.cpp : Implementation file for code common to all xtags..


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL,
//      run nmake -f ccapsps.mk in the project directory.
#include <w95wraps.h>
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "resource.h"
#include "initguid.h"
#include "iextag.h"

#include "peerfact.h"
#include "ccaps.h"
#include "homepg.h"
#include "download.h"

#ifndef __X_HTMLAREA_HXX_
#define __X_HTMLAREA_HXX_
#include "htmlarea.hxx"
#endif

#ifndef __X_SELECT_HXX_
#define __X_SELECT_HXX_
#include "select.hxx"
#endif

#ifndef __X_SELITEM_HXX_
#define __X_SELITEM_HXX_
#include "selitem.hxx"
#endif

#ifndef __X_COMBOBOX_HXX_
#define __X_COMBOBOX_HXX_
#include "combobox.hxx"
#endif

#ifndef __X_CHECKBOX_HXX_
#define __X_CHECKBOX_HXX_
#include "checkbox.hxx"
#endif

#ifndef __X_RADIO_HXX_
#define __X_RADIO_HXX_
#include "radio.hxx"
#endif

#ifndef __X_USERDATA_HXX_
#define __X_USERDATA_HXX_
#include "userdata.hxx"
#endif

#ifndef __X_RECTPEER_HXX_
#define __X_RECTPEER_HXX_
#include "rectpeer.hxx"
#endif

#ifndef __X_DEVICERECT_HXX_
#define __X_DEVICERECT_HXX_
#include "devicerect.hxx"
#endif

#ifndef __X_TMPPRINT_HXX_
#define __X_TMPPRINT_HXX_
#include "tmpprint.hxx"
#endif

#ifndef __X_HEADFOOT_HXX_
#define __X_HEADFOOT_HXX_
#include "headfoot.hxx"
#endif

#ifndef __X_SCROLLBAR_HXX_
#define __X_SCROLLBAR_HXX_
#include "scrllbar.hxx"
#endif

#ifndef __X_SPINBTTN_HXX_
#define __X_SPINBTTN_HXX_
#include "spinbttn.hxx"
#endif

#ifndef __X_SLIDEBAR_HXX_
#define __X_SLIDEBAR_HXX_
#include "slidebar.hxx"
#endif

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>


#if 1
// this is according to IE5 bug 65301. (richards, alexz).
#if _MSC_VER < 1200
#pragma comment(linker, "/merge:.CRT=.data")
#endif
#endif


#include "shfusion.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_PeerFactory,         CPeerFactory)
    OBJECT_ENTRY(CLSID_ClientCaps,          CClientCaps)
    OBJECT_ENTRY(CLSID_HomePage,            CHomePage)
    OBJECT_ENTRY(CLSID_CDownloadBehavior,   CDownloadBehavior)
    OBJECT_ENTRY(CLSID_CCombobox,           CCombobox)
    OBJECT_ENTRY(CLSID_CIESelectElement,    CIESelectElement)
    OBJECT_ENTRY(CLSID_CIEOptionElement,    CIEOptionElement)
    OBJECT_ENTRY(CLSID_CHtmlArea,           CHtmlArea)
    OBJECT_ENTRY(CLSID_CCheckBox,           CCheckBox)
    OBJECT_ENTRY(CLSID_CRadioButton,        CRadioButton)
    OBJECT_ENTRY(CLSID_CLayoutRect,         CLayoutRect)
    OBJECT_ENTRY(CLSID_CDeviceRect,         CDeviceRect)
    OBJECT_ENTRY(CLSID_CTemplatePrinter,    CTemplatePrinter)
    OBJECT_ENTRY(CLSID_CHeaderFooter,       CHeaderFooter)
    OBJECT_ENTRY(CLSID_CScrollBar,          CScrollBar)
    OBJECT_ENTRY(CLSID_CSpinButton,         CSpinButton)
    OBJECT_ENTRY(CLSID_CSliderBar,          CSliderBar)
END_OBJECT_MAP()

HINSTANCE   g_hInst             = NULL;
BOOL        g_fUnicodePlatform;
DWORD       g_dwPlatformVersion;            // (dwMajorVersion << 16) + (dwMinorVersion)
DWORD       g_dwPlatformID;                 // VER_PLATFORM_WIN32S/WIN32_WINDOWS/WIN32_WINNT
DWORD       g_dwPlatformBuild;              // Build number
BOOL        g_fUseShell32InsteadOfSHFolder;

// ISSUE: (alexz) find out why ATL leaks during registration and then remove usage of g_fDisableMemLeakReport
#if DBG == 1
BOOL g_fDisableMemLeakReport = FALSE;
#endif

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HANDLE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        {
            SHFusionInitializeFromModule((HMODULE)hInstance);
            OSVERSIONINFOA vi;

#ifdef UNIX // Unix setup program doesn't invoke COM. Needs to do it here.
            CoInitialize(NULL);
#endif // Unix

            vi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
            GetVersionExA(&vi);

            g_dwPlatformVersion     = (vi.dwMajorVersion << 16) + vi.dwMinorVersion;
            g_dwPlatformID          = vi.dwPlatformId;
            g_dwPlatformBuild       = vi.dwBuildNumber;

            g_fUnicodePlatform = (  g_dwPlatformID == VER_PLATFORM_WIN32_NT );
                                 // || vi.dwPlatformId == VER_PLATFORM_WIN32_UNIX);

            // NOTE:    On Millennium or W2k we should use Shell32 for
            //          SHGetFolderPath instead of SHFolder.
            g_fUseShell32InsteadOfSHFolder = (VER_PLATFORM_WIN32_WINDOWS == g_dwPlatformID 
                                                && (g_dwPlatformVersion >= 0x0004005a))
                                             || (VER_PLATFORM_WIN32_NT == g_dwPlatformID 
                                                && g_dwPlatformVersion >= 0x00050000);

            g_hInst = (HINSTANCE)hInstance;

            _Module.Init(ObjectMap, (HINSTANCE)hInstance);
            DisableThreadLibraryCalls((HINSTANCE)hInstance);

            CPersistUserData::GlobalInit();
#ifdef UNIX
            CoUninitialize();
#endif // Unix
        }
        break;

    case DLL_PROCESS_DETACH:
        CPersistUserData::GlobalUninit();

        _Module.Term();

#if DBG == 1
#ifndef UNIX // UNIX doesn't have _CrtDumpMemoryLeaks yet.
        if (!g_fDisableMemLeakReport && _CrtDumpMemoryLeaks())
        {
            if (IDYES == MessageBoxA (
                NULL,
                "MEMORY LEAKS DETECTED\r\n\r\n"
                "Break for instructions how to track the leaks?",
                "IEPEERS.DLL",
                MB_YESNO | MB_SETFOREGROUND))
            {
                DebugBreak();

                //
                // How to track the leaks:
                //
                // Step 1. Look for trace of memory leaks in debug output window, e.g.:
                //
                //      Dumping objects ->
                //      ...
                //      {42} normal block at 0x01A00CC0, 226 bytes long.
                //      Data: <m o n k e y   w > 6D 00 6F 00 6E 00 6B 00 65 00 79 00 20 00 77 00 
                //      ...
                //
                // interesting info: block with serial number 42 leaked
                //
                //  Step 2. Set breakpoint inside debug allocator on block number 42 using one of the 
                //  following methods:
                //      - set break point in DLL_PROCESS_ATTACH case above, go to QuickWatch window,
                //        and evaluate expression "_CrtSetBreakAlloc(42)"; or
                //      - set break point in DLL_PROCESS_ATTACH case above, and set variable _crtBreakAlloc
                //        global debug variable to 42; or
                //      - place a call "_CrtSetBreakAlloc(42)" in DLL_PROCESS_ATTACH case above,
                //        recompile and run.
            }
        }
#endif // UNIX
#endif
        SHFusionUninitialize();
        break;
    }

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#if DBG == 1
    g_fDisableMemLeakReport = TRUE;
#endif

    // registers object, typelib and all interfaces in typelib
    HRESULT hr = _Module.RegisterServer(TRUE);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#if DBG == 1
    g_fDisableMemLeakReport = TRUE;
#endif

    _Module.UnregisterServer();

    return S_OK;
}

STDAPI DllEnumClassObjects(int i, CLSID *pclsid, IUnknown **ppUnk)
{
    if (i >= (sizeof(ObjectMap)/sizeof(ObjectMap[0])) - 1)
    {
        return S_FALSE;
    }

    *pclsid = *(ObjectMap[i].pclsid);
    return _Module.GetClassObject(*pclsid, IID_IUnknown, (LPVOID*)ppUnk);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\httpwf.cxx ===
//=========================================================================
//
//  File : httpwf.cxx
//
//  purpose : implementation of the Cwfolders class
//
//=========================================================================
// Chad Lindhorst, 1998

#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "httpwfh.h"
#include "utils.hxx"
#include "iextag.h"
#include "htiface.h"  // for ITargetFrame
#include "msdaipper.h"  // only needed for IPP_E_SERVERTYPE_NOT_SUPPORTED
// This #define was from oledberr.h, but only shows up with some versions
// of OLEDB.  (OLEDBVER = 0x210)  Hopefully this is less destructive than
// setting OLEDBVER.
#define DB_E_TIMEOUT                     ((HRESULT)0x80040E97L)
#define DB_E_CANNOTCONNECT               ((HRESULT)0x80040E96L)
#include "oledberr.h"

#define ARRAYSIZE(a)  (sizeof(a) / sizeof(a[0]))

// ========================================================================
// Cwfolders
// ========================================================================

//+------------------------------------------------------------------------
//
//  Members:    Cwfolders::Cwfolders
//              Cwfolders::~Cwfolders
//
//  Synopsis:   Constructor/destructor
//
//-------------------------------------------------------------------------

Cwfolders::Cwfolders() 
{
    m_pSite = NULL;
    m_pwb = NULL;
}

Cwfolders::~Cwfolders() 
{
    ReleaseInterface (m_pwb);
    ReleaseInterface (m_pSite);
}

// ========================================================================
// Iwfolders
// ========================================================================

//+------------------------------------------------------------------------
//
//  Member:     Cwfolders::navigate
//
//  Synopsis:   Navigates the browser to a folder view of the URL passed 
//              in.  The function requires that m_hwndOwner and m_pwb are
//              both inited. (done in Cwfolders::Init)
//
//-------------------------------------------------------------------------

STDMETHODIMP
Cwfolders::navigate(BSTR bstrUrl, BSTR * pbstrRetVal)
{
    IUnknown* punk;

    if(!m_pwb)
    {
        return E_FAIL;
    }

    HRESULT hr = m_pwb->QueryInterface(IID_IUnknown, (void **) &punk);
    if (FAILED (hr))
    {
        return hr;
    }
    hr = navigateInternal(bstrUrl, NULL, /*NULL,*/ USE_NO_UI, punk);
    punk->Release();
    SetScriptErrorMessage (hr, pbstrRetVal);
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     Cwfolders::navigateFrame
//
//  Synopsis:   Navigates the browser to a folder view of the URL passed 
//              in.  This version also allows for the folder view to be
//              pointed to a specific frame, as indicated by bstrTargetFrame.
//              The Protocol parameter can be either "WEC","DAV", or "any"
//              the latter meaning that the protocol doesn't matter.
//              Protocol selection is currently an ISSUE.  This requires
//              the m_hwndOwner and m_pwb members to be inited.
//
//-------------------------------------------------------------------------

STDMETHODIMP 
Cwfolders::navigateFrame(BSTR bstrUrl, BSTR bstrTargetFrame, /*BSTR bstrProtocol,*/
                         BSTR * pbstrRetVal) 
{
    IUnknown* punk;

    if(!m_pwb)
    {
        return E_FAIL;
    }

    HRESULT hr = m_pwb->QueryInterface(IID_IUnknown, (void **) &punk);
    if (FAILED (hr))
    {
        return hr;
    }

    hr = navigateInternal(bstrUrl, bstrTargetFrame, /*bstrProtocol,*/ USE_NO_UI, punk);
    punk->Release();
    SetScriptErrorMessage (hr, pbstrRetVal);
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     Cwfolders::navigateNoSite
//
//  Synopsis:   This does a folder navigation but doesn't require the behavior
//              to be started in the normal way.  (you can just call this
//              with the punk.  That punk should be to an object with an
//              IWebBrowser2 interface.)  
//
//-------------------------------------------------------------------------

STDMETHODIMP
Cwfolders::navigateNoSite (BSTR bstrUrl, BSTR bstrTargetFrame, /*BSTR bstrProtocol,*/
               DWORD dwhwnd, IUnknown* punk)
{
    HRESULT hr = E_FAIL;

    if ((!(m_hwndOwner = (HWND)LongToHandle(dwhwnd))) || !punk)
    {
        goto done;
    }

    // We should release any old members here
    if (m_pwb)
    {
        ReleaseInterface (m_pwb);
        m_pwb = NULL;
    }

    hr = punk->QueryInterface(IID_IWebBrowser2, (void **) &m_pwb);
    if (FAILED (hr))
        m_pwb = NULL;
    
    if (m_pwb)
        hr = navigateInternal(bstrUrl, bstrTargetFrame, /*bstrProtocol,*/ USE_ALL_UI, punk);
    else
        hr = E_FAIL;

done:
    return hr;
}

// ========================================================================
// IElementBehaviorSite
// ========================================================================

//+------------------------------------------------------------------------
//
//  Member:     Cwfolders::Init
//
//  Synopsis:   Called when this code is initialized as a behavior.  This
//              sets up the m_pwb, m_pSite, and m_hwndOwner members as 
//              well.
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE 
Cwfolders::Init (IElementBehaviorSite __RPC_FAR *pBehaviorSite) 
{
    HRESULT hr = E_INVALIDARG;

    if (pBehaviorSite != NULL)
    {
        m_pSite = pBehaviorSite;
        m_pSite->AddRef();
    
        if (m_pwb)
        {
            ReleaseInterface(m_pwb);
            m_pwb = NULL;
        }

        // gets browser window handle (for ui)
        hr = GetClientSiteWindow(m_pSite, &m_hwndOwner);
        if (SUCCEEDED(hr))
            // Get the browser
            hr = IUnknown_QueryService(m_pSite, SID_SWebBrowserApp, 
                                       IID_IWebBrowser2, (LPVOID *) &m_pwb);     
    }
    return hr;  
}

//+------------------------------------------------------------------------
//
//  Member:     Cwfolders::Notify
//
//  Synopsis:   Not really used, but needed by the interface...
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE 
Cwfolders::Notify (LONG lEvent, VARIANT __RPC_FAR *pVar) 
{
    return S_OK;    
}

// ========================================================================
// IObjectSafety
// ========================================================================

//+------------------------------------------------------------------------
//
//  Member:     Cwfolders::SetInterfaceSafetyOptions
//
//  Synopsis:   Prevents those pesky security dialogs from popping up.
//              We are ALWAYS secure.
//
//-------------------------------------------------------------------------

STDMETHODIMP 
Cwfolders::SetInterfaceSafetyOptions (REFIID riid,
    DWORD dwSupportedOptions, DWORD dwEnabledOptions) 
{
    if (riid == IID_Iwfolders) 
    {
        // Since this object is always safe to use, no matter the input,
        // this returns S_OK all the time.
        return S_OK;
    }
    return IObjectSafetyImpl<Cwfolders>::SetInterfaceSafetyOptions (
        riid, dwSupportedOptions, dwEnabledOptions);
}

// ========================================================================
// Internal helper functions
// ========================================================================

//+------------------------------------------------------------------------
//
//  Member:     Cwfolders::navigateInternal
//
//  Synopsis:   All the other navigate functions call this one... this is
//              the one that does everything.  It first creates a thread
//              which will run ParseDisplayName from office.  Then, it 
//              makes a window that will recieve messages from the new 
//              thread.  Finally, it spends it's time in a DialogBox
//              call.  The normal flow is like this:
//
//  PDN Thread ---------WM_WEBFOLDER_NAV----------> Message Window
//  (PDN thread dies)
//  Message Window -----WM_WEBFOLDER_DONE---------> Dialog Window
//  (dialog and message windows close, this function returns)
//
//              The dialog we put up has a cancel button though....
//
//  (user hits cancel)
//  Dialog Window ------WM_WEBFOLDER_CANCEL-------> MessageWindow
//  MessageWindow ------WM_WEBFOLDER_DONE---------> DialogWindow
//  (dialog window closes, this function returns)
//  PDN Thread ---------WM_WEBFOLDER_NAV----------> MessageWindow
//  (PDN thread dies and message window closes)
//
//              The argsThreadArgs local variable in this function is
//              used to pass information between this function, the
//              message window, the dialog window, and the PDN thread.
//              Be careful that this variable isn't used by more than one
//              piece of code at once!!
//
//-------------------------------------------------------------------------

STDMETHODIMP
Cwfolders::navigateInternal(BSTR bstrUrl, BSTR bstrTargetFrame, /*BSTR bstrProtocol,*/ int iUI, IUnknown* punk) 
{
    HRESULT hr = E_FAIL;
    DWORD dwScheme;

    // This is what is used to pass all sorts of stuff between the different
    // windows and threads below.
    CThreadArgs argsThreadArgs;

    DWORD dwThread = 0;
    void * pThread = NULL;

    HWND hwndMessage = 0;

    WCHAR wszClassName [] = WFOLDERSWNDCLASS;

    uCLSSPEC classpec;
    URL_COMPONENTS urlcomp;
    VARIANT vTarget;
    LPITEMIDLIST pidl = NULL;

    // sanity check.
    if (!bstrUrl)
        BAILOUT (E_INVALIDARG);

    // Can't be longer than MAX_WEB_FOLDER_LENGTH
    if (SysStringLen(bstrUrl) > MAX_WEB_FOLDER_LENGTH)
    {
        if (iUI & USE_ERROR_BOXES)
            ShowError (m_hwndOwner, IDS_ERRORURLTOOLONG, 
                       IDS_ERRORURLTOOLONGTITLE, NULL); 
        BAILOUT (E_INVALIDARG);
    }

    /*
    // Check and make sure the protocol makes sense.
    if (bstrProtocol && (! (0==StrCmpICW(L"wec", bstrProtocol) ||
                            0==StrCmpICW(L"dav", bstrProtocol) ||
                            0==StrCmpICW(L"any", bstrProtocol))))
    {
        BAILOUT (E_INVALIDARG);
    }
    */

    // if the url is ftp, then we are just going to assume that Office
    // can't handle it.  We save the user the fun of the 10 minute IOD
    memset (&urlcomp, 0, sizeof(urlcomp));
    urlcomp.dwStructSize = sizeof(urlcomp);
    urlcomp.dwHostNameLength = 1;
    urlcomp.dwUrlPathLength = 1;
    urlcomp.dwExtraInfoLength = 1;

    if (!InternetCrackUrlW(bstrUrl, 0, 0, &urlcomp))
        BAILOUT(E_INVALIDARG);

    /*
    if (urlcomp.nScheme != INTERNET_SCHEME_HTTP &&
        urlcomp.nScheme != INTERNET_SCHEME_HTTPS &&
        bstrProtocol && (0==StrCmpICW(L"dav", bstrProtocol) ||
                         0==StrCmpICW(L"wec", bstrProtocol)))
    {
        BAILOUT(E_INVALIDARG);
    }
    */
    
    if (urlcomp.nScheme == INTERNET_SCHEME_FTP ||
        urlcomp.nScheme == INTERNET_SCHEME_FILE)
    {
        if (iUI & USE_FAILED_QUESTION)
        {
            ShowNavigationFailedQuestion (bstrUrl, bstrTargetFrame); 
            goto done;
        }
        else BAILOUT(IPP_E_SERVERTYPE_NOT_SUPPORTED);
        
        //vTarget.vt = VT_BSTR;
        //vTarget.bstrVal = bstrTargetFrame;

        //m_pwb->Navigate (bstrUrl, NULL, &vTarget, NULL, NULL);
        //BAILOUT(S_OK);
    }
    

    // JIT install Office NSE.
    // - note, do not call JIT on NT5 since it is not supported
    OSVERSIONINFO osVersionInfo;
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (GetVersionEx(&osVersionInfo) &&
        (osVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT ) &&
        (osVersionInfo.dwMajorVersion > 4)   )
    {
      // this is NT5, no need to call JIT
    }
    else
    {
        classpec.tyspec=TYSPEC_CLSID;
        classpec.tagged_union.clsid=CLSID_IOD;    
        if (FAILED(FaultInIEFeature(m_hwndOwner, &classpec, NULL, 0)))
            BAILOUT(S_FALSE);  // this is where the script error code "CANCEL" originates
    }
    
/****************************** DANPOZ    ************************
    // Give office an URL and ask for a pidl back.  Do that in a 
    // seperate thread.  
    argsThreadArgs.m_hwndDialog = 0;     // must be done in case
                                       // the message thread needs to
                                       // find out if the dialog is open
    argsThreadArgs.m_bstrUrl = SysAllocString (bstrUrl);
    argsThreadArgs.m_pidl = NULL;
    argsThreadArgs.m_hrReady = E_FAIL;
    argsThreadArgs.m_ipdnStatus = READY_WORKING;
    argsThreadArgs.m_imsgStatus = READY_WORKING;


    // make message window      
    WNDCLASSEX wcex;
        
    wcex.cbSize         = sizeof(WNDCLASSEX); 
    wcex.style          = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc    = NavMessageProc;
    wcex.cbClsExtra     = 0;
    wcex.cbWndExtra     = 0;
    wcex.hInstance      = g_hInst;
    wcex.hIcon          = NULL;
    wcex.hCursor        = NULL;
    wcex.hbrBackground  = NULL;
    wcex.lpszMenuName   = NULL;
    wcex.lpszClassName  = wszClassName;
    wcex.hIconSm        = NULL;

    RegisterClassEx(&wcex);   

    argsThreadArgs.m_hwndMessage = CreateWindow(wszClassName, NULL, NULL,
        0, 0, 0, 0, NULL, NULL, g_hInst, NULL);        
    if (argsThreadArgs.m_hwndMessage == NULL)
        BAILOUT (E_FAIL);
    SendMessage (argsThreadArgs.m_hwndMessage, WM_WEBFOLDER_INIT, 0, (LPARAM) &argsThreadArgs);

    // run Office's ParseDisplayName in a different thread.  It will be
    // sending messages to the argsThreadArgs.hwndMessage.  It copies all
    // information from that structure it needs first, then sets a flag
    // which allows this procedure to deallocate the memory.
    pThread = CreateThread (NULL, 0, RunParseDisplayName, &argsThreadArgs, 0, &dwThread);    

    if (pThread == NULL)
    {
        DestroyWindow (hwndMessage);
        BAILOUT (E_FAIL);
    }

    // Wait until RunParseDisplayName makes copies of the data it needs before
    // deleting it. (which would happen if the function returns)
    while (argsThreadArgs.m_ipdnStatus == READY_WORKING)
        Sleep(0);

    // our fancy dialog (with animation!)
    DialogBoxParam (g_hInst, MAKEINTRESOURCE (IDD_WEBFOLDER_SEARCH), m_hwndOwner, 
        WaitDlgProc, (LPARAM) &argsThreadArgs);

    SetFocus (m_hwndOwner);
    
    if (argsThreadArgs.m_imsgStatus == READY_DONE)  //user didn't hit cancel

    {
        hr = argsThreadArgs.m_hrReady;
******************************** DANPOZ *****************************/

/******************************** DANPOZ *****************************/
        hr = CreateWebFolderIDList( bstrUrl, &pidl, m_hwndOwner, punk);
/**********************************************************************/

        switch (hr)
        {
            case S_OK:
                // navigate to the pidl returned by office
                // ---------------------------------------

                // the message handling window packs the pidl it got from
                // office (through WM_WEBFOLDER_NAV) into the .pidl of
                // argsThreadArgs.
                /******** ************** DANPOZ *********************
                hr = NavToPidl (argsThreadArgs.m_pidl, bstrTargetFrame, m_pwb);
                *****************************************************/
                /*********************** DANPOZ NEW ***************/
                hr = NavToPidl (pidl, bstrTargetFrame, m_pwb);
                /*********************************  ***************/
                if (FAILED (hr))
                {
                    hr = E_FAIL;
                    if (iUI & USE_WEB_PAGE_UI)
                        ShowNavigationFailed (m_hwndOwner, bstrUrl, bstrTargetFrame,
                                              L"res://shdoclc.dll/http_gen.htm");
                    goto done;
                }
                else
                    hr = S_OK;
                break;
            case E_OUTOFMEMORY: //handled lower, under cleanup
                break;
            case MK_E_CONNECTMANUALLY: //returned to us if we sent Office an ftp or file url.  Shouldn't
                                       // happen at all (we filter those.) unless called via script
            case IPP_E_SERVERTYPE_NOT_SUPPORTED:
                // The server doesn't support our extensions, but does 
                // exist
                if (iUI & USE_FAILED_QUESTION)
                {
                    ShowNavigationFailedQuestion (bstrUrl, bstrTargetFrame); 
                    goto done;
                }
                break;
            case DB_SEC_E_PERMISSIONDENIED:
                // authentication failed
                if (iUI & USE_WEB_PAGE_UI)
                    ShowNavigationFailed (m_hwndOwner, bstrUrl, bstrTargetFrame,
                                          L"res://shdoclc.dll/http_403.htm");
                break;
            case STG_E_ACCESSDENIED:
            case STG_E_SHAREVIOLATION:
            case IPP_E_OFFLINE:
                hr = IPP_E_OFFLINE;
                if (iUI & USE_ERROR_BOXES)
                    ShowError (m_hwndOwner, IDS_ERROROFFLINE, 
                               IDS_ERROROFFLINETITLE, NULL); 
                break;
            case DB_E_TIMEOUT:
                // bind procedure timed out
                if (iUI & USE_WEB_PAGE_UI)
                    ShowNavigationFailed (m_hwndOwner, bstrUrl, bstrTargetFrame,
                                          L"res://shdoclc.dll/dnserror.htm");
                break;
            case ERROR_MOD_NOT_FOUND:
            case 0x8007007e: // this value is coming back.  VC 6 looks it up like
                             // ERROR_MOD_NOT_FOUND which is really what happened
                             // (office wasn't there)  But ERROR_MOD_NOT_FOUND 
                             // has a different number. 
                // This gets called when the IOD passes, but the namespace
                // extension isn't there.  This should never get called.
                hr = E_FAIL;
                break;
            case MK_E_SYNTAX:
            case MK_E_NOOBJECT:
            case MK_E_UNAVAILABLE:
            case MK_E_NOSTORAGE:
            case E_INVALIDARG:     
                //hr = MK_E_NOOBJECT;
                //if (iUI & USE_WEB_PAGE_UI)
                //    ShowNavigationFailed (m_hwndOwner, bstrUrl, bstrTargetFrame,
                //                          L"res://shdoclc.dll/dnserror.htm");
                //break;

                //ISSUE - hack follows for bug 47127 - We "should" catch most real
                // invalid args in the param checking at the beginning of this method,
                // but forcing hr to IPP_E_SERVERTYPE_NOT_SUPPORTED makes it impossible to
                // detect a real invalid arg situation that we missed above (i.e. targetframe)
                hr = IPP_E_SERVERTYPE_NOT_SUPPORTED; //Force correct error code for script

                //Fall through as per bug 43338
            default:
#ifdef NONB2_HACK                
                hr = E_FAIL;
                // Something went wrong, we know not what.  Give a relatively
                // general error page.
                if (iUI & USE_WEB_PAGE_UI)
                    ShowNavigationFailed (m_hwndOwner, bstrUrl, bstrTargetFrame,
                                          L"res://shdoclc.dll/http_gen.htm");
                goto done;
                break;
#else
                // For beta 2 (bug 43338) we're going to 
                if (iUI & USE_FAILED_QUESTION)
                {
                    ShowNavigationFailedQuestion (bstrUrl, bstrTargetFrame); 
                    goto done;
                }
                break;
#endif
        }
/****************** DANPOZ ***************************
    }
    else
        hr = S_FALSE;
******************************************************/

cleanup:
    if (hr == E_OUTOFMEMORY)
        if (iUI & USE_ERROR_BOXES)
           ShowError (m_hwndOwner, IDS_ERROROUTOFMEMORY, 
                      IDS_ERROROUTOFMEMORYTITLE, NULL); 
    if (hr == E_FAIL)
        if (iUI & USE_ERROR_BOXES)
            ShowError (m_hwndOwner, IDS_ERRORINTERNAL, 
                       IDS_ERRORINTTITLE, NULL); 
    if (hr == E_INVALIDARG)
        if (iUI & USE_WEB_PAGE_UI)
            ShowNavigationFailed (m_hwndOwner, bstrUrl, bstrTargetFrame,
                                  L"res://shdoclc.dll/http_gen.htm");   

done:
    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     Cwfolders::ShowNavigationFailedQuestion
//
//  Synopsis:   This is what we want to call when we can't get a folder 
//              view of the resource, but we might be able to get a file
//              view (normal).  This asks the user if he/she wants us to
//              try.  Navigates to the target frame.
//
//-------------------------------------------------------------------------

void 
Cwfolders::ShowNavigationFailedQuestion (BSTR bstrUrl, BSTR bstrTargetFrame)
{
    VARIANT vEMPTY;
    VariantInit (&vEMPTY);
    VARIANT * PVAREMPTY = &vEMPTY;
        
    WCHAR wszMessage [MAX_LOADSTRING+1];
    WCHAR wszTitle   [MAX_LOADSTRING+1];

    LoadString(g_hInst, IDS_ERRORBADSERVER, wszMessage, ARRAYSIZE(wszMessage));
    LoadString(g_hInst, IDS_ERRORBADSERVERTITLE, wszTitle, ARRAYSIZE(wszTitle));
    WCHAR * wsErrorMessage = new WCHAR [MAX_LOADSTRING+wcslen(bstrUrl)+1];
    if (!wsErrorMessage)
    {
        ShowError (m_hwndOwner, IDS_ERROROUTOFMEMORY, 
                   IDS_ERROROUTOFMEMORYTITLE, NULL); 
        delete[] wsErrorMessage;
        return;
    }
    wnsprintf (wsErrorMessage, MAX_LOADSTRING+wcslen(bstrUrl), wszMessage, bstrUrl);
    int iButton = MessageBox (m_hwndOwner, 
                              wsErrorMessage,
                              wszTitle,
                              MB_YESNO | MB_ICONQUESTION);
    delete[] wsErrorMessage;
    if (iButton == IDYES)
    {
        VARIANT vTarget;
        vTarget.vt = VT_BSTR;
        vTarget.bstrVal = bstrTargetFrame;

        m_pwb->Navigate (bstrUrl, NULL, &vTarget, NULL, NULL);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     Cwfolders::NavToPidl
//
//  Synopsis:   Comparatively low level helper function that navigates
//              a given pidl (from office) to the target frame given.
//              The web browser 2 arg does not have to refer to the
//              correct frame.
//
//-------------------------------------------------------------------------

HRESULT 
Cwfolders::NavToPidl (LPITEMIDLIST pidl, BSTR bstrTargetFrame, IWebBrowser2 * pwb)
{
    VARIANT vPidl;
    HRESULT hr;
    IWebBrowser2 * pwbf = NULL;
    ITargetFrame * ptf = NULL;
    IUnknown * punknown = NULL;
    VARIANT vEMPTY;
    VariantInit (&vEMPTY);
    VARIANT * PVAREMPTY  = &vEMPTY;

    hr = InitVARIANTFromPidl(&vPidl, pidl);
    if (FAILED(hr))
        return hr;

    // This is here to change frames, or to make a new one as the case my
    if (bstrTargetFrame && (0!=StrCmpICW(L"", bstrTargetFrame)))
    {
        hr = pwb->QueryInterface(IID_ITargetFrame, (void **)&ptf);     
        FAILONBAD_HR(hr);
        hr = ptf->FindFrame (bstrTargetFrame, (IUnknown *) pwb, 0, &punknown);
        if (FAILED (hr))
        {
            hr = CreateTargetFrame (bstrTargetFrame, &punknown);
        }
        FAILONBAD_HR(hr);
        hr = punknown->QueryInterface(IID_IWebBrowser2, (void **)&pwbf);
        FAILONBAD_HR(hr);
    }
    else
    {
        pwbf = pwb;
    }

    // the actual navigation!
    hr = pwbf->put_Visible (VARIANT_TRUE);
    if (SUCCEEDED (hr))
    {
        pwbf->Stop();
        hr = pwbf->Navigate2(&vPidl, PVAREMPTY, PVAREMPTY, PVAREMPTY, PVAREMPTY);
    }
cleanup:
    ReleaseInterface (ptf);
    if (pwb != pwbf)
        ReleaseInterface (pwbf);
    ReleaseInterface (punknown);

    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     Cwfolders::RunParseDisplayName
//
//  Synopsis:   Runs ParseDisplayName.  This is abstracted to use as a
//              seperate thread.
//
//-------------------------------------------------------------------------

DWORD WINAPI 
Cwfolders::RunParseDisplayName (LPVOID pArguments)
{
    HRESULT hr = E_FAIL;

    CThreadArgs *pInfo = (CThreadArgs *)pArguments;
    LPITEMIDLIST pidl = NULL;
    HWND hwndMessage = pInfo->m_hwndMessage;
    BSTR bstrUrl = SysAllocString (pInfo->m_bstrUrl);

    // This will signal that pInfo is safe to be released (we have all the info 
    // we need out of it)  pInfo should NEVER be referenced in this function
    // after this value is set.
    pInfo->m_ipdnStatus = READY_INITIALIZED;

    if (!bstrUrl)
    {
        PostMessage (hwndMessage, WM_WEBFOLDER_NAV, 0, (LPARAM) E_OUTOFMEMORY);
        goto cleanup;
    }

    // calls the appropriate ParseDisplayName
    /******************DANPOZ*********************
    hr = CreateWebFolderIDList(bstrUrl, &pidl);
    **********************************************/
    // because of some OLE restrictions, this call must be PostMesage,
    // not SendMessage.
    PostMessage (hwndMessage, WM_WEBFOLDER_NAV, (WPARAM) pidl, (LPARAM) hr);
    
cleanup:
    SysFreeString (bstrUrl);
    return hr;
}

//+------------------------------------------------------------------------
//
//  NAME:         Cwfolders::WaitDlgProc
//
//  SYNOPSIS:     This is the handler for our little dialog.  It will get
//                a WM_WEBFOLDER_DONE message when it should die.
//
//-------------------------------------------------------------------------

INT_PTR CALLBACK 
Cwfolders::WaitDlgProc (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CThreadArgs * pInfo = NULL;
    HWND hAnimation;
    HWND hStatic;

    switch (message)
    {
    case WM_COMMAND:
        if (LOWORD(wParam) == IDCANCEL) 
        {
            pInfo = (CThreadArgs *) GetProp (hDlg, __INFO);
            if (!pInfo)
                return E_FAIL;
            PostMessage (pInfo->m_hwndMessage, WM_WEBFOLDER_CANCEL, 0, 0);
        }   
        return TRUE;

    case WM_INITDIALOG:
        if (!lParam)
            return E_INVALIDARG;
        pInfo = (CThreadArgs *) lParam;
        // if this is true then there is no message window (PDN thread closed
        // it before we could even start the wait dialog.)  Just close the
        // dialog because everything is already done.
        if (pInfo->m_imsgStatus == READY_DONE)
            EndDialog (hDlg, 0);
        else
        {
            if (!SetProp (hDlg, __INFO, (void *)lParam))
                return E_FAIL;
            // Change our text string to something with the URL in it.
            // If this section fails for any reason, the dialog will keep
            // the generic "IE is looking for your folder" message.
            {
                WCHAR wsMessage [MAX_LOADSTRING+1]; 
                WCHAR *wsStatus = new WCHAR[wcslen(pInfo->m_bstrUrl)+1+MAX_LOADSTRING];
                if (wsStatus)
                {
                    LoadString ( g_hInst, IDS_WEBFOLDER_FIND, wsMessage, ARRAYSIZE(wsMessage) );

                    DWORD dwResultSize;
                    WCHAR wsResult [INTERNET_MAX_URL_LENGTH]; 

                    if (SUCCEEDED (CoInternetParseUrl(pInfo->m_bstrUrl, PARSE_DOMAIN, 
                         0, wsResult, ARRAYSIZE(wsResult), &dwResultSize, 0)))
                    {
                        wnsprintf (wsStatus, wcslen(pInfo->m_bstrUrl)+MAX_LOADSTRING, 
                            wsMessage, wsResult);
                        hStatic = GetDlgItem (hDlg, IDC_WEBFOLDER_MESSAGE);
                        if (hStatic)
                            SendMessage (hStatic, WM_SETTEXT, 0, (LPARAM) wsStatus);
                    }
                    
                    delete[] wsStatus;
                }
            }
            // At this point, we are ready to get messages from the
            // message window, so let it know our hwnd.
            pInfo->m_hwndDialog = hDlg;
            hAnimation = GetDlgItem (hDlg, IDC_WEBFOLDER_ANIMATE);
            if (hAnimation)
                Animate_Open(hAnimation, MAKEINTRESOURCE(IDA_ISEARCH));
        }
        return S_OK;

    case WM_WEBFOLDER_DONE:
        // The message window is closing us.
        EndDialog (hDlg, 0);
        break;

    case WM_DESTROY:
        hAnimation = GetDlgItem (hDlg, IDC_WEBFOLDER_ANIMATE);
        if (hAnimation)
        {
            Animate_Close(hAnimation);
        }        
        RemoveProp (hDlg, __INFO);
        break;
    }
    return DefWindowProc(hDlg, message, wParam, lParam);
}

//+------------------------------------------------------------------------
//
//  NAME:         Cwfolders::NavMessageProc
//
//  SYNOPSIS:     This is the message handler for the ParseDisplayName call.
//
//-------------------------------------------------------------------------

INT_PTR CALLBACK 
Cwfolders::NavMessageProc (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CThreadArgs * pInfo = NULL;
    HANDLE hCancel;
    HWND hwndDialog;

    switch (message)
    {
    case WM_CREATE:
        if (!SetProp (hDlg, __CANCEL, STATUS_READY))
            return E_FAIL;
        return S_OK;

    case WM_WEBFOLDER_INIT:
        if (!lParam)
            return E_INVALIDARG;
        pInfo = (CThreadArgs *) lParam;
        if (!SetProp (hDlg, __INFO, (void *)lParam))
            return E_FAIL;
        pInfo->m_hwndMessage = hDlg;
        break;
    
    case WM_WEBFOLDER_CANCEL:
        pInfo = (CThreadArgs *) GetProp (hDlg, __INFO);
        if (!pInfo)
            return E_FAIL;
        if (!SetProp (hDlg, __CANCEL, STATUS_CANCELED))
            return E_FAIL;
        hwndDialog = pInfo->m_hwndDialog;
        // let the navigateInternal call know that we are canceled.
        pInfo->m_imsgStatus = READY_CANCEL;
        if (hwndDialog)
            SendMessage (hwndDialog, WM_WEBFOLDER_DONE, 0, 0);
        return S_OK;

    case WM_WEBFOLDER_NAV:
        hCancel = GetProp (hDlg, __CANCEL);
        if (!hCancel)
            return E_FAIL;
        if (hCancel != STATUS_CANCELED)
        {
            // we wait to get pInfo because if we canceled before, it
            // doesn't exist anymore!
            pInfo = (CThreadArgs *) GetProp (hDlg, __INFO);
            if (!pInfo)
                return E_FAIL;

            pInfo->m_pidl = (LPITEMIDLIST) wParam;
            pInfo->m_hrReady = (HRESULT)lParam;
            hwndDialog = pInfo->m_hwndDialog;
            pInfo->m_imsgStatus = READY_DONE;
            if (hwndDialog)
                SendMessage (hwndDialog, WM_WEBFOLDER_DONE, 0, 0);
        }
        DestroyWindow (hDlg);
        return TRUE;

    case WM_DESTROY:
        RemoveProp (hDlg, __CANCEL);
        RemoveProp (hDlg, __INFO);
        break;
    }
    return DefWindowProc(hDlg, message, wParam, lParam);
}

//+------------------------------------------------------------------------
//
//  Member:     Cwfolders::ShowError
//
//  Synopsis:   Throws up a message box.  The two unsinged ints point to
//              entries in the string table.  If the bstr is set, it will
//              be placed in the %s location in the string table.  
//
//-------------------------------------------------------------------------

void 
Cwfolders::ShowError (HWND hwnd, unsigned int IDSmessage, 
                      unsigned int IDStitle, BSTR bstrUrl)
{
    WCHAR wszMessage [MAX_LOADSTRING+1];
    WCHAR wszTitle   [MAX_LOADSTRING+1];

    LoadString(g_hInst, IDSmessage, wszMessage, ARRAYSIZE(wszMessage));
    LoadString(g_hInst, IDStitle, wszTitle, ARRAYSIZE(wszTitle));
    if (bstrUrl)
    {
        WCHAR * wsErrorMessage = new WCHAR [MAX_LOADSTRING+wcslen(bstrUrl)+1];
        if (!wsErrorMessage)
        {
            ShowError (hwnd, IDS_ERROROUTOFMEMORY, IDS_ERROROUTOFMEMORYTITLE, NULL); 
            return;
        }
        wnsprintf (wsErrorMessage, MAX_LOADSTRING+wcslen(bstrUrl), wszMessage, bstrUrl);
        MessageBox (hwnd, wsErrorMessage, wszTitle, MB_OK | MB_ICONERROR);
        delete[] wsErrorMessage;
    }
    else
        MessageBox (hwnd, wszMessage, wszTitle, MB_OK | MB_ICONERROR);
}
    
//+------------------------------------------------------------------------
//
//  Member:     Cwfolders::ShowNavigationFailed
//
//  Synopsis:   This guy gets called when there is no chance we can show
//              the requested resource in ANY view.  For instance, if the
//              DNS lookup fails.
//
//-------------------------------------------------------------------------

void 
Cwfolders::ShowNavigationFailed (HWND hWnd, BSTR bstrUrl, BSTR bstrTargetFrame,
                                 WCHAR * wszResource)
{
    VARIANT vTarget;
    vTarget.vt = VT_BSTR;

    // +1 for \0 and +1 for '#'
    WCHAR * wszResUrl = new WCHAR [wcslen(bstrUrl) + wcslen(wszResource) + 2];
    
    if (wszResUrl)
    {
        // This is how to hack a different URL into the address bar when
        // showing an error page without having the address of the error
        // page in there too.
        wszResUrl [0] = NULL;
        wcscat (wszResUrl, wszResource);
        wcscat (wszResUrl, L"#");
        wcscat (wszResUrl, bstrUrl);

        vTarget.bstrVal = bstrTargetFrame;
        m_pwb->Navigate (wszResUrl, NULL, &vTarget, NULL, NULL);
        delete [] wszResUrl;
    }
    else
    {
        // the memory allocation failed.  Oh well, so the url in
        // the address bar is wrong.  
        vTarget.bstrVal = bstrTargetFrame;
        m_pwb->Navigate (wszResource, NULL, &vTarget, NULL, NULL);
    }
}
     
//+------------------------------------------------------------------------
//
//  Member:     Cwfolders::CreateWebFolderIDList
//
//  Synopsis:   Asks office nse for a pidl, given an URL.  This was written
//              by Chris Guzak to be compatible with NT 5, which puts the 
//              office nse in a different place from NT 4, 9x.
//
//-------------------------------------------------------------------------

HRESULT 
//Cwfolders::CreateWebFolderIDList(BSTR bstrUrl, LPITEMIDLIST *ppidl)
Cwfolders::CreateWebFolderIDList(BSTR bstrUrl, LPITEMIDLIST *ppidl, HWND hwnd, IUnknown* punk)
{
    IShellFolder *psf = NULL;
    HRESULT hr = SHGetDesktopFolder(&psf);
    if (SUCCEEDED(hr))
    {
        IBindCtx *pbc;
        hr = CreateBindCtx(0, &pbc);
        if (SUCCEEDED(hr))
        {        
            hr = pbc->RegisterObjectParam((LPOLESTR)STR_PARSE_PREFER_FOLDER_BROWSING, punk);
            if (SUCCEEDED(hr))
            {
                ULONG ulAttr = SFGAO_FOLDER;
                if (SUCCEEDED(hr = psf->ParseDisplayName(NULL, pbc, bstrUrl, NULL, ppidl, &ulAttr)))
                {
                    if (!(ulAttr & SFGAO_FOLDER))
                    {
                        // fancy footwork to navigate to the parent folder if one exists
                        WCHAR * wszParentUrl = new WCHAR [1+SysStringLen(bstrUrl)];
                        if (wszParentUrl)
                        {
                            DWORD dwBuffSize = SysStringLen(bstrUrl);
                            // get name of parent folder
                            if (InternetCombineUrlW (bstrUrl, L"", wszParentUrl, &dwBuffSize, ICU_NO_ENCODE))
                            {
                                ulAttr = SFGAO_FOLDER;
                                hr = psf->ParseDisplayName(NULL, pbc, wszParentUrl, NULL, ppidl, &ulAttr);
                                if (SUCCEEDED(hr))
                                {   
                                    if (!(ulAttr & SFGAO_FOLDER))
                                        hr = MK_E_NOSTORAGE;
                                }
                            }
                            else
                            {
                                switch (GetLastError()) 
                                {
                                    case ERROR_BAD_PATHNAME:
                                        hr = MK_E_NOSTORAGE;
                                        break;
                                    case ERROR_INSUFFICIENT_BUFFER:
                                        hr = E_OUTOFMEMORY;
                                        break;
                                    case ERROR_INTERNET_INVALID_URL:
                                        hr = E_INVALIDARG;
                                        break;
                                    default:
                                        hr = E_FAIL;
                                }
                            }
                            delete [] wszParentUrl;
                        }
                        else
                            hr = E_OUTOFMEMORY;
                    }
                }
         
            }                
            pbc->Release();
        }
        psf->Release();
    }

      
   if(FAILED(hr))
   {
   
        IShellFolder *psfb = NULL;
        hr = SHGetDesktopFolder(&psf);

        if (SUCCEEDED(hr))
        {
            IBindCtx *pbc;
            hr = CreateBindCtx(0, &pbc);
            if (SUCCEEDED(hr))
            {
                BIND_OPTS bo;
                memset(&bo, 0, sizeof(bo));
                bo.cbStruct = sizeof(bo);
                bo.grfFlags = BIND_JUSTTESTEXISTENCE;
                bo.grfMode = STGM_CREATE;
                pbc->SetBindOptions(&bo);
                
                // CLSID_MyComputer CLSID_WebFolders
                WCHAR wszPath[] = L"::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{BDEADF00-C265-11D0-BCED-00A0C90AB50F}";

                LPITEMIDLIST pidlo = NULL;
                LPITEMIDLIST pidlurl = NULL;
                ULONG chEaten = 0;
                ULONG ulAttr = SFGAO_FOLDER;

                // first PDN gets the Office shell folder pidl, then bind to it, next PDN tries for a pidl
                // to our specific URL
                if (SUCCEEDED(hr = psf->ParseDisplayName(NULL, pbc, wszPath, &chEaten, &pidlo, &ulAttr)) ) 
                {
                    if( SUCCEEDED(hr = psf->BindToObject (pidlo, NULL, IID_IShellFolder, (void **) &psfb)) )
                    { 
                        if( SUCCEEDED(hr = psfb->ParseDisplayName(hwnd, pbc, bstrUrl, &chEaten, &pidlurl, &ulAttr)))
                        {
                            if (!(ulAttr & SFGAO_FOLDER))
                            {
                                // fancy footwork to navigate to the parent folder if one exists
                                WCHAR * wszParentUrl = new WCHAR [1+SysStringLen(bstrUrl)];
                                if (wszParentUrl)
                                {
                                    DWORD dwBuffSize = SysStringLen(bstrUrl);
                                    // get name of parent folder
                                    if (InternetCombineUrlW (bstrUrl, L"", wszParentUrl, &dwBuffSize, ICU_NO_ENCODE))
                                    {
                                        ulAttr = SFGAO_FOLDER;
                                        hr = psfb->ParseDisplayName(NULL, pbc, wszParentUrl, &chEaten, &pidlurl, &ulAttr);
                                        if (SUCCEEDED(hr))
                                        {   
                                            if (!(ulAttr & SFGAO_FOLDER))
                                            hr = MK_E_NOSTORAGE;
                                        }
                                    }
                                    else
                                    {
                                        switch (GetLastError()) 
                                        {
                                            case ERROR_BAD_PATHNAME:
                                                hr = MK_E_NOSTORAGE;
                                                break;
                                            case ERROR_INSUFFICIENT_BUFFER:
                                                hr = E_OUTOFMEMORY;
                                                break;
                                            case ERROR_INTERNET_INVALID_URL:
                                                hr = E_INVALIDARG;
                                                break;
                                            default:
                                                hr = E_FAIL;
                                        }
                                    }
                                    delete [] wszParentUrl;
                                }
                                else
                                    hr = E_OUTOFMEMORY;
                            }
                    
                            if (pidlurl && pidlo)
                                (*ppidl) = ILCombine (pidlo, pidlurl);

                            ILFree(pidlurl);

                        } // psfb->ParseDisplayName

                    } // psf->BindToObject

                    ILFree(pidlo);
                } // psf->ParseDisplayName

                pbc->Release();

            } // CreateBindCtx 
        }

        ReleaseInterface (psf);
        ReleaseInterface (psfb);
    }  
    return hr;
}

// ========================================================================
// The following three functions were taken from an SDK example.
// They are here to facilitate the packing of a PIDL into a 
// VARIANT so that explorer will accept it for an argument to
// Navigate2.
// ========================================================================

//+------------------------------------------------------------------------
//
//  Member:     Cwfolders::InitVARIANTFromPidl
//
//  Synopsis:   Packs a pidl into a VARIANT
//
//-------------------------------------------------------------------------

HRESULT 
Cwfolders::InitVARIANTFromPidl(LPVARIANT pvar, LPITEMIDLIST pidl)   
{
    if (!pidl || !pvar) 
    { 
        return E_POINTER;      
    }
    // Get the size of the pidl and allocate a SAFEARRAY of
    // equivalent size      
    UINT cb = ILGetSize(pidl);
    LPSAFEARRAY psa = MakeSafeArrayFromData((LPBYTE)pidl, cb);      
    if (!psa) 
    { 
        VariantInit(pvar);
        return E_OUTOFMEMORY;  
    }
    pvar->vt = VT_ARRAY|VT_UI1;  
    pvar->parray = psa;
    return NOERROR;  
}

//+------------------------------------------------------------------------
//
//  Member:     Cwfolders::MakeSafeArrayFromData
//
//  Synopsis:   Allocates a SAFEARRAY of cbData size and packs pData into
//              it.
//
//-------------------------------------------------------------------------

LPSAFEARRAY 
Cwfolders::MakeSafeArrayFromData(LPBYTE pData, DWORD cbData)   
{
    LPSAFEARRAY psa;      

    if (!pData || 0 == cbData) 
    {
        return NULL;  // nothing to do
    }
    // create a one-dimensional safe array of BYTEs
    psa = SafeArrayCreateVector(VT_UI1, 0, cbData);      
    if (psa) 
    {
        // copy data into the area in safe array reserved for data
        // Note we party directly on the pointer instead of using locking/
        // unlocking functions.  Since we just created this and no one
        // else could possibly know about it or be using it, this is okay.
        memcpy(psa->pvData,pData,cbData);      
    }      
    
    return psa;   
}

//+------------------------------------------------------------------------
//
//  Member:     Cwfolders::ILGetSize
//
//  Synopsis:   Gets the size of the PIDL by walking the item id list
//
//-------------------------------------------------------------------------

#define _ILSkip(pidl, cb)       ((LPITEMIDLIST)(((BYTE*)(pidl))+cb))
#define _ILNext(pidl)           _ILSkip(pidl, (pidl)->mkid.cb)

UINT 
Cwfolders::ILGetSize(LPITEMIDLIST pidl) 
{
    UINT cbTotal = 0;
    if (pidl) 
    {
        cbTotal += sizeof(pidl->mkid.cb); // Null terminator
        while (pidl->mkid.cb) 
        {
            cbTotal += pidl->mkid.cb;
            pidl = _ILNext(pidl);
        }
    }
    return cbTotal;
}

// ========================================================================
// These two functions live in shdocvw.  They are not, unfortunately,
// exported, so they appear here as well.
// ========================================================================

//+------------------------------------------------------------------------
//
//    NAME:       Cwfolders::ParseTargetType
//
//    SYNOPSIS:   Maps pszTarget into a target class.
//
//    IMPLEMENTATION:
//    Treats unknown MAGIC targets as _self
//
//-------------------------------------------------------------------------

TARGET_TYPE 
Cwfolders::ParseTargetType(LPCOLESTR pszTarget)
{
    const TARGETENTRY *pEntry = targetTable;

    if (pszTarget[0] != '_') return TARGET_FRAMENAME;
    while (pEntry->pTargetValue)
    {
        if (!StrCmpW(pszTarget, pEntry->pTargetValue)) return pEntry->targetType;
        pEntry++;
    }
    //  Treat unknown MAGIC targets as regular frame name! <<for NETSCAPE compatibility>>
    return TARGET_FRAMENAME;

}

//+------------------------------------------------------------------------
//
//  NAME:         Cwfolders::CreateTargetFrame
//
//  SYNOPSIS:     Creates a new window, if pszTargetName is not special
//                target, names it pszTargetName.  returns IUnknown for
//                the object that implements ITargetFrame,IHlinkFrame and
//                IWebBrowserApp.
//
//-------------------------------------------------------------------------

HRESULT 
Cwfolders::CreateTargetFrame(LPCOLESTR pszTargetName, LPUNKNOWN /*IN,OUT*/ *ppunk)
{
    LPTARGETFRAME2 ptgfWindowFrame;
    HRESULT hr = S_OK;

    //  Launch a new window, set it's frame name to pszTargetName
    //  return it's IUnknown. If the new window is passed to us,
    //  just set the target name.

    if (NULL == *ppunk)
    {
#ifndef  UNIX
        hr = CoCreateInstance(CLSID_InternetExplorer, NULL,
                              CLSCTX_LOCAL_SERVER, IID_IUnknown, (LPVOID*)ppunk);
#else
        hr = CoCreateInternetExplorer( IID_IUnknown, 
                                       CLSCTX_LOCAL_SERVER | CLSCTX_INPROC_SERVER,
                                       (LPVOID*) ppunk );
#endif
    }

    if (SUCCEEDED(hr))
    {
        //  Don't set frame name if target is special or missing
        if (pszTargetName && ParseTargetType(pszTargetName) == TARGET_FRAMENAME)
        {
            HRESULT hrLocal;
            hrLocal = (*ppunk)->QueryInterface(IID_ITargetFrame2, (LPVOID *)&ptgfWindowFrame);
            if (SUCCEEDED(hrLocal))
            {
                ptgfWindowFrame->SetFrameName(pszTargetName);
                ptgfWindowFrame->Release();
            }
        }

        // Even if we don't set the frame name, we still want to return
        // success, otherwise we'd have a blank window hanging around.
    }

    return hr;
}

//+------------------------------------------------------------------------
//
//  NAME:         Cwfolders::SetScriptErrorMessage
//
//  SYNOPSIS:     This converts the hresult we would have returned from
//                navigateInternal to a string to pass back to scripts
//
//-------------------------------------------------------------------------

void
Cwfolders::SetScriptErrorMessage (HRESULT hr, BSTR * pbstr)
{
    // These strings are what the scripting language recieves
    // as our return value to navigate and navigateFrame
    // The hr in the switch is the return value of NavigateInternal
    switch (hr)
    {
    case S_OK:
        *pbstr = SysAllocString (L"OK");
        break;
    case IPP_E_SERVERTYPE_NOT_SUPPORTED:
        *pbstr = SysAllocString (L"PROTOCOL_NOT_SUPPORTED");
        break;
    case MK_E_NOOBJECT:
    case DB_E_CANNOTCONNECT:
        *pbstr = SysAllocString (L"LOCATION_DOES_NOT_EXIST");
        break;
    case DB_SEC_E_PERMISSIONDENIED:
        *pbstr = SysAllocString (L"PERMISSION_DENIED");
        break;
    case E_INVALIDARG:
        *pbstr = SysAllocString (L"INVALIDARG");
        break;
    case IPP_E_OFFLINE:
        *pbstr = SysAllocString (L"OFFLINE");
        break;
    case E_OUTOFMEMORY:
        *pbstr = SysAllocString (L"OUTOFMEMORY");
        break;
    case DB_E_TIMEOUT:
        *pbstr = SysAllocString (L"TIMEOUT");
        break;
    case S_FALSE:
        *pbstr = SysAllocString (L"CANCEL");
        break;
    case MK_E_CONNECTMANUALLY: //returned to us if we sent Office an ftp or file url
        *pbstr = SysAllocString (L"PROTOCOL_NOT_SUPPORTED");
        break;
    default:
        *pbstr = SysAllocString (L"FAILED");
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\httpwfh.h ===
//=================================================
//
//  File : httpwfh.h
//
//  purpose : definition of the Cwfolders class
//
//=================================================
// Chad Lindhorst, 1998

#ifndef __HTTPWFH_H_
#define __HTTPWFH_H_

#include <mshtmhst.h>

#include "iextag.h"         // for IID_Iwfolders... etc.
#include "resource.h"       // main symbols
#include "oledb.h"

// This is used to fix the max size for strings loaded from the
// string table.
#define MAX_LOADSTRING MAX_PATH

// This is the longest URL we should send to office.  (anything longer
// will get an error dialog.)  (Should be MAX_PATH - talk to office...)
#define MAX_WEB_FOLDER_LENGTH            MAX_PATH

// This is the guid we use for active setup....
static const GUID CLSID_IOD = 
{ 0x73fa19d0, 0x2d75, 0x11d2, { 0x99, 0x5d, 0x00, 0xc0, 0x4f, 0x98, 0xbb, 0xc9 } };

// Just to look nice.
#define BAILOUT(HR)             {hr=HR; goto cleanup;}
#define FAILONBAD_HR(HR)        {if (FAILED(HR)) BAILOUT(HR);}

// These typedefs and statics are for the target frame creation code taken
// out of shdocvw.  
typedef enum _TARGET_TYPE {
TARGET_FRAMENAME,
TARGET_SELF,
TARGET_PARENT,
TARGET_BLANK,
TARGET_TOP,
TARGET_MAIN,
TARGET_SEARCH
} TARGET_TYPE;

typedef struct _TARGETENTRY {
    TARGET_TYPE targetType;
    const WCHAR *pTargetValue;
} TARGETENTRY;

static const TARGETENTRY targetTable[] =
{
    {TARGET_SELF, L"_self"},
    {TARGET_PARENT, L"_parent"},
    {TARGET_BLANK, L"_blank"},
    {TARGET_TOP, L"_top"},
    {TARGET_MAIN, L"_main"},
    {TARGET_SEARCH, L"_search"},
    {TARGET_SELF, NULL}
};

// Custom Window Messages
#define WM_WEBFOLDER_NAV                   WM_USER + 2000
#define WM_WEBFOLDER_CANCEL                WM_WEBFOLDER_NAV + 1
#define WM_WEBFOLDER_DONE                  WM_WEBFOLDER_NAV + 2
#define WM_WEBFOLDER_INIT                  WM_WEBFOLDER_NAV + 3

// Used to keep the state of the message window.  They are void * to cram into
// the window properties.
#define STATUS_READY        (void *) 1
#define STATUS_CANCELED     (void *) 2

// Window Property Names
#define __INFO              L"__WFOLDER_INFO"
#define __CANCEL            L"__WFOLDER_CANCEL"

// Name of the class of windows that handles all the messages from ParseDisplayName
#define WFOLDERSWNDCLASS  L"WebFolderSilentMessageHandlerWindowClass"

// These values help the various parts of this program know what is going on.
// They are to be used in ONE DIRECTION ONLY because they are often carried
// to different threads, and the variable they are used with is NOT 
// synchronized.
#define READY_WORKING            0
#define READY_INITIALIZED        1
#define READY_CANCEL             10
#define READY_DONE               11

// These are my different UI codes.  You pass one (or all) of these to NavigateInternal
// to change what UI gets seen.
#define USE_NO_UI                0
#define USE_ERROR_BOXES          1
#define USE_FAILED_QUESTION      2
#define USE_WEB_PAGE_UI          4

#define USE_ALL_UI               USE_ERROR_BOXES | USE_FAILED_QUESTION | USE_WEB_PAGE_UI

//+------------------------------------------------------------------------
//
//  Class:      Cwfolders
//
//  Synopsis:   Implements a behavior which allows the browser to
//              navigate to a folder view of a given URL.  The most
//              important method here is Navigate.
//
//-------------------------------------------------------------------------

class ATL_NO_VTABLE Cwfolders : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<Cwfolders,&CLSID_wfolders>,
    public IDispatchImpl<Iwfolders, &IID_Iwfolders, &LIBID_IEXTagLib>,
    public IObjectSafetyImpl<Cwfolders>,
    public IElementBehavior
{
// METHODS
// -------

public:
    Cwfolders();

    ~Cwfolders();

DECLARE_REGISTRY_RESOURCEID(IDR_WFOLDERS)

BEGIN_COM_MAP(Cwfolders) 
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(Iwfolders)
    COM_INTERFACE_ENTRY(IElementBehavior)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
END_COM_MAP()

    // Iwfolders
    STDMETHOD(navigate)(BSTR bstrUrl, BSTR * pbstrRetVal);
    STDMETHOD(navigateFrame)(BSTR bstrUrl, BSTR bstrTargetFrame, /*BSTR bstrProtocol,*/ BSTR * pbstrRetVal);
    STDMETHOD(navigateNoSite)(BSTR bstrUrl, BSTR bstrTargetFrame, /*BSTR bstrProtocol,*/
                              DWORD dwhwnd, IUnknown* punk);

    // IObjectSafety
    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid,
              DWORD dwSupportedOptions, DWORD dwEnabledOptions);

    // IElementBehavior
    HRESULT STDMETHODCALLTYPE Init (IElementBehaviorSite __RPC_FAR *pBehaviorSite);
    HRESULT STDMETHODCALLTYPE Notify (LONG lEvent, VARIANT __RPC_FAR *pVar);
    STDMETHOD(Detach)() { return S_OK; };


private:
    // The function that actually does all the navigation.
    // all other (including exported) functions call this one.
    STDMETHOD(navigateInternal)(BSTR bstrUrl, BSTR bstrTargetFrame, /*BSTR bstrProtocol,*/ int iUI, IUnknown* punk);

    // show UI for four different kinds of errors.
    void ShowNavigationFailedQuestion (BSTR bstrUrl, BSTR bstrTargetFrame);
    void ShowError (HWND hWnd, unsigned int IDSmessage, unsigned int IDStitle, BSTR bstrUrl);
    void ShowNavigationFailed (HWND hWnd, BSTR bstrUrl, BSTR bstrTargetFrame,
                               WCHAR * wszResource);

// STATIC METHODS
// --------------

public:
    // message handler for my window (the "connecting..." dialog)
    static INT_PTR CALLBACK WaitDlgProc (HWND hDlg, UINT message, 
                               WPARAM wParam, LPARAM lParam);
    // message handler for a silent, invisible message window that
    // stays around to listen for ParseDisplayName to finish
    static INT_PTR CALLBACK NavMessageProc (HWND hDlg, UINT message, WPARAM wParam, 
                                  LPARAM lParam);

private:
    // These two (unexported) functions were taken from the shdocvw code.
    static TARGET_TYPE ParseTargetType(LPCOLESTR pszTarget);
    static HRESULT CreateTargetFrame(LPCOLESTR pszTargetName, LPUNKNOWN *ppunk);

    // Some helper functions for pidl stuffing
    static HRESULT InitVARIANTFromPidl(LPVARIANT pvar, LPITEMIDLIST pidl);
    static LPSAFEARRAY MakeSafeArrayFromData(LPBYTE pData, DWORD cbData);
    static UINT ILGetSize(LPITEMIDLIST pidl);

    // My thread proc
    static DWORD WINAPI RunParseDisplayName (LPVOID pArguments);

    // General helper functions (destined for utils.cxx?)
    static HRESULT NavToPidl (LPITEMIDLIST pidl, BSTR bstrTargetFrame, 
        IWebBrowser2 * pwb);

    // Some code mostly supplied by Chris Guzak that gets a pidl from 
    // an url.
    static HRESULT CreateWebFolderIDList(BSTR bstrUrl, LPITEMIDLIST *ppidl, HWND hwnd, IUnknown *punk);
    static void SetScriptErrorMessage (HRESULT hr, BSTR * pbstr);

// DATA MEMBERS
// ------------

public:
    IWebBrowser2 * m_pwb;
    HWND m_hwndOwner;
    IElementBehaviorSite *m_pSite;
};

// Using this to pass arguments to my child thread.
class CThreadArgs
{
public:
    CThreadArgs()
    {
        m_bstrUrl = NULL;
    }
    ~CThreadArgs()
    {
        SysFreeString (m_bstrUrl);
    }

    // holds the URL ask office for a pidl with
    BSTR m_bstrUrl;
    // holds the hwnd of the message window, once
    // it is created and initialized.  (0 otherwise)
    HWND m_hwndMessage;
    // holds the hwnd of the dialog window, once
    // it is created and initialized.  (0 otherwise)
    HWND m_hwndDialog;
    // holds the HRESULT returned by office
    HRESULT m_hrReady;
    // holds the pidl returned by office 
    // (this actually only carries the pidl between the
    // message window and the navigateInternal call...
    // the pidl gets from the PDN thread to the message
    // window through the WM_WEBFOLDER_NAV message)
    LPITEMIDLIST m_pidl;
    // Holds the status of the message window
    int m_imsgStatus;
    // Holds the status of the PDN thread
    int m_ipdnStatus;
};

#endif //__HTTPWFH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\peerfact.cxx ===
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#include "iextag.h"
#include "peerfact.h"
#include "ccaps.h"
#include "homepg.h"
#include "persist.hxx"
#include "download.h"

#ifndef __X_HTMLAREA_HXX_
#define __X_HTMLAREA_HXX_
#include "htmlarea.hxx"
#endif

#ifndef __X_SELECT_HXX_
#define __X_SELECT_HXX_
#include "select.hxx"
#endif

#ifndef __X_SELITEM_HXX_
#define __X_SELITEM_HXX_
#include "selitem.hxx"
#endif

#ifndef __X_COMBOBOX_HXX_
#define __X_COMBOBOX_HXX_
#include "combobox.hxx"
#endif

#ifndef __X_CHECKBOX_HXX_
#define __X_CHECKBOX_HXX_
#include "checkbox.hxx"
#endif

#ifndef __X_RADIO_HXX_
#define __X_RADIO_HXX_
#include "radio.hxx"
#endif

#ifndef __X_USERDATA_HXX_
#define __X_USERDATA_HXX_
#include "userdata.hxx"
#endif

#ifndef __X_RECTPEER_HXX_
#define __X_RECTPEER_HXX_
#include "rectpeer.hxx"
#endif

#ifndef __X_DEVICERECT_HXX_
#define __X_DEVICERECT_HXX_
#include "devicerect.hxx"
#endif

#ifndef __X_TMPPRINT_HXX_
#define __X_TMPPRINT_HXX_
#include "tmpprint.hxx"
#endif

#ifndef __X_HEADFOOT_HXX_
#define __X_HEADFOOT_HXX_
#include "headfoot.hxx"
#endif

#ifndef __X_SCROLLBAR_HXX_
#define __X_SCROLLBAR_HXX_
#include "scrllbar.hxx"
#endif

#ifndef __X_SPINBTTN_HXX_
#define __X_SPINBTTN_HXX_
#include "spinbttn.hxx"
#endif

#ifndef __X_SLIDEBAR_HXX_
#define __X_SLIDEBAR_HXX_
#include "slidebar.hxx"
#endif

#ifndef UNIX // UNIX doesn't support this.
#include "httpwfh.h"
#include "ancrclk.h"
#endif


//+-----------------------------------------------------------
//
// Member:  CPeerFactory constructor
//
//------------------------------------------------------------

CPeerFactory::CPeerFactory()
{
}

//+-----------------------------------------------------------
//
// Member:  CPeerFactory destructor
//
//------------------------------------------------------------

CPeerFactory::~CPeerFactory()
{
}

//+-----------------------------------------------------------
//
// Member:  behavior desc map macros
//
//------------------------------------------------------------

typedef HRESULT FN_CREATEINSTANCE (IElementBehavior ** ppBehavior);

struct BEHAVIOR_DESC
{
	LPCTSTR                 pchName;
    LPCTSTR                 pchTagName;
    LPCTSTR                 pchBaseTagName;
	FN_CREATEINSTANCE *     pfnCreateInstance;
};

#define DECLARE_BEHAVIOR(className)                                     \
    HRESULT className##_CreateInstance(IElementBehavior ** ppBehavior)  \
    {                                                                   \
        HRESULT                 hr;                                     \
        CComObject<className> * pInstance;                              \
                                                                        \
        hr = CComObject<className>::CreateInstance(&pInstance);         \
        if (hr)                                                         \
            goto Cleanup;                                               \
                                                                        \
        hr = pInstance->QueryInterface(                                 \
                IID_IElementBehavior, (void**) ppBehavior);             \
                                                                        \
    Cleanup:                                                            \
        return hr;                                                      \
    }                                                                   \


#define BEGIN_BEHAVIORS_MAP(x)                                      static BEHAVIOR_DESC x[] = {
#define END_BEHAVIORS_MAP()                                         { NULL, NULL, NULL, NULL }};
#define BEHAVIOR_ENTRY(className, name, tagName, baseTagName)       { name, tagName, baseTagName, className##_CreateInstance},

//+-----------------------------------------------------------
//
//  Behaviors map
//
//  To add a new entry: execute steps 1 and 2
//
//------------------------------------------------------------

//
// STEP 1.
//

DECLARE_BEHAVIOR(CHtmlArea)
DECLARE_BEHAVIOR(CCombobox)
DECLARE_BEHAVIOR(CIESelectElement)
DECLARE_BEHAVIOR(CIEOptionElement)
DECLARE_BEHAVIOR(CCheckBox)
DECLARE_BEHAVIOR(CRadioButton)
DECLARE_BEHAVIOR(CLayoutRect)
DECLARE_BEHAVIOR(CDeviceRect)
DECLARE_BEHAVIOR(CTemplatePrinter)
DECLARE_BEHAVIOR(CHeaderFooter)
DECLARE_BEHAVIOR(CScrollBar)
DECLARE_BEHAVIOR(CSpinButton)
DECLARE_BEHAVIOR(CSliderBar)
DECLARE_BEHAVIOR(CClientCaps)
DECLARE_BEHAVIOR(CHomePage)
DECLARE_BEHAVIOR(CPersistUserData)
DECLARE_BEHAVIOR(CPersistHistory)
DECLARE_BEHAVIOR(CPersistShortcut)
DECLARE_BEHAVIOR(CPersistSnapshot)
DECLARE_BEHAVIOR(CDownloadBehavior)
DECLARE_BEHAVIOR(Cwfolders)
DECLARE_BEHAVIOR(CAnchorClick)

//
// STEP 2.
//

BEGIN_BEHAVIORS_MAP(_BehaviorDescMap)

    //             className            behaviorName            tagName                 baseTagName
#if DBG==1
    BEHAVIOR_ENTRY(CCheckBox,           _T("checkBox"),         _T("CHECKBOX"),         NULL           ) // keep first in the list as it is a perf benchmark (alexz)
    BEHAVIOR_ENTRY(CRadioButton,        _T("radioButton"),      _T("RADIOBUTTON"),      NULL           ) 
    BEHAVIOR_ENTRY(CHtmlArea,           _T("htmlArea"),         _T("HTMLAREA"),         NULL           )
    BEHAVIOR_ENTRY(CCombobox,           _T("comboBox"),         _T("COMBOBOX"),         NULL           )
    BEHAVIOR_ENTRY(CIESelectElement,    _T("select"),           _T("SELECT"),           NULL           )
    BEHAVIOR_ENTRY(CIEOptionElement,    _T("option"),           _T("OPTION"),           NULL           )
    BEHAVIOR_ENTRY(CScrollBar,          _T("scrollBar"),        _T("SCROLLBAR"),        NULL           )
    BEHAVIOR_ENTRY(CSpinButton,         _T("spinButton"),       _T("SPINBUTTON"),       NULL           )
    BEHAVIOR_ENTRY(CSliderBar,          _T("sliderBar"),        _T("SLIDERBAR"),        NULL           )
#endif
    BEHAVIOR_ENTRY(CLayoutRect,         _T("layoutRect"),       _T("LAYOUTRECT"),       NULL           )
    BEHAVIOR_ENTRY(CDeviceRect,         _T("deviceRect"),       _T("DEVICERECT"),       NULL           )
    BEHAVIOR_ENTRY(CTemplatePrinter,    _T("templatePrinter"),  _T("TEMPLATEPRINTER"),  NULL           )
    BEHAVIOR_ENTRY(CHeaderFooter,       _T("headerFooter"),     _T("HEADERFOOTER"),     NULL           )

    BEHAVIOR_ENTRY(CClientCaps,         _T("clientCaps"),    NULL,                   NULL           )
    BEHAVIOR_ENTRY(CHomePage,           _T("homePage"),      NULL,                   NULL           )
    BEHAVIOR_ENTRY(CPersistUserData,    _T("userData"),      NULL,                   NULL           )
    BEHAVIOR_ENTRY(CPersistHistory,     _T("saveHistory"),   NULL,                   NULL           )
    BEHAVIOR_ENTRY(CPersistShortcut,    _T("saveFavorite"),  NULL,                   NULL           )
    BEHAVIOR_ENTRY(CPersistSnapshot,    _T("saveSnapshot"),  NULL,                   NULL           )
    BEHAVIOR_ENTRY(CDownloadBehavior,   _T("download"),      NULL,                   NULL           )

#ifndef UNIX // UNIX doesn't support these
    BEHAVIOR_ENTRY(Cwfolders,           _T("httpFolder"),    NULL,                   NULL           )
    BEHAVIOR_ENTRY(CAnchorClick,        _T("anchorClick"),   NULL,                   NULL           )
#endif

END_BEHAVIORS_MAP()

//+-----------------------------------------------------------
//
// Member:      CPeerFactory::FindBehavior
//
//------------------------------------------------------------

STDMETHODIMP
CPeerFactory::FindBehavior(
    BSTR                    bstrName,
    BSTR	                bstrUrl, 
    IElementBehaviorSite *  pSite,
    IElementBehavior **     ppBehavior)
{
    HRESULT             hr = E_FAIL;
    IHTMLElement *      pElement = NULL;
    BSTR                bstrTagName = NULL;
    IClassFactory *     pFactory = NULL;
    BEHAVIOR_DESC *     pDesc;

    if (!ppBehavior)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // ensure name
    //

    if (!bstrName)
    {
        hr = pSite->GetElement(&pElement);
        if (hr)
            goto Cleanup;

        hr = pElement->get_tagName(&bstrTagName);
        if (hr)
            goto Cleanup;

        bstrName = bstrTagName;
    }

    //
    // lookup
    //

    Assert (bstrName);

    *ppBehavior = NULL;

    for (pDesc = _BehaviorDescMap; pDesc->pchName; pDesc++)
    {
        if (0 == StrCmpICW(bstrName, pDesc->pchName))
        {
            hr = pDesc->pfnCreateInstance(ppBehavior);
            break; // done
        }
    }

Cleanup:
    ReleaseInterface (pElement);
    ReleaseInterface (pFactory);

    if (bstrTagName)
        SysFreeString (bstrTagName);

    return hr;
}

//+-----------------------------------------------------------
//
// Member:      CPeerFactory::Create, per IElementNamespaceFactory
//
//------------------------------------------------------------

HRESULT
CPeerFactory::Create(IElementNamespace * pNamespace)
{
    HRESULT             hr = S_OK;
    BEHAVIOR_DESC *     pDesc;
    BSTR                bstrTagName;

    for (pDesc = _BehaviorDescMap; pDesc->pchName; pDesc++)
    {
        if (pDesc->pchTagName)
        {
            // CONSIDER (alexz) it could be optimized so to avoid these 2 SysAllocString-s
            Assert( !pDesc->pchBaseTagName && "Base tag has been moved to a private debug-only testing interface.  Talk to JHarding" );
            bstrTagName = SysAllocString(pDesc->pchTagName);

            hr = pNamespace->AddTag(bstrTagName, 0);

            SysFreeString(bstrTagName);

            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\peerfact.h ===
// CPeerFactory.h : Declaration of the CPeerFactory

#ifndef __PEERFACT_H_
#define __PEERFACT_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CPeerFactory

class ATL_NO_VTABLE CPeerFactory : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CPeerFactory, &CLSID_PeerFactory>,
	public IElementBehaviorFactory,
	public IElementNamespaceFactory
{
public:
    //
    // construction / destruction
    //

    CPeerFactory();
    ~CPeerFactory();

    //
    // IElementBehaviorFactory
    //

    STDMETHOD(FindBehavior)(
        BSTR bstrName, BSTR bstrUrl, IElementBehaviorSite * pSite, IElementBehavior ** ppPeer);

    //
    // IElementNamespaceFactory
    //

    STDMETHOD(Create)(IElementNamespace * pNamespace);

    //
    // macros
    //

DECLARE_REGISTRY_RESOURCEID(IDR_PEERFACTORY)

BEGIN_COM_MAP(CPeerFactory)
    COM_INTERFACE_ENTRY(IElementBehaviorFactory)
    COM_INTERFACE_ENTRY(IElementNamespaceFactory)
END_COM_MAP()

};

#endif //__PEERFACT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\radio.cxx ===
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "iextag.h"

#include "utils.hxx"

#include "radio.hxx"

const CBaseCtl::PROPDESC CRadioButton::s_propdesc[] = 
{
    {_T("value"), VT_BSTR},
    {_T("checked"), VT_BOOL, NULL, NULL, VB_FALSE},
    NULL
};

enum
{
    VALUE = 0,
    CHECKED = 1
};

HRESULT
CRadioButton::Init(CContextAccess * pca)
{
    HRESULT         hr = S_OK;

    hr = pca->Open (CA_SITEOM);
    if (hr)
        goto Cleanup;

    hr = pca->SiteOM()->RegisterName(_T("radiobutton"));
    if (hr)
        goto Cleanup;

Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CRadioButton::get_value(BSTR * pv)
{
    return GetProps()[VALUE].Get(pv); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CRadioButton::put_value(BSTR v)
{
    return GetProps()[VALUE].Set(v); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CRadioButton::get_checked(VARIANT_BOOL * pv)
{
    return GetProps()[CHECKED].Get(pv);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CRadioButton::put_checked(VARIANT_BOOL v)
{
    return GetProps()[CHECKED].Set(v);
}

///////////////////////////////////////////////////////////////////////////////

HRESULT
CRadioButton::OnClick(CEventObjectAccess *pEvent)
{
    HRESULT      hr = S_OK;
    VARIANT_BOOL fChecked = FALSE;

    hr = get_checked(&fChecked);
    if (hr)
        goto Cleanup;

    // You can't uncheck a radio button by clicking on it.
    if (!fChecked)
        hr = ChangeState();

Cleanup:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////

HRESULT
CRadioButton::OnKeyPress(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;
    long    lKeyCode;

    hr = pEvent->GetKeyCode(&lKeyCode);
    if (hr)
        goto Cleanup;

    // TODO is this the right way to check lKey?
    if (_T(' ') == lKeyCode)
    {
        VARIANT_BOOL fChecked = FALSE;

        hr = get_checked(&fChecked);
        if (hr)
            goto Cleanup;

        // You can't uncheck a radio button by clicking on it.
        if (!fChecked)
            hr = ChangeState();
    }

Cleanup:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////

HRESULT
CRadioButton::ChangeState()
{
    HRESULT         hr = S_OK;
    CContextAccess  a(_pSite);
    VARIANT_BOOL    fChecked = VB_FALSE;
    IHTMLElement * pElem = NULL;

    hr = a.Open(CA_SITERENDER | CA_ELEM);
    if (hr)
        goto Cleanup;

    hr = get_checked(&fChecked);
    if (hr)
        goto Cleanup;

    hr = put_checked(!fChecked);
    if (hr)
        goto Cleanup;

    hr = a.SiteRender()->Invalidate(NULL);

Cleanup:
    ReleaseInterface(pElem);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\persist.cxx ===
//+=============================================================================
//
//  File :  persist.cxx
//
//  contents : implementation of CPersistData xtag
//
//=============================================================================
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MSHTML_H_
#define X_MSHTML_H_
#include "mshtml.h"       // for IHTML*ELement*
#endif

#ifndef X_PERHIST_H_
#define X_PERHIST_H_
#include "perhist.h"      // For IPersistHistory
#endif

#ifndef X_DISPEX_H_
#define X_DISPEX_H_
#include "dispex.h"       // For IDispatchEx
#endif

#ifndef X_PERSIST_HXX_
#define X_PERSIST_HXX_
#include "persist.hxx"
#endif

#ifndef __X_IEXTAG_H_
#define __X_IEXTAG_H_
#include "iextag.h"
#endif

#ifndef __X_UTILS_HXX_
#define __X_UTILS_HXX_
#include "utils.hxx"
#endif


//+----------------------------------------------------------------------------
//
//  Member : Init
//
//  Synopsis : this method is called by MSHTML.dll to initialize peer object
//
//-----------------------------------------------------------------------------

HRESULT
CPersistDataPeer::Init(IElementBehaviorSite * pPeerSite)
{
    _pPeerSite = pPeerSite;
    _pPeerSite->AddRef();

    _pPeerSite->QueryInterface(IID_IElementBehaviorSiteOM, (void**)&_pPeerSiteOM);

    // now register our 2 events
    if (_pPeerSiteOM)
    {
        _pPeerSiteOM->RegisterEvent (_T("onload"), 0, NULL);
        _pPeerSiteOM->RegisterEvent (_T("onsave"), 0, NULL);
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member : Notify
//
//  Synopsis : when document is ready for modifications, setup timer calls
//
//-----------------------------------------------------------------------------

HRESULT
CPersistDataPeer::Notify(LONG lEvent, VARIANT *)
{
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  member : queryType
//
//  Synopsis : IPersistData method, this is used by the calling routines in order
//      to avoid cocreating the XML object.  This way they can query any of the
//      persist Tags, and find out what persist behaiors it supprots. 
//-----------------------------------------------------------------------------
HRESULT
CPersistDataPeer::queryType(long lType, VARIANT_BOOL * pfSupportsType)
{
    if (!pfSupportsType)
        return E_POINTER;

    *pfSupportsType = (lType == (long)_eState) ? VB_TRUE : VB_FALSE;

    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Member : Save
//
//  Synopsis : Implementation of the IHTMLPersistData method
//
//-----------------------------------------------------------------------------

HRESULT
CPersistDataPeer::save(IUnknown * pUnk, 
                       long lType, 
                       VARIANT_BOOL *pfBroadcast)
{
    HRESULT hr;
    BSTR    bstrEvent;

    if (!pfBroadcast)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pfBroadcast = VB_TRUE;

    // cache the OM pointers
    InitOM(pUnk, lType);

    bstrEvent = SysAllocString(L"onsave");

    if (!bstrEvent)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // allow script to save data
    hr = (FireEvent(bstrEvent, pfBroadcast, TRUE));
    SysFreeString(bstrEvent);

Cleanup:
    return( hr );
}


//+----------------------------------------------------------------------------
//
//  Member : Load
//
//  Synopsis : Implementation of the IHTMLPersistData method
//
//-----------------------------------------------------------------------------

HRESULT
CPersistDataPeer::load(IUnknown * pUnk, 
                       long lType, 
                       VARIANT_BOOL *pfContinue)
{
    HRESULT hr;
    BSTR    bstrEvent;

    if (!pfContinue)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pfContinue = VB_TRUE;

    // cache the OM pointers
    InitOM(pUnk, lType, INIT_USE_CACHED);

    bstrEvent = SysAllocString(L"onload");
    if (!bstrEvent)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // allow event handlers the chance to load from the cach
    hr = (FireEvent(bstrEvent, pfContinue, FALSE));
    SysFreeString(bstrEvent);

Cleanup:
    return( hr );
}

//+--------------------------------------------------------------------------------
//
//  Member : FireEvent
//
//  Synopsis : helper method to fire the persistence events
//
//---------------------------------------------------------------------------------

HRESULT
CPersistDataPeer::FireEvent(BSTR bstrEvent, VARIANT_BOOL * pfContinue, BOOL fIsSaveEvent)
{
    IHTMLEventObj  * pEventObj = NULL;
    IHTMLEventObj2 * pEO2 = NULL;
    LONG             lCookie;
    HRESULT          hr = E_PENDING;
    VARIANT          varRet;

    if (!_pPeerSiteOM)
        goto Cleanup;

    VariantInit(&varRet);

    // create an event object
    hr = _pPeerSiteOM->CreateEventObject(&pEventObj);
    if (hr || !pEventObj)
        goto Cleanup;

    // Now populate the event object with whatever properties are
    // appropriate for this event:
    hr = pEventObj->QueryInterface(IID_IHTMLEventObj2, (void**)&pEO2);
    if (hr==S_OK)
    {
        BSTR bstrEventType = SysAllocString( (fIsSaveEvent) ? L"save" : L"load" );

        // we need to set the event type, the event type is either
        // "load" or "save".
        if (bstrEventType)
        {
            pEO2->put_type( bstrEventType );
            SysFreeString(bstrEventType);
        }
    }

    // get the event cookie to fire the event
    hr = _pPeerSiteOM->GetEventCookie (bstrEvent, &lCookie);
    if (hr)
        goto Cleanup;

    hr = _pPeerSiteOM->FireEvent (lCookie, pEventObj);

    if (pfContinue)
    {
        hr = pEventObj->get_returnValue(&varRet);
        if (!hr)
            *pfContinue =  ((V_VT(&varRet) == VT_BOOL) && 
            (V_BOOL(&varRet) == VB_FALSE))? VB_FALSE : VB_TRUE;
    }

Cleanup:
    VariantClear(&varRet);
    ReleaseInterface(pEventObj);
    ReleaseInterface(pEO2);
    return ( hr );
}


//+-----------------------------------------------------------------------
//
//  Member : ClearOMInterfaces ()
//
//  Synopsis : this helper function is called after the Save/Load persistenceCache
//      operations are finished, and is responsible for freeing up any of hte OM 
//      interfaces that were cached.
//
//------------------------------------------------------------------------
void
CPersistDataPeer::ClearOMInterfaces()
{
    ClearInterface(&_pRoot);
    ClearInterface(&_pInnerXMLDoc);
}

//---------------------------------------------------------------------------
//
//  Member:     CPersistDataPeer::InitOM
//
//  Synopsis:   IHTMLPersistData OM method implementation
//
//---------------------------------------------------------------------------

HRESULT
CPersistDataPeer::InitOM(IUnknown * pUnk, long lType, DWORD dwFlags /* ==0*/)
{
    HRESULT            hr = S_OK;
    IHTMLElement     * pPeerElement = NULL;
    long               lElemID = -1;
    BSTR               bstrTag =NULL;
    CBufferedStr       cbsID;
    IXMLDOMNodeList  * pChildren = NULL;
    IXMLDOMElement   * pNewChild = NULL;
    IXMLDOMNode      * pSubTree = NULL;

    if (!pUnk)
        return E_INVALIDARG;

    if (_pInnerXMLDoc)
    {
        if (dwFlags & INIT_USE_CACHED)
            goto Cleanup;
        else
            ClearOMInterfaces();
    }

    // make sure we know what we have been given.
    hr = (pUnk->QueryInterface(IID_IXMLDOMDocument, (void**)&_pInnerXMLDoc));
    if (hr)
        goto Cleanup;

    // find the data value...
    hr = _pInnerXMLDoc->get_documentElement( &_pRoot );
    if (hr)
        goto Cleanup;

    // but in most cases the xmlObject is a big bucket, and we would like
    // to set the _pRoot to the subtree associated with our own _pPeerElement.
    // if this root doesn't exist, create it.  we try to find an ID first, if 
    // if it is not there, then create a unique name for this child subtree 
    // but appending the srcID to the tagName.

    _pPeerSite->GetElement(&pPeerElement);
    if (!pPeerElement)
        goto Cleanup;

    hr = pPeerElement->get_id(&bstrTag);
    if (hr || !bstrTag || !SysStringLen(bstrTag))
    {
        SysFreeString(bstrTag);

        hr = pPeerElement->get_sourceIndex(&lElemID);
        if (hr)
            goto Cleanup;

        hr = pPeerElement->get_tagName(&bstrTag);
        if (hr)
            goto Cleanup;

        hr = cbsID.QuickAppend(bstrTag);
        SysFreeString(bstrTag);
        if (hr)
            goto Cleanup;

        hr = cbsID.QuickAppend(lElemID);
        if (hr)
            goto Cleanup;

        bstrTag = SysAllocString(cbsID);
    }

    if (!bstrTag)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // now we can actually see if there is a child of this name
    //   We need to do this by looping over the childNode collection
    //   and looking for one with our name.
    //--------------------------------------------------------------
    hr = _pRoot->get_childNodes(&pChildren);
    if (FAILED(hr))
        goto Cleanup;

    if (hr == S_OK)
    {
        long i, iLen;
        
        hr = pChildren->get_length(&iLen);
        if (FAILED(hr))
            goto Cleanup;

        for (i=0; i < iLen; i++)
        {
            IXMLDOMNode * pTemp = NULL;
            BSTR       bstrNodeName = NULL;
            BOOL       fEqual = FALSE;

            hr= pChildren->get_item(i, &pTemp);
            if (FAILED(hr))
                break;
            
            hr = pTemp->get_nodeName( &bstrNodeName );
            if (FAILED(hr))
                break;

            fEqual = ! _wcsicmp(bstrTag, bstrNodeName);

            SysFreeString(bstrNodeName);

            if (fEqual)
            {
                // transfer ownership
                pSubTree = pTemp;
                break;
            }

            ClearInterface( &pTemp );
        }
    }

    if(pSubTree)
    {
        // yes there's a child so use it, we have a domnode so we need to
        // qi for the element
        ClearInterface(&_pRoot);
        hr = pSubTree->QueryInterface(IID_IXMLDOMElement, (void**)&_pRoot);
    }
    else
    {
        // no child yet so lets create one.
        hr = _pInnerXMLDoc->createElement(bstrTag, &pNewChild);
        if (hr || ! pNewChild)
            goto Cleanup;

        hr = _pRoot->appendChild(pNewChild, NULL);
        if (hr)
            goto Cleanup;

        ClearInterface(&_pRoot);
        _pRoot=pNewChild;
        pNewChild = NULL;   // transfer ownership
    }


Cleanup:
    ReleaseInterface(pPeerElement);
    SysFreeString(bstrTag);
    ReleaseInterface(pChildren);
    ReleaseInterface(pSubTree);
    ReleaseInterface(pNewChild);
    return( hr );
}


//---------------------------------------------------------------------------
//
//  Member:     CPersistDataPeer::getAttribute
//
//  Synopsis:   IHTMLPersistData OM method implementation
//
//---------------------------------------------------------------------------

HRESULT
CPersistDataPeer::getAttribute (BSTR strName, VARIANT * pvarValue )
{
    HRESULT hr = S_OK;

    if (!pvarValue)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    VariantClear(pvarValue);

    if (!strName)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = InitOM();
    if (hr) 
    {
        // no OM pointers so fail silently
        hr = S_OK;
        goto Cleanup;
    }

    // get the child of the root that has the name strName
    if (_pRoot)
    {
        hr = _pRoot->getAttribute(strName, pvarValue);
        if (hr ==S_FALSE)
            hr = S_OK;
    }

Cleanup:
    return hr ;
}


//---------------------------------------------------------------------------
//
//  Member:     CPersistDataPeer::setAttribute
//
//  Synopsis:   IHTMLPersistData OM method implementation
//
//---------------------------------------------------------------------------

HRESULT
CPersistDataPeer::setAttribute (BSTR strName, VARIANT varValue)
{
    HRESULT  hr = S_OK;

    if (!strName)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = InitOM();
    if (hr) 
    {
        // no OM pointers so fail silently
        hr = S_OK;
        goto Cleanup;
    }

    // save this value as an attribute on the root.
    if (_pRoot)
    {
        // TODO - look into just passing the variant into the xml object
        // and let them worry about all the types... We do the processing below
        // to be safe for now.
        VARIANT * pvar = NULL;
        CVariant cvarTemp;

        if ((V_VT(&varValue)==VT_BSTR) || 
             V_VT(&varValue)==(VT_BYREF|VT_BSTR))
        {
            pvar = (V_VT(&varValue) & VT_BYREF) ?
                    V_VARIANTREF(&varValue) : &varValue;
        }
        else if ((V_VT(&varValue)==VT_BOOL ||
                 V_VT(&varValue)==(VT_BYREF|VT_BOOL)))
        {
            // sadly, do our own bool conversion...
            VARIANT_BOOL vbFlag = (V_VT(&varValue)==VT_BOOL) ?
                                   V_BOOL(&varValue) :
                                   V_BOOL( V_VARIANTREF(&varValue) );

            V_VT(&cvarTemp) = VT_BSTR;
            V_BSTR(&cvarTemp) = vbFlag ? SysAllocString(L"true") :
                                         SysAllocString(L"false");

            pvar = & cvarTemp;
        }
        else
        {
            pvar = &varValue;

            hr = VariantChangeTypeEx(pvar, pvar, LCID_SCRIPTING, 0, VT_BSTR);
            if (hr)
                goto Cleanup;
        }


        hr = _pRoot->setAttribute(strName, *pvar);
        if (hr ==S_FALSE)
            hr = S_OK;
    }

Cleanup:
    return hr;
}

//---------------------------------------------------------------------------
//
//  Member:     CPersistDataPeer::removeDataValue
//
//  Synopsis:   IHTMLPersistData OM method implementation
//
//---------------------------------------------------------------------------

HRESULT
CPersistDataPeer::removeAttribute (BSTR strName)
{
    HRESULT hr = S_OK;

    if (!strName)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = InitOM();
    if (hr) 
    {
        // no OM pointers so fail silently
        hr = S_OK;
        goto Cleanup;
    }

    // get the child of the root that has the name strName
    if (_pRoot)
    {
        hr = _pRoot->removeAttribute(strName);
        if (hr ==S_FALSE)
            hr = S_OK;
    }

Cleanup:
    return hr ;
}

//---------------------------------------------------------------------------
//
//  Member:     CPersistDataPeer::get_XMLDocument
//
//  Synopsis:   IHTMLPersistData OM proeprty implementation. this is the default 
//                  property for this object, and as such it exposes the XMLOM
//                  of the user data.
//
//---------------------------------------------------------------------------

HRESULT
CPersistDataPeer::get_XMLDocument (IDispatch ** ppDisp)
{
    HRESULT hr = S_OK;

    if (!ppDisp)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppDisp = NULL;

    hr = InitOM();
    if (hr) 
    {
        // no OM pointers so fail silently
        hr = S_OK;
        goto Cleanup;
    }

    if (_pInnerXMLDoc)
    {
        hr = _pInnerXMLDoc->QueryInterface(IID_IDispatch, 
                                           (void**)ppDisp);
    }

Cleanup:
    return hr;
}


//+-----------------------------------------------------------
//
//  Member : GetSaveCategory
//
//  Synopsis : this helper function turns the tagName fo the 
//      pPeerElement, into the category for its save operations.
//
//+-----------------------------------------------------------
ENUM_SAVE_CATEGORY
CPersistDataPeer::GetSaveCategory()
{
    HRESULT            hr = S_OK;
    CVariant           cvarTag;
    IHTMLElement     * pPeerElement = NULL;
    ENUM_SAVE_CATEGORY escRet = ESC_UNKNOWN;

    _pPeerSite->GetElement(&pPeerElement);
    if (!pPeerElement)
        goto Cleanup;

    V_VT(&cvarTag) = VT_BSTR;
    hr = pPeerElement->get_tagName(&V_BSTR(&cvarTag));
    if (hr)
        goto Cleanup;

    // there's got to be a better way to do this, but for
    // now I will try to put the most common ones in front.
    if (0==_wcsicmp(V_BSTR(&cvarTag), L"input"))
    {
        // but wait!!!! don't save password type inputs
        BSTR     bstrType = SysAllocString(L"type");
        CVariant cvarVal;

        escRet = ESC_INTRINSIC;
        if (!bstrType)
            goto Cleanup;

        hr = (pPeerElement->getAttribute(bstrType, 0, &cvarVal));
        SysFreeString(bstrType);
        if (hr)
            goto Cleanup;

        if (V_VT(&cvarVal) == VT_BSTR &&
            0==_wcsicmp(V_BSTR(&cvarVal), L"password"))
        {
            escRet = ESC_PASSWORD;
            goto Cleanup;
        }
    }
    else if (0==_wcsicmp(V_BSTR(&cvarTag), L"script"))
    {
        escRet = ESC_SCRIPT;
    }
    else if (0==_wcsicmp(V_BSTR(&cvarTag), L"select")   ||
             0==_wcsicmp(V_BSTR(&cvarTag), L"textarea") ||
             0==_wcsicmp(V_BSTR(&cvarTag), L"richtext") ||
             0==_wcsicmp(V_BSTR(&cvarTag), L"button")   ||
             0==_wcsicmp(V_BSTR(&cvarTag), L"fieldset") 
            )
    {
        escRet = ESC_INTRINSIC;
    }
    else if (0==_wcsicmp(V_BSTR(&cvarTag), L"object") || 
             0==_wcsicmp(V_BSTR(&cvarTag), L"embed")  ||
             0==_wcsicmp(V_BSTR(&cvarTag), L"applet")
            )
    {
        escRet = ESC_CONTROL;
    }


Cleanup:
    ReleaseInterface(pPeerElement);
    return escRet;
}

//+-----------------------------------------------------------
//
//  member : GetEngineClsidForLanguage ()
//
//  synopsis : another helper method that returns the CLSID of the
//   scripdEngine associated with the language progID.
//
//+-----------------------------------------------------------
HRESULT
CPersistDataPeer::GetEngineClsidForLanguage(CLSID * pclsid, 
                                            IHTMLDocument2 * pBrowseDoc)
{
    HRESULT hr = S_OK;
    BSTR    bstrLanguage = NULL;
    IHTMLElement * pPeerElement = NULL;


    if (!pclsid)
        return E_POINTER;

    *pclsid = IID_NULL;

    _pPeerSite->GetElement(&pPeerElement);
    if (!pPeerElement)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // what language script engine to instantiate?
    hr = (pPeerElement->get_language(&bstrLanguage));
    if (hr)
        goto Cleanup;

    if (!bstrLanguage || !SysStringLen(bstrLanguage))
    {
        IHTMLElementCollection * pCollection = NULL;

        hr = E_FAIL;

        if (bstrLanguage)
        {
            SysFreeString(bstrLanguage);
            bstrLanguage = NULL;
        }

        // use the default language, we get this from the language of 
        // first script block in the document.
        if (!FAILED(pBrowseDoc->get_scripts(&pCollection)))
        {
            CVariant    cvarID;
            CVariant    cvarEmpty;
            IDispatch * pDisp;

            V_VT(&cvarID) = VT_I4;
            V_I4(&cvarID) = 0;

            if (!FAILED(pCollection->item(cvarID, cvarEmpty, &pDisp)))
            {
                IHTMLElement     * pFirstScript = NULL;

                if (pDisp &&
                    !FAILED(pDisp->QueryInterface(IID_IHTMLElement, 
                                                      (void**)&pFirstScript)))
                {
                    pFirstScript->get_language(&bstrLanguage);
                    if (bstrLanguage && SysStringLen(bstrLanguage))
                        hr = CLSIDFromProgID ( bstrLanguage, pclsid );

                    ReleaseInterface(pFirstScript);
                }

                ReleaseInterface(pDisp);
            }

            ReleaseInterface(pCollection);
        }

        if (hr)
        {
            hr = CLSIDFromProgID ( L"JScript", pclsid );
        }
    }
    else
    {
        hr = CLSIDFromProgID ( bstrLanguage, pclsid );
    }

Cleanup:
    SysFreeString(bstrLanguage);
    ReleaseInterface(pPeerElement);
    return ( hr );
}
//+-----------------------------------------------------------
//
//  Member  GetScriptEngine
//
//  Synopsis : helper method - this creates the appropriate script 
//      engine, and parses in the text of hte script block that we
//      are interested in.
//
//+-----------------------------------------------------------

IActiveScript * 
CPersistDataPeer::GetScriptEngine(IHTMLDocument2 * pBrowseDoc, ULONG * puFlags)
{
    HRESULT              hr = S_OK;
    BSTR                 bstrCode = NULL;
    CLSID                clsID;
    CLSID                clsIDTarget;
    IActiveScript      * pScriptEngine = NULL;
    IActiveScriptSite  * pScriptSite = NULL;
    IActiveScriptParse * pASP = NULL;
    IHTMLScriptElement * pScriptElem = NULL;
    IHTMLElement       * pPeerElement = NULL;


    hr = (GetEngineClsidForLanguage(&clsID, pBrowseDoc));
    if (hr)
        goto Cleanup;

    // set the return flags, so that these tests only need to be done once
    // some callers need to know if the script block is jscript, vbscript,
    // of something else
    if (!FAILED(CLSIDFromProgID ( _T("JScript"), &clsIDTarget )) &&
        (clsID == clsIDTarget))
    {
        *puFlags = SCRIPT_ENGINE_JSCRIPT;
    }
    else if (!FAILED(CLSIDFromProgID ( _T("VBScript"), &clsIDTarget )) &&
        (clsID == clsIDTarget))
    {
        *puFlags = SCRIPT_ENGINE_VBSCRIPT;
    }
    else
        *puFlags = SCRIPT_ENGINE_OTHER;


    // create the script engine 
    hr = CoCreateInstance( clsID, NULL, CLSCTX_INPROC_SERVER,
            IID_IActiveScript,(void **)&pScriptEngine);
    if ( hr )
        goto Cleanup;

    // get the scriptSite interface from ourselves.
    hr = (QueryInterface(IID_IActiveScriptSite, (void**) &pScriptSite));
    if (hr)
        goto Cleanup;

    hr = pScriptEngine->SetScriptSite(pScriptSite);
    ReleaseInterface(pScriptSite);  // engine should have addref'd 
    if ( FAILED(hr) )
        goto Error;

    // prepare to load out text 
    hr = (pScriptEngine->QueryInterface (IID_IActiveScriptParse, (void**)&pASP));
    if ( hr )
        goto Error;

    hr = (pASP->InitNew());
    if ( hr )
        goto Error;

    _pPeerSite->GetElement(&pPeerElement);
    if (!pPeerElement)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // get the text of the script element
    hr = (pPeerElement->QueryInterface(IID_IHTMLScriptElement, (void**)&pScriptElem));
    if ( hr )
        goto Error;

    hr = (pScriptElem->get_text(&bstrCode));
    if ( hr || !bstrCode)
        goto Error;

    hr = pASP->ParseScriptText( bstrCode,  
                                NULL,                 // Item Name (Namespace)
                                NULL,                 // context
                                NULL,                 // delimiter
                                0,                    // srcContext Cookie
                                0,                    // ulStarting Line
                                SCRIPTTEXT_ISVISIBLE, //dwFlags
                                NULL,                 // pVarResult
                                NULL );               // pException Info
    if ( hr )
        goto Error;

    hr = pScriptEngine->SetScriptState(SCRIPTSTATE_CONNECTED);
    if ( FAILED(hr) )
        goto Error;

Cleanup:
    SysFreeString(bstrCode);
    ReleaseInterface(pPeerElement);
    ReleaseInterface(pScriptElem);
    ReleaseInterface(pASP);
    return pScriptEngine;

Error:
    ClearInterface(&pScriptEngine);
    goto Cleanup;
}


//+-----------------------------------------------------------
//
//  Member  BuildNewScriptBlock
//
//  Synopsis : helper method, this does the real work of snapshotting a 
//      script block.  IF the script is VBSCRIPT or JSCRIPT the appropriate 
//      syntax is used.  for any other language, we convert to JScript.
//
//+-----------------------------------------------------------
HRESULT
CPersistDataPeer::BuildNewScriptBlock(CBufferedStr * pstrBuffer, ULONG *puFlags)
{
    HRESULT          hr    = S_OK;
    IDispatch      * pScriptNameSpace = NULL;
    IDispatchEx    * pDispScript    = NULL;
    IDispatchEx    * pBrowseWin     = NULL;
    DISPID           dispidName;
    BSTR             bstrName       = NULL;
    IHTMLWindow2   * pWin           = NULL;
    IActiveScript  * pScriptEngine  = NULL;
    IDispatch      * pdispBrowseDoc = NULL;
    IHTMLDocument2 * pBrowseDoc     = NULL;
    IHTMLElement   * pPeerElement   = NULL;


    _pPeerSite->GetElement(&pPeerElement);
    if (!pPeerElement)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = (pPeerElement->get_document(&pdispBrowseDoc));
    if (hr)
        goto Cleanup;

    hr = (pdispBrowseDoc->QueryInterface(IID_IHTMLDocument2, 
                                            (void**)&pBrowseDoc));
    if (hr)
        goto Cleanup;

    pScriptEngine = GetScriptEngine(pBrowseDoc, puFlags);
    if (!pScriptEngine)
        goto Cleanup;   // fail silently


    // loop over all the dispatches in the script engine's name 
    //   space and get thier values.from..pSrcDoc
    hr = pScriptEngine->GetScriptDispatch( NULL, &pScriptNameSpace );
    if ( hr )
        goto Cleanup;

    hr = (pScriptNameSpace->QueryInterface( IID_IDispatchEx, (void**)&pDispScript));
    if ( hr )
        goto Cleanup;

    // inorder to derefernce the script variables we need the browse
    // documents window.
    hr = (pBrowseDoc->get_parentWindow(&pWin));
    if(hr)
        goto Cleanup;

    hr = (pWin->QueryInterface(IID_IDispatchEx, (void**)&pBrowseWin));
    if (hr)
        goto Cleanup;

    // now run through all the objects in this script engine and 
    // find their values 
    hr = (pDispScript->GetNextDispID(0, DISPID_STARTENUM, &dispidName));
    if (hr)
        goto Cleanup;

    while (dispidName)
    {
        hr = (pDispScript->GetMemberName(dispidName, &bstrName));
        if (!hr && bstrName)
        {
            DISPID  dispidBrowser;

            if (!FAILED(pBrowseWin->GetDispID(bstrName, fdexNameCaseSensitive, &dispidBrowser)))
            {
                DISPPARAMS dp;
                CVariant cvarRes;
                BOOL fNeedsQuotesInScript = FALSE;

                dp.rgvarg = NULL;
                dp.rgdispidNamedArgs = NULL;
                dp.cArgs = 0;
                dp.cNamedArgs = 0;

                hr = (pBrowseWin->Invoke(dispidBrowser,
                                             IID_NULL,  
                                             LCID_SCRIPTING,   
                                             DISPATCH_PROPERTYGET,
                                             &dp,                 
                                             &cvarRes,            
                                             NULL,                
                                             NULL));


                fNeedsQuotesInScript = (V_VT(&cvarRes) == VT_BSTR);

                // Filter out VT_IDISPATCH & VT_UNKNOWN
                if (!hr && 
                    V_VT(&cvarRes) != VT_DISPATCH &&
                    V_VT(&cvarRes) != VT_UNKNOWN   &&
                    !FAILED(cvarRes.CoerceVariantArg(VT_BSTR)))
                {
                    // assume JSCript if not VBScript
                    LPTSTR  pstrAssign = (*puFlags & SCRIPT_ENGINE_VBSCRIPT) ? 
                                                _T("\n\r    dim ") : 
                                                _T("\n\r    var ");


                    // concatenate on the end of the buffer.
                    //  "\n\r    var <name> = " <value>";  "
                    hr = pstrBuffer->QuickAppend(pstrAssign);
                    if (hr)
                        goto Cleanup;
                    hr = pstrBuffer->QuickAppend(bstrName);
                    if (hr)
                        goto Cleanup;

                    // if vbscript, put assignment on its own line.
                    if (*puFlags & SCRIPT_ENGINE_VBSCRIPT)
                    {
                        hr = pstrBuffer->QuickAppend(_T("\n\r        "));
                        if (hr)
                            goto Cleanup;
                        hr = pstrBuffer->QuickAppend(bstrName);
                        if (hr)
                            goto Cleanup;
                    }

                    // now handle outputing the assignment itself, careful
                    // to only put quotes around things that were strings.
                    hr = pstrBuffer->QuickAppend(_T(" = "));
                    if (hr)
                        goto Cleanup;

                    if (fNeedsQuotesInScript )
                    {
                        hr = pstrBuffer->QuickAppend(_T("\""));
                        if (hr)
                            goto Cleanup;
                    }

                    if (V_VT(&cvarRes) != VT_EMPTY)
                    {
                        hr = pstrBuffer->QuickAppend(V_BSTR(&cvarRes));
                    }
                    else
                    {
                        // someone had dim x = Empty in their script
                        // or var x = document.expando
                        // and this doesn't coerc to a bstr (returned S_FALSE)
                        // don't reset the use quotes flag,  
                        // for jscript convert to null, for vb
                        if (!(*puFlags & SCRIPT_ENGINE_VBSCRIPT))
                        {
                            hr = pstrBuffer->QuickAppend(_T("null"));
                        }
                        else
                            hr = pstrBuffer->QuickAppend(_T("Empty"));
                    }
                    if (hr)
                        goto Cleanup;

                    if (fNeedsQuotesInScript )
                    {
                        hr = pstrBuffer->QuickAppend(_T("\""));
                        if (hr)
                            goto Cleanup;
                    }

                    // VBSCRIPT doesn need ';' at the eol
                    if (!(*puFlags & SCRIPT_ENGINE_VBSCRIPT))
                    {
                        hr = pstrBuffer->QuickAppend(_T(";"));
                    }

                    if (hr)
                        goto Cleanup;
                }
            }

            SysFreeString(bstrName);
            bstrName = NULL;
        }
            
        hr = (pDispScript->GetNextDispID(0, dispidName, &dispidName));
        if (hr==S_FALSE)
        {  
            hr = S_OK;
            break;
        }
        else if (hr)
            goto Cleanup;
    }

 
Cleanup:
    if (pScriptEngine)
        pScriptEngine->Close();
    if (bstrName)
        SysFreeString(bstrName);
    ReleaseInterface(pPeerElement);
    ReleaseInterface(pBrowseDoc);
    ReleaseInterface(pScriptEngine);
    ReleaseInterface(pdispBrowseDoc);
    ReleaseInterface(pWin);
    ReleaseInterface(pBrowseWin);
    ReleaseInterface(pDispScript);
    ReleaseInterface(pScriptNameSpace);
    // no partial string in an error case... 
    if (hr)
        pstrBuffer->Set();

    return( hr );
}




//+-----------------------------------------------------------
//
// member : SaveHandler_GenericTag
//
// synopsis : this does the generic handling when a tag has the
//      persistence peer. It simply gets the outerHTML and saves that
//      in the XML object.  on the load the element will be hit
//      with a put_outerHTML of this string.
//
//+-----------------------------------------------------------
HRESULT
CPersistDataPeer::SaveHandler_GenericTag()
{
    HRESULT        hr = S_OK;
    CVariant       cvarOuter;
    IHTMLElement * pPeerParent = NULL;
    IHTMLElement * pPeerElement = NULL;

    _pPeerSite->GetElement(&pPeerElement);
    if (!pPeerElement)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // for elements in the head, we don't want to do this since
    // there is a tree limitation that doesn't allow the outerHTML
    // to be set.
    hr = pPeerElement->get_parentElement(&pPeerParent);
    if (hr)
        goto Cleanup;

    // the right way to do this is to ask the question:
    // are we in the body/frameset, NOT is our parent the
    // head, so...
    while (pPeerParent)
    {
        CVariant       cvarTag;
        IHTMLElement * pTemp = NULL;

        V_VT(&cvarTag) = VT_BSTR;
        hr = pPeerParent->get_tagName(&V_BSTR(&cvarTag));
        if (hr)
            goto Cleanup;

        if (0==_wcsicmp(V_BSTR(&cvarTag), L"body") ||
            0==_wcsicmp(V_BSTR(&cvarTag), L"frameset"))
            break;

        hr = pPeerParent->get_parentElement(&pTemp);
        if (hr)
            goto Cleanup;

        ClearInterface(&pPeerParent);
        pPeerParent = pTemp;
    }

    if (!pPeerParent)
        goto Cleanup;

    hr = pPeerElement->get_outerHTML(&V_BSTR(&cvarOuter));
    if (hr)
        goto Cleanup;

    V_VT(&cvarOuter) = VT_BSTR;

    // now save the outerHTML string
    hr = _pRoot->setAttribute(_T("__NEW_TAG_OUTER"), cvarOuter);
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pPeerElement);
    ReleaseInterface(pPeerParent);
    return( hr );
}


//+----------------------------------------------------------------------------
//
//  Member : LoadHandler_GenericTag()
//
//  Synopsis : this restores the outerHTML of the tag as it is loaded
//
//+----------------------------------------------------------------------------
HRESULT
CPersistDataPeer::LoadHandler_GenericTag()
{
    HRESULT          hr = S_OK;
    CVariant         cvarOuter;
    IHTMLElement   * pPeerElement   = NULL;

   if (!_pRoot)
        goto Cleanup;

    _pPeerSite->GetElement(&pPeerElement);
    if (!pPeerElement)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // now get the outerHTML string
    hr = _pRoot->getAttribute(_T("__NEW_TAG_OUTER"), &cvarOuter);
    if (hr)
        goto Cleanup;

    hr = cvarOuter.CoerceVariantArg(VT_BSTR);
    if (hr)
        goto Cleanup;

    hr = pPeerElement->put_outerHTML(V_BSTR(&cvarOuter));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pPeerElement);
    return( hr );
}


//+------------------------------------------------------------------------------
//
//  Member : SaveHandler_ScriptTag()
//
//  Synopsis : saves the script into the xml store.  We do this in the standard way:
//      1- create a private script engin,
//      2- load it with the text of the peer's script block
//      3 - walk through its namespace pulling out the variables
//      4 - create a list of name value pairs as the new script block
//      5 - save this block in the appropriate place
//
//+------------------------------------------------------------------------------

HRESULT
CPersistDataPeer::SaveHandler_ScriptTag()
{
    HRESULT          hr = S_OK;
    CVariant         cvarText;
    BSTR             bstrLanguage = NULL;
    CLSID            clsIDTarget;
    CLSID            clsIDLang;
    CBufferedStr     cbsNewScript;
    IDispatch      * pdispBrowseDoc = NULL;
    IHTMLDocument2 * pBrowseDoc     = NULL;
    IHTMLElement   * pPeerElement   = NULL;
    ULONG            uFlags = 0;


    if (!_pRoot)
        goto Cleanup;

    _pPeerSite->GetElement(&pPeerElement);
    if (!pPeerElement)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pPeerElement->get_document(&pdispBrowseDoc);
    if (hr)
        goto Cleanup;

    hr = pdispBrowseDoc->QueryInterface(IID_IHTMLDocument2, 
                                            (void**)&pBrowseDoc);
    if (hr)
        goto Cleanup;

    // get the new script block, and the language that it
    // originated from
    hr = BuildNewScriptBlock(&cbsNewScript, &uFlags);
    if (hr)
        goto Cleanup;

    // Language can only be set in design mode,  as a result
    // we can't change the script block since we don't know the
    //  syntax for an arbitrary script engine.  so, only save
    //  script if this is javascript or vbscript.
    if (uFlags & SCRIPT_ENGINE_OTHER)
        goto Cleanup;

    V_VT(&cvarText) = VT_BSTR;
    V_BSTR(&cvarText) = SysAllocString((LPTSTR)cbsNewScript);
    if (!V_BSTR(&cvarText))
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    hr = _pRoot->setAttribute(_T("__NEW_SCRIPT_TEXT"), cvarText);
    if (hr)
        goto Cleanup;

Cleanup:
    SysFreeString(bstrLanguage);
    ReleaseInterface(pPeerElement);
    ReleaseInterface(pBrowseDoc);
    ReleaseInterface(pdispBrowseDoc);
    return( hr );
}


//+----------------------------------------------------------------------------
//
//  Member : LoadHandler_ScriptTag()
//
//  Synopsis : does the load - but wait... 
//      NYI - put_text is design time only, so the peer needs a different way
//      of sliding this in.
//
//+----------------------------------------------------------------------------

HRESULT
CPersistDataPeer::LoadHandler_ScriptTag()
{
    HRESULT   hr = S_OK;
    CVariant  cvarText;

    if (!_pRoot)
        goto Cleanup;

    // try to get the new text from the saved XML
    hr = _pRoot->getAttribute(_T("__NEW_SCRIPT_TEXT"), &cvarText);
    if (hr)
        goto Cleanup;

    // if there is script text, then we need to set this into the 
    // browse window's namespace


Cleanup:
    if (hr == S_FALSE) hr = S_OK;
    return( hr );
}


//===============================================================
//
//  Class : CPersistShortcut
//
//  synopsis : derives from CPersistDataPeer and does the special handling 
//       related to the shortcut functionality
//
//===============================================================



//+----------------------------------------------------------------
//
// Member : save
//
//  synopsis: over ride of parent functionality to deal with shortcut
//      specific stuff...
//
//-----------------------------------------------------------------
HRESULT 
CPersistShortcut::save(IUnknown * pUnk, 
                       long lType, 
                       VARIANT_BOOL *pfContinue)
{
    HRESULT hr;

    if (lType != (long)htmlPersistStateFavorite)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = super::save(pUnk, lType, pfContinue);

    if (hr || (*pfContinue == VB_FALSE))
        goto Cleanup;

    // do the particular tag handling related to shortcuts
    switch (GetSaveCategory())
    {
    case ESC_UNKNOWN:
    case ESC_INTRINSIC:
    case ESC_CONTROL:
        hr = SaveHandler_GenericTag();
        break;

//    case ESC_SCRIPT:
//        hr = SaveHandler_ScriptTag();
//        break;

    default:
        break;
    }

Cleanup:
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member : Load
//
//  Synopsis : Implementation of the IHTMLPersistenceCache method
//
//-----------------------------------------------------------------------------

HRESULT
CPersistShortcut::load(IUnknown * pUnk, 
                       long lType, 
                       VARIANT_BOOL *pfDoDefault)
{
    HRESULT          hr;

    if (lType != (long)htmlPersistStateFavorite)
    {
        hr = S_OK;
        goto Cleanup;
    }

    // fire the event first, since the pPeerElement is about to be
    //  removed from the tree entirely.  Of course, if the user sets 
    // expandoes on this, they will get lost, but the alternative is to
    // loose access to the xmlcache.  So, if you think about it, they get
    // outerHTML behaviour, and using XMLCache behavior means
    // that you better cancel default behavior.
    hr = super::load(pUnk, lType, pfDoDefault);
    // is default load behavior canceled ?
    if (hr || (*pfDoDefault == VB_FALSE))
        goto Cleanup;

    switch (GetSaveCategory())
    {
    case ESC_UNKNOWN:
    case ESC_INTRINSIC:
    case ESC_CONTROL:
        hr = LoadHandler_GenericTag();
        break;

//    case ESC_SCRIPT:
//        hr = LoadHandler_ScriptTag();
//        break;

    default:
        break;
    }


Cleanup:
    return hr;
}


//===============================================================
//
//  Class : CPersistHistory
//
//  synopsis : derives from CPersistDataPeer and does the special handling 
//       related to the History functionality
//
//===============================================================


//+----------------------------------------------------------------
//
// Member : save
//
//  synopsis: over ride of parent functionality to deal with shortcut
//      specific stuff...
//
//-----------------------------------------------------------------
HRESULT 
CPersistHistory::save(IUnknown * pUnk, 
                       long lType, 
                       VARIANT_BOOL *pfContinue)
{
    HRESULT hr;

    if (lType != (long)htmlPersistStateHistory)
    {
        hr = S_OK;
        goto Cleanup;
    }

     hr = super::save(pUnk, lType, pfContinue);
    if (hr || (*pfContinue == VB_FALSE))
        goto Cleanup;

    // do any tag specific handling that history needs
    switch (GetSaveCategory())
    {
        // if we don't know anything special to do with this tag, just
        // transfer over its outerHTML on the assumption that the author
        // knows what they are doing
    case ESC_UNKNOWN:
    case ESC_INTRINSIC:
        hr = SaveHandler_GenericTag();
        break;

//    case ESC_SCRIPT:
//        hr = SaveHandler_ScriptTag();
//        break;

    default :
        break;
    }

Cleanup:
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member : Load
//
//  Synopsis : Implementation of the IHTMLPersistenceCache method
//
//-----------------------------------------------------------------------------

HRESULT
CPersistHistory::load(IUnknown * pUnk, 
                       long lType, 
                       VARIANT_BOOL *pfDoDefault)
{
    HRESULT          hr;

    if (lType != (long)htmlPersistStateHistory)
    {
        hr = S_OK;
        goto Cleanup;
    }

    // cache the OM pointers
    hr = InitOM(pUnk, lType);
    if (hr)
        goto Cleanup;

    hr = super::load(pUnk, lType, pfDoDefault);
    // is default load behavior canceled ?
    if (hr || (*pfDoDefault == VB_FALSE))
        goto Cleanup;

//  ISSUE (carled) NYI - script retoration presents a unique challenge 
//  because this needs to execute inline instead of the original 
//  script block text.
    switch(GetSaveCategory())
    {
//    case ESC_SCRIPT:
//        hr = LoadHandler_ScriptTag();
//        break;

    case ESC_UNKNOWN:
    case ESC_INTRINSIC:
        hr = LoadHandler_GenericTag();
        break;

    default:
        break;
    }

Cleanup:
    return hr;
}


//===============================================================
//
//  Class : CPersistSnapshot
//
//  synopsis : derives from CPersistDataPeer and does the special handling 
//       related to the run-time same (snapshot) functionality
//
//===============================================================


//+----------------------------------------------------------------
//
// Member : CPersistSnapshot::save
//
//  synopsis: over ride of parent functionality to deal with shortcut
//      specific stuff...
//      Since it doesn't make much sense to allow theXMLOM to be acccessed
//      in this case, calling super:: pretty much only fires the event.
//
//-----------------------------------------------------------------
HRESULT 
CPersistSnapshot::save(IUnknown * pUnk, 
                       long lType, 
                       VARIANT_BOOL *pfContinue)
{
    HRESULT          hr;
    CVariant         cvarTag;
    IHTMLDocument2 * pDesignDoc = NULL;

    if (lType != (long)htmlPersistStateSnapshot)
    {
        hr = S_OK;
        goto Cleanup;
    }

    if (!pUnk)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = pUnk->QueryInterface(IID_IHTMLDocument2, (void**)&pDesignDoc);
    if (hr)
        goto Cleanup;

    // allow the onsave event to be fired.
    hr = super::save(NULL, lType, pfContinue);
    if (hr || (*pfContinue == VB_FALSE))
        goto Cleanup;

    // now that the author has had the oppurtunity to set expandoes,
    // and value properties, we start the real work of snapshot saveing.
    switch (GetSaveCategory())
    {
    case ESC_CONTROL:
        hr = TransferControlValues(pDesignDoc);
        break;

    case ESC_SCRIPT:
        hr = TransferScriptValues(pDesignDoc);
        break;

    case ESC_UNKNOWN:
        // if we don't know anything special to do with this tag, just
        // transfer over its outerHTML on the assumption that the author
        // knows what they are doing
    case ESC_INTRINSIC:
        hr = TransferIntrinsicValues(pDesignDoc);
        break;

    default:
        break;
    }

Cleanup:
    ReleaseInterface(pDesignDoc);
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member : CPersistSnapshot::Load
//
//  Synopsis : Implementation of the IHTMLPersistenceCache method
//      Since it doesn't make much sense to allow theXMLOM to be acccessed
//      in this case, calling super:: pretty much only fires the event.
//
//-----------------------------------------------------------------------------

HRESULT
CPersistSnapshot::load(IUnknown * pUnk, 
                       long lType, 
                       VARIANT_BOOL *pfDoDefault)
{
    HRESULT          hr;

    if (lType != (long)htmlPersistStateSnapshot)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = super::load(pUnk, lType, pfDoDefault);

Cleanup:
    return hr;
}


//+-----------------------------------------------------------
//
// member : GetDesignElem
//
// Synposis : this helper function is responsible for finding the
//      design document's element counterpart to our pPeerElement.
//
//+-----------------------------------------------------------
IHTMLElement *
CPersistSnapshot::GetDesignElem(IHTMLDocument2 * pDesignDoc)
{
    HRESULT                  hr = S_OK;
    CVariant                 cvarID;
    CVariant                 cvarEmpty;
    IDispatch              * pDisp = NULL;
    IHTMLElement           * pRetElem = NULL;
    IHTMLElement           * pPeerElement = NULL;
    IHTMLElementCollection * pCollection = NULL;

    _pPeerSite->GetElement(&pPeerElement);
    if (!pPeerElement)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    V_VT(&cvarID) = VT_BSTR;
    hr = pPeerElement->get_id(&V_BSTR(&cvarID));
    if (hr)
        goto Cleanup;

    // first get the documents all collection.
    hr = pDesignDoc->get_all(&pCollection);
    if (hr)
        goto Cleanup;

    // now find out elements coutner part inthe design document, 
    // if it exits.  Elements that were created by inline scripts,
    // or other script driven means, may not be found.
    hr = pCollection->item(cvarID, cvarEmpty, &pDisp);
    if (hr || !pDisp)
        goto Cleanup;

    // make sure that we do not have a collection...
    hr = pDisp->QueryInterface(IID_IHTMLElement, (void**)&pRetElem);

Cleanup:
    ReleaseInterface(pPeerElement);
    ReleaseInterface(pDisp);
    ReleaseInterface(pCollection);
    return pRetElem;
}

//+-----------------------------------------------------------
//
// member : TransferIntrinsicValues 
//
// synopsis : this transfers the value of the browse-control to the 
//      design control by setting the outerHTML of the design control
//      to that of the browseControl
//
//+-----------------------------------------------------------
HRESULT
CPersistSnapshot::TransferIntrinsicValues (IHTMLDocument2 *pDesignDoc)
{
    HRESULT        hr = S_OK;
    BSTR           bstrOuter = NULL;
    IHTMLElement * pDesignElem = NULL;
    IHTMLElement * pPeerElement = NULL;

    _pPeerSite->GetElement(&pPeerElement);
    if (!pPeerElement)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pPeerElement->get_outerHTML(&bstrOuter);
    if (hr)
        goto Cleanup;

    pDesignElem = GetDesignElem(pDesignDoc);
    if (!pDesignElem)
        goto Cleanup;

    hr = pDesignElem->put_outerHTML(bstrOuter);

Cleanup:
    SysFreeString(bstrOuter);
    ReleaseInterface(pPeerElement);
    ReleaseInterface(pDesignElem);
    return( hr );
}


//+-----------------------------------------------------------
//
//  Member : TransferControlValues
//
//  Synopsis : Transfers the values of the control by cooking up a 
//      stream and calling IPersitHistory::Save on the browse-control
//      and then feeding that stream into IPersistHistory::Load on
//      the design-control,  Then when the design document is saved,
//      IPersistPropertyBag::save will get called (it is this that finally
//      allows the controls state to be written out as the altHTML attribute.
//
//+-----------------------------------------------------------
HRESULT
CPersistSnapshot::TransferControlValues (IHTMLDocument2 *pDesignDoc)
{
    HRESULT           hr = S_OK;
    IHTMLElement    * pDesignElem = NULL;
    IHTMLElement    * pPeerElement = NULL;
    IPersistHistory * pSrcPH = NULL;
    IPersistHistory * pDesignPH = NULL;
    IStream         * pStream = NULL;
    HGLOBAL           hg = NULL;
    static LARGE_INTEGER i64Zero = {0, 0};

    _pPeerSite->GetElement(&pPeerElement);
    if (!pPeerElement)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pDesignElem = GetDesignElem(pDesignDoc);
    if (!pDesignElem)
        goto Cleanup;

    // step 1. get the appropriate IPersistHistory interfaces.
    hr = pPeerElement->QueryInterface(IID_IPersistHistory, (void**)&pSrcPH);
    if (hr)
        goto Cleanup;

    hr = (pDesignElem->QueryInterface(IID_IPersistHistory, (void**)&pDesignPH));
    if (hr)
        goto Cleanup;

    // step 2. create a temporary stream
    hg = GlobalAlloc(GMEM_MOVEABLE, 0);
    if (!hg)
    {  
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = (CreateStreamOnHGlobal(hg, TRUE, &pStream));
    if (hr)
        goto Cleanup;

    // Step 3. save the browse object
    hr = (pSrcPH->SaveHistory(pStream));
    if (hr)
        goto Cleanup;

    // Step 4. reset the stream
    hr = (pStream->Seek(i64Zero, STREAM_SEEK_SET, NULL));
    if (hr)
        goto Cleanup;

    // Stpe 5. Load the design object.
    hr = (pDesignPH->LoadHistory(pStream, NULL));
    if (hr)
        goto Cleanup;

Cleanup:
    // ISSUE (carled) is there a memory leak here? the hGlobal was allocated,
    //   a stream was created, and freed but where does the memory get freed?
    ReleaseInterface(pPeerElement);
    ReleaseInterface(pStream);
    ReleaseInterface(pSrcPH);
    ReleaseInterface(pDesignPH);
    ReleaseInterface(pDesignElem);
    return( (hr == E_NOINTERFACE)? S_OK : hr );
}


//+-----------------------------------------------------------
//
//  Member : TransferScriptValues
//
//  Synopsis: transfers the values of script blocks, by loading this
//      script into a private script engine, and then iterating over all
//      the values and getting the current values from the browse document.
//      These (Variable, Value) pairs are then spit out as the new innerHTML
//      of the design-script element.
//
//+-----------------------------------------------------------

HRESULT
CPersistSnapshot::TransferScriptValues (IHTMLDocument2 *pDesignDoc)
{ 
    HRESULT          hr = S_OK;
    IHTMLElement   * pDesignElem  = NULL;
    BSTR             bstrNewBlock = NULL;
    CBufferedStr     cbsNewScript;
    ULONG            uFlags       = 0;
    IHTMLScriptElement * pScriptElem = NULL;

    pDesignElem = GetDesignElem(pDesignDoc);
    if (!pDesignElem)
        goto Cleanup;

    // get the text of the new script block
    hr = (BuildNewScriptBlock(&cbsNewScript, &uFlags));
    if (hr)
        goto Cleanup;

    bstrNewBlock = SysAllocString((LPTSTR)cbsNewScript);
    if (!bstrNewBlock)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Set the new script assignments 
    hr = (pDesignElem->QueryInterface(IID_IHTMLScriptElement, (void**)&pScriptElem));
    if ( hr )
        goto Cleanup;

    hr = (pScriptElem->put_text(bstrNewBlock));
    if ( hr )
        goto Cleanup;

    // since all the namespaces exist on the "window"
    // we need to make sure that the script block we
    // write out is in a language whose syntax we know. As
    // a result a script block from any ActiveScript language
    // will get persisted, but unless it is VBScript or JScript, 
    // in the saveing, it is translated into JScript.
    if (uFlags & SCRIPT_ENGINE_OTHER)
    {
        BSTR  bstrForceLanguage = SysAllocString(L"JScript");
        if (!bstrForceLanguage)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = (pDesignElem->put_language(bstrForceLanguage));
        SysFreeString(bstrForceLanguage);
        if (hr) 
            goto Cleanup;
    }
    
Cleanup:
    SysFreeString(bstrNewBlock);
    ReleaseInterface(pScriptElem);
    ReleaseInterface(pDesignElem);
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\rectpeer.cxx ===
//===============================================================
//
//  rectpeer.cxx : Implementation of the CLayoutRect Peer
//
//  Synposis : this class is repsponsible for handling the "generic"
//      containership for view templates. It is the XML-ish tag <layout:Rect>
//
//===============================================================
                                                              
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef __X_IEXTAG_H_
#define __X_IEXTAG_H_
#include "iextag.h"
#endif

#ifndef __X_RECTPEER_HXX_
#define __X_RECTPEER_HXX_
#include "rectpeer.hxx"
#endif

#ifndef __X_UTILS_HXX_
#define __X_UTILS_HXX_
#include "utils.hxx"
#endif

#ifndef X_SHLGUID_H_
#define X_SHLGUID_H_
#include <shlguid.h> 
#endif

#ifndef MSHTMHST_H_
#define MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef MSHTMCID_H_
#define MSHTMCID_H_
#include <mshtmcid.h>
#endif

#define CheckResult(x) { hr = x; if (FAILED(hr)) goto Cleanup; }

//+----------------------------------------------------------------------------
//
//  DTOR
//
//-----------------------------------------------------------------------------

CLayoutRect::~CLayoutRect()
{
    Detach();
}

//+----------------------------------------------------------------------------
//
//  Member : Detach - IElementBehavior method impl
//
//  Synopsis : when the peer is detatched, we will take this oppurtunity 
//      to release our various cached pointers.
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CLayoutRect::Detach() 
{ 
    CDataObject  * pDO = NULL;
    long           i=0;

    ClearInterface( &_pPeerSite );

    for (pDO = &_aryAttributes[0], i=0;
         pDO && i< eAttrTotal;
         pDO++, i++)
    {
         pDO->ClearContents();
    }

    return S_OK; 
}

//+----------------------------------------------------------------------------
//
//  Member : Init - IElementBehavior method impl
//
//  Synopsis : this method is called by MSHTML.dll to initialize peer object.
//      this is where we do all the connection and peer management work.
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CLayoutRect::Init(IElementBehaviorSite * pPeerSite)
{
    HRESULT          hr = S_OK;
    VARIANT          varParam;
    CContextAccess   ca(pPeerSite);    

    if (!pPeerSite)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // some of our attributes have default values
    V_BOOL(&_aryAttributes[eHonorPageBreaks]._varValue) = VB_TRUE;
    V_VT(&_aryAttributes[eHonorPageBreaks]._varValue) = VT_BOOL;

    V_BOOL(&_aryAttributes[eHonorPageRules]._varValue) = VB_TRUE;
    V_VT(&_aryAttributes[eHonorPageRules]._varValue) = VT_BOOL;


    // cache our peer element
    _pPeerSite = pPeerSite;
    _pPeerSite->AddRef();

    // set up our default style sheet
    ca.Open(CA_SITEOM | CA_DEFAULTS | CA_DEFSTYLE);

    // The contents of layout rects shouldn't inherit styles from outside;
    // we're like frames.
    CheckResult( ca.Defaults()->put_viewInheritStyle( VB_FALSE ) );

    CheckResult( ca.DefStyle()->put_overflow(CComBSTR("hidden")));

    V_VT(&varParam) = VT_BSTR;
    V_BSTR(&varParam) = SysAllocString(_T("300px"));
    if (!V_BSTR(&varParam))
        goto Cleanup;
    CheckResult( ca.DefStyle()->put_width(varParam));
    VariantClear(&varParam);

    V_VT(&varParam) = VT_BSTR;
    V_BSTR(&varParam) = SysAllocString(_T("150px"));
    if (!V_BSTR(&varParam))
        goto Cleanup;
    CheckResult( ca.DefStyle()->put_height(varParam));
    VariantClear(&varParam);

Cleanup:
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member : Notify - IElementBehavior method impl
//
//  Synopsis : peer Interface, called for notification of document events.
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CLayoutRect::Notify(LONG lEvent, VARIANT *)
{
    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Member : get_nextRect - ILayoutRect property impl
//         : put_nextRect - ILayoutRect property impl
//
//  Synopsis : property get'er. returns the next element in the container chain
//           : property put'er. sets the next element in the container chain
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CLayoutRect::get_nextRect(BSTR * pbstrNextId)
{
    TEMPLATESECURITYCHECK()

    if ( !pbstrNextId )
        return E_POINTER;

    return _aryAttributes[eNextRect].GetAsBSTR( pbstrNextId );
}


STDMETHODIMP
CLayoutRect::put_nextRect(BSTR bstrNextId )
{
    TEMPLATESECURITYCHECK()

    return _aryAttributes[eNextRect].Set(bstrNextId);
}


STDMETHODIMP
CLayoutRect::get_media(BSTR * pbstrMedia)
{
    TEMPLATESECURITYCHECK()

    // (greglett) This won't ever be used.  Don't confuse the caller.  Let them know.
    return E_NOTIMPL;
}


STDMETHODIMP
CLayoutRect::put_media(BSTR bstrMedia )
{
    TEMPLATESECURITYCHECK()

    // (greglett) This won't ever be used.  Don't confuse the caller.  Let them know.
    return E_NOTIMPL;
}


//+----------------------------------------------------------------------------
//
//  Member : get_contentSrc - ILayoutRect property impl
//         : put_contentSrc - ILayoutRect property impl
//
//  Synopsis : property get'er. returns the String of the content ULR
//           : property put'er. sets the string of the content URL 
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLayoutRect::get_contentSrc(VARIANT * pvarSrc)
{
    TEMPLATESECURITYCHECK()

    if (!pvarSrc)
        return E_POINTER;

    return VariantCopy(pvarSrc, &(_aryAttributes[eContentSrc]._varValue));
}

STDMETHODIMP
CLayoutRect::put_contentSrc(VARIANT varSrc)
{
    HRESULT hr;

    if (!TemplateAccessAllowed(_pPeerSite))
    {
        PutBlankViewLink();
        return E_ACCESSDENIED;
    }

    hr =  VariantCopy(&(_aryAttributes[eContentSrc]._varValue), &varSrc);
    if (hr)
        goto Cleanup;

    if (V_VT(&varSrc) == VT_BSTR)
    {
        hr = PutViewLink(V_BSTR(&varSrc));
    }
    else if (   V_VT(&varSrc) == VT_UNKNOWN
             || V_VT(&varSrc) == VT_DISPATCH)
    {
        hr = PutViewLink(V_UNKNOWN(&varSrc));
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if (hr)
        goto Cleanup;

Cleanup:
    return hr;
}

//+----------------------------------------------------------------------
//
//   Helper : PutViewLink
//
//   Handles an IUnknown and routes it to the relevant PutViewLink function
//
//-----------------------------------------------------------------------
HRESULT
CLayoutRect::PutViewLink(IUnknown * pUnk )
{
    HRESULT           hr            = E_FAIL;
    IHTMLDocument2  * pISlaveDoc    = NULL;     // Slave document
    IStream         * pIStream      = NULL;     // OE Express header stream

    if (!pUnk)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Are we an HTML document?
    if (    !pUnk->QueryInterface(IID_IHTMLDocument2, (void**)&pISlaveDoc)
        &&  pISlaveDoc)
    {
        hr = PutViewLink(pISlaveDoc);
    }
    // Are we a stream from which to load an HTML document?
    else if (   !pUnk->QueryInterface(IID_IStream, (void **)&pIStream)
             && pIStream)
    {
        hr = PutViewLink(pIStream);
    }

Cleanup:
    ReleaseInterface(pISlaveDoc);
    ReleaseInterface(pIStream);
    return hr;
}

//+----------------------------------------------------------------------
//
//   Helper : PutViewLink
//
//   Handles a IHTMLDocument2 input so that we can set up table-of-links.
//   The second one handles strings, so that 
//   we can connect to "document" or to a specific URL
//
//-----------------------------------------------------------------------
HRESULT
CLayoutRect::PutViewLink(IHTMLDocument2 * pISlaveDoc )
{
    HRESULT hr = S_OK;
    IHTMLElement            * pIBody        = NULL;     // From input document
    IHTMLElement            * pIBodyNew     = NULL;     // From (slave) document copy.
    IHTMLDocument           * pINewSlaveDoc = NULL;
    IHTMLDocument4          * pINewSlaveDoc4= NULL;     // Copied document.
    IDispatch               * pIDDocNewSlave= NULL;     // Copied Document
    IElementBehaviorSiteOM2 * pIBS          = NULL;
    IHTMLElementDefaults    * pIPThis       = NULL;
    IOleCommandTarget       * pioctNewSlave = NULL;
    IHTMLElement            * pIElement     = NULL;
    IDispatch               * pIDDoc        = NULL;
    IHTMLDocument2          * pIThisDoc2    = NULL;
    BSTR                      bstrTagName   = NULL;
    BSTR                      bstrHTML      = NULL;
    BSTR                      bstrMedia     = NULL;
    VARIANT var;
    VariantInit(&var);


    if (!pISlaveDoc)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // Get the body and save its innerHTML
    hr = pISlaveDoc->get_body(&pIBody);
    if (FAILED(hr))
        goto Cleanup;
    if (!pIBody)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pIBody->get_innerHTML(&bstrHTML);
    if (FAILED(hr))
        goto Cleanup;
    if (!bstrHTML)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pIBody->get_tagName(&bstrTagName);
    if (FAILED(hr))
        goto Cleanup;
    if (!bstrTagName)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // Set the media to print on the BODY markup before we parse in the stream string.
    bstrMedia = SysAllocString(_T("print"));
    if (!bstrMedia)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }


    // Create an element to act as the viewlinked document.
    Assert(_pPeerSite);
    hr = _pPeerSite->GetElement(&pIElement);
    if (FAILED(hr))
        goto Cleanup;
    if (!pIElement)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pIElement->get_document(&pIDDoc); 
    if (FAILED(hr))
        goto Cleanup;
    if (!pIDDoc)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    hr = pIDDoc->QueryInterface(IID_IHTMLDocument2, (void **)&pIThisDoc2);
    if (FAILED(hr))
        goto Cleanup;
    if (!pIThisDoc2)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pIThisDoc2->createElement(bstrTagName, &pIBodyNew);
    if (FAILED(hr))
        goto Cleanup;
    if (!pIBodyNew)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pIBodyNew->get_document(&pIDDocNewSlave);
    if (FAILED(hr))
        goto Cleanup;
    if (!pIDDocNewSlave)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pIDDocNewSlave->QueryInterface(IID_IHTMLDocument4, (void **)&pINewSlaveDoc4);
    if (FAILED(hr))
        goto Cleanup;
    if (!pINewSlaveDoc4)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    hr = pIDDocNewSlave->QueryInterface(IID_IOleCommandTarget, (void **)&pioctNewSlave);
    if (FAILED(hr))
        goto Cleanup;
    if (!pioctNewSlave)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    //
    //  (greglett) 11/27/2000
    //  There are two types of Print Media
    //  1. (per element) WYSIWYG mesurement. Set by the DeviceRect.
    //  2. (per markup)  A combination of "is paginated media", "is a print content document", and "should apply printing rules like no bg, media styles..."
    //     It is crucial to set the first two here right now.
    //     We only allowed print media to be set on a print template in 5.5 for a few reasons:
    //     1. The combination of the above three properties is arbitrary and confusing enough that it would be impossible to explain.
    //     2. Why would someone who is not a print template be interetsted in displaying as if printing?
    //     3. Incorrect worries about security issues in setting print media (URL spoofing, metafile running, &c...)
    //     The first two reasons are still valid, so Trident still blocks this for anything other than print templates in 6.0.
    //     This used to not be an issue, since print-templateness was a CDoc level thing.  Now that it is per markup...
    //     This is nonsensical. In fact, *no* paginated/print content documents should be print templates, and vice-versa.
    //     For Blackcomb, we really need to refactor what "Print Media" means.
    //     
    V_VT(&var) = VT_BOOL;
    V_BOOL(&var) = VB_TRUE;
    hr = pioctNewSlave->Exec( &CGID_MSHTML,
                           IDM_SETPRINTTEMPLATE,
                           NULL, 
                           &var, 
                           NULL);
    if (FAILED(hr))
        goto Cleanup;

    hr = pINewSlaveDoc4->put_media(bstrMedia);
    if (FAILED(hr))
        goto Cleanup;

    V_BOOL(&var) = VB_FALSE;
    hr = pioctNewSlave->Exec( &CGID_MSHTML,
                           IDM_SETPRINTTEMPLATE,
                           NULL, 
                           &var, 
                           NULL);
    if (FAILED(hr))
        goto Cleanup;


    // Reparse in the innerHTML, so that all media properties will get picked up
    hr = pIBodyNew->put_innerHTML(bstrHTML);
    if (FAILED(hr))
        goto Cleanup;

    // Viewlink the slave doc.
    Assert(_pPeerSite);
    hr = _pPeerSite->QueryInterface(IID_IElementBehaviorSiteOM2, (void**)&pIBS);
    if (FAILED(hr))
        goto Cleanup;
    if (!pIBS)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pIBS->GetDefaults(&pIPThis);
    if (FAILED(hr))
        goto Cleanup;
    if (!pIPThis)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pINewSlaveDoc4->QueryInterface(IID_IHTMLDocument, (void**)&pINewSlaveDoc);
    if (FAILED(hr))
        goto Cleanup;
    if (!pINewSlaveDoc)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pIPThis->putref_viewLink(pINewSlaveDoc);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pIBody);
    ReleaseInterface(pIBodyNew);
    ReleaseInterface(pIDDocNewSlave);
    ReleaseInterface(pINewSlaveDoc);
    ReleaseInterface(pINewSlaveDoc4);
    ReleaseInterface(pIPThis);
    ReleaseInterface(pIBS);
    ReleaseInterface(pioctNewSlave);
    ReleaseInterface(pIElement);
    ReleaseInterface(pIDDoc);
    ReleaseInterface(pIThisDoc2);
    SysFreeString(bstrHTML);
    SysFreeString(bstrTagName);
    SysFreeString(bstrMedia);
    return hr;
}

//+----------------------------------------------------------------------
//
//   Helper : PutViewLink
//
//   Handles a IHTMLDocument2 input so that we can set up table-of-links.
//   The second one handles strings, so that 
//   we can connect to "document" or to a specific URL
//
//-----------------------------------------------------------------------
#define UNICODE_MARKER 0xfeff
HRESULT
CLayoutRect::PutViewLink(IStream * pIStream)
{
    HRESULT                   hr            = S_OK;
    IHTMLElement            * pIElement     = NULL;
    IDispatch               * pIDDoc        = NULL;
    IHTMLDocument2          * pIThisDoc2    = NULL;
    IHTMLDocument2          * pISlaveDoc2   = NULL;
    IHTMLDocument4          * pISlaveDoc4   = NULL;
    IDispatch               * pIDDocSlave   = NULL;
    IHTMLElement            * pBodyNew      = NULL;
    IElementBehaviorSiteOM2 * pIBS          = NULL;
    IHTMLElementDefaults    * pIPThis       = NULL;
    IOleCommandTarget       * pioctSlave    = NULL;
    BSTR                      bstrBody      = NULL;
    BSTR                      bstrHTML      = NULL;
    BSTR                      bstrMedia     = NULL;
    VARIANT                   var;
    CBufferedStr              strContent;
    LARGE_INTEGER             lnOffset;

    VariantInit(&var);

    if (!pIStream)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    lnOffset.HighPart   = 0;
    lnOffset.LowPart    = 0;
    pIStream->Seek(lnOffset, STREAM_SEEK_SET, NULL);
    
    // Read the OE header.  We need the *whole* thing to pass in as an innerHTML.
    {
        BOOL    fUnicode;
        WCHAR   chUnicodeMarker = UNICODE_MARKER;
        WCHAR   achBufWC[1024];
        CHAR    achBufMB[1024];
        ULONG   cRead;
    
        hr = pIStream->Read(achBufWC, sizeof(WCHAR), &cRead);
        if (!hr)
        {
            fUnicode = (memcmp(achBufWC, &chUnicodeMarker, sizeof(WCHAR)) == 0);
            if (!fUnicode)
                pIStream->Seek(lnOffset, STREAM_SEEK_SET, NULL);    // Put it back!  We took off two real MB characters
            
            while (     hr == S_OK
                    &&  cRead > 0  )
            {
                if (fUnicode)
                {
                    hr = pIStream->Read(achBufWC, 1023 * sizeof(WCHAR), &cRead);
                    cRead /= sizeof(WCHAR);
                }
                else
                {
                    hr = pIStream->Read(achBufMB, 1023 * sizeof(CHAR), &cRead);
                    cRead = MultiByteToWideChar(CP_ACP, 0, achBufMB, cRead, achBufWC, 1023);
                }

                if (cRead > 0)
                {
                    achBufWC[cRead] = _T('\0');
                    strContent.QuickAppend(achBufWC);
                }
            }
        }
    }

    // Create a BODY to act as the viewlinked document.
    hr = _pPeerSite->GetElement(&pIElement);
    if (FAILED(hr))
        goto Cleanup;
    Assert(pIElement);

    hr = pIElement->get_document(&pIDDoc); 
    if (FAILED(hr))
        goto Cleanup;
    Assert(pIDDoc);
    
    bstrBody = SysAllocString(_T("BODY"));
    if (!bstrBody)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pIDDoc->QueryInterface(IID_IHTMLDocument2, (void **)&pIThisDoc2);
    if (FAILED(hr))
        goto Cleanup;
    Assert(pIThisDoc2);    

    hr = pIThisDoc2->createElement(bstrBody, &pBodyNew);
    if (FAILED(hr))
        goto Cleanup;
    Assert(pBodyNew);    

    bstrHTML = SysAllocString(strContent);
    if (!bstrHTML)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }    
   
    // Set the media to print on the BODY markup before we parse in the stream string.
    bstrMedia = SysAllocString(_T("print"));
    if (!bstrMedia)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pBodyNew->get_document(&pIDDocSlave);
    if (FAILED(hr))
        goto Cleanup;
    Assert(pIDDocSlave);

    hr = pIDDocSlave->QueryInterface(IID_IHTMLDocument4, (void **)&pISlaveDoc4);
    if (FAILED(hr))
        goto Cleanup;
    Assert(pISlaveDoc4);

    hr = pIDDocSlave->QueryInterface(IID_IOleCommandTarget, (void **)&pioctSlave);
    if (FAILED(hr))
        goto Cleanup;
    Assert(pioctSlave);
        
    //
    //  (greglett) 11/27/2000
    //  There are two types of Print Media
    //  1. (per element) WYSIWYG mesurement. Set by the DeviceRect.
    //  2. (per markup)  A combination of "is paginated media", "is a print content document", and "should apply printing rules like no bg, media styles..."
    //     It is crucial to set the first two here right now.
    //     We only allowed print media to be set on a print template in 5.5 for a few reasons:
    //     1. The combination of the above three properties is arbitrary and confusing enough that it would be impossible to explain.
    //     2. Why would someone who is not a print template be interetsted in displaying as if printing?
    //     3. Incorrect worries about security issues in setting print media (URL spoofing, metafile running, &c...)
    //     The first two reasons are still valid, so Trident still blocks this for anything other than print templates in 6.0.
    //     This used to not be an issue, since print-templateness was a CDoc level thing.  Now that it is per markup...
    //     This is nonsensical. In fact, *no* paginated/print content documents should be print templates, and vice-versa.
    //     For Blackcomb, we really need to refactor what "Print Media" means.
    //     
    V_VT(&var) = VT_BOOL;
    V_BOOL(&var) = VB_TRUE;
    hr = pioctSlave->Exec( &CGID_MSHTML,
                           IDM_SETPRINTTEMPLATE,
                           NULL, 
                           &var, 
                           NULL);
    if (FAILED(hr))
        goto Cleanup;

    hr = pISlaveDoc4->put_media(bstrMedia);
    if (FAILED(hr))
        goto Cleanup;

    V_BOOL(&var) = VB_FALSE;
    hr = pioctSlave->Exec( &CGID_MSHTML,
                           IDM_SETPRINTTEMPLATE,
                           NULL, 
                           &var, 
                           NULL);
    if (FAILED(hr))
        goto Cleanup;

    // innerHTML in the contents of the stream as the new document...
    hr = pBodyNew->put_innerHTML(bstrHTML);
    if (FAILED(hr))
        goto Cleanup;

    // ...and viewlink the document.
    hr = pIDDocSlave->QueryInterface(IID_IHTMLDocument2, (void **)&pISlaveDoc2);
    if (FAILED(hr))
        goto Cleanup;
    Assert(pISlaveDoc2);
    
    Assert(_pPeerSite);
    hr = _pPeerSite->QueryInterface(IID_IElementBehaviorSiteOM2, (void**)&pIBS);
    if (FAILED(hr))
        goto Cleanup;
    Assert(pIBS);

    hr = pIBS->GetDefaults(&pIPThis);
    if (FAILED(hr))
        goto Cleanup;
    Assert(pIPThis);

    hr = pIPThis->putref_viewLink(pISlaveDoc2);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pIElement);
    ReleaseInterface(pIDDoc);
    ReleaseInterface(pISlaveDoc2);
    ReleaseInterface(pISlaveDoc4);
    ReleaseInterface(pIDDocSlave);
    ReleaseInterface(pIThisDoc2);
    ReleaseInterface(pBodyNew);
    ReleaseInterface(pIPThis);
    ReleaseInterface(pIBS);
    ReleaseInterface(pioctSlave);
    SysFreeString(bstrBody);
    SysFreeString(bstrHTML);
    SysFreeString(bstrMedia);
    return hr;
}

//+----------------------------------------------------------------------
//
//   Helper : PutViewLink
//
//   Handles a BSTR input to connect to "document" or a specific URL.
//
//-----------------------------------------------------------------------
HRESULT
CLayoutRect::PutViewLink(BSTR bstrSrc)
{

    HRESULT                 hr;
    IElementBehaviorSite  * pIPeerSite         = _pPeerSite; // interface to our peer
    IHTMLElement          * pIThis             = NULL;     // Interface to this element
    IHTMLElementDefaults  * pIPThis            = NULL;     // Interface to this's element defaults
    IDispatch             * pIThisDocDispatch  = NULL;     // The doc we're in
    IHTMLDocument4        * pIThisDoc4         = NULL;     // Same, so we can get to contentFromUrl
    IHTMLDocument2        * pISlaveDoc         = NULL;     // Slave document
    IElementBehaviorSiteOM2 * pIBS             = NULL;
    IHTMLDialog           * pIDialog           = NULL;
    IServiceProvider      * pIDocSrvProv       = NULL;
    IHTMLEventObj2        * pIEventObj         = NULL;
    BSTR                    bstrOptions        = NULL;
    BSTR                    bstrURL            = NULL;
    VARIANT                 vunkDialogArg;
    VARIANT                 vbstrContentDoc;
    VARIANT                 vbIsXML;

    VariantInit(&vunkDialogArg);
    VariantInit(&vbstrContentDoc);
    VariantInit(&vbIsXML);

    Assert(bstrSrc);
    if (!bstrSrc)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = pIPeerSite->GetElement(&pIThis);
    if (FAILED(hr))
        goto Cleanup;

    hr = pIThis->get_document(&pIThisDocDispatch); 
    if (FAILED(hr))
        goto Cleanup;

    hr = pIThisDocDispatch->QueryInterface(IID_IHTMLDocument4, (void**)&pIThisDoc4);
    if (FAILED(hr))
        goto Cleanup;

    //  Get the dialog arguments, if they exist
    hr = pIThisDocDispatch->QueryInterface(IID_IServiceProvider, (void **)&pIDocSrvProv);
    if (!FAILED(hr))
    {
        // The keyword "document" maps to the dialog argument __IE_ContentDocumentUrl.  Go after it.
        hr = pIDocSrvProv->QueryService(IID_IHTMLDialog, IID_IHTMLDialog, (void**)&pIDialog);
        if (!FAILED(hr))
        {            
            hr = pIDialog->get_dialogArguments(&vunkDialogArg);
            if (FAILED(hr) || V_VT(&vunkDialogArg) != VT_UNKNOWN)
                goto Cleanup;

            hr = V_UNKNOWN(&vunkDialogArg)->QueryInterface(IID_IHTMLEventObj2, (void**)&pIEventObj);
            if (FAILED(hr))
                goto Cleanup;

        }
    }

    if (V_VT(&vunkDialogArg) != VT_UNKNOWN)
    {
        bstrOptions = SysAllocString( _T("print") );
        bstrURL     = bstrSrc;
    }
    else
    {
        BSTR    bstrTarget=NULL;

        bstrTarget = SysAllocString(_T("__IE_ContentDocumentUrl"));
        if (!bstrTarget)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = pIEventObj->getAttribute(bstrTarget, 0, &vbstrContentDoc);

        SysFreeString(bstrTarget);
        if (FAILED(hr) || V_VT(&vbstrContentDoc) != VT_BSTR)
            goto Cleanup;

        // We now have the content document URL in vbstrContentDoc.  Either
    
        if (    !_tcsicmp(bstrSrc, _T("document"))
            ||  !_tcsicmp(bstrSrc, V_BSTR(&vbstrContentDoc)) )
        {
            bstrTarget = SysAllocString(_T("__IE_ParsedXML"));
            if (!bstrTarget)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            hr = pIEventObj->getAttribute(bstrTarget, 0, &vbIsXML);

            SysFreeString(bstrTarget);

            // Are we an already parsed XML document (with HTML:xxx tags)?
            if (    !FAILED(hr)
                &&  V_VT(&vbIsXML) == VT_BOOL
                &&  V_BOOL(&vbIsXML) == VB_TRUE )
            {
                bstrOptions = SysAllocString( _T("print xml") );
            }
            else
            {
                bstrOptions = SysAllocString( _T("print") );
            }        

            bstrURL = V_BSTR(&vbstrContentDoc);
        }
        else
        {
            bstrOptions = SysAllocString( _T("print") );
            bstrURL     = bstrSrc;            
        }
    }

    if ( !bstrOptions )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    Assert(bstrURL);    
    hr = pIThisDoc4->createDocumentFromUrl(bstrURL, bstrOptions, &pISlaveDoc);

    if (FAILED(hr))
        goto Cleanup;

    hr = pIPeerSite->QueryInterface(IID_IElementBehaviorSiteOM2, (void**)&pIBS);
    if (FAILED(hr))
        goto Cleanup;

    hr = pIBS->GetDefaults(&pIPThis);
    if (FAILED(hr))
        goto Cleanup;

    hr = pIPThis->putref_viewLink(pISlaveDoc);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    SysFreeString( bstrOptions );
    ReleaseInterface(pIThis);
    ReleaseInterface(pIPThis);
    ReleaseInterface(pIThisDocDispatch);
    ReleaseInterface(pIThisDoc4);
    ReleaseInterface(pISlaveDoc);
    ReleaseInterface(pIBS);
    ReleaseInterface(pIDialog);
    ReleaseInterface(pIDocSrvProv);
    ReleaseInterface(pIEventObj);
    VariantClear(&vunkDialogArg);                
    VariantClear(&vbstrContentDoc);
    return hr;
}

//+----------------------------------------------------------------------
//
//   Helper : PutBlankViewLink
//
//   Does a PutViewLink for "about:blank"
//
//-----------------------------------------------------------------------
HRESULT CLayoutRect::PutBlankViewLink()
{
    HRESULT hr;

    BSTR bstrBlank = SysAllocString(_T("about:blank"));
    if (!bstrBlank)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = PutViewLink(bstrBlank);

Cleanup:
    if (bstrBlank)
        SysFreeString(bstrBlank);

    return hr;
}



//+----------------------------------------------------------------------------
//
//  Member : get_honorPageBreaks - ILayoutRect property imple
//         : put_honorPageBreaks - ILayoutRect property imple
//
//  Synopsis : Get'r and put'r for the boolean property on whether to honorPageBreaks
//          within this tag. By default this is true.
//
//+----------------------------------------------------------------------------
STDMETHODIMP
CLayoutRect::get_honorPageBreaks (VARIANT_BOOL * pVB)
{
    TEMPLATESECURITYCHECK()

    return _aryAttributes[eHonorPageBreaks].GetAsBOOL(pVB);
}

STDMETHODIMP
CLayoutRect::put_honorPageBreaks (VARIANT_BOOL v)
{
    TEMPLATESECURITYCHECK()

    return _aryAttributes[eHonorPageBreaks].Set(v);
}

//+----------------------------------------------------------------------------
//
//  Member : get_honorPageRules - ILayoutRect property imple
//         : put_honorPageRules - ILayoutRect property imple
//
//  Synopsis : Get'r and put'r for the boolean property on whether to honorPageRules
//          within this tag. By default this is true.
//
//+----------------------------------------------------------------------------
STDMETHODIMP
CLayoutRect::get_honorPageRules (VARIANT_BOOL * pVB)
{
    TEMPLATESECURITYCHECK()

    return _aryAttributes[eHonorPageRules].GetAsBOOL(pVB);
}

STDMETHODIMP
CLayoutRect::put_honorPageRules (VARIANT_BOOL v)
{
    TEMPLATESECURITYCHECK()

    return _aryAttributes[eHonorPageRules].Set(v);
}

//+----------------------------------------------------------------------------
//
//  Member : get_nextRectElement - ILayoutRect property imple
//         : put_nextRectElement - ILayoutRect property imple
//
//  Synopsis : Get'r and put'r for the IDispatch property for the nextRect.
//
//+----------------------------------------------------------------------------
STDMETHODIMP
CLayoutRect::get_nextRectElement (IDispatch ** ppElem)
{
    TEMPLATESECURITYCHECK()

    // (greglett) This is not currently used, and we don't want to do the work to get this
    // working in the Whistler timeframe.
    return E_NOTIMPL;

    //return _aryAttributes[eNextRectElement].GetAsDispatch( ppElem );
}

STDMETHODIMP
CLayoutRect::put_nextRectElement (IDispatch * pElem)
{
    TEMPLATESECURITYCHECK()

    // (greglett) This is not currently used, and we don't want to do the work to get this
    // working in the Whistler timeframe.
    return E_NOTIMPL;

    //return _aryAttributes[eNextRectElement].Set( pElem );
}

//+----------------------------------------------------------------------------
//
//  Member : get_contentDocument - ILayoutRect property imple
//         : put_contentDocument - ILayoutRect property imple
//
//  Synopsis : Get'r and put'r for the IDispatch property for the contentDocument.
//
//+----------------------------------------------------------------------------

STDMETHODIMP
CLayoutRect::get_contentDocument(IDispatch ** ppDoc)
{
    TEMPLATESECURITYCHECK()

    // get peer, get IHTMLElement, get ViewLink, get document
    HRESULT hr = S_OK;
    IElementBehaviorSite    * pPeerSite     = _pPeerSite;
    IElementBehaviorSiteOM2 * pIBS          = NULL;
    IHTMLElementDefaults    * pIPThis       = NULL;

    if (!ppDoc)
        return E_POINTER;

    *ppDoc = NULL;

    hr = pPeerSite->QueryInterface(IID_IElementBehaviorSiteOM2, (void**)&pIBS);
    if (hr)
        goto Cleanup;

    hr = pIBS->GetDefaults(&pIPThis);
    if (hr)
        goto Cleanup;

    hr = pIPThis->get_viewLink((IHTMLDocument **)ppDoc);
    
    hr = S_OK;

Cleanup:
    ReleaseInterface(pIBS);
    ReleaseInterface(pIPThis);
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member : Load  - IPersistPropertyBag2 property impl
//
//  Synopsis : This gives us a chance to pull properties from the property bag
//      created when the element's attributes were parsed in. Since we handle
//      all the getter/putter logic, our copy of the value will always be the 
//      current one.  This gives this behavior full control over the attribures
//      that it is interested in.
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CLayoutRect::Load ( IPropertyBag2 *pPropBag, IErrorLog *pErrLog)
{
    HRESULT        hr = S_OK;
    IPropertyBag * pBag = NULL;
    CDataObject  * pDO = NULL;
    long           i=0;
 
    if (!pPropBag)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = pPropBag->QueryInterface(IID_IPropertyBag, (void**) &pBag);
    if (hr || !pBag)
        goto Cleanup;

    // loop through all the attributes and load them
    for (pDO = &_aryAttributes[0], i=0;
         pDO && i< eAttrTotal;
         pDO++, i++)
    {
        pBag->Read(pDO->_pstrPropertyName, &pDO->_varValue, pErrLog);
    }

    BSTR bstr;
    _aryAttributes[eContentSrc].GetAsBSTR(&bstr);
    if (bstr)
    {
        if (TemplateAccessAllowed(_pPeerSite))
            PutViewLink(bstr);
        else
            PutBlankViewLink();

    }

Cleanup:
    ReleaseInterface(pBag);
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member : Save  - IPersistPropertyBag2 property impl
//
//  Synopsis : Like the load, above, this allows us to save the attributes which
//      we control.  This is all part of fully owning our element's behavior, OM
//      and attributes. 
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CLayoutRect::Save ( IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    HRESULT        hr = S_OK;
    IPropertyBag * pBag = NULL;
    CDataObject  * pDO = NULL;
    long           i=0;

    // verify parameters
    if (!pPropBag)
    {
        hr = E_POINTER;
        goto Cleanup;
    }


    // now go through our properties and save them if they are dirty, or if
    // a save-All is required.
    //---------------------------------------------------------------------

    hr = pPropBag->QueryInterface(IID_IPropertyBag, (void**) &pBag);
    if (hr || !pBag)
        goto Cleanup;

    for (pDO = &_aryAttributes[0], i=0;
         pDO && i< eAttrTotal;
         pDO++, i++)
    {
        if (pDO->IsDirty() || fSaveAllProperties)
        {
            if (V_VT(&pDO->_varValue) != VT_DISPATCH)
            {
                pBag->Write(pDO->_pstrPropertyName, &(pDO->_varValue));

                if (fClearDirty)
                    pDO->_fDirty = FALSE;
            }
        }
    }

Cleanup:
    ReleaseInterface(pBag);

    return hr;
}

  
//+-----------------------------------------------------------------------------
//
//  Method: Draw, IHTMLPainter
//
//------------------------------------------------------------------------------
STDMETHODIMP
CLayoutRect::Draw(RECT rcBounds, RECT rcUpdate, LONG lDrawFlags, HDC hdc,
                         LPVOID pvDrawObject)
{
    return E_NOTIMPL;
}

//+-----------------------------------------------------------------------------
//
//  Method: GetRenderInfo, IHTMLPainter
//
//------------------------------------------------------------------------------
STDMETHODIMP
CLayoutRect::GetPainterInfo(HTML_PAINTER_INFO * pInfo)
{
    Assert(pInfo != NULL);

    *pInfo = _hpi;

    return S_OK;
}


//+-----------------------------------------------------------------------------
//
//  Method: HitTestPoint, IHTMLPainter
//
//------------------------------------------------------------------------------
STDMETHODIMP
CLayoutRect::HitTestPoint(POINT pt, BOOL * pbHit, LONG *plPartID)
{
    Assert(pbHit != NULL);

    *pbHit = TRUE;

    return S_OK;
}

//+-----------------------------------------------------------------------------
//
//  Method: OnResize, IHTMLPainter
//
//------------------------------------------------------------------------------
STDMETHODIMP
CLayoutRect::OnResize(SIZE size)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\scrllbar.cxx ===
//+------------------------------------------------------------------
//
// Microsoft IEPEERS
// Copyright (C) Microsoft Corporation, 1999.
//
// File:        iextags\scrllbar.cxx
//
// Contents:    Scrollbar Control
//
// Classes:     CScrollBar
//
// Interfaces:  IScrollBar
//
//-------------------------------------------------------------------

#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "iextag.h"

#include "utils.hxx"

#include "utbutton.hxx"
#include "scrllbar.hxx"

#define CheckResult(x) { hr = x; if (FAILED(hr)) goto Cleanup; }

/////////////////////////////////////////////////////////////////////////////
//
// CScrollBar
//
/////////////////////////////////////////////////////////////////////////////

const CBaseCtl::PROPDESC CScrollBar::s_propdesc[] = 
{
    {_T("max"), VT_I4, 100},
    {_T("min"), VT_I4, 0},
    {_T("unit"), VT_I4, 1},
    {_T("block"), VT_I4, 10},
    {_T("visible-units"), VT_I4, 20},
    {_T("position"), VT_I4, 0},
    {_T("orientation"), VT_BSTR, 0, _T("horizontal")},
    NULL
};

enum
{
    eMax = 0,
    eMin,
    eUnit,
    eBlock,
    eVisibleUnits,
    ePosition,
    eOrientation,
};

//+------------------------------------------------------------------------
//
//  Members:    CScrollBar::CScrollBar
//              CScrollBar::~CScrollBar
//
//  Synopsis:   Constructor/Destructor
//
//-------------------------------------------------------------------------

CScrollBar::CScrollBar()
{
}

CScrollBar::~CScrollBar()
{
    if (_pSinkBlockInc)
    {
        delete _pSinkBlockInc;
    }
    if (_pSinkBlockDec)
    {
        delete _pSinkBlockDec;
    }
    if (_pSinkSlider)
    {
        delete _pSinkSlider;
    }
    if (_pSinkDelayTimer)
    {
        delete _pSinkDelayTimer;
    }
    if (_pSinkRepeatTimer)
    {
        delete _pSinkRepeatTimer;
    }
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::Init()
//
// Synopsis:    Set up the scroll bar's events
//
// Arguments:   None
//
// Returns:     Success if the control is setup correctly.
//
//-------------------------------------------------------------------


HRESULT
CScrollBar::Init()
{
    HRESULT hr = S_OK;
    CContextAccess  a(_pSite);

    a.Open(CA_ELEM | CA_DEFAULTS | CA_SITEOM | CA_DEFAULTS);

    //
    // Register the scrollbar name
    //

    CheckResult( a.SiteOM()->RegisterName(_T("scrollbar")));

    //
    // Register for events
    //

    CheckResult( AttachEvent(EVENT_ONMOUSEUP, &a));
    CheckResult( AttachEvent(EVENT_ONMOUSEDOWN, &a));
    CheckResult( AttachEvent(EVENT_ONKEYDOWN, &a));
    CheckResult( AttachEvent(EVENT_ONPROPERTYCHANGE, &a));
    CheckResult( AttachEvent(EVENT_ONSELECTSTART, &a));
    CheckResult( AttachEvent(EVENT_ONFOCUS, &a));
    CheckResult( AttachEvent(EVENT_ONBLUR, &a));

    // We want to be able to receive keyboard focus

    CheckResult( a.Defaults()->put_tabStop(VB_TRUE));
    CheckResult( a.Defaults()->put_viewMasterTab(VB_TRUE));

    //
    // Register the scrollbar's events
    //

    CheckResult( RegisterEvent(a.SiteOM(), CComBSTR("onscroll"), &_lOnScrollCookie));
    CheckResult( RegisterEvent(a.SiteOM(), CComBSTR("onchange"), &_lOnChangeCookie));

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::Detach()
//
// Synopsis:    Releases interfaces.
//
// Arguments:   None
//
// Returns:     S_OK
//
//-------------------------------------------------------------------

HRESULT
CScrollBar::Detach()
{
    _pIncrementer->Unload();
    _pDecrementer->Unload();
    _pSliderThumb->Unload();

    ReleaseInterface(_pBlockInc);
    ReleaseInterface(_pBlockDec);
    ReleaseInterface(_pSliderBar);
    ReleaseInterface(_pContainer);

    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::OnContentReady()
//
// Synopsis:    Called when the HTML content for the control is ready.
//
// Arguments:   None
//
// Returns:     Success if the control is created correctly.
//
//-------------------------------------------------------------------

HRESULT
CScrollBar::OnContentReady()
{
    HRESULT hr = S_OK;

    //
    // Cache the properties
    //

    CheckResult( ReadProperties());

    //
    // Create the button
    //

    CheckResult( BuildContainer());
    CheckResult( BuildDecrementer());
    CheckResult( BuildSliderBar());
    CheckResult( BuildBlockDecrementer());
    CheckResult( BuildSliderThumb());
    CheckResult( BuildBlockIncrementer());
    CheckResult( BuildIncrementer());

    //
    // Calculate dimensions and layout correctly
    //

    CheckResult( Layout());
    
Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::OnPropertyChange()
//
// Synopsis:    Called when the scrollbar property changes.  Gives us the 
//              chance to redraw if the scrollbar is changed dynamically
//
// Arguments:   Names of changes property
//
// Returns:     Success if the control is created correctly.
//
//-------------------------------------------------------------------

HRESULT
CScrollBar::OnPropertyChange(CEventObjectAccess *pEvent, BSTR propertyName)
{
    HRESULT hr = S_OK;

    CheckResult( Layout());

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::OnMouseDown()
//
// Synopsis:    Called to handel 'onmousedown' event; does a page inc/dec
//              Sets focus on element triggering an onfocus event
//
// Arguments:   Event Object
//
// Returns:     Success if the control is created correctly.
//
//-------------------------------------------------------------------


HRESULT
CScrollBar::OnMouseDown(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    CContextAccess a(_pSite);

    CheckResult( a.Open(CA_ELEM2))

    CheckResult( a.Elem2()->focus());

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::OnKeyDown()
//
// Synopsis:    Called to handle 'onmouseup' event; does a page inc/dec
//
// Arguments:   Event Object
//
// Returns:     Success if the control is handled property.
//
//-------------------------------------------------------------------


HRESULT
CScrollBar::OnKeyDown(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    long lKeyCode;

    CheckResult( pEvent->GetKeyCode(&lKeyCode));

    switch (lKeyCode)
    {
        case VK_END:            
        {
            _lCurrentPosition = _lMaxPosition;

            CheckResult( SetThumbPosition( _lCurrentPosition ));
            break; 
        }

        case VK_HOME:
        {
            _lCurrentPosition = _lMinPosition;

            CheckResult( SetThumbPosition( _lCurrentPosition ));
            break;
        }

        case VK_NEXT:
        {
            _lCurIncrement = _lBlockIncrement;
            
            CheckResult( DoIncrement());
            break;
        }

        case VK_PRIOR:
        {
            _lCurIncrement = - _lBlockIncrement;
            
            CheckResult( DoIncrement());
            break;
        }

        case VK_DOWN:
        case VK_RIGHT:
        {
            _lCurIncrement = _lUnitIncrement;

            CheckResult( DoIncrement());
            break;
        }
        
        case VK_UP:
        case VK_LEFT:
        {
            _lCurIncrement = - _lUnitIncrement;

            CheckResult( DoIncrement());
            break;
        }
    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::OnMouseUp()
//
// Synopsis:    Called to handle 'onmouseup' event; does a page inc/dec
//
// Arguments:   Event Object
//
// Returns:     Success if the control is handled property.
//
//-------------------------------------------------------------------


HRESULT
CScrollBar::OnMouseUp(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::OnSelectStart
//
// Synopsis:    Called to handel 'onclick' event
//
// Arguments:   Names of changes property
//
// Returns:     Success if the control is created correctly.
//
//-------------------------------------------------------------------

HRESULT
CScrollBar::OnSelectStart(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    CheckResult( pEvent->EventObj()->put_cancelBubble( VARIANT_TRUE ));
    CheckResult( pEvent->EventObj()->put_returnValue( CComVariant(false) ));

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::BuildContainer()
//
// Synopsis:    Builds the scrollbar container DIV.
//
// Arguments:   None
//
// Returns:     Success if the control is created correctly.
//
//-------------------------------------------------------------------



HRESULT
CScrollBar::BuildContainer()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLStyle> pStyle;

    CComPtr<IDispatch> pDispDocLink;
    CComPtr<IHTMLDocument2> pDocLink;

    CComBSTR    bstr;
    CComVariant color;

    CContextAccess a(_pSite);
    
    CheckResult( GetScrollbarColor(&color));

    hr = a.Open( CA_ELEM | CA_STYLE | CA_DEFAULTS);
    if (FAILED(hr))
        goto Cleanup;

    //
    //  Get the height and width of behavior element object
    //

    hr = a.Style()->get_pixelWidth(&_width);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Style()->get_pixelHeight(&_height);
    if (FAILED(hr))
        goto Cleanup;

    //
    //  Make sure that _width and _height are reasonable
    //

    CheckResult( AdjustHeightAndWidth());

    hr = GetHTMLDocument(_pSite, &pDoc);
    if (FAILED(hr))
        goto Cleanup;

    hr = pDoc->createElement(CComBSTR("div"), &_pContainer);
    if (FAILED(hr))
        goto Cleanup;

    hr = _pContainer->get_style(&pStyle);
    if (FAILED(hr))
        goto Cleanup;

    hr = pStyle->put_pixelWidth(_width);
    if (FAILED(hr))
        goto Cleanup;

    hr = pStyle->put_pixelHeight(_height);
    if (FAILED(hr))
        goto Cleanup;

    hr = pStyle->put_backgroundColor(color);
    if (FAILED(hr))
        goto Cleanup;

    hr = pStyle->put_overflow(CComBSTR("hidden"));
    if (FAILED(hr))
        goto Cleanup;


    //
    // Set up the view link
    //

    CheckResult( _pContainer->get_document(&pDispDocLink));
    CheckResult( pDispDocLink->QueryInterface(IID_IHTMLDocument2, (void**) &pDocLink));
    CheckResult( a.Defaults()->putref_viewLink(pDocLink));

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::AdjustHeightAndWidth()
//
// Synopsis:    Verifies that height and width are sane and sets to 
//              rational values if not.
//
// Arguments:   none
//
// Returns:     S_OK if all goes will
//
//-------------------------------------------------------------------

HRESULT 
CScrollBar::AdjustHeightAndWidth()
{
    HRESULT hr = S_OK;

    CVariant        width, height;
    CContextAccess  a(_pSite);

    a.Open( CA_STYLE );

    CheckResult( a.Style()->get_width(&width));
    CheckResult( a.Style()->get_height(&height));

    if(_eoOrientation == Horizontal) 
    {
        if(height.IsEmpty() || ((V_VT(&height) == VT_BSTR) && (V_BSTR(&height) == NULL)) ) 
        {
            _height = GetSystemMetrics(SM_CYHSCROLL);
        }   
        if(width.IsEmpty() || ((V_VT(&width) == VT_BSTR) && (V_BSTR(&width) == NULL)))
        {
            _width  = 100;
        }

        _height = max(_height, 8);
    }
    else
    {
        if(width.IsEmpty() || ((V_VT(&height) == VT_BSTR) && (V_BSTR(&height) == NULL)))
        {
            _width  = GetSystemMetrics(SM_CXVSCROLL);
        }
        if(height.IsEmpty() || ((V_VT(&width) == VT_BSTR) && (V_BSTR(&width) == NULL)))
        {
            _height = 100;
        }

        _width = max(_width, 8);
    }

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::IncrementCallback()
//
// Synopsis:    Called by the increment button
//
// Arguments:   A Utility Button
//
// Returns:     true if button can be incremented, false otherwise
//
//-------------------------------------------------------------------


HRESULT 
CScrollBar::IncrementCallback(CUtilityButton *pButton)
{
    HRESULT hr = S_OK;

    if(pButton->IsPressing()) 
    {

        if(pButton->IsRaised()) 
        {
            CheckResult( ClearTimers());

            _suspended = true;
        }
        
        else 
        {
            if(_suspended)
            {
                CheckResult( StartRepeatTimer());

                _suspended = false;
            }
            else 
            {
                _lCurIncrement = _lUnitIncrement;

                CheckResult( DoIncrement());
                CheckResult( StartDelayTimer());
            }
        }

    }

    else 
    {
        CheckResult( ClearTimers());

        _suspended = false;
    }

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::DecrementCallback()
//
// Synopsis:    Called by the decrement button
//
// Arguments:   A Utility Button
//
// Returns:     true if button can be decremented, false otherwise
//
//-------------------------------------------------------------------


HRESULT 
CScrollBar::DecrementCallback(CUtilityButton *pButton)
{
    HRESULT hr = S_OK;

    if(pButton->IsPressing()) 
    {

        if(pButton->IsRaised()) 
        {
            CheckResult( ClearTimers());

            _suspended = true;
        }
        
        else 
        {
            if(_suspended)
            {
                CheckResult( StartRepeatTimer());

                _suspended = false;
            }
            else 
            {
                _lCurIncrement = - _lUnitIncrement;

                CheckResult( DoIncrement());
                CheckResult( StartDelayTimer());
            }
        }

    }

    else 
    {
        CheckResult( ClearTimers());

        _suspended = false;
    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::DoIncrement()
//
// Synopsis:    Increments current position by the current increment amount
//              which is set by the various unit or block incrementers.
//              Fires and event, and sets the thumb position to the new value.
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------

HRESULT
CScrollBar::DoIncrement()
{
    HRESULT hr = S_OK;

    long _lOldPosition = _lCurrentPosition;

    _lCurrentPosition += _lCurIncrement;
    
    //
    //  Don't let it go below the mininum
    //

    if(_lCurrentPosition < _lMinPosition)
    {
        _lCurrentPosition = _lMinPosition;
    }

    //
    //  Or above the maximum
    //

    else if(_lCurrentPosition > _lMaxPosition)
    {
        _lCurrentPosition = _lMaxPosition;
    }

    //
    //  Move the thumb
    //

    CheckResult( SetThumbPosition( _lCurrentPosition ));

    //
    //  If position has changed, fire an event...
    //

    if(_lOldPosition != _lCurrentPosition) 
    {

        CheckResult( FireEvent( _lOnChangeCookie, NULL, CComBSTR("change")) );

    }

Cleanup:

    return hr;

}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::MouseMoveCallback()
//
// Synopsis:    Performs a sanity check on the proposed coordinate.
//              Called by the slider thumb when an attempt is made to move it
//
// Arguments:   None
//
// Returns:     true if button can be moved, false otherwise
//
//-------------------------------------------------------------------


HRESULT 
CScrollBar::MouseMoveCallback(CUtilityButton *pButton, long &x, long &y)
{
    HRESULT hr = S_OK;

    long max = TrackLength() - ThumbLength();

    if(_eoOrientation == Horizontal) 
    {

        if(x < 0)
            x = 0;

        if(x > max)
            x = max;

        //
        // Reset the current position
        //

        CheckResult( SyncThumbPosition( x ));
    }

    else 
    {

        if(y < 0)
            y = 0;

        if(y > max)
            y = max;

        //
        // Reset the current position
        //

        CheckResult( SyncThumbPosition( y ));
    }

    //
    // This stuff is for performance conciderations, with three divs making up the slider
    // - track, thumb, track - moving the thumb and continuously resizng the track elements 
    // caused wragged movement.  Instead, we won't display them once the thumb starts to move, and
    // turn them back on when the thumb stops.
    //

    if(! pButton->IsMoving()) 
    {
        CheckResult( SetBlockMoverPositions());

        CheckResult( BlockDisplay(_pBlockDec, true));
        CheckResult( BlockDisplay(_pBlockInc, true));

    }
    else 
    {
        CheckResult( BlockDisplay(_pBlockDec, false));
        CheckResult( BlockDisplay(_pBlockInc, false));
    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::StartDelayTimer()
//
// Synopsis:    Sets up the Delay timeout and builds its event sink if necessary
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------

HRESULT
CScrollBar::StartDelayTimer()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLWindow2> pWindow;
    CComPtr<IHTMLWindow3> pWindow3;
    CComVariant vDispatch;
    CComVariant vLanguage;

    //
    //  Create a new timer sink if one doesn't exist yet
    //

    if(! _pSinkDelayTimer) 
    {

        _pSinkDelayTimer = new CEventSink(this, NULL, SCROLL_DELAY_TIMER);
        if (!_pSinkDelayTimer)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

    }

    //
    // Setup the Delay Timer
    //

    vDispatch = _pSinkDelayTimer;
    _pSinkDelayTimer->AddRef();

    Assert( _lDelayTimerId == 0);

    CheckResult( GetHTMLDocument(_pSite, &pDoc));
    CheckResult( pDoc->get_parentWindow( &pWindow));
    CheckResult( pWindow->QueryInterface( __uuidof(IHTMLWindow3), (void **) &pWindow3 ));
    CheckResult( pWindow3->setTimeout( &vDispatch, GetDelayRate(), &vLanguage, &_lDelayTimerId ));

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::ClearDelayTimer()
//
// Synopsis:    Stops the delay timer
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------

HRESULT
CScrollBar::ClearDelayTimer()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLWindow2> pWindow;

    //
    //  Clear the delay timer
    //

    if(_lDelayTimerId)
    {

        CheckResult( GetHTMLDocument(_pSite, &pDoc));
        CheckResult( pDoc->get_parentWindow( &pWindow));
        CheckResult( pWindow->clearTimeout( _lDelayTimerId ));

        _lDelayTimerId = 0;

    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::OnDelay()
//
// Synopsis:    Called when the Delay timeout fires.  Clears the timer,
//              increments, and then starts the Repeat interval timer
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------

HRESULT
CScrollBar::OnDelay()
{
    HRESULT hr = S_OK;

    //
    //  Clear the delay timer; start the repeat timer
    //

    CheckResult( ClearDelayTimer());
    CheckResult( DoIncrement());
    CheckResult( StartRepeatTimer());

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::StartRepeatTimer()
//
// Synopsis:    Sets up the repeat timer and builds its event sink if necessary
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------

HRESULT
CScrollBar::StartRepeatTimer()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLWindow2> pWindow;
    CComPtr<IHTMLWindow3> pWindow3;
    CComVariant vDispatch;
    CComVariant vLanguage;

    //
    // Setup the Timer interval
    //

    if (! _pSinkRepeatTimer )
    {

        _pSinkRepeatTimer = new CEventSink(this, NULL, SCROLL_REPEAT_TIMER);
        if (!_pSinkRepeatTimer)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

    }

    vDispatch = _pSinkRepeatTimer;
    _pSinkRepeatTimer->AddRef();

    Assert( _lRepeatTimerId == 0);

    CheckResult( GetHTMLDocument(_pSite, &pDoc));
    CheckResult( pDoc->get_parentWindow( &pWindow));
    CheckResult( pWindow->QueryInterface( __uuidof(IHTMLWindow3), (void **) &pWindow3 ));
    CheckResult( pWindow3->setInterval( &vDispatch, GetRepeatRate(), &vLanguage, &_lRepeatTimerId ));

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::ClearRepeatTimer()
//
// Synopsis:    Stops the repeat timer
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------

HRESULT
CScrollBar::ClearRepeatTimer()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLWindow2> pWindow;

    if(_lRepeatTimerId)
    {

        CheckResult( GetHTMLDocument(_pSite, &pDoc));
        CheckResult( pDoc->get_parentWindow( &pWindow));
        CheckResult( pWindow->clearInterval( _lRepeatTimerId ));

        _lRepeatTimerId = 0;

    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::OnRepeat()
//
// Synopsis:    Fires the incrementer
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT
CScrollBar::OnRepeat()
{
    HRESULT hr = S_OK;

    CheckResult( DoIncrement());

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::ClearTimers()
//
// Synopsis:    Stops any active timers.  Effectively, this stops repeating actions
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT
CScrollBar::ClearTimers()
{
    HRESULT hr = S_OK;

    CheckResult( ClearDelayTimer());
    CheckResult( ClearRepeatTimer());

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::BlockMoveStartInc()
//
// Synopsis:    Start the block increment process
//
// Arguments:   CEventObjectAccess
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT   
CScrollBar::BlockMoveStartInc(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLElement2> pElement2;

    _moving    = true;
    _pCurBlock = _pBlockInc;

    CheckResult( _pBlockInc->QueryInterface( __uuidof(IHTMLElement2), (void **) &pElement2));
    CheckResult( pElement2->setCapture());
    CheckResult( BlockIncrement());
    CheckResult( BlockHighlight(_pBlockInc, true));

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::BlockMoveStartDec()
//
// Synopsis:    Start the block decrement process
//
// Arguments:   CEventObjectAccess
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT 
CScrollBar::BlockMoveStartDec(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLElement2> pElement2;

    _moving    = true;
    _pCurBlock = _pBlockDec;

    CheckResult( _pBlockDec->QueryInterface( __uuidof(IHTMLElement2), (void **) &pElement2));
    CheckResult( pElement2->setCapture());
    CheckResult( BlockDecrement());
    CheckResult( BlockHighlight(_pBlockDec, true));

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::BlockMoveSuspend()
//
// Synopsis:    Used to suspend and restart the repeater timers.  
//
// Arguments:   CEventObjectAccess
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT   
CScrollBar::BlockMoveSuspend(CEventObjectAccess *pEvent, IHTMLElement *pTrack)
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLElement> pSrcElement;

    pEvent->Open(EOA_EVENTOBJ);

    if( _moving ) 
    {
        CheckResult( pEvent->EventObj()->get_srcElement(&pSrcElement))

        if(! IsSameObject( pSrcElement, pTrack) )
        {
            _suspended = true;

            CheckResult( BlockHighlight(pTrack, false));
            CheckResult( ClearRepeatTimer());
        }

        else if( _suspended ) 
        {
            _suspended = false;
    
            CheckResult( BlockHighlight(pTrack, true));
            CheckResult( StartRepeatTimer());

        }
    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::BlockMoveResume()
//
// Synopsis:    Resumes the repeating move functionality by restarting the timer
//
// Arguments:   CEventObjectAccess
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT   
CScrollBar::BlockMoveResume(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    if( _moving ) 
    {
        CheckResult( StartRepeatTimer());
    }

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::BlockMoveEnd()
//
// Synopsis:    Shuts down the block move process buy dehighlighting the area
//              and stopping any timers
//
// Arguments:   CEventObjectAccess
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT   
CScrollBar::BlockMoveEnd(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLElement2> pElement2;

    if(_pCurBlock) 
    {
        CheckResult( _pCurBlock->QueryInterface( __uuidof(IHTMLElement2), (void **) &pElement2));
        CheckResult( pElement2->releaseCapture());
    }

    CheckResult( ClearTimers());
    CheckResult( BlockHighlight( _pBlockInc, false));
    CheckResult( BlockHighlight( _pBlockDec, false));

    _moving = false;
    _suspended = false;
    _pCurBlock = NULL;

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::BlockCheck()
//
// Synopsis:    Checks to see if the mouse coordinates of the pEvent object
//              fall withing the bounding box of the current block move element.
//              If not, the repeat action is halted buy clearing the timers
//
// Arguments:   CEventObjectAccess *pEvent
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT   
CScrollBar::BlockMoveCheck(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    POINT ptClient;
    CComPtr<IHTMLRect> pRect;
    CComPtr<IHTMLElement2> pElement2;

    long top, left, right, bottom;

    if(! _pCurBlock)
        return S_OK;

    CheckResult( pEvent->GetWindowCoordinates(&ptClient));

    CheckResult( _pCurBlock->QueryInterface( __uuidof(IHTMLElement2), (void **) &pElement2));
    CheckResult( pElement2->getBoundingClientRect(&pRect));

    CheckResult( pRect->get_left(&left));
    CheckResult( pRect->get_top(&top));
    CheckResult( pRect->get_right(&right));
    CheckResult( pRect->get_bottom(&bottom));

    if(! (((ptClient.x >= left) && (ptClient.x <= right)) && 
          ((ptClient.y >= top)  && (ptClient.y <= bottom)))) 
    {
        CheckResult( BlockHighlight(_pCurBlock, false));
        CheckResult( ClearTimers());
    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::BlockDisplay()
//
// Synopsis:    Used set the display property to 'none' before move
//              the slider thumb so that it appears to move more smoothly.
//              After the move is completed, the display is set to inline.
//
// Arguments:   IHTMLElement pBlock - the block to hightlight
//              bool flag           - turn on or off
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT   
CScrollBar::BlockDisplay(IHTMLElement *pBlock, bool flag)
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLStyle> pStyle;

    CComBSTR bstr;

    bstr       = flag ? _T("inline") : _T("none");

    CheckResult( pBlock->get_style(&pStyle));
    CheckResult( pStyle->put_display(bstr));


Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::BlockHighlight()
//
// Synopsis:    Used set the display property to 'none' before move
//              the slider thumb so that it appears to move more smoothly.
//              After the move is completed, the display is set to inline.
//
// Arguments:   IHTMLElement pBlock - the block to hightlight
//              bool flag           - turn on or off
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------

HRESULT   
CScrollBar::BlockHighlight(IHTMLElement *pBlock, bool flag)
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLStyle> pStyle;

    CComVariant color;

    if(flag) 
    {
        CheckResult( GetShadowColor(&color));
    }
    else
    {
        CheckResult( GetScrollbarColor(&color));
    }

    CheckResult( pBlock->get_style(&pStyle));
    CheckResult( pStyle->put_backgroundColor(color));


Cleanup:

    return hr;

}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::BlockIncrement()
//
// Synopsis:    Increments the scrollbar one page (or as much of one as
//              possible)
//
// Arguments:   None
//
// Returns:     S_OK
//
//-------------------------------------------------------------------


HRESULT  
CScrollBar::BlockIncrement() 
{
    HRESULT hr = S_OK;

    _lCurIncrement = _lBlockIncrement;

    CheckResult( DoIncrement());
    CheckResult( StartDelayTimer());

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::BlockDecrement()
//
// Synopsis:    Decrements the scrollbar one page (or as much of one as
//              possible)
//
// Arguments:   None
//
// Returns:     S_OK
//
//-------------------------------------------------------------------


HRESULT  
CScrollBar::BlockDecrement()
{
    HRESULT hr = S_OK;

    _lCurIncrement = - _lBlockIncrement;

    CheckResult( DoIncrement());
    CheckResult( StartDelayTimer());

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::SetThumbPosition()
//
// Synopsis:    Set the thumb position to the location determined by the 
//              unit
//
// Arguments:   None
//
// Returns:     S_OK
//
//-------------------------------------------------------------------


HRESULT  
CScrollBar::SetThumbPosition(long position)
{
    HRESULT hr = S_OK;

    double  pixPerUnit;

    //
    //  Update the OM
    //

    GetProps()[ePosition].Set(position); 

    //
    //  Calculate the offset of the thumb
    //

    _sliderOffset = NearestLong( (PixelsPerUnit() * (double) (position - _lMinPosition)));

    if ( _eoOrientation == Horizontal ) 
    {

        CheckResult( _pSliderThumb->SetHorizontalOffset(_sliderOffset));

    }
    else 
    {

        CheckResult( _pSliderThumb->SetVerticalOffset(_sliderOffset));

    }

    CheckResult( SetBlockMoverPositions());

Cleanup:

    return S_OK;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::SyncThumbPosition()
//
// Synopsis:    Essentially the inverse of SetThumbPositoin.  This function
//              sets the _lCurrentPosition from the thumb's location within 
//              the slider bar.
//
// Arguments:   x, y coordinates of thumb (relative to slider bar)
//
// Returns:     S_OK
//
//-------------------------------------------------------------------


HRESULT  
CScrollBar::SyncThumbPosition(long pixels)
{
    HRESULT hr = S_OK;

    long _lOldPosition = _lCurrentPosition;

    _lCurrentPosition   = ((long) (pixels / PixelsPerUnit())) + _lMinPosition;
    _sliderOffset = pixels;

    if(_lOldPosition != _lCurrentPosition)
    {
        CheckResult ( FireEvent( _lOnChangeCookie, NULL, CComBSTR("change")));
        CheckResult ( FireEvent( _lOnScrollCookie, NULL, CComBSTR("scroll")));
    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::SetBlockMoverPositions()
//
// Synopsis:    Sets the position of the page move zone based on slider thumb
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------



HRESULT
CScrollBar::SetBlockMoverPositions()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLStyle> pIncStyle, pDecStyle;

    //
    //  Calculate dimensions of regions around the slider thumb
    //

    long decPosition  = 0L;
    long decLength    = _sliderOffset;

    long incPosition  = ThumbLength() + _sliderOffset;
    long incLength    = TrackLength() - ThumbLength() - _sliderOffset;

    CheckResult( _pBlockInc->get_style(&pIncStyle));
    CheckResult( _pBlockDec->get_style(&pDecStyle));

    if ( _eoOrientation == Horizontal ) 
    {
        CheckResult( pDecStyle->put_pixelLeft(decPosition));
        CheckResult( pDecStyle->put_pixelWidth(decLength));

        CheckResult( pIncStyle->put_pixelLeft(incPosition));
        CheckResult( pIncStyle->put_pixelWidth(incLength));
    }
    else 
    {
        CheckResult( pDecStyle->put_pixelTop(decPosition));
        CheckResult( pDecStyle->put_pixelHeight(decLength));

        CheckResult( pIncStyle->put_pixelTop(incPosition));
        CheckResult( pIncStyle->put_pixelHeight(incLength));
    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::BuildIncrementer()
//
// Synopsis:    Builds the incrementer button
//
// Arguments:   None
//
// Returns:     S_OK if it can be built
//
//-------------------------------------------------------------------



HRESULT
CScrollBar::BuildIncrementer()
{
    HRESULT hr = S_OK;
    CComVariant arrowColor, faceColor, v3dLightColor, highlightColor, shadowColor, darkShadowColor;

    unsigned arrowStyle = (_eoOrientation == Vertical) ? BUTTON_ARROW_DOWN : BUTTON_ARROW_RIGHT;
    
    CheckResult( CUtilityButton::Create(this, _pContainer, &_pIncrementer));    
    
    CheckResult( GetArrowColor(&arrowColor));
    CheckResult( GetFaceColor(&faceColor));
    CheckResult( Get3DLightColor(&v3dLightColor));
    CheckResult( GetHighlightColor(&highlightColor));
    CheckResult( GetShadowColor(&shadowColor));
    CheckResult( GetDarkShadowColor(&darkShadowColor))

    CheckResult( _pIncrementer->SetAbilities( BUTTON_PRESSABLE ));
    CheckResult( _pIncrementer->SetArrowStyle( arrowStyle ));
    CheckResult( _pIncrementer->SetArrowColor( arrowColor ));
    CheckResult( _pIncrementer->SetFaceColor(  faceColor ));
    CheckResult( _pIncrementer->Set3DLightColor( v3dLightColor ));
    CheckResult( _pIncrementer->SetHighlightColor( highlightColor ));
    CheckResult( _pIncrementer->SetShadowColor( shadowColor ));
    CheckResult( _pIncrementer->SetDarkShadowColor( darkShadowColor ));

    CheckResult( _pIncrementer->SetPressedCallback((PFN_PRESSED) IncrementCallback));

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::BuildDecrementer()
//
// Synopsis:    Builds the decrementer button
//
// Arguments:   None
//
// Returns:     S_OK if it can be built
//
//-------------------------------------------------------------------



HRESULT
CScrollBar::BuildDecrementer()
{
    HRESULT hr = S_OK;
    CComVariant arrowColor, faceColor, v3dLightColor, highlightColor, shadowColor, darkShadowColor;

    unsigned arrowStyle = (_eoOrientation == Vertical) ? BUTTON_ARROW_UP : BUTTON_ARROW_LEFT;
    
    CheckResult( CUtilityButton::Create(this, _pContainer, &_pDecrementer));

    CheckResult( GetArrowColor(&arrowColor));
    CheckResult( GetFaceColor(&faceColor));
    CheckResult( Get3DLightColor(&v3dLightColor));
    CheckResult( GetHighlightColor(&highlightColor));
    CheckResult( GetShadowColor(&shadowColor));
    CheckResult( GetDarkShadowColor(&darkShadowColor))

    CheckResult( _pDecrementer->SetAbilities( BUTTON_PRESSABLE ));
    CheckResult( _pDecrementer->SetArrowStyle( arrowStyle ));
    CheckResult( _pDecrementer->SetArrowColor( arrowColor ));
    CheckResult( _pDecrementer->SetFaceColor(  faceColor ));
    CheckResult( _pDecrementer->Set3DLightColor( v3dLightColor ));
    CheckResult( _pDecrementer->SetHighlightColor( highlightColor ));
    CheckResult( _pDecrementer->SetShadowColor( shadowColor ));
    CheckResult( _pDecrementer->SetDarkShadowColor( darkShadowColor ));

    CheckResult( _pDecrementer->SetPressedCallback((PFN_PRESSED) DecrementCallback));

Cleanup:

    return hr;
}



//+------------------------------------------------------------------
//
// Member:      CScrollBar::BuildSliderThumb()
//
// Synopsis:    Builds the slider thumb button
//
// Arguments:   None
//
// Returns:     S_OK if it can be built
//
//-------------------------------------------------------------------



HRESULT
CScrollBar::BuildSliderThumb()
{
    HRESULT hr = S_OK;
    CComVariant faceColor, v3dLightColor, highlightColor, shadowColor, darkShadowColor;

    unsigned freedom = (_eoOrientation == Vertical) ? BUTTON_MOVEABLE_Y : BUTTON_MOVEABLE_X;
    
    CheckResult( CUtilityButton::Create(this, _pSliderBar, &_pSliderThumb));

    CheckResult( GetFaceColor(&faceColor));
    CheckResult( Get3DLightColor(&v3dLightColor));
    CheckResult( GetHighlightColor(&highlightColor));
    CheckResult( GetShadowColor(&shadowColor));
    CheckResult( GetDarkShadowColor(&darkShadowColor))

    CheckResult( _pSliderThumb->SetAbilities( freedom ));

    CheckResult( _pSliderThumb->SetFaceColor(  faceColor ));
    CheckResult( _pSliderThumb->SetFaceColor(  faceColor ));
    CheckResult( _pSliderThumb->Set3DLightColor( v3dLightColor ));
    CheckResult( _pSliderThumb->SetHighlightColor( highlightColor ));
    CheckResult( _pSliderThumb->SetShadowColor( shadowColor ));
    CheckResult( _pSliderThumb->SetDarkShadowColor( darkShadowColor ));

    CheckResult( _pSliderThumb->SetMovedCallback((PFN_MOVED) MouseMoveCallback));

Cleanup:

    return hr;
}



//+------------------------------------------------------------------
//
// Member:      CScrollBar::BuildSliderBar()
//
// Synopsis:    Builds the slider bar which will contain a slider thumb
//
// Arguments:   None
//
// Returns:     S_OK if it can be built
//
//-------------------------------------------------------------------



HRESULT
CScrollBar::BuildSliderBar()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLStyle> pStyle;
    CComBSTR    bstr;

    CheckResult( GetHTMLDocument(_pSite, &pDoc));
    CheckResult( pDoc->createElement(CComBSTR("div"), &_pSliderBar));

    CheckResult( _pSliderBar->get_style(&pStyle));
    CheckResult( pStyle->put_display(CComBSTR("inline")));
    CheckResult( pStyle->put_overflow(CComBSTR("hidden")));
    CheckResult( AppendChild(_pContainer, _pSliderBar));

    _pSinkSlider = new CEventSink(this, _pSliderBar, SCROLL_SLIDER);
    if (!_pSinkSlider)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    bstr = _T("onmousedown");
    CheckResult( AttachEventToSink(_pSliderBar, bstr, _pSinkSlider));

    bstr = _T("onmouseup");
    CheckResult( AttachEventToSink(_pSliderBar, bstr, _pSinkSlider));

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::BuildBlockIncrementer()
//
// Synopsis:    Builds the area of the slider bar that handles page incrementing
//
// Arguments:   None
//
// Returns:     S_OK if it can be built
//
//-------------------------------------------------------------------


HRESULT
CScrollBar::BuildBlockIncrementer()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLStyle> pStyle;
    CComPtr<IHTMLStyle2> pStyle2;

    CComBSTR    bstr;
    CComVariant color;

    CheckResult( GetScrollbarColor(&color));

    CheckResult( GetHTMLDocument(_pSite, &pDoc));
    CheckResult( pDoc->createElement(CComBSTR("div"), &_pBlockInc));

    CheckResult( _pBlockInc->get_style(&pStyle));
    CheckResult( pStyle->put_backgroundColor(color));
    CheckResult( pStyle->put_display(CComBSTR("inline")));
    CheckResult( pStyle->put_pixelTop(0L));
    CheckResult( pStyle->put_pixelLeft(0L));

    CheckResult( pStyle->QueryInterface(IID_IHTMLStyle2, (void **) &pStyle2));
    CheckResult( pStyle2->put_position(CComBSTR("absolute")));

    CheckResult( AppendChild(_pSliderBar, _pBlockInc));


    _pSinkBlockInc = new CEventSink(this, _pBlockInc, SCROLL_PAGEINC);
    if (!_pSinkBlockInc)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    bstr = _T("onmousedown");
    CheckResult( AttachEventToSink(_pBlockInc, bstr, _pSinkBlockInc));

    bstr = _T("onmouseup");
    CheckResult( AttachEventToSink(_pBlockInc, bstr, _pSinkBlockInc));

    bstr = _T("onmouseenter");
    CheckResult( AttachEventToSink(_pBlockInc, bstr, _pSinkBlockInc));

    bstr = _T("onmousemove");
    CheckResult( AttachEventToSink(_pBlockInc, bstr, _pSinkBlockInc));

    bstr = _T("onresize");
    CheckResult( AttachEventToSink(_pBlockInc, bstr, _pSinkBlockInc));


Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::BuildBlockDecrementer()
//
// Synopsis:    Builds the area of the slider bar that handles page decrementing
//
// Arguments:   None
//
// Returns:     S_OK if it can be built
//
//-------------------------------------------------------------------

HRESULT
CScrollBar::BuildBlockDecrementer()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLStyle> pStyle;
    CComPtr<IHTMLStyle2> pStyle2;

    CComBSTR    bstr;
    CComVariant color;

    CheckResult( GetScrollbarColor(&color));

    CheckResult( GetHTMLDocument(_pSite, &pDoc));
    CheckResult( pDoc->createElement(CComBSTR("div"), &_pBlockDec));

    CheckResult( _pBlockDec->get_style(&pStyle));
    CheckResult( pStyle->put_backgroundColor(color));
    CheckResult( pStyle->put_display(CComBSTR("inline")));
    CheckResult( pStyle->put_pixelTop(0L));
    CheckResult( pStyle->put_pixelLeft(0L));

    CheckResult( pStyle->QueryInterface(IID_IHTMLStyle2, (void **) &pStyle2));
    CheckResult( pStyle2->put_position(CComBSTR("absolute")));

    CheckResult( AppendChild(_pSliderBar, _pBlockDec));


    _pSinkBlockDec = new CEventSink(this, _pBlockDec, SCROLL_PAGEDEC);
    if (!_pSinkBlockDec)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    bstr = _T("onmousedown");
    CheckResult( AttachEventToSink(_pBlockDec, bstr, _pSinkBlockDec));

    bstr = _T("onmouseup");
    CheckResult( AttachEventToSink(_pBlockDec, bstr, _pSinkBlockDec));

    bstr = _T("onmouseenter");
    CheckResult( AttachEventToSink(_pBlockDec, bstr, _pSinkBlockDec));

    bstr = _T("onmousemove");
    CheckResult( AttachEventToSink(_pBlockDec, bstr, _pSinkBlockDec));

    bstr = _T("onresize");
    CheckResult( AttachEventToSink(_pBlockDec, bstr, _pSinkBlockDec));


Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::CalcConstituentDimensions()
//
// Synopsis:    Determins the pixel dimensions of all controls that make up the scrollbar
//
// Arguments:   None
//
// Returns:     S_OK if they can be calculated
//
//-------------------------------------------------------------------



HRESULT 
CScrollBar::CalcConstituentDimensions()
{
    HRESULT hr = S_OK;

    long  totalSize;

    if (_eoOrientation == Horizontal) 
    {
        _lLength     = _width;
        _lWidth      = _height;
    }

    else if (_eoOrientation == Vertical) 
    {
        _lLength     = _height;
        _lWidth      = _width;
    }

    else 
    {
        Assert( false ); // can't happen
    }

    totalSize     = NearestLong( (PixelsPerUnit() * (double) _lVisibleUnits)) ;

    _lThumbLength = min( totalSize, TrackLength());
    _lThumbLength = max( SCROLL_MIN_THUMBSIZE, _lThumbLength );

    return hr;
}



//+------------------------------------------------------------------
//
// Member:      CScrollBar::SetConstituentDimensions()
//
// Synopsis:    Sets the dimensions of the controls
//
// Arguments:   None
//
// Returns:     S_OK if they can be set
//
//-------------------------------------------------------------------



HRESULT
CScrollBar::SetConstituentDimensions()
{
    HRESULT hr = S_OK;

    CContextAccess a(_pSliderBar);
    CContextAccess i(_pBlockInc);
    CContextAccess d(_pBlockDec);

    CheckResult( a.Open( CA_STYLE ));
    CheckResult( i.Open( CA_STYLE ));
    CheckResult( d.Open( CA_STYLE ));

    if (_eoOrientation == Horizontal) 
    {

        CheckResult( a.Style()->put_pixelHeight( TotalWidth() ));
        CheckResult( a.Style()->put_pixelWidth( TrackLength() ));

        CheckResult( i.Style()->put_pixelHeight( TotalWidth() ));
        CheckResult( i.Style()->put_pixelWidth( ButtonSize() ));

        CheckResult( d.Style()->put_pixelHeight( TotalWidth() ));
        CheckResult( d.Style()->put_pixelWidth( ButtonSize() ));

        CheckResult( _pIncrementer->SetHeight( TotalWidth() ));
        CheckResult( _pIncrementer->SetWidth(  ButtonSize() ));

        CheckResult( _pDecrementer->SetHeight( TotalWidth() ));
        CheckResult( _pDecrementer->SetWidth(  ButtonSize() ));

        CheckResult( _pSliderThumb->SetHeight( TotalWidth() ));
        CheckResult( _pSliderThumb->SetWidth(  ThumbLength() ));

    }
    else 
    {

        CheckResult( a.Style()->put_pixelHeight( TrackLength() ));
        CheckResult( a.Style()->put_pixelWidth( TotalWidth() ));

        CheckResult( i.Style()->put_pixelHeight( ButtonSize() ));
        CheckResult( i.Style()->put_pixelWidth( TotalWidth() ));

        CheckResult( d.Style()->put_pixelHeight( ButtonSize() ));
        CheckResult( d.Style()->put_pixelWidth( TotalWidth() ));

        CheckResult( _pIncrementer->SetHeight(  ButtonSize() ));
        CheckResult( _pIncrementer->SetWidth(   TotalWidth() ));

        CheckResult( _pDecrementer->SetHeight(  ButtonSize() ));
        CheckResult( _pDecrementer->SetWidth(   TotalWidth() ));

        CheckResult( _pSliderThumb->SetHeight( ThumbLength() ));
        CheckResult( _pSliderThumb->SetWidth(   TotalWidth() ));
    
    }

    CheckResult( SetThumbPosition( _lCurrentPosition ));

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::ReadProperties()
//
// Synopsis:    Reads in property values for later calculations
//
// Arguments:   None
//
// Returns:     S_OK if they can be read
//
//-------------------------------------------------------------------



HRESULT 
CScrollBar::ReadProperties()
{
    HRESULT hr = S_OK;
    BSTR orientation;

    CheckResult( get_min(&_lMinPosition));
    CheckResult( get_max(&_lMaxPosition));
    CheckResult( get_position(&_lCurrentPosition));
    CheckResult( get_unit(&_lUnitIncrement));
    CheckResult( get_block(&_lBlockIncrement));
    CheckResult( get_visibleUnits(&_lVisibleUnits));

    CheckResult( get_orientation(&orientation));

    _eoOrientation = _wcsicmp(orientation, _T("vertical")) == 0 ? Vertical : Horizontal;

Cleanup:

    return hr;
}



//+------------------------------------------------------------------
//
// Member:      CScrollBar::Layout()
//
// Synopsis:    Laysout the scrollbar by calculating dimensions
//
// Arguments:   None
//
// Returns:     S_OK if scrollbar can be layed-out
//
//-------------------------------------------------------------------



HRESULT
CScrollBar::Layout()
{
    HRESULT hr = S_OK;

    CheckResult( CalcConstituentDimensions());
    CheckResult( SetConstituentDimensions());

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
//
// Synopsis:    Scrollbar Property interigators
//
//
//-------------------------------------------------------------------




/////////////////////////////////////////////////////////////////////////////

HRESULT
CScrollBar::get_min(long * pv)
{
    return GetProps()[eMin].Get(pv); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CScrollBar::put_min(long v)
{
    return GetProps()[eMin].Set(v); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CScrollBar::get_max(long * pv)
{
    return GetProps()[eMax].Get(pv); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CScrollBar::put_max(long v)
{
    return GetProps()[eMax].Set(v); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CScrollBar::get_position(long * pv)
{
    return GetProps()[ePosition].Get(pv); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CScrollBar::put_position(long v)
{
    return SetThumbPosition( v ); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CScrollBar::get_unit(long * pv)
{
    return GetProps()[eUnit].Get(pv); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CScrollBar::put_unit(long v)
{
    return GetProps()[eUnit].Set(v); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CScrollBar::get_block(long * pv)
{
    return GetProps()[eBlock].Get(pv); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CScrollBar::put_block(long v)
{
    return GetProps()[eBlock].Set(v); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CScrollBar::get_visibleUnits(long * pv)
{
    return GetProps()[eVisibleUnits].Get(pv); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CScrollBar::put_visibleUnits(long v)
{
    return GetProps()[eVisibleUnits].Set(v); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CScrollBar::get_orientation(BSTR * pv)
{
    return GetProps()[eOrientation].Get(pv); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CScrollBar::put_orientation(BSTR v)
{
    return GetProps()[eOrientation].Set(v); 
}


/////////////////////////////////////////////////////////////////////////////

HRESULT
CScrollBar::GetScrollbarColor(VARIANT * pv)
{
    HRESULT hr = S_OK;
    CVariant color;
    CComVariant defaultColor("scrollbar");

    CContextAccess a(_pSite);

    CheckResult( a.Open(CA_STYLE3));
    CheckResult( a.Style3()->get_scrollbarBaseColor ( &color ));

    if(color.IsEmpty() || ((V_VT(&color) == VT_BSTR) && (V_BSTR(&color) == NULL)) ) 
    {   
        return ::VariantCopy(pv, &defaultColor);
    }
    else 
    {
        return ::VariantCopy(pv, &color);
    }

Cleanup:

    return hr;
}

HRESULT
CScrollBar::GetFaceColor(VARIANT * pv)
{
    HRESULT hr = S_OK;
    CComPtr<IHTMLCurrentStyle> pStyle;
    CComPtr<IHTMLCurrentStyle2> pStyle2;

    CContextAccess a(_pSite);

    CheckResult( a.Open(CA_ELEM2));

    CheckResult( a.Elem2()->get_currentStyle(&pStyle));
    CheckResult( pStyle->QueryInterface( __uuidof(IHTMLCurrentStyle2), (void **) &pStyle2));
    CheckResult( pStyle2->get_scrollbarFaceColor( pv));

Cleanup:

    return hr;
}

HRESULT
CScrollBar::GetArrowColor(VARIANT * pv)
{
    HRESULT hr = S_OK;
    CComPtr<IHTMLCurrentStyle> pStyle;
    CComPtr<IHTMLCurrentStyle2> pStyle2;

    CContextAccess a(_pSite);

    CheckResult( a.Open(CA_ELEM2));

    CheckResult( a.Elem2()->get_currentStyle(&pStyle));
    CheckResult( pStyle->QueryInterface( __uuidof(IHTMLCurrentStyle2), (void **) &pStyle2));
    CheckResult( pStyle2->get_scrollbarArrowColor( pv));

Cleanup:

    return hr;
}

HRESULT
CScrollBar::Get3DLightColor(VARIANT * pv)
{
    HRESULT hr = S_OK;
    CComPtr<IHTMLCurrentStyle> pStyle;
    CComPtr<IHTMLCurrentStyle2> pStyle2;

    CContextAccess a(_pSite);

    CheckResult( a.Open(CA_ELEM2));

    CheckResult( a.Elem2()->get_currentStyle(&pStyle));
    CheckResult( pStyle->QueryInterface( __uuidof(IHTMLCurrentStyle2), (void **) &pStyle2));
    CheckResult( pStyle2->get_scrollbar3dLightColor( pv));

Cleanup:

    return hr;
}

HRESULT
CScrollBar::GetShadowColor(VARIANT * pv)
{
    HRESULT hr = S_OK;
    CComPtr<IHTMLCurrentStyle> pStyle;
    CComPtr<IHTMLCurrentStyle2> pStyle2;

    CContextAccess a(_pSite);

    CheckResult( a.Open(CA_ELEM2));

    CheckResult( a.Elem2()->get_currentStyle(&pStyle));
    CheckResult( pStyle->QueryInterface( __uuidof(IHTMLCurrentStyle2), (void **) &pStyle2));
    CheckResult( pStyle2->get_scrollbarShadowColor( pv));

Cleanup:

    return hr;
}

HRESULT
CScrollBar::GetHighlightColor(VARIANT * pv)
{
    HRESULT hr = S_OK;
    CComPtr<IHTMLCurrentStyle> pStyle;
    CComPtr<IHTMLCurrentStyle2> pStyle2;

    CContextAccess a(_pSite);

    CheckResult( a.Open(CA_ELEM2));

    CheckResult( a.Elem2()->get_currentStyle(&pStyle));
    CheckResult( pStyle->QueryInterface( __uuidof(IHTMLCurrentStyle2), (void **) &pStyle2));
    CheckResult( pStyle2->get_scrollbarHighlightColor( pv));

Cleanup:

    return hr;
}

HRESULT
CScrollBar::GetDarkShadowColor(VARIANT * pv)
{
    HRESULT hr = S_OK;
    CComPtr<IHTMLCurrentStyle> pStyle;
    CComPtr<IHTMLCurrentStyle2> pStyle2;

    CContextAccess a(_pSite);

    CheckResult( a.Open(CA_ELEM2));

    CheckResult( a.Elem2()->get_currentStyle(&pStyle));
    CheckResult( pStyle->QueryInterface( __uuidof(IHTMLCurrentStyle2), (void **) &pStyle2));
    CheckResult( pStyle2->get_scrollbarDarkShadowColor( pv));

Cleanup:

    return hr;
}



HRESULT
CScrollBar::AttachEventToSink(IHTMLDocument3 *pDoc, CComBSTR& bstr, CEventSink* pSink)
{
    HRESULT hr = S_OK;
    VARIANT_BOOL    vSuccess;

    CheckResult( pDoc->attachEvent(bstr, pSink, &vSuccess));

    if (vSuccess != VARIANT_TRUE)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:

    return hr;
}




HRESULT
CScrollBar::AttachEventToSink(IHTMLElement *pElem, CComBSTR& bstr, CEventSink* pSink)
{
    HRESULT hr = S_OK;
    VARIANT_BOOL    vSuccess;
    CComPtr<IHTMLElement2> pElem2;

    CheckResult( pElem->QueryInterface(IID_IHTMLElement2, (void **) &pElem2));
    CheckResult( pElem2->attachEvent(bstr, pSink, &vSuccess));

    if (vSuccess != VARIANT_TRUE)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:

    return hr;
}



//+------------------------------------------------------------------------
//
// CScrollBar::CEventSink
//
// IDispatch Implementation
// The event sink's IDispatch interface is what gets called when events
// are fired.
//
//-------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  Member:     CScrollBar::CEventSink::GetTypeInfoCount
//              CScrollBar::CEventSink::GetTypeInfo
//              CScrollBar::CEventSink::GetIDsOfNames
//
//  Synopsis:   We don't really need a nice IDispatch... this minimalist
//              version does just plenty.
//
//-------------------------------------------------------------------------

STDMETHODIMP
CScrollBar::CEventSink::GetTypeInfoCount(UINT* /*pctinfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CScrollBar::CEventSink::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
                                   /* [in] */ LCID /*lcid*/,
                                   /* [out] */ ITypeInfo** /*ppTInfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CScrollBar::CEventSink::GetIDsOfNames( REFIID          riid,
                                         OLECHAR**       rgszNames,
                                         UINT            cNames,
                                         LCID            lcid,
                                         DISPID*         rgDispId)
{
    return E_NOTIMPL;
}

//+------------------------------------------------------------------------
//
//  Member:     CScrollBar::CEventSink::Invoke
//
//  Synopsis:   This gets called for all events on our object.  (it was
//              registered to do so in Init with attach_event.)  It calls
//              the appropriate parent functions to handle the events.
//
//-------------------------------------------------------------------------
STDMETHODIMP
CScrollBar::CEventSink::Invoke(DISPID dispIdMember,
                                     REFIID, LCID,
                                     WORD wFlags,
                                     DISPPARAMS* pDispParams,
                                     VARIANT* pVarResult,
                                     EXCEPINFO*,
                                     UINT* puArgErr)
{
    HRESULT         hr          = S_OK;
    IHTMLEventObj   *pEventObj  = NULL;
    CComBSTR        bstrOn;
    CComBSTR        bstrEvent;

    Assert(_pParent);

    if (!pDispParams) // || (pDispParams->cArgs < 1))
        goto Cleanup;

    if (pDispParams->cArgs == 0) 
    {
        if (_dwFlags & SCROLL_DELAY_TIMER)
        {
            CheckResult( _pParent->OnDelay() );
        }
        else if (_dwFlags & SCROLL_REPEAT_TIMER)
        {
            CheckResult( _pParent->OnRepeat() );
        }
    }

    else if (pDispParams->rgvarg[0].vt == VT_DISPATCH)
    {
        CEventObjectAccess eoa(pDispParams);
        
        hr = pDispParams->rgvarg[0].pdispVal->QueryInterface(IID_IHTMLEventObj, (void **)&pEventObj);
        if (FAILED(hr))
            goto Cleanup;

        hr = pEventObj->get_type(&bstrEvent);
        if (FAILED(hr))
            goto Cleanup;

        if (_dwFlags & SCROLL_PAGEDEC)
        {
            if (!StrCmpICW(bstrEvent, L"mousedown"))
            {
                CheckResult( _pParent->BlockMoveStartDec(&eoa));
            }
            else if (!StrCmpICW(bstrEvent, L"mouseup"))
            {
                CheckResult( _pParent->BlockMoveEnd(&eoa));
            }
            else if (!StrCmpICW(bstrEvent, L"mousemove"))
            {
                CheckResult( _pParent->BlockMoveSuspend(&eoa, _pElement));
            }
            else if (!StrCmpICW(bstrEvent, L"resize"))
            {
                CheckResult( _pParent->BlockMoveCheck(&eoa));
            }
       }

        else if (_dwFlags & SCROLL_PAGEINC)
        {
            if (!StrCmpICW(bstrEvent, L"mousedown"))
            {
                CheckResult( _pParent->BlockMoveStartInc(&eoa));
            }
            else if (!StrCmpICW(bstrEvent, L"mouseup"))
            {
                CheckResult( _pParent->BlockMoveEnd(&eoa));
            }
            else if (!StrCmpICW(bstrEvent, L"mousemove"))
            {
                CheckResult( _pParent->BlockMoveSuspend(&eoa, _pElement));
            }
             else if (!StrCmpICW(bstrEvent, L"resize"))
            {
                CheckResult( _pParent->BlockMoveCheck(&eoa));
            }
       }

        else if (_dwFlags & SCROLL_SLIDER)
        {
            if (!StrCmpICW(bstrEvent, L"mousedown"))
            {
                CheckResult( _pParent->OnMouseDown(&eoa));
            }
        }
    }

Cleanup:

    ReleaseInterface(pEventObj);

    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CScrollBar::CEventSink
//
//  Synopsis:   This is used to allow communication between the parent class
//              and the event sink class.  The event sink will call the ProcOn*
//              methods on the parent at the appropriate times.
//
//-------------------------------------------------------------------------

CScrollBar::CEventSink::CEventSink(CScrollBar *pParent, IHTMLElement *pElement, DWORD dwFlags)
{
    _pParent  = pParent;
    _pElement = pElement;
    _dwFlags  = dwFlags;
}

// ========================================================================
// CScrollBar::CEventSink
//
// IUnknown Implementation
// Vanilla IUnknown implementation for the event sink.
// ========================================================================

STDMETHODIMP
CScrollBar::CEventSink::QueryInterface(REFIID riid, void ** ppUnk)
{
    void * pUnk = NULL;

    if (riid == IID_IDispatch)
        pUnk = (IDispatch*)this;

    if (riid == IID_IUnknown)
        pUnk = (IUnknown*)this;

    if (pUnk)
    {
        *ppUnk = pUnk;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
CScrollBar::CEventSink::AddRef(void)
{
    return ((IElementBehavior*) _pParent)->AddRef();
}

STDMETHODIMP_(ULONG)
CScrollBar::CEventSink::Release(void)
{
    return ((IElementBehavior*) _pParent)->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by iextag.rc
//
#define IDI_HOMEPAGE                    206

#define IDS_PROJNAME                    100
#define IDR_PEERFACTORY                 101
#define IDR_CLIENTCAPS                  102
#define IDR_CPERSISTUSERDATA            103
#define IDR_HOMEPAGE                    104
#define IDS_SETHOMEPAGE_TITLE           105
#define IDS_SETHOMEPAGE_MSG             106
#define IDR_CPERSISTSNAPSHOT            107
#define IDR_CPERSISTFAVORITE            108
#define IDR_CPERSISTHISTORY             109
#define IDR_DOWNLOADBEHAVIOR            110
#define IDR_WFOLDERS                    112
#define IDR_ANCHORCLICK                 113
#define IDS_WEBFOLDER_FIND              114
#define IDS_ERRORINTERNAL               115
#define IDS_ERRORINTTITLE               116
#define IDS_ERRORBADURL                 117
#define IDS_ERRORBADURLTITLE            118
#define IDS_ERRORNOURL                  119
#define IDS_ERRORNOURLTITLE             120
#define IDS_ERRORBADSERVER              121
#define IDS_ERRORBADSERVERTITLE         122
#define IDS_ERROROUTOFMEMORY            123
#define IDS_ERROROUTOFMEMORYTITLE       124
#define IDS_ERRORTIMEOUT                125
#define IDS_ERRORTIMEOUTTITLE           126
#define IDS_ERRORURLTOOLONG             127
#define IDS_ERRORURLTOOLONGTITLE        128
#define IDS_ERROROFFLINE                129
#define IDS_ERROROFFLINETITLE           130
#define IDR_HTMLAREA                    131
#define IDR_LAYOUTRECT                  132
#define IDR_COMBOBOX                    135
#define IDR_CHECKBOX                    136
#define IDR_RADIO                       137
#define IDR_SELECT                      138
#define IDR_SELITEM                     139
#define IDR_TEMPLATEPRINTER             140
#define IDR_SCROLLBAR                   141
#define IDR_SPINBUTTON                  142
#define IDR_SLIDERBAR                   143
#define IDR_UTILITYBUTTON               144
#define IDR_HEADERFOOTER                145
#define IDR_DEVICERECT                  146

#define IDC_WEBFOLDER_PROGRESS          201
#define IDD_WEBFOLDER_SEARCH            202
#define IDC_WEBFOLDER_ANIMATE           202
#define IDC_WEBFOLDER_MESSAGE           203
#define IDA_ISEARCH                     204

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        204
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         205
#define _APS_NEXT_SYMED_VALUE           102

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\selitem.cxx ===
//+------------------------------------------------------------------
//
// Microsoft IEPEERS
// Copyright (C) Microsoft Corporation, 1999.
//
// File:        iextags\selitem.cxx
//
// Contents:    The OPTION element.
//
// Classes:     CIEOptionElement
//
// Interfaces:  IHTMLOptionElement2
//              IPrivateOption
//
//-------------------------------------------------------------------

#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "iextag.h"

#include "utils.hxx"

#ifndef __X_SELECT_HXX_
#define __X_SELECT_HXX_
#include "select.hxx"
#endif

#ifndef __X_SELITEM_HXX_
#define __X_SELITEM_HXX_
#include "selitem.hxx"
#endif



const CBaseCtl::PROPDESC CIEOptionElement::s_propdesc[] = 
{
    {_T("value"), VT_BSTR, NULL, _T("")},
    {_T("selected"), VT_I4, -1},
    {_T("defaultSelected"), VT_BOOL, NULL, NULL, VARIANT_FALSE},
    {_T("index"), VT_I4, -1},
    NULL
};

enum
{
    eValue          = 0,
    eSelected       = 1,
    eDefSelected    = 2,
    eIndex          = 3,
};


/////////////////////////////////////////////////////////////////////////////
//
// CIEOptionElement
//
/////////////////////////////////////////////////////////////////////////////


//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::CIEOptionElement()
//
// Synopsis:    Initializes member variables.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
CIEOptionElement::CIEOptionElement()
{
    _fSelectOnMouseDown = TRUE;
    _fFirstSize = TRUE;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::SetupDefaultStyle()
//
// Synopsis:    Sets the default style for OPTION elements, which can
//              be overridden through CSS.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::SetupDefaultStyle()
{
    HRESULT         hr;
#ifndef OPTION_GETSIZE
    CComBSTR        bstr;
#endif
    CComBSTR        bstrNoWrap(_T("nowrap"));
    CComBSTR        bstr100(_T("100%"));
    CComBSTR        bstrBlock(_T("block"));
    CVariant        var;
    CContextAccess  a(_pSite);

    hr = a.Open(CA_DEFSTYLE);
    if (FAILED(hr))
        goto Cleanup;

    // Setup the padding
    V_VT(&var) = VT_I4;
    V_I4(&var) = 2;
    hr = a.DefStyle()->put_paddingLeft(var);
    if (FAILED(hr))
        goto Cleanup;

#ifndef OPTION_GETSIZE
    // Setup overflow
    bstr = _T("hidden");
    hr = a.DefStyle()->put_overflow(bstr);
    if (FAILED(hr))
        goto Cleanup;
#endif

#ifdef OPTION_GETSIZE
    // Setup the whitespace
    hr = a.DefStyle()->put_whiteSpace(bstrNoWrap);
    if (FAILED(hr))
        goto Cleanup;

/*    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstr100;    
    hr = a.DefStyle()->put_width(var);
    if (FAILED(hr))
        goto Cleanup;
*/
    hr = a.DefStyle()->put_display(bstrBlock);
    if (FAILED(hr))
        goto Cleanup;
#endif

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::GetSelect()
//
// Synopsis:    Sets *ppSelect to the parent element, which should
//              be the SELECT element for this OPTION.
//
// Arguments:   IHTMLSelectElement3 **ppSelect 
//                - Receives a pointer to the SELECT which must be
//                  released by the caller.
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::GetSelect(IHTMLSelectElement3 **ppSelect)
{
    HRESULT         hr;
    IHTMLElement    *pParent = NULL;

    Assert(ppSelect);

    hr = GetParent(&pParent);
    if (FAILED(hr))
        goto Cleanup;

    hr = pParent->QueryInterface(IID_IHTMLSelectElement3, (void**)ppSelect);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pParent);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::GetSelect()
//
// Synopsis:    Sets *ppSelect to the parent element, which should
//              be the SELECT element for this OPTION.
//
// Arguments:   IPrivateSelect **ppSelect 
//                - Receives a pointer to the SELECT which must be
//                  released by the caller.
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::GetSelect(IPrivateSelect **ppSelect)
{
    HRESULT         hr;
    IHTMLElement    *pParent = NULL;

    Assert(ppSelect);

    hr = GetParent(&pParent);
    if (FAILED(hr))
        goto Cleanup;

    hr = pParent->QueryInterface(IID_IPrivateSelect, (void**)ppSelect);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pParent);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::GetParent()
//
// Synopsis:    Sets *ppParent to the parent element.
//
// Arguments:   IHTMLElement **ppParent 
//                - Receives a pointer to the parent which must be
//                  released by the caller.
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::GetParent(IHTMLElement **ppParent)
{
    HRESULT         hr;
    CContextAccess  a(_pSite);

    Assert(ppParent);

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_offsetParent(ppParent);
    if (FAILED(hr))
        goto Cleanup;

    if (!*ppParent)
    {
        // If we didn't get a parent element,
        // then this function has failed.
        hr = E_FAIL;
    }

Cleanup:
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
//
// IHTMLOptionElement
//
/////////////////////////////////////////////////////////////////////////////


//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::put_value()
//
// Synopsis:    Sets the value property/attribute.
//
// Arguments:   BSTR v - The new value property/attribute
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::put_value(BSTR v)
{
    return GetProps()[eValue].Set(v);
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::get_value()
//
// Synopsis:    Retrieves the value property/attribute.
//
// Arguments:   BSTR *p - Receives the value property/attribute
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::get_value(BSTR *p)
{
    HRESULT         hr;
    CComBSTR        bstr;
    CContextAccess  a(_pSite);

    hr = GetProps()[eValue].Get(&bstr);
    if (FAILED(hr))
        goto Cleanup;

    if (bstr.Length() == 0)
    {
        hr = a.Open(CA_ELEM);
        if (FAILED(hr))
            goto Cleanup;

        hr = a.Elem()->get_innerText(&bstr);
        if (FAILED(hr))
            goto Cleanup;
    }

    *p = bstr;

Cleanup:
    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::put_index()
//
// Synopsis:    Sets the index property.
//              NOTE: Currently not implemented.
//                    This is silently ignored.
//
// Arguments:   long lIndex - The new index property
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::put_index(long lIndex)
{
    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::get_index()
//
// Synopsis:    Retrieves the index property.
//
// Arguments:   long *plIndex - Receives the index property
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::get_index(long *plIndex)
{
    return GetIndex(plIndex);
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::put_selected()
//
// Synopsis:    Sets the selected property.
//
// Arguments:   VARIANT_BOOL bSelected - The new selected property
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::put_selected(VARIANT_BOOL bSelected)
{
    HRESULT         hr;
    long            lIndex;
    VARIANT_BOOL    bPrev;
    IPrivateSelect  *pSelect    = NULL;

    hr = get_selected(&bPrev);
    if (FAILED(hr))
        goto Cleanup;

    if (bPrev == bSelected)
    {
        // No need to do anything
        goto Cleanup;
    }

    hr = get_index(&lIndex);
    if (FAILED(hr))
        goto Cleanup;

    hr = GetSelect(&pSelect);
    if (FAILED(hr))
        goto Cleanup;

    // This will take care of making the option look selected
    hr = pSelect->OnOptionSelected(bSelected, lIndex, SELECT_FIREEVENT);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pSelect);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::get_selected()
//
// Synopsis:    Retrieves the selected property.
//
// Arguments:   VARIANT_BOOL *pbSelected - Receives the selected property
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::get_selected(VARIANT_BOOL * pbSelected)
{
    return GetSelected(pbSelected);
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::put_defaultSelected()
//
// Synopsis:    Sets the defaultSelected property.
//
// Arguments:   VARIANT_BOOL *p - The new defaultSelected property
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::put_defaultSelected(VARIANT_BOOL v)
{
    return GetProps()[eDefSelected].Set(v);
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::get_defaultSelected()
//
// Synopsis:    Retrieves the defaultSelected property.
//
// Arguments:   VARIANT_BOOL *p - Receives the defaultSelected property
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::get_defaultSelected(VARIANT_BOOL *p)
{
    return GetProps()[eDefSelected].Get(p);
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::put_text()
//
// Synopsis:    Sets the text of the option.
//
// Arguments:   BSTR pbstrText - The new text
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::put_text(BSTR bstrText)
{
    HRESULT         hr;
    CContextAccess  a(_pSite);

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->put_innerText(bstrText);
    if (FAILED(hr))
        goto Cleanup;
    
Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::get_text()
//
// Synopsis:    Retrieves the text of the option.
//
// Arguments:   BSTR *pbstrText - Receives the value
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::get_text(BSTR *pbstrText)
{
    HRESULT         hr;
    CContextAccess  a(_pSite);

    Assert(pbstrText);

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_innerText(pbstrText);
    if (FAILED(hr))
        goto Cleanup;
    
Cleanup:
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
//
// CBaseCtl overrides
//
/////////////////////////////////////////////////////////////////////////////


//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::Init()
//
// Synopsis:    Attaches events sets the default style.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::Init()
{
    HRESULT                     hr;
    CComBSTR                    bstr;
    CContextAccess              a(_pSite);

#ifdef OPTION_GETSIZE
    hr = a.Open(CA_SITEOM | CA_STYLE);
#else
    hr = a.Open(CA_SITEOM);
#endif
    if (FAILED(hr))
        goto Cleanup;

    hr = a.SiteOM()->RegisterName(_T("option"));
    if (FAILED(hr))
        goto Cleanup;

    hr = AttachEvent(EVENT_ONMOUSEOVER, &a);
    if (FAILED(hr))
        goto Cleanup;
    hr = AttachEvent(EVENT_ONMOUSEDOWN, &a);
    if (FAILED(hr))
        goto Cleanup;
    hr = AttachEvent(EVENT_ONMOUSEUP, &a);
    if (FAILED(hr))
        goto Cleanup;
    hr = AttachEvent(EVENT_ONSELECTSTART, &a);
    if (FAILED(hr))
        goto Cleanup;
    hr = AttachEvent(EVENT_ONPROPERTYCHANGE, &a);
    if (FAILED(hr))
        goto Cleanup;

    bstr = _T("onselectstart");
    hr = RegisterEvent(a.SiteOM(), bstr, &_lOnSelectStartCookie);
    if (FAILED(hr))
        goto Cleanup;

#ifdef OPTION_GETSIZE
    // Force a layout
    hr = a.Style()->put_display(_T("inline-block"));
    if (FAILED(hr))
        goto Cleanup;
#endif

    hr = SetupDefaultStyle();
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::OnContentReady()
//
// Synopsis:    Setup the default selection status.
//
// Arguments:   IHTMLEventObj *pEvent - Event object with status info
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::OnContentReady()
{
    HRESULT         hr;
    VARIANT_BOOL    bSelected;
    VARIANT_BOOL    bDefSelected;

    hr = get_selected(&bSelected);
    if (FAILED(hr))
        goto Cleanup;

    hr = get_defaultSelected(&bDefSelected);
    if (FAILED(hr))
        goto Cleanup;

    if (bSelected || bDefSelected)
    {
        _fInitSel = TRUE;
        hr = SetSelected(VARIANT_TRUE);
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::OnMouseOver()
//
// Synopsis:    If the option is setup to highlight, then highlight
//              the element.
//
// Arguments:   IHTMLEventObj *pEvent - Event object with status info
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::OnMouseOver(CEventObjectAccess *pEvent)
{
    HRESULT            hr          = S_OK;
    IPrivateSelect     *pSelect    = NULL;
    long               lIndex;

    if (_fHighlightOnMouseOver)
    {
        hr = get_index(&lIndex);
        if (FAILED(hr))
            goto Cleanup;

        hr = GetSelect(&pSelect);
        if (FAILED(hr))
            goto Cleanup;

        hr = pSelect->OnOptionHighlighted(lIndex);
        if (FAILED(hr))
            goto Cleanup;

        hr = pSelect->OnOptionFocus(lIndex);
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pSelect);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::OnMouseDown()
//
// Synopsis:    Selects this option if this option is set to select
//              on mouse down events.
//
// Arguments:   IHTMLEventObj *pEvent - Event object with status info
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::OnMouseDown(CEventObjectAccess *pEvent)
{
    if (_fSelectOnMouseDown)
    {
        return OptionClicked(pEvent);
    }

    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::OnMouseUp()
//
// Synopsis:    Select this element if this element is set to select
//              on mouse up events.
//
// Arguments:   IHTMLEventObj *pEvent - Event object with status info
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::OnMouseUp(CEventObjectAccess *pEvent)
{
    if (!_fSelectOnMouseDown)
    {
        return OptionClicked(pEvent, SELECT_FIREEVENT);
    }

    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::OptionClicked()
//
// Synopsis:    Handles the event if the option is clicked
//
// Arguments:   IHTMLEventObj *pEvent - Event object with status info
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::OptionClicked(CEventObjectAccess *pEvent, DWORD dwFlags /* = 0 */)
{
    HRESULT         hr;
    IPrivateSelect  *pSelect    = NULL;
    long            lIndex;
    long            lKeyboardStatus = NULL;
    long            lMouseButtons = NULL;
    VARIANT_BOOL    bDisabled;

    hr = GetSelect(&pSelect);
    if (FAILED(hr))
        goto Cleanup;

    hr = pSelect->GetDisabled(&bDisabled);
    if (FAILED(hr) || bDisabled)
        goto Cleanup;

    hr = pEvent->GetMouseButtons(&lMouseButtons);
    if (FAILED(hr))
        goto Cleanup;

    // Check if the button that went down is the left mouse button
    if (lMouseButtons & EVENT_LEFTBUTTON)
    {
        hr = pEvent->GetKeyboardStatus(&lKeyboardStatus);
        if (FAILED(hr))
            goto Cleanup;

        // Setup the key status
        dwFlags |= (lKeyboardStatus & EVENT_ALTKEY) ? SELECT_ALT : 0;
        dwFlags |= (lKeyboardStatus & EVENT_SHIFTKEY) ? SELECT_SHIFT : 0;
        dwFlags |= (lKeyboardStatus & EVENT_CTRLKEY) ? SELECT_CTRL : 0;

        hr = get_index(&lIndex);
        if (FAILED(hr))
            goto Cleanup;

        hr = pSelect->OnOptionClicked(lIndex, dwFlags);
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pSelect);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::RenderChanges()
//
// Synopsis:    When the select has a viewlink, we do not want to render
//              changes in the option since it's hidden.
//
// Arguments:   BOOL *pbRender - Returns whether we want to render
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::RenderChanges(BOOL *pbRender)
{
    HRESULT         hr;
    DWORD           dwFlavor;
    IPrivateSelect  *pSelect    = NULL;

    Assert(pbRender);

    hr = GetSelect(&pSelect);
    if (FAILED(hr))
        goto Cleanup;

    pSelect->GetFlavor(&dwFlavor);
    if (FAILED(hr))
        goto Cleanup;

    *pbRender = SELECT_ISLISTBOX(dwFlavor);

Cleanup:
    ReleaseInterface(pSelect);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::OnPropertyChange()
//
// Synopsis:    Allows a recalc of the option's width
//
// Arguments:   CEventObjectAccess *pEvent - Event info
//              BSTR bstr
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::OnPropertyChange(CEventObjectAccess *pEvent, BSTR bstr)
{
    _fResize = TRUE;
    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::OnSelectStart()
//
// Synopsis:    Cancels the selection event so that users cannot
//              drag and select text in the option. SELECT will
//              handle mouse drags as selecting OPTION elements.
//
// Arguments:   IHTMLEventObj *pEvent - Event object with status info
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::OnSelectStart(CEventObjectAccess *pEvent)
{
    return CancelEvent(pEvent);
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::CancelEvent()
//
// Synopsis:    Cancels the event.
//
// Arguments:   IHTMLEventObj *pEvent - Event object with status info
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::CancelEvent(CEventObjectAccess *pEvent)
{
    HRESULT     hr;
    CVariant    var;

    // Cancel the event by returning FALSE
    V_VT(&var) = VT_BOOL;
    V_BOOL(&var) = VARIANT_FALSE;
    hr = pEvent->EventObj()->put_returnValue(var);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
//
// IPrivateOption overrides
//
/////////////////////////////////////////////////////////////////////////////


//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::SetSelected()
//
// Synopsis:    Sets the current selected status to bOn.
//
// Arguments:   VARIANT_BOOL bOn - The new selected status
//              BOOL *pbChanged  - Returns if the selection status changed
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIEOptionElement::SetSelected(VARIANT_BOOL bOn)
{
    HRESULT         hr;
    long            lSel = bOn ? 0 : -1;

    hr = GetProps()[eSelected].Set(lSel);
    if (FAILED(hr))
        goto Cleanup;

    hr = SetHighlight(bOn);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::GetSelected()
//
// Synopsis:    Sets *pbOn to the current selected status.
//
// Arguments:   VARIANT_BOOL *pbOn - Receives the selected status
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIEOptionElement::GetSelected(VARIANT_BOOL *pbOn)
{
    HRESULT hr;
    long    lSel;

    hr = GetProps()[eSelected].Get(&lSel);
    if (FAILED(hr))
        goto Cleanup;

    *pbOn = (lSel == -1) ? VARIANT_FALSE : VARIANT_TRUE;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::SetHighlight()
//
// Synopsis:    Sets the current highlight status to bOn.
//
// Arguments:   VARIANT_BOOL bOn - The new highlight status
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIEOptionElement::SetHighlight(VARIANT_BOOL bOn)
{
    HRESULT         hr;
    BOOL            bRender;
    CComBSTR        bstrBkCol;
    CComBSTR        bstrCol;
    CVariant        var;
    CContextAccess  a(_pSite);

    _fPrevHighlight = _fHighlight;

    if ((_fHighlight ? VARIANT_TRUE : VARIANT_FALSE) == bOn)
    {
        hr = S_OK;
        goto Cleanup;
    }

    _fHighlight = bOn;

    hr = RenderChanges(&bRender);
    if (FAILED(hr) || !bRender)     // If failed or no need to render, stop
        goto Cleanup;

    hr = a.Open(CA_DEFSTYLE);
    if (FAILED(hr))
        goto Cleanup;

    // Setup Colors
    if (_fHighlight)
    {
        bstrBkCol = _T("highlight");
        bstrCol = _T("highlighttext");
    }
    else
    {
        bstrBkCol = _T("");
        bstrCol = _T("");
    }

    // Setup background
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = (BSTR)bstrBkCol;
    hr = a.DefStyle()->put_backgroundColor(var);
    if (FAILED(hr))
        goto Cleanup;

    // Setup foreground color
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = (BSTR)bstrCol;
    hr = a.DefStyle()->put_color(var);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::GetHighlight()
//
// Synopsis:    Sets *pbOn to the current highlight status.
//
// Arguments:   VARIANT_BOOL *pbOn - Receives the highlight status
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIEOptionElement::GetHighlight(VARIANT_BOOL *pbOn)
{
    Assert(pbOn);

    *pbOn = _fHighlight ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::SetIndex()
//
// Synopsis:    Sets the index property. (For initialization)
//
// Arguments:   long lIndex - The new index
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIEOptionElement::SetIndex(long lIndex)
{
    return GetProps()[eIndex].Set(lIndex);
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::GetIndex()
//
// Synopsis:    Gets the index property.
//
// Arguments:   long *plIndex - The index
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIEOptionElement::GetIndex(long *plIndex)
{
    return GetProps()[eIndex].Get(plIndex);
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::Reset()
//
// Synopsis:    Sets the selection status back to the initial status.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIEOptionElement::Reset()
{
    return SetHighlight(_fInitSel ? VARIANT_TRUE : VARIANT_FALSE);
}

#ifndef OPTION_GETSIZE
//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::SetFinalDefaultStyles()
//
// Synopsis:    After setting dimensions, sets some final styles.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIEOptionElement::SetFinalDefaultStyles()
{
    HRESULT         hr = S_OK;
    CComBSTR        bstrWidth(_T("100%"));
    CComBSTR        bstrNoWrap(_T("nowrap"));
    CVariant        var;
    CContextAccess  a(_pSite);

    hr = a.Open(CA_DEFSTYLE | CA_STYLE);
    if (FAILED(hr))
        goto Cleanup;

    // Force the width to 100%
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstrWidth;
    hr = a.Style()->put_width(var);
    if (FAILED(hr))
        goto Cleanup;

    // Turn on nowrap
    hr = a.DefStyle()->put_whiteSpace(bstrNoWrap);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::SetFinalHeight()
//
// Synopsis:    Sets the final height of the option.
//
// Arguments:   long lHeight    The new height
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIEOptionElement::SetFinalHeight(long lHeight)
{
    HRESULT         hr = S_OK;
    CVariant        var;
    CContextAccess  a(_pSite);

    hr = a.Open(CA_STYLE);
    if (FAILED(hr))
        goto Cleanup;

    // Force the height
    V_VT(&var) = VT_I4;
    V_I4(&var) = lHeight;
    hr = a.Style()->put_height(var);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}
#endif

#ifdef OPTION_GETSIZE

/////////////////////////////////////////////////////////////////////////////
//
// IElementBehaviorLayout overrides
//
/////////////////////////////////////////////////////////////////////////////


//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::GetLayoutInfo()
//
// Synopsis:    Returns the type of layout we want.
//
// Arguments:   LONG *plLayoutInfo - Returns the layout info
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::GetLayoutInfo(LONG *plLayoutInfo)
{
    Assert(plLayoutInfo);

    *plLayoutInfo = BEHAVIORLAYOUTINFO_MODIFYNATURAL;

    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::GetSize()
//
// Synopsis:    Returns the size we want.
//
// Arguments:   LONG  dwFlags         - Request type
//              SIZE  sizeContent     - Content size
//              POINT *pptTranslate   - Translation point
//              POINT *pptTopLeft     - Top left point
//              SIZE  *psizeProposed  - Returns our proposed size
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::GetSize(LONG dwFlags, 
                          SIZE sizeContent, 
                          POINT * pptTranslate, 
                          POINT * pptTopLeft, 
                          SIZE  * psizeProposed)
{
    HRESULT         hr;
    IPrivateSelect  *pSelect = NULL;

    hr = GetSelect(&pSelect);
    if (FAILED(hr))
        goto Cleanup;

    hr = pSelect->OnOptionSized(&sizeContent, _fFirstSize, _fResize);
    if (FAILED(hr))
        goto Cleanup;

    *psizeProposed = sizeContent;
    _fFirstSize = FALSE;
    _fResize = FALSE;

Cleanup:
    ReleaseInterface(pSelect);
    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\select.cxx ===
//+------------------------------------------------------------------
//
// Microsoft IEPEERS
// Copyright (C) Microsoft Corporation, 1999.
//
// File:        iextags\select.cxx
//
// Contents:    The SELECT control.
//
// Classes:     CIESelectElement
//
// Interfaces:  IHTMLSelectElement3
//              IPrivateSelect
//
//-------------------------------------------------------------------

#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef __X_IEXTAG_HXX_
#define __X_IEXTAG_HXX_
#include "iextag.h"
#endif

#ifndef __X_UTILS_HXX_
#define __X_UTILS_HXX_
#include "utils.hxx"
#endif

#ifndef __X_SELECT_HXX_
#define __X_SELECT_HXX_
#include "select.hxx"
#endif

#ifndef __X_SELITEM_HXX_
#define __X_SELITEM_HXX_
#include "selitem.hxx"
#endif


// TODO: This is a magic number right now, should be based on font
#define SELECT_OPTIONWIDTH  4
#define SELECT_OPTIONHEIGHT 16
#define SELECT_MAXOPTIONS   12

#define SELECT_SCROLLWAIT   250
#define SELECT_TIMERVLWAIT  10

const CBaseCtl::PROPDESC CIESelectElement::s_propdesc[] = 
{
    {_T("size"), VT_I4, -1},
    {_T("selectedIndex"), VT_I4, -1},
    {_T("multiple"), VT_I4, -1},
    {_T("name"), VT_BSTR, NULL, NULL},
    {_T("length"), VT_I4, 0},
    {_T("type"), VT_BSTR, NULL, NULL},
    NULL
};

enum
{
    eSize               = 0,
    eSelectedIndex      = 1,
    eMultiple           = 2,
    eName               = 3,
    eLength             = 4,
    eType               = 5,
};


/////////////////////////////////////////////////////////////////////////////
//
// CIESelectElement
//
/////////////////////////////////////////////////////////////////////////////


BOOL                CIESelectElement::_bSavedCtrl       = FALSE;
UINT_PTR            CIESelectElement::_iTimerID         = 0;
CIESelectElement    *CIESelectElement::_pTimerSelect    = NULL;
POINT               CIESelectElement::_ptSavedPoint;
#ifdef SELECT_TIMERVL
UINT_PTR            CIESelectElement::_iTimerVL         = 0;
LONG                CIESelectElement::_lTimerVLRef      = 0;
CRITICAL_SECTION    CIESelectElement::_lockTimerVL;
CIESelectElement::SELECT_TIMERVL_LINKELEM  *CIESelectElement::_queueTimerVL = NULL;
#endif

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::CIESelectElement()
//
// Synopsis:    Initializes member variables.
//
// Arguments:   None
//
// Returns:     None.
//
//-------------------------------------------------------------------
CIESelectElement::CIESelectElement()
{
    _lShiftAnchor = -1;
    _lTopChanged = -1;
    _lBottomChanged = -1;
    _pDispDocLink = NULL ;

#ifdef SELECT_GETSIZE
    _fLayoutDirty = TRUE;
#endif
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::~CIESelectElement()
//
// Synopsis:    Releases the event sink.
//
// Arguments:   None
//
// Returns:     None.
//
//-------------------------------------------------------------------
CIESelectElement::~CIESelectElement()
{
    if (_pSinkPopup)
    {
        delete _pSinkPopup;
    }
    if (_pSinkVL)
    {
        delete _pSinkVL;
    }
    if (_pSinkButton)
    {
        delete _pSinkButton;
    }
}


/////////////////////////////////////////////////////////////////////////////
//
// IElementBehavior overrides
//
/////////////////////////////////////////////////////////////////////////////


//+------------------------------------------------------------------
//
// Member:      CIESelectElement::Detach()
//
// Synopsis:    Releases interfaces.
//
// Arguments:   None
//
// Returns:     S_OK
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::Detach()
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    bOpen;
    
    ClearInterface(&_pDispDocLink);
    ClearInterface(&_pLastSelected);
    ClearInterface(&_pLastHighlight);
    ClearInterface(&_pSelectInPopup);
    ClearInterface(&_pElemDisplay);
    ClearInterface(&_pStyleButton);

    if (_pPopup && !SELECT_ISINPOPUP(_fFlavor))
    {
        hr = _pPopup->get_isOpen(&bOpen);
        if (FAILED(hr))
            goto Cleanup;

        if (bOpen)
        {
            hr = HidePopup();
            if (FAILED(hr))
                goto Cleanup;
         }

        ClearInterface(&_pPopup);
    }

Cleanup:
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
//
// IElementBehaviorSubmit overrides and helpers
//
/////////////////////////////////////////////////////////////////////////////


//+------------------------------------------------------------------
//
// Member:      CIESelectElement::Reset()
//
// Synopsis:    Resets the selection status to the original status.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::Reset()
{
    HRESULT                 hr;
    long                    cItems;
    long                    iItem;
    IHTMLElementCollection  *pItems         = NULL;
    IDispatch               *pItem          = NULL;
    IPrivateOption          *pOption        = NULL;
    CVariant                var, var2;
    VARIANT_BOOL            bOn;
    long                    lLastSelected   = -1;
    CContextAccess          a(_pSite);
    

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Get the children and length
    //
    hr = a.Elem()->get_children((IDispatch**)&pItems);
    if (FAILED(hr))
        goto Cleanup;

    hr = pItems->get_length(&cItems);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Go through all of the children and
    // run a reset on them.
    //
    V_VT(&var) = VT_I4;
    for (iItem = 0; iItem < cItems; iItem++)
    {
        V_I4(&var) = iItem;
        hr = pItems->item(var, var2, &pItem);
        if (FAILED(hr))
            goto Cleanup;

        hr = pItem->QueryInterface(IID_IPrivateOption, (void**)&pOption);
        if (FAILED(hr))
        {
            ClearInterface(&pItem);
            continue;
        }

        // Reset the option's selection status
        hr = pOption->Reset();
        if (FAILED(hr))
            goto Cleanup;

        hr = pOption->GetHighlight(&bOn);
        if (FAILED(hr))
            goto Cleanup;

        if (bOn)
        {
            lLastSelected = iItem;
            ClearInterface(&_pLastHighlight);
            _pLastHighlight = pOption;
            _pLastHighlight->AddRef();
        }

        ClearInterface(&pOption);
        ClearInterface(&pItem);
    }

    if (lLastSelected == -1)
    {
        lLastSelected = 0;
    }

    if (SELECT_ISDROPBOX(_fFlavor) && (cItems > 0))
    {
        hr = GetIndex(lLastSelected, &pOption);
        if (FAILED(hr))
            goto Cleanup;

        if (pOption)
        {
            DropDownSelect(pOption);
        }
    }

    hr = CommitSelection(NULL);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pOption);
    ReleaseInterface(pItem);
    ReleaseInterface(pItems);

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetSubmitInfo()
//
// Synopsis:    Sends the information for a forms submission.
//
// Arguments:   IHTMLSubmitData *pSubmitData - submit interface
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::GetSubmitInfo(IHTMLSubmitData *pSubmitData)
{
    HRESULT             hr;
    CComBSTR            bstrName;
    CContextAccess      a(_pSite);

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    // Get this control's name
    hr = get_name(&bstrName);
    if (FAILED(hr))
        goto Cleanup;

    if ((bstrName == NULL) || (bstrName[0] == 0))
    {
        //
        // If the control does not have a name,
        // then the operation failed.
        //
        hr = S_FALSE;
        goto Cleanup;
    }

    //
    // Append the submit info
    //
    if (SELECT_ISMULTIPLE(_fFlavor))
    {
        hr = GetMultipleSubmitInfo(pSubmitData, bstrName);
        if (FAILED(hr))
            goto Cleanup;
    }
    else
    {
        hr = GetSingleSubmitInfo(pSubmitData, bstrName);
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetSingleSubmitInfo()
//
// Synopsis:    Sends the information for a forms submission when
//              the select is a single select.
//
// Arguments:   IHTMLSubmitData *pSubmitData - submit interface
//              CComBSTR *pbstrName  - the name of the select
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::GetSingleSubmitInfo(IHTMLSubmitData *pSubmitData, CComBSTR bstrName)
{
    HRESULT             hr;
    long                lIndex;
    CComBSTR            bstrVal;
    IHTMLOptionElement2 *pOption = NULL;

    hr = get_selectedIndex(&lIndex);
    if (FAILED(hr))
        goto Cleanup;

    if (lIndex < 0)
    {
        // There is no selection, so stop
        goto Cleanup;
    }

    hr = GetIndex(lIndex, &pOption);
    if (FAILED(hr) || !pOption)
    {
        // If the option does not exist,
        // ignore the error and stop
        hr = S_OK;
        goto Cleanup;
    }

    // Get the value to submit
    hr = pOption->get_value(&bstrVal);
    if (FAILED(hr))
        goto Cleanup;

    // Append the data
    hr = pSubmitData->appendNameValuePair(bstrName, bstrVal);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pOption);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetMultipleSubmitInfo()
//
// Synopsis:    Sends the information for a forms submission when
//              the select is a multiple select.
//
// Arguments:   IHTMLSubmitData *pSubmitData - submit interface
//              CComBSTR *pbstrName  - the name of the select
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::GetMultipleSubmitInfo(IHTMLSubmitData *pSubmitData, CComBSTR bstrName)
{
    HRESULT                 hr;
    long                    cItems;
    long                    iItem;
    VARIANT_BOOL            bSelected;
    CComBSTR                bstrVal;
    CVariant                var, var2;
    BOOL                    bNeedSeparator  = FALSE;
    IHTMLElementCollection  *pItems         = NULL;
    IDispatch               *pItem          = NULL;
    IHTMLOptionElement2     *pOption        = NULL;
    CContextAccess          a(_pSite);

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_children((IDispatch**)&pItems);
    if (FAILED(hr))
        goto Cleanup;

    hr = pItems->get_length(&cItems);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Go through all the children, find the selected ones, and submit their info
    //
    V_VT(&var) = VT_I4;
    for (iItem = 0; iItem < cItems; iItem++)
    {
        V_I4(&var) = iItem;
        hr = pItems->item(var, var2, &pItem);
        if (FAILED(hr))
            goto Cleanup;

        hr = pItem->QueryInterface(IID_IHTMLOptionElement2, (void**)&pOption);
        if (FAILED(hr))
        {
            ClearInterface(&pItem);
            continue;
        }

        hr = pOption->get_selected(&bSelected);
        if (FAILED(hr))
            goto Cleanup;

        if (bSelected)
        {
            //
            // The option is selected, so submit its value
            //
            if (bNeedSeparator)
            {
                // Separate the item from the previous item
                hr = pSubmitData->appendItemSeparator();
                if (FAILED(hr))
                    goto Cleanup;
            }
            else
            {
                bNeedSeparator = TRUE;
            }

            hr = pOption->get_value(&bstrVal);
            if (FAILED(hr))
                goto Cleanup;

            hr = pSubmitData->appendNameValuePair(bstrName, bstrVal);
            if (FAILED(hr))
                goto Cleanup;
        }

        ClearInterface(&pOption);
        ClearInterface(&pItem);
    }

Cleanup:
    ReleaseInterface(pOption);
    ReleaseInterface(pItem);
    ReleaseInterface(pItems);

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
//
// IElementBehaviorFocus overrides
//
/////////////////////////////////////////////////////////////////////////////


//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetFocusRect()
//
// Synopsis:    Sets pRect to the rectangle of the focus rect.
//
// Arguments:   pRect - Receives the focus rectangle
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::GetFocusRect(RECT * pRect)
{
    HRESULT         hr;
    long            lNumOptions;
    IHTMLElement    *pElem      = NULL;
    IDispatch       *pDispatch  = NULL;
    VARIANT_BOOL    bOpen;
    long            lTopIndex;
    long            lBottomIndex;
    CContextAccess  a(_pSite);
    RECT            rect;
    long            lIndex;
    
    Assert(pRect);

    hr = GetNumOptions(&lNumOptions);
    if (FAILED(hr))
        goto Cleanup;

    lIndex = _lFocusIndex;

    if (SELECT_ISLISTBOX(_fFlavor))
    {
        hr = a.Open(CA_ELEM2);
        if (FAILED(hr))
            goto Cleanup;

        if (lNumOptions == 0)
        {
            if (!SELECT_ISINPOPUP(_fFlavor))
            {
                pRect->top = 0;
                pRect->left = 0;
#ifdef SELECT_GETSIZE
                pRect->right = _sizeOption.cx;
                pRect->bottom = _sizeOption.cy;
#else
                pRect->bottom = SELECT_OPTIONHEIGHT;
                hr = a.Elem2()->get_clientWidth(&pRect->right);
                if (FAILED(hr))
                    goto Cleanup;
#endif
            }
        }
        else
        {
            hr = GetTopVisibleOptionIndex(&lTopIndex);
            if (FAILED(hr))
                goto Cleanup;

            hr = GetBottomVisibleOptionIndex(&lBottomIndex);
            if (FAILED(hr))
                goto Cleanup;

            // Make sure the option is onscreen
            if ((_lFocusIndex >= lTopIndex) && (_lFocusIndex < lBottomIndex))
            {
                // If the writingmode is "tb-rl", the index is got with counting from left to right.
                // Hence, it needs to be changed to the actual index so that the index is as from 
                // right to left.
                if (_fWritingModeTBRL)
                {
                    lIndex = lNumOptions-_lFocusIndex-1;
                }
                hr = GetIndex(lIndex, &pDispatch);
                if (FAILED(hr))
                    goto Cleanup;

                hr = pDispatch->QueryInterface(IID_IHTMLElement, (void**)&pElem);
                if (FAILED(hr))
                    goto Cleanup;
                
                hr = pElem->get_offsetTop(&rect.top);
                if (FAILED(hr))
                    goto Cleanup;

                hr = pElem->get_offsetLeft(&rect.left);
                if (FAILED(hr))
                    goto Cleanup;

                // If the writingmode is "tb-rl", then, the top and left values are interchaged to 
                // present the options in right to left manner.
                if (_fWritingModeTBRL)
                {
                    pRect->left = rect.top;
                    pRect->top = rect.left;
                }
                else
                {
                    pRect->top = rect.top; 
                    pRect->left = rect.left;
                }

#ifdef SELECT_GETSIZE
                if (_fWritingModeTBRL)
                {
                    // The rectangle now changes to present the options text in vertical direction 
                    // and hence the changes in width and height.
                    hr = a.Elem2()->get_clientHeight(&pRect->right); 
                    if (FAILED(hr))
                        goto Cleanup;

                    pRect->right += pRect->left;
                    pRect->bottom = pRect->top + _sizeOption.cy; 
                }
                else
                {
                    hr = a.Elem2()->get_clientWidth(&pRect->right); 
                    if (FAILED(hr))
                        goto Cleanup;

                    pRect->bottom = pRect->top + _sizeOption.cy;
                }
#else
                hr = pElem->get_offsetWidth(&pRect->right);
                if (FAILED(hr))
                    goto Cleanup;

                hr = pElem->get_offsetHeight(&pRect->bottom);
                if (FAILED(hr))
                    goto Cleanup;

                pRect->right += pRect->left;
                pRect->bottom += pRect->top;
#endif

            }
        }
    }
    else if (SELECT_ISDROPBOX(_fFlavor) && (lNumOptions > 0))
    {
        hr = _pPopup->get_isOpen(&bOpen);
        if (FAILED(hr))
            goto Cleanup;

        if (!bOpen)
        {
#ifdef SELECT_GETSIZE
            // TODO: Handle with real borders
            pRect->left = 1;
            pRect->top = 1;
            pRect->right = pRect->left + _sizeOption.cx;
            pRect->bottom = pRect->top + _sizeOption.cy;

#else
            hr = _pElemDisplay->get_offsetTop(&rect.top);
            if (FAILED(hr))
                goto Cleanup;

            hr = _pElemDisplay->get_offsetLeft(&rect.left);
            if (FAILED(hr))
                goto Cleanup;

            hr = _pElemDisplay->get_offsetWidth(&rect.bottom);
            if (FAILED(hr))
                goto Cleanup;

            hr = _pElemDisplay->get_offsetHeight(&rect.right);
            if (FAILED(hr))
                goto Cleanup;

            *pRect = rect;
            if (_fWritingModeTBRL)
            {
                pRect->top = rect.left;
                pRect->left = rect.top;
            }
            else
            {
                pRect->right = rect.bottom;
                pRect->bottom = rect.right;
            }

            pRect->right += pRect->left;
            pRect->bottom += pRect->top;
#endif
        }
    }


Cleanup:
    ReleaseInterface(pDispatch);
    ReleaseInterface(pElem);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::RefreshFocusRect()
//
// Synopsis:    Refreshes the focus rectangle.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::RefreshFocusRect()
{
    HRESULT             hr;
    CContextAccess      a(_pSite);

    hr = a.Open(CA_ELEM3);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem3()->put_hideFocus(VARIANT_TRUE);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem3()->put_hideFocus(VARIANT_FALSE);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}


#ifdef SELECT_GETSIZE
/////////////////////////////////////////////////////////////////////////////
//
// IElementBehaviorLayout overrides
//
/////////////////////////////////////////////////////////////////////////////


//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetLayoutInfo()
//
// Synopsis:    Returns the type of layout we want.
//
// Arguments:   LONG *plLayoutInfo - Returns the layout info
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::GetLayoutInfo(LONG *plLayoutInfo)
{
    Assert(plLayoutInfo);

    *plLayoutInfo = BEHAVIORLAYOUTINFO_MODIFYNATURAL;

    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetSize()
//
// Synopsis:    Returns the size we want.
//
// Arguments:   LONG  dwFlags         - Request type
//              SIZE  sizeContent     - Content size
//              POINT *pptTranslate   - Translation point
//              POINT *pptTopLeft     - Top left point
//              SIZE  *psizeProposed  - Returns our proposed size
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::GetSize(LONG  dwFlags, 
                          SIZE  sizeContent, 
                          POINT *pptTranslate, 
                          POINT *pptTopLeft, 
                          SIZE  *psizeProposed)
{
    HRESULT     hr = S_OK;
    BOOL        bWidthSet;
    BOOL        bHeightSet;
    long        lButtonWidth    = GetSystemMetrics(SM_CXVSCROLL);


    // if this is not a normal sizing pass, or if this is the second
    // call due to percent sized children, just leave.
    if (! (dwFlags & BEHAVIORLAYOUTMODE_NATURAL)
         || dwFlags & BEHAVIORLAYOUTMODE_FINAL_PERCENT)
        goto Cleanup;

    hr = IsWidthHeightSet(&bWidthSet, &bHeightSet);
    if (FAILED(hr))
        goto Cleanup;

    if (!_fLayoutDirty && (bWidthSet || bHeightSet))
    {
        // Check to see if the layout really is dirty
        _fLayoutDirty = (psizeProposed->cx != _sizeSelect.cx) ||
                        (psizeProposed->cy != _sizeSelect.cy);
    }

    if (!_fAllOptionsSized)
    {
        // If we have zero options, then all the options have been sized
        // This doesn't get set correctly because OnOptionSized will never get
        // called when there are no options.
        long lNumOptions;

        hr = GetNumOptions(&lNumOptions);
        if (FAILED(hr))
            goto Cleanup;

        _fAllOptionsSized = lNumOptions == 0;
    }

    if (_fLayoutDirty && _fContentReady && _fAllOptionsSized)
    {

        _fLayoutDirty = FALSE;

        if (SELECT_ISDROPBOX(_fFlavor) && _fVLEngaged)
        {
            _sizeContent = _sizeOption;             // the forced option size
            // TODO: +2 for padding
            _sizeContent.cx += lButtonWidth + 2;
            _sizeContent.cy += 2;

            _sizeSelect = _sizeContent;
        }
        else
        {
            long        lSize;

            hr = get_size(&lSize);
            if (FAILED(hr))
                goto Cleanup;

            // If we have no default option size, then set to a default size
            if (_sizeOption.cx == 0)
            {
                _sizeOption.cx = SELECT_OPTIONWIDTH;

                if (!_fNeedScrollBar)
                {
                    _sizeOption.cx += lButtonWidth;
                }
            }

            if (_sizeOption.cy == 0)
            {
                _sizeOption.cy = SELECT_OPTIONHEIGHT;
            }

            if (_fNeedScrollBar)
            {
                _sizeContent.cx = _sizeOption.cx;
            }
            else if(_sizeContent.cx < _sizeOption.cx)
            {
                _sizeContent.cx = _sizeOption.cx;
            }

            if (_fNeedScrollBar)
            {
                _sizeContent.cx += lButtonWidth;
            }  
            _sizeContent.cy = _sizeOption.cy * lSize;

            _sizeSelect = _sizeContent;
        }

        // Add in the border and padding
        // TODO: Replace with real border
        if (SELECT_ISDROPBOX(_fFlavor))
        {
            _sizeSelect.cx += 4;
            _sizeSelect.cy += 4;
        }
        else if (!SELECT_ISINPOPUP(_fFlavor))
        {
            _sizeSelect.cx += 6;
            _sizeSelect.cy += 6;
        }
        

        if (bHeightSet)
        {
            _sizeSelect.cy = psizeProposed->cy;

            // TODO: Replace with real border
            _sizeContent.cy = _sizeSelect.cy - 6;

            if (SELECT_ISLISTBOX(_fFlavor))
            {
                // Make sure that the content height is a multiple of the height of the options
                _sizeContent.cy -= _sizeContent.cy % _sizeOption.cy;
                // TODO: Replace with real border
                _sizeSelect.cy = _sizeContent.cy + 6;
            }
        }

        if (bWidthSet)
        {
            _sizeSelect.cx = psizeProposed->cx;
            // TODO: Replace with real border

            _sizeContent.cx = _sizeSelect.cx - 6;
            // _sizeContent.cx -= 8;

            if (SELECT_ISLISTBOX(_fFlavor))
            {
                long lNumOptions;

                hr = GetNumOptions(&lNumOptions);
                if (FAILED(hr))
                    goto Cleanup;

                _sizeOption.cx = _sizeContent.cx;
                if (lNumOptions > (_sizeContent.cy / _sizeOption.cy))
                {
                    // Scrollbars are needed
                    _sizeOption.cx -= lButtonWidth;
                }
            }

            if (SELECT_ISDROPBOX(_fFlavor))
            {
                _sizeSelect.cx += lButtonWidth + 2;
            }
        }

        // TODO: Remove _lMaxHeight everywhere
        _lMaxHeight = _sizeOption.cy;
    }

    *psizeProposed = _sizeSelect;

    
Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::IsWidthHeightSet()
//
// Synopsis:    Returns whether the width and/or height was set in the style.
//
// Arguments:   BOOL *pbWidthSet    - Returns if the width was set
//              BOOL *pbHeightSet   - Returns if the height was set
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::IsWidthHeightSet(BOOL *pbWidthSet, BOOL *pbHeightSet)
{
    HRESULT         hr;
    CVariant        var;
    CContextAccess  a(_pSite);

    hr = a.Open(CA_STYLE);
    if (FAILED(hr))
        goto Cleanup;

    if (pbWidthSet)
    {
        hr = a.Style()->get_width(&var);
        if (FAILED(hr))
            goto Cleanup;

        *pbWidthSet = !(var.IsEmpty() || ((V_VT(&var) == VT_BSTR) && (V_BSTR(&var) == NULL)));
    }

    if (pbHeightSet)
    {
        hr = a.Style()->get_height(&var);
        if (FAILED(hr))
            goto Cleanup;

        *pbHeightSet = !(var.IsEmpty() || ((V_VT(&var) == VT_BSTR) && (V_BSTR(&var) == NULL)));
    }

Cleanup:
    return hr;
}
#endif


/////////////////////////////////////////////////////////////////////////////
//
// CBaseCtl overrides
//
/////////////////////////////////////////////////////////////////////////////


//+------------------------------------------------------------------
//
// Member:      CIESelectElement::Init()
//
// Synopsis:    Attaches events and sets the default style.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::Init()
{
    HRESULT         hr;
    CComBSTR        bstr;
    CContextAccess  a(_pSite);

    hr = a.Open(CA_ELEM | CA_DEFAULTS | CA_SITEOM | CA_STYLE);
    if (FAILED(hr))
        goto Cleanup;
    
    // Register the behavior name
    hr = a.SiteOM()->RegisterName(_T("select"));
    if (FAILED(hr))
        goto Cleanup;

    //
    // Register for events
    //
    hr = AttachEvent(EVENT_ONFOCUS, &a);
    if (FAILED(hr))
        goto Cleanup;
    hr = AttachEvent(EVENT_ONBLUR, &a);
    if (FAILED(hr))
        goto Cleanup;
    hr = AttachEvent(EVENT_ONMOUSEDOWN, &a);
    if (FAILED(hr))
        goto Cleanup;
    hr = AttachEvent(EVENT_ONMOUSEUP, &a);
    if (FAILED(hr))
        goto Cleanup;
    hr = AttachEvent(EVENT_ONMOUSEOVER, &a);
    if (FAILED(hr))
        goto Cleanup;
    hr = AttachEvent(EVENT_ONMOUSEOUT, &a);
    if (FAILED(hr))
        goto Cleanup;
    hr = AttachEvent(EVENT_ONMOUSEMOVE, &a);
    if (FAILED(hr))
        goto Cleanup;
    hr = AttachEvent(EVENT_ONKEYDOWN, &a);
    if (FAILED(hr))
        goto Cleanup;
    hr = AttachEvent(EVENT_ONKEYUP, &a);
    if (FAILED(hr))
        goto Cleanup;
    hr = AttachEvent(EVENT_ONKEYPRESS, &a);
    if (FAILED(hr))
        goto Cleanup;
    hr = AttachEvent(EVENT_ONSELECTSTART, &a);
    if (FAILED(hr))
        goto Cleanup;
    hr = AttachEvent(EVENT_ONSCROLL, &a);
    if (FAILED(hr))
        goto Cleanup;
    hr = AttachEvent(EVENT_ONCONTEXTMENU, &a);
    if (FAILED(hr))
        goto Cleanup;
    hr = AttachEvent(EVENT_ONPROPERTYCHANGE, &a);
    if (FAILED(hr))
        goto Cleanup;

    bstr = _T("onchange");
    hr = RegisterEvent(a.SiteOM(), bstr, &_lOnChangeCookie);
    if (FAILED(hr))
        goto Cleanup;

    bstr = _T("onmousedown");
    hr = RegisterEvent(a.SiteOM(), bstr, &_lOnMouseDownCookie, BEHAVIOREVENTFLAGS_STANDARDADDITIVE | BEHAVIOREVENTFLAGS_BUBBLE);
    if (FAILED(hr))
        goto Cleanup;

    bstr = _T("onmouseup");
    hr = RegisterEvent(a.SiteOM(), bstr, &_lOnMouseUpCookie, BEHAVIOREVENTFLAGS_STANDARDADDITIVE | BEHAVIOREVENTFLAGS_BUBBLE);
    if (FAILED(hr))
        goto Cleanup;

    bstr = _T("onclick");
    hr = RegisterEvent(a.SiteOM(), bstr, &_lOnClickCookie, BEHAVIOREVENTFLAGS_STANDARDADDITIVE | BEHAVIOREVENTFLAGS_BUBBLE);
    if (FAILED(hr))
        goto Cleanup;

    bstr = _T("onkeydown");
    hr = RegisterEvent(a.SiteOM(), bstr, &_lOnKeyDownCookie, BEHAVIOREVENTFLAGS_STANDARDADDITIVE | BEHAVIOREVENTFLAGS_BUBBLE);
    if (FAILED(hr))
        goto Cleanup;

    bstr = _T("onkeyup");
    hr = RegisterEvent(a.SiteOM(), bstr, &_lOnKeyUpCookie, BEHAVIOREVENTFLAGS_STANDARDADDITIVE | BEHAVIOREVENTFLAGS_BUBBLE);
    if (FAILED(hr))
        goto Cleanup;

    bstr = _T("onkeypress");
    hr = RegisterEvent(a.SiteOM(), bstr, &_lOnKeyPressedCookie, BEHAVIOREVENTFLAGS_STANDARDADDITIVE | BEHAVIOREVENTFLAGS_BUBBLE);
    if (FAILED(hr))
        goto Cleanup;

    // Be able to receive keyboard focus
    hr = a.Defaults()->put_tabStop(VB_TRUE);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Defaults()->put_viewMasterTab(VARIANT_TRUE);
    if (FAILED(hr))
        goto Cleanup;

    // Force a layout
    hr = a.Style()->put_display(_T("inline-block"));
    if (FAILED(hr))
        goto Cleanup;

    hr = SetupDefaultStyle();
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SetupDefaultStyle()
//
// Synopsis:    Sets the default style for the select control.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::SetupDefaultStyle()
{
    HRESULT         hr;
    CComBSTR        bstrHidden(_T("hidden"));
    CComBSTR        bstrBorder(_T("3 window-inset"));
    CComBSTR        bstrDefault(_T("default"));
    CComBSTR        bstrFont(_T("MS Sans Serif"));
    CComBSTR        bstrFontSize(_T("10pt"));
    CComBSTR        bstrWindow(_T("window"));
    CComBSTR        bstrColor(_T("windowtext"));
    CComBSTR        bstrVert(_T("text-bottom"));
    CVariant        var;
    CContextAccess  a(_pSite);

    //
    //  TODO: Can this be made into a table?
    //

    hr = a.Open(CA_DEFSTYLE);
    if (FAILED(hr))
        goto Cleanup;

    // Setup hidden
    hr = a.DefStyle()->put_visibility(bstrHidden);
    if (FAILED(hr))
        goto Cleanup;

    // Setup border
    hr = a.DefStyle()->put_border(bstrBorder);
    if (FAILED(hr))
        goto Cleanup;

    // Setup mouse
    hr = a.DefStyle()->put_cursor(bstrDefault);
    if (FAILED(hr))
        goto Cleanup;

    // Setup overflow
    hr = a.DefStyle()->put_overflow(bstrHidden);
    if (FAILED(hr))
        goto Cleanup;

    // Setup font
    hr = a.DefStyle()->put_fontFamily(bstrFont);
    if (FAILED(hr))
        goto Cleanup;

    // Setup the font size
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstrFontSize;
    hr = a.DefStyle()->put_fontSize(var);
    if (FAILED(hr))
        goto Cleanup;

    // Setup background
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = (BSTR)bstrWindow;
    hr = a.DefStyle()->put_backgroundColor(var);
    if (FAILED(hr))
        goto Cleanup;

    // Setup the foreground color
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = (BSTR)bstrColor;
    hr = a.DefStyle()->put_color(var);
    if (FAILED(hr))
        goto Cleanup;

    // Setup the vertical alignment
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstrVert;
    hr = a.DefStyle()->put_verticalAlign(var);
    if (FAILED(hr))
        goto Cleanup;

    // Set a top margin
    V_VT(&var) = VT_I4;
    V_I4(&var) = 1;
    hr = a.DefStyle()->put_marginTop(var);
    if (FAILED(hr))
        goto Cleanup;

    V_VT(&var) = VT_I4;
    V_I4(&var) = 7;
    hr = a.DefStyle()->put_width(var);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnContentReady()
//
// Synopsis:    Initializes the flavor of the control and the flavor
//              of the OPTION elements.
//
// Arguments:   CEventObjectAccess *pEvent - Event information
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::OnContentReady()
{
    return InitContent();
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::InitContent()
//
// Synopsis:    Initializes the flavor of the control and the flavor
//              of the OPTION elements.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::InitContent()
{
    HRESULT         hr;
    VARIANT_BOOL    bMult;
    long            lSize;

    hr = SetWritingModeFlag();
    if (FAILED(hr))
        goto Cleanup;

    //
    // Retrieve properties
    //
    hr = get_multiple(&bMult);
    if (FAILED(hr))
        goto Cleanup;
    if (hr == S_FALSE)
    {
        // The attribute was not set correctly, default to VARIANT_FALSE
        bMult = VARIANT_FALSE;
        hr = put_multiple(bMult);
        if (FAILED(hr))
            goto Cleanup;
    }

    hr = get_size(&lSize);
    if (FAILED(hr))
        goto Cleanup;

    if ((hr == S_FALSE) || (lSize < 1))
    {
        // The size was not set correctly, correct it
        lSize = bMult ? 4 : 1;
        hr = GetProps()[eSize].Set(lSize);
        if (FAILED(hr))
            goto Cleanup;
    }

    //
    // Setup the flavor (default is single select listbox)
    //
    _fFlavor = _fFlavor & SELECT_INPOPUP;   // If this was set, then keep it
    if (bMult)
    {
        // Multiple select
        _fFlavor |= SELECT_MULTIPLE;
    }
    else if (lSize == 1)
    {
        // Single select dropbox.
        _fFlavor |= SELECT_DROPBOX;
    }

    //
    // Based on the flavor, setup the control
    //
    if (SELECT_ISLISTBOX(_fFlavor))
    {
#ifdef SELECT_GETSIZE
        _fLayoutDirty = TRUE;
#endif
        hr = SetupListBox();
        if (FAILED(hr))
            goto Cleanup;
    }
    else if (SELECT_ISDROPBOX(_fFlavor))
    {
        hr = SetupDropBox();
        if (FAILED(hr))
            goto Cleanup;
    }
    else
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // Initialize the options
    //
    hr = InitOptions();
    if (FAILED(hr))
        goto Cleanup;

#ifndef SELECT_GETSIZE
    //
    // Make the control visible
    //
    hr = MakeVisible(TRUE);
    if (FAILED(hr))
        goto Cleanup;
#endif

#ifdef SELECT_GETSIZE
    _fContentReady = TRUE;
#endif

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::MakeVisible()
//
// Synopsis:    Makes the control visible or hidden.
//
// Arguments:   BOOL bShow  - True to make visible
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::MakeVisible(BOOL bShow /* = TRUE */)
{
    HRESULT         hr;
    CComBSTR        bstrVisible;
    CContextAccess  a(_pSite);

    hr = a.Open(CA_DEFSTYLE);
    if (FAILED(hr))
        goto Cleanup;

    if (bShow)
    {
        bstrVisible = _T("visible");
    }
    else
    {
        bstrVisible = _T("hidden");
    }

    // Display the control
    hr = a.DefStyle()->put_visibility(bstrVisible);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SetupListBox()
//
// Synopsis:    Sets up the listbox control.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::SetupListBox()
{
    HRESULT         hr;
    long            lSize;
    long            lNumOptions;
    CContextAccess  a(_pSite);

    hr = a.Open(CA_DEFSTYLE | CA_DEFSTYLE2 | CA_DEFAULTS);
    if (FAILED(hr))
        goto Cleanup;

    hr = get_size(&lSize);
    if (FAILED(hr))
        goto Cleanup;

#ifndef SELECT_GETSIZE
    hr = SetDimensions(lSize);
    if (FAILED(hr))
        goto Cleanup;
#endif

    hr = GetNumOptions(&lNumOptions);
    if (FAILED(hr))
        goto Cleanup;

    _fNeedScrollBar = (lNumOptions > lSize);

    if (_fWritingModeTBRL)
    {
        hr = SetPixelHeightWidth();
        if (FAILED(hr))
            goto Cleanup;
    }

    //
    // Setup the scroll segment
    //
     hr = a.Defaults()->put_scrollSegmentY(lNumOptions);
        if (FAILED(hr))
            goto Cleanup;


#ifdef SELECT_GETSIZE

    if (!_fContentReady)
    {
        // The border is different on the listbox (we need this in case we were dynamically
        // changed from a dropbox to a listbox).
        hr = a.DefStyle()->put_border(CComBSTR(_T("3 window-inset")));
        if (FAILED(hr))
            goto Cleanup;

        hr = a.DefStyle2()->put_overflowY(CComBSTR(_T("auto")));
        if (FAILED(hr))
            goto Cleanup;

        //
        // Make the control visible
        //
        hr = MakeVisible(TRUE);
        if (FAILED(hr))
            goto Cleanup;
    }
#endif

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SetupDropBox()
//
// Synopsis:    Sets up the dropbox control.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT 
CIESelectElement::SetupDropBox()
{
    HRESULT hr;

    hr = SetupDropControl();
    if (FAILED(hr))
        goto Cleanup;

    hr = SetupPopup();
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SetupDropControl()
//
// Synopsis:    Sets up the dropbox control portion.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT 
CIESelectElement::SetupDropControl()
{
    HRESULT                     hr              = S_OK;
    CComBSTR                    bstrHidden(_T("hidden"));
    CComBSTR                    bstrBorder(_T("2 inset"));
    CComBSTR                    bstrWritingMode(_T(""));
    CContextAccess              a(_pSite);
    long                        lTemp;

#ifndef SELECT_GETSIZE
    IHTMLDocument2              *pDocThis       = NULL;
    IDispatch                   *pDispDocLink  = NULL;
    IHTMLDocument2              *pDocLink      = NULL;
    IHTMLDocument3              *pDocLink3     = NULL;
    IHTMLElement                *pElemLink      = NULL;
    IHTMLDOMNode                *pNodeLink      = NULL;
    IHTMLElement                *pElemDisplay      = NULL;
    IHTMLDOMNode                *pNodeDisplay      = NULL;
    IHTMLElement                *pElemButton    = NULL;
    IHTMLDOMNode                *pNodeButton    = NULL;
    CComBSTR                    bstr;
    CVariant                    var;
    IDispatch                   *pDispatch      = NULL;
    IHTMLElement                *pElem          = NULL;
    IHTMLElement2               *pElem2         = NULL;
    IHTMLStyle                  *pStyle         = NULL;
    IHTMLStyle2                 *pStyle2        = NULL;
    long                        lHeight;
    long                        lWidth;
    long                        lButtonWidth;
    long                        lNumOptions;
    long                        lDiff;
#endif

#ifdef SELECT_GETSIZE
    hr = a.Open(CA_DEFSTYLE);
    if (FAILED(hr))
        goto Cleanup;
#else
    hr = a.Open(CA_ELEM | CA_ELEM2 | CA_ELEM3 | CA_PELEM | CA_DEFSTYLE);
    if (FAILED(hr))
        goto Cleanup;
#endif

    // Set overflow hidden for the drop control
    hr = a.DefStyle()->put_overflow(bstrHidden);
    if (FAILED(hr))
        goto Cleanup;

    // The border is different on the drop control
    hr = a.DefStyle()->put_border(bstrBorder);
    if (FAILED(hr))
        goto Cleanup;

#ifndef SELECT_GETSIZE
    hr = GetNumOptions(&lNumOptions);
    if (FAILED(hr))
        goto Cleanup;

    // Set the dimensions of the control
    if (lNumOptions > 0)
    {
        // TODO: Change this to the real maximum number of options
        if (lNumOptions > SELECT_MAXOPTIONS)
        {
            lNumOptions = SELECT_MAXOPTIONS;
        }
        hr = SetDimensions(lNumOptions);
        if (FAILED(hr))
            goto Cleanup;
    }
    else
    {
        hr = SetDimensions(1);
        if (FAILED(hr))
            goto Cleanup;
    }

    hr = a.Elem2()->get_clientHeight(&_lPopupSize.cy);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.DefStyle()->get_pixelWidth(&lWidth);
    if (FAILED(hr))
        goto Cleanup;
    _lPopupSize.cx = lWidth;

    if (lNumOptions > 0)
    {
        hr = GetIndex(0, &pElem);
        if (FAILED(hr))
            goto Cleanup;

        hr = pElem->get_offsetHeight(&lHeight);
        if (FAILED(hr))
            goto Cleanup;

        lDiff = _lPopupSize.cy - lHeight;

        hr = a.DefStyle()->get_pixelHeight(&lHeight);
        if (FAILED(hr))
            goto Cleanup;

        lHeight -= lDiff;

        ClearInterface(&pElem);
    }
    else
    {
        hr = a.DefStyle()->get_pixelHeight(&lHeight);
        if (FAILED(hr))
            goto Cleanup;
    }

    if (_fWritingModeTBRL)
    {
        lTemp = lWidth;
        lWidth = lHeight;
        lHeight = lTemp;
    }

    hr = a.DefStyle()->put_pixelHeight(lHeight + 2);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.DefStyle()->put_pixelWidth(lWidth + 2);
    if (FAILED(hr))
        goto Cleanup;


    // Get the client area's width
    hr = a.Elem2()->get_clientWidth(&lWidth);
    if (FAILED(hr))
        goto Cleanup;

    // Get the client area's height
    hr = a.Elem2()->get_clientHeight(&lHeight);
    if (FAILED(hr))
        goto Cleanup;

    // Get the width of the button
    lButtonWidth = GetSystemMetrics(SM_CXVSCROLL);

    // Get the document
    hr = a.Elem()->get_document((IDispatch**)&pDocThis);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Create a superflous slave element for now
    //
    bstr = _T("SPAN");
    hr = pDocThis->createElement(bstr, &pElemLink);
    if (FAILED(hr))
        goto Cleanup;

    hr = pElemLink->QueryInterface(IID_IHTMLDOMNode, (void**)&pNodeLink);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Create the display element
    //
    bstr = _T("SPAN");
    hr = pDocThis->createElement(bstr, &pElemDisplay);
    if (FAILED(hr))
        goto Cleanup;

    _pElemDisplay = pElemDisplay;
    _pElemDisplay->AddRef();

    //
    // Insert the display
    //
    hr = pElemDisplay->QueryInterface(IID_IHTMLDOMNode, (void**)&pNodeDisplay);
    if (FAILED(hr))
        goto Cleanup;

    hr = pNodeLink->appendChild(pNodeDisplay, NULL);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Create the button
    //
    bstr = _T("SPAN");
    hr = pDocThis->createElement(bstr, &pElemButton);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Insert the button
    //
    hr = pElemButton->QueryInterface(IID_IHTMLDOMNode, (void**)&pNodeButton);
    if (FAILED(hr))
        goto Cleanup;

    hr = pNodeLink->appendChild(pNodeButton, NULL);
    if (FAILED(hr))
        goto Cleanup;

    // Remove the superflous Link element now
    hr = pNodeLink->removeNode(VB_FALSE, NULL);
    if (FAILED(hr))
        goto Cleanup;

    // Get hold of the Link document

    if ( _pDispDocLink )
    {
        pDispDocLink = _pDispDocLink;
        _pDispDocLink->AddRef();
    }
    else
    {
        hr = pElemDisplay->get_document(&pDispDocLink);
        if (FAILED(hr))
            goto Cleanup;
    }

    hr = pDispDocLink->QueryInterface(IID_IHTMLDocument2, (void**)&pDocLink);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Create the viewLink
    //
    hr = a.PElem()->putref_viewLink(pDocLink);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Set the display's style
    //
    hr = pElemDisplay->get_style(&pStyle);
    if (FAILED(hr))
        goto Cleanup;

    hr = pStyle->QueryInterface(IID_IHTMLStyle2, (void**)&pStyle2);
    if (FAILED(hr))
        goto Cleanup;

    // Set the mouse cursor be an arrow for the display
    bstr = _T("default");
    hr = pStyle->put_cursor(bstr);
    if (FAILED(hr))
        goto Cleanup;

    // Set overflow hidden for the display
    bstr = _T("hidden");
    hr = pStyle->put_overflow(bstr);
    if (FAILED(hr))
        goto Cleanup;

    if (_fWritingModeTBRL)
    {
        lTemp = lWidth;
        lWidth = lHeight;
        lHeight = lWidth;
    }

    // Set the width of the display
    hr = pStyle->put_pixelWidth(lWidth - lButtonWidth);
    if (FAILED(hr))
        goto Cleanup;

    // Set the height of the display
    bstr = _T("100%");
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstr;
    hr = pStyle->put_height(var);
    if (FAILED(hr))
        goto Cleanup;

    // Set the vertical alignment of the display to be top
    bstr = _T("top");
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstr;
    hr = pStyle->put_verticalAlign(var);
    if (FAILED(hr))
        goto Cleanup;

    // Set the font for the display
    bstr = _T("MS Sans Serif");
    hr = pStyle->put_fontFamily(bstr);
    if (FAILED(hr))
        goto Cleanup;

    // Set the font size for the display
    bstr = _T("10pt");
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstr;
    hr = pStyle->put_fontSize(var);
    if (FAILED(hr))
        goto Cleanup;

    // Set the left padding on the display
    bstr = _T("3px");
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstr;
    hr = pStyle->put_paddingLeft(var);
    if (FAILED(hr))
        goto Cleanup;

    // Set the top padding on the display
    bstr = _T("1px");
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstr;
    hr = pStyle->put_paddingTop(var);
    if (FAILED(hr))
        goto Cleanup;

    ClearInterface(&pStyle);
    ClearInterface(&pStyle2);

    //
    // Set the button's style
    //
    hr = pElemButton->get_style(&pStyle);
    if (FAILED(hr))
        goto Cleanup;

    hr = pStyle->QueryInterface(IID_IHTMLStyle2, (void**)&pStyle2);
    if (FAILED(hr))
        goto Cleanup;

    _pStyleButton = pStyle;
    _pStyleButton->AddRef();

    // Set the mouse cursor be an arrow for the button
    bstr = _T("default");
    hr = pStyle->put_cursor(bstr);
    if (FAILED(hr))
        goto Cleanup;

    // Set overflow hidden for the button
    bstr = _T("hidden");
    hr = pStyle->put_overflow(bstr);
    if (FAILED(hr))
        goto Cleanup;

    if (_fWritingModeTBRL)
    {
        hr = pStyle->put_pixelHeight(lButtonWidth);
        if (FAILED(hr))
            goto Cleanup;
    }
    else
    {
        // Set the width of the button
        hr = pStyle->put_pixelWidth(lButtonWidth);
        if (FAILED(hr))
            goto Cleanup;
    }

    // Set the height of the button
    bstr = _T("100%");
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstr;
    if (_fWritingModeTBRL)
    {
        hr = pStyle->put_width(var);
        if (FAILED(hr))
            goto Cleanup;
    }
    else
    {
        hr = pStyle->put_height(var);
        if (FAILED(hr))
            goto Cleanup;
    }

    // Set the background color for the button
    bstr = _T("buttonface");
    hr = pStyle->put_background(bstr);
    if (FAILED(hr))
        goto Cleanup;

    // Set the border for the button
    bstr = _T("2 outset");
    hr = pStyle->put_border(bstr);
    if (FAILED(hr))
        goto Cleanup;

    // Set the font family of the button
    bstr = _T("Marlett");
    hr = pStyle->put_fontFamily(bstr);
    if (FAILED(hr))
        goto Cleanup;

    // Set the font size of the button
    V_VT(&var) = VT_I4;
    V_I4(&var) = lButtonWidth - 4;
    hr = pStyle->put_fontSize(var);
    if (FAILED(hr))
        goto Cleanup;

    // Set the text to be the down arrow
    bstr = _T("u");
    hr = pElemButton->put_innerText(bstr);
    if (FAILED(hr))
        goto Cleanup;

    // Set the alignment on the arrow to be centered
    bstr = _T("center");
    hr = pStyle->put_textAlign(bstr);
    if (FAILED(hr))
        goto Cleanup;

    // The layout-grid-line is supposed to vertically
    // center the arrow, but it doesn't. The padding
    // is there to push the arrow up one pixel for IE5 compat.
    // Set the layout-grid-line of the button to be 100%
    bstr = _T("100%");
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstr;
    hr = pStyle2->put_layoutGridLine(var);
    if (FAILED(hr))
        goto Cleanup;

    // Set the bottom padding of the button
    bstr = _T("2px");
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstr;
    hr = pStyle->put_paddingBottom(var);
    if (FAILED(hr))
        goto Cleanup;

    ClearInterface(&pStyle);
    ClearInterface(&pStyle2);

    //
    // Attach an event sink to listen for events within the view link
    //
    hr = pDocLink->QueryInterface(IID_IHTMLDocument3, (void**)&pDocLink3);
    if (FAILED(hr))
        goto Cleanup;

    if ( !_pSinkVL )
    {
        _pSinkVL = new CEventSink(this, SELECTES_VIEWLINK);
        if (!_pSinkVL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        bstr = _T("onmousedown");
        hr = AttachEventToSink(pDocLink3, bstr, _pSinkVL);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onmouseup");
        hr = AttachEventToSink(pDocLink3, bstr, _pSinkVL);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onclick");
        hr = AttachEventToSink(pDocLink3, bstr, _pSinkVL);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onselectstart");
        hr = AttachEventToSink(pDocLink3, bstr, _pSinkVL);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("oncontextmenu");
        hr = AttachEventToSink(pDocLink3, bstr, _pSinkVL);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onbeforefocusenter");
        hr = AttachEventToSink(pDocLink3, bstr, _pSinkVL);
        if (FAILED(hr))
            goto Cleanup;
    }
    if ( !_pSinkButton )
    {
        _pSinkButton = new CEventSink(this, SELECTES_BUTTON);
        if (!_pSinkButton)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = pElemDisplay->QueryInterface(IID_IHTMLElement2, (void**)&pElem2);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onbeforefocusenter");
        hr = AttachEventToSink(pElem2, bstr, _pSinkVL);
        if (FAILED(hr))
            goto Cleanup;

        ClearInterface(&pElem2);

        hr = pElemButton->QueryInterface(IID_IHTMLElement2, (void**)&pElem2);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onmousedown");
        hr = AttachEventToSink(pElem2, bstr, _pSinkButton);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onmouseup");
        hr = AttachEventToSink(pElem2, bstr, _pSinkButton);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onmouseout");
        hr = AttachEventToSink(pElem2, bstr, _pSinkButton);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onbeforefocusenter");
        hr = AttachEventToSink(pElem2, bstr, _pSinkButton);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onbeforefocusenter");
        hr = AttachEventToSink(pElem2, bstr, _pSinkVL);
        if (FAILED(hr))
            goto Cleanup;
   }
#endif
Cleanup:
#ifndef SELECT_GETSIZE
    ReleaseInterface(pDocThis);

    ReleaseInterface(pDispDocLink);
    ReleaseInterface(pDocLink);
    ReleaseInterface(pDocLink3);

    ReleaseInterface(pElemLink);
    ReleaseInterface(pNodeLink);

    ReleaseInterface(pElemDisplay);
    ReleaseInterface(pNodeDisplay);
    
    ReleaseInterface(pElemButton);
    ReleaseInterface(pNodeButton);

    ReleaseInterface(pDispatch);
    ReleaseInterface(pElem);
    ReleaseInterface(pElem2);
    ReleaseInterface(pStyle);
    ReleaseInterface(pStyle2);
#endif

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::AttachEventToSink()
//
// Synopsis:    Attaches an element's event to a given sink.
//
// Arguments:   IHTMLElement2 *pElem    - The element to listen to
//              CComBSTR& bstr          - The name of the event
//              CEventSink* pSink       - The event sink
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::AttachEventToSink(IHTMLElement2 *pElem, CComBSTR& bstr, CEventSink* pSink)
{
    HRESULT         hr;
    VARIANT_BOOL    vSuccess;

    hr = pElem->attachEvent(bstr, (IDispatch*)pSink, &vSuccess);
    if (FAILED(hr))
        goto Cleanup;

    if (vSuccess != VARIANT_TRUE)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::AttachEventToSink()
//
// Synopsis:    Attaches a document's event to a given sink.
//
// Arguments:   IHTMLDocument3 *pDoc    - The document to listen to
//              CComBSTR& bstr          - The name of the event
//              CEventSink* pSink       - The event sink
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::AttachEventToSink(IHTMLDocument3 *pDoc, CComBSTR& bstr, CEventSink* pSink)
{
    HRESULT         hr;
    VARIANT_BOOL    vSuccess;

    hr = pDoc->attachEvent(bstr, (IDispatch*)pSink, &vSuccess);
    if (FAILED(hr))
        goto Cleanup;

    if (vSuccess != VARIANT_TRUE)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:
    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SetupPopup()
//
// Synopsis:    Sets up the popup window for dropbox.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::SetupPopup()
{
    HRESULT                 hr;

    IDispatch               *pDocMainD      = NULL;
    IHTMLDocument2          *pDocMain       = NULL;
    IHTMLWindow2            *pWinMain       = NULL;
    IHTMLWindow4            *pWinMain4      = NULL;
    IHTMLDocument           *pDocThis       = NULL;
    IHTMLDocument2          *pDoc2          = NULL;
    IDispatch               *pPopupDisp     = NULL;
    IHTMLElement            *pElemHTML      = NULL;
    IHTMLElement            *pElemBODY      = NULL;
    IHTMLElement            *pElemSELECT    = NULL;
    IHTMLElementCollection  *pItems         = NULL;
    IDispatch               *pDispatchItem  = NULL;
    IHTMLElement2           *pElem2         = NULL;
    IHTMLStyle              *pStyleBody     = NULL;


#ifndef SELECT_GETSIZE
    IHTMLStyle              *pStyle         = NULL;
    IHTMLElement            *pElem          = NULL;
#endif

    long                    lSize;
    CVariant                var, var2;
    CComBSTR                bstr, bstrHTML, bstrTemp;
    CComBSTR                bstrImport = _T("<?IMPORT namespace=IE implementation='#default'>");
    TCHAR                   strNum[5];
    CContextAccess          a(_pSite);


    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_document(&pDocMainD);
    if (FAILED(hr))
        goto Cleanup;

    hr = pDocMainD->QueryInterface(IID_IHTMLDocument2, (void **)&pDocMain);
    if (FAILED(hr))
        goto Cleanup;

    hr = pDocMain->get_parentWindow(&pWinMain);
    if (FAILED(hr))
        goto Cleanup;

    hr = pWinMain->QueryInterface(IID_IHTMLWindow4, (void **)&pWinMain4);
    if (FAILED(hr))
        goto Cleanup;

    V_VT(&var) = VT_EMPTY;
    hr = pWinMain4->createPopup(&var, &pPopupDisp);
    if (FAILED(hr))
        goto Cleanup;

    hr = pPopupDisp->QueryInterface(IID_IHTMLPopup, (void **)&_pPopup);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Get the popup's document
    //
    hr = _pPopup->get_document(&pDocThis);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Get the popup's document
    //
    pDocThis->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc2);
    if (FAILED(hr))
        goto Cleanup;

    hr = pDoc2->get_body(&pElemBODY);
    if (FAILED(hr))
        goto Cleanup;

    hr = UpdatePopup();
    if (FAILED(hr))
        goto Cleanup;

    hr = pElemBODY->get_children((IDispatch**)&pItems);
    if (FAILED(hr))
        goto Cleanup;

    hr = pItems->item(var, var2, &pDispatchItem);
    if (FAILED(hr))
        goto Cleanup;

    if (!pDispatchItem)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // Attach an event sink to listen for events within the popup
    //
    hr = pDispatchItem->QueryInterface(IID_IHTMLElement2, (void**)&pElem2);
    if (FAILED(hr))
        goto Cleanup;

    if ( !_pSinkPopup )
    {
        _pSinkPopup = new CEventSink(this, SELECTES_POPUP);
        if (!_pSinkPopup)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        bstr = _T("onchange");
        hr = AttachEventToSink(pElem2, bstr, _pSinkPopup);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onkeydown");
        hr = AttachEventToSink(pElem2, bstr, _pSinkPopup);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onkeyup");
        hr = AttachEventToSink(pElem2, bstr, _pSinkPopup);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onkeypress");
        hr = AttachEventToSink(pElem2, bstr, _pSinkPopup);
        if (FAILED(hr))
            goto Cleanup;
    }
Cleanup:
    ReleaseInterface(pDocMainD);
    ReleaseInterface(pDocMain);
    ReleaseInterface(pWinMain);
    ReleaseInterface(pWinMain4);
    ReleaseInterface(pPopupDisp);
    ReleaseInterface(pElemHTML);
    ReleaseInterface(pElemBODY);
    ReleaseInterface(pElemSELECT);
    ReleaseInterface(pDocThis);
    ReleaseInterface(pDoc2);
    ReleaseInterface(pItems);
    ReleaseInterface(pDispatchItem);
    ReleaseInterface(pElem2);
    ReleaseInterface(pStyleBody);
#ifndef SELECT_GETSIZE
    ReleaseInterface(pStyle);
    ReleaseInterface(pElem);
#endif

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CIESelectElement::UpdatePopup()
//
// Synopsis:    Update the popup window for dropbox.
//              The viewlink has just the dropdown button and selected text. The _pPopup has 
//              the list of options stored in its associated document. Each time an option is
//              is added to the dropdown, it is actually added to the document associated with
//              the _pPopup. The popup of the dropdown, itself doesn't get updated. This leads
//              to wrong display of the list of options. To fix this, this function is added.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::UpdatePopup()
{
    HRESULT                 hr;
    IHTMLDocument           *pDocThis       = NULL;
    IHTMLDocument2          *pDoc2          = NULL;
    IHTMLElement            *pElemBODY      = NULL;
    IHTMLElementCollection  *pItems         = NULL;
    IDispatch               *pDispatchItem  = NULL;
    IHTMLStyle              *pStyleBody     = NULL;


#ifndef SELECT_GETSIZE
    IHTMLStyle              *pStyle         = NULL;
    IHTMLElement            *pElem          = NULL;
#endif

    long                    lSize;
    CVariant                var, var2;
    CComBSTR                bstr, bstrHTML, bstrTemp;
    CComBSTR                bstrImport = _T("<?IMPORT namespace=IE implementation='#default'>");
    TCHAR                   strNum[5];
    CContextAccess          a(_pSite);
    CComBSTR                bstrWritingMode(_T(""));

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Get the popup's document
    //

    hr = _pPopup->get_document(&pDocThis);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Get the popup's document
    //
    pDocThis->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc2);
    if (FAILED(hr))
        goto Cleanup;

    hr = pDoc2->get_body(&pElemBODY);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Set the style on the popup
    //
    hr = pElemBODY->get_style(&pStyleBody);
    if (FAILED(hr))
        goto Cleanup;

    hr = pStyleBody->put_border(CComBSTR(_T("1 solid")));
    if (FAILED(hr))
        goto Cleanup;

    if (_pSelectInPopup)
    {
        if (_fWritingModeTBRL)
        {
            bstrWritingMode = _T("tb-rl");
        }
        hr = _pSelectInPopup->SetWritingMode(bstrWritingMode);
        goto Cleanup;
    }

#ifdef  NEVER

    hr = pStyleBody->put_margin(CComBSTR(_T("0")));
    if (FAILED(hr))
        goto Cleanup;

    hr = pStyleBody->put_padding(CComBSTR(_T("0")));
    if (FAILED(hr))
        goto Cleanup;

    hr = pStyleBody->put_overflow(CComBSTR(_T("hidden")));
    if (FAILED(hr))
        goto Cleanup;

#endif

    //
    // Create a SELECT element
    //

    hr = GetNumOptions(&lSize);
    if (FAILED(hr))
        goto Cleanup;

    if (lSize <= 1)
    {
        lSize = 2;
    }

    _ltot(min(lSize, SELECT_MAXOPTIONS), strNum, 10);

    hr = a.Elem()->get_innerHTML(&bstrHTML);
    if (FAILED(hr))
        goto Cleanup;

    bstr = bstrImport;

    bstrTemp = _T("<IE:select size=");
    bstr += bstrTemp;

    bstrTemp = strNum;
    bstr += bstrTemp;

    bstrTemp = _T(" style='border:none;margin:0px'>");
    bstr += bstrTemp;

    bstr += bstrHTML;

    bstrTemp = _T("</IE:select>");
    bstr += bstrTemp;

    hr = pElemBODY->put_innerHTML(bstr);
    if (FAILED(hr))
        goto Cleanup;

    hr = pElemBODY->get_children((IDispatch**)&pItems);
    if (FAILED(hr))
        goto Cleanup;

    hr = pItems->item(var, var2, &pDispatchItem);
    if (FAILED(hr))
        goto Cleanup;

    if (!pDispatchItem)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pDispatchItem->QueryInterface(IID_IPrivateSelect, (void**)&_pSelectInPopup);
    if (FAILED(hr))
        goto Cleanup;

    hr = _pSelectInPopup->SetInPopup(_pPopup);
    if (FAILED(hr))
        goto Cleanup;

    hr = _pSelectInPopup->InitOptions();
    if (FAILED(hr))
        goto Cleanup;

#ifndef SELECT_GETSIZE
    hr = pDispatchItem->QueryInterface(IID_IHTMLElement, (void**)&pElem);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Set the width/height of the popup's select
    //
    hr = pElem->get_style(&pStyle);
    if (FAILED(hr))
        goto Cleanup;

    V_VT(&var) = VT_I4;
    if (_fWritingModeTBRL)
    {
        V_I4(&var) = _lPopupSize.cy;
    }
    else
    {
        V_I4(&var) = _lPopupSize.cx;
    }
    hr = pStyle->put_width(var);
    if (FAILED(hr))
        goto Cleanup;

    if (_fWritingModeTBRL)
    {
        V_I4(&var) = _lPopupSize.cx;
    }
    else
    {
        V_I4(&var) = _lPopupSize.cy;
    }
    hr = pStyle->put_height(var);
    if (FAILED(hr))
        goto Cleanup;

    _lPopupSize.cx += 2;
    _lPopupSize.cy += 2;
#endif

Cleanup:
    ReleaseInterface(pElemBODY);
    ReleaseInterface(pDocThis);
    ReleaseInterface(pDoc2);
    ReleaseInterface(pItems);
    ReleaseInterface(pDispatchItem);
    ReleaseInterface(pStyleBody);
#ifndef SELECT_GETSIZE
    ReleaseInterface(pStyle);
    ReleaseInterface(pElem);
#endif

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnFocus()
//
// Synopsis:    Update focus information.
//
// Arguments:   CEventObjectAccess *pEvent - Event information
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::OnFocus(CEventObjectAccess *pEvent)
{
    if (SELECT_ISDROPBOX(_fFlavor))
    {
        return SetDisplayHighlight(TRUE);
    }

    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnBlur()
//
// Synopsis:    When SELECT loses focus, the focused OPTION should
//              lose focus as well.
//
// Arguments:   CEventObjectAccess *pEvent - Event information
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::OnBlur(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    if (SELECT_ISDROPBOX(_fFlavor))
    {
        
        hr = HidePopup();
        if (FAILED(hr))
            goto Cleanup;

        hr = SetDisplayHighlight(FALSE);
        if (FAILED(hr))
            goto Cleanup;
            
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SetDisplayHighlight()
//
// Synopsis:    Sets the highlighted state of the dropbox display.
//
// Arguments:   BOOL bOn -  Indicates whether the display should be
//                          highlighted.
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::SetDisplayHighlight(BOOL bOn)
{
    HRESULT         hr;
    CComBSTR        bstrBack;
    CComBSTR        bstrText;
    CVariant        var;
    long            lNumOptions;
    VARIANT_BOOL    bOpen;
    IHTMLStyle      *pStyle     = NULL;

    hr = GetNumOptions(&lNumOptions);
    if (FAILED(hr))
        goto Cleanup;

    if ((lNumOptions > 0) && _pPopup && _pElemDisplay)
    {
        hr = _pPopup->get_isOpen(&bOpen);
        if (FAILED(hr))
            goto Cleanup;

        if (bOn && !bOpen)
        {
            bstrBack = _T("highlight");
            bstrText = _T("highlighttext");
        }
        else
        {
            bstrBack = _T("");
            bstrText = _T("");
        }

        hr = _pElemDisplay->get_style(&pStyle);
        if (FAILED(hr))
            goto Cleanup;

        hr = pStyle->put_background(bstrBack);
        if (FAILED(hr))
            goto Cleanup;

        V_VT(&var) = VT_BSTR;
        V_BSTR(&var) = (BSTR)bstrText;
        hr = pStyle->put_color(var);
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pStyle);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnMouseDown()
//
// Synopsis:    Start a drag in listboxes.
//              Toggles the popup open/closed in a dropbox.
//
// Arguments:   CEventObjectAccess *pEvent - Event information
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::OnMouseDown(CEventObjectAccess *pEvent)
{
    HRESULT             hr;
    VARIANT_BOOL        bDisabled;
    long                lMouseButtons = NULL;

    hr = GetDisabled(&bDisabled);
    if (FAILED(hr) || bDisabled)
        goto Cleanup;

    hr = pEvent->GetMouseButtons(&lMouseButtons);
    if (FAILED(hr))
        goto Cleanup;

    if (lMouseButtons & EVENT_LEFTBUTTON)
    {
        if (SELECT_ISDROPBOX(_fFlavor))
        {
            hr = TogglePopup();
            if (FAILED(hr))
                goto Cleanup;

            hr = SetDisplayHighlight(TRUE);
            if (FAILED(hr))
                goto Cleanup;
        }
        else if (!SELECT_ISINPOPUP(_fFlavor))
        {
            // Just in case a previous drag was not completed
            hr = FinishDrag();
            if (FAILED(hr))
                goto Cleanup;

            // Start the new drag
            hr = StartDrag();
            if (FAILED(hr))
                goto Cleanup;
        }
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnMouseOver()
//
// Synopsis:    Used to hang onto the current popup state.  Mouse events out of
//              our control can shut the popup without our knowledge. This gives
//              us that knowledge.
//
// Arguments:   CEventObjectAccess *pEvent - Event information
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::OnMouseOver(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    if (_pPopup)
    {
        hr = _pPopup->get_isOpen(&_bPopupOpen);
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnMouseOut()
//
// Synopsis:    Used to hang onto the current popup state. Mouse events out of
//              our control can shut the popup without our knowledge.  This gives
//              us that knowledge.
//
// Arguments:   CEventObjectAccess *pEvent - Event information
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::OnMouseOut(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    if (_pPopup)
    {
        hr = _pPopup->get_isOpen(&_bPopupOpen);
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnMouseUp()
//
// Synopsis:    Finish a drag and commit all changes.
//
// Arguments:   CEventObjectAccess *pEvent - Event information
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::OnMouseUp(CEventObjectAccess *pEvent)
{
    HRESULT             hr;
    VARIANT_BOOL        bDisabled;
    long                lKeyboardStatus = NULL;
    POINT               ptElem;

    hr = GetDisabled(&bDisabled);
    if (FAILED(hr) || bDisabled)
        goto Cleanup;

    if (_fDragMode)
    {
        // Stop the drag
        hr = FinishDrag();
        if (FAILED(hr))
            goto Cleanup;

        hr = pEvent->GetParentCoordinates(&ptElem);
        if (FAILED(hr))
            goto Cleanup;

        hr = pEvent->GetKeyboardStatus(&lKeyboardStatus);
        if (FAILED(hr))
            goto Cleanup;

        // Make final selection changes
        hr = HandleDownXY(ptElem, lKeyboardStatus & EVENT_CTRLKEY);
        if (FAILED(hr))
            goto Cleanup;
    }

    // Commit all selection changes
    hr = FireOnChange();
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnMouseMove()
//
// Synopsis:    Handle drag select.
//
// Arguments:   CEventObjectAccess *pEvent - Event information
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::OnMouseMove(CEventObjectAccess *pEvent)
{
    HRESULT             hr = S_OK;
    long                lMouseButtons   = NULL;
    long                lKeyboardStatus = NULL;
    POINT               ptElem;

    if (!_fDragMode)
        goto Cleanup;

    hr = ClearScrollTimeout();
    if (FAILED(hr))
        goto Cleanup;

    hr = pEvent->GetMouseButtons(&lMouseButtons);
    if (FAILED(hr))
        goto Cleanup;

    if (lMouseButtons & EVENT_LEFTBUTTON)
    {
        hr = pEvent->GetParentCoordinates(&ptElem);
        if (FAILED(hr))
            goto Cleanup;

        hr = pEvent->GetKeyboardStatus(&lKeyboardStatus);
        if (FAILED(hr))
            goto Cleanup;

        // Make selection changes
        hr = HandleDownXY(ptElem, lKeyboardStatus & EVENT_CTRLKEY);
        if (FAILED(hr))
            goto Cleanup;
    }
    else
    {
        // A different mouse button is down, finish this drag
        hr = FinishDrag();
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::StartDrag()
//
// Synopsis:    Capture the mouse, get focus, engage drag mode.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::StartDrag()
{
    HRESULT         hr;
    CContextAccess  a(_pSite);

    if (_fDragMode)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = a.Open(CA_ELEM2);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem2()->setCapture();
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem2()->focus();
    if (FAILED(hr))
        goto Cleanup;

    _fDragMode = TRUE;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::FinishDrag()
//
// Synopsis:    Release the mouse, kill scroll timer, disengage drag mode.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::FinishDrag()
{
    HRESULT         hr;
    CContextAccess  a(_pSite);

    if (!_fDragMode)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = ClearScrollTimeout();
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Open(CA_ELEM2);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem2()->releaseCapture();
    if (FAILED(hr))
        goto Cleanup;

    _fDragMode = FALSE;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::HandleDownXY()
//
// Synopsis:    Performs special "clicks" during a drag.
//
// Arguments:   POINT pt        - Location of the mouse
//              BOOL bCtrlKey   - TRUE if the CTRL key is down
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::HandleDownXY(POINT pt, BOOL bCtrlKey)
{
    HRESULT             hr;
    long                lIndex;
    BOOL                bNeedTimer;
    long                lXY;

    Assert(!SELECT_ISINPOPUP(_fFlavor));

    if (_fWritingModeTBRL)
    {
        lXY = pt.x;
    }
    else
    {
        lXY = pt.y;
    }

    hr = GetOptionIndexFromY(lXY, &lIndex, &bNeedTimer);
    if (FAILED(hr))
        goto Cleanup;

    if ((hr == S_FALSE) || (_lFocusIndex == lIndex))
    {
        // No need to do any selecting, so stop
        hr = S_OK;
        goto Cleanup;
    }

    // Select the option
    hr = OnOptionSelected(VARIANT_TRUE, lIndex, SELECT_EXTEND);
    if (FAILED(hr))
        goto Cleanup;

    // Check for drag mode since this could be the last call
    if (bNeedTimer && _fDragMode)
    {
        // The mouse is either above or below the control,
        // so set a timer to get the control to scroll.
        SetScrollTimeout(pt, bCtrlKey);
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetOptionIndexFromY()
//
// Synopsis:    Determines the index of the option based on lY.
//
// Arguments:   long lY             - The Y coordinate
//              long *plIndex       - Returns the index
//              BOOL *pbNeedTimer   - Returns whether Y is 
//                                    above/below the control
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::GetOptionIndexFromY(long lY, long *plIndex, BOOL *pbNeedTimer)
{
    HRESULT             hr;
    long                lTopIndex;
    long                lBottomIndex;
    long                lNumOptions;
    long                lIndex;
    long                lTop;
    long                lScrollTop;
    long                lClientTop;
    long                lLeft;
    long                lScrollLeft;
    long                lClientLeft;


    IHTMLElement        *pElemParent    = NULL;
    IHTMLElement        *pElem          = NULL;
    IHTMLElement2       *pElem2         = NULL;
    CContextAccess      a(_pSite);

    Assert(plIndex && pbNeedTimer);

    *pbNeedTimer = FALSE;

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Convert the mouse points relative to the upper left
    // corner of the select's client rectangle.
    //
    pElem = a.Elem();
    pElem->AddRef();

    hr = pElem->QueryInterface(IID_IHTMLElement2, (void**)&pElem2);
    if (FAILED(hr))
        goto Cleanup;

    // Go through all the parents to calculate the correct offset
    while (true)
    {
        if (_fWritingModeTBRL) 
        {
            hr = pElem->get_offsetLeft(&lLeft);
            if (FAILED(hr))
                goto Cleanup;

            hr = pElem2->get_clientLeft(&lClientLeft);
            if (FAILED(hr))
                goto Cleanup;

            lY -= lLeft + lClientLeft;
        }
        else
        {
            hr = pElem->get_offsetTop(&lTop);
            if (FAILED(hr))
                goto Cleanup;

            hr = pElem2->get_clientTop(&lClientTop);
            if (FAILED(hr))
                goto Cleanup;

            lY -= lTop + lClientTop;
        }

        hr = pElem->get_offsetParent(&pElemParent);
        if (FAILED(hr))
            goto Cleanup;

        if (pElemParent == NULL)
        {
            break;
        }

        ClearInterface(&pElem);
        ClearInterface(&pElem2);

        pElem = pElemParent;
        pElemParent = NULL;

        hr = pElem->QueryInterface(IID_IHTMLElement2, (void**)&pElem2);
        if (FAILED(hr))
            goto Cleanup;

        if (_fWritingModeTBRL)
        {
            hr = pElem2->get_scrollLeft(&lScrollLeft);
            if (FAILED(hr))
                goto Cleanup;
        
            lY += lScrollLeft;
        }
        else
        {

            hr = pElem2->get_scrollTop(&lScrollTop);
            if (FAILED(hr))
                goto Cleanup;

            lY += lScrollTop;
        }
    }

    //
    // Calculate the clicked index
    //
    hr = GetTopVisibleOptionIndex(&lTopIndex);
    if (FAILED(hr))
        goto Cleanup;

    if (lY < 0)
    {
        //
        // If lY is negative, we need to subtract an extra height
        // so that the match will come out right when the division
        // truncates the remainder.
        //
        // We also want to restrict the index to only one option
        // beyond the visible range of the control.
        //
        lY = -_lMaxHeight;
        *pbNeedTimer = TRUE;
    }

    lIndex = (lY / _lMaxHeight) + lTopIndex;

    hr = GetBottomVisibleOptionIndex(&lBottomIndex);
    if (FAILED(hr))
        goto Cleanup;

    // If the writingmode is "tb-rl", the count which is made from left has to be transformed to the
    // count from right.
    if (_fWritingModeTBRL)
    {
        lIndex = lBottomIndex - lIndex -1;
    }
    if (lIndex >= lBottomIndex)
    {
        //
        // We want to restrict the index to only one option
        // beyond the visible range of the control.
        //
        lIndex = lBottomIndex;
        *pbNeedTimer = TRUE;
    }

    //
    // Make sure the index is valid
    //
    hr = GetNumOptions(&lNumOptions);
    if (FAILED(hr))
        goto Cleanup;

    if ((lIndex >= 0) && (lIndex < lNumOptions))
    {
        // Success!
        *plIndex = lIndex;
        hr = S_OK;
    }
    else
    {
        // Invalid index
        hr = S_FALSE;
    }

Cleanup:
    ReleaseInterface(pElem);
    ReleaseInterface(pElem2);
    ReleaseInterface(pElemParent);

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnKeyDown()
//
// Synopsis:    Changes the selection based on the key pressed.
//
// Arguments:   CEventObjectAccess *pEvent - Event information
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::OnKeyDown(CEventObjectAccess *pEvent)
{
    HRESULT             hr;
    DWORD               dwFlags = 0;
    long                lNumOptions;
    long                lSize;
    long                lKeyboardStatus = 0;
    long                lKeyCode;
    VARIANT_BOOL        bDisabled;
    VARIANT_BOOL        bSelected;
    VARIANT_BOOL        bIsOpen;
    BOOL                bCancelEvent = FALSE;
    IPrivateOption      *pOption = NULL;

    hr = GetDisabled(&bDisabled);
    if (FAILED(hr) || bDisabled)
        goto Cleanup;

    hr = GetNumOptions(&lNumOptions);
    if (FAILED(hr) || (lNumOptions == 0))   // No need to do anything if no options
        goto Cleanup;

    hr = pEvent->GetKeyboardStatus(&lKeyboardStatus);
    if (FAILED(hr))
        goto Cleanup;

    dwFlags |= (lKeyboardStatus & EVENT_ALTKEY)    ? SELECT_ALT    : 0;
    dwFlags |= (lKeyboardStatus & EVENT_SHIFTKEY)  ? SELECT_SHIFT  : 0;
    dwFlags |= (lKeyboardStatus & EVENT_CTRLKEY)   ? SELECT_CTRL   : 0;

    hr = pEvent->GetKeyCode(&lKeyCode);
    if (FAILED(hr))
        goto Cleanup;

    switch (lKeyCode)
    {
    case VK_UP:
    case VK_DOWN:
        if (SELECT_ISDROPBOX(_fFlavor))
        {
            Assert(_pPopup && _pSelectInPopup);

            hr = _pPopup->get_isOpen(&bIsOpen);
            if (FAILED(hr))
                goto Cleanup;

            if (lKeyboardStatus & EVENT_ALTKEY)
            {
                if (bIsOpen)
                {
                    hr = _pSelectInPopup->SelectCurrentOption(dwFlags);
                    if (FAILED(hr))
                        goto Cleanup;
                }
                else
                {
                    hr = ShowPopup();
                    if (FAILED(hr))
                        goto Cleanup;
                }
            }
            else
            {
                BOOL bChanged;

                hr = _pSelectInPopup->MoveFocusByOne(lKeyCode == VK_UP, dwFlags | (!bIsOpen ? SELECT_FIREEVENT : 0));
                if (FAILED(hr))
                    goto Cleanup;

                hr = _pSelectInPopup->CommitSelection(&bChanged);
                if (FAILED(hr))
                    goto Cleanup;

                if (bChanged)
                {
                    hr = SynchSelWithPopup();
                    if (FAILED(hr))
                        goto Cleanup;
                }
            }
        }
        else if ( SELECT_ISINPOPUP(_fFlavor))
        {

            VARIANT_BOOL bOpen;
            long         lSize;
            long         lPrevIndex;
            long         lTopOptionIndex;
            long         lBottomOptionIndex;

            Assert(_pPopup);

            Assert(_pLastHighlight);



            hr = _pLastHighlight->GetIndex(&lPrevIndex);
            if (FAILED(hr))
                goto Cleanup;

            hr = get_size(&lSize);
            if (FAILED(hr))
                goto Cleanup;

            hr = GetTopVisibleOptionIndex(&lTopOptionIndex);
            if (FAILED(hr))
                goto Cleanup;

            hr = GetBottomVisibleOptionIndex(&lBottomOptionIndex);
            if (FAILED(hr))
                goto Cleanup;

            hr = _pLastHighlight->SetHighlight(VARIANT_FALSE);
            if (FAILED(hr))
                goto Cleanup;

            if ( lKeyCode == VK_DOWN)
            {
                _lFocusIndex = (lNumOptions == (lPrevIndex +1)) ? lPrevIndex : lPrevIndex +1 ;
            }
            else 
            {
                _lFocusIndex = ( lPrevIndex == 0 ) ? lPrevIndex : lPrevIndex -1 ;
            }

            hr = GetIndex(_lFocusIndex , &pOption);
            if (FAILED(hr) || !pOption)
                goto Cleanup;

            hr = pOption->SetIndex(VARIANT_TRUE);
            if (FAILED(hr))
                goto Cleanup;

            // Highlight the item
            hr = pOption->SetHighlight(VARIANT_TRUE);
            if (FAILED(hr))
                goto Cleanup;

            if (_pLastHighlight)
            {
                ClearInterface(&_pLastHighlight);
            }

            _pLastHighlight = pOption;
            _pLastHighlight->AddRef();

            hr = OnOptionFocus(_lFocusIndex, VARIANT_TRUE);
            if (FAILED(hr))
                goto Cleanup;

            hr = _pLastHighlight -> SetSelected(VARIANT_TRUE);
            if (FAILED(hr))
                goto Cleanup;

            hr = _pLastHighlight -> SetIndex(_lFocusIndex);
            if (FAILED(hr))
                goto Cleanup;


            if ( ((lKeyCode == VK_UP) && ((lBottomOptionIndex  - lPrevIndex) == lSize)) ||
                 ((lKeyCode == VK_DOWN) && ((lPrevIndex - lTopOptionIndex) == lSize - 1  )) )
            {                   
                hr = MakeOptionVisible(pOption);
                if (FAILED(hr))
                    goto Cleanup;
            }
        }
        else if (!(lKeyboardStatus & EVENT_ALTKEY))
        {
            hr = MoveFocusByOne(lKeyCode == VK_UP, dwFlags | SELECT_FIREEVENT);
            if (FAILED(hr))
                goto Cleanup;
        }
        
        bCancelEvent = TRUE;
        break;

    case VK_SPACE:
        if (SELECT_ISMULTIPLE(_fFlavor))
        {
            // Select the current OPTION
            hr = OnOptionClicked(_lFocusIndex, dwFlags | SELECT_FIREEVENT);
            if (FAILED(hr))
                goto Cleanup;
        }

        bCancelEvent = TRUE;
        break;

    case VK_RETURN:
        if (SELECT_ISDROPBOX(_fFlavor))
        {
            // Select the current OPTION
            Assert(_pSelectInPopup);

            hr = _pSelectInPopup->SelectCurrentOption(dwFlags);
            if (FAILED(hr))
                goto Cleanup;
        }
        else if ( SELECT_ISINPOPUP(_fFlavor))
        {
            hr = OnOptionClicked(_lFocusIndex, dwFlags | SELECT_FIREEVENT);
            if (FAILED(hr))
                goto Cleanup;

        }
        bCancelEvent = TRUE;
        break;

    case VK_HOME:
        hr = OnOptionClicked(0, dwFlags | SELECT_FIREEVENT);
        if (FAILED(hr))
            goto Cleanup;

        bCancelEvent = TRUE;
        break;

    case VK_END:
        hr = OnOptionClicked(lNumOptions - 1, dwFlags | SELECT_FIREEVENT);
        if (FAILED(hr))
            goto Cleanup;

        bCancelEvent = TRUE;
        break;

    case VK_PRIOR:
        hr = PushFocusToExtreme(FALSE);
        if (FAILED(hr))
            goto Cleanup;

        hr = SelectVisibleIndex(0);
        if (FAILED(hr))
            goto Cleanup;

        bCancelEvent = TRUE;
        break;

    case VK_NEXT:
        hr = PushFocusToExtreme(TRUE);
        if (FAILED(hr))
            goto Cleanup;

        hr = get_size(&lSize);
        if (FAILED(hr))
            goto Cleanup;

        hr = SelectVisibleIndex(lSize - 1);
        if (FAILED(hr))
            goto Cleanup;

        bCancelEvent = TRUE;
        break;

    case VK_ESCAPE:
        if (SELECT_ISDROPBOX(_fFlavor))
        {
            hr = SetDisplayHighlight(TRUE);
            if (FAILED(hr))
                goto Cleanup;
        }
        bCancelEvent = TRUE;
        break;

    default:
        //
        // If the keypressed can be displayed on screen,
        // then look for it in the options.
        //
        if (_istgraph((TCHAR)lKeyCode))
        {
            hr = SelectByKey(lKeyCode);
            if (FAILED(hr))
                goto Cleanup;
        }

        // Forces WM_CHAR to be generated when handling OnKeyDown
        hr = S_FALSE;
        break;
    }

    if (bCancelEvent)
    {
        hr = CancelEvent(pEvent);
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    if ( pOption )
        ReleaseInterface(pOption);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::MoveFocusByOne()
//
// Synopsis:    Moves the focus up/down by one.
//
// Arguments:   BOOL bUp        - TRUE if moving up
//              DWORD dwFlags   - Keyboard status flags
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIESelectElement::MoveFocusByOne(BOOL bUp, DWORD dwFlags)
{
    HRESULT         hr;
    long            lNumOptions;
    long            lDir        = bUp   ? -1    : 1;
    IPrivateOption  *pOption    = NULL;

    // No options, nothing to do
    hr = GetNumOptions(&lNumOptions);
    if (FAILED(hr))
        goto Cleanup;

    // Trying to move beyond an extreme, stop
    if ((bUp && (_lFocusIndex <= 0)) || 
        (!bUp && (_lFocusIndex >= (lNumOptions - 1))))
        goto Cleanup;

    if (SELECT_ISMULTIPLE(_fFlavor) && (dwFlags & SELECT_CTRL))
    {
        // Move the focus
        hr = OnOptionFocus(_lFocusIndex + lDir);
        if (FAILED(hr))
            goto Cleanup;

        hr = GetIndex(_lFocusIndex, &pOption);
        if (FAILED(hr))
            goto Cleanup;

        hr = MakeOptionVisible(pOption);
        if (FAILED(hr))
            goto Cleanup;
    }
    else
    {
        // Select the option
        hr = OnOptionClicked(_lFocusIndex + lDir, dwFlags);
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pOption);

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SelectCurrentOption()
//
// Synopsis:    Selects the option that currently has focus.
//
// Arguments:   DWORD dwFlags   - Keyboard status flags
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIESelectElement::SelectCurrentOption(DWORD dwFlags)
{
    return OnOptionClicked(_lFocusIndex, dwFlags | SELECT_FIREEVENT);
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SelectByKey()
//
// Synopsis:    Selects the next option that begins with the given key.
//              Loops around, if the end is reached.
//
// Arguments:   long lKey   - The character to look for
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::SelectByKey(long lKey)
{
    HRESULT         hr;
    long            lNumOptions;
    long            lStart;
    long            lIndex;
    IPrivateOption  *pOption = NULL;

    hr = GetNumOptions(&lNumOptions);
    if (FAILED(hr))
        goto Cleanup;

    lStart = _lFocusIndex + 1;
    if (lStart >= lNumOptions)
    {
        lStart = 0;
    }

    // Search from the start index to the last option
    hr = SearchForKey(lKey, lStart, lNumOptions - 1, &lIndex);
    if (FAILED(hr))
        goto Cleanup;

    if ((hr == S_FALSE) && (lStart > 0))
    {
        //
        // If the previous search did not find anything,
        // then search from index 0 to just before the
        // previous start index.
        //
        hr = SearchForKey(lKey, 0, lStart - 1, &lIndex);
        if (FAILED(hr))
            goto Cleanup;
    }

    if (hr == S_OK)
    {
        // Select the found option
        hr = OnOptionClicked(lIndex, SELECT_FIREEVENT);
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pOption);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SelectByKey()
//
// Synopsis:    Selects the next option that begins with the given key.
//              Loops around, if the end is reached.
//
// Arguments:   long lKey       - The character to look for
//              long lStart     - The first index to check
//              long lEnd       - The last index to check
//              long *plIndex   - The index of the found option (or -1)
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::SearchForKey(long lKey, long lStart, long lEnd, long *plIndex)
{
    HRESULT                 hr;
    IHTMLElementCollection  *pItems         = NULL;
    IDispatch               *pItem          = NULL;
    IHTMLElement            *pOption        = NULL;
    long                    iItem;
    CComBSTR                bstr;
    CVariant                var, var2;
    CContextAccess          a(_pSite);

    Assert(plIndex);

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_children((IDispatch**)&pItems);
    if (FAILED(hr))
        goto Cleanup;

    V_VT(&var) = VT_I4;
    for (iItem = lStart; iItem <= lEnd; iItem++)
    {
        V_I4(&var) = iItem;
        hr = pItems->item(var, var2, &pItem);
        if (FAILED(hr))
            goto Cleanup;

        hr = pItem->QueryInterface(IID_IHTMLElement, (void**)&pOption);
        if (FAILED(hr))
        {
            ClearInterface(&pItem);
            continue;
        }

        hr = pOption->get_innerText(&bstr);
        if (FAILED(hr))
            goto Cleanup;

        if (    bstr.m_str
            &&  bstr.m_str[0]
            &&  _totupper((TCHAR)bstr[0]) == _totupper((TCHAR)lKey))
        {
            // An option is found
            *plIndex = iItem;
            hr = S_OK;
            goto Cleanup;
        }

        ClearInterface(&pOption);
        ClearInterface(&pItem);
    }

    // No option found
    hr = S_FALSE;

Cleanup:
    ReleaseInterface(pOption);
    ReleaseInterface(pItem);
    ReleaseInterface(pItems);

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnPropertyChange()
//
// Synopsis:    Allows setting of a global variable about the writingmode.
//
// Arguments:   CEventObjectAccess *pEvent - Event info
//              BSTR bstr
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::OnPropertyChange(CEventObjectAccess *pEvent, BSTR bstr)
{
    HRESULT             hr = S_OK;


    if (!StrCmpICW(bstr, L"style.writingMode"))
    {
        hr = SetWritingModeFlag();
        if (FAILED(hr))
            goto Cleanup;

        hr = RefreshView();
        if (FAILED(hr))
           goto Cleanup;
    }

Cleanup:
    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SetWritingModeFlag()
//
// Synopsis:    The _fWritingModeTBRL flag is set properly based on
//              the writingmode.
//
// Arguments:   None.
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement:: SetWritingModeFlag()
{
    CContextAccess  a(_pSite);
    HRESULT         hr = S_OK;
    CComBSTR        bstrWritingMode(_T(""));

    hr = a.Open(CA_STYLE3);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Style3()->get_writingMode(&bstrWritingMode);
    if (FAILED(hr))
        goto Cleanup;

    if(!bstrWritingMode || StrCmpICW(bstrWritingMode, L"tb-rl")) 
    {
        _fWritingModeTBRL = FALSE;
    }
    else
    {
        _fWritingModeTBRL = TRUE;
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SetPixelHeightWidth()
//
// Synopsis:    The pixelheight and pixelwidth are set accordingly 
//              based on the writingmode.
//
// Arguments:   None.
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement:: SetPixelHeightWidth()
{
    CContextAccess  a(_pSite);
    HRESULT         hr = S_OK;
    long            lWidth;
    long            lHeight;
    long            lButtonWidth;

    hr = a.Open(CA_DEFSTYLE);
    if (FAILED(hr))
        goto Cleanup;

    // Get the width of the button
    lButtonWidth = GetSystemMetrics(SM_CXVSCROLL);

    if (_fWritingModeTBRL)
    {
        lWidth = _sizeOptionReported.cy + 2;
        lHeight = lButtonWidth;
    }
    else
    {
        lWidth = lButtonWidth;
        lHeight = _sizeOptionReported.cy + 2;
    }

    // Set the height
    hr = a.DefStyle()->put_pixelHeight(lHeight);
    if (FAILED(hr))
        goto Cleanup;

    // Set the width
    hr = a.DefStyle()->put_pixelWidth(lWidth);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}
//+------------------------------------------------------------------
//
// Member:      CIESelectElement::RefreshView()
//
// Synopsis:    The view has to be changed after the writing mode is changed.
//
// Arguments:   None.
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement:: RefreshView()
{
    HRESULT         hr = S_OK;
    CContextAccess  a(_pSite);
    CComBSTR        bstrWritingMode(_T(""));
    CVariant        var;
    long            lWidth;
    long            lHeight;
    long            lButtonWidth;

    hr = a.Open(CA_DEFSTYLE);
    if (FAILED(hr))
        goto Cleanup;


    if(SELECT_ISLISTBOX(_fFlavor))
    {
        if (_fWritingModeTBRL)
        {
            hr = SetPixelHeightWidth();
            if (FAILED(hr))
                goto Cleanup;
        }
    }

    if (SELECT_ISDROPBOX(_fFlavor))
    {
        if (_fWritingModeTBRL)
        {
            bstrWritingMode = _T("tb-rl");
        }

        hr = SetWritingMode(bstrWritingMode);
        if (FAILED(hr))
            goto Cleanup;

        hr = UpdatePopup();
        if (FAILED(hr))
            goto Cleanup;

        if (_pElemDisplay)
        {
            hr = SetupDisplay(_pElemDisplay);
            if (FAILED(hr))
                goto Cleanup;

            _pElemDisplay->Release();

            hr = SetupDropControlDimensions();
            if (FAILED(hr))
                goto Cleanup;
        }
    }

Cleanup:
    return hr;
}
//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnSelectStart()
//
// Synopsis:    Cancels selection.
//
// Arguments:   CEventObjectAccess *pEvent - Event information
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::OnSelectStart(CEventObjectAccess *pEvent)
{
    return CancelEvent(pEvent);
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnScroll()
//
// Synopsis:    Cancels scroll.
//
// Arguments:   CEventObjectAccess *pEvent - Event information
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::OnScroll(CEventObjectAccess *pEvent)
{
    return RefreshFocusRect();
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnContextMenu()
//
// Synopsis:    Cancels menu.
//
// Arguments:   CEventObjectAccess *pEvent - Event information
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::OnContextMenu(CEventObjectAccess *pEvent)
{
    return CancelEvent(pEvent);
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::CancelEvent()
//
// Synopsis:    Cancels the event.
//
// Arguments:   CEventObjectAccess *pEvent - Event information
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::CancelEvent(CEventObjectAccess *pEvent)
{
    HRESULT     hr;
    CVariant    var;

    V_VT(&var) = VT_BOOL;
    V_BOOL(&var) = VARIANT_FALSE;
    hr = pEvent->EventObj()->put_returnValue(var);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
//
// IHTMLSelectElement3 overrides
//
/////////////////////////////////////////////////////////////////////////////


//+------------------------------------------------------------------
//
// Member:      CIESelectElement::clearSelection()
//
// Synopsis:    Deselects all of the OPTION elements.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::clearSelection()
{
    HRESULT hr = S_OK;

    if (SELECT_ISMULTIPLE(_fFlavor))
    {
        hr = SetAllSelected(VARIANT_FALSE, SELECT_FIREEVENT);
        if (FAILED(hr))
            goto Cleanup;
    }

    // Don't allow single-select to deselect

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::selectAll()
//
// Synopsis:    Selects all of the OPTION elements.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::selectAll()
{
    HRESULT hr;
    long    lNumOptions;

    if (SELECT_ISMULTIPLE(_fFlavor))
    {
        hr = SetAllSelected(VARIANT_TRUE, SELECT_FIREEVENT);
        if (FAILED(hr))
            goto Cleanup;
    }
    else
    {
        // Single select selects the last element

        hr = GetNumOptions(&lNumOptions);
        if (FAILED(hr) || (lNumOptions == 0))
            goto Cleanup;

        hr = OnOptionSelected(VARIANT_TRUE, lNumOptions - 1, SELECT_FIREEVENT);
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::put_name()
//
// Synopsis:    Sets the name of the select.
//
// Arguments:   BSTR bstrName - The new name
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::put_name(BSTR bstrName)
{
    return GetProps()[eName].Set(bstrName);
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::get_name()
//
// Synopsis:    Retrieves the name of the select.
//
// Arguments:   BSTR *pbstrName - Receives the value
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::get_name(BSTR *pbstrName)
{
    return GetProps()[eName].Get(pbstrName);
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::put_size()
//
// Synopsis:    Sets the size of the SELECT.
//
// Arguments:   long lSize - The new size
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::put_size(long lSize)
{
    HRESULT         hr          = S_OK;
    VARIANT_BOOL    bMult;
    CVariant        var;
    long            lPrevSize;
    CContextAccess  a(_pSite);

    if (lSize < 1)
    {
        return E_INVALIDARG;
    }
    else
    {
        get_size(&lPrevSize);

        if (lPrevSize == lSize)
        {
            // No need to change.
            return S_OK;
        }

        hr = GetProps()[eSize].Set(lSize);
        if (FAILED(hr))
            goto Cleanup;

#ifdef SELECT_GETSIZE
        hr = get_multiple(&bMult);
        if (FAILED(hr))
            goto Cleanup;

        // Detect major change
        if ((lSize == 1) && SELECT_ISLISTBOX(_fFlavor) && !bMult)
        {
            hr = BecomeDropBox();
            if (FAILED(hr))
                goto Cleanup;
        }
        else if ((lSize > 1) && SELECT_ISDROPBOX(_fFlavor))
        {
            hr = BecomeListBox();
            if (FAILED(hr))
                goto Cleanup;
        }
        else
        {
            // Reset the height --> CalcSize gets called
            hr = a.Open(CA_DEFSTYLE);
            if (FAILED(hr))
                goto Cleanup;

            V_VT(&var) = VT_I4;
            V_I4(&var) = _sizeOptionReported.cy * lSize;
            hr = a.DefStyle()->put_height(var);
            if (FAILED(hr))
                goto Cleanup;

            hr = RefreshListBox();
            if (FAILED(hr))
                goto Cleanup;

        }
#endif
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::BecomeListBox()
//
// Synopsis:    Changes a dropbox into a listbox.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::BecomeListBox()
{
    HRESULT hr;

    _sizeOption = _sizeOptionReported;

    hr = DeInitViewLink();
    if (FAILED(hr))
        goto Cleanup;

    _fContentReady = FALSE;

    hr = InitContent();
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::BecomeDropBox()
//
// Synopsis:    Changes a listbox into a dropbox.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::BecomeDropBox()
{
    HRESULT hr;

    _sizeOption = _sizeOptionReported;


    hr = InitContent();
    if (FAILED(hr))
        goto Cleanup;

    hr = InitViewLink();
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::RefreshListBox()
//
// Synopsis:    Refreshes content settings on a listbox.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::RefreshListBox()
{
    HRESULT hr;

    _sizeOption = _sizeOptionReported;

    hr = InitContent();
    if (FAILED(hr))
        goto Cleanup;

    if ( !_fNeedScrollBar)
    {
        AdjustSizeForScrollbar(&_sizeOption);
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::get_size()
//
// Synopsis:    Gets the size of the SELECT.
//
// Arguments:   long *plSize - Receives the size
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::get_size(long *plSize)
{
    return GetProps()[eSize].Get(plSize);
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::put_selectedIndex()
//
// Synopsis:    Sets the index to be selected.  
//              Any currently selected options are unselected.
//
// Arguments:   long lIndex - The index to select
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::put_selectedIndex(long lIndex)
{
    HRESULT             hr;
    IHTMLOptionElement2 *pOption    = NULL;

    hr = clearSelection();
    if (FAILED(hr))
        goto Cleanup;

    hr = GetIndex(lIndex, &pOption);
    if (FAILED(hr))
        goto Cleanup;

    hr = pOption->put_selected(VARIANT_TRUE);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pOption);

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::get_selectedIndex()
//
// Synopsis:    Gets the last index to be selected.
//
// Arguments:   long *plIndex - Receives the index
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::get_selectedIndex(long *plIndex)
{
    if (SELECT_ISMULTIPLE(_fFlavor))
    {
        return GetFirstSelected(plIndex);
    }
    else
    {
        return GetProps()[eSelectedIndex].Get(plIndex);
    }
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::put_multiple()
//
// Synopsis:    Turns multiple selection on/off.
//
// Arguments:   VARIANT_BOOL bMult - VARIANT_TRUE=on VARIANT_FALSE=off
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::put_multiple(VARIANT_BOOL bMult)
{
    HRESULT         hr;
    VARIANT_BOOL    bPrevMult;
    long            lMult = bMult ? 0 : -1;

    hr = get_multiple(&bPrevMult);
    if (FAILED(hr))
        goto Cleanup;

    hr = GetProps()[eMultiple].Set(lMult);
    if (FAILED(hr))
        goto Cleanup;

    if (bPrevMult == bMult)
    {
        // Done
        goto Cleanup;
    }

    if (bMult && SELECT_ISDROPBOX(_fFlavor))
    {
        hr = BecomeListBox();
        if (FAILED(hr))
            goto Cleanup;
    }
    else
    {
        long lSize;

        hr = get_size(&lSize);
        if (FAILED(hr))
            goto Cleanup;

        if (!bMult && (lSize == 1) && SELECT_ISLISTBOX(_fFlavor))
        {
            hr = BecomeDropBox();
            if (FAILED(hr))
                goto Cleanup;
        }
        else
        {
            hr = RefreshListBox();
            if (FAILED(hr))
                goto Cleanup;
        }
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::get_multiple()
//
// Synopsis:    Gets if the SELECT is a multiple select.
//
// Arguments:   VARIANT_BOOL *p - Receives if it is a multiple select
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::get_multiple(VARIANT_BOOL * p)
{
    HRESULT hr;
    long    lMult;

    hr = GetProps()[eMultiple].Get(&lMult);
    if (FAILED(hr))
        goto Cleanup;

    *p = (lMult == -1) ? VARIANT_FALSE : VARIANT_TRUE;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::get_length()
//
// Synopsis:    Retrieves the number of options.
//
// Arguments:   long *plLength - Receives the value
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::get_length(long *plLength)
{
    return GetNumOptions(plLength);
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::get_type()
//
// Synopsis:    Retrieves the name of the select.
//
// Arguments:   BSTR *pbstrType - Receives the value
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::get_type(BSTR *pbstrType)
{
    CComBSTR    bstr;

    if (!pbstrType)
    {
        return E_NOTIMPL;
    }
    Assert(pbstrType);

    if (SELECT_ISMULTIPLE(_fFlavor))
    {
        bstr = _T("select-multiple");
    }
    else
    {
        bstr = _T("select-one");
    }

    *pbstrType = bstr;

    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::get_options()
//
// Synopsis:    Maps to children.
//
// Arguments:   IDispatch **ppOptions - receives children collection
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::get_options(IDispatch ** ppOptions)
{
    HRESULT             hr;
    CComPtr<IDispatch>  pItems;

    CContextAccess a(_pSite);
    
    if (!ppOptions)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    //  Restoring the old way of handling the options collection until
    //  we can sort out the DISPID issue.
    //
    //  This version simply returns the IHTMLElementCollection of children which doesn't 
    //  support Add/Remove, etc.  The new way will again return the select element's
    //  dispatch interface and support the standard collection interface methods directly.
    //

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_children((IDispatch**) &pItems);
    if (FAILED(hr))
        goto Cleanup;

    hr = pItems->QueryInterface(IID_IDispatch, (void **) ppOptions);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::add()
//
// Synopsis:    Adds the element to the options collection
//
// Arguments:   IDispatch *pElement - option element to be added
//              long lIndex - position in collection where the element is to be added
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------

HRESULT 
CIESelectElement::add(IDispatch *pElement, VARIANT varIndex)
{
    HRESULT hr;

    CComPtr<IHTMLOptionElement2> pOption;
    CComPtr<IHTMLElement> pHtml, pParent;

    CVariant var;

    long lIndex;


    Assert(pElement);

    hr = pElement->QueryInterface(__uuidof(IHTMLOptionElement2), (void **) &pOption);
    if (FAILED(hr))
        goto Cleanup;

    hr = var.CoerceVariantArg(&varIndex, VT_I4);
    if (FAILED(hr))
        goto Cleanup;

    lIndex = var.IsEmpty() ? -1 : V_I4(&var);

    if (lIndex < -1)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Check to see if this has already been added and is part of this document
    // by checking to see if it has a parent element already
    // 

    hr = pElement->QueryInterface( __uuidof(IHTMLElement), (void **) &pHtml);
    if (FAILED(hr))
        goto Cleanup;

    hr = pHtml->get_parentElement(&pParent);
    if (FAILED(hr))
        goto Cleanup;

    if(pParent) 
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = AddOptionHelper(pOption, lIndex);
    if (FAILED(hr))
        goto Cleanup;

    if (_pSelectInPopup)
    {
        ClearInterface(&_pSelectInPopup) ;
        UpdatePopup();
    }

Cleanup:

    return hr; 
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::remove()
//
// Synopsis:    Removes the element from the options collection
//
// Arguments:   long lIndex - position in collection of the element that is to be removed
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------

HRESULT 
CIESelectElement::remove(long lIndex)
{
    HRESULT hr;

    if (lIndex < 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = RemoveOptionHelper(lIndex);

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CIESelectElement::AddOptionHelper()
//
// Synopsis:    Inserts the option element into the select's child collection
//
// Arguments:   IHTMLOptionElement2 *pOption - option element to be added
//              long lIndex - position in collection where the element is to be added
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------

HRESULT 
CIESelectElement::AddOptionHelper(IHTMLOptionElement2 *pOption, long lIndex)
{
    HRESULT hr;

    CComPtr<IHTMLElementCollection> pItems;
    CComPtr<IHTMLOptionElement2>    pPrevOption;

    CComPtr<IHTMLDOMNode> pElementNode, pOptionNode, pPrevNode;
    CComVariant vDispatch;

    CContextAccess a(_pSite);

    long cOptions;

    Assert( lIndex >= -1 );

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    // Get number of options

    hr = get_length(&cOptions);
    if (FAILED(hr))
        goto Cleanup;
    
    // Calculate the position of the added item within the child collection

    if ( lIndex == -1 || lIndex >= cOptions) // append
    {
        pPrevNode = NULL;
    }
    else
    {
        // Get the adjacent option if one exists

        hr = GetIndex(lIndex, &pPrevOption);
        if (FAILED(hr))
            goto Cleanup;

        hr = pPrevOption->QueryInterface( __uuidof(IHTMLDOMNode), (void **) &pPrevNode);
        if (FAILED(hr))
            goto Cleanup;
    }

    // Insert the option 

    hr = a.Elem()->QueryInterface( __uuidof(IHTMLDOMNode), (void **) &pElementNode);
    if (FAILED(hr))
        goto Cleanup;

    hr = pOption->QueryInterface( __uuidof(IHTMLDOMNode), (void **) &pOptionNode);
    if (FAILED(hr))
        goto Cleanup;

    vDispatch = pPrevNode;

    hr = pElementNode->insertBefore(pOptionNode, vDispatch, NULL);
    if (FAILED(hr))
        goto Cleanup;


Cleanup:

    return ResetIndexes();
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::remove()
//
// Synopsis:    Removes the option element from the select's child collection
//
// Arguments:   long lIndex - position in collection where the element is to be added
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------

HRESULT 
CIESelectElement::RemoveOptionHelper(long lIndex)
{
    HRESULT hr = S_OK;
 
    CComPtr<IHTMLElementCollection> pItems;
    CComPtr<IHTMLOptionElement2>    pOption;

    CComPtr<IHTMLDOMNode> pElementNode, pOptionNode;

    CContextAccess a(_pSite);

    long cOptions;

    Assert( lIndex >= -1 );

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    // Get number of options

    hr = get_length(&cOptions);
    if (FAILED(hr))
        goto Cleanup;

    // Get the option at the given index

    if(lIndex >= cOptions)
        goto Cleanup;
   
    hr = GetIndex(lIndex, &pOption);
    if (FAILED(hr))
        goto Cleanup;

    // Remove it

    hr = a.Elem()->QueryInterface( __uuidof(IHTMLDOMNode), (void **) &pElementNode);
    if (FAILED(hr))
        goto Cleanup;

    hr = pOption->QueryInterface( __uuidof(IHTMLDOMNode), (void **) &pOptionNode);
    if (FAILED(hr))
        goto Cleanup;

    hr = pElementNode->removeChild(pOptionNode, NULL);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:

    return ResetIndexes();
}


//+------------------------------------------------------------------
//
// Member:      CIESelectElement::ParseChildren()
//
// Synopsis:    Walks through the list of children looking for any elements that 
//              do not support IPrivateOption (and are therefor not ie:option elements)
//              and removes them from the document.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------

HRESULT 
CIESelectElement::ParseChildren()
{
    HRESULT hr;

    CContextAccess a(_pSite);
    CComVariant name, index;

    CComPtr<IHTMLElementCollection> pItems;
    CComPtr<IDispatch> pDispatch;
    CComPtr<IPrivateOption> pOption;
    CComPtr<IHTMLDOMNode> pElementNode, pOptionNode;

    long i, cItems;

    //
    // Get all the children
    // 

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_children((IDispatch**) &pItems);
    if (FAILED(hr))
        goto Cleanup;

    hr = pItems->get_length(&cItems);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->QueryInterface( __uuidof(IHTMLDOMNode), (void **) &pElementNode);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Iterator through the collection looking for those who don't belong
    //

    for (i = cItems - 1; i >= 0; i--) 
    {
        name = i;
        hr = pItems->item(name, index, &pDispatch);
        if (FAILED(hr))
            goto Cleanup;

        //
        // If it's not an option element, remove it; it doesn't belong
        //

        hr = pDispatch->QueryInterface(IID_IPrivateOption, (void **) &pOption);
        if (FAILED(hr))
        {
            hr = pDispatch->QueryInterface( __uuidof(IHTMLDOMNode), (void **) &pOptionNode);
            if (FAILED(hr))
                goto Cleanup;

            hr = pElementNode->removeChild(pOptionNode, NULL);
            if (FAILED(hr))
                goto Cleanup;

            pOptionNode.Release();
        }
             
        pDispatch.Release();
        pOption.Release();
    }

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CIESelectElement::ResetIndexes()
//
// Synopsis:    Sets the index of each child to the current position in the
//              child collection.
//
//              Note: this is only here because of the fact that the option elements
//              hold onto the index.  This should be removed since it makes dealing with
//              the dynamic collection difficult.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------

HRESULT
CIESelectElement::ResetIndexes()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLElementCollection> pItems;
    CComPtr<IDispatch> pDispatch;
    CComPtr<IPrivateOption> pPrivOption;

    CComVariant name, index;

    long i;
    long cOptions;

    // get the option collection and iterate through it

    hr = get_length(&cOptions);
    if (FAILED(hr))
        goto Cleanup;

    for(i = 0; i < cOptions; i++) 
    {
        name = i;
        hr = item(name, index, &pDispatch);
        if (FAILED(hr))
            goto Cleanup;

        hr = pDispatch->QueryInterface(IID_IPrivateOption, (void **) &pPrivOption);
        if (FAILED(hr))
            goto Cleanup;
        
        hr = pPrivOption->SetIndex(i);
        if (FAILED(hr))
            goto Cleanup;  
        
        pDispatch.Release();
        pPrivOption.Release();
    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::get__newEnum()
//
// Synopsis:    Standard get__newEnum collection iterator
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------

HRESULT
CIESelectElement::get__newEnum(IUnknown ** p)
{
    HRESULT hr = S_OK;

    CContextAccess a(_pSite);
    CComPtr<IHTMLElementCollection> pItems;

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_children((IDispatch**) &pItems);
    if (FAILED(hr))
        goto Cleanup;
    
    hr = pItems->get__newEnum(p);
    if(FAILED(hr))
        goto Cleanup;

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::item()
//
// Synopsis:    Gets an item from the options collection.
//
// Arguments:   VARIANT name       - 
//              VARIANT index      -
//              IDispatch ** pdisp - the selected item
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------

HRESULT
CIESelectElement::item(VARIANT name, VARIANT index, IDispatch ** pdisp)
{
    HRESULT hr = S_OK;

    CContextAccess a(_pSite);
    CComPtr<IHTMLElementCollection> pItems;

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_children((IDispatch**) &pItems);
    if (FAILED(hr))
        goto Cleanup;
    
    hr = pItems->item(name, index, pdisp);
    if(FAILED(hr))
        goto Cleanup;

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::tags()
//
// Synopsis:    Commits the highlighted options to being selected.
//
// Arguments:   BOOL *pbChanged - Returns whether anything changed
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------

HRESULT
CIESelectElement::tags(VARIANT tagName, IDispatch ** pdisp)
{
    HRESULT hr = S_OK;

    CContextAccess a(_pSite);
    CComPtr<IHTMLElementCollection> pItems;

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_children((IDispatch**) &pItems);
    if (FAILED(hr))
        goto Cleanup;
    
    hr = pItems->tags(tagName, pdisp);
    if(FAILED(hr))
        goto Cleanup;

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::CommitSingleSelection()
//
// Synopsis:    Commits the highlighted options to being selected.
//
// Arguments:   BOOL *pbChanged - Returns whether anything changed
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------

HRESULT
CIESelectElement::urns(VARIANT urn, IDispatch ** pdisp)
{
    HRESULT hr = S_OK;

    CContextAccess a(_pSite);
    CComPtr<IHTMLElementCollection> pItems;
    CComPtr<IHTMLElementCollection2> pItems2;

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_children((IDispatch**) &pItems);
    if (FAILED(hr))
        goto Cleanup;

    hr = pItems->QueryInterface( __uuidof(IHTMLElementCollection2), (void **) &pItems2);
    if (FAILED(hr))
        goto Cleanup;
    
    hr = pItems2->urns(urn, pdisp);
    if(FAILED(hr))
        goto Cleanup;

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CIESelectElement::CommitSingleSelection()
//
// Synopsis:    Commits the highlighted options to being selected.
//
// Arguments:   BOOL *pbChanged - Returns whether anything changed
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::CommitSingleSelection(BOOL *pbChanged)
{
    HRESULT         hr      = S_OK;
    VARIANT_BOOL    bOn;
    long            lIndex  = -1;

    Assert(pbChanged);
    *pbChanged = FALSE;

    if (_pLastSelected)
    {
        hr = _pLastSelected->GetHighlight(&bOn);
        if (FAILED(hr))
            goto Cleanup;

        if (!bOn)
        {
            // If we're not highlighted, then our selection status changed
            hr = _pLastSelected->SetSelected(VARIANT_FALSE);
            if (FAILED(hr))
                goto Cleanup;

            *pbChanged = TRUE;
        }

        ClearInterface(&_pLastSelected);
    }

    if (_pLastHighlight)
    {
        hr = _pLastHighlight->GetSelected(&bOn);
        if (FAILED(hr))
            goto Cleanup;

        if (!bOn)
        {
            // If we are not selected, then our selection status changed
            hr = _pLastHighlight->SetSelected(VARIANT_TRUE);
            if (FAILED(hr))
                goto Cleanup;

            *pbChanged = TRUE;
        }

        hr = _pLastHighlight->GetIndex(&lIndex);
        if (FAILED(hr))
            goto Cleanup;

        _pLastSelected = _pLastHighlight;
        _pLastSelected->AddRef();
    }

    hr = GetProps()[eSelectedIndex].Set(lIndex);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::CommitMultipleSelection()
//
// Synopsis:    Commits the highlighted options to being selected.
//
// Arguments:   BOOL *pbChanged - Returns whether anything changed
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::CommitMultipleSelection(BOOL *pbChanged)
{
    HRESULT                 hr;
    long                    cItems;
    long                    iItem;
    VARIANT_BOOL            bSelected;
    VARIANT_BOOL            bHighlight;
    IHTMLElementCollection  *pItems         = NULL;
    IDispatch               *pDispatchItem  = NULL;
    IPrivateOption          *pPrivOption    = NULL;
    CContextAccess          a(_pSite);

    Assert(pbChanged);
    *pbChanged = FALSE;

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_children((IDispatch**)&pItems);
    if (FAILED(hr))
        goto Cleanup;
    hr = pItems->get_length(&cItems);
    if (FAILED(hr))
        goto Cleanup;

    if ( (_lTopChanged < 0) || (_lTopChanged >= cItems) ||
            (_lBottomChanged < 0) || (_lBottomChanged >= cItems) )
    {
        hr = S_OK;
        goto Cleanup;
    }

    for (iItem = _lTopChanged; iItem <= _lBottomChanged; iItem++)
    {
        CVariant                var, var2;

        //
        // Get a child
        //
        V_VT(&var) = VT_I4;
        V_I4(&var) = iItem;
        hr = pItems->item(var, var2, &pDispatchItem);
        if (FAILED(hr))
            goto Cleanup;

        hr = pDispatchItem->QueryInterface(IID_IPrivateOption, (void**)&pPrivOption);
        if (FAILED(hr))
        {
            ClearInterface(&pDispatchItem);
            continue;
        }

        hr = pPrivOption->GetSelected(&bSelected);
        if (FAILED(hr))
            goto Cleanup;

        hr = pPrivOption->GetHighlight(&bHighlight);
        if (FAILED(hr))
            goto Cleanup;

        if (bSelected != bHighlight)
        {
            hr = pPrivOption->SetSelected(bHighlight);
            if (FAILED(hr))
                goto Cleanup;

            *pbChanged = TRUE;
        }

        ClearInterface(&pPrivOption);
        ClearInterface(&pDispatchItem);
    }

Cleanup:
    ReleaseInterface(pPrivOption);
    ReleaseInterface(pDispatchItem);
    ReleaseInterface(pItems);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::CommitSelection()
//
// Synopsis:    Commits the highlighted options to being selected.
//
// Arguments:   BOOL *pbChanged - Returns whether anything changed
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIESelectElement::CommitSelection(BOOL *pbChanged)
{
    HRESULT         hr          = S_OK;
    BOOL            bChanged;

    if (SELECT_ISMULTIPLE(_fFlavor))
    {
        hr = CommitMultipleSelection(&bChanged);
        if (FAILED(hr))
            goto Cleanup;
    }
    else
    {
        hr = CommitSingleSelection(&bChanged);
        if (FAILED(hr))
            goto Cleanup;
    }

    if (pbChanged)
    {
        *pbChanged = bChanged;
    }

Cleanup:
    return hr;
}
//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SetWritingMode
//
// Synopsis:    Commits the writing mode.
//
// Arguments:   BSTR bstrName : the writing mode.
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIESelectElement::SetWritingMode(BSTR bstrName)
{
    HRESULT         hr = S_OK;
    CContextAccess  a(_pSite);
    
    hr = a.Open(CA_STYLE3);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Style3()->put_writingMode(bstrName);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::FireOnChange()
//
// Synopsis:    Commits the highlighted options to being selected.
//              Then, if anything changed, fires onchange.
//
// Arguments:   BOOL *pbChanged - Returns whether anything changed
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::FireOnChange()
{
    HRESULT         hr          = S_OK;
    BOOL            bChanged;

    hr = CommitSelection(&bChanged);
    if (FAILED(hr))
        goto Cleanup;

    if (bChanged || SELECT_ISINPOPUP(_fFlavor))
    {
        hr = FireEvent(_lOnChangeCookie, NULL, CComBSTR("change"));
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::AdjustChangedRange()
//
// Synopsis:    Ajdusts the change range to include the given index.
//
// Arguments:   long lIndex - The index to include
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
void
CIESelectElement::AdjustChangedRange(long lIndex)
{
    if (SELECT_ISMULTIPLE(_fFlavor))
    {
        if ((lIndex < _lTopChanged) || (_lTopChanged == -1))
        {
            _lTopChanged = lIndex;
        }

        if (lIndex > _lBottomChanged)
        {
            _lBottomChanged = lIndex;
        }
    }
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnOptionClicked()
//
// Synopsis:    Called when an option is clicked (or simulated click).
//
// Arguments:   long  lIndex  - The index of the option
//              DWORD dwFlags - Selection flags (fire event, keyboard)
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIESelectElement::OnOptionClicked(long lIndex, DWORD dwFlags)
{
    VARIANT_BOOL    bSelected   = VARIANT_TRUE;
    DWORD           dwSelFlags  = dwFlags & (SELECT_FIREEVENT);

    if (SELECT_ISMULTIPLE(_fFlavor))
    {
        if (dwFlags & SELECT_SHIFT)
        {
            dwSelFlags |= SELECT_EXTEND;
        }
        else if (dwFlags & SELECT_CTRL)
        {
            dwSelFlags |= SELECT_TOGGLE;
        }
        else
        {
            dwSelFlags |= SELECT_CLEARPREV;
        }
    }
    else
    {
        dwSelFlags |= SELECT_CLEARPREV;
    }

    return OnOptionSelected(bSelected, lIndex, dwSelFlags);
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnOptionSelected()
//
// Synopsis:    Called when an option is selected/deselected.
//
// Arguments:   VARIANT_BOOL bSelected - Whether the option is selected
//              long  lIndex           - The index of the option
//              DWORD dwFlags          - Selection flags (fire event, keyboard)
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIESelectElement::OnOptionSelected(VARIANT_BOOL bSelected, long lIndex, DWORD dwFlags)
{
    HRESULT             hr;
    IPrivateOption      *pOption        = NULL;
    BOOL                bSetShiftAnchor = TRUE;
    BOOL                bRefreshFocus   = TRUE;
    BOOL                bNeedToSelect   = TRUE;
    long                lPrevIndex;

    if (!SELECT_ISMULTIPLE(_fFlavor))
    {
        //
        // Do some checking for single-select
        //

        if (!bSelected)
        {
            // Don't allow de-select in single-select
            hr = S_OK;
            goto Cleanup;
        }

        // Require this flag in single-select
        dwFlags |= SELECT_CLEARPREV;
    }

    hr = GetIndex(lIndex, &pOption);
    if (FAILED(hr) || !pOption)
        goto Cleanup;

    AdjustChangedRange(lIndex);

    //
    // Remove the previously selected items only if selecting
    //
    if (bSelected)
    {
        if (SELECT_ISMULTIPLE(_fFlavor))
        {
            // Multiple select doesn't have to de-highlight previous items
            if (dwFlags & SELECT_CLEARPREV)
            {
                hr = SetAllSelected(VARIANT_FALSE, NULL);
                if (FAILED(hr))
                    goto Cleanup;
            }
        }
        else
        {
            // Single select must de-highlight the previous item
            if (_pLastHighlight)
            {
                hr = _pLastHighlight->GetIndex(&lPrevIndex);
                if (FAILED(hr))
                    goto Cleanup;

                // If highlighting the previous item, then don't do anything
                if (lPrevIndex != lIndex)
                {
                    // De-highlight the previous item
                    hr = _pLastHighlight->SetHighlight(VARIANT_FALSE);
                    if (FAILED(hr))
                        goto Cleanup;
                }
            }

            if (SELECT_ISINPOPUP(_fFlavor) && _pLastHighlight)
            {
                // In the popup, un-highlight the currently highlighted option.
                hr = _pLastHighlight->SetHighlight(VARIANT_FALSE);
                if (FAILED(hr))
                    goto Cleanup;
            }
        }
    }

    //
    // Highlight the new item
    //
    if (SELECT_ISDROPBOX(_fFlavor))
    {
        hr = DropDownSelect(pOption);
        if (FAILED(hr))
            goto Cleanup;

        Assert(_pSelectInPopup);

        hr = _pSelectInPopup->OnOptionSelected(bSelected, lIndex, dwFlags & (~SELECT_FIREEVENT));
        if (FAILED(hr))
            goto Cleanup;

        bNeedToSelect = FALSE;
    }
    else if (SELECT_ISMULTIPLE(_fFlavor))
    {
        if ((dwFlags & SELECT_EXTEND) && (_lShiftAnchor != -1))
        {
            hr = SelectRange(_lShiftAnchor, _lFocusIndex, lIndex);
            if (FAILED(hr))
                goto Cleanup;

            bSetShiftAnchor = FALSE;
            bNeedToSelect = FALSE;
        }
        else
        {
            if (dwFlags & SELECT_TOGGLE)
            {
                hr = pOption->GetSelected(&bSelected);
                if (FAILED(hr))
                    goto Cleanup;

                bSelected = bSelected ? VARIANT_FALSE : VARIANT_TRUE;
            }
        }
    }
    else if (SELECT_ISINPOPUP(_fFlavor))
    {
        VARIANT_BOOL bOpen;

        Assert(_pPopup);

        hr = _pPopup->get_isOpen(&bOpen);
        if (FAILED(hr))
            goto Cleanup;

        if (bOpen)
        {
            bRefreshFocus = !(dwFlags & SELECT_FIREEVENT);
        }
        else
        {
            bRefreshFocus = FALSE;
        }
    }

    if (bNeedToSelect)
    {
        // Highlight the item
        hr = pOption->SetHighlight(bSelected);
        if (FAILED(hr))
            goto Cleanup;
    }

    if (bSelected || (dwFlags & SELECT_CLEARPREV))
    {
        if (_pLastHighlight)
        {
            ClearInterface(&_pLastHighlight);
        }

        if (bSelected)
        {
            _pLastHighlight = pOption;
            _pLastHighlight->AddRef();

            if (SELECT_ISLISTBOX(_fFlavor))
            {
                hr = MakeOptionVisible(_pLastHighlight);
                if (FAILED(hr))
                    goto Cleanup;
            }
        }
    }

    if (bSetShiftAnchor)
    {
        _lShiftAnchor = lIndex;
    }

    hr = OnOptionFocus(lIndex, (VARIANT_BOOL)bRefreshFocus);
    if (FAILED(hr))
        goto Cleanup;

    if (dwFlags & SELECT_FIREEVENT)
    {
        // Commit changes to selection (highlight -> selected)
        hr = FireOnChange();
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pOption);

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnOptionHighlighted()
//
// Synopsis:    Called back when an option is highlighted
//
// Arguments:   long lIndex - Index of the option
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIESelectElement::OnOptionHighlighted(long lIndex)
{
    HRESULT             hr;

    if (_pLastHighlight)
    {
        hr = _pLastHighlight->SetHighlight(VARIANT_FALSE);
        if (FAILED(hr))
            goto Cleanup;

        ClearInterface(&_pLastHighlight);
    }

    hr = GetIndex(lIndex, &_pLastHighlight);
    if (FAILED(hr))
        goto Cleanup;

    hr = _pLastHighlight->SetHighlight(VARIANT_TRUE);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnOptionFocus()
//
// Synopsis:    Called back when an option is focused
//
// Arguments:   long         lIndex          - Index of the option
//              VARIANT_BOOL bRequireRefresh - Force a refresh
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIESelectElement::OnOptionFocus(long lIndex, VARIANT_BOOL bRequireRefresh /* = VARIANT_TRUE */)
{
    HRESULT             hr = S_OK ;

    _lFocusIndex = lIndex;

    if (bRequireRefresh || !SELECT_ISINPOPUP(_fFlavor))
    {
        hr = RefreshFocusRect();
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::InitOptions()
//
// Synopsis:    Sets option flags based on the select's flavor.
//              Initializes default selections.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIESelectElement::InitOptions()
{
    HRESULT                 hr;
    long                    cItems;
    long                    iItem;
    long                    lStart, lEnd;
    long                    lDirection;

    BOOL                    bTurnOff        = FALSE;
    IHTMLElementCollection  *pItems         = NULL;
    IDispatch               *pDispatchItem  = NULL;
    IPrivateOption          *pPrivOption    = NULL;
    IHTMLOptionElement2     *pOption        = NULL;

    CVariant                var, var2;
    VARIANT_BOOL            bSelected;
    CContextAccess          a(_pSite);


    hr = a.Open(CA_ELEM | CA_STYLE);
    if (FAILED(hr))
        goto Cleanup;

    hr = ParseChildren();
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_children((IDispatch**)&pItems);
    if (FAILED(hr))
        goto Cleanup;
    hr = pItems->get_length(&cItems);
    if (FAILED(hr))
        goto Cleanup;

    V_VT(&var) = VT_I4;
    for (iItem = 0; iItem < cItems; iItem++)
    {
        V_I4(&var) = iItem;
        hr = pItems->item(var, var2, &pDispatchItem);
        if (FAILED(hr))
            goto Cleanup;

        hr = pDispatchItem->QueryInterface(IID_IPrivateOption, (void**)&pPrivOption);
        if (FAILED(hr))
        {
            ClearInterface(&pDispatchItem);
            continue;
        }

        hr = pPrivOption->SetIndex(iItem);
        if (FAILED(hr))
            goto Cleanup;

        if (SELECT_ISINPOPUP(_fFlavor))
        {
            //
            // If the listbox is in a popup, 
            // options should only be selected on onmouseup events.
            // The options should also highlight on onmouseover events.
            // 
            pPrivOption->SetSelectOnMouseDown(VARIANT_FALSE);
            pPrivOption->SetHighlightOnMouseOver(VARIANT_TRUE);
        }
        else
        {
            pPrivOption->SetSelectOnMouseDown(VARIANT_TRUE);
            pPrivOption->SetHighlightOnMouseOver(VARIANT_FALSE);
        }
    
       
        ClearInterface(&pPrivOption);
        ClearInterface(&pDispatchItem);
    }

    //
    // Deal with default selected options
    //

    // Setup the begin and end values and the direction.
    // we're doing this since the code we want to run is the same,
    // just in different directions depending on the flavor.
    if (SELECT_ISMULTIPLE(_fFlavor))
    {
        lStart = 0;
        lEnd = cItems;
        lDirection = 1;
    }
    else
    {
        lStart = cItems - 1;
        lEnd = -1;
        lDirection = -1;
    }
    for (iItem = lStart; iItem != lEnd; iItem += lDirection)
    {
        V_I4(&var) = iItem;
        hr = pItems->item(var, var2, &pDispatchItem);
        if (FAILED(hr))
            goto Cleanup;

        hr = pDispatchItem->QueryInterface(IID_IPrivateOption, (void**)&pPrivOption);
        if (FAILED(hr))
        {
            ClearInterface(&pDispatchItem);
            continue;
        }

        if (bTurnOff)
        {
            hr = pPrivOption->SetSelected(VARIANT_FALSE);
            if (FAILED(hr))
                goto Cleanup;

            hr = pPrivOption->SetInitSelected(VARIANT_FALSE);
            if (FAILED(hr))
                goto Cleanup;
        }
        else
        {
            hr = pPrivOption->GetSelected(&bSelected);
            if (FAILED(hr))
                goto Cleanup;

            if (bSelected)
            {
                hr = OnOptionSelected(VARIANT_TRUE, iItem, 0);
                if (FAILED(hr))
                    goto Cleanup;

                if (SELECT_ISMULTIPLE(_fFlavor))
                {
                    // Multiple select is done. So, break out
                    iItem = lEnd - lDirection; // Causes us to break out
                }
                else
                {
                    // Single select should turn the rest off
                    bTurnOff = TRUE;
                }
            }
        }

        ClearInterface(&pPrivOption);
        ClearInterface(&pDispatchItem);
    }

    hr = CommitSelection(NULL);
    if (FAILED(hr))
        goto Cleanup;

    if (SELECT_ISDROPBOX(_fFlavor) && (cItems > 0))
    {
        // Initialize the selection on dropdowns
        long lSelIndex;

        hr = get_selectedIndex(&lSelIndex);
        if (FAILED(hr))
            goto Cleanup;

        if (((lSelIndex == -1) || (hr == S_FALSE)) && (cItems > 0))
        {
            V_I4(&var) = 0;
            hr = pItems->item(var, var2, &pDispatchItem);
            if (FAILED(hr))
                goto Cleanup;

            hr = pDispatchItem->QueryInterface(IID_IPrivateOption, (void**)&pPrivOption);
            if (SUCCEEDED(hr))
            {
                hr = pPrivOption->SetInitSelected(VARIANT_TRUE);
                if (FAILED(hr))
                    goto Cleanup;
            } // added

            // There was no slection, so select the first one
            OnOptionSelected(VARIANT_TRUE, 0, 0);
            // Ignore the return value

            hr = CommitSelection(NULL);
            if (FAILED(hr))
                goto Cleanup;
        }
    }

Cleanup:
    ReleaseInterface(pOption);
    ReleaseInterface(pPrivOption);
    ReleaseInterface(pDispatchItem);
    ReleaseInterface(pItems);

    return hr;
}

#ifdef SELECT_GETSIZE
//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnOptionSized()
//
// Synopsis:    Called by the options when they are sized.
//
// Arguments:   SIZE* psizeOption - The option's size (and returns it)
//              BOOL  bNew        - TRUE if this is the first time it's calling back
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIESelectElement::OnOptionSized(SIZE* psizeOption, BOOL bNew, BOOL bAdjust)
{
    HRESULT     hr = S_OK;

    BOOL bWidthSet, bHeightSet;

    if (bNew)
    {
        // If the option is reporting a new size, then compare it
        // with the current largest option.
        _lNumOptionsReported++;
    }

    if (bNew || bAdjust)
    {
        if (psizeOption->cx > _sizeOptionReported.cx)
        {
            _sizeOptionReported.cx = psizeOption->cx; 
            _fLayoutDirty = TRUE;
        }

        if(_lNumOptionsReported == 1) {
            if (psizeOption->cy > _sizeOptionReported.cy)
            {
                _sizeOptionReported.cy = psizeOption->cy;
                _fLayoutDirty = TRUE;
            }
        }
    }

    hr = IsWidthHeightSet(&bWidthSet, &bHeightSet);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Only adjust for scrollbars if the width hasn't been
    // set explicitly.  The code to handle explicitly sizing
    // accounts for the scrollbar.
    //

    // Set the return value for the option
    *psizeOption = _sizeOptionReported;

    if(!bWidthSet) 
    {
        AdjustSizeForScrollbar(psizeOption);
    }

    if (!_fAllOptionsSized)
    {
        long lNumOptions;

        hr = GetNumOptions(&lNumOptions);
        if (FAILED(hr))
            goto Cleanup;

        if (lNumOptions == _lNumOptionsReported)
        {
            // All options have reported in at least once
            // so they have all been sized.
            _fAllOptionsSized = TRUE;
        }
    }

    if (_fAllOptionsSized)
    {
        // All options have been sized, so setup the select's version
        // of an option size.

        _sizeOption = *psizeOption;

#ifdef SELECT_TIMERVL
        if (SELECT_ISDROPBOX(_fFlavor) &&
            _fContentReady && !_fVLEngaged)
        {
            // If ViewLink has not been turned on, then turn it on.
            AddSelectToTimerVLQueue(this);
        }
#endif
    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::AdjustSizeForScrollbar()
//
// Synopsis:    Inflates the size to account for any scrollbars.
//
// Arguments:   SIZE *pSize - The size to adjust
//
// Returns:     None.
//
//-------------------------------------------------------------------
VOID
CIESelectElement::AdjustSizeForScrollbar(SIZE *pSize)
{
    long lButtonWidth = GetSystemMetrics(SM_CXVSCROLL);

    if (_fContentReady)
    {
        if ( !_fNeedScrollBar && SELECT_ISLISTBOX(_fFlavor))
        {
            // If the select does not need a scroll bar, then
            // the option needs to be wider.
            pSize->cx += lButtonWidth;
        }

        if (SELECT_ISINPOPUP(_fFlavor))
        {
            // This is padding added in the drop control that
            // affects the width of the popup, affecting the
            // width of the option.
            pSize->cx += 4;
        }
    }
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SetupDropControlDimensions()
//
// Synopsis:    Setup the drop control's elements' dimensions.
//
// Arguments:   SIZE sizeOption - The option's size
//              BOOL bNew       - TRUE if this is the first time it's calling back
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::SetupDropControlDimensions()
{
    HRESULT             hr;
    long                lButtonWidth;
    IHTMLStyle          *pStyle = NULL;
    SIZE                sizeLogical;
    long                lWidth;
    long                lHeight;

    Assert(_pElemDisplay);

    // Get the width of the button
    lButtonWidth = GetSystemMetrics(SM_CXVSCROLL);

    if (_fWritingModeTBRL)
    {
        sizeLogical.cx = _sizeOptionReported.cy;
        sizeLogical.cy = _sizeOptionReported.cx;
        lWidth = _sizeOptionReported.cy + 2;
        lHeight = lButtonWidth;
    }
    else
    {
        sizeLogical = _sizeOptionReported;
        lWidth = lButtonWidth;
        lHeight = _sizeOptionReported.cy + 2;
    }

    hr = _pElemDisplay->get_style(&pStyle);
    if (FAILED(hr))
        goto Cleanup;

    // Set the width of the display
    hr = pStyle->put_pixelWidth(sizeLogical.cx);
    if (FAILED(hr))
        goto Cleanup;

    // Set the height of the display
    hr = pStyle->put_pixelHeight(sizeLogical.cy);
    if (FAILED(hr))
        goto Cleanup;

    // Set the width of the button
    hr = _pStyleButton->put_pixelWidth(lWidth);
    if (FAILED(hr))
        goto Cleanup;

    // Set the height of the button (+2 for border)
    hr = _pStyleButton->put_pixelHeight(lHeight);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pStyle);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SetupButton()
//
// Synopsis:    Setup the drop control's button.
//
// Arguments:   IHTMLElement *pButton - The button
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::SetupButton(IHTMLElement *pButton)
{
    HRESULT         hr;
    IHTMLStyle      *pStyle     = NULL;
    CComBSTR        bstrDefault(_T("default"));
    CComBSTR        bstrHidden(_T("hidden"));
    CComBSTR        bstrButtonFace(_T("buttonface"));
    CComBSTR        bstrBorder(_T("2 outset"));
    CComBSTR        bstrFont(_T("Marlett"));
    CComBSTR        bstrButtonText(_T("u"));
    CComBSTR        bstrCenter(_T("center"));
    CComBSTR        bstrMiddle(_T("middle")); 
    CVariant        var;
    long            lButtonWidth;


    // Get the width of the button
    lButtonWidth = GetSystemMetrics(SM_CXVSCROLL);

    hr = pButton->get_style(&pStyle);
    if (FAILED(hr))
        goto Cleanup;
        
    // Store for later use
    _pStyleButton = pStyle;
    _pStyleButton->AddRef();

    // Set the mouse cursor be an arrow for the button
    hr = pStyle->put_cursor(bstrDefault);
    if (FAILED(hr))
        goto Cleanup;

    // Set overflow hidden for the button
    hr = pStyle->put_overflow(bstrHidden);
    if (FAILED(hr))
        goto Cleanup;

    // Set the background color for the button
    hr = pStyle->put_background(bstrButtonFace);
    if (FAILED(hr))
        goto Cleanup;

    // Set the border for the button
    hr = pStyle->put_border(bstrBorder);
    if (FAILED(hr))
        goto Cleanup;

    // Set the font family of the button
    hr = pStyle->put_fontFamily(bstrFont);
    if (FAILED(hr))
        goto Cleanup;

    // Set the font size of the button
    V_VT(&var) = VT_I4;
    V_I4(&var) = lButtonWidth - 4;
    hr = pStyle->put_fontSize(var);
    if (FAILED(hr))
        goto Cleanup;

    // Set the text to be the down arrow
    hr = pButton->put_innerText(bstrButtonText);
    if (FAILED(hr))
        goto Cleanup;

    // Set the alignment on the arrow to be centered
    hr = pStyle->put_textAlign(bstrCenter);
    if (FAILED(hr))
        goto Cleanup;

    // Align the button to the middle
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstrMiddle;
    hr = pStyle->put_verticalAlign(var);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pStyle);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SetupDisplay()
//
// Synopsis:    Setup the drop control's display.
//
// Arguments:   IHTMLElement *pDisplay - The display
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::SetupDisplay(IHTMLElement *pDisplay)
{
    HRESULT         hr;
    IHTMLStyle      *pStyle     = NULL;
    IHTMLStyle3     *pStyle3     = NULL;
    CComBSTR        bstrDefault(_T("default"));
    CComBSTR        bstrHidden(_T("hidden"));
    CComBSTR        bstrMiddle(_T("middle"));
    CComBSTR        bstr2px(_T("2px"));
    CVariant        var;
    long            lButtonWidth;
    CComBSTR        bstrWritingMode(_T(""));

    _pElemDisplay = pDisplay;
    _pElemDisplay->AddRef();

    // Get the width of the button
    lButtonWidth = GetSystemMetrics(SM_CXVSCROLL);

    //
    // Set the display's style
    //
    hr = pDisplay->get_style(&pStyle);
    if (FAILED(hr))
        goto Cleanup;

    hr = pStyle->QueryInterface(IID_IHTMLStyle3, (void**)&pStyle3);
    if (FAILED(hr))
        goto Cleanup;

    if (_fWritingModeTBRL)
    {
        bstrWritingMode = _T("tb-rl");
    }

    hr = pStyle3->put_writingMode(bstrWritingMode);
    if (FAILED(hr))
        goto Cleanup;

    // Set the mouse cursor be an arrow for the display
    hr = pStyle->put_cursor(bstrDefault);
    if (FAILED(hr))
        goto Cleanup;

    // Set overflow hidden for the display
    hr = pStyle->put_overflow(bstrHidden);
    if (FAILED(hr))
        goto Cleanup;
   
    // Set the vertical alignment of the display to be middle
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstrMiddle;
    hr = pStyle->put_verticalAlign(var);
    if (FAILED(hr))
        goto Cleanup;

    // Set the left padding on the display
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstr2px;
    hr = pStyle->put_paddingLeft(var);
    if (FAILED(hr))
        goto Cleanup;

    // Set the margin on the display
    V_VT(&var) = VT_I4;
    V_I4(&var) = 1;
    hr = pStyle->put_marginLeft(var);
    if (FAILED(hr))
        goto Cleanup;
    hr = pStyle->put_marginRight(var);
    if (FAILED(hr))
        goto Cleanup;
    hr = pStyle->put_marginTop(var);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pStyle);
    ClearInterface(&pStyle3);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::InitViewLink()
//
// Synopsis:    Engages viewlink, sets up the drop control's dimensions
//              and makes the drop control visible.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::InitViewLink()
{
    HRESULT         hr;
    long            lIndex;
    IPrivateOption  *pOption = NULL;
    long            lSize;

    hr = get_size(&lSize);
    if (FAILED(hr))
        goto Cleanup;

    if ( lSize >1 )
        goto Cleanup;

    // Engage the viewlink
    hr = EngageViewLink();
    if (FAILED(hr))
        goto Cleanup;

    // Put the selected option into the display
    hr = get_selectedIndex(&lIndex);
    if (FAILED(hr))
        goto Cleanup;

    if (lIndex >= 0)
    {
        hr = GetIndex(lIndex, &pOption);
        if (SUCCEEDED(hr) && pOption)
        {
            hr = DropDownSelect(pOption);
            if (FAILED(hr))
                goto Cleanup;
        }
    }

    // Resize the elements in the viewlink
    hr = SetupDropControlDimensions();
    if (FAILED(hr))
        goto Cleanup;

    // Make the control visible
    hr = MakeVisible(TRUE);
    if (FAILED(hr))
        goto Cleanup;

    _fLayoutDirty = TRUE;

Cleanup:
    ReleaseInterface(pOption);

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::DeInitViewLink()
//
// Synopsis:    Turns off ViewLink.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::DeInitViewLink()
{
    HRESULT         hr = E_FAIL;
    VARIANT_BOOL    bOpen;
    CContextAccess  a(_pSite);


    if (!_fVLEngaged)
    {
        goto Cleanup;
    }
    else
    {
        _fVLEngaged = FALSE;
    }

    
    //
    // Get a hold of the Link document
    //

    ReleaseInterface(_pDispDocLink);
    hr = _pElemDisplay->get_document(&_pDispDocLink);
    if (FAILED(hr))
        goto Cleanup;

    ClearInterface(&_pElemDisplay);
    ClearInterface(&_pStyleButton);
    ClearInterface(&_pSelectInPopup);

    hr = a.Open(CA_DEFAULTS);
    if (FAILED(hr))
        goto Cleanup;

    // Remove the viewLink
    hr = a.Defaults()->putref_viewLink(NULL);
    if (FAILED(hr))
        goto Cleanup;

    if (_pPopup && !SELECT_ISINPOPUP(_fFlavor))
    {
        hr = _pPopup->get_isOpen(&bOpen);
        if (FAILED(hr))
            goto Cleanup;

        if (bOpen)
        {
            hr = HidePopup();
            if (FAILED(hr))
                goto Cleanup;
        }

        ClearInterface(&_pPopup);
    }

Cleanup:
    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CIESelectElement::EngageViewLink()
//
// Synopsis:    Turns on ViewLink.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::EngageViewLink()
{
    HRESULT             hr              = S_OK;

    IHTMLDocument2      *pDocThis       = NULL;
    IHTMLDocument2      *pDocLink       = NULL;
    IHTMLDocument3      *pDocLink3      = NULL;
    IDispatch           *pDispDocLink   = NULL;

    IHTMLElement        *pElemLink      = NULL;
    IHTMLDOMNode        *pNodeLink      = NULL;
    IHTMLElement        *pElemNOBR      = NULL;
    IHTMLDOMNode        *pNodeNOBR      = NULL;
    IHTMLElement        *pElemDisplay   = NULL;
    IHTMLDOMNode        *pNodeDisplay   = NULL;
    IHTMLElement        *pElemButton    = NULL;
    IHTMLDOMNode        *pNodeButton    = NULL;

    IHTMLElement2       *pElem2         = NULL;
    CComBSTR            bstrSpan(_T("SPAN"));
    CComBSTR            bstrNOBR(_T("NOBR"));
    CComBSTR            bstr;
    CContextAccess      a(_pSite);

    if (_fVLEngaged)
    {
        goto Cleanup;
    }
    else
    {
        _fVLEngaged = TRUE;
    }

    hr = a.Open(CA_ELEM | CA_DEFAULTS);
    if (FAILED(hr))
        goto Cleanup;

    // Get the document
    hr = a.Elem()->get_document((IDispatch**)&pDocThis);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Create a superflous slave element for now
    //
    hr = pDocThis->createElement(bstrSpan, &pElemLink);
    if (FAILED(hr))
        goto Cleanup;

    hr = pElemLink->QueryInterface(IID_IHTMLDOMNode, (void**)&pNodeLink);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Create and insert a NOBR element
    //
    hr = pDocThis->createElement(bstrNOBR, &pElemNOBR);
    if (FAILED(hr))
        goto Cleanup;

    hr = pElemNOBR->QueryInterface(IID_IHTMLDOMNode, (void**)&pNodeNOBR);
    if (FAILED(hr))
        goto Cleanup;

    hr = pNodeLink->appendChild(pNodeNOBR, NULL);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Create and insert the display element
    //
    hr = pDocThis->createElement(bstrSpan, &pElemDisplay);
    if (FAILED(hr))
        goto Cleanup;

    hr = pElemDisplay->QueryInterface(IID_IHTMLDOMNode, (void**)&pNodeDisplay);
    if (FAILED(hr))
        goto Cleanup;

    hr = pNodeNOBR->appendChild(pNodeDisplay, NULL);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Create and insert the button
    //
    hr = pDocThis->createElement(bstrSpan, &pElemButton);
    if (FAILED(hr))
        goto Cleanup;

    hr = pElemButton->QueryInterface(IID_IHTMLDOMNode, (void**)&pNodeButton);
    if (FAILED(hr))
        goto Cleanup;

    hr = pNodeNOBR->appendChild(pNodeButton, NULL);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Remove the superflous Link element now
    //
    hr = pNodeLink->removeNode(VB_FALSE, NULL);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Get a hold of the Link document
    //
    if (_pDispDocLink)
    {
        ClearInterface(&_pDispDocLink);
    }

    hr = pElemDisplay->get_document(&pDispDocLink);
    if (FAILED(hr))
        goto Cleanup;

    _pDispDocLink = pDispDocLink;
    _pDispDocLink->AddRef();

    hr = pDispDocLink->QueryInterface(IID_IHTMLDocument2, (void**)&pDocLink);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Create the viewLink
    //
    hr = a.Defaults()->putref_viewLink(pDocLink);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Setup styles and sizes
    //
    hr = SetupDisplay(pElemDisplay);
    if (FAILED(hr))
        goto Cleanup;

    hr = SetupButton(pElemButton);
    if (FAILED(hr))
        goto Cleanup;

    hr = pDocLink->QueryInterface(IID_IHTMLDocument3, (void**)&pDocLink3);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Attach an event sink to listen for events within the view link
    //

    if ( !_pSinkVL )
    {
        _pSinkVL = new CEventSink(this, SELECTES_VIEWLINK);
        if (!_pSinkVL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        bstr = _T("onmousedown");
        hr = AttachEventToSink(pDocLink3, bstr, _pSinkVL);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onmouseup");
        hr = AttachEventToSink(pDocLink3, bstr, _pSinkVL);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onclick");
        hr = AttachEventToSink(pDocLink3, bstr, _pSinkVL);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onselectstart");
        hr = AttachEventToSink(pDocLink3, bstr, _pSinkVL);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("oncontextmenu");
        hr = AttachEventToSink(pDocLink3, bstr, _pSinkVL);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onbeforefocusenter");
        hr = AttachEventToSink(pDocLink3, bstr, _pSinkVL);
        if (FAILED(hr))
            goto Cleanup;
    }


    if ( !_pSinkButton )
    {
        _pSinkButton = new CEventSink(this, SELECTES_BUTTON);
        if (!_pSinkButton)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = pElemDisplay->QueryInterface(IID_IHTMLElement2, (void**)&pElem2);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onbeforefocusenter");
        hr = AttachEventToSink(pElem2, bstr, _pSinkVL);
        if (FAILED(hr))
            goto Cleanup;

        ClearInterface(&pElem2);

        hr = pElemButton->QueryInterface(IID_IHTMLElement2, (void**)&pElem2);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onmousedown");
        hr = AttachEventToSink(pElem2, bstr, _pSinkButton);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onmouseup");
        hr = AttachEventToSink(pElem2, bstr, _pSinkButton);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onmouseout");
        hr = AttachEventToSink(pElem2, bstr, _pSinkButton);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onbeforefocusenter");
        hr = AttachEventToSink(pElem2, bstr, _pSinkButton);
        if (FAILED(hr))
            goto Cleanup;

        if ( _pSinkVL )
        bstr = _T("onbeforefocusenter");
        hr = AttachEventToSink(pElem2, bstr, _pSinkVL);
        if (FAILED(hr))
            goto Cleanup;

    }
Cleanup:
    ReleaseInterface(pDocThis);

    ReleaseInterface(pDispDocLink);
    ReleaseInterface(pDocLink);
    ReleaseInterface(pDocLink3);

    ReleaseInterface(pElemLink);
    ReleaseInterface(pNodeLink);

    ReleaseInterface(pElemNOBR);
    ReleaseInterface(pNodeNOBR);

    ReleaseInterface(pElemDisplay);
    ReleaseInterface(pNodeDisplay);

    ReleaseInterface(pElemButton);
    ReleaseInterface(pNodeButton);

    ReleaseInterface(pElem2);
    
    return hr;
}
#endif

#ifndef SELECT_GETSIZE
//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SetDimensions()
//
// Synopsis:    Sets the dimensions for the select and option controls.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIESelectElement::SetDimensions()
{
    HRESULT     hr;
    long        lSize;

    hr = get_size(&lSize);
    if (FAILED(hr))
        goto Cleanup;

    hr = SetDimensions(lSize);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SetDimensions()
//
// Synopsis:    Sets the dimensions for the select and option controls.
//
// Arguments:   long lSize      The size of the control.
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::SetDimensions(long lSize)
{
    HRESULT                     hr;

    IHTMLElementCollection      *pItems         = NULL;
    IDispatch                   *pDispatchItem  = NULL;
    IHTMLElement2               *pElem2         = NULL;
    IPrivateOption              *pOption        = NULL;
    IHTMLRect                   *pRect          = NULL;
    
    long                        cNumItems;
    long                        iCurRow;

    long                        lHeight = 0;
    long                        lWidth = 0;

    long                        lScrollWidth;
    long                        lVertBorder;
    long                        lHorizBorder;

    long                        lMaxWidth = 0;
    long                        lMaxHeight = 0;

    long                        lClient;
    long                        lOffset;

    long                        lItemTop;
    long                        lItemLeft;
    long                        lItemHeight;
    long                        lItemWidth;
    long                        lTemp;

    CVariant                    var, var2;

    CContextAccess              a(_pSite);

    hr = a.Open(CA_ELEM | CA_ELEM2 | CA_DEFSTYLE);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Get the scroll bar width
    //
    lScrollWidth = GetSystemMetrics(SM_CXVSCROLL);

    //
    // Calculate the vertical padding and border
    //
    hr = a.Elem()->get_offsetHeight(&lOffset);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem2()->get_clientHeight(&lClient);
    if (FAILED(hr))
        goto Cleanup;

    lVertBorder = lOffset - lClient;

    //
    // Calculate the horizontal padding and border
    //
    hr = a.Elem()->get_offsetWidth(&lOffset);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem2()->get_clientWidth(&lClient);
    if (FAILED(hr))
        goto Cleanup;

    lHorizBorder = lOffset - lClient;

    //
    // Get the children
    //
    hr = a.Elem()->get_children((IDispatch**)&pItems);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Set the scroll range
    //
    hr = pItems->get_length(&cNumItems);
    if (FAILED(hr))
        goto Cleanup;

    for (iCurRow = 0; iCurRow < cNumItems; iCurRow++)
    {
        // Get the row
        V_VT(&var) = VT_I4;
        V_I4(&var) = iCurRow;
        hr = pItems->item(var, var2, &pDispatchItem);
        if (FAILED(hr))
            goto Cleanup;

        // Get the IHTMLElement interface
        hr = pDispatchItem->QueryInterface(IID_IHTMLElement2, (void**)&pElem2);
        if (FAILED(hr))
            goto Cleanup;

        //
        // Get the width and height of the option
        //
        hr = pElem2->getBoundingClientRect(&pRect);
        if (FAILED(hr))
            goto Cleanup;

        hr = pRect->get_top(&lItemTop);
        if (FAILED(hr))
            goto Cleanup;
        
        hr = pRect->get_left(&lItemLeft);
        if (FAILED(hr))
            goto Cleanup;
        
        hr = pRect->get_right(&lItemWidth);
        if (FAILED(hr))
            goto Cleanup;

        hr = pRect->get_bottom(&lItemHeight);
        if (FAILED(hr))
            goto Cleanup;

        lItemWidth -= lItemLeft;
        lItemHeight -= lItemTop;

        ClearInterface(&pRect);
        ClearInterface(&pElem2);

        //
        // If the width is greater than the maximum,
        // then set the max to the option's width.
        //
        if (lItemWidth > lMaxWidth)
        {
            lMaxWidth = lItemWidth;
        }

        //
        // If the width is greater than the maximum,
        // then set the max to the option's width.
        //
        if (lItemHeight > lMaxHeight)
        {
            lMaxHeight = lItemHeight;
        }

        hr = pDispatchItem->QueryInterface(IID_IPrivateOption, (void**)&pOption);
        if (FAILED(hr))
            goto Cleanup;

        hr = pOption->SetFinalDefaultStyles();
        if (FAILED(hr))
            goto Cleanup;

        ClearInterface(&pOption);
        ClearInterface(&pDispatchItem);
    }

    //
    // If we have no default option height,
    // then set to a default size.
    //
    if (lMaxHeight == 0)
    {
        lMaxHeight = SELECT_OPTIONHEIGHT;
    }

    //
    // Calculate the height of the control
    //
    lHeight = lMaxHeight * lSize;

    // Add in the border
    lHeight += lVertBorder;

    // Add in the border and the scroll bar + padding
    // for IE5 compat, there is 2 pixels padding at left and right
    lWidth = lMaxWidth + lHorizBorder + lScrollWidth + 4;

    if (_fWritingModeTBRL)
    {
        lTemp = lWidth;
        lWidth = lHeight;
        lHeight = lTemp;
    }
    // Set the height
    hr = a.DefStyle()->put_pixelHeight(lHeight);
    if (FAILED(hr))
        goto Cleanup;

    // Set the width
    hr = a.DefStyle()->put_pixelWidth(lWidth);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Take care of some last minute styles
    // Force fixed height
    //
    _lMaxHeight = lMaxHeight;
    for (iCurRow = 0; iCurRow < cNumItems; iCurRow++)
    {
        // Get the row
        V_VT(&var) = VT_I4;
        V_I4(&var) = iCurRow;
        hr = pItems->item(var, var2, &pDispatchItem);
        if (FAILED(hr))
            goto Cleanup;

        hr = pDispatchItem->QueryInterface(IID_IPrivateOption, (void**)&pOption);
        if (FAILED(hr))
            goto Cleanup;

        hr = pOption->SetFinalHeight(lMaxHeight);
        if (FAILED(hr))
            goto Cleanup;

        ClearInterface(&pDispatchItem);
        ClearInterface(&pOption);
    }

Cleanup:
    ReleaseInterface(pDispatchItem);
    ReleaseInterface(pItems);
    ReleaseInterface(pElem2);
    ReleaseInterface(pRect);
    ReleaseInterface(pOption);
    return hr;
}
#endif

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetSelectedIndex()
//
// Synopsis:    Returns the currently selected index.
//
// Arguments:   long *plIndex - Returns the index.
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIESelectElement::GetSelectedIndex(long *plIndex)
{
    return get_selectedIndex(plIndex);
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetDisabled()
//
// Synopsis:    Returns if the control is disabled.
//
// Arguments:   VARIANT_BOOL *pbDisabled - Returns VARIANT_TRUE if disabled.
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIESelectElement::GetDisabled(VARIANT_BOOL *pbDisabled)
{
    HRESULT         hr;
    CContextAccess  a(_pSite);

    Assert(pbDisabled);

    hr = a.Open(CA_ELEM3);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem3()->get_disabled(pbDisabled);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SetAllSelected()
//
// Synopsis:    Sets all of the options to the given selection status.
//
// Arguments:   VARIANT_BOOL bSelected - Select/Deselect elements
//              DWORD        dwFlags   - Selection flags (fire event)
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::SetAllSelected(VARIANT_BOOL bSelected, DWORD dwFlags)
{
    HRESULT                 hr;
    long                    cItems;
    long                    iItem;
    VARIANT_BOOL            bPrev;
    IHTMLElementCollection  *pItems         = NULL;
    IDispatch               *pDispatchItem  = NULL;
    IPrivateOption          *pPrivOption    = NULL;
    CVariant                var, var2;
    CContextAccess          a(_pSite);

    Assert(SELECT_ISMULTIPLE(_fFlavor));

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_children((IDispatch**)&pItems);
    if (FAILED(hr))
        goto Cleanup;
    hr = pItems->get_length(&cItems);
    if (FAILED(hr))
        goto Cleanup;

    V_VT(&var) = VT_I4;
    for (iItem = 0; iItem < cItems; iItem++)
    {
        if ((dwFlags & SELECT_FIREEVENT) && (iItem == (cItems - 1)))
        {
            hr = OnOptionSelected(bSelected, iItem, SELECT_FIREEVENT);
            if (FAILED(hr))
                goto Cleanup;
        }
        else
        {
            V_I4(&var) = iItem;
            hr = pItems->item(var, var2, &pDispatchItem);
            if (FAILED(hr))
            {
                ClearInterface(&pDispatchItem);
                continue;
            }

            hr = pDispatchItem->QueryInterface(IID_IPrivateOption, (void**)&pPrivOption);
            if (FAILED(hr))
                goto Cleanup;

            hr = pPrivOption->GetHighlight(&bPrev);
            if (FAILED(hr))
                goto Cleanup;

            if (bPrev != bSelected)
            {
                hr = pPrivOption->SetHighlight(bSelected);
                if (FAILED(hr))
                    goto Cleanup;

                AdjustChangedRange(iItem);
            }
        }

        ClearInterface(&pPrivOption);
        ClearInterface(&pDispatchItem);
    }

Cleanup:
    ReleaseInterface(pPrivOption);
    ReleaseInterface(pDispatchItem);
    ReleaseInterface(pItems);

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetNumOptions()
//
// Synopsis:    Returns the number of options in the select.
//
// Arguments:   long *plItems - Returns the number of options
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::GetNumOptions(long *plItems)
{
    HRESULT                 hr;
    IHTMLElementCollection  *pItems         = NULL;
    CContextAccess          a(_pSite);

    Assert(plItems);

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_children((IDispatch**)&pItems);
    if (FAILED(hr))
        goto Cleanup;
    hr = pItems->get_length(plItems);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pItems);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetScrollTopBottom()
//
// Synopsis:    Returns the scroll top and bottom values.
//
// Arguments:   long *plScrollTop    - The top value
//              long *plScrollBottom - The bottom value
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::GetScrollTopBottom(long *plScrollTop, long *plScrollBottom)
{
    HRESULT                 hr;
    long                    lHeight;
    CContextAccess          a(_pSite);

    Assert(plScrollTop);
    Assert(plScrollBottom);

    hr = a.Open(CA_ELEM2);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Calculate the visible range
    //
    hr = a.Elem2()->get_scrollTop(plScrollTop);
    if (FAILED(hr))
        goto Cleanup;

#ifdef SELECT_GETSIZE
    // TODO: Just use this instead of lHeight
    lHeight = _sizeContent.cy;
#else
    hr = a.Elem2()->get_clientHeight(&lHeight);
    if (FAILED(hr))
        goto Cleanup;
#endif

    *plScrollBottom = *plScrollTop + lHeight;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetTopVisibleOptionIndex()
//
// Synopsis:    Returns the index of the first visible option.
//
// Arguments:   long *plItems - Returns the index
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::GetTopVisibleOptionIndex(long *plIndex)
{
    HRESULT                 hr              = S_OK;
    long                    lScrollTop;
    long                    lScrollBottom;

    Assert(plIndex);

    if (_lMaxHeight > 0)
    {
        //
        // Calculate the visible range
        //
        hr = GetScrollTopBottom(&lScrollTop, &lScrollBottom);
        if (FAILED(hr))
            goto Cleanup;

        //
        // Assuming fixed height to calc index
        //
        *plIndex = lScrollTop / _lMaxHeight;
    }
    else
    {
        *plIndex = 0;
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetBottomVisibleOptionIndex()
//
// Synopsis:    Returns the index of the last visible option (+1)
//
// Arguments:   long *plItems - Returns the index
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::GetBottomVisibleOptionIndex(long *plIndex)
{
    HRESULT                 hr              = S_OK;
    long                    lScrollTop;
    long                    lScrollBottom;

    Assert(plIndex);

    if (_lMaxHeight > 0)
    {
        //
        // Calculate the visible range
        //
        hr = GetScrollTopBottom(&lScrollTop, &lScrollBottom);
        if (FAILED(hr))
            goto Cleanup;

        //
        // Assuming fixed height to calc index
        //
        *plIndex = lScrollBottom / _lMaxHeight;
    }
    else
    {
        *plIndex = 0;
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetFirstSelected()
//
// Synopsis:    Returns the index of the first option that's selected.
//
// Arguments:   long *plItems - Returns the index of the option
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::GetFirstSelected(long *plIndex)
{
    HRESULT                 hr;
    long                    cItems;
    long                    iItem;
    VARIANT_BOOL            bSelected;
    IHTMLElementCollection  *pItems         = NULL;
    IDispatch               *pDispatchItem  = NULL;
    IPrivateOption          *pOption        = NULL;
    CVariant                var, var2;
    CContextAccess          a(_pSite);

    Assert(plIndex);
    *plIndex = -1;

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_children((IDispatch**)&pItems);
    if (FAILED(hr))
        goto Cleanup;
    hr = pItems->get_length(&cItems);
    if (FAILED(hr))
        goto Cleanup;

    V_VT(&var) = VT_I4;
    for (iItem = 0; iItem < cItems; iItem++)
    {
        V_I4(&var) = iItem;
        hr = pItems->item(var, var2, &pDispatchItem);
        if (FAILED(hr))
            goto Cleanup;

        hr = pDispatchItem->QueryInterface(IID_IPrivateOption, (void**)&pOption);
        if (FAILED(hr))
        {
            ClearInterface(&pDispatchItem);
            continue;
        }

        hr = pOption->GetSelected(&bSelected);
        if (FAILED(hr))
            goto Cleanup;

        if (bSelected)
        {
            // Found the first selected option
            *plIndex = iItem;
            iItem = cItems; // Causes us to break out
        }

        ClearInterface(&pOption);
        ClearInterface(&pDispatchItem);
    }

Cleanup:
    ReleaseInterface(pOption);
    ReleaseInterface(pDispatchItem);
    ReleaseInterface(pItems);

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::Select(long lIndex)
//
// Synopsis:    Selects the lIndex-th Option.
//              Note: Unlike put_selectedIndex, this method does *not* clear
//              the currently selected option(s),
//
// Arguments:   long lItems - Index of the option
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::Select(long lIndex)
{
    HRESULT             hr;
    IHTMLOptionElement2 *pOption    = NULL;

    hr = GetIndex(lIndex, &pOption);
    if (FAILED(hr))
        goto Cleanup;

    hr = pOption->put_selected(VARIANT_TRUE);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:

    ReleaseInterface(pOption);

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SelectVisibleIndex()
//
// Synopsis:    Selects the option that's lIndex down from the top
//              visible option.
//
// Arguments:   long lItems - Index of the option
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::SelectVisibleIndex(long lIndex)
{
    HRESULT                 hr              = S_OK;
    IHTMLOptionElement2     *pOption        = NULL;
    VARIANT_BOOL            bSelected;
    long                    lTopIndex;
    long                    lNewIndex;
    long                    lNumOptions;

    hr = GetNumOptions(&lNumOptions);
    if (FAILED(hr))
        goto Cleanup;

    hr = GetTopVisibleOptionIndex(&lTopIndex);
    if (FAILED(hr))
        goto Cleanup;

    lNewIndex = lTopIndex + lIndex;

    if (lNewIndex >= lNumOptions)
    {
        lNewIndex = lNumOptions - 1;
    }

    hr = GetIndex(lNewIndex, &pOption);
    if (FAILED(hr) || !pOption)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = pOption->get_selected(&bSelected);
    if (FAILED(hr))
        goto Cleanup;

    if (!bSelected)
    {
        hr = OnOptionClicked(lNewIndex, SELECT_FIREEVENT);
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pOption);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::PushFocusToExtreme()
//
// Synopsis:    Pushes the focused option to the top or bottom.
//
// Arguments:   BOOL bTop - TRUE to push to the top, FALSE to the bottom
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::PushFocusToExtreme(BOOL bTop)
{
    HRESULT                 hr              = S_OK;
    IHTMLElement            *pElem          = NULL;
    long                    lScrollTop;
    long                    lScrollBottom;
    long                    lScrollHeight;
    long                    lHeight;
    long                    lTop;
    long                    lBottom;
    long                    lNewTop;
    long                    lNewBottom;
    CContextAccess          a(_pSite);

    if (_lFocusIndex < 0)
        goto Cleanup;

    hr = a.Open(CA_ELEM2);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Calculate the visible range
    //
    hr = GetScrollTopBottom(&lScrollTop, &lScrollBottom);
    if (FAILED(hr))
        goto Cleanup;

    a.Elem2()->get_scrollHeight(&lScrollHeight);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Get the option's range
    //
    hr = GetIndex(_lFocusIndex, &pElem);
    if (FAILED(hr))
        goto Cleanup;

    hr = pElem->get_offsetTop(&lTop);
    if (FAILED(hr))
        goto Cleanup;

    hr = pElem->get_offsetHeight(&lHeight);
    if (FAILED(hr))
        goto Cleanup;

    lBottom = lTop + lHeight;

    //
    // Realign the scroll range
    //
    if (bTop)
    {
        lNewTop = lTop;
        lNewBottom = lScrollBottom + (lTop - lScrollTop);
    }
    else
    {
        lNewTop = lScrollTop + (lBottom - lScrollBottom);
        lNewBottom = lBottom;
    }

    if (lNewBottom > lScrollHeight)
    {
        lNewTop -= (lNewBottom - lScrollHeight);
        lNewBottom = lScrollHeight;
    }

    if (lNewTop < 0)
    {
        lNewBottom -= lNewTop;
        lNewTop = 0;
    }

    //
    // If there is a change, then change the scroll top
    //
    if (lNewTop != lScrollTop)
    {
        hr = a.Elem2()->put_scrollTop(lNewTop);
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pElem);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::MakeOptionVisible()
//
// Synopsis:    Makes the given option visible.
//
// Arguments:   IPrivateOption *pOption - The option to make visible
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::MakeOptionVisible(IPrivateOption *pOption)
{
    HRESULT                 hr;
    IHTMLElement            *pElem = NULL;
    long                    lScrollTop;
    long                    lScrollBottom;
    long                    lHeight;
    long                    lTop;
    long                    lBottom;
    long                    lNewTop;
    CContextAccess          a(_pSite);

#ifdef SELECT_GETSIZE
    if (SELECT_ISDROPBOX(_fFlavor) || !(_fContentReady && _fAllOptionsSized))
#else
    if (SELECT_ISDROPBOX(_fFlavor))
#endif
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = a.Open(CA_ELEM2);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Calculate the visible range
    //
    hr = GetScrollTopBottom(&lScrollTop, &lScrollBottom);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Get the option's range
    //
    hr = pOption->QueryInterface(IID_IHTMLElement, (void**)&pElem);
    if (FAILED(hr))
        goto Cleanup;

    hr = pElem->get_offsetTop(&lTop);
    if (FAILED(hr))
        goto Cleanup;

    hr = pElem->get_offsetHeight(&lHeight);
    if (FAILED(hr))
        goto Cleanup;

    lBottom = lTop + lHeight;

    //
    // Make sure the option is not already visible
    //
    if ((lTop < lScrollTop) || (lBottom > lScrollBottom))
    {
        //
        // First, make sure that the option isn't just bigger than the control
        //
        if ((lTop < lScrollTop) && (lBottom > lScrollBottom))
            goto Cleanup;

        //
        // Determine if we're coming from the top or bottom
        //
        if (lTop < lScrollTop)
        {
            // From top
            lNewTop = lTop;
        }
        else
        {
            // From bottom
            lNewTop = lBottom - (lScrollBottom - lScrollTop);
        }

        hr = a.Elem2()->put_scrollTop(lNewTop);
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pElem);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetIndex()
//
// Synopsis:    Returns a pointer to the given index.
//
// Arguments:   long lIndex - Index of the option
//              IHTMLOptionElement2 **ppOption - Returns a pointer to the option
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::GetIndex(long lIndex, IHTMLOptionElement2 **ppOption)
{
    HRESULT     hr;
    IDispatch   *pDispatch = NULL;

    Assert(ppOption);

    hr = GetIndex(lIndex, &pDispatch);
    if (FAILED(hr))
        goto Cleanup;

    hr = pDispatch->QueryInterface(IID_IHTMLOptionElement2, (void**)ppOption);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pDispatch);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetIndex()
//
// Synopsis:    Returns a pointer to the given index.
//
// Arguments:   long lIndex - Index of the option
//              IPrivateOption **ppOption - Returns a pointer to the option
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::GetIndex(long lIndex, IPrivateOption **ppOption)
{
    HRESULT     hr;
    IDispatch   *pDispatch = NULL;

    Assert(ppOption);

    hr = GetIndex(lIndex, &pDispatch);
    if (FAILED(hr))
        goto Cleanup;

    hr = pDispatch->QueryInterface(IID_IPrivateOption, (void**)ppOption);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pDispatch);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetIndex()
//
// Synopsis:    Returns a pointer to the given index.
//
// Arguments:   long lIndex - Index of the option
//              IHTMLElement **ppOption - Returns a pointer to the option
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::GetIndex(long lIndex, IHTMLElement **ppElem)
{
    HRESULT     hr;
    IDispatch   *pDispatch = NULL;

    Assert(ppElem);

    hr = GetIndex(lIndex, &pDispatch);
    if (FAILED(hr))
        goto Cleanup;

    hr = pDispatch->QueryInterface(IID_IHTMLElement, (void**)ppElem);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pDispatch);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetIndex()
//
// Synopsis:    Returns a pointer to the given index.
//
// Arguments:   long lIndex - Index of the option
//              IDispatch **ppOption - Returns a pointer to the option
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::GetIndex(long lIndex, IDispatch **ppOption)
{
    HRESULT                 hr;
    IHTMLElementCollection  *pItems         = NULL;
    CVariant                var, var2;
    CContextAccess          a(_pSite);

    Assert(ppOption);

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_children((IDispatch**)&pItems);
    if (FAILED(hr))
        goto Cleanup;

    V_VT(&var) = VT_I4;
    V_I4(&var) = lIndex;
    hr = pItems->item(var, var2, ppOption);
    if (FAILED(hr))
        goto Cleanup;

    if (!*ppOption)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pItems);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SelectRange()
//
// Synopsis:    Selects a range of elements.
//              lAnchor is one end of the range. lNew is the new
//              end of the range. lLast is the old end of the range.
//              From these values, we can tell if we're selecting or
//              deselecting.
//
// Arguments:   long lAnchor - Beginning of the range
//              long lLast   - Old end of the range
//              long lNew    - New end of the range
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::SelectRange(long lAnchor, long lLast, long lNew)
{
    HRESULT                 hr;
    long                    lIndexStart, lIndexEnd;
    long                    lRangeLast, lRangeNew;
    long                    iItem;
    IHTMLElementCollection  *pItems         = NULL;
    IDispatch               *pDispatchItem  = NULL;
    IPrivateOption          *pOption        = NULL;
    IPrivateOption          *pAnchor        = NULL;
    VARIANT_BOOL            bAnchorHighlight;
    CVariant                var, var2;
    BOOL                    bUndo;
    CContextAccess          a(_pSite);

#if DBG == 1                // For Assert
    long                    cItems;
#endif

    if (lNew == lLast)
    {
        // No change, so exit
        hr = S_OK;
        goto Cleanup;
    }

    if (((lNew < lAnchor) && (lAnchor < lLast)) ||
        ((lNew > lAnchor) && (lAnchor > lLast)))
    {
        //
        // If we flip sides around the anchor,
        // then do one side before the other
        //
        hr = SelectRange(lAnchor, lLast, lAnchor);
        if (FAILED(hr))
            goto Cleanup;

        hr = SelectRange(lAnchor, lAnchor, lNew);

        // Done
        goto Cleanup;
    }

    bUndo = (abs(lNew - lAnchor) < abs(lLast - lAnchor));

    // Skip over the option that does not need to change
    lRangeLast = lLast;
    lRangeNew = lNew;
    if (bUndo)
    {
        if (lLast < lNew)
        {
            lRangeNew--;
        }
        else
        {
            lRangeNew++;
        }
    }
    else
    {
        if (lLast < lNew)
        {
            lRangeLast++;
        }
        else
        {
            lRangeLast--;
        }
    }

    if (lRangeLast < lRangeNew)
    {
        lIndexStart = lRangeLast;
        lIndexEnd = lRangeNew;
    }
    else
    {
        lIndexStart = lRangeNew;
        lIndexEnd = lRangeLast;
    }

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_children((IDispatch**)&pItems);
    if (FAILED(hr))
        goto Cleanup;

#if DBG == 1                // For Assert Check
    hr = pItems->get_length(&cItems);
    if (FAILED(hr))
        goto Cleanup;
#endif

    Assert( (lIndexStart >= 0)      && (lIndexEnd >= 0) && 
            (lIndexStart < cItems)  && (lIndexEnd < cItems) );

    hr = GetIndex(lAnchor, &pAnchor);
    if (FAILED(hr))
        goto Cleanup;

    hr = pAnchor->GetHighlight(&bAnchorHighlight);
    if (FAILED(hr))
        goto Cleanup;

    V_VT(&var) = VT_I4;
    for (iItem = lIndexStart; iItem <= lIndexEnd; iItem++)
    {
        V_I4(&var) = iItem;
        hr = pItems->item(var, var2, &pDispatchItem);
        if (FAILED(hr))
            goto Cleanup;

        hr = pDispatchItem->QueryInterface(IID_IPrivateOption, (void**)&pOption);
        if (FAILED(hr))
            goto Cleanup;

        if (_fDragMode)
        {
            if (bUndo)
            {
                hr = pOption->SetPrevHighlight();
                if (FAILED(hr))
                    goto Cleanup;
            }
            else
            {
                hr = pOption->SetHighlight(bAnchorHighlight);
                if (FAILED(hr))
                    goto Cleanup;
            }
        }
        else
        {
            hr = pOption->SetHighlight(bUndo ? VARIANT_FALSE : VARIANT_TRUE);
            if (FAILED(hr))
                goto Cleanup;
        }

        AdjustChangedRange(iItem);

        ClearInterface(&pDispatchItem);
        ClearInterface(&pOption);
    }

Cleanup:
    ReleaseInterface(pItems);
    ReleaseInterface(pDispatchItem);
    ReleaseInterface(pOption);
    ReleaseInterface(pAnchor);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::DropDownSelect()
//
// Synopsis:    Puts the text from the option into the display.
//
// Arguments:   IPrivateOption *pOption - Option to select
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::DropDownSelect(IPrivateOption *pOption)
{
    HRESULT         hr;
    CComBSTR        bstr;
    IHTMLElement    *pOptionElem = NULL;

    if (!_pElemDisplay)
    {
        return S_OK;
    }

    hr = pOption->QueryInterface(IID_IHTMLElement, (void**)&pOptionElem);
    if (FAILED(hr))
        goto Cleanup;

    // Put the text from the option into the display bar
    hr = pOptionElem->get_innerHTML(&bstr);
    if (FAILED(hr))
        goto Cleanup;
    hr = _pElemDisplay->put_innerHTML(bstr);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pOptionElem);
    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CIESelectElement::TogglePopup()
//
// Synopsis:    Toggles the popup open/closed.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::TogglePopup()
{
    HRESULT         hr;
    VARIANT_BOOL    bOpen;

    Assert(_pPopup);

    hr = _pPopup->get_isOpen(&bOpen);
    if (FAILED(hr))
        goto Cleanup;

    if (_bPopupOpen == VARIANT_TRUE)
    {
        hr = HidePopup();
        if (FAILED(hr))
            goto Cleanup;

        _bPopupOpen = VARIANT_FALSE;
    }
    else
    {
        hr = ShowPopup();
        if (FAILED(hr))
            goto Cleanup;

        _bPopupOpen = VARIANT_TRUE;
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::HidePopup()
//
// Synopsis:    Hides the popup.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::HidePopup()
{
    HRESULT         hr;     
    VARIANT_BOOL    bOpen;

    Assert(_pPopup && _pSelectInPopup );

    hr = _pPopup->get_isOpen(&bOpen);
    if (FAILED(hr))
        goto Cleanup;

    if (bOpen)
    {
        hr = _pPopup->hide();
        if (FAILED(hr))
            goto Cleanup;

        hr = SetDisplayHighlight(TRUE);
        if (FAILED(hr))
            goto Cleanup;

        hr = RefreshFocusRect();
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::ShowPopup()
//
// Synopsis:    Shows the popup.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::ShowPopup()
{
    HRESULT             hr;
    VARIANT_BOOL        bOpen;
    CContextAccess      a(_pSite);
    VARIANT             var;
    IUnknown            *pUnk = NULL;
    long                lHeightSelect;
    CComBSTR            bstrWritingMode(_T(""));
    CComBSTR            bstrHTML;
    long                lX;
    long                lY;
    long                lWidth;

    Assert(_pPopup && _pSelectInPopup);

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = SetDisplayHighlight(FALSE);
    if (FAILED(hr))
        goto Cleanup;

    hr = RefreshFocusRect();
    if (FAILED(hr))
        goto Cleanup;

    hr = _pPopup->get_isOpen(&bOpen);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->QueryInterface(IID_IUnknown, (void **)&pUnk);
    V_VT(&var)      = VT_UNKNOWN;
    V_UNKNOWN(&var) = pUnk;

    hr = a.Elem()->get_offsetHeight(&lHeightSelect);
    if (FAILED(hr))
        goto Cleanup;

    if (_pSelectInPopup)
    {
        if (_fWritingModeTBRL)
        {
            bstrWritingMode = _T("tb-rl");
        }
        hr = _pSelectInPopup->SetWritingMode(bstrWritingMode);
        if (FAILED(hr))
            goto Cleanup;
    }

#ifdef SELECT_GETSIZE
    if (!bOpen)
    {
        long lHeight;
        long lNumOptions;

        hr = GetNumOptions(&lNumOptions);
        if (FAILED(hr))
            goto Cleanup;

        // TODO: Fix SELECT_MAXOPTIONS with correct value
        lHeight = min(SELECT_MAXOPTIONS, lNumOptions);
        lHeight *= _sizeOption.cy;
        lHeight += 2;

        if (_fWritingModeTBRL)
        {   
            hr = a.Elem()->get_offsetWidth(&lHeightSelect);
            if (FAILED(hr))
                goto Cleanup;

            lX = lHeightSelect- lHeight-_sizeOption.cy;
            lY = 0;
            lWidth = lHeight;
            lHeight = _sizeSelect.cx;
        }
        else
        {
            lX = 0;
            lY = lHeightSelect;
            lWidth = _sizeSelect.cx;
        }
        hr = _pPopup->show(lX, lY, lWidth, lHeight, &var);
        if (FAILED(hr))
            goto Cleanup;
    }
#else
    if (!bOpen)
    {
        if (_fWritingModeTBRL)
        {
            lX = lHeightSelect- lHeight-_sizeOption.cy;
            lY = 0;
            lWidth = _lPopupSize.cy;
            lHeight = _lPopupSize.cx;
        }
        else
        {
            lX = o;
            lY = lHeightSelect;
            lWidth = _lPopupSize.cx;
            lHeight = _lPopupSize.cy;
        }
        hr = _pPopup->show(lX, lY, lWidth, lHeight, &var);
        if (FAILED(hr))
            goto Cleanup;
    }
#endif

Cleanup:
 
    ReleaseInterface(pUnk);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnChangeInPopup()
//
// Synopsis:    Called when there is a change in the popup.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::OnChangeInPopup()
{
    HRESULT hr;
    
    hr = HidePopup();
    if (FAILED(hr))
        goto Cleanup;

    hr = SynchSelWithPopup();
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SynchSelWithPopup()
//
// Synopsis:    Synchronizes the selection state between the popup
//              and the select.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::SynchSelWithPopup()
{
    HRESULT hr;
    long    lIndex;
    long    lPrevIndex;

    Assert(_pSelectInPopup);

    hr = _pSelectInPopup->GetSelectedIndex(&lIndex);
    if (FAILED(hr))
        goto Cleanup;

    hr = get_selectedIndex(&lPrevIndex);
    if (FAILED(hr))
        goto Cleanup;

    if (lPrevIndex != lIndex)
    {
        //
        // Only make a selection if there's a change
        //

        hr = Select(lIndex);
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnButtonMouseDown()
//
// Synopsis:    Called when the button in the drop control should
//              go down.
//
// Arguments:   CEventObjectAccess *pEvent  Event information
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::OnButtonMouseDown(CEventObjectAccess *pEvent)
{
    HRESULT         hr;
    VARIANT_BOOL    bOpen;

    Assert(_pPopup);

    hr = _pPopup->get_isOpen(&bOpen);
    if (FAILED(hr))
        goto Cleanup;

    if (bOpen == VARIANT_FALSE)
    {
        hr = PressButton(TRUE);
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::PressButton()
//
// Synopsis:    Makes the button appear up/down.
//
// Arguments:   BOOL bDown  - TRUE for down, FALSE for up
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::PressButton(BOOL bDown)
{
    HRESULT             hr = S_OK;
    CComBSTR            bstr;
    CVariant            var;

    if (bDown)
    {
        // Down border
        bstr = _T("1 inset");

        // Set the padding to make the arrow go down/right
        V_VT(&var) = VT_I4;
        V_I4(&var) = 2;
    }
    else
    {
        // Up border
        bstr = _T("2 outset");

        // Set the padding to make the arrow go back to center
        V_VT(&var) = VT_I4;
        V_I4(&var) = 0;
    }

    hr = _pStyleButton->put_border(bstr);
    if (FAILED(hr))
        goto Cleanup;

    hr = _pStyleButton->put_paddingTop(var);
    if (FAILED(hr))
        goto Cleanup;

    hr = _pStyleButton->put_paddingLeft(var);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::TimerProc()
//
// Synopsis:    Callback for the scrolling timer.
//
// Arguments:   HWND  hwnd      - Window handle owning the timer
//              UINT  uMsg      - Message ID
//              UINT  idEvent   - Timer ID
//              DWORD dwTime    - Time that has passed
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
VOID CALLBACK
CIESelectElement::TimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
    // If the ID does not match, then don't do anything
    if (idEvent != _iTimerID)
    {
        return;
    }

    if (_pTimerSelect)
    {
        //
        // We have a select to deal with
        //
        _pTimerSelect->HandleDownXY(_ptSavedPoint, _bSavedCtrl);
    }
    else
    {
        //
        // Someone didn't clear us, so we need to cleanup
        //
        if (KillTimer(NULL, _iTimerID))
        {
            _iTimerID = 0;
        }
    }
}
 
//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SetScrollTimeout()
//
// Synopsis:    Sets the scrolling timer.
//
// Arguments:   POINT pt    - Point where the mouse was
//              BOOL  bCtrl - TRUE if the CTRL key was down
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::SetScrollTimeout(POINT pt, BOOL bCtrl)
{
    if (_iTimerID)
    {
        ClearScrollTimeout();
    }

    _ptSavedPoint = pt;
    _bSavedCtrl = bCtrl;
    _pTimerSelect = this;
    _iTimerID = SetTimer(NULL, 0, SELECT_SCROLLWAIT, CIESelectElement::TimerProc);

    if (!_iTimerID)
    {
        _pTimerSelect = NULL;
        return E_FAIL;
    }
    
    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::ClearScrollTimeout()
//
// Synopsis:    Clears the scrolling timeout.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::ClearScrollTimeout()
{
    BOOL bSuccess = TRUE;

    if (_iTimerID)
    {
        bSuccess = KillTimer(NULL, _iTimerID);
        _iTimerID = 0;
        _pTimerSelect = NULL;
    }

    return bSuccess ? S_OK : E_FAIL;
}

#ifdef SELECT_TIMERVL
//+------------------------------------------------------------------
//
// Member:      CIESelectElement::InitTimerVLServices()
//
// Synopsis:    Initializes the critical section lock for the timer.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
VOID
CIESelectElement::InitTimerVLServices()
{
    if (_lTimerVLRef == 0)
    {
        // ISSUE: May happen more than once
        InitializeCriticalSection(&_lockTimerVL);
    }

    // Guaranteed to return 0, when _lTimerVLRef becomes 0
    // Not guaranteed to return _lTimerVLRef when nonzero (in Win95)
    // Guaranteed to return _lTimerVLRef in Win98/NT4
    InterlockedIncrement(&_lTimerVLRef);
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::DeInitTimerVLServices()
//
// Synopsis:    Frees the critical section lock.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
VOID
CIESelectElement::DeInitTimerVLServices()
{
    if (InterlockedDecrement(&_lTimerVLRef) == 0)
    {
        DeleteCriticalSection(&_lockTimerVL);
    }
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SetTimerVL()
//
// Synopsis:    Sets the VL timer.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
VOID
CIESelectElement::SetTimerVL()
{
    _iTimerVL = SetTimer(NULL, 0, SELECT_TIMERVLWAIT, CIESelectElement::TimerVLProc);
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::ClearTimerVL()
//
// Synopsis:    Kills the VL timer.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
VOID
CIESelectElement::ClearTimerVL()
{
    if (KillTimer(NULL, _iTimerVL))
    {
        _iTimerVL = 0;
    }
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::AddSelectToTimerVLQueue()
//
// Synopsis:    Adds a select to the queue.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
VOID
CIESelectElement::AddSelectToTimerVLQueue(CIESelectElement *pSelect)
{
    struct SELECT_TIMERVL_LINKELEM  *pElem = new struct SELECT_TIMERVL_LINKELEM;
    struct SELECT_TIMERVL_LINKELEM  *pParent;

    if (pElem)
    {
        BOOL bSetTimer;

        pElem->pNext = NULL;
        pElem->pSelect = pSelect;

        InitTimerVLServices();

        __try
        {
            EnterCriticalSection (&_lockTimerVL);

            bSetTimer = (_queueTimerVL == NULL);

            // Add to the queue
            if (_queueTimerVL == NULL)
            {
                _queueTimerVL = pElem;
            }
            else
            {
                pElem->pNext = _queueTimerVL;
                _queueTimerVL = pElem;
            }

            if (bSetTimer)
            {
                SetTimerVL();
            }
        }
        __finally
        {
            // Release ownership of the critical section
            LeaveCriticalSection (&_lockTimerVL);
        }
    }
    else
    {
        Assert(FALSE);
    }
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::TimerVLProc()
//
// Synopsis:    Called by the timer.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
VOID CALLBACK
CIESelectElement::TimerVLProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
    long    lNumRemoved = 0;
    long    lIndex;
    struct SELECT_TIMERVL_LINKELEM  *pRoot = NULL;
    struct SELECT_TIMERVL_LINKELEM  *pNode;

    if (idEvent != _iTimerVL)
        return;

    __try
    {
        EnterCriticalSection (&_lockTimerVL);

        ClearTimerVL();

        // Empty the queue
        pRoot = _queueTimerVL;
        _queueTimerVL = NULL;

    }
    __finally
    {
        // Release ownership of the critical section
        LeaveCriticalSection (&_lockTimerVL);
    }

    // Go through the nodes we retrieved
    while (pRoot)
    {
        pNode = pRoot;
        pRoot = pRoot->pNext;

        // Init the viewlink
        pNode->pSelect->InitViewLink();
        delete pNode;

        // Dealloc the reference to the timer services
        DeInitTimerVLServices();
    }
}
#endif


//+------------------------------------------------------------------------
//
// CIESelectElement::CEventSink
//
// IDispatch Implementation
// The event sink's IDispatch interface is what gets called when events
// are fired.
//
//-------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  Member:     CIESelectElement::CEventSink::GetTypeInfoCount
//              CIESelectElement::CEventSink::GetTypeInfo
//              CIESelectElement::CEventSink::GetIDsOfNames
//
//  Synopsis:   We don't really need a nice IDispatch... this minimalist
//              version does just plenty.
//
//-------------------------------------------------------------------------

STDMETHODIMP
CIESelectElement::CEventSink::GetTypeInfoCount(UINT* /*pctinfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CIESelectElement::CEventSink::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
                                   /* [in] */ LCID /*lcid*/,
                                   /* [out] */ ITypeInfo** /*ppTInfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CIESelectElement::CEventSink::GetIDsOfNames( REFIID          riid,
                                         OLECHAR**       rgszNames,
                                         UINT            cNames,
                                         LCID            lcid,
                                         DISPID*         rgDispId)
{
    return E_NOTIMPL;
}

//+------------------------------------------------------------------------
//
//  Member:     CIESelectElement::CEventSink::Invoke
//
//  Synopsis:   This gets called for all events on our object.  (it was
//              registered to do so in Init with attach_event.)  It calls
//              the appropriate parent functions to handle the events.
//
//-------------------------------------------------------------------------
STDMETHODIMP
CIESelectElement::CEventSink::Invoke(DISPID dispIdMember,
                                     REFIID, LCID,
                                     WORD wFlags,
                                     DISPPARAMS* pDispParams,
                                     VARIANT* pVarResult,
                                     EXCEPINFO*,
                                     UINT* puArgErr)
{
    HRESULT         hr          = S_OK;
    long            lCookie;
    CComBSTR        bstrEvent;
    BOOL            bRefire = FALSE;

    Assert(_pParent);

    if (!pDispParams || (pDispParams->cArgs < 1))
        goto Cleanup;

    if (pDispParams->rgvarg[0].vt == VT_DISPATCH)
    {
        CEventObjectAccess eoa(pDispParams);
        
        hr = eoa.Open(EOA_EVENTOBJ);
        if (FAILED(hr))
            goto Cleanup;

        hr = eoa.EventObj()->get_type(&bstrEvent);
        if (FAILED(hr))
            goto Cleanup;

        if (_dwFlags & SELECTES_POPUP)
        {
            if (!StrCmpICW(bstrEvent, L"change"))
            {
                hr = _pParent->OnChangeInPopup();
                if (FAILED(hr))
                    goto Cleanup;
            }
            else if (!StrCmpICW(bstrEvent, L"keydown"))
            {
                bRefire = TRUE;
                lCookie = _pParent->_lOnKeyDownCookie;
            }
            else if (!StrCmpICW(bstrEvent, L"keyup"))
            {
                bRefire = TRUE;
                lCookie = _pParent->_lOnKeyUpCookie;
            }
            else if (!StrCmpICW(bstrEvent, L"keypress"))
            {
                bRefire = TRUE;
                lCookie = _pParent->_lOnKeyPressedCookie;
            }
       }
        else if (_dwFlags & SELECTES_VIEWLINK)
        {
            if (!StrCmpICW(bstrEvent, L"mousedown"))
            {
                hr = _pParent->OnMouseDown(&eoa);
                if (FAILED(hr))
                    goto Cleanup;

                lCookie = _pParent->_lOnMouseDownCookie;
                bRefire = TRUE;
            }
            else if (!StrCmpICW(bstrEvent, L"selectstart"))
            {
                hr = _pParent->OnSelectStart(&eoa);
                if (FAILED(hr))
                    goto Cleanup;
            }
            else if (!StrCmpICW(bstrEvent, L"contextmenu"))
            {
                hr = _pParent->OnContextMenu(&eoa);
                if (FAILED(hr))
                    goto Cleanup;
            }
            else if (!StrCmpICW(bstrEvent, L"beforefocusenter"))
            {
                hr = _pParent->CancelEvent(&eoa);
                if (FAILED(hr))
                    goto Cleanup;
            }
            else if (!StrCmpICW(bstrEvent, L"mouseup"))
            {
                bRefire = TRUE;
                lCookie = _pParent->_lOnMouseUpCookie;
            }
            else if (!StrCmpICW(bstrEvent, L"click"))
            {
                bRefire = TRUE;
                lCookie = _pParent->_lOnClickCookie;
            }
        }
        else if (_dwFlags & SELECTES_BUTTON)
        {
            if (!StrCmpICW(bstrEvent, L"mousedown"))
            {
                hr = _pParent->OnButtonMouseDown(&eoa);
                if (FAILED(hr))
                    goto Cleanup;
            }
            else if (!StrCmpICW(bstrEvent, L"mouseout") || !StrCmpICW(bstrEvent, L"mouseup"))
            {
                hr = _pParent->PressButton(FALSE);
                if (FAILED(hr))
                    goto Cleanup;
            }
        }
        else if (_dwFlags & SELECTES_INPOPUP)
        {
            // ISSUE: This might not be needed if popup is able to send keystrokes
            if (!StrCmpICW(bstrEvent, L"keydown"))
            {
                hr = _pParent->OnKeyDown(&eoa);
                if (FAILED(hr))
                    goto Cleanup;
            }
        }

        if (bRefire)
        {
            // Cancel bubbling to master
            hr = eoa.EventObj()->put_cancelBubble(VB_TRUE);
            if (FAILED(hr))
                goto Cleanup;

            // refire the event on master
            hr = _pParent->FireEvent(lCookie, NULL, bstrEvent);
            if (FAILED(hr))
                goto Cleanup;
        }

    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CIESelectElement::CEventSink
//
//  Synopsis:   This is used to allow communication between the parent class
//              and the event sink class.  The event sink will call the ProcOn*
//              methods on the parent at the appropriate times.
//
//-------------------------------------------------------------------------

CIESelectElement::CEventSink::CEventSink(CIESelectElement *pParent, DWORD dwFlags)
{
    _pParent = pParent;
    _dwFlags = dwFlags;
}

// ========================================================================
// CIESelectElement::CEventSink
//
// IUnknown Implementation
// Vanilla IUnknown implementation for the event sink.
// ========================================================================

STDMETHODIMP
CIESelectElement::CEventSink::QueryInterface(REFIID riid, void ** ppUnk)
{
    void * pUnk = NULL;

    if (riid == IID_IDispatch)
        pUnk = (IDispatch*)this;

    if (riid == IID_IUnknown)
        pUnk = (IUnknown*)this;

    if (pUnk)
    {
        *ppUnk = pUnk;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
CIESelectElement::CEventSink::AddRef(void)
{
    return ((IElementBehavior*)_pParent)->AddRef();
}

STDMETHODIMP_(ULONG)
CIESelectElement::CEventSink::Release(void)
{
    return ((IElementBehavior*)_pParent)->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\winres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// winres.h - Windows resource definitions
//  extracted from WINUSER.H and COMMCTRL.H

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#define VS_VERSION_INFO     1

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS // Ignore following symbols
#endif

#ifndef WINVER
#define WINVER 0x0400   // default to Windows Version 4.0
#endif

#include <winresrc.h>

#ifdef _MAC
#define DS_WINDOWSUI    0x8000L
#endif

// operation messages sent to DLGINIT
#define LB_ADDSTRING    (WM_USER+1)
#define CB_ADDSTRING    (WM_USER+3)

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC      (-1)

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\slidebar.cxx ===
//+------------------------------------------------------------------
//
// Microsoft IEPEERS
// Copyright (C) Microsoft Corporation, 1999.
//
// File:        iextags\scrllbar.cxx
//
// Contents:    Scrollbar Control
//
// Classes:     CSliderBar
//
// Interfaces:  IScrollBar
//
//-------------------------------------------------------------------

#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "iextag.h"
#include "math.h"

#include "utils.hxx"

#include "utbutton.hxx"
#include "slidebar.hxx"

#define CheckResult(x) { hr = x; if (FAILED(hr)) goto Cleanup; }

/////////////////////////////////////////////////////////////////////////////
//
// CSliderBar
//
/////////////////////////////////////////////////////////////////////////////

const CBaseCtl::PROPDESC CSliderBar::s_propdesc[] = 
{
    {_T("max"), VT_I4, 100},
    {_T("min"), VT_I4, 0},
    {_T("unit"), VT_I4, 1},
    {_T("block"), VT_I4, 10},
    {_T("position"), VT_I4, 0},
    {_T("orientation"), VT_BSTR, 0, _T("horizontal")},

    NULL
};

enum
{
    eMax = 0,
    eMin,
    eUnit,
    eBlock,
    ePosition,
    eOrientation
};

//+------------------------------------------------------------------------
//
//  Members:    CSliderBar::CSliderBar
//              CSliderBar::~CSliderBar
//
//  Synopsis:   Constructor/Destructor
//
//-------------------------------------------------------------------------

CSliderBar::CSliderBar()
{
}

CSliderBar::~CSliderBar()
{
    if (_pSinkBlockInc)
    {
        delete _pSinkBlockInc;
    }
    if (_pSinkBlockDec)
    {
        delete _pSinkBlockDec;
    }
    if (_pSinkSlider)
    {
        delete _pSinkSlider;
    }
    if (_pSinkDelayTimer)
    {
        delete _pSinkDelayTimer;
    }
    if (_pSinkRepeatTimer)
    {
        delete _pSinkRepeatTimer;
    }
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::Init()
//
// Synopsis:    Set up the scroll bar's events
//
// Arguments:   None
//
// Returns:     Success if the control is setup correctly.
//
//-------------------------------------------------------------------


HRESULT
CSliderBar::Init()
{
    HRESULT hr = S_OK;
    CContextAccess  a(_pSite);

    CheckResult( a.Open(CA_DEFAULTS | CA_SITEOM | CA_DEFSTYLE));

    // Setup overflow

    CheckResult( a.DefStyle()->put_overflow(CComBSTR("hidden")));

    //
    // Register the scrollbar name
    //

    CheckResult( a.SiteOM()->RegisterName(_T("sliderbar")));

    //
    // Register for events
    //

    CheckResult( AttachEvent(EVENT_ONMOUSEUP, &a));
    CheckResult( AttachEvent(EVENT_ONMOUSEDOWN, &a));
    CheckResult( AttachEvent(EVENT_ONKEYDOWN, &a));
    CheckResult( AttachEvent(EVENT_ONPROPERTYCHANGE, &a));
    CheckResult( AttachEvent(EVENT_ONSELECTSTART, &a));
    CheckResult( AttachEvent(EVENT_ONFOCUS, &a));
    CheckResult( AttachEvent(EVENT_ONBLUR, &a));

    // We want to be able to receive keyboard focus

    CheckResult( a.Defaults()->put_tabStop(VB_TRUE));
    CheckResult( a.Defaults()->put_viewMasterTab(VB_TRUE));

    //
    // Register the sliderbar's events
    //

	CheckResult( RegisterEvent(a.SiteOM(), CComBSTR("onscroll"), &_lOnScrollCookie));
    CheckResult( RegisterEvent(a.SiteOM(), CComBSTR("onchange"), &_lOnChangeCookie));

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CSliderBar::Detach()
//
// Synopsis:    Releases interfaces.
//
// Arguments:   None
//
// Returns:     S_OK
//
//-------------------------------------------------------------------

HRESULT
CSliderBar::Detach()
{
    _pSliderThumb->Unload();

    ReleaseInterface(_pBlockInc);
    ReleaseInterface(_pBlockDec);
    ReleaseInterface(_pSliderBar);
    ReleaseInterface(_pTrack);
    ReleaseInterface(_pContainer);

    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::OnContentReady()
//
// Synopsis:    Called when the HTML content for the control is ready.
//
// Arguments:   None
//
// Returns:     Success if the control is created correctly.
//
//-------------------------------------------------------------------

HRESULT
CSliderBar::OnContentReady()
{
    HRESULT hr = S_OK;

    //
    // Cache the properties
    //

    CheckResult( ReadProperties());

    //
    // Create the button
    //

    CheckResult( BuildContainer());
    CheckResult( BuildSliderBar());
    CheckResult( BuildSliderTrack());
    CheckResult( BuildBlockDecrementer());
    CheckResult( BuildSliderThumb());
    CheckResult( BuildBlockIncrementer());

    //
    // Calculate dimensions and layout correctly
    //

    CheckResult( Layout());
    
Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CSliderBar::OnPropertyChange()
//
// Synopsis:    Called when the scrollbar property changes.  Gives us the 
//              chance to redraw if the scrollbar is changed dynamically
//
// Arguments:   Names of changes property
//
// Returns:     Success if the control is created correctly.
//
//-------------------------------------------------------------------

HRESULT
CSliderBar::OnPropertyChange(CEventObjectAccess *pEvent, BSTR propertyName)
{
    HRESULT hr = S_OK;

    CheckResult( Layout());

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::OnMouseDown()
//
// Synopsis:    Called to handle 'onmousedown' event; 
//              Sets focus on element triggering an onfocus event
//
// Arguments:   Event Object
//
// Returns:     Success if the control is created correctly.
//
//-------------------------------------------------------------------


HRESULT
CSliderBar::OnMouseDown(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    CContextAccess a(_pSite);

    CheckResult( a.Open(CA_ELEM2))

    CheckResult( a.Elem2()->focus());

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CSliderBar::OnMouseUp()
//
// Synopsis:    Called to handle 'onmouseup' event; does a page inc/dec
//
// Arguments:   Event Object
//
// Returns:     Success if the control is handled property.
//
//-------------------------------------------------------------------


HRESULT
CSliderBar::OnMouseUp(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::OnKeyDown()
//
// Synopsis:    Called to handle 'onmouseup' event; does a page inc/dec
//
// Arguments:   Event Object
//
// Returns:     Success if the control is handled property.
//
//-------------------------------------------------------------------


HRESULT
CSliderBar::OnKeyDown(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    long                lKeyCode;

    CheckResult( pEvent->GetKeyCode(&lKeyCode));

    switch (lKeyCode)
    {
        case VK_END:            
        {
            _lCurrentPosition = _lMaxPosition;

            CheckResult( SetThumbPosition( _lCurrentPosition ));
            break;
        }

        case VK_HOME:
        {
            _lCurrentPosition = _lMinPosition;

            CheckResult( SetThumbPosition( _lCurrentPosition ));
            break;
        }

        case VK_NEXT:
        {
            _lCurIncrement = _lBlockIncrement;
            
            CheckResult( DoIncrement());
            break;
        }

        case VK_PRIOR:
        {
            _lCurIncrement = - _lBlockIncrement;
            
            CheckResult( DoIncrement());
            break;
        }

        case VK_DOWN:
        case VK_RIGHT:
        {
            _lCurIncrement = _lUnitIncrement;

            CheckResult( DoIncrement());
            break;
        }
        
        case VK_UP:
        case VK_LEFT:
        {
            _lCurIncrement = - _lUnitIncrement;

            CheckResult( DoIncrement());
            break;
        }
    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::OnSelectStart
//
// Synopsis:    Called to handel 'onclick' event
//
// Arguments:   Names of changes property
//
// Returns:     Success if the control is created correctly.
//
//-------------------------------------------------------------------

HRESULT
CSliderBar::OnSelectStart(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    CheckResult( pEvent->EventObj()->put_cancelBubble( VARIANT_TRUE ));
    CheckResult( pEvent->EventObj()->put_returnValue( CComVariant(false) ));

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CSliderBar::OnFocus
//
// Synopsis:    Called to handel 'onfocus' event
//
// Arguments:   Names of changes property
//
// Returns:     Success if the control is created correctly.
//
//-------------------------------------------------------------------


HRESULT
CSliderBar::OnFocus(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    return hr;
}

HRESULT
CSliderBar::GetFocusRect(RECT * pRect)
{
    HRESULT hr = S_OK;

    CContextAccess a(_pSite);

    a.Open(CA_STYLE);

    CheckResult( a.Style()->get_pixelWidth(&pRect->right));
    CheckResult( a.Style()->get_pixelHeight(&pRect->bottom));

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::OnBlur
//
// Synopsis:    Called to handel 'onblur' event
//
// Arguments:   Names of changes property
//
// Returns:     Success if the control is created correctly.
//
//-------------------------------------------------------------------


HRESULT
CSliderBar::OnBlur(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::BuildContainer()
//
// Synopsis:    Builds the scrollbar container DIV.
//
// Arguments:   None
//
// Returns:     Success if the control is created correctly.
//
//-------------------------------------------------------------------



HRESULT
CSliderBar::BuildContainer()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLStyle> pStyle;

    CComPtr<IDispatch> pDispDocLink;
    CComPtr<IHTMLDocument2> pDocLink;

    CComBSTR    bstr;

    CContextAccess a(_pSite);
    
    hr = a.Open( CA_ELEM | CA_STYLE | CA_DEFAULTS);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Style()->get_pixelWidth(&_width);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Style()->get_pixelHeight(&_height);
    if (FAILED(hr))
        goto Cleanup;

    hr = GetHTMLDocument(_pSite, &pDoc);
    if (FAILED(hr))
        goto Cleanup;

    hr = pDoc->createElement(CComBSTR("div"), &_pContainer);
    if (FAILED(hr))
        goto Cleanup;

    hr = _pContainer->get_style(&pStyle);
    if (FAILED(hr))
        goto Cleanup;

    hr = pStyle->put_pixelWidth(_width);
    if (FAILED(hr))
        goto Cleanup;

    hr = pStyle->put_pixelHeight(_height);
    if (FAILED(hr))
        goto Cleanup;

    hr = pStyle->put_backgroundColor(CComVariant("transparent"));
    if (FAILED(hr))
        goto Cleanup;

    hr = pStyle->put_overflow(CComBSTR("hidden"));
    if (FAILED(hr))
        goto Cleanup;


    //
    // Set up the view link
    //

    CheckResult( _pContainer->get_document(&pDispDocLink));
    CheckResult( pDispDocLink->QueryInterface(IID_IHTMLDocument2, (void**) &pDocLink));
    CheckResult( a.Defaults()->putref_viewLink(pDocLink));

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CSliderBar::DoIncrement()
//
// Synopsis:    Increments current position by the current increment amount
//              which is set by the various unit or block incrementers.
//              Fires and event, and sets the thumb position to the new value.
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------

HRESULT
CSliderBar::DoIncrement()
{
    HRESULT hr = S_OK;

    long _lOldPosition = _lCurrentPosition;

    _lCurrentPosition += _lCurIncrement;
    
    //
    //  Don't let it go below the mininum
    //

    if(_lCurrentPosition < _lMinPosition)
    {
        _lCurrentPosition = _lMinPosition;
    }

    //
    //  Or above the maximum
    //

    else if(_lCurrentPosition > _lMaxPosition)
    {
        _lCurrentPosition = _lMaxPosition;
    }

    //
    //  Move the thumb
    //

    CheckResult( SetThumbPosition( _lCurrentPosition ));

    //
    //  If position has changed, fire an event...
    //

    if(_lOldPosition != _lCurrentPosition) 
    {

        CheckResult( FireEvent( _lOnChangeCookie, NULL, CComBSTR("change")) );

    }

Cleanup:

    return hr;

}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::MouseMoveCallback()
//
// Synopsis:    Performs a sanity check on the proposed coordinate.
//              Called by the slider thumb when an attempt is made to move it
//
// Arguments:   None
//
// Returns:     true if button can be moved, false otherwise
//
//-------------------------------------------------------------------


HRESULT 
CSliderBar::MouseMoveCallback(CUtilityButton *pButton, long &x, long &y)
{
    HRESULT hr = S_OK;

    //
    // Can't extend past slider bar
    //

    long max = TrackLength() - ThumbLength();

    if(_eoOrientation == Horizontal) 
    {

        if(x < 0)
            x = 0;

        if(x > max)
            x = max;

        //
        // Snap to grid
        //

        x = (long) (floor ( (x / PixelsPerUnit()) + 0.5) * PixelsPerUnit());

        //
        // Reset the current position
        //

        CheckResult( SyncThumbPosition( x ));
    }

    else 
    {

        if(y < 0)
            y = 0;

        if(y > max)
            y = max;

        //
        // Snap to grid
        //

        y = (long) (floor ( (y / PixelsPerUnit()) + 0.5) * PixelsPerUnit());

        //
        // Reset the current position
        //

        CheckResult( SyncThumbPosition( y ));
    }


    //
    // This stuff is for performance conciderations, with three divs making up the slider
    // (track, thumb, track), moving that thumb and continuously resizng the track elements 
    // caused ragged movement.  Instead, we won't display them once the thumb starts to move, and
    // turn them back on when the thumb stops.
    //

    if(! pButton->IsMoving()) 
    {
        CheckResult( SetBlockMoverPositions());

        CheckResult( BlockDisplay(_pBlockDec, true));
        CheckResult( BlockDisplay(_pBlockInc, true));
    }
    else 
    {
        CheckResult( BlockDisplay(_pBlockDec, false));
        CheckResult( BlockDisplay(_pBlockInc, false));
    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::StartDelayTimer()
//
// Synopsis:    Sets up the Delay timeout and builds its event sink if necessary
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------

HRESULT
CSliderBar::StartDelayTimer()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLWindow2> pWindow;
    CComPtr<IHTMLWindow3> pWindow3;
    CComVariant vDispatch;
    CComVariant vLanguage;

    //
    //  Create a new timer sink if one doesn't exist yet
    //

    if(! _pSinkDelayTimer) 
    {

        _pSinkDelayTimer = new CEventSink(this, NULL, SLIDER_DELAY_TIMER);
        if (!_pSinkDelayTimer)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

    }

    //
    // Setup the Delay Timer
    //

    vDispatch = _pSinkDelayTimer;
    _pSinkDelayTimer->AddRef();

    Assert( _lDelayTimerId == 0);

    CheckResult( GetHTMLDocument(_pSite, &pDoc));
    CheckResult( pDoc->get_parentWindow( &pWindow));
    CheckResult( pWindow->QueryInterface( __uuidof(IHTMLWindow3), (void **) &pWindow3 ));
    CheckResult( pWindow3->setTimeout( &vDispatch, GetDelayRate(), &vLanguage, &_lDelayTimerId ));

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CSliderBar::ClearDelayTimer()
//
// Synopsis:    Stops the delay timer
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------

HRESULT
CSliderBar::ClearDelayTimer()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLWindow2> pWindow;

    //
    //  Clear the delay timer
    //

    if(_lDelayTimerId)
    {

        CheckResult( GetHTMLDocument(_pSite, &pDoc));
        CheckResult( pDoc->get_parentWindow( &pWindow));
        CheckResult( pWindow->clearTimeout( _lDelayTimerId ));

        _lDelayTimerId = 0;

    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::OnDelay()
//
// Synopsis:    Called when the Delay timeout fires.  Clears the timer,
//              increments, and then starts the Repeat interval timer
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------

HRESULT
CSliderBar::OnDelay()
{
    HRESULT hr = S_OK;

    //
    //  Clear the delay timer; start the repeat timer
    //

    CheckResult( ClearDelayTimer());
    CheckResult( DoIncrement());
    CheckResult( StartRepeatTimer());

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CSliderBar::StartRepeatTimer()
//
// Synopsis:    Sets up the repeat timer and builds its event sink if necessary
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------

HRESULT
CSliderBar::StartRepeatTimer()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLWindow2> pWindow;
    CComPtr<IHTMLWindow3> pWindow3;
    CComVariant vDispatch;
    CComVariant vLanguage;

    //
    // Setup the Timer interval
    //

    if (! _pSinkRepeatTimer )
    {

        _pSinkRepeatTimer = new CEventSink(this, NULL, SLIDER_REPEAT_TIMER);
        if (!_pSinkRepeatTimer)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

    }

    vDispatch = _pSinkRepeatTimer;
    _pSinkRepeatTimer->AddRef();

    Assert( _lRepeatTimerId == 0);

    CheckResult( GetHTMLDocument(_pSite, &pDoc));
    CheckResult( pDoc->get_parentWindow( &pWindow));
    CheckResult( pWindow->QueryInterface( __uuidof(IHTMLWindow3), (void **) &pWindow3 ));
    CheckResult( pWindow3->setInterval( &vDispatch, GetRepeatRate(), &vLanguage, &_lRepeatTimerId ));

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::ClearRepeatTimer()
//
// Synopsis:    Stops the repeat timer
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------

HRESULT
CSliderBar::ClearRepeatTimer()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLWindow2> pWindow;

    if(_lRepeatTimerId)
    {

        CheckResult( GetHTMLDocument(_pSite, &pDoc));
        CheckResult( pDoc->get_parentWindow( &pWindow));
        CheckResult( pWindow->clearInterval( _lRepeatTimerId ));

        _lRepeatTimerId = 0;

    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::OnRepeat()
//
// Synopsis:    Fires the incrementer
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT
CSliderBar::OnRepeat()
{
    HRESULT hr = S_OK;

    CheckResult( DoIncrement());

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::ClearTimers()
//
// Synopsis:    Stops any active timers.  Effectively, this stops repeating actions
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT
CSliderBar::ClearTimers()
{
    HRESULT hr = S_OK;

    CheckResult( ClearDelayTimer());
    CheckResult( ClearRepeatTimer());

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CSliderBar::BlockMoveStartInc()
//
// Synopsis:    Start the block increment process
//
// Arguments:   CEventObjectAccess
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT   
CSliderBar::BlockMoveStartInc(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLElement2> pElement2;

    _moving    = true;
    _pCurBlock = _pBlockInc;

    CheckResult( _pBlockInc->QueryInterface( __uuidof(IHTMLElement2), (void **) &pElement2));
    CheckResult( pElement2->setCapture());
    CheckResult( BlockIncrement());
    CheckResult( BlockHighlight(_pBlockInc, true));

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CSliderBar::BlockMoveStartDec()
//
// Synopsis:    Start the block decrement process
//
// Arguments:   CEventObjectAccess
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT 
CSliderBar::BlockMoveStartDec(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLElement2> pElement2;

    _moving    = true;
    _pCurBlock = _pBlockDec;

    CheckResult( _pBlockDec->QueryInterface( __uuidof(IHTMLElement2), (void **) &pElement2));
    CheckResult( pElement2->setCapture());
    CheckResult( BlockDecrement());
    CheckResult( BlockHighlight(_pBlockDec, true));

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CSliderBar::BlockMoveSuspend()
//
// Synopsis:    Used to suspend and restart the repeater timers.  
//
// Arguments:   CEventObjectAccess
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT   
CSliderBar::BlockMoveSuspend(CEventObjectAccess *pEvent, IHTMLElement *pTrack)
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLElement> pSrcElement;

    pEvent->Open(EOA_EVENTOBJ);

    if( _moving ) 
    {
        CheckResult( pEvent->EventObj()->get_srcElement(&pSrcElement))

        if(! IsSameObject( pSrcElement, pTrack) )
        {
            _suspended = true;

            CheckResult( BlockHighlight(pTrack, false));
            CheckResult( ClearRepeatTimer());
        }

        else if( _suspended ) 
        {
            _suspended = false;
    
            CheckResult( BlockHighlight(pTrack, true));
            CheckResult( StartRepeatTimer());

        }
    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::BlockMoveResume()
//
// Synopsis:    Resumes the repeating move functionality by restarting the timer
//
// Arguments:   CEventObjectAccess
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT   
CSliderBar::BlockMoveResume(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    if( _moving ) 
    {
        CheckResult( StartRepeatTimer());
    }

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CSliderBar::BlockMoveEnd()
//
// Synopsis:    Shuts down the block move process buy dehighlighting the area
//              and stopping any timers
//
// Arguments:   CEventObjectAccess
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT   
CSliderBar::BlockMoveEnd(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLElement2> pElement2;

    if(_pCurBlock) 
    {
        CheckResult( _pCurBlock->QueryInterface( __uuidof(IHTMLElement2), (void **) &pElement2));
        CheckResult( pElement2->releaseCapture());
    }

    CheckResult( ClearTimers());
    CheckResult( BlockHighlight( _pBlockInc, false));
    CheckResult( BlockHighlight( _pBlockDec, false));

    _moving = false;
    _suspended = false;
    _pCurBlock = NULL;

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::BlockCheck()
//
// Synopsis:    Checks to see if the mouse coordinates of the pEvent object
//              fall withing the bounding box of the current block move element.
//              If not, the repeat action is halted buy clearing the timers
//
// Arguments:   CEventObjectAccess *pEvent
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT   
CSliderBar::BlockMoveCheck(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    POINT ptClient;
    CComPtr<IHTMLRect> pRect;
    CComPtr<IHTMLElement2> pElement2;

    long top, left, right, bottom;

    if(! _pCurBlock)
        return S_OK;

    CheckResult( pEvent->GetWindowCoordinates(&ptClient));

    CheckResult( _pCurBlock->QueryInterface( __uuidof(IHTMLElement2), (void **) &pElement2));
    CheckResult( pElement2->getBoundingClientRect(&pRect));

    CheckResult( pRect->get_left(&left));
    CheckResult( pRect->get_top(&top));
    CheckResult( pRect->get_right(&right));
    CheckResult( pRect->get_bottom(&bottom));

    if(! (((ptClient.x >= left) && (ptClient.x <= right)) && 
          ((ptClient.y >= top)  && (ptClient.y <= bottom)))) 
    {
        CheckResult( BlockHighlight(_pCurBlock, false));
        CheckResult( ClearTimers());
    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::BlockDisplay()
//
// Synopsis:    Used set the display property to 'none' before move
//              the slider thumb so that it appears to move more smoothly.
//              After the move is completed, the display is set to inline.
//
// Arguments:   IHTMLElement pBlock - the block to hightlight
//              bool flag           - turn on or off
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT   
CSliderBar::BlockDisplay(IHTMLElement *pBlock, bool flag)
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLStyle> pStyle;

    CComBSTR bstr;

    bstr       = flag ? _T("inline") : _T("none");

    CheckResult( pBlock->get_style(&pStyle));
    CheckResult( pStyle->put_display(bstr));


Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::BlockHighlight()
//
// Synopsis:    Used set the display property to 'none' before move
//              the slider thumb so that it appears to move more smoothly.
//              After the move is completed, the display is set to inline.
//
// Arguments:   IHTMLElement pBlock - the block to hightlight
//              bool flag           - turn on or off
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------

HRESULT   
CSliderBar::BlockHighlight(IHTMLElement *pBlock, bool flag)
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLStyle> pStyle;

    CComBSTR color;

    color       = flag ? _T("transparent") : _T("transparent");

    CheckResult( pBlock->get_style(&pStyle));
    CheckResult( pStyle->put_backgroundColor(CComVariant(color)));


Cleanup:

    return hr;

}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::BlockIncrement()
//
// Synopsis:    Increments the scrollbar one page (or as much of one as
//              possible)
//
// Arguments:   None
//
// Returns:     S_OK
//
//-------------------------------------------------------------------


HRESULT  
CSliderBar::BlockIncrement() 
{
    HRESULT hr = S_OK;

    _lCurIncrement = _lBlockIncrement;

    CheckResult( DoIncrement());
    CheckResult( StartDelayTimer());

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CSliderBar::BlockDecrement()
//
// Synopsis:    Decrements the scrollbar one page (or as much of one as
//              possible)
//
// Arguments:   None
//
// Returns:     S_OK
//
//-------------------------------------------------------------------


HRESULT  
CSliderBar::BlockDecrement()
{
    HRESULT hr = S_OK;

    _lCurIncrement = - _lBlockIncrement;

    CheckResult( DoIncrement());
    CheckResult( StartDelayTimer());

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CSliderBar::SetThumbPosition()
//
// Synopsis:    Set the thumb position to the location determined by the 
//              unit
//
// Arguments:   None
//
// Returns:     S_OK
//
//-------------------------------------------------------------------


HRESULT  
CSliderBar::SetThumbPosition(long position)
{
    HRESULT hr = S_OK;

    double  pixPerUnit;

    //
    //  Update the OM
    //

    GetProps()[ePosition].Set(position); 

    //
    //  Calculate the offset of the thumb
    //

    _sliderOffset = NearestLong( (PixelsPerUnit() * (double) (position - _lMinPosition)));

    if ( _eoOrientation == Horizontal ) 
    {

        CheckResult( _pSliderThumb->SetHorizontalOffset(_sliderOffset));

    }
    else 
    {

        CheckResult( _pSliderThumb->SetVerticalOffset(_sliderOffset));

    }

    CheckResult( SetBlockMoverPositions());

Cleanup:

    return S_OK;
}


//+------------------------------------------------------------------
//
// Member:      CSliderBar::SyncThumbPosition()
//
// Synopsis:    Essentially the inverse of SetThumbPositoin.  This function
//              sets the _lCurrentPosition from the thumb's location within 
//              the slider bar.
//
// Arguments:   x, y coordinates of thumb (relative to slider bar)
//
// Returns:     S_OK
//
//-------------------------------------------------------------------


HRESULT  
CSliderBar::SyncThumbPosition(long pixels)
{
    HRESULT hr = S_OK;

    long _lOldPosition = _lCurrentPosition;

    _lCurrentPosition   = ((long) (pixels / PixelsPerUnit())) + _lMinPosition;
    _sliderOffset       = pixels;

    if(_lOldPosition != _lCurrentPosition)
    {
        CheckResult ( FireEvent( _lOnChangeCookie, NULL, CComBSTR("change")));
        CheckResult ( FireEvent( _lOnScrollCookie, NULL, CComBSTR("scroll")));
    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::SetBlockMoverPositions()
//
// Synopsis:    Sets the position of the page move zone based on slider thumb
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------



HRESULT
CSliderBar::SetBlockMoverPositions()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLStyle> pIncStyle, pDecStyle;

    //
    //  Calculate dimensions of regions around the slider thumb
    //

    long decPosition  = 0L;
    long decLength    = _sliderOffset;

    long incPosition  = ThumbLength() + _sliderOffset;
    long incLength    = TrackLength() - ThumbLength() - _sliderOffset;

    CheckResult( _pBlockInc->get_style(&pIncStyle));
    CheckResult( _pBlockDec->get_style(&pDecStyle));

    if ( _eoOrientation == Horizontal ) 
    {
        CheckResult( pDecStyle->put_pixelLeft(decPosition));
        CheckResult( pDecStyle->put_pixelWidth(decLength));

        CheckResult( pIncStyle->put_pixelLeft(incPosition));
        CheckResult( pIncStyle->put_pixelWidth(incLength));
    }
    else 
    {
        CheckResult( pDecStyle->put_pixelTop(decPosition));
        CheckResult( pDecStyle->put_pixelHeight(decLength));

        CheckResult( pIncStyle->put_pixelTop(incPosition));
        CheckResult( pIncStyle->put_pixelHeight(incLength));
    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::BuildSliderThumb()
//
// Synopsis:    Builds the slider thumb button
//
// Arguments:   None
//
// Returns:     S_OK if it can be built
//
//-------------------------------------------------------------------



HRESULT
CSliderBar::BuildSliderThumb()
{
    HRESULT hr = S_OK;
    CComVariant faceColor, v3dLightColor, highlightColor, shadowColor, darkShadowColor;

    unsigned freedom = (_eoOrientation == Vertical) ? BUTTON_MOVEABLE_Y : BUTTON_MOVEABLE_X;
    
    CheckResult( CUtilityButton::Create(this, _pSliderBar, &_pSliderThumb));

    CheckResult( GetFaceColor(&faceColor));
    CheckResult( Get3DLightColor(&v3dLightColor));
    CheckResult( GetHighlightColor(&highlightColor));
    CheckResult( GetShadowColor(&shadowColor));
    CheckResult( GetDarkShadowColor(&darkShadowColor))

    CheckResult( _pSliderThumb->SetAbilities( freedom ));

    CheckResult( _pSliderThumb->SetFaceColor(  faceColor ));
    CheckResult( _pSliderThumb->SetFaceColor(  faceColor ));
    CheckResult( _pSliderThumb->Set3DLightColor( v3dLightColor ));
    CheckResult( _pSliderThumb->SetHighlightColor( highlightColor ));
    CheckResult( _pSliderThumb->SetShadowColor( shadowColor ));
    CheckResult( _pSliderThumb->SetDarkShadowColor( darkShadowColor ));

    CheckResult( _pSliderThumb->SetMovedCallback((PFN_MOVED) MouseMoveCallback));

Cleanup:

    return hr;
}



//+------------------------------------------------------------------
//
// Member:      CSliderBar::BuildSliderBar()
//
// Synopsis:    Builds the slider bar which will contain a slider thumb
//
// Arguments:   None
//
// Returns:     S_OK if it can be built
//
//-------------------------------------------------------------------



HRESULT
CSliderBar::BuildSliderBar()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLStyle> pStyle;
    CComBSTR    bstr;

    CheckResult( GetHTMLDocument(_pSite, &pDoc));
    CheckResult( pDoc->createElement(CComBSTR("div"), &_pSliderBar));

    CheckResult( _pSliderBar->get_style(&pStyle));
    CheckResult( pStyle->put_display(CComBSTR("inline")));
    CheckResult( pStyle->put_overflow(CComBSTR("hidden")));
    CheckResult( AppendChild(_pContainer, _pSliderBar));

    _pSinkSlider = new CEventSink(this, _pSliderBar, SLIDER_SLIDER);
    if (!_pSinkSlider)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    bstr = _T("onmousedown");
    CheckResult( AttachEventToSink(_pSliderBar, bstr, _pSinkSlider));

    bstr = _T("onmouseup");
    CheckResult( AttachEventToSink(_pSliderBar, bstr, _pSinkSlider));

Cleanup:

    return hr;
}



HRESULT
CSliderBar::BuildSliderTrack()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLStyle> pStyle;
    CComPtr<IHTMLStyle2> pStyle2;
    CComBSTR  bstr;

    CheckResult( GetHTMLDocument(_pSite, &pDoc));
    CheckResult( pDoc->createElement(CComBSTR("div"), &_pTrack));
    CheckResult( _pTrack->get_style(&pStyle));
    
    CheckResult( pStyle->QueryInterface(IID_IHTMLStyle2, (void **) &pStyle2));
    CheckResult( pStyle2->put_position(CComBSTR("absolute")));
    
    CheckResult( pStyle->put_overflow(CComBSTR("hidden")));
    CheckResult( pStyle->put_border(CComBSTR("2px inset")));

    CheckResult( AppendChild(_pSliderBar, _pTrack));

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::BuildBlockIncrementer()
//
// Synopsis:    Builds the area of the slider bar that handles page incrementing
//
// Arguments:   None
//
// Returns:     S_OK if it can be built
//
//-------------------------------------------------------------------


HRESULT
CSliderBar::BuildBlockIncrementer()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLStyle> pStyle;
    CComPtr<IHTMLStyle2> pStyle2;
    CComBSTR  bstr;

    CheckResult( GetHTMLDocument(_pSite, &pDoc));
    CheckResult( pDoc->createElement(CComBSTR("div"), &_pBlockInc));

    CheckResult( _pBlockInc->get_style(&pStyle));
    CheckResult( pStyle->put_backgroundColor(CComVariant("transparent")));
    CheckResult( pStyle->put_display(CComBSTR("inline")));
    CheckResult( pStyle->put_pixelTop(0L));
    CheckResult( pStyle->put_pixelLeft(0L));

    CheckResult( pStyle->QueryInterface(IID_IHTMLStyle2, (void **) &pStyle2));
    CheckResult( pStyle2->put_position(CComBSTR("absolute")));

    CheckResult( AppendChild(_pSliderBar, _pBlockInc));


    _pSinkBlockInc = new CEventSink(this, _pBlockInc, SLIDER_PAGEINC);
    if (!_pSinkBlockInc)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    bstr = _T("onmousedown");
    CheckResult( AttachEventToSink(_pBlockInc, bstr, _pSinkBlockInc));

    bstr = _T("onmouseup");
    CheckResult( AttachEventToSink(_pBlockInc, bstr, _pSinkBlockInc));

    bstr = _T("onmouseenter");
    CheckResult( AttachEventToSink(_pBlockInc, bstr, _pSinkBlockInc));

    bstr = _T("onmousemove");
    CheckResult( AttachEventToSink(_pBlockInc, bstr, _pSinkBlockInc));

    bstr = _T("onresize");
    CheckResult( AttachEventToSink(_pBlockInc, bstr, _pSinkBlockInc));


Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::BuildBlockDecrementer()
//
// Synopsis:    Builds the area of the slider bar that handles page decrementing
//
// Arguments:   None
//
// Returns:     S_OK if it can be built
//
//-------------------------------------------------------------------

HRESULT
CSliderBar::BuildBlockDecrementer()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLStyle> pStyle;
    CComPtr<IHTMLStyle2> pStyle2;
    CComBSTR  bstr;

    CheckResult( GetHTMLDocument(_pSite, &pDoc));
    CheckResult( pDoc->createElement(CComBSTR("div"), &_pBlockDec));

    CheckResult( _pBlockDec->get_style(&pStyle));
    CheckResult( pStyle->put_backgroundColor(CComVariant("transparent")));
    CheckResult( pStyle->put_display(CComBSTR("inline")));
    CheckResult( pStyle->put_pixelTop(0L));
    CheckResult( pStyle->put_pixelLeft(0L));

    CheckResult( pStyle->QueryInterface(IID_IHTMLStyle2, (void **) &pStyle2));
    CheckResult( pStyle2->put_position(CComBSTR("absolute")));

    CheckResult( AppendChild(_pSliderBar, _pBlockDec));


    _pSinkBlockDec = new CEventSink(this, _pBlockDec, SLIDER_PAGEDEC);
    if (!_pSinkBlockDec)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    bstr = _T("onmousedown");
    CheckResult( AttachEventToSink(_pBlockDec, bstr, _pSinkBlockDec));

    bstr = _T("onmouseup");
    CheckResult( AttachEventToSink(_pBlockDec, bstr, _pSinkBlockDec));

    bstr = _T("onmouseenter");
    CheckResult( AttachEventToSink(_pBlockDec, bstr, _pSinkBlockDec));

    bstr = _T("onmousemove");
    CheckResult( AttachEventToSink(_pBlockDec, bstr, _pSinkBlockDec));

    bstr = _T("onresize");
    CheckResult( AttachEventToSink(_pBlockDec, bstr, _pSinkBlockDec));


Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::CalcConstituentDimensions()
//
// Synopsis:    Determins the pixel dimensions of all controls that make up the scrollbar
//
// Arguments:   None
//
// Returns:     S_OK if they can be calculated
//
//-------------------------------------------------------------------



HRESULT 
CSliderBar::CalcConstituentDimensions()
{
    HRESULT hr = S_OK;

    long  totalSize;

    if (_eoOrientation == Horizontal) 
    {
        _lLength     = _width;
        _lWidth      = _height;
    }

    else if (_eoOrientation == Vertical) 
    {
        _lLength     = _height;
        _lWidth      = _width;
    }

    else 
    {
        Assert( false ); // can't happen
    }

    return hr;
}



//+------------------------------------------------------------------
//
// Member:      CSliderBar::SetConstituentDimensions()
//
// Synopsis:    Sets the dimensions of the controls
//
// Arguments:   None
//
// Returns:     S_OK if they can be set
//
//-------------------------------------------------------------------



HRESULT
CSliderBar::SetConstituentDimensions()
{
    HRESULT hr = S_OK;

    CContextAccess a(_pSliderBar);
    CContextAccess i(_pBlockInc);
    CContextAccess d(_pBlockDec);
    CContextAccess t(_pTrack);

    CheckResult( a.Open( CA_STYLE ));
    CheckResult( i.Open( CA_STYLE ));
    CheckResult( d.Open( CA_STYLE ));
    CheckResult( t.Open( CA_STYLE ));

    if(_eoOrientation == Horizontal)
    {
        CheckResult( a.Style()->put_pixelHeight( TotalWidth() ));
        CheckResult( a.Style()->put_pixelWidth( TrackLength() ));

        CheckResult( i.Style()->put_pixelHeight( TotalWidth() ));
        CheckResult( i.Style()->put_pixelWidth( ThumbWidth() ));

        CheckResult( d.Style()->put_pixelHeight( TotalWidth() ));
        CheckResult( d.Style()->put_pixelWidth( ThumbWidth() ));

        CheckResult( _pSliderThumb->SetHeight( ThumbWidth() ));
        CheckResult( _pSliderThumb->SetWidth(  ThumbLength() ));

        CheckResult( t.Style()->put_pixelTop( TrackOffset() ));
        CheckResult( t.Style()->put_pixelHeight( TrackWidth() ));
        CheckResult( t.Style()->put_pixelWidth( TrackLength() ));
    }
    else 
    {
        CheckResult( a.Style()->put_pixelHeight( TrackLength() ));
        CheckResult( a.Style()->put_pixelWidth( TotalWidth() ));

        CheckResult( i.Style()->put_pixelHeight( ThumbWidth() ));
        CheckResult( i.Style()->put_pixelWidth( TotalWidth() ));

        CheckResult( d.Style()->put_pixelHeight( ThumbWidth() ));
        CheckResult( d.Style()->put_pixelWidth( TotalWidth() ));

        CheckResult( _pSliderThumb->SetHeight( ThumbLength() ));
        CheckResult( _pSliderThumb->SetWidth(  ThumbWidth() ));

        CheckResult( t.Style()->put_pixelLeft( TrackOffset() ));
        CheckResult( t.Style()->put_pixelHeight( TrackLength() ));
        CheckResult( t.Style()->put_pixelWidth( TrackWidth() ));
    }

    CheckResult( SetThumbPosition( _lCurrentPosition ));

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CSliderBar::ReadProperties()
//
// Synopsis:    Reads in property values for later calculations
//
// Arguments:   None
//
// Returns:     S_OK if they can be read
//
//-------------------------------------------------------------------



HRESULT 
CSliderBar::ReadProperties()
{
    HRESULT hr = S_OK;
    BSTR orientation;

    CheckResult( get_min(&_lMinPosition));
    CheckResult( get_max(&_lMaxPosition));
    CheckResult( get_position(&_lCurrentPosition));
    CheckResult( get_unit(&_lUnitIncrement));
    CheckResult( get_block(&_lBlockIncrement));

    CheckResult( get_orientation(&orientation));

    _eoOrientation = _wcsicmp(orientation, _T("vertical")) == 0 ? Vertical : Horizontal;

Cleanup:

    return hr;
}



//+------------------------------------------------------------------
//
// Member:      CSliderBar::Layout()
//
// Synopsis:    Laysout the scrollbar by calculating dimensions
//
// Arguments:   None
//
// Returns:     S_OK if scrollbar can be layed-out
//
//-------------------------------------------------------------------



HRESULT
CSliderBar::Layout()
{
    HRESULT hr = S_OK;

    CheckResult( CalcConstituentDimensions());
    CheckResult( SetConstituentDimensions());

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
//
// Synopsis:    Scrollbar Property interigators
//
//
//-------------------------------------------------------------------




/////////////////////////////////////////////////////////////////////////////

HRESULT
CSliderBar::get_min(long * pv)
{
    return GetProps()[eMin].Get(pv); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CSliderBar::put_min(long v)
{
    return GetProps()[eMin].Set(v); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CSliderBar::get_max(long * pv)
{
    return GetProps()[eMax].Get(pv); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CSliderBar::put_max(long v)
{
    return GetProps()[eMax].Set(v); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CSliderBar::get_position(long * pv)
{
    return GetProps()[ePosition].Get(pv); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CSliderBar::put_position(long v)
{
    return SetThumbPosition( v ); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CSliderBar::get_unit(long * pv)
{
    return GetProps()[eUnit].Get(pv); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CSliderBar::put_unit(long v)
{
    return GetProps()[eUnit].Set(v); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CSliderBar::get_block(long * pv)
{
    return GetProps()[eBlock].Get(pv); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CSliderBar::put_block(long v)
{
    return GetProps()[eBlock].Set(v); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CSliderBar::get_orientation(BSTR * pv)
{
    return GetProps()[eOrientation].Get(pv); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CSliderBar::put_orientation(BSTR v)
{
    return GetProps()[eOrientation].Set(v); 
}





/////////////////////////////////////////////////////////////////////////////

HRESULT
CSliderBar::GetScrollbarColor(VARIANT * pv)
{
    HRESULT hr = S_OK;
    CVariant color;
    CComVariant defaultColor("scrollbar");

    CContextAccess a(_pSite);

    CheckResult( a.Open(CA_STYLE3));
    CheckResult( a.Style3()->get_scrollbarBaseColor ( &color ));

    if(color.IsEmpty() || ((V_VT(&color) == VT_BSTR) && (V_BSTR(&color) == NULL)) ) 
    {   
        return ::VariantCopy(pv, &defaultColor);
    }
    else 
    {
        return ::VariantCopy(pv, &color);
    }

Cleanup:

    return hr;
}

HRESULT
CSliderBar::GetFaceColor(VARIANT * pv)
{
    HRESULT hr = S_OK;
    CComPtr<IHTMLCurrentStyle> pStyle;
    CComPtr<IHTMLCurrentStyle2> pStyle2;

    CContextAccess a(_pSite);

    CheckResult( a.Open(CA_ELEM2));

    CheckResult( a.Elem2()->get_currentStyle(&pStyle));
    CheckResult( pStyle->QueryInterface( __uuidof(IHTMLCurrentStyle2), (void **) &pStyle2));
    CheckResult( pStyle2->get_scrollbarFaceColor( pv));

Cleanup:

    return hr;
}

HRESULT
CSliderBar::GetArrowColor(VARIANT * pv)
{
    HRESULT hr = S_OK;
    CComPtr<IHTMLCurrentStyle> pStyle;
    CComPtr<IHTMLCurrentStyle2> pStyle2;

    CContextAccess a(_pSite);

    CheckResult( a.Open(CA_ELEM2));

    CheckResult( a.Elem2()->get_currentStyle(&pStyle));
    CheckResult( pStyle->QueryInterface( __uuidof(IHTMLCurrentStyle2), (void **) &pStyle2));
    CheckResult( pStyle2->get_scrollbarArrowColor( pv));

Cleanup:

    return hr;
}

HRESULT
CSliderBar::Get3DLightColor(VARIANT * pv)
{
    HRESULT hr = S_OK;
    CComPtr<IHTMLCurrentStyle> pStyle;
    CComPtr<IHTMLCurrentStyle2> pStyle2;

    CContextAccess a(_pSite);

    CheckResult( a.Open(CA_ELEM2));

    CheckResult( a.Elem2()->get_currentStyle(&pStyle));
    CheckResult( pStyle->QueryInterface( __uuidof(IHTMLCurrentStyle2), (void **) &pStyle2));
    CheckResult( pStyle2->get_scrollbar3dLightColor( pv));

Cleanup:

    return hr;
}

HRESULT
CSliderBar::GetShadowColor(VARIANT * pv)
{
    HRESULT hr = S_OK;
    CComPtr<IHTMLCurrentStyle> pStyle;
    CComPtr<IHTMLCurrentStyle2> pStyle2;

    CContextAccess a(_pSite);

    CheckResult( a.Open(CA_ELEM2));

    CheckResult( a.Elem2()->get_currentStyle(&pStyle));
    CheckResult( pStyle->QueryInterface( __uuidof(IHTMLCurrentStyle2), (void **) &pStyle2));
    CheckResult( pStyle2->get_scrollbarShadowColor( pv));

Cleanup:

    return hr;
}

HRESULT
CSliderBar::GetHighlightColor(VARIANT * pv)
{
    HRESULT hr = S_OK;
    CComPtr<IHTMLCurrentStyle> pStyle;
    CComPtr<IHTMLCurrentStyle2> pStyle2;

    CContextAccess a(_pSite);

    CheckResult( a.Open(CA_ELEM2));

    CheckResult( a.Elem2()->get_currentStyle(&pStyle));
    CheckResult( pStyle->QueryInterface( __uuidof(IHTMLCurrentStyle2), (void **) &pStyle2));
    CheckResult( pStyle2->get_scrollbarHighlightColor( pv));

Cleanup:

    return hr;
}

HRESULT
CSliderBar::GetDarkShadowColor(VARIANT * pv)
{
    HRESULT hr = S_OK;
    CComPtr<IHTMLCurrentStyle> pStyle;
    CComPtr<IHTMLCurrentStyle2> pStyle2;

    CContextAccess a(_pSite);

    CheckResult( a.Open(CA_ELEM2));

    CheckResult( a.Elem2()->get_currentStyle(&pStyle));
    CheckResult( pStyle->QueryInterface( __uuidof(IHTMLCurrentStyle2), (void **) &pStyle2));
    CheckResult( pStyle2->get_scrollbarDarkShadowColor( pv));

Cleanup:

    return hr;
}





HRESULT
CSliderBar::AttachEventToSink(IHTMLDocument3 *pDoc, CComBSTR& bstr, CEventSink* pSink)
{
    HRESULT hr = S_OK;
    VARIANT_BOOL    vSuccess;

    CheckResult( pDoc->attachEvent(bstr, pSink, &vSuccess));

    if (vSuccess != VARIANT_TRUE)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:

    return hr;
}




HRESULT
CSliderBar::AttachEventToSink(IHTMLElement *pElem, CComBSTR& bstr, CEventSink* pSink)
{
    HRESULT hr = S_OK;
    VARIANT_BOOL    vSuccess;
    CComPtr<IHTMLElement2> pElem2;

    CheckResult( pElem->QueryInterface(IID_IHTMLElement2, (void **) &pElem2));
    CheckResult( pElem2->attachEvent(bstr, pSink, &vSuccess));

    if (vSuccess != VARIANT_TRUE)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:

    return hr;
}



//+------------------------------------------------------------------------
//
// CSliderBar::CEventSink
//
// IDispatch Implementation
// The event sink's IDispatch interface is what gets called when events
// are fired.
//
//-------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  Member:     CSliderBar::CEventSink::GetTypeInfoCount
//              CSliderBar::CEventSink::GetTypeInfo
//              CSliderBar::CEventSink::GetIDsOfNames
//
//  Synopsis:   We don't really need a nice IDispatch... this minimalist
//              version does just plenty.
//
//-------------------------------------------------------------------------

STDMETHODIMP
CSliderBar::CEventSink::GetTypeInfoCount(UINT* /*pctinfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CSliderBar::CEventSink::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
                                   /* [in] */ LCID /*lcid*/,
                                   /* [out] */ ITypeInfo** /*ppTInfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CSliderBar::CEventSink::GetIDsOfNames( REFIID          riid,
                                         OLECHAR**       rgszNames,
                                         UINT            cNames,
                                         LCID            lcid,
                                         DISPID*         rgDispId)
{
    return E_NOTIMPL;
}

//+------------------------------------------------------------------------
//
//  Member:     CSliderBar::CEventSink::Invoke
//
//  Synopsis:   This gets called for all events on our object.  (it was
//              registered to do so in Init with attach_event.)  It calls
//              the appropriate parent functions to handle the events.
//
//-------------------------------------------------------------------------
STDMETHODIMP
CSliderBar::CEventSink::Invoke(DISPID dispIdMember,
                                     REFIID, LCID,
                                     WORD wFlags,
                                     DISPPARAMS* pDispParams,
                                     VARIANT* pVarResult,
                                     EXCEPINFO*,
                                     UINT* puArgErr)
{
    HRESULT         hr          = S_OK;
    IHTMLEventObj   *pEventObj  = NULL;
    CComBSTR        bstrOn;
    CComBSTR        bstrEvent;

    Assert(_pParent);

    if (!pDispParams) // || (pDispParams->cArgs < 1))
        goto Cleanup;

    if (pDispParams->cArgs == 0) 
    {
        if (_dwFlags & SLIDER_DELAY_TIMER)
        {
            CheckResult( _pParent->OnDelay() );
        }
        else if (_dwFlags & SLIDER_REPEAT_TIMER)
        {
            CheckResult( _pParent->OnRepeat() );
        }
    }

    else if (pDispParams->rgvarg[0].vt == VT_DISPATCH)
    {
        CEventObjectAccess eoa(pDispParams);
        
        hr = pDispParams->rgvarg[0].pdispVal->QueryInterface(IID_IHTMLEventObj, (void **)&pEventObj);
        if (FAILED(hr))
            goto Cleanup;

        hr = pEventObj->get_type(&bstrEvent);
        if (FAILED(hr))
            goto Cleanup;

        if (_dwFlags & SLIDER_PAGEDEC)
        {
            if (!StrCmpICW(bstrEvent, L"mousedown"))
            {
                CheckResult( _pParent->BlockMoveStartDec(&eoa));
            }
            else if (!StrCmpICW(bstrEvent, L"mouseup"))
            {
                CheckResult( _pParent->BlockMoveEnd(&eoa));
            }
            else if (!StrCmpICW(bstrEvent, L"mousemove"))
            {
                CheckResult( _pParent->BlockMoveSuspend(&eoa, _pElement));
            }
            else if (!StrCmpICW(bstrEvent, L"resize"))
            {
                CheckResult( _pParent->BlockMoveCheck(&eoa));
            }
        }
 
        else if (_dwFlags & SLIDER_PAGEINC)
        {
            if (!StrCmpICW(bstrEvent, L"mousedown"))
            {
                CheckResult( _pParent->BlockMoveStartInc(&eoa));
            }
            else if (!StrCmpICW(bstrEvent, L"mouseup"))
            {
                CheckResult( _pParent->BlockMoveEnd(&eoa));
            }
            else if (!StrCmpICW(bstrEvent, L"mousemove"))
            {
                CheckResult( _pParent->BlockMoveSuspend(&eoa, _pElement));
            }
            else if (!StrCmpICW(bstrEvent, L"resize"))
            {
                CheckResult( _pParent->BlockMoveCheck(&eoa));
            }
        }

        else if (_dwFlags & SLIDER_SLIDER)
        {
            if (!StrCmpICW(bstrEvent, L"mousedown"))
            {
                CheckResult( _pParent->OnMouseDown(&eoa));
            }
        }
    }

Cleanup:

    ReleaseInterface(pEventObj);

    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CSliderBar::CEventSink
//
//  Synopsis:   This is used to allow communication between the parent class
//              and the event sink class.  The event sink will call the ProcOn*
//              methods on the parent at the appropriate times.
//
//-------------------------------------------------------------------------

CSliderBar::CEventSink::CEventSink(CSliderBar *pParent, IHTMLElement *pElement, DWORD dwFlags)
{
    _pParent  = pParent;
    _pElement = pElement;
    _dwFlags  = dwFlags;
}

// ========================================================================
// CSliderBar::CEventSink
//
// IUnknown Implementation
// Vanilla IUnknown implementation for the event sink.
// ========================================================================

STDMETHODIMP
CSliderBar::CEventSink::QueryInterface(REFIID riid, void ** ppUnk)
{
    void * pUnk = NULL;

    if (riid == IID_IDispatch)
        pUnk = (IDispatch*)this;

    if (riid == IID_IUnknown)
        pUnk = (IUnknown*)this;

    if (pUnk)
    {
        *ppUnk = pUnk;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
CSliderBar::CEventSink::AddRef(void)
{
    return ((IElementBehavior*) _pParent)->AddRef();
}

STDMETHODIMP_(ULONG)
CSliderBar::CEventSink::Release(void)
{
    return ((IElementBehavior*) _pParent)->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\spinbttn.cxx ===
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "iextag.h"

#include "utils.hxx"

#include "spinbttn.hxx"


/////////////////////////////////////////////////////////////////////////////
//
// CSpinButton
//
/////////////////////////////////////////////////////////////////////////////

const CBaseCtl::PROPDESC CSpinButton::s_propdesc[] = 
{
    {_T("value"), VT_BSTR},
    NULL
};

enum
{
    eValue = 0
};

/////////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Members:    CSpinButton::CSpinButton
//              CSpinButton::~CSpinButton
//
//  Synopsis:   Constructor/destructor
//
//-------------------------------------------------------------------------

CSpinButton::CSpinButton()
{
    int i;

    m_pHTMLPopup    = 0;
    m_pSink         = 0;
    _pPrimaryMarkup = 0;

    _pSinkBody     = 0;

    for (i = 0; i < 2; i++)
    {
        _apSinkElem[i] = 0;
    }
}

CSpinButton::~CSpinButton()
{
    int i;

    if (m_pSink)
        delete m_pSink;

    if (_pSinkBody)
    {
        delete _pSinkBody;
    }

    for (i = 0; i < 2; i++)
    {
        if (_apSinkElem[i])
        {
            delete _apSinkElem[i];
        }
    }
}

HRESULT
CSpinButton::Detach()
{
    if (_pPrimaryMarkup)
    {
        _pPrimaryMarkup->Release();
    }
    if (m_pHTMLPopup)
        m_pHTMLPopup->Release();

    return S_OK;
}

HRESULT
CSpinButton::Init()
{
    HRESULT         hr          = S_OK;
    BSTR            bstrEvent   = NULL;
    VARIANT_BOOL    vSuccess    = VARIANT_FALSE;
    CContextAccess  a(_pSite);

    hr = a.Open(CA_ELEM | CA_ELEM2);
    if (hr)
        goto Cleanup;

    // this puppy is ref counted when used.
    m_pSink = new CEventSink (this);

    if (!m_pSink)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // we want to sink a few events.
    //

    bstrEvent = SysAllocString (L"onclick");
    if (!bstrEvent)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    a.Elem2()->attachEvent (bstrEvent, (IDispatch *) m_pSink, &vSuccess);
    if (vSuccess == VARIANT_TRUE)
    {
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }


Cleanup:
    if (bstrEvent)
    {
        SysFreeString(bstrEvent);
    }

    return hr;
}


//+------------------------------------------------------------------------
//
//  Member:     CSpinButton::ProcOnClick
//
//  Synopsis:   Handles the onclick events.
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CSpinButton::ProcOnClick (CEventSink *pSink)
{
    HRESULT hr = S_OK;
    long    lElemLeft, lElemTop, lElemWidth, lElemHeight;

    IHTMLDocument    *pDoc = NULL;

    IMarkupServices  *pMarkupSrv = NULL;
    IMarkupPointer   *pMarkupPStart = NULL;
    IMarkupPointer   *pMarkupPEnd = NULL;
    IHTMLElement     *pHtml = NULL;
    IHTMLElement     *pBody = NULL;
    IHTMLElement     *pElem = NULL;
    IHTMLElement2    *pElem2 = NULL;
    BSTR              bstrEvent   = NULL;
    VARIANT_BOOL      vSuccess    = VARIANT_FALSE;
    IDispatch        *pDocMain = NULL;
    IOleWindow       *pIOleWnd = NULL;
    HWND              hwndMain;
    RECT              rcClient;

    CContextAccess    a(_pSite);

    hr = a.Open(CA_ELEM);
    if (hr)
        goto Cleanup;

    // VARIANT         var;

    // var.vt == VT_EMPTY;


    if (pSink != m_pSink)
    {
        Assert(m_pHTMLPopup);
        if (pSink == _apSinkElem[0])
        {
            a.Elem()->put_innerText(_T("test1"));
        }
        else
        {
            a.Elem()->put_innerText(_T("test2"));
        }
        m_pHTMLPopup->hide();
        return hr;
    }

    // ISSUE: hr?
    a.Elem()->get_offsetLeft(&lElemLeft);
    a.Elem()->get_offsetTop(&lElemTop);
    a.Elem()->get_offsetWidth(&lElemWidth);
    a.Elem()->get_offsetHeight(&lElemHeight);

    // get the current main doc window location

    // ISSUE: hr?
    a.Elem()->get_document(&pDocMain);

    // get the oleWindow
    hr = pDocMain->QueryInterface(IID_IOleWindow, (void **)&pIOleWnd);

    if (FAILED(hr))
        goto Cleanup;

    pDocMain->Release();

    // this window can be cached
    hr = pIOleWnd->GetWindow(&hwndMain);
    hr = S_OK;

    GetWindowRect(hwndMain, &rcClient);

    lElemTop    = lElemTop + lElemHeight + rcClient.top;
    lElemLeft   = lElemLeft + rcClient.left;

    pIOleWnd->Release();

    if (m_pHTMLPopup)
    {

        //
        // we have the popup
        // just make sure it shows up
        // show it modal
        //

        /*
        hr = m_pHTMLPopup->show(a.Elem(),
                                lElemLeft, lElemTop,
                                lElemWidth, 100,
                                VARIANT_TRUE);
        */

        return hr;
    }

    //
    // create a popup window
    // if there is no window yet
    //

    hr = CoCreateInstance(CLSID_HTMLPopup,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IHTMLPopup,
                              (void **) &m_pHTMLPopup);

    if (FAILED(hr))
        return hr;

    //
    // create elements in the popup doc
    //

    // hr = m_pHTMLPopup->getDoc(&pDoc);
    hr = m_pHTMLPopup->get_document(&pDoc);

    if (FAILED(hr))
        goto Cleanup;

    //
    // get the markup services interface from the doc
    // so that we can construct a markup tree
    //


    hr = pDoc->QueryInterface(IID_IMarkupServices, (void **)&pMarkupSrv);
    if (FAILED(hr))
        goto Cleanup;

    hr = pDoc->QueryInterface(IID_IMarkupContainer, (void **)&_pPrimaryMarkup);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupSrv->CreateMarkupPointer(&pMarkupPStart);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupSrv->CreateMarkupPointer(&pMarkupPEnd);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupPStart->MoveToContainer(_pPrimaryMarkup, TRUE);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupPEnd->MoveToContainer(_pPrimaryMarkup, FALSE);
    if (FAILED(hr))
        goto Cleanup;

#define METHOD1 1

//
//  ISSUE: METHOD 2 crashes in CHtmInfo::Init
//

#ifdef  METHOD2
    hr = pMarkupSrv->ParseString(_T("<HTML><BODY><INPUT></BODY></HTML>"),
                                0,
                                &_pPrimaryMarkup, pMarkupPStart, pMarkupPEnd);
    if (FAILED(hr))
        goto Cleanup;

    ReleaseInterface(pMarkupSrv);
    ReleaseInterface(pMarkupPStart);
    ReleaseInterface(pMarkupPEnd);
#endif

    //
    //  this is the prefered method of creating the content of the popup
    //

#ifdef  METHOD1
    hr = pMarkupSrv->CreateElement(TAGID_HTML, 0, &pHtml);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupSrv->InsertElement(pHtml, pMarkupPStart, pMarkupPEnd);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupSrv->CreateElement(TAGID_BODY,
                                   _T("style='border:solid 1;overflow:hidden'"),
                                   &pBody);
    if (FAILED(hr))
        goto Cleanup;

    pMarkupPStart->MoveAdjacentToElement(pHtml, ELEM_ADJ_AfterBegin);
    if (FAILED(hr))
        goto Cleanup;

    pMarkupPEnd->MoveAdjacentToElement(pHtml, ELEM_ADJ_BeforeEnd);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupSrv->InsertElement(pBody, pMarkupPStart, pMarkupPEnd);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupSrv->CreateElement( TAGID_INPUT,
                                    _T("type=checkbox value='text1' \
                                        style='width:100%;border:0;background:white' \
                                    "),
                                    &pElem);
    if (FAILED(hr))
        goto Cleanup;

    pMarkupPStart->MoveAdjacentToElement(pBody, ELEM_ADJ_AfterBegin);
    if (FAILED(hr))
        goto Cleanup;

    pMarkupPEnd->MoveAdjacentToElement(pBody, ELEM_ADJ_BeforeEnd);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupSrv->InsertElement(pElem, pMarkupPStart, pMarkupPEnd);
    if (FAILED(hr))
        goto Cleanup;

    pMarkupPStart->MoveAdjacentToElement(pElem, ELEM_ADJ_AfterEnd);
    if (FAILED(hr))
        goto Cleanup;

    bstrEvent = SysAllocString (L"onclick");
    if (!bstrEvent)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pElem->QueryInterface(IID_IHTMLElement2, (void **)&pElem2);
    if (FAILED(hr))
        goto Cleanup;

    _apSinkElem[0] = new CEventSink (this);

    if (!_apSinkElem[0])
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pElem2->attachEvent (bstrEvent, (IDispatch *) _apSinkElem[0], &vSuccess);
    if (vSuccess == VARIANT_TRUE)
    {
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    ReleaseInterface(pElem2);
    pElem2 = NULL;
    ReleaseInterface(pElem);
    pElem = NULL;


    hr = pMarkupSrv->CreateElement( TAGID_INPUT,
                                    _T("type=button value='text2' \
                                        style='width:100%;border:0;background:white' \
                                    "),
                                    &pElem);
    if (FAILED(hr))
        goto Cleanup;

    pMarkupPEnd->MoveAdjacentToElement(pBody, ELEM_ADJ_BeforeEnd);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupSrv->InsertElement(pElem, pMarkupPStart, pMarkupPEnd);
    if (FAILED(hr))
        goto Cleanup;

    hr = pElem->QueryInterface(IID_IHTMLElement2, (void **)&pElem2);
    if (FAILED(hr))
        goto Cleanup;

    _apSinkElem[1] = new CEventSink (this);

    if (!_apSinkElem[1])
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pElem2->attachEvent (bstrEvent, (IDispatch *) _apSinkElem[1], &vSuccess);
    if (vSuccess == VARIANT_TRUE)
    {
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
        goto Cleanup;
    }
#endif

    //
    // position the window just under the element
    // not supported due to a pdlparser problem
    //

#ifdef  METHOD3
    var.vt = VT_BSTR;
    var.bstrVal = _T("file://c:\\toto.htm");
#endif

    /*
    hr = m_pHTMLPopup->show(a.Elem(),
                            lElemLeft, lElemTop,
                            lElemWidth, 100,
                            VARIANT_TRUE);

    if (FAILED(hr))
        goto Cleanup;
    */

Cleanup:
    if (pDoc)
    {
        pDoc->Release();
    }
    if (bstrEvent)
    {
        SysFreeString(bstrEvent);
    }

    ReleaseInterface(pElem2);
    ReleaseInterface(pElem);
    ReleaseInterface(pMarkupSrv);
    ReleaseInterface(pMarkupPStart);
    ReleaseInterface(pMarkupPEnd);
    ReleaseInterface(pBody);
    ReleaseInterface(pHtml);

    return hr;
}

// ========================================================================
// CEventSink::IDispatch
// ========================================================================

// The event sink's IDispatch interface is what gets called when events
// are fired.

//+------------------------------------------------------------------------
//
//  Member:     CSpinButton::CEventSink::GetTypeInfoCount
//              CSpinButton::CEventSink::GetTypeInfo
//              CSpinButton::CEventSink::GetIDsOfNames
//
//  Synopsis:   We don't really need a nice IDispatch... this minimalist
//              version does just plenty.
//
//-------------------------------------------------------------------------

STDMETHODIMP
CSpinButton::CEventSink::GetTypeInfoCount(UINT* /*pctinfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CSpinButton::CEventSink::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
                                   /* [in] */ LCID /*lcid*/,
                                   /* [out] */ ITypeInfo** /*ppTInfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CSpinButton::CEventSink::GetIDsOfNames( REFIID          riid,
                                         OLECHAR**       rgszNames,
                                         UINT            cNames,
                                         LCID            lcid,
                                         DISPID*         rgDispId)
{
    return E_NOTIMPL;
}

//+------------------------------------------------------------------------
//
//  Member:     CSpinButton::CEventSink::Invoke
//
//  Synopsis:   This gets called for all events on our object.  (it was
//              registered to do so in Init with attach_event.)  It calls
//              the appropriate parent functions to handle the events.
//
//-------------------------------------------------------------------------
STDMETHODIMP
CSpinButton::CEventSink::Invoke( DISPID dispIdMember,
                                  REFIID, LCID,
                                  WORD wFlags,
                                  DISPPARAMS* pDispParams,
                                  VARIANT* pVarResult,
                                  EXCEPINFO*,
                                  UINT* puArgErr)
{
    HRESULT hr = TRUE;
    if (m_pParent && pDispParams && pDispParams->cArgs>=1)
    {
        if (pDispParams->rgvarg[0].vt == VT_DISPATCH)
        {
            IHTMLEventObj *pObj=NULL;

            if (SUCCEEDED(pDispParams->rgvarg[0].pdispVal->QueryInterface(IID_IHTMLEventObj,
                (void **)&pObj) && pObj))
            {
                BSTR bstrEvent=NULL;

                pObj->get_type(&bstrEvent);

                // user clicked one of our anchors
                if (! StrCmpICW (bstrEvent, L"click"))
                {
                    hr = m_pParent->ProcOnClick(this);
                }

                pObj->Release();
            }
        }
    }

    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CSpinButton::CEventSink
//
//  Synopsis:   This is used to allow communication between the parent class
//              and the event sink class.  The event sink will call the ProcOn*
//              methods on the parent at the appropriate times.
//
//-------------------------------------------------------------------------

CSpinButton::CEventSink::CEventSink (CSpinButton * pParent)
{
    m_pParent = pParent;
}

// ========================================================================
// CEventSink::IUnknown
// ========================================================================

// Vanilla IUnknown implementation for the event sink.

STDMETHODIMP
CSpinButton::CEventSink::QueryInterface(REFIID riid, void ** ppUnk)
{
    void * pUnk = NULL;

    if (riid == IID_IDispatch)
        pUnk = (IDispatch *) this;

    if (riid == IID_IUnknown)
        pUnk = (IUnknown *) this;

    if (pUnk)
    {
        *ppUnk = pUnk;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
CSpinButton::CEventSink::AddRef(void)
{
    return ((IElementBehavior *)m_pParent)->AddRef();
}

STDMETHODIMP_(ULONG)
CSpinButton::CEventSink::Release(void)
{
    return ((IElementBehavior *)m_pParent)->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\userdata.cxx ===
//===============================================================
//
//  userdata.cxx : Implementation of the CPersistUserData Peer
//
//  Synposis : this class is repsponsible for handling the "generic"
//      persistence of author data in the expanded cookie cahce
//
//===============================================================
                                                              
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef __X_IEXTAG_H_
#define __X_IEXTAG_H_
#include "iextag.h"
#endif

#ifndef __X_USERDATA_HXX_
#define __X_USERDATA_HXX_
#include "userdata.hxx"
#endif

#ifndef __X_UTILS_HXX_
#define __X_UTILS_HXX_
#include "utils.hxx"
#endif

// Static data members

// User name related
TCHAR CPersistUserData::s_rgchUserData[] = TEXT("userdata");

// This global string will store the string userdata:username@. This is useful is several 
// situations and we want to avoid computing this over and over again. 
TCHAR CPersistUserData::s_rgchCacheUrlPrefix[ARRAY_SIZE(s_rgchUserData) + 1 /* for : */ +  MAX_PATH + 1 /* for @ */];
DWORD CPersistUserData::s_cchCacheUrlPrefix = 0;
BOOL  CPersistUserData::s_bCheckedUserName = FALSE;
BOOL  CPersistUserData::s_bCacheUrlPrefixRet = FALSE;


// cache container related
HRESULT CPersistUserData::s_hrCacheContainer;
BOOL  CPersistUserData::s_bCheckedCacheContainer = FALSE;

// Values below are the default ones used if not administrator provided override is seen.
// These values are in Kilo Bytes. 

// Initialize with hard-coded values if not admin limit specified.
DWORD CPersistUserData::s_rgdwDomainLimit[URLZONE_UNTRUSTED + 1] = 
        { 1024, 10240, 1024, 1024, 640 };
DWORD CPersistUserData::s_dwUnkZoneDomainLimit = 640;

DWORD CPersistUserData::s_rgdwDocLimit[URLZONE_UNTRUSTED + 1] = 
        { 128, 512, 128, 128, 64 };
DWORD CPersistUserData::s_dwUnkZoneDocLimit = 64;


// Critical sections for synchronization.

CRITICAL_SECTION CPersistUserData::s_csCacheUrlPrefix;
CRITICAL_SECTION CPersistUserData::s_csCacheContainer;
CRITICAL_SECTION CPersistUserData::s_csSiteTable;

CSiteTable * CPersistUserData::s_pSiteTable = NULL; 

DWORD CPersistUserData::s_dwClusterSizeMinusOne;
DWORD CPersistUserData::s_dwClusterSizeMask;
                     
// Registry location and keys to read the admin specified values from
#define KEY_PERSISTENCE     TEXT("Software\\Policies\\microsoft\\Internet Explorer\\Persistence")
#define VALUE_DOCUMENTLIMIT      TEXT("DocumentLimit")
#define VALUE_DOMAINLIMIT   TEXT("DomainLimit")

// Some character definitions which are useful in this file
const TCHAR chSLASH = TEXT('/');
const TCHAR chBACKSLASH = TEXT('\\');
const TCHAR chAT = TEXT('@');
const TCHAR chCOLON = TEXT(':');
// Character at the begining of a Unicode file.
const WCHAR wchLEADUNICODEFILE = 0xFEFF ;

const TCHAR rgchAnyUser[] = TEXT("anyuser");
const CHAR rgchRelAppData[] = "Microsoft\\Internet Explorer\\UserData";
const CHAR rgchRelCookies[] = "..\\UserData";

#ifndef unix
const CHAR schDIR_SEPERATOR = '\\';
#else
const CHAR schDIR_SEPERATOR = '/';
#endif

//+----------------------------------------------------------------------------
//
//  member : CPersistUserData::~CPersistUserData
//
//-----------------------------------------------------------------------------

CPersistUserData::~CPersistUserData()
{
    ClearInterface(&_pPeerSite);
    ClearInterface(&_pPeerSiteOM);
    ClearOMInterfaces();
}

//+----------------------------------------------------------------------------
//
//  Member : GlobalInit  (static)
//
//  Synopsis : this method is called once a DLL attach time to init static variables.
//
//-----------------------------------------------------------------------------
BOOL CPersistUserData::GlobalInit()
{
    // Initialize the critical sections we use.
    InitializeCriticalSection(&s_csCacheUrlPrefix);
    InitializeCriticalSection(&s_csCacheContainer);
    InitializeCriticalSection(&s_csSiteTable);

    // Read out admin specified limits if any.
    DWORD   dwLimit;
    DWORD   dwSize = sizeof(dwLimit);
    DWORD   dwType;
    HUSKEY  huskey = NULL;

    if ((SHRegOpenUSKey(KEY_PERSISTENCE, KEY_QUERY_VALUE, NULL, &huskey, FALSE)) == NOERROR)
    {
        // Should be more than enough to represent a zone id as a string.
        TCHAR rgchZone[10];

        for ( int i = 0 ; i < ARRAY_SIZE(s_rgdwDomainLimit) ; i++ )
        {
            HUSKEY husZoneKey = NULL;
            wnsprintf(rgchZone, ARRAY_SIZE(rgchZone), TEXT("%d"), i);

            if (SHRegOpenUSKey(rgchZone,  KEY_QUERY_VALUE, huskey, &husZoneKey, FALSE) == NOERROR)
            {  
                if ( (SHRegQueryUSValue(husZoneKey, VALUE_DOMAINLIMIT, &dwType, 
                                &dwLimit, &dwSize, FALSE, NULL, 0) == NOERROR) && 
                  
                      (dwType == REG_DWORD)
                    )
                {
                    s_rgdwDomainLimit[i] = dwLimit;
                }
                dwSize = sizeof(dwLimit);

                if ( (SHRegQueryUSValue(husZoneKey, VALUE_DOCUMENTLIMIT, &dwType, 
                                &dwLimit, &dwSize, FALSE, NULL, 0) == NOERROR) && 
                  
                      (dwType == REG_DWORD)
                    )
                {
                    s_rgdwDocLimit[i] = dwLimit;
                }
                SHRegCloseUSKey(husZoneKey);
            }

            dwSize = sizeof(dwLimit);
        }
    }

    if (huskey)
    {
        SHRegCloseUSKey(huskey);
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Member : GlobalUninit  (static)
//
//  Synopsis : this method is called at DLL detach time to uninit static variables.
//
//-----------------------------------------------------------------------------

BOOL CPersistUserData::GlobalUninit( )
{
    DeleteSiteTable();
    DeleteCriticalSection(&s_csCacheUrlPrefix);
    DeleteCriticalSection(&s_csCacheContainer);
    DeleteCriticalSection(&s_csSiteTable);
    return TRUE;
}
        
    
//+----------------------------------------------------------------------------
//
//  Member : Init
//
//  Synopsis : this method is called by MSHTML.dll to initialize peer object
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CPersistUserData::Init(IElementBehaviorSite * pPeerSite)
{
    if (!pPeerSite)
        return E_INVALIDARG;

    _pPeerSite = pPeerSite;
    _pPeerSite->AddRef();


    return _pPeerSite->QueryInterface(IID_IElementBehaviorSiteOM, 
                                         (void**)&_pPeerSiteOM);
}

//+----------------------------------------------------------------------------
//
//  Member : Notify
//
//  Synopsis : peer Interface, called for notification of document events.
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CPersistUserData::Notify(LONG lEvent, VARIANT *)
{
    return S_OK;
}


//+-----------------------------------------------------------------------
//
//  Member : ClearOMInterfaces ()
//
//  Synopsis : this helper function is called after the Save/Load persistenceCache
//      operations are finished, and is responsible for freeing up any of hte OM 
//      interfaces that were cached.
//
//------------------------------------------------------------------------
void
CPersistUserData::ClearOMInterfaces()
{
    ClearInterface(&_pRoot);
    ClearInterface(&_pInnerXMLDoc);
}

//+----------------------------------------------------------------
//
// Member : initXMLCache
//
//  Synopsis : Helper function, this is responsible for cocreateing the 
//      XML object and initializing it for use.
//              the fReset flag indicates that the contents of teh xmlCache 
//      should be cleared  It is assumed in this case that the cache already exists
//
//-----------------------------------------------------------------
HRESULT
CPersistUserData::initXMLCache(BOOL fReset/*=false*/)
{
    HRESULT             hr = S_OK;
    BSTR                bstrStub = NULL;
    VARIANT_BOOL        vtbCleanThisUp;
    IObjectSafety     * pObjSafe = NULL;

    if (!fReset)
    {
        // are we already initialized?
        if (_pInnerXMLDoc && _fCoCreateTried)
            goto Cleanup;

        // protect against expensive retries if over network
        _fCoCreateTried = true;  

        hr = CoCreateInstance(CLSID_DOMDocument,
                                  0,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IXMLDOMDocument,
                                  (void **)&_pInnerXMLDoc);

        if (hr)
            goto Cleanup;

        hr = _pInnerXMLDoc->QueryInterface(IID_IObjectSafety, 
                                           (void **)&pObjSafe);
        if (hr)
            goto ErrorCase;

        hr = pObjSafe->SetInterfaceSafetyOptions( IID_NULL, 
                                                  INTERFACE_USES_SECURITY_MANAGER, 
                                                  INTERFACE_USES_SECURITY_MANAGER);
        if (hr)
            goto ErrorCase;
    }

    // one last error check
    if (_pInnerXMLDoc)
    {
        // now create some XML tree
        bstrStub = SysAllocString(L"<ROOTSTUB />");
        if (bstrStub )
        {
            hr = _pInnerXMLDoc->loadXML(bstrStub, &vtbCleanThisUp);
            SysFreeString( bstrStub );
            if (hr)
                goto ErrorCase;
        }

        // TODO: we no longer need to really cache the _pRoot, why not
        hr = _pInnerXMLDoc->get_documentElement( &_pRoot);
        if (hr)
            goto ErrorCase;
    }


Cleanup:
    ReleaseInterface(pObjSafe);

    if (hr == S_FALSE)
        hr = S_OK;
    return hr ;

ErrorCase:
    ClearInterface(&_pInnerXMLDoc);
    goto Cleanup;
}

//+----------------------------------------------------------------
//
//  Member : SecureDomainAndPath
//
//  synopsis : this helper function is responsisble for the domain
//      and path level security when a user wants to save or load a 
//      store.
//          We use the security manager if possible so that HTA's
//      are handled properly.
//          This will return a substring of the pstrFileName, if the
//      user explicitly specified a store.  
//      The logic of this function is basically:
//          if pstrFileName is only a name return TRUE (and use the DirPath)
//          else { extract the store from pstrFileName
//                 compare the Name's path to the DirPath via domain et al
//                      using the security manager
//                 if that passes, then do a path comparison, since the 
//                      security mgr only handles domains
//
//    valid formats for pstrFileName:
//      Foo
//      userdata:foo
//      file://c:/temp/foo
//      userdata:file://c:/temp/foo
//+----------------------------------------------------------------
BOOL
CPersistUserData::SecureDomainAndPath(LPOLESTR pstrFileName,
                                      LPOLESTR *ppstrStore,
                                      LPOLESTR *ppstrPath,
                                      LPOLESTR *ppstrName)
{
    BOOL               fRet = FALSE;
    DWORD              cchPath; 
    LPTSTR             pszPath = NULL, pStore = NULL;
    LPOLESTR           pstrDirPath  = NULL;
    IHTMLElement     * pPeerElement   = NULL;
    IInternetSecurityManager * pSecMgr = NULL;
    DWORD              dwPolicy = 0;
    DWORD              dwZone = URLZONE_INVALID;

    if (!pstrFileName)
        goto Cleanup;

    Assert(ppstrStore && ppstrPath && ppstrName);

    *ppstrStore = *ppstrPath = *ppstrName = NULL;

    // get the doc's path
    if (FAILED(GetDirPath(&pstrDirPath)))
        goto Cleanup;

    Assert(pstrDirPath != NULL);

    // Only allow userdata saves and loads from supported schemes. 
    if (!IsSchemeAllowed(pstrDirPath))
        goto Cleanup;

    // pull the store off the front
    //-----------------------------------------------
    pStore = _tcschr(pstrFileName, _T(':'));
    if (pStore)
    {
        // we found one, if the next character is a / or a \
        //   then the format must be scheme://  otherwise
        //   userdata:http:// or store:file://c:\temp  is assumed
        //-------------------------------------------------
        if ( pStore[1]  != chSLASH && pStore[1] != chBACKSLASH)
        {
            long cchStore = (long)(pStore - pstrFileName);

            // copy the 'store:' over to the out parameter,
            // advance the Name to 
            (*ppstrStore) = new TCHAR [cchStore+1];
            if (!*ppstrStore)
                goto Cleanup;
                
            memcpy(*ppstrStore, pstrFileName, cchStore);
            (*ppstrStore)[cchStore] = _T('\0');
            pstrFileName = pStore +1;
        }
    }
    
    // first determine if the pstrFileName is just a name or 
    // a fully specified path. if there is a slash, then its
    // fully specified.
    //------------------------------------------------------
    if (!_tcschr(pstrFileName, _T('\\')) && 
        !_tcschr(pstrFileName, _T('/')))
    {
        long cchName = (_tcslen(pstrFileName)+1);
        cchPath = (_tcslen(pstrDirPath)+1);

        *ppstrName = new TCHAR [cchName];
        *ppstrPath = new TCHAR [cchPath];
        if (!*ppstrName || !*ppstrPath)
            goto Cleanup;
            
        memcpy(*ppstrName, pstrFileName, cchName*sizeof(TCHAR));
        memcpy(*ppstrPath, pstrDirPath, cchPath*sizeof(TCHAR));

        fRet = TRUE;
        // Fall through and make sure that the zone policy for pstrDirPath 
        // allows us to do userdata operations.
    }

    if (FAILED(CoInternetCreateSecurityManager(NULL, &pSecMgr, 0)))
    {
        fRet = FALSE;
        goto Cleanup;
    }

    if (FAILED(pSecMgr->MapUrlToZone(pstrDirPath, &dwZone, 0)))
    {
        fRet = FALSE;
        goto Cleanup;
    }

    SetZone(dwZone);
                            
    if ( FAILED(pSecMgr->ProcessUrlAction(pstrDirPath,
                                URLACTION_HTML_USERDATA_SAVE,
                                (BYTE *)&dwPolicy,
                                sizeof(dwPolicy),
                                NULL,
                                0,
                                PUAF_NOUI,
                                0))
            ||
          (GetUrlPolicyPermissions(dwPolicy) != URLPOLICY_ALLOW)
        )
    {
        fRet = FALSE;
        goto Cleanup;
    }

    // If fRet is TRUE it implies that the filename was a relative path.
    // In this case we don't need to do further checks, we can return 
    // success at this point.
    if (fRet)
        goto Cleanup;

    // at this point the store is pulled of the front (if it was specified);
    // the pstrFileName is ready to be domain and path compared for security
    //
    // do security mgr (domain) test first
    // ---------------------------------------------------------------------
    {
        TCHAR  achURL[INTERNET_MAX_URL_LENGTH];
        BYTE   abSID1[MAX_SIZE_SECURITY_ID];
        BYTE   abSID2[MAX_SIZE_SECURITY_ID];
        DWORD  cbSID1 = ARRAY_SIZE(abSID1);
        DWORD  cbSID2 = ARRAY_SIZE(abSID2);
        DWORD  dwSize;


        // Unescape the URL of the name. (be safe)
        //------------------------------------------
        if (FAILED(CoInternetParseUrl(pstrFileName, PARSE_ENCODE, 0, achURL, 
                                      ARRAY_SIZE(achURL), &dwSize, 0)))
            goto Cleanup;

        if (FAILED(pSecMgr->GetSecurityId(pstrDirPath, (LPBYTE)&abSID1, &cbSID1, 0)))
            goto Cleanup;

        if (FAILED(pSecMgr->GetSecurityId(achURL, (LPBYTE)&abSID2, &cbSID2, 0)))
            goto Cleanup;

        // compare the security ID's
        if (cbSID1 != cbSID2 || (0 != memcmp(abSID1, abSID2, cbSID1)))
            goto Cleanup;
    }

    // at this point, we know that the domains match so we now need to
    // make sure that if there are paths, then they follow the rules:
    //    if dirPath is "a\b\c"  then the Name path
    // can be :  "\a\b\c\d\name" or "\a\b\name or a\name"
    // but NOT : "\g\name"  or "a\f\name" or "a\b\f\name"
    //----------------------------------------------------------------

    URL_COMPONENTS ucFile, ucDoc;
    memset(&ucFile, 0, sizeof(ucFile));
    memset(&ucDoc, 0, sizeof(ucDoc));

    ucFile.dwStructSize = sizeof(ucFile);
    ucFile.lpszUrlPath = NULL; 
    ucFile.dwUrlPathLength = 1;

    ucDoc.dwStructSize = sizeof(ucDoc);
    ucDoc.lpszUrlPath = NULL; 
    ucDoc.dwUrlPathLength = 1;

    if (!InternetCrackUrl(pstrFileName, 0, 0, &ucFile))
        goto Cleanup;

    if (!InternetCrackUrl(pstrDirPath, 0, 0, &ucDoc))
        goto Cleanup;

    // Strip off the document from the filepath.
    // because the doc path came from DirPath() I know
    // that it has no trailing name or slash
    cchPath = ucFile.dwUrlPathLength;
    pszPath = ucFile.lpszUrlPath;

    for (;cchPath > 0; cchPath--) 
    {
        if ( pszPath[cchPath - 1]  == chSLASH || pszPath[cchPath - 1] == chBACKSLASH)
        {
            cchPath--;  // Skip over the /
            break;
        }
    }

    // yes, this changes the passed in string... SO DON"T change cchPath or
    // add a "goto Cleanup" in the following block of code.
    {
        TCHAR  chReplace = pszPath[cchPath];
        pszPath[cchPath] = _T('\0'); // chop into 2 parts

        // now, one of the two paths better be a substring of the other 
        //  how do we do this case - insensitive?
        //--------------------------------------------------------------------
        if (_tcsistr(ucDoc.lpszUrlPath, pszPath) ||
            _tcsistr(pszPath, ucDoc.lpszUrlPath))
        {
            // we have a valid name!!! 
            fRet = TRUE;

            // extract the File Name
            long cch = (ucFile.dwUrlPathLength- cchPath);
            *ppstrName = new TCHAR [cch];
            if (!*ppstrName)
            {
                fRet = FALSE;
                goto Cleanup;
            }
            
            memcpy(*ppstrName, (LPTSTR)&(pszPath[cchPath+1]), cch*sizeof(TCHAR));

            // and the path
            cch = (1+cchPath);
            *ppstrPath = new TCHAR [cch];
            memcpy(*ppstrPath, pszPath, cch*sizeof(TCHAR));
        }
        pszPath[cchPath] = chReplace;
    }


Cleanup:
    delete [] pstrDirPath;
    ReleaseInterface( pPeerElement );
    ReleaseInterface( pSecMgr );
    return fRet;
}

//+----------------------------------------------------------------
//
// Member: IsSchemeAllowed
// Synopsis: Given the directory path of the document trying to save the 
//           userdata object determines if the scheme (i.e. protocol) it uses
//           is supported. 
//------------------------------------------------------------------

BOOL CPersistUserData::IsSchemeAllowed(LPCOLESTR pStrDirPath)
{
    PARSEDURL pu;
    BOOL fRet = FALSE;

    pu.cbSize = sizeof(pu);
    HRESULT hr = ParseURL(pStrDirPath, &pu);

    if (hr == S_OK)
    {
        switch(pu.nScheme)
        {
            case URL_SCHEME_MAILTO:
            case URL_SCHEME_NEWS:
            case URL_SCHEME_NNTP:
            case URL_SCHEME_TELNET:
            case URL_SCHEME_WAIS:
            case URL_SCHEME_SNEWS:
            case URL_SCHEME_SHELL:
            case URL_SCHEME_JAVASCRIPT:
            case URL_SCHEME_VBSCRIPT:
            case URL_SCHEME_ABOUT:
            case URL_SCHEME_MK:
                fRet = FALSE;
                break;
            default:
                fRet = TRUE;
                break;
        }
    }

    return fRet;
}

//+----------------------------------------------------------------
//
// Member : GetDirPath
//
// Synopsis :  Helper function to figures out the directory which the current doc lives in
//          For example if the doc URL is http://www.foo.com/bar/goo/abc.htm?x=y
//          This function will extract out http://www.foo.com/bar/goo
//          
//-----------------------------------------------------------------

HRESULT 
CPersistUserData::GetDirPath(LPOLESTR *ppDirPath)
{
    HRESULT          hr;
    IHTMLElement   * pPeerElement   = NULL;
    IDispatch      * pdispBrowseDoc = NULL;
    IHTMLDocument2 * pBrowseDoc     = NULL;
    BSTR             bstrURL = NULL;
    LPOLESTR         pStr = NULL;

    if (ppDirPath == NULL)
    {
        hr = E_POINTER;
        return hr;
    }

    _pPeerSite->GetElement(&pPeerElement);
    Assert(pPeerElement != NULL);

    if ((hr = pPeerElement->get_document(&pdispBrowseDoc)) != S_OK)
        goto cleanup;

    if ((hr = pdispBrowseDoc->QueryInterface(IID_IHTMLDocument2, 
                                        (void**)&pBrowseDoc)) != S_OK)
        goto cleanup;

    if ((hr = pBrowseDoc->get_URL(&bstrURL)) != S_OK)
        goto cleanup;
    
    URL_COMPONENTS uc;
    memset(&uc, 0, sizeof(uc));

    uc.dwStructSize = sizeof(uc);
    uc.lpszScheme = NULL;
    uc.dwSchemeLength = 1;      // let's us get the scheme back.
    uc.lpszHostName = NULL;
    uc.dwHostNameLength = 1;
    uc.lpszUrlPath = NULL;
    uc.dwUrlPathLength = 1;
    // Important: even though we don't care about the extra info
    // we have to ask for it. If we don't InternetCrackUrl returns everything
    // after the HostName as the urlPath. We don't want the query string or the 
    // fragment in our dwUrlPathLength.

    uc.lpszExtraInfo = NULL;
    uc.dwExtraInfoLength = 1;

    if (!InternetCrackUrl(bstrURL, 0, 0, &uc))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    // Allocate enough memory for the whole URL. 
    DWORD dwStrLen;

    dwStrLen = lstrlen(bstrURL) + 1;

    pStr = new WCHAR[dwStrLen];

    if (pStr == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    // Strip off the document from the path. 
    DWORD cchPath; 
    LPTSTR pszPath;

    cchPath = uc.dwUrlPathLength;
    pszPath = uc.lpszUrlPath;

    for (;cchPath > 0; cchPath--) 
    {
        if ( pszPath[cchPath - 1]  == chSLASH  || pszPath[cchPath - 1] == chBACKSLASH)
        {
            cchPath--;  // Skip over the /
            break;
        }
    }

    if (uc.dwUrlPathLength && !cchPath)
    {
        // this case can only happen when there is no path. e.g. http://server/document.htm
        // we can't just use 0 for cchPath since InternetCreateUrl won't properly remove
        // the document name.  so let cchPath=1, and point to the "/" this will allow ICU to
        // create the url properly without the name.
        cchPath = 1;
    }

    uc.dwUrlPathLength = cchPath;
    // When creating the path we don't want the extra info to be included in the 
    // URL.
    uc.lpszExtraInfo = NULL;
    uc.dwExtraInfoLength = 0;

    if (!InternetCreateUrl(&uc, 0, pStr, &dwStrLen))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    // It is important that we do this so that www%20foo%20com and www.foo.com are 
    // treated as the same site. 
    hr = UrlUnescape(pStr, NULL, 0, URL_UNESCAPE_INPLACE);
    if (hr != S_OK)
        goto cleanup;
    
    *ppDirPath = pStr;
    pStr = NULL;    // So we don't free it...
    hr = S_OK;

cleanup:

    ReleaseInterface(pPeerElement);
    ReleaseInterface(pdispBrowseDoc);
    ReleaseInterface(pBrowseDoc);
    SysFreeString(bstrURL);
    delete [] pStr;
        
    return hr;
}

//+----------------------------------------------------------------
//
// Member : save
//
//-----------------------------------------------------------------
STDMETHODIMP 
CPersistUserData::save(BSTR  bstrName)
{
    HRESULT       hr = S_OK;
    BSTR          bstrValue = NULL;
    DWORD         cbDataLen = 0;
    LPOLESTR      pstrCacheStore = NULL;
    LPOLESTR      pstrCachePath  = NULL;
    LPOLESTR      pstrCacheName  = NULL;
    

    // verify parameters
    //---------------------------------------
    if (!bstrName || !SysStringLen(bstrName))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!_pInnerXMLDoc || !_pRoot)
        goto Cleanup;

    // do a security check between the DirPath() and the bstrName 
    // the user provided.  This bool test also returns the various store
    // names
    //---------------------------------------------------------
    if (!SecureDomainAndPath(bstrName, 
                             &pstrCacheStore, 
                             &pstrCachePath, 
                             &pstrCacheName))
    {
        hr = E_ACCESSDENIED;
        goto Cleanup;
    }

    // security test passed. prepare the data
    // get the text of the XML document and
    // load the variant 
    //-----------------------------------------------------------
    hr = _pInnerXMLDoc->get_xml( &bstrValue);
    if (hr)
        goto Cleanup;

    // now convert the data to an appendable/useable format
    cbDataLen = SysStringLen(bstrValue) * sizeof(WCHAR);

    // If there was no explicit store, or explictly "userdata"
    // then pass this off to the userData store.  otherwise
    // (for future implementions) pass this off to the appropriate
    // storage mechanism.
    //
    //   TODO - change this API to take a IPersist<something>
    //   interface rather than a string/byte pointer.  This will make
    //   it more general and veratile for the future.
    //------------------------------------------------------------
    if (!pstrCacheStore || !_tcscmp(pstrCacheStore, s_rgchUserData) )
    {
        hr = SaveUserData(pstrCachePath, 
                          pstrCacheName, 
                          bstrValue, 
                          cbDataLen, 
                          _ftExpires, 
                          UDF_BSTR); 
    }
    // else
    //  save to alternative store: NYI

Cleanup:
    delete [] pstrCacheStore;
    delete [] pstrCacheName;
    delete [] pstrCachePath;
    SysFreeString(bstrValue);

    return hr ;
}


//---------------------------------------------------------------------------
//
//  Member:     CPersistUserData::load
//
//  Synopsis:   IHTMLUserData OM method implementation
//
//---------------------------------------------------------------------------

STDMETHODIMP
CPersistUserData::load (BSTR strName)
{
    HRESULT        hr = S_OK;
    BSTR           strData = NULL;
    DWORD          dwSize = 0;
    LPOLESTR       pstrCacheStore = NULL;
    LPOLESTR       pstrCachePath  = NULL;
    LPOLESTR       pstrCacheName  = NULL;
    VARIANT_BOOL   vtbCleanThisUp;

    if (!strName || !SysStringLen(strName))
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = initXMLCache();
    if (hr)
        goto Cleanup;

    // do a security check between the DirPath() and the bstrName 
    // the user provided.  This bool test also returns the various store
    // names
    //---------------------------------------------------------
    if (!SecureDomainAndPath(strName, 
                             &pstrCacheStore, 
                             &pstrCachePath, 
                             &pstrCacheName))
    {
        hr = E_ACCESSDENIED;
        goto Cleanup;
    }

    // If there was no explicit store, or explictly "userdata"
    // then pass this off to the userData store.  otherwise
    // (for future implementions) pass this off to the appropriate
    // storage mechanism.
    //
    //   TODO - change this API to take a IPersist<something>
    //   interface rather than a string/byte pointer.  This will make
    //   it more general and veratile for the future.
    //------------------------------------------------------------
    if (!pstrCacheStore || !_tcscmp(pstrCacheStore, s_rgchUserData) )
    {
        // If the UDF_BSTR flag is specified we get back a BSTR in 
        hr = LoadUserData(pstrCachePath, 
                          pstrCacheName, 
                          (LPVOID *)&strData, 
                          &dwSize, 
                          UDF_BSTR);
    }
    // else
    //     load from alternate store : NYI 

    if (hr)  // Couldn't read the data.
        goto Cleanup;

    ClearInterface(&_pRoot);
    hr = _pInnerXMLDoc->loadXML(strData, &vtbCleanThisUp);
    if (hr)
        goto Cleanup;

    hr = _pInnerXMLDoc->get_documentElement( &_pRoot );

Cleanup:
    if (hr)
    {
        // If the document didn't exist return an empty document.
        if ( hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) ||
             hr == S_FALSE )
            hr = S_OK;

        // we need to make sure that there is a usable cache 
        // coming out of this function.  Even if we were unable 
        // to loadit
        initXMLCache(true);
    }
    delete [] pstrCacheStore;
    delete [] pstrCacheName;
    delete [] pstrCachePath;
    SysFreeString(strData);

    return hr;
}


//---------------------------------------------------------------------------
//
//  Member:     CPersistUserData::get_xmlDocument
//
//  Synopsis:   IHTMLUserData OM proeprty implementation. this is the default 
//                  property for this object, and as such it exposes the XMLOM
//                  of the user data.
//
//---------------------------------------------------------------------------

STDMETHODIMP
CPersistUserData::get_XMLDocument (IDispatch ** ppDisp)
{
    HRESULT hr = S_OK;

    if (!ppDisp)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = initXMLCache();
    if (hr)
        goto Cleanup;

    if (_pInnerXMLDoc)
        hr = _pInnerXMLDoc->QueryInterface(IID_IDispatch, (void**)ppDisp);

Cleanup:
    return hr ;
}

//---------------------------------------------------------------------------
//
//  Member:     CPersistUserData::getAttribute
//
//  Synopsis:   IHTMLUserData OM method implementation
//
//---------------------------------------------------------------------------

HRESULT
CPersistUserData::getAttribute (BSTR strName, VARIANT * pvarValue )
{
    HRESULT hr = S_OK;

    if (!pvarValue)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    VariantClear(pvarValue);

    if (!strName)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = initXMLCache();
    if (hr)
        goto Cleanup;

    // get the child of the root that has the name strName
    if (_pRoot)
    {
        hr = _pRoot->getAttribute(strName, pvarValue);
        if (hr ==S_FALSE)
            hr = S_OK;
    }

Cleanup:
    return hr ;
}


//---------------------------------------------------------------------------
//
//  Member:     CPersistUserData::setAttribute
//
//  Synopsis:   IHTMLUserData OM method implementation
//
//---------------------------------------------------------------------------

STDMETHODIMP
CPersistUserData::setAttribute (BSTR strName, VARIANT varValue)
{
    HRESULT  hr = S_OK;

    if (!strName)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = initXMLCache();
    if (hr)
        goto Cleanup;

    // save this value as an attribute on the root.
    if (_pRoot)
    {
        VARIANT * pvar;
        CVariant cvarTemp;

        if ((V_VT(&varValue)==VT_BSTR) || 
             V_VT(&varValue)==(VT_BYREF|VT_BSTR))
        {
            pvar = (V_VT(&varValue) & VT_BYREF) ?
                    V_VARIANTREF(&varValue) : &varValue;
        }
        else if ((V_VT(&varValue)==VT_BOOL ||
                 V_VT(&varValue)==(VT_BYREF|VT_BOOL)))
        {
            // sadly, do our own bool conversion...
            VARIANT_BOOL vbFlag = (V_VT(&varValue)==VT_BOOL) ?
                                   V_BOOL(&varValue) :
                                   V_BOOL( V_VARIANTREF(&varValue) );

            V_VT(&cvarTemp) = VT_BSTR;
            V_BSTR(&cvarTemp) = vbFlag ? SysAllocString(L"true") :
                                         SysAllocString(L"false");

            pvar = & cvarTemp;
        }
        else
        {
            pvar = &varValue;

            hr = VariantChangeTypeEx(pvar, pvar, LCID_SCRIPTING, 0, VT_BSTR);
            if (hr)
                goto Cleanup;
        }

        hr = _pRoot->setAttribute(strName, *pvar);
        if (hr ==S_FALSE)
            hr = S_OK;
    }

Cleanup:
    return hr ;
}



//---------------------------------------------------------------------------
//
//  Member:     CPersistUserData::removeAttribute
//
//  Synopsis:   IHTMLUserData OM method implementation
//
//---------------------------------------------------------------------------

STDMETHODIMP
CPersistUserData::removeAttribute (BSTR strName)
{
    HRESULT hr = S_OK;

    if (!strName)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = initXMLCache();
    if (hr)
        goto Cleanup;

    // get the child of the root that has the name strName
    if (_pRoot)
    {
        hr = _pRoot->removeAttribute(strName);
        if (hr ==S_FALSE)
            hr = S_OK;
    }

Cleanup:
    return hr ;
}


//+--------------------------------------------------------------------------
//
//  Member : get_expires
//
//  Synopsis : returns the expiration time of the currently loaded data store
//      If there is not expiration time set, it returns an null string.
//
//---------------------------------------------------------------------------
HRESULT
CPersistUserData::get_expires(BSTR * pstrDate)
{
    HRESULT  hr = S_OK;
    FILETIME ftZero = {0};

    if (!pstrDate)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pstrDate = NULL;

    // only set the return string if there is a non-zero time set
    if (CompareFileTime(&ftZero, &_ftExpires) != 0)
    {
        TCHAR    achDate[DATE_STR_LENGTH];

        hr = ConvertGmtTimeToString(_ftExpires, 
                                    (LPTSTR)&achDate, 
                                    DATE_STR_LENGTH);

        (*pstrDate) = SysAllocString(achDate);
        if (!*pstrDate)
            hr = E_OUTOFMEMORY;
    }

Cleanup:
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member : put_expires
//
//  Synopsis : set the expiration time to be used when the current data store
//      is saved.  If the save method is not called, this has no real effect
//              The date string passed in is expected in GMT format just like
//      other script dates.  Specifically, this uses the same format as cookies
//      which is the format returned by the Date.toGMTString() script call.
//      e.g. "Tue, 02 Apr 1996 02:04:57 UTC"
//
//---------------------------------------------------------------------------
HRESULT
CPersistUserData::put_expires(BSTR bstrDate)
{
    HRESULT   hr;
    FILETIME  ftTemp;

    if (!bstrDate)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = ParseDate(bstrDate, &ftTemp);
    // S_FALSE means that ere  was a parse error
    if (hr ==S_FALSE)
        hr = E_INVALIDARG;

    if (SUCCEEDED(hr))
        _ftExpires = ftTemp;

Cleanup:
    return hr;
}

//============================================================================
//
// Private members of CPersistData to help with the persistence
//
//============================================================================
//---------------------------------------------------------------------------
//
//  Member:     CPersistUserData::LoadUserData
//
//  Synopsis:   IHTMLUserData OM method implementation
//
//  If UDF_BSTR is passed the size is the number of bytes in the string, 
//          excluding the null terminator
//
//---------------------------------------------------------------------------

HRESULT 
CPersistUserData::LoadUserData(
    LPCOLESTR pwzDirPath, 
    LPCOLESTR pwzName, 
    LPVOID *ppData, 
    LPDWORD pdwSize, 
    DWORD dwFlags
    )
{
    HRESULT hr = E_UNEXPECTED;
    LPTSTR pszCacheUrl = NULL;
    DWORD dwError;
    BYTE *buffer = NULL;
    BYTE * pOutBuffer = NULL;
    FILETIME ftZero = {0};

    HANDLE hUrlCacheStream = NULL;

    if (pdwSize == NULL)
    {
        hr = E_POINTER;
        goto cleanup;
    }

    if ((hr = EnsureCacheContainer()) != S_OK)
        return hr;

    // Get the cache url for this document. 
    if ((hr = GetCacheUrlFromDirPath(pwzDirPath, pwzName, &pszCacheUrl)) != S_OK)
    {
        goto cleanup;
    }
    
    Assert(pszCacheUrl != NULL);

    // Now try to retreive the information from the cache.
    LPINTERNET_CACHE_ENTRY_INFO pICEI;
    DWORD cbICEI;

    cbICEI = sizeof(INTERNET_CACHE_ENTRY_INFO) + MAX_PATH /* for the path */ + 1024 /* for URL dir */;
    buffer = new BYTE[cbICEI];
    pICEI = (LPINTERNET_CACHE_ENTRY_INFO)buffer;
    
    if (pICEI == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }
    
    DWORD dwBufSize;
    dwBufSize = cbICEI;

    hUrlCacheStream = NULL;          
    if ((hUrlCacheStream = RetrieveUrlCacheEntryStream(pszCacheUrl, pICEI, &dwBufSize, FALSE,0)) == NULL)
    {

        dwError = ::GetLastError();
        // Try with more memory if the buffer was insufficient.
        if (dwError == ERROR_INSUFFICIENT_BUFFER)
        {
            // If we failed because of insufficient buffer, dwBufSize 
            // better be bigger than the original buffer.
            Assert(dwBufSize > cbICEI);

            delete [] buffer;
            cbICEI = dwBufSize;
            buffer = new BYTE[cbICEI];
            pICEI = (LPINTERNET_CACHE_ENTRY_INFO)buffer;
            if (!pICEI)
            {
                hr = E_OUTOFMEMORY;
                goto cleanup;
            }

            if ((hUrlCacheStream = RetrieveUrlCacheEntryStream(pszCacheUrl, pICEI, &dwBufSize, FALSE,0)) == NULL)
                dwError = ::GetLastError();
            else
                dwError = NOERROR;
        }

        if (dwError != NOERROR)
        {
            // Try to nuke it so it doesn't bother us in the future.
            hr = HRESULT_FROM_WIN32(dwError);
            goto cleanup;
        }
    }

    Assert(hUrlCacheStream != NULL);

    FILETIME currTime;
    GetSystemTimeAsFileTime(&currTime);

    if ((CompareFileTime(&ftZero, &(pICEI->ExpireTime)) != 0) && // ExpireTime is not zero
        (CompareFileTime(&currTime, &(pICEI->ExpireTime))  > 0)  //currentTime is not beyond expired time.
       ) 
    {
        // It is okay to delete the entry even though we have a handle open to it. 
        // the file will get destroyed once we release the handle. 
        DeleteUrlCacheEntry(pszCacheUrl);

#if 0  //  ISSUE: TODO:- sanjays - The logic below is incorrect and needs to be fixed. 
        // To ensure correctness at this point we should delete the sizeof the
        // document from the quota
        LPTSTR pszSite;
        DWORD cchSite;
        if (CreateSiteTable() == S_OK && 
            GetSiteFromCacheUrl(pszCacheUrl, &pszSite, &cchSite) == S_OK)
        {
            pszSite[cchSite] = 0;
            ModifySitesSpaceUsage(pszSite, -(int)RealDiskUsage(pICEI->dwSizeLow));
        }
#endif
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto cleanup;
    }

    DWORD dwOutBufSize;

    dwOutBufSize = pICEI->dwSizeLow;

    // Caller is not interested in the buffer, just wants to the know the amount of 
    // memory required.

    if (ppData == NULL)
    {
        *pdwSize = dwOutBufSize;
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto cleanup;
    } 

    DWORD dwStreamPosition;
    dwStreamPosition = 0;

    // Allocate memory to read in the buffer. 
    if (dwFlags & UDF_BSTR)
    {
        // If we are retrieving a BSTR, we better have an even number of bytes in the stream.
        Assert((dwOutBufSize & 0x1) == 0x0);

        // Since BSTR's are stored as Unicode files they have the lead unicode bytes 
        // We should skip over these and real the actual data.
        DWORD dwLeadCharSize = sizeof(OLECHAR);
        OLECHAR wchLead;

        if (!ReadUrlCacheEntryStream(hUrlCacheStream, 0, &wchLead, &dwLeadCharSize, 0))
        {
            dwError = ::GetLastError();
            hr = HRESULT_FROM_WIN32(dwError);
            goto cleanup;
        }

        // the first two bytes should be the lead unicode file character.
        Assert(wchLead == wchLEADUNICODEFILE);

        dwOutBufSize -= sizeof(OLECHAR);
        dwStreamPosition += sizeof(OLECHAR);
            
        DWORD cch = (dwOutBufSize/sizeof(OLECHAR)); 
        pOutBuffer = (BYTE *) SysAllocStringLen(NULL, cch);
        // SysAllocStringLen will null terminate the string;
    }           
    else
    {
        pOutBuffer = new BYTE[dwOutBufSize];
    }

    if (pOutBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    if (!ReadUrlCacheEntryStream(hUrlCacheStream, dwStreamPosition, pOutBuffer, &dwOutBufSize, 0))
    {
        dwError = ::GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
        goto cleanup;
    }

    // set the pICEI->ExpireTime to the local value to support get_expires.
    if (CompareFileTime(&ftZero, &(pICEI->ExpireTime)) != 0)
    {
        _ftExpires = pICEI->ExpireTime;
    }

    *ppData = (LPVOID)pOutBuffer;
    *pdwSize = dwOutBufSize;
    pOutBuffer = NULL;
    hr = S_OK;

cleanup:

    delete [] pszCacheUrl;
    delete [] buffer;
    delete [] pOutBuffer;

    if (hUrlCacheStream != NULL)
        UnlockUrlCacheEntryStream(hUrlCacheStream, 0);

    return hr;
}


//---------------------------------------------------------------------------
//
//  Member:     CPersistUserData::SaveUserData
//
//  Synopsis:   IHTMLUserData OM method implementation
//
//---------------------------------------------------------------------------

HRESULT 
CPersistUserData::SaveUserData(
    LPCOLESTR pwzDirPath, 
    LPCOLESTR pwzName, 
    LPVOID pData, 
    DWORD dwSize, 
    FILETIME ftExpire, 
    DWORD dwFlags 
    )
{
    // Do Parameter validation.
    HRESULT hr;
    DWORD dwError = NOERROR;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    LPTSTR pszCacheUrl = NULL;
    FILETIME ftZero = { 0 };
    BOOL fAddLeadUnicodeChar = (dwFlags & UDF_BSTR) ? TRUE : FALSE;
     
    if ((hr = EnsureCacheContainer()) != S_OK)
        return hr;

    // make sure we have created the site table which tracks the amount of memory
    // allocated by each site.
    if ((hr = CreateSiteTable()) != S_OK)
        return hr;

    if ((hr = GetCacheUrlFromDirPath(pwzDirPath, pwzName, &pszCacheUrl)) != S_OK)
    {
        return hr;
    }

    // dwOldSize is the size of the document we will be overwriting by saving
    // this document.
    DWORD dwOldDiskUsage = 0;
    DWORD dwDiskUsage = RealDiskUsage(dwSize + (fAddLeadUnicodeChar ? sizeof(WCHAR) : 0));
    
    if ((hr = EnforceStorageLimits(pwzDirPath, pszCacheUrl, dwDiskUsage, &dwOldDiskUsage, TRUE)) != S_OK)
    {
        delete [] pszCacheUrl;
        return hr;
    }

    Assert(pszCacheUrl != NULL);

    TCHAR achFileName[MAX_PATH];

    // Convert the string that we send in to a url name    
    if (!CreateUrlCacheEntry(pszCacheUrl,
                            0,
                            TEXT("xml"),
                            achFileName,
                            0))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    hFile = CreateFile(
            achFileName,
            GENERIC_WRITE,
            0,  // no sharing.
            NULL,
            TRUNCATE_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL);
            
    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }


    DWORD dwBytesWritten;
    dwBytesWritten = 0;

    // Need to add lead character to indicate a Unicode file.
    if ( fAddLeadUnicodeChar )
    {
        if ( !WriteFile(hFile, (LPVOID) &wchLEADUNICODEFILE, sizeof(WCHAR), &dwBytesWritten, NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            CloseHandle(hFile);
            goto cleanup;
        } 
    }
    
    if (!WriteFile(hFile, pData, dwSize, &dwBytesWritten, NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CloseHandle(hFile);
        goto cleanup;
    }

    // We must close the handle before commiting the cache entry. 
    // If we don't some of the file system api's fail on Win95 and
    // consequently the CommitUrlCacheEntry fails as well. 
    CloseHandle(hFile);     

    if (!CommitUrlCacheEntry(pszCacheUrl,
                             achFileName,
                             ftExpire,
                             ftZero,
                             NORMAL_CACHE_ENTRY,
                             NULL,
                             0,
                             NULL,
                             0))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        hr = S_OK;
    }

cleanup:
    // EnforceStorageLimits assumes this store will succeed and updates the size usage
    // Since we didn't we should undo that now.
    if (hr != S_OK)
    {
        // In this case we have to get the site string and undo the changes
        // we made earlier in EnforceStorageLimits.
        LPTSTR pszSite;
        DWORD cchSite;
        if (GetSiteFromCacheUrl(pszCacheUrl, &pszSite, &cchSite) == S_OK)
        {
            pszSite[cchSite] = 0;
            ModifySitesSpaceUsage(pszSite, (int)dwOldDiskUsage - dwDiskUsage);
        }
    }

    delete [] pszCacheUrl;

    return hr ;
}




HRESULT CPersistUserData::GetCacheUrlFromDirPath(LPCOLESTR pwzDirPath, LPCOLESTR pwzFileName, LPTSTR * ppszCacheUrl)
{
    if (pwzDirPath == NULL)
    {
        return E_POINTER;
    }

    if (pwzFileName == NULL)
        pwzFileName = TEXT("_default");
    
    LPCTSTR pszCacheUrlPrefix;
    DWORD cchCacheUrlPrefix ; 

    // IMPORTANT: Do not free the memory returned by GetCacheUrlPrefix.
    if (!GetCacheUrlPrefix(&pszCacheUrlPrefix, &cchCacheUrlPrefix))
    {
        Assert(FALSE);
        return E_FAIL;
    }


    LPTSTR pszUrl;

    HRESULT hr = S_OK;


    // The length of the string remaining to be processed.
    DWORD cch = lstrlen(pwzDirPath);
    // If the path includes the trailing / ignore it for now, we will add it back when composing the URL.
    if (cch > 0 && (pwzDirPath[cch - 1] == chSLASH || pwzDirPath[cch - 1] == chBACKSLASH))
        cch-- ; 

    DWORD cchFileName = lstrlen(pwzFileName);

       
    // The fake URL name we produce is of the form
    // For https://www.microsoft.com/foobar  and document name 'default'
    // userdata:sanjays@https@www.microsoft.com/foobar/default
    
    // First figure out the constituent parts. 
    LPCOLESTR pszScan;

    PARSEDURL pu;
    pu.cbSize = sizeof(pu);
    
    hr = ParseURL(pwzDirPath, &pu);
    
    if (hr == S_OK)
    {
        pszScan = pu.pszSuffix;
        cch -= (DWORD)(pszScan - pwzDirPath);    // we processed the scheme: part of the string.
    }
    else
        return hr;

    // Now skip over any / or \'s till we get to the begining of the host name.
    while (*pszScan == chSLASH || *pszScan == chBACKSLASH)
    {
        *pszScan++;
        cch--;
    }
    
    // This implies the directory path passed in was bogus

    if (*pszScan == 0)
        return E_INVALIDARG;

    DWORD numChars = cchCacheUrlPrefix; // For "userdata:sanjays@" NULL terminator will be used for the ':'
    numChars += pu.cchProtocol + 1 /* for scheme followed by @ */ ;
    numChars += cch + 1;            /* for hostname and path followed by / */
    numChars += cchFileName + 1;  /* filename and the  NULL terminator */ ;
    
                       
    LPTSTR pszCacheUrl = new TCHAR[numChars];

    if (pszCacheUrl == NULL)
        return E_OUTOFMEMORY;
    else
        *ppszCacheUrl = pszCacheUrl;          


    memcpy(pszCacheUrl, pszCacheUrlPrefix, sizeof(TCHAR) * cchCacheUrlPrefix);
    pszCacheUrl += cchCacheUrlPrefix;
    memcpy(pszCacheUrl, pu.pszProtocol, sizeof(TCHAR) * pu.cchProtocol);
    pszCacheUrl += pu.cchProtocol;
    *pszCacheUrl++ = chAT; 
    memcpy(pszCacheUrl, pszScan, sizeof(TCHAR) * cch);
    pszCacheUrl += cch;
    *pszCacheUrl++ = chSLASH;
    memcpy(pszCacheUrl, pwzFileName, sizeof(TCHAR) * (cchFileName + 1));

    return S_OK;
}


// Returns a string of the form userdata:username@. This string is used as a prefix
// on all userdata cache items stored on behalf of this user.
// The caller should not free the memory returned here. 
// If no user name is found ( could happen on Win9x system with no logon it uses the 
// string "anyuser" for the username. 

BOOL CPersistUserData::GetCacheUrlPrefix(LPCTSTR * ppszCacheUrlPrefix, DWORD *pcchCacheUrlPrefix)
{
    BOOL bRet;

    EnterCriticalSection(&s_csCacheUrlPrefix);

    if (s_bCheckedUserName)
    {
        bRet = s_bCacheUrlPrefixRet;
    }            
    else
    {
        TCHAR rgchUserName[MAX_PATH];
        DWORD cchUserNameLen = ARRAY_SIZE(rgchUserName);

        if (!::GetUserName(rgchUserName, &cchUserNameLen))
        {
            DWORD dwError = GetLastError();
            Assert(dwError != ERROR_INSUFFICIENT_BUFFER);
            // Just user the string anyuser
            cchUserNameLen = lstrlen(rgchAnyUser);
            memcpy(rgchUserName, rgchAnyUser, (cchUserNameLen + 1) * sizeof(TCHAR));
            bRet = TRUE;
        }
        else
        {
            bRet = TRUE;
            cchUserNameLen--;  // Includes the count for null termination
        }
            
        // If we succeed we should calculate the cache url prefix as well.
        // Create a string of the form userdata:username@ 

        if (bRet)
        {
            LPTSTR psz = s_rgchCacheUrlPrefix;
            memcpy(psz, s_rgchUserData, sizeof(TCHAR) * (ARRAY_SIZE(s_rgchUserData) - 1));
            psz += (ARRAY_SIZE(s_rgchUserData) - 1);
            *psz++ = chCOLON;
            memcpy(psz, rgchUserName, sizeof(TCHAR) * cchUserNameLen);
            psz += cchUserNameLen;
            *psz++ = chAT;
            *psz = 0;
            s_cchCacheUrlPrefix = (DWORD) (psz - s_rgchCacheUrlPrefix);
        }

    }

    s_bCheckedUserName = TRUE;
    s_bCacheUrlPrefixRet = bRet;
    if (bRet)
    {
        *ppszCacheUrlPrefix = s_rgchCacheUrlPrefix;
        *pcchCacheUrlPrefix = s_cchCacheUrlPrefix;
    }


    LeaveCriticalSection(&s_csCacheUrlPrefix);

    return bRet;
}

// This is an ANSI function in an otherwise unicode world. 
// This is because Unicode versions of the cache folder functions used here 
// are not supported and return ERROR_NOT_IMPLEMENTED

HRESULT CPersistUserData::EnsureCacheContainer()
{                                            
    CHAR achUserData[] = "UserData";
    HRESULT hr = S_OK;
    DWORD dwError = NOERROR;
    CHAR rgchPath[MAX_PATH]; 
    LPCSTR pszDirPath = NULL;
    LPCSTR pszRelPath = NULL;
    BYTE buffer[sizeof(INTERNET_CACHE_CONFIG_INFOA) + sizeof(INTERNET_CACHE_CONFIG_PATH_ENTRYA)];
    INTERNET_CACHE_CONFIG_INFOA *pCacheConfigInfo = (INTERNET_CACHE_CONFIG_INFOA *)buffer;
    DWORD dwBufSize = sizeof(buffer);

    EnterCriticalSection(&s_csCacheContainer);

    if (s_bCheckedCacheContainer)
    {   
        hr = s_hrCacheContainer;
        goto cleanup;

    }
                
    // If SHGetFolderPathA is available and works, try to get the "Application
    // Data" folder.
    if (SHGetFolderPathA(NULL, CSIDL_APPDATA, NULL, 0, rgchPath))
    {
       // We will create the cache container under the appdata folder.
       pszDirPath = rgchPath;
       pszRelPath = rgchRelAppData;
    }
    else if (GetUrlCacheConfigInfoA(pCacheConfigInfo, &dwBufSize, CACHE_CONFIG_COOKIES_PATHS_FC))
    {
        // In this case we will create the cache container in the same directory
        // as cookies.
        pszDirPath = pCacheConfigInfo->CachePaths[0].CachePath;
        pszRelPath = rgchRelCookies;
    }
    else
    {
        Assert(GetLastError() != ERROR_INSUFFICIENT_BUFFER);
        Assert(pCacheConfigInfo->dwNumCachePaths == 1);     

        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;                     
    }

    // Compose the path for the directory. Combine the dirpath and relative path
    // to get the location of the userdata folder.
    if (PathCombineA(rgchPath, pszDirPath, pszRelPath) == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    // Now try to create the cache entry. 
    if (!CreateUrlCacheContainerA(
                achUserData,
                achUserData,
                rgchPath,
                1000,
                0, 
                (INTERNET_CACHE_CONTAINER_NODESKTOPINIT 
                ),
                NULL,
                NULL)
        )
    {
        // If this was because the cache already existed we are okay. 
        dwError = GetLastError();
        
        if (dwError != ERROR_ALREADY_EXISTS)
            hr = HRESULT_FROM_WIN32(dwError);
    }           

    // Figure out the cluster size information for the disk that the cache container
    // will live on.
    // The directory name lives in rgchPath, we will clobber it to create a string
    // which just has the device part.
    if (rgchPath[0] != chSLASH && rgchPath[0] != chBACKSLASH)
    {
        // Dir path is of the from c:\..... We just need the c:\ part.
        rgchPath[3] = 0;
    }
    else
    {
         // Dir path is of the form \\foo\bar\.... 
        // In this case we pass the name passed to GetDiskSpace is the whole string
        DWORD dwLen = lstrlenA(rgchPath);
        if (dwLen + 1 < ARRAY_SIZE(rgchPath))
        {
            rgchPath[dwLen] = schDIR_SEPERATOR;
            rgchPath[dwLen + 1] = '\0';
        }
    }

    DWORD dwSectorsPerCluster;
    DWORD dwBytesPerSector;
    DWORD dwFreeClusters;
    DWORD dwClusters;
    DWORD dwClusterSize;
    if (GetDiskFreeSpaceA(rgchPath, &dwSectorsPerCluster, &dwBytesPerSector, &dwFreeClusters, &dwClusters))
    {
        s_dwClusterSizeMinusOne = dwSectorsPerCluster * dwBytesPerSector - 1;
        s_dwClusterSizeMask     = ~s_dwClusterSizeMinusOne;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

cleanup:

    s_bCheckedCacheContainer = TRUE;
    s_hrCacheContainer = hr;

    LeaveCriticalSection(&s_csCacheContainer);
    return hr;
}                        

// Adds iSizeDelta to the amount of space taken by this site. 
// Creates a new entry if non-exists to date. 

HRESULT CPersistUserData::ModifySitesSpaceUsage(LPCTSTR pszKey, int iSizeDelta)
{
    HRESULT hr = S_OK;
    EnterCriticalSection(&s_csSiteTable);

    Assert(s_pSiteTable);

    if (s_pSiteTable != NULL)
    {
        DWORD dwSpace;

        if (!s_pSiteTable->Lookup(pszKey, dwSpace))
            dwSpace = 0;

        if (iSizeDelta < 0 && (-iSizeDelta  > (int)dwSpace))
        {
            // Our quota is going to be set to a number less than zero.
            // Assert but recover by setting space usage to zero.
            Assert(FALSE);
            dwSpace = 0;                   
        }
        else
             dwSpace += iSizeDelta;


        hr = s_pSiteTable->SetAt(pszKey, dwSpace);
    }
    else
        hr = E_FAIL;
                  
    LeaveCriticalSection(&s_csSiteTable);

    return hr;
}

// Helper function to get the site string given a cache URL name. 
//  arguments
//      pszCacheUrl [in] - Cache Url for which we want the site URL.
//      *ppszBegPos [out[ - will contain the pointer where the site begins.
//      *pcch = number of characters in the site name. 
// Returns
//          S_OK if entry is for current user, the two out arguments are valid in this case.
//          S_FALSE if entry is for a different user.
//          E_* on failure

HRESULT CPersistUserData::GetSiteFromCacheUrl(LPCTSTR pszCacheUrl, LPTSTR * ppszBegPos, DWORD *pcch)
{
    LPCTSTR pszCacheUrlPrefix;
    DWORD cchCacheUrlPrefix ; 

    if (pszCacheUrl == NULL)
        return E_INVALIDARG;    

    // IMPORTANT: Do not free the memory returned by GetCacheUrlPrefix.
    if (!GetCacheUrlPrefix(&pszCacheUrlPrefix, &cchCacheUrlPrefix))
    {
        Assert(FALSE);
        return E_FAIL;
    }
    
    if (StrCmpNI(pszCacheUrl, pszCacheUrlPrefix, cchCacheUrlPrefix) == 0)
    {
        LPCTSTR psz = pszCacheUrl + cchCacheUrlPrefix;

        // At this point psz points to the begining of the protocol. 
        // Everything from this point to the first / or \ is what we use
        // to track the site name.

        LPCTSTR pszEnd = psz;
        while (*pszEnd != 0 && *pszEnd != chSLASH && *pszEnd != chBACKSLASH)
            pszEnd++;

        Assert(*pszEnd != 0);
        if (*pszEnd == 0)
            return E_INVALIDARG;
        
        *ppszBegPos = (LPTSTR)psz;
        *pcch = (DWORD)(pszEnd - psz);
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

        
        
// Create the Site Table and populate it.
#define CACHE_ENTRY_BUFFER_SIZE (sizeof(INTERNET_CACHE_ENTRY_INFO) \
                                 + MAX_PATH * sizeof(TCHAR)\
                                 + INTERNET_MAX_URL_LENGTH * sizeof(TCHAR))

HRESULT CPersistUserData::CreateSiteTable( )
{           
    HRESULT hr = S_OK;

    // First grab the critical section so no else tries to do this at
    // the same time.
    EnterCriticalSection(&s_csSiteTable);

    if (s_pSiteTable == NULL)
    {
        s_pSiteTable = new CSiteTable();
        if (s_pSiteTable == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }


        // Now iterate over the cache container and populate the entries
        // in the table.
        BYTE buffer[CACHE_ENTRY_BUFFER_SIZE];
        LPINTERNET_CACHE_ENTRY_INFO lpICEI = (LPINTERNET_CACHE_ENTRY_INFO)buffer;
        DWORD dwBufSize = CACHE_ENTRY_BUFFER_SIZE;

        lpICEI->dwStructSize = sizeof(INTERNET_CACHE_ENTRY_INFO);

        HANDLE hEnum = FindFirstUrlCacheEntry(
                           TEXT("userdata:"),
                           lpICEI,
                           &dwBufSize
                           );

        if (hEnum == NULL)
        {
            DWORD dwError = GetLastError();
            // If this assert fires the
            // assumption that our buffer size is 
            // big enough is getting violated. 
            // Either up the limit or change to use
            // a dynamic allocation where we retry the
            // call
            Assert(dwError != ERROR_INSUFFICIENT_BUFFER);

            // If we can't get an enumerator because the container is empty we are 
            // fine.
            if (dwError == ERROR_NO_MORE_ITEMS)
                hr = S_OK;
            else
                hr = HRESULT_FROM_WIN32(dwError);
            goto cleanup;
        }

        // make sure the entry has not expired.
        FILETIME ftZero = {0};
        FILETIME currTime;
        GetSystemTimeAsFileTime(&currTime);

        do 
        {
            // The URL name we created is of the form.
            // userdata:username@http:www.microsoft.com/foobar/default

            if (lpICEI->lpszSourceUrlName != NULL)
            {
                DWORD cchSite; 
                LPTSTR pszSite;

                if ((CompareFileTime(&ftZero, &(lpICEI->ExpireTime)) != 0) && // ExpireTime is not zero
                    (CompareFileTime(&currTime, &(lpICEI->ExpireTime))  > 0)  //currentTime is beyond expires time.
                   ) 
                {
                    // TODO : Is it okay to delete the cache entry while we are still enumerating it.
                    DeleteUrlCacheEntry(lpICEI->lpszSourceUrlName);
                }
                else
                {
                    hr = GetSiteFromCacheUrl(lpICEI->lpszSourceUrlName, &pszSite, &cchSite);
                    if (hr == S_FALSE)
                    {
                        // This implies that the document does not belong to this user.
                        // Continue on to the next entry.
                        hr = S_OK;
                        continue;
                    }
                    else if (FAILED(hr))
                    {
                        break;
                    }
                                

                    // If we reach here the document belongs to this user. 

                    // Null terminate the site string. We are not interested
                    // in the parts beyond the site name for tracking memory
                    // usage
                    pszSite[cchSite] = 0;

                    // We don't support userdata files beyond 4GB
                    Assert(lpICEI->dwSizeHigh == 0);

                    hr = ModifySitesSpaceUsage(pszSite, RealDiskUsage(lpICEI->dwSizeLow));

                    // Only reasonable way in which this function could fail is if it out of memory.
                    // In that case we will just return failure from the API.
                    if (hr != S_OK)
                        break;
                }
            }            
            // Previous call might have modified these values.
            // Re-init to the actual sizes of the buffers.
            dwBufSize = CACHE_ENTRY_BUFFER_SIZE;
            lpICEI->dwStructSize = sizeof(INTERNET_CACHE_ENTRY_INFO);

        } while (FindNextUrlCacheEntry(hEnum, lpICEI, &dwBufSize));

        FindCloseUrlCache(hEnum);
    }

cleanup:
    LeaveCriticalSection(&s_csSiteTable);

    return hr;
}


HRESULT CPersistUserData::DeleteSiteTable()
{
    HRESULT hr = S_OK;

    // Destroy the site table object. It should clean up all the allocated memory.
    EnterCriticalSection(&s_csSiteTable);
    delete s_pSiteTable;
    s_pSiteTable = NULL;
    LeaveCriticalSection(&s_csSiteTable);

    return hr;
}


// This function enforces the storage limit for a given site.
// Arguments :
//      pwzDirPath - URL of the HTML document storing the data.
//      pszCacheUrl - corresponding cache URL of the document. 
//      dwDiskUsage - disk space used by the userdata file to be stored.
//      *pdwOldDiskUsage - disk usage of the document being overwritten if the save is done.
//      bModify - if this flag is TRUE, the function will change the size usage
//          of this site to reflect the saving of this document. 

HRESULT CPersistUserData::EnforceStorageLimits(
    LPCOLESTR /* pwzDirPath */, 
    LPCTSTR pszCacheUrl, 
    DWORD dwDiskUsage,
    DWORD* pdwOldDiskUsage,
    BOOL bModify
    )
{
    HRESULT hr = S_OK;

    LPTSTR pszBegSite;
    DWORD cchSite;
    LPTSTR pszSite;
    DWORD dwDomainLimit;
    DWORD dwDocLimit;
    DWORD dwZone = URLZONE_INVALID;

    dwZone = GetZone();
    Assert(ARRAY_SIZE(s_rgdwDomainLimit) == ARRAY_SIZE(s_rgdwDocLimit));

    if (dwZone < ARRAY_SIZE(s_rgdwDomainLimit))
    {
        dwDomainLimit = s_rgdwDomainLimit[dwZone];
        dwDocLimit = s_rgdwDocLimit[dwZone];
    }
    else
    {
        dwDomainLimit = s_dwUnkZoneDomainLimit;
        dwDocLimit = s_dwUnkZoneDocLimit;
    }

    if (dwDiskUsage > (dwDocLimit * 1024))
        return HRESULT_FROM_WIN32(ERROR_HANDLE_DISK_FULL);

    

    // First get the site string we will use as a key to save this sites space usage.
    hr = GetSiteFromCacheUrl(pszCacheUrl, &pszBegSite, &cchSite);

    if (hr == S_OK)     
    {
        // Copy the string into our own buffer and         
        pszSite = (LPTSTR) _alloca((cchSite + 1) * sizeof(TCHAR));
       
        memcpy(pszSite, pszBegSite, cchSite * sizeof(TCHAR));
        pszSite[cchSite] = 0;
    }                              
    else if (hr == S_FALSE)
    {
        // This implies that we are being asked to check the storage limit for a user
        // who is not the current user. We don't support this currently.
        hr = E_INVALIDARG;
    }

    if (hr != S_OK)
        return hr;

    // Now figure ouf the size of the document in the cache.
    BYTE buffer[CACHE_ENTRY_BUFFER_SIZE];
    LPINTERNET_CACHE_ENTRY_INFO lpICEI = (LPINTERNET_CACHE_ENTRY_INFO) buffer;
    DWORD dwBufSize = CACHE_ENTRY_BUFFER_SIZE;

    lpICEI->dwStructSize = sizeof(INTERNET_CACHE_ENTRY_INFO);

    DWORD dwOldDiskUsage = 0;

    if (GetUrlCacheEntryInfo(pszCacheUrl, lpICEI, &dwBufSize))
    {
        // Found an old entry. get the size of the document. 
        Assert(lpICEI->dwSizeHigh == 0);

        dwOldDiskUsage = RealDiskUsage(lpICEI->dwSizeLow);
    }
    else
    {
        DWORD dwError = GetLastError();

        // We have allocated a big enough buffer. The call 
        // should not return not enough memory
        Assert(dwError != ERROR_INSUFFICIENT_BUFFER);
        if (dwError == ERROR_FILE_NOT_FOUND)
            dwOldDiskUsage = 0;
        else
        {
            hr = HRESULT_FROM_WIN32(dwError);
            return hr;
        }
    }

    int iSizeDelta = (int)(dwDiskUsage - dwOldDiskUsage);

    EnterCriticalSection(&s_csSiteTable);
    if (iSizeDelta > 0)
    {
        DWORD dwCurrentSize;

        // We are increasng the size allocation. Check if we have enough space.
        if (!s_pSiteTable->Lookup(pszSite, dwCurrentSize))
            dwCurrentSize = 0;

        dwCurrentSize += iSizeDelta;
        if (dwCurrentSize > (dwDomainLimit * 1024) )
        {
            // We might want to define a new error such as E_QUOTAEXCEEDED here.
            hr = HRESULT_FROM_WIN32(ERROR_HANDLE_DISK_FULL);
        }
    }

    if (pdwOldDiskUsage)
        *pdwOldDiskUsage = dwOldDiskUsage;

    if (hr == S_OK && bModify && iSizeDelta != 0)
    {
        hr = ModifySitesSpaceUsage(pszSite, iSizeDelta);
    }

    LeaveCriticalSection(&s_csSiteTable);

    return hr;
}

           

    
// CSiteTable is a helper class we use to keep track of the amount of allocations per-site. 
// This is used to decide if the site is exceeding it's quota when a new document is being 
// saved.
// It seems like a much simpler approach would be to enumerate the entries in the container
// when the site is trying to write a new document. However the cache enumeration API's don't allow
// for filtering based on sitename. Since we are forced to enumerate all the documents
// we remember the current amount of memory allocated by each site.
CSiteTable::CSiteTable(int nTableSize)
{
    m_pHashTable = NULL;
    m_nHashTableSize = nTableSize;
    m_nCount = 0;
}

CSiteTable::~CSiteTable()
{
    RemoveAll();
}

inline UINT CSiteTable::HashKey(LPCTSTR key) const
{
    UINT nHash = 0;            

    while (*key)
        nHash = (nHash<<5) + nHash + *key++;

    return nHash;
}


HRESULT CSiteTable::InitHashTable()
{
    Assert(m_nCount == 0);
    Assert(m_nHashTableSize > 0);
    
    m_pHashTable = new CAssoc*[m_nHashTableSize];
    if (m_pHashTable == NULL)
        return E_OUTOFMEMORY;

    memset(m_pHashTable, 0, sizeof(CAssoc*) * m_nHashTableSize);
    
    return S_OK;
}

// Change the hash table to the new size, This is an expensive
// operation but is done infrequently. 

HRESULT CSiteTable::ChangeHashTableSize(int nHashSize)
{
    Assert(nHashSize != 0);

    if (m_pHashTable == NULL)
    {
        // Easy we are done
        m_nHashTableSize = nHashSize;
        return S_OK;
    }

    // Allocate an alternate hash table.
    CAssoc **pNewHashTable = new CAssoc*[nHashSize];
    if (pNewHashTable == NULL)
        return E_OUTOFMEMORY;

    memset(pNewHashTable, 0, sizeof(CAssoc *) * nHashSize);

    // Loop over the entries in the current hash table and 
    // add them to the new hash table.
    for (UINT nHash = 0 ; nHash < m_nHashTableSize ; nHash++)
    {
        CAssoc *pAssoc = m_pHashTable[nHash];
        while (pAssoc != NULL)
        {
            UINT nNewHash = HashKey(pAssoc->pStr) % nHashSize;
            CAssoc * pAssocCurrent = pAssoc; 
            pAssoc = pAssoc->pNext;

            pAssocCurrent->pNext = pNewHashTable[nNewHash];
            pNewHashTable[nNewHash] = pAssocCurrent;
        }
    }

    delete [] m_pHashTable;
    m_pHashTable = pNewHashTable;
    return S_OK;
}

void CSiteTable::RemoveAll()
{
    if (m_pHashTable != NULL)
    {
        for (UINT nHash = 0 ; nHash < m_nHashTableSize; nHash++)
        { 
           CAssoc *pAssoc = m_pHashTable[nHash];
           while (pAssoc != NULL)
           {
                LocalFree(pAssoc->pStr);
                CAssoc * pAssocDel = pAssoc;
                pAssoc = pAssoc->pNext;
                delete pAssocDel;
           }
        }
        delete [] m_pHashTable;
        m_pHashTable = NULL;
    }
    m_nCount = 0;
}

CSiteTable::CAssoc *
CSiteTable::GetAssocAt(LPCTSTR key, UINT &nHash) const
{
    nHash = HashKey(key) % m_nHashTableSize;

    if (m_pHashTable == NULL)
        return NULL;

    CAssoc *pAssoc;
    for (pAssoc = m_pHashTable[nHash] ;
         pAssoc != NULL;
         pAssoc = pAssoc->pNext
        )
    {
        if (StrCmpI(key, pAssoc->pStr) == 0)
            return pAssoc;
    
    }
    
    return NULL;
}

BOOL CSiteTable::Lookup(LPCTSTR key, DWORD &rdw) const
{
    UINT nHash;
    CAssoc *pAssoc = GetAssocAt(key, nHash);
    if (pAssoc == NULL)
        return FALSE;   // not in table.
    rdw = pAssoc->dwValue;
    return TRUE;

}

HRESULT CSiteTable::SetAt(LPCTSTR key, DWORD dwValue)
{
    UINT nHash;

    CAssoc *pAssoc;
    if ((pAssoc = GetAssocAt(key, nHash)) == NULL)
    {
        HRESULT hr = S_OK;
        if (m_pHashTable == NULL)
        {
            hr = InitHashTable();
        }
        else if (m_nHashTableSize * 2 <= m_nCount)
        { 
            // If we have twice as many sites as entries in 
            // the hash table we will grow the size

            // If this doesn't suceed we still have a 
            // hash table of the previous size. 
            // We will attempt to use that.
            if (ChangeHashTableSize(m_nHashTableSize * 2) == S_OK)
                nHash = HashKey(key) % m_nHashTableSize;   //recalculate the hash value. 
        }
        
        if (hr != S_OK)
            return hr;

        pAssoc = new CAssoc();
        if (pAssoc == NULL)
            return E_OUTOFMEMORY;

        pAssoc->pStr = StrDup(key);
        if (pAssoc->pStr == NULL)
        {
            delete pAssoc;
            return E_OUTOFMEMORY;
        }

        //. Put into the hash table.
        pAssoc->pNext = m_pHashTable[nHash];
        m_pHashTable[nHash] = pAssoc;
        m_nCount++;
    }
    pAssoc->dwValue = dwValue;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\tmpprint.cxx ===
//===============================================================
//
//  tmpprint.cxx : Implementation of the CTemplatePrinter Peer
//
//  Synposis : This class has two major responsibilities
//      1) Providing printer UI (dialogs, &c...) to a print template
//      2) Providing a way for the template document to reach the printer
//
//===============================================================
                                                              
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TMPPRINT_HXX_
#define X_TMPPRINT_HXX_
#include "tmpprint.hxx"
#endif

#ifndef X_IEXTAG_H_
#define X_IEXTAG_H_
#include "iextag.h"
#endif

#ifndef X_SHLGUID_H_
#define X_SHLGUID_H_
#include <shlguid.h> 
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"       //  For default header/footer resource
#endif

#ifndef X_UTILS_HXX_
#define X_UTILS_HXX_
#include "utils.hxx"
#endif

#ifndef X_DLGS_H_
#define X_DLGS_H_
#include "dlgs.h"
#endif

#ifndef X_VRSSCAN_HXX_
#define X_VRSSCAN_HXX_
#include "vrsscan.h"
#endif

#ifndef X_WINSPOOL_H_
#define X_WINSPOOL_H_
#include "winspool.h"
#endif

#ifndef X_WINGDI_H_
#define X_WINGDI_H_
#include "wingdi.h"
#endif

#include <commctrl.h>
#include <commdlg.h>
#include <mshtmcid.h>
#include <mshtmdid.h>
#include <dispex.h>

// NB (greglett)
// We need to define this because we're building with a WINVER of 4, and this is only deifned for NT5
// Remove this as soon as the winver changes.
#define NEED_BECAUSE_COMPILED_AT_WINVER_4
#ifdef  NEED_BECAUSE_COMPILED_AT_WINVER_4
#define PD_CURRENTPAGE                 0x00400000
#define PD_NOCURRENTPAGE               0x00800000
#endif

// This is defined in transform.hxx, but we can't access that as a peer.
inline int MulDivQuick(int nMultiplicand, int nMultiplier, int nDivisor)
        { Assert(nDivisor); return (!nDivisor-1) & MulDiv(nMultiplicand, nMultiplier, nDivisor); }

#define ORIENTPORTRAIT  _T("portrait")
#define ORIENTLANDSCAPE _T("landscape")

static const TCHAR *s_aachPrintArg[] = 
{
    _T("__IE_BrowseDocument"),          // PRINTARG_BROWSEDOC
    _T("__IE_PrinterCMD_DevNames"),     // PRINTARG_DEVNAMES
    _T("__IE_PrinterCMD_DevMode"),      // PRINTARG_DEVMODE
    _T("__IE_PrinterCMD_Printer"),      // PRINTARG_PRINTER
    _T("__IE_PrinterCMD_Device"),       // PRINTARG_DRIVER
    _T("__IE_PrinterCMD_Port"),         // PRINTARG_PORT
    _T("__IE_PrintType"),               // PRINTARG_TYPE
};

#define DEVCAP_COPIES       0
#define DEVCAP_COLLATE      1
#define DEVCAP_DUPLEX       2
#define DEVCAP_LAST_RETAIL  3   // Add more retail properties before this!

#ifndef DBG

#define DEVCAP_LAST             DEVCAP_LAST_RETAIL

#else

#define DEVCAP_DBG_PRINTERNAME  DEVCAP_LAST_RETAIL
#define DEVCAP_LAST             DEVCAP_LAST_RETAIL + 1

#endif

static const TCHAR *s_aachDeviceCapabilities[] = 
{
    _T("copies"),        
    _T("collate"),       
    _T("duplex"),               // Add more retail properties after this!

#if DBG == 1
    _T("printerName"),
#endif
};


//+----------------------------------------------------------------------------
//
//  Function : InitMultiByteFromWideChar
//
//  Synopsis : Allocates & creates a wide char string from a multi byte string.
//
//-----------------------------------------------------------------------------
LPSTR
InitMultiByteFromWideChar(LPCWSTR pchWide, long cchWide)
{
    long    cchMulti;
    char *  pchMulti;

    //
    // Alloc space on heap for buffer.
    //
    cchMulti = ::WideCharToMultiByte(CP_ACP, 0, pchWide, cchWide, NULL, 0, NULL, NULL);
    Assert(cchMulti > 0);

    cchMulti++;
    pchMulti = new char[cchMulti];
    if (pchMulti)
    {
        ::WideCharToMultiByte(CP_ACP, 0, pchWide, cchWide, pchMulti, cchMulti, NULL, NULL);
        pchMulti[cchMulti - 1] = '\0';
    }

    return pchMulti;
}
inline LPSTR
InitMultiByteFromWideChar(LPCWSTR pwch)
{
    return InitMultiByteFromWideChar(pwch, _tcslen(pwch));
}

//+----------------------------------------------------------------------------
//
//  Function : InitWideCharFromMultiByte
//
//  Synopsis : Allocates & creates a multibyte string from a widechar string.
//
//-----------------------------------------------------------------------------
LPWSTR
InitWideCharFromMultiByte(LPSTR pchMulti, long cchMulti)
{
    long    cchWide;
    LPWSTR  pchWide;

    //
    // Alloc space on heap for buffer.
    //
    cchWide = ::MultiByteToWideChar(CP_ACP, 0, pchMulti, cchMulti, NULL, 0);
    Assert(cchWide > 0);

    cchWide++;
    pchWide = new WCHAR[cchWide];
    if (pchWide)
    {
        ::MultiByteToWideChar(CP_ACP, 0, pchMulti, cchMulti, pchWide, cchWide);
        pchWide[cchWide - 1] = _T('\0');
    }

    return pchWide;
}
inline LPWSTR
InitWideCharFromMultiByte(LPSTR pwch)
{
    return InitWideCharFromMultiByte(pwch, strlen(pwch));
}

//+----------------------------------------------------------------------------
//
//  Function : CreateDevNames
//
//  Synopsis : Takes the three strings in a DEVNAMES structure, allocates &
//             & creates the structure as a GHND.
//
//-----------------------------------------------------------------------------
HRESULT
CreateDevNames(TCHAR *pchDriver, TCHAR *pchPrinter, TCHAR *pchPort, HGLOBAL *pDN)
{
    HRESULT hr = S_OK;
    DWORD dwLenDriver, dwLenPrinter, dwLenPort;
    DWORD nStructSize;

    Assert(pDN);

    if (!pchDriver || !pchPrinter || !pchPort)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    dwLenDriver  = _tcslen(pchDriver) + 1;
    dwLenPrinter = _tcslen(pchPrinter) + 1;
    dwLenPort    = _tcslen(pchPort) + 1;

    nStructSize = sizeof(DEVNAMES)
                  + ((dwLenPrinter + dwLenDriver + dwLenPort) * sizeof(TCHAR));
    (*pDN) = ::GlobalAlloc(GHND, nStructSize);

    if (!(*pDN))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    {
        DEVNAMES *pDevNames = ((DEVNAMES *) ::GlobalLock(*pDN));
        if (pDevNames)
        {
#pragma warning(disable: 4244)
            pDevNames->wDriverOffset = sizeof(DEVNAMES) / sizeof(TCHAR);
            pDevNames->wDeviceOffset = pDevNames->wDriverOffset + dwLenDriver;
            pDevNames->wOutputOffset = pDevNames->wDeviceOffset + dwLenPrinter;
#pragma warning(default: 4244)
            _tcscpy((((TCHAR *)pDevNames) + pDevNames->wDriverOffset), pchDriver);
            _tcscpy((((TCHAR *)pDevNames) + pDevNames->wDeviceOffset), pchPrinter);
            _tcscpy((((TCHAR *)pDevNames) + pDevNames->wOutputOffset), pchPort);
        }
        ::GlobalUnlock(*pDN);        
    }

Cleanup:
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member : Init - IElementBehavior method impl
//
//  Synopsis :  peer Interface, initialization
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::Init(IElementBehaviorSite * pPeerSite)
{
    HRESULT hr      = S_OK;
    HKEY    hKey    = NULL;

    if (!pPeerSite)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // cache our peer element
    _pPeerSite = pPeerSite;
    _pPeerSite->AddRef();
    _pPeerSite->QueryInterface(IID_IElementBehaviorSiteOM, (void**)&_pPeerSiteOM);

    GetDialogArguments();   // Cache the dialog arguments.

    // What order should we obtain default print settings?
    // 1. Settings passed in by our host (1a and 1b should be mutually exclusive)
    //   1a. A DEVMODE/DEVNAMES
    //   1b. A printer (and maybe a port & driver name, too)
    // 2. Read defaults from the registry
    // 3. Get the default Windows printer, if any.

    //
    // READ IN A DEVMODE/DEVNAMES
    //
    {
        VARIANT varDM;
        VARIANT varDN;
        VariantInit(&varDN);
        VariantInit(&varDM);

        // Only accept arguments in matched pair.
        if (    GetDialogArgument(&varDN, PRINTARG_DEVNAMES) == S_OK
            &&  GetDialogArgument(&varDM, PRINTARG_DEVMODE) == S_OK
            &&  V_VT(&varDN) == VT_HANDLE
            &&  V_VT(&varDM) == VT_HANDLE
            &&  V_BYREF(&varDN)
            &&  V_BYREF(&varDM) )
        {
            RemoveDialogArgument(PRINTARG_DEVNAMES);
            RemoveDialogArgument(PRINTARG_DEVMODE);
                
            _hDevNames  = V_BYREF(&varDN);  // NB We will release this!
            _hDevMode   = V_BYREF(&varDM);  // NB We will release this!
        }

        VariantClear(&varDN);
        VariantClear(&varDM);
    }

    //
    // READ IN A PRINTER/PORT/DRIVER
    //
    if (!_hDevNames)
    {
        VARIANT varPrinter;
        VARIANT varDriver;
        VARIANT varPort;

        VariantInit(&varPrinter);
        VariantInit(&varDriver);
        VariantInit(&varPort);

        Assert(!_hDevMode);

        if (    GetDialogArgument(&varPrinter, PRINTARG_PRINTER) == S_OK
            &&  V_VT(&varPrinter) == VT_BSTR
            &&  V_BSTR(&varPrinter) )
        {
            GetDialogArgument(&varDriver, PRINTARG_DRIVER);
            GetDialogArgument(&varPort, PRINTARG_PORT);

            if (g_fUnicodePlatform)
                hr = ReadDeviceUnicode(V_BSTR(&varPrinter),
                                       V_VT(&varDriver) == VT_BSTR ? V_BSTR(&varDriver) : NULL,
                                       V_VT(&varPort) == VT_BSTR ? V_BSTR(&varPort) : NULL );
            else
                hr = ReadDeviceNonUnicode(V_BSTR(&varPrinter),
                                          V_VT(&varDriver) == VT_BSTR ? V_BSTR(&varDriver) : NULL,
                                          V_VT(&varPort) == VT_BSTR ? V_BSTR(&varPort) : NULL );
        }

        VariantClear(&varPrinter);
        VariantClear(&varDriver);
        VariantClear(&varPort);
    }

    // Get these default settings from the registry, if we can
    //      1.  Header/Footer
    //      2.  Margins
    //      3.  Target device (printer)
    //      4.  Page size/Paper source information.
    if (GetRegPrintOptionsKey(PRINTOPTSUBKEY_PAGESETUP, &hKey) == S_OK)
    {            
        ReadHeaderFooterFromRegistry(hKey);
        ReadMarginsFromRegistry(hKey);

        RegCloseKey(hKey);
    }          

    //      5.  Table of links
    if (GetRegPrintOptionsKey(PRINTOPTSUBKEY_MAIN, &hKey) == S_OK)
    {            
        _fPrintTableOfLinks = ReadBoolFromRegistry(hKey, _T("Print_Shortcuts"));

        RegCloseKey(hKey);
    }          

    hr = GetDeviceProperties();     // Returns E_FAIL if we don't have a valid printer at this point.

    //
    // DEFAULT WINDOWS PRINTER
    //
    if (hr)
        hr = GetPrintDialogSettings(FALSE, NULL);    // Get printer defaults.

Cleanup:
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member : Detach - IElementBehavior method impl
//
//  Synopsis :  peer Interface, destruction work upon detaching from document
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::Detach() 
{ 
    // Abort any currently printing document.
    if (_hDC)
    {
        ::AbortDoc(_hDC);
        ::DeleteDC(_hDC);
        _hDC = NULL;
    }
    
    // Free any cached resources.
    if (_hInstResource)
    {
        MLFreeLibrary(_hInstResource);
        _hInstResource = NULL;
    }
    if (_hInstRatings)
    {
        FreeLibrary(_hInstRatings);
        _hInstRatings = NULL;
    }
    if (_hInstComctl32)
    {
        FreeLibrary(_hInstComctl32);
        _hInstComctl32 = NULL;
    }

    ReturnPrintHandles();       // Send our print handles back to the master thread CDoc.
    if (_hDevNames)
    {
        ::GlobalFree(_hDevNames);
        _hDevNames = NULL;
    }
    if (_hDevMode)
    {
        ::GlobalFree(_hDevMode);
        _hDevMode = NULL;
    }

    // Clear any COM interfaces we currently reference
    ClearInterface( &_pevDlgArgs );
    ClearInterface( &_pPeerSite );
    ClearInterface( &_pPeerSiteOM );

    return S_OK; 
}

//+----------------------------------------------------------------------------
//
//  Member : Notify - IElementBehavior method impl
//
//  Synopsis : peer Interface, called for notification of document events.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::Notify(LONG lEvent, VARIANT *)
{
    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Member : (ITemplatePrinter) CTemplatePrinter::printPage 
//
//  Synopsis : takes the passed element and prints it on its own page
//             should be called any number of times after startDoc, and before endDoc.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::printBlankPage()
{
    // No TEMPLATESECURITYCHECK() required because printPage has one.
    
    return printPage(NULL);
}

STDMETHODIMP
CTemplatePrinter::printPage(IDispatch *pElemDisp)
{
    TEMPLATESECURITYCHECK()
    
    IHTMLElementRender  *pRender = NULL;
    HRESULT hr = S_OK;

    if (!_hDC)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (::StartPage(_hDC) <= 0)
    {
    // Returns a "nonzero" value on success, "zero" on failure.
        
        DWORD dwError = GetLastError(); 
        Assert(FALSE && "error calling StartPage api");
        hr = E_FAIL;
        goto Cleanup;
    }

#ifdef DBG
    RECT rcUnprintTest;
    SIZE szResTest;
    SIZE szPage;

    szResTest.cx            = ::GetDeviceCaps(_hDC, LOGPIXELSX);
    szResTest.cy            = ::GetDeviceCaps(_hDC, LOGPIXELSY);
    szPage.cx               = ::GetDeviceCaps(_hDC, PHYSICALWIDTH);
    szPage.cy               = ::GetDeviceCaps(_hDC, PHYSICALHEIGHT);
    rcUnprintTest.left      = ::GetDeviceCaps(_hDC, PHYSICALOFFSETX);
    rcUnprintTest.top       = ::GetDeviceCaps(_hDC, PHYSICALOFFSETY);
    rcUnprintTest.right     =  szPage.cx - ::GetDeviceCaps(_hDC, HORZRES) - rcUnprintTest.left;
    rcUnprintTest.bottom    =  szPage.cy - ::GetDeviceCaps(_hDC, VERTRES) - rcUnprintTest.top;   
    Assert(     rcUnprintTest.left == _rcUnprintable.left
            &&  rcUnprintTest.right == _rcUnprintable.right
            &&  rcUnprintTest.top == _rcUnprintable.top
            &&  rcUnprintTest.bottom == _rcUnprintable.bottom );
#endif

    //  If we have been given an element, draw it to the screen.
    if (pElemDisp)
    {
        hr = pElemDisp->QueryInterface(IID_IHTMLElementRender, (void **)&pRender);
        if (hr) 
            goto Cleanup;
          
        ::SetViewportOrgEx(_hDC, -_rcUnprintable.left,-_rcUnprintable.top, NULL);

        hr = pRender->DrawToDC(_hDC);
    }

    if (::EndPage(_hDC) <= 0)
    {
        // Known issues with EndPage:
        // 1.   Win95 Fax fails the EndPage API when the "SetUpMyFax" wizard is aborted.  dwError=0.  (100092)
        DWORD dwError = GetLastError(); 
        goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pRender);
    if (hr)
        stopDoc();

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member : (ITemplatePrinter) CTemplatePrinter::startDoc
//
//  Synopsis : Gets/Inits the default printer and starts to print a document.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::startDoc(BSTR bstrTitle, VARIANT_BOOL * p)
{
    TEMPLATESECURITYCHECK()
    
    HRESULT     hr = S_OK;
    DOCINFO     docinfo;
    TCHAR       achTitle[MAX_JOBNAME];
    
    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *p = VB_FALSE;

    if (    _hDC
        ||  !_hDevNames 
        ||  !_hDevMode)
    {
        hr = S_FALSE;
        goto Cleanup;
    }
    
    {
        DEVNAMES *pDevNames = ((DEVNAMES *) ::GlobalLock(_hDevNames));
        void     *pDevMode  = ::GlobalLock(_hDevMode);
        if (pDevNames && pDevMode)
        {           
            // (greglett) Non-Unicode badness.  See comment at definition of _hDevMode
            if (g_fUnicodePlatform)
            {
                if (!_fUsePrinterCopyCollate)
                {
                    // Force template to do its own copies/collation (to prevent both us and the printer from doing so).
                    ((DEVMODEW *)pDevMode)->dmCollate = FALSE;
                    ((DEVMODEW *)pDevMode)->dmCopies = 1;
                }
                else
                {
                    // We might want to check if the hardware supports copy/collation
                    ((DEVMODEW *)pDevMode)->dmFields |= DM_COPIES | DM_COLLATE;
                    ((DEVMODEW *)pDevMode)->dmCollate = _fCollate;
                    ((DEVMODEW *)pDevMode)->dmCopies = _nCopies;
                }

                _hDC =  ::CreateDCW(((TCHAR *)pDevNames) + pDevNames->wDriverOffset,
                                   ((TCHAR *)pDevNames) + pDevNames->wDeviceOffset,
                                   NULL,
                                   (DEVMODEW *) pDevMode);
            }
            else
            {
                LPSTR pchDriver = InitMultiByteFromWideChar(((TCHAR *)pDevNames) + pDevNames->wDriverOffset);
                LPSTR pchDevice = InitMultiByteFromWideChar(((TCHAR *)pDevNames) + pDevNames->wDeviceOffset);

                if (!_fUsePrinterCopyCollate)
                {
                    // Force template to do its own copies/collation (to prevent both us and the printer from doing so).
                    ((DEVMODEA *)pDevMode)->dmCollate = FALSE;
                    ((DEVMODEA *)pDevMode)->dmCopies = 1;
                }
                else
                {
                    // We might want to check if the hardware supports copy/collation
                    ((DEVMODEA *)pDevMode)->dmFields |= DM_COPIES | DM_COLLATE;
                    ((DEVMODEA *)pDevMode)->dmCollate = _fCollate;
                    ((DEVMODEA *)pDevMode)->dmCopies = _nCopies;
                }

                if (pchDriver && pchDevice)
                {
                    _hDC = ::CreateDCA(pchDriver,
                                       pchDevice,
                                       NULL,
                                       (DEVMODEA *)pDevMode);
                }
                if (pchDriver)
                    delete []pchDriver;
                if (pchDevice)
                    delete []pchDevice;
            }
        }
        ::GlobalUnlock(_hDevNames);
        ::GlobalUnlock(_hDevMode);

        if (!_hDC)
        {
            DWORD dwError = GetLastError();
            Assert(!"Failed to create DC!");
            hr = E_FAIL;
            goto Cleanup;
        }
    }

    //
    //  Fill out the DOCINFO structure
    //
    ::ZeroMemory(&docinfo,sizeof(DOCINFO));
    ::ZeroMemory(achTitle,sizeof(TCHAR) * MAX_JOBNAME);
    docinfo.cbSize      = sizeof(DOCINFO);  
    docinfo.fwType      = 0; 
   
    if (bstrTitle)
        _tcsncpy(achTitle, bstrTitle, MAX_JOBNAME - 1);
    docinfo.lpszDocName = achTitle;
    
    if (_achFileName[0])
        docinfo.lpszOutput = _achFileName;

    //
    //  Set up the document so that it can begin accepting pages
    //
    if (::StartDoc(_hDC, &docinfo) > 0)
        *p = VB_TRUE;
#ifdef DBG
    else
    {
        DWORD dwError = GetLastError(); 
        goto Cleanup;
    }
#endif

Cleanup:
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member : (ITemplatePrinter) CTemplatePrinter::endDoc
//
//  Synopsis : 'Finishes' the doc - takes pages printed via printPage and queues the job
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::stopDoc()
{   
    TEMPLATESECURITYCHECK()

    HRESULT hr = S_OK;

    if (!_hDC)
        goto Cleanup;    

    if (::EndDoc(_hDC) <=0)
    {
        DWORD dwError = GetLastError(); 
        Assert(FALSE && "error calling EndDoc API");
        hr = E_FAIL;
        goto Cleanup;
    }

    ::DeleteDC(_hDC);
    _hDC = NULL;

Cleanup:
    return hr;
}

//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get/put framesetDocument
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_framesetDocument(VARIANT_BOOL * p)
{
    return GetFlagSafe(p,_fFramesetDocument);
}
STDMETHODIMP
CTemplatePrinter::put_framesetDocument(VARIANT_BOOL v)
{
    PUTFLAGSAFE(_fFramesetDocument, v);
}

//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get/put printTableOfLinks
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_tableOfLinks(VARIANT_BOOL * p)
{
    return GetFlagSafe(p,_fPrintTableOfLinks);
}
STDMETHODIMP
CTemplatePrinter::put_tableOfLinks(VARIANT_BOOL v)
{
    PUTFLAGSAFE(_fPrintTableOfLinks, v);
}
//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get/put printAllLinkedDocuments
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_allLinkedDocuments(VARIANT_BOOL * p)
{
    return GetFlagSafe(p, _fPrintAllLinkedDocuments);
}
STDMETHODIMP
CTemplatePrinter::put_allLinkedDocuments(VARIANT_BOOL v)
{
    PUTFLAGSAFE(_fPrintAllLinkedDocuments, v);
}

//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get/put printFrameActive
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_frameActive(VARIANT_BOOL * p)
{
    return GetFlagSafe(p,_fFrameActive);
}
STDMETHODIMP
CTemplatePrinter::put_frameActive(VARIANT_BOOL v)
{
    if (!!v)
        _fFrameAsShown = FALSE;
    PUTFLAGSAFE(_fFrameActive, v);
}
//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter2) CTemplatePrinter::get/put printFrameActive
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_frameActiveEnabled(VARIANT_BOOL * p)
{
    return GetFlagSafe(p,_fFrameActiveEnabled);
}
STDMETHODIMP
CTemplatePrinter::put_frameActiveEnabled(VARIANT_BOOL v)
{
    PUTFLAGSAFE(_fFrameActiveEnabled, v);
}
//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get/put printFrameAsShown
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_frameAsShown(VARIANT_BOOL * p)
{
    return GetFlagSafe(p,_fFrameAsShown);
}
STDMETHODIMP
CTemplatePrinter::put_frameAsShown(VARIANT_BOOL v)
{
    if (!!v)
        _fFrameActive = FALSE;
    PUTFLAGSAFE(_fFrameAsShown, v);
}
//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get/put printSelection
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_selection(VARIANT_BOOL * p)
{
    return GetFlagSafe(p,_fPrintSelection);
}
STDMETHODIMP
CTemplatePrinter::put_selection(VARIANT_BOOL v)
{
    PUTFLAGSAFE(_fPrintSelection, v);
}
//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter2) CTemplatePrinter::get/put printSelectionEnabled
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_selectionEnabled(VARIANT_BOOL * p)
{
    return GetFlagSafe(p,_fPrintSelectionEnabled);
}
STDMETHODIMP
CTemplatePrinter::put_selectionEnabled(VARIANT_BOOL v)
{
    PUTFLAGSAFE(_fPrintSelectionEnabled, v);
}
//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get/put printSelectedPages
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_selectedPages(VARIANT_BOOL * p)
{
    return GetFlagSafe(p,_fPrintSelectedPages);
}
STDMETHODIMP
CTemplatePrinter::put_selectedPages(VARIANT_BOOL v)
{
    PUTFLAGSAFE(_fPrintSelectedPages, v);
}
//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get/put printCurrentPage
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_currentPage(VARIANT_BOOL * p)
{
    return GetFlagSafe(p,_fPrintCurrentPage);
}
STDMETHODIMP
CTemplatePrinter::put_currentPage(VARIANT_BOOL v)
{
    PUTFLAGSAFE(_fPrintCurrentPage, v);
}
//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get/put printCurrentPageAvail
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_currentPageAvail(VARIANT_BOOL * p)
{
    return GetFlagSafe(p,_fCurrentPageAvail);
}
STDMETHODIMP
CTemplatePrinter::put_currentPageAvail(VARIANT_BOOL v)
{
    PUTFLAGSAFE(_fCurrentPageAvail, v);
}
//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get/put printCollate
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_collate(VARIANT_BOOL * p)
{
    return GetFlagSafe(p,_fCollate);
}
STDMETHODIMP
CTemplatePrinter::put_collate(VARIANT_BOOL v)
{
    PUTFLAGSAFE(_fCollate, v);
}
//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter2) CTemplatePrinter::get/put usePrinterCopyCollate
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_usePrinterCopyCollate(VARIANT_BOOL * p)
{
    return GetFlagSafe(p,_fUsePrinterCopyCollate);
}
STDMETHODIMP
CTemplatePrinter::put_usePrinterCopyCollate(VARIANT_BOOL v)
{
    PUTFLAGSAFE(_fUsePrinterCopyCollate, v);
}

//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get_duplex
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_duplex(VARIANT_BOOL * p)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;

    if (!p)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *p = VB_FALSE;

    if (_hDevMode)
    {
        void * pDevMode = ::GlobalLock(_hDevMode);
        if (pDevMode)
        {
            // (greglett) Unicode weirdness.  DEVMMODEA on Win9x, DEVMODEW on NT.
            if (    (   g_fUnicodePlatform
                     && (((DEVMODEW *)pDevMode)->dmFields & DM_DUPLEX)
                     && ((DEVMODEW *)pDevMode)->dmDuplex != DMDUP_SIMPLEX )
                ||  (  !g_fUnicodePlatform
                     && (((DEVMODEA *)pDevMode)->dmFields & DM_DUPLEX)
                     && ((DEVMODEA *)pDevMode)->dmDuplex != DMDUP_SIMPLEX ) )
            {
                *p = VB_TRUE;
            }
            ::GlobalUnlock(_hDevMode);
        }
    }

Cleanup:
    return hr;
}

//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get/put copies
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_copies(WORD * p)
{   
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else
        *p = _nCopies;

    return hr;
}
STDMETHODIMP
CTemplatePrinter::put_copies(WORD v)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;

    if (v < 0)
        hr = E_INVALIDARG;
    else
        _nCopies = v;

    ////////////////////////////////////////////////////////////////////
    // a-naande 7-30-02 winse 25090
    // if the DEVMODE struct isn't null, then the value in dmCopies will supersede
    // nCopies in the PRINTDLG struct, so set it to match _nCopies
    if(SUCCEEDED(hr) && _hDevMode)
    {
        void *pDevMode  = ::GlobalLock(_hDevMode);
        if (pDevMode)
        {
            if (g_fUnicodePlatform)
            {
                ((DEVMODEW *)pDevMode)->dmCopies = _nCopies;
            }
            else
            {
                ((DEVMODEA *)pDevMode)->dmCopies = _nCopies;   
            }
            ::GlobalUnlock(_hDevMode);
        }
    }


    return hr;
}
//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get/put pageFrom
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_pageFrom(WORD * p)
{    
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else
        *p = _nPageFrom;

    return hr;
}
STDMETHODIMP
CTemplatePrinter::put_pageFrom(WORD v)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;

    if (v < 0)
        hr = E_INVALIDARG;
    else
        _nPageFrom = v;

    return hr;
}


//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get/put pageTo
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_pageTo(WORD * p)
{    
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else
        *p = _nPageTo;

    return hr;
}
STDMETHODIMP
CTemplatePrinter::put_pageTo(WORD v)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;

    if (v < 0)
        hr = E_INVALIDARG;
    else
        _nPageTo = v;

    return hr;
}

//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get/put marginLeft/Right/Top/Bottom
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_marginLeft(long * p)
{    
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else
        *p = (_rcMargin.left / 1000);

    return hr;
}
STDMETHODIMP
CTemplatePrinter::put_marginLeft(long v)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;

    if (v < 0)
        hr = E_INVALIDARG;
    else
        _rcMargin.left = v * 1000;

    return hr;
}
STDMETHODIMP
CTemplatePrinter::get_marginRight(long * p)
{   
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else
        *p = (_rcMargin.right / 1000);

    return hr;
}
STDMETHODIMP
CTemplatePrinter::put_marginRight(long v)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;

    if (v < 0)
        hr = E_INVALIDARG;
    else
        _rcMargin.right = v * 1000;

    return hr;
}
STDMETHODIMP
CTemplatePrinter::get_marginTop(long * p)
{    
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else
        //  Input in 1/100 inches.
        *p = (_rcMargin.top / 1000);

    return hr;
}
STDMETHODIMP
CTemplatePrinter::put_marginTop(long v)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;

    if (v < 0)
        hr = E_INVALIDARG;
    else
        //  Output in 1/100 inches.
        _rcMargin.top = v * 1000;

    return hr;
}
STDMETHODIMP
CTemplatePrinter::get_marginBottom(long * p)
{    
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else
        //  Input in 1/100 inches.
        *p = (_rcMargin.bottom / 1000);

    return hr;
}
STDMETHODIMP
CTemplatePrinter::put_marginBottom(long v)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    
    if (v < 0)
        hr = E_INVALIDARG;
    else
        //  Output in 1/100 inches.
        _rcMargin.bottom = v * 1000;

    return hr;
}

//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get pageWidth/Height
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_pageWidth(long * p)
{   
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else
        //  Output in 1/100 inches.
        *p = _ptPaperSize.x / 10;

    return hr;
}
STDMETHODIMP
CTemplatePrinter::get_pageHeight(long * p)
{    
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else
        //  Output in 1/100 inches.
        *p = _ptPaperSize.y / 10;

    return hr;
}

//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter2) CTemplatePrinter::get/put orientation
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_orientation(BSTR * p)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    
    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *p = NULL;
    
    if (GetOrientation() == DMORIENT_LANDSCAPE)
        *p = SysAllocString(ORIENTLANDSCAPE);
    else
        *p = SysAllocString(ORIENTPORTRAIT);

    if (!p)
        hr = E_OUTOFMEMORY;

Cleanup:    
    return hr;
}

STDMETHODIMP
CTemplatePrinter::put_orientation(BSTR v)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;

    if (!v)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (_tcsicmp(v, ORIENTPORTRAIT) == 0)
        SetOrientation(DMORIENT_PORTRAIT);
    else if (_tcsicmp(v, ORIENTLANDSCAPE) == 0)
        SetOrientation(DMORIENT_LANDSCAPE);
    else
        hr = E_INVALIDARG;

Cleanup:    
    return hr;
}

//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get unprintableLeft/Top/Right/Bottom
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_unprintableLeft(long * p)
{    
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else if (_szResolution.cx == 0)
        *p = 0;
    else
        //  Output should be in 1/100 inches, not printer pixels.
        *p = MulDivQuick(_rcUnprintable.left, 100, _szResolution.cx);

    return hr;
}
STDMETHODIMP
CTemplatePrinter::get_unprintableTop(long * p)
{    
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;

    if (!p)
        hr = E_POINTER;
    else if (_szResolution.cy == 0)
        *p = 0;
    else
        //  Output should be in 1/100 inches, not printer pixels.
        *p = MulDivQuick(_rcUnprintable.top, 100, _szResolution.cy);

    return hr;
}
STDMETHODIMP
CTemplatePrinter::get_unprintableRight(long * p)
{    
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else if (_szResolution.cx == 0)
        *p = 0;
    else
        //  Output should be in 1/100 inches, not printer pixels.
        *p = MulDivQuick(_rcUnprintable.right, 100, _szResolution.cx);

    return hr;
}
STDMETHODIMP
CTemplatePrinter::get_unprintableBottom(long * p)
{    
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else if (_szResolution.cy == 0)
        *p = 0;
    else
        //  Output should be in 1/100 inches, not printer pixels.
        *p = MulDivQuick(_rcUnprintable.bottom, 100, _szResolution.cy);

    return hr;
}
//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get/put header
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_header(BSTR * p)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else
    {
        *p = SysAllocString(_achHeader);
        if (!p)
            hr = E_OUTOFMEMORY;
    }

    return hr;
}
STDMETHODIMP
CTemplatePrinter::put_header(BSTR v)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    TCHAR   *achTemp;

    achTemp = v;    
    if (! (_tcslen(achTemp) <= ARRAY_SIZE(_achHeader) - 1))
        hr = E_INVALIDARG;
    else
    {
        _fPersistHFToRegistry = FALSE;
        _tcscpy(_achHeader, achTemp);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get/put footer
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_footer(BSTR * p)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else
    {
        *p = SysAllocString(_achFooter);
        if (!p)
            hr = E_OUTOFMEMORY;
    }
    
    return hr;
}
STDMETHODIMP
CTemplatePrinter::put_footer(BSTR v)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    TCHAR   *achTemp;

    achTemp = v;
    if (! (_tcslen(achTemp) <= ARRAY_SIZE(_achFooter) - 1))
        hr = E_INVALIDARG;
    else
    {
        _fPersistHFToRegistry = FALSE;
        _tcscpy(_achFooter, achTemp);
    }
    
    return hr;
}

//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter2) CTemplatePrinter::deviceSupports
//
//  Takes a BSTR indicating which property to query (supported values in the
//  defined above).
//  Returns information about that property.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::deviceSupports(BSTR bstrProperty, VARIANT * pvar)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT   hr        = S_OK;
    void     *pDevMode  = NULL;
    DEVNAMES *pDevNames = NULL;
    TCHAR    *achDevice = NULL;
    TCHAR    *achPort   = NULL;
    int i;

    if (!pvar)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    VariantInit(pvar);

    pDevMode = ::GlobalLock(_hDevMode);
    pDevNames = ((DEVNAMES *) ::GlobalLock(_hDevNames));
    if (!pDevMode || !pDevNames)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    for (i = 0;
        (i < DEVCAP_LAST) && (_tcsicmp(bstrProperty, s_aachDeviceCapabilities[i]) != 0);
        i++);

    if (i >= DEVCAP_LAST)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    achDevice = ((TCHAR *)pDevNames) + (pDevNames->wDeviceOffset);
    achPort = ((TCHAR *)pDevNames) + (pDevNames->wOutputOffset);    
    switch (i)
    {
    case DEVCAP_COPIES:
        V_VT(pvar) = VT_INT;
        V_INT(pvar) = ::DeviceCapabilities(achDevice, achPort, DC_COPIES, NULL, NULL);
        break;
    case DEVCAP_COLLATE:
        V_VT(pvar) = VT_BOOL;
        V_BOOL(pvar) = (::DeviceCapabilities(achDevice, achPort, DC_COLLATE, NULL, NULL) != 0) ? VB_TRUE : VB_FALSE;
        break;
    case DEVCAP_DUPLEX:
        V_VT(pvar) = VT_BOOL;
        V_BOOL(pvar) = (::DeviceCapabilities(achDevice, achPort, DC_DUPLEX, NULL, NULL) != 0) ? VB_TRUE : VB_FALSE;
        break;
#if DBG==1
    case DEVCAP_DBG_PRINTERNAME:
        V_BSTR(pvar) = ::SysAllocString(achDevice);
        if (V_BSTR(pvar))
            V_VT(pvar) = VT_BSTR;
        else
            hr = E_OUTOFMEMORY;
        break;
#endif
    default:
        Assert(FALSE && "Unrecognized DEVCAP_ value.");
        break;
    }


Cleanup:    
    if (pDevNames)
        ::GlobalUnlock(_hDevNames);
    if (pDevMode)
        ::GlobalUnlock(_hDevMode);
    return hr;
}

STDMETHODIMP
CTemplatePrinter::updatePageStatus(long * p)
{    
    TEMPLATESECURITYCHECK();
    
    VARIANT              varHost;
    HRESULT              hr      = S_OK;
    IOleCommandTarget   *pioct   = NULL;
    const GUID          *pguid   = NULL;
    DWORD                nCmdId  = 0;

    VariantInit(&varHost);

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }     

    if (    GetDialogArgument(&varHost, PRINTARG_BROWSEDOC) == S_OK
         && V_VT(&varHost) == VT_UNKNOWN
         && V_UNKNOWN(&varHost) )
    {
        VARIANT varIn;
        V_VT(&varIn) = VT_I4;
        V_I4(&varIn) = (*p > 0) ? (*p) : 0;

        hr = V_UNKNOWN(&varHost)->QueryInterface(IID_IOleCommandTarget, (void **)&pioct);
        if (hr)
            goto Cleanup;
        Assert(pioct);

        hr = pioct->Exec(&CGID_MSHTML, IDM_UPDATEPAGESTATUS, 0, &varIn, 0);

        hr = S_OK;      // If the host isn't listening, we'll get an OLE error.  Don't throw it to script!
    }

Cleanup:
    ReleaseInterface(pioct);
    VariantClear(&varHost);
    return hr;
}

//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::printNonNative
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::printNonNative(IUnknown* pDoc, VARIANT_BOOL *p)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT             hr              = S_OK;
    IOleCommandTarget  *pioct           = NULL;
    IPrint             *pIPrint         = NULL;
    VARIANT             varOut;
    VARIANT             varIn;

    VariantInit(&varOut);

    if (!pDoc || !p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *p = VB_FALSE;

    hr = pDoc->QueryInterface(IID_IOleCommandTarget, (void **)&pioct);
    if (hr)
        goto Cleanup;
    Assert(pioct);

    V_VT(&varIn) = VT_I4;
    V_I4(&varIn) = IPRINT_DOCUMENT;
    hr = pioct->Exec( &CGID_MSHTML,
                      IDM_GETIPRINT,
                      NULL, 
                      &varIn, 
                      &varOut);

    if (    hr
        ||  V_VT(&varOut) != VT_UNKNOWN
        ||  !V_UNKNOWN(&varOut))
        goto Cleanup;

    // We don't get back an IPrint collection unless it has at least one member.
    // At this point, we can claim that we should be printing, and a template does not need to.
    *p = VB_TRUE;

    hr = PrintIPrintCollection(&varOut);    

Cleanup:
    VariantClear(&varOut);
    ReleaseInterface(pioct);

    return hr;
}

STDMETHODIMP
CTemplatePrinter::printNonNativeFrames(IUnknown *pMarkup, VARIANT_BOOL fActiveFrame)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT              hr              = S_OK;
    IOleCommandTarget   *pioct           = NULL;
    VARIANT             varOut;
    VARIANT             varIn;
    VARIANT             varBrowseDoc;

    if (!pMarkup)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    VariantInit(&varOut);
    VariantInit(&varIn);
    VariantInit(&varBrowseDoc);

    // Use the browse document if one exists - it will have the WebOC frame.
    // NB (greglett)
    // This assumes that the reference we are passed to the browse doc
    // stays good - including nested frames &c... on the browse doc while the WebOC is still
    // loaded & (if it was selected) active.
    // Yes, this may exhibit unexpected behavior if the user Prints and navigates away.
    // A better solution would be appreciated.
    if (    GetDialogArgument(&varBrowseDoc, PRINTARG_BROWSEDOC) == S_OK
        &&  V_VT(&varBrowseDoc) == VT_UNKNOWN
        &&  V_UNKNOWN(&varBrowseDoc) )
    {
        hr = V_UNKNOWN(&varBrowseDoc)->QueryInterface(IID_IOleCommandTarget, (void **)&pioct);
    }

    // Otherwise, use the content document
    if (!pioct)
    {
        hr = pMarkup->QueryInterface(IID_IOleCommandTarget, (void **)&pioct);
        if (hr)
            goto Cleanup;
    }

    Assert(pioct);

    V_VT(&varIn) = VT_I4;
    V_I4(&varIn) = fActiveFrame ? IPRINT_ACTIVEFRAME : IPRINT_ALLFRAMES;
    hr = pioct->Exec( &CGID_MSHTML,
                      IDM_GETIPRINT,
                      NULL, 
                      &varIn, 
                      &varOut);

    if (    hr
        ||  V_VT(&varOut) != VT_UNKNOWN
        ||  !V_UNKNOWN(&varOut))
        goto Cleanup;

    hr = PrintIPrintCollection(&varOut);

Cleanup:
    VariantClear(&varOut);
    VariantClear(&varBrowseDoc);
    ReleaseInterface(pioct);

    return hr;
}   

HRESULT
CTemplatePrinter::PrintIPrintCollection(VARIANT * pvarIPrintAry)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT             hr             = S_OK;
    IDispatch *         pIPrintAry     = NULL;
    IPrint *            pIPrint        = NULL;
    VARIANT             varInvokeOut;
    VARIANT             varInvokeParam;
    DISPPARAMS          DispParams;
    DVTARGETDEVICE *    pTargetDevice   = NULL;
    PAGESET *           pPageSet        = NULL;
    long                cIPrint, i;
    long                lFirstPage, lPages, lLastPage;

    Assert(V_VT(pvarIPrintAry) == VT_UNKNOWN);
    Assert(V_UNKNOWN(pvarIPrintAry));

    VariantInit(&varInvokeOut);
    VariantInit(&varInvokeParam);

    hr = V_UNKNOWN(pvarIPrintAry)->QueryInterface(IID_IDispatch, (void **)&pIPrintAry);
    if (hr)
        goto Cleanup;
    Assert(pIPrintAry);

    DispParams.cNamedArgs           = 0;
    DispParams.rgdispidNamedArgs    = NULL;
    DispParams.cArgs                = 0;
    DispParams.rgvarg               = NULL;
    hr = pIPrintAry->Invoke(DISPID_IHTMLIPRINTCOLLECTION_LENGTH,
                            IID_NULL,
                            LOCALE_USER_DEFAULT,
                            DISPATCH_PROPERTYGET,
                            &DispParams,
                            &varInvokeOut,
                            NULL, NULL);
    if (    hr
        ||  V_VT(&varInvokeOut) != VT_I4
        ||  V_I4(&varInvokeOut) <= 0      )
        goto Cleanup;
    
    cIPrint = V_I4(&varInvokeOut);
    VariantClear(&varInvokeOut);

    hr = CreateIPrintParams(&pTargetDevice, &pPageSet);
    if (hr)
        goto Cleanup;

    lFirstPage = pPageSet->rgPages[0].nFromPage;        
    lLastPage  = pPageSet->rgPages[0].nToPage;

    DispParams.cArgs        = 1;
    DispParams.rgvarg       = &varInvokeParam;
    V_VT(&varInvokeParam)   = VT_I4;
    for (i = 0; i < cIPrint; i++)
    {
        V_I4(&varInvokeParam) = i;
        hr = pIPrintAry->Invoke(DISPID_IHTMLIPRINTCOLLECTION_ITEM,
                                IID_NULL,
                                LOCALE_USER_DEFAULT,
                                DISPATCH_METHOD,
                                &DispParams,
                                &varInvokeOut,
                                NULL, NULL);
        if (    hr
            ||  V_VT(&varInvokeOut) != VT_UNKNOWN
            ||  !V_UNKNOWN(&varInvokeOut))
        {
            VariantClear(&varInvokeOut);
            continue;
        }

        hr = V_UNKNOWN(&varInvokeOut)->QueryInterface(IID_IPrint, (void **)&pIPrint);
        VariantClear(&varInvokeOut);
        if (hr)
            continue;
        Assert(pIPrint);

        hr = pIPrint->Print(
                 PRINTFLAG_MAYBOTHERUSER,
                 &pTargetDevice,
                 &pPageSet,
                 NULL,
                 NULL,
                 lFirstPage,
                 &lPages,        // out
                 &lLastPage      // out
                 );

        ReleaseInterface(pIPrint);
        pIPrint = NULL;
    }
    
    hr = S_OK;


Cleanup:    
    if (pTargetDevice)
        ::CoTaskMemFree(pTargetDevice);
    if (pPageSet)
        ::CoTaskMemFree(pPageSet);

    ReleaseInterface(pIPrintAry);
    return hr;
}

//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::showPrintDialog, ensurePrintDialogDefaults
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::ensurePrintDialogDefaults(VARIANT_BOOL *p)
{   
    TEMPLATESECURITYCHECK();
    
    if (!p)
        return E_POINTER;

    // If we already have default printer information, use it.
    if (_hDevNames && _hDevMode)
        *p = VB_TRUE;

    // Otherwise, go get it.        
    else
        GetPrintDialogSettings(FALSE, p);

    return S_OK;
}
STDMETHODIMP
CTemplatePrinter::showPrintDialog(VARIANT_BOOL *p)
{   
    TEMPLATESECURITYCHECK();
    
    if (!p)
        return E_POINTER;

    GetPrintDialogSettings(TRUE, p);

    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::showPageSetupDialog
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::showPageSetupDialog(VARIANT_BOOL *p)
{   
    TEMPLATESECURITYCHECK();
    
    HRESULT             hr;
    HWND                hWnd;
    BOOL                fMetricUnits        = FALSE;
    IHTMLEventObj2      *pEvent             = NULL;     //  To populate with dialog parameters
    IDocHostUIHandler   *pUIHandler         = NULL;
    IOleCommandTarget   *pUICommandHandler  = NULL;
    HGLOBAL             hPageSetup          = NULL;
    PAGESETUPDLG *      ppagesetupdlg       = NULL;
    VARIANT             varIn;  

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *p = VB_FALSE;

    if (_hDC)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hPageSetup = ::GlobalAlloc(GHND, sizeof(PAGESETUPDLG));
    if (!hPageSetup)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    ppagesetupdlg = (PAGESETUPDLG *)::GlobalLock(hPageSetup);
    if (!ppagesetupdlg)
    {   
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = InitDialog(&hWnd, &pEvent, &pUICommandHandler);
    if (hr)
        goto Cleanup;

    {
        //  Are we using metric or British (US) for margins?
        TCHAR           achLocale[32];
        int             iLocale = 32;
        fMetricUnits = (    GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_IMEASURE, achLocale, iLocale)
                        &&  achLocale[0] == TCHAR('0'));
    }

    //  Now, initialize the event's type and expandos.
    {
        BSTR bstrTemp = SysAllocString( L"pagesetup" );
        VARIANT var;

        if (bstrTemp)
        {
            pEvent->put_type( bstrTemp );
            SysFreeString(bstrTemp);
        }

        V_VT(&var) = VT_PTR;
        V_BYREF(&var) = ppagesetupdlg;
        hr = pEvent->setAttribute(_T("pagesetupStruct"), var, 0);
        if (hr)
            goto Cleanup;

        V_VT(&var)   = VT_BSTR;        
        bstrTemp = SysAllocString(_achHeader);
        if (bstrTemp)
        {
            V_BSTR(&var) = bstrTemp;
            hr = pEvent->setAttribute(_T("pagesetupHeader"), var, 0);
            SysFreeString(bstrTemp);
        }

        bstrTemp = SysAllocString(_achFooter);
        if (bstrTemp)
        {
            V_BSTR(&var) = bstrTemp;
            hr = pEvent->setAttribute(_T("pagesetupFooter"), var, 0);
            SysFreeString(bstrTemp);
        }
    }

    // Fill out PAGESETUPDLG structure    
    ::ZeroMemory(ppagesetupdlg, sizeof(PAGESETUPDLG));
    ppagesetupdlg->lStructSize    = sizeof(PAGESETUPDLG);
    ppagesetupdlg->hwndOwner      = hWnd;
    ppagesetupdlg->hDevMode       = _hDevMode;
    ppagesetupdlg->hDevNames      = _hDevNames;   
    ppagesetupdlg->Flags          |= PSD_DEFAULTMINMARGINS;    

    if (_ptPaperSize.x != -1)
    {
        ppagesetupdlg->ptPaperSize = _ptPaperSize;
    }
    if (_rcMargin.left != -1)
    {
        ppagesetupdlg->Flags |= PSD_MARGINS;
        ppagesetupdlg->rtMargin = _rcMargin;

        if (fMetricUnits)
        {
            // Margins from PrintInfoBag are in 1/100000" and need to be converted to 1/100 mm.
            ppagesetupdlg->rtMargin.left   = MulDivQuick(ppagesetupdlg->rtMargin.left  , 2540, 100000);
            ppagesetupdlg->rtMargin.right  = MulDivQuick(ppagesetupdlg->rtMargin.right , 2540, 100000);
            ppagesetupdlg->rtMargin.top    = MulDivQuick(ppagesetupdlg->rtMargin.top   , 2540, 100000);
            ppagesetupdlg->rtMargin.bottom = MulDivQuick(ppagesetupdlg->rtMargin.bottom, 2540, 100000);
        }
        else
        {
            // Margins from PrintInfoBag are in 1/100000" and need to be converted to 1/1000".
            ppagesetupdlg->rtMargin.left   = ppagesetupdlg->rtMargin.left   / 100;
            ppagesetupdlg->rtMargin.right  = ppagesetupdlg->rtMargin.right  / 100; 
            ppagesetupdlg->rtMargin.top    = ppagesetupdlg->rtMargin.top    / 100;
            ppagesetupdlg->rtMargin.bottom = ppagesetupdlg->rtMargin.bottom / 100;
        }
    }
  
    CommCtrlNativeFontSupport();

    V_VT(&varIn) = VT_UNKNOWN;
    V_UNKNOWN(&varIn) = pEvent;     

    // Query host to show dialog
    if (pUICommandHandler)
    {        
        // We may be marshalling this call across threads.  RPC doesn't allow VT_PTRs to cross threads.
        // We work around this by sticking the structure into a GHND contents and pass the VT_HANDLE.
        // We then delegate to the browse document, who will obtain a copy of the GHND pointer and use that for the VT_PTR
        // the struct. (CDoc::DelegateShowPrintingDialog)
        //
        // In theory, we could detect this by looking at the __IE_uPrintFlags to see if it is flagged synchronous to avoid playing with handles.
        // The downside: as with all dialogArguments, anyone could have mucked around with the flags)
        VARIANT var;
        V_VT(&var) = VT_HANDLE;
        V_BYREF(&var) = hPageSetup;
        pEvent->setAttribute(_T("hPageSetup"), var, 0);

        // Delegate call to browse Trident
        hr = pUICommandHandler->Exec(
                NULL,                       // For Trident
                OLECMDID_SHOWPAGESETUP,
                0,
                &varIn,
                NULL);               

        pEvent->removeAttribute(_T("hPageSetup"), 0, NULL);
    }

    if (   !pUICommandHandler
        ||  hr == OLECMDERR_E_NOTSUPPORTED 
        ||  hr == OLECMDERR_E_UNKNOWNGROUP
        ||  hr == E_FAIL
        ||  hr == E_NOTIMPL )
    {      
        ClearInterface(&pUICommandHandler);

        // Create backup UI Handler
        // (greglett) Cache this - CoCreate is expensive.
        hr = CoCreateInstance(CLSID_DocHostUIHandler,
              NULL,
              CLSCTX_INPROC_SERVER,
              IID_IDocHostUIHandler,
              (void**)&pUIHandler);
        if (!pUIHandler)
            goto Cleanup;

        hr = pUIHandler->QueryInterface(IID_IOleCommandTarget,(void**)&pUICommandHandler);        
        if (!pUICommandHandler)
            goto Cleanup;
        
        hr = pUICommandHandler->Exec(
                &CGID_DocHostCommandHandler,        // For a dochost object
                OLECMDID_SHOWPAGESETUP,
                0,
                &varIn,
                NULL);
    }

    //  If the dialog was cancelled, or there was a problem showing the dialog,

    //  do not update values.
    if (hr)
        goto Cleanup;

    *p = VB_TRUE;       //  OK was pressed.
    
    //
    //  Retrieve page setup changes from the page setup dialog structure.
    //
    _hDevMode       = ppagesetupdlg->hDevMode;
    _hDevNames      = ppagesetupdlg->hDevNames;    
    GetDeviceProperties();

    if (fMetricUnits)
    {
        // Margins from Page Setup dialog are in 1/100 mm and need to be converted to 1/100000"
        _rcMargin.left   = MulDivQuick(ppagesetupdlg->rtMargin.left  , 100000, 2540);
        _rcMargin.right  = MulDivQuick(ppagesetupdlg->rtMargin.right , 100000, 2540);
        _rcMargin.top    = MulDivQuick(ppagesetupdlg->rtMargin.top   , 100000, 2540);
        _rcMargin.bottom = MulDivQuick(ppagesetupdlg->rtMargin.bottom, 100000, 2540);
    }
    else
    {
        // Margins from Page Setup dialog are in 1/1000" and need to be converted to 1/100000"
        _rcMargin.left   = ppagesetupdlg->rtMargin.left   * 100;
        _rcMargin.right  = ppagesetupdlg->rtMargin.right  * 100;
        _rcMargin.top    = ppagesetupdlg->rtMargin.top    * 100;
        _rcMargin.bottom = ppagesetupdlg->rtMargin.bottom * 100;
    }

    // (greglett)  99% of OS's use PSD_DEFAULTMINMARGINS to restrict the margins to the printable page area.    
    // NT4SP6 without the IE shell extensions doesn't.  So, we are forced to do more work for yet another violation of the API documentation.
    // Force margins to be at least as large as the unprintable region.
    // Do we want also to display an error message if they are different? (Otherwise, we change it, and the user doesn't see it.)
    if (_rcMargin.left < MulDivQuick(_rcUnprintable.left, 100000, _szResolution.cx))
        _rcMargin.left = MulDivQuick(_rcUnprintable.left, 100000, _szResolution.cx);
    if (_rcMargin.right < MulDivQuick(_rcUnprintable.right, 100000, _szResolution.cx))
        _rcMargin.right = MulDivQuick(_rcUnprintable.right, 100000, _szResolution.cx);
    if (_rcMargin.top < MulDivQuick(_rcUnprintable.top, 100000, _szResolution.cy))
        _rcMargin.top = MulDivQuick(_rcUnprintable.top, 100000, _szResolution.cy);
    if (_rcMargin.bottom < MulDivQuick(_rcUnprintable.bottom, 100000, _szResolution.cy))
        _rcMargin.bottom = MulDivQuick(_rcUnprintable.bottom, 100000, _szResolution.cy);

    //
    //  Read in Trident specific values from the page setup dialog
    //
    {
        VARIANT var;
        TCHAR   *pchTemp;

        if (    !pEvent->getAttribute(_T("pagesetupHeader"),0,&var)
            &&  var.vt == VT_BSTR
            &&  var.bstrVal)
        {
            pchTemp = var.bstrVal;
            _tcscpy(_achHeader, pchTemp);
            SysFreeString(var.bstrVal);
        }
        else
            _achHeader[0] = _T('\0');
        
        if (    !pEvent->getAttribute(_T("pagesetupFooter"),0,&var)
            &&  var.vt == VT_BSTR
            &&  var.bstrVal)

        {
            pchTemp = var.bstrVal;
            _tcscpy(_achFooter, pchTemp);
            SysFreeString(var.bstrVal);
        }
        else
            _achFooter[0] = _T('\0');
    }

    //
    //  Persist results of the page setup dialog out to the registry.
    //
    {                
        HKEY    keyPageSetup = NULL;
        if (GetRegPrintOptionsKey(PRINTOPTSUBKEY_PAGESETUP,&keyPageSetup) == ERROR_SUCCESS)
        {
            if (_fPersistHFToRegistry)
            {
                WriteHeaderFooterToRegistry(keyPageSetup);
            }
            WriteMarginsToRegistry(keyPageSetup);            
            RegCloseKey(keyPageSetup);
        }
    }

Cleanup:
    ReleaseInterface(pEvent);
    ReleaseInterface(pUIHandler);
    ReleaseInterface(pUICommandHandler);
    if (hPageSetup)
    {
        if (ppagesetupdlg)
            ::GlobalUnlock(hPageSetup);
        ::GlobalFree(hPageSetup);
    }
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member : CTemplatePrinter::GetPrintDialogSettings
//
//  Synopsis : 'Finishes' the doc - takes pages printed via printPage and queues the job
//
//-----------------------------------------------------------------------------
HRESULT
CTemplatePrinter::GetPrintDialogSettings(BOOL fBotherUser, VARIANT_BOOL *pvarfOKOrCancel)
{
    HRESULT             hr;
    HWND                hWnd                = NULL;
    IHTMLEventObj2      *pEvent             = NULL;     //  To populate with dialog parameters
    IDocHostUIHandler   *pUIHandler         = NULL;
    IOleCommandTarget   *pUICommandHandler  = NULL;
    HGLOBAL             hPrint              = NULL;
    PRINTDLG *          pprintdlg           = NULL;
    VARIANT             varIn;              
    int                 nFontSize;
    void                *pDevMode           = NULL;

    if (pvarfOKOrCancel)
        *pvarfOKOrCancel = VB_FALSE;

    hPrint = ::GlobalAlloc(GHND, sizeof(PRINTDLG));
    if (!hPrint)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pprintdlg = (PRINTDLG *)::GlobalLock(hPrint);
    if (!pprintdlg)
    {   
        hr = E_FAIL;
        goto Cleanup;
    }

    if (_hDC)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = InitDialog(&hWnd, &pEvent, &pUICommandHandler, &nFontSize);
    if (hr)
        goto Cleanup;

    // PrintDlgEx (only available NT5+) fails with a NULL HWND.
    // It is likely that the DHUI that raises the dialog will use PrintDlgEx (our default DHUI in shdocvw does).
    if (    g_dwPlatformID == VER_PLATFORM_WIN32_NT
        &&  hWnd == NULL )
        hWnd = GetDesktopWindow();
   
    // PrintDlgEx (only available NT5+) fails with a NULL HWND.
    // It is likely that the DHUI that raises the dialog will use PrintDlgEx (our default DHUI in shdocvw does).
    if (    g_dwPlatformID == VER_PLATFORM_WIN32_NT
        &&  hWnd == NULL )
        hWnd = GetDesktopWindow();

    //  Now, initialize the event's type and expandos.
    {
        BSTR bstrTemp = SysAllocString( L"print" );
        VARIANT var;

        if (bstrTemp)
        {
            pEvent->put_type(bstrTemp);
            SysFreeString(bstrTemp);
        }
               
        V_VT(&var)   = VT_BOOL;
        V_BOOL(&var) = AreRatingsEnabled() ? VB_TRUE : VB_FALSE;
        hr = pEvent->setAttribute(_T("printfAreRatingsEnabled"), var, 0);
        if (hr)
            goto Cleanup;

        V_BOOL(&var) = _fFramesetDocument ? VB_TRUE : VB_FALSE;
        hr = pEvent->setAttribute(_T("printfRootDocumentHasFrameset"), var, 0);
        if (hr)
            goto Cleanup;

        V_BOOL(&var) = _fFrameActive ? VB_TRUE : VB_FALSE;
        hr = pEvent->setAttribute(_T("printfActiveFrame"), var, 0);
        if (hr)
            goto Cleanup;

        V_BOOL(&var) = _fFrameActiveEnabled ? VB_TRUE : VB_FALSE;
        hr = pEvent->setAttribute(_T("printfActiveFrameEnabled"), var, 0);
        if (hr)
            goto Cleanup;

        V_BOOL(&var) = _fFrameAsShown ? VB_TRUE : VB_FALSE;
        hr = pEvent->setAttribute(_T("printfAsShown"), var, 0);
        if (hr)
            goto Cleanup;

        V_BOOL(&var) = _fPrintAllLinkedDocuments ? VB_TRUE : VB_FALSE;
        hr = pEvent->setAttribute(_T("printfLinked"), var, 0);
        if (hr)
            goto Cleanup;

        V_BOOL(&var) = _fPrintSelectionEnabled ? VB_TRUE : VB_FALSE;
        hr = pEvent->setAttribute(_T("printfSelection"), var, 0);
        if (hr)
            goto Cleanup;

        V_BOOL(&var) = _fPrintTableOfLinks ? VB_TRUE : VB_FALSE;
        hr = pEvent->setAttribute(_T("printfShortcutTable"), var, 0);
        if (hr)
            goto Cleanup;

        V_BOOL(&var) = VB_FALSE;
        hr = pEvent->setAttribute(_T("printToFileOk"),var, 0);
        if (hr)
            goto Cleanup;

        V_VT(&var)  = VT_INT;
        V_INT(&var) = nFontSize;
        hr = pEvent->setAttribute(_T("printiFontScaling"), var, 0);
        if (hr)
            goto Cleanup;

        V_VT(&var)    = VT_PTR;
        V_BYREF(&var) = pprintdlg;
        hr = pEvent->setAttribute(_T("printStruct"), var, 0);
        if (hr)
            goto Cleanup;

        V_VT(&var)      = VT_UNKNOWN;
        V_UNKNOWN(&var) = NULL;
        hr = pEvent->setAttribute(_T("printpBodyActiveTarget"), var, 0);
        if (hr)
            goto Cleanup;

        V_VT(&var)   = VT_BSTR;        
        bstrTemp = SysAllocString(_achFileName);
        if (bstrTemp)
        {
            V_BSTR(&var) = bstrTemp;
            hr = pEvent->setAttribute(_T("printToFileName"), var, 0);
            SysFreeString(bstrTemp);
        }
    }
           
    //
    // Initialize the PRINTDLG structure
    //
    ::ZeroMemory(pprintdlg, sizeof(PRINTDLG));
    pprintdlg->lStructSize        = sizeof(PRINTDLG);
    pprintdlg->hwndOwner          = hWnd;       
    pprintdlg->hDevMode           = _hDevMode;
    pprintdlg->hDevNames          = _hDevNames;
    pprintdlg->nCopies            = _nCopies;
    pprintdlg->nFromPage          = _nPageFrom;
    pprintdlg->nToPage            = _nPageTo;
    pprintdlg->nMinPage           = 1;
    pprintdlg->nMaxPage           = 0xffff;
    pprintdlg->Flags              |= (_fPrintSelectionEnabled ? 0 : PD_NOSELECTION);
    pprintdlg->Flags              |= (_fCollate ? PD_COLLATE : 0);
    pprintdlg->Flags              |= (_fPrintSelectedPages ? PD_PAGENUMS : 0);
    pprintdlg->Flags              |= (_fPrintToFile ? PD_PRINTTOFILE : 0);
    pprintdlg->Flags              |= (_fCurrentPageAvail ? (_fPrintCurrentPage ? PD_CURRENTPAGE : 0) : PD_NOCURRENTPAGE);

    if (!fBotherUser)
    {
        // this indicates we only want to retrieve the defaults,
        // not to bring up the dialog
        pprintdlg->hDevMode     = NULL;
        pprintdlg->hDevNames    = NULL;
        pprintdlg->Flags        |= PD_RETURNDEFAULT;
    }

    CommCtrlNativeFontSupport();
    V_VT(&varIn) = VT_UNKNOWN;
    V_UNKNOWN(&varIn) = pEvent;

    // Query host to show dialog
    hr = E_FAIL;
    if (    pvarfOKOrCancel         // Don't delegate on the ::Init call.  Only delegate script calls.
        &&  pUICommandHandler)
    {        
        // We may be marshalling this call across threads.  RPC doesn't allow VT_PTRs to cross threads.
        // We work around this by sticking the structure into a GHND contents and pass the VT_HANDLE.
        // We then delegate to the browse document, who will obtain a copy of the GHND pointer and use that for the VT_PTR
        // the struct. (CDoc::DelegateShowPrintingDialog)
        //
        // In theory, we could detect this by looking at the __IE_uPrintFlags to see if it is flagged synchronous to avoid playing with handles.
        // The downside: as with all dialogArguments, anyone could have mucked around with the flags)
        VARIANT var;
        V_VT(&var) = VT_HANDLE;
        V_BYREF(&var) = hPrint;
        pEvent->setAttribute(_T("hPrint"), var, 0);

        // Delegate call to browse Trident
        hr = pUICommandHandler->Exec(
                NULL,                       // For Trident
                OLECMDID_SHOWPRINT,
                0,
                &varIn,
                NULL);               

        pEvent->removeAttribute(_T("hPrint"), 0, NULL);
    }

    if (    hr == OLECMDERR_E_NOTSUPPORTED 
        ||  hr == OLECMDERR_E_UNKNOWNGROUP
        ||  hr == E_FAIL
        ||  hr == E_NOTIMPL )
    {
        ClearInterface(&pUICommandHandler);

        // Create backup UI Handler
        // (greglett) Cache this - CoCreate is expensive.
        hr = CoCreateInstance(CLSID_DocHostUIHandler,
              NULL,
              CLSCTX_INPROC_SERVER,
              IID_IDocHostUIHandler,
              (void**)&pUIHandler);
        if (!pUIHandler)
            goto Cleanup;

        hr = pUIHandler->QueryInterface(IID_IOleCommandTarget,(void**)&pUICommandHandler);        
        if (!pUICommandHandler)
            goto Cleanup;

        hr = pUICommandHandler->Exec(
                &CGID_DocHostCommandHandler,
                OLECMDID_SHOWPRINT,
                0,
                &varIn,
                NULL);

    }
      

    //  If the dialog was cancelled, or there was a problem showing the dialog,
    //  do not update values.
    if (FAILED(hr))
        goto Cleanup;

    // this can be false because either init failed for no installed printer
    //  or the user clicked cancel.
    if (hr==S_FALSE)
    {
        // Three cases:
        //   fBotherUser   *pvarfOkOrCancel
        //        1               1			fBotherUser && varfOkOrCancel  - We are being called from script.  We tried to raise a dialog, and
        //                                  failed or were cancelled - UI has been displayed in the former case.
        //        0               1         We are being called from script.  We tried to get default printer info
        //                                  and failed - this is probably because no default it set.  As we used
        //                                  to, we need to raise the dialog (despite the fBotherUser) to get enough info.
        //        0               0         We are being called from the init, with no default printer.  We will continue
        //                                  through the procedure to get defaults.
        //        1               0         Never occurs.
        Assert(!(!pvarfOKOrCancel && fBotherUser));
        if (fBotherUser)
        {
            hr = S_OK;
            goto Cleanup;
        }
        else if (pvarfOKOrCancel)
        {
            hr = GetPrintDialogSettings(TRUE, pvarfOKOrCancel);
            goto Cleanup;
        }
        // Otherwise, we need to set the default values.
        else
            hr = S_OK;
    }
    else if (pvarfOKOrCancel)
        *pvarfOKOrCancel = VB_TRUE;       //  OK was pressed.

    //
    //  Take base print dialog return values and store them.
    //
    _hDevMode               = pprintdlg->hDevMode;
    _hDevNames              = pprintdlg->hDevNames;
    _nCopies                = (fBotherUser) ? pprintdlg->nCopies : 1; // bug in printDLG
    _nPageFrom              = pprintdlg->nFromPage;
    _nPageTo                = pprintdlg->nToPage;
    _fPrintSelectedPages    = (!!(pprintdlg->Flags & PD_PAGENUMS));
    _fPrintSelection        = (!!(pprintdlg->Flags & PD_SELECTION));
    _fCollate               = (!!(pprintdlg->Flags & PD_COLLATE));
    _fPrintToFile           = (!!(pprintdlg->Flags & PD_PRINTTOFILE));
    _fPrintCurrentPage      = (!!(pprintdlg->Flags & PD_CURRENTPAGE));

    // Collate/Copy information is in both the struct and the DEVMODE.
    // The DEVMODE bits instruct the printer to do its own copy/collate information.
    // This means that only one copy of the document is uploaded to the printer/server, and the printer itself does the replication/duplex work.
    if (_hDevMode)
    {
        pDevMode  = ::GlobalLock(_hDevMode);       
        if (pDevMode)
        {
            // (greglett) DEVMODE is returned A on Win9x platforms, not W.  <sigh>
            if (g_fUnicodePlatform)
            {
                if (((DEVMODEW *)pDevMode)->dmFields & DM_COLLATE)
                    _fCollate = (((DEVMODEW *)pDevMode)->dmCollate == DMCOLLATE_TRUE) || _fCollate;
                if (    ((DEVMODEW *)pDevMode)->dmFields & DM_COPIES
                    &&  ((DEVMODEW *)pDevMode)->dmCopies > _nCopies )
                    _nCopies  = ((DEVMODEW *)pDevMode)->dmCopies;
            }
            else
            {
                if (((DEVMODEA *)pDevMode)->dmFields & DM_COLLATE)
                    _fCollate = (((DEVMODEA *)pDevMode)->dmCollate == DMCOLLATE_TRUE) || _fCollate;
                if (    ((DEVMODEA *)pDevMode)->dmFields & DM_COPIES
                    &&  ((DEVMODEA *)pDevMode)->dmCopies > _nCopies )
                    _nCopies  = ((DEVMODEA *)pDevMode)->dmCopies;
            }
            ::GlobalUnlock(_hDevMode);        
        }
    }

    GetDeviceProperties();

    //  Read in changes to the Trident specific print options.
    {
        VARIANT var;
        // Read changed values from event object
        if (!pEvent->getAttribute(_T("printfLinked"),0,&var))
        {
            Assert(var.vt == VT_BOOL);
            _fPrintAllLinkedDocuments = var.boolVal;
        }

        if (!pEvent->getAttribute(_T("printfActiveFrame"), 0, &var))
        {
            Assert(var.vt == VT_BOOL);
            _fFrameActive = var.boolVal;
        }

        if (!pEvent->getAttribute(_T("printfAsShown"), 0, &var))
        {
            Assert(var.vt == VT_BOOL);
            _fFrameAsShown = var.boolVal;
        }

        if (!pEvent->getAttribute(_T("printfShortcutTable"), 0, &var))
        {
            Assert(var.vt == VT_BOOL);
            _fPrintTableOfLinks = var.boolVal;
        }
    }

    if (_fPrintToFile)
    {
        // assume failure, treating as canceling
        VARIANT var;
        hr = S_FALSE;
    
        if (    !pEvent->getAttribute(_T("printToFileOK"), 0, &var)
            &&  var.boolVal)
        {
            if (    !pEvent->getAttribute(_T("printToFileName"), 0, &var)
                &&  var.vt == VT_BSTR)
            {                                              
                TCHAR * pchFullPath = var.bstrVal;
                _tcscpy(_achFileName, pchFullPath);
                SysFreeString(var.bstrVal);

                //  (greglett)  Code used to update Trident's default save path here. (pre 5.5)
                //  Not being internal, we can't do that anymore.
                hr = S_OK;
            }
        }

        if (hr != S_OK)
           *pvarfOKOrCancel = VB_FALSE;
    }

Cleanup:      
    ReleaseInterface(pUIHandler);
    ReleaseInterface(pUICommandHandler);
    ReleaseInterface(pEvent);
    if (hPrint)
    {
        if (pprintdlg)
            ::GlobalUnlock(hPrint);
        ::GlobalFree(hPrint);
    }
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member : CTemplatePrinter::InitDialog
//  
//  Synopsis : Does all the COM schtick to get the appropriate interfaces to show
//             a dialog.
//
//  Parameters:  hWnd: Will try to fill with Trident's hWnd.  May return as NULL with S_OK.
//               ppEventObj2:  Will create an IHTMLEventObj2.  Must be created if S_OK is returned.
//               ppUIHandler:  Will return Trident's UI Handler.  May return NULL with S_OK.
//
//-----------------------------------------------------------------------------
HRESULT
CTemplatePrinter::InitDialog(HWND *phWnd, IHTMLEventObj2 **ppEventObj2, IOleCommandTarget **ppUIHandler, int *pnFontScale)
{
    HRESULT              hr;
    IHTMLElement        *pElement           = NULL;
    IDispatch           *pDispatch          = NULL;
    IHTMLDocument2      *pDoc               = NULL;
    IOleWindow          *pDocWin            = NULL;
    IHTMLEventObj       *pEventObj          = NULL;
    VARIANT              varHost;

    Assert(phWnd);
    Assert(ppEventObj2);
    Assert(ppUIHandler);

    VariantInit(&varHost);

    *phWnd = NULL;
    *ppEventObj2 = NULL;
    *ppUIHandler = NULL;
    if (pnFontScale)
        *pnFontScale = 2;

    if (!_pPeerSiteOM)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    if (!phWnd || !ppEventObj2 || !ppUIHandler)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = _pPeerSite->GetElement(&pElement);
    if (hr)
        goto Cleanup;
    Assert(pElement);

    hr = pElement->get_document(&pDispatch);
    if (hr)
        goto Cleanup;
    Assert(pDispatch);

    hr = pDispatch->QueryInterface(IID_IHTMLDocument2, (void**) &pDoc);
    if (hr)
        goto Cleanup;

    hr = pDoc->QueryInterface(IID_IOleWindow, (void **)&pDocWin);
    if (!hr)
    {
        Assert(pDocWin);
        pDocWin->GetWindow(phWnd);
    }

    // Create an event object to pass to our host with the print information
    hr = _pPeerSiteOM->CreateEventObject(&pEventObj);
    if (hr)
        goto Cleanup;
    Assert(pEventObj);

    // Now get the appropriate interface to populate the event object with parameters
    // for the dialog.
    hr = pEventObj->QueryInterface(IID_IHTMLEventObj2, (void**)ppEventObj2);
    if (hr)
        goto Cleanup;
    Assert(ppEventObj2);

    //  Get the instance of the Trident Host UI browse document, if it exists.
    //  We use this to delegate to our host.
    if (   GetDialogArgument(&varHost, PRINTARG_BROWSEDOC) == S_OK
        && V_VT(&varHost) == VT_UNKNOWN
        && V_UNKNOWN(&varHost) ) 
    {
        hr = V_UNKNOWN(&varHost)->QueryInterface(IID_IOleCommandTarget, (void **)ppUIHandler);
        Assert(*ppUIHandler);        
    }

Cleanup:
    ReleaseInterface(pElement);
    ReleaseInterface(pDispatch);
    ReleaseInterface(pDoc);    
    ReleaseInterface(pDocWin);
    ReleaseInterface(pEventObj);
    VariantClear(&varHost);
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member : CTemplatePrinter::ReturnPrintHandles
//
//  Synopsis : Show our print handles to the browse instance of Trident.
//
//-----------------------------------------------------------------------------
void
CTemplatePrinter::ReturnPrintHandles()
{
    HRESULT hr;
    VARIANT             varHost;
    VARIANT             varIn;
    SAFEARRAYBOUND      sabound;
    IOleCommandTarget * pioct   = NULL;
    SAFEARRAY         * psa     = NULL;
    long                lArg    = 0;

    VariantInit(&varHost);
    VariantInit(&varIn);

    if (!_hDevNames || !_hDevMode)
        goto Cleanup;   

    //
    // Get handle back to the browse document to update its print handles.
    //
    if (    GetDialogArgument(&varHost, PRINTARG_BROWSEDOC) != S_OK
        ||  V_VT(&varHost) != VT_UNKNOWN
        ||  !V_UNKNOWN(&varHost) )
        goto Cleanup;
           
    hr = V_UNKNOWN(&varHost)->QueryInterface(IID_IOleCommandTarget, (void **)&pioct);
    if (hr)
        goto Cleanup;
    Assert(pioct);

    //
    // Create a SAFEARRAY filled with our two print handles { DEVNAMES, DEVMODE }
    //
    sabound.cElements   = 2;
    sabound.lLbound     = 0;
    psa = SafeArrayCreate(VT_HANDLE, 1, &sabound);
    if (!psa)
        goto Cleanup;

    //
    // Bundle the array in the Exec argument...
    //
    V_VT(&varIn) = VT_ARRAY | VT_HANDLE;
    V_ARRAY(&varIn) = psa;

    if (    SafeArrayPutElement(psa, &lArg, &_hDevNames) != S_OK
        ||  SafeArrayPutElement(psa, &(++lArg), &_hDevMode) != S_OK )
    {
        goto Cleanup;
    }
       
    //
    // Actually make the call, passing our handles to the browse instance
    //
    pioct->Exec( &CGID_MSHTML,
                  IDM_SETPRINTHANDLES,
                  NULL, 
                  &varIn, 
                  NULL);

Cleanup:
    VariantClear(&varIn);       // Destroys SAFEARRAY.
    VariantClear(&varHost);
    ReleaseInterface(pioct);
    return;
}


//+----------------------------------------------------------------------------
//
//  Member : CTemplatePrinter::GetDialogArgument
//
//  Synopsis : The dialogArgument on the attached print template has several important expandos.
//             This function gets the dialogArguments and caches a ptr to it.
//
//  Returens:  S_OK:    dlgArgs saved
//             E_*:     Error encounterd
//
//-----------------------------------------------------------------------------
HRESULT
CTemplatePrinter::GetDialogArguments()
{
    HRESULT             hr;
    IHTMLElement        *pElement       = NULL;
    IDispatch           *pDispatch      = NULL;
    IServiceProvider    *pIDocSrvProv   = NULL;
    IHTMLDialog         *pIHTMLDialog   = NULL; 
    VARIANT              varDlgArgs;

    Assert(_pPeerSite);
    VariantInit(&varDlgArgs);

    hr = _pPeerSite->GetElement(&pElement);
    if (hr)
        goto Cleanup;
    Assert(pElement);

    hr = pElement->get_document(&pDispatch);
    if (hr)
        goto Cleanup;
    Assert(pDispatch);

    hr = pDispatch->QueryInterface(IID_IServiceProvider, (void **)&pIDocSrvProv);
    if (FAILED(hr))
        goto Cleanup;
    Assert(pIDocSrvProv);
    
    hr = pIDocSrvProv->QueryService(IID_IHTMLDialog, IID_IHTMLDialog, (void**)&pIHTMLDialog);
    if (FAILED(hr))
        goto Cleanup;
    Assert(pIHTMLDialog);

    hr = pIHTMLDialog->get_dialogArguments(&varDlgArgs);
    if (hr)
        goto Cleanup;

    if (    V_VT(&varDlgArgs) != VT_UNKNOWN
        ||  !V_UNKNOWN(&varDlgArgs) )
    {
        hr = E_FAIL;    // Major badness.  This MUST be there.
        goto Cleanup;
    }

    hr = V_UNKNOWN(&varDlgArgs)->QueryInterface(IID_IHTMLEventObj2, (void**)&_pevDlgArgs);
    if (hr)
        goto Cleanup;
    Assert(_pevDlgArgs);

Cleanup:
    ReleaseInterface(pElement);
    ReleaseInterface(pDispatch);
    ReleaseInterface(pIDocSrvProv);
    ReleaseInterface(pIHTMLDialog);
    VariantClear(&varDlgArgs);

    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member : CTemplatePrinter::GetDialogArgument
//
//  Synopsis : The dialogArgument on the attached print template has several important expandos.
//             Function gets the expando specified by the argument enum
//
//  Returens:  S_OK:    expando obtained (might be VT_NULL or VT_EMPTY)
//             E_*:     Error encounterd
//
//-----------------------------------------------------------------------------
HRESULT
CTemplatePrinter::GetDialogArgument(VARIANT *pvar, PRINTARG eArg)
{
    HRESULT              hr             = S_OK;    
    BSTR                 bstrTarget     = NULL; 

    Assert(pvar);
    Assert(eArg >= 0 && eArg < PRINTTYPE_LAST);

    // (greglett) TODO: Implement a caching system for these args.  We access some of
    //            often, and shouldn't do the (potentially) cross-thread OLE each time.

    if (!_pevDlgArgs)
        return E_FAIL;

    VariantClear(pvar);

    bstrTarget = SysAllocString(s_aachPrintArg[eArg]);
    if (!bstrTarget)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = _pevDlgArgs->getAttribute(bstrTarget, 0, pvar);

Cleanup:
    SysFreeString(bstrTarget);

    return hr;        
}

//+----------------------------------------------------------------------------
//
//  Member : CTemplatePrinter::RemoveDialogArgument
//
//  Synopsis : Remove the dialogArgument specified byt he argument enum.
//
//  Returens:  S_OK:    expando obtained (might be VT_NULL or VT_EMPTY)
//             E_*:     Error encounterd
//
//-----------------------------------------------------------------------------
HRESULT
CTemplatePrinter::RemoveDialogArgument(PRINTARG eArg)
{
    HRESULT              hr             = S_OK;    
    BSTR                 bstrTarget     = NULL; 
    VARIANT_BOOL         fSuccess;

    Assert(eArg >= 0 && eArg > PRINTTYPE_LAST);

    if (!_pevDlgArgs)
        return E_FAIL;

    bstrTarget = SysAllocString(s_aachPrintArg[eArg]);
    if (!bstrTarget)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = _pevDlgArgs->removeAttribute(bstrTarget, 0, &fSuccess);

Cleanup:
    SysFreeString(bstrTarget);

    return hr;        
}


//+----------------------------------------------------------------------------
//
//  Member : CTemplatePrinter::EnsureMLLoadLibrary
//
//  Synopsis : Ensure the library with the default header/footer/margins has
//             been loaded and return it.
//
//-----------------------------------------------------------------------------
HINSTANCE
CTemplatePrinter::EnsureMLLoadLibrary()
{
    if (!_hInstResource)
    {
        _hInstResource = MLLoadLibrary(_T("shdoclc.dll"), NULL, ML_CROSSCODEPAGE);
        Assert(_hInstResource && "Resource DLL is not loaded!");
    }

    return _hInstResource;
}


//+----------------------------------------------------------------------
//
//  Function:   CTemplatePrinter::GetDefaultMargin
//
//  Purpose:    Get default values for the margin from
//                  (1) The registry
//                  (2) The resource DLL
//                  (3) Arbitrary, hard-coded values.
//
//  Parameters  keyOldValues    registry key for the margins or NULL
//              pMarginName     "margin_top", "margin_bottom", &c...
//              pMarginValue    buffer for value
//              cchMargin        length of the buffer in TCHARs
//              dwMarginConst   const for getting the margin from the resource file
//-----------------------------------------------------------------------
HRESULT
CTemplatePrinter::GetDefaultMargin(HKEY keyOldValues, TCHAR* pMarginName, TCHAR* pMarginValue, DWORD cchMargin, DWORD dwMarginConst)
{
    HRESULT hr = E_FAIL;
    DWORD   cchLen;
    Assert(pMarginName);
    Assert(pMarginValue);
    Assert(cchMargin > 0);

    //  First try the passed registry key.
    if (keyOldValues != NULL)
    {
        hr = ReadSubkeyFromRegistry(keyOldValues, pMarginName, pMarginValue, cchMargin);
    }

    //  Next try the resource file.
    if (hr)
    {
        cchLen = ::LoadString(EnsureMLLoadLibrary(), dwMarginConst, pMarginValue, cchMargin);
        if (cchLen > 0)
            hr = ERROR_SUCCESS;
    }

    // Lastly, just do hardcoded values.
    if (hr)
    {
        cchLen = _tcslen(_T("0.750000")) + 1;
        if (cchLen <= cchMargin)
        {
            _tcscpy(pMarginValue,_T("0.750000"));
            hr = ERROR_SUCCESS;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTemplatePrinter::GetDefaultHeaderFooter
//
//  Purpose:    Get default values for the header/footer from
//                  (1) The registry
//                  (2) The resource DLL
//                  (3) Arbitrary, hard-coded values.
//
//  Arguments:  keyOldValues       If Not Null try to read from the IE3 defaults, If NULL or the read
//                                 was not successfull, get it from the resources
//              pValueName         "header" or "footer"
//              pDefault           ptr to the default header or footer
//              cbDefault          size of the array to hold the header-footer (in TCHAR)
//              pDefaultLiteral    default value if there is no def. in resources
//
//  Returns :   None
//
//----------------------------------------------------------------------------
HRESULT
CTemplatePrinter::GetDefaultHeaderFooter(HKEY keyOldValues,
                       TCHAR* pValueName,
                       TCHAR* pDefault,
                       DWORD  cchDefault,
                       DWORD  dwResourceID,
                       TCHAR* pDefaultLiteral)
{
    HRESULT hr      = E_FAIL;

    Assert(pValueName);
    Assert(pDefault);
    Assert(pDefaultLiteral);
    Assert(cchDefault > 0);

    //  Try registry for a left/right header/footer first.
    if (keyOldValues != NULL)
    {
        TCHAR   achName[32];
        TCHAR   achLeft [MAX_DEFAULTHEADFOOT] = _T("");
        TCHAR   achRight[MAX_DEFAULTHEADFOOT] = _T("");
        TCHAR   achSeparator[3]               = _T("&b");
        DWORD   cchTotal  = 0;

        _tcscpy(achName,pValueName);
        _tcscat(achName,_T("_left"));
        if (!ReadSubkeyFromRegistry(keyOldValues, achName, achLeft, MAX_DEFAULTHEADFOOT))
            cchTotal += _tcslen(achLeft);

        _tcscpy(achName,pValueName);
        _tcscat(achName,_T("_right"));
        if (!ReadSubkeyFromRegistry(keyOldValues, achName, achRight, MAX_DEFAULTHEADFOOT))
            cchTotal += _tcslen(achRight);

        if (cchTotal)
        {
            // Include the null - add it in.
            cchTotal += _tcslen(achSeparator) + 1;
            if (cchTotal <= cchDefault)
            {
                _tcscpy(pDefault,achLeft);
                _tcscat(pDefault,achSeparator);
                _tcscat(pDefault,achRight);
                hr = ERROR_SUCCESS;
            }
        }    
    }

    // Concatenate the left/right if it exists and return it.
    if (hr)
    {
        DWORD cchLen;
        cchLen = ::LoadString(EnsureMLLoadLibrary(), dwResourceID, pDefault, cchDefault);
        if (cchLen > 0)
            hr = ERROR_SUCCESS;
    }


    //  Otherwise, use the passed default value.
    if (hr)
    {
        if (_tcslen(pDefaultLiteral) + 1 <= cchDefault)
        {
            _tcscpy(pDefault, pDefaultLiteral);
            hr = ERROR_SUCCESS;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTemplatePrinter::GetDefaultPageSetupValues
//
//  Synopsis:   Try to get the old page setup values from HKEY_LOCAL_MACHINE. If found copies them into
//              HKEY_CURRENT_USER, if not, copies the default values
//
//  Arguments:  None
//
//  Returns :   S_OK or E_FAIL
//
//  Summary :   ---
//
//----------------------------------------------------------------------------
HRESULT
CTemplatePrinter::GetDefaultPageSetupValues(HKEY keyExplorer,HKEY * pKeyPrintOptions)
{
    TCHAR   achDefaultHeader[MAX_DEFAULTHEADFOOT];
    TCHAR   achDefaultFooter[MAX_DEFAULTHEADFOOT];
    TCHAR   achDefaultMarginTop    [MAX_MARGINLENGTH];
    TCHAR   achDefaultMarginBottom [MAX_MARGINLENGTH];
    TCHAR   achDefaultMarginLeft   [MAX_MARGINLENGTH];
    TCHAR   achDefaultMarginRight  [MAX_MARGINLENGTH];
    HKEY    keyOldValues;
    HRESULT hr = S_OK;

    if (!pKeyPrintOptions)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // Check the default machine registry values
    if (::RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     _T("Software\\Microsoft\\Internet Explorer\\PageSetup"),0,
                     KEY_ALL_ACCESS,
                     &keyOldValues) != ERROR_SUCCESS)
    {
        keyOldValues = NULL;
    }
    
    GetDefaultHeaderFooter(keyOldValues, _T("header"), (TCHAR*)&achDefaultHeader, MAX_DEFAULTHEADFOOT, IDS_DEFAULTHEADER, _T("&w&bPage &p of &P"));
    GetDefaultHeaderFooter(keyOldValues, _T("footer"), (TCHAR*)&achDefaultFooter, MAX_DEFAULTHEADFOOT, IDS_DEFAULTFOOTER, _T("&u&b&d"));
    GetDefaultMargin(keyOldValues, _T("margin_bottom"), (TCHAR*)&achDefaultMarginBottom, MAX_MARGINLENGTH, IDS_DEFAULTMARGINBOTTOM);
    GetDefaultMargin(keyOldValues, _T("margin_top"),    (TCHAR*)&achDefaultMarginTop,    MAX_MARGINLENGTH, IDS_DEFAULTMARGINTOP);
    GetDefaultMargin(keyOldValues, _T("margin_left"),   (TCHAR*)&achDefaultMarginLeft,   MAX_MARGINLENGTH, IDS_DEFAULTMARGINLEFT);
    GetDefaultMargin(keyOldValues, _T("margin_right"),  (TCHAR*)&achDefaultMarginRight,  MAX_MARGINLENGTH, IDS_DEFAULTMARGINRIGHT);

    ::RegCloseKey(keyOldValues);
    keyOldValues = NULL;

    //  Create the new user registry key
    if (::RegCreateKeyEx(keyExplorer,
                   _T("PageSetup"),
                   0,
                   NULL,
                   REG_OPTION_NON_VOLATILE,
                   KEY_ALL_ACCESS,
                   NULL,
                   pKeyPrintOptions,
                   NULL) == ERROR_SUCCESS)
    {       
        //  Put our default values into registry keys.
        WriteSubkeyToRegistry(*pKeyPrintOptions, _T("header"),         achDefaultHeader);
        WriteSubkeyToRegistry(*pKeyPrintOptions, _T("footer"),         achDefaultFooter);
        WriteSubkeyToRegistry(*pKeyPrintOptions, _T("margin_bottom"),  achDefaultMarginBottom);
        WriteSubkeyToRegistry(*pKeyPrintOptions, _T("margin_left"),    achDefaultMarginLeft);
        WriteSubkeyToRegistry(*pKeyPrintOptions, _T("margin_right"),   achDefaultMarginRight);
        WriteSubkeyToRegistry(*pKeyPrintOptions, _T("margin_top"),     achDefaultMarginTop);
    };

Cleanup:    
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CTemplatePrinter::GetRegPrintOptionsKey
//
//  Synopsis:   Get handle of requested key under \HKCU\Software\Microsoft\Internet Explorer
//
//  Arguments:  PrintSubKey      - subkey of printoptions root to return key for
//              pKeyPrintOptions - ptr to handle of requested key in registry
//
//  Returns :   S_OK or E_FAIL
//
//  Summary :   First it tries to get the values from "new place"
//              HKEY_CURRENT_USER\Software\Microsoft\Internet Explorer\PageSetup
//              If there is no such a key, it creates it and tries to get the values from "old place"
//              HKEY_LOCAL_MACHINE\Software\Microsoft\Internet Explorer\PageSetup
//              If successful it copies the values into the "new place"
//              If not, it tries to get the values from the registry,
//              If no luck, it uses the hardcoded strings
//              NOTE : If the procedure returns with S_OK, it guaranties that they will be a
//              "new place" with values.
//
//----------------------------------------------------------------------------
HRESULT
CTemplatePrinter::GetRegPrintOptionsKey(PRINTOPTIONS_SUBKEY PrintSubKey, HKEY * pKeyPrintOptions)
{
    HKEY     keyExplorer;
    HRESULT  hr = E_FAIL;

    if (RegOpenKeyEx(
                HKEY_CURRENT_USER,
                _T("Software\\Microsoft\\Internet Explorer"),
                0,
                KEY_ALL_ACCESS,
                &keyExplorer) == ERROR_SUCCESS)
    {
        LPTSTR szSubKey = (PrintSubKey == PRINTOPTSUBKEY_MAIN
                            ? _T("Main")
                            : _T("PageSetup"));

        if (RegOpenKeyEx(keyExplorer,
                         szSubKey,
                         0,
                         KEY_ALL_ACCESS,
                         pKeyPrintOptions) == ERROR_SUCCESS)
        {
            if (PrintSubKey == PRINTOPTSUBKEY_PAGESETUP)
            {
                //
                //  For the PageSetup key, we do some additional checks to make
                //  sure that (at least) the header and footer keys exist.
                //

                DWORD dwT;

                if (    (RegQueryValueEx(*pKeyPrintOptions, _T("header"), 0, NULL, NULL, &dwT) == ERROR_SUCCESS)
                    &&  (RegQueryValueEx(*pKeyPrintOptions, _T("footer"), 0, NULL, NULL, &dwT) == ERROR_SUCCESS))
                {
                    // the header and footer keys exist, we're fine
                    hr = S_OK;
                }
                else
                {
                    // whoops.  fall back...
                    hr = GetDefaultPageSetupValues(keyExplorer, pKeyPrintOptions);
                }
            }
            else
                hr = S_OK;
        }
        else
        {
            //  For page setup, if we don't have default values, create them.
            if (PrintSubKey == PRINTOPTSUBKEY_PAGESETUP)
            {
                hr = GetDefaultPageSetupValues(keyExplorer, pKeyPrintOptions);
            }
        }

        RegCloseKey(keyExplorer);
    }
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member : CTemplatePrinter::ReadBoolFromRegistry
//
//  Synopsis : Takes an open registry key and subkey name, and returns the
//             value as a boolean.
//
//-----------------------------------------------------------------------------
BOOL
CTemplatePrinter::ReadBoolFromRegistry(HKEY hKey, TCHAR *pSubkeyName)
{
    TCHAR   achBool[MAX_DEFAULTBOOL];
    BOOL    fRet = FALSE;
    achBool[0] = '\0';

    if (!ReadSubkeyFromRegistry(hKey, pSubkeyName, achBool, MAX_DEFAULTBOOL))
    {
        fRet = !_tcsicmp(achBool, _T("yes"));
    }

    return fRet;
}

//+----------------------------------------------------------------------------
//
//  Member : CTemplatePrinter::AreRatingsEnabled
//
//  Synopsis : Checks MS_RATING.DLL to see if ratings are enabled.
//
//-----------------------------------------------------------------------------
BOOL
CTemplatePrinter::AreRatingsEnabled()
{
    BOOL fRet = FALSE;

    typedef HRESULT (STDAPICALLTYPE *PFN)(void);
    
    if (!_hInstRatings)
        LoadLibrary("MSRATING.DLL", &_hInstRatings);

    if (_hInstRatings)
    {
        PFN     pfn;
        pfn = (PFN) ::GetProcAddress(_hInstRatings, "RatingEnabledQuery");
        if (!pfn)
        {
            goto Cleanup;
        }

        fRet = !pfn() ? TRUE: FALSE;
    }

Cleanup:
    return fRet;
}


//+----------------------------------------------------------------------------
//
//  Member : CTemplatePrinter::DecimalTCHARToMargin
//
//  Synopsis : Takes a decimal representation in 1" and returns a long
//             with that value in 1/100000"
//
//-----------------------------------------------------------------------------
long
CTemplatePrinter::DecimalTCHARToFixed(TCHAR* pString, int nPowersOfTen)
{
    TCHAR* p = pString;
    int    iLen = _tcslen(pString);
    int    i;
    int    j = 0;
    int    iChar = 0;
    long   nRet = 0;

    if (pString == NULL)
        goto Cleanup;

    // Clear leading whitespace
    for (i=0;i<iLen;i++,p++)
        if (*p != _T(' '))
            break;
    
    // Do the integer part    
    for (;i<iLen;i++,p++)
    {
        iChar = *p;
        if ((iChar < _T('0')) || (iChar > _T('9')))
            break;
        nRet = nRet * 10 + (iChar - _T('0'));
    }

    if (iChar == _T('.'))
    {
        // Do the decimal part.
        for (i++,p++; (i+j<iLen && j<5); j++,p++)
        {
            iChar = *p;
            if ((iChar < _T('0')) || (iChar > _T('9')))
                break;
            nRet = nRet * 10 + (iChar - _T('0'));
        }
    }
    
    //  Make sure we are in 1/100000"
    for (;j < nPowersOfTen; j++)
        nRet *= 10;

Cleanup:
    return nRet;
}

BOOL
CTemplatePrinter::CommCtrlNativeFontSupport()
{
    BOOL    fRet = FALSE;    
    typedef BOOL (APIENTRY *PFN)(LPINITCOMMONCONTROLSEX);

    if (!_hInstComctl32)
        LoadLibrary("COMCTL32.DLL", &_hInstComctl32);

    if (_hInstComctl32)
    {
        INITCOMMONCONTROLSEX icc;
        PFN     pfn;

        pfn = (PFN) ::GetProcAddress(_hInstComctl32, "InitCommonControlsEx");
        if (!pfn)
        {
            goto Cleanup;
        }

        icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
        icc.dwICC = ICC_NATIVEFNTCTL_CLASS;        

        fRet = pfn(&icc);
    }

Cleanup:
    return fRet;
}


//+----------------------------------------------------------------------------
//
//  Member : CTemplatePrinter::WriteFixedToRegistry
//
//  Synopsis : Takes an open registry key and subkey name, and writes the
//              passed value to the resulting registry key in whole units.
//
//-----------------------------------------------------------------------------
HRESULT
CTemplatePrinter::WriteFixedToRegistry(HKEY hKeyPS, const TCHAR* pValueName,LONG nMargin, int nFactor)
{
    TCHAR   achFixed[MAX_MARGINLENGTH];

    //  Convert 1/100000" units to a TCHAR representation of decimal in 1" units.
    FixedToDecimalTCHAR(nMargin, achFixed, nFactor);

    return WriteSubkeyToRegistry(hKeyPS, pValueName, achFixed);
}

//+----------------------------------------------------------------------------
//
//  Member : CTemplatePrinter::ReadFixedFromRegistry
//
//  Synopsis : Takes an open registry key and subkey name, and gets a fixed point value
//
//-----------------------------------------------------------------------------
HRESULT
CTemplatePrinter::ReadFixedFromRegistry(HKEY hKeyPS, const TCHAR *pValueName, LONG *pFixed, int nPowersOfTen)
{
    HRESULT hr;
    TCHAR   achFixed[MAX_MARGINLENGTH];
    achFixed[0] = '\0';

    Assert(pValueName);
    Assert(pFixed);
    
    *pFixed = 0;

    hr = ReadSubkeyFromRegistry(hKeyPS, pValueName, achFixed, MAX_MARGINLENGTH);
    if (!hr)
        *pFixed = DecimalTCHARToFixed(achFixed, nPowersOfTen);

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member : CTemplatePrinter::ReadDeviceUnicode
//
//  Synopsis : Creates device information given the printer name, 
//
//-----------------------------------------------------------------------------
HRESULT
CTemplatePrinter::ReadDeviceUnicode(TCHAR *pchPrinter, TCHAR *pchDriver, TCHAR *pchPort)
{
    HRESULT             hr          = S_OK;
    HANDLE              hPrinter    = NULL;
    PRINTER_INFO_2 *    pPrintInfo  = NULL;
    Assert(pchPrinter);

    if (    ::OpenPrinter(pchPrinter, &hPrinter, NULL)
        &&  hPrinter)
    {
        DWORD               nStructSize;

        if (!pchDriver || !pchPort)
        {

            ::GetPrinter(hPrinter, 2, NULL, 0, &nStructSize);
            pPrintInfo = (PRINTER_INFO_2 *) ::GlobalAlloc(GPTR, nStructSize);           
            if (!pPrintInfo)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            if (!::GetPrinter(hPrinter, 2, (byte *)pPrintInfo, nStructSize, &nStructSize))
            {
                hr = E_FAIL;
                goto Cleanup;
            }
        }

        hr = CreateDevNames(pchDriver ? pchDriver : pPrintInfo->pDriverName,
                            pchPrinter,
                            pchPort ? pchPort : pPrintInfo->pPortName,
                            &_hDevNames);
        if (hr)
            goto Cleanup;

        nStructSize = ::DocumentProperties(0, hPrinter, pchPrinter, NULL, NULL, 0);
        if (nStructSize < sizeof(DEVMODE))
        {
            Assert(!"Memory size suggested by DocumentProperties is smaller than DEVMODE");
            nStructSize = sizeof(DEVMODE);
        }

        _hDevMode = ::GlobalAlloc(GHND, nStructSize);
        if (_hDevMode)
        {
            DEVMODE *pDevMode = (DEVMODE *) ::GlobalLock(_hDevMode);

            if (pDevMode)
            {
                ::DocumentProperties(0, hPrinter, pchPrinter, pDevMode, NULL, DM_OUT_BUFFER);

                pDevMode->dmFields &= ~DM_COLLATE;
                pDevMode->dmCollate = DMCOLLATE_FALSE;

                ::GlobalUnlock(_hDevMode);
            }
            else
            {
                ::GlobalFree(_hDevMode);
                _hDevMode = NULL;
            }
        }
    }

Cleanup:
    if (hPrinter)
        ::ClosePrinter(hPrinter);        
    if (pPrintInfo)
       ::GlobalFree(pPrintInfo);

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member : CTemplatePrinter::ReadDeviceNonUnicode
//
//  Synopsys : Because non-Unicode platforms (Win9x) don't properly implement
//             many of the printing widechar calls, they need to explicitly
//             make multibyte (A) calls.
//
//+----------------------------------------------------------------------------
HRESULT
CTemplatePrinter::ReadDeviceNonUnicode(TCHAR *pchPrinterWide, TCHAR *pchDriverWide, TCHAR *pchPortWide)
{
    HRESULT             hr                  = S_OK;
    HANDLE              hPrinter            = NULL;
    LPSTR               pchPrinter          = NULL;
    TCHAR *             pchDriverWideLocal  = NULL;
    TCHAR *             pchPortWideLocal    = NULL;
    PRINTER_INFO_2A *   pPrintInfo          = NULL;

    Assert(pchPrinterWide);
    
    pchPrinter = InitMultiByteFromWideChar(pchPrinterWide);
    if (!pchPrinter)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (    ::OpenPrinterA(pchPrinter, &hPrinter, NULL)
        &&  hPrinter    )
    {
        DWORD   nStructSize;
        
        if (!pchDriverWide || !pchPortWide)
        {
            ::GetPrinterA(hPrinter, 2, NULL, 0, &nStructSize);

            pPrintInfo = (PRINTER_INFO_2A *)::GlobalAlloc(GPTR, nStructSize);           
            if (!pPrintInfo)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            if (!::GetPrinterA(hPrinter, 2, (byte *)pPrintInfo, nStructSize, &nStructSize))
            {
                hr = E_FAIL;
                goto Cleanup;
            }

            pchDriverWideLocal  = InitWideCharFromMultiByte(pPrintInfo->pDriverName);
            pchPortWideLocal    = InitWideCharFromMultiByte(pPrintInfo->pPortName);
        }

        hr = CreateDevNames(pchDriverWide ? pchDriverWide : pchDriverWideLocal,
                            pchPrinterWide,
                            pchPortWide ? pchPortWide : pchPortWideLocal,
                            &_hDevNames);
        if (hr)
            goto Cleanup;

        // NB (105850) (mikhaill) -- Windows Millennium's routine DocumentPropertiesA()
        // impudently changes processor state. This happens just once after
        // reboot and cause, in particular, unmasking floating point exception flags.
        // At some later moment processor meet any suspicious condition (overflow,
        // underflow, zero-divide, precision loose, etc) in some innocent routine,
        // generates unhandled exception and eventually crashes.
        // The following fsave/frstor pair is an ugly patch that should be removed
        // after millennium bug fix.
        // Windows Millennium build versions tested: 4.90.2485, 4.90.2491.
#ifdef _M_IX86
    {
        FLOATING_SAVE_AREA fsa;
        _asm fsave fsa;
#endif //_M_IX86
        nStructSize = ::DocumentPropertiesA(0, hPrinter, pchPrinter, NULL, NULL, 0);
#ifdef _M_IX86
        _asm frstor fsa;
    }
#endif //_M_IX86
        
        if (nStructSize < sizeof(DEVMODEA))
        {
            Assert(!"Memory size suggested by DocumentProperties is smaller than DEVMODEA");
            nStructSize = sizeof(DEVMODEA);
        }

        _hDevMode = ::GlobalAlloc(GHND, nStructSize);
        if (_hDevMode)
        {
            DEVMODEA *pDevMode = (DEVMODEA *) ::GlobalLock(_hDevMode);

            if (pDevMode)
            {
                // NB (109499) same as 105850 above
                // but appeared in Windows98 (mikhaill 5/7/00)
#ifdef _M_IX86
    {
        FLOATING_SAVE_AREA fsa;
        _asm fsave fsa;
#endif //_M_IX86
                ::DocumentPropertiesA(0, hPrinter, pchPrinter, pDevMode, NULL, DM_OUT_BUFFER);
#ifdef _M_IX86
        _asm frstor fsa;
    }
#endif //_M_IX86

                pDevMode->dmFields &= ~DM_COLLATE;
                pDevMode->dmCollate = DMCOLLATE_FALSE;
                
                ::GlobalUnlock(_hDevMode);
            }
            else
            {
                ::GlobalFree(_hDevMode);
                _hDevMode = NULL;
            }
        }
    }

Cleanup:
    if (hPrinter)
        ::ClosePrinter(hPrinter);
    if (pPrintInfo)
        ::GlobalFree(pPrintInfo);
    if (pchPrinter)
        delete []pchPrinter;
    if (pchDriverWideLocal)
        delete []pchDriverWideLocal;
    if (pchPortWideLocal)
        delete []pchPortWideLocal;

    return hr;
}

//+-----------------------------------------------------------------------------
//
//  Member:     CTemplatePrinter::GetDeviceProperties
//
//  Synopsis :  Gets the relevant physical properties of the device currently specified
//              in _hDevNames and _hDevMode
//
//------------------------------------------------------------------------------
HRESULT
CTemplatePrinter::GetDeviceProperties()
{
    IHTMLElementRender  *pRender            = NULL;
    IHTMLElement        *pElement           = NULL;
    BSTR                 bstrPrinter        = NULL;
    HRESULT hr                              = E_FAIL;

    if (_hDevNames && _hDevMode)
    {
        DEVNAMES *pDevNames = ((DEVNAMES *)::GlobalLock(_hDevNames));
        void     *pDevMode  = ::GlobalLock(_hDevMode);
        if (pDevNames && pDevMode)
        {
            HDC hDC = NULL;

            // (greglett) Non-Unicode badness.  See comment at definition of _hDevMode
            if (g_fUnicodePlatform)
            {
                hDC = ::CreateICW(((TCHAR *)pDevNames) + pDevNames->wDriverOffset,
                                 ((TCHAR *)pDevNames) + pDevNames->wDeviceOffset,
                                 NULL,
                                 (DEVMODEW *)pDevMode);
            }
            else
            {
                LPSTR pchDriver = InitMultiByteFromWideChar(((TCHAR *)pDevNames) + pDevNames->wDriverOffset);
                LPSTR pchDevice = InitMultiByteFromWideChar(((TCHAR *)pDevNames) + pDevNames->wDeviceOffset);
                if (pchDriver && pchDevice)
                {
                    hDC = ::CreateICA(pchDriver,
                                      pchDevice,
                                      NULL,
                                      (DEVMODEA *)pDevMode);
                }
                if (pchDriver)
                    delete []pchDriver;
                if (pchDevice)
                    delete []pchDevice;
            }

            if (hDC)
            {                
                SIZE    szPage;
    
                //  Obtain the resolution and unprintable areas for this device.
                _szResolution.cx        = ::GetDeviceCaps(hDC, LOGPIXELSX);
                _szResolution.cy        = ::GetDeviceCaps(hDC, LOGPIXELSY);
                szPage.cx               = ::GetDeviceCaps(hDC, PHYSICALWIDTH);
                szPage.cy               = ::GetDeviceCaps(hDC, PHYSICALHEIGHT);
                _rcUnprintable.left     = ::GetDeviceCaps(hDC, PHYSICALOFFSETX);
                _rcUnprintable.top      = ::GetDeviceCaps(hDC, PHYSICALOFFSETY);
                _rcUnprintable.right    =  szPage.cx - ::GetDeviceCaps(hDC, HORZRES) - _rcUnprintable.left;
                _rcUnprintable.bottom   =  szPage.cy - ::GetDeviceCaps(hDC, VERTRES) - _rcUnprintable.top;   
                Assert(_rcUnprintable.right >= 0);
                Assert(_rcUnprintable.bottom >= 0);

                _ptPaperSize.x          = (_szResolution.cx)
                                            ? MulDivQuick(szPage.cx, 1000, _szResolution.cx)
                                            : 8500;
                _ptPaperSize.y          = (_szResolution.cy)
                                            ? MulDivQuick(szPage.cy, 1000, _szResolution.cy)
                                            : 11000;
                
                
                hr = _pPeerSite->GetElement(&pElement);
                if (!hr)
                {
                    Assert(pElement);

                    hr = pElement->QueryInterface(IID_IHTMLElementRender, (void **)&pRender);
                    if (!hr) 
                    {
                        Assert(pRender);
                        
                        bstrPrinter = ::SysAllocString(((TCHAR *)pDevNames) + pDevNames->wDeviceOffset);
                        if (bstrPrinter)
                            pRender->SetDocumentPrinter(bstrPrinter,hDC);
                        else
                            hr = E_OUTOFMEMORY;
                    }
                }

                ::DeleteDC(hDC);
            }
        }

        ::GlobalUnlock(_hDevNames);
        ::GlobalUnlock(_hDevMode);

        hr = S_OK;
    }

    ReleaseInterface(pElement);
    ReleaseInterface(pRender);
    if (bstrPrinter)
        ::SysFreeString(bstrPrinter);
    return hr;
}

HRESULT
CTemplatePrinter::CreateIPrintParams(DVTARGETDEVICE **ppTargetDevice, PAGESET **ppPageSet)
{
    HRESULT hr = S_OK;
    DWORD   nStructSize;

    Assert(ppTargetDevice && ppPageSet);
    (*ppTargetDevice) = NULL;
    (*ppPageSet)      = NULL;

    // Create a PAGESET.
    (*ppPageSet) = (PAGESET *)::CoTaskMemAlloc(sizeof(PAGESET));
    if (!(*ppPageSet))
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    ::ZeroMemory(*ppPageSet, sizeof(PAGESET));

    (*ppPageSet)->cbStruct      = sizeof(PAGESET)       ;
    (*ppPageSet)->cPageRange    = 1;
    if (_fPrintSelectedPages)
    {
        (*ppPageSet)->rgPages[0].nFromPage  = _nPageFrom;
        (*ppPageSet)->rgPages[0].nToPage    = _nPageTo;
    }
    else
    {
        (*ppPageSet)->rgPages[0].nFromPage  = 1;
        (*ppPageSet)->rgPages[0].nToPage    = PAGESET_TOLASTPAGE;
    }

    (*ppTargetDevice) = InitTargetDevice();
    if (!(*ppTargetDevice))
    {
        // Error!  Clear the PageSet structure.
        ::CoTaskMemFree(*ppPageSet);
        (*ppPageSet) = NULL;

        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:
    return hr;
}


// NB (greglett)
// Alas, Win9x returns a ASCII DEVMODE and a Unicode DEVNAMES from the dialog functions.
// The old code avoided converting the second structure, *except* to create a TARGETDEVICE for IPrint objects.
// Since we will need to do this, I have brought this function over.
// If this function works *really* well, then maybe we can always convert and get rid of all the explicit calls to
// ANSI functions above. (CreateICA, CreateDCA, OpenPrinterA, &c...).
DVTARGETDEVICE *
DevModeWFromDevModeA( DVTARGETDEVICE *ptd )
{
    // NOTE: Only the DEVMODE structure is in the wrong (ascii) format!
    DEVMODEA  *         lpdma = NULL;
    DVTARGETDEVICE *    ptdW  = NULL;

    if (!ptd || !ptd->tdExtDevmodeOffset)
        goto Cleanup;

    lpdma = (DEVMODEA *) (((BYTE *)ptd) + ptd->tdExtDevmodeOffset);

    // If the reported size is too small for our conception of a DEVMODEA, don't risk a GPF
    // in our code and bail out now.
    if ( (DWORD)lpdma->dmSize + lpdma->dmDriverExtra < offsetof(DEVMODEA, dmLogPixels) )
        goto Cleanup;

    ptdW = (DVTARGETDEVICE *)::CoTaskMemAlloc( ptd->tdSize + (sizeof(BCHAR) - sizeof(char)) * (CCHDEVICENAME + CCHFORMNAME) );

    if (ptdW)
    {
        // Copy the entire structure up to DEVMODE part.
        memcpy(ptdW, ptd, ptd->tdExtDevmodeOffset);

        // Account for the increase of the two DEVMODE unicode strings.
        ptdW->tdSize += (sizeof(BCHAR) - sizeof(char)) * (CCHDEVICENAME + CCHFORMNAME);

        // Convert the devmode structure.
        {
            DEVMODEW  * lpdmw = (DEVMODEW *) (((BYTE *)ptdW) + ptdW->tdExtDevmodeOffset);
            long        nCapChar;

            // Copy the first string (CCHDEVICENAME).
            // Really, 0 indicates a conversion error.  However, we really can't do much about it other than construct a NULL string.
            if (!::MultiByteToWideChar(CP_ACP, 0, (char *)lpdma->dmDeviceName, -1,  lpdmw->dmDeviceName, CCHDEVICENAME))
            {
                lpdmw->dmDeviceName[0] = _T('\0');    
            }

            // Copy the gap between strings.
            memcpy( &lpdmw->dmSpecVersion,
                    &lpdma->dmSpecVersion,
                    offsetof(DEVMODEA, dmFormName) -
                    offsetof(DEVMODEA, dmSpecVersion) );

            // Copy the first string (CCHDEVICENAME).
            if (!::MultiByteToWideChar(CP_ACP, 0, (char *)lpdma->dmFormName, -1,  lpdmw->dmFormName, CCHFORMNAME))
            {
                lpdmw->dmFormName[0] = _T('\0');
            }


            // Copy the last part including the driver-specific DEVMODE part (dmDriverExtra).
            memcpy( &lpdmw->dmLogPixels,
                    &lpdma->dmLogPixels,
                    (DWORD)lpdma->dmSize + lpdma->dmDriverExtra -
                    offsetof(DEVMODEA, dmLogPixels) );

            // Correct the dmSize member by accounting for larger unicode strings.
            lpdmw->dmSize += (sizeof(BCHAR) - sizeof(char)) * (CCHDEVICENAME + CCHFORMNAME);
        }
    }

Cleanup:
    
    return ptdW;
}

//+----------------------------------------------------------------------
//
//  Function:   InitPrintHandles
//
//  Purpose:    Allocate a DVTARGETDEVICE structure, and initialize
//              it according to the hDevMode and hDevNames.
//              Also allocated an HIC.
//
//  Note:       IMPORTANT: Note that the DEVMODE structure is not wrapped
//              on non-unicode platforms.  (See comments below for details.)
//
//  Returns:    HRESULT
//
//-----------------------------------------------------------------------
DVTARGETDEVICE *
CTemplatePrinter::InitTargetDevice()
{
    HRESULT hr = S_OK;
    LPDEVNAMES pDN = NULL;
    LPDEVMODE  pDM = NULL;
    LPDEVMODEA pDMA = NULL;
    DVTARGETDEVICE * ptd = NULL;
    WORD nMaxOffset;
    DWORD dwDevNamesSize, dwDevModeSize, dwPtdSize;
    int nNameLength;

    if (!_hDevNames || !_hDevMode)
        goto Cleanup;

    pDN = (LPDEVNAMES)::GlobalLock(_hDevNames);
    if (!pDN)
        goto Cleanup;
    if (g_fUnicodePlatform)
    {
        pDM  = (LPDEVMODE)::GlobalLock(_hDevMode);
        if (!pDM)
            goto Cleanup;
    }
    else
    {
        pDMA = (LPDEVMODEA)::GlobalLock(_hDevMode);
        if (!pDMA)
            goto Cleanup;
    }

    // IMPORTANT: We have painstakingly
    // converted only the hDevNames parameter and NOT hDevMode (NOT!!!) to have TCHAR
    // members.

    nMaxOffset = max( pDN->wDriverOffset, pDN->wDeviceOffset );
    nMaxOffset = max( nMaxOffset, pDN->wOutputOffset );
    nNameLength = _tcslen( (TCHAR *)pDN + nMaxOffset );

    // dw* are in bytes, not TCHARS

    dwDevNamesSize = sizeof(TCHAR) * ((DWORD)nMaxOffset + nNameLength + 1);
    dwDevModeSize = g_fUnicodePlatform ? ((DWORD)pDM->dmSize + pDM->dmDriverExtra)
                                       : ((DWORD)pDMA->dmSize + pDMA->dmDriverExtra);

    dwPtdSize = sizeof(DWORD) + dwDevNamesSize + dwDevModeSize;

    ptd = (DVTARGETDEVICE *)::CoTaskMemAlloc(dwPtdSize);
    if (!ptd)
        goto Cleanup;
    else
    {
        ptd->tdSize = dwPtdSize;

        // This is an ugly trick.  ptd->tdDriverNameOffset and pDN happen
        // to match up, so we just copy that plus the data in one big chunk.
        // Remember, I didn't write this -- this code is based on the OLE2 SDK.

        // Offsets are in characters, not bytes.
        memcpy( &ptd->tdDriverNameOffset, pDN, dwDevNamesSize );
        ptd->tdDriverNameOffset *= sizeof(TCHAR);
        ptd->tdDriverNameOffset += sizeof(DWORD);
        ptd->tdDeviceNameOffset *= sizeof(TCHAR);
        ptd->tdDeviceNameOffset += sizeof(DWORD);
        ptd->tdPortNameOffset *= sizeof(TCHAR);
        ptd->tdPortNameOffset += sizeof(DWORD);

        // IMPORTANT: We are not converting the DEVMODE structure back and forth
        // from ASCII to Unicode on Win9x anymore because we are not touching the
        // two strings or any other member.  Converting the DEVMODE structure can
        // be tricky because of potential and common discrepancies between the
        // value of the dmSize member and sizeof(DEVMODE).  (25155)

        if (g_fUnicodePlatform)
            memcpy((BYTE *)&ptd->tdDriverNameOffset + dwDevNamesSize, pDM, dwDevModeSize);
        else
            memcpy((BYTE *)&ptd->tdDriverNameOffset + dwDevNamesSize, pDMA, dwDevModeSize);

        ptd->tdExtDevmodeOffset = USHORT(sizeof(DWORD) + dwDevNamesSize);        

        // We must return a corrent (all WCHAR) DVTARGETDEVICEW structure.
        // Convert the nasty DEVMODEA if we've just copied it over.
        if (!g_fUnicodePlatform)
        {
            DVTARGETDEVICE *ptdOld;
            ptdOld  = ptd;
            ptd     = DevModeWFromDevModeA(ptdOld);
            ::CoTaskMemFree(ptdOld);
        }
    }

Cleanup:
    if (pDM || pDMA)
        ::GlobalUnlock(_hDevMode);
    if (pDN)
        ::GlobalUnlock(_hDevNames);

    return ptd;
}


#ifdef DBG
//
//  CTemplatePrinter Debug-Only functions
//
void
CTemplatePrinter::VerifyOrientation()
{
    // Verify that the page size reflects the current orientation bit in the DEVMODE
    // These properties should always be in sync.
    if (_hDevMode)
    {
        void *pDevMode  = ::GlobalLock(_hDevMode);
        if (pDevMode)
        {
            BOOL    fOrientationValid;
            BOOL    fLandscape; 

            // (greglett) Non-Unicode badness.  See comment at definition of _hDevMode
            if (g_fUnicodePlatform)
            {
                fOrientationValid   = !!(((DEVMODEW *)pDevMode)->dmFields & DM_ORIENTATION);
                fLandscape          = (((DEVMODEW *)pDevMode)->dmOrientation == DMORIENT_LANDSCAPE);
            }
            else
            {
                fOrientationValid   = !!(((DEVMODEA *)pDevMode)->dmFields & DM_ORIENTATION);
                fLandscape          = (((DEVMODEA *)pDevMode)->dmOrientation == DMORIENT_LANDSCAPE);
            }

            Assert(     !fOrientationValid
                    ||  fLandscape == (_ptPaperSize.x > _ptPaperSize.y)  );

            ::GlobalUnlock(_hDevMode);
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\atlbase.h ===
// This is a part of the ActiveX Template Library.
// Copyright (C) 1996 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// ActiveX Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// ActiveX Template Library product.

#ifndef __ATLBASE_H__
#define __ATLBASE_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE         // UNICODE is used by Windows headers
#endif
#endif

#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE        // _UNICODE is used by C-runtime/MFC headers
#endif
#endif

#ifdef _DEBUG
#ifndef DEBUG
#define DEBUG
#endif
#endif

#ifdef UNIX
#define MWNO_DEF_IN_TEMPLATES
#endif

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning(disable: 4201) // nameless unions are part of C++
#pragma warning(disable: 4127) // constant expression
#pragma warning(disable: 4512) // can't generate assignment operator (so what?)
#pragma warning(disable: 4514) // unreferenced inlines are common
#pragma warning(disable: 4103) // pragma pack
#pragma warning(disable: 4702) // unreachable code
#pragma warning(disable: 4237) // bool
#pragma warning(disable: 4710) // function couldn't be inlined
#pragma warning(disable: 4711) // function 'function' selected for inline expansion
#pragma warning(disable: 4355) // 'this' : used in base member initializer list
#endif //!_ATL_NO_PRAGMA_WARNINGS

#include <windows.h>
#include <winnls.h>
#include <ole2.h>

#include <ddraw.h>

#ifndef _ATL_NO_DEBUG_CRT
// Warning: if you define the above symbol, you will have
// to provide your own definition of the _ASSERTE(x) macro
// in order to compile ATL
	#include <crtdbg.h>
#endif

#include <stddef.h>
#include <tchar.h>
#include <malloc.h>
#include <olectl.h>
#include <winreg.h>

#define _ATL_PACKING 8
#pragma pack(push, _ATL_PACKING)

#if defined (_CPPUNWIND) & (defined(_ATL_EXCEPTIONS) | defined(_AFX))
#define ATLTRY(x) try{x;} catch(...) {}
#else
#define ATLTRY(x) x;
#endif

#ifdef _DEBUG
void _cdecl AtlTrace(LPCTSTR lpszFormat, ...);
#define ATLTRACE            AtlTrace
#define ATLTRACENOTIMPL(funcname)   AtlTrace(_T("%s not implemented.\n"), funcname); return E_NOTIMPL
#else
inline void _cdecl AtlTrace(LPCTSTR , ...){}
#define ATLTRACE            1 ? (void)0 : AtlTrace
#define ATLTRACENOTIMPL(funcname)   return E_NOTIMPL
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// Master version numbers

#define _ATL     1      // ActiveX Template Library
#define _ATL_VER 0x0110 // ActiveX Template Library version 1.10

/////////////////////////////////////////////////////////////////////////////
// Win32 libraries

#ifndef _ATL_NO_FORCE_LIBS
	#pragma comment(lib, "kernel32.lib")
	#pragma comment(lib, "user32.lib")
	#pragma comment(lib, "ole32.lib")
	#pragma comment(lib, "oleaut32.lib")
	#pragma comment(lib, "olepro32.lib")
	#pragma comment(lib, "uuid.lib")
	#pragma comment(lib, "advapi32.lib")
#endif // _ATL_NO_FORCE_LIBS

/////////////////////////////////////////////////////////////////////////////
// Threading Model Support

class CComCriticalSection
{
public:
	void Lock() {EnterCriticalSection(&m_sec);}
	void Unlock() {LeaveCriticalSection(&m_sec);}
	void Init() {InitializeCriticalSection(&m_sec);}
	void Term() {DeleteCriticalSection(&m_sec);}
	CRITICAL_SECTION m_sec;
};

class CComAutoCriticalSection
{
public:
	void Lock() {EnterCriticalSection(&m_sec);}
	void Unlock() {LeaveCriticalSection(&m_sec);}
	CComAutoCriticalSection() {InitializeCriticalSection(&m_sec);}
	~CComAutoCriticalSection() {DeleteCriticalSection(&m_sec);}
	CRITICAL_SECTION m_sec;
};

class CComFakeCriticalSection
{
public:
	void Lock() {}
	void Unlock() {}
	void Init() {}
	void Term() {}
};

class CComMultiThreadModel
{
public:
	static ULONG WINAPI Increment(LPLONG p) {return InterlockedIncrement(p);}
	static ULONG WINAPI Decrement(LPLONG p) {return InterlockedDecrement(p);}
	typedef CComAutoCriticalSection AutoCriticalSection;
	typedef CComCriticalSection CriticalSection;
};

class CComSingleThreadModel
{
public:
	static ULONG WINAPI Increment(LPLONG p) {return ++(*p);}
	static ULONG WINAPI Decrement(LPLONG p) {return --(*p);}
	typedef CComFakeCriticalSection AutoCriticalSection;
	typedef CComFakeCriticalSection CriticalSection;
};

#ifndef _ATL_SINGLE_THREADED
#ifndef _ATL_APARTMENT_THREADED
#ifndef _ATL_FREE_THREADED
#define _ATL_FREE_THREADED
#endif
#endif
#endif

#if defined(_ATL_SINGLE_THREADED)
	typedef CComSingleThreadModel CComObjectThreadModel;
	typedef CComSingleThreadModel CComGlobalsThreadModel;
#elif defined(_ATL_APARTMENT_THREADED)
	typedef CComSingleThreadModel CComObjectThreadModel;
	typedef CComMultiThreadModel CComGlobalsThreadModel;
#else
	typedef CComMultiThreadModel CComObjectThreadModel;
	typedef CComMultiThreadModel CComGlobalsThreadModel;
#endif

/////////////////////////////////////////////////////////////////////////////
// CComModule

struct _ATL_OBJMAP_ENTRY; // fwd decl

struct _ATL_REGMAP_ENTRY
{
	LPCTSTR     szKey;
	LPCTSTR     szData;
};

class CComModule
{
// Operations
public:
	void Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h);
	void Term();

	LONG Lock() {return CComGlobalsThreadModel::Increment(&m_nLockCnt);}
	LONG Unlock() {return CComGlobalsThreadModel::Decrement(&m_nLockCnt);}
	LONG GetLockCount() {return m_nLockCnt;}

	HINSTANCE GetModuleInstance() {return m_hInst;}
	HINSTANCE GetResourceInstance() {return m_hInst;}
	HINSTANCE GetTypeLibInstance() {return m_hInst;}
	HINSTANCE GetRegistryResourceInstance() {return m_hInst;}

	// Registry support (helpers)
	HRESULT RegisterTypeLib(LPCTSTR lpszIndex = NULL);
	HRESULT RegisterServer(BOOL bRegTypeLib = FALSE);
	HRESULT UnregisterServer();

	// Resource-based Registration
	HRESULT WINAPI UpdateRegistryFromResource(LPCTSTR lpszRes, BOOL bRegister,
		struct _ATL_REGMAP_ENTRY* pMapEntries = NULL);
	HRESULT WINAPI UpdateRegistryFromResource(UINT nResID, BOOL bRegister,
		struct _ATL_REGMAP_ENTRY* pMapEntries = NULL);
	#ifdef _ATL_STATIC_REGISTRY
	// Statically linking to Registry Ponent
	HRESULT WINAPI UpdateRegistryFromResourceS(UINT nResID, BOOL bRegister,
		struct _ATL_REGMAP_ENTRY* pMapEntries = NULL);
	HRESULT WINAPI UpdateRegistryFromResourceS(LPCTSTR lpszRes, BOOL bRegister,
		struct _ATL_REGMAP_ENTRY* pMapEntries = NULL);
	#endif //_ATL_STATIC_REGISTRY

	// Standard Registration
	HRESULT WINAPI UpdateRegistryClass(const CLSID& clsid, LPCTSTR lpszProgID,
		LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags, BOOL bRegister);
	HRESULT WINAPI RegisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
		LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags);
	HRESULT WINAPI UnregisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
		LPCTSTR lpszVerIndProgID);

	// Register/Revoke All Class Factories with the OS (EXE only)
	HRESULT RegisterClassObjects(DWORD dwClsContext, DWORD dwFlags);
	HRESULT RevokeClassObjects();

	// Obtain a Class Factory (DLL only)
	HRESULT GetClassObject(REFCLSID rclsid, REFIID riid,
		LPVOID* ppv);

// Attributes
public:
	HINSTANCE m_hInst;
	_ATL_OBJMAP_ENTRY* m_pObjMap;
	LONG m_nLockCnt;
	HANDLE m_hHeap;
	CComGlobalsThreadModel::CriticalSection m_csTypeInfoHolder;
	CComGlobalsThreadModel::CriticalSection m_csObjMap;
};

/////////////////////////////////////////////////////////////////////////////
// CRegKey

class CRegKey
{
public:
	CRegKey();
	~CRegKey();

// Attributes
public:
	operator HKEY() const;
	HKEY m_hKey;

// Operations
public:
	LONG SetValue(DWORD dwValue, LPCTSTR lpszValueName);
	LONG QueryValue(DWORD& dwValue, LPCTSTR lpszValueName);
	LONG SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);

	LONG SetKeyValue(LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);
	static LONG WINAPI SetValue(HKEY hKeyParent, LPCTSTR lpszKeyName,
		LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);

	LONG Create(HKEY hKeyParent, LPCTSTR lpszKeyName,
		LPTSTR lpszClass = REG_NONE, DWORD dwOptions = REG_OPTION_NON_VOLATILE,
		REGSAM samDesired = KEY_ALL_ACCESS,
		LPSECURITY_ATTRIBUTES lpSecAttr = NULL,
		LPDWORD lpdwDisposition = NULL);
	LONG Open(HKEY hKeyParent, LPCTSTR lpszKeyName,
		REGSAM samDesired = KEY_ALL_ACCESS);
	LONG Close();
	HKEY Detach();
	void Attach(HKEY hKey);
	LONG DeleteSubKey(LPCTSTR lpszSubKey);
	LONG RecurseDeleteKey(LPCTSTR lpszKey);
	LONG DeleteValue(LPCTSTR lpszValue);
};

inline CRegKey::CRegKey()
{m_hKey = NULL;}

inline CRegKey::~CRegKey()
{Close();}

inline CRegKey::operator HKEY() const
{return m_hKey;}

inline LONG CRegKey::SetValue(DWORD dwValue, LPCTSTR lpszValueName)
{
	_ASSERTE(m_hKey != NULL);
	return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_DWORD,
		(BYTE * const)&dwValue, sizeof(DWORD));
}

inline HRESULT CRegKey::SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	_ASSERTE(lpszValue != NULL);
	_ASSERTE(m_hKey != NULL);
	return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_SZ,
		(BYTE * const)lpszValue, (lstrlen(lpszValue)+1)*sizeof(TCHAR));
}

inline HKEY CRegKey::Detach()
{
	HKEY hKey = m_hKey;
	m_hKey = NULL;
	return hKey;
}

inline void CRegKey::Attach(HKEY hKey)
{
	_ASSERTE(m_hKey == NULL);
	m_hKey = hKey;
}

inline LONG CRegKey::DeleteSubKey(LPCTSTR lpszSubKey)
{
	_ASSERTE(m_hKey != NULL);
	return RegDeleteKey(m_hKey, lpszSubKey);
}

inline LONG CRegKey::DeleteValue(LPCTSTR lpszValue)
{
	_ASSERTE(m_hKey != NULL);
	return RegDeleteValue(m_hKey, (LPTSTR)lpszValue);
}

// Make sure MFC's afxconv.h hasn't already been loaded to do this
#ifndef USES_CONVERSION
#ifndef _DEBUG
#define USES_CONVERSION int _convert; _convert
#else
#define USES_CONVERSION int _convert = 0
#endif

/////////////////////////////////////////////////////////////////////////////
// Global UNICODE<>ANSI translation helpers

inline LPWSTR WINAPI AtlA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
	_ASSERTE(lpa != NULL);
	_ASSERTE(lpw != NULL);
	// verify that no illegal character present
	// since lpw was allocated based on the size of lpa
	// don't worry about the number of chars
	lpw[0] = '\0';
	MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars);
	return lpw;
}

inline LPSTR WINAPI AtlW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
	_ASSERTE(lpw != NULL);
	_ASSERTE(lpa != NULL);
	// verify that no illegal character present
	// since lpa was allocated based on the size of lpw
	// don't worry about the number of chars
	lpa[0] = '\0';
	WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL);
	return lpa;
}

#define A2W(lpa) (\
	((LPCSTR)lpa == NULL) ? NULL : (\
		_convert = (lstrlenA(lpa)+1),\
		AtlA2WHelper((LPWSTR) alloca(_convert*2), lpa, _convert)))

#define W2A(lpw) (\
	((LPCWSTR)lpw == NULL) ? NULL : (\
		_convert = (lstrlenW(lpw)+1)*2,\
		AtlW2AHelper((LPSTR) alloca(_convert), lpw, _convert)))

#define A2CW(lpa) ((LPCWSTR)A2W(lpa))
#define W2CA(lpw) ((LPCSTR)W2A(lpw))

#if defined(_UNICODE)
// in these cases the default (TCHAR) is the same as OLECHAR
	inline size_t ocslen(LPCOLESTR x) { return lstrlenW(x); }
	inline OLECHAR* ocscpy(LPOLESTR dest, LPCOLESTR src) { return lstrcpyW(dest, src); }
	inline LPOLESTR CharNextO(LPCOLESTR lp) {return CharNextW(lp);}
	inline LPCOLESTR T2COLE(LPCTSTR lp) { return lp; }
	inline LPCTSTR OLE2CT(LPCOLESTR lp) { return lp; }
	inline LPOLESTR T2OLE(LPTSTR lp) { return lp; }
	inline LPTSTR OLE2T(LPOLESTR lp) { return lp; }
#elif defined(OLE2ANSI)
// in these cases the default (TCHAR) is the same as OLECHAR
	inline size_t ocslen(LPCOLESTR x) { return lstrlen(x); }
	inline OLECHAR* ocscpy(LPOLESTR dest, LPCOLESTR src) { return lstrcpy(dest, src); }
	inline LPOLESTR CharNextO(LPCOLESTR lp) {return CharNext(lp);}
	inline LPCOLESTR T2COLE(LPCTSTR lp) { return lp; }
	inline LPCTSTR OLE2CT(LPCOLESTR lp) { return lp; }
	inline LPOLESTR T2OLE(LPTSTR lp) { return lp; }
	inline LPTSTR OLE2T(LPOLESTR lp) { return lp; }
#else
	inline size_t ocslen(LPCOLESTR x) { return lstrlenW(x); }
	//lstrcpyW doesn't work on Win95, so we do this
	inline OLECHAR* ocscpy(LPOLESTR dest, LPCOLESTR src)
	{return (LPOLESTR) memcpy(dest, src, (lstrlenW(src)+1)*sizeof(WCHAR));}
	//CharNextW doesn't work on Win95 so we use this
	inline LPOLESTR CharNextO(LPCOLESTR lp) {return (LPOLESTR)(lp+1);}
	#define T2COLE(lpa) A2CW(lpa)
	#define T2OLE(lpa) A2W(lpa)
	#define OLE2CT(lpo) W2CA(lpo)
	#define OLE2T(lpo) W2A(lpo)
#endif

#ifdef OLE2ANSI
	inline LPOLESTR A2OLE(LPSTR lp) { return lp;}
	inline LPSTR OLE2A(LPOLESTR lp) { return lp;}
	#define W2OLE W2A
	#define OLE2W A2W
	inline LPCOLESTR A2COLE(LPCSTR lp) { return lp;}
	inline LPCSTR OLE2CA(LPCOLESTR lp) { return lp;}
	#define W2COLE W2CA
	#define OLE2CW A2CW
#else
	inline LPOLESTR W2OLE(LPWSTR lp) { return lp; }
	inline LPWSTR OLE2W(LPOLESTR lp) { return lp; }
	#define A2OLE A2W
	#define OLE2A W2A
	inline LPCOLESTR W2COLE(LPCWSTR lp) { return lp; }
	inline LPCWSTR OLE2CW(LPCOLESTR lp) { return lp; }
	#define A2COLE A2CW
	#define OLE2CA W2CA
#endif

#ifdef _UNICODE
	#define T2A W2A
	#define A2T A2W
	inline LPWSTR T2W(LPTSTR lp) { return lp; }
	inline LPTSTR W2T(LPWSTR lp) { return lp; }
	#define T2CA W2CA
	#define A2CT A2CW
	inline LPCWSTR T2CW(LPCTSTR lp) { return lp; }
	inline LPCTSTR W2CT(LPCWSTR lp) { return lp; }
#else
	#define T2W A2W
	#define W2T W2A
	inline LPSTR T2A(LPTSTR lp) { return lp; }
	inline LPTSTR A2T(LPSTR lp) { return lp; }
	#define T2CW A2CW
	#define W2CT W2CA
	inline LPCSTR T2CA(LPCTSTR lp) { return lp; }
	inline LPCTSTR A2CT(LPCSTR lp) { return lp; }
#endif

#ifndef _ATL_NO_OLEAUT
inline BSTR OLE2BSTR(LPCOLESTR lp) {return ::SysAllocString(lp);}
#if defined(_UNICODE)
// in these cases the default (TCHAR) is the same as OLECHAR
	inline BSTR T2BSTR(LPCTSTR lp) {return ::SysAllocString(lp);}
	inline BSTR A2BSTR(LPCSTR lp) {USES_CONVERSION; return ::SysAllocString(A2COLE(lp));}
	inline BSTR W2BSTR(LPCWSTR lp) {return ::SysAllocString(lp);}
#elif defined(OLE2ANSI)
// in these cases the default (TCHAR) is the same as OLECHAR
	inline BSTR T2BSTR(LPCTSTR lp) {return ::SysAllocString(lp);}
	inline BSTR A2BSTR(LPCSTR lp) {return ::SysAllocString(lp);}
	inline BSTR W2BSTR(LPCWSTR lp) {USES_CONVERSION; return ::SysAllocString(W2COLE(lp));}
#else
	inline BSTR T2BSTR(LPCTSTR lp) {USES_CONVERSION; return ::SysAllocString(T2COLE(lp));}
	inline BSTR A2BSTR(LPCSTR lp) {USES_CONVERSION; return ::SysAllocString(A2COLE(lp));}
	inline BSTR W2BSTR(LPCWSTR lp) {return ::SysAllocString(lp);}
#endif
#endif  // !_ATL_NO_OLEAUT
#endif //!USES_CONVERSION

#pragma pack(pop)

#endif // __ATLBASE_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\atlcom.h ===
// This is a part of the ActiveX Template Library.
// Copyright (C) 1996-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// ActiveX Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// ActiveX Template Library product.

#ifndef __ATLCOM_H__
#define __ATLCOM_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLBASE_H__
	#error atlcom.h requires atlbase.h to be included first
#endif

#pragma pack(push, _ATL_PACKING)

#define MWNO_DEF_IN_TEMPLATES

#ifdef _DEBUG
#define RELEASE_AND_DESTROY() ULONG l = InternalRelease();if (l == 0) delete this; return l
#else
#define RELEASE_AND_DESTROY() if (InternalRelease() == 0) delete this; return 0
#endif

#define offsetofclass(base, derived) ((DWORD)(DWORD_PTR)((base*)((derived*)8))-8)

#ifndef _SYS_GUID_OPERATORS_
inline BOOL InlineIsEqualGUID(REFGUID rguid1, REFGUID rguid2)
{
   return (
	  ((PLONG) &rguid1)[0] == ((PLONG) &rguid2)[0] &&
	  ((PLONG) &rguid1)[1] == ((PLONG) &rguid2)[1] &&
	  ((PLONG) &rguid1)[2] == ((PLONG) &rguid2)[2] &&
	  ((PLONG) &rguid1)[3] == ((PLONG) &rguid2)[3]);
}
#endif

inline BOOL InlineIsEqualUnknown(REFGUID rguid1)
{
   return (
	  ((PLONG) &rguid1)[0] == 0 &&
	  ((PLONG) &rguid1)[1] == 0 &&
#if defined(_MAC) || defined(BIG_ENDIAN)
	  ((PLONG) &rguid1)[2] == 0xC0000000 &&
	  ((PLONG) &rguid1)[3] == 0x00000046);
#else
	  ((PLONG) &rguid1)[2] == 0x000000C0 &&
	  ((PLONG) &rguid1)[3] == 0x46000000);
#endif
}

HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCOLESTR lpszDesc,
	const IID& iid = GUID_NULL, HRESULT hRes = 0);
#ifndef OLE2ANSI
HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCSTR lpszDesc,
	const IID& iid = GUID_NULL, HRESULT hRes = 0);
#endif
HRESULT WINAPI AtlReportError(const CLSID& clsid, UINT nID,
	const IID& iid = GUID_NULL, HRESULT hRes = 0);


#ifndef _ATL_NO_OLEAUT
/////////////////////////////////////////////////////////////////////////////
// CComBSTR
class CComBSTR
{
public:
	BSTR m_str;
	CComBSTR()
	{
		m_str = NULL;
	}
	CComBSTR(int nSize, LPCOLESTR sz = NULL)
	{
		m_str = ::SysAllocStringLen(sz, nSize);
	}
	CComBSTR(LPCOLESTR pSrc)
	{
		m_str = ::SysAllocString(pSrc);
	}
	CComBSTR(const CComBSTR& src)
	{
		m_str = src.Copy();
	}
	CComBSTR& operator=(const CComBSTR& src);
	CComBSTR& operator=(LPCOLESTR pSrc);
#ifndef OLE2ANSI
	CComBSTR(LPCSTR pSrc);
	CComBSTR& operator=(LPCSTR pSrc);
	CComBSTR(int nSize, LPCSTR sz = NULL);
#endif
	~CComBSTR()
	{
		::SysFreeString(m_str);
	}
	operator BSTR() const
	{
		return m_str;
	}
	BSTR* operator&()
	{
		return &m_str;
	}
	BSTR Copy() const
	{
		return ::SysAllocStringLen(m_str, ::SysStringLen(m_str));
	}
	void Attach(BSTR src)
	{
		if (m_str != src)
		{
			::SysFreeString(m_str);
			m_str = src;
		}
	}
	BSTR Detach()
	{
		BSTR s = m_str;
		m_str = NULL;
		return s;
	}
	void Empty()
	{
		::SysFreeString(m_str);
		m_str = NULL;
	}
	BOOL operator!()
	{
		return (m_str == NULL) ? TRUE : FALSE;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CComVariant

class CComVariant : public tagVARIANT
{
public:
	CComVariant() {VariantInit(this);}
	~CComVariant() {VariantClear(this);}
	CComVariant(VARIANT& var)
	{
		VariantInit(this);
		VariantCopy(this, &var);
	}
	CComVariant(LPCOLESTR lpsz)
	{
		VariantInit(this);
		vt = VT_BSTR;
		bstrVal = ::SysAllocString(lpsz);
	}
#ifndef OLE2ANSI
	CComVariant(LPCSTR lpsz);
#endif
	CComVariant(const CComVariant& var)
	{
		VariantInit(this);
		VariantCopy(this, (VARIANT*)&var);
	}
	CComVariant& operator=(const CComVariant& var)
	{
		VariantCopy(this, (VARIANT*)&var);
		return *this;
	}
	CComVariant& operator=(VARIANT& var)
	{
		VariantCopy(this, &var);
		return *this;
	}
	CComVariant& operator=(LPCOLESTR lpsz)
	{
		VariantClear(this);
		vt = VT_BSTR;
		bstrVal = ::SysAllocString(lpsz);
		return *this;
	}
#ifndef OLE2ANSI
	CComVariant& operator=(LPCSTR lpsz);
#endif
};
#endif  // !_ATL_NO_OLEAUT

#ifndef _ATL_NO_SECURITY

/////////////////////////////////////////////////////////////////////////////
// CSecurityDescriptor

class CSecurityDescriptor
{
public:
	CSecurityDescriptor();
	~CSecurityDescriptor();

public:
	HRESULT Attach(PSECURITY_DESCRIPTOR pSelfRelativeSD);
	HRESULT AttachObject(HANDLE hObject);
	HRESULT Initialize();
	HRESULT InitializeFromProcessToken(BOOL bDefaulted = FALSE);
	HRESULT InitializeFromThreadToken(BOOL bDefaulted = FALSE, BOOL bRevertToProcessToken = TRUE);
	HRESULT SetOwner(PSID pOwnerSid, BOOL bDefaulted = FALSE);
	HRESULT SetGroup(PSID pGroupSid, BOOL bDefaulted = FALSE);
	HRESULT Allow(LPCTSTR pszPrincipal, DWORD dwAccessMask);
	HRESULT Deny(LPCTSTR pszPrincipal, DWORD dwAccessMask);
	HRESULT Revoke(LPCTSTR pszPrincipal);

	// utility functions
	// Any PSID you get from these functions should be free()ed
	static HRESULT SetPrivilege(LPCTSTR Privilege, BOOL bEnable = TRUE, HANDLE hToken = NULL);
	static HRESULT GetTokenSids(HANDLE hToken, PSID* ppUserSid, PSID* ppGroupSid);
	static HRESULT GetProcessSids(PSID* ppUserSid, PSID* ppGroupSid = NULL);
	static HRESULT GetThreadSids(PSID* ppUserSid, PSID* ppGroupSid = NULL, BOOL bOpenAsSelf = FALSE);
	static HRESULT CopyACL(PACL pDest, PACL pSrc);
	static HRESULT GetCurrentUserSID(PSID *ppSid);
	static HRESULT GetPrincipalSID(LPCTSTR pszPrincipal, PSID *ppSid);
	static HRESULT AddAccessAllowedACEToACL(PACL *Acl, LPCTSTR pszPrincipal, DWORD dwAccessMask);
	static HRESULT AddAccessDeniedACEToACL(PACL *Acl, LPCTSTR pszPrincipal, DWORD dwAccessMask);
	static HRESULT RemovePrincipalFromACL(PACL Acl, LPCTSTR pszPrincipal);

	operator PSECURITY_DESCRIPTOR()
	{
		return m_pSD;
	}

public:
	PSECURITY_DESCRIPTOR m_pSD;
	PSID m_pOwner;
	PSID m_pGroup;
	PACL m_pDACL;
	PACL m_pSACL;
};

#endif // _ATL_NO_SECURITY

/////////////////////////////////////////////////////////////////////////////
// Connection point helpers
//

HRESULT AtlAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw);
HRESULT AtlUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw);

/////////////////////////////////////////////////////////////////////////////
// IRegister
//

EXTERN_C const IID IID_IRegister;
EXTERN_C const CLSID CLSID_Register;

interface IRegister : public IDispatch
{
	public:
	virtual HRESULT STDMETHODCALLTYPE AddReplacement(
		/* [in] */ BSTR key,
		/* [in] */ BSTR item) = 0;

	virtual HRESULT STDMETHODCALLTYPE ClearReplacements( void) = 0;

	virtual HRESULT STDMETHODCALLTYPE ResourceRegister(
		/* [in] */ BSTR fileName,
		/* [in] */ VARIANT ID,
		/* [in] */ VARIANT type) = 0;

	virtual HRESULT STDMETHODCALLTYPE ResourceUnregister(
		/* [in] */ BSTR fileName,
		/* [in] */ VARIANT ID,
		/* [in] */ VARIANT type) = 0;

	virtual HRESULT STDMETHODCALLTYPE FileRegister(
		/* [in] */ BSTR fileName) = 0;

	virtual HRESULT STDMETHODCALLTYPE FileUnregister(
		/* [in] */ BSTR fileName) = 0;

	virtual HRESULT STDMETHODCALLTYPE StringRegister(
		/* [in] */ BSTR data) = 0;

	virtual HRESULT STDMETHODCALLTYPE StringUnregister(
		/* [in] */ BSTR data) = 0;

	virtual HRESULT STDMETHODCALLTYPE AddKey(
		/* [in] */ BSTR keyName) = 0;

	virtual HRESULT STDMETHODCALLTYPE DeleteKey(
		/* [in] */ BSTR keyName) = 0;

	virtual HRESULT STDMETHODCALLTYPE AddKeyValue(
		/* [in] */ BSTR keyName,
		/* [in] */ BSTR valueName,
		/* [in] */ VARIANT value) = 0;

	virtual HRESULT STDMETHODCALLTYPE GetKeyValue(
		/* [in] */ BSTR keyName,
		/* [in] */ BSTR valueName,
		/* [retval][out] */ VARIANT __RPC_FAR *value) = 0;

	virtual HRESULT STDMETHODCALLTYPE SetKeyValue(
		/* [in] */ BSTR keyName,
		/* [in] */ BSTR valueName,
		/* [in] */ VARIANT value) = 0;
};

/////////////////////////////////////////////////////////////////////////////
// Smart OLE pointers provide automatic AddRef/Release
// CComPtr<IFoo> p;

IUnknown* WINAPI _AtlComPtrAssign(IUnknown** pp, IUnknown* lp);
IUnknown* WINAPI _AtlComQIPtrAssign(IUnknown** pp, IUnknown* lp, REFIID riid);

template <class T>
class CComPtr
{
public:
	typedef T _PtrClass;
	CComPtr() {p=NULL;}
	CComPtr(T* lp)
	{
		if ((p = lp) != NULL)
			p->AddRef();
	}
	CComPtr(const CComPtr<T>& lp)
	{
		if ((p = lp.p) != NULL)
			p->AddRef();
	}
	~CComPtr() {if (p) p->Release();}
	void Release() {if (p) p->Release(); p=NULL;}
	operator T*() {return (T*)p;}
	T& operator*() {_ASSERTE(p!=NULL); return *p; }
	T** operator&() { _ASSERTE(p==NULL); return &p; }
	T* operator->() { _ASSERTE(p!=NULL); return p; }
	T* operator=(T* lp){return (T*)_AtlComPtrAssign((IUnknown**)&p, lp);}
	T* operator=(const CComPtr<T>& lp)
	{
		return (T*)_AtlComPtrAssign((IUnknown**)&p, lp.p);
	}
	BOOL operator!(){return (p == NULL) ? TRUE : FALSE;}
	T* p;
};

//Note: CComQIPtr<IUnknown, &IID_IUnknown> is not meaningful
//      Use CComPtr<IUnknown>
template <class T, const IID* piid>
class CComQIPtr
{
public:
	typedef T _PtrClass;
	CComQIPtr() {p=NULL;}
	CComQIPtr(T* lp)
	{
		if ((p = lp) != NULL)
			p->AddRef();
	}
	CComQIPtr(const CComQIPtr<T,piid>& lp)
	{
		if ((p = lp.p) != NULL)
			p->AddRef();
	}
	// If you get an error that this member is already defined, you are probably
	// using a CComQIPtr<IUnknown, &IID_IUnknown>.  This is not necessary.
	// Use CComPtr<IUnknown>
	CComQIPtr(IUnknown* lp)
	{
		p=NULL;
		if (lp != NULL)
			lp->QueryInterface(*piid, (void **)&p);
	}
	~CComQIPtr() {if (p) p->Release();}
	void Release() {if (p) p->Release(); p=NULL;}
	operator T*() {return p;}
	T& operator*() {_ASSERTE(p!=NULL); return *p; }
	T** operator&() {_ASSERTE(p==NULL); return &p; }
	T* operator->() {_ASSERTE(p!=NULL); return p; }
	T* operator=(T* lp){return (T*)_AtlComPtrAssign((IUnknown**)&p, lp);}
	T* operator=(const CComQIPtr<T,piid>& lp)
	{
		return (T*)_AtlComPtrAssign((IUnknown**)&p, lp.p);
	}
	T* operator=(IUnknown* lp)
	{
		return (T*)_AtlComQIPtrAssign((IUnknown**)&p, lp, *piid);
	}
	BOOL operator!(){return (p == NULL) ? TRUE : FALSE;}
	T* p;
};

void WINAPI AtlFreeMarshalStream(IStream* pStream);
HRESULT WINAPI AtlMarshalPtrInProc(IUnknown* pUnk, const IID& iid, IStream** ppStream);
HRESULT WINAPI AtlUnmarshalPtr(IStream* pStream, const IID& iid, IUnknown** ppUnk);

/////////////////////////////////////////////////////////////////////////////
// COM Objects

#define DECLARE_PROTECT_FINAL_CONSTRUCT()\
	void InternalFinalConstructAddRef() {InternalAddRef();}\
	void InternalFinalConstructRelease() {InternalRelease();}

typedef HRESULT (WINAPI _ATL_CREATORFUNC)(void* pv, REFIID riid, LPVOID* ppv);
typedef HRESULT (WINAPI _ATL_CREATORARGFUNC)(void* pv, REFIID riid, LPVOID* ppv, DWORD dw);

template <class T1>
class CComCreator
{
public:
	static HRESULT WINAPI CreateInstance(void* pv, REFIID riid, LPVOID* ppv)
	{
		_ASSERTE(*ppv == NULL);
		HRESULT hRes = E_OUTOFMEMORY;
		T1* p = NULL;
		ATLTRY(p = new T1(pv))
		if (p != NULL)
		{
			p->SetVoid(pv);
			p->InternalFinalConstructAddRef();
			hRes = p->FinalConstruct();
			p->InternalFinalConstructRelease();
			if (hRes == S_OK)
				hRes = p->QueryInterface(riid, ppv);
			if (hRes != S_OK)
				delete p;
		}
		return hRes;
	}
};

template <HRESULT hr>
class CComFailCreator
{
public:
	static HRESULT WINAPI CreateInstance(void*, REFIID, LPVOID*)
	{
		return hr;
	}
};

template <class T1, class T2>
class CComCreator2
{
public:
	static HRESULT WINAPI CreateInstance(void* pv, REFIID riid, LPVOID* ppv)
	{
		_ASSERTE(*ppv == NULL);
		HRESULT hRes = E_OUTOFMEMORY;
		if (pv == NULL)
			hRes = T1::CreateInstance(NULL, riid, ppv);
		else
			hRes = T2::CreateInstance(pv, riid, ppv);
		return hRes;
	}
};

#define DECLARE_NOT_AGGREGATABLE(x) public:\
	typedef CComCreator2< CComCreator< CComObject<x> >, CComFailCreator<CLASS_E_NOAGGREGATION> > _CreatorClass;
#define DECLARE_AGGREGATABLE(x) public:\
	typedef CComCreator2< CComCreator< CComObject<x> >, CComCreator< CComAggObject<x> > > _CreatorClass;
#define DECLARE_ONLY_AGGREGATABLE(x) public:\
	typedef CComCreator2< CComFailCreator<E_FAIL>, CComCreator< CComAggObject<x> > > _CreatorClass;

struct _ATL_INTMAP_ENTRY
{
	const IID* piid;       // the interface id (IID)
	DWORD dw;
	_ATL_CREATORARGFUNC* pFunc; //NULL:end, 1:offset, n:ptr
};

struct _ATL_CREATORDATA
{
	_ATL_CREATORFUNC* pFunc;
};

template <class Creator>
class _CComCreatorData
{
public:
	static _ATL_CREATORDATA data;
};

template <class Creator>
_ATL_CREATORDATA _CComCreatorData<Creator>::data = {Creator::CreateInstance};

struct _ATL_CACHEDATA
{
	DWORD dwOffsetVar;
	DWORD dwOffsetCS;
	_ATL_CREATORFUNC* pFunc;
};

template <class Creator, DWORD dwVar, DWORD dwCS>
class _CComCacheData
{
public:
	static _ATL_CACHEDATA data;
};

template <class Creator, DWORD dwVar, DWORD dwCS>
_ATL_CACHEDATA _CComCacheData<Creator, dwVar, dwCS>::data = {dwVar, dwCS, Creator::CreateInstance};

struct _ATL_CHAINDATA
{
	DWORD dwOffset;
	const _ATL_INTMAP_ENTRY* (WINAPI *pFunc)();
};

template <class base, class derived>
class _CComChainData
{
public:
	static _ATL_CHAINDATA data;
};

template <class base, class derived>
_ATL_CHAINDATA _CComChainData<base, derived>::data =
	{offsetofclass(base, derived), base::_GetEntries};

template <class T, const CLSID* pclsid>
class CComAggregateCreator
{
public:
	static HRESULT WINAPI CreateInstance(void* pv, REFIID/*riid*/, LPVOID* ppv)
	{
		_ASSERTE(*ppv == NULL);
		_ASSERTE(pv != NULL);
		T* p = (T*) pv;
		// Add the following line to your object if you get a message about
		// GetControllingUnknown() being undefined
		// DECLARE_GET_CONTROLLING_UNKNOWN()
		return CoCreateInstance(*pclsid, p->GetControllingUnknown(), CLSCTX_INPROC, IID_IUnknown, ppv);
	}
};

template <class T>
class CComCachedTearOffCreator
{
public:
	static HRESULT WINAPI CreateInstance(void* pv, REFIID riid, LPVOID* ppv)
	{
		_ASSERTE(pv != NULL);
		T::_OwnerClass* pOwner = (T::_OwnerClass*)pv;
		_ASSERTE(*ppv == NULL);
		HRESULT hRes = E_OUTOFMEMORY;
		CComCachedTearOffObject<T>* p = NULL;
		// Add the following line to your object if you get a message about
		// GetControllingUnknown() being undefined
		// DECLARE_GET_CONTROLLING_UNKNOWN()
		ATLTRY(p = new CComCachedTearOffObject<T>(pOwner->GetControllingUnknown(), pOwner))
		if (p != NULL)
		{
			p->SetVoid(pv);
			p->InternalFinalConstructAddRef();
			hRes = p->FinalConstruct();
			p->InternalFinalConstructRelease();
			if (hRes == S_OK)
				hRes = p->QueryInterface(riid, ppv);
			if (hRes != S_OK)
				delete p;
		}
		return hRes;
	}
};

#ifdef _ATL_DEBUG_QI
#define DEBUG_QI_ENTRY(x) \
		{NULL, \
		(DWORD)_T(#x), \
		(_ATL_CREATORARGFUNC*)0},
#else
#define DEBUG_QI_ENTRY(x)
#endif //_ATL_DEBUG_QI

//If you get a message that FinalConstruct is ambiguous then you need to
// override it in your class and call each base class' version of this
#define BEGIN_COM_MAP(x) public:\
	typedef x _ComMapClass;\
	IUnknown* GetUnknown() { _ASSERTE(_GetEntries()->pFunc == (_ATL_CREATORARGFUNC*)1); \
			return (IUnknown*)((INT_PTR)this+_GetEntries()->dw); } \
	HRESULT _InternalQueryInterface(REFIID iid, void** ppvObject)\
	{return InternalQueryInterface(this, _GetEntries(), iid, ppvObject);}\
	const static _ATL_INTMAP_ENTRY* WINAPI _GetEntries() {\
	static const _ATL_INTMAP_ENTRY _entries[] = { DEBUG_QI_ENTRY(x)

#define DECLARE_GET_CONTROLLING_UNKNOWN() public:\
	virtual IUnknown* GetControllingUnknown() {return GetUnknown();}

#define COM_INTERFACE_ENTRY(x)\
	{&IID_##x, \
	offsetofclass(x, _ComMapClass), \
	(_ATL_CREATORARGFUNC*)1},

#define COM_INTERFACE_ENTRY_IID(iid, x)\
	{&iid,\
	offsetofclass(x, _ComMapClass),\
	(_ATL_CREATORARGFUNC*)1},

#define COM_INTERFACE_ENTRY2(x, x2)\
	{&IID_##x,\
	(DWORD)((x*)(x2*)((_ComMapClass*)8))-8,\
	(_ATL_CREATORARGFUNC*)1},

#define COM_INTERFACE_ENTRY2_IID(iid, x, x2)\
	{&iid,\
	(DWORD)((x*)(x2*)((_ComMapClass*)8))-8,\
	(_ATL_CREATORARGFUNC*)1},

#define COM_INTERFACE_ENTRY_FUNC(iid, dw, func)\
	{&iid, \
	dw, \
	func},

#define COM_INTERFACE_ENTRY_FUNC_BLIND(dw, func)\
	{NULL, \
	dw, \
	func},

#define COM_INTERFACE_ENTRY_TEAR_OFF(iid, x)\
	{&iid,\
	(DWORD)&_CComCreatorData<\
		CComCreator<CComTearOffObject<x, _ComMapClass> >\
		>::data,\
	_Creator},

#define COM_INTERFACE_ENTRY_CACHED_TEAR_OFF(iid, x, punk, cs)\
	{&iid,\
	(DWORD)&_CComCacheData<\
		CComCachedTearOffCreator< x >,\
		(DWORD)offsetof(_ComMapClass, punk),\
		(DWORD)offsetof(_ComMapClass, cs)\
		>::data,\
	_Cache},

#define COM_INTERFACE_ENTRY_AGGREGATE(iid, punk)\
	{&iid,\
	(DWORD)offsetof(_ComMapClass, punk),\
	_Delegate},

#define COM_INTERFACE_ENTRY_AGGREGATE_BLIND(punk)\
	{NULL,\
	(DWORD)offsetof(_ComMapClass, punk),\
	_Delegate},

#define COM_INTERFACE_ENTRY_AUTOAGGREGATE(iid, punk, clsid, cs)\
	{&iid,\
	(DWORD)&_CComCacheData<\
		CComAggregateCreator<_ComMapClass, &clsid>,\
		(DWORD)offsetof(_ComMapClass, punk),\
		(DWORD)offsetof(_ComMapClass, cs)\
		>::data,\
	_Cache},

#define COM_INTERFACE_ENTRY_AUTOAGGREGATE_BLIND(punk, clsid, cs)\
	{NULL,\
	(DWORD)&_CComCacheData<\
		CComAggregateCreator<_ComMapClass, &clsid>,\
		(DWORD)offsetof(_ComMapClass, punk),\
		(DWORD)offsetof(_ComMapClass, cs)\
		>::data,\
	_Cache},

#define COM_INTERFACE_ENTRY_CHAIN(classname)\
	{NULL,\
	(DWORD)&_CComChainData<classname, _ComMapClass>::data,\
	_Chain},

#ifdef _ATL_DEBUG_QI
#define END_COM_MAP()   {NULL, 0, 0}};\
	return &_entries[1];}
#else
#define END_COM_MAP()   {NULL, 0, 0}};\
	return _entries;}
#endif // _ATL_DEBUG_QI

struct _ATL_OBJMAP_ENTRY
{
	const CLSID* pclsid;
	HRESULT (WINAPI *pfnUpdateRegistry)(BOOL bRegister);
	_ATL_CREATORFUNC* pfnGetClassObject;
	_ATL_CREATORFUNC* pfnCreateInstance;
	HRESULT WINAPI RevokeClassObject()
	{
		return CoRevokeClassObject(dwRegister);
	}
	HRESULT WINAPI RegisterClassObject(DWORD dwClsContext, DWORD dwFlags)
	{
		CComPtr<IUnknown> p;
		HRESULT hRes = pfnGetClassObject(pfnCreateInstance, IID_IUnknown, (LPVOID*) &p);
		if (SUCCEEDED(hRes))
			hRes = CoRegisterClassObject(*pclsid, p, dwClsContext, dwFlags, &dwRegister);
		return hRes;
	}
	IUnknown* pCF;
	DWORD dwRegister;
};


#define BEGIN_OBJECT_MAP(x) static _ATL_OBJMAP_ENTRY x[] = {
#define END_OBJECT_MAP()   {NULL, NULL, NULL, NULL}};
#define OBJECT_ENTRY(clsid, class) {&clsid, &class::UpdateRegistry, &class::_ClassFactoryCreatorClass::CreateInstance, &class::_CreatorClass::CreateInstance, NULL, 0},

#define THREADFLAGS_APARTMENT 0x1
#define THREADFLAGS_BOTH 0x2
#define AUTPRXFLAG 0x4

// the functions in this class don't need to be virtual because
// they are called from CComObject
class CComObjectRoot
{
public:
	typedef CComObjectThreadModel _ThreadModel;
	CComObjectRoot()
	{
		m_dwRef = 0L;
	}
	HRESULT FinalConstruct()
	{
		return S_OK;
	}
	void FinalRelease() {}

	ULONG InternalAddRef()
	{
		_ASSERTE(m_dwRef != -1L);
		return _ThreadModel::Increment(&m_dwRef);
	}
	ULONG InternalRelease()
	{
		return _ThreadModel::Decrement(&m_dwRef);
	}
	static HRESULT WINAPI InternalQueryInterface(void* pThis,
		const _ATL_INTMAP_ENTRY* entries, REFIID iid, void** ppvObject);
//Outer funcs
	ULONG OuterAddRef() {return m_pOuterUnknown->AddRef();}
	ULONG OuterRelease() {return m_pOuterUnknown->Release();}
	HRESULT OuterQueryInterface(REFIID iid, void ** ppvObject)
	{return m_pOuterUnknown->QueryInterface(iid, ppvObject);}

	void SetVoid(void*) {}
	void InternalFinalConstructAddRef() {}
	void InternalFinalConstructRelease() {_ASSERTE(m_dwRef == 0);}
	// If this assert occurs, your object has probably been deleted
	// Try using DECLARE_PROTECT_FINAL_CONSTRUCT()

#ifdef _ATL_DEBUG_QI
	static HRESULT DumpIID(REFIID iid, LPCTSTR pszClassName, HRESULT hr);
#endif // _ATL_DEBUG_QI

	static HRESULT WINAPI _Cache(void* pv, REFIID iid, void** ppvObject, DWORD dw);
	static HRESULT WINAPI _Creator(void* pv, REFIID iid, void** ppvObject, DWORD dw);
	static HRESULT WINAPI _Delegate(void* pv, REFIID iid, void** ppvObject, DWORD dw);
	static HRESULT WINAPI _Chain(void* pv, REFIID iid, void** ppvObject, DWORD dw);

	union
	{
		long m_dwRef;
		IUnknown* m_pOuterUnknown;
	};
};

#if defined(_WINDLL) | defined(_USRDLL) | defined(_ATL_DLL_SERVER)
#define DECLARE_CLASSFACTORY_EX(cf) typedef CComCreator< CComObjectCached< cf > > _ClassFactoryCreatorClass;
#else
// don't let class factory refcount influence lock count
#define DECLARE_CLASSFACTORY_EX(cf) typedef CComCreator< CComObjectNoLock< cf > > _ClassFactoryCreatorClass;
#endif
#define DECLARE_CLASSFACTORY() DECLARE_CLASSFACTORY_EX(CComClassFactory)
#define DECLARE_CLASSFACTORY2(lic) DECLARE_CLASSFACTORY_EX(CComClassFactory2<lic>)


#define DECLARE_NO_REGISTRY()\
	static HRESULT WINAPI UpdateRegistry(BOOL /*bRegister*/)\
	{return S_OK;}

#define DECLARE_REGISTRY(class, pid, vpid, nid, flags)\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)\
	{\
		return _Module.UpdateRegistryClass(GetObjectCLSID(), pid, vpid, nid,\
			flags, bRegister);\
	}

#define DECLARE_REGISTRY_RESOURCE(x)\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)\
	{\
	return _Module.UpdateRegistryFromResource(_T(#x), bRegister);\
	}

#define DECLARE_REGISTRY_RESOURCEID(x)\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)\
	{\
	return _Module.UpdateRegistryFromResource(x, bRegister);\
	}

// Statically linking to Registry Ponent
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Must have included atl\ponent\register\static\statreg.cpp and statreg.h
#ifdef _ATL_STATIC_REGISTRY
#define DECLARE_STATIC_REGISTRY_RESOURCE(x)\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)\
	{\
	return _Module.UpdateRegistryFromResourceS(_T(#x), bRegister);\
	}

#define DECLARE_STATIC_REGISTRY_RESOURCEID(x)\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)\
	{\
	return _Module.UpdateRegistryFromResourceS(x, bRegister);\
	}
#endif //_ATL_STATIC_REGISTRY

template<class Base> class CComObject; // fwd decl

template <class Owner>
class CComTearOffObjectBase : public CComObjectRoot
{
public:
	typedef Owner _OwnerClass;
	CComObject<Owner>* m_pOwner;
	CComTearOffObjectBase() {m_pOwner = NULL;}
};

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
template <class Base>
class CComObject : public Base
{
public:
	typedef Base _BaseClass;
	CComObject(void* = NULL)
	{
		_Module.Lock();
	}
	// Set refcount to 1 to protect destruction
	~CComObject(){m_dwRef = 1L; FinalRelease(); _Module.Unlock();}
	//If InternalAddRef or InteralRelease is undefined then your class
	//doesn't derive from CComObjectRoot
	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		RELEASE_AND_DESTROY();
	}
	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}
	static HRESULT WINAPI CreateInstance(CComObject<Base>** pp);
};

template <class Base>
HRESULT WINAPI CComObject<Base>::CreateInstance(CComObject<Base>** pp)
{
	_ASSERTE(pp != NULL);
	HRESULT hRes = E_OUTOFMEMORY;
	CComObject<Base>* p = NULL;
	ATLTRY(p = new CComObject<Base>())
	if (p != NULL)
	{
		p->SetVoid(NULL);
		p->InternalFinalConstructAddRef();
		hRes = p->FinalConstruct();
		p->InternalFinalConstructRelease();
		if (hRes != S_OK)
		{
			delete p;
			p = NULL;
		}
	}
	*pp = p;
	return hRes;
}

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
// CComObjectCached is used primarily for class factories in DLL's
// but it is useful anytime you want to cache an object
template <class Base>
class CComObjectCached : public Base
{
public:
	typedef Base _BaseClass;
	CComObjectCached(void* = NULL){}
	// Set refcount to 1 to protect destruction
	~CComObjectCached(){m_dwRef = 1L; FinalRelease();}
	//If InternalAddRef or InteralRelease is undefined then your class
	//doesn't derive from CComObjectRoot
	STDMETHOD_(ULONG, AddRef)()
	{
		m_csCached.Lock();
		ULONG l = InternalAddRef();
		if (m_dwRef == 2)
			_Module.Lock();
		m_csCached.Unlock();
		return l;
	}
	STDMETHOD_(ULONG, Release)()
	{
		m_csCached.Lock();
		InternalRelease();
		ULONG l = m_dwRef;
		m_csCached.Unlock();
		if (l == 0)
			delete this;
		else if (l == 1)
			_Module.Unlock();
		return l;
	}
	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}
	static HRESULT WINAPI CreateInstance(CComObject<Base>** pp);
	CComGlobalsThreadModel::AutoCriticalSection m_csCached;
};

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
template <class Base>
class CComObjectNoLock : public Base
{
public:
	typedef Base _BaseClass;
	CComObjectNoLock(void* = NULL){}
	// Set refcount to 1 to protect destruction
	~CComObjectNoLock() {m_dwRef = 1L; FinalRelease();}

	//If InternalAddRef or InteralRelease is undefined then your class
	//doesn't derive from CComObjectRoot
	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		RELEASE_AND_DESTROY();
	}
	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}
};

// It is possible for Base not to derive from CComObjectRoot
// However, you will need to provide FinalConstruct and InternalQueryInterface
template <class Base>
class CComObjectGlobal : public Base
{
public:
	typedef Base _BaseClass;
	CComObjectGlobal(void* = NULL){m_hResFinalConstruct = FinalConstruct();}
	~CComObjectGlobal() {FinalRelease();}

	STDMETHOD_(ULONG, AddRef)() {return _Module.Lock();}
	STDMETHOD_(ULONG, Release)(){return _Module.Unlock();}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}
	HRESULT m_hResFinalConstruct;
};

// It is possible for Base not to derive from CComObjectRoot
// However, you will need to provide FinalConstruct and InternalQueryInterface
template <class Base>
class CComObjectStack : public Base
{
public:
	typedef Base _BaseClass;
	CComObjectStack(void* = NULL){m_hResFinalConstruct = FinalConstruct();}
	~CComObjectStack() {FinalRelease();}

	STDMETHOD_(ULONG, AddRef)() {_ASSERTE(FALSE);return 0;}
	STDMETHOD_(ULONG, Release)(){_ASSERTE(FALSE);return 0;}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{_ASSERTE(FALSE);return E_NOINTERFACE;}
	HRESULT m_hResFinalConstruct;
};

//Base is the user's class that derives from CComTearOffObjectBase and whatever
//interfaces the user wants to support on the object
//Owner is the class of object that Base is a tear-off for
template <class Base, class Owner>
class CComTearOffObject : public Base
{
public:
	typedef Base _BaseClass;
	CComTearOffObject(void* p)
	{
		m_pOwner = reinterpret_cast<CComObject<Owner>*>(p);
		m_pOwner->AddRef();
	}
	// Set refcount to 1 to protect destruction
	~CComTearOffObject(){m_dwRef = 1L; FinalRelease(); m_pOwner->Release();}

	//If InternalAddRef or InteralRelease is undefined then your class
	//doesn't derive from CComObjectRoot
	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		RELEASE_AND_DESTROY();
	}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{
		if (InlineIsEqualUnknown(iid) ||
			FAILED(_InternalQueryInterface(iid, ppvObject)))
		{
			return m_pOwner->QueryInterface(iid, ppvObject);
		}
		return S_OK;
	}
};

template <class Base> //Base must be derived from CComObjectRoot
class CComContainedObject : public Base
{
public:
	typedef Base _BaseClass;
	CComContainedObject(void* pv) {m_pOuterUnknown = (IUnknown*)pv;}

	STDMETHOD_(ULONG, AddRef)() {return OuterAddRef();}
	STDMETHOD_(ULONG, Release)() {return OuterRelease();}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return OuterQueryInterface(iid, ppvObject);}
	//GetControllingUnknown may be virtual if the Base class has declared
	//DECLARE_GET_CONTROLLING_UNKNOWN()
	IUnknown* GetControllingUnknown() {return m_pOuterUnknown;}
};

//contained is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
template <class contained>
class CComAggObject : public IUnknown, public CComObjectRoot
{
public:
	typedef contained _BaseClass;
	CComAggObject(void* pv) : m_contained(pv)
	{_Module.Lock();}
	//If you get a message that this call is ambiguous then you need to
	// override it in your class and call each base class' version of this
	HRESULT FinalConstruct() {CComObjectRoot::FinalConstruct(); return m_contained.FinalConstruct();}
	void FinalRelease() {CComObjectRoot::FinalRelease(); m_contained.FinalRelease();}
	// Set refcount to 1 to protect destruction
	~CComAggObject(){m_dwRef = 1L; FinalRelease(); _Module.Unlock();}

	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		RELEASE_AND_DESTROY();
	}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{
		HRESULT hRes = S_OK;
		if (InlineIsEqualUnknown(iid))
		{
			*ppvObject = (void*)(IUnknown*)this;
			AddRef();
		}
		else
			hRes = m_contained._InternalQueryInterface(iid, ppvObject);
		return hRes;
	}
	CComContainedObject<contained> m_contained;
};

template <class contained>
class CComCachedTearOffObject : public IUnknown, public CComObjectRoot
{
public:
	typedef contained _BaseClass;
	CComCachedTearOffObject(void* pv, typename contained::_OwnerClass* pOwner) : m_contained(pv)
	{
		_ASSERTE(m_contained.m_pOwner == NULL);
		m_contained.m_pOwner = reinterpret_cast<CComObject<contained::_OwnerClass>*>(pOwner);
	}
	//If you get a message that this call is ambiguous then you need to
	// override it in your class and call each base class' version of this
	HRESULT FinalConstruct() {CComObjectRoot::FinalConstruct(); return m_contained.FinalConstruct();}
	void FinalRelease() {CComObjectRoot::FinalRelease(); m_contained.FinalRelease();}
	// Set refcount to 1 to protect destruction
	~CComCachedTearOffObject(){m_dwRef = 1L; FinalRelease();}

	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		RELEASE_AND_DESTROY();
	}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{
		HRESULT hRes = S_OK;
		if (InlineIsEqualUnknown(iid))
		{
			*ppvObject = (void*)(IUnknown*)this;
			AddRef();
		}
		else
			hRes = m_contained._InternalQueryInterface(iid, ppvObject);
		return hRes;
	}
	CComContainedObject<contained> m_contained;
};

class CComClassFactory : public IClassFactory, public CComObjectRoot
{
public:
	// This typedef is because class factories are globally held
	typedef CComGlobalsThreadModel _ThreadModel;
BEGIN_COM_MAP(CComClassFactory)
	COM_INTERFACE_ENTRY(IClassFactory)
END_COM_MAP()
	// IClassFactory
	STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj);
	STDMETHOD(LockServer)(BOOL fLock);
	// helper
	void SetVoid(void* pv)
	{
		m_pfnCreateInstance = (_ATL_CREATORFUNC*)pv;
	}
	_ATL_CREATORFUNC* m_pfnCreateInstance;
};

class CComClassFactory2Base : public IClassFactory2, public CComObjectRoot
{
public:
	// This typedef is because class factories are globally held
	typedef CComGlobalsThreadModel _ThreadModel;
BEGIN_COM_MAP(CComClassFactory2Base)
	COM_INTERFACE_ENTRY(IClassFactory)
	COM_INTERFACE_ENTRY(IClassFactory2)
END_COM_MAP()
	// IClassFactory
	STDMETHOD(LockServer)(BOOL fLock);
	// helper
	void SetVoid(void* pv)
	{
		m_pfnCreateInstance = (_ATL_CREATORFUNC*)pv;
	}
	_ATL_CREATORFUNC* m_pfnCreateInstance;
};

template <class license>
class CComClassFactory2 : public CComClassFactory2Base, license
{
public:
	typedef license _LicenseClass;
	typedef CComClassFactory2<license> _ComMapClass;
	// IClassFactory
	STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
		REFIID riid, void** ppvObj)
	{
		_ASSERTE(m_pfnCreateInstance != NULL);
		if (ppvObj == NULL)
			return E_POINTER;
		*ppvObj = NULL;
		if (!IsLicenseValid())
			return CLASS_E_NOTLICENSED;

		if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
			return CLASS_E_NOAGGREGATION;
		else
			return m_pfnCreateInstance(pUnkOuter, riid, ppvObj);
	}
	// IClassFactory2
	STDMETHOD(CreateInstanceLic)(IUnknown* pUnkOuter, IUnknown* pUnkReserved,
				REFIID riid, BSTR bstrKey, void** ppvObject)
	{
		_ASSERTE(m_pfnCreateInstance != NULL);
		if (ppvObject == NULL)
			return E_POINTER;
		*ppvObject = NULL;
		if ( ((bstrKey != NULL) && !VerifyLicenseKey(bstrKey)) ||
			 ((bstrKey == NULL) && !IsLicenseValid()) )
			return CLASS_E_NOTLICENSED;
		return m_pfnCreateInstance(pUnkOuter, riid, ppvObject);
	}
	STDMETHOD(RequestLicKey)(DWORD dwReserved, BSTR* pbstrKey)
	{
		if (pbstrKey == NULL)
			return E_POINTER;
		*pbstrKey = NULL;

		if (!IsLicenseValid())
			return CLASS_E_NOTLICENSED;
		return GetLicenseKey(dwReserved,pbstrKey) ? S_OK : E_FAIL;
	}
	STDMETHOD(GetLicInfo)(LICINFO* pLicInfo)
	{
		if (pLicInfo == NULL)
			return E_POINTER;
		pLicInfo->cbLicInfo = sizeof(LICINFO);
		pLicInfo->fLicVerified = IsLicenseValid();
		BSTR bstr = NULL;
		pLicInfo->fRuntimeKeyAvail = GetLicenseKey(0,&bstr);
		::SysFreeString(bstr);
		return S_OK;
	}
};

template <class T, const CLSID* pclsid>
class CComCoClass
{
public:
	DECLARE_CLASSFACTORY()
	DECLARE_AGGREGATABLE(T)
	typedef T _CoClass;
	static const CLSID& WINAPI GetObjectCLSID() {return *pclsid;}
	static HRESULT WINAPI Error(LPCOLESTR lpszDesc,
		const IID& iid = GUID_NULL, HRESULT hRes = 0)
	{return AtlReportError(GetObjectCLSID(), lpszDesc, iid, hRes);}
	static HRESULT WINAPI Error(UINT nID, const IID& iid = GUID_NULL,
		HRESULT hRes = 0)
	{return AtlReportError(GetObjectCLSID(), nID, iid, hRes);}
#ifndef OLE2ANSI
	static HRESULT WINAPI Error(LPCSTR lpszDesc,
		const IID& iid = GUID_NULL, HRESULT hRes = 0)
	{return AtlReportError(GetObjectCLSID(), lpszDesc, iid, hRes);}
#endif
};

// ATL doesn't support multiple LCID's at the same time
// Whatever LCID is queried for first is the one that is used.
class CComTypeInfoHolder
{
// Should be 'protected' but can cause compiler to generate fat code.
public:
	const GUID* m_pguid;
	const GUID* m_plibid;
	WORD m_wMajor;
	WORD m_wMinor;

	ITypeInfo* m_pInfo;
	long m_dwRef;

public:
	HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo);

	void AddRef();
	void Release();
	HRESULT GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
	HRESULT GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
		LCID lcid, DISPID* rgdispid);
	HRESULT Invoke(IDispatch* p, DISPID dispidMember, REFIID riid,
		LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
		EXCEPINFO* pexcepinfo, UINT* puArgErr);
};

#ifndef MWNO_DEF_IN_TEMPLATES
template <class T, const IID* piid, const GUID* plibid, WORD wMajor = 1,
WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
#else
template <class T, const IID* piid, const GUID* plibid, WORD wMajor,
WORD wMinor, class tihclass>
#endif
class CComDualImpl : public T
{
public:
	typedef tihclass _tihclass;
	CComDualImpl() {_tih.AddRef();}
	~CComDualImpl() {_tih.Release();}

	STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
	{*pctinfo = 1; return S_OK;}

	STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
	{return _tih.GetTypeInfo(itinfo, lcid, pptinfo);}

	STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
		LCID lcid, DISPID* rgdispid)
	{return _tih.GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);}

	STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
		LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
		EXCEPINFO* pexcepinfo, UINT* puArgErr)
	{return _tih.Invoke((IDispatch*)this, dispidMember, riid, lcid,
		wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);}
protected:
	static _tihclass _tih;
	static HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo)
	{return _tih.GetTI(lcid, ppInfo);}
};
#ifndef MWNO_DEF_IN_TEMPLATES
template <class T, const IID* piid, const GUID* plibid, WORD wMajor = 1,
WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
#else
template <class T, const IID* piid, const GUID* plibid, WORD wMajor,
WORD wMinor, class tihclass>
#endif
typename CComDualImpl<T, piid, plibid, wMajor, wMinor, tihclass>::_tihclass
CComDualImpl<T, piid, plibid, wMajor, wMinor, tihclass>::_tih =
{piid, plibid, wMajor, wMinor, NULL, 0};

#ifndef MWNO_DEF_IN_TEMPLATES
template <const CLSID* pcoclsid, const IID* psrcid, const GUID* plibid,
WORD wMajor = 1, WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
#else
template <const CLSID* pcoclsid, const IID* psrcid, const GUID* plibid,
WORD wMajor, WORD wMinor, class tihclass >
#endif
class CComProvideClassInfo2Impl : public IProvideClassInfo2
{
public:
	typedef tihclass _tihclass;
	CComProvideClassInfo2Impl() {_tih.AddRef();}
	~CComProvideClassInfo2Impl() {_tih.Release();}

	STDMETHOD(GetClassInfo)(ITypeInfo** pptinfo)
	{
		return _tih.GetTypeInfo(0, LANG_NEUTRAL, pptinfo);
	}
	STDMETHOD(GetGUID)(DWORD dwGuidKind, GUID* pGUID)
	{
		if (pGUID == NULL)
			return E_POINTER;

		if (dwGuidKind == GUIDKIND_DEFAULT_SOURCE_DISP_IID && psrcid)
		{
			*pGUID = *psrcid;
			return S_OK;
		}
		*pGUID = GUID_NULL;
		return E_FAIL;
	}

protected:
	static _tihclass _tih;
};

#ifndef MWNO_DEF_IN_TEMPLATES
template <const CLSID* pcoclsid, const IID* psrcid, const GUID* plibid,
WORD wMajor = 1, WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
#else
template <const CLSID* pcoclsid, const IID* psrcid, const GUID* plibid,
WORD wMajor , WORD wMinor , class tihclass >
#endif
typename CComProvideClassInfo2Impl<pcoclsid, psrcid, plibid, wMajor, wMinor, tihclass>::_tihclass
CComProvideClassInfo2Impl<pcoclsid, psrcid, plibid, wMajor, wMinor, tihclass>::_tih =
{pcoclsid,plibid, wMajor, wMinor, NULL, 0};


/////////////////////////////////////////////////////////////////////////////
// CISupportErrorInfo

template <const IID* piid>
class CComISupportErrorInfoImpl : public ISupportErrorInfo
{
public:
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid)\
	{return (InlineIsEqualGUID(riid,*piid)) ? S_OK : S_FALSE;}
};


/////////////////////////////////////////////////////////////////////////////
// CComEnumImpl

// These _CopyXXX classes are used with enumerators in order to control
// how enumerated items are initialized, copied, and deleted

// Default is shallow copy with no special init or cleanup
template <class T>
class _Copy
{
public:
	static void copy(T* p1, T* p2) {memcpy(p1, p2, sizeof(T));}
	static void init(T*) {}
	static void destroy(T*) {}
};

#if _MSC_VER >= 1100 && defined(__BOOL_DEFINED)
template <>
#endif
class _Copy<VARIANT>
{
public:
	static void copy(VARIANT* p1, VARIANT* p2) {VariantCopy(p1, p2);}
	static void init(VARIANT* p) {VariantInit(p);}
	static void destroy(VARIANT* p) {VariantClear(p);}
};

#if _MSC_VER >= 1100 && defined(__BOOL_DEFINED)
template <>
#endif
class _Copy<LPOLESTR>
{
public:
	static void copy(LPOLESTR* p1, LPOLESTR* p2)
	{
		(*p1) = (LPOLESTR)CoTaskMemAlloc(sizeof(OLECHAR)*(ocslen(*p2)+1));
		ocscpy(*p1,*p2);
	}
	static void init(LPOLESTR* p) {*p = NULL;}
	static void destroy(LPOLESTR* p) { CoTaskMemFree(*p);}
};

#if _MSC_VER >= 1100 && defined(__BOOL_DEFINED)
template <>
#endif
class _Copy<OLEVERB>
{
public:
	static void copy(OLEVERB* p1, OLEVERB* p2)
	{
		*p1 = *p2;
		if (p1->lpszVerbName == NULL)
			return;
		p1->lpszVerbName = (LPOLESTR)CoTaskMemAlloc(sizeof(OLECHAR)*(ocslen(p2->lpszVerbName)+1));
		ocscpy(p1->lpszVerbName,p2->lpszVerbName);
	}
	static void init(OLEVERB* p) { p->lpszVerbName = NULL;}
	static void destroy(OLEVERB* p) { if (p->lpszVerbName) CoTaskMemFree(p->lpszVerbName);}
};

#if _MSC_VER >= 1100 && defined(__BOOL_DEFINED)
template <>
#endif
class _Copy<CONNECTDATA>
{
public:
	static void copy(CONNECTDATA* p1, CONNECTDATA* p2)
	{
		*p1 = *p2;
		if (p1->pUnk)
			p1->pUnk->AddRef();
	}
	static void init(CONNECTDATA* ) {}
	static void destroy(CONNECTDATA* p) {if (p->pUnk) p->pUnk->Release();}
};

template <class T>
class _CopyInterface
{
public:
	static void copy(T** p1, T** p2)
	{*p1 = *p2;if (*p1) (*p1)->AddRef();}
	static void init(T** ) {}
	static void destroy(T** p) {if (*p) (*p)->Release();}
};

template<class T>
class CComIEnum : public IUnknown
{
public:
	STDMETHOD(Next)(ULONG celt, T* rgelt, ULONG* pceltFetched) = 0;
	STDMETHOD(Skip)(ULONG celt) = 0;
	STDMETHOD(Reset)(void) = 0;
	STDMETHOD(Clone)(CComIEnum<T>** ppEnum) = 0;
};


enum CComEnumFlags
{
	//see FlagBits in CComEnumImpl
	AtlFlagNoCopy = 0,
	AtlFlagTakeOwnership = 2,
	AtlFlagCopy = 3 // copy implies ownership
};

template <class Base, const IID* piid, class T, class Copy>
class CComEnumImpl : public Base
{
public:
	CComEnumImpl() {m_begin = m_end = m_iter = NULL; m_dwFlags = 0; m_pUnk = NULL;}
	~CComEnumImpl();
	STDMETHOD(Next)(ULONG celt, T* rgelt, ULONG* pceltFetched);
	STDMETHOD(Skip)(ULONG celt);
	STDMETHOD(Reset)(void){m_iter = m_begin;return S_OK;}
	STDMETHOD(Clone)(Base** ppEnum);
	HRESULT Init(T* begin, T* end, IUnknown* pUnk,
		CComEnumFlags flags = AtlFlagNoCopy);
	IUnknown* m_pUnk;
	T* m_begin;
	T* m_end;
	T* m_iter;
	DWORD m_dwFlags;
protected:
	enum FlagBits
	{
		BitCopy=1,
		BitOwn=2
	};
};

template <class Base, const IID* piid, class T, class Copy>
CComEnumImpl<Base, piid, T, Copy>::~CComEnumImpl()
{
	if (m_dwFlags & BitOwn)
	{
		for (T* p = m_begin; p != m_end; p++)
			Copy::destroy(p);
		delete [] m_begin;
	}
	if (m_pUnk)
		m_pUnk->Release();
}

template <class Base, const IID* piid, class T, class Copy>
STDMETHODIMP CComEnumImpl<Base, piid, T, Copy>::Next(ULONG celt, T* rgelt,
	ULONG* pceltFetched)
{
	if (rgelt == NULL || (celt != 1 && pceltFetched == NULL))
		return E_POINTER;
	if (m_begin == NULL || m_end == NULL || m_iter == NULL)
		return E_FAIL;
	ULONG nRem = (ULONG)(m_end - m_iter);
	HRESULT hRes = S_OK;
	if (nRem < celt)
		hRes = S_FALSE;
	ULONG nMin = min(celt, nRem);
	if (pceltFetched != NULL)
		*pceltFetched = nMin;
	while(nMin--)
		Copy::copy(rgelt++, m_iter++);
	return hRes;
}

template <class Base, const IID* piid, class T, class Copy>
STDMETHODIMP CComEnumImpl<Base, piid, T, Copy>::Skip(ULONG celt)
{
	m_iter += celt;
	if (m_iter < m_end)
		return S_OK;
	m_iter = m_end;
	return S_FALSE;
}

template <class Base, const IID* piid, class T, class Copy>
STDMETHODIMP CComEnumImpl<Base, piid, T, Copy>::Clone(Base** ppEnum)
{
	typedef CComObject<CComEnum<Base, piid, T, Copy> > _class;
	HRESULT hRes = E_POINTER;
	if (ppEnum != NULL)
	{
		_class* p = NULL;
		ATLTRY(p = new _class)
		if (p == NULL)
		{
			*ppEnum = NULL;
			hRes = E_OUTOFMEMORY;
		}
		else
		{
			// If the data is a copy then we need to keep "this" object around
			hRes = p->Init(m_begin, m_end, (m_dwFlags & BitCopy) ? this : m_pUnk);
			if (FAILED(hRes))
				delete p;
			else
			{
				p->m_iter = m_iter;
				hRes = p->_InternalQueryInterface(*piid, (void**)ppEnum);
				if (FAILED(hRes))
					delete p;
			}
		}
	}
	return hRes;
}

template <class Base, const IID* piid, class T, class Copy>
HRESULT CComEnumImpl<Base, piid, T, Copy>::Init(T* begin, T* end, IUnknown* pUnk,
	CComEnumFlags flags)
{
	if (flags == AtlFlagCopy)
	{
		_ASSERTE(m_begin == NULL); //Init called twice?
		ATLTRY(m_begin = new T[end-begin])
		m_iter = m_begin;
		if (m_begin == NULL)
			return E_OUTOFMEMORY;
		for (T* i=begin; i != end; i++)
		{
			Copy::init(m_iter);
			Copy::copy(m_iter++, i);
		}
		m_end = m_begin + (end-begin);
	}
	else
	{
		m_begin = begin;
		m_end = end;
	}
	m_pUnk = pUnk;
	if (m_pUnk)
		m_pUnk->AddRef();
	m_iter = m_begin;
	m_dwFlags = flags;
	return S_OK;
}

template <class Base, const IID* piid, class T, class Copy>
class CComEnum : public CComEnumImpl<Base, piid, T, Copy>, public CComObjectRoot
{
public:
	typedef CComEnum<Base, piid, T, Copy > _CComEnum;
	typedef CComEnumImpl<Base, piid, T, Copy > _CComEnumBase;
	BEGIN_COM_MAP(_CComEnum)
		COM_INTERFACE_ENTRY_IID(*piid, _CComEnumBase)
	END_COM_MAP()
};

#ifndef _ATL_NO_CONNECTION_POINTS
/////////////////////////////////////////////////////////////////////////////
// Connection Points

struct _ATL_CONNMAP_ENTRY
{
	DWORD dwOffset;
};


// We want the offset of the connection point relative to the connection
// point container base class
#define BEGIN_CONNECTION_POINT_MAP(x)\
	typedef x _atl_conn_classtype;\
	virtual const _ATL_CONNMAP_ENTRY* GetConnMap()\
		{ return _StaticGetConnMap(); }\
	static const _ATL_CONNMAP_ENTRY* _StaticGetConnMap() {\
	static const _ATL_CONNMAP_ENTRY _entries[] = {
// CONNECTION_POINT_ENTRY computes the offset of the connection point to the
// IConnectionPointContainer interface
#define CONNECTION_POINT_ENTRY(member){offsetof(_atl_conn_classtype, member)-\
	offsetofclass(IConnectionPointContainer, _atl_conn_classtype)},
#define END_CONNECTION_POINT_MAP() {(DWORD)-1} }; return _entries;}


#ifndef _DEFAULT_VECTORLENGTH
#define _DEFAULT_VECTORLENGTH 4
#endif

template <unsigned int nMaxSize>
class CComStaticArrayCONNECTDATA
{
public:
	CComStaticArrayCONNECTDATA()
	{
		memset(m_arr, 0, sizeof(CONNECTDATA)*nMaxSize);
		m_pCurr = &m_arr[0];
	}
	BOOL Add(IUnknown* pUnk);
	BOOL Remove(DWORD dwCookie);
	CONNECTDATA* begin() {return &m_arr[0];}
	CONNECTDATA* end() {return &m_arr[nMaxSize];}
protected:
	CONNECTDATA m_arr[nMaxSize];
	CONNECTDATA* m_pCurr;
};

template <unsigned int nMaxSize>
inline BOOL CComStaticArrayCONNECTDATA<nMaxSize>::Add(IUnknown* pUnk)
{
	for (CONNECTDATA* p = begin();p<end();p++)
	{
		if (p->pUnk == NULL)
		{
			p->pUnk = pUnk;
			p->dwCookie = (DWORD)pUnk;
			return TRUE;
		}
	}
	return FALSE;
}

template <unsigned int nMaxSize>
inline BOOL CComStaticArrayCONNECTDATA<nMaxSize>::Remove(DWORD dwCookie)
{
	CONNECTDATA* p;
	for (p=begin();p<end();p++)
	{
		if (p->dwCookie == dwCookie)
		{
			p->pUnk = NULL;
			p->dwCookie = NULL;
			return TRUE;
		}
	}
	return FALSE;
}

#if _MSC_VER >= 1100 && defined(__BOOL_DEFINED)
template <>
#endif
class CComStaticArrayCONNECTDATA<1>
{
public:
	CComStaticArrayCONNECTDATA() {m_cd.pUnk = NULL; m_cd.dwCookie = 0;}
	BOOL Add(IUnknown* pUnk)
	{
		if (m_cd.pUnk != NULL)
			return FALSE;
		m_cd.pUnk = pUnk;
		m_cd.dwCookie = (DWORD)pUnk;
		return TRUE;
	}
	BOOL Remove(DWORD dwCookie)
	{
		if (dwCookie != m_cd.dwCookie)
			return FALSE;
		m_cd.pUnk = NULL;
		m_cd.dwCookie = 0;
		return TRUE;
	}
	CONNECTDATA* begin() {return &m_cd;}
	CONNECTDATA* end() {return (&m_cd)+1;}
protected:
	CONNECTDATA m_cd;
};

class CComDynamicArrayCONNECTDATA
{
public:
	CComDynamicArrayCONNECTDATA()
	{
		m_nSize = 0;
		m_pCD = NULL;
	}

	~CComDynamicArrayCONNECTDATA() {free(m_pCD);}
	BOOL Add(IUnknown* pUnk);
	BOOL Remove(DWORD dwCookie);
	CONNECTDATA* begin() {return (m_nSize < 2) ? &m_cd : m_pCD;}
	CONNECTDATA* end() {return (m_nSize < 2) ? (&m_cd)+m_nSize : &m_pCD[m_nSize];}
protected:
	CONNECTDATA* m_pCD;
	CONNECTDATA m_cd;
	int m_nSize;
};

class CComConnectionPointBase : public IConnectionPoint, public CComObjectRoot
{
	typedef CComEnum<IEnumConnections, &IID_IEnumConnections, CONNECTDATA,
		_Copy<CONNECTDATA> > CComEnumConnections;
public:
	CComConnectionPointBase(IConnectionPointContainer* pCont, const IID* piid)
	{
		m_pContainer = pCont;
		m_piid = piid;
	}

	BEGIN_COM_MAP(CComConnectionPointBase)
		COM_INTERFACE_ENTRY(IConnectionPoint)
	END_COM_MAP()

	//Connection point lifetimes are determined by the container
	STDMETHOD_(ULONG, AddRef)() {_ASSERTE(m_pContainer != NULL); return m_pContainer->AddRef();}
	STDMETHOD_(ULONG, Release)(){_ASSERTE(m_pContainer != NULL); return m_pContainer->Release();}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}

	STDMETHOD(GetConnectionInterface)(IID* piid);
	STDMETHOD(GetConnectionPointContainer)(IConnectionPointContainer** ppCPC);

	const IID* GetIID() {return m_piid;}
	void Lock() {m_sec.Lock();}
	void Unlock() {m_sec.Unlock();}
protected:
	const IID* m_piid;
	_ThreadModel::AutoCriticalSection m_sec;
	IConnectionPointContainer* m_pContainer;
	friend class CComConnectionPointContainerImpl;
};

class CComConnectionPointContainerImpl; // fwd decl

template <class CDV = CComDynamicArrayCONNECTDATA>
class CComConnectionPoint : public CComConnectionPointBase
{
	typedef CDV _CDV;
	typedef CComEnum<IEnumConnections, &IID_IEnumConnections, CONNECTDATA,
		_Copy<CONNECTDATA> > CComEnumConnections;
public:
	CComConnectionPoint(IConnectionPointContainer* pCont, const IID* piid) :
		CComConnectionPointBase(pCont, piid) {}

	// interface methods
	STDMETHOD(Advise)(IUnknown* pUnkSink, DWORD* pdwCookie);
	STDMETHOD(Unadvise)(DWORD dwCookie);
	STDMETHOD(EnumConnections)(IEnumConnections** ppEnum);

	_CDV m_vec;
	friend class CComConnectionPointContainerImpl;
};

template <class CDV = CComDynamicArrayCONNECTDATA>
STDMETHODIMP CComConnectionPoint<CDV>::Advise(IUnknown* pUnkSink,
	DWORD* pdwCookie)
{
	IUnknown* p;
	HRESULT hRes = S_OK;
	if (pUnkSink == NULL || pdwCookie == NULL)
		return E_POINTER;
	m_sec.Lock();
	if (SUCCEEDED(pUnkSink->QueryInterface(*m_piid, (void**)&p)))
	{
		*pdwCookie = (DWORD)p;
		hRes = m_vec.Add(p) ? S_OK : CONNECT_E_ADVISELIMIT;
		if (hRes != S_OK)
		{
			*pdwCookie = 0;
			p->Release();
		}
	}
	else
		hRes = CONNECT_E_CANNOTCONNECT;
	m_sec.Unlock();
	return hRes;
}

template <class CDV = CComDynamicArrayCONNECTDATA>
STDMETHODIMP CComConnectionPoint<CDV>::Unadvise(DWORD dwCookie)
{
	m_sec.Lock();
	HRESULT hRes = m_vec.Remove(dwCookie) ? S_OK : CONNECT_E_NOCONNECTION;
	IUnknown* p = (IUnknown*) dwCookie;
	m_sec.Unlock();
	if (hRes == S_OK && p != NULL)
		p->Release();
	return hRes;
}

template <class CDV = CComDynamicArrayCONNECTDATA>
STDMETHODIMP CComConnectionPoint<CDV>::EnumConnections(
	IEnumConnections** ppEnum)
{
	if (ppEnum == NULL)
		return E_POINTER;
	*ppEnum = NULL;
	CComObject<CComEnumConnections>* pEnum = NULL;
	ATLTRY(pEnum = new CComObject<CComEnumConnections>)
	if (pEnum == NULL)
		return E_OUTOFMEMORY;
	m_sec.Lock();
	CONNECTDATA* pcd = NULL;
	ATLTRY(pcd = new CONNECTDATA[m_vec.end()-m_vec.begin()])
	if (pcd == NULL)
	{
		delete pEnum;
		m_sec.Unlock();
		return E_OUTOFMEMORY;
	}
	CONNECTDATA* pend = pcd;
	// Copy the valid CONNECTDATA's
	for (CONNECTDATA* p = m_vec.begin();p<m_vec.end();p++)
	{
		if (p->pUnk != NULL)
		{
			p->pUnk->AddRef();
			*pend++ = *p;
		}
	}
	// don't copy the data, but transfer ownership to it
	pEnum->Init(pcd, pend, NULL, AtlFlagTakeOwnership);
	m_sec.Unlock();
	HRESULT hRes = pEnum->_InternalQueryInterface(IID_IEnumConnections, (void**)ppEnum);
	if (FAILED(hRes))
		delete pEnum;
	return hRes;
}


class CComConnectionPointContainerImpl : public IConnectionPointContainer
{
	typedef CComEnum<IEnumConnectionPoints,
		&IID_IEnumConnectionPoints, IConnectionPoint*,
		_CopyInterface<IConnectionPoint> >
		CComEnumConnectionPoints;
public:

	STDMETHOD(EnumConnectionPoints)(IEnumConnectionPoints** ppEnum);
	STDMETHOD(FindConnectionPoint)(REFIID riid, IConnectionPoint** ppCP);

protected:
	virtual const _ATL_CONNMAP_ENTRY* GetConnMap() = 0;
	CComConnectionPointBase* FindConnPoint(REFIID riid);
	void InitCloneVector(CComConnectionPointBase** ppCP);
};


#endif //!_ATL_NO_CONNECTION_POINTS

#pragma pack(pop)

/////////////////////////////////////////////////////////////////////////////
// CComModule

//Although these functions are big, they are only used once in a module
//so we should make them inline.

inline void CComModule::Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h)
{
	m_pObjMap = p;
	m_hInst = h;
	m_nLockCnt=0L;
	m_hHeap = NULL;
	m_csTypeInfoHolder.Init();
	m_csObjMap.Init();
}

inline HRESULT CComModule::RegisterClassObjects(DWORD dwClsContext, DWORD dwFlags)
{
	_ASSERTE(m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = m_pObjMap;
	HRESULT hRes = S_OK;
	while (pEntry->pclsid != NULL && hRes == S_OK)
	{
		hRes = pEntry->RegisterClassObject(dwClsContext, dwFlags);
		pEntry++;
	}
	return hRes;
}

inline HRESULT CComModule::RevokeClassObjects()
{
	_ASSERTE(m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = m_pObjMap;
	HRESULT hRes = S_OK;
	while (pEntry->pclsid != NULL && hRes == S_OK)
	{
		hRes = pEntry->RevokeClassObject();
		pEntry++;
	}
	return hRes;
}

inline HRESULT CComModule::GetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	_ASSERTE(m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = m_pObjMap;
	HRESULT hRes = S_OK;
	if (ppv == NULL)
		return E_POINTER;
	while (pEntry->pclsid != NULL)
	{
		if (InlineIsEqualGUID(rclsid, *pEntry->pclsid))
		{
			if (pEntry->pCF == NULL)
			{
				m_csObjMap.Lock();
				if (pEntry->pCF == NULL)
					hRes = pEntry->pfnGetClassObject(pEntry->pfnCreateInstance, IID_IUnknown, (LPVOID*)&pEntry->pCF);
				m_csObjMap.Unlock();
			}
			if (pEntry->pCF != NULL)
				hRes = pEntry->pCF->QueryInterface(riid, ppv);
			break;
		}
		pEntry++;
	}
	if (*ppv == NULL && hRes == S_OK)
		hRes = CLASS_E_CLASSNOTAVAILABLE;
	return hRes;
}

inline void CComModule::Term()
{
	_ASSERTE(m_hInst != NULL);
	if (m_pObjMap != NULL)
	{
		_ATL_OBJMAP_ENTRY* pEntry = m_pObjMap;
		while (pEntry->pclsid != NULL)
		{
			if (pEntry->pCF != NULL)
				pEntry->pCF->Release();
			pEntry->pCF = NULL;
			pEntry++;
		}
	}
	m_csTypeInfoHolder.Term();
	m_csObjMap.Term();
	if (m_hHeap != NULL)
		HeapDestroy(m_hHeap);
}

inline HRESULT CComModule::RegisterServer(BOOL bRegTypeLib)
{
	_ASSERTE(m_hInst != NULL);
	_ASSERTE(m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = m_pObjMap;
	HRESULT hRes = S_OK;
	while (pEntry->pclsid != NULL)
	{
		hRes = pEntry->pfnUpdateRegistry(TRUE);
		if (FAILED(hRes))
			break;
		pEntry++;
	}
// KENSY: Remove dependency on OLEAUT
#if 0
	if (SUCCEEDED(hRes) && bRegTypeLib)
		hRes = RegisterTypeLib();
#else
        if (bRegTypeLib)
            return E_FAIL;
#endif	
	return hRes;
}

inline HRESULT CComModule::UnregisterServer()
{
	_ASSERTE(m_hInst != NULL);
	_ASSERTE(m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = m_pObjMap;
	while (pEntry->pclsid != NULL)
	{
		pEntry->pfnUpdateRegistry(FALSE); //unregister
		pEntry++;
	}
	return S_OK;
}

#endif // __ATLCOM_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\atlutil.h ===
// This is a part of the ActiveX Template Library.
// Copyright (C) 1996 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// ActiveX Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// ActiveX Template Library product.

#ifndef __ATLUTIL_H__
#define __ATLUTIL_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#endif // __ATLUTIL_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\utbutton.cxx ===
//+------------------------------------------------------------------
//
// Microsoft IEPEERS
// Copyright (C) Microsoft Corporation, 1999.
//
// File:        iextags\utbutton.cxx
//
// Contents:    Utility Button
//
// Classes:     CUtilityButton
//
// Interfaces:  IUtilityButton
//
//-------------------------------------------------------------------

#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "iextag.h"

#include "utils.hxx"

#include "utbutton.hxx"


#define CheckResult(x) { hr = x; if (FAILED(hr)) goto Cleanup; }

//
//  Not used, but currently required by CBaseCtl...
//

const CBaseCtl::PROPDESC CUtilityButton::s_propdesc[] = 
{
    {_T("vestigial"), VT_BSTR},
    NULL
};

/////////////////////////////////////////////////////////////////////////////
//
// CUtilityButton
//
//  
// Synopsis:    Factory create method.  CUtilityButtons constructor is protected so that this technique should
//              be used to properly initialize the button
//
// Arguments:   Owner control, owner html element, out paramter is the created button
//
/////////////////////////////////////////////////////////////////////////////

HRESULT CUtilityButton::Create(CBaseCtl *pOwnerCtl, IHTMLElement *pOwner, CComObject<CUtilityButton> ** ppButton)
{
    HRESULT hr = S_OK;

    CComObject<CUtilityButton> *pButton;

    CComObject<CUtilityButton>::CreateInstance(&pButton);
    if ( pButton == NULL )
        return NULL;

    hr = pButton->Init(pOwnerCtl, pOwner);
    if(FAILED(hr))
        goto Cleanup;

    *ppButton = pButton;

    return S_OK;

Cleanup:

    if(pButton)
        delete pButton;

    return hr;
}

//+------------------------------------------------------------------------
//
//  Members:    CUtilityButton::CUtilityButton
//              CUtilityButton::~CUtilityButton
//
//  Synopsis:   Constructor/Destructor
//
//-------------------------------------------------------------------------

CUtilityButton::CUtilityButton()
{
    _tx = 0;
    _ty = 0;

    _moving = false;
    _pressing = false;
    _raised = true;
    _abilities = 0;

    _pStyle = NULL;
    _pOwner = NULL;
    _pElement = NULL;

}

CUtilityButton::~CUtilityButton()
{
    ReleaseInterface(_pStyle);
    ReleaseInterface(_pFaceStyle);
    ReleaseInterface(_pOwner);
    ReleaseInterface(_pElement);
    ReleaseInterface(_pFace);
    ReleaseInterface(_pArrow);
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::Init
//
// Synopsis:    Called by factory method during initialization
//
// Arguments:   Owner control, containing html element
//
// Returns:     Success if the control is created correctly.
//
//-------------------------------------------------------------------

HRESULT
CUtilityButton::Init(CBaseCtl *pOwnerCtl, IHTMLElement *pOwner)
{
    HRESULT hr = S_OK;

    _pOwnerCtl = pOwnerCtl;

    _pOwner = pOwner;
    _pOwner->AddRef();

    CheckResult( BuildButton());
    CheckResult( RegisterEvents());

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::RegisterEvents()
//
// Synopsis:    Signs up the button for events its interested in
//
// Arguments:   None
//
// Returns:     Non-S_OK on error
//
//-------------------------------------------------------------------

HRESULT 
CUtilityButton::RegisterEvents()
{
    HRESULT hr = S_OK;
    
    CContextAccess  a(_pElement);

    a.Open(CA_ELEM);

    //
    // Register for events
    //

    CheckResult( AttachEvent(EVENT_ONMOUSEMOVE, &a));
    CheckResult( AttachEvent(EVENT_ONMOUSEDOWN, &a));
    CheckResult( AttachEvent(EVENT_ONMOUSEUP, &a));
    CheckResult( AttachEvent(EVENT_ONMOUSEOUT, &a));
    CheckResult( AttachEvent(EVENT_ONMOUSEOVER, &a));
    CheckResult( AttachEvent(EVENT_ONSELECTSTART, &a));

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::Unload()
//
// Synopsis:    Called to break down connection points.  This is necessary
//              to overcome a problem with circular reference and should be removed
//              when that is fixed.
//
// Arguments:   Names of changes property
//
// Returns:     Non-S_OK on error
//
//-------------------------------------------------------------------

HRESULT  
CUtilityButton::Unload()
{
    HRESULT hr = S_OK;
    IConnectionPointContainer *     pCPC = NULL;
    IConnectionPoint *              pCP = NULL;

    if (_fElementEventSinkConnected)
    {
        CheckResult( _pElement->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC));
        CheckResult( pCPC->FindConnectionPoint(DIID_HTMLElementEvents2, &pCP));
        CheckResult( pCP->Unadvise(_dwCookie));

        _fElementEventSinkConnected = FALSE;
    }

Cleanup:

    ReleaseInterface(pCPC);
    ReleaseInterface(pCP);

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::OnMouseDown()
//
// Synopsis:    Called to handel 'onmousedown' event
//
// Arguments:   Event Object
//
// Returns:     Success if the control is created correctly.
//
//-------------------------------------------------------------------

HRESULT
CUtilityButton::OnMouseDown(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    long clientX, clientY, left, top;

    CComPtr<IHTMLElement2> pElem2;

    CheckResult( _pElement->QueryInterface(IID_IHTMLElement2, (void **) & pElem2));

    if (IS_PRESSABLE(_abilities)) 
    {

        ShowDepressed();

        CheckResult( pElem2->setCapture());

        _pressing = true;

        if( _pfnPressed)
            CheckResult( (_pOwnerCtl->*_pfnPressed)(this));

    }

    if (IS_MOVEABLE(_abilities)) 
    {

		CheckResult( pEvent->EventObj()->get_clientX(&clientX));
		CheckResult( pEvent->EventObj()->get_clientY(&clientY));

        CheckResult( _pStyle->get_pixelTop(&top));
        CheckResult( _pStyle->get_pixelLeft(&left));

        CheckResult( pElem2->setCapture());

        _tx = clientX - left;
        _ty = clientY - top;

        _moving = true;

    }

Cleanup:
    
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::OnMouseMove()
//
// Synopsis:    Called to handle 'onmousemove' event
//
// Arguments:   Event object
//
// Returns:     Success if the control is handled correctly.
//
//-------------------------------------------------------------------

HRESULT
CUtilityButton::OnMouseMove(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;
    long clientX, clientY, left, top;

    if(_moving) 
    {

        CComPtr<IHTMLStyle> pStyle;

        hr = _pElement->get_style(&pStyle);
        if( FAILED(hr))
            goto Cleanup;

        //
        //  Calculate new coordinates
        //

        if( IS_MOVEABLE_X(_abilities)) 
        {

			CheckResult( pEvent->EventObj()->get_clientX(&clientX));

            left = clientX - _tx;

        }

        if( IS_MOVEABLE_Y(_abilities)) 
        {

			CheckResult( pEvent->EventObj()->get_clientY(&clientY));
			
			top  = clientY - _ty;

        }

        //
        //  Check to see if we can move
        //

        if( _pfnMoved)
            CheckResult( (_pOwnerCtl->*_pfnMoved)(this, left, top));

        //
        //  Do the move
        //

        if( IS_MOVEABLE_X(_abilities)) 
        {

            CheckResult( pStyle->put_pixelLeft(left));

        }

        if( IS_MOVEABLE_Y(_abilities)) 
        {

            CheckResult( pStyle->put_pixelTop(top));

        }

    }

    if(_pressing) 
    {
        CComPtr<IHTMLElement> pSrcElement;

        CheckResult( pEvent->Open(EOA_EVENTOBJ));
        CheckResult( pEvent->EventObj()->get_srcElement(&pSrcElement))

        if(IsSameObject(pSrcElement, _pElement) ||
           IsSameObject(pSrcElement, _pFace) ||
           IsSameObject(pSrcElement, _pArrow))
        {
            if(_raised) 
            {
                ShowDepressed();

                if( _pfnPressed)
                    CheckResult( (_pOwnerCtl->*_pfnPressed)(this));
            }
        }
        else
        {
            if(! _raised) 
            {
                ShowRaised();

                if( _pfnPressed)
                    CheckResult( (_pOwnerCtl->*_pfnPressed)(this));
            }
        }
    }

Cleanup:
    
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::OnMouseUp()
//
// Synopsis:    Called to handel 'onmouseup' event
//
// Arguments:   Event object
//
// Returns:     Success if the control handled correctly
//
//-------------------------------------------------------------------

HRESULT
CUtilityButton::OnMouseUp(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLElement2> pElem2;
    CComPtr<IHTMLStyle> pStyle;
    POINT ptClient;

    CheckResult( _pElement->QueryInterface(IID_IHTMLElement2, (void **) &pElem2));

    if(_pressing) 
    {

        _pressing = false;

        CheckResult( pElem2->releaseCapture());

        ShowRaised();

        if( _pfnPressed)
            CheckResult( (_pOwnerCtl->*_pfnPressed)(this));
 
    }

    if(_moving) 
    {
        _moving = false;

        CheckResult( _pElement->get_style(&pStyle));
        CheckResult( pElem2->releaseCapture());
        CheckResult( pEvent->GetWindowCoordinates(&ptClient));
    
        long left = ptClient.x - _tx;
        long top  = ptClient.y - _ty;

        //
        // Let them know we're done moving
        //

        if( _pfnMoved)
            CheckResult( (_pOwnerCtl->*_pfnMoved)(this, left, top));

        //
        //  Do the move
        //

        if( IS_MOVEABLE_X(_abilities)) 
        {

            CheckResult( pStyle->put_pixelLeft(left));

        }

        if( IS_MOVEABLE_Y(_abilities)) 
        {

            CheckResult( pStyle->put_pixelTop(top));

        }
    }


Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::OnMouseOver()
//
// Synopsis:    Called to handle 'onmouseover' event
//
// Arguments:   Event Object
//
// Returns:     Success if the control is created correctly.
//
//-------------------------------------------------------------------

HRESULT
CUtilityButton::OnMouseOver(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLElement> pElement;

	pEvent->EventObj()->get_srcElement(&pElement);

    if(IsSameObject(pElement, _pElement)) 
    {

        if( _pressing ) {
    
            return ShowDepressed();

        }

    }

    return S_OK;
}



//+------------------------------------------------------------------
//
// Member:      CUtilityButton::OnMouseDown()
//
// Synopsis:    Called to handle 'onmouseout' event
//
// Arguments:   Event Object
//
// Returns:     Success if the control is created correctly.
//
//-------------------------------------------------------------------

HRESULT
CUtilityButton::OnMouseOut(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLElement> pElement;

	pEvent->EventObj()->get_srcElement(&pElement);

    if(IsSameObject(pElement, _pElement)) 
    {

        if( _pressing ) {

             return ShowRaised();

        }

    }

    return S_OK;
}


//+------------------------------------------------------------------
//
// Member:      CUtilityButton::OnClick()
//
// Synopsis:    Called to handel 'onclick' event
//
// Arguments:   Names of changes property
//
// Returns:     Success if the control is created correctly.
//
//-------------------------------------------------------------------

HRESULT
CUtilityButton::OnClick(CEventObjectAccess *pEvent)
{
    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::OnSelectStart()
//
// Synopsis:    Called to handel 'OnSelectStart' event
//
// Arguments:   Event object
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------

HRESULT
CUtilityButton::OnSelectStart(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    CheckResult( pEvent->EventObj()->put_cancelBubble( VARIANT_TRUE ));
    CheckResult( pEvent->EventObj()->put_returnValue( CComVariant(false) ));

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::ShowDepressed()
//
// Synopsis:    Called to make the button appear depressed
//
// Arguments:   None
//
// Returns:     Success if the control is pressed.
//
//-------------------------------------------------------------------

HRESULT 
CUtilityButton::ShowDepressed()
{
    HRESULT hr = S_OK;

    CheckResult( _pStyle->put_borderTopColor(_vShadowColor));
    CheckResult( _pStyle->put_borderLeftColor(_vShadowColor));
    CheckResult( _pStyle->put_borderBottomColor(_vShadowColor));
    CheckResult( _pStyle->put_borderRightColor(_vShadowColor));
    
    CheckResult( _pFaceStyle->put_borderTopColor(_vFaceColor));
    CheckResult( _pFaceStyle->put_borderLeftColor(_vFaceColor));
    CheckResult( _pFaceStyle->put_borderBottomColor(_vFaceColor));
    CheckResult( _pFaceStyle->put_borderRightColor(_vFaceColor));

    CheckResult( _pFaceStyle->put_paddingTop(CComVariant("1px")));
    CheckResult( _pFaceStyle->put_paddingLeft(CComVariant("1px")));

    _raised = false;

Cleanup:

    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::ShowDepressed()
//
// Synopsis:    Called to make the button appear depressed
//
// Arguments:   None
//
// Returns:     Success if the control is pressed.
//
//-------------------------------------------------------------------

HRESULT 
CUtilityButton::ShowRaised()
{
    HRESULT hr = S_OK;
    CComBSTR border;

    border = "1px solid";
    CheckResult( _pStyle->put_border(border));
    CheckResult( _pFaceStyle->put_border(border));
    
    CheckResult( _pStyle->put_borderTopColor(_v3dLightColor));
    CheckResult( _pStyle->put_borderLeftColor(_v3dLightColor));
    CheckResult( _pStyle->put_borderBottomColor(_vDarkShadowColor));
    CheckResult( _pStyle->put_borderRightColor(_vDarkShadowColor));
    
    CheckResult( _pFaceStyle->put_borderTopColor(_vHighlightColor));
    CheckResult( _pFaceStyle->put_borderLeftColor(_vHighlightColor));
    CheckResult( _pFaceStyle->put_borderBottomColor(_vShadowColor));
    CheckResult( _pFaceStyle->put_borderRightColor(_vShadowColor));

    CheckResult( _pFaceStyle->put_paddingTop(CComVariant("0px")));
    CheckResult( _pFaceStyle->put_paddingLeft(CComVariant("0px")));

    _raised = true;

Cleanup:

    return S_OK;
}


//+------------------------------------------------------------------
//
// Member:      CUtilityButton::ShowDisabled()
//
// Synopsis:    Called to make the button appear disabled
//
// Arguments:   None
//
// Returns:     Success if the control is correctly rendered.
//
//-------------------------------------------------------------------

HRESULT 
CUtilityButton::ShowDisabled()
{
    return S_OK;
}


//+------------------------------------------------------------------
//
// Member:      CUtilityButton::BuildButton()
//
// Synopsis:    Builds the button from html elements
//
// Arguments:   None
//
// Returns:     Success if the control is correctly rendered.
//
//-------------------------------------------------------------------

HRESULT
CUtilityButton::BuildButton()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLStyle2>    pStyle2;

    //
    // Get the document
    //

    CheckResult( _pOwner->get_document((IDispatch**) &pDoc));

    //
    // Create the button outline and get a few interfaces to use with it
    //

    CheckResult( pDoc->createElement(CComBSTR("DIV"), &_pElement));
    CheckResult( _pElement->get_style(&_pStyle));

    CheckResult( AppendChild(_pOwner, _pElement));

    CheckResult( _pStyle->put_display(CComBSTR("inline")));
    CheckResult( _pStyle->put_overflow(CComBSTR("hidden")));

    CheckResult( pDoc->createElement(CComBSTR("DIV"), &_pFace));
    CheckResult( _pFace->get_style(&_pFaceStyle));

    CheckResult( _pFaceStyle->put_display(CComBSTR("inline")));
    CheckResult( _pFaceStyle->put_overflow(CComBSTR("hidden")));

    CheckResult( AppendChild(_pElement, _pFace));



    ShowRaised();
    
Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CUtilityButton::BuildArrow()
//
// Synopsis:    Creates a container for an arrow character on the button face
//
// Arguments:   None
//
// Returns:     Success if the control is correctly rendered.
//
//-------------------------------------------------------------------

HRESULT 
CUtilityButton::BuildArrow()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2>   pDoc;
    CComPtr<IHTMLStyle>       pStyle;

    CComBSTR bstr;

    //
    // Get the document, build and append element
    //

    CheckResult( _pOwner->get_document((IDispatch**) &pDoc));
    CheckResult( pDoc->createElement(CComBSTR("font"), &_pArrow));
    CheckResult( AppendChild(_pFace, _pArrow));

    //
    //  Set up the font element (scope this stuff incase anything above fails)
    //

    CheckResult( _pArrow->get_style(&pStyle));

    bstr = _T("default");
    CheckResult( pStyle->put_cursor( bstr ));

    bstr = _T("Marlett");
    CheckResult( pStyle->put_fontFamily( bstr ));

    bstr = _T("center");
    CheckResult( pStyle->put_textAlign( bstr ));

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::SetHeight()
//
// Synopsis:    Sets the height
//
// Arguments:   height
//
// Returns:     Success if the control is correctly rendered.
//
//-------------------------------------------------------------------

HRESULT 
CUtilityButton::SetHeight(long height)
{
    HRESULT hr = S_OK;

    CheckResult( _pStyle->put_pixelHeight(height));
    CheckResult( _pFaceStyle->put_pixelHeight(max(height - 2, 0)));

    if(_pArrow) 
    {

        CheckResult( SetArrowSize());

    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::SetWidth()
//
// Synopsis:    Sets the width
//
// Arguments:   width
//
// Returns:     Success if the control is correctly rendered.
//
//-------------------------------------------------------------------

HRESULT 
CUtilityButton::SetWidth(long width)
{
    HRESULT hr = S_OK;

    CheckResult( _pStyle->put_pixelWidth(width));
    CheckResult( _pFaceStyle->put_pixelWidth( max(width - 2, 0)));

    if(_pArrow) 
    {

        CheckResult( SetArrowSize());

    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::SetHTML()
//
// Synopsis:    Sets the innerHTML
//
// Arguments:   an HTML string
//
// Returns:     Success if the control is correctly rendered.
//
//-------------------------------------------------------------------

HRESULT    
CUtilityButton::SetArrowStyle(unsigned style)
{
    HRESULT hr = S_OK;

    CComBSTR bstr;

    if(_pArrow == NULL) 
    {

        CheckResult( BuildArrow());

    }

    switch (style) 
    {
        case BUTTON_ARROW_UP:
            bstr = _T("5");
            break;
        case BUTTON_ARROW_DOWN:
            bstr = _T("6");
            break;
        case BUTTON_ARROW_LEFT:
            bstr = _T("3");
            break;
        case BUTTON_ARROW_RIGHT:
            bstr = _T("4");
            break;
        default:
            Assert(false);
            break;
    };

    CheckResult( _pArrow->put_innerText(bstr));

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::SetArrowSize()
//
// Synopsis:    Sets the size of the arrow.  The arrow is represented by a single
//              character whose font size needs to be the min of the button width and height,
//              minus the border size.
//
// Arguments:   None
//
// Returns:     Success if the fontSize is set correctly.
//
//-------------------------------------------------------------------

HRESULT    
CUtilityButton::SetArrowSize()
{
    HRESULT hr = S_OK;

    CContextAccess a(_pArrow);
    CContextAccess f(_pElement);

    long height, width;
    CComVariant fontSize;

    a.Open( CA_STYLE );
    f.Open( CA_STYLE );

    CheckResult( f.Style()->get_pixelWidth(&width));
    CheckResult( f.Style()->get_pixelHeight(&height));
 
    //
    //  We need to account for the 2 pixel border on both sides
    //  so subtract 2 * 2 pixels (but don't go below 0!)
    //

    fontSize = max( min(width, height) - 4, 0);

    CheckResult( a.Style()->put_fontSize(fontSize));

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::SetArrowColor()
//
// Synopsis:    Sets the color of the character that represents the actual arrow inside of the button.
//
// Arguments:   None
//
// Returns:     Success if the color is set correctly.
//
//-------------------------------------------------------------------

HRESULT    
CUtilityButton::SetArrowColor(VARIANT color)
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLFontElement> pFont;

    if( _pArrow) 
    {
        CheckResult( _pArrow->QueryInterface( __uuidof(IHTMLFontElement), (void **) &pFont));
        CheckResult( pFont->put_color(color));
    }

Cleanup:

    return hr;
}

HRESULT    
CUtilityButton::Set3DLightColor(VARIANT color)
{
    HRESULT hr;

    CheckResult( ::VariantCopy(&_v3dLightColor, &color));

    if(_pStyle) 
    {
        CheckResult( _pStyle->put_borderTopColor( _v3dLightColor ));
        CheckResult( _pStyle->put_borderLeftColor( _v3dLightColor ));
    }

Cleanup:

    return S_OK;
}

HRESULT    
CUtilityButton::SetDarkShadowColor(VARIANT color)
{
    HRESULT hr = S_OK;

    CheckResult( ::VariantCopy(&_vDarkShadowColor, &color));

    if(_pStyle) 
    {
        CheckResult( _pStyle->put_borderBottomColor( _vDarkShadowColor ));
        CheckResult( _pStyle->put_borderRightColor( _vDarkShadowColor ));
    }

Cleanup:

    return S_OK;
}

HRESULT    
CUtilityButton::SetShadowColor(VARIANT color)
{
    HRESULT hr = S_OK;

    CheckResult( ::VariantCopy(&_vShadowColor, &color));

    if(_pStyle) 
    {
        CheckResult( _pFaceStyle->put_borderBottomColor( _vShadowColor ));
        CheckResult( _pFaceStyle->put_borderRightColor( _vShadowColor ));
    }

Cleanup:

    return S_OK;
}

HRESULT    
CUtilityButton::SetHighlightColor(VARIANT color)
{
    HRESULT hr = S_OK;

    CheckResult( ::VariantCopy(&_vHighlightColor, &color));

    if(_pStyle) 
    {
        CheckResult( _pFaceStyle->put_borderTopColor( _vHighlightColor ));
        CheckResult( _pFaceStyle->put_borderLeftColor( _vHighlightColor ));
    }

Cleanup:

    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::SetFaceColor()
//
// Synopsis:    Sets the color of the character that represents the actual arrow inside of the button.
//
// Arguments:   None
//
// Returns:     Success if the color is set correctly.
//
//-------------------------------------------------------------------

HRESULT    
CUtilityButton::SetFaceColor(VARIANT color)
{
    HRESULT hr = S_OK;

    CheckResult( ::VariantCopy(&_vFaceColor, &color));

    if(_pStyle) 
    {
        CheckResult( _pFaceStyle->put_backgroundColor(color));
    }

Cleanup:

    return S_OK;
}


//+------------------------------------------------------------------
//
// Member:      CUtilityButton::SetAbilities()
//
// Synopsis:    Sets the abilities attribute
//
// Arguments:   a flag
//
// Returns:     Success if the control is correctly rendered.
//
//-------------------------------------------------------------------

HRESULT    
CUtilityButton::SetAbilities(unsigned abilities)
{
    HRESULT hr = S_OK;

    _abilities = abilities;

    if (IS_MOVEABLE(_abilities)) 
    {

        CComPtr<IHTMLStyle2> pStyle2;

        CheckResult( _pStyle->QueryInterface(IID_IHTMLStyle2, (void **) &pStyle2));
        CheckResult( pStyle2->put_position(CComBSTR("absolute")));

    } 

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::SetHeight()
//
// Synopsis:    Sets the pixelOffset in the X dimension
//
// Arguments:   pixelOffset
//
// Returns:     Success if the control is correctly rendered.
//
//-------------------------------------------------------------------

HRESULT   
CUtilityButton::SetHorizontalOffset(long pixelOffset)
{
    return _pStyle->put_pixelLeft(pixelOffset);
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::SetVerticalOffset()
//
// Synopsis:    Sets the pixelOffset in the Y dimension
//
// Arguments:   pixelOffset
//
// Returns:     Success if the control is correctly rendered.
//
//-------------------------------------------------------------------

HRESULT   
CUtilityButton::SetVerticalOffset(long pixelOffset)
{
    return _pStyle->put_pixelTop(pixelOffset);
}


//+------------------------------------------------------------------
//
// Member:      CUtilityButton::SetPressedCallback()
//
// Synopsis:    Set the pressed callback function; called by the mousedown handler
//
// Arguments:   height
//
//-------------------------------------------------------------------

HRESULT 
CUtilityButton::SetPressedCallback(PFN_PRESSED pfnPressed)
{
    _pfnPressed = pfnPressed;

    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::SetMovedCallback()
//
// Synopsis:    Sets the moved callback function;  called by the mousemove handler
//
// Arguments:   moved function
//
//-------------------------------------------------------------------

HRESULT
CUtilityButton::SetMovedCallback(PFN_MOVED pfnMoved)
{
    _pfnMoved = pfnMoved;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\iextag\utils.cxx ===
//+------------------------------------------------------------------------
//
//  File : Utils.cxx
//
//  purpose : implementation of helpful stuff
//
//-------------------------------------------------------------------------


#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "utils.hxx"

#include <docobj.h>
#include <mshtmcid.h>
#include <mshtmhst.h>

#define BUFFEREDSTR_SIZE 1024

// VARIANT conversion interface exposed by script engines (VBScript/JScript).
EXTERN_C const GUID SID_VariantConversion = 
                { 0x1f101481, 0xbccd, 0x11d0, { 0x93, 0x36,  0x0,  0xa0,  0xc9,  0xd,  0xca,  0xa9 } };

//+------------------------------------------------------------------------
//
//  Function:   GetHTMLDocument
//
//  Synopsis:   Gets the IHTMLDocument2 interface from the client site.
//
//-------------------------------------------------------------------------

STDMETHODIMP 
GetHTMLDocument(IElementBehaviorSite * pSite, IHTMLDocument2 **ppDoc)
{
    HRESULT hr = E_FAIL;

    if (!ppDoc)
        return E_POINTER;

    if (pSite != NULL)
    {
        IHTMLElement *pElement = NULL;
        hr = pSite->GetElement(&pElement);
        if (SUCCEEDED(hr))
        {
            IDispatch * pDispDoc = NULL;
            hr = pElement->get_document(&pDispDoc);
            if (SUCCEEDED(hr))
            {
                hr = pDispDoc->QueryInterface(IID_IHTMLDocument2, (void **)ppDoc);
                pDispDoc->Release();
            }
            pElement->Release();
        }
    }

    return hr;
}

//+------------------------------------------------------------------------
//
//  Function:   GetHTMLWindow
//
//  Synopsis:   Gets the IHTMLWindow2 interface from the client site.
//
//-------------------------------------------------------------------------

STDMETHODIMP 
GetHTMLWindow(IElementBehaviorSite * pSite, IHTMLWindow2 **ppWindow)
{
    HRESULT hr = E_FAIL;
    IHTMLDocument2 *pDoc = NULL;

    hr = GetHTMLDocument(pSite, &pDoc);

    if (SUCCEEDED(hr))
    {
        hr = pDoc->get_parentWindow(ppWindow);
        pDoc->Release();
    }

    return hr;
}

//+------------------------------------------------------------------------
//
//  Function:   GetClientSiteWindow
//
//  Synopsis:   Gets the window handle of the client site passed in.
//
//-------------------------------------------------------------------------

STDMETHODIMP 
GetClientSiteWindow(IElementBehaviorSite *pSite, HWND *phWnd)
{
    HRESULT hr = E_FAIL;
    IWindowForBindingUI *pWindowForBindingUI = NULL;

    if (pSite != NULL) {

        // Get IWindowForBindingUI ptr
        hr = pSite->QueryInterface(IID_IWindowForBindingUI,
                (LPVOID *)&pWindowForBindingUI);

        if (FAILED(hr)) {
            IServiceProvider *pServProv;
            hr = pSite->QueryInterface(IID_IServiceProvider, (LPVOID *)&pServProv);

            if (hr == NOERROR) {
                pServProv->QueryService(IID_IWindowForBindingUI,IID_IWindowForBindingUI,
                    (LPVOID *)&pWindowForBindingUI);
                pServProv->Release();
            }
        }

        if (pWindowForBindingUI) {
            pWindowForBindingUI->GetWindow(IID_IWindowForBindingUI, phWnd);
            pWindowForBindingUI->Release();
        }
    }

    return hr;
}


//+------------------------------------------------------------------------
//
//  Function:   AppendElement
//
//  Synopsis:   Appends a child to an owner
//
//-------------------------------------------------------------------------

STDMETHODIMP
AppendChild(IHTMLElement *pOwner, IHTMLElement *pChild)
{
    HRESULT hr; 

    CComPtr<IHTMLDOMNode> pOwnerNode, pChildNode;

    hr = pOwner->QueryInterface(IID_IHTMLDOMNode, (void **) &pOwnerNode);
    if (FAILED(hr))
        goto Cleanup;

    hr = pChild->QueryInterface(IID_IHTMLDOMNode, (void **) &pChildNode);
    if (FAILED(hr))
        goto Cleanup;

    hr = pOwnerNode->appendChild(pChildNode, NULL);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:

    return hr;
}


//+---------------------------------------------------------------
//
// Function:    IsSameObject
//
// Synopsis:    Checks for COM identity
//
// Arguments:   pUnkLeft, pUnkRight
//
//+---------------------------------------------------------------

BOOL
IsSameObject(IUnknown *pUnkLeft, IUnknown *pUnkRight)
{
    IUnknown *pUnk1, *pUnk2;

    if (pUnkLeft == pUnkRight)
        return TRUE;

    if (pUnkLeft == NULL || pUnkRight == NULL)
        return FALSE;

    if (SUCCEEDED(pUnkLeft->QueryInterface(IID_IUnknown, (LPVOID *)&pUnk1)))
    {
        pUnk1->Release();
        if (pUnk1 == pUnkRight)
            return TRUE;
        if (SUCCEEDED(pUnkRight->QueryInterface(IID_IUnknown, (LPVOID *)&pUnk2)))
        {
            pUnk2->Release();
            return pUnk1 == pUnk2;
        }
    }
    return FALSE;
}

//+------------------------------------------------------------------------
//
//  Function:   ClearInterfaceFn
//
//  Synopsis:   Sets an interface pointer to NULL, after first calling
//              Release if the pointer was not NULL initially
//
//  Arguments:  [ppUnk]     *ppUnk is cleared
//
//-------------------------------------------------------------------------

void
ClearInterfaceFn(IUnknown ** ppUnk)
{
    IUnknown * pUnk;

    pUnk = *ppUnk;
    *ppUnk = NULL;
    if (pUnk)
        pUnk->Release();
}



//+------------------------------------------------------------------------
//
//  Function:   ReplaceInterfaceFn
//
//  Synopsis:   Replaces an interface pointer with a new interface,
//              following proper ref counting rules:
//
//              = *ppUnk is set to pUnk
//              = if *ppUnk was not NULL initially, it is Release'd
//              = if pUnk is not NULL, it is AddRef'd
//
//              Effectively, this allows pointer assignment for ref-counted
//              pointers.
//
//  Arguments:  [ppUnk]
//              [pUnk]
//
//-------------------------------------------------------------------------

void
ReplaceInterfaceFn(IUnknown ** ppUnk, IUnknown * pUnk)
{
    IUnknown * pUnkOld = *ppUnk;

    *ppUnk = pUnk;

    //  Note that we do AddRef before Release; this avoids
    //    accidentally destroying an object if this function
    //    is passed two aliases to it

    if (pUnk)
        pUnk->AddRef();

    if (pUnkOld)
        pUnkOld->Release();
}



//+------------------------------------------------------------------------
//
//  Function:   ReleaseInterface
//
//  Synopsis:   Releases an interface pointer if it is non-NULL
//
//  Arguments:  [pUnk]
//
//-------------------------------------------------------------------------

void
ReleaseInterface(IUnknown * pUnk)
{
    if (pUnk)
        pUnk->Release();
}


//+------------------------------------------------------------------------
//
//  Member:     CBufferedStr::Set
//
//  Synopsis:   Initilizes a CBufferedStr
//
//-------------------------------------------------------------------------
HRESULT
CBufferedStr::Set (LPCTSTR pch, UINT uiCch)
{
    HRESULT hr = S_OK;

    Free();

    if (!uiCch)
        _cchIndex = pch ? _tcslen (pch) : 0;
    else
        _cchIndex = uiCch;

    _cchBufSize = _cchIndex > BUFFEREDSTR_SIZE ? _cchIndex : BUFFEREDSTR_SIZE;
    _pchBuf = new TCHAR [ _cchBufSize ];
    if (!_pchBuf)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (pch)
    {
        _tcsncpy (_pchBuf, pch, _cchIndex);
    }

    _pchBuf[_cchIndex] = '\0';

Cleanup:
    return (hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CBufferedStr::QuickAppend
//
//  Parameters: pchNewStr   string to be added to _pchBuf
//
//  Synopsis:   Appends pNewStr into _pchBuf starting at
//              _pchBuf[uIndex].  Increments index to reference
//              new end of string.  If _pchBuf is not large enough,
//              reallocs _pchBuf and updates _cchBufSize.
//
//-------------------------------------------------------------------------
HRESULT
CBufferedStr::QuickAppend (const TCHAR* pchNewStr, ULONG newLen)
{
    HRESULT hr = S_OK;

    if (!_pchBuf)
    {
        hr = Set();
        if (hr)
            goto Cleanup;
    }

    if (_cchIndex + newLen >= _cchBufSize)    // we can't fit the new string in the current buffer
    {                                         // so allocate a new buffer, and copy the old string
        _cchBufSize += (newLen > BUFFEREDSTR_SIZE) ? newLen : BUFFEREDSTR_SIZE;
        TCHAR * pchTemp = new TCHAR [ _cchBufSize ];
        if (!pchTemp)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        _tcsncpy (pchTemp, _pchBuf, _cchIndex);

        Free();
        _pchBuf = pchTemp;
    }

    // append the new string
    _tcsncpy (_pchBuf + _cchIndex, pchNewStr, newLen);
    _cchIndex += newLen;
    _pchBuf[_cchIndex] = '\0';

Cleanup:
    return (hr);
}
HRESULT
CBufferedStr::QuickAppend(long lValue)
{
    TCHAR   strValue[40];

#ifdef UNICODE
    return QuickAppend( _ltow(lValue, strValue, 10) );
#else
    return QuickAppend( _ltoa(lValue, strValue, 10) );
#endif
}

//+---------------------------------------------------------------------------
//
//  method : ConvertGmtTimeToString
//
//  Synopsis: This function produces a standard(?) format date, of the form
// Tue, 02 Apr 1996 02:04:57 UTC  The date format *will not* be tailored
// for the locale.  This is for cookie use and Netscape compatibility
//
//----------------------------------------------------------------------------
static const TCHAR* achMonth[] = {
    _T("Jan"),_T("Feb"),_T("Mar"),_T("Apr"),_T("May"),_T("Jun"),
        _T("Jul"),_T("Aug"),_T("Sep"),_T("Oct"),_T("Nov"),_T("Dec") 
};
static const TCHAR* achDay[] = {
    _T("Sun"), _T("Mon"),_T("Tue"),_T("Wed"),_T("Thu"),_T("Fri"),_T("Sat")
};

HRESULT 
ConvertGmtTimeToString(FILETIME Time, TCHAR * pchDateStr, DWORD cchDateStr)
{
    SYSTEMTIME SystemTime;
    CBufferedStr strBuf;

    if (cchDateStr < DATE_STR_LENGTH)
        return E_INVALIDARG;

    FileTimeToSystemTime(&Time, &SystemTime);

    strBuf.QuickAppend(achDay[SystemTime.wDayOfWeek]);
    strBuf.QuickAppend(_T(", "));
    strBuf.QuickAppend(SystemTime.wDay);
    strBuf.QuickAppend(_T(" ") );
    strBuf.QuickAppend(achMonth[SystemTime.wMonth - 1] );
    strBuf.QuickAppend(_T(" ") );
    strBuf.QuickAppend(SystemTime.wYear );
    strBuf.QuickAppend(_T(" ") );
    strBuf.QuickAppend(SystemTime.wHour );
    strBuf.QuickAppend(_T(":") );
    strBuf.QuickAppend(SystemTime.wMinute );
    strBuf.QuickAppend(_T(":") );
    strBuf.QuickAppend(SystemTime.wSecond );
    strBuf.QuickAppend(_T(" UTC") );

    if (strBuf.Length() >cchDateStr)
        return E_FAIL;

    _tcscpy(pchDateStr, strBuf);

    return S_OK;
}

HRESULT 
ParseDate(BSTR strDate, FILETIME * pftTime)
{
    HRESULT      hr = S_FALSE;
    SYSTEMTIME   stTime ={0};
    LPCTSTR      pszToken = NULL;
    BOOL         fFound;
    int          idx, cch;
    CDataListEnumerator  dle(strDate, _T(':'));

    if (!pftTime)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // get the dayOfTheWeek:  3 digits max plus comma
    //--------------------------------------------------
    if (! dle.GetNext(&pszToken, &cch) || cch > 4)
        goto Cleanup;
    else
    {
        for (idx=0; idx < ARRAY_SIZE(achDay); idx++)
        {
            fFound = !_tcsnicmp( pszToken, achDay[idx], 3);
            if (fFound)
            {
                stTime.wDayOfWeek = (WORD)idx;
                break;
            }
        }

        if (!fFound)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }

    // get the Day 2 digits max
    //--------------------------------------------------
    if (! dle.GetNext(&pszToken, &cch) || cch > 2)
        goto Cleanup;

    stTime.wDay = (WORD)_ttoi(pszToken);

    // get the Month: 3 characters
    //--------------------------------------------------
    if (! dle.GetNext(&pszToken, &cch) || cch > 3)
        goto Cleanup;
    else
    {
        for (idx=0; idx < ARRAY_SIZE(achMonth); idx++)
        {
            fFound = !_tcsnicmp( pszToken, achMonth[idx], 3);
            if (fFound)
            {
                stTime.wMonth = (WORD)idx + 1;
                break;
            }
        }

        if (!fFound)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }

    // get the Year 4 digits max
    //--------------------------------------------------
    if (! dle.GetNext(&pszToken, &cch) || cch > 4)
        goto Cleanup;

    stTime.wYear = (WORD)_ttoi(pszToken);

    // get the Hour 2 digits max
    //--------------------------------------------------
    if (! dle.GetNext(&pszToken, &cch) || cch > 2)
        goto Cleanup;

    stTime.wHour = (WORD)_ttoi(pszToken);

    // get the Minute 2 digits max
    //--------------------------------------------------
    if (! dle.GetNext(&pszToken, &cch) || cch > 2)
        goto Cleanup;

    stTime.wMinute = (WORD)_ttoi(pszToken);

    // get the Second 2 digits max
    //--------------------------------------------------
    if (! dle.GetNext(&pszToken, &cch) || cch > 2)
        goto Cleanup;

    stTime.wSecond = (WORD)_ttoi(pszToken);

    // now we have SYSTEMTIME, lets return the FILETIME
    if (!SystemTimeToFileTime(&stTime, pftTime))
        hr = GetLastError();
    else
        hr = S_OK;

Cleanup:
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   MbcsFromUnicode
//
//  Synopsis:   Converts a string to MBCS from Unicode.
//
//  Arguments:  [pstr]  -- The buffer for the MBCS string.
//              [cch]   -- The size of the MBCS buffer, including space for
//                              NULL terminator.
//
//              [pwstr] -- The Unicode string to convert.
//              [cwch]  -- The number of characters in the Unicode string to
//                              convert, including NULL terminator.  If this
//                              number is -1, the string is assumed to be
//                              NULL terminated.  -1 is supplied as a
//                              default argument.
//
//  Returns:    If [pstr] is NULL or [cch] is 0, 0 is returned.  Otherwise,
//              the number of characters converted, including the terminating
//              NULL, is returned (note that converting the empty string will
//              return 1).  If the conversion fails, 0 is returned.
//
//  Modifies:   [pstr].
//
//----------------------------------------------------------------------------

int
MbcsFromUnicode(LPSTR pstr, int cch, LPCWSTR pwstr, int cwch)
{
    int ret;

#if DBG == 1 /* { */
    int errcode;
#endif /* } */

    if (!pstr || cch <= 0 || !pwstr || cwch<-1)
        return 0;

    ret = WideCharToMultiByte(CP_ACP, 0, pwstr, cwch, pstr, cch, NULL, NULL);

#if DBG == 1 /* { */
    if (ret <= 0)
    {
        errcode = GetLastError();
    }
#endif /* } */

    return ret;
}


//+---------------------------------------------------------------------------
//
//  Function:   UnicodeFromMbcs
//
//  Synopsis:   Converts a string to Unicode from MBCS.
//
//  Arguments:  [pwstr] -- The buffer for the Unicode string.
//              [cwch]  -- The size of the Unicode buffer, including space for
//                              NULL terminator.
//
//              [pstr]  -- The MBCS string to convert.
//              [cch]  -- The number of characters in the MBCS string to
//                              convert, including NULL terminator.  If this
//                              number is -1, the string is assumed to be
//                              NULL terminated.  -1 is supplied as a
//                              default argument.
//
//  Returns:    If [pwstr] is NULL or [cwch] is 0, 0 is returned.  Otherwise,
//              the number of characters converted, including the terminating
//              NULL, is returned (note that converting the empty string will
//              return 1).  If the conversion fails, 0 is returned.
//
//  Modifies:   [pwstr].
//
//----------------------------------------------------------------------------

int
UnicodeFromMbcs(LPWSTR pwstr, int cwch, LPCSTR pstr, int cch)
{
    int ret;

#if DBG == 1 /* { */
    int errcode;
#endif /* } */

    if (!pstr || cwch <= 0 || !pwstr || cch<-1)
        return 0;

    ret = MultiByteToWideChar(CP_ACP, 0, pstr, cch, pwstr, cwch);

#if DBG == 1 /* { */
    if (ret <= 0)
    {
        errcode = GetLastError();
    }
#endif /* } */

    return ret;
}


//+--------------------------------------------------------------------
//
//  Function:    _tcsistr
//
//---------------------------------------------------------------------

const TCHAR * __cdecl _tcsistr (const TCHAR * tcs1,const TCHAR * tcs2)
{
    const TCHAR *cp;
    int cc,count;
    int n2Len = _tcslen ( tcs2 );
    int n1Len = _tcslen ( tcs1 );

    if ( n1Len >= n2Len )
    {
        for ( cp = tcs1, count = n1Len - n2Len; count>=0 ; cp++,count-- )
        {
            cc = CompareString(LCID_SCRIPTING,
                NORM_IGNORECASE | NORM_IGNOREWIDTH | NORM_IGNOREKANATYPE,
                cp, n2Len,tcs2, n2Len);
            if ( cc > 0 )
                cc-=2;
            if ( !cc )
                return cp;
        }
    }
    return NULL;
}

//+--------------------------------------------------------------------
//
//  Function:    AccessAllowed
//
//---------------------------------------------------------------------
BOOL
AccessAllowed(BSTR bstrUrl, IUnknown * pUnkSite)
{
    BOOL                fAccessAllowed = FALSE;
    HRESULT             hr;
    CComPtr<IBindHost>	pBindHost;
    CComPtr<IMoniker>	pMoniker;
    LPTSTR              pchUrl = NULL;
    BYTE                abSID1[MAX_SIZE_SECURITY_ID];
    BYTE                abSID2[MAX_SIZE_SECURITY_ID];
    DWORD               cbSID1 = ARRAY_SIZE(abSID1);
    DWORD               cbSID2 = ARRAY_SIZE(abSID2);
    CComPtr<IInternetSecurityManager>                   pSecurityManager;
    CComPtr<IInternetHostSecurityManager>               pHostSecurityManager;
    CComQIPtr<IServiceProvider, &IID_IServiceProvider>  pServiceProvider(pUnkSite);

    if (!pServiceProvider)
        goto Cleanup;

    //
    // expand url
    //

    hr = pServiceProvider->QueryService(SID_IBindHost, IID_IBindHost, (void**)&pBindHost);
    if (hr)
        goto Cleanup;

    hr = pBindHost->CreateMoniker(bstrUrl, NULL, &pMoniker, NULL);
    if (hr)
        goto Cleanup;

    hr = pMoniker->GetDisplayName(NULL, NULL, &pchUrl);
    if (hr)
        goto Cleanup;

    //
    // get security id of the url
    //

    hr = CoInternetCreateSecurityManager(NULL, &pSecurityManager, 0);
    if (hr)
        goto Cleanup;

    hr = pSecurityManager->GetSecurityId(pchUrl, abSID1, &cbSID1, NULL);
    if (hr)
        goto Cleanup;

    //
    // get security id of the document
    //

    hr = pServiceProvider->QueryService(
        IID_IInternetHostSecurityManager, IID_IInternetHostSecurityManager, (void**)&pHostSecurityManager);
    if (hr)
        goto Cleanup;

    hr = pHostSecurityManager->GetSecurityId(abSID2, &cbSID2, NULL);

    //
    // the security check itself
    //

    fAccessAllowed = (cbSID1 == cbSID2 && (0 == memcmp(abSID1, abSID2, cbSID1)));

Cleanup:
    if (pchUrl)
        CoTaskMemFree(pchUrl);

    return fAccessAllowed;
}
//+------------------------------------------------------------------------
//
//  CDataObject : Member function implmentations
//
//-------------------------------------------------------------------------
HRESULT 
CDataObject::Set (BSTR bstrValue)
{
    VariantClear(&_varValue);
    _fDirty = TRUE;

    V_VT(&_varValue)   = VT_BSTR;
    if (!bstrValue)
    {
        V_BSTR(&_varValue) = NULL;
        return S_OK;
    }
    else
    {
        V_BSTR(&_varValue) = SysAllocStringLen(bstrValue, SysStringLen(bstrValue));

        return (V_BSTR(&_varValue)) ? S_OK : E_OUTOFMEMORY;
    }
}

HRESULT 
CDataObject::Set (VARIANT_BOOL vBool)
{
    VariantClear(&_varValue);
    _fDirty = TRUE;

    V_VT(&_varValue)   = VT_BOOL;
    V_BOOL(&_varValue) = vBool;

    return S_OK;
}

HRESULT
CDataObject::Set(IDispatch * pDisp)
{
    VariantClear(&_varValue);
    _fDirty = TRUE;

    V_VT(&_varValue)   = VT_DISPATCH;
    V_DISPATCH(&_varValue) = pDisp;

    if (pDisp)
        pDisp->AddRef();

    return S_OK;
}

HRESULT 
CDataObject::GetAsBSTR (BSTR * pbstr)
{
    HRESULT hr = S_OK;

    if (!pbstr) 
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstr = NULL;

    if (V_VT(&_varValue) == VT_BSTR)
    {
        *pbstr = SysAllocStringLen(V_BSTR(&_varValue), 
                                   SysStringLen(V_BSTR(&_varValue)));

        if (!*pbstr)
            hr = E_OUTOFMEMORY;
    }

Cleanup:
    return hr;
};


HRESULT 
CDataObject::GetAsBOOL (VARIANT_BOOL * pVB)
{
    HRESULT hr = S_OK;

    if (!pVB) 
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (V_VT(&_varValue) != VT_BOOL)
    {
        *pVB = VB_FALSE;
        hr = S_FALSE;
    }
    else
    {
        *pVB =  V_BOOL(&_varValue);
    }

Cleanup:
    return hr;
};

HRESULT
CDataObject::GetAsDispatch(IDispatch ** ppDisp)
{
    HRESULT hr = S_OK;

    if (!ppDisp)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppDisp = NULL;

    if (V_VT(&_varValue)!= VT_DISPATCH)
    {
        hr = S_FALSE;
    }
    else
    {
        *ppDisp = V_DISPATCH(&_varValue);
        if (*ppDisp)
            (*ppDisp)->AddRef();
    }

Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// Helper Class:    CContextAccess
//                  access to behavior site, element and style
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////

CContextAccess::CContextAccess(IElementBehaviorSite * pSite)
{
    memset (this, 0, sizeof(*this));

    _pSite = pSite;
    _pSite->AddRef();
}

CContextAccess::CContextAccess(IHTMLElement * pElement)
{
    memset (this, 0, sizeof(*this));

    _dwAccess = CA_ELEM;

    _pElem = pElement;
    _pElem->AddRef();
}

/////////////////////////////////////////////////////////////////////////////

CContextAccess::~CContextAccess()
{
    DWORD   dw;

    ReleaseInterface (_pSite);

    // the point of this loop is to avoid doing as many ReleaseInterface-s as we have possible values in CONTEXT_ACCESS enum.
    // instead, we do as many ReleaseInterface-s as number of bits actually set in dwAccess.

    while (_dwAccess)
    {
        dw = (_dwAccess - 1) & _dwAccess;
        switch (_dwAccess - dw)
        {
        case CA_SITEOM:     _pSiteOM->Release();            break;
        case CA_SITERENDER: _pSiteRender->Release();        break;
        case CA_ELEM:       _pElem->Release();              break;
        case CA_ELEM2:      _pElem2->Release();             break;
        case CA_ELEM3:      _pElem3->Release();             break;
        case CA_STYLE:      _pStyle->Release();             break;
        case CA_STYLE2:     _pStyle2->Release();            break;
        case CA_STYLE3:     _pStyle3->Release();            break;
        case CA_DEFAULTS:   _pDefaults->Release();          break;
        case CA_DEFSTYLE:   _pDefStyle->Release();          break;
        case CA_DEFSTYLE2:  _pDefStyle2->Release();         break;
        case CA_DEFSTYLE3:  _pDefStyle3->Release();         break;
        default:            Assert (FALSE && "invalid _dwAccess");  break;
        }
        _dwAccess = dw;
    }
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CContextAccess::Open(DWORD dwAccess)
{
    HRESULT     hr = S_OK;
    DWORD       dw, dw2, dw3;

    // NOTE order of these ifs is important

    // STYLE2 or STYLE3 require us to get STYLE
    if (dwAccess & (CA_STYLE2 | CA_STYLE3))
        dwAccess |= CA_STYLE;

    // ELEM2, ELEM3, or CA_STYLE require us to get ELEM
    if (dwAccess & (CA_ELEM2 | CA_ELEM3 | CA_STYLE))
        dwAccess |= CA_ELEM;

    // DEFSTYLE2 or DEFSTYLE3 require us to get STYLE
    if (dwAccess & (CA_DEFSTYLE2 | CA_DEFSTYLE3))
        dwAccess |= CA_DEFSTYLE;

    // any DEFSTYLE require us to get PELEM
    if (dwAccess & (CA_DEFSTYLE))
        dwAccess |= CA_DEFAULTS;

    // PELEM requires us to get SITEOM
    if (dwAccess & (CA_DEFAULTS))
        dwAccess |= CA_SITEOM;

    // the point of this loop is to avoid doing as many ifs as we have possible values in CONTEXT_ACCESS enum.
    // instead, we do as many ifs as number of bits actually set in dwAccess.

    dw = dwAccess;

    while (dw)
    {
        dw2 = (dw - 1) & dw;
        dw3 = dw - dw2;
        if (0 == (dw3 & _dwAccess))
        {
            switch (dw3)
            {
            case CA_SITEOM:
                Assert (_pSite && !_pSiteOM);
                hr = _pSite->QueryInterface(IID_IElementBehaviorSiteOM2, (void**)&_pSiteOM);
                if (hr)
                    goto Cleanup;
                break;

            case CA_SITERENDER:
                Assert (_pSite && !_pSiteRender);
                hr = _pSite->QueryInterface(IID_IElementBehaviorSiteRender, (void**)&_pSiteRender);
                if (hr)
                    goto Cleanup;
                break;

            case CA_ELEM:
                Assert (_pSite && !_pElem);
                hr = _pSite->GetElement(&_pElem);
                if (hr)
                    goto Cleanup;
                break;

            case CA_ELEM2:
                Assert (_pElem && !_pElem2);
                hr = _pElem->QueryInterface(IID_IHTMLElement2, (void**)&_pElem2);
                if (hr)
                    goto Cleanup;
                break;

            case CA_ELEM3:
                Assert (_pElem && !_pElem3);
                hr = _pElem->QueryInterface(IID_IHTMLElement3, (void**)&_pElem3);
                if (hr)
                    goto Cleanup;
                break;

            case CA_STYLE:
                Assert (_pElem && !_pStyle);
                hr = _pElem->get_style(&_pStyle);
                if (hr)
                    goto Cleanup;
                break;

            case CA_STYLE2:
                Assert (_pStyle && !_pStyle2);
                hr = _pStyle->QueryInterface(IID_IHTMLStyle2, (void**)&_pStyle2);
                if (hr)
                    goto Cleanup;
                break;

            case CA_STYLE3:
                Assert (_pStyle && !_pStyle3);
                hr = _pStyle->QueryInterface(IID_IHTMLStyle3, (void**)&_pStyle3);
                if (hr)
                    goto Cleanup;
                break;

            case CA_DEFAULTS:
                Assert (_pSiteOM && !_pDefaults);
                hr = _pSiteOM->GetDefaults(&_pDefaults);
                if (hr)
                    goto Cleanup;
                break;

            case CA_DEFSTYLE:
                Assert (_pDefaults && !_pDefStyle);
                hr = _pDefaults->get_style(&_pDefStyle);
                if (hr)
                    goto Cleanup;
                break;

            case CA_DEFSTYLE2:
                Assert (_pDefStyle && !_pDefStyle2);
                hr = _pDefStyle->QueryInterface(IID_IHTMLStyle2, (void**)&_pDefStyle2);
                if (hr)
                    goto Cleanup;
                break;

            case CA_DEFSTYLE3:
                Assert (_pDefStyle && !_pDefStyle3);
                hr = _pDefStyle->QueryInterface(IID_IHTMLStyle3, (void**)&_pDefStyle3);
                if (hr)
                    goto Cleanup;
                break;

            default:
                Assert (FALSE && "invalid dwAccess");
                break;
            }
        }

        dw = dw2;
    }

    _dwAccess |= dwAccess;

Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////

#if DBG == 1

HRESULT
CContextAccess::DbgTest(IElementBehaviorSite * pSite)
{
    HRESULT     hr;

    // CA_NONE
    {
        CContextAccess  a(pSite);

        hr = a.Open(CA_NONE);
        if (hr)
            goto Cleanup;
    }

    // CA_ELEM
    {
        CContextAccess  a(pSite);

        hr = a.Open(CA_ELEM);
        if (hr)
            goto Cleanup;

        a.Elem()->AddRef();
        a.Elem()->Release();
    }

    // CA_ELEM2
    {
        CContextAccess  a(pSite);

        hr = a.Open(CA_ELEM2);
        if (hr)
            goto Cleanup;

        a.Elem2()->AddRef();
        a.Elem2()->Release();
    }

    // CA_ELEM3
    {
        CContextAccess  a(pSite);

        hr = a.Open(CA_ELEM3);
        if (hr)
            goto Cleanup;

        a.Elem3()->AddRef();
        a.Elem3()->Release();
    }

    // CA_STYLE
    {
        CContextAccess  a(pSite);

        hr = a.Open(CA_STYLE);
        if (hr)
            goto Cleanup;

        a.Style()->AddRef();
        a.Style()->Release();
    }

    // CA_STYLE2
    {
        CContextAccess  a(pSite);

        hr = a.Open(CA_STYLE2);
        if (hr)
            goto Cleanup;

        a.Style2()->AddRef();
        a.Style2()->Release();
    }

    // CA_STYLE3
    {
        CContextAccess  a(pSite);

        hr = a.Open(CA_STYLE3);
        if (hr)
            goto Cleanup;

        a.Style3()->AddRef();
        a.Style3()->Release();
    }

    // CA_DEFSTYLE
    {
        CContextAccess  a(pSite);

        hr = a.Open(CA_DEFSTYLE);
        if (hr)
            goto Cleanup;

        a.DefStyle()->AddRef();
        a.DefStyle()->Release();
    }

    // CA_DEFSTYLE2
    {
        CContextAccess  a(pSite);

        hr = a.Open(CA_DEFSTYLE2);
        if (hr)
            goto Cleanup;

        a.DefStyle2()->AddRef();
        a.DefStyle2()->Release();
    }

    // CA_DEFSTYLE3
    {
        CContextAccess  a(pSite);

        hr = a.Open(CA_DEFSTYLE3);
        if (hr)
            goto Cleanup;

        a.DefStyle3()->AddRef();
        a.DefStyle3()->Release();
    }

    // CA_SITEOM
    {
        CContextAccess  a(pSite);

        hr = a.Open(CA_SITEOM);
        if (hr)
            goto Cleanup;

        a.SiteOM()->AddRef();
        a.SiteOM()->Release();
    }

    // sequencing of Opens
    {
        CContextAccess  a(pSite);

        hr = a.Open(CA_SITEOM);
        if (hr)
            goto Cleanup;

        a.SiteOM()->AddRef();
        a.SiteOM()->Release();

        hr = a.Open(CA_ELEM);
        if (hr)
            goto Cleanup;

        a.Elem()->AddRef();
        a.Elem()->Release();

        hr = a.Open(CA_DEFSTYLE3);
        if (hr)
            goto Cleanup;

        a.DefStyle3()->AddRef();
        a.DefStyle3()->Release();
    }

Cleanup:
    return hr;
}

#endif

/////////////////////////////////////////////////////////////////////////////
//
// Helper Class:    CEventObjectAccess
//                  access to event object
//
/////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////

CEventObjectAccess::CEventObjectAccess(DISPPARAMS * pDispParams)
{
    memset (this, 0, sizeof(*this));
    _pDispParams = pDispParams;
}

///////////////////////////////////////////////////////////////////////////////

CEventObjectAccess::~CEventObjectAccess()
{
    ReleaseInterface (_pEventObj);
    ReleaseInterface (_pEventObj2);
}

///////////////////////////////////////////////////////////////////////////////

HRESULT
CEventObjectAccess::Open(DWORD dwAccess)
{
    HRESULT     hr = S_OK;
    VARIANT *   pvarArg;

    Assert (_pDispParams);

    if (!_pDispParams ||
        !_pDispParams->rgvarg ||
         _pDispParams->cArgs != 1)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pvarArg = &_pDispParams->rgvarg[0];

    if (!V_UNKNOWN(pvarArg) ||
        (VT_DISPATCH != V_VT(pvarArg) &&
         VT_UNKNOWN  != V_VT(pvarArg)))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (0 != (dwAccess & EOA_EVENTOBJ) &&
        !_pEventObj)
    {
        hr = V_UNKNOWN(pvarArg)->QueryInterface(IID_IHTMLEventObj, (void **)&_pEventObj);
        if (hr)
            goto Cleanup;
    }

    if (dwAccess & EOA_EVENTOBJ2 &&
        !_pEventObj2)
    {
        hr =  V_UNKNOWN(pvarArg)->QueryInterface(IID_IHTMLEventObj2, (void **)&_pEventObj2);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    return hr;
}

HRESULT
CEventObjectAccess::GetScreenCoordinates(POINT * ppt)
{
    HRESULT hr = S_OK;

    if (!_fEventPropertiesInitialized)
    {
        hr = InitializeEventProperties();
        if (hr)
            goto Cleanup;
    }

    *ppt = _EventProperties.ptScreen;

Cleanup:
    return hr;
}

HRESULT
CEventObjectAccess::GetWindowCoordinates(POINT * ppt)
{
    HRESULT hr = S_OK;

    if (!_fEventPropertiesInitialized)
    {
        hr = InitializeEventProperties();
        if (hr)
            goto Cleanup;
    }

    *ppt = _EventProperties.ptClient;

Cleanup:
    return hr;
}

HRESULT
CEventObjectAccess::GetParentCoordinates(POINT * ppt)
{
    HRESULT hr = S_OK;

    if (!_fEventPropertiesInitialized)
    {
        hr = InitializeEventProperties();
        if (hr)
            goto Cleanup;
    }

    *ppt = _EventProperties.ptElem;

Cleanup:
    return hr;
}

HRESULT
CEventObjectAccess::GetKeyCode(long * pl)
{
    HRESULT hr = S_OK;

    if (!_fEventPropertiesInitialized)
    {
        hr = InitializeEventProperties();
        if (hr)
            goto Cleanup;
    }

    *pl = _EventProperties.lKey;

Cleanup:
    return hr;
}

HRESULT
CEventObjectAccess::GetMouseButtons(long * pl)
{
    HRESULT hr      = S_OK;

    if (!_fEventPropertiesInitialized)
    {
        hr = InitializeEventProperties();
        if (hr)
            goto Cleanup;
    }

    *pl = _EventProperties.lMouseButtons;

Cleanup:
    return hr;
}

HRESULT
CEventObjectAccess::GetKeyboardStatus(long * pl)
{
    HRESULT hr = S_OK;

    if (!_fEventPropertiesInitialized)
    {
        hr = InitializeEventProperties();
        if (hr)
            goto Cleanup;
    }

    *pl = _EventProperties.lKeys;

Cleanup:
    return hr;
}

HRESULT
CEventObjectAccess::InitializeEventProperties()
{
    HRESULT hr = S_OK;

    VARIANT_BOOL b;

    BOOL fAltKey = FALSE;
    BOOL fCtrlKey = FALSE;
    BOOL fShiftKey = FALSE;

    BOOL    fLeft   = FALSE;
    BOOL    fRight  = FALSE;
    BOOL    fMiddle = FALSE;
    long    lMouseButtons;

    if (!_pEventObj)
    {
        hr = Open(EOA_EVENTOBJ);
        if (hr)
            goto Cleanup;
    }

    // KeyboardStatus

    hr = _pEventObj->get_altKey(&b);
    if (hr)
        goto Cleanup;
    fAltKey = (b == VARIANT_TRUE);

    hr = _pEventObj->get_ctrlKey(&b);
    if (hr)
        goto Cleanup;
    fCtrlKey = (b == VARIANT_TRUE);

    hr = _pEventObj->get_shiftKey(&b);
    if (hr)
        goto Cleanup;
    fShiftKey = (b == VARIANT_TRUE);

    _EventProperties.lKeys = (fAltKey ? EVENT_ALTKEY : 0) | (fCtrlKey ? EVENT_CTRLKEY : 0) | (fShiftKey ? EVENT_SHIFTKEY : 0);

    // MouseButtons

    hr = _pEventObj->get_button(&lMouseButtons);
    if (hr)
        goto Cleanup;

    fLeft = (lMouseButtons == 1) || (lMouseButtons == 3) || (lMouseButtons == 5) || (lMouseButtons == 7);
    fRight = (lMouseButtons == 2) || (lMouseButtons == 3) || (lMouseButtons == 6) || (lMouseButtons == 7);
    fMiddle = (lMouseButtons == 4) || (lMouseButtons == 5) || (lMouseButtons == 6) || (lMouseButtons == 7);

    _EventProperties.lMouseButtons = ( fLeft  ? EVENT_LEFTBUTTON   : 0) 
                                   | (fRight  ? EVENT_RIGHTBUTTON  : 0) 
                                   | (fMiddle ? EVENT_MIDDLEBUTTON : 0);

    // KeyCode
    
    hr = _pEventObj->get_keyCode(&_EventProperties.lKey);
    if (hr)
        goto Cleanup;

    // ParentCoordinates

    hr = _pEventObj->get_x(&_EventProperties.ptElem.x);
    if (hr)
        goto Cleanup;
    hr = _pEventObj->get_y(&_EventProperties.ptElem.y);
    if (hr)
        goto Cleanup;

    // WindowCoordinates

    hr = _pEventObj->get_clientX(&_EventProperties.ptClient.x);
    if (hr)
        goto Cleanup;
    hr = _pEventObj->get_clientY(&_EventProperties.ptClient.y);
    if (hr)
        goto Cleanup;

    // ScreenCoordinates

    hr = _pEventObj->get_screenX(&_EventProperties.ptScreen.x);
    if (hr)
        goto Cleanup;
    hr = _pEventObj->get_screenY(&_EventProperties.ptScreen.y);
    if (hr)
        goto Cleanup;
    
    _fEventPropertiesInitialized = TRUE;

Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// Misc helpers
//
/////////////////////////////////////////////////////////////////////////////

void *
MemAllocClear(size_t cb)
{
    void * pv = malloc(cb);

    if (pv)
    {
        memset (pv, 0, cb);
    }

    return pv;
}

HRESULT
LoadLibrary(char *achLibraryName, HINSTANCE *hInst)
{
    DWORD       dwError;
    Assert(achLibraryName);
    Assert(hInst);
    *hInst = NULL;

    // Try to load the library using the normal mechanism.
    *hInst = ::LoadLibraryA(achLibraryName);

#ifdef WIN16
    if ( (UINT) *hInst < 32 )
        goto Error;
#endif

#if !defined(WIN16) && !defined(WINCE)
    // If that failed because the module was not be found,
    // then try to find the module in the directory we were
    // loaded from.
    if (!*hInst)
    {
        dwError = ::GetLastError();

        if (   dwError == ERROR_MOD_NOT_FOUND
            || dwError == ERROR_DLL_NOT_FOUND)
        {
            char achBuf1[MAX_PATH];
            char achBuf2[MAX_PATH];
            char *pch;

            // Get path name of this module.
            if (::GetModuleFileNameA(NULL, achBuf1, ARRAY_SIZE(achBuf1)) == 0)
                goto Error;

            // Find where the file name starts in the module path.
            if (::GetFullPathNameA(achBuf1, ARRAY_SIZE(achBuf2), achBuf2, &pch) == 0)
                goto Error;

            // Chop off the file name to get a directory name.
            *pch = 0;

            // See if there's a dll with the given name in the directory.
            if (::SearchPathA(
                    achBuf2,
                    achLibraryName,
                    NULL,
                    ARRAY_SIZE(achBuf1),
                    achBuf1,
                    NULL) != 0)
            {
                // Yes, there's a dll. Load it.
                *hInst = ::LoadLibraryExA(
                            achBuf1,
                            NULL,
                            LOAD_WITH_ALTERED_SEARCH_PATH);
            }
        }
    }
#endif // !defined(WIN16) && !defined(WINCE)

    if (!*hInst)
    {
        goto Error;
    }

    return S_OK;

Error:
    dwError = GetLastError();
    return dwError ? HRESULT_FROM_WIN32(dwError) : E_FAIL;
}

//+----------------------------------------------------------------------------
//
//  Member : AccessAllowed
//
//  Synopsis : Internal helper. this function is part of the behavior security
//      model for this tag.  We only allow layout rects to be trusted if they're
//      within a trusted dialog.
//
//-----------------------------------------------------------------------------

BOOL
TemplateAccessAllowed(IElementBehaviorSite *pISite)
{
#ifdef TEMPLATE_TESTING
    return TRUE;
#else
    HRESULT             hr;
    IHTMLElement      * pElem = NULL;
    IDispatch         * pDoc  = NULL;
    IOleCommandTarget * pioct = NULL;
    VARIANT             varRet;
    MSOCMD              msocmd;

    if (!pISite)
        return FALSE;

    VariantInit(&varRet);
    msocmd.cmdID = IDM_ISTRUSTEDDLG;
    msocmd.cmdf  = 0;

    hr = pISite->GetElement(&pElem);
    if (FAILED(hr))
        goto Cleanup;

    hr = pElem->get_document(&pDoc); 
    if (FAILED(hr))
        goto Cleanup;

    hr = pDoc->QueryInterface(IID_IOleCommandTarget, (void**)&pioct);
    if (hr)
        goto Cleanup;

    hr = pioct->Exec(&CGID_MSHTML, IDM_GETPRINTTEMPLATE, NULL, NULL, &varRet);

Cleanup:
    ReleaseInterface(pElem);
    ReleaseInterface(pDoc);
    ReleaseInterface(pioct);

    return  (hr || V_VT(&varRet) != VT_BOOL  || V_BOOL(&varRet) != VB_TRUE) ? FALSE : TRUE;
#endif
}

//------------------------------------------------------------------------------
//---------------------------------- Wrappers ----------------------------------
//------------------------------------------------------------------------------

STDAPI
SHGetFolderPathA(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPSTR pchPath)
{
    HMODULE hDLL = NULL;
    void *  pfnSHGetFolderPath = NULL ;

    if (g_fUseShell32InsteadOfSHFolder)
    {
        hDLL = LoadLibraryA("shell32.dll");
        if (hDLL)
        {
            pfnSHGetFolderPath = GetProcAddress(hDLL, "SHGetFolderPathA");

            if(!pfnSHGetFolderPath)
            {
                FreeLibrary(hDLL);
                hDLL = NULL;
            }
        }
    }

    if (!hDLL)
    {
        hDLL = LoadLibraryA("shfolder.dll");
        if (hDLL)
        {
            pfnSHGetFolderPath = GetProcAddress(hDLL, "SHGetFolderPathA");

            if(!pfnSHGetFolderPath)
            {
                FreeLibrary(hDLL);
                hDLL = NULL;
            }
        }

    }

    if (pfnSHGetFolderPath)
    {
        HRESULT hr = (*(HRESULT (STDAPICALLTYPE *)(HWND, int, HANDLE, DWORD, LPSTR))pfnSHGetFolderPath)
                        (hwnd, csidl, hToken, dwFlags, pchPath);

        FreeLibrary(hDLL);

        return hr;
    }

    return E_FAIL;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\atlimpl.cpp ===
// This is a part of the ActiveX Template Library.
// Copyright (C) 1996 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// ActiveX Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// ActiveX Template Library product.

#ifndef __ATLBASE_H__
	#error atlimpl.cpp requires atlbase.h to be included first
#endif

const IID IID_IRegister = {0xCC118C81,0xB379,0x11CF,{0x84,0xE3,0x00,0xAA,0x00,0x21,0xF3,0x37}};
const CLSID CLSID_Register = {0xCC118C85,0xB379,0x11CF,{0x84,0xE3,0x00,0xAA,0x00,0x21,0xF3,0x37}};

#ifndef _ATL_NO_OLEAUT
/////////////////////////////////////////////////////////////////////////////
// CComBSTR

CComBSTR& CComBSTR::operator=(const CComBSTR& src)
{
	if (m_str != src.m_str)
	{
		if (m_str)
			::SysFreeString(m_str);
		m_str = src.Copy();
	}
	return *this;
}

CComBSTR& CComBSTR::operator=(LPCOLESTR pSrc)
{
	if (m_str)
		::SysFreeString(m_str);

	m_str = ::SysAllocString(pSrc);
	return *this;
}

#ifndef OLE2ANSI
CComBSTR::CComBSTR(LPCSTR pSrc)
{
	USES_CONVERSION;
	m_str = ::SysAllocString(A2COLE(pSrc));
}

CComBSTR::CComBSTR(int nSize, LPCSTR sz)
{
	USES_CONVERSION;
	m_str = ::SysAllocStringLen(A2COLE(sz), nSize);
}

CComBSTR& CComBSTR::operator=(LPCSTR pSrc)
{
	USES_CONVERSION;
	if (m_str)
		::SysFreeString(m_str);

	m_str = ::SysAllocString(A2COLE(pSrc));
	return *this;
}
#endif
/////////////////////////////////////////////////////////////////////////////
// CComVariant

#ifndef OLE2ANSI
CComVariant::CComVariant(LPCSTR lpsz)
{
	USES_CONVERSION;
	VariantInit(this);
	vt = VT_BSTR;
	bstrVal = ::SysAllocString(A2COLE(lpsz));
}

CComVariant& CComVariant::operator=(LPCSTR lpsz)
{
	USES_CONVERSION;
	VariantClear(this);
	vt = VT_BSTR;
	bstrVal = ::SysAllocString(A2COLE(lpsz));
	return *this;
}
#endif
#endif  // !_ATL_NO_OLEAUT

/////////////////////////////////////////////////////////////////////////////
// Smart Pointer helpers

IUnknown* WINAPI _AtlComPtrAssign(IUnknown** pp, IUnknown* lp)
{
	if (lp != NULL)
		lp->AddRef();
	if (*pp)
		(*pp)->Release();
	*pp = lp;
	return lp;
}

IUnknown* WINAPI _AtlComQIPtrAssign(IUnknown** pp, IUnknown* lp, REFIID riid)
{
	IUnknown* pTemp = *pp;
	lp->QueryInterface(riid, (void**)pp);
	if (pTemp)
		pTemp->Release();
	return *pp;
}

/////////////////////////////////////////////////////////////////////////////
// Inproc Marshaling helpers

void WINAPI AtlFreeMarshalStream(IStream* pStream)
{
	if (pStream != NULL)
	{
		CoReleaseMarshalData(pStream);
		pStream->Release();
	}
}

HRESULT WINAPI AtlMarshalPtrInProc(IUnknown* pUnk, const IID& iid, IStream** ppStream)
{
	HRESULT hRes = CreateStreamOnHGlobal(NULL, TRUE, ppStream);
	if (SUCCEEDED(hRes))
	{
		hRes = CoMarshalInterface(*ppStream, iid,
			pUnk, MSHCTX_INPROC, NULL, MSHLFLAGS_TABLESTRONG);
		if (FAILED(hRes))
		{
			(*ppStream)->Release();
			*ppStream = NULL;
		}
	}
	return hRes;
}

HRESULT WINAPI AtlUnmarshalPtr(IStream* pStream, const IID& iid, IUnknown** ppUnk)
{
	*ppUnk = NULL;
	HRESULT hRes = E_INVALIDARG;
	if (pStream != NULL)
	{
		LARGE_INTEGER l;
		l.QuadPart = 0;
		pStream->Seek(l, STREAM_SEEK_SET, NULL);
		hRes = CoUnmarshalInterface(pStream, iid, (void**)ppUnk);
	}
	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// Connection Point Helpers

HRESULT AtlAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw)
{
	CComPtr<IConnectionPointContainer> pCPC;
	CComPtr<IConnectionPoint> pCP;
	HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
	if (SUCCEEDED(hRes))
		hRes = pCPC->FindConnectionPoint(iid, &pCP);
	if (SUCCEEDED(hRes))
		hRes = pCP->Advise(pUnk, pdw);
	return hRes;
}

HRESULT AtlUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw)
{
	CComPtr<IConnectionPointContainer> pCPC;
	CComPtr<IConnectionPoint> pCP;
	HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
	if (SUCCEEDED(hRes))
		hRes = pCPC->FindConnectionPoint(iid, &pCP);
	if (SUCCEEDED(hRes))
		hRes = pCP->Unadvise(dw);
	return hRes;
}

#ifndef _ATL_NO_OLEAUT
/////////////////////////////////////////////////////////////////////////////
// CComTypeInfoHolder

void CComTypeInfoHolder::AddRef()
{
	_Module.m_csTypeInfoHolder.Lock();
	m_dwRef++;
	_Module.m_csTypeInfoHolder.Unlock();
}

void CComTypeInfoHolder::Release()
{
	_Module.m_csTypeInfoHolder.Lock();
	if (--m_dwRef == 0)
	{
		if (m_pInfo != NULL)
			m_pInfo->Release();
		m_pInfo = NULL;
	}
	_Module.m_csTypeInfoHolder.Unlock();
}

HRESULT CComTypeInfoHolder::GetTI(LCID lcid, ITypeInfo** ppInfo)
{
	//If this assert occurs then most likely didn't initialize properly
	_ASSERTE(m_plibid != NULL && m_pguid != NULL);
	_ASSERTE(ppInfo != NULL);
	*ppInfo = NULL;

	HRESULT hRes = E_FAIL;
	_Module.m_csTypeInfoHolder.Lock();
	if (m_pInfo == NULL)
	{
		ITypeLib* pTypeLib;
		hRes = LoadRegTypeLib(*m_plibid, m_wMajor, m_wMinor, lcid, &pTypeLib);
		if (SUCCEEDED(hRes))
		{
			ITypeInfo* pTypeInfo;
			hRes = pTypeLib->GetTypeInfoOfGuid(*m_pguid, &pTypeInfo);
			if (SUCCEEDED(hRes))
				m_pInfo = pTypeInfo;
			pTypeLib->Release();
		}
	}
	*ppInfo = m_pInfo;
	if (m_pInfo != NULL)
	{
		m_pInfo->AddRef();
		hRes = S_OK;
	}
	_Module.m_csTypeInfoHolder.Unlock();
	return hRes;
}

HRESULT CComTypeInfoHolder::GetTypeInfo(UINT /*itinfo*/, LCID lcid,
	ITypeInfo** pptinfo)
{
	HRESULT hRes = E_POINTER;
	if (pptinfo != NULL)
		hRes = GetTI(lcid, pptinfo);
	return hRes;
}

HRESULT CComTypeInfoHolder::GetIDsOfNames(REFIID /*riid*/, LPOLESTR* rgszNames,
	UINT cNames, LCID lcid, DISPID* rgdispid)
{
	ITypeInfo* pInfo;
	HRESULT hRes = GetTI(lcid, &pInfo);
	if (pInfo != NULL)
	{
		hRes = pInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
		pInfo->Release();
	}
	return hRes;
}

HRESULT CComTypeInfoHolder::Invoke(IDispatch* p, DISPID dispidMember, REFIID /*riid*/,
	LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
	EXCEPINFO* pexcepinfo, UINT* puArgErr)
{
	SetErrorInfo(0, NULL);
	ITypeInfo* pInfo;
	HRESULT hRes = GetTI(lcid, &pInfo);
	if (pInfo != NULL)
	{
		hRes = pInfo->Invoke(p, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
		pInfo->Release();
	}
	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// IDispatch Error handling

HRESULT WINAPI AtlReportError(const CLSID& clsid, UINT nID, const IID& iid,
	HRESULT hRes)
{
	TCHAR szDesc[1024];
	szDesc[0] = NULL;
	// For a valid HRESULT the id should be in the range [0x0200, 0xffff]
	_ASSERTE((nID >= 0x0200 && nID <= 0xffff) || hRes != 0);
	if (LoadString(_Module.GetResourceInstance(), nID, szDesc, 1024) == 0)
	{
		_ASSERTE(FALSE);
		lstrcpy(szDesc, _T("Unknown Error"));
	}
	AtlReportError(clsid, szDesc, iid, hRes);
	if (hRes == 0)
		hRes = MAKE_HRESULT(3, FACILITY_ITF, nID);
	return hRes;
}

#ifndef OLE2ANSI
HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCSTR lpszDesc,
	const IID& iid, HRESULT hRes)
{
	USES_CONVERSION;
	return AtlReportError(clsid, A2CW(lpszDesc), iid, hRes);
}
#endif

HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCOLESTR lpszDesc,
	const IID& iid, HRESULT hRes)
{
	CComPtr<ICreateErrorInfo> pICEI;
	if (SUCCEEDED(CreateErrorInfo(&pICEI)))
	{
		CComPtr<IErrorInfo> pErrorInfo;
		pICEI->SetGUID(iid);
		LPOLESTR lpsz;
		ProgIDFromCLSID(clsid, &lpsz);
		if (lpsz != NULL)
			pICEI->SetSource(lpsz);
		CoTaskMemFree(lpsz);
		pICEI->SetDescription((LPOLESTR)lpszDesc);
		if (SUCCEEDED(pICEI->QueryInterface(IID_IErrorInfo, (void**)&pErrorInfo)))
			SetErrorInfo(0, pErrorInfo);
	}
	return (hRes == 0) ? DISP_E_EXCEPTION : hRes;
}
#endif  // !_ATL_NO_OLEAUT

/////////////////////////////////////////////////////////////////////////////
// QI implementation

#ifdef _ATL_DEBUG_QI
#define _DUMPIID(iid, name, hr) DumpIID(iid, name, hr)
#else
#define _DUMPIID(iid, name, hr) hr
#endif

HRESULT WINAPI CComObjectRoot::InternalQueryInterface(void* pThis,
	const _ATL_INTMAP_ENTRY* pEntries, REFIID iid, void** ppvObject)
{
	_ASSERTE(pThis != NULL);
	// First entry should be an offset (pFunc == 1)
	_ASSERTE(pEntries->pFunc == (_ATL_CREATORARGFUNC*)1);
#ifdef _ATL_DEBUG_QI
	LPCTSTR pszClassName = (LPCTSTR) pEntries[-1].dw;
#endif // _ATL_DEBUG_QI
	if (ppvObject == NULL)
		return _DUMPIID(iid, pszClassName, E_POINTER);
	*ppvObject = NULL;
	if (InlineIsEqualUnknown(iid)) // use first interface
	{
			IUnknown* pUnk = (IUnknown*)((INT_PTR)pThis+pEntries->dw);
			pUnk->AddRef();
			*ppvObject = pUnk;
			return _DUMPIID(iid, pszClassName, S_OK);
	}
	while (pEntries->pFunc != NULL)
	{
		BOOL bBlind = (pEntries->piid == NULL);
		if (bBlind || InlineIsEqualGUID(*(pEntries->piid), iid))
		{
			if (pEntries->pFunc == (_ATL_CREATORARGFUNC*)1) //offset
			{
				_ASSERTE(!bBlind);
				IUnknown* pUnk = (IUnknown*)((INT_PTR)pThis+pEntries->dw);
				pUnk->AddRef();
				*ppvObject = pUnk;
				return _DUMPIID(iid, pszClassName, S_OK);
			}
			else //actual function call
			{
				HRESULT hRes = pEntries->pFunc(pThis,
					iid, ppvObject, pEntries->dw);
				if (hRes == S_OK || (!bBlind && FAILED(hRes)))
					return _DUMPIID(iid, pszClassName, hRes);
			}
		}
		pEntries++;
	}
	return _DUMPIID(iid, pszClassName, E_NOINTERFACE);
}

#ifdef _ATL_DEBUG_QI

HRESULT CComObjectRoot::DumpIID(REFIID iid, LPCTSTR pszClassName, HRESULT hr)
{
	USES_CONVERSION;
	CRegKey key;
	TCHAR szName[100];
	DWORD dwType,dw = sizeof(szName);

	LPOLESTR pszGUID = NULL;
	StringFromCLSID(iid, &pszGUID);
	OutputDebugString(pszClassName);
	OutputDebugString(_T(" - "));

	// Attempt to find it in the interfaces section
	key.Open(HKEY_CLASSES_ROOT, _T("Interface"));
	if (key.Open(key, OLE2T(pszGUID)) == S_OK)
	{
		*szName = 0;
		RegQueryValueEx(key.m_hKey, (LPTSTR)NULL, NULL, &dwType, (LPBYTE)szName, &dw);
		OutputDebugString(szName);
		goto cleanup;
	}
	// Attempt to find it in the clsid section
	key.Open(HKEY_CLASSES_ROOT, _T("CLSID"));
	if (key.Open(key, OLE2T(pszGUID)) == S_OK)
	{
		*szName = 0;
		RegQueryValueEx(key.m_hKey, (LPTSTR)NULL, NULL, &dwType, (LPBYTE)szName, &dw);
		OutputDebugString(_T("(CLSID\?\?\?) "));
		OutputDebugString(szName);
		goto cleanup;
	}
	OutputDebugString(OLE2T(pszGUID));
cleanup:
	if (hr != S_OK)
		OutputDebugString(_T(" - failed"));
	OutputDebugString(_T("\n"));
	CoTaskMemFree(pszGUID);
	return hr;
}
#endif

HRESULT WINAPI CComObjectRoot::_Cache(void* pv, REFIID iid, void** ppvObject, DWORD dw)
{
	HRESULT hRes = E_NOINTERFACE;
	_ATL_CACHEDATA* pcd = (_ATL_CACHEDATA*)(DWORD_PTR)dw;       //$WIN64 dw --> __ptr64
	IUnknown** pp = (IUnknown**)((DWORD_PTR)pv + pcd->dwOffsetVar);
	if (*pp == NULL)
	{
		_ThreadModel::CriticalSection* pcs =
			(_ThreadModel::CriticalSection*)((INT_PTR)pv + pcd->dwOffsetCS);
		pcs->Lock();
		if (*pp == NULL)
			hRes = pcd->pFunc(pv, IID_IUnknown, (void**)pp);
		pcs->Unlock();
	}
	if (*pp != NULL)
		hRes = (*pp)->QueryInterface(iid, ppvObject);
	return hRes;
}

HRESULT WINAPI CComObjectRoot::_Creator(void* pv, REFIID iid, void** ppvObject, DWORD dw)
{
	_ATL_CREATORDATA* pcd = (_ATL_CREATORDATA*)(DWORD_PTR)dw;       //$WIN64 dw --> __ptr64
	return pcd->pFunc(pv, iid, ppvObject);
}

HRESULT WINAPI CComObjectRoot::_Delegate(void* pv, REFIID iid, void** ppvObject, DWORD dw)
{
	HRESULT hRes = E_NOINTERFACE;
	IUnknown* p = *(IUnknown**)((DWORD_PTR)pv + dw);
	if (p != NULL)
		hRes = p->QueryInterface(iid, ppvObject);
	return hRes;
}

HRESULT WINAPI CComObjectRoot::_Chain(void* pv, REFIID iid, void** ppvObject, DWORD dw)
{
	_ATL_CHAINDATA* pcd = (_ATL_CHAINDATA*)(DWORD_PTR)dw;       //$WIN64 dw --> __ptr64
	void* p = (void*)((DWORD_PTR)pv + pcd->dwOffset);
	return InternalQueryInterface(p, pcd->pFunc(), iid, ppvObject);
}

/////////////////////////////////////////////////////////////////////////////
// CComClassFactory

STDMETHODIMP CComClassFactory::CreateInstance(LPUNKNOWN pUnkOuter,
	REFIID riid, void** ppvObj)
{
	_ASSERTE(m_pfnCreateInstance != NULL);
	HRESULT hRes = E_POINTER;
	if (ppvObj != NULL)
	{
		*ppvObj = NULL;
		// can't ask for anything other than IUnknown when aggregating
		_ASSERTE((pUnkOuter == NULL) || InlineIsEqualUnknown(riid));
		if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
			hRes = CLASS_E_NOAGGREGATION;
		else
			hRes = m_pfnCreateInstance(pUnkOuter, riid, ppvObj);
	}
	return hRes;
}

STDMETHODIMP CComClassFactory::LockServer(BOOL fLock)
{
	if (fLock)
		_Module.Lock();
	else
		_Module.Unlock();
	return S_OK;
}

STDMETHODIMP CComClassFactory2Base::LockServer(BOOL fLock)
{
	if (fLock)
		_Module.Lock();
	else
		_Module.Unlock();
	return S_OK;
}

#ifndef _ATL_NO_CONNECTION_POINTS
/////////////////////////////////////////////////////////////////////////////
// Connection Points

CComConnectionPointBase* CComConnectionPointContainerImpl::
	FindConnPoint(REFIID riid)
{
	const _ATL_CONNMAP_ENTRY* pEntry = GetConnMap();
	while (pEntry->dwOffset != (DWORD)-1)
	{
		CComConnectionPointBase* pCP =
			(CComConnectionPointBase*)((INT_PTR)this+pEntry->dwOffset);
		if (InlineIsEqualGUID(riid, *pCP->GetIID()))
			return pCP;
		pEntry++;
	}
	return NULL;
}


void CComConnectionPointContainerImpl::InitCloneVector(
	CComConnectionPointBase** ppCP)
{
	const _ATL_CONNMAP_ENTRY* pEntry = GetConnMap();
	while (pEntry->dwOffset != (DWORD)-1)
	{
		*ppCP = (CComConnectionPointBase*)((INT_PTR)this+pEntry->dwOffset);
		ppCP++;
		pEntry++;
	}
}


STDMETHODIMP CComConnectionPointContainerImpl::EnumConnectionPoints(
	IEnumConnectionPoints** ppEnum)
{
	if (ppEnum == NULL)
		return E_POINTER;
	*ppEnum = NULL;
	CComEnumConnectionPoints* pEnum = NULL;
	ATLTRY(pEnum = new CComObject<CComEnumConnectionPoints>)
	if (pEnum == NULL)
		return E_OUTOFMEMORY;

	// count the entries in the map
	_ATL_CONNMAP_ENTRY* pEntry = (_ATL_CONNMAP_ENTRY*)GetConnMap();
	int nCPCount=0;
	while (pEntry->dwOffset != (DWORD)-1)
	{
		nCPCount++;
		pEntry++;
	}
	_ASSERTE(nCPCount > 0);

	// allocate an initialize a vector of connection point object pointers
	CComConnectionPointBase** ppCP = (CComConnectionPointBase**)alloca(sizeof(CComConnectionPointBase*)*nCPCount);
	InitCloneVector(ppCP);

	// copy the pointers: they will AddRef this object
	HRESULT hRes = pEnum->Init((IConnectionPoint**)&ppCP[0],
		(IConnectionPoint**)&ppCP[nCPCount], this, AtlFlagCopy);
	if (FAILED(hRes))
	{
		delete pEnum;
		return hRes;
	}
	hRes = pEnum->QueryInterface(IID_IEnumConnectionPoints, (void**)ppEnum);
	if (FAILED(hRes))
		delete pEnum;
	return hRes;
}


STDMETHODIMP CComConnectionPointContainerImpl::FindConnectionPoint(
	REFIID riid, IConnectionPoint** ppCP)
{
	if (ppCP == NULL)
		return E_POINTER;
	*ppCP = NULL;
	HRESULT hRes = CONNECT_E_NOCONNECTION;
	CComConnectionPointBase* pCP = FindConnPoint(riid);
	if (pCP != NULL)
	{
		pCP->AddRef();
		*ppCP = pCP;
		hRes = S_OK;
	}
	return hRes;
}


BOOL CComDynamicArrayCONNECTDATA::Add(IUnknown* pUnk)
{
	if (m_nSize == 0) // no connections
	{
		m_cd.pUnk = pUnk;
		m_cd.dwCookie = (DWORD)pUnk;
		m_nSize = 1;
		return TRUE;
	}
	else if (m_nSize == 1)
	{
		//create array
		m_pCD = (CONNECTDATA*)malloc(sizeof(CONNECTDATA)*_DEFAULT_VECTORLENGTH);
		memset(m_pCD, 0, sizeof(CONNECTDATA)*_DEFAULT_VECTORLENGTH);
		m_pCD[0] = m_cd;
		m_nSize = _DEFAULT_VECTORLENGTH;
	}
	for (CONNECTDATA* p = begin();p<end();p++)
	{
		if (p->pUnk == NULL)
		{
			p->pUnk = pUnk;
			p->dwCookie = (DWORD)pUnk;
			return TRUE;
		}
	}
	int nAlloc = m_nSize*2;
	m_pCD = (CONNECTDATA*)realloc(m_pCD, sizeof(CONNECTDATA)*nAlloc);
	memset(&m_pCD[m_nSize], 0, sizeof(CONNECTDATA)*m_nSize);
	m_pCD[m_nSize].pUnk = pUnk;
	m_pCD[m_nSize].dwCookie = (DWORD)pUnk;
	m_nSize = nAlloc;
	return TRUE;
}

BOOL CComDynamicArrayCONNECTDATA::Remove(DWORD dwCookie)
{
	CONNECTDATA* p;
	if (dwCookie == NULL)
		return FALSE;
	if (m_nSize == 0)
		return FALSE;
	if (m_nSize == 1)
	{
		if (m_cd.dwCookie == dwCookie)
		{
			m_nSize = 0;
			return TRUE;
		}
		return FALSE;
	}
	for (p=begin();p<end();p++)
	{
		if (p->dwCookie == dwCookie)
		{
			p->pUnk = NULL;
			p->dwCookie = NULL;
			return TRUE;
		}
	}
	return FALSE;
}

STDMETHODIMP CComConnectionPointBase::GetConnectionInterface(IID* piid)
{
	if (piid == NULL)
		return E_POINTER;
	*piid = *(IID*)GetIID();
	return S_OK;
}

STDMETHODIMP CComConnectionPointBase::GetConnectionPointContainer(IConnectionPointContainer** ppCPC)
{
	if (ppCPC == NULL)
		return E_POINTER;
	_ASSERTE(m_pContainer != NULL);
	*ppCPC = m_pContainer;
	m_pContainer->AddRef();
	return S_OK;
}

#endif //!_ATL_NO_CONNECTION_POINTS

/////////////////////////////////////////////////////////////////////////////
// statics

static UINT WINAPI AtlGetDirLen(LPCOLESTR lpszPathName)
{
	_ASSERTE(lpszPathName != NULL);

	// always capture the complete file name including extension (if present)
	LPCOLESTR lpszTemp = lpszPathName;
	for (LPCOLESTR lpsz = lpszPathName; *lpsz != NULL; )
	{
		LPCOLESTR lp = CharNextO(lpsz);
		// remember last directory/drive separator
		if (*lpsz == OLESTR('\\') || *lpsz == OLESTR('/') || *lpsz == OLESTR(':'))
			lpszTemp = lp;
		lpsz = lp;
	}

	return (UINT)(lpszTemp-lpszPathName);
}

/////////////////////////////////////////////////////////////////////////////
// Object Registry Support

static HRESULT WINAPI AtlRegisterProgID(LPCTSTR lpszCLSID, LPCTSTR lpszProgID, LPCTSTR lpszUserDesc)
{
	CRegKey keyProgID;
	LONG lRes = keyProgID.Create(HKEY_CLASSES_ROOT, lpszProgID);
	if (lRes == ERROR_SUCCESS)
	{
		keyProgID.SetValue(lpszUserDesc);
		keyProgID.SetKeyValue(_T("CLSID"), lpszCLSID);
		return S_OK;
	}
	return HRESULT_FROM_WIN32(lRes);
}

#ifndef _ATL_NO_OLEAUT
HRESULT WINAPI CComModule::UpdateRegistryFromResource(UINT nResID, BOOL bRegister,
	struct _ATL_REGMAP_ENTRY* pMapEntries)
{
	CComPtr<IRegister> p;
	HRESULT hRes = CoCreateInstance(CLSID_Register, NULL,
		CLSCTX_INPROC_SERVER, IID_IRegister, (void**)&p);
	if (SUCCEEDED(hRes))
	{
		TCHAR szModule[_MAX_PATH];
		GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH);
		p->AddReplacement(CComBSTR(OLESTR("Module")), CComBSTR(szModule));
		if (NULL != pMapEntries)
		{
			while (NULL != pMapEntries->szKey)
			{
				_ASSERTE(NULL != pMapEntries->szData);

				CComBSTR bstrKey(pMapEntries->szKey);
				CComBSTR bstrValue(pMapEntries->szData);
				p->AddReplacement(bstrKey, bstrValue);
				pMapEntries++;
			}
		}

		CComVariant varRes;
		varRes.vt = VT_I2;
		varRes.iVal = (short)nResID;
		CComVariant varReg(OLESTR("REGISTRY"));
		GetModuleFileName(_Module.GetRegistryResourceInstance(), szModule, _MAX_PATH);
		CComBSTR bstrModule = szModule;
		if (bRegister)
		{
			hRes = p->ResourceRegister(bstrModule, varRes, varReg);
		}
		else
		{
			hRes = p->ResourceUnregister(bstrModule, varRes, varReg);
		}
	}
	return hRes;
}

HRESULT WINAPI CComModule::UpdateRegistryFromResource(LPCTSTR lpszRes, BOOL bRegister,
	struct _ATL_REGMAP_ENTRY* pMapEntries)
{
	CComPtr<IRegister> p;
	HRESULT hRes = CoCreateInstance(CLSID_Register, NULL,
		CLSCTX_INPROC_SERVER, IID_IRegister, (void**)&p);
	if (SUCCEEDED(hRes))
	{
		TCHAR szModule[_MAX_PATH];
		GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH);
		p->AddReplacement(CComBSTR(OLESTR("Module")), CComBSTR(szModule));
		if (NULL != pMapEntries)
		{
			while (NULL != pMapEntries->szKey)
			{
				_ASSERTE(NULL != pMapEntries->szData);

				CComBSTR bstrKey(pMapEntries->szKey);
				CComBSTR bstrValue(pMapEntries->szData);

				p->AddReplacement(bstrKey, bstrValue);
				pMapEntries++;
			}
		}
		CComVariant varRes(lpszRes);
		CComVariant varReg(OLESTR("REGISTRY"));
		GetModuleFileName(_Module.GetRegistryResourceInstance(), szModule, _MAX_PATH);
		CComBSTR bstrModule = szModule;
		if (bRegister)
		{
			hRes = p->ResourceRegister(bstrModule, varRes, varReg);
		}
		else
		{
			hRes = p->ResourceUnregister(bstrModule, varRes, varReg);
		}
	}
	return hRes;
}
#endif  // !_ATL_NO_OLEAUT

#ifdef _ATL_STATIC_REGISTRY
// Statically linking to Registry Ponent
HRESULT WINAPI CComModule::UpdateRegistryFromResourceS(UINT nResID, BOOL bRegister,
	struct _ATL_REGMAP_ENTRY* pMapEntries)
{
	CRegObject      ro;
	CRegException   re;
	TCHAR szModule[_MAX_PATH];
	GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH);
	ro.AddReplacement(OLESTR("Module"), CComBSTR(szModule));
	if (NULL != pMapEntries)
	{
		while (NULL != pMapEntries->szKey)
		{
			_ASSERTE(NULL != pMapEntries->szData);
			ro.AddReplacement(CComBSTR(pMapEntries->szKey),
				CComBSTR(pMapEntries->szData));
			pMapEntries++;
		}
	}

	CComVariant varRes;
	varRes.vt = VT_I2;
	varRes.iVal = (short)nResID;
	CComVariant varReg(OLESTR("REGISTRY"));
	GetModuleFileName(_Module.GetRegistryResourceInstance(), szModule, _MAX_PATH);
	CComBSTR bstrModule = szModule;
	return (bRegister) ? ro.ResourceRegister(bstrModule, varRes, varReg, re) :
		ro.ResourceUnregister(bstrModule, varRes, varReg, re);
}

HRESULT WINAPI CComModule::UpdateRegistryFromResourceS(LPCTSTR lpszRes, BOOL bRegister,
	struct _ATL_REGMAP_ENTRY* pMapEntries)
{
	CRegObject      ro;
	CRegException   re;
	TCHAR szModule[_MAX_PATH];
	GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH);
	ro.AddReplacement(OLESTR("Module"), CComBSTR(szModule));
	if (NULL != pMapEntries)
	{
		while (NULL != pMapEntries->szKey)
		{
			_ASSERTE(NULL != pMapEntries->szData);
			ro.AddReplacement(CComBSTR(pMapEntries->szKey),
				CComBSTR(pMapEntries->szData));
			pMapEntries++;
		}
	}

	CComVariant varRes(lpszRes);
	CComVariant varReg(OLESTR("REGISTRY"));
	GetModuleFileName(_Module.GetRegistryResourceInstance(), szModule, _MAX_PATH);
	CComBSTR bstrModule = szModule;
	return (bRegister) ? ro.ResourceRegister(bstrModule, varRes, varReg, re) :
		ro.ResourceUnregister(bstrModule, varRes, varReg, re);
}
#endif // _ATL_STATIC_REGISTRY

#ifndef _ATL_NO_OLD_REGISTRY
HRESULT WINAPI CComModule::UpdateRegistryClass(const CLSID& clsid, LPCTSTR lpszProgID,
	LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags, BOOL bRegister)
{
	if (bRegister)
	{
		return RegisterClassHelper(clsid, lpszProgID, lpszVerIndProgID, nDescID,
			dwFlags);
	}
	else
		return UnregisterClassHelper(clsid, lpszProgID, lpszVerIndProgID);
}

HRESULT WINAPI CComModule::RegisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
	LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags)
{
	static const TCHAR szProgID[] = _T("ProgID");
	static const TCHAR szVIProgID[] = _T("VersionIndependentProgID");
	static const TCHAR szLS32[] = _T("LocalServer32");
	static const TCHAR szIPS32[] = _T("InprocServer32");
	static const TCHAR szThreadingModel[] = _T("ThreadingModel");
	static const TCHAR szAUTPRX32[] = _T("AUTPRX32.DLL");
	static const TCHAR szApartment[] = _T("Apartment");
	static const TCHAR szBoth[] = _T("both");
	USES_CONVERSION;
	HRESULT hRes = S_OK;
	TCHAR szDesc[256];
	LoadString(m_hInst, nDescID, szDesc, 256);
	TCHAR szModule[_MAX_PATH];
	GetModuleFileName(m_hInst, szModule, _MAX_PATH);

	LPOLESTR lpOleStr;
	StringFromCLSID(clsid, &lpOleStr);
	LPTSTR lpsz = OLE2T(lpOleStr);

    if(lpsz == NULL) 
    {   
        if(lpOleStr)CoTaskMemFree(lpOleStr);
        return E_OUTOFMEMORY;
    }

	hRes = AtlRegisterProgID(lpsz, lpszProgID, szDesc);
	if (hRes == S_OK)
		hRes = AtlRegisterProgID(lpsz, lpszVerIndProgID, szDesc);
	LONG lRes = ERROR_SUCCESS;
	if (hRes == S_OK)
	{
		CRegKey key;
		LONG lRes = key.Open(HKEY_CLASSES_ROOT, _T("CLSID"));
		if (lRes == ERROR_SUCCESS)
		{
			lRes = key.Create(key, lpsz);
			if (lRes == ERROR_SUCCESS)
			{
				key.SetValue(szDesc);
				key.SetKeyValue(szProgID, lpszProgID);
				key.SetKeyValue(szVIProgID, lpszVerIndProgID);

				if ((m_hInst == NULL) || (m_hInst == GetModuleHandle(NULL))) // register as EXE
					key.SetKeyValue(szLS32, szModule);
				else
				{
					key.SetKeyValue(szIPS32, (dwFlags & AUTPRXFLAG) ? szAUTPRX32 : szModule);
					LPCTSTR lpszModel = (dwFlags & THREADFLAGS_BOTH) ? szBoth :
						(dwFlags & THREADFLAGS_APARTMENT) ? szApartment : NULL;
					if (lpszModel != NULL)
						key.SetKeyValue(szIPS32, lpszModel, szThreadingModel);
				}
			}
		}
	}
	CoTaskMemFree(lpOleStr);
	if (lRes != ERROR_SUCCESS)
		hRes = HRESULT_FROM_WIN32(lRes);
	return hRes;
}

HRESULT WINAPI CComModule::UnregisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
	LPCTSTR lpszVerIndProgID)
{
	USES_CONVERSION;
	CRegKey key;
	key.Attach(HKEY_CLASSES_ROOT);
	key.RecurseDeleteKey(lpszProgID);
	key.RecurseDeleteKey(lpszVerIndProgID);
	LPOLESTR lpOleStr;
	StringFromCLSID(clsid, &lpOleStr);
	LPTSTR lpsz = OLE2T(lpOleStr);
	if (key.Open(key, _T("CLSID")) == ERROR_SUCCESS)
		key.RecurseDeleteKey(lpsz);
	CoTaskMemFree(lpOleStr);
	return S_OK;
}
#endif  // _ATL_NO_OLD_REGISTRY

#ifndef _ATL_NO_OLEAUT
/////////////////////////////////////////////////////////////////////////////
// TypeLib Support

HRESULT CComModule::RegisterTypeLib(LPCTSTR lpszIndex)
{
    USES_CONVERSION;
    _ASSERTE(m_hInst != NULL);
    TCHAR szModule[_MAX_PATH+10];
    OLECHAR szDir[_MAX_PATH];
    szModule[0] = 0;
    GetModuleFileName(GetTypeLibInstance(), szModule, _MAX_PATH);
    if (lpszIndex != NULL)
        lstrcat(szModule, lpszIndex);
    ITypeLib* pTypeLib;
    LPOLESTR lpszModule = T2OLE(szModule);
    HRESULT hr = LoadTypeLib(lpszModule, &pTypeLib);
    if (!SUCCEEDED(hr))
    {
		// typelib not in module, try <module>.tlb instead
		LPTSTR lpszExt = NULL;
		LPTSTR lpsz;
		for (lpsz = szModule; *lpsz != NULL; lpsz = CharNext(lpsz))
		{
			if (*lpsz == _T('.'))
				lpszExt = lpsz;
		}
		if (lpszExt == NULL)
			lpszExt = lpsz;
		lstrcpy(lpszExt, _T(".tlb"));
		lpszModule = T2OLE(szModule);
		hr = LoadTypeLib(lpszModule, &pTypeLib);
	}
	if (SUCCEEDED(hr))
	{
		ocscpy(szDir, lpszModule);
		szDir[AtlGetDirLen(szDir)] = 0;
		hr = ::RegisterTypeLib(pTypeLib, lpszModule, szDir);
	}
	if (pTypeLib != NULL)
		pTypeLib->Release();
	return hr;
}
#endif  // !_ATL_NO_OLEAUT

/////////////////////////////////////////////////////////////////////////////
// CRegKey

LONG CRegKey::Close()
{
	LONG lRes = ERROR_SUCCESS;
	if (m_hKey != NULL)
	{
		lRes = RegCloseKey(m_hKey);
		m_hKey = NULL;
	}
	return lRes;
}

LONG CRegKey::Create(HKEY hKeyParent, LPCTSTR lpszKeyName,
	LPTSTR lpszClass, DWORD dwOptions, REGSAM samDesired,
	LPSECURITY_ATTRIBUTES lpSecAttr, LPDWORD lpdwDisposition)
{
	_ASSERTE(hKeyParent != NULL);
	DWORD dw;
	HKEY hKey = NULL;
	LONG lRes = RegCreateKeyEx(hKeyParent, lpszKeyName, 0,
		lpszClass, dwOptions, samDesired, lpSecAttr, &hKey, &dw);
	if (lpdwDisposition != NULL)
		*lpdwDisposition = dw;
	if (lRes == ERROR_SUCCESS)
	{
		lRes = Close();
		m_hKey = hKey;
	}
	return lRes;
}

LONG CRegKey::Open(HKEY hKeyParent, LPCTSTR lpszKeyName, REGSAM samDesired)
{
	_ASSERTE(hKeyParent != NULL);
	HKEY hKey = NULL;
	LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey);
	if (lRes == ERROR_SUCCESS)
	{
		lRes = Close();
		_ASSERTE(lRes == ERROR_SUCCESS);
		m_hKey = hKey;
	}
	return lRes;
}

LONG CRegKey::QueryValue(DWORD& dwValue, LPCTSTR lpszValueName)
{
	DWORD dwType = NULL;
	DWORD dwCount = sizeof(DWORD);
	LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
		(LPBYTE)&dwValue, &dwCount);
	_ASSERTE((lRes!=ERROR_SUCCESS) || (dwType == REG_DWORD));
	_ASSERTE((lRes!=ERROR_SUCCESS) || (dwCount == sizeof(DWORD)));
	return lRes;
}

LONG WINAPI CRegKey::SetValue(HKEY hKeyParent, LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	_ASSERTE(lpszValue != NULL);
	CRegKey key;
	LONG lRes = key.Create(hKeyParent, lpszKeyName);
	if (lRes == ERROR_SUCCESS)
		lRes = key.SetValue(lpszValue, lpszValueName);
	return lRes;
}

LONG CRegKey::SetKeyValue(LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	_ASSERTE(lpszValue != NULL);
	CRegKey key;
	LONG lRes = key.Create(m_hKey, lpszKeyName);
	if (lRes == ERROR_SUCCESS)
		lRes = key.SetValue(lpszValue, lpszValueName);
	return lRes;
}

//RecurseDeleteKey is necessary because on NT RegDeleteKey doesn't work if the
//specified key has subkeys
LONG CRegKey::RecurseDeleteKey(LPCTSTR lpszKey)
{
	CRegKey key;
	LONG lRes = key.Open(m_hKey, lpszKey);
	if (lRes != ERROR_SUCCESS)
		return lRes;
	FILETIME time;
	TCHAR szBuffer[256];
	DWORD dwSize = 256;
	while (RegEnumKeyEx(key.m_hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL,
		&time)==ERROR_SUCCESS)
	{
		lRes = key.RecurseDeleteKey(szBuffer);
		if (lRes != ERROR_SUCCESS)
			return lRes;
		dwSize = 256;
	}
	key.Close();
	return DeleteSubKey(lpszKey);
}

#ifndef _ATL_NO_SECURITY

CSecurityDescriptor::CSecurityDescriptor()
{
	m_pSD = NULL;
	m_pOwner = NULL;
	m_pGroup = NULL;
	m_pDACL = NULL;
	m_pSACL= NULL;
}

CSecurityDescriptor::~CSecurityDescriptor()
{
	if (m_pSD)
		delete m_pSD;
	if (m_pOwner)
		free(m_pOwner);
	if (m_pGroup)
		free(m_pGroup);
	if (m_pDACL)
		free(m_pDACL);
	if (m_pSACL)
		free(m_pSACL);
}

HRESULT CSecurityDescriptor::Initialize()
{
	if (m_pSD)
	{
		delete m_pSD;
		m_pSD = NULL;
	}
	if (m_pOwner)
	{
		free(m_pOwner);
		m_pOwner = NULL;
	}
	if (m_pGroup)
	{
		free(m_pGroup);
		m_pGroup = NULL;
	}
	if (m_pDACL)
	{
		free(m_pDACL);
		m_pDACL = NULL;
	}
	if (m_pSACL)
	{
		free(m_pSACL);
		m_pSACL = NULL;
	}

	m_pSD = new SECURITY_DESCRIPTOR;
	if (!m_pSD)
		return E_OUTOFMEMORY;
	if (!InitializeSecurityDescriptor(m_pSD, SECURITY_DESCRIPTOR_REVISION))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		delete m_pSD;
		m_pSD = NULL;
		_ASSERTE(FALSE);
		return hr;
	}
	// Set the DACL to allow EVERYONE
	SetSecurityDescriptorDacl(m_pSD, TRUE, NULL, FALSE);
	return S_OK;
}

HRESULT CSecurityDescriptor::InitializeFromProcessToken(BOOL bDefaulted)
{
	PSID pUserSid;
	PSID pGroupSid;
	HRESULT hr;

	Initialize();
	hr = GetProcessSids(&pUserSid, &pGroupSid);
	if (FAILED(hr))
		return hr;
	hr = SetOwner(pUserSid, bDefaulted);
	if (FAILED(hr))
		return hr;
	hr = SetGroup(pGroupSid, bDefaulted);
	if (FAILED(hr))
		return hr;
	return S_OK;
}

HRESULT CSecurityDescriptor::InitializeFromThreadToken(BOOL bDefaulted, BOOL bRevertToProcessToken)
{
	PSID pUserSid;
	PSID pGroupSid;
	HRESULT hr;

	Initialize();
	hr = GetThreadSids(&pUserSid, &pGroupSid);
	if (HRESULT_CODE(hr) == ERROR_NO_TOKEN && bRevertToProcessToken)
		hr = GetProcessSids(&pUserSid, &pGroupSid);
	if (FAILED(hr))
		return hr;
	hr = SetOwner(pUserSid, bDefaulted);
	if (FAILED(hr))
		return hr;
	hr = SetGroup(pGroupSid, bDefaulted);
	if (FAILED(hr))
		return hr;
	return S_OK;
}

HRESULT CSecurityDescriptor::SetOwner(PSID pOwnerSid, BOOL bDefaulted)
{
	_ASSERTE(m_pSD);

	// Mark the SD as having no owner
	if (!SetSecurityDescriptorOwner(m_pSD, NULL, bDefaulted))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		return hr;
	}

	if (m_pOwner)
	{
		free(m_pOwner);
		m_pOwner = NULL;
	}

	// If they asked for no owner don't do the copy
	if (pOwnerSid == NULL)
		return S_OK;

	// Make a copy of the Sid for the return value
	DWORD dwSize = GetLengthSid(pOwnerSid);

	m_pOwner = (PSID) malloc(dwSize);
	if (!m_pOwner)
	{
		// Insufficient memory to allocate Sid
		_ASSERTE(FALSE);
		return E_OUTOFMEMORY;
	}
	if (!CopySid(dwSize, m_pOwner, pOwnerSid))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		free(m_pOwner);
		m_pOwner = NULL;
		return hr;
	}

	_ASSERTE(IsValidSid(m_pOwner));

	if (!SetSecurityDescriptorOwner(m_pSD, m_pOwner, bDefaulted))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		free(m_pOwner);
		m_pOwner = NULL;
		return hr;
	}

	return S_OK;
}

HRESULT CSecurityDescriptor::SetGroup(PSID pGroupSid, BOOL bDefaulted)
{
	_ASSERTE(m_pSD);

	// Mark the SD as having no Group
	if (!SetSecurityDescriptorGroup(m_pSD, NULL, bDefaulted))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		return hr;
	}

	if (m_pGroup)
	{
		free(m_pGroup);
		m_pGroup = NULL;
	}

	// If they asked for no Group don't do the copy
	if (pGroupSid == NULL)
		return S_OK;

	// Make a copy of the Sid for the return value
	DWORD dwSize = GetLengthSid(pGroupSid);

	m_pGroup = (PSID) malloc(dwSize);
	if (!m_pGroup)
	{
		// Insufficient memory to allocate Sid
		_ASSERTE(FALSE);
		return E_OUTOFMEMORY;
	}
	if (!CopySid(dwSize, m_pGroup, pGroupSid))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		free(m_pGroup);
		m_pGroup = NULL;
		return hr;
	}

	_ASSERTE(IsValidSid(m_pGroup));

	if (!SetSecurityDescriptorGroup(m_pSD, m_pGroup, bDefaulted))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		free(m_pGroup);
		m_pGroup = NULL;
		return hr;
	}

	return S_OK;
}

HRESULT CSecurityDescriptor::Allow(LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
	HRESULT hr = AddAccessAllowedACEToACL(&m_pDACL, pszPrincipal, dwAccessMask);
	if (SUCCEEDED(hr))
		SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
	return hr;
}

HRESULT CSecurityDescriptor::Deny(LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
	HRESULT hr = AddAccessDeniedACEToACL(&m_pDACL, pszPrincipal, dwAccessMask);
	if (SUCCEEDED(hr))
		SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
	return hr;
}

HRESULT CSecurityDescriptor::Revoke(LPCTSTR pszPrincipal)
{
	HRESULT hr = RemovePrincipalFromACL(m_pDACL, pszPrincipal);
	if (SUCCEEDED(hr))
		SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
	return hr;
}

HRESULT CSecurityDescriptor::GetProcessSids(PSID* ppUserSid, PSID* ppGroupSid)
{
	BOOL bRes;
	HRESULT hr;
	HANDLE hToken = NULL;
	if (ppUserSid)
		*ppUserSid = NULL;
	if (ppGroupSid)
		*ppGroupSid = NULL;
	bRes = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken);
	if (!bRes)
	{
		// Couldn't open process token
		hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		return hr;
	}
	hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
	return hr;
}

HRESULT CSecurityDescriptor::GetThreadSids(PSID* ppUserSid, PSID* ppGroupSid, BOOL bOpenAsSelf)
{
	BOOL bRes;
	HRESULT hr;
	HANDLE hToken = NULL;
	if (ppUserSid)
		*ppUserSid = NULL;
	if (ppGroupSid)
		*ppGroupSid = NULL;
	bRes = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, bOpenAsSelf, &hToken);
	if (!bRes)
	{
		// Couldn't open thread token
		hr = HRESULT_FROM_WIN32(GetLastError());
		return hr;
	}
	hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
	return hr;
}


HRESULT CSecurityDescriptor::GetTokenSids(HANDLE hToken, PSID* ppUserSid, PSID* ppGroupSid)
{
	DWORD dwSize;
	HRESULT hr;
	PTOKEN_USER ptkUser = NULL;
	PTOKEN_PRIMARY_GROUP ptkGroup = NULL;

	if (ppUserSid)
		*ppUserSid = NULL;
	if (ppGroupSid)
		*ppGroupSid = NULL;

	if (ppUserSid)
	{
		// Get length required for TokenUser by specifying buffer length of 0
		GetTokenInformation(hToken, TokenUser, NULL, 0, &dwSize);
		hr = GetLastError();
		if (hr != ERROR_INSUFFICIENT_BUFFER)
		{
			// Expected ERROR_INSUFFICIENT_BUFFER
			_ASSERTE(FALSE);
			hr = HRESULT_FROM_WIN32(hr);
			goto failed;
		}

		ptkUser = (TOKEN_USER*) malloc(dwSize);
		if (!ptkUser)
		{
			// Insufficient memory to allocate TOKEN_USER
			_ASSERTE(FALSE);
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		// Get Sid of process token.
		if (!GetTokenInformation(hToken, TokenUser, ptkUser, dwSize, &dwSize))
		{
			// Couldn't get user info
			hr = HRESULT_FROM_WIN32(GetLastError());
			_ASSERTE(FALSE);
			goto failed;
		}

		// Make a copy of the Sid for the return value
		dwSize = GetLengthSid(ptkUser->User.Sid);

		PSID pSid = (PSID) malloc(dwSize);
		if (!pSid)
		{
			// Insufficient memory to allocate Sid
			_ASSERTE(FALSE);
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		if (!CopySid(dwSize, pSid, ptkUser->User.Sid))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			_ASSERTE(FALSE);
			goto failed;
		}

		_ASSERTE(IsValidSid(pSid));
		*ppUserSid = pSid;
		free(ptkUser);
	}
	if (ppGroupSid)
	{
		// Get length required for TokenPrimaryGroup by specifying buffer length of 0
		GetTokenInformation(hToken, TokenPrimaryGroup, NULL, 0, &dwSize);
		hr = GetLastError();
		if (hr != ERROR_INSUFFICIENT_BUFFER)
		{
			// Expected ERROR_INSUFFICIENT_BUFFER
			_ASSERTE(FALSE);
			hr = HRESULT_FROM_WIN32(hr);
			goto failed;
		}

		ptkGroup = (TOKEN_PRIMARY_GROUP*) malloc(dwSize);
		if (!ptkGroup)
		{
			// Insufficient memory to allocate TOKEN_USER
			_ASSERTE(FALSE);
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		// Get Sid of process token.
		if (!GetTokenInformation(hToken, TokenPrimaryGroup, ptkGroup, dwSize, &dwSize))
		{
			// Couldn't get user info
			hr = HRESULT_FROM_WIN32(GetLastError());
			_ASSERTE(FALSE);
			goto failed;
		}

		// Make a copy of the Sid for the return value
		dwSize = GetLengthSid(ptkGroup->PrimaryGroup);

		PSID pSid = (PSID) malloc(dwSize);
		if (!pSid)
		{
			// Insufficient memory to allocate Sid
			_ASSERTE(FALSE);
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		if (!CopySid(dwSize, pSid, ptkGroup->PrimaryGroup))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			_ASSERTE(FALSE);
			goto failed;
		}

		_ASSERTE(IsValidSid(pSid));

		*ppGroupSid = pSid;
		free(ptkGroup);
	}

	return S_OK;

failed:
	if (ptkUser)
		free(ptkUser);
	if (ptkGroup)
		free (ptkGroup);
	return hr;
}


HRESULT CSecurityDescriptor::GetCurrentUserSID(PSID *ppSid)
{
	HANDLE tkHandle;

	if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &tkHandle))
	{
		TOKEN_USER *tkUser;
		DWORD tkSize;
		DWORD sidLength;

		// Call to get size information for alloc
		GetTokenInformation(tkHandle, TokenUser, NULL, 0, &tkSize);
		tkUser = (TOKEN_USER *) malloc(tkSize);

		// Now make the real call
		if (GetTokenInformation(tkHandle, TokenUser, tkUser, tkSize, &tkSize))
		{
			sidLength = GetLengthSid(tkUser->User.Sid);
			*ppSid = (PSID) malloc(sidLength);

			memcpy(*ppSid, tkUser->User.Sid, sidLength);
			CloseHandle(tkHandle);

			free(tkUser);
			return S_OK;
		}
		else
		{
			free(tkUser);
			return HRESULT_FROM_WIN32(GetLastError());
		}
	}
	return HRESULT_FROM_WIN32(GetLastError());
}


HRESULT CSecurityDescriptor::GetPrincipalSID(LPCTSTR pszPrincipal, PSID *ppSid)
{
	HRESULT hr;
	LPTSTR pszRefDomain = NULL;
	DWORD dwDomainSize = 0;
	DWORD dwSidSize = 0;
	SID_NAME_USE snu;

	// Call to get size info for alloc
	LookupAccountName(NULL, pszPrincipal, *ppSid, &dwSidSize, pszRefDomain, &dwDomainSize, &snu);

	hr = GetLastError();
	if (hr != ERROR_INSUFFICIENT_BUFFER)
		return HRESULT_FROM_WIN32(hr);

	pszRefDomain = new TCHAR[dwDomainSize];
	if (pszRefDomain == NULL)
		return E_OUTOFMEMORY;

	*ppSid = (PSID) malloc(dwSidSize);
	if (*ppSid != NULL)
	{
		if (!LookupAccountName(NULL, pszPrincipal, *ppSid, &dwSidSize, pszRefDomain, &dwDomainSize, &snu))
		{
			free(*ppSid);
			*ppSid = NULL;
			delete[] pszRefDomain;
			return HRESULT_FROM_WIN32(GetLastError());
		}
		delete[] pszRefDomain;
		return S_OK;
	}
	delete[] pszRefDomain;
	return E_OUTOFMEMORY;
}


HRESULT CSecurityDescriptor::Attach(PSECURITY_DESCRIPTOR pSelfRelativeSD)
{
	PACL    pDACL = NULL;
	PACL    pSACL = NULL;
	BOOL    bDACLPresent, bSACLPresent;
	BOOL    bDefaulted;
	PACL    m_pDACL = NULL;
	ACCESS_ALLOWED_ACE* pACE;
	HRESULT hr;
	PSID    pUserSid;
	PSID    pGroupSid;

	hr = Initialize();
	if(FAILED(hr))
		return hr;

	// get the existing DACL.
	if (!GetSecurityDescriptorDacl(pSelfRelativeSD, &bDACLPresent, &pDACL, &bDefaulted))
		goto failed;

	if (bDACLPresent)
	{
		if (pDACL)
		{
			// allocate new DACL.
			if (!(m_pDACL = (PACL) malloc(pDACL->AclSize)))
				goto failed;

			// initialize the DACL
			if (!InitializeAcl(m_pDACL, pDACL->AclSize, ACL_REVISION))
				goto failed;

			// copy the ACES
			for (int i = 0; i < pDACL->AceCount; i++)
			{
				if (!GetAce(pDACL, i, (void **)&pACE))
					goto failed;

				if (!AddAccessAllowedAce(m_pDACL, ACL_REVISION, pACE->Mask, (PSID)&(pACE->SidStart)))
					goto failed;
			}

			if (!IsValidAcl(m_pDACL))
				goto failed;
		}

		// set the DACL
		if (!SetSecurityDescriptorDacl(m_pSD, m_pDACL ? TRUE : FALSE, m_pDACL, bDefaulted))
			goto failed;
	}

	// get the existing SACL.
	if (!GetSecurityDescriptorSacl(pSelfRelativeSD, &bSACLPresent, &pSACL, &bDefaulted))
		goto failed;

	if (bSACLPresent)
	{
		if (pSACL)
		{
			// allocate new SACL.
			if (!(m_pSACL = (PACL) malloc(pSACL->AclSize)))
				goto failed;

			// initialize the SACL
			if (!InitializeAcl(m_pSACL, pSACL->AclSize, ACL_REVISION))
				goto failed;

			// copy the ACES
			for (int i = 0; i < pSACL->AceCount; i++)
			{
				if (!GetAce(pSACL, i, (void **)&pACE))
					goto failed;

				if (!AddAccessAllowedAce(m_pSACL, ACL_REVISION, pACE->Mask, (PSID)&(pACE->SidStart)))
					goto failed;
			}

			if (!IsValidAcl(m_pSACL))
				goto failed;
		}

		// set the SACL
		if (!SetSecurityDescriptorSacl(m_pSD, m_pSACL ? TRUE : FALSE, m_pSACL, bDefaulted))
			goto failed;
	}

	if (!GetSecurityDescriptorOwner(m_pSD, &pUserSid, &bDefaulted))
		goto failed;

	if (FAILED(SetOwner(pUserSid, bDefaulted)))
		goto failed;

	if (!GetSecurityDescriptorGroup(m_pSD, &pGroupSid, &bDefaulted))
		goto failed;

	if (FAILED(SetGroup(pGroupSid, bDefaulted)))
		goto failed;

	if (!IsValidSecurityDescriptor(m_pSD))
		goto failed;

	return hr;

failed:
	if (m_pDACL)
		free(m_pDACL);
	if (m_pSD)
		free(m_pSD);
	return E_UNEXPECTED;
}

HRESULT CSecurityDescriptor::AttachObject(HANDLE hObject)
{
	HRESULT hr;
	DWORD dwSize = 0;
	PSECURITY_DESCRIPTOR pSD = NULL;

	GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
		DACL_SECURITY_INFORMATION, pSD, 0, &dwSize);

	hr = GetLastError();
	if (hr != ERROR_INSUFFICIENT_BUFFER)
		return HRESULT_FROM_WIN32(hr);

	pSD = (PSECURITY_DESCRIPTOR) malloc(dwSize);

	if (!GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
		DACL_SECURITY_INFORMATION, pSD, dwSize, &dwSize))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		free(pSD);
		return hr;
	}

	hr = Attach(pSD);
	free(pSD);
	return hr;
}


HRESULT CSecurityDescriptor::CopyACL(PACL pDest, PACL pSrc)
{
	ACL_SIZE_INFORMATION aclSizeInfo;
	LPVOID pAce;
	ACE_HEADER *aceHeader;

	if (pSrc == NULL)
		return S_OK;

	if (!GetAclInformation(pSrc, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
		return HRESULT_FROM_WIN32(GetLastError());

	// Copy all of the ACEs to the new ACL
	for (UINT i = 0; i < aclSizeInfo.AceCount; i++)
	{
		if (!GetAce(pSrc, i, &pAce))
			return HRESULT_FROM_WIN32(GetLastError());

		aceHeader = (ACE_HEADER *) pAce;

		if (!AddAce(pDest, ACL_REVISION, 0xffffffff, pAce, aceHeader->AceSize))
			return HRESULT_FROM_WIN32(GetLastError());
	}

	return S_OK;
}

HRESULT CSecurityDescriptor::AddAccessDeniedACEToACL(PACL *ppAcl, LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
	ACL_SIZE_INFORMATION aclSizeInfo;
	int aclSize;
	DWORD returnValue;
	PSID principalSID;
	PACL oldACL, newACL;

	oldACL = *ppAcl;

	returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
	if (FAILED(returnValue))
		return returnValue;

	aclSizeInfo.AclBytesInUse = 0;
	if (*ppAcl != NULL)
		GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

	aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_DENIED_ACE) + GetLengthSid(principalSID) - sizeof(DWORD);

	newACL = (PACL) new BYTE[aclSize];

	if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
	{
		free(principalSID);
		return HRESULT_FROM_WIN32(GetLastError());
	}

	if (!AddAccessDeniedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID))
	{
		free(principalSID);
		return HRESULT_FROM_WIN32(GetLastError());
	}

	returnValue = CopyACL(newACL, oldACL);
	if (FAILED(returnValue))
	{
		free(principalSID);
		return returnValue;
	}

	*ppAcl = newACL;

	if (oldACL != NULL)
		free(oldACL);
	free(principalSID);
	return S_OK;
}


HRESULT CSecurityDescriptor::AddAccessAllowedACEToACL(PACL *ppAcl, LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
	ACL_SIZE_INFORMATION aclSizeInfo;
	int aclSize;
	DWORD returnValue;
	PSID principalSID;
	PACL oldACL, newACL;

	oldACL = *ppAcl;

	returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
	if (FAILED(returnValue))
		return returnValue;

	aclSizeInfo.AclBytesInUse = 0;
	if (*ppAcl != NULL)
		GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

	aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(principalSID) - sizeof(DWORD);

	newACL = (PACL) new BYTE[aclSize];

	if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
	{
		free(principalSID);
		return HRESULT_FROM_WIN32(GetLastError());
	}

	returnValue = CopyACL(newACL, oldACL);
	if (FAILED(returnValue))
	{
		free(principalSID);
		return returnValue;
	}

	if (!AddAccessAllowedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID))
	{
		free(principalSID);
		return HRESULT_FROM_WIN32(GetLastError());
	}

	*ppAcl = newACL;

	if (oldACL != NULL)
		free(oldACL);
	free(principalSID);
	return S_OK;
}


HRESULT CSecurityDescriptor::RemovePrincipalFromACL(PACL pAcl, LPCTSTR pszPrincipal)
{
	ACL_SIZE_INFORMATION aclSizeInfo;
	ULONG i;
	LPVOID ace;
	ACCESS_ALLOWED_ACE *accessAllowedAce;
	ACCESS_DENIED_ACE *accessDeniedAce;
	SYSTEM_AUDIT_ACE *systemAuditAce;
	PSID principalSID;
	DWORD returnValue;
	ACE_HEADER *aceHeader;

	returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
	if (FAILED(returnValue))
		return returnValue;

	GetAclInformation(pAcl, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

	for (i = 0; i < aclSizeInfo.AceCount; i++)
	{
		if (!GetAce(pAcl, i, &ace))
		{
			free(principalSID);
			return HRESULT_FROM_WIN32(GetLastError());
		}

		aceHeader = (ACE_HEADER *) ace;

		if (aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
		{
			accessAllowedAce = (ACCESS_ALLOWED_ACE *) ace;

			if (EqualSid(principalSID, (PSID) &accessAllowedAce->SidStart))
			{
				DeleteAce(pAcl, i);
				free(principalSID);
				return S_OK;
			}
		} else

		if (aceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
		{
			accessDeniedAce = (ACCESS_DENIED_ACE *) ace;

			if (EqualSid(principalSID, (PSID) &accessDeniedAce->SidStart))
			{
				DeleteAce(pAcl, i);
				free(principalSID);
				return S_OK;
			}
		} else

		if (aceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE)
		{
			systemAuditAce = (SYSTEM_AUDIT_ACE *) ace;

			if (EqualSid(principalSID, (PSID) &systemAuditAce->SidStart))
			{
				DeleteAce(pAcl, i);
				free(principalSID);
				return S_OK;
			}
		}
	}
	free(principalSID);
	return S_OK;
}


HRESULT CSecurityDescriptor::SetPrivilege(LPCTSTR privilege, BOOL bEnable, HANDLE hToken)
{
	HRESULT hr;
	TOKEN_PRIVILEGES tpPrevious;
	TOKEN_PRIVILEGES tp;
	DWORD cbPrevious = sizeof(TOKEN_PRIVILEGES);
	LUID luid;

	// if no token specified open process token
	if (hToken == 0)
	{
		if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			_ASSERTE(FALSE);
			return hr;
		}
	}

	if (!LookupPrivilegeValue(NULL, privilege, &luid ))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		return hr;
	}

	tp.PrivilegeCount = 1;
	tp.Privileges[0].Luid = luid;
	tp.Privileges[0].Attributes = 0;

	if (!AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), &tpPrevious, &cbPrevious))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		return hr;
	}

	tpPrevious.PrivilegeCount = 1;
	tpPrevious.Privileges[0].Luid = luid;

	if (bEnable)
		tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
	else
		tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED & tpPrevious.Privileges[0].Attributes);

	if (!AdjustTokenPrivileges(hToken, FALSE, &tpPrevious, cbPrevious, NULL, NULL))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		return hr;
	}
	return S_OK;
}


#endif //_ATL_NO_SECURITY

#ifdef _DEBUG
#include <stdio.h>
#include <stdarg.h>

void _cdecl AtlTrace(LPCTSTR lpszFormat, ...)
{
	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	TCHAR szBuffer[512];

	nBuf = wvsprintf(szBuffer, lpszFormat, args);
	_ASSERTE(nBuf < sizeof(szBuffer));

	OutputDebugString(szBuffer);
	va_end(args);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// Minimize CRT
// Specify DllMain as EntryPoint
// Turn off exception handling
// Define _ATL_MIN_CRT

#ifdef _ATL_MIN_CRT
/////////////////////////////////////////////////////////////////////////////
// Heap Allocation

#ifndef _DEBUG

#ifndef _ATL_NO_FLTUSED
extern "C" const int _fltused = 0;
#endif

#ifndef USE_IERT
_CRTNOALIAS _CRTRESTRICT void* __cdecl malloc(size_t n)
{
	if (_Module.m_hHeap == NULL)
	{
		_Module.m_hHeap = HeapCreate(0, 0, 0);
		if (_Module.m_hHeap == NULL)
			return NULL;
	}
	_ASSERTE(_Module.m_hHeap != NULL);

#ifdef _MALLOC_ZEROINIT
	void* p = HeapAlloc(_Module.m_hHeap, 0, n);
	if (p != NULL)
		memset(p, 0, n);
	return p;
#else
	return HeapAlloc(_Module.m_hHeap, 0, n);
#endif
}

_CRTNOALIAS _CRTRESTRICT void* __cdecl calloc(size_t n, size_t s)
{
#ifdef _MALLOC_ZEROINIT
	return malloc(n * s);
#else
	void* p = malloc(n * s);
	if (p != NULL)
		memset(p, 0, n * s);
	return p;
#endif
}

_CRTNOALIAS void __cdecl free(void* p)
{
	_ASSERTE(_Module.m_hHeap != NULL);
	if (p != NULL)
		HeapFree(_Module.m_hHeap, 0, p);
}
#endif // USE_IERT

#if 0
_CRTNOALIAS _CRTRESTRICT void* __cdecl realloc(void* p, size_t n)
{
	_ASSERTE(_Module.m_hHeap != NULL);
	return (p == NULL) ? malloc(n) : HeapReAlloc(_Module.m_hHeap, 0, p, n);
}
#endif

#endif  //_DEBUG

#if !defined(_DEBUG) || defined(USE_IERT)

#ifndef _MERGE_PROXYSTUB
int __cdecl _purecall()
{
#if DBG==1
	DebugBreak();
#endif // DBG
	return 0;
}
#endif  // !_MERGE_PROXYSTUB

void* __cdecl operator new(size_t n)
{
	return malloc(n);
}

void __cdecl operator delete(void* p)
{
	free(p);
}
#endif //!defined(_DEBUG) || defined(USE_IERT)

#endif //_ATL_MIN_CRT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\imgutil\cddsurf.h ===
#define DECLARE_MEMCLEAR_NEW_DELETE \
    void * __cdecl operator new(size_t cb) { void *pv = malloc(cb); if (pv) ZeroMemory(pv, cb); return pv; } \
    void __cdecl operator delete(void * pv) { free(pv); }

class CVoid
{
};

class CBaseFT : public CVoid
{
public:

    DECLARE_MEMCLEAR_NEW_DELETE

    ULONG               AddRef()               { return((ULONG)InterlockedIncrement((LONG *)&_ulRefs)); }
    ULONG               Release();
    ULONG               SubAddRef()            { return((ULONG)InterlockedIncrement((LONG *)&_ulAllRefs)); }
    ULONG               SubRelease();
    CRITICAL_SECTION *  GetPcs() { return(_pcs); }
    void                SetPcs(CRITICAL_SECTION *pcs) { _pcs = pcs; }
    ULONG               GetRefs()              { return(_ulRefs); }
    ULONG               GetAllRefs()           { return(_ulAllRefs); }

    void                EnterCriticalSection() { if (_pcs) ::EnterCriticalSection(_pcs); }
    void                LeaveCriticalSection() { if (_pcs) ::LeaveCriticalSection(_pcs); }

protected:

                        CBaseFT(CRITICAL_SECTION * pcs = NULL);
    virtual            ~CBaseFT();
    virtual void        Passivate();
    ULONG               InterlockedRelease()   { return((ULONG)InterlockedDecrement((LONG *)&_ulRefs)); }

private:

    CRITICAL_SECTION *  _pcs;
    ULONG               _ulRefs;
    ULONG               _ulAllRefs;
};


class CDDrawWrapper : public CBaseFT, public IDirectDrawSurface, public IDirectDrawPalette
{
    typedef CBaseFT super;
    
public:
    CDDrawWrapper(HBITMAP hbmDib);
    ~CDDrawWrapper();

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    STDMETHOD(QueryInterface)(REFIID iid, void** ppInterface);

    // IDirectDrawSurface
    STDMETHOD(AddAttachedSurface)(LPDIRECTDRAWSURFACE lpdds);
    STDMETHOD(AddOverlayDirtyRect)(LPRECT lprc);
    STDMETHOD(Blt)(LPRECT lprcDest, LPDIRECTDRAWSURFACE lpdds, LPRECT lprcSrc, DWORD dw, LPDDBLTFX lpfx);
    STDMETHOD(BltBatch)(LPDDBLTBATCH lpBlt, DWORD dwCount, DWORD dwFlags);
    STDMETHOD(BltFast)(DWORD dwX, DWORD dwY, LPDIRECTDRAWSURFACE lpdds, LPRECT lprcSrc, DWORD dwTrans);
    STDMETHOD(DeleteAttachedSurface)(DWORD dwFlags, LPDIRECTDRAWSURFACE lpdds);
    STDMETHOD(EnumAttachedSurfaces)(LPVOID lpContext, LPDDENUMSURFACESCALLBACK lpfn);
    STDMETHOD(EnumOverlayZOrders)(DWORD dwFlags, LPVOID lpContext, LPDDENUMSURFACESCALLBACK lpfn);
    STDMETHOD(Flip)(LPDIRECTDRAWSURFACE lpdds, DWORD dwFlags);
    STDMETHOD(GetAttachedSurface)(LPDDSCAPS lpCaps, LPDIRECTDRAWSURFACE FAR * lpdds);
    STDMETHOD(GetBltStatus)(DWORD dw);
    STDMETHOD(GetCaps)(LPDDSCAPS lpCaps);
    STDMETHOD(GetClipper)(LPDIRECTDRAWCLIPPER FAR* lpClipper);
    STDMETHOD(GetColorKey)(DWORD dw, LPDDCOLORKEY lpKey);
    STDMETHOD(GetDC)(HDC FAR * lphdc);
    STDMETHOD(GetFlipStatus)(DWORD dw);
    STDMETHOD(GetOverlayPosition)(LPLONG lpl1, LPLONG lpl2);
    STDMETHOD(GetPalette)(LPDIRECTDRAWPALETTE FAR* ppPal);
    STDMETHOD(GetPixelFormat)(LPDDPIXELFORMAT pPixelFormat);
    STDMETHOD(GetSurfaceDesc)(LPDDSURFACEDESC pSurfaceDesc);
    STDMETHOD(Initialize)(LPDIRECTDRAW pDD, LPDDSURFACEDESC pSurfaceDesc);
    STDMETHOD(IsLost)();
    STDMETHOD(Lock)(LPRECT pRect, LPDDSURFACEDESC pSurfaceDesc, DWORD dwFlags, HANDLE hEvent);
    STDMETHOD(ReleaseDC)(HDC hdc);
    STDMETHOD(Restore)();
    STDMETHOD(SetClipper)(LPDIRECTDRAWCLIPPER pClipper);
    STDMETHOD(SetColorKey)(DWORD dwFlags, LPDDCOLORKEY pDDColorKey);
    STDMETHOD(SetOverlayPosition)(LONG x, LONG y);
    STDMETHOD(SetPalette)(LPDIRECTDRAWPALETTE pDDPal);
    STDMETHOD(Unlock)(LPVOID pBits);
    STDMETHOD(UpdateOverlay)(LPRECT prc, LPDIRECTDRAWSURFACE pdds, LPRECT prc2, DWORD dw, LPDDOVERLAYFX pfx);
    STDMETHOD(UpdateOverlayDisplay)(DWORD dw);
    STDMETHOD(UpdateOverlayZOrder)(DWORD dw, LPDIRECTDRAWSURFACE pdds);

    // IDirectDrawPalette
    STDMETHOD(SetEntries)(DWORD dwFlags, DWORD dwStart, DWORD dwCount, LPPALETTEENTRY pEntries);
    STDMETHOD(GetCaps)(LPDWORD lpdw);
    STDMETHOD(GetEntries)(DWORD dwFlags, DWORD dwStart, DWORD dwCount, LPPALETTEENTRY pEntries);
    STDMETHOD(Initialize)(LPDIRECTDRAW lpdd, DWORD dwCount, LPPALETTEENTRY pEntries);

protected:
    HBITMAP         m_hbmDib;
    DIBSECTION      m_dsSurface;
    DDCOLORKEY      m_ddColorKey;
    LONG            m_lPitch;
    RECT            m_rcSurface;
    BYTE *          m_pbBits;
};

HBITMAP ImgCreateDib(LONG xWid, LONG yHei, BOOL fPal, int cBitsPerPix,
    int cEnt, PALETTEENTRY * ppe, BYTE ** ppbBits, int * pcbRow);
HBITMAP ImgCreateDibFromInfo(BITMAPINFO * pbmi, UINT wUsage, BYTE ** ppbBits, int * pcbRow);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\imgutil\cddsurf.cpp ===
#include "stdafx.h"
#include "imgutil.h"
#include "ddraw.h"
#include "cddsurf.h"

// Get rid of "synonyms" warning
#pragma warning(disable : 4097)

// Get rid of "unused formal parameters warning"
#pragma warning(disable : 4100)

#undef  DEFINE_GUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }

DEFINE_GUID( IID_IDirectDrawSurface,		0x6C14DB81,0xA733,0x11CE,0xA5,0x21,0x00,
0x20,0xAF,0x0B,0xE5,0x60 );

DEFINE_GUID( IID_IDirectDrawPalette,		0x6C14DB84,0xA733,0x11CE,0xA5,0x21,0x00,
0x20,0xAF,0x0B,0xE5,0x60 );

const RGBQUAD     g_rgbBgColor = { 0xFF, 0xFF, 0xFF, 0 };
const RGBQUAD     g_rgbFgColor = { 0x00, 0x00, 0x00, 0 };

const PALETTEENTRY g_peVga[16] =
{
    { 0x00, 0x00, 0x00, 0x00 }, // Black
    { 0x80, 0x00, 0x00, 0x00 }, // Dark red
    { 0x00, 0x80, 0x00, 0x00 }, // Dark green
    { 0x80, 0x80, 0x00, 0x00 }, // Dark yellow
    { 0x00, 0x00, 0x80, 0x00 }, // Dark blue
    { 0x80, 0x00, 0x80, 0x00 }, // Dark purple
    { 0x00, 0x80, 0x80, 0x00 }, // Dark aqua
    { 0xC0, 0xC0, 0xC0, 0x00 }, // Light grey
    { 0x80, 0x80, 0x80, 0x00 }, // Dark grey
    { 0xFF, 0x00, 0x00, 0x00 }, // Light red
    { 0x00, 0xFF, 0x00, 0x00 }, // Light green
    { 0xFF, 0xFF, 0x00, 0x00 }, // Light yellow
    { 0x00, 0x00, 0xFF, 0x00 }, // Light blue
    { 0xFF, 0x00, 0xFF, 0x00 }, // Light purple
    { 0x00, 0xFF, 0xFF, 0x00 }, // Light aqua
    { 0xFF, 0xFF, 0xFF, 0x00 }  // White
};

#define Verify(x) (x)

LONG g_lSecondaryObjCount = 0;

#define DecrementSecondaryObjectCount( idCaller ) DecrementSecondaryObjectCount_Actual()

inline void
DecrementSecondaryObjectCount_Actual()
{
    InterlockedDecrement(&g_lSecondaryObjCount);
}

#define IncrementSecondaryObjectCount( idCaller ) IncrementSecondaryObjectCount_Actual()

inline void
IncrementSecondaryObjectCount_Actual()
{
    Verify(InterlockedIncrement(&g_lSecondaryObjCount) > 0);
}

CBaseFT::CBaseFT(CRITICAL_SECTION * pcs)
{
    _ulRefs     = 1;
    _ulAllRefs  = 1;
    _pcs        = pcs;
    IncrementSecondaryObjectCount(10);
}

CBaseFT::~CBaseFT()
{
    DecrementSecondaryObjectCount(10);
}

void CBaseFT::Passivate()
{
}

ULONG CBaseFT::Release()
{
    ULONG ulRefs = (ULONG)InterlockedDecrement((LONG *)&_ulRefs);

    if (ulRefs == 0)
    {
        Passivate();
        SubRelease();
    }

    return(ulRefs);
}

ULONG CBaseFT::SubRelease()
{
    ULONG ulRefs = (ULONG)InterlockedDecrement((LONG *)&_ulAllRefs);

    if (ulRefs == 0)
    {
        delete this;
    }

    return(ulRefs);
}

void CopyColorsFromPaletteEntries(RGBQUAD *prgb, const PALETTEENTRY *ppe,
    UINT uCount)
{
    while (uCount--)
    {
        prgb->rgbRed   = ppe->peRed;
        prgb->rgbGreen = ppe->peGreen;
        prgb->rgbBlue  = ppe->peBlue;
        prgb->rgbReserved = 0;

        prgb++;
        ppe++;
    }
}


void CopyPaletteEntriesFromColors(PALETTEENTRY *ppe, const RGBQUAD *prgb,
    UINT uCount)
{
    while (uCount--)
    {
        ppe->peRed   = prgb->rgbRed;
        ppe->peGreen = prgb->rgbGreen;
        ppe->peBlue  = prgb->rgbBlue;
        ppe->peFlags = 0;

        prgb++;
        ppe++;
    }
}

#define MASK565_0   0x0000F800
#define MASK565_1   0x000007E0
#define MASK565_2   0x0000001F

HBITMAP ImgCreateDib(LONG xWid, LONG yHei, BOOL fPal, int cBitsPerPix,
    int cEnt, PALETTEENTRY * ppe, BYTE ** ppbBits, int * pcbRow)
{
    struct {
        BITMAPINFOHEADER bmih;
        union {
            RGBQUAD argb[256];
            WORD aw[256];
            DWORD adw[3];
        } u;
    } bmi;
    int i;

    if (cBitsPerPix != 8)
        fPal = FALSE;

    bmi.bmih.biSize          = sizeof(BITMAPINFOHEADER);
    bmi.bmih.biWidth         = xWid;
    bmi.bmih.biHeight        = yHei;
    bmi.bmih.biPlanes        = 1;
    bmi.bmih.biBitCount      = (WORD)((cBitsPerPix == 15) ? 16 : cBitsPerPix);
    bmi.bmih.biCompression   = (cBitsPerPix == 16) ? BI_BITFIELDS : BI_RGB;
    bmi.bmih.biSizeImage     = 0;
    bmi.bmih.biXPelsPerMeter = 0;
    bmi.bmih.biYPelsPerMeter = 0;
    bmi.bmih.biClrUsed       = 0;
    bmi.bmih.biClrImportant  = 0;

    if (cBitsPerPix == 1)
    {
        bmi.bmih.biClrUsed = 2;

        if (cEnt > 2)
            cEnt = 2;

        if (cEnt > 0)
        {
            bmi.bmih.biClrImportant = cEnt;
            CopyColorsFromPaletteEntries(bmi.u.argb, ppe, cEnt);
        }
        else
        {
            bmi.u.argb[0] = g_rgbBgColor;
            bmi.u.argb[1] = g_rgbFgColor;
        }
    }
    else if (cBitsPerPix == 4)
    {
        bmi.bmih.biClrUsed = 16;

        if (cEnt > 16)
            cEnt = 16;

        if (cEnt > 0)
        {
            bmi.bmih.biClrImportant = cEnt;
            CopyColorsFromPaletteEntries(bmi.u.argb, ppe, cEnt);
        }
        else
        {
            bmi.bmih.biClrImportant = 16;
            CopyColorsFromPaletteEntries(bmi.u.argb, g_peVga, 16);
        }
    }
    else if (cBitsPerPix == 8)
    {
        if (fPal)
        {
            bmi.bmih.biClrUsed = 256;

            for (i = 0; i < 256; ++i)
                bmi.u.aw[i] = (WORD)i;
        }
        else
        {
            if (cEnt > 0 && cEnt < 256)
            {
                bmi.bmih.biClrUsed = cEnt;
                bmi.bmih.biClrImportant = cEnt;
            }
            else
                bmi.bmih.biClrUsed = 256;

            if (cEnt && ppe)
            {
                CopyColorsFromPaletteEntries(bmi.u.argb, ppe, cEnt);
            }
        }
    }
    else if (cBitsPerPix == 16)
    {
        bmi.u.adw[0] = MASK565_0;
        bmi.u.adw[1] = MASK565_1;
        bmi.u.adw[2] = MASK565_2;
    }

    return ImgCreateDibFromInfo((BITMAPINFO *)&bmi, fPal ? DIB_PAL_COLORS : DIB_RGB_COLORS, ppbBits, pcbRow);
}


HBITMAP ImgCreateDibFromInfo(BITMAPINFO * pbmi, UINT wUsage, BYTE ** ppbBits, int * pcbRow)
{
    HDC 	hdcMem = NULL;
    HBITMAP	hbm = NULL;
    BYTE * 	pbBits;
    int 	cbRow;
    LONG    xWid, yHei;
    int 	cBitsPerPix;

    xWid = pbmi->bmiHeader.biWidth;
    yHei = pbmi->bmiHeader.biHeight;
    cBitsPerPix = pbmi->bmiHeader.biBitCount;
    
	cbRow = ((xWid * cBitsPerPix + 31) & ~31) / 8;

    if (pcbRow)
    {
        *pcbRow = cbRow;
    }

    hdcMem = CreateCompatibleDC(NULL);

    if (hdcMem == NULL)
        goto Cleanup;

    hbm = CreateDIBSection(hdcMem, pbmi, wUsage, (void **)&pbBits, NULL, 0);

    if (hbm && ppbBits)
    {
        *ppbBits = pbBits;
    }

Cleanup:
    if (hdcMem)
        DeleteDC(hdcMem);

    return(hbm);
}

CDDrawWrapper::CDDrawWrapper(HBITMAP hbmDib)
{
    m_hbmDib = hbmDib;
    GetObject(hbmDib, sizeof(DIBSECTION), &m_dsSurface);
    m_lPitch = ((m_dsSurface.dsBmih.biWidth * m_dsSurface.dsBmih.biBitCount + 31) & ~31) / 8;
    if (m_dsSurface.dsBmih.biHeight > 0)
    {
        m_pbBits = (BYTE *)m_dsSurface.dsBm.bmBits + (m_dsSurface.dsBm.bmHeight - 1) * m_lPitch;
        m_lPitch = -m_lPitch;
    }
    else
    {
        m_pbBits = (BYTE *)m_dsSurface.dsBm.bmBits;
    }

    // left, top already 0
    m_rcSurface.right = m_dsSurface.dsBm.bmWidth;
    m_rcSurface.bottom = m_dsSurface.dsBm.bmHeight;

    // initialize transparent index to -1
    m_ddColorKey.dwColorSpaceLowValue = m_ddColorKey.dwColorSpaceHighValue = (DWORD)-1;
}

CDDrawWrapper::~CDDrawWrapper()
{
}

STDMETHODIMP
CDDrawWrapper::QueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IDirectDrawSurface)
        *ppv = (IUnknown *)(IDirectDrawSurface *)this;
    else if (riid == IID_IDirectDrawPalette)
        *ppv = (IUnknown *)(IDirectDrawPalette *)this;
    else if (riid == IID_IUnknown)
        *ppv = (IUnknown *)(IDirectDrawSurface *)this;
    else    
        *ppv = NULL;

    if (*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return(S_OK);
    }
    else
    {
        return(E_NOINTERFACE);
    }
}

STDMETHODIMP_(ULONG)
CDDrawWrapper::AddRef()
{
    return(super::AddRef());
}

STDMETHODIMP_(ULONG)
CDDrawWrapper::Release()
{
    return(super::Release());
}

STDMETHODIMP CDDrawWrapper::GetColorKey(DWORD dw, LPDDCOLORKEY lpKey)
{
    if (dw != DDCKEY_SRCBLT)
        return E_INVALIDARG;

    if (lpKey == NULL)
        return E_POINTER;

    memcpy(lpKey, &m_ddColorKey, sizeof(DDCOLORKEY));

    return S_OK;
}

STDMETHODIMP CDDrawWrapper::GetPalette(LPDIRECTDRAWPALETTE FAR* ppPal)
{
    if (ppPal == NULL)
        return E_POINTER;
        
    // Return interface to set color table if DIB section has one
    
    if (m_dsSurface.dsBmih.biBitCount <= 8)
    {
        *ppPal = (LPDIRECTDRAWPALETTE)this;
        ((LPUNKNOWN)*ppPal)->AddRef();
        return S_OK;
    }
    else
    {
        *ppPal = NULL;
        return E_NOINTERFACE;
    }
}


STDMETHODIMP CDDrawWrapper::SetColorKey(DWORD dwFlags, LPDDCOLORKEY pDDColorKey)
{
    if (dwFlags != DDCKEY_SRCBLT)
        return E_INVALIDARG;

    if (pDDColorKey == NULL)
        return E_POINTER;

    memcpy(&m_ddColorKey, pDDColorKey, sizeof(DDCOLORKEY));

    return S_OK;
}

STDMETHODIMP CDDrawWrapper::SetEntries(DWORD dwFlags, DWORD dwStart, DWORD dwCount, LPPALETTEENTRY pEntries)
{
    RGBQUAD argb[256];
    DWORD nColors = (DWORD)(1 << m_dsSurface.dsBmih.biBitCount);
    UINT nColorsSet;
    HDC hdc;
    HBITMAP hbm;
    
    if (dwFlags)
        return E_INVALIDARG;

    if (dwStart >= nColors || dwStart + dwCount > nColors)
        return E_INVALIDARG;

    if (pEntries == NULL)
        return E_POINTER;

    CopyColorsFromPaletteEntries(argb, pEntries, dwCount);
    hdc = CreateCompatibleDC(NULL);
    if (hdc)
    {
        hbm = (HBITMAP)SelectObject(hdc, m_hbmDib);
        nColorsSet = SetDIBColorTable(hdc, (UINT)dwStart, (UINT)dwCount, argb);
        SelectObject(hdc, hbm);
        DeleteDC(hdc);
    }
    else
        nColorsSet = 0;
    
    return nColorsSet ? S_OK : E_FAIL;
}

STDMETHODIMP CDDrawWrapper::GetEntries(DWORD dwFlags, DWORD dwStart, DWORD dwCount, LPPALETTEENTRY pEntries)
{
    RGBQUAD argb[256];
    DWORD nColors = (DWORD)(1 << m_dsSurface.dsBmih.biBitCount);
    UINT nColorsGet;
    HDC hdc;
    HBITMAP hbm;
    
    if (dwFlags)
        return E_INVALIDARG;

    if (dwStart >= nColors || dwStart + dwCount > nColors)
        return E_INVALIDARG;

    if (pEntries == NULL)
        return E_POINTER;

    hdc = CreateCompatibleDC(NULL);
    if (hdc)
    {
        hbm = (HBITMAP)SelectObject(hdc, m_hbmDib);
        nColorsGet = GetDIBColorTable(hdc, (UINT)dwStart, (UINT)dwCount, argb);
        SelectObject(hdc, hbm);
        DeleteDC(hdc);
    }
    else
        return E_FAIL;

    if (nColorsGet)
        CopyPaletteEntriesFromColors(pEntries, argb, dwCount);

    return nColorsGet ? S_OK : E_FAIL;
}


STDMETHODIMP CDDrawWrapper::Lock(LPRECT pRect, LPDDSURFACEDESC pSurfaceDesc, DWORD dwFlags, HANDLE hEvent)
{
    RECT    rcClip;
    
    if (pRect == NULL || pSurfaceDesc == NULL)
        return E_POINTER;

    if (pSurfaceDesc->dwSize != sizeof(DDSURFACEDESC))
        return E_INVALIDARG;

    if (hEvent)
        return E_INVALIDARG;

    IntersectRect(&rcClip, pRect, &m_rcSurface);
    if (!EqualRect(&rcClip, pRect))
        return E_INVALIDARG;
        
    pSurfaceDesc->dwFlags = DDSD_WIDTH | DDSD_HEIGHT | DDSD_PITCH;
    pSurfaceDesc->dwWidth = m_dsSurface.dsBm.bmWidth;
    pSurfaceDesc->dwHeight = m_dsSurface.dsBm.bmHeight;
    pSurfaceDesc->lPitch = m_lPitch;

    pSurfaceDesc->lpSurface = (LPVOID)(m_pbBits 
                                + pRect->top * m_lPitch 
                                + ((pRect->left * m_dsSurface.dsBmih.biBitCount) / 8));
     
    return S_OK;
}


STDMETHODIMP CDDrawWrapper::Unlock(LPVOID pBits)
{
    return S_OK;
}

// The remainder of these methods are not needed by the plugin filters

STDMETHODIMP CDDrawWrapper::AddAttachedSurface(LPDIRECTDRAWSURFACE lpdds)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::AddOverlayDirtyRect(LPRECT lprc)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::Blt(LPRECT lprcDest, LPDIRECTDRAWSURFACE lpdds, LPRECT lprcSrc, DWORD dw, LPDDBLTFX lpfx)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::BltBatch(LPDDBLTBATCH lpBlt, DWORD dwCount, DWORD dwFlags)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::BltFast(DWORD dwX, DWORD dwY, LPDIRECTDRAWSURFACE lpdds, LPRECT lprcSrc, DWORD dwTrans)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::DeleteAttachedSurface(DWORD dwFlags, LPDIRECTDRAWSURFACE lpdds)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::EnumAttachedSurfaces(LPVOID lpContext, LPDDENUMSURFACESCALLBACK lpfn)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::EnumOverlayZOrders(DWORD dwFlags, LPVOID lpContext, LPDDENUMSURFACESCALLBACK lpfn)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::Flip(LPDIRECTDRAWSURFACE lpdds, DWORD dwFlags)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::GetAttachedSurface(LPDDSCAPS lpCaps, LPDIRECTDRAWSURFACE FAR * lpdds)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::GetBltStatus(DWORD dw)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::GetCaps(LPDDSCAPS lpCaps)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::GetClipper(LPDIRECTDRAWCLIPPER FAR* lpClipper)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::GetDC(HDC FAR * lphdc)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::GetFlipStatus(DWORD dw)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::GetOverlayPosition(LPLONG lpl1, LPLONG lpl2)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::GetPixelFormat(LPDDPIXELFORMAT pPixelFormat)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::GetSurfaceDesc(LPDDSURFACEDESC pSurfaceDesc)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::Initialize(LPDIRECTDRAW pDD, LPDDSURFACEDESC pSurfaceDesc)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::IsLost()
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::ReleaseDC(HDC hdc)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::Restore()
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::SetClipper(LPDIRECTDRAWCLIPPER pClipper)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::SetOverlayPosition(LONG x, LONG y)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::SetPalette(LPDIRECTDRAWPALETTE pDDPal)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::UpdateOverlay(LPRECT prc, LPDIRECTDRAWSURFACE pdds, LPRECT prc2, DWORD dw, LPDDOVERLAYFX pfx)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::UpdateOverlayDisplay(DWORD dw)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::UpdateOverlayZOrder(DWORD dw, LPDIRECTDRAWSURFACE pdds)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::GetCaps(LPDWORD lpdw)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::Initialize(LPDIRECTDRAW lpdd, DWORD dwCount, LPPALETTEENTRY pEntries)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\imgutil\cdith8.cpp ===
#include "stdafx.h"
#include "resource.h"
#include "imgutil.h"
#include "cdithtbl.h"
#include "dithers.h"
#include "cdith8.h"
#include "align.h"
#include "cddsurf.h"
//#include <icapexp.h>

void CopyColorsFromPaletteEntries(RGBQUAD *prgb, const PALETTEENTRY *ppe, UINT uCount);

CDitherTable* CDitherToRGB8::s_apTableCache[MAX_DITHERTABLE_CACHE_SIZE];
ULONG CDitherToRGB8::s_nCacheSize;
CRITICAL_SECTION CDitherToRGB8::s_csCache;

void CDitherToRGB8::InitTableCache()
{
   ULONG iTable;

   InitializeCriticalSection( &s_csCache );

   s_nCacheSize = 0;
   for( iTable = 0; iTable < MAX_DITHERTABLE_CACHE_SIZE; iTable++ )
   {
      s_apTableCache[iTable] = NULL;
   }
}

void CDitherToRGB8::CleanupTableCache()
{
   ULONG iTable;

   EnterCriticalSection( &s_csCache );
   for( iTable = 0; iTable < s_nCacheSize; iTable++ )
   {
      _ASSERTE( s_apTableCache[iTable]->m_nRefCount == 0 );
      delete s_apTableCache[iTable];
      s_apTableCache[iTable] = NULL;
   }
   s_nCacheSize = 0;
   LeaveCriticalSection( &s_csCache );

   DeleteCriticalSection( &s_csCache );
}

CDitherToRGB8::CDitherToRGB8() :
   m_dwEvents( 0 ),
   m_iScanLine( 0 ),
   m_bProgressiveDither( FALSE ),
   m_pErrBuf( NULL ),
   m_pErrBuf1( NULL ),
   m_pErrBuf2( NULL ),
   m_pTable( NULL ),
   m_pbBits( NULL ),
   m_hbmDestDib( NULL )
{
}

CDitherToRGB8::~CDitherToRGB8()
{
    if (m_pTable)
        m_pTable->m_nRefCount--;

    if (m_hbmDestDib)
        DeleteObject(m_hbmDestDib);   
}

STDMETHODIMP CDitherToRGB8::GetSurface( LONG nWidth, LONG nHeight, 
   REFGUID bfid, ULONG nPasses, DWORD dwHints, IUnknown** ppSurface )
{
    HRESULT hResult;
    CComPtr< IUnknown > pDestSurface;

    if (ppSurface != NULL)
        *ppSurface = NULL;
      
    if ((nWidth <= 0) || (nHeight <= 0))
        return E_INVALIDARG;
        
    if (ppSurface == NULL)
        return E_POINTER;

    if (IsEqualGUID(bfid, BFID_RGB_24))
    {
        m_eSrcFormat = RGB24;
        m_nBitsPerPixel = 24;
    }
    else if (IsEqualGUID(bfid, BFID_INDEXED_RGB_8))
    {
        m_eSrcFormat = RGB8;
        m_nBitsPerPixel = 8;
    }
    else
        return E_NOINTERFACE;

    m_nWidth = nWidth;
    m_nHeight = nHeight;

    if ((dwHints & IMGDECODE_HINT_TOPDOWN) && 
        (dwHints & IMGDECODE_HINT_FULLWIDTH) &&
        (m_dwEvents & IMGDECODE_EVENT_PROGRESS))
        m_bProgressiveDither = TRUE;
    else
        m_bProgressiveDither = FALSE;

    m_pErrBuf = new ERRBUF[(m_nWidth+2)*2];
    if (m_pErrBuf == NULL)
      return E_OUTOFMEMORY;

    m_pErrBuf1 = &m_pErrBuf[1];
    m_pErrBuf2 = &m_pErrBuf[m_nWidth+3];

    memset(m_pErrBuf, 0, sizeof( ERRBUF )*(m_nWidth+2)*2);

    hResult = m_pEventSink->GetSurface(m_nWidth, m_nHeight, BFID_INDEXED_RGB_8,
        nPasses, dwHints, &pDestSurface);
    if (FAILED(hResult))
        return( hResult );

    hResult = pDestSurface->QueryInterface(IID_IDirectDrawSurface, 
                                            (void **)&m_pDestSurface);
    if (FAILED(hResult))
        return hResult;
    
    m_hbmDestDib = ImgCreateDib(m_nWidth, -LONG(m_nHeight), FALSE, m_nBitsPerPixel, 0, NULL, 
                        &m_pbBits, (int *)&m_nPitch);
    if (m_hbmDestDib == NULL)
        return E_OUTOFMEMORY;

    hResult = CreateDDrawSurfaceOnDIB(m_hbmDestDib, &m_pSurface);
    if (FAILED(hResult))
        return hResult;
        
    *ppSurface = (IUnknown *)m_pSurface;
    (*ppSurface)->AddRef();

    return S_OK;
}

STDMETHODIMP CDitherToRGB8::OnBeginDecode( DWORD* pdwEvents, ULONG* pnFormats,
   GUID** ppFormats )
{
   HRESULT hResult;
   GUID* pFormats;
   ULONG nFormats;
   ULONG iFormat;
   BOOL bFound;

   if( pdwEvents != NULL )
   {
      *pdwEvents = 0;
   }
   if( pnFormats != NULL )
   {
      *pnFormats = 0;
   }
   if( ppFormats != NULL )
   {
      *pnFormats = NULL;
   }
   if( pdwEvents == NULL )
   {
      return( E_POINTER );
   }
   if( pnFormats == NULL )
   {
      return( E_POINTER );
   }
   if( ppFormats == NULL )
   {
      return( E_POINTER );
   }

   hResult = m_pEventSink->OnBeginDecode( &m_dwEvents, &nFormats, &pFormats );
   if( FAILED( hResult ) )
   {
      return( hResult );
   }

   bFound = FALSE;
   for( iFormat = 0; (iFormat < nFormats) && !bFound; iFormat++ )
   {
      if( IsEqualGUID( pFormats[iFormat], BFID_INDEXED_RGB_8 ) )
      {
         bFound = TRUE;
      }
   }
   CoTaskMemFree( pFormats );
   if( !bFound )
   {
      return( E_FAIL );
   }

   *ppFormats = (GUID*)CoTaskMemAlloc( 3*sizeof( GUID ) );
   if( *ppFormats == NULL )
   {
      return( E_OUTOFMEMORY );
   }
   *pnFormats = 3;
   (*ppFormats)[0] = BFID_GRAY_8;
   (*ppFormats)[1] = BFID_RGB_24;
   (*ppFormats)[2] = BFID_INDEXED_RGB_8;

   *pdwEvents = m_dwEvents|IMGDECODE_EVENT_BITSCOMPLETE|
      IMGDECODE_EVENT_PALETTE;

   return( S_OK );
}

STDMETHODIMP CDitherToRGB8::OnBitsComplete()
{
   HRESULT hResult;

   hResult = DitherFull();
   if( FAILED( hResult ) )
   {
      return( hResult );
   }

   if( m_dwEvents & IMGDECODE_EVENT_BITSCOMPLETE )
   {
      hResult = m_pEventSink->OnBitsComplete();
      if( FAILED( hResult ) )
      {
         return( hResult );
      }
   }

   return( S_OK );
}

STDMETHODIMP CDitherToRGB8::OnDecodeComplete( HRESULT hrStatus )
{
   HRESULT hResult;

   delete m_pErrBuf;
   m_pErrBuf = NULL;
   m_pErrBuf1 = NULL;
   m_pErrBuf2 = NULL;

	// Propagate the transparency information if necessary
	
	if (m_pSurface && m_pDestSurface)
	{
	    DDCOLORKEY  ddKey;

	    if (SUCCEEDED(m_pSurface->GetColorKey(DDCKEY_SRCBLT, &ddKey)))
	        m_pDestSurface->SetColorKey(DDCKEY_SRCBLT, &ddKey);
	}
		
   if( m_pSurface != NULL )
   {
      m_pSurface.Release();
   }
   if( m_pDestSurface != NULL )
   {
      m_pDestSurface.Release();
   }

   hResult = m_pEventSink->OnDecodeComplete( hrStatus );
   m_pEventSink.Release();
   if( FAILED( hResult ) )
   {
      return( hResult );
   }

   return( S_OK );
}

STDMETHODIMP CDitherToRGB8::OnPalette()
{
    HRESULT hResult;
    CComPtr< IDirectDrawPalette > pPalette;
    PALETTEENTRY ape[256];

    if (m_eSrcFormat == RGB8)
    {
        hResult = m_pSurface->GetPalette(&pPalette);
        if (FAILED(hResult))
            return hResult;

        hResult = pPalette->GetEntries(0, 0, 256, ape);
        if (FAILED(hResult))
            return hResult;

        CopyColorsFromPaletteEntries(m_argbSrcColors, ape, 256);
    }

    if (m_dwEvents & IMGDECODE_EVENT_PALETTE)
    {
        hResult = m_pEventSink->OnPalette();
        if (FAILED(hResult))
        {
            return hResult;
        }
    }

    return S_OK;
}

STDMETHODIMP CDitherToRGB8::OnProgress( RECT* pBounds, BOOL bComplete )
{
   HRESULT hResult;

   if( pBounds == NULL )
   {
      return( E_INVALIDARG );
   }

   if( m_bProgressiveDither && bComplete )
   {
      hResult = DitherBand( pBounds );
      if( FAILED( hResult ) )
      {
         return( hResult );
      }
   }
   else
   {
      hResult = ConvertBlock( pBounds );
      if( FAILED( hResult ) )
      {
         return( hResult );
      }
   }

   if( m_dwEvents & IMGDECODE_EVENT_PROGRESS )
   {
      hResult = m_pEventSink->OnProgress( pBounds, bComplete );
      if( FAILED( hResult ) )
      {
         return( hResult );
      }
   }

   return( S_OK );
}

STDMETHODIMP CDitherToRGB8::SetDestColorTable( ULONG nColors, 
   const RGBQUAD* prgbColors )
{
   ULONG iTable;
   HRESULT hResult;

   if( (nColors == 0) || (nColors > 256) )
   {
      return( E_INVALIDARG );
   }
   if( prgbColors == NULL )
   {
      return( E_INVALIDARG );
   }

   EnterCriticalSection( &s_csCache );

   if( m_pTable != NULL )
   {
      // Release whatever table we've got already
      m_pTable->m_nRefCount--;
      m_pTable = NULL;
   }

   // See if we can find the requested table in the cache
   for( iTable = 0; (iTable < s_nCacheSize) && (m_pTable == NULL); iTable++ )
   {
      if( s_apTableCache[iTable]->Match( nColors, prgbColors ) )
      {
         m_pTable = s_apTableCache[iTable];
         m_pTable->m_nRefCount++;
      }
   }

   if( m_pTable == NULL )
   {
      if( s_nCacheSize < MAX_DITHERTABLE_CACHE_SIZE )
      {
         m_pTable = new CDitherTable;
         if( m_pTable == NULL )
         {
            LeaveCriticalSection( &s_csCache );
            return( E_OUTOFMEMORY );
         }
         hResult = m_pTable->SetColors( nColors, prgbColors );
         if( FAILED( hResult ) )
         {
            LeaveCriticalSection( &s_csCache );
            m_pTable = NULL;
            return( hResult );
         }

         // Add a new cache entry
         m_pTable->m_nRefCount++;
         s_apTableCache[s_nCacheSize] = m_pTable;
         s_nCacheSize++;
      }
      else
      {
         // Find a cache entry to replace.
         for( iTable = 0; (iTable < s_nCacheSize) && (m_pTable == NULL); 
            iTable++ )
         {
            if( s_apTableCache[iTable]->m_nRefCount == 0 )
            {
               m_pTable = s_apTableCache[iTable];
               hResult = m_pTable->SetColors( nColors, prgbColors );
               if( FAILED( hResult ) )
               {
                  LeaveCriticalSection( &s_csCache );
                  m_pTable = NULL;
                  return( hResult );
               }
               m_pTable->m_nRefCount++;
            }
         }
      }
   }

   _ASSERTE( m_pTable != NULL );

   LeaveCriticalSection( &s_csCache );

   return( S_OK );
}

STDMETHODIMP CDitherToRGB8::SetEventSink( IImageDecodeEventSink* pEventSink )
{
   if( pEventSink == NULL )
   {
      return( E_INVALIDARG );
   }

   m_pEventSink = pEventSink;

   return( S_OK );
}

HRESULT CDitherToRGB8::ConvertBlock( RECT* pBounds )
{
    HRESULT hResult;
    void* pSrcBits;
    void* pDestBits;
    LONG nSrcPitch;
    LONG nDestPitch;
    DDSURFACEDESC ddsd;

    _ASSERTE( pBounds->left == 0 );
    _ASSERTE( pBounds->right == LONG( m_nWidth ) );

    ddsd.dwSize = sizeof(ddsd);
    hResult = m_pSurface->Lock(pBounds, &ddsd, 0, 0);
    if (FAILED(hResult))
        return hResult;

    pSrcBits = ddsd.lpSurface;
    nSrcPitch = ddsd.lPitch;

    hResult = m_pDestSurface->Lock(pBounds, &ddsd, 0, 0);
    if (FAILED(hResult))
    {
        m_pSurface->Unlock(pSrcBits);
        return hResult;
    }

    pDestBits = ddsd.lpSurface;
    nDestPitch = ddsd.lPitch;
    
    switch( m_eSrcFormat )
    {
        case RGB24:
            Convert24to8(LPBYTE(pDestBits), LPBYTE(pSrcBits), nDestPitch, 
                    nSrcPitch, m_pTable->m_abInverseMap, pBounds->left, 
                    pBounds->right-pBounds->left, pBounds->top, 
                    pBounds->bottom-pBounds->top );
            break;

        case RGB8:
            Convert8to8( LPBYTE( pDestBits ), LPBYTE( pSrcBits ), nDestPitch, 
                    nSrcPitch, m_argbSrcColors, m_pTable->m_abInverseMap, pBounds->left, 
                    pBounds->right-pBounds->left, pBounds->top, 
                    pBounds->bottom-pBounds->top );
            break;

        default:
            return E_FAIL;
            break;
    }

    m_pDestSurface->Unlock(pDestBits);
    m_pSurface->Unlock(pSrcBits);

    return S_OK;
}

HRESULT CDitherToRGB8::DitherBand( RECT* pBounds )
{
    HRESULT hResult;
    void* pSrcBits;
    void* pDestBits;
    LONG nSrcPitch;
    LONG nDestPitch;
    LONG lDestTrans = -1;
    LONG lSrcTrans = -1;
    DDSURFACEDESC ddsd;
    DDCOLORKEY ddColorKey;

    _ASSERTE( pBounds->left == 0 );
    _ASSERTE( pBounds->right == LONG( m_nWidth ) );

    ddsd.dwSize = sizeof(ddsd);
    hResult = m_pSurface->Lock(pBounds, &ddsd, 0, 0);
    if (FAILED(hResult))
        return hResult;

    pSrcBits = ddsd.lpSurface;
    nSrcPitch = ddsd.lPitch;

    hResult = m_pDestSurface->Lock(pBounds, &ddsd, 0, 0);
    if (FAILED(hResult))
    {
        m_pSurface->Unlock(pSrcBits);
        return hResult;
    }

    pDestBits = ddsd.lpSurface;
    nDestPitch = ddsd.lPitch;

    switch (m_eSrcFormat)
    {    
        case RGB24:
            Dith24to8(LPBYTE(pDestBits), LPBYTE(pSrcBits), nDestPitch, 
                nSrcPitch, m_pTable->m_argbColors, m_pTable->m_abInverseMap, 
                m_pErrBuf1, m_pErrBuf2, pBounds->left, pBounds->right-pBounds->left, 
                pBounds->top, pBounds->bottom-pBounds->top);
            break;

        case RGB8:
            if (SUCCEEDED(m_pSurface->GetColorKey(DDCKEY_SRCBLT, &ddColorKey)))
                lSrcTrans = ddColorKey.dwColorSpaceLowValue;

            if (SUCCEEDED(m_pDestSurface->GetColorKey(DDCKEY_SRCBLT, &ddColorKey)))
                lDestTrans = ddColorKey.dwColorSpaceLowValue;

            // preserve the transparent index if necessary
            if (lSrcTrans >= 0 && lDestTrans == -1)
            {
                lDestTrans = lSrcTrans;
            }

            if (lSrcTrans == -1 || lDestTrans == -1)
            {
                Dith8to8(LPBYTE(pDestBits), LPBYTE(pSrcBits), nDestPitch, nSrcPitch,
                    m_argbSrcColors, m_pTable->m_argbColors, m_pTable->m_abInverseMap, 
                    m_pErrBuf1, m_pErrBuf2, pBounds->left, pBounds->right-pBounds->left, 
                    pBounds->top, pBounds->bottom-pBounds->top);
            }
            else
            {
                Dith8to8t(LPBYTE(pDestBits), LPBYTE(pSrcBits), nDestPitch, nSrcPitch,
                    m_argbSrcColors, m_pTable->m_argbColors, m_pTable->m_abInverseMap, 
                    m_pErrBuf1, m_pErrBuf2, pBounds->left, pBounds->right-pBounds->left, 
                    pBounds->top, pBounds->bottom-pBounds->top, (BYTE)lDestTrans, (BYTE)lSrcTrans);
            }
            break;

        default:
            return E_FAIL;
    }

    m_pDestSurface->Unlock(pDestBits);
    m_pSurface->Unlock(pSrcBits);

    return S_OK;
}

HRESULT CDitherToRGB8::DitherFull()
{
    HRESULT hResult;
    RECT rect;

    rect.left = 0;
    rect.top = 0;
    rect.right = m_nWidth;
    rect.bottom = m_nHeight;

    hResult = DitherBand(&rect);
    if (FAILED(hResult))
        return hResult;

    return S_OK;
}

HRESULT DitherTo8( BYTE * pDestBits, LONG nDestPitch, 
                   BYTE * pSrcBits, LONG nSrcPitch, REFGUID bfidSrc, 
                   RGBQUAD * prgbDestColors, RGBQUAD * prgbSrcColors,
                   BYTE * pbDestInvMap,
                   LONG x, LONG y, LONG cx, LONG cy,
                   LONG lDestTrans, LONG lSrcTrans)
{
   ERRBUF* m_pErrBuf;
   ERRBUF* m_pErrBuf1;
   ERRBUF* m_pErrBuf2;

//    StartCAPAll();
    
    HRESULT hr = S_OK;

    m_pErrBuf = new ERRBUF[(cx+2)*2];
    if (m_pErrBuf == NULL)
    {
        return( E_OUTOFMEMORY );
    }

    m_pErrBuf1 = &m_pErrBuf[1];
    m_pErrBuf2 = &m_pErrBuf[cx+3];

    memset(m_pErrBuf, 0, sizeof( ERRBUF )*(cx+2)*2);

    if (bfidSrc == BFID_RGB_24)
    {
        Dith24to8( pDestBits, pSrcBits, nDestPitch, nSrcPitch, 
            prgbDestColors, pbDestInvMap, 
            m_pErrBuf1, m_pErrBuf2, x, cx, y, cy );
    }
    else if (bfidSrc == BFID_RGB_8)
    {
        if (lDestTrans == -1 || lSrcTrans == -1)
        {
            Dith8to8( pDestBits, pSrcBits, nDestPitch, nSrcPitch,
                prgbSrcColors, prgbDestColors, pbDestInvMap, 
                m_pErrBuf1, m_pErrBuf2, x, cx, y, cy );
        }
        else
        {
            Dith8to8t( pDestBits, pSrcBits, nDestPitch, nSrcPitch,
                prgbSrcColors, prgbDestColors, pbDestInvMap, 
                m_pErrBuf1, m_pErrBuf2, x, cx, y, cy, (BYTE)lDestTrans, (BYTE)lSrcTrans );
        }
    }
    else
    {
        hr = E_FAIL;
    }

   delete m_pErrBuf;

//    StopCAPAll();
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\imgutil\cdithtbl.cpp ===
#include "stdafx.h"
#include "imgutil.h"
#include "cdithtbl.h"

CDitherTable::CDitherTable() :
   m_nColors( 0 ),
   m_nRefCount( 0 ),
   m_pnDistanceBuffer( NULL )
{
}

CDitherTable::~CDitherTable()
{
}

BOOL CDitherTable::Match( ULONG nColors, const RGBQUAD* prgbColors )
{
   if( m_nColors != nColors )
   {
      return( FALSE );
   }

   if( memcmp( m_argbColors, prgbColors, m_nColors*sizeof( RGBQUAD ) ) != 0 )
   {
      return( FALSE );
   }

   return( TRUE );
}

HRESULT CDitherTable::SetColors( ULONG nColors, const RGBQUAD* prgbColors )
{
   HRESULT hResult;

   m_nColors = nColors;
   memcpy( m_argbColors, prgbColors, m_nColors*sizeof( RGBQUAD ) );

   hResult = BuildInverseMap();
   if( FAILED( hResult ) )
   {
      return( hResult );
   }

   return( S_OK );
}
/*
void CDitherTable::BuildInverseMap()
{
   ULONG r;
   ULONG g;
   ULONG b;
   ULONG iColor;
   ULONG iMapEntry;
   int nMinDistance;
   int nDistance;
   int nRedDistance;
   int nBlueDistance;
   int nGreenDistance;

   iMapEntry = 0;
   for( r = 0; r < 32; r++ )
   {
      for( g = 0; g < 32; g++ )
      {
         for( b = 0; b < 32; b++ )
         {
            nMinDistance = 1000000;
            for( iColor = 0; iColor < m_nColors; iColor++ )
            {
               nRedDistance = m_argbColors[iColor].rgbRed-((r<<3)+(r>>2));
               nGreenDistance = m_argbColors[iColor].rgbGreen-((g<<3)+(g>>2));
               nBlueDistance = m_argbColors[iColor].rgbBlue-((b<<3)+(b>>2));
               nDistance = (nRedDistance*nRedDistance)+(nGreenDistance*
                  nGreenDistance)+(nBlueDistance*nBlueDistance);
               if( nDistance < nMinDistance )
               {
                  nMinDistance = nDistance;
                  m_abInverseMap[iMapEntry] = BYTE( iColor );
               }
            }
            iMapEntry++;
         }
      }
   }
}
*/

HRESULT CDitherTable::BuildInverseMap()
{
   _ASSERTE( m_pnDistanceBuffer == NULL );

   m_pnDistanceBuffer = new ULONG[32768];
   if( m_pnDistanceBuffer == NULL )
   {
      return( E_OUTOFMEMORY );
   }

   inv_cmap( m_nColors, m_argbColors, 5, m_pnDistanceBuffer, m_abInverseMap );

   delete m_pnDistanceBuffer;
   m_pnDistanceBuffer = NULL;

   return( S_OK );
}

/*****************************************************************
 * TAG( inv_cmap )
 *
 * Compute an inverse colormap efficiently.
 * Inputs:
 * 	colors:		Number of colors in the forward colormap.
 * 	colormap:	The forward colormap.
 * 	bits:		Number of quantization bits.  The inverse
 * 			colormap will have (2^bits)^3 entries.
 * 	dist_buf:	An array of (2^bits)^3 long integers to be
 * 			used as scratch space.
 * Outputs:
 * 	rgbmap:		The output inverse colormap.  The entry
 * 			rgbmap[(r<<(2*bits)) + (g<<bits) + b]
 * 			is the colormap entry that is closest to the
 * 			(quantized) color (r,g,b).
 * Assumptions:
 * 	Quantization is performed by right shift (low order bits are
 * 	truncated).  Thus, the distance to a quantized color is
 * 	actually measured to the color at the center of the cell
 * 	(i.e., to r+.5, g+.5, b+.5, if (r,g,b) is a quantized color).
 * Algorithm:
 * 	Uses a "distance buffer" algorithm:
 * 	The distance from each representative in the forward color map
 * 	to each point in the rgb space is computed.  If it is less
 * 	than the distance currently stored in dist_buf, then the
 * 	corresponding entry in rgbmap is replaced with the current
 * 	representative (and the dist_buf entry is replaced with the
 * 	new distance).
 *
 * 	The distance computation uses an efficient incremental formulation.
 *
 * 	Distances are computed "outward" from each color.  If the
 * 	colors are evenly distributed in color space, the expected
 * 	number of cells visited for color I is N^3/I.
 * 	Thus, the complexity of the algorithm is O(log(K) N^3),
 * 	where K = colors, and N = 2^bits.
 */

/*
 * Here's the idea:  scan from the "center" of each cell "out"
 * until we hit the "edge" of the cell -- that is, the point
 * at which some other color is closer -- and stop.  In 1-D,
 * this is simple:
 * 	for i := here to max do
 * 		if closer then buffer[i] = this color
 * 		else break
 * 	repeat above loop with i := here-1 to min by -1
 *
 * In 2-D, it's trickier, because along a "scan-line", the
 * region might start "after" the "center" point.  A picture
 * might clarify:
 *		 |    ...
 *               | ...	.
 *              ...    	.
 *           ... |      .
 *          .    +     	.
 *           .          .
 *            .         .
 *             .........
 *
 * The + marks the "center" of the above region.  On the top 2
 * lines, the region "begins" to the right of the "center".
 *
 * Thus, we need a loop like this:
 * 	detect := false
 * 	for i := here to max do
 * 		if closer then
 * 			buffer[..., i] := this color
 * 			if !detect then
 * 				here = i
 * 				detect = true
 * 		else
 * 			if detect then
 * 				break
 * 				
 * Repeat the above loop with i := here-1 to min by -1.  Note that
 * the "detect" value should not be reinitialized.  If it was
 * "true", and center is not inside the cell, then none of the
 * cell lies to the left and this loop should exit
 * immediately.
 *
 * The outer loops are similar, except that the "closer" test
 * is replaced by a call to the "next in" loop; its "detect"
 * value serves as the test.  (No assignment to the buffer is
 * done, either.)
 *
 * Each time an outer loop starts, the "here", "min", and
 * "max" values of the next inner loop should be
 * re-initialized to the center of the cell, 0, and cube size,
 * respectively.  Otherwise, these values will carry over from
 * one "call" to the inner loop to the next.  This tracks the
 * edges of the cell and minimizes the number of
 * "unproductive" comparisons that must be made.
 *
 * Finally, the inner-most loop can have the "if !detect"
 * optimized out of it by splitting it into two loops: one
 * that finds the first color value on the scan line that is
 * in this cell, and a second that fills the cell until
 * another one is closer:
 *  	if !detect then	    {needed for "down" loop}
 * 	    for i := here to max do
 * 		if closer then
 * 			buffer[..., i] := this color
 * 			detect := true
 * 			break
 *	for i := i+1 to max do
 *		if closer then
 * 			buffer[..., i] := this color
 * 		else
 * 			break
 *
 * In this implementation, each level will require the
 * following variables.  Variables labelled (l) are local to each
 * procedure.  The ? should be replaced with r, g, or b:
 *  	cdist:	    	The distance at the starting point.
 * 	?center:	The value of this component of the color
 *  	c?inc:	    	The initial increment at the ?center position.
 * 	?stride:	The amount to add to the buffer
 * 			pointers (dp and rgbp) to get to the
 * 			"next row".
 * 	min(l):		The "low edge" of the cell, init to 0
 * 	max(l):		The "high edge" of the cell, init to
 * 			colormax-1
 * 	detect(l):    	True if this row has changed some
 * 	    	    	buffer entries.
 *  	i(l): 	    	The index for this row.
 *  	?xx:	    	The accumulated increment value.
 *  	
 *  	here(l):    	The starting index for this color.  The
 *  	    	    	following variables are associated with here,
 *  	    	    	in the sense that they must be updated if here
 *  	    	    	is changed.
 *  	?dist:	    	The current distance for this level.  The
 *  	    	    	value of dist from the previous level (g or r,
 *  	    	    	for level b or g) initializes dist on this
 *  	    	    	level.  Thus gdist is associated with here(b)).
 *  	?inc:	    	The initial increment for the row.
 *
 *  	?dp:	    	Pointer into the distance buffer.  The value
 *  	    	    	from the previous level initializes this level.
 *  	?rgbp:	    	Pointer into the rgb buffer.  The value
 *  	    	    	from the previous level initializes this level.
 * 
 * The blue and green levels modify 'here-associated' variables (dp,
 * rgbp, dist) on the green and red levels, respectively, when here is
 * changed.
 */

/* Track minimum and maximum. */
#define MINMAX_TRACK

void CDitherTable::inv_cmap(int colors, RGBQUAD *colormap, int bits,
        ULONG* dist_buf, BYTE* rgbmap )
{
    int nbits = 8 - bits;

    colormax = 1 << bits;
    x = 1 << nbits;
    xsqr = 1 << (2 * nbits);

    /* Compute "strides" for accessing the arrays. */
    gstride = (int) colormax;
    rstride = (int) (colormax * colormax);

    maxfill( dist_buf, colormax );

    for ( cindex = 0; cindex < colors; cindex++ )
    {
        /* The caller can force certain colors in the output space to be
         * omitted by setting a nonzero value for the color's 'x' component.
         * This will produce a map that never refers to those colors.
         * -francish, 2/16/96
         */
        if (!colormap[cindex].rgbReserved)
        {
            /*
             * Distance formula is
             * (red - map[0])^2 + (green - map[1])^2 + (blue - map[2])^2
             *
             * Because of quantization, we will measure from the center of
             * each quantized "cube", so blue distance is
             * 	(blue + x/2 - map[2])^2,
             * where x = 2^(8 - bits).
             * The step size is x, so the blue increment is
             * 	2*x*blue - 2*x*map[2] + 2*x^2
             *
             * Now, b in the code below is actually blue/x, so our
             * increment will be 2*(b*x^2 + x^2 - x*map[2]).  For
             * efficiency, we will maintain this quantity in a separate variable
             * that will be updated incrementally by adding 2*x^2 each time.
             */
            /* The initial position is the cell containing the colormap
             * entry.  We get this by quantizing the colormap values.
             */
            rcenter = colormap[cindex].rgbRed >> nbits;
            gcenter = colormap[cindex].rgbGreen >> nbits;
            bcenter = colormap[cindex].rgbBlue >> nbits;
    
            rdist = colormap[cindex].rgbRed - (rcenter * x + x/2);
            gdist = colormap[cindex].rgbGreen - (gcenter * x + x/2);
            cdist = colormap[cindex].rgbBlue - (bcenter * x + x/2);
            cdist = rdist*rdist + gdist*gdist + cdist*cdist;
    
            crinc = 2 * ((rcenter + 1) * xsqr - (colormap[cindex].rgbRed*x));
            cginc = 2 * ((gcenter + 1) * xsqr - (colormap[cindex].rgbGreen*x));
            cbinc = 2 * ((bcenter + 1) * xsqr - (colormap[cindex].rgbBlue*x));
    
            /* Array starting points. */
            cdp = dist_buf + rcenter * rstride + gcenter * gstride + bcenter;
            crgbp = rgbmap + rcenter * rstride + gcenter * gstride + bcenter;
    
            (void)redloop();
        }
    }
}

/* redloop -- loop up and down from red center. */
int CDitherTable::redloop()
{
    int detect;
    int r;
    int first;
    long txsqr = xsqr + xsqr;

    detect = 0;

    /* Basic loop up. */
    for ( r = rcenter, rdist = cdist, rxx = crinc,
	  rdp = cdp, rrgbp = crgbp, first = 1;
	  r < (int) colormax;
	  r++, rdp += rstride, rrgbp += rstride,
	  rdist += rxx, rxx += txsqr, first = 0 )
    {
	if ( greenloop( first ) )
	    detect = 1;
	else if ( detect )
	    break;
    }
    
    /* Basic loop down. */
    for ( r = rcenter - 1, rxx = crinc - txsqr, rdist = cdist - rxx,
	  rdp = cdp - rstride, rrgbp = crgbp - rstride, first = 1;
	  r >= 0;
	  r--, rdp -= rstride, rrgbp -= rstride,
	  rxx -= txsqr, rdist -= rxx, first = 0 )
    {
	if ( greenloop( first ) )
	    detect = 1;
	else if ( detect )
	    break;
    }
    
    return detect;
}

#undef min
#undef max
#define here greenloop_here
#define min greenloop_min
#define max greenloop_max
#define prevmin greenloop_prevmin
#define prevmax greenloop_prevmax

/* greenloop -- loop up and down from green center. */
int CDitherTable::greenloop( int restart )
{
    int detect;
    int g;
    int first;
    long txsqr = xsqr + xsqr;
#ifdef MINMAX_TRACK
    int thismax, thismin;
#endif

    if ( restart )
    {
	here = gcenter;
	min = 0;
	max = (int) colormax - 1;
	ginc = cginc;
#ifdef MINMAX_TRACK
	prevmax = 0;
	prevmin = (int) colormax;
#endif
    }

#ifdef MINMAX_TRACK
    thismin = min;
    thismax = max;
#endif
    detect = 0;

    /* Basic loop up. */
    for ( g = here, gcdist = gdist = rdist, gxx = ginc,
	  gcdp = gdp = rdp, gcrgbp = grgbp = rrgbp, first = 1;
	  g <= max;
	  g++, gdp += gstride, gcdp += gstride, grgbp += gstride, gcrgbp += gstride,
	  gdist += gxx, gcdist += gxx, gxx += txsqr, first = 0 )
    {
	if ( blueloop( first ) )
	{
	    if ( !detect )
	    {
		/* Remember here and associated data! */
		if ( g > here )
		{
		    here = g;
		    rdp = gcdp;
		    rrgbp = gcrgbp;
		    rdist = gcdist;
		    ginc = gxx;
#ifdef MINMAX_TRACK
		    thismin = here;
#endif
		}
		detect = 1;
	    }
	}
	else if ( detect )
	{
#ifdef MINMAX_TRACK
	    thismax = g - 1;
#endif
	    break;
	}
    }
    
    /* Basic loop down. */
    for ( g = here - 1, gxx = ginc - txsqr, gcdist = gdist = rdist - gxx,
	  gcdp = gdp = rdp - gstride, gcrgbp = grgbp = rrgbp - gstride,
	  first = 1;
	  g >= min;
	  g--, gdp -= gstride, gcdp -= gstride, grgbp -= gstride, gcrgbp -= gstride,
	  gxx -= txsqr, gdist -= gxx, gcdist -= gxx, first = 0 )
    {
	if ( blueloop( first ) )
	{
	    if ( !detect )
	    {
		/* Remember here! */
		here = g;
		rdp = gcdp;
		rrgbp = gcrgbp;
		rdist = gcdist;
		ginc = gxx;
#ifdef MINMAX_TRACK
		thismax = here;
#endif
		detect = 1;
	    }
	}
	else if ( detect )
	{
#ifdef MINMAX_TRACK
	    thismin = g + 1;
#endif
	    break;
	}
    }
    
#ifdef MINMAX_TRACK
    /* If we saw something, update the edge trackers.  For now, only
     * tracks edges that are "shrinking" (min increasing, max
     * decreasing.
     */
    if ( detect )
    {
	if ( thismax < prevmax )
	    max = thismax;

	prevmax = thismax;

	if ( thismin > prevmin )
	    min = thismin;

	prevmin = thismin;
    }
#endif

    return detect;
}

#undef min
#undef max
#undef here
#undef prevmin
#undef prevmax
#define here blueloop_here
#define min blueloop_min
#define max blueloop_max
#define prevmin blueloop_prevmin
#define prevmax blueloop_prevmax

/* blueloop -- loop up and down from blue center. */
int CDitherTable::blueloop( int restart )
{
    int detect;
    register ULONG* dp;
    register BYTE* rgbp;
    register long bdist, bxx;
    register int b, i = cindex;
    register long txsqr = xsqr + xsqr;
    register int lim;
#ifdef MINMAX_TRACK
    int thismin, thismax;
#endif /* MINMAX_TRACK */

    if ( restart )
    {
	here = bcenter;
	min = 0;
	max = (int) colormax - 1;
	binc = cbinc;
#ifdef MINMAX_TRACK
	prevmin = (int) colormax;
	prevmax = 0;
#endif /* MINMAX_TRACK */
    }

    detect = 0;
#ifdef MINMAX_TRACK
    thismin = min;
    thismax = max;
#endif

    /* Basic loop up. */
    /* First loop just finds first applicable cell. */
    for ( b = here, bdist = gdist, bxx = binc, dp = gdp, rgbp = grgbp, lim = max;
	  b <= lim;
	  b++, dp++, rgbp++,
	  bdist += bxx, bxx += txsqr )
    {
        if ( *dp > (DWORD)bdist )
	{
	    /* Remember new 'here' and associated data! */
	    if ( b > here )
	    {
		here = b;
		gdp = dp;
		grgbp = rgbp;
		gdist = bdist;
		binc = bxx;
#ifdef MINMAX_TRACK
		thismin = here;
#endif
	    }
	    detect = 1;
	    break;
	}
    }
    /* Second loop fills in a run of closer cells. */
    for ( ;
	  b <= lim;
	  b++, dp++, rgbp++,
	  bdist += bxx, bxx += txsqr )
    {
        if ( *dp > (DWORD)bdist )
	{
	    *dp = bdist;
	    *rgbp = (BYTE) i;
	}
	else
	{
#ifdef MINMAX_TRACK
	    thismax = b - 1;
#endif
	    break;
	}
    }
    
    /* Basic loop down. */
    /* Do initializations here, since the 'find' loop might not get
     * executed. 
     */
    lim = min;
    b = here - 1;
    bxx = binc - txsqr;
    bdist = gdist - bxx;
    dp = gdp - 1;
    rgbp = grgbp - 1;
    /* The 'find' loop is executed only if we didn't already find
     * something.
     */
    if ( !detect )
	for ( ;
	      b >= lim;
	      b--, dp--, rgbp--,
	      bxx -= txsqr, bdist -= bxx )
	{
            if ( *dp > (DWORD)bdist )
	    {
		/* Remember here! */
		/* No test for b against here necessary because b <
		 * here by definition.
		 */
		here = b;
		gdp = dp;
		grgbp = rgbp;
		gdist = bdist;
		binc = bxx;
#ifdef MINMAX_TRACK
		thismax = here;
#endif
		detect = 1;
		break;
	    }
	}
    /* The 'update' loop. */
    for ( ;
	  b >= lim;
	  b--, dp--, rgbp--,
	  bxx -= txsqr, bdist -= bxx )
    {
        if ( *dp > (DWORD)bdist )
	{
	    *dp = bdist;
	    *rgbp = (BYTE) i;
	}
	else
	{
#ifdef MINMAX_TRACK
	    thismin = b + 1;
#endif
	    break;
	}
    }


	/* If we saw something, update the edge trackers. */
#ifdef MINMAX_TRACK
    if ( detect )
    {
	/* Only tracks edges that are "shrinking" (min increasing, max
	 * decreasing.
	 */
	if ( thismax < prevmax )
	    max = thismax;

	if ( thismin > prevmin )
	    min = thismin;
    
	/* Remember the min and max values. */
	prevmax = thismax;
	prevmin = thismin;
    }
#endif /* MINMAX_TRACK */

    return detect;
}

void CDitherTable::maxfill( ULONG* buffer, long side)
{
    register unsigned long maxv = (unsigned long)~0L;
    register long i;
    register ULONG* bp;

    (void)side;

    for ( i = colormax * colormax * colormax, bp = buffer;
	  i > 0;
	  i--, bp++ )
	*bp = maxv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\imgutil\apis.cpp ===
#include "stdafx.h"
#include "imgutil.h"
#include "cdithtbl.h"
#include "cddsurf.h"

// Get rid of "unused formal parameters warning"
#pragma warning(disable : 4100)

STDAPI DecodeImage( IStream* pStream, IMapMIMEToCLSID* pMap, 
   IUnknown* pUnknownEventSink )
{
   USES_CONVERSION;
   HRESULT hResult;
   CComPtr< IStream > pSniffedStream;
   UINT nFormat;
   TCHAR szMIMEType[64];
   LPCOLESTR pszMIMETypeO;
   CComPtr< IMapMIMEToCLSID > pActualMap;
   CComPtr< IImageDecodeFilter > pFilter;
   CComPtr< IImageDecodeEventSink > pEventSink;
   CLSID clsid;
   int nChars;
    
   if( pStream == NULL )
   {
      return( E_INVALIDARG );
   }
   if( pUnknownEventSink == NULL )
   {
      return( E_INVALIDARG );
   }

    pUnknownEventSink->QueryInterface(IID_IImageDecodeEventSink,
        (void **)&pEventSink);

    if (pEventSink == NULL)
        return E_INVALIDARG;
        
   if( pMap == NULL )
   {
      hResult = CoCreateInstance( CLSID_CoMapMIMEToCLSID, NULL, 
         CLSCTX_INPROC_SERVER, IID_IMapMIMEToCLSID, (void**)&pActualMap );
      if( FAILED( hResult ) )
      {
         return( hResult );
      }
   }
   else
   {
      pActualMap = pMap;
   }

   hResult = SniffStream( pStream, &nFormat, &pSniffedStream );
   if( FAILED( hResult ) )
   {
      return( hResult );
   }

   nChars = GetClipboardFormatName( nFormat, szMIMEType, 63 );
   if( nChars == 0 )
   {
      return( E_FAIL );
   }
   if( nChars > 60 )
   {
      return( E_FAIL );
   }

   pszMIMETypeO = T2COLE( szMIMEType );
   hResult = pActualMap->MapMIMEToCLSID( pszMIMETypeO, &clsid );
   if( FAILED( hResult ) )
   {
      return( hResult );
   }
   if( hResult == S_FALSE )
   {
      return( E_FAIL );
   }

   hResult = CoCreateInstance( clsid, NULL, CLSCTX_INPROC_SERVER, 
      IID_IImageDecodeFilter, (void**)&pFilter );
   if( FAILED( hResult ) )
   {
      return( hResult );
   }

   hResult = pFilter->Initialize( pEventSink );
   if( FAILED( hResult ) )
   {
      return( hResult );
   }

   hResult = pFilter->Process( pSniffedStream );

   pFilter->Terminate( hResult );

   if( FAILED( hResult ) )
   {
      return( hResult );
   }

   return( S_OK );
}

STDAPI CreateMIMEMap( IMapMIMEToCLSID** ppMap )
{
   if( ppMap == NULL )
   {
      return( E_POINTER );
   }

   return( CoCreateInstance( CLSID_CoMapMIMEToCLSID, NULL, 
      CLSCTX_INPROC_SERVER, IID_IMapMIMEToCLSID, (void**)ppMap ) );
}

STDAPI ComputeInvCMAP(const RGBQUAD *pRGBColors, ULONG nColors, BYTE *pInvTable, ULONG cbTable)
{
#ifndef MINSUPPORT
    CDitherTable *pDitherTable;
    HRESULT hr;
    
    if (pRGBColors == NULL)
        return E_POINTER;

    if (pInvTable == NULL)
        return E_POINTER;

    if (nColors > 256)
        return E_INVALIDARG;

    if (cbTable != 32768)
        return E_INVALIDARG;


    pDitherTable = new CDitherTable;
    if (pDitherTable == NULL)
        return E_OUTOFMEMORY;

    hr = pDitherTable->SetColors(nColors, pRGBColors);
    if (SUCCEEDED(hr))
        memcpy(pInvTable, pDitherTable->m_abInverseMap, 32768);

    delete pDitherTable;
    
    return hr;
#else
    return E_NOTIMPL;
#endif    
}

#ifdef MINSUPPORT

HRESULT DitherTo8( BYTE * pDestBits, LONG nDestPitch, 
                   BYTE * pSrcBits, LONG nSrcPitch, REFGUID bfidSrc, 
                   RGBQUAD * prgbDestColors, RGBQUAD * prgbSrcColors,
                   BYTE * pbDestInvMap,
                   LONG x, LONG y, LONG cx, LONG cy,
                   LONG lDestTrans, LONG lSrcTrans)
{
    return E_NOTIMPL;
}

#endif

STDAPI CreateDDrawSurfaceOnDIB(HBITMAP hbmDib, IDirectDrawSurface **ppSurface)
{
#ifndef MINSUPPORT
    if (hbmDib == NULL)
        return E_INVALIDARG;

    if (ppSurface == NULL)
        return E_POINTER;

    *ppSurface = (IDirectDrawSurface *)(new CDDrawWrapper(hbmDib));

    return *ppSurface ? S_OK : E_OUTOFMEMORY;
#else
    return E_NOTIMPL;
#endif    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\imgutil\cdith8.h ===
const ULONG MAX_DITHERTABLE_CACHE_SIZE = 4;

class CDitherToRGB8 :
   public IImageDecodeEventSink,
   public IDithererImpl,
   public CComObjectRoot,
   public CComCoClass< CDitherToRGB8, &CLSID_CoDitherToRGB8 >
{
public:
   CDitherToRGB8();
   ~CDitherToRGB8();

   BEGIN_COM_MAP( CDitherToRGB8 )
      COM_INTERFACE_ENTRY( IImageDecodeEventSink )
      COM_INTERFACE_ENTRY( IDithererImpl )
   END_COM_MAP()


   DECLARE_REGISTRY( CDitherToRGB8, _T( "ImgUtil.CoDitherToRGB8.1" ),
      _T( "ImgUtil.CoDitherToRGB8" ), IDS_CODITHERTORGB8_DESC, 
      THREADFLAGS_BOTH );


//   DECLARE_NO_REGISTRY()

// IImageDecodeEventSink
public:
   STDMETHOD( GetSurface )( LONG nWidth, LONG nHeight, REFGUID bfid, 
      ULONG nPasses, DWORD dwHints, IUnknown** ppSurface );
   STDMETHOD( OnBeginDecode )( DWORD* pdwEvents, ULONG* pnFormats, 
      GUID** ppFormats );
   STDMETHOD( OnBitsComplete )();
   STDMETHOD( OnDecodeComplete )( HRESULT hrStatus );
   STDMETHOD( OnPalette )();
   STDMETHOD( OnProgress )( RECT* pBounds, BOOL bComplete );

// IDithererImpl
public: 
   STDMETHOD( SetDestColorTable )( ULONG nColors, const RGBQUAD* prgbColors );
   STDMETHOD( SetEventSink )( IImageDecodeEventSink* pEventSink );
public:
   static void InitTableCache();
   static void CleanupTableCache();

protected:
   HRESULT ConvertBlock( RECT* pBounds );
   HRESULT DitherBand( RECT* pBounds );
   HRESULT DitherFull();

protected:
   static CDitherTable* s_apTableCache[MAX_DITHERTABLE_CACHE_SIZE];
   static ULONG s_nCacheSize;
   static CRITICAL_SECTION s_csCache;

protected:
   typedef enum _ESrcFormat
   {
      RGB24,
      RGB8
   } ESrcFormat;

   CComPtr< IImageDecodeEventSink > m_pEventSink;
   CComPtr< IDirectDrawSurface > m_pDestSurface;
   CComPtr< IDirectDrawSurface > m_pSurface;
   BYTE *m_pbBits;
   DWORD m_dwEvents;
   ULONG m_nWidth;
   ULONG m_nHeight;
   ULONG m_nPitch;
   ULONG m_nBitsPerPixel;
   BOOL m_bProgressiveDither;
   ESrcFormat m_eSrcFormat;
   ULONG m_iScanLine;
   HBITMAP m_hbmDestDib;
   ERRBUF* m_pErrBuf;
   ERRBUF* m_pErrBuf1;
   ERRBUF* m_pErrBuf2;
   CDitherTable* m_pTable;
   RGBQUAD m_argbSrcColors[256];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\imgutil\align.h ===
inline ULONG AlignLong( ULONG nSrc )
{
   return( (nSrc+3)&(~0x3) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\imgutil\cdithtbl.h ===
class CDitherTable
{
   friend class CDitherToRGB8;

public:
   CDitherTable();
   ~CDitherTable();

   BOOL Match( ULONG nColors, const RGBQUAD* prgbColors );
   HRESULT SetColors( ULONG nColors, const RGBQUAD* prgbColors );

protected:
   HRESULT BuildInverseMap();

   void inv_cmap( int colors, RGBQUAD *colormap, int bits, ULONG* dist_buf, 
      BYTE* rgbmap );
   int redloop();
   int greenloop( int restart );
   int blueloop( int restart );
   void maxfill( ULONG* buffer, long side );

public:
   BYTE m_abInverseMap[32768];

protected:
   ULONG m_nRefCount;
   ULONG m_nColors;
   RGBQUAD m_argbColors[256];
   ULONG* m_pnDistanceBuffer;

// Vars that were global in the original code
   int bcenter, gcenter, rcenter;
   long gdist, rdist, cdist;
   long cbinc, cginc, crinc;
   ULONG* gdp;
   ULONG* rdp;
   ULONG* cdp;
   BYTE* grgbp;
   BYTE* rrgbp;
   BYTE* crgbp;
   int gstride, rstride;
   long x, xsqr, colormax;
   int cindex;

// Static locals from the original redloop().  Good coding at its finest.
   long rxx;

// Static locals from the original greenloop()
   int greenloop_here;
   int greenloop_min;
   int greenloop_max;
   int greenloop_prevmin;
   int greenloop_prevmax;
   long ginc;
   long gxx;
   long gcdist;
   ULONG* gcdp;
   BYTE* gcrgbp;

// Static locals from the original blueloop()
   int blueloop_here;
   int blueloop_min;
   int blueloop_max;
   int blueloop_prevmin;
   int blueloop_prevmax;
   long binc;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\imgutil\cmapmime.h ===
HRESULT InitDefaultMappings();
void CleanupDefaultMappings();

class CMapStringToCLSID
{
public:
   CMapStringToCLSID();  // Default constructor
   ~CMapStringToCLSID();  // Destructor

   const CLSID& GetCLSID() const;
   DWORD GetMapMode() const;
   LPCTSTR GetString() const;
   HRESULT InitFromKey( HKEY hKey, LPCTSTR pszKeyName );
   void SetCLSID( REFGUID clsid );
   void SetMapMode( DWORD dwMapMode );
   HRESULT SetString( LPCTSTR pszString );

protected:
   char m_achSignature[4];

public:
   CMapStringToCLSID* m_pNext;

protected:
   LPTSTR m_pszString;
   CLSID m_clsid;
   DWORD m_dwMapMode;
};

class CMapMIMEToCLSID :
   public IMapMIMEToCLSID,
   public CComObjectRoot,
   public CComCoClass< CMapMIMEToCLSID, &CLSID_CoMapMIMEToCLSID >
{
public:
   CMapMIMEToCLSID();  // Default constructor
   ~CMapMIMEToCLSID();  // Destructor

   BEGIN_COM_MAP( CMapMIMEToCLSID )
      COM_INTERFACE_ENTRY( IMapMIMEToCLSID )
   END_COM_MAP()


   DECLARE_REGISTRY( CMapMIMEToCLSID, _T( "ImgUtil.CoMapMIMEToCLSID.1" ),
      _T( "ImgUtil.CoMapMIMEToCLSID" ), IDS_COMAPMIMETOCLSID_DESC,
      THREADFLAGS_BOTH )


//   DECLARE_NO_REGISTRY()

// IMapMIMEToCLSID
public:
   STDMETHOD( EnableDefaultMappings )( BOOL bEnable );
   STDMETHOD( MapMIMEToCLSID )( LPCOLESTR pszMIMEType, GUID* pCLSID );
   STDMETHOD( SetMapping )( LPCOLESTR pszMIMEType, DWORD dwMapMode, 
      REFGUID clsid );

protected:
   CMapStringToCLSID* AddMapping( LPCTSTR pszMIMEType );
   void DeleteMapping( LPCTSTR pszMIMEType );
   CMapStringToCLSID* FindMapping( LPCTSTR pszMIMEType );

protected:
   ULONG m_nMappings;
   BOOL m_bEnableDefaultMappings;
   CMapStringToCLSID* m_pMappings;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\imgutil\cmimeid.h ===
class CMIMEBitMatcher
{
public:
   CMIMEBitMatcher();  // Default constructor
   ~CMIMEBitMatcher();  // Destructor

   HRESULT InitFromBinary( const BYTE* pData, ULONG nBytes, 
      ULONG* pnBytesToMatch );
   HRESULT Match( const BYTE* pBytes, ULONG nBytes ) const;

protected:
   char m_achSignature[4];

public:
   CMIMEBitMatcher* m_pNext;

protected:
   ULONG m_nOffset;
   ULONG m_nBytes;
   BYTE* m_pMask;
   BYTE* m_pData;
};

class CMIMEType
{
public:
   CMIMEType();  // Default constructor
   ~CMIMEType();  // Destructor

   UINT GetClipboardFormat() const;
   HRESULT InitFromKey( HKEY hKey, LPCTSTR pszName, ULONG* pnMaxBytes );
   HRESULT Match( const BYTE* pBytes, ULONG nBytes ) const;

protected:
   char m_achSignature[4];

public:
   CMIMEType* m_pNext;

protected:
   UINT m_nClipboardFormat;
   CMIMEBitMatcher* m_lpBitMatchers;
   ULONG m_nMaxBytes;
};

class CMIMEIdentifier
{
public:
   CMIMEIdentifier();  // Default constructor
   ~CMIMEIdentifier();  // Destructor

   ULONG GetMaxBytes() const;
   HRESULT Identify( const BYTE* pbBytes, ULONG nBytes, UINT* pnFormat );
   HRESULT IdentifyStream( ISniffStream* pSniffStream, 
      UINT* pnClipboardFormat );
   HRESULT InitFromRegistry();

protected:
   char m_achSignature[4];

protected:
   ULONG m_nMaxBytes;
   CMIMEType* m_lpTypes;
};

void InitMIMEIdentifier();
void CleanupMIMEIdentifier();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\imgutil\dithers.cpp ===
#include "stdafx.h"
#include "dithers.h"

#ifndef _DEBUG
#define INLINE  __inline
#else
#define INLINE
#endif

//-----------------------------------------------------------------------------
// helpers
//-----------------------------------------------------------------------------

const BYTE g_abClamp[] = {
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,
25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,
47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,
69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,
90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,
109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,
126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,
143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,
160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,
177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,
194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,
211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,
228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,
245,246,247,248,249,250,251,252,253,254,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255
};

INLINE UINT Clamp8(int z)
{
#ifdef _DEBUG
    UINT t = (z & 0xff00) ? (0xff & ~(z >> 16)) : z;

    if (t != g_abClamp[z + 128])
        DebugBreak();
#endif

    return g_abClamp[z + 128];
}

INLINE WORD rgb555(BYTE r, BYTE g, BYTE b)
{
    return( WORD( ((((WORD)(r) << 5) | (WORD)(g)) << 5) | (WORD)(b) ) );
}

//-----------------------------------------------------------------------------
// Halftoning stuff
//-----------------------------------------------------------------------------
//
// This table is used to halftone from 8 to 5 bpp.  Typically, 16 bit
// halftoning code will map an 8 bit value to a 5 bit value, map it back to
// 8 bits, compute some error, and use a halftone table to adjust the 5 bit
// value for the error.  This array is a concatenation of 8 different 8-to-5
// tables that include the error factoring in their mapping.  It is used with
// the halftoning table below, which gives indices to each of the mapping
// tables within the array.   Given the correct table pointer for a pixel,
// callers can perform a single lookup per color component in this table to get
// a halftoned 5 bit component.
//
#pragma data_seg(".text", "CODE")
BYTE aHT16Data[] =
{
      0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,
      1,  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,  2,
      3,  3,  3,  3,  3,  3,  3,  3,  4,  4,  4,  4,  4,  4,  4,  4,
      5,  5,  5,  5,  5,  5,  5,  5,  6,  6,  6,  6,  6,  6,  6,  6,
      7,  7,  7,  7,  7,  7,  7,  7,  8,  8,  8,  8,  8,  8,  8,  8,
      9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,
     11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12,
     13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14,
     15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
     17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18,
     19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20,
     21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,
     23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24,
     25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26,
     27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28,
     29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 31,
      0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,
      1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,  2,  3,
      3,  3,  3,  3,  3,  3,  3,  4,  4,  4,  4,  4,  4,  4,  4,  5,
      5,  5,  5,  5,  5,  5,  5,  6,  6,  6,  6,  6,  6,  6,  6,  7,
      7,  7,  7,  7,  7,  7,  7,  8,  8,  8,  8,  8,  8,  8,  8,  9,
      9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10, 11,
     11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 13,
     13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 15,
     15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 17,
     17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19,
     19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 21,
     21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 23,
     23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 25,
     25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 27,
     27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 29,
     29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 31,
     31, 31, 31, 31, 31, 31
};
UINT aHT16Heads[4][4] =
{
    262, 256, 261,   0,
    258, 260, 257, 259,
    261,   0, 262, 256,
    257, 259, 258, 260,
};
#pragma data_seg()

INLINE UINT *
Get555HalftoneRow(UINT y)
{
    return aHT16Heads[y % 4];
}

INLINE BYTE *
Get555HalftoneTable(UINT *row, UINT x)
{
    return aHT16Data + row[x % 4];
}

//-----------------------------------------------------------------------------
// Rounding stuff
//-----------------------------------------------------------------------------
//
// round an 8bit value to a 5bit value with good distribution
//
#if 0   // not presently used
#pragma data_seg(".text", "CODE")
BYTE aRound8to5[] = {
      0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,
      2,  2,  2,  2,  2,  3,  3,  3,  3,  3,  3,  3,  3,  4,  4,  4,
      4,  4,  4,  4,  4,  4,  5,  5,  5,  5,  5,  5,  5,  5,  6,  6,
      6,  6,  6,  6,  6,  6,  7,  7,  7,  7,  7,  7,  7,  7,  8,  8,
      8,  8,  8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9,  9, 10,
     10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 12,
     12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13,
     14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15,
     16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19,
     19, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21,
     21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23,
     23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25,
     25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27,
     27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29,
     29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31,
};
#pragma data_seg()
#endif  // not presently used

//
// complement of table above
//
#pragma data_seg(".text", "CODE")
BYTE aRound5to8[] = {
      0,  8, 16, 25, 33, 41, 49, 58, 66, 74, 82, 90, 99,107,115,123,
    132,140,148,156,165,173,181,189,197,206,214,222,230,239,247,255,
};
#pragma data_seg()

///////////////////////////////////////////////////////////////////////////////
//
// Dithering stuff.
//
// This code implements error-diffusion to an arbitrary set of colors,
// optionally with transparency.  Since the output colors can be arbitrary,
// the color picker for the dither is a 32k inverse-mapping table.  24bpp
// values are whacked down to 16bpp (555) and used as indices into the table.
// To compensate for posterization effects when converting 24bpp to 16bpp, an
// ordered dither (16bpp halftone) is used to generate the 555 color.
//
///////////////////////////////////////////////////////////////////////////////

INLINE void SwapError(ERRBUF **a, ERRBUF **b)
{
    ERRBUF *te;

    te = *a;
    *a = *b;
    *b = te;
}

INLINE void ZeroError(ERRBUF *err, size_t pels)
{
    ZeroMemory(err - 1, ErrbufBytes(pels));
}

///////////////////////////////////////////////////////////////////////////////
//
// Dith8to8()                                              8bpp to 8bpp dither.
//
// Computes the 24bpp source color by combining the source pixel's color table
// entry with accumulated error for the pixel.  Halftones this 24bpp value to a
// 16bpp 555 color.  Uses the 16bpp color as a lookup into an inverse mapping
// table to pick the output color for the pixel.  Uses the destination color
// table entry to compute and accumulates error for neighboring pixels.
//
///////////////////////////////////////////////////////////////////////////////

INLINE void DithScan8to8(BYTE *dst, const BYTE *src, const RGBQUAD *colorsIN,
    const RGBQUAD *colorsOUT, const BYTE *map, ERRBUF *cur_err,
    ERRBUF *nxt_err, UINT x, UINT xl, UINT y)
{
    UINT *row = Get555HalftoneRow(y);

    for (; x < xl; src++, x++)
    {
        register const RGBQUAD *pChosen;
        register BYTE *tbl;
        register int r;
        register int g;
        register int b;

        pChosen = colorsIN + *src;

        r = Clamp8((int)pChosen->rgbRed   + (cur_err->r >> 4));
        g = Clamp8((int)pChosen->rgbGreen + (cur_err->g >> 4));
        b = Clamp8((int)pChosen->rgbBlue  + (cur_err->b >> 4));
        cur_err++;

        tbl = Get555HalftoneTable(row, x);
        pChosen = colorsOUT + (*dst++ = map[rgb555(tbl[r], tbl[g], tbl[b])]);

        r -= (int)pChosen->rgbRed;
        (nxt_err+1)->r += r * 1;
        (nxt_err-1)->r += r * 3;
        (nxt_err  )->r += r * 5;
        (cur_err  )->r += r * 7;

        g -= (int)pChosen->rgbGreen;
        (nxt_err+1)->g += g * 1;
        (nxt_err-1)->g += g * 3;
        (nxt_err  )->g += g * 5;
        (cur_err  )->g += g * 7;

        b -= (int)pChosen->rgbBlue;
        (nxt_err+1)->b += b * 1;
        (nxt_err-1)->b += b * 3;
        (nxt_err  )->b += b * 5;
        (cur_err  )->b += b * 7;

        nxt_err++;
    }
}

void Dith8to8(BYTE *dst, const BYTE *src, int dst_next_scan, int src_next_scan,
    const RGBQUAD *colorsIN, const RGBQUAD *colorsOUT, const BYTE *map,
    ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT cx, UINT y, int cy)
{
    int dy;

    cx += x;

    if (cy < 0)
    {
        dy = -1;
        cy *= -1;
    }
    else
        dy = 1;

    if (y & 1)
        SwapError(&cur_err, &nxt_err);

    while (cy)
    {
        DithScan8to8(dst, src, colorsIN, colorsOUT, map, cur_err, nxt_err,
            x, cx, y);

        ZeroError(cur_err, cx);
        SwapError(&cur_err, &nxt_err);

        *(BYTE **)&src += src_next_scan;
        *(BYTE **)&dst += dst_next_scan;
        y += dy;
        cy--;
    }
}

INLINE void ConvertScan8to8( BYTE* pbDest, const BYTE* pbSrc, 
   const RGBQUAD* prgbColors, const BYTE* pbMap, UINT x, UINT xl, UINT y )
{
   UINT* pRow = Get555HalftoneRow( y );
   BYTE* pbTable;
   BYTE r;
   BYTE g;
   BYTE b;

   for (; x < xl; pbSrc += 3, x++ )
   {
      r = prgbColors[*pbSrc].rgbRed;
      g = prgbColors[*pbSrc].rgbGreen;
      b = prgbColors[*pbSrc].rgbBlue;

      pbTable = Get555HalftoneTable( pRow, x );
      *pbDest = pbMap[rgb555( pbTable[r], pbTable[g], pbTable[b] )];
   }
}

void Convert8to8( BYTE* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, const RGBQUAD* prgbColors, const BYTE* pbMap, UINT x, 
   UINT nWidth, UINT y, int nHeight )
{
   int dy;
   UINT x2;

   x2 = x+nWidth;

   if( nHeight < 0 )
   {
      dy = -1;
      nHeight *= -1;
   }
   else
   {
      dy = 1;
   }

   while( nHeight )
   {
      ConvertScan8to8( pbDest, pbSrc, prgbColors, pbMap, x, x2, y );

      pbSrc += nSrcPitch;
      pbDest += nDestPitch;

      y += dy;
      nHeight--;
   }
}

INLINE void DithScanGray8to8( BYTE* pbDest, const BYTE* pbSrc,
   const RGBQUAD* prgbColors, const BYTE* pbMap, ERRBUF* pCurrentError,
   ERRBUF* pNextError, UINT x, UINT xl, UINT y )
{
   BYTE bSrc;
   BYTE bDest;
    UINT* pRow = Get555HalftoneRow( y );

    for(; x < xl; pbSrc++, x++ )
    {
        const RGBQUAD* prgbChosen;
        BYTE* pbTable;
        int r;
        int g;
        int b;

        bSrc = *pbSrc;
        r = Clamp8( (int)bSrc + pCurrentError->r/16 );
        g= Clamp8( (int)bSrc + pCurrentError->g/16 );
        b = Clamp8( (int)bSrc + pCurrentError->b/16 );
        pCurrentError++;

        pbTable = Get555HalftoneTable( pRow, x );
        bDest = pbMap[rgb555( pbTable[r], pbTable[g], pbTable[b] )];
         prgbChosen = prgbColors+bDest;
         *pbDest = bDest;
         pbDest++;

        r -= (int)prgbChosen->rgbRed;
        (pNextError+1)->r += r * 1;
        (pNextError-1)->r += r * 3;
        (pNextError)->r += r * 5;
        (pCurrentError)->r += r * 7;

        g -= (int)prgbChosen->rgbGreen;
        (pNextError+1)->g += g * 1;
        (pNextError-1)->g += g * 3;
        (pNextError)->g += g * 5;
        (pCurrentError)->g += g * 7;

        b -= (int)prgbChosen->rgbBlue;
        (pNextError+1)->b += b * 1;
        (pNextError-1)->b += b * 3;
        (pNextError)->b += b * 5;
        (pCurrentError)->b += b * 7;

        pNextError++;
    }
}

void DithGray8to8( BYTE* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, const RGBQUAD* prgbColors, const BYTE* pbMap, 
   ERRBUF* pCurrentError, ERRBUF* pNextError, UINT x, UINT cx, UINT y, int cy )
{
    int dy;

    cx += x;

    if (cy < 0)
    {
        dy = -1;
        cy *= -1;
    }
    else
    {
        dy = 1;
    }

    if (y & 1)
    {
        SwapError( &pCurrentError, &pNextError );
    }
    while (cy)
    {
        DithScanGray8to8( pbDest, pbSrc, prgbColors, pbMap, pCurrentError, 
           pNextError, x, cx, y );

        ZeroError( pCurrentError, cx );
        SwapError( &pCurrentError, &pNextError );

        *(BYTE **)&pbSrc += nSrcPitch;
        *(BYTE **)&pbDest += nDestPitch;
        y += dy;
        cy--;
    }
}

INLINE void ConvertScanGray8to8( BYTE* pbDest, const BYTE* pbSrc,
   const BYTE* pbMap, UINT x, UINT xl, UINT y )
{
   UINT* pRow = Get555HalftoneRow( y );
   BYTE* pbTable;
   BYTE g;

   for (; x < xl; pbSrc++, x++ )
   {
      g = *pbSrc;

      pbTable = Get555HalftoneTable( pRow, x );
      *pbDest = pbMap[rgb555( pbTable[g], pbTable[g], pbTable[g] )];
   }
}

void ConvertGray8to8( BYTE* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, const BYTE* pbMap, UINT x, UINT nWidth, UINT y, int nHeight )
{
   int dy;
   UINT x2;

   x2 = x+nWidth;

   if( nHeight < 0 )
   {
      dy = -1;
      nHeight *= -1;
   }
   else
   {
      dy = 1;
   }

   while( nHeight )
   {
      ConvertScanGray8to8( pbDest, pbSrc, pbMap, x, x2, y );

      pbSrc += nSrcPitch;
      pbDest += nDestPitch;

      y += dy;
      nHeight--;
   }
}

///////////////////////////////////////////////////////////////////////////////
//
// Dith8to8t()                           8bpp to 8bpp dither with transparency.
//
// If the source pixel is the given source transparency color, this routine
// picks the destination transparency color for output and zero error is
// accumulated to the pixel's neighbors.
// Otherwise, this routine functions identically to Dith8to8.
//
///////////////////////////////////////////////////////////////////////////////

INLINE void DithScan8to8t(BYTE *dst, const BYTE *src,
    const RGBQUAD *colorsIN, const RGBQUAD *colorsOUT, const BYTE *map,
    ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT xl, UINT y,
    BYTE indexTxpOUT, BYTE indexTxpIN)
{
    UINT *row = Get555HalftoneRow(y);

    for (; x < xl; src++, x++)
    {
        register const RGBQUAD *pChosen;
        register BYTE *tbl;
        register BYTE index;
        register int r;
        register int g;
        register int b;

        index = *src;
        if (index == indexTxpIN)
        {
            *dst++ = indexTxpOUT;
            cur_err++;
            nxt_err++;
            continue;
        }

        pChosen = colorsIN + index;
        r = Clamp8((int)pChosen->rgbRed   + (cur_err->r >> 4));
        g = Clamp8((int)pChosen->rgbGreen + (cur_err->g >> 4));
        b = Clamp8((int)pChosen->rgbBlue  + (cur_err->b >> 4));
        cur_err++;

        tbl = Get555HalftoneTable(row, x);
        pChosen = colorsOUT + (*dst++ = map[rgb555(tbl[r], tbl[g], tbl[b])]);

        r -= (int)pChosen->rgbRed;
        (nxt_err+1)->r += r * 1;
        (nxt_err-1)->r += r * 3;
        (nxt_err  )->r += r * 5;
        (cur_err  )->r += r * 7;

        g -= (int)pChosen->rgbGreen;
        (nxt_err+1)->g += g * 1;
        (nxt_err-1)->g += g * 3;
        (nxt_err  )->g += g * 5;
        (cur_err  )->g += g * 7;

        b -= (int)pChosen->rgbBlue;
        (nxt_err+1)->b += b * 1;
        (nxt_err-1)->b += b * 3;
        (nxt_err  )->b += b * 5;
        (cur_err  )->b += b * 7;

        nxt_err++;
    }
}

void Dith8to8t(BYTE *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, const RGBQUAD *colorsIN, const RGBQUAD *colorsOUT,
    const BYTE *map, ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT cx, UINT y,
    int cy, BYTE indexTxpOUT, BYTE indexTxpIN)
{
    int dy;

    cx += x;

    if (cy < 0)
    {
        dy = -1;
        cy *= -1;
    }
    else
        dy = 1;

    if (y & 1)
        SwapError(&cur_err, &nxt_err);

    while (cy)
    {
        DithScan8to8t(dst, src, colorsIN, colorsOUT, map, cur_err, nxt_err,
            x, cx, y, indexTxpOUT, indexTxpIN);

        ZeroError(cur_err, cx);
        SwapError(&cur_err, &nxt_err);

        *(BYTE **)&src += src_next_scan;
        *(BYTE **)&dst += dst_next_scan;
        y += dy;
        cy--;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// Dith8to16()                                            8bpp to 16bpp dither.
//
// Computes the 24bpp source color by combining the source pixel's color table
// entry with accumulated error for the pixel.  Halftones this 24bpp value to a
// 16bpp 555 color.  Remaps this color to 24bpp to compute and accumulates
// error for neighboring pixels.
//
///////////////////////////////////////////////////////////////////////////////

INLINE void DithScan8to16(WORD *dst, const BYTE *src, const RGBQUAD *colors,
    ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT xl, UINT y)
{
    UINT *row = Get555HalftoneRow(y);

    for (; x < xl; src++, x++)
    {
        register const RGBQUAD *pChosen;
        register WORD wColor;
        register BYTE *tbl;
        register int r;
        register int g;
        register int b;

        pChosen = colors + *src;
        r = Clamp8((int)pChosen->rgbRed   + cur_err->r / 16);
        g = Clamp8((int)pChosen->rgbGreen + cur_err->g / 16);
        b = Clamp8((int)pChosen->rgbBlue  + cur_err->b / 16);
        cur_err++;

        tbl = Get555HalftoneTable(row, x);
        wColor = (*dst++ = rgb555(tbl[r], tbl[g], tbl[b]));

        b -= (int)aRound5to8[wColor & 0x1f];
        (nxt_err+1)->b += b * 1;
        (nxt_err-1)->b += b * 3;
        (nxt_err  )->b += b * 5;
        (cur_err  )->b += b * 7;

        g -= (int)aRound5to8[(wColor >> 5) & 0x1f];
        (nxt_err+1)->g += g * 1;
        (nxt_err-1)->g += g * 3;
        (nxt_err  )->g += g * 5;
        (cur_err  )->g += g * 7;

        r -= (int)aRound5to8[(wColor >> 10) & 0x1f];
        (nxt_err+1)->r += r * 1;
        (nxt_err-1)->r += r * 3;
        (nxt_err  )->r += r * 5;
        (cur_err  )->r += r * 7;

        nxt_err++;
    }
}

void Dith8to16(WORD *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, const RGBQUAD *colors, ERRBUF *cur_err, ERRBUF *nxt_err,
    UINT x, UINT cx, UINT y, int cy)
{
    int dy;

    cx += x;

    if (cy < 0)
    {
        dy = -1;
        cy *= -1;
    }
    else
        dy = 1;

    if (y & 1)
        SwapError(&cur_err, &nxt_err);

    while (cy)
    {
        DithScan8to16(dst, src, colors, cur_err, nxt_err, x, cx, y);

        ZeroError(cur_err, cx);
        SwapError(&cur_err, &nxt_err);

        *(BYTE **)&src += src_next_scan;
        *(BYTE **)&dst += dst_next_scan;
        y += dy;
        cy--;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// Dith8to16t()                         8bpp to 16bpp dither with transparency.
//
// If the source pixel is the given source transparency color, this routine
// picks the destination transparency color for output and zero error is
// accumulated to the pixel's neighbors.
// Otherwise, this routine functions identically to Dith8to16.
//
///////////////////////////////////////////////////////////////////////////////

INLINE void DithScan8to16t(WORD *dst, const BYTE *src, const RGBQUAD *colors,
    ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT xl, UINT y,
    WORD wColorTxpOUT, BYTE indexTxpIN)
{
    UINT *row = Get555HalftoneRow(y);

    for (; x < xl; src ++, x++)
    {
        register const RGBQUAD *pChosen;
        register WORD wColor;
        register BYTE *tbl;
        register BYTE index;
        register int r;
        register int g;
        register int b;

        index = *src;
        if (index == indexTxpIN)
        {
            *dst++ = wColorTxpOUT;
            cur_err++;
            nxt_err++;
            continue;
        }

        pChosen = colors + index;
        r = Clamp8((int)pChosen->rgbRed   + cur_err->r / 16);
        g = Clamp8((int)pChosen->rgbGreen + cur_err->g / 16);
        b = Clamp8((int)pChosen->rgbBlue  + cur_err->b / 16);
        cur_err++;

        tbl = Get555HalftoneTable(row, x);
        wColor = (*dst++ = rgb555(tbl[r], tbl[g], tbl[b]));

        b -= (int)aRound5to8[wColor & 0x1f];
        (nxt_err+1)->b += b * 1;
        (nxt_err-1)->b += b * 3;
        (nxt_err  )->b += b * 5;
        (cur_err  )->b += b * 7;

        g -= (int)aRound5to8[(wColor >> 5) & 0x1f];
        (nxt_err+1)->g += g * 1;
        (nxt_err-1)->g += g * 3;
        (nxt_err  )->g += g * 5;
        (cur_err  )->g += g * 7;

        r -= (int)aRound5to8[(wColor >> 10) & 0x1f];
        (nxt_err+1)->r += r * 1;
        (nxt_err-1)->r += r * 3;
        (nxt_err  )->r += r * 5;
        (cur_err  )->r += r * 7;

        nxt_err++;
    }
}

void Dith8to16t(WORD *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, const RGBQUAD *colors, ERRBUF *cur_err, ERRBUF *nxt_err,
    UINT x, UINT cx, UINT y, int cy, WORD wColorTxpOUT, BYTE indexTxpIN)
{
    int dy;

    cx += x;

    if (cy < 0)
    {
        dy = -1;
        cy *= -1;
    }
    else
        dy = 1;

    if (y & 1)
        SwapError(&cur_err, &nxt_err);

    while (cy)
    {
        DithScan8to16t(dst, src, colors, cur_err, nxt_err, x, cx, y,
            wColorTxpOUT, indexTxpIN);

        ZeroError(cur_err, cx);
        SwapError(&cur_err, &nxt_err);

        *(BYTE **)&src += src_next_scan;
        *(BYTE **)&dst += dst_next_scan;
        y += dy;
        cy--;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// Dith24to8()                                            24bpp to 8bpp dither.
//
// Computes the 24bpp source color by combining the source pixel's color with
// accumulated error for the pixel.  Halftones this 24bpp value to a 16bpp 555
// color.  Uses the 16bpp color as a lookup into an inverse mapping table to
// pick the output color for the pixel.  Uses the destination color table entry
// to compute and accumulates error for neighboring pixels.
//
///////////////////////////////////////////////////////////////////////////////

INLINE void DithScan24to8(BYTE *dst, const BYTE *src, const RGBQUAD *colors,
    const BYTE *map, ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT xl, UINT y)
{
    UINT *row = Get555HalftoneRow(y);

    for (; x < xl; src += 3, x++)
    {
        register const RGBQUAD *pChosen;
        register BYTE *tbl;
        register int r;
        register int g;
        register int b;

        r = Clamp8((int)src[2] + cur_err->r / 16);
        g = Clamp8((int)src[1] + cur_err->g / 16);
        b = Clamp8((int)src[0] + cur_err->b / 16);
        cur_err++;

        tbl = Get555HalftoneTable(row, x);
        pChosen = colors + (*dst++ = map[rgb555(tbl[r], tbl[g], tbl[b])]);

        r -= (int)pChosen->rgbRed;
        (nxt_err+1)->r += r * 1;
        (nxt_err-1)->r += r * 3;
        (nxt_err  )->r += r * 5;
        (cur_err  )->r += r * 7;

        g -= (int)pChosen->rgbGreen;
        (nxt_err+1)->g += g * 1;
        (nxt_err-1)->g += g * 3;
        (nxt_err  )->g += g * 5;
        (cur_err  )->g += g * 7;

        b -= (int)pChosen->rgbBlue;
        (nxt_err+1)->b += b * 1;
        (nxt_err-1)->b += b * 3;
        (nxt_err  )->b += b * 5;
        (cur_err  )->b += b * 7;

        nxt_err++;
    }
}

void Dith24to8(BYTE *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, const RGBQUAD *colors, const BYTE *map, ERRBUF *cur_err,
    ERRBUF *nxt_err, UINT x, UINT cx, UINT y, int cy)
{
    int dy;

    cx += x;

    if (cy < 0)
    {
        dy = -1;
        cy *= -1;
    }
    else
        dy = 1;

    if (y & 1)
        SwapError(&cur_err, &nxt_err);

    while (cy)
    {
        DithScan24to8(dst, src, colors, map, cur_err, nxt_err, x, cx, y);

        ZeroError(cur_err, cx);
        SwapError(&cur_err, &nxt_err);

        *(BYTE **)&src += src_next_scan;
        *(BYTE **)&dst += dst_next_scan;
        y += dy;
        cy--;
    }
}

INLINE void ConvertScan24to8( BYTE* pbDest, const BYTE* pbSrc, 
   const BYTE* pbMap, UINT x, UINT xl, UINT y )
{
   UINT* pRow;
   BYTE* pbTable;
   BYTE r;
   BYTE g;
   BYTE b;

   pRow = Get555HalftoneRow( y );

   for (; x < xl; pbSrc += 3, x++ )
   {
      r = pbSrc[2];
      g = pbSrc[1];
      b = pbSrc[0];

      pbTable = Get555HalftoneTable( pRow, x );
      *pbDest = pbMap[rgb555( pbTable[r], pbTable[g], pbTable[b] )];
   }
}

void Convert24to8( BYTE* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, const BYTE* pbMap, UINT x, UINT nWidth, UINT y, int nHeight )
{
   int dy;
   UINT x2;

   x2 = x+nWidth;

   if( nHeight < 0 )
   {
      dy = -1;
      nHeight *= -1;
   }
   else
   {
      dy = 1;
   }

   while( nHeight )
   {
      ConvertScan24to8( pbDest, pbSrc, pbMap, x, x2, y );

      pbSrc += nSrcPitch;
      pbDest += nDestPitch;

      y += dy;
      nHeight--;
   }
}

///////////////////////////////////////////////////////////////////////////////
//
// Dith24to16()                                          24bpp to 16bpp dither.
//
// Computes the 24bpp source color by combining the source pixel's color with
// accumulated error for the pixel.  Halftones this 24bpp value to a 16bpp 555
// color.  Remaps this color to 24bpp to compute and accumulates error for
// neighboring pixels.
//
///////////////////////////////////////////////////////////////////////////////

INLINE void DithScan24to16(WORD *dst, const BYTE *src, ERRBUF *cur_err,
    ERRBUF *nxt_err, UINT x, UINT xl, UINT y)
{
    UINT *row = Get555HalftoneRow(y);

    for (; x < xl; src += 3, x++)
    {
        register WORD wColor;
        register BYTE *tbl;
        register int r;
        register int g;
        register int b;

        r = Clamp8((int)src[2] + cur_err->r / 16);
        g = Clamp8((int)src[1] + cur_err->g / 16);
        b = Clamp8((int)src[0] + cur_err->b / 16);
        cur_err++;

        tbl = Get555HalftoneTable(row, x);
        wColor = (*dst++ = rgb555(tbl[r], tbl[g], tbl[b]));

        b -= (int)aRound5to8[wColor & 0x1f];
        (nxt_err+1)->b += b * 1;
        (nxt_err-1)->b += b * 3;
        (nxt_err  )->b += b * 5;
        (cur_err  )->b += b * 7;

        g -= (int)aRound5to8[(wColor >> 5) & 0x1f];
        (nxt_err+1)->g += g * 1;
        (nxt_err-1)->g += g * 3;
        (nxt_err  )->g += g * 5;
        (cur_err  )->g += g * 7;

        r -= (int)aRound5to8[(wColor >> 10) & 0x1f];
        (nxt_err+1)->r += r * 1;
        (nxt_err-1)->r += r * 3;
        (nxt_err  )->r += r * 5;
        (cur_err  )->r += r * 7;

        nxt_err++;
    }
}

void Dith24to16(WORD *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT cx,
    UINT y, int cy)
{
    int dy;

    cx += x;

    if (cy < 0)
    {
        dy = -1;
        cy *= -1;
    }
    else
        dy = 1;

    if (y & 1)
        SwapError(&cur_err, &nxt_err);

    while (cy)
    {
        DithScan24to16(dst, src, cur_err, nxt_err, x, cx, y);

        ZeroError(cur_err, cx);
        SwapError(&cur_err, &nxt_err);

        *(BYTE **)&src += src_next_scan;
        *(BYTE **)&dst += dst_next_scan;
        y += dy;
        cy--;
    }
}

///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\imgutil\cmapmime.cpp ===
#include "stdafx.h"
#include "imgutil.h"
#include "resource.h"
#include "cmapmime.h"

CMapStringToCLSID* g_pDefaultMappings = NULL;
BOOL g_bDefaultMappingsInitialized = FALSE;
CRITICAL_SECTION g_csDefaultMappings;
const LPCTSTR MIME_DATABASE_ROOT = _T( "MIME\\Database\\Content Type" );

int UNICODEstrlen(LPCTSTR psz)
{
    const TCHAR *p;

    for (p = psz; *p; ++p)
        ;

    return (int)(p - psz);
}

HRESULT InitDefaultMappings()
{
   HRESULT hResult;
   LONG nResult;
   HKEY hKey;
   ULONG iSubkey;
   HKEY hSubkey;
   BOOL bDone;
   ULONG nNameLength;
   TCHAR szKeyName[MAX_PATH+1];
   CMapStringToCLSID* pMapping;
   FILETIME time;

   InitializeCriticalSection( &g_csDefaultMappings );
   
   nResult = RegOpenKeyEx( HKEY_CLASSES_ROOT, MIME_DATABASE_ROOT, 0, KEY_READ,
      &hKey );
   if( nResult != ERROR_SUCCESS )
   {
      return( E_FAIL );
   }

   iSubkey = 0;
   bDone = FALSE;
   while( !bDone )
   {
      nNameLength = sizeof( szKeyName )/sizeof( *szKeyName );
      nResult = RegEnumKeyEx( hKey, iSubkey, szKeyName, &nNameLength, NULL, 
         NULL, NULL, &time );
      if( (nResult != ERROR_SUCCESS) && (nResult != ERROR_NO_MORE_ITEMS) )
      {
         RegCloseKey( hKey );
         return( E_FAIL );
      }
      if( nResult == ERROR_SUCCESS )
      {
         nResult = RegOpenKeyEx( hKey, szKeyName, 0, KEY_READ, &hSubkey );
         if( nResult != ERROR_SUCCESS )
         {
            RegCloseKey( hKey );
            return( E_FAIL );
         }

         pMapping = new CMapStringToCLSID;
         if( pMapping == NULL )
         {
            return( E_OUTOFMEMORY );
         }
         hResult = pMapping->InitFromKey( hSubkey, szKeyName );
         if( SUCCEEDED( hResult ) )
         {
            pMapping->m_pNext = g_pDefaultMappings;
            g_pDefaultMappings = pMapping;
         }
         else
         {
            delete pMapping;
         }

         RegCloseKey( hSubkey );
      }
      else
      {
         bDone = TRUE;
      }

      iSubkey++;
   }

   return( S_OK );
}

void CleanupDefaultMappings()
{
   CMapStringToCLSID* pKill;

   EnterCriticalSection( &g_csDefaultMappings );

   while( g_pDefaultMappings != NULL )
   {
      pKill = g_pDefaultMappings;
      g_pDefaultMappings = g_pDefaultMappings->m_pNext;
      delete pKill;
   }

   LeaveCriticalSection( &g_csDefaultMappings );

   DeleteCriticalSection( &g_csDefaultMappings );
}

static HRESULT DefaultMapMIMEToCLSID( LPCTSTR pszMIMEType, CLSID* pCLSID )
{
   CMapStringToCLSID* pTrav;
   BOOL bFound;

   _ASSERTE( pszMIMEType != NULL );
   _ASSERTE( pCLSID != NULL );

   *pCLSID = CLSID_NULL;

   EnterCriticalSection( &g_csDefaultMappings );

   bFound = FALSE;
   pTrav = g_pDefaultMappings;
   while( (pTrav != NULL) && !bFound )
   {
      if( lstrcmp( pszMIMEType, pTrav->GetString() ) == 0 )
      {
         *pCLSID = pTrav->GetCLSID();
         bFound = TRUE;
      }
      pTrav = pTrav->m_pNext;
   }

   LeaveCriticalSection( &g_csDefaultMappings );

   if( IsEqualCLSID( *pCLSID, CLSID_NULL ) )
   {
      return( S_FALSE );
   }
   else
   {
      return( S_OK );
   }
}

CMapStringToCLSID::CMapStringToCLSID() :
   m_pNext( NULL ),
   m_pszString( NULL ),
   m_clsid( CLSID_NULL ),
   m_dwMapMode( MAPMIME_DEFAULT )
{
   memcpy( m_achSignature, "NoLK", 4 );
}

CMapStringToCLSID::~CMapStringToCLSID()
{
   delete m_pszString;
}

const CLSID& CMapStringToCLSID::GetCLSID() const
{
   return( m_clsid );
}

DWORD CMapStringToCLSID::GetMapMode() const
{
   return( m_dwMapMode );
}

LPCTSTR CMapStringToCLSID::GetString() const
{
   _ASSERTE( m_pszString != NULL );

   return( m_pszString );
}

HRESULT CMapStringToCLSID::InitFromKey( HKEY hKey, LPCTSTR pszKeyName )
{
   LONG nResult;
   HRESULT hResult;
   DWORD dwValueType;
   BYTE* pData;
   ULONG nBytes = 0;
   CLSID clsid;
   USES_CONVERSION;

   nResult = RegQueryValueEx( hKey, _T( "Image Filter CLSID" ), NULL, 
      &dwValueType, NULL, &nBytes );
   if( (nResult != ERROR_SUCCESS) || (dwValueType != REG_SZ) || nBytes > 8192 )
   {
      return( E_FAIL );
   }
   pData = LPBYTE( _alloca( nBytes ) );

   nResult = RegQueryValueEx( hKey, _T( "Image Filter CLSID" ), NULL, 
      &dwValueType, pData, &nBytes );
   if( nResult != ERROR_SUCCESS )
   {
      return( E_FAIL );
   }

   hResult = SetString( pszKeyName );
   if( FAILED( hResult ) )
   {
      return( hResult );
   }

   CLSIDFromString( T2OLE( LPTSTR( pData ) ), &clsid );
   SetCLSID( clsid );

   return( S_OK );
}

void CMapStringToCLSID::SetCLSID( REFGUID clsid )
{
   m_clsid = clsid;
}

void CMapStringToCLSID::SetMapMode( DWORD dwMapMode )
{
   m_dwMapMode = dwMapMode;
}

HRESULT CMapStringToCLSID::SetString( LPCTSTR pszString )
{
   _ASSERTE( m_pszString == NULL );

   m_pszString = new TCHAR[UNICODEstrlen( pszString )+1];
   if( m_pszString == NULL )
   {
      return( E_OUTOFMEMORY );
   }

   lstrcpy( m_pszString, pszString );

   return( S_OK );
}

CMapMIMEToCLSID::CMapMIMEToCLSID() :
   m_nMappings( 0 ),
   m_pMappings( NULL ),
   m_bEnableDefaultMappings( TRUE )
{
}

CMapMIMEToCLSID::~CMapMIMEToCLSID()
{
   CMapStringToCLSID* pKill;

   while( m_pMappings != NULL )
   {
      pKill = m_pMappings;
      m_pMappings = m_pMappings->m_pNext;
      delete pKill;
   }
}

CMapStringToCLSID* CMapMIMEToCLSID::FindMapping( LPCTSTR pszMIMEType )
{
   CMapStringToCLSID* pMapping;

   pMapping = m_pMappings;
   while( pMapping != NULL )
   {
      if( lstrcmp( pMapping->GetString(), pszMIMEType ) == 0 )
      {
         return( pMapping );
      }
      pMapping = pMapping->m_pNext;
   }

   return( NULL );
}

CMapStringToCLSID* CMapMIMEToCLSID::AddMapping( LPCTSTR pszMIMEType )
{
   CMapStringToCLSID* pMapping;
   HRESULT hResult;

   pMapping = new CMapStringToCLSID;
   if( pMapping == NULL )
   {
      return( NULL );
   }
   
   hResult = pMapping->SetString( pszMIMEType );
   if( FAILED( hResult ) )
   {
      delete pMapping;
      return( NULL );
   }

   pMapping->m_pNext = m_pMappings;
   m_pMappings = pMapping;
   m_nMappings++;

   return( pMapping );
}

void CMapMIMEToCLSID::DeleteMapping( LPCTSTR pszMIMEType )
{
   CMapStringToCLSID* pMapping;
   CMapStringToCLSID* pFollow;

   pFollow = NULL;
   pMapping = m_pMappings;
   while( pMapping != NULL )
   {
      if( lstrcmp( pMapping->GetString(), pszMIMEType ) == 0 )
      {
         if( pFollow == NULL )
         {
            m_pMappings = pMapping->m_pNext;
         }
         else
         {
            pFollow->m_pNext = pMapping->m_pNext;
         }
         delete pMapping;
         m_nMappings--;
         return;
      }
      pFollow = pMapping;
      pMapping = pMapping->m_pNext;
   }
}

STDMETHODIMP CMapMIMEToCLSID::SetMapping( LPCOLESTR pszMIMEType, 
   DWORD dwMapMode, REFGUID clsid )
{
   USES_CONVERSION;
   CMapStringToCLSID* pMapping;
   LPCTSTR pszMIMETypeT;

   if( pszMIMEType == NULL )
   {
      return( E_INVALIDARG );
   }
   if( dwMapMode > MAPMIME_DEFAULT_ALWAYS )
   {
      return( E_INVALIDARG );
   }

   pszMIMETypeT = OLE2CT( pszMIMEType );

   if( dwMapMode == MAPMIME_DEFAULT )
   {
      DeleteMapping( pszMIMETypeT );
   }
   else
   {
      pMapping = FindMapping( pszMIMETypeT );
      if( pMapping == NULL )
      {
         pMapping = AddMapping( pszMIMETypeT );
         if( pMapping == NULL )
         {
            return( E_OUTOFMEMORY );
         }
      }
      pMapping->SetMapMode( dwMapMode );
      if( dwMapMode == MAPMIME_CLSID )
      {
         pMapping->SetCLSID( clsid );
      }
   }

   return( S_OK );
}

STDMETHODIMP CMapMIMEToCLSID::EnableDefaultMappings( BOOL bEnable )
{
   m_bEnableDefaultMappings = bEnable;

   return( S_OK );
}

STDMETHODIMP CMapMIMEToCLSID::MapMIMEToCLSID( LPCOLESTR pszMIMEType, 
   GUID* pCLSID )
{
   USES_CONVERSION;
   LPCTSTR pszMIMETypeT;
   DWORD dwMapMode;
   GUID clsid = CLSID_NULL;
   CMapStringToCLSID* pMapping;
   HRESULT hResult;

   if( pCLSID != NULL )
   {
      *pCLSID = CLSID_NULL;
   }
   if( pszMIMEType == NULL )
   {
      return( E_INVALIDARG );
   }
   if( pCLSID == NULL )
   {
      return( E_POINTER );
   }

   pszMIMETypeT = OLE2CT( pszMIMEType );

   pMapping = FindMapping( pszMIMETypeT );
   if( pMapping != NULL )
   {
      dwMapMode = pMapping->GetMapMode();
      if( dwMapMode == MAPMIME_CLSID )
      {
         clsid = pMapping->GetCLSID();
      }
   }
   else
   {
      dwMapMode = MAPMIME_DEFAULT;
   }

   switch( dwMapMode )
   {
   case MAPMIME_DEFAULT:
      if( m_bEnableDefaultMappings )
      {
         hResult = DefaultMapMIMEToCLSID( pszMIMETypeT, &clsid );
      }
      else
      {
         hResult = S_FALSE;
      }
      break;

   case MAPMIME_DEFAULT_ALWAYS:
      hResult = DefaultMapMIMEToCLSID( pszMIMETypeT, &clsid );
      break;

   case MAPMIME_CLSID:
      hResult = S_OK;
      break;

   case MAPMIME_DISABLE:
      hResult = S_FALSE;
      break;

   default:
      _ASSERT( FALSE );
      hResult = E_FAIL;
      break;
   }

   if( hResult == S_OK )
   {
      *pCLSID = clsid;
   }

   return( hResult );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\imgutil\csnfstrm.cpp ===
#include "stdafx.h"
#include "imgutil.h"
#include "resource.h"
#include "csnfstrm.h"

CSniffStream::CSniffStream() :
   m_pbBuffer( NULL ),
   m_iOffset( 0 ),
   m_nBufferSize( 0 ),
   m_nValidBytes( 0 ),
   m_iNextFreeByte( 0 )
{
}

CSniffStream::~CSniffStream()
{
   delete m_pbBuffer;
}

STDMETHODIMP CSniffStream::Clone( IStream** ppStream )
{
   if( ppStream == NULL )
   {
      return( E_POINTER );
   }

   *ppStream = NULL;

   return( E_NOTIMPL );
}

STDMETHODIMP CSniffStream::Commit( DWORD dwFlags )
{
   (void)dwFlags;

   return( E_NOTIMPL );
}

STDMETHODIMP CSniffStream::CopyTo( IStream* pStream, ULARGE_INTEGER nBytes,
   ULARGE_INTEGER* pnBytesRead, ULARGE_INTEGER* pnBytesWritten )
{
   (void)pStream;
   (void)nBytes;
   (void)pnBytesRead;
   (void)pnBytesWritten;

   return( E_NOTIMPL );
}

STDMETHODIMP CSniffStream::LockRegion( ULARGE_INTEGER iOffset, 
   ULARGE_INTEGER nBytes, DWORD dwLockType )
{
   (void)iOffset;
   (void)nBytes;
   (void)dwLockType;

   return( E_NOTIMPL );
}

STDMETHODIMP CSniffStream::Read( void* pBuffer, ULONG nBytes, 
   ULONG* pnBytesRead )
{
   ULONG nBytesToRead = 0;
   ULONG nBytesLeft;
   ULONG nBytesRead;
   BYTE* pbBuffer;
   HRESULT hResult;

   if( pnBytesRead != NULL )
   {
      *pnBytesRead = 0;
   }

   if( pBuffer == NULL )
   {
      return( E_POINTER );
   }

   if( nBytes == 0 )
   {
      return( E_INVALIDARG );
   }

   pbBuffer = LPBYTE( pBuffer );
   nBytesLeft = nBytes;
   if( m_pbBuffer != NULL )
   {
      _ASSERTE( m_nValidBytes > 0 );

      nBytesToRead = min( nBytesLeft, m_nValidBytes );
      memcpy( pbBuffer, &m_pbBuffer[m_iOffset], nBytesToRead );
      nBytesLeft -= nBytesToRead;
      if( pnBytesRead != NULL )
      {
         *pnBytesRead += nBytesToRead;
      }
      m_nValidBytes -= nBytesToRead;
      pbBuffer += nBytesToRead;
      m_iOffset += nBytesToRead;
      if( m_nValidBytes == 0 )
      {
         delete m_pbBuffer;
         m_pbBuffer = NULL;
         m_nValidBytes = 0;
         m_iNextFreeByte = 0;
         m_iOffset = 0;
         m_nBufferSize = 0;
      }
   }

   if( nBytesLeft == 0 )
   {
      return( S_OK );
   }

   _ASSERTE( m_pbBuffer == NULL );
   hResult = m_pStream->Read( pbBuffer, nBytesLeft, &nBytesRead );
   if( hResult == S_OK && pnBytesRead != NULL )
   {
      *pnBytesRead += nBytesRead;
   }

   return( hResult );
}

STDMETHODIMP CSniffStream::Revert()
{
   return( E_NOTIMPL );
}

STDMETHODIMP CSniffStream::Seek( LARGE_INTEGER nDisplacement, DWORD dwOrigin,
   ULARGE_INTEGER* piNewPosition )
{
   (void)nDisplacement;
   (void)dwOrigin;
   (void)piNewPosition;

   return( E_NOTIMPL );
}

STDMETHODIMP CSniffStream::SetSize( ULARGE_INTEGER nNewSize )
{
   (void)nNewSize;

   return( E_NOTIMPL );
}

STDMETHODIMP CSniffStream::Stat( STATSTG* pStatStg, DWORD dwFlags )
{
   (void)pStatStg;
   (void)dwFlags;

   return( E_NOTIMPL );
}

STDMETHODIMP CSniffStream::UnlockRegion( ULARGE_INTEGER iOffset, 
   ULARGE_INTEGER nBytes, DWORD dwLockType )
{
   (void)iOffset;
   (void)nBytes;
   (void)dwLockType;

   return( E_NOTIMPL );
}

STDMETHODIMP CSniffStream::Write( const void* pBuffer, ULONG nBytes, 
   ULONG* pnBytesWritten )
{
   (void)pBuffer;
   (void)nBytes;
   (void)pnBytesWritten;

   return( E_NOTIMPL );
}

STDMETHODIMP CSniffStream::Init( IStream* pStream )
{
   if( pStream == NULL )
   {
      return( E_INVALIDARG );
   }

   m_pStream = pStream;

   return( S_OK );
}

STDMETHODIMP CSniffStream::Peek( void* pBuffer, ULONG nBytes, 
   ULONG* pnBytesRead )
{
   BYTE* pbNewBuffer;
   HRESULT hResult;
   ULONG nBytesToRead;
   ULONG nBytesRead;

   if( pnBytesRead != NULL )
   {
      *pnBytesRead = 0;
   }

   if( pBuffer == NULL )
   {
      return( E_POINTER );
   }
   if( nBytes == 0 )
   {
      return( E_INVALIDARG );
   }

   hResult = S_OK;

   if( nBytes > m_nValidBytes )
   {
      // We have to read from the stream

      if( nBytes > (m_nBufferSize-m_iOffset) )
      {
         // We need more buffer space
         pbNewBuffer = new BYTE[nBytes];
         if( pbNewBuffer == NULL )
         {
            return( E_OUTOFMEMORY );
         }

         if( m_pbBuffer != NULL )
         {
            memcpy( pbNewBuffer, &m_pbBuffer[m_iOffset], m_nValidBytes );
         }
         delete m_pbBuffer;
         m_pbBuffer = pbNewBuffer;

         m_nBufferSize = nBytes;
         m_iOffset = 0;
         m_iNextFreeByte = m_nValidBytes;
      }

      hResult = m_pStream->Read( &m_pbBuffer[m_iNextFreeByte], 
         nBytes-m_nValidBytes, &nBytesRead );
      m_iNextFreeByte += nBytesRead;
      m_nValidBytes += nBytesRead;
   }

   // Copy as much as we can from our buffer
   nBytesToRead = min( nBytes, m_nValidBytes );
   if( nBytesToRead > 0 )
   {
      memcpy( pBuffer, &m_pbBuffer[m_iOffset], nBytesToRead );
      if( pnBytesRead != NULL )
      {
         *pnBytesRead += nBytesToRead;
      }
   }

   if( nBytesToRead == nBytes )
   {
      return( S_OK );
   }
   else
   {
      return( hResult );
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\imgutil\cmimeid.cpp ===
#include "stdafx.h"
#include "imgutil.h"
#include "cmimeid.h"

static CRITICAL_SECTION g_csMIMEIdentifier;
static CMIMEIdentifier* g_pMIMEIdentifier = NULL;

void InitMIMEIdentifier()
{
   InitializeCriticalSection( &g_csMIMEIdentifier );
}

void CleanupMIMEIdentifier()
{
    DeleteCriticalSection(&g_csMIMEIdentifier);
}


STDAPI GetMaxMIMEIDBytes( ULONG* pnMaxBytes )
{
   HRESULT hResult;

   if( pnMaxBytes != NULL )
   {
      *pnMaxBytes = 0;
   }
   if( pnMaxBytes == NULL )
   {
      return( E_POINTER );
   }

   EnterCriticalSection( &g_csMIMEIdentifier );
   if( g_pMIMEIdentifier == NULL )
   {
      g_pMIMEIdentifier = new CMIMEIdentifier;
      hResult = g_pMIMEIdentifier->InitFromRegistry();
      if( FAILED( hResult ) )
      {
         delete g_pMIMEIdentifier;
         g_pMIMEIdentifier = NULL;
         LeaveCriticalSection( &g_csMIMEIdentifier );
         return( hResult );
      }
   }

   *pnMaxBytes = g_pMIMEIdentifier->GetMaxBytes();

   LeaveCriticalSection( &g_csMIMEIdentifier );

   return( S_OK );
}

STDAPI IdentifyMIMEType( const BYTE* pbBytes, ULONG nBytes, 
   UINT* pnFormat )
{
   HRESULT hResult;
  
   if( pnFormat != NULL )
   {
      *pnFormat = 0;
   }
   if( pbBytes == NULL )
   {
      return( E_INVALIDARG );
   }
   if( pnFormat == NULL )
   {
      return( E_POINTER );
   }

   EnterCriticalSection( &g_csMIMEIdentifier );
   if( g_pMIMEIdentifier == NULL )
   {
      g_pMIMEIdentifier = new CMIMEIdentifier;
      hResult = g_pMIMEIdentifier->InitFromRegistry();
      if( FAILED( hResult ) )
      {
         delete g_pMIMEIdentifier;
         g_pMIMEIdentifier = NULL;
         LeaveCriticalSection( &g_csMIMEIdentifier );
         return( hResult );
      }
   }

   hResult = g_pMIMEIdentifier->Identify( pbBytes, nBytes, pnFormat );
   LeaveCriticalSection( &g_csMIMEIdentifier );

   return( hResult );
}

STDAPI SniffStream( IStream* pInStream, UINT* pnFormat, 
   IStream** ppOutStream )
{
   HRESULT hResult;
   HRESULT hIDResult;
   CComPtr< ISniffStream > pSniffStream;

   if( pnFormat != NULL )
   {
      *pnFormat = 0;
   }
   if( ppOutStream != NULL )
   {
      *ppOutStream = NULL;
   }

   if( pInStream == NULL )
   {
      return( E_INVALIDARG );
   }
   if( pnFormat == NULL )
   {
      return( E_POINTER );
   }
   if( ppOutStream == NULL )
   {
      return( E_POINTER );
   }

   hResult = pInStream->QueryInterface( IID_ISniffStream, 
      (void**)&pSniffStream );
   if( FAILED( hResult ) && (hResult != E_NOINTERFACE) )
   {
      return( hResult );
   }

   if( hResult == E_NOINTERFACE )
   {
      hResult = CoCreateInstance( CLSID_CoSniffStream, NULL, 
         CLSCTX_INPROC_SERVER, IID_ISniffStream, (void**)&pSniffStream );
      if( FAILED( hResult ) )
      {
         return( hResult );
      }

      hResult = pSniffStream->Init( pInStream );
      if( FAILED( hResult ) )
      {
         return( hResult );
      }
   }


   EnterCriticalSection( &g_csMIMEIdentifier );
   if( g_pMIMEIdentifier == NULL )
   {
      g_pMIMEIdentifier = new CMIMEIdentifier;
      hResult = g_pMIMEIdentifier->InitFromRegistry();
      if( FAILED( hResult ) )
      {
         delete g_pMIMEIdentifier;
         g_pMIMEIdentifier = NULL;
         LeaveCriticalSection( &g_csMIMEIdentifier );
         return( hResult );
      }
   }

   hIDResult = g_pMIMEIdentifier->IdentifyStream( pSniffStream, pnFormat );
   LeaveCriticalSection( &g_csMIMEIdentifier );
   if( FAILED( hIDResult ) )
   {
      return( hIDResult );
   }

   hResult = pSniffStream->QueryInterface( IID_IStream, (void**)ppOutStream );
   if( FAILED( hResult ) )
   {
      return( hResult );
   }

   return( hIDResult );
}

const LPCTSTR MIME_DATABASE_ROOT = _T( "MIME\\Database\\Content Type" );

CMIMEBitMatcher::CMIMEBitMatcher() :
   m_pNext( NULL ),
   m_nOffset( 0 ),
   m_nBytes( 0 ),
   m_pMask( NULL ),
   m_pData( NULL )
{
   memcpy( m_achSignature, "NoLK", 4 );
}

CMIMEBitMatcher::~CMIMEBitMatcher()
{
   delete m_pMask;
   delete m_pData;
}

HRESULT CMIMEBitMatcher::InitFromBinary( const BYTE* pData, ULONG nBytes,
   ULONG* pnBytesToMatch )
{
   const BYTE* pTrav;
#ifdef BIG_ENDIAN
   BYTE pTravBig[4];
#endif

   _ASSERTE( pData != NULL );
   _ASSERTE( pnBytesToMatch != NULL );

   if( nBytes <= sizeof( ULONG ) )
   {
      return( E_FAIL );
   }

   pTrav = pData;
#ifdef BIG_ENDIAN
   pTravBig[0] = pTrav[3];
   pTravBig[1] = pTrav[2];
   pTravBig[2] = pTrav[1];
   pTravBig[3] = pTrav[0];
   m_nBytes = *(ULONG*)pTravBig;
#else
   m_nBytes = *(const ULONG*)(pTrav);
#endif   

   pTrav += sizeof( ULONG );

   if( nBytes != (2*m_nBytes)+sizeof( ULONG ) )
   {
      return( E_FAIL );
   }

   m_pMask = new BYTE[m_nBytes];
   if( m_pMask == NULL )
   {
      return( E_OUTOFMEMORY );
   }

   m_pData = new BYTE[m_nBytes];
   if( m_pData == NULL )
   {
      return( E_OUTOFMEMORY );
   }

   memcpy( m_pMask, pTrav, m_nBytes );
   pTrav += m_nBytes;
   memcpy( m_pData, pTrav, m_nBytes );

   *pnBytesToMatch = m_nBytes;

   return( S_OK );
}

HRESULT CMIMEBitMatcher::Match( const BYTE* pBytes, ULONG nBytes ) const
{
   ULONG iByte;
   ULONG nBytesToMatch;

   _ASSERTE( m_nBytes > 0 );

   nBytesToMatch = min( nBytes, m_nBytes );
   for( iByte = 0; iByte < nBytesToMatch; iByte++ )
   {
      if( (pBytes[iByte]&m_pMask[iByte]) != m_pData[iByte] )
      {
         // The bits definitely don't match
         return( S_FALSE );
      }
   }

   if( nBytes < m_nBytes )
   {
      // We could have a match, but we need more data to be sure.
      return( E_PENDING );
   }

   // We have a match
   return( S_OK );
}


CMIMEType::CMIMEType() :
   m_pNext( NULL ),
   m_nClipboardFormat( 0 ),
   m_lpBitMatchers( NULL ),
   m_nMaxBytes( 0 )
{
   memcpy( m_achSignature, "NoLK", 4 );
}

CMIMEType::~CMIMEType()
{
   CMIMEBitMatcher* pBitMatcher;

   while( m_lpBitMatchers != NULL )
   {
      pBitMatcher = m_lpBitMatchers;
      m_lpBitMatchers = m_lpBitMatchers->m_pNext;
      delete pBitMatcher;
   }
}

UINT CMIMEType::GetClipboardFormat() const
{
   return( m_nClipboardFormat );
}

HRESULT CMIMEType::InitFromKey( HKEY hKey, LPCTSTR pszName, ULONG* pnMaxBytes )
{
   LONG nResult;
   HRESULT hResult;
   HKEY hBitsKey;
   DWORD dwValueType;
   BYTE* pData;
   ULONG nBytes = 0;
   ULONG nBytesToMatch;
   CMIMEBitMatcher* pBitMatcher;

   _ASSERTE( hKey != NULL );
   _ASSERTE( pszName != NULL );
   _ASSERTE( pnMaxBytes != NULL );

   nResult = RegOpenKeyEx( hKey, _T( "Bits" ), 0, KEY_READ, &hBitsKey );
   if( nResult != ERROR_SUCCESS )
   {
      return( E_FAIL );
   }

   nResult = RegQueryValueEx( hBitsKey, _T( "0" ), NULL, &dwValueType, NULL,
      &nBytes );
   if( (nResult != ERROR_SUCCESS) || (dwValueType != REG_BINARY) || nBytes > 8192 )
   {
      RegCloseKey( hBitsKey );
      return( E_FAIL );
   }
   pData = LPBYTE( _alloca( nBytes ) );

   nResult = RegQueryValueEx( hBitsKey, _T( "0" ), NULL, &dwValueType, pData,
      &nBytes );
   if( nResult != ERROR_SUCCESS )
   {
      RegCloseKey( hBitsKey );
      return( E_FAIL );
   }

   RegCloseKey( hBitsKey );

   pBitMatcher = new CMIMEBitMatcher;
   if( pBitMatcher == NULL )
   {
      return( E_OUTOFMEMORY );
   }

   hResult = pBitMatcher->InitFromBinary( pData, nBytes, &nBytesToMatch );
   if( FAILED( hResult ) )
   {
      delete pBitMatcher;
      return( hResult );
   }

   m_nMaxBytes = max( m_nMaxBytes, nBytesToMatch );

   m_lpBitMatchers = pBitMatcher;

   m_nClipboardFormat = RegisterClipboardFormat( pszName );
   if( m_nClipboardFormat == 0 )
   {
      return( E_FAIL );
   }

   *pnMaxBytes = m_nMaxBytes;

   return( S_OK );
}

HRESULT CMIMEType::Match( const BYTE* pBytes, ULONG nBytes ) const
{
   HRESULT hResult;
   HRESULT hResultSoFar;
   CMIMEBitMatcher* pBitMatcher;

   _ASSERTE( pBytes != NULL );
   _ASSERTE( m_nClipboardFormat != 0 );
   _ASSERTE( m_lpBitMatchers != NULL );

   hResultSoFar = S_FALSE;
   for( pBitMatcher = m_lpBitMatchers; pBitMatcher != NULL; pBitMatcher =
      pBitMatcher->m_pNext )
   {
      hResult = pBitMatcher->Match( pBytes, nBytes );
      switch( hResult )
      {
      case S_OK:
         return( S_OK );
         break;

      case E_PENDING:
         hResultSoFar = E_PENDING;
         break;

      case S_FALSE:
         break;

      default:
         return( hResult );
         break;
      }
   }

   return( hResultSoFar );
}


CMIMEIdentifier::CMIMEIdentifier() :
   m_lpTypes( NULL ),
   m_nMaxBytes( 0 )
{
   memcpy( m_achSignature, "NoLK", 4 );
}

CMIMEIdentifier::~CMIMEIdentifier()
{
   CMIMEType* pType;

   while( m_lpTypes != NULL )
   {
      pType = m_lpTypes;
      m_lpTypes = m_lpTypes->m_pNext;
      delete pType;
   }
}

ULONG CMIMEIdentifier::GetMaxBytes() const
{
   return( m_nMaxBytes );
}

HRESULT CMIMEIdentifier::Identify( const BYTE* pbBytes, ULONG nBytes, 
   UINT* pnFormat )
{
   HRESULT hResultSoFar;
   CMIMEType* pType;
   HRESULT hResult;

   if( pnFormat != NULL )
   {
      *pnFormat = 0;
   }
   if( pbBytes == NULL )
   {
      return( E_INVALIDARG );
   }
   if( pnFormat == NULL )
   {
      return( E_POINTER );
   }

   hResultSoFar = S_FALSE;
   for( pType = m_lpTypes; pType != NULL; pType = pType->m_pNext )
   {
      hResult = pType->Match( pbBytes, nBytes );
      switch( hResult )
      {
      case S_OK:
         *pnFormat = pType->GetClipboardFormat();
         return( S_OK );
         break;

      case E_PENDING:
         hResultSoFar = E_PENDING;
         break;

      case S_FALSE:
         break;

      default:
         return( hResult );
         break;
      }
   }

   return( hResultSoFar );
}

HRESULT CMIMEIdentifier::IdentifyStream( ISniffStream* pSniffStream, 
   UINT* pnFormat )
{
   HRESULT hResult;
   HRESULT hPeekResult;
   BYTE* pbBytes;
   ULONG nBytesRead;
   UINT nFormat;

   if( pnFormat != NULL )
   {
      *pnFormat = 0;
   }
   if( pSniffStream == NULL )
   {
      return( E_INVALIDARG );
   }
   if( pnFormat == NULL )
   {
      return( E_POINTER );
   }

   pbBytes = LPBYTE( _alloca( m_nMaxBytes ) );
   hPeekResult = pSniffStream->Peek( pbBytes, m_nMaxBytes, &nBytesRead );
   if( FAILED( hPeekResult ) && (hPeekResult != E_PENDING) )
   {
      return( hPeekResult );
   }

   hResult = Identify( pbBytes, nBytesRead, &nFormat );
   if( hResult == S_OK )
   {
      *pnFormat = nFormat;
   }
   if( (hResult == E_PENDING) && (hPeekResult == S_FALSE) )
   {
      return( S_FALSE );
   }

   return( hResult );
}

HRESULT CMIMEIdentifier::InitFromRegistry()
{
   LONG nResult;
   HKEY hKey;
   ULONG iSubkey;
   HKEY hSubkey;
   TCHAR szKeyName[MAX_PATH+1];
   ULONG nNameLength;
   FILETIME time;
   BOOL bDone;
   CMIMEType* pType;
   HRESULT hResult;
   ULONG nMaxBytes;

   if( m_lpTypes != NULL )
   {
      return( E_FAIL );
   }

   nResult = RegOpenKeyEx( HKEY_CLASSES_ROOT, MIME_DATABASE_ROOT, 0, KEY_READ,
      &hKey );
   if( nResult != ERROR_SUCCESS )
   {
      return( E_FAIL );
   }

   iSubkey = 0;
   bDone = FALSE;
   while( !bDone )
   {
      nNameLength = sizeof( szKeyName )/sizeof( *szKeyName );
      nResult = RegEnumKeyEx( hKey, iSubkey, szKeyName, &nNameLength, NULL, 
         NULL, NULL, &time );
      if( (nResult != ERROR_SUCCESS) && (nResult != ERROR_NO_MORE_ITEMS) )
      {
         RegCloseKey( hKey );
         return( E_FAIL );
      }
      if( nResult == ERROR_SUCCESS )
      {
         nResult = RegOpenKeyEx( hKey, szKeyName, 0, KEY_READ, &hSubkey );
         if( nResult != ERROR_SUCCESS )
         {
            RegCloseKey( hKey );
            return( E_FAIL );
         }

         pType = new CMIMEType;
         if( pType == NULL )
         {
            return( E_OUTOFMEMORY );
         }
         hResult = pType->InitFromKey( hSubkey, szKeyName, &nMaxBytes );
         if( SUCCEEDED( hResult ) )
         {
            m_nMaxBytes = max( m_nMaxBytes, nMaxBytes );
            pType->m_pNext = m_lpTypes;
            m_lpTypes = pType;
         }
         else
         {
            delete pType;
         }

         RegCloseKey( hSubkey );
      }
      else
      {
         bDone = TRUE;
      }

      iSubkey++;
   }

   return( S_OK );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\imgutil\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#ifdef UNIX
#include "include/dlldata.c"
#include "include/imgutil_p.c"
#else
#include "include\dlldata.c"
#include "include\imgutil_p.c"
#endif

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#else
// We have to put something here to keep the compiler from bitching
static int g_foo;
#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\imgutil\include\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\imgutil\dlldatax.h ===
#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\imgutil\csnfstrm.h ===
class CSniffStream :
   public IStream,
   public ISniffStream,
   public CComObjectRoot,
   public CComCoClass< CSniffStream, &CLSID_CoSniffStream >
{
public:
   CSniffStream();  // Default constructor
   ~CSniffStream();  // Destructor

   BEGIN_COM_MAP( CSniffStream )
      COM_INTERFACE_ENTRY( IStream )
      COM_INTERFACE_ENTRY( ISniffStream )
   END_COM_MAP()


   DECLARE_REGISTRY( CSniffStream, _T( "ImgUtil.CoSniffStream.1" ),
      _T( "ImgUtil.CoSniffStream" ), IDS_COSNIFFSTREAM_DESC, 
      THREADFLAGS_BOTH );


//   DECLARE_NO_REGISTRY()

// IStream
public:
   STDMETHOD( Clone )( IStream** ppStream );
   STDMETHOD( Commit )( DWORD dwFlags );
   STDMETHOD( CopyTo )( IStream* pStream, ULARGE_INTEGER nBytes, 
      ULARGE_INTEGER* pnBytesRead, ULARGE_INTEGER* pnBytesWritten );
   STDMETHOD( LockRegion )( ULARGE_INTEGER iOffset, ULARGE_INTEGER nBytes,
      DWORD dwLockType );
   STDMETHOD( Read )( void* pBuffer, ULONG nBytes, ULONG* pnBytesRead );
   STDMETHOD( Revert )();
   STDMETHOD( Seek )( LARGE_INTEGER nDisplacement, DWORD dwOrigin, 
      ULARGE_INTEGER* piNewPosition );
   STDMETHOD( SetSize )( ULARGE_INTEGER nNewSize );
   STDMETHOD( Stat )( STATSTG* pStatStg, DWORD dwFlags );
   STDMETHOD( UnlockRegion )( ULARGE_INTEGER iOffset, ULARGE_INTEGER nBytes,
      DWORD dwLockType );
   STDMETHOD( Write )( const void* pBuffer, ULONG nBytes, 
      ULONG* pnBytesWritten );

// ISniffStream
public:
   STDMETHOD( Init )( IStream* pStream );
   STDMETHOD( Peek )( void* pBuffer, ULONG nBytes, ULONG* pnBytesRead );

protected:
   CComPtr< IStream > m_pStream;
   BYTE* m_pbBuffer;
   ULONG m_nBufferSize;
   ULONG m_nValidBytes;
   ULONG m_iNextFreeByte;
   ULONG m_iOffset;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\imgutil\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by imgutil.rc
//

#define IDS_COBITMAPSURFACE_DESC        1
#define IDS_COSNIFFSTREAM_DESC          4
#define IDS_COMAPMIMETOCLSID_DESC       5
#define IDS_CODITHERTORGB8_DESC         8


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\imgutil\dithers.h ===
#ifndef _DITHERS_H
#define _DITHERS_H

#ifdef __cplusplus
extern "C" {
#endif

///////////////////////////////////////////////////////////////////////////////
//
// Dithering stuff.
//
// This code implements error-diffusion to an arbitrary set of colors,
// optionally with transparency.  Since the output colors can be arbitrary,
// the color picker for the dither is a 32k inverse-mapping table.  24bpp
// values are whacked down to 16bpp (555) and used as indices into the table.
// To compensate for posterization effects when converting 24bpp to 16bpp, an
// ordered dither (16bpp halftone) is used to generate the 555 color.
//
///////////////////////////////////////////////////////////////////////////////

typedef struct
{
    int r, g, b;

} ERRBUF;

__inline size_t ErrbufBytes(size_t pels)
{
    return (pels + 2) * sizeof(ERRBUF);
}

///////////////////////////////////////////////////////////////////////////////

void Dith8to8(BYTE *dst, const BYTE *src, int dst_next_scan, int src_next_scan,
    const RGBQUAD *colorsIN, const RGBQUAD *colorsOUT, const BYTE *map,
    ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT cx, UINT y, int cy);

void Convert8to8( BYTE* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, const RGBQUAD* prgbColors, const BYTE* pbMap, UINT x, 
   UINT nWidth, UINT y, int nHeight );

void DithGray8to8( BYTE* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, const RGBQUAD* prgbColors, const BYTE* pbMap,
   ERRBUF* pCurrentError, ERRBUF* pNextError, UINT x, UINT cx, UINT y, 
   int cy );

void ConvertGray8to8( BYTE* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, const BYTE* pbMap, UINT x, UINT nWidth, UINT y, 
   int nHeight );

void Dith8to8t(BYTE *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, const RGBQUAD *colorsIN, const RGBQUAD *colorsOUT,
    const BYTE *map, ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT cx, UINT y,
    int cy, BYTE indexTxpOUT, BYTE indexTxpIN);

void Dith8to16(WORD *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, const RGBQUAD *colors, ERRBUF *cur_err, ERRBUF *nxt_err,
    UINT x, UINT cx, UINT y, int cy);

void Dith8to16t(WORD *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, const RGBQUAD *colors, ERRBUF *cur_err, ERRBUF *nxt_err,
    UINT x, UINT cx, UINT y, int cy, WORD wColorTxpOUT, BYTE indexTxpIN);

void Dith24to8(BYTE *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, const RGBQUAD *colors, const BYTE *map, ERRBUF *cur_err,
    ERRBUF *nxt_err, UINT x, UINT cx, UINT y, int cy);

void Convert24to8( BYTE* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, const BYTE* pbMap, UINT x, UINT nWidth, UINT y, 
   int nHeight );

void Dith24to16(WORD *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT cx,
    UINT y, int cy);

///////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
}
#endif

#endif // _DITHERS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\imgutil\imgutil.cpp ===
// BitmapSurfaces.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file
//      dlldatax.c to the project.  Make sure precompiled headers
//      are turned off for this file, and add _MERGE_PROXYSTUB to the
//      defines for the project.
//
//      Modify the custom build rule for BitmapSurfaces.idl by adding the following
//      files to the Outputs.  You can select all of the .IDL files by
//      expanding each project and holding Ctrl while clicking on each of them.
//          BitmapSurfaces_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL,
//      run nmake -f BitmapSurfacesps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <advpub.h>
#include "initguid.h"
#include "imgutil.h"
#include "csnfstrm.h"
#include "cmimeid.h"
#include "cmapmime.h"
#include "cdithtbl.h"
#include "dithers.h"
#include "cdith8.h"
#include "dlldatax.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP( ObjectMap )
   OBJECT_ENTRY( CLSID_CoSniffStream, CSniffStream )
   OBJECT_ENTRY( CLSID_CoMapMIMEToCLSID, CMapMIMEToCLSID )
#ifndef MINSUPPORT
   OBJECT_ENTRY( CLSID_CoDitherToRGB8, CDitherToRGB8 )
#endif
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain( HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved )
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
        InitMIMEIdentifier();
        InitDefaultMappings();
#ifndef MINSUPPORT
        CDitherToRGB8::InitTableCache();
#endif
    }
    else if (dwReason == DLL_PROCESS_DETACH)
   {
#ifndef MINSUPPORT
      CDitherToRGB8::CleanupTableCache();
#endif
      CleanupMIMEIdentifier();
      CleanupDefaultMappings();
      _Module.Term();
   }

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
   return( _Module.GetClassObject(rclsid, riid, ppv) );
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI ie3_DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI ie3_DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    _Module.UnregisterServer();
    return S_OK;
}

static HINSTANCE hAdvPackLib;

REGINSTALL GetRegInstallFn(void)
{
    hAdvPackLib = LoadLibraryA("advpack.dll");
    if (!hAdvPackLib)
        return NULL;

    return (REGINSTALL)GetProcAddress(hAdvPackLib, achREGINSTALL);
}

inline void UnloadAdvPack(void)
{
    FreeLibrary(hAdvPackLib);
}

STDAPI ie4_DllRegisterServer(void)
{
    REGINSTALL pfnReg = GetRegInstallFn();
    HRESULT hr;

#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif

    if (pfnReg == NULL)
        return E_FAIL;
        
    // Delete any old registration entries, then add the new ones.
    hr = (*pfnReg)(_Module.GetResourceInstance(), "UnReg", NULL);
    if (SUCCEEDED(hr))
        hr = (*pfnReg)(_Module.GetResourceInstance(), "Reg", NULL);

    UnloadAdvPack();
    
    return hr;
}

STDAPI
ie4_DllUnregisterServer(void)
{
    REGINSTALL pfnReg = GetRegInstallFn();
    HRESULT hr;
    
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif

    if (pfnReg == NULL)
        return E_FAIL;

    hr = (*pfnReg)( _Module.GetResourceInstance(), "UnReg", NULL);

    UnloadAdvPack();

    return hr;
}

STDAPI DllRegisterServer(void)
{
    REGINSTALL pfnReg = GetRegInstallFn();
    UnloadAdvPack();

    if (pfnReg)
        return ie4_DllRegisterServer();
    else
        return ie3_DllRegisterServer();
}

STDAPI
DllUnregisterServer(void)
{
    REGINSTALL pfnReg = GetRegInstallFn();
    UnloadAdvPack();

    if (pfnReg)
        return ie4_DllUnregisterServer();
    else
        return ie3_DllUnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\imgutil\daytona\makefile.inc ===
MIDL= $(DEVTOOLS)\midl.exe

BitmapSurfaces.h: ..\BitmapSurfaces.idl

.idl.h:
   $(MIDL) $*.idl /h $*.h /tlb $*.tlb

..\imgutil.rc : ..\selfreg.inf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\imgutil\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#include <atlbase.h>
#include <ddraw.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <ocmm.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\pngfilt\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by PNGFilt.rc
//
#define IDS_COPNGFILTER_DESC            1
#define IDR_COPNGFILTER_REG             201

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        205
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\pngfilt\pngcrc.cpp ===
static DWORD g_adwCRCTable[256] =
{
   0x0,
   0x77073096,
   0xee0e612c,
   0x990951ba,
   0x76dc419,
   0x706af48f,
   0xe963a535,
   0x9e6495a3,
   0xedb8832,
   0x79dcb8a4,
   0xe0d5e91e,
   0x97d2d988,
   0x9b64c2b,
   0x7eb17cbd,
   0xe7b82d07,
   0x90bf1d91,
   0x1db71064,
   0x6ab020f2,
   0xf3b97148,
   0x84be41de,
   0x1adad47d,
   0x6ddde4eb,
   0xf4d4b551,
   0x83d385c7,
   0x136c9856,
   0x646ba8c0,
   0xfd62f97a,
   0x8a65c9ec,
   0x14015c4f,
   0x63066cd9,
   0xfa0f3d63,
   0x8d080df5,
   0x3b6e20c8,
   0x4c69105e,
   0xd56041e4,
   0xa2677172,
   0x3c03e4d1,
   0x4b04d447,
   0xd20d85fd,
   0xa50ab56b,
   0x35b5a8fa,
   0x42b2986c,
   0xdbbbc9d6,
   0xacbcf940,
   0x32d86ce3,
   0x45df5c75,
   0xdcd60dcf,
   0xabd13d59,
   0x26d930ac,
   0x51de003a,
   0xc8d75180,
   0xbfd06116,
   0x21b4f4b5,
   0x56b3c423,
   0xcfba9599,
   0xb8bda50f,
   0x2802b89e,
   0x5f058808,
   0xc60cd9b2,
   0xb10be924,
   0x2f6f7c87,
   0x58684c11,
   0xc1611dab,
   0xb6662d3d,
   0x76dc4190,
   0x1db7106,
   0x98d220bc,
   0xefd5102a,
   0x71b18589,
   0x6b6b51f,
   0x9fbfe4a5,
   0xe8b8d433,
   0x7807c9a2,
   0xf00f934,
   0x9609a88e,
   0xe10e9818,
   0x7f6a0dbb,
   0x86d3d2d,
   0x91646c97,
   0xe6635c01,
   0x6b6b51f4,
   0x1c6c6162,
   0x856530d8,
   0xf262004e,
   0x6c0695ed,
   0x1b01a57b,
   0x8208f4c1,
   0xf50fc457,
   0x65b0d9c6,
   0x12b7e950,
   0x8bbeb8ea,
   0xfcb9887c,
   0x62dd1ddf,
   0x15da2d49,
   0x8cd37cf3,
   0xfbd44c65,
   0x4db26158,
   0x3ab551ce,
   0xa3bc0074,
   0xd4bb30e2,
   0x4adfa541,
   0x3dd895d7,
   0xa4d1c46d,
   0xd3d6f4fb,
   0x4369e96a,
   0x346ed9fc,
   0xad678846,
   0xda60b8d0,
   0x44042d73,
   0x33031de5,
   0xaa0a4c5f,
   0xdd0d7cc9,
   0x5005713c,
   0x270241aa,
   0xbe0b1010,
   0xc90c2086,
   0x5768b525,
   0x206f85b3,
   0xb966d409,
   0xce61e49f,
   0x5edef90e,
   0x29d9c998,
   0xb0d09822,
   0xc7d7a8b4,
   0x59b33d17,
   0x2eb40d81,
   0xb7bd5c3b,
   0xc0ba6cad,
   0xedb88320,
   0x9abfb3b6,
   0x3b6e20c,
   0x74b1d29a,
   0xead54739,
   0x9dd277af,
   0x4db2615,
   0x73dc1683,
   0xe3630b12,
   0x94643b84,
   0xd6d6a3e,
   0x7a6a5aa8,
   0xe40ecf0b,
   0x9309ff9d,
   0xa00ae27,
   0x7d079eb1,
   0xf00f9344,
   0x8708a3d2,
   0x1e01f268,
   0x6906c2fe,
   0xf762575d,
   0x806567cb,
   0x196c3671,
   0x6e6b06e7,
   0xfed41b76,
   0x89d32be0,
   0x10da7a5a,
   0x67dd4acc,
   0xf9b9df6f,
   0x8ebeeff9,
   0x17b7be43,
   0x60b08ed5,
   0xd6d6a3e8,
   0xa1d1937e,
   0x38d8c2c4,
   0x4fdff252,
   0xd1bb67f1,
   0xa6bc5767,
   0x3fb506dd,
   0x48b2364b,
   0xd80d2bda,
   0xaf0a1b4c,
   0x36034af6,
   0x41047a60,
   0xdf60efc3,
   0xa867df55,
   0x316e8eef,
   0x4669be79,
   0xcb61b38c,
   0xbc66831a,
   0x256fd2a0,
   0x5268e236,
   0xcc0c7795,
   0xbb0b4703,
   0x220216b9,
   0x5505262f,
   0xc5ba3bbe,
   0xb2bd0b28,
   0x2bb45a92,
   0x5cb36a04,
   0xc2d7ffa7,
   0xb5d0cf31,
   0x2cd99e8b,
   0x5bdeae1d,
   0x9b64c2b0,
   0xec63f226,
   0x756aa39c,
   0x26d930a,
   0x9c0906a9,
   0xeb0e363f,
   0x72076785,
   0x5005713,
   0x95bf4a82,
   0xe2b87a14,
   0x7bb12bae,
   0xcb61b38,
   0x92d28e9b,
   0xe5d5be0d,
   0x7cdcefb7,
   0xbdbdf21,
   0x86d3d2d4,
   0xf1d4e242,
   0x68ddb3f8,
   0x1fda836e,
   0x81be16cd,
   0xf6b9265b,
   0x6fb077e1,
   0x18b74777,
   0x88085ae6,
   0xff0f6a70,
   0x66063bca,
   0x11010b5c,
   0x8f659eff,
   0xf862ae69,
   0x616bffd3,
   0x166ccf45,
   0xa00ae278,
   0xd70dd2ee,
   0x4e048354,
   0x3903b3c2,
   0xa7672661,
   0xd06016f7,
   0x4969474d,
   0x3e6e77db,
   0xaed16a4a,
   0xd9d65adc,
   0x40df0b66,
   0x37d83bf0,
   0xa9bcae53,
   0xdebb9ec5,
   0x47b2cf7f,
   0x30b5ffe9,
   0xbdbdf21c,
   0xcabac28a,
   0x53b39330,
   0x24b4a3a6,
   0xbad03605,
   0xcdd70693,
   0x54de5729,
   0x23d967bf,
   0xb3667a2e,
   0xc4614ab8,
   0x5d681b02,
   0x2a6f2b94,
   0xb40bbe37,
   0xc30c8ea1,
   0x5a05df1b,
   0x2d02ef8d
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\pngfilt\cpngfilt.cpp ===
#include "stdafx.h"
#include "pngfilt.h"
#include "resource.h"
#include "cpngfilt.h"
#include "scanline.h"
#include <math.h>

#include "pngcrc.cpp"

#undef  DEFINE_GUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }

DEFINE_GUID( IID_IDirectDrawSurface,        0x6C14DB81,0xA733,0x11CE,0xA5,0x21,0x00,
0x20,0xAF,0x0B,0xE5,0x60 );

#ifdef _DEBUG
static ULONG g_nPNGTraceLevel = 1;
static void _cdecl FakeTrace( LPCTSTR pszFormat, ... )
{
   (void)pszFormat;
}

#define PNGTRACE1(PARAMS) ((g_nPNGTraceLevel >= 1) ? AtlTrace##PARAMS : FakeTrace##PARAMS)
#define PNGTRACE(PARAMS) ATLTRACE##PARAMS
#else
#define PNGTRACE1(PARAMS) ATLTRACE##PARAMS
#define PNGTRACE(PARAMS) ATLTRACE##PARAMS
#endif

// Gamma correction table for sRGB, assuming a file gamma of 1.0

#define VIEWING_GAMMA   1.125
#define DISPLAY_GAMMA   2.2

#define MAXFBVAL    255

BYTE gamma10[256] = {
      0, 15, 21, 26, 30, 34, 37, 41, 43, 46, 49, 51, 53, 56, 58, 60,
     62, 64, 66, 68, 69, 71, 73, 75, 76, 78, 79, 81, 82, 84, 85, 87,
     88, 90, 91, 92, 94, 95, 96, 98, 99,100,101,103,104,105,106,107,
    109,110,111,112,113,114,115,116,117,119,120,121,122,123,124,125,
    126,127,128,129,130,131,132,133,134,135,135,136,137,138,139,140,
    141,142,143,144,145,145,146,147,148,149,150,151,151,152,153,154,
    155,156,156,157,158,159,160,160,161,162,163,164,164,165,166,167,
    167,168,169,170,170,171,172,173,173,174,175,176,176,177,178,179,
    179,180,181,181,182,183,184,184,185,186,186,187,188,188,189,190,
    190,191,192,192,193,194,194,195,196,196,197,198,198,199,200,200,
    201,202,202,203,203,204,205,205,206,207,207,208,208,209,210,210,
    211,212,212,213,213,214,215,215,216,216,217,218,218,219,219,220,
    221,221,222,222,223,223,224,225,225,226,226,227,228,228,229,229,
    230,230,231,231,232,233,233,234,234,235,235,236,236,237,238,238,
    239,239,240,240,241,241,242,242,243,244,244,245,245,246,246,247,
    247,248,248,249,249,250,250,251,251,252,252,253,253,254,254,255,
};

#ifdef BIG_ENDIAN
#define my_ntohl(x) (x)
inline DWORD endianConverter( DWORD dwSrc )
{
   return( ((dwSrc&0xff)<<24)+((dwSrc&0xff00)<<8)+((dwSrc&0xff0000)>>8)+
      ((dwSrc&0xff000000)>>24) );
}
#else
inline DWORD my_ntohl( DWORD dwSrc )
{
   return( ((dwSrc&0xff)<<24)+((dwSrc&0xff00)<<8)+((dwSrc&0xff0000)>>8)+
      ((dwSrc&0xff000000)>>24) );
}
#endif

void FixByteOrder( PNGCHUNKHEADER* pChunkHeader )
{
   pChunkHeader->nDataLength = my_ntohl( pChunkHeader->nDataLength );
}

void FixByteOrder( PNGIHDRDATA* pIHDR )
{
   pIHDR->nWidth = my_ntohl( pIHDR->nWidth );
   pIHDR->nHeight = my_ntohl( pIHDR->nHeight );
}

void CopyPaletteEntriesFromColors(PALETTEENTRY *ppe, const RGBQUAD *prgb,
    UINT uCount)
{
    while (uCount--)
    {
        ppe->peRed   = prgb->rgbRed;
        ppe->peGreen = prgb->rgbGreen;
        ppe->peBlue  = prgb->rgbBlue;
        ppe->peFlags = 0;

        prgb++;
        ppe++;
    }
}

/////////////////////////////////////////////////////////////////////////////
//

CPNGFilter::CPNGFilter() :
   m_eInternalState( ISTATE_READFILEHEADER ),
   m_nBytesLeftInCurrentTask( 0 ),
   m_nDataBytesRead( 0 ),
   m_iAppend( 0 ),
   m_pStream( NULL ),
   m_bFinishedIDAT( FALSE ),
   m_nBytesInScanLine( 0 ),
   m_iScanLine( 0 ),
   m_iFirstStaleScanLine( 0 ),
   m_bExpandPixels( FALSE ),
   m_pbScanLine( NULL ),
   m_pbPrevScanLine( NULL ),
   m_pfnCopyScanLine( NULL ),
   m_dwChunksEncountered( 0 ),
   m_iBackgroundIndex( 0 ),
   m_bSurfaceUsesAlpha( FALSE ),
   m_bConvertAlpha( FALSE ),
   m_nFormats( 0 ),
   m_pFormats( NULL ),
   m_nTransparentColors( 0 )
{
   m_rgbBackground.rgbRed = 0;
   m_rgbBackground.rgbGreen = 0;
   m_rgbBackground.rgbBlue = 0;
   m_rgbBackground.rgbReserved = 0;

    for (int i = 0; i < 256; ++i)
        m_abTrans[i] = (BYTE)i;

    memcpy(m_abGamma, m_abTrans, sizeof(m_abTrans));
}

CPNGFilter::~CPNGFilter()
{
   if( m_pFormats != NULL )
   {
      CoTaskMemFree( m_pFormats );
   }
   delete m_pbPrevScanLine;
   delete m_pbScanLine;
}

const PNGCOPYSCANLINEPROC g_apfnCopyScanLineGray1[1] =
{
   CopyScanLineGray1ToBGR24
};

const PNGCOPYSCANLINEPROC g_apfnCopyScanLineGray2[1] =
{
   CopyScanLineGray2ToBGR24
};

const PNGCOPYSCANLINEPROC g_apfnCopyScanLineGray4[1] =
{
   CopyScanLineGray4ToBGR24
};

const PNGCOPYSCANLINEPROC g_apfnCopyScanLineGray8[1] =
{
   CopyScanLineGray8ToBGR24
};

const PNGCOPYSCANLINEPROC g_apfnCopyScanLineGray16[1] =
{
   CopyScanLineGray16ToBGR24
};

const PNGCOPYSCANLINEPROC g_apfnCopyScanLineRGB24[1] =
{
   CopyScanLineRGB24ToBGR24
};

const PNGCOPYSCANLINEPROC g_apfnCopyScanLineRGB48[1] =
{
   CopyScanLineRGB48ToBGR24
};

const PNGCOPYSCANLINEPROC g_apfnCopyScanLineIndex1[1] =
{
   CopyScanLineIndex1ToIndex8
};

const PNGCOPYSCANLINEPROC g_apfnCopyScanLineIndex2[1] =
{
   CopyScanLineIndex2ToIndex8
};

const PNGCOPYSCANLINEPROC g_apfnCopyScanLineIndex4[1] =
{
   CopyScanLineIndex4ToIndex8
};

const PNGCOPYSCANLINEPROC g_apfnCopyScanLineIndex8[1] =
{
   CopyScanLineIndex8ToIndex8
};

const PNGCOPYSCANLINEPROC g_apfnCopyScanLineGrayA16[2] =
{
   CopyScanLineGrayA16ToBGRA32,
   CopyScanLineGrayA16ToBGR24
};

const PNGCOPYSCANLINEPROC g_apfnCopyScanLineGrayA32[2] =
{
   CopyScanLineGrayA32ToBGRA32,
   CopyScanLineGrayA32ToBGR24
};

const PNGCOPYSCANLINEPROC g_apfnCopyScanLineRGBA32[2] =
{
   CopyScanLineRGBA32ToBGRA32,
   CopyScanLineRGBA32ToBGR24
};

const PNGCOPYSCANLINEPROC g_apfnCopyScanLineRGBA64[2] =
{
   CopyScanLineRGBA64ToBGRA32,
   CopyScanLineRGBA64ToBGR24
};

const PNGDUPLICATESCANLINEPROC g_apfnDuplicateScanLineBGR24[1] =
{
    DuplicateScanLineBGR24
};

const PNGDUPLICATESCANLINEPROC g_apfnDuplicateScanLineIndex8[1] =
{
    DuplicateScanLineIndex8
};

const PNGDUPLICATESCANLINEPROC g_apfnDuplicateScanLineAlphaSrc[2] =
{
    DuplicateScanLineARGB32,
    DuplicateScanLineBGR24
};

const GUID g_TargetGuidsForAlphaSrcs[2] =
{
    // BFID_RGBA_32
    { 0x773c9ac0, 0x3274, 0x11d0, { 0xb7, 0x24, 0x00, 0xaa, 0x00, 0x6c, 0x1a, 0x1 } },
    // BFID_RGB_24
    { 0xe436eb7d, 0x524f, 0x11ce, { 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70 } }
};

const PNG_FORMAT_INFO CPNGFilter::s_aFormatInfo[15] =
{
   { 1, &BFID_RGB_24, g_apfnCopyScanLineGray1, g_apfnDuplicateScanLineBGR24 },
   { 1, &BFID_RGB_24, g_apfnCopyScanLineGray2, g_apfnDuplicateScanLineBGR24 },
   { 1, &BFID_RGB_24, g_apfnCopyScanLineGray4, g_apfnDuplicateScanLineBGR24 },
   { 1, &BFID_RGB_24, g_apfnCopyScanLineGray8, g_apfnDuplicateScanLineBGR24 },
   { 1, &BFID_RGB_24, g_apfnCopyScanLineGray16, g_apfnDuplicateScanLineBGR24 },
   { 1, &BFID_RGB_24, g_apfnCopyScanLineRGB24, g_apfnDuplicateScanLineBGR24 },
   { 1, &BFID_RGB_24, g_apfnCopyScanLineRGB48, g_apfnDuplicateScanLineBGR24 },
   { 1, &BFID_INDEXED_RGB_8, g_apfnCopyScanLineIndex1, g_apfnDuplicateScanLineIndex8 },
   { 1, &BFID_INDEXED_RGB_8, g_apfnCopyScanLineIndex2, g_apfnDuplicateScanLineIndex8 },
   { 1, &BFID_INDEXED_RGB_8, g_apfnCopyScanLineIndex4, g_apfnDuplicateScanLineIndex8 },
   { 1, &BFID_INDEXED_RGB_8, g_apfnCopyScanLineIndex8, g_apfnDuplicateScanLineIndex8 },
   { 2, g_TargetGuidsForAlphaSrcs, g_apfnCopyScanLineGrayA16, g_apfnDuplicateScanLineAlphaSrc },
   { 2, g_TargetGuidsForAlphaSrcs, g_apfnCopyScanLineGrayA32, g_apfnDuplicateScanLineAlphaSrc },
   { 2, g_TargetGuidsForAlphaSrcs, g_apfnCopyScanLineRGBA32, g_apfnDuplicateScanLineAlphaSrc },
   { 2, g_TargetGuidsForAlphaSrcs, g_apfnCopyScanLineRGBA64, g_apfnDuplicateScanLineAlphaSrc }
};

HRESULT CPNGFilter::ChooseDestinationFormat( GUID* pBFID )
{
   ULONG iPossibleFormat;
   ULONG iAcceptableFormat;
   const PNG_FORMAT_INFO* pFormatInfo;
   BOOL bFound;
   ULONG iChosenFormat;

   _ASSERTE( pBFID != NULL );

   *pBFID = GUID_NULL;

   pFormatInfo = &s_aFormatInfo[m_eSrcFormat];

   bFound = FALSE;
   iChosenFormat = 0;
   for( iAcceptableFormat = 0; (iAcceptableFormat < m_nFormats) && !bFound;
      iAcceptableFormat++ )
   {
      for( iPossibleFormat = 0; iPossibleFormat <
         pFormatInfo->nPossibleFormats; iPossibleFormat++ )
      {
         if( IsEqualGUID(m_pFormats[iAcceptableFormat],
             pFormatInfo->pPossibleFormats[iPossibleFormat] ) )
         {
            iChosenFormat = iPossibleFormat;
            bFound = TRUE;
         }
      }
   }
   if( !bFound )
   {
      return( E_FAIL );
   }

   m_pfnCopyScanLine = pFormatInfo->ppfnCopyScanLineProcs[iChosenFormat];
   m_pfnDuplicateScanLine = pFormatInfo->ppfnDuplicateScanLineProcs[iChosenFormat];
   *pBFID = pFormatInfo->pPossibleFormats[iChosenFormat];

   return( S_OK );
}

HRESULT CPNGFilter::LockBits(RECT *prcBounds, DWORD dwLockFlags, void **ppBits, long *pPitch)
{
    HRESULT hResult;
    DDSURFACEDESC   ddsd;

    (dwLockFlags);

    ddsd.dwSize = sizeof(ddsd);
    hResult = m_pDDrawSurface->Lock(prcBounds, &ddsd, DDLOCK_WAIT | DDLOCK_SURFACEMEMORYPTR, NULL);
    if (FAILED(hResult))
        return hResult;

    *ppBits = ddsd.lpSurface;
    *pPitch = ddsd.lPitch;

    return S_OK;
}

HRESULT CPNGFilter::UnlockBits(RECT *prcBounds, void *pBits)
{
    (prcBounds);

    return m_pDDrawSurface->Unlock(pBits);
}


HRESULT CPNGFilter::FireGetSurfaceEvent()
{
    HRESULT hResult;
    GUID bfid;
    CComPtr < IUnknown > pSurface;

    _ASSERTE( m_pEventSink != NULL );
    _ASSERTE( m_pDDrawSurface == NULL );

    m_bConvertAlpha = FALSE;
    m_bSurfaceUsesAlpha = FALSE;

    hResult = ChooseDestinationFormat(&bfid);
    if (FAILED(hResult))
    {
        return(hResult);
    }

    hResult = m_pEventSink->GetSurface(m_pngIHDR.nWidth, m_pngIHDR.nHeight,
        bfid, m_nPasses, IMGDECODE_HINT_TOPDOWN|IMGDECODE_HINT_FULLWIDTH,
        &pSurface);
    if (FAILED(hResult))
    {
        return( hResult);
    }

    hResult = pSurface->QueryInterface(IID_IDirectDrawSurface, (void **)&m_pDDrawSurface);

    if (FAILED(hResult))
        return(hResult);

    return (S_OK);
}

// Send an OnProgress event to the event sink (if it has requested progress
// notifications).
HRESULT CPNGFilter::FireOnProgressEvent()
{
   HRESULT hResult;
   RECT rect;

   if( !(m_dwEvents & IMGDECODE_EVENT_PROGRESS) )
   {
      return( S_OK );
   }

   PNGTRACE1((_T("Pass: %d\n"), m_iPass ));

   rect.left = 0;
   rect.top = m_iFirstStaleScanLine;
   rect.right = m_pngIHDR.nWidth;
   rect.bottom = min( m_iScanLine, m_pngIHDR.nHeight );
   hResult = m_pEventSink->OnProgress( &rect, TRUE );
   if( FAILED( hResult ) )
   {
      return( hResult );
   }

   m_iFirstStaleScanLine = m_iScanLine;

   return( S_OK );
}


///////////////////////////////////////////////////////////////////////////////
// PNG scan line filtering routines

void CPNGFilter::NoneFilterScanLine()
{
}

void CPNGFilter::SubFilterScanLine()
{
   BYTE* pbByte;
   ULONG iByte;
   ULONG nSrcByte;

   pbByte = m_pbScanLine+1+m_nBPP;
   for( iByte = m_nBPP; iByte < m_nBytesInScanLine; iByte++ )
   {
      nSrcByte = *pbByte;
      nSrcByte += *(pbByte-m_nBPP);
      *pbByte = BYTE( nSrcByte );
      pbByte++;
   }
}

void CPNGFilter::UpFilterScanLine()
{
   ULONG iByte;

   if( m_iScanLineInPass == 0 )
   {
      // Unfiltering the top scan line is a NOP
      return;
   }

   for( iByte = 1; iByte <= m_nBytesInScanLine; iByte++ )
   {
      m_pbScanLine[iByte] = BYTE( m_pbScanLine[iByte]+
         m_pbPrevScanLine[iByte] );
   }
}

void CPNGFilter::AverageFilterScanLine()
{
   ULONG iByte;
   ULONG nSum;

   if( m_iScanLineInPass == 0 )
   {
      // No prior scan line.  Skip the first m_nBPP bytes, since they are not
      // affected by the filter
      for( iByte = m_nBPP+1; iByte <= m_nBytesInScanLine; iByte++ )
      {
         m_pbScanLine[iByte] = BYTE( m_pbScanLine[iByte]+
            (m_pbScanLine[iByte-m_nBPP]/2) );
      }
   }
   else
   {
      for( iByte = 1; iByte <= m_nBPP; iByte++ )
      {
         m_pbScanLine[iByte] = BYTE( m_pbScanLine[iByte]+
            (m_pbPrevScanLine[iByte]/2) );
      }
      for( ; iByte <= m_nBytesInScanLine; iByte++ )
      {
         nSum = m_pbScanLine[iByte-m_nBPP]+m_pbPrevScanLine[iByte];
         m_pbScanLine[iByte] = BYTE( m_pbScanLine[iByte]+(nSum/2) );
      }
   }
}

static inline int Abs( int n )
{
   if( n > 0 )
   {
      return( n );
   }
   else
   {
      return( -n );
   }
}

BYTE PaethPredictor( BYTE a, BYTE b, BYTE c )
{
   int p;
   int pa;
   int pb;
   int pc;

   p = int( a )+int( b )-int( c );
   pa = Abs( p-a );
   pb = Abs( p-b );
   pc = Abs( p-c );

   if( (pa <= pb) && (pa <= pc) )
   {
      return( a );
   }
   if( pb <= pc )
   {
      return( b );
   }
   return( c );
}

void CPNGFilter::PaethFilterScanLine()
{
   ULONG iByte;

   if( m_iScanLineInPass == 0 )
   {
      for( iByte = 1; iByte <= m_nBPP; iByte++ )
      {
         m_pbScanLine[iByte] = BYTE( m_pbScanLine[iByte]+PaethPredictor( 0, 0,
            0 ) );
      }
      for( ; iByte <= m_nBytesInScanLine; iByte++ )
      {
         m_pbScanLine[iByte] = BYTE( m_pbScanLine[iByte]+PaethPredictor(
            m_pbScanLine[iByte-m_nBPP], 0, 0 ) );
      }
   }
   else
   {
      for( iByte = 1; iByte <= m_nBPP; iByte++ )
      {
         m_pbScanLine[iByte] = BYTE( m_pbScanLine[iByte]+PaethPredictor( 0,
            m_pbPrevScanLine[iByte], 0 ) );
      }
      for( ; iByte <= m_nBytesInScanLine; iByte++ )
      {
         m_pbScanLine[iByte] = BYTE( m_pbScanLine[iByte]+PaethPredictor(
            m_pbScanLine[iByte-m_nBPP], m_pbPrevScanLine[iByte],
            m_pbPrevScanLine[iByte-m_nBPP] ) );
      }
   }
}

// Update a CRC accumulator with new data bytes
DWORD UpdateCRC( DWORD dwInitialCRC, const BYTE* pbData, ULONG nCount )
{
   DWORD dwCRC;
   ULONG iByte;

   dwCRC = dwInitialCRC;
   for( iByte = 0; iByte < nCount; iByte++ )
   {
      dwCRC = g_adwCRCTable[(dwCRC^pbData[iByte])&0xff]^(dwCRC>>8);
   }

   return( dwCRC );
}

HRESULT CPNGFilter::NextState()
{
   switch( m_eInternalState )
   {
   case ISTATE_READFILEHEADER:
      m_eInternalState = ISTATE_READCHUNKHEADER;
      break;

   case ISTATE_READCHUNKHEADER:
      if( m_pngChunkHeader.dwChunkType == PNG_CHUNK_IDAT )
      {
        if (!(m_dwChunksEncountered & CHUNK_BKGD))
            m_eInternalState = ISTATE_CHOOSEBKGD;
        else
            m_eInternalState = ISTATE_READIDATDATA;
      }
      else
      {
         m_eInternalState = ISTATE_READCHUNKDATA;
      }
      break;

    case ISTATE_CHOOSEBKGD:
        m_eInternalState = ISTATE_READIDATDATA;
        break;

   case ISTATE_READCHUNKDATA:
   
      if (m_bSkipData)
      {
         m_eInternalState = ISTATE_EATDATA;
      }
      else switch( m_pngChunkHeader.dwChunkType )
      {
      case PNG_CHUNK_BKGD:
         m_eInternalState = ISTATE_PROCESSBKGD;
         break;

      case PNG_CHUNK_IHDR:
         m_eInternalState = ISTATE_PROCESSIHDR;
         break;

      case PNG_CHUNK_TRNS:
         m_eInternalState = ISTATE_PROCESSTRNS;
         break;

      case PNG_CHUNK_GAMA:
         m_eInternalState = ISTATE_PROCESSGAMA;
         break;

      case PNG_CHUNK_PLTE:
         m_eInternalState = ISTATE_PROCESSPLTE;
         break;

      case PNG_CHUNK_IEND:
         m_eInternalState = ISTATE_PROCESSIEND;
         break;

      case PNG_CHUNK_IDAT:
         _ASSERT( FALSE );
         // fallthrough
         
      default:
         m_eInternalState = ISTATE_EATDATA;
         break;
      }

      break;

   case ISTATE_PROCESSBKGD:
      m_eInternalState = ISTATE_READCHUNKCRC;
      break;

   case ISTATE_PROCESSIHDR:
      m_eInternalState = ISTATE_READCHUNKCRC;
      break;

   case ISTATE_PROCESSIEND:
      m_eInternalState = ISTATE_READCHUNKCRC;
      break;

   case ISTATE_EATDATA:
      if( m_nDataBytesRead != m_pngChunkHeader.nDataLength )
      {
         m_eInternalState = ISTATE_READCHUNKDATA;
      }
      else
      {
         m_eInternalState = ISTATE_READCHUNKCRC;
      }
      break;

   case ISTATE_READCHUNKCRC:
      if( m_dwChunksEncountered & CHUNK_IEND )
      {
         m_eInternalState = ISTATE_DONE;
      }
      else
      {
         m_eInternalState = ISTATE_READCHUNKHEADER;
      }
      break;

   case ISTATE_READIDATDATA:
      if( m_nDataBytesRead < m_pngChunkHeader.nDataLength )
      {
         m_eInternalState = ISTATE_READIDATDATA;
      }
      else
      {
         _ASSERTE( m_nDataBytesRead == m_pngChunkHeader.nDataLength );
         m_eInternalState = ISTATE_READCHUNKCRC;
      }
      break;

   case ISTATE_PROCESSPLTE:
      m_eInternalState = ISTATE_READCHUNKCRC;
      break;

    case ISTATE_PROCESSTRNS:
        m_eInternalState = ISTATE_READCHUNKCRC;
        break;

    case ISTATE_PROCESSGAMA:
        m_eInternalState = ISTATE_READCHUNKCRC;
        break;

   case ISTATE_DONE:
      m_eInternalState = ISTATE_DONE;
      break;

   default:
      PNGTRACE((_T("Unknown state\n")));
      _ASSERT( FALSE );
      break;
   }

   m_nBytesLeftInCurrentTask = 0;

   return( S_OK );
}

// Process a PNG background color chunk.
HRESULT CPNGFilter::ProcessBKGD()
{
   if( !(m_dwChunksEncountered & CHUNK_IHDR) )
   {
      PNGTRACE((_T("Missing IHDR\n")));
      return( E_FAIL );
   }
   if( m_dwChunksEncountered & CHUNK_BKGD )
   {
      PNGTRACE((_T("Multiple bKGD chunks\n")));
      return( E_FAIL );
   }
   if( m_dwChunksEncountered & (CHUNK_IDAT|CHUNK_IEND) )
   {
      PNGTRACE((_T("Invalid bKGD placement\n")));
      return( E_FAIL );
   }
   if( m_bPalette && !(m_dwChunksEncountered & CHUNK_PLTE) )
   {
      PNGTRACE((_T("bKGD before PLTE in indexed-color image\n")));
      return( E_FAIL );
   }

   m_dwChunksEncountered |= (CHUNK_BKGD|CHUNK_POSTPLTE);

   switch( m_pngIHDR.bColorType )
   {
   case PNG_COLORTYPE_INDEXED:
      if( m_pngChunkHeader.nDataLength != 1 )
      {
         PNGTRACE((_T("Invalid bKGD size\n")));
         return( E_FAIL );
      }
      m_iBackgroundIndex = m_abData[0];
      if( m_iBackgroundIndex >= m_nColors )
      {
         PNGTRACE((_T("Invalid palette index in bKGD\n")));
         return( E_FAIL );
      }
      break;

   case PNG_COLORTYPE_RGB:
   case PNG_COLORTYPE_RGBA:
      if( m_pngChunkHeader.nDataLength != 6 )
      {
         PNGTRACE((_T("Invalid bKGD size\n")));
         return( E_FAIL );
      }
      if( m_pngIHDR.nBitDepth == 8 )
      {
         m_frgbBackground.fRed = float( m_abData[1]/255.0 );
         m_frgbBackground.fGreen = float( m_abData[3]/255.0 );
         m_frgbBackground.fBlue = float( m_abData[5]/255.0 );
      }
      else
      {
         m_frgbBackground.fRed = float( ((m_abData[0]<<8)+m_abData[1] )/
            65535.0 );
         m_frgbBackground.fGreen = float( ((m_abData[2]<<8)+m_abData[3] )/
            65535.0 );
         m_frgbBackground.fBlue = float( ((m_abData[4]<<8)+m_abData[5] )/
            65535.0 );
      }
      break;

   case PNG_COLORTYPE_GRAY:
   case PNG_COLORTYPE_GRAYA:
      if( m_pngChunkHeader.nDataLength != 2 )
      {
         PNGTRACE((_T("Invalid bKGD size\n")));
         return( E_FAIL );
      }
      m_frgbBackground.fRed = float( ((m_abData[0]<<8)+m_abData[1])&
         ((0x01<<m_pngIHDR.nBitDepth)-1) );
      m_frgbBackground.fRed /= float( (0x01<<m_pngIHDR.nBitDepth)-1 );
      m_frgbBackground.fGreen = m_frgbBackground.fRed;
      m_frgbBackground.fBlue = m_frgbBackground.fRed;
      break;

   default:
      _ASSERT( FALSE );
      break;
   }

   m_rgbBackground.rgbRed = BYTE( m_frgbBackground.fRed*255.0 );
   m_rgbBackground.rgbGreen = BYTE( m_frgbBackground.fGreen*255.0 );
   m_rgbBackground.rgbBlue = BYTE( m_frgbBackground.fBlue*255.0 );
   m_rgbBackground.rgbReserved = 0;

   return( S_OK );
}

HRESULT CPNGFilter::ChooseBKGD()
{
   if( !(m_dwChunksEncountered & CHUNK_IHDR) )
   {
      PNGTRACE((_T("Missing IHDR\n")));
      return( E_FAIL );
   }

   if( m_dwChunksEncountered & CHUNK_BKGD )
   {
      PNGTRACE((_T("Multiple bKGD chunks\n")));
      return( E_FAIL );
   }

   m_dwChunksEncountered |= (CHUNK_BKGD|CHUNK_POSTPLTE);

    // Since the image doesn't specify a background color we have to
    // choose one.  Since the image target isn't known we'll use the
    // button face color for lack of anything better...

    *((DWORD *)&m_rgbBackground) = (GetSysColor(COLOR_BTNFACE) & 0x00FFFFFF);
    m_frgbBackground.fRed = float( m_rgbBackground.rgbRed/255.0 );
    m_frgbBackground.fGreen = float( m_rgbBackground.rgbGreen/255.0 );
    m_frgbBackground.fBlue = float( m_rgbBackground.rgbBlue/255.0 );

   return S_OK;
}

// Get ready to read the image data
HRESULT CPNGFilter::BeginImage()
{
    LPDIRECTDRAWPALETTE pDDPalette;
    PALETTEENTRY        ape[256];
    HRESULT hResult;
    BYTE *pby;
    int i;

    // Nothing to do if there's no palette
    if (!m_bPalette)
        return S_OK;

    if (!(m_dwChunksEncountered & CHUNK_PLTE))
    {
        PNGTRACE((_T("No PLTE chunk found for indexed color image\n")));
        return (E_FAIL);
    }


    // TRICK: This applies gamma to the rgbReserved field as well
    //        but this field is always 0, and gamma correction of
    //        0 is always 0, so this safe.
    pby = (BYTE *)m_argbColors;
    for (i = m_nColors * 4; i ; --i, ++pby)
        *pby = m_abGamma[*pby];

    hResult = m_pDDrawSurface->GetPalette(&pDDPalette);
    if (SUCCEEDED(hResult))
    {
        CopyPaletteEntriesFromColors(ape, m_argbColors, m_nColors);
        pDDPalette->SetEntries(0, 0, m_nColors, ape);
        pDDPalette->Release();
    }
        
    if (m_dwEvents & IMGDECODE_EVENT_PALETTE)
    {
        hResult = m_pEventSink->OnPalette();
        if (FAILED(hResult))
        {
            return (hResult);
        }
    }

   return (S_OK);
}

// Process the PNG end-of-stream chunk
HRESULT CPNGFilter::ProcessIEND()
{
   if( !(m_dwChunksEncountered & CHUNK_LASTIDAT) )
   {
      PNGTRACE((_T("Invalid IEND placement\n")));
      return( E_FAIL );
   }

   m_dwChunksEncountered |= CHUNK_IEND;

   if( m_pngChunkHeader.nDataLength > 0 )
   {
      PNGTRACE((_T("Invalid IEND chunk length\n")));
      return( E_FAIL );
   }

   return( S_OK );
}

HRESULT CPNGFilter::DetermineSourceFormat()
{
   switch( m_pngIHDR.bColorType )
   {
   case PNG_COLORTYPE_RGB:
      switch( m_pngIHDR.nBitDepth )
      {
      case 8:
         m_eSrcFormat = SRC_RGB_24;
         break;

      case 16:
         m_eSrcFormat = SRC_RGB_48;
         break;

      default:
         PNGTRACE((_T("Invalid bit depth %d for RGB image\n"), 
            m_pngIHDR.nBitDepth ));
         return( E_FAIL );
         break;
      }
      m_nBitsPerPixel = m_pngIHDR.nBitDepth*3;
      break;

   case PNG_COLORTYPE_RGBA:
      switch( m_pngIHDR.nBitDepth )
      {
      case 8:
         m_eSrcFormat = SRC_RGBA_32;
         break;

      case 16:
         m_eSrcFormat = SRC_RGBA_64;
         break;

      default:
         PNGTRACE((_T("Invalid bit depth %d for RGBA image\n"), 
            m_pngIHDR.nBitDepth ));
         return( E_FAIL );
         break;
      }
      m_nBitsPerPixel = m_pngIHDR.nBitDepth*4;
      break;

   case PNG_COLORTYPE_INDEXED:
      switch( m_pngIHDR.nBitDepth )
      {
      case 1:
         m_eSrcFormat = SRC_INDEXED_RGB_1;
         break;

      case 2:
         m_eSrcFormat = SRC_INDEXED_RGB_2;
         break;

      case 4:
         m_eSrcFormat = SRC_INDEXED_RGB_4;
         break;

      case 8:
         m_eSrcFormat = SRC_INDEXED_RGB_8;
         break;

      default:
         PNGTRACE((_T("Invalid bit depth %d for indexed-color image\n"),
            m_pngIHDR.nBitDepth ));
         return( E_FAIL );
         break;
      }
      m_nBitsPerPixel = m_pngIHDR.nBitDepth;
      break;

   case PNG_COLORTYPE_GRAY:
      switch( m_pngIHDR.nBitDepth )
      {
      case 1:
         m_eSrcFormat = SRC_GRAY_1;
         break;

      case 2:
         m_eSrcFormat = SRC_GRAY_2;
         break;

      case 4:
         m_eSrcFormat = SRC_GRAY_4;
         break;

      case 8:
         m_eSrcFormat = SRC_GRAY_8;
         break;

      case 16:
         m_eSrcFormat = SRC_GRAY_16;
         break;

      default:
         PNGTRACE((_T("Invalid bit depth %d for grayscale image\n"),
            m_pngIHDR.nBitDepth ));
         return( E_FAIL );
         break;
      }
      m_nBitsPerPixel = m_pngIHDR.nBitDepth;
      break;

   case PNG_COLORTYPE_GRAYA:
      switch( m_pngIHDR.nBitDepth )
      {
      case 8:
         m_eSrcFormat = SRC_GRAYA_16;
         break;

      case 16:
         m_eSrcFormat = SRC_GRAYA_32;
         break;

      default:
         PNGTRACE((_T("Invalid bit depth %d for grayscale/alpha image\n"),
            m_pngIHDR.nBitDepth ));
         return( E_FAIL );
         break;
      }
      m_nBitsPerPixel = m_pngIHDR.nBitDepth*2;
      break;

   default:
      PNGTRACE((_T("Invalid color type %d\n"), m_pngIHDR.bColorType ));
      return( E_FAIL );
      break;
   }

   return( S_OK );
}

// Process the PNG image header chunk
HRESULT CPNGFilter::ProcessIHDR()
{
   PNGIHDRDATA* pIHDR;
   HRESULT hResult;
   int nError;

   if( m_dwChunksEncountered != 0 )
   {
      PNGTRACE((_T("Multiple IHDR chunks\n")));
      return( E_FAIL );
   }

   m_dwChunksEncountered |= CHUNK_IHDR;

   pIHDR = (PNGIHDRDATA*)m_abData;
   FixByteOrder( pIHDR );
   memcpy( &m_pngIHDR, pIHDR, sizeof( m_pngIHDR ) );

   PNGTRACE1((_T("%dx%dx%d\n"), m_pngIHDR.nWidth, m_pngIHDR.nHeight, 
      m_pngIHDR.nBitDepth ));

   if( (m_pngIHDR.nWidth == 0) || (m_pngIHDR.nHeight == 0) )
   {
      PNGTRACE((_T("Invalid image size\n")));
      return( E_FAIL );
   }

   m_bPalette = m_pngIHDR.bColorType & PNG_COLORTYPE_PALETTE_MASK;
   m_bColor = m_pngIHDR.bColorType & PNG_COLORTYPE_COLOR_MASK;
   m_bAlpha = m_pngIHDR.bColorType & PNG_COLORTYPE_ALPHA_MASK;

   hResult = DetermineSourceFormat();
   if( FAILED( hResult ) )
   {
      return( hResult );
   }
   m_nBytesInScanLine = ((m_pngIHDR.nWidth*m_nBitsPerPixel)+7)/8;
   m_nBPP = max( 1, m_nBytesInScanLine/m_pngIHDR.nWidth );

   m_pbPrevScanLine = new BYTE[m_nBytesInScanLine+1];
   if( m_pbPrevScanLine == NULL )
   {
      return( E_OUTOFMEMORY );
   }
   m_pbScanLine = new BYTE[m_nBytesInScanLine+1];
   if( m_pbScanLine == NULL )
   {
      return( E_OUTOFMEMORY );
   }

   switch( m_pngIHDR.bCompressionMethod )
   {
   case PNG_COMPRESSION_DEFLATE32K:
      m_zlibStream.zalloc = NULL;
      m_zlibStream.zfree = NULL;
      m_zlibStream.opaque = NULL;
      nError = inflateInit( &m_zlibStream );
      if( nError != Z_OK )
      {
         return( E_OUTOFMEMORY );
      }
      break;

   default:
      PNGTRACE((_T("Unknown compression method %x\n"),
         m_pngIHDR.bCompressionMethod ));
      return( E_FAIL );
      break;
   }
   if( m_pngIHDR.bFilterMethod != PNG_FILTER_ADAPTIVE )
   {
      PNGTRACE((_T("Unknown filter method %x\n"), m_pngIHDR.bFilterMethod ));
      return( E_FAIL );
   }

   switch( m_pngIHDR.bInterlaceMethod )
   {
   case PNG_INTERLACE_NONE:
      PNGTRACE1((_T("Image is not interlaced\n")));
      m_nPasses = 1;
      m_pInterlaceInfo = s_aInterlaceInfoNone;
      m_bExpandPixels = FALSE;
      break;

   case PNG_INTERLACE_ADAM7:
      PNGTRACE1((_T("Image is Adam7 interlaced\n")));
      m_nPasses = 7;
      m_pInterlaceInfo = s_aInterlaceInfoAdam7;
      if( m_dwEvents & IMGDECODE_EVENT_PROGRESS )
      {
         m_bExpandPixels = TRUE;
      }
      else
      {
         // Don't bother expanding the pixels if the event sink doesn't care
         // about progress messages.
         m_bExpandPixels = FALSE;
      }
      break;

   default:
      PNGTRACE((_T("Unknown interlace method %d\n"), m_pngIHDR.bInterlaceMethod ));
      return( E_FAIL );
      break;
   }
   m_iPass = 0;
   BeginPass( m_iPass );

   if( m_bPalette )
   {
      PNGTRACE1((_T("Palette used\n")));
   }
   if( m_bColor )
   {
      PNGTRACE1((_T("Color used\n")));
   }
   if( m_bAlpha )
   {
      PNGTRACE1((_T("Alpha channel used\n")));
   }

   hResult = FireGetSurfaceEvent();
   if( FAILED( hResult ) )
   {
      return( hResult );
   }

   m_iAppend = 0;

   return( S_OK );
}

HRESULT CPNGFilter::ProcessPLTE()
{
   ULONG iColor;
   ULONG iByte;

   if( !(m_dwChunksEncountered & CHUNK_IHDR) )
   {
      PNGTRACE((_T("Missing IHDR\n")));
      return( E_FAIL );
   }

   if( m_dwChunksEncountered & CHUNK_PLTE )
   {
      PNGTRACE((_T("Multiple PLTE chunks\n")));
      return( E_FAIL );
   }

   if( m_dwChunksEncountered & (CHUNK_POSTPLTE|CHUNK_IDAT|CHUNK_IEND) )
   {
      PNGTRACE((_T("Invalid PLTE placement\n")));
      return( E_FAIL );
   }

   if( !m_bColor )
   {
      PNGTRACE(( _T("Palettes not allowed for grayscale images - ignoring\n" )));
      return( S_OK );
   }

   m_dwChunksEncountered |= CHUNK_PLTE;

   if( m_pngChunkHeader.nDataLength == 0 )
   {
      return( E_FAIL );
   }
   if( m_bPalette )
   {
      // Image requires a palette
      if( m_pngChunkHeader.nDataLength > (1U<<m_pngIHDR.nBitDepth)*3 )
      {
         return( E_FAIL );
      }
   }
   else
   {
      if( m_pngChunkHeader.nDataLength > 256*3 )
      {
         return( E_FAIL );
      }
   }
   if( m_pngChunkHeader.nDataLength%3 != 0 )
   {
      return( E_FAIL );
   }

   m_nColors = m_pngChunkHeader.nDataLength/3;

   iByte = 0;
   for( iColor = 0; iColor < m_nColors; iColor++ )
   {
      m_argbColors[iColor].rgbRed = m_abData[iByte];
      m_argbColors[iColor].rgbGreen = m_abData[iByte+1];
      m_argbColors[iColor].rgbBlue = m_abData[iByte+2];
//      ATLTRACE( "Palette[%x] = (%x, %x, %x)\n", iColor, m_abData[iByte],
//         m_abData[iByte+1], m_abData[iByte+2] );
      iByte += 3;
   }

   m_iAppend = 0;

   return( S_OK );
}

HRESULT CPNGFilter::ProcessTRNS()
{
    WORD    *pw = (WORD *)m_abData;
    RGBQUAD trans;
    int     byShiftCnt;
    ULONG   i;
    HRESULT hResult;
    DDCOLORKEY  ddKey;

    // TRNS chunk must precede first IDAT chunk and must follow the
    // PLTE chunk (if any).
    if ((m_dwChunksEncountered & CHUNK_IDAT)
        || (m_bPalette && (~m_dwChunksEncountered & CHUNK_PLTE)))
    {
        PNGTRACE((_T("Invalid TRNS placement\n")));
        return (E_FAIL);
    }

    m_dwChunksEncountered |= CHUNK_TRNS;


    switch (m_pngIHDR.bColorType)
    {
        case PNG_COLORTYPE_RGB:
        case PNG_COLORTYPE_GRAY:
            // ISSUE: we really should preserve the full 16-bit values
            // for proper transparent calculation but our main client,
            // MSHTML, doesn't preserve the RGB values at 16-bit resolution
            // either so it doesn't matter.

            byShiftCnt = (m_eSrcFormat == SRC_RGB_48) ? 8 : 0;
            trans.rgbRed   = (BYTE)(my_ntohl(pw[0]) >> byShiftCnt);
            trans.rgbReserved = 0;

            if (m_pngIHDR.bColorType == PNG_COLORTYPE_GRAY)
            {
                trans.rgbGreen = trans.rgbBlue = trans.rgbRed;
            }
            else
            {
                trans.rgbGreen = (BYTE)(my_ntohl(pw[1]) >> byShiftCnt);
                trans.rgbBlue  = (BYTE)(my_ntohl(pw[2]) >> byShiftCnt);
            }

            m_nTransparentColors = 1;
            m_dwTransKey = *((DWORD *)&trans);
            break;

        case PNG_COLORTYPE_INDEXED:
            // Fill in m_abTrans.  Remember this is filled with
            // the identity map in the constructor...
            for (i = 0; i < m_pngChunkHeader.nDataLength; ++i)
            {
                if (m_abData[i] != 0xff)
                {
                    if (m_nTransparentColors++)
                    {
                        // collapse transparent index to first level seen
                        m_abTrans[i] = (BYTE)m_dwTransKey;
                    }
                    else
                    {
                        // first transparent index seen
                        m_dwTransKey = i;
                        m_abTrans[i] = (BYTE)i;
                    }
                }
            }
            break;

        default:
            PNGTRACE(( _T("Color type %d doesn't allow tRNS chunk\n"), m_pngIHDR.bColorType ));
            return E_FAIL;
    }

    // Tell the surface what the transparent index is


    ddKey.dwColorSpaceLowValue = m_dwTransKey;
    ddKey.dwColorSpaceHighValue = m_dwTransKey;
    hResult = m_pDDrawSurface->SetColorKey(DDCKEY_SRCBLT, &ddKey);

    return (S_OK);
}

HRESULT CPNGFilter::ProcessGAMA()
{
    double  gbright, gcvideo, file_gamma, max_sample, final_gamma;
    ULONG   ulGamma;
    int     i, iGamma;
    
    // GAMA chunk must precede first IDAT chunk
    if (m_dwChunksEncountered & CHUNK_IDAT)
    {
        PNGTRACE((_T("Invalid GAMA placement\n")));
        return (E_FAIL);
    }

    m_dwChunksEncountered |= CHUNK_GAMA;

    // Get the file gamma and compute table if it's not 1.0

    ulGamma = my_ntohl(*((ULONG *)m_abData));
    max_sample = 255;

    // use our precomputed table if possible

    if (ulGamma == 100000)
    {
        memcpy(m_abGamma, gamma10, sizeof(gamma10));
    }
    else
    {
        file_gamma = ulGamma / 100000.0;

        final_gamma = (VIEWING_GAMMA / (file_gamma * DISPLAY_GAMMA));

        for (i = 0; i < 256; ++i)
        {
            gbright = (double)i / max_sample;
            gcvideo = pow(gbright, final_gamma);
            iGamma = (int)(gcvideo * MAXFBVAL + 0.5);
            m_abGamma[i] = (iGamma > 255) ? (BYTE)255 : (BYTE)iGamma;
        }
    }

   return (S_OK);
}

HRESULT CPNGFilter::ReadChunkCRC()
{
   HRESULT hResult;
   ULONG nBytesRead;
   BYTE* pBuffer;

   if( m_nBytesLeftInCurrentTask == 0 )
   {
      m_nBytesLeftInCurrentTask = 4;
   }
   pBuffer = LPBYTE( &m_dwChunkCRC )+4-m_nBytesLeftInCurrentTask;
   hResult = m_pStream->Read( pBuffer, m_nBytesLeftInCurrentTask,
      &nBytesRead );
   m_nBytesLeftInCurrentTask -= nBytesRead;
   switch( hResult )
   {
   case S_OK:
      break;

   case S_FALSE:
      return( E_FAIL );
      break;

   default:
      return( hResult );
      break;
   }

   m_dwChunkCRC = my_ntohl( m_dwChunkCRC );

   if( m_dwChunkCRC != ~m_dwCRC )
   {
      PNGTRACE((_T("Bad CRC\n")));
      return( E_FAIL );
   }

   if( m_pngChunkHeader.dwChunkType == PNG_CHUNK_IEND )
   {
      PNGTRACE1((_T("Finished IEND chunk\n")));
   }

   return( S_OK );
}

HRESULT CPNGFilter::ReadChunkData()
{
   HRESULT hResult = S_OK;
   ULONG nBytesToRead;
   ULONG nBytesRead;
   BYTE* pBuffer;

   if( m_nBytesLeftInCurrentTask == 0 )
   {
      if( m_pngChunkHeader.nDataLength == 0 )
      {
         return( S_OK );
      }

      m_iAppend = 0;
      m_nDataBytesRead = 0;
      m_nBytesLeftInCurrentTask = m_pngChunkHeader.nDataLength;
   }

   if (m_nBytesLeftInCurrentTask > PNG_BUFFER_SIZE - m_iAppend)
   {
      // We should have already previously decided to skip too-long data
      _ASSERTE(m_bSkipData);
      m_bSkipData = TRUE;
   }

   while (m_nBytesLeftInCurrentTask && hResult == S_OK)
   {
      pBuffer = &m_abData[m_iAppend];
      
      _ASSERTE(!m_nBytesLeftInCurrentTask || m_iAppend < PNG_BUFFER_SIZE);
      
      nBytesToRead = min(PNG_BUFFER_SIZE - m_iAppend, m_nBytesLeftInCurrentTask);
      
      hResult = m_pStream->Read( pBuffer, nBytesToRead,
         &nBytesRead );
      m_nBytesLeftInCurrentTask -= nBytesRead;
      m_nDataBytesRead += nBytesRead;
      m_iAppend += nBytesRead;
      m_dwCRC = UpdateCRC( m_dwCRC, pBuffer, nBytesRead );
      
     // If we're just skipping data, reset starting point
     if (m_bSkipData)
        m_iAppend = 0;
   }
      
   switch( hResult )
   {
   case S_OK:
      break;

   case S_FALSE:
      return( E_FAIL );
      break;

   default:
      return( hResult );
      break;
   }

   return( S_OK );
}

const PNG_INTERLACE_INFO CPNGFilter::s_aInterlaceInfoNone[1] =
{
   {
      1, 1, 1, 1, 0, 0,
      { 0, 1, 2, 3, 4, 5, 6, 7 },
      { 0, 1, 2, 3, 4, 5, 6, 7 }
   }
};

const PNG_INTERLACE_INFO CPNGFilter::s_aInterlaceInfoAdam7[7] =
{
   {
      8, 8, 8, 8, 0, 0,
      { 0, 1, 1, 1, 1, 1, 1, 1 },
      { 0, 1, 1, 1, 1, 1, 1, 1 }
   },
   {
      8, 8, 4, 8, 4, 0,
      { 0, 0, 0, 0, 0, 1, 1, 1 },
      { 0, 1, 1, 1, 1, 1, 1, 1 }
   },
   {
      4, 8, 4, 4, 0, 4,
      { 0, 1, 1, 1, 1, 2, 2, 2 },
      { 0, 0, 0, 0, 0, 1, 1, 1 }
   },
   {
      4, 4, 2, 4, 2, 0,
      { 0, 0, 0, 1, 1, 1, 1, 2 },
      { 0, 1, 1, 1, 1, 2, 2, 2 }
   },
   {
      2, 4, 2, 2, 0, 2,
      { 0, 1, 1, 2, 2, 3, 3, 4 },
      { 0, 0, 0, 1, 1, 1, 1, 2 }
   },
   {
      2, 2, 1, 2, 1, 0,
      { 0, 0, 1, 1, 2, 2, 3, 3 },
      { 0, 1, 1, 2, 2, 3, 3, 4 }
   },
   {
      1, 2, 1, 1, 0, 1,
      { 0, 1, 2, 3, 4, 5, 6, 7 },
      { 0, 0, 1, 1, 2, 2, 3, 3 }
   }
};

BOOL CPNGFilter::BeginPass( ULONG iPass )
{
   const PNG_INTERLACE_INFO* pInfo;
   ULONG iRightEdgeOfLastPixel;

   _ASSERTE( iPass < m_nPasses );

   pInfo = &m_pInterlaceInfo[iPass];

   m_nDeltaX = pInfo->nDeltaX;
   m_nDeltaY = pInfo->nDeltaY;
   m_iFirstX = pInfo->iFirstX;
   m_iScanLine = pInfo->iFirstY;
   m_nPixelsInScanLine = ((m_pngIHDR.nWidth/8)*(8/m_nDeltaX))+
      pInfo->anPixelsInPartialBlock[m_pngIHDR.nWidth%8];
   m_nBytesInScanLine = (m_nBitsPerPixel*m_nPixelsInScanLine+7)/8;
   m_nScanLinesInPass = ((m_pngIHDR.nHeight/8)*(8/m_nDeltaY))+
      pInfo->anScanLinesInPartialBlock[m_pngIHDR.nHeight%8];
   m_iScanLineInPass = 0;
   m_iFirstStaleScanLine = 0;
   if( m_bExpandPixels )
   {
      m_nPixelWidth = pInfo->nPixelWidth;
      m_nPixelHeight = pInfo->nPixelHeight;
      iRightEdgeOfLastPixel = m_iFirstX+((m_nPixelsInScanLine-1)*m_nDeltaX)+
         m_nPixelWidth;
      if( iRightEdgeOfLastPixel > m_pngIHDR.nWidth )
      {
         // The last pixel in the scan line is a partial pixel
         m_nPartialPixelWidth = m_nPixelWidth-(iRightEdgeOfLastPixel-
            m_pngIHDR.nWidth);
         m_nFullPixelsInScanLine = m_nPixelsInScanLine-1;
      }
      else
      {
         m_nPartialPixelWidth = 0;
         m_nFullPixelsInScanLine = m_nPixelsInScanLine;
      }
   }
   else
   {
      m_nPixelWidth = 1;
      m_nPixelHeight = 1;
      m_nPartialPixelWidth = 0;
   }

   PNGTRACE1((_T("Pass %d.  %d pixels in scan line\n"), iPass, 
      m_nPixelsInScanLine ));

   m_zlibStream.next_out = m_pbScanLine;
   m_zlibStream.avail_out = m_nBytesInScanLine+1;
   if( (m_nPixelsInScanLine == 0) || (m_nScanLinesInPass == 0) )
   {
      return( TRUE );
   }

   return( FALSE );
}

HRESULT CPNGFilter::NextPass()
{
   BOOL bEmpty;

   bEmpty = FALSE;
   do
   {
      m_iPass++;
      if( m_iPass < m_nPasses )
      {
         bEmpty = BeginPass( m_iPass );
      }
   } while( (m_iPass < m_nPasses) && bEmpty );

   if( m_iPass >= m_nPasses )
   {
      return( S_FALSE );
   }

   return( S_OK );
}

HRESULT CPNGFilter::NextScanLine()
{
   HRESULT hResult;
   BYTE* pbTemp;

   _ASSERTE( m_zlibStream.avail_out == 0 );

   m_iScanLine += m_nDeltaY;
   m_iScanLineInPass++;
   if( m_iScanLineInPass >= m_nScanLinesInPass )
   {
      // We're done with this pass
      hResult = FireOnProgressEvent();
      if( FAILED( hResult ) )
      {
         return( hResult );
      }

      hResult = NextPass();

      return( hResult );
   }
   else if( ((m_iScanLine-m_iFirstStaleScanLine)/m_nDeltaY) >= 16 )
   {
      hResult = FireOnProgressEvent();
      if( FAILED( hResult ) )
      {
         return( hResult );
      }
   }

   pbTemp = m_pbScanLine;
   m_pbScanLine = m_pbPrevScanLine;
   m_pbPrevScanLine = pbTemp;

   m_zlibStream.avail_out = m_nBytesInScanLine+1;
   m_zlibStream.next_out = m_pbScanLine;

   return( S_OK );
}

HRESULT CPNGFilter::ReadIDATData()
{
   HRESULT hResult;
   ULONG nBytesToRead;
   ULONG nBytesRead;
   int nError;

   if( !(m_dwChunksEncountered & CHUNK_IHDR) )
   {
      PNGTRACE((_T("Missing IHDR\n")));
      return( E_FAIL );
   }

   if( m_dwChunksEncountered & CHUNK_LASTIDAT )
   {
      PNGTRACE((_T("Extra IDAT chunk\n")));
      return( E_FAIL );
   }

   if( !(m_dwChunksEncountered & CHUNK_IDAT) )
   {
      // This is the first IDAT chunk.  Initialize the surface.
      hResult = BeginImage();
      if( FAILED( hResult ) )
      {
         return( hResult );
      }
   }

   m_dwChunksEncountered |= CHUNK_IDAT;

   nBytesToRead = min( m_pngChunkHeader.nDataLength-m_nDataBytesRead,
      PNG_BUFFER_SIZE );

   hResult = m_pStream->Read( m_abData, nBytesToRead, &nBytesRead );
   m_nDataBytesRead += nBytesRead;
   m_dwCRC = UpdateCRC( m_dwCRC, m_abData, nBytesRead );
   switch( hResult )
   {
   case S_OK:
      break;

   case S_FALSE:
      return( E_FAIL );
      break;

   case E_PENDING:
      if( nBytesRead == 0 )
      {
         return( E_PENDING );
      }
      break;

   default:
      return( hResult );
      break;
   }

   m_zlibStream.next_in = m_abData;
   m_zlibStream.avail_in = nBytesRead;

   do
   {
      nError = inflate( &m_zlibStream, Z_PARTIAL_FLUSH );
      if( (nError == Z_OK) || (nError == Z_STREAM_END) )
      {
         if( m_zlibStream.avail_out == 0 )
         {
            switch( m_pbScanLine[0] )
            {
            case 0:
               NoneFilterScanLine();
               break;

            case 1:
               SubFilterScanLine();
               break;

            case 2:
               UpFilterScanLine();
               break;

            case 3:
               AverageFilterScanLine();
               break;

            case 4:
               PaethFilterScanLine();
               break;

            default:
               _ASSERT( FALSE );
               break;
            }
            hResult = WriteScanLine();
            if( FAILED( hResult ) )
            {
               return( hResult );
            }

            hResult = NextScanLine();
            if( FAILED( hResult ) )
            {
               return( hResult );
            }
         }
         else
         {
            _ASSERTE( m_zlibStream.avail_in == 0 );
         }
      }
      else
      {
         return( E_FAIL );
      }

      if( nError == Z_STREAM_END )
      {
         if( m_nDataBytesRead < m_pngChunkHeader.nDataLength )
         {
            PNGTRACE((_T("Extra IDAT data\n")));
            return( E_FAIL );
         }
         m_dwChunksEncountered |= CHUNK_LASTIDAT;
         m_bFinishedIDAT = TRUE;
         inflateEnd( &m_zlibStream );

         if( m_dwEvents & IMGDECODE_EVENT_BITSCOMPLETE )
         {
            hResult = m_pEventSink->OnBitsComplete();
            if( FAILED( hResult ) )
            {
               return( hResult );
            }
         }
      }
   } while( (nError == Z_OK) && (m_zlibStream.avail_in > 0) );

   return( S_OK );
}

HRESULT CPNGFilter::ReadChunkHeader()
{
   HRESULT hResult;
   ULONG nBytesRead;
   BYTE* pBuffer;

   if( m_nBytesLeftInCurrentTask == 0 )
   {
      m_nBytesLeftInCurrentTask = sizeof( m_pngChunkHeader );
   }

   pBuffer = LPBYTE( &m_pngChunkHeader )+sizeof( m_pngChunkHeader )-
      m_nBytesLeftInCurrentTask;
   hResult = m_pStream->Read( pBuffer, m_nBytesLeftInCurrentTask,
      &nBytesRead );
   m_nBytesLeftInCurrentTask -= nBytesRead;
   switch( hResult )
   {
   case S_OK:
      break;

   case S_FALSE:
      return( E_FAIL );
      break;

   default:
      return( hResult );
      break;
   }

   FixByteOrder( &m_pngChunkHeader );

   m_dwCRC = UpdateCRC( 0xffffffff, LPBYTE( &m_pngChunkHeader.dwChunkType ),
      sizeof( m_pngChunkHeader.dwChunkType ) );

   #ifdef BIG_ENDIAN
      m_pngChunkHeader.dwChunkType = endianConverter(m_pngChunkHeader.dwChunkType);
   #endif

   m_nDataBytesRead = 0;
   m_bSkipData = FALSE;

   PNGTRACE1((_T("Chunk type: %c%c%c%c\n"), m_pngChunkHeader.dwChunkType&0xff,
      (m_pngChunkHeader.dwChunkType>>8)&0xff,
      (m_pngChunkHeader.dwChunkType>>16)&0xff,
      (m_pngChunkHeader.dwChunkType>>24)&0xff ));
   PNGTRACE1((_T("Data length: %d\n"), m_pngChunkHeader.nDataLength ));

   if( !(m_pngChunkHeader.dwChunkType & PNG_CHUNK_ANCILLARY) )
   {
      switch( m_pngChunkHeader.dwChunkType )
      {
      case PNG_CHUNK_IHDR:
      case PNG_CHUNK_PLTE:
      case PNG_CHUNK_IEND:
      
         // If m_pngChunkHeader.nDataLength > 4096 on an critical non-IDAT chunk,
         // we can't decode it, so fail.
          
         if (m_pngChunkHeader.nDataLength > PNG_BUFFER_SIZE)
         {
            PNGTRACE((_T("Critical chunk too long\n")));
            return( E_FAIL );
         }
            
         break;
         
      case PNG_CHUNK_IDAT:
      
         break;

      default:
         PNGTRACE((_T("Unknown critical chunk\n")));
         return( E_FAIL );
         break;
      }
   }
   else
   {
      // If m_pngChunkHeader.nDataLength > 4096 on an ancillary chunk,
      // set a flag so we discard the data
      
      if (m_pngChunkHeader.nDataLength > PNG_BUFFER_SIZE)
      {
         PNGTRACE((_T("Discarding ancillary chunk that is too long\n")));
         m_bSkipData = TRUE;
      }
   }

   return( S_OK );
}

static const BYTE g_abPNGHeader[8] = { 137, 80, 78, 71, 13, 10, 26, 10 };

HRESULT CPNGFilter::ReadFileHeader()
{
   HRESULT hResult;
   ULONG nBytesRead;
   BYTE* pBuffer;

   if( m_nBytesLeftInCurrentTask == 0 )
   {
      m_nBytesLeftInCurrentTask = 8;
   }

   pBuffer = &m_abData[m_iAppend];
   hResult = m_pStream->Read( pBuffer, m_nBytesLeftInCurrentTask,
      &nBytesRead );
   m_nBytesLeftInCurrentTask -= nBytesRead;
   switch( hResult )
   {
   case S_OK:
      break;

   case S_FALSE:
      return( E_FAIL );
      break;

   default:
      return( hResult );
      break;
   }

   if( memcmp( m_abData, g_abPNGHeader, 8 ) == 0 )
   {
      PNGTRACE1((_T("File is a PNG image\n")));
   }
   else
   {
      PNGTRACE((_T("File is not a PNG image\n")));
      return( E_FAIL );
   }

   m_iAppend = 0;

   return( S_OK );
}

HRESULT CPNGFilter::EatData()
{
   m_iAppend = 0;

   return( S_OK );
}


///////////////////////////////////////////////////////////////////////////////
// IImageDecodeFilter methods
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPNGFilter::Initialize( IImageDecodeEventSink* pEventSink )
{
   HRESULT hResult;

   if( pEventSink == NULL )
   {
      return( E_INVALIDARG );
   }

   m_pEventSink = pEventSink;

   hResult = m_pEventSink->OnBeginDecode( &m_dwEvents, &m_nFormats,
      &m_pFormats );
   if( FAILED( hResult ) )
   {
      return( hResult );
   }

   return( S_OK );
}

STDMETHODIMP CPNGFilter::Process( IStream* pStream )
{
   HRESULT hResult;
   BYTE bData;
   ULONG nBytesRead;

   // We have to do this every time.  We don't AddRef, since we don't hold onto
   // the stream.
   m_pStream = pStream;

   do
   {
      switch( m_eInternalState )
      {
      case ISTATE_READFILEHEADER:
         hResult = ReadFileHeader();
         break;

      case ISTATE_READCHUNKHEADER:
         hResult = ReadChunkHeader();
         break;

      case ISTATE_READCHUNKDATA:
         hResult = ReadChunkData();
         break;

      case ISTATE_READIDATDATA:
         hResult = ReadIDATData();
         break;

      case ISTATE_READCHUNKCRC:
         hResult = ReadChunkCRC();
         break;

      case ISTATE_EATDATA:
         hResult = EatData();
         break;

      case ISTATE_PROCESSBKGD:
         hResult = ProcessBKGD();
         break;

        case ISTATE_CHOOSEBKGD:
            hResult = ChooseBKGD();
            break;

        case ISTATE_PROCESSTRNS:
            hResult = ProcessTRNS();
            break;

        case ISTATE_PROCESSGAMA:
            hResult = ProcessGAMA();
            break;

      case ISTATE_PROCESSIEND:
         hResult = ProcessIEND();
         break;

      case ISTATE_PROCESSIHDR:
         hResult = ProcessIHDR();
         break;

      case ISTATE_PROCESSPLTE:
         hResult = ProcessPLTE();
         break;

      case ISTATE_DONE:
         hResult = m_pStream->Read( &bData, 1, &nBytesRead );
         if (hResult == S_OK && nBytesRead == 0)
            hResult = S_FALSE;
         break;

      default:
         PNGTRACE((_T("Unknown state\n")));
         _ASSERT( FALSE );
         hResult = E_UNEXPECTED;
         break;
      }
      if( hResult == S_OK )
      {
         NextState();
      }
   } while( hResult == S_OK );

   m_pStream = NULL;

   return( hResult );
}

STDMETHODIMP CPNGFilter::Terminate( HRESULT hrStatus )
{
   PNGTRACE1((_T("Image decode terminated.  Status: %x\n"), hrStatus ));

    if (m_pDDrawSurface != NULL)
    {
        m_pDDrawSurface.Release();
    }

   if( m_pEventSink != NULL )
   {
      m_pEventSink->OnDecodeComplete( hrStatus );
      m_pEventSink.Release();
   }

   return( S_OK );
}

HRESULT CPNGFilter::WriteScanLine()
{
   ULONG nPixelHeight;
   ULONG iScanLine;
   RECT rect;
   HRESULT hResult;
   void* pBits = NULL;
   LONG nPitch;

   nPixelHeight = min( m_nPixelHeight, m_pngIHDR.nHeight-m_iScanLine );
   if (nPixelHeight < 1)
       return S_OK;
   rect.left = m_iFirstX;
   rect.top = m_iScanLine;
   rect.right = m_pngIHDR.nWidth;
   rect.bottom = m_iScanLine+nPixelHeight;
   hResult = LockBits( &rect, SURFACE_LOCK_EXCLUSIVE, &pBits,
      &nPitch );
   if( FAILED( hResult ) )
   {
      return( hResult );
   }

   m_pfnCopyScanLine( pBits, &m_pbScanLine[1], m_nPixelsInScanLine, m_nDeltaX,
      &m_frgbBackground, m_bPalette ? m_abTrans : m_abGamma);
   if( m_bExpandPixels )
   {
      for( iScanLine = 0; iScanLine < nPixelHeight; iScanLine++ )
      {
         m_pfnDuplicateScanLine( pBits, m_nDeltaX, m_nFullPixelsInScanLine,
            m_nPixelWidth, m_nPartialPixelWidth );
      }
   }

   UnlockBits( &rect, pBits );

   return( S_OK );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\pngfilt\cpngfilt.h ===
#ifndef UNIX
#pragma pack( push, PNG )
#pragma pack( 1 )
#endif

typedef struct _PNGCHUNKHEADER
{
   ULONG nDataLength;
   DWORD dwChunkType;
} PNGCHUNKHEADER;

typedef struct _PNGIHDRDATA
{
   ULONG nWidth;
   ULONG nHeight;
   BYTE nBitDepth;
   BYTE bColorType;
   BYTE bCompressionMethod;
   BYTE bFilterMethod;
   BYTE bInterlaceMethod;
} PNGIHDRDATA;

#ifndef UNIX
#pragma pack( pop, PNG )
#endif

typedef struct _PNG_INTERLACE_INFO
{
   ULONG nDeltaX;
   ULONG nDeltaY;
   ULONG nPixelWidth;
   ULONG nPixelHeight;
   ULONG iFirstX;
   ULONG iFirstY;
   BYTE anPixelsInPartialBlock[8];
   BYTE anScanLinesInPartialBlock[8];
} PNG_INTERLACE_INFO;

typedef struct _FLOATRGB
{
   float fRed;
   float fGreen;
   float fBlue;
} FLOATRGB;

typedef void (*PNGCOPYSCANLINEPROC)( void* pDest, const void* pSrc, 
   ULONG nPixels, ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, 
   BYTE* pXlate );
typedef void (*PNGDUPLICATESCANLINEPROC)( void* pScanLine, ULONG nDeltaX,
   ULONG nFullPixels, ULONG nFullPixelWidth, ULONG nPartialPixelWidth );

typedef struct _PNG_FORMAT_INFO
{
   ULONG nPossibleFormats;
   const GUID* pPossibleFormats;
   const PNGCOPYSCANLINEPROC* ppfnCopyScanLineProcs;
   const PNGDUPLICATESCANLINEPROC* ppfnDuplicateScanLineProcs;
} PNG_FORMAT_INFO;

#define PNGCHUNK( a, b, c, d ) \
   (MAKELONG( MAKEWORD( (a), (b) ), MAKEWORD( (c), (d) ) ))

const DWORD PNG_CHUNK_IHDR = PNGCHUNK( 'I', 'H', 'D', 'R' );
const DWORD PNG_CHUNK_IEND = PNGCHUNK( 'I', 'E', 'N', 'D' );
const DWORD PNG_CHUNK_IDAT = PNGCHUNK( 'I', 'D', 'A', 'T' );
const DWORD PNG_CHUNK_PLTE = PNGCHUNK( 'P', 'L', 'T', 'E' );
const DWORD PNG_CHUNK_BKGD = PNGCHUNK( 'b', 'K', 'G', 'D' );
const DWORD PNG_CHUNK_TRNS = PNGCHUNK( 't', 'R', 'N', 'S' );
const DWORD PNG_CHUNK_GAMA = PNGCHUNK( 'g', 'A', 'M', 'A' );

const DWORD PNG_CHUNK_ANCILLARY = 0x00000020;

const BYTE PNG_COMPRESSION_DEFLATE32K = 0;
const BYTE PNG_FILTER_ADAPTIVE = 0;
const BYTE PNG_INTERLACE_NONE = 0;
const BYTE PNG_INTERLACE_ADAM7 = 1;

const ULONG PNG_BUFFER_SIZE = 4096;

const DWORD CHUNK_IHDR = 0x01;
const DWORD CHUNK_PLTE = 0x02;
const DWORD CHUNK_POSTPLTE = 0x04;
const DWORD CHUNK_IDAT = 0x08;
const DWORD CHUNK_LASTIDAT = 0x10;
const DWORD CHUNK_IEND = 0x20;
const DWORD CHUNK_BKGD = 0x40;
const DWORD CHUNK_TRNS = 0x80;
const DWORD CHUNK_GAMA = 0x100;

const BYTE PNG_COLORTYPE_PALETTE_MASK = 0x01;
const BYTE PNG_COLORTYPE_COLOR_MASK = 0x02;
const BYTE PNG_COLORTYPE_ALPHA_MASK = 0x04;
const BYTE PNG_COLORTYPE_INDEXED = PNG_COLORTYPE_PALETTE_MASK|
   PNG_COLORTYPE_COLOR_MASK;
const BYTE PNG_COLORTYPE_RGB = PNG_COLORTYPE_COLOR_MASK;
const BYTE PNG_COLORTYPE_GRAY = 0x00;
const BYTE PNG_COLORTYPE_RGBA = PNG_COLORTYPE_COLOR_MASK|
   PNG_COLORTYPE_ALPHA_MASK;
const BYTE PNG_COLORTYPE_GRAYA = PNG_COLORTYPE_ALPHA_MASK;

class CPNGFilter : 
   public IImageDecodeFilter,
	public CComObjectRoot,
	public CComCoClass< CPNGFilter, &CLSID_CoPNGFilter >
{
public:
	CPNGFilter();
   ~CPNGFilter();

   BEGIN_COM_MAP( CPNGFilter )
	   COM_INTERFACE_ENTRY( IImageDecodeFilter )
   END_COM_MAP()

   DECLARE_NOT_AGGREGATABLE( CPNGFilter )  
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

   DECLARE_REGISTRY( CPNGFilter, _T( "PNGFilter.CoPNGFilter.1" ), 
      _T( "PNGFilter.CoPNGFilter" ), IDS_COPNGFILTER_DESC, THREADFLAGS_BOTH )

//   DECLARE_NO_REGISTRY()

// IImageDecodeFilter
public:
   STDMETHOD( Initialize )( IImageDecodeEventSink* pEventSink );
   STDMETHOD( Process )( IStream* pStream );
   STDMETHOD( Terminate )( HRESULT hrStatus );

protected:
   HRESULT BeginImage();
   HRESULT ChooseDestinationFormat( GUID* pBFID );
   HRESULT DetermineSourceFormat();
   HRESULT EatData();
   HRESULT FireGetSurfaceEvent();
   HRESULT FireOnProgressEvent();
   HRESULT NextState();
   HRESULT OutputBytes( const BYTE* pData, ULONG nBytes );
   HRESULT ChooseBKGD();
   HRESULT ProcessBKGD();
   HRESULT ProcessIDAT();
   HRESULT ProcessIEND();
   HRESULT ProcessIHDR();
   HRESULT ProcessPLTE();
   HRESULT ProcessTRNS();
   HRESULT ProcessGAMA();
   HRESULT ReadChunkHeader();
   HRESULT ReadChunkData();
   HRESULT ReadChunkCRC();
   HRESULT ReadFileHeader();
   HRESULT ReadIDATData();
   HRESULT NextPass();
   HRESULT NextScanLine();
   BOOL BeginPass( ULONG iPass );
   HRESULT WriteScanLine();

    HRESULT LockBits(RECT *prcBounds, DWORD dwLockFlags, void **ppBits, long *pPitch);
    HRESULT UnlockBits(RECT *prcBounds, void *pBits);

   void NoneFilterScanLine();
   void SubFilterScanLine();
   void UpFilterScanLine();
   void AverageFilterScanLine();
   void PaethFilterScanLine();

protected:
   static const PNG_INTERLACE_INFO s_aInterlaceInfoNone[1];
   static const PNG_INTERLACE_INFO s_aInterlaceInfoAdam7[7];
   static const PNG_FORMAT_INFO s_aFormatInfo[15];

protected:
   typedef enum _EInternalState
   {
      ISTATE_READFILEHEADER,
      ISTATE_READCHUNKHEADER,
      ISTATE_READCHUNKDATA,
      ISTATE_READIDATDATA,
      ISTATE_READCHUNKCRC,
      ISTATE_PROCESSIHDR,
      ISTATE_PROCESSIEND,
      ISTATE_PROCESSPLTE,
      ISTATE_PROCESSBKGD,
      ISTATE_PROCESSTRNS,
      ISTATE_PROCESSGAMA,
      ISTATE_CHOOSEBKGD,
      ISTATE_EATDATA,
      ISTATE_DONE
   } EInternalState;
   typedef enum _ESrcFormat
   {
      SRC_GRAY_1,
      SRC_GRAY_2,
      SRC_GRAY_4,
      SRC_GRAY_8,
      SRC_GRAY_16,
      SRC_RGB_24,
      SRC_RGB_48,
      SRC_INDEXED_RGB_1,
      SRC_INDEXED_RGB_2,
      SRC_INDEXED_RGB_4,
      SRC_INDEXED_RGB_8,
      SRC_GRAYA_16,
      SRC_GRAYA_32,
      SRC_RGBA_32,
      SRC_RGBA_64
   } ESrcFormat;

   EInternalState m_eInternalState;  // State of decode state machine
   DWORD m_dwEvents;  // Events the event sink wants to receive
   PNGCOPYSCANLINEPROC m_pfnCopyScanLine;
   PNGDUPLICATESCANLINEPROC m_pfnDuplicateScanLine;
   const PNG_INTERLACE_INFO* m_pInterlaceInfo;
   ULONG m_nFormats;  // Number of formats the event sink supports
   GUID* m_pFormats;  // Formats supported by the event sink
   BOOL m_bPalette;  // Does image use a palette?
   BOOL m_bColor;  // Does image use color?
   BOOL m_bAlpha;  // Does image have an alpha channel
   BOOL m_bSurfaceUsesAlpha;
   BOOL m_bConvertAlpha;
   BOOL m_bSkipData;
   ESrcFormat m_eSrcFormat;  // Source pixel format
   DWORD m_dwCRC;  // CRC accumulator
   DWORD m_dwChunkCRC;  // Stored CRC of current chunk
   ULONG m_nColors;  // Number of colors in palette
   ULONG m_iBackgroundIndex;  // Index of background color
   RGBQUAD m_rgbBackground;  // Background color
   FLOATRGB m_frgbBackground;  // Floating-point background color
   DWORD  m_dwTransKey;      // Transparent color key (RGB or indexed
   ULONG    m_nTransparentColors;   // # transparent indices
   IStream* m_pStream;  // Source stream
   CComPtr< IImageDecodeEventSink > m_pEventSink;  // Event sink
   PNGCHUNKHEADER m_pngChunkHeader;  // Header of current chunk
   PNGIHDRDATA m_pngIHDR;  // IHDR chunk
   DWORD m_dwChunksEncountered;  // CHUNK_* flags for what chunks have been
      // encountered in the image stream so far
   CComPtr< IDirectDrawSurface > m_pDDrawSurface;
   BOOL m_bFinishedIDAT;  // Have we finished the IDAT section?
   ULONG m_nBytesLeftInCurrentTask;  // Bytes remaining before we switch to a
      // new state
   ULONG m_nDataBytesRead;  // Bytes of chunk data read
   ULONG m_iAppend;  // Where to append data in buffer
   BYTE* m_pbScanLine;  // Current decoded scan line (including filter byte)
   BYTE* m_pbPrevScanLine;  // Previous decoded scan line
   ULONG m_iPass;  // Current pass
   ULONG m_nPasses;  // Number of passes
   ULONG m_nBytesInScanLine;  // Number of bytes in one scan line
   ULONG m_nPixelsInScanLine;  // Number of pixels in one scan line
   ULONG m_nBitsPerPixel;  // Bits per pixel in source image
   BOOL m_bExpandPixels;  // Expand interlaced pixels?
   ULONG m_iScanLine;  // Current scan line
   ULONG m_nScanLinesInPass;  // Number of scan lines in current pass
   ULONG m_iScanLineInPass;  // Current scan line in pass
   ULONG m_iFirstStaleScanLine;  // First scan line whose progress has not been
      // reported
   ULONG m_nBPP;  // Bytes per pixel
   ULONG m_nDeltaX;  // Horizontal distance between pixels
   ULONG m_nDeltaY;  // Vertical distance between pixels
   ULONG m_nPixelWidth;  // Width of a pixel
   ULONG m_nPixelHeight;  // Height of a pixel
   ULONG m_iFirstX;  // Horizontal position of first pixel in scan line
   ULONG m_iFirstY;  // Vertical position of first scan line in pass
   ULONG m_nFullPixelsInScanLine;
   ULONG m_nPartialPixelWidth;
   z_stream m_zlibStream;  // ZLib data
   BYTE m_abData[PNG_BUFFER_SIZE];  // Data buffer
   BYTE m_abTrans[256];     // table to collapse multiple transparent indices
   BYTE m_abGamma[256];     // gamma correction table
   RGBQUAD m_argbColors[256];

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\pngfilt\pngfilt.cpp ===
// PNGFilter.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL,
//      run nmake -f WMFFilterps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "pngfilt.h"
#include "cpngfilt.h"
#include <advpub.h>

#define IID_DEFINED
#ifdef UNIX
#  include "pngfilt.ic"
#else
#  include "pngfilt_i.c"
#endif

#pragma warning( disable: 4505 )

HRESULT WriteMIMEKeys(LPCTSTR lpszCLSID, LPTSTR lpszMIME, int nBytes, BYTE * pbID);

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CoPNGFilter, CPNGFilter)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
   {
        _Module.Term();
   }

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

BYTE byPNGID[] = {   0x08, 0x00, 0x00, 0x00,                    // length
                     0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,   // mask
                     0x89,0x50,0x4E,0x47,0x0D,0x0A,0x1A,0x0A    // data
                   };


STDAPI ie3_DllRegisterServer(void)
{
    HRESULT hr;
    // registers object, typelib and all interfaces in typelib
    hr = _Module.RegisterServer(FALSE);
    if (FAILED(hr))
        return hr;

    hr = WriteMIMEKeys(_T("{A3CCEDF7-2DE2-11D0-86F4-00A0C913F750}"), _T("image/png"), sizeof(byPNGID), byPNGID);
    if (FAILED(hr))
        return hr;

    hr = WriteMIMEKeys(_T("{A3CCEDF7-2DE2-11D0-86F4-00A0C913F750}"), _T("image/x-png"), sizeof(byPNGID), byPNGID);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI ie3_DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}

TCHAR szDatabase[] = _T("MIME\\Database\\Content Type\\");
TCHAR szBits[] = _T("Bits");

HRESULT WriteMIMEKeys(LPCTSTR lpszCLSID, LPTSTR lpszMIME, int nBytes, BYTE * pbID)
{
    TCHAR szBuf[MAX_PATH];
    HKEY hkey, hkey2;
    DWORD dw;

    lstrcpy(szBuf, szDatabase);
    lstrcat(szBuf, lpszMIME);

    RegCreateKeyEx(HKEY_CLASSES_ROOT, szBuf, 0, NULL, 0, KEY_WRITE, NULL, &hkey, &dw);
    if (hkey)
    {
        RegSetValueEx(hkey, _T("Image Filter CLSID"), 0, REG_SZ, (LPBYTE)lpszCLSID, lstrlen(lpszCLSID)+1);

        RegCreateKeyEx(hkey, szBits, 0, NULL, 0, KEY_WRITE, NULL, &hkey2, &dw);
        if (hkey2)
        {
            RegSetValueEx(hkey2, _T("0"), 0, REG_BINARY, pbID, nBytes);
            RegCloseKey(hkey2);
        }
        RegCloseKey(hkey);
    }

    return S_OK;
}

static HINSTANCE hAdvPackLib;

REGINSTALL GetRegInstallFn(void)
{
    hAdvPackLib = LoadLibraryA("advpack.dll");
    if (!hAdvPackLib)
        return NULL;

    return (REGINSTALL)GetProcAddress(hAdvPackLib, achREGINSTALL);
}

inline void UnloadAdvPack(void)
{
    FreeLibrary(hAdvPackLib);
}

STDAPI ie4_DllRegisterServer(void)
{
    REGINSTALL pfnReg = GetRegInstallFn();
    HRESULT hr;

    if (pfnReg == NULL)
        return E_FAIL;
        
    // Delete any old registration entries, then add the new ones.
    hr = (*pfnReg)(_Module.GetResourceInstance(), "UnReg", NULL);
    if (SUCCEEDED(hr))
        hr = (*pfnReg)(_Module.GetResourceInstance(), "Reg", NULL);

    UnloadAdvPack();
    
    return hr;
}

STDAPI
ie4_DllUnregisterServer(void)
{
    REGINSTALL pfnReg = GetRegInstallFn();
    HRESULT hr;
    
    if (pfnReg == NULL)
        return E_FAIL;

    hr = (*pfnReg)( _Module.GetResourceInstance(), "UnReg", NULL);

    UnloadAdvPack();

    return hr;
}

STDAPI DllRegisterServer(void)
{
    REGINSTALL pfnReg = GetRegInstallFn();
    UnloadAdvPack();

    if (pfnReg)
        return ie4_DllRegisterServer();
    else
        return ie3_DllRegisterServer();
}

STDAPI
DllUnregisterServer(void)
{
    REGINSTALL pfnReg = GetRegInstallFn();
    UnloadAdvPack();

    if (pfnReg)
        return ie4_DllUnregisterServer();
    else
        return ie3_DllUnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\pngfilt\scanline.cpp ===
#include "stdafx.h"
#include "pngfilt.h"
#include "resource.h"
#include "cpngfilt.h"
#include "scanline.h"

void DuplicateScanLineARGB32( void* pScanLine, ULONG nDeltaX, ULONG nFullPixels, 
   ULONG nFullPixelWidth, ULONG nPartialPixelWidth )
{
   BYTE* pbSrcPixel;
   BYTE* pbDestPixel;
   ULONG iSrcPixel;
   ULONG iDestPixel;
   BYTE bAlpha;
   BYTE bRed;
   BYTE bGreen;
   BYTE bBlue;

   pbSrcPixel = LPBYTE( pScanLine );
   
   for( iSrcPixel = 0; iSrcPixel < nFullPixels; iSrcPixel++ )
   {
      bAlpha = pbSrcPixel[4];
      bRed = pbSrcPixel[2];
      bGreen = pbSrcPixel[1];
      bBlue = pbSrcPixel[0];
      pbDestPixel = pbSrcPixel+4;

      for( iDestPixel = 1; iDestPixel < nFullPixelWidth; iDestPixel++ )
      {
         pbDestPixel[0] = bBlue;
         pbDestPixel[1] = bGreen;
         pbDestPixel[2] = bRed;
         pbDestPixel[3] = bAlpha;
         
         pbDestPixel += 4;
      }

      pbSrcPixel += 4*nDeltaX;
   }

   if( nPartialPixelWidth > 0 )
   {
      bAlpha = pbSrcPixel[3];
      bRed = pbSrcPixel[2];
      bGreen = pbSrcPixel[1];
      bBlue = pbSrcPixel[0];
      pbDestPixel = pbSrcPixel+4;

      for( iDestPixel = 1; iDestPixel < nPartialPixelWidth; iDestPixel++ )
      {
         pbDestPixel[0] = bBlue;
         pbDestPixel[1] = bGreen;
         pbDestPixel[2] = bRed;
         pbDestPixel[3] = bAlpha;
      
         pbDestPixel += 4;
      }
   }
}

void DuplicateScanLineBGR24( void* pScanLine, ULONG nDeltaX, ULONG nFullPixels, 
   ULONG nFullPixelWidth, ULONG nPartialPixelWidth )
{
   BYTE* pbSrcPixel;
   BYTE* pbDestPixel;
   ULONG iSrcPixel;
   ULONG iDestPixel;
   BYTE bRed;
   BYTE bGreen;
   BYTE bBlue;

   pbSrcPixel = LPBYTE( pScanLine );
   
   for( iSrcPixel = 0; iSrcPixel < nFullPixels; iSrcPixel++ )
   {
      bRed = pbSrcPixel[2];
      bGreen = pbSrcPixel[1];
      bBlue = pbSrcPixel[0];
      pbDestPixel = pbSrcPixel+3;

      for( iDestPixel = 1; iDestPixel < nFullPixelWidth; iDestPixel++ )
      {
         pbDestPixel[0] = bBlue;
         pbDestPixel[1] = bGreen;
         pbDestPixel[2] = bRed;
         
         pbDestPixel += 3;
      }

      pbSrcPixel += 3*nDeltaX;
   }

   if( nPartialPixelWidth > 0 )
   {
      bRed = pbSrcPixel[2];
      bGreen = pbSrcPixel[1];
      bBlue = pbSrcPixel[0];
      pbDestPixel = pbSrcPixel+3;

      for( iDestPixel = 1; iDestPixel < nPartialPixelWidth; iDestPixel++ )
      {
         pbDestPixel[0] = bBlue;
         pbDestPixel[1] = bGreen;
         pbDestPixel[2] = bRed;
      
         pbDestPixel += 3;
      }
   }
}

void DuplicateScanLineIndex8( void* pScanLine, ULONG nDeltaX, 
   ULONG nFullPixels, ULONG nFullPixelWidth, ULONG nPartialPixelWidth )
{
   BYTE* pbSrcPixel;
   BYTE* pbDestPixel;
   ULONG iSrcPixel;
   ULONG iDestPixel;
   BYTE bIndex;

   pbSrcPixel = LPBYTE( pScanLine );
   
   for( iSrcPixel = 0; iSrcPixel < nFullPixels; iSrcPixel++ )
   {
      bIndex = pbSrcPixel[0];
      pbDestPixel = pbSrcPixel+1;

      for( iDestPixel = 1; iDestPixel < nFullPixelWidth; iDestPixel++ )
      {
         pbDestPixel[0] = bIndex;
         
         pbDestPixel++;
      }

      pbSrcPixel += nDeltaX;
   }

   if( nPartialPixelWidth > 0 )
   {
      bIndex = pbSrcPixel[0];
      pbDestPixel = pbSrcPixel+1;

      for( iDestPixel = 1; iDestPixel < nPartialPixelWidth; iDestPixel++ )
      {
         pbDestPixel[0] = bIndex;
      
         pbDestPixel++;
      }
   }
}

const float RECIP65535 = 1.0f/65535.0f;
const float RECIP255 = 1.0f/255.0f;

void CopyScanLineRGBA64ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iPixel;
   float fAlpha;
   float fInverseAlpha;
   float fSrcRed;
   float fSrcGreen;
   float fSrcBlue;
   float fDestRed;
   float fDestGreen;
   float fDestBlue;

   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );

   for( iPixel = 0; iPixel < nPixels; iPixel++ )
   {
      fAlpha = ((pbSrc[6]<<8)+pbSrc[7])*RECIP65535;
      fInverseAlpha = 1.0f-fAlpha;

      fSrcRed = ((pbSrc[0]<<8)+pbSrc[1])*RECIP65535;
      fSrcGreen = ((pbSrc[2]<<8)+pbSrc[3])*RECIP65535;
      fSrcBlue = ((pbSrc[4]<<8)+pbSrc[5])*RECIP65535;

      fDestRed = (fAlpha*fSrcRed)+(fInverseAlpha*pfrgbBackground->fRed);
      fDestGreen = (fAlpha*fSrcGreen)+(fInverseAlpha*pfrgbBackground->fGreen);
      fDestBlue = (fAlpha*fSrcBlue)+(fInverseAlpha*pfrgbBackground->fBlue);

      pbDest[0] = pXlate[BYTE(fDestBlue*255.0f)];
      pbDest[1] = pXlate[BYTE(fDestGreen*255.0f)];
      pbDest[2] = pXlate[BYTE(fDestRed*255.0f)];

      pbSrc += 8;
      pbDest += 3*nDeltaXDest;
   }
}

void CopyScanLineRGBA32ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iPixel;
   float fAlpha;
   float fInverseAlpha;
   float fSrcRed;
   float fSrcGreen;
   float fSrcBlue;
   float fDestRed;
   float fDestGreen;
   float fDestBlue;

   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );

   for( iPixel = 0; iPixel < nPixels; iPixel++ )
   {
      fAlpha = pbSrc[3]*RECIP255;
      fInverseAlpha = 1.0f-fAlpha;

      fSrcRed = pbSrc[0]*RECIP255;
      fSrcGreen = pbSrc[1]*RECIP255;
      fSrcBlue = pbSrc[2]*RECIP255;

      fDestRed = (fAlpha*fSrcRed)+(fInverseAlpha*pfrgbBackground->fRed);
      fDestGreen = (fAlpha*fSrcGreen)+(fInverseAlpha*pfrgbBackground->fGreen);
      fDestBlue = (fAlpha*fSrcBlue)+(fInverseAlpha*pfrgbBackground->fBlue);

      pbDest[0] = pXlate[BYTE(fDestBlue*255.0f)];
      pbDest[1] = pXlate[BYTE(fDestGreen*255.0f)];
      pbDest[2] = pXlate[BYTE(fDestRed*255.0f)];

      pbSrc += 4;
      pbDest += 3*nDeltaXDest;
   }
}

void CopyScanLineGrayA32ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iPixel;
   float fAlpha;
   float fInverseAlpha;
   float fSrc;
   float fDest;
   BYTE bDest;

   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );

   for( iPixel = 0; iPixel < nPixels; iPixel++ )
   {
      fAlpha = ((pbSrc[2]<<8)+pbSrc[3])*RECIP65535;
      fInverseAlpha = 1.0f-fAlpha;

      fSrc = ((pbSrc[0]<<8)+pbSrc[1])*RECIP65535;

      fDest = (fAlpha*fSrc)+(fInverseAlpha*pfrgbBackground->fRed);
      bDest = pXlate[BYTE(fDest*255.0f)];

      pbDest[0] = bDest;
      pbDest[1] = bDest;
      pbDest[2] = bDest;

      pbSrc += 4;
      pbDest += 3*nDeltaXDest;
   }
}

void CopyScanLineGrayA16ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iPixel;
   float fAlpha;
   float fInverseAlpha;
   float fSrc;
   float fDest;
   BYTE bDest;

   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );

   for( iPixel = 0; iPixel < nPixels; iPixel++ )
   {
      fAlpha = pbSrc[1]*RECIP255;
      fInverseAlpha = 1.0f-fAlpha;

      fSrc = pbSrc[0]*RECIP255;

      fDest = (fAlpha*fSrc)+(fInverseAlpha*pfrgbBackground->fRed);
      bDest = pXlate[BYTE(fDest*255.0f)];

      pbDest[0] = bDest;
      pbDest[1] = bDest;
      pbDest[2] = bDest;

      pbSrc += 2;
      pbDest += 3*nDeltaXDest;
   }
}

void CopyScanLineRGBA64ToBGRA32( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iPixel;

   (void)pfrgbBackground;
    
   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );

   for( iPixel = 0; iPixel < nPixels; iPixel++ )
   {
      pbDest[0] = pXlate[pbSrc[4]];
      pbDest[1] = pXlate[pbSrc[2]];
      pbDest[2] = pXlate[pbSrc[0]];
      pbDest[3] = pbSrc[6]; // alpha not gamma corrected

      pbSrc += 8;
      pbDest += 4*nDeltaXDest;
   }
}

void CopyScanLineRGB48ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iPixel;

   (void)pfrgbBackground;
    
   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );

   for( iPixel = 0; iPixel < nPixels; iPixel++ )
   {
      pbDest[0] = pXlate[pbSrc[4]];
      pbDest[1] = pXlate[pbSrc[2]];
      pbDest[2] = pXlate[pbSrc[0]];

      pbSrc += 6;
      pbDest += 3*nDeltaXDest;
   }
}

void CopyScanLineRGBA32ToBGRA32( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iPixel;

   (void)pfrgbBackground;

   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );

   for( iPixel = 0; iPixel < nPixels; iPixel++ )
   {
      pbDest[0] = pXlate[pbSrc[2]];
      pbDest[1] = pXlate[pbSrc[1]];
      pbDest[2] = pXlate[pbSrc[0]];
      pbDest[3] = pbSrc[3]; // alpha not gamma corrected

      pbSrc += 4;
      pbDest += 4*nDeltaXDest;
   }
}

void CopyScanLineRGB24ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iPixel;

   (void)pfrgbBackground;
    
   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );

   for( iPixel = 0; iPixel < nPixels; iPixel++ )
   {
      pbDest[0] = pXlate[pbSrc[2]];
      pbDest[1] = pXlate[pbSrc[1]];
      pbDest[2] = pXlate[pbSrc[0]];

      pbSrc += 3;
      pbDest += 3*nDeltaXDest;
   }
}

void CopyScanLineGrayA32ToBGRA32( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iPixel;

   (void)pfrgbBackground;
    
   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );

   for( iPixel = 0; iPixel < nPixels; iPixel++ )
   {
      pbDest[0] = pXlate[pbSrc[0]];
      pbDest[1] = pbDest[0];
      pbDest[2] = pbDest[0];
      pbDest[3] = pbSrc[2]; // alpha not gamma corrected

      pbSrc += 4;
      pbDest += 4*nDeltaXDest;
   }
}

void CopyScanLineGray16ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iPixel;

   (void)pfrgbBackground;

   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );

   for( iPixel = 0; iPixel < nPixels; iPixel++ )
   {
      pbDest[0] = pXlate[pbSrc[0]];
      pbDest[1] = pbDest[0];
      pbDest[2] = pbDest[0];
      
      pbSrc += 2;
      pbDest += 3*nDeltaXDest;
   }
}

void CopyScanLineGrayA16ToBGRA32( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iPixel;

   (void)pfrgbBackground;
    
   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );

   for( iPixel = 0; iPixel < nPixels; iPixel++ )
   {
      pbDest[0] = pXlate[pbSrc[0]];
      pbDest[1] = pbDest[0];
      pbDest[2] = pbDest[0];
      pbDest[3] = pbSrc[1];

      pbSrc += 2;
      pbDest += 4*nDeltaXDest;
   }
}

void CopyScanLineGray8ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iPixel;

   (void)pfrgbBackground;

   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );

   for( iPixel = 0; iPixel < nPixels; iPixel++ )
   {
      pbDest[0] = pXlate[pbSrc[0]];
      pbDest[1] = pbDest[0];
      pbDest[2] = pbDest[0];
      
      pbSrc++;
      pbDest += 3*nDeltaXDest;
   }
}

void CopyScanLineGray8ToGray8( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iPixel;

   (void)pfrgbBackground;

   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );

   for( iPixel = 0; iPixel < nPixels; iPixel++ )
   {
      pbDest[0] = pXlate[pbSrc[0]];
      
      pbSrc++;
      pbDest += nDeltaXDest;
   }
}

static inline BYTE Expand4To8( ULONG nIntensity )
{
   return( BYTE( nIntensity+(nIntensity<<4) ) );
}

void CopyScanLineGray4ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iPair;
   ULONG nPairs;
   BYTE bSrc;
   BYTE bDest;

   (void)pfrgbBackground;
    
   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );
   nPairs = nPixels/2;
   for( iPair = 0; iPair < nPairs; iPair++ )
   {
      bSrc = pbSrc[0];
      bDest = pXlate[BYTE((bSrc & 0xf0) + ((bSrc & 0xf0) >> 4))];
      pbDest[0] = bDest;
      pbDest[1] = bDest;
      pbDest[2] = bDest;

      pbDest += 3*nDeltaXDest;

      bDest = pXlate[BYTE((bSrc & 0x0f) + ((bSrc & 0x0f) << 4))];
      pbDest[0] = bDest;
      pbDest[1] = bDest;
      pbDest[2] = bDest;

      pbDest += 3*nDeltaXDest;
      pbSrc++;
   }

   if( (nPixels%2) > 0 )
   {
      bSrc = pbSrc[0];
      bDest = pXlate[BYTE((bSrc & 0xf0) + ((bSrc & 0xf0) >> 4))];
      pbDest[0] = bDest;
      pbDest[1] = bDest;
      pbDest[2] = bDest;
   }
}

static BYTE g_abExpand2To8[4] = { 0, 85, 170, 255 };

static inline BYTE Expand2To8( ULONG nIntensity )
{
   return( g_abExpand2To8[nIntensity] );
}

void CopyScanLineGray2ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iQuad;
   ULONG nQuads;
   ULONG iPixel;
   ULONG nShift;
   ULONG nExtraPixels;
   BYTE bSrc;
   BYTE bDest;

   (void)pfrgbBackground;

   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );
   nQuads = nPixels/4;
   for( iQuad = 0; iQuad < nQuads; iQuad++ )
   {
      bSrc = pbSrc[0];
      nShift = 6;
      for( iPixel = 0; iPixel < 4; iPixel++ )
      {
         bDest = pXlate[Expand2To8((bSrc >> nShift) & 0x03)];
         pbDest[0] = bDest;
         pbDest[1] = bDest;
         pbDest[2] = bDest;

         nShift -= 2;
         pbDest += 3*nDeltaXDest;
      }

      pbSrc++;
   }

   nExtraPixels = nPixels%4;
   if( nExtraPixels > 0 )
   {
      nShift = 6;
      bSrc = pbSrc[0];
      for( iPixel = 0; iPixel < nExtraPixels; iPixel++ )
      {
         bDest = pXlate[Expand2To8((bSrc >> nShift) & 0x03)];
         pbDest[0] = bDest;
         pbDest[1] = bDest;
         pbDest[2] = bDest;

         nShift -= 2;
         pbDest += 3*nDeltaXDest;
      }
   }
}

static BYTE g_abExpand1To8[2] = { 0, 255 };

static inline BYTE Expand1To8( ULONG nIntensity )
{
   return( g_abExpand1To8[nIntensity] );
}

void CopyScanLineGray1ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iOctet;
   ULONG nOctets;
   ULONG nShift;
   ULONG nExtraPixels;
   ULONG iPixel;
   BYTE bSrc;
   BYTE bDest;

   (void)pfrgbBackground;
    (void)pXlate;

   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );
   nOctets = nPixels/8;
   for( iOctet = 0; iOctet < nOctets; iOctet++ )
   {
      bSrc = pbSrc[0];
      nShift = 7;
      for( iPixel = 0; iPixel < 8; iPixel++ )
      {
         bDest = Expand1To8( (bSrc>>nShift)&0x01 );
         pbDest[0] = bDest;
         pbDest[1] = bDest;
         pbDest[2] = bDest;

         nShift--;
         pbDest += 3*nDeltaXDest;
      }
      
      pbSrc++;
   }

   nExtraPixels = nPixels%8;
   if( nExtraPixels > 0 )
   {
      nShift = 7;
      bSrc = pbSrc[0];
      for( iPixel = 0; iPixel < nExtraPixels; iPixel++ )
      {
         bDest = Expand1To8( (bSrc>>nShift)&0x01 );
         pbDest[0] = bDest;
         pbDest[1] = bDest;
         pbDest[2] = bDest;

         nShift--;
         pbDest += 3*nDeltaXDest;
      }
   }
}

void CopyScanLineIndex8ToIndex8( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iPixel;

   (void)pfrgbBackground;

   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );

   for( iPixel = 0; iPixel < nPixels; iPixel++ )
   {
      pbDest[0] = pXlate[pbSrc[0]];
      
      pbSrc++;
      pbDest += nDeltaXDest;
   }
}

void CopyScanLineIndex4ToIndex8( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iPair;
   ULONG nPairs;
   BYTE bSrc;

   (void)pfrgbBackground;

   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );
   nPairs = nPixels/2;
   for( iPair = 0; iPair < nPairs; iPair++ )
   {
      bSrc = pbSrc[0];
      pbDest[0] = pXlate[BYTE((bSrc >> 4) & 0x0f)];
      pbDest[nDeltaXDest] = pXlate[BYTE(bSrc & 0x0f)];
      
      pbSrc++;
      pbDest += 2*nDeltaXDest;
   }

   if( (nPixels%2) > 0 )
   {
      pbDest[0] = pXlate[BYTE((pbSrc[0] >> 4) & 0x0f)];
   }
}

void CopyScanLineIndex2ToIndex8( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iQuad;
   ULONG nQuads;
   ULONG nShift;
   ULONG nExtraPixels;
   ULONG iPixel;
   BYTE bSrc;

   (void)pfrgbBackground;

   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );
   nQuads = nPixels/4;
   for( iQuad = 0; iQuad < nQuads; iQuad++ )
   {
      bSrc = pbSrc[0];
      pbDest[0] = pXlate[BYTE((bSrc>>6) & 0x03)];
      pbDest[nDeltaXDest] = pXlate[BYTE((bSrc >> 4) & 0x03)];
      pbDest[2*nDeltaXDest] = pXlate[BYTE((bSrc >> 2) & 0x03)];
      pbDest[3*nDeltaXDest] = pXlate[BYTE(bSrc & 0x03)];
      
      pbSrc++;
      pbDest += 4*nDeltaXDest;
   }

   nExtraPixels = nPixels%4;
   if( nExtraPixels > 0 )
   {
      nShift = 6;
      bSrc = pbSrc[0];
      for( iPixel = 0; iPixel < nExtraPixels; iPixel++ )
      {
         pbDest[0] = pXlate[BYTE((bSrc >> nShift) & 0x03)];
         nShift -= 2;
         pbDest += nDeltaXDest;
      }
   }
}

void CopyScanLineIndex1ToIndex8( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate)
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iOctet;
   ULONG nOctets;
   ULONG nShift;
   ULONG nExtraPixels;
   ULONG iPixel;
   BYTE bSrc;

   (void)pfrgbBackground;

   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );
   nOctets = nPixels/8;
   for( iOctet = 0; iOctet < nOctets; iOctet++ )
   {
      bSrc = pbSrc[0];
      nShift = 7;
      for( iPixel = 0; iPixel < 8; iPixel++ )
      {
         pbDest[0] = pXlate[BYTE((bSrc>>nShift) &0x01)]; 
         nShift--;
         pbDest += nDeltaXDest;
      }
      
      pbSrc++;
   }

   nExtraPixels = nPixels%8;
   if( nExtraPixels > 0 )
   {
      nShift = 7;
      bSrc = pbSrc[0];
      for( iPixel = 0; iPixel < nExtraPixels; iPixel++ )
      {
         pbDest[0] = pXlate[BYTE((bSrc>>nShift) &0x01)]; 
         nShift--;
         pbDest += nDeltaXDest;
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\pngfilt\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define _ATL_NO_FLTUSED
#define _MERGE_PROXYSTUB
#define USE_IERT

#include <ddraw.h>
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include "imgutil.h"

extern "C" {
#ifdef UNIX
#  include "zlib.h"
#else
   // zlib is centralized in root/public/internal/base/inc
#  include "zlib.h"
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\pngfilt\scanline.h ===
void DuplicateScanLineARGB32( void* pScanLine, ULONG nDeltaX, ULONG nFullPixels, 
   ULONG nFullPixelWidth, ULONG nPartialPixelWidth );
void DuplicateScanLineBGR24( void* pScanLine, ULONG nDeltaX, ULONG nFullPixels, 
   ULONG nFullPixelWidth, ULONG nPartialPixelWidth );
void DuplicateScanLineIndex8( void* pScanLine, ULONG nDeltaX, 
   ULONG nFullPixels, ULONG nFullPixelWidth, ULONG nPartialPixelWidth );

void CopyScanLineRGBA64ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );
void CopyScanLineRGBA32ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );
void CopyScanLineGrayA32ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );
void CopyScanLineGrayA16ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );

void CopyScanLineRGBA64ToBGRA32( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );
void CopyScanLineRGB48ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );
void CopyScanLineRGBA32ToBGRA32( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );
void CopyScanLineRGB24ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );

void CopyScanLineGrayA32ToBGRA32( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );
void CopyScanLineGray16ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );
void CopyScanLineGrayA16ToBGRA32( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );
void CopyScanLineGray8ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );
void CopyScanLineGray8ToGray8( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );
void CopyScanLineGray4ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );
void CopyScanLineGray2ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );
void CopyScanLineGray1ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );

void CopyScanLineIndex8ToIndex8( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );
void CopyScanLineIndex4ToIndex8( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );
void CopyScanLineIndex2ToIndex8( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );
void CopyScanLineIndex1ToIndex8( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\pngfilt\include\makefile.inc ===
MIDL= midl.exe

.idl.h:
   $(MIDL) $? /h $(*B).H /tlb ..\Daytona\$(O)\$(*B).tlb /I$(INCLUDES) /iid $(*B).ic

.SUFFIXES: .idl .h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\imgfilt\pngfilt\daytona\makefile.inc ===
..\pngfilt.rc : ..\selfreg.inf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\inc\dxtpriv.h ===
/*******************************************************************************
* DXVector.h *
*------------*
*   Description:
*       This is the header file for the matrix classes.
*
*******************************************************************************/
#ifndef __DXTPRIV_H_
#define __DXTPRIV_H_

#ifndef _INC_MATH
#include <math.h>
#endif

#ifndef _INC_CRTDBG
#include <crtdbg.h>
#endif

//=== Class, Enum, Struct and Union Declarations ===================
class CDXMatrix4x4F;

//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================
float det4x4( CDXMatrix4x4F *pIn );
float det3x3( float a1, float a2, float a3, float b1, float b2, float b3, 
              float c1, float c2, float c3 );
float det2x2( float a, float b, float c, float d );

/*** CDX2DXForm ************
*   This class implements basic matrix operation based on the GDI XFORM
*   structure.
*/
//const DX2DXFORM g_DX2DXFORMIdentity = { 1., 0., 0., 1., 0., 0., DX2DXO_IDENTITY };

class CDX2DXForm : public DX2DXFORM
{
  /*=== Methods =======*/
public:
    /*--- Constructors ---*/
    CDX2DXForm() { SetIdentity(); }
    CDX2DXForm( const CDX2DXForm& Other ) { memcpy( this, &Other, sizeof(*this) ); }
    CDX2DXForm( const DX2DXFORM& Other ) { memcpy( this, &Other, sizeof(*this) ); }

    /*--- methods ---*/
    void DetermineOp( void );
    void Set( const DX2DXFORM& Other ) { memcpy( this, &Other, sizeof(*this) ); DetermineOp(); }
    void ZeroMatrix( void ) { memset( this, 0, sizeof( *this ) ); }
    void SetIdentity( void ) {  
        eM11 = 1.;
        eM12 = 0.;
        eM21 = 0.;
        eM22 = 1.;
        eDx = 0.;
        eDy = 0.;
        eOp = DX2DXO_IDENTITY;
    }
    BOOL IsIdentity() const { return eOp == DX2DXO_IDENTITY; }
    void Scale( float sx, float sy );
    void Rotate( float Rotation );
    void Translate( float dx, float dy );
    BOOL Invert();
    void TransformBounds( const DXBNDS& Bnds, DXBNDS& ResultBnds ) const;
    void TransformPoints( const DXFPOINT InPnts[], DXFPOINT OutPnts[], ULONG ulCount ) const;
    void GetMinMaxScales( float& MinScale, float& MaxScale );

    /*--- operators ---*/
    DXFPOINT operator*( const DXFPOINT& v ) const;
    CDX2DXForm operator*( const CDX2DXForm& Other ) const;
};

//=== CDX2DXForm methods ==============================================================
inline void CDX2DXForm::DetermineOp( void )
{
    if( ( eM12 == 0. ) && ( eM21 == 0. ) )
    {
        if( ( eM11 == 1. ) && ( eM22 == 1. ) )
        {
            eOp = ( ( eDx == 0 ) && ( eDy == 0 ) )?(DX2DXO_IDENTITY):(DX2DXO_TRANSLATE);
        }
        else
        {
            eOp = ( ( eDx == 0 ) && ( eDy == 0 ) )?(DX2DXO_SCALE):(DX2DXO_SCALE_AND_TRANS);
        }
    }
    else
    {
        eOp = ( ( eDx == 0 ) && ( eDy == 0 ) )?(DX2DXO_GENERAL):(DX2DXO_GENERAL_AND_TRANS);
    }
} /* CDX2DXForm::DetermineOp */

inline float DXSq( float f ) { return f * f; }

// This function computes the Min and Max scale that a matrix represents.
// In other words, what is the maximum/minimum length that a line of length 1
// could get stretched/shrunk to if the line was transformed by this matrix.
//
// The function uses eigenvalues; and returns two float numbers. Both are
// non-negative; and MaxScale >= MinScale.
// 
inline void CDX2DXForm::GetMinMaxScales( float& MinScale, float& MaxScale )
{
    if( ( eM12 == 0. ) && ( eM21 == 0. ) )
    {
        // Let MinScale = abs(eM11)
        if (eM11 < 0)
            MinScale = -eM11;
        else
            MinScale = eM11;

        // Let MaxScale = abs(eM22)
        if (eM22 < 0)
            MaxScale = -eM22;
        else
            MaxScale = eM22;

        // Swap Min/Max if necessary
        if (MinScale > MaxScale)
        {
            float flTemp = MinScale;
            MinScale = MaxScale;
            MaxScale = flTemp;
        }
    }
    else
    {
        float t1 = DXSq(eM11) + DXSq(eM12) + DXSq(eM21) + DXSq(eM22);
        if( t1 == 0. )
        {
            MinScale = MaxScale = 0;
        }
        else
        {
            float t2 = (float)sqrt( (DXSq(eM12 + eM21) + DXSq(eM11 - eM22)) *
                                    (DXSq(eM12 - eM21) + DXSq(eM11 + eM22)) );

            // Due to floating point error; t1 may end up less than t2;
            // but that would mean that the min scale was small (relative
            // to max scale)
            if (t1 <= t2)
                MinScale = 0;
            else
                MinScale = (float)sqrt( (t1 - t2) * .5f );

            MaxScale = (float)sqrt( (t1 + t2) * .5f );
        }
    }
} /* CDX2DXForm::GetMinMaxScales */

inline void CDX2DXForm::Rotate( float Rotation )
{
    double Angle = Rotation * (3.1415926535/180.0);
    float CosZ   = (float)cos( Angle );
    float SinZ   = (float)sin( Angle );
    if (CosZ > 0.0F && CosZ < 0.0000005F)
    {
        CosZ = .0F;
    }
    if (SinZ > -0.0000005F && SinZ < .0F)
    {
        SinZ = .0F;
    }

    float M11 = ( CosZ * eM11 ) + ( SinZ * eM21 ); 
    float M21 = (-SinZ * eM11 ) + ( CosZ * eM21 );
    float M12 = ( CosZ * eM12 ) + ( SinZ * eM22 ); 
    float M22 = (-SinZ * eM12 ) + ( CosZ * eM22 );
    eM11 = M11; eM21 = M21; eM12 = M12; eM22 = M22;
    DetermineOp();
} /* CDX2DXForm::Rotate */

inline void CDX2DXForm::Scale( float sx, float sy )
{
    eM11 *= sx;
    eM12 *= sx;
    eDx  *= sx;
    eM21 *= sy;
    eM22 *= sy;
    eDy  *= sy;
    DetermineOp();
} /* CDX2DXForm::Scale */

inline void CDX2DXForm::Translate( float dx, float dy )
{
    eDx += dx;
    eDy += dy;
    DetermineOp();
} /* CDX2DXForm::Translate */

inline void CDX2DXForm::TransformBounds( const DXBNDS& Bnds, DXBNDS& ResultBnds ) const
{
    ResultBnds = Bnds;
    if( eOp != DX2DXO_IDENTITY )
    {
        ResultBnds.u.D[DXB_X].Min = (long)(( eM11 * Bnds.u.D[DXB_X].Min ) + ( eM12 * Bnds.u.D[DXB_Y].Min ) + eDx);
        ResultBnds.u.D[DXB_X].Max = (long)(( eM11 * Bnds.u.D[DXB_X].Max ) + ( eM12 * Bnds.u.D[DXB_Y].Max ) + eDx);
        ResultBnds.u.D[DXB_Y].Min = (long)(( eM21 * Bnds.u.D[DXB_X].Min ) + ( eM22 * Bnds.u.D[DXB_Y].Min ) + eDy);
        ResultBnds.u.D[DXB_Y].Max = (long)(( eM21 * Bnds.u.D[DXB_X].Max ) + ( eM22 * Bnds.u.D[DXB_Y].Max ) + eDy);
    }
} /* CDX2DXForm::TransformBounds */

inline void CDX2DXForm::TransformPoints( const DXFPOINT InPnts[], DXFPOINT OutPnts[], ULONG ulCount ) const
{
    ULONG i;
    switch( eOp )
    {
      case DX2DXO_IDENTITY:
        memcpy( OutPnts, InPnts, ulCount * sizeof( DXFPOINT ) );
        break;
      case DX2DXO_TRANSLATE:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = InPnts[i].x + eDx;
            OutPnts[i].y = InPnts[i].y + eDy;
        }
        break;
      case DX2DXO_SCALE:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = InPnts[i].x * eM11;
            OutPnts[i].y = InPnts[i].y * eM22;
        }
        break;
      case DX2DXO_SCALE_AND_TRANS:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = (InPnts[i].x * eM11) + eDx;
            OutPnts[i].y = (InPnts[i].y * eM22) + eDy;
        }
        break;
      case DX2DXO_GENERAL:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = ( InPnts[i].x * eM11 ) + ( InPnts[i].y * eM12 );
            OutPnts[i].y = ( InPnts[i].x * eM21 ) + ( InPnts[i].y * eM22 );
        }
        break;
      case DX2DXO_GENERAL_AND_TRANS:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = ( InPnts[i].x * eM11 ) + ( InPnts[i].y * eM12 ) + eDx;
            OutPnts[i].y = ( InPnts[i].x * eM21 ) + ( InPnts[i].y * eM22 ) + eDy;
        }
        break;
      default:
        _ASSERT( 0 );   // invalid operation id
    }
} /* CDX2DXForm::TransformPoints */

inline DXFPOINT CDX2DXForm::operator*( const DXFPOINT& v ) const
{
    DXFPOINT NewPnt;
    NewPnt.x = ( v.x * eM11 ) + ( v.y * eM12 ) + eDx;
    NewPnt.y = ( v.x * eM21 ) + ( v.y * eM22 ) + eDy;
    return NewPnt;
} /* CDX2DXForm::operator* */

inline CDX2DXForm CDX2DXForm::operator*( const CDX2DXForm& Other ) const
{
    DX2DXFORM x;
    x.eM11 = ( eM11 * Other.eM11 ) + ( eM12 * Other.eM21 );
    x.eM12 = ( eM11 * Other.eM12 ) + ( eM12 * Other.eM22 );
    x.eDx  = ( eM11 * Other.eDx  ) + ( eM12 * Other.eDy  ) + eDx;

    x.eM21 = ( eM21 * Other.eM11 ) + ( eM22 * Other.eM21 );
    x.eM22 = ( eM21 * Other.eM12 ) + ( eM22 * Other.eM22 );
    x.eDy  = ( eM21 * Other.eDx  ) + ( eM22 * Other.eDy  ) + eDy;
    return x;
} /* CDX2DXForm::operator*= */

inline BOOL CDX2DXForm::Invert()
{
    switch( eOp )
    {
    case DX2DXO_IDENTITY:
        break;
    case DX2DXO_TRANSLATE:
        eDx = -eDx;
        eDy = -eDy;
        break;
    case DX2DXO_SCALE:

        if (eM11 == 0.0 || eM22 == 0.0)
            return false;
        eM11 = 1.0f / eM11;
        eM22 = 1.0f / eM22;
        break;

    case DX2DXO_SCALE_AND_TRANS:
        {
            if (eM11 == 0.0f || eM22 == 0.0f)
                return false;

            // Our old equation was F = aG + b
            // The inverse is G = F/a - b/a where a is eM11 and b is eDx
            float flOneOverA = 1.0f / eM11;
            eDx = -eDx * flOneOverA;
            eM11 = flOneOverA;

            // Our old equation was F = aG + b
            // The inverse is G = F/a - b/a where a is eM22 and b is eDy

            flOneOverA = 1.0f / eM22;
            eDy = -eDy * flOneOverA;
            eM22 = flOneOverA;
            break;
        }

    case DX2DXO_GENERAL:
    case DX2DXO_GENERAL_AND_TRANS:
        {
            // The inverse of A=  |a b| is | d -c|*(1/Det) where Det is the determinant of A
            //                    |c d|    |-b  a|
            // Det(A) = ad - bc

            // Compute determininant
            float flDet = (eM11 * eM22 -  eM12 * eM21);
            if (flDet == 0.0f)
                return FALSE;

            float flCoef = 1.0f / flDet;

            // Remember old value of eM11
            float flM11Original = eM11;

            eM11 = flCoef * eM22;
            eM12 = -flCoef * eM12;
            eM21 = -flCoef * eM21;
            eM22 = flCoef * flM11Original;

            // If we have a translation; then we need to 
            // compute new values for that translation
            if (eOp == DX2DXO_GENERAL_AND_TRANS)
            {
                // Remember original value of eDx
                float eDxOriginal = eDx;

                eDx = -eM11 * eDx - eM12 * eDy;
                eDy = -eM21 * eDxOriginal - eM22 * eDy;
            }
        }
        break;

    default:
        _ASSERT( 0 );   // invalid operation id
    }

    // We don't need to call DetermineOp here
    // because the op doesn't change when inverted
    // i.e. a scale remains a scale, etc.

    return true;
} /* CDX2DXForm::Invert */

/*** CDXMatrix4x4F ************
*   This class implements basic matrix operation based on a 4x4 array.
*/
//const float g_DXMat4X4Identity[4][4] =
//{
//    { 1.0, 0. , 0. , 0.  },
//    { 0. , 1.0, 0. , 0.  },
//    { 0. , 0. , 1.0, 0.  },
//    { 0. , 0. , 0. , 1.0 }
//};

class CDXMatrix4x4F
{
public:
  /*=== Member Data ===*/
    float m_Coeff[4][4];

  /*=== Methods =======*/
public:
    /*--- Constructors ---*/
    CDXMatrix4x4F() { SetIdentity(); }
    CDXMatrix4x4F( const CDXMatrix4x4F& Other )
        { CopyMemory( (void *)&m_Coeff, (void *)&Other.m_Coeff, sizeof(m_Coeff) ); }
    CDXMatrix4x4F( DX2DXFORM& XForm );

    /*--- operations ---*/
    void ZeroMatrix( void ) { memset( m_Coeff, 0, sizeof( m_Coeff ) ); }
    void SetIdentity( void ) {
        memset( m_Coeff, 0, sizeof( m_Coeff ) );
        m_Coeff[0][0] = m_Coeff[1][1] = m_Coeff[2][2] = m_Coeff[3][3] = 1.0;
    }
    void SetCoefficients( float Coeff[4][4] ) { memcpy( m_Coeff, Coeff, sizeof( m_Coeff )); }
    void GetCoefficients( float Coeff[4][4] ) { memcpy( Coeff, m_Coeff, sizeof( m_Coeff )); }

    //BOOL IsIdentity();
    void Scale( float sx, float sy, float sz );
    void Rotate( float rx, float ry, float rz );
    void Translate( float dx, float dy, float dz );
    BOOL Invert();
    BOOL GetInverse( CDXMatrix4x4F *pIn );
    void Transpose();
    void GetTranspose( CDXMatrix4x4F *pIn );
    void GetAdjoint( CDXMatrix4x4F *pIn );
    HRESULT InitFromSafeArray( SAFEARRAY *psa );
    HRESULT GetSafeArray( SAFEARRAY **ppsa ) const;
    void TransformBounds( DXBNDS& Bnds, DXBNDS& ResultBnds );

    /*--- operators ---*/
    CDXDVec operator*( CDXDVec& v) const;
    CDXCVec operator*( CDXCVec& v) const;
    CDXMatrix4x4F operator*(CDXMatrix4x4F Matrix) const;
    void operator*=(CDXMatrix4x4F Matrix) const;
    void CDXMatrix4x4F::operator=(const CDXMatrix4x4F srcMatrix);
    void CDXMatrix4x4F::operator+=(const CDXMatrix4x4F otherMatrix);
    void CDXMatrix4x4F::operator-=(const CDXMatrix4x4F otherMatrix);
    BOOL CDXMatrix4x4F::operator==(const CDXMatrix4x4F otherMatrix) const;
    BOOL CDXMatrix4x4F::operator!=(const CDXMatrix4x4F otherMatrix) const;
};

inline CDXMatrix4x4F::CDXMatrix4x4F( DX2DXFORM& XForm )
{
    SetIdentity();
    m_Coeff[0][0] = XForm.eM11;
    m_Coeff[0][1] = XForm.eM12;
    m_Coeff[1][0] = XForm.eM21;
    m_Coeff[1][1] = XForm.eM22;
    m_Coeff[0][3] = XForm.eDx;
    m_Coeff[1][3] = XForm.eDy;
}

// Additional Operations

inline void CDXMatrix4x4F::operator=(const CDXMatrix4x4F srcMatrix)
{
    CopyMemory( (void *)m_Coeff, (const void *)srcMatrix.m_Coeff, sizeof(srcMatrix.m_Coeff) );
} /* CDXMatrix4x4F::operator= */

inline BOOL CDXMatrix4x4F::operator==(const CDXMatrix4x4F otherMatrix) const
{
    return !memcmp( (void *)m_Coeff, (const void *)otherMatrix.m_Coeff, sizeof(otherMatrix.m_Coeff) );
} /* CDXMatrix4x4F::operator== */

inline BOOL CDXMatrix4x4F::operator!=(const CDXMatrix4x4F otherMatrix) const
{
    return memcmp( (void *)m_Coeff, (const void *)otherMatrix.m_Coeff, sizeof(otherMatrix.m_Coeff) );
} /* CDXMatrix4x4F::operator!= */

inline void CDXMatrix4x4F::operator+=(const CDXMatrix4x4F otherMatrix)
{
    for( int i = 0; i < 4; i++ )
        for( int j = 0; j < 4; j++ )
            m_Coeff[i][j] += otherMatrix.m_Coeff[i][j];
} /* CDXMatrix4x4F::operator+= */

inline void CDXMatrix4x4F::operator-=(const CDXMatrix4x4F otherMatrix) 
{
    for( int i = 0; i < 4; i++ )
        for( int j = 0; j < 4; j++ )
            m_Coeff[i][j] -= otherMatrix.m_Coeff[i][j];
} /* CDXMatrix4x4F::operator-= */

inline CDXDVec CDXMatrix4x4F::operator*(CDXDVec& v) const
{
    CDXDVec t;
    float temp;
    temp = v[0]*m_Coeff[0][0]+v[1]*m_Coeff[1][0]+v[2]*m_Coeff[2][0]+v[3]*m_Coeff[3][0];
    t[0] = (long)((temp < 0) ? temp -= .5 : temp += .5);
    temp = v[0]*m_Coeff[0][1]+v[1]*m_Coeff[1][1]+v[2]*m_Coeff[2][1]+v[3]*m_Coeff[3][1];
    t[1] = (long)((temp < 0) ? temp -= .5 : temp += .5);
    temp = v[0]*m_Coeff[0][2]+v[1]*m_Coeff[1][2]+v[2]*m_Coeff[2][2]+v[3]*m_Coeff[3][2];
    t[2] = (long)((temp < 0) ? temp -= .5 : temp += .5);
    temp = v[0]*m_Coeff[0][3]+v[1]*m_Coeff[1][3]+v[2]*m_Coeff[2][3]+v[3]*m_Coeff[3][3];
    t[3] = (long)((temp < 0) ? temp -= .5 : temp += .5);
    return t;
} /* CDXMatrix4x4F::operator*(DXDVEC) */

inline CDXCVec CDXMatrix4x4F::operator*(CDXCVec& v) const
{
    CDXCVec t;
    t[0] = v[0]*m_Coeff[0][0]+v[1]*m_Coeff[1][0]+v[2]*m_Coeff[2][0]+v[3]*m_Coeff[3][0];
    t[1] = v[0]*m_Coeff[0][1]+v[1]*m_Coeff[1][1]+v[2]*m_Coeff[2][1]+v[3]*m_Coeff[3][1];
    t[2] = v[0]*m_Coeff[0][2]+v[1]*m_Coeff[1][2]+v[2]*m_Coeff[2][2]+v[3]*m_Coeff[3][2];
    t[3] = v[0]*m_Coeff[0][3]+v[1]*m_Coeff[1][3]+v[2]*m_Coeff[2][3]+v[3]*m_Coeff[3][3];
    return t;
} /* CDXMatrix4x4F::operator*(DXCVEC) */

inline CDXMatrix4x4F CDXMatrix4x4F::operator*(CDXMatrix4x4F Mx) const
{
    CDXMatrix4x4F t;
    int i, j;

    for( i = 0; i < 4; i++ )
    {
        for( j = 0; j < 4; j++ )
        {
            t.m_Coeff[i][j] =   m_Coeff[i][0] * Mx.m_Coeff[0][j] + 
                                m_Coeff[i][1] * Mx.m_Coeff[1][j] +
                                m_Coeff[i][2] * Mx.m_Coeff[2][j] +
                                m_Coeff[i][3] * Mx.m_Coeff[3][j];
        }
    }

    return t;
} /* CDXMatrix4x4F::operator*(CDXMatrix4x4F) */
            
inline void CDXMatrix4x4F::operator*=(CDXMatrix4x4F Mx) const
{
    CDXMatrix4x4F t;
    int i, j;

    for( i = 0; i < 4; i++ )
    {
        for( j = 0; j < 4; j++ )
        {
            t.m_Coeff[i][j] =   m_Coeff[i][0] * Mx.m_Coeff[0][j] + 
                                m_Coeff[i][1] * Mx.m_Coeff[1][j] +
                                m_Coeff[i][2] * Mx.m_Coeff[2][j] +
                                m_Coeff[i][3] * Mx.m_Coeff[3][j];
        }
    }

    CopyMemory( (void *)m_Coeff, (void *)t.m_Coeff, sizeof(m_Coeff) );
} /* CDXMatrix4x4F::operator*=(CDXMatrix4x4F) */
            

inline void CDXMatrix4x4F::Scale( float sx, float sy, float sz )
{
    if( sx != 1. )
    {
        m_Coeff[0][0] *= sx;
        m_Coeff[0][1] *= sx;
        m_Coeff[0][2] *= sx;
        m_Coeff[0][3] *= sx;
    }
    if( sy != 1. )
    {
        m_Coeff[1][0] *= sy;
        m_Coeff[1][1] *= sy;
        m_Coeff[1][2] *= sy;
        m_Coeff[1][3] *= sy;
    }
    if( sz != 1. )
    {
        m_Coeff[2][0] *= sz;
        m_Coeff[2][1] *= sz;
        m_Coeff[2][2] *= sz;
        m_Coeff[2][3] *= sz;
    }
} /* CDXMatrix4x4F::Scale */

inline void CDXMatrix4x4F::Translate( float dx, float dy, float dz )
{
    float a, b, c, d;
    a = b = c = d = 0;
    if( dx != 0. )
    {
        a += m_Coeff[0][0]*dx;
        b += m_Coeff[0][1]*dx;
        c += m_Coeff[0][2]*dx;
        d += m_Coeff[0][3]*dx;
    }
    if( dy != 0. )
    {
        a += m_Coeff[1][0]*dy;
        b += m_Coeff[1][1]*dy;
        c += m_Coeff[1][2]*dy;
        d += m_Coeff[1][3]*dy;
    }
    if( dz != 0. )
    {
        a += m_Coeff[2][0]*dz;
        b += m_Coeff[2][1]*dz;
        c += m_Coeff[2][2]*dz;
        d += m_Coeff[2][3]*dz;
    }
    m_Coeff[3][0] += a;
    m_Coeff[3][1] += b;
    m_Coeff[3][2] += c;
    m_Coeff[3][3] += d;
} /* CDXMatrix4x4F::Translate */

inline void CDXMatrix4x4F::Rotate( float rx, float ry, float rz )
{
    const float l_dfCte = (const float)(3.1415926535/180.0);

    float lAngleY = 0.0;
    float lAngleX = 0.0;
    float lAngleZ = 0.0;
    float lCosX = 1.0;
    float lSinX = 0.0;
    float lCosY = 1.0;
    float lSinY = 0.0;
    float lCosZ = 1.0;
    float lSinZ = 0.0;

    // calculate rotation angle sines and cosines
    if( rx != 0 )
    {
        lAngleX = rx * l_dfCte;
        lCosX = (float)cos(lAngleX);
        lSinX = (float)sin(lAngleX);
        if (lCosX > 0.0F && lCosX < 0.0000005F)
        {
            lCosX = .0F;
        }
        if (lSinX > -0.0000005F && lSinX < .0F)
        {
            lSinX = .0F;
        }
    }
    if( ry != 0 )
    {
        lAngleY = ry * l_dfCte;
        lCosY = (float)cos(lAngleY);
        lSinY = (float)sin(lAngleY);
        if (lCosY > 0.0F && lCosY < 0.0000005F)
        {
            lCosY = .0F;
        }
        if (lSinY > -0.0000005F && lSinY < .0F)
        {
            lSinY = .0F;
        }
    }
    if( rz != 0 )
    {
        lAngleZ = rz * l_dfCte;
        lCosZ = (float)cos(lAngleZ);
        lSinZ = (float)sin(lAngleZ);
        if (lCosZ > 0.0F && lCosZ < 0.0000005F)
        {
            lCosZ = .0F;
        }
        if (lSinZ > -0.0000005F && lSinZ < .0F)
        {
            lSinZ = .0F;
        }
    }

    float u, v;
    int i;

    //--- X Rotation
    for( i = 0; i < 4; i++ )
    {
        u = m_Coeff[1][i]; 
        v = m_Coeff[2][i];
        m_Coeff[1][i] = lCosX*u+lSinX*v; 
        m_Coeff[2][i] = -lSinX*u+lCosX*v;
    }

    //--- Y Rotation
    for( i = 0; i < 4; i++ )
    {
        u = m_Coeff[0][i];
        v = m_Coeff[2][i];
        m_Coeff[0][i] = lCosY*u-lSinY*v; 
        m_Coeff[2][i] = lSinY*u+lCosY*v;
    }

    //--- Z Rotation
    for( i = 0; i < 4; i++ )
    {
        u = m_Coeff[0][i];
        v = m_Coeff[1][i];
        m_Coeff[0][i] = lCosZ*u+lSinZ*v; 
        m_Coeff[1][i] = -lSinZ*u+lCosZ*v;
    }
}

/*
inline BOOL CDXMatrix4x4F::IsIdentity()
{
    return  !memcmp( m_Coeff, g_DXMat4X4Identity, sizeof(g_DXMat4X4Identity) );
} /* CDXMatrix4x4F::IsIdentity */


/*
   Uses Gaussian elimination to invert the 4 x 4 non-linear matrix in t and
   return the result in Mx.  The matrix t is destroyed in the process.
*/
inline BOOL CDXMatrix4x4F::Invert()
{
    int i,j,k,Pivot;
    float PValue;
    CDXMatrix4x4F Mx;
    Mx.SetIdentity();

/* Find pivot element.  Use partial pivoting by row */
    for( i = 0;i < 4; i++ )
    {
        Pivot = 0;
        for( j = 0; j < 4; j++ )
        {
            if( fabs(m_Coeff[i][j]) > fabs(m_Coeff[i][Pivot]) ) Pivot = j;
        }

        if( m_Coeff[i][Pivot] == 0.0 )
        {
            ZeroMatrix();   /* Singular Matrix */
            return FALSE; 
        }

/* Normalize */
        PValue = m_Coeff[i][Pivot];
        for( j = 0; j < 4; j++ )
        {
            m_Coeff[i][j] /= PValue;
            Mx.m_Coeff[i][j] /= PValue;
        }

/* Zeroing */
        for( j = 0; j < 4; j++ )
        {
            if( j != i )
            {
                PValue = m_Coeff[j][Pivot];
                for( k = 0; k < 4; k++ )
                {
                    m_Coeff[j][k] -= PValue*m_Coeff[i][k];
                    Mx.m_Coeff[j][k] -= PValue*Mx.m_Coeff[i][k];
                }
            }
        }
    }

/* Reorder rows */
    for( i = 0; i < 4; i++ )
    {
        if( m_Coeff[i][i] != 1.0 )
        {
            for( j = i + 1; j < 4; j++ )
                if( m_Coeff[j][i] == 1.0 ) break;
            if( j >= 4 )
            {
                ZeroMatrix();
                return FALSE;
            }

            //--- swap rows i and j of original
            for( k = 0; k < 4; k++ )
            {
                m_Coeff[i][k] += m_Coeff[j][k];
                m_Coeff[j][k] = m_Coeff[i][k] - m_Coeff[j][k];
                m_Coeff[i][k] -= m_Coeff[j][k];
            }
            
            //--- swap rows i and j of result
            for( k = 0; k < 4; k++ )
            {
                Mx.m_Coeff[i][k] += Mx.m_Coeff[j][k];
                Mx.m_Coeff[j][k] = Mx.m_Coeff[i][k] - Mx.m_Coeff[j][k];
                Mx.m_Coeff[i][k] -= Mx.m_Coeff[j][k];
            }
        }
    }
    *this = Mx;
    return TRUE;
} /* CDXMatrix4x4F::Invert */

inline void CDXMatrix4x4F::Transpose()
{
    float temp;

    temp = m_Coeff[0][1];
    m_Coeff[0][1] = m_Coeff[1][0];
    m_Coeff[1][0] = temp;

    temp = m_Coeff[0][2];
    m_Coeff[0][2] = m_Coeff[2][0];
    m_Coeff[2][0] = temp;

    temp = m_Coeff[0][3];
    m_Coeff[0][3] = m_Coeff[3][0];
    m_Coeff[3][0] = temp;

    temp = m_Coeff[1][2];
    m_Coeff[1][2] = m_Coeff[2][1];
    m_Coeff[2][1] = temp;

    temp = m_Coeff[1][3];
    m_Coeff[1][3] = m_Coeff[3][1];
    m_Coeff[3][1] = temp;

    temp = m_Coeff[2][3];
    m_Coeff[2][3] = m_Coeff[3][2];
    m_Coeff[3][2] = temp;

} /* CDXMatrix4x4F::Transpose */

inline void CDXMatrix4x4F::GetTranspose( CDXMatrix4x4F *m )
{
    float temp;

    (*this) = *m;

    temp = m_Coeff[0][1];
    m_Coeff[0][1] = m_Coeff[1][0];
    m_Coeff[1][0] = temp;

    temp = m_Coeff[0][2];
    m_Coeff[0][2] = m_Coeff[2][0];
    m_Coeff[2][0] = temp;

    temp = m_Coeff[0][3];
    m_Coeff[0][3] = m_Coeff[3][0];
    m_Coeff[3][0] = temp;

    temp = m_Coeff[1][2];
    m_Coeff[1][2] = m_Coeff[2][1];
    m_Coeff[2][1] = temp;

    temp = m_Coeff[1][3];
    m_Coeff[1][3] = m_Coeff[3][1];
    m_Coeff[3][1] = temp;

    temp = m_Coeff[2][3];
    m_Coeff[2][3] = m_Coeff[3][2];
    m_Coeff[3][2] = temp;

} /* CDXMatrix4x4F::Transpose */


/*
Matrix Inversion
by Richard Carling
from "Graphics Gems", Academic Press, 1990
*/

#define SMALL_NUMBER    1.e-8
/* 
 *   inverse( original_matrix, inverse_matrix )
 * 
 *    calculate the inverse of a 4x4 matrix
 *
 *     -1     
 *     A  = ___1__ adjoint A
 *         det A
 */

inline BOOL CDXMatrix4x4F::GetInverse( CDXMatrix4x4F *pIn )
{
    int i, j;
    float det;

    /* calculate the adjoint matrix */

    GetAdjoint( pIn );

    /*  calculate the 4x4 determinant
     *  if the determinant is zero, 
     *  then the inverse matrix is not unique.
     */

    det = det4x4( pIn );

    if( fabs( det ) < SMALL_NUMBER )
    {
        //  Non-singular matrix, no inverse!
        return FALSE;;
    }

    /* scale the adjoint matrix to get the inverse */

    for( i = 0; i < 4; i++ )
        for( j = 0; j < 4; j++ )
            m_Coeff[i][j] = m_Coeff[i][j] / det;

    return TRUE;
}


/* 
 *   adjoint( original_matrix, inverse_matrix )
 * 
 *     calculate the adjoint of a 4x4 matrix
 *
 *      Let  a   denote the minor determinant of matrix A obtained by
 *           ij
 *
 *      deleting the ith row and jth column from A.
 *
 *                    i+j
 *     Let  b   = (-1)    a
 *          ij            ji
 *
 *    The matrix B = (b  ) is the adjoint of A
 *                     ij
 */
inline void CDXMatrix4x4F::GetAdjoint( CDXMatrix4x4F *pIn )
{
    float a1, a2, a3, a4, b1, b2, b3, b4;
    float c1, c2, c3, c4, d1, d2, d3, d4;

    /* assign to individual variable names to aid  */
    /* selecting correct values  */

    a1 = pIn->m_Coeff[0][0]; b1 = pIn->m_Coeff[0][1]; 
    c1 = pIn->m_Coeff[0][2]; d1 = pIn->m_Coeff[0][3];

    a2 = pIn->m_Coeff[1][0]; b2 = pIn->m_Coeff[1][1]; 
    c2 = pIn->m_Coeff[1][2]; d2 = pIn->m_Coeff[1][3];

    a3 = pIn->m_Coeff[2][0]; b3 = pIn->m_Coeff[2][1];
    c3 = pIn->m_Coeff[2][2]; d3 = pIn->m_Coeff[2][3];

    a4 = pIn->m_Coeff[3][0]; b4 = pIn->m_Coeff[3][1]; 
    c4 = pIn->m_Coeff[3][2]; d4 = pIn->m_Coeff[3][3];


    /* row column labeling reversed since we transpose rows & columns */

    m_Coeff[0][0]  =   det3x3( b2, b3, b4, c2, c3, c4, d2, d3, d4);
    m_Coeff[1][0]  = - det3x3( a2, a3, a4, c2, c3, c4, d2, d3, d4);
    m_Coeff[2][0]  =   det3x3( a2, a3, a4, b2, b3, b4, d2, d3, d4);
    m_Coeff[3][0]  = - det3x3( a2, a3, a4, b2, b3, b4, c2, c3, c4);
        
    m_Coeff[0][1]  = - det3x3( b1, b3, b4, c1, c3, c4, d1, d3, d4);
    m_Coeff[1][1]  =   det3x3( a1, a3, a4, c1, c3, c4, d1, d3, d4);
    m_Coeff[2][1]  = - det3x3( a1, a3, a4, b1, b3, b4, d1, d3, d4);
    m_Coeff[3][1]  =   det3x3( a1, a3, a4, b1, b3, b4, c1, c3, c4);
        
    m_Coeff[0][2]  =   det3x3( b1, b2, b4, c1, c2, c4, d1, d2, d4);
    m_Coeff[1][2]  = - det3x3( a1, a2, a4, c1, c2, c4, d1, d2, d4);
    m_Coeff[2][2]  =   det3x3( a1, a2, a4, b1, b2, b4, d1, d2, d4);
    m_Coeff[3][2]  = - det3x3( a1, a2, a4, b1, b2, b4, c1, c2, c4);
        
    m_Coeff[0][3]  = - det3x3( b1, b2, b3, c1, c2, c3, d1, d2, d3);
    m_Coeff[1][3]  =   det3x3( a1, a2, a3, c1, c2, c3, d1, d2, d3);
    m_Coeff[2][3]  = - det3x3( a1, a2, a3, b1, b2, b3, d1, d2, d3);
    m_Coeff[3][3]  =   det3x3( a1, a2, a3, b1, b2, b3, c1, c2, c3);
}
/*
 * float = det4x4( matrix )
 * 
 * calculate the determinant of a 4x4 matrix.
 */
inline float det4x4( CDXMatrix4x4F *pIn )
{
    float ans;
    float a1, a2, a3, a4, b1, b2, b3, b4, c1, c2, c3, c4, d1, d2, d3, d4;

    /* assign to individual variable names to aid selecting */
    /*  correct elements */

    a1 = pIn->m_Coeff[0][0]; b1 = pIn->m_Coeff[0][1]; 
    c1 = pIn->m_Coeff[0][2]; d1 = pIn->m_Coeff[0][3];

    a2 = pIn->m_Coeff[1][0]; b2 = pIn->m_Coeff[1][1]; 
    c2 = pIn->m_Coeff[1][2]; d2 = pIn->m_Coeff[1][3];

    a3 = pIn->m_Coeff[2][0]; b3 = pIn->m_Coeff[2][1]; 
    c3 = pIn->m_Coeff[2][2]; d3 = pIn->m_Coeff[2][3];

    a4 = pIn->m_Coeff[3][0]; b4 = pIn->m_Coeff[3][1]; 
    c4 = pIn->m_Coeff[3][2]; d4 = pIn->m_Coeff[3][3];

    ans = a1 * det3x3( b2, b3, b4, c2, c3, c4, d2, d3, d4 )
        - b1 * det3x3( a2, a3, a4, c2, c3, c4, d2, d3, d4 )
        + c1 * det3x3( a2, a3, a4, b2, b3, b4, d2, d3, d4 )
        - d1 * det3x3( a2, a3, a4, b2, b3, b4, c2, c3, c4 );
    return ans;
}

/*
 * float = det3x3(  a1, a2, a3, b1, b2, b3, c1, c2, c3 )
 * 
 * calculate the determinant of a 3x3 matrix
 * in the form
 *
 *     | a1,  b1,  c1 |
 *     | a2,  b2,  c2 |
 *     | a3,  b3,  c3 |
 */

inline float det3x3( float a1, float a2, float a3, 
                     float b1, float b2, float b3, 
                     float c1, float c2, float c3 )
{
    float ans;

    ans = a1 * det2x2( b2, b3, c2, c3 )
        - b1 * det2x2( a2, a3, c2, c3 )
        + c1 * det2x2( a2, a3, b2, b3 );
    return ans;
}

/*
 * float = det2x2( float a, float b, float c, float d )
 * 
 * calculate the determinant of a 2x2 matrix.
 */
inline float det2x2( float a, float b, float c, float d )
{
    float ans = a * d - b * c;
    return ans;
}

inline HRESULT CDXMatrix4x4F::InitFromSafeArray( SAFEARRAY * /*pSA*/ )
{
    HRESULT hr = S_OK;
#if 0
    long *pData;

    if( !pSA || ( pSA->cDims != 1 ) ||
         ( pSA->cbElements != sizeof(float) ) ||
         ( pSA->rgsabound->lLbound   != 1 ) ||
         ( pSA->rgsabound->cElements != 8 ) 
      )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = SafeArrayAccessData(pSA, (void **)&pData);

        if( SUCCEEDED( hr ) )
        {
            for( int i = 0; i < 4; ++i )
            {
                m_Bounds[i].Min = pData[i];
                m_Bounds[i].Max = pData[i+4];
                m_Bounds[i].SampleRate = SampleRate;
            }

            hr = SafeArrayUnaccessData( pSA );
        }
    }
#endif
    return hr;
} /* CDXMatrix4x4F::InitFromSafeArray */

inline HRESULT CDXMatrix4x4F::GetSafeArray( SAFEARRAY ** /*ppSA*/ ) const
{
    HRESULT hr = S_OK;
#if 0
    SAFEARRAY *pSA;

    if( !ppSA )
    {
        hr = E_POINTER;
    }
    else
    {
        SAFEARRAYBOUND rgsabound;
        rgsabound.lLbound   = 1;
        rgsabound.cElements = 16;

        if( !(pSA = SafeArrayCreate( VT_I4, 1, &rgsabound ) ) )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            long *pData;
            hr = SafeArrayAccessData( pSA, (void **)&pData );

            if( SUCCEEDED( hr ) )
            {
                for( int i = 0; i < 4; ++i )
                {
                    pData[i]   = m_Bounds[i].Min;
                    pData[i+4] = m_Bounds[i].Max;
                }

                hr = SafeArrayUnaccessData( pSA );
            }
        }

        if( SUCCEEDED( hr ) )
        {
            *ppSA = pSA;
        }
    }
#endif
    return hr;
} /* CDXMatrix4x4F::GetSafeArray */

inline void CDXMatrix4x4F::TransformBounds( DXBNDS& /*Bnds*/, DXBNDS& /*ResultBnds*/ )
{

} /* CDXMatrix4x4F::TransformBounds */



#endif   // __DXTPRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdbase\baseerr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       baseerr.cxx
//
//  Contents:   CBase error utilties implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_OLECTL_H_
#define X_OLECTL_H_
#include <olectl.h>
#endif

//+---------------------------------------------------------------------------
//
//  Method:     CBase::SetErrorInfo
//
//  Synopsis:
//
//
//----------------------------------------------------------------------------

HRESULT
CBase::SetErrorInfo(HRESULT hr)
{
    PreSetErrorInfo();

    if (FAILED(hr))
    {
        ClearErrorInfo();
        CloseErrorInfo(hr);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBase::SetErrorInfoPGet
//
//----------------------------------------------------------------------------

HRESULT
CBase::SetErrorInfoPGet(HRESULT hr, DISPID dispid)
{
    // No PreSetErrorInfo call needed on read-only operations.

    if (FAILED(hr))
    {
        ClearErrorInfo();
        CloseErrorInfoPGet(hr, dispid);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBase::SetErrorInfoPSet
//
//----------------------------------------------------------------------------

HRESULT
CBase::SetErrorInfoPSet(HRESULT hr, DISPID dispid)
{
    PreSetErrorInfo();

    if (FAILED(hr))
    {
        if (hr == E_INVALIDARG)
        {
            hr = CTL_E_INVALIDPROPERTYVALUE;
        }
        ClearErrorInfo();
        CloseErrorInfoPSet(hr, dispid);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBase::CloseErrorInfo
//
//  Synopsis:
//
//
//----------------------------------------------------------------------------

HRESULT
CBase::CloseErrorInfo(HRESULT hr)
{
    if (FAILED(hr))
    {
        Assert(BaseDesc()->_pclsid );
        ::CloseErrorInfo(hr, (BaseDesc()->_pclsid ? *BaseDesc()->_pclsid : 
                                                    CLSID_NULL));
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBase::CloseErrorInfo
//
//  Specific method for automation calls
//
//----------------------------------------------------------------------------

HRESULT
CBase::CloseErrorInfo(HRESULT hr, DISPID dispid, INVOKEKIND invkind)
{
    CErrorInfo *pEI;

    if (OK(hr))
        return hr;

    if ((pEI = GetErrorInfo()) != NULL)
    {
        pEI->_invkind = invkind;
        pEI->_dispidInvoke = dispid;
        if ( BaseDesc()->_piidDispinterface )
        {
            pEI -> _iidInvoke = *BaseDesc()->_piidDispinterface;
        }
        else
        {
            // rgardner If we don't have an IID what do we
            // do????
            return S_FALSE;
        }
    }

    return CloseErrorInfo(hr);
}


//+---------------------------------------------------------------------------
//
//  Method:     CBase::SetErrorInfo
//
//----------------------------------------------------------------------------

HRESULT __cdecl
CBase::SetErrorInfo(HRESULT hr, DISPID dispid, INVOKEKIND invkind, UINT ids, ...)
{
    PreSetErrorInfo();

    va_list arg;
    CErrorInfo *pEI;

    ClearErrorInfo();

    if(ids && (pEI = GetErrorInfo()) != NULL)
    {
        va_start(arg, ids);
        pEI->SetTextV(EPART_SOLUTION, ids, &arg);
        va_end(arg);
    }

    return CloseErrorInfo(hr, dispid, invkind);
}

//+---------------------------------------------------------------------------
//
//  Method:     CBase::SetErrorInfoBadValue
//
//----------------------------------------------------------------------------

HRESULT __cdecl
CBase::SetErrorInfoBadValue(DISPID dispid, UINT ids, ...)
{
    PreSetErrorInfo();

    va_list arg;
    CErrorInfo *pEI;

    ClearErrorInfo();

    if (ids && (pEI = GetErrorInfo()) != NULL)
    {
        va_start(arg, ids);
        pEI->SetTextV(EPART_SOLUTION, ids, &arg);
        va_end(arg);
    }

    return CloseErrorInfoPSet(E_INVALIDARG, dispid);
}


//+---------------------------------------------------------------------------
//
//  Method:     CBase::SetErrorInfoPBadValue
//
//----------------------------------------------------------------------------

HRESULT __cdecl
CBase::SetErrorInfoPBadValue(DISPID dispid, UINT ids, ...)
{
    PreSetErrorInfo();

    va_list arg;
    CErrorInfo *pEI;

    ClearErrorInfo();

    if (ids && (pEI = GetErrorInfo()) != NULL)
    {
        va_start(arg, ids);
        pEI->SetTextV(EPART_SOLUTION, ids, &arg);
        va_end(arg);
    }

    return CloseErrorInfoPSet(CTL_E_INVALIDPROPERTYVALUE, dispid);
}


//+---------------------------------------------------------------------------
//
//  Method:     CBase::SetErrorInfoInvalidArg
//
//----------------------------------------------------------------------------

HRESULT
CBase::SetErrorInfoInvalidArg()
{
    PreSetErrorInfo();

    ClearErrorInfo();
    return CloseErrorInfo(E_INVALIDARG);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdbase\base.cxx ===
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       base.cxx
//
//  Contents:   CBase implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ATOMTBL_HXX_
#define X_ATOMTBL_HXX_
#include "atomtbl.hxx"
#endif

#ifndef X_TYPENAV_HXX_
#define X_TYPENAV_HXX_
#include "typenav.hxx"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_DISPEX_H_
#define X_DISPEX_H_
#include <dispex.h>
#endif

#ifndef X_ACTIVSCP_H_
#define X_ACTIVSCP_H_
#include <activscp.h>
#endif

#ifndef X_OLECTL_H_
#define X_OLECTL_H_
#include <olectl.h>
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

// This files is generated from the pdlparse /G to produce the table of handlers
// and the handler functions themselves.
#ifndef X_FUNCSIG_HXX_
#define X_FUNCSIG_HXX_
#include "funcsig.hxx"
#endif

#ifndef X_NCACHE_HXX_
#define X_NCACHE_HXX_
#include "ncache.hxx"
#endif

// Include headers from that PDLParser generated for DISPIDs and IHTMLDocument2
#include "document.h"
#include "window.h"

#pragma warning(disable: 4189)  /* local variable is initialized but not referenced */
#pragma warning(disable: 4701)  /* local variable may be used without having been initialized */
#include <funcsig.cxx>

EXTERN_C const GUID CLSID_HTMLWindow2;

#ifdef COMPLUS_SHIM
#include <funcND.cpp>

#endif	// COMPLUS_SHIM

#pragma warning(default: 4701)
#pragma warning(default: 4189)

DeclareTag(tagOleAutomation, "OleAuto", "Enable OLE automation Invoke");
DeclareTag(tagInvokeTrace, "OleAuto", "Trace custom invoke calls (slow...)");
DeclareTag(tagDisableLockAR, "Lock", "Disable AddRef/Release in locks")

PerfDbgExtern(tagPerfWatch)

MtDefine(CFunctionPointer, ObjectModel, "CFunctionPointer")
MtDefine(CBaseFireEventAry_pv, Locals, "CBase::FireEvent stack ptr array")
MtDefine(CBaseFireTypeAry_pv, Locals, "CBase::FireType stack data array")
MtDefine(CBaseFirePropertyNotify_pv, Locals, "CBase::FirePropertyNotify ptr array")
MtDefine(CDispParams, ObjectModel, "CDispParms")
MtDefine(CDispParams_rgvarg, CDispParams, "CDispParams::rgvarg")
MtDefine(CDispParams_rgdispidNamedArgs, CDispParams, "CDispParams::rgdispidNamedArgs")

const IID * const g_apIID_IDispatchEx[] = { &IID_IDispatchEx, &IID_IDispatch, NULL };
extern BOOL g_fInVizAct2000;


BEGIN_TEAROFF_TABLE(CBase, IDispatchEx)
    //  IDispatch methods
    TEAROFF_METHOD(CBase, GetTypeInfoCount, gettypeinfocount, (UINT *pcTinfo))
    TEAROFF_METHOD(CBase, GetTypeInfo, gettypeinfo, (UINT itinfo, ULONG lcid, ITypeInfo ** ppTI))
    TEAROFF_METHOD(CBase, GetIDsOfNames, getidsofnames, (REFIID riid,
                                   LPOLESTR *prgpsz,
                                   UINT cpsz,
                                   LCID lcid,
                                   DISPID *prgid))
    TEAROFF_METHOD(CBase, Invoke, invoke, (DISPID dispidMember,
                            REFIID riid,
                            LCID lcid,
                            WORD wFlags,
                            DISPPARAMS * pdispparams,
                            VARIANT * pvarResult,
                            EXCEPINFO * pexcepinfo,
                            UINT * puArgErr))

    TEAROFF_METHOD(CBase, GetDispID, getdispid, (BSTR bstrName,
                               DWORD grfdex,
                               DISPID *pid))

    TEAROFF_METHOD(CBase, InvokeEx, invokeex, (DISPID id,
                        LCID lcid,
                        WORD wFlags,
                        DISPPARAMS *pdp,
                        VARIANT *pvarRes,
                        EXCEPINFO *pei,
                        IServiceProvider *pSrvProvider)) 
            
    TEAROFF_METHOD(CBase, DeleteMemberByName, deletememberbyname, (BSTR bstr,DWORD grfdex))
    TEAROFF_METHOD(CBase, DeleteMemberByDispID, deletememberbydispid, (DISPID id))    
    TEAROFF_METHOD(CBase, GetMemberProperties, getmemberproperties, (DISPID id,
                                         DWORD grfdexFetch,
                                         DWORD *pgrfdex))
    TEAROFF_METHOD(CBase, GetMemberName, getmembername, (DISPID id,
                                   BSTR *pbstrName))
    TEAROFF_METHOD(CBase, GetNextDispID, getnextdispid, (DWORD grfdex,
                                   DISPID id,
                                   DISPID *pid))
    TEAROFF_METHOD(CBase, GetNameSpaceParent, getnamespaceparent, (IUnknown **ppunk))
END_TEAROFF_TABLE()


BEGIN_TEAROFF_TABLE(CBase, IProvideMultipleClassInfo)
    TEAROFF_METHOD(CBase, GetClassInfo, getclassinfo, (ITypeInfo ** ppTI))
    TEAROFF_METHOD(CBase, GetGUID, getguid, (DWORD dwGuidKind, GUID * pGUID))
    TEAROFF_METHOD(CBase, GetMultiTypeInfoCount, getmultitypeinfocount, (ULONG *pcti))
    TEAROFF_METHOD(CBase, GetInfoOfIndex, getinfoofindex, (
            ULONG iti,
            DWORD dwFlags,
            ITypeInfo** pptiCoClass,
            DWORD* pdwTIFlags,
            ULONG* pcdispidReserved,
            IID* piidPrimary,
            IID* piidSource))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CBase, ISupportErrorInfo)
    TEAROFF_METHOD(CBase, InterfaceSupportsErrorInfo, interfacesupportserrorinfo, (REFIID iid))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CBase, IOleCommandTarget)
    TEAROFF_METHOD(CBase, QueryStatus, querystatus, (GUID * pguidCmdGroup, ULONG cCmds, MSOCMD rgCmds[], MSOCMDTEXT * pcmdtext))
    TEAROFF_METHOD(CBase, Exec, exec, (GUID * pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG * pvarargIn, VARIANTARG * pvarargOut))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CBase, ISpecifyPropertyPages)
    TEAROFF_METHOD(CBase, GetPages, getpages, (CAUUID * pPages))
END_TEAROFF_TABLE()


BEGIN_TEAROFF_TABLE(CBase, IObjectIdentity)
    TEAROFF_METHOD(CBase, IsEqualObject, isequalobject, (IUnknown*))
END_TEAROFF_TABLE()


// NOTE: Tearoff table for CFunctionPointer IDispatchEx located in types.hdl
// is included in element.cxx for other tearoff tables.

HRESULT
CFunctionPointer::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IObjectIdentity, NULL)
    }

    if (*ppv)
    {
        (*(IUnknown**)ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

HRESULT GetCallerIDispatch(IServiceProvider *pSP, IDispatch ** ppID);

HRESULT
CFunctionPointer::InvokeEx(DISPID id,
                           LCID lcid,
                           WORD wFlags,
                           DISPPARAMS *pdp,
                           VARIANT *pvarRes,
                           EXCEPINFO *pei,
                           IServiceProvider *pSrvProvider)
{
    HRESULT hr = S_OK;
    COmWindowProxy *pWindow = _pThis->IsPassivated() ? NULL : _pThis->Proxy();

    if (pSrvProvider && pWindow)
    {
        IDispatch *pCaller = NULL;
        hr = THR(GetCallerIDispatch(pSrvProvider, &pCaller));
        if (FAILED(hr))
        {            
            goto Cleanup;
        }

        if (!pCaller || !pWindow->AccessAllowed(pCaller))
            hr = E_ACCESSDENIED;

        ReleaseInterface(pCaller);
    }
    
    if (hr)
    {
        goto Cleanup;
    }

    // Value property on the function object returns the name of the function.
    if (id == DISPID_VALUE && !(wFlags & DISPATCH_METHOD))
    {
        TCHAR       pchFuncName[255];

        if (pvarRes)
        {
            PROPERTYDESC   *pDesc;
            WORD            wEntry;
            WORD            wIIDIndex;

            V_VT(pvarRes) = VT_BSTR;

            hr = _pThis->FindPropDescFromDispID(_dispid, (PROPERTYDESC **)&pDesc, &wEntry, &wIIDIndex);
            if (!hr)
            {
                Format(0, &pchFuncName, 255, _T("\nfunction <0s>() {\n    [native code]\n}\n"),
                       pDesc->pstrExposedName ? pDesc->pstrExposedName :
                                                pDesc->pstrName);
                if (!hr)
                {
                    hr = FormsAllocString(pchFuncName, &V_BSTR(pvarRes));
                }
            }

            // Any error return null string.
            if (hr)
                V_BSTR(pvarRes) = NULL;
        }

        hr = S_OK;
    }
    else
    {
        hr = _pThis->InvokeEx(_dispid, lcid, wFlags, pdp, pvarRes, pei, pSrvProvider);
    }

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CDispParams::Create, public
//
//  Synopsis:   Allocated argument and named argument arrays.
//              Initial values are VT_NULL for argument array
//              and DISPID_UNKNOWN for named argument array.
//
//----------------------------------------------------------------
HRESULT
CDispParams::Create (DISPPARAMS *pOrgDispParams)
{
    HRESULT     hr = S_OK;
    UINT        i;

    // Nothing should exist yet.
    if (rgvarg || rgdispidNamedArgs)
    {
        hr = E_FAIL;
        goto Error;
    }

    if (cArgs + cNamedArgs)
    {
        rgvarg = new(Mt(CDispParams_rgvarg)) VARIANTARG[cArgs + cNamedArgs];
        if (!rgvarg)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }

        // cArgs is now total count of args including named args.
        cArgs = cArgs + cNamedArgs;

        // Initialize all parameters to VT_NULL.
        for (i = 0; i < cArgs; i++)
        {
            rgvarg[i].vt = VT_NULL;
        }

        // Any arguments to copy over?
        if (pOrgDispParams->cArgs)
        {
            if (cArgs >= pOrgDispParams->cArgs)
            {
                UINT    iStartIndex;

                iStartIndex = cArgs - pOrgDispParams->cArgs;

                if (cArgs >= iStartIndex + pOrgDispParams->cArgs)
                {
                    memcpy(&rgvarg[iStartIndex],
                           pOrgDispParams->rgvarg,
                           sizeof(VARIANTARG) * pOrgDispParams->cArgs);
                }
            }
            else
            {
                hr = E_UNEXPECTED;
                goto Cleanup;
            }
        }

        if (cNamedArgs)
        {
            rgdispidNamedArgs = new(Mt(CDispParams_rgdispidNamedArgs)) DISPID[cNamedArgs];
            if (!rgdispidNamedArgs)
            {
                hr = E_OUTOFMEMORY;
                goto Error;
            }

            // Initialize all named args to the unknown dispid.
            for (i = 0; i < cNamedArgs; i++)
            {
                rgdispidNamedArgs[i] = DISPID_UNKNOWN;
            }

            if (pOrgDispParams->cNamedArgs)
            {
                if (cNamedArgs >= pOrgDispParams->cNamedArgs)
                {
                    UINT    iStartIndex;

                    iStartIndex = cNamedArgs - pOrgDispParams->cNamedArgs;
                    if (cNamedArgs >= (iStartIndex + pOrgDispParams->cNamedArgs))
                    {
                        memcpy(&rgdispidNamedArgs[iStartIndex],
                               pOrgDispParams->rgdispidNamedArgs,
                               sizeof(VARIANTARG) * pOrgDispParams->cNamedArgs);

                    }
                }
                else
                {
                    hr = E_UNEXPECTED;
                    goto Cleanup;
                }
            }
        }
    }

Cleanup:
    RRETURN(hr);

Error:
    delete [] rgvarg;
    delete [] rgdispidNamedArgs;
    goto Cleanup;
}


//+---------------------------------------------------------------
//
//  Member:     CDispParams::MoveArgsToDispParams, public
//
//  Synopsis:   Move arguments from arguments array to pOutDispParams.
//              Notice, I said move not copy so both this
//              object and the pOutDispParams hold the identical
//              VARIANTS.  So be careful to only release these
//              variants ONCE.  The fFromEnd parameter specifies
//              how the arguments are moved from our rgvar array.
//
//----------------------------------------------------------------
HRESULT
CDispParams::MoveArgsToDispParams (DISPPARAMS *pOutDispParams, UINT cNumArgs, BOOL fFromEnd /*= TRUE*/)
{
    HRESULT hr = S_OK;
    UINT     iStartIndex;

    if (rgvarg && cNumArgs)
    {
        if (cArgs >= cNumArgs && pOutDispParams->cArgs >= cNumArgs)
        {
            iStartIndex = fFromEnd ? cArgs - cNumArgs : 0;

            memcpy(pOutDispParams->rgvarg,
                   &rgvarg[iStartIndex],
                   sizeof(VARIANTARG) * cNumArgs);
            goto Cleanup;
        }

        hr = E_FAIL;
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CDispParams::ReleaseVariants, public
//
//  Synopsis:   Release any variants in out arguments array.
//              Again, if the values were moved (exist in 2
//              places) be careful you may have just screwed
//              yourself.
//
//----------------------------------------------------------------
void
CDispParams::ReleaseVariants ()
{
    for (UINT i = 0; i < cArgs; i++)
        VariantClear(rgvarg + i);
}


//+---------------------------------------------------------------
//
//  Member:     CBaseCF::CreateInstance, public
//
//  Synopsis:   Method of IClassFactory interface.
//
//----------------------------------------------------------------

STDMETHODIMP
CBaseCF::CreateInstance(
    IUnknown *pUnkOuter,
    REFIID iid,
    void **ppv)
{
    HRESULT     hr;                         
    CBase       *pBase  = NULL;
    IUnknown    *pUnk;

    CEnsureThreadState ets;
    hr = ets._hr;
    if (FAILED(hr))
        goto Error;

    if (pUnkOuter && iid != IID_IUnknown)
    {
        hr = E_INVALIDARG;
        goto Error;
    }

    // Initialize the class
    // (Ensure only one thread performs initialization)

    if (_pfnInitClass)
    {
        LOCK_GLOBALS;

        if (_pfnInitClass)
        {
            hr = (*_pfnInitClass)();
            if (hr)
                goto Error;

            _pfnInitClass = NULL;
        }
    }

    // Create the object in two steps.  The first
    // step calls the constructor.

    pBase = (*_pfnCreate)(pUnkOuter);
    if (!pBase)
        goto MemoryError;

    // Check whether aggregation is supported by the object.

    if (pUnkOuter && pBase->PunkOuter() != pUnkOuter)
    {
        hr = CLASS_E_NOAGGREGATION;
        goto Error;
    }

    // Call the second step initialization.

    hr = pBase->Init();
    if (hr)
        goto Error;

    pUnk = pBase->PunkInner();

    if (pUnkOuter)
    {
        *ppv = pUnk;
    }
    else
    {
        hr = pUnk->QueryInterface(iid, ppv);
        pUnk->Release();
    }

Cleanup:
    RRETURN(hr);

MemoryError:
    hr = E_OUTOFMEMORY;

Error:
    *ppv = NULL;
    if (pBase)
        pBase->PrivateRelease();
    goto Cleanup;
}

//+---------------------------------------------------------------
//
//  Member:     CBaseLockCF::LockServer, public
//
//  Synopsis:   Method of IClassFactory interface.
//             
//              Allows client to lock thread state.
//
//----------------------------------------------------------------

STDMETHODIMP
CBaseLockCF::LockServer (BOOL fLock)
{
    HRESULT hr;

#ifdef OBJCNTCHK
    DWORD dwObjCnt;
#endif

    if (fLock)
    {
        CEnsureThreadState ets;
        hr = ets._hr;
        if (FAILED(hr))
        {
            goto Cleanup;
        }

        TLS(dll.cLockServer) += 1;
        IncrementObjectCount(&dwObjCnt);
    }
    else
    {
        THREADSTATE * pts = GetThreadState();
#ifdef OBJCNTCHK
        dwObjCnt = GetCurrentThreadId();

        if (!pts)
        {
#if DBG==1
            AssertSz(0, "CBaseLockCF::LockServer(FALSE) called but there is no thread state");
#else
            F3DebugBreak();
#endif
            hr = E_FAIL;
        }
        else if (pts->dll.cLockServer <= 0)
        {
#if DBG==1
            AssertSz(0, "CBaseLockCF::LockServer(FALSE) called too many times on this thread");
#else
            F3DebugBreak();
#endif
            hr = E_FAIL;
        }
        else
#endif
        {
            hr = S_OK;
            if (pts)
            {
                (pts->dll.cLockServer) -= 1;
                DecrementObjectCount(&dwObjCnt);
            }
        }
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CBase::CBase, public
//
//  Synopsis:   Constructor.
//
//----------------------------------------------------------------

#if DBG == 1
ULONG CBase::s_ulLastSSN = 0;
#endif

CBase::CBase()
{
    _pAA = NULL;

    IncrementSecondaryObjectCount( 0 );
    _ulRefs = 1;
    _ulAllRefsAndFlags = 1 << BRF_FLAGS_SHIFT;

#if DBG == 1
    _ulSSN = ++s_ulLastSSN;
    MemSetName((this, "SSN=%d", _ulSSN));
#endif
#ifdef OBJCNTCHK
    _dwTidDbg = GetCurrentThreadId();
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CBase::CBaseCheckThread
//
//  Synopsis:   Verifies that the current thread is the same as the one this
//              object was created on.
//
//----------------------------------------------------------------------------

#ifdef OBJCNTCHK

void
CBase::CBaseCheckThread()
{
    if (_dwTidDbg != GetCurrentThreadId())
    {
        char ach[512];
        wsprintfA(ach, "Attempt to access CBase object on the wrong thread.  The object was "
                 "created on thread 0x%08lX; attemping access on thread 0x%08lX.",
                 _dwTidDbg, GetCurrentThreadId());
#if DBG==1
        AssertSz(0, ach);
#else
        F3DebugBreak();
#endif
    }
}

#endif

//+---------------------------------------------------------------------------
//
//  Member:     CBase::Init 
//
//  Synopsis:   Nothing happens.
//
//----------------------------------------------------------------------------

HRESULT
CBase::Init()
{
    //
    // Assert that the cpi classdesc is setup correctly.  It should either
    // be NULL or have at least two entries.  The second entry can be
    // CPI_ENTRY_NULL.
    //

    Assert(!BaseDesc()->_pcpi || BaseDesc()->_pcpi[0].piid);
            
    return S_OK;
}

CBase::~CBase()
{
    CBaseCheckThread();

    Assert("Ref count messed up in derived dtor?" &&
            (GetRefs()       == ULREF_IN_DESTRUCTOR || GetRefs()       == 1) &&
            (GetObjectRefs() == ULREF_IN_DESTRUCTOR || GetObjectRefs() == 1));

    Assert(!IsPassivating() && IsPassivated() && IsDestructing() || GetRefs() == 1 && GetObjectRefs() == 1);

    Assert(_pAA == NULL);

    Assert( ! GWHasPostedMethod( this ) );

    DecrementSecondaryObjectCount(0);
}


//+---------------------------------------------------------------
//
//  Member:     CBase::Passivate
//
//  Synopsis:   Shutdown main object by releasing references to
//              other objects and generally cleaning up.  This
//              function is called when the main reference count
//              goes to zero.  The destructor is called when
//              the reference count for the main object and all
//              embedded sub-objects goes to zero.
//
//---------------------------------------------------------------

void
CBase::Passivate()
{
    CBaseCheckThread();

    Assert("CBase::Passivate called unexpectedly or refcnt "
            "messed up in derived Passivate" &&
            (GetObjectRefs() == ULREF_IN_DESTRUCTOR || GetRefs() == 1));
    Assert( IsPassivating() && !IsPassivated() && !IsDestructing() || GetRefs() == 1 && GetObjectRefs() == 1 );

    //
    // The attr array destructor will free up any stuff left inside it.
    // This includes anyone sinking events or prop notifies from us.
    //
    // WARNING!!!  Be very careful to not delete the _pAA anywhere but
    // here - CStyle and its children do not manage their AAs, so _pAA
    // is changed to NULL in their Passivate() (before CBase::Passivate()
    // is called).  If you want _pAA to be destroyed elsewhere, consider
    // the CStyle case carefully.  -CWilso
    //
    
    delete _pAA;
    _pAA = NULL;

    // Mark that we got to this point.
    _ulAllRefsAndFlags |= BRF_PASSIVATED;
}

//+---------------------------------------------------------------
//
//  member: CBase ::IsEqualObject
//
//  synopsis : default IObjectIdentity implementation.
//
//----------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CBase::IsEqualObject(IUnknown * pUnk)
{
    HRESULT    hr = E_POINTER;
    IUnknown * pUnkThis = NULL;
    IUnknown * pUnkTarget=NULL;

    if (!pUnk)
        goto Cleanup;

    hr = THR_NOTRACE(PrivateQueryInterface(IID_IUnknown, (void**)&pUnkThis));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(pUnk->QueryInterface(IID_IUnknown, (void**)&pUnkTarget));
    if (hr)
        goto Cleanup;

    hr = (pUnkTarget == pUnkThis) ? S_OK : S_FALSE;

Cleanup:
    ReleaseInterface(pUnkThis);
    ReleaseInterface(pUnkTarget);
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------
//
//  Member:     CBase::PrivateQueryInterface, IPrivateUnknown
//
//---------------------------------------------------------------

HRESULT CBase::PrivateQueryInterface(REFIID iid, void **ppvObj)
{
#if DBG==1
    // If we ever get to CBase::PrivateQueryInterface with an IID of one of the
    // non-stacked interfaces then the most derived class needs to handle this
    // IID in it's PrivateQueryInterface.
    for (int i = 0; i++; i < MAX_IIDS)
    {
        if (IsEqualIID(iid, *(_IIDTable[i])))
            break;
    }            

    Assert("Non stack interface not handled in PrivateQueryInterface" && DispNonDualDIID(iid) || i < MAX_IIDS); 
#endif

    *ppvObj = NULL;
    return E_NOINTERFACE;
}


#if DBG == 1
BOOL        g_fDisableBaseTrace;
BOOL        g_fDisableBaseSubTrace;
CBase *     g_pBaseTrace;
CBase *     g_pSubBaseTrace;
ULONG       g_ulSSNTrace = 0xFFFFFFFF;
ULONG       g_ulSSNSubTrace = 0xFFFFFFFF;
#endif


//+---------------------------------------------------------------
//
//  Member:     CBase::PrivateAddRef, IPrivateUnknown
//
//---------------------------------------------------------------

#if DBG==1 || defined(OBJCNTCHK)
ULONG CBase::PrivateAddRef()
{
    CBaseCheckThread();

    Assert("CBase::PrivateAddRef called after CBase::Passivate." &&
            _ulRefs != 0);

    _ulRefs += 1;

#if DBG==1
    if (!g_fDisableBaseTrace && (this == g_pBaseTrace || _ulSSN == g_ulSSNTrace))
    {
        TraceTag((0, "base %x AR %d", this, _ulRefs));
        TraceCallers(0, 0, 12);
    }

    return _ulRefs;
#else
    return 0;
#endif
}
#endif

//+---------------------------------------------------------------
//
//  Member:     CBase::PrivateRelease, IPrivateUnknown
//
//---------------------------------------------------------------

ULONG CBase::PrivateRelease()
{
    CBaseCheckThread();

    ULONG ulRefs = --_ulRefs;

#if DBG==1
    if (!g_fDisableBaseTrace && (this == g_pBaseTrace || _ulSSN == g_ulSSNTrace))
    {
        TraceTag((0, "base %x Rel %d", this, ulRefs));
        TraceCallers(0, 0, 12);
    }
#endif

    AssertSz( ulRefs != 0 || !(IsPassivating() || IsPassivated()), 
        "Bouncing off of zero ref counts in CBase::PrivateRelease" );

    if (ulRefs == 0 && !IsPassivating() && !IsPassivated())
    {
        _ulRefs = ULREF_IN_DESTRUCTOR;
        _ulAllRefsAndFlags |= BRF_PASSIVATING;
        Passivate();
        AssertSz(_ulRefs == ULREF_IN_DESTRUCTOR, "Unexpected refcnt on return from CBase::Passivate");
        AssertSz( IsPassivated(), "Derived Passivate didn't call super::Passivate");
        _ulRefs = 0;
        _ulAllRefsAndFlags &= ~BRF_PASSIVATING;

        SubRelease();
    }

    return ulRefs;
}

#if DBG == 1

ULONG CBase::SubAddRef( )
{
    CBaseCheckThread();

    if (!g_fDisableBaseTrace && 
        !g_fDisableBaseSubTrace && (
            this == g_pBaseTrace || 
            this == g_pSubBaseTrace ||
            _ulSSN == g_ulSSNTrace ||
            _ulSSN == g_ulSSNSubTrace))
    {
        TraceTag((0, "base %x SubAR %d", this, GetRefs() + 1));
        TraceCallers(0, 0, 12);
    }
    return _ulAllRefsAndFlags += 1 << BRF_FLAGS_SHIFT;
}

#endif

//+---------------------------------------------------------------
//
//  Member:     CBase::SubRelease
//
//---------------------------------------------------------------

ULONG CBase::SubRelease()
{
    CBaseCheckThread();

#if DBG==1
    ULONG ulAllRefsPrev = GetRefs();

    if (!g_fDisableBaseTrace &&
        !g_fDisableBaseSubTrace && (
            this == g_pBaseTrace || 
            this == g_pSubBaseTrace ||
            _ulSSN == g_ulSSNTrace ||
            _ulSSN == g_ulSSNSubTrace))
    {
        TraceTag((0, "base %x SubRel %d", this, ulAllRefsPrev - 1));
        TraceCallers(0, 0, 12);
    }
#endif

    Assert( ulAllRefsPrev > 0 );
    _ulAllRefsAndFlags -= 1 << BRF_FLAGS_SHIFT;
    if (GetRefs() == 0)
    {
        Assert( !IsPassivating() && IsPassivated() && !IsDestructing() );

        _ulAllRefsAndFlags = (ULREF_IN_DESTRUCTOR << BRF_FLAGS_SHIFT) | BRF_PASSIVATED | BRF_DESTRUCTING;
        _ulRefs = ULREF_IN_DESTRUCTOR;
        delete this;
    }

#if DBG==1
    return ulAllRefsPrev - 1;
#else
    return 0;
#endif
}


//+------------------------------------------------------------------------
//
//  Member:     CBase::CLock::CLock
//
//  Synopsis:   Lock resources in CBase object.
//
//-------------------------------------------------------------------------

CBase::CLock::CLock(CBase *pBase)
{
#if DBG==1
    g_fDisableBaseTrace = TRUE;
#endif

    _pBase = pBase;

#if DBG==1
    if (!IsTagEnabled(tagDisableLockAR))
#endif
    {
        pBase->PunkOuter()->AddRef();
    }
    
#if DBG==1
    g_fDisableBaseTrace = FALSE;
#endif
}

//+------------------------------------------------------------------------
//
//  Member:     CServer::CLock::~CLock
//
//  Synopsis:   Unlock resources in CBase object.
//
//-------------------------------------------------------------------------

CBase::CLock::~CLock()
{
#if DBG==1
    g_fDisableBaseTrace = TRUE;
#endif

#if DBG==1
    if (!IsTagEnabled(tagDisableLockAR))
#endif
    {
        _pBase->PunkOuter()->Release();
    }
    
#if DBG==1
    g_fDisableBaseTrace = FALSE;
#endif
}


//+------------------------------------------------------------------------
//
//  Member:     CBase::QueryService
//
//  Synopsis:   Get service from host.  Derived classes should override.
//
//  Arguments:  guidService     id of service
//              iid             id of interface on service
//              ppv             the service
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CBase::QueryService(REFGUID guidService, REFIID iid, void ** ppv)
{
    if ( ppv )
        *ppv = NULL;
    RRETURN(E_NOINTERFACE);
}


//+------------------------------------------------------------------------
//
//  Member:     CBase::GetPages, ISpecifyPropertyPages
//
//  Synopsis:   Specifies the property pages supported by this object.
//
//  Arguments:  pPages  CLSID's for the pages are returned via a counted array
//
//  Returns:    HRESULT
//
//  Notes:      The array of CLSIDs is divided into two groups, each group
//              ending in a NULL pointer. The first group of CLSIDs is used
//              for when we are in run-mode (browse mode), and the second for
//              when we are in edit mode.
//
//-------------------------------------------------------------------------

STDMETHODIMP
CBase::GetPages(CAUUID * pPages)
{
#ifdef NO_PROPERTY_PAGE
    pPages->pElems = NULL;
    pPages->cElems = 0;
    return S_OK;
#else
    int         i, c;
    int         iStart;
    BOOL        fDesign = DesignMode();
    const CLSID * const * apclsid = BaseDesc()->_apclsidPages;

    pPages->pElems = NULL;
    pPages->cElems = 0;

    if (apclsid)
    {
        if (fDesign)
        {   
            for (c = 0; apclsid[c]; c++)
                ;

            iStart = c + 1;
        }
        else
        {
            iStart = 0;
        }

        for (i = iStart; apclsid[i]; i++)
            ;

        c = i - iStart;

        if (c != 0)
        {
            pPages->pElems = (GUID *) CoTaskMemAlloc(c * sizeof(CLSID));
            if (!pPages->pElems)
            {
                pPages->cElems = 0;
                RRETURN(E_OUTOFMEMORY);
            }

            for (i = iStart; i < iStart + c; i++)
            {
                memcpy(pPages->pElems + i - iStart,
                       apclsid[i],
                       sizeof(CLSID));
            }
            pPages->cElems = c;
        }
    }

    return S_OK;
#endif // NO_PROPERTY_PAGE
}


//+------------------------------------------------------------------------
//
//  Member:     CBase::HasPages
//
//  Synopsis:   Checks if any property pages are supported by this object.
//
//  Returns:    BOOL
//
//  Notes:      The array of CLSIDs is divided into two groups, each group
//              ending in a NULL pointer. The first group of CLSIDs is used
//              for when we are in run-mode (browse mode), and the second for
//              when we are in edit mode.
//
//-------------------------------------------------------------------------

BOOL
CBase::HasPages()
{
#ifdef NO_PROPERTY_PAGE
    return FALSE;
#else
    int         i = 0;
    const CLSID * const * apclsid = BaseDesc()->_apclsidPages;


    if (!apclsid)
        return FALSE;

    if (DesignMode())
    {   
        for (; apclsid[i]; i++)
            ;

        i++;
    }

    return (apclsid[i] != NULL);
#endif // NO_PROPERTY_PAGE
}

//+---------------------------------------------------------------------------
//
//  Member:     CBase:GetClassInfo, IProvideMultipleClassInfo
//
//  Synopsis:   Returns the control's coclass typeinfo.
//
//  Arguments:  ppTI    Resulting typeinfo.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBase::GetClassInfo(ITypeInfo ** ppTI)
{
    RRETURN(THR(LoadF3TypeInfo(*BaseDesc()->_pclsid, ppTI)));
}


//+---------------------------------------------------------------------------
//
//  Member:     CBase:GetGUID, IProvideMultipleClassInfo
//
//  Synopsis:   Returns some type of requested guid
//
//  Arguments:  dwGuidKind      The type of guid requested
//              pGUID           Resultant
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBase::GetGUID(DWORD dwGuidKind, GUID *pGUID)
{
    if (!pGUID)
        RRETURN(E_INVALIDARG);

    *pGUID = g_Zero.guid;

    if (dwGuidKind == GUIDKIND_DEFAULT_SOURCE_DISP_IID)
    {
        *pGUID= (BaseDesc()->_pcpi) ? 
                    *(BaseDesc()->_pcpi[CPI_OFFSET_PRIMARYDISPEVENT].piid) :
                    IID_NULL;
        return S_OK;
    }

    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Member:     CBase:GetMultiTypeInfoCount, IProvideMultipleClassInfo
//
//  Synopsis:   Returns the count of type infos on this object
//
//  Arguments:  pcti    Resultant of count of ti's.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBase::GetMultiTypeInfoCount(ULONG *pcti)
{
    HRESULT hr = S_OK;

    if (!pcti)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // The default is we support one typeinfo
    *pcti = 1;

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CBase:GetAggMultiTypeInfoCount
//
//  Synopsis:   Helper for aggregators for IProvideMultipleClassInfo
//
//  Arguments:  pcti    Resultant of count of ti's.
//              pUnkAgg The aggregate IUnknown
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CBase::GetAggMultiTypeInfoCount(ULONG *pcti, IUnknown *pUnkAgg)
{
    HRESULT                     hr = S_OK;
    IProvideMultipleClassInfo * pPMCI = NULL;

    if (!pcti)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pcti = 0;

    if (pUnkAgg)
    {
        // Determine how many ITypeInfos are available from the contained object
        hr = THR_NOTRACE(pUnkAgg->QueryInterface(
                IID_IProvideMultipleClassInfo,
                (void **)&pPMCI));
        if (hr)
        {
            //
            // Aggregate does not support MCI, just give it one TI.
            //

            *pcti = 1;
        }
        else
        {
            hr = THR(pPMCI->GetMultiTypeInfoCount(pcti));
            if (hr)
                goto Cleanup;
        }
    }

    //
    // Finally append our own TI
    //

    (*pcti)++;
    hr = S_OK;

Cleanup:
    ReleaseInterface(pPMCI);
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CBase:GetInfoOfIndex, IProvideMultipleClassInfo
//
//  Synopsis:   Get info on the type-info of some index
//
//  Arguments:  iti         Index of type info
//              dwFlags
//              pptiCoClass
//              pdwTIFlags
//              pcdispidReserved
//              piidPrimary
//              piidSource
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBase::GetInfoOfIndex(
        ULONG iTI,
        DWORD dwFlags,
        ITypeInfo** ppTICoClass,
        DWORD* pdwTIFlags,
        ULONG* pcdispidReserved,
        IID* piidPrimary,
        IID* piidSource)
{
    HRESULT             hr = S_OK;

    if (ppTICoClass)
        *ppTICoClass = NULL;
    if (pdwTIFlags)
        *pdwTIFlags = 0;
    if (pcdispidReserved)
        *pcdispidReserved = 0;
    if (piidPrimary)
        *piidPrimary = IID_NULL;
    if (piidSource)
        *piidSource = IID_NULL;

    if (((dwFlags & MULTICLASSINFO_GETTYPEINFO) && !ppTICoClass)                ||
        ((dwFlags & MULTICLASSINFO_GETNUMRESERVEDDISPIDS) && !pcdispidReserved) ||
        ((dwFlags & MULTICLASSINFO_GETIIDPRIMARY) && !piidPrimary)              ||
        ((dwFlags & MULTICLASSINFO_GETIIDSOURCE) && !piidSource))
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (iTI != 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (dwFlags & MULTICLASSINFO_GETTYPEINFO)
    {
        hr = THR(GetClassInfo(ppTICoClass));
        if (hr)
            goto Cleanup;
    }

    if (dwFlags & MULTICLASSINFO_GETNUMRESERVEDDISPIDS)
    {
        //
        // NOTE: (anandra) For our default objects, the reserved
        // dispids have been verified in the code.  Other aggregators
        // will need to ensure this or implement their own.
        //
        
        *pcdispidReserved = 0;
    }

    if (dwFlags & MULTICLASSINFO_GETIIDPRIMARY)
    {
        *piidPrimary = (BaseDesc()->_piidDispinterface) ?
                            *(BaseDesc()->_piidDispinterface) : 
                            IID_NULL;
    }

    if (dwFlags & MULTICLASSINFO_GETIIDSOURCE)
    {
        *piidSource = (BaseDesc()->_pcpi && 
                       BaseDesc()->_pcpi[CPI_OFFSET_PRIMARYDISPEVENT].piid) ? 
                        *(BaseDesc()->_pcpi[CPI_OFFSET_PRIMARYDISPEVENT].piid) :
                        IID_NULL;
    }

    if (pdwTIFlags)
    {
        *pdwTIFlags = TIFLAGS_EXTENDDISPATCHONLY;
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CBase:GetAggInfoOfIndex
//
//  Synopsis:   Helper for getting info on the type-info of some index
//              on an aggregator
//
//  Arguments:  iti         Index of type info
//              dwFlags
//              pptiCoClass
//              pdwTIFlags
//              pcdispidReserved
//              piidPrimary
//              piidSource
//              pUnkAgg
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CBase::GetAggInfoOfIndex(
            ULONG iTI,
            DWORD dwFlags,
            ITypeInfo** ppTICoClass,
            DWORD* pdwTIFlags,
            ULONG* pcdispidReserved,
            IID* piidPrimary,
            IID* piidSource,
            IUnknown *pUnkAgg)
{
    IProvideMultipleClassInfo * pPMCI = NULL;
    IProvideClassInfo *         pPCI = NULL;
    ITypeInfo *                 pTICoClass = NULL;
    HRESULT                     hr = S_OK;

    if (iTI == 0)
    {
        // Call default implementation
        hr = THR(CBase::GetInfoOfIndex(
                iTI,
                dwFlags,
                ppTICoClass,
                pdwTIFlags,
                pcdispidReserved,
                piidPrimary,
                piidSource));
    }
    else
    {
        //
        // If the aggregate supports multiple ITypeInfos, pass the request on
        // (Decrement the index by one to account for our extender ITypeInfo)
        //

        hr = THR_NOTRACE(pUnkAgg->QueryInterface(
                IID_IProvideMultipleClassInfo,
                (void **)&pPMCI));
        if (!hr)
        {
            hr = THR(pPMCI->GetInfoOfIndex(iTI - 1,
                                           dwFlags,
                                           ppTICoClass,
                                           pdwTIFlags,
                                           pcdispidReserved,
                                           piidPrimary,
                                           piidSource));
        }
        else if (iTI != 1)
        {
            // If the caller requested an ITypeInfo for something other
            // than the us or that of the immediate aggregate and the
            // aggregate does not support multiple ITypeInfos, it is an error
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        else
        {
            //
            // If the aggregate does not support multiple ITypeInfos and the
            // request is for the aggregate's ITypeInfo, return it
            // using traditional methods
            //

            if (pdwTIFlags)
            {
                *pdwTIFlags = TIFLAGS_EXTENDDISPATCHONLY;
            }

            if (dwFlags & (MULTICLASSINFO_GETTYPEINFO   |
                           MULTICLASSINFO_GETIIDPRIMARY |
                           MULTICLASSINFO_GETIIDSOURCE))
            {
                hr = THR(pUnkAgg->QueryInterface(
                        IID_IProvideClassInfo,
                        (void **)&pPCI));
                if (hr)
                    goto Cleanup;

                if (!ppTICoClass)
                    ppTICoClass = &pTICoClass;

                hr = THR(pPCI->GetClassInfo(ppTICoClass));
                if (hr)
                    goto Cleanup;

                if ((dwFlags & MULTICLASSINFO_GETIIDPRIMARY) ||
                    (dwFlags & MULTICLASSINFO_GETIIDSOURCE))
                {
                    hr = THR(GetTypeInfoFromCoClass(
                                *ppTICoClass,
                                (dwFlags & MULTICLASSINFO_GETIIDPRIMARY
                                        ? FALSE
                                        : TRUE),
                                NULL,
                                (dwFlags & MULTICLASSINFO_GETIIDPRIMARY
                                        ? piidPrimary
                                        : piidSource)));
                    if (hr)
                        goto Cleanup;
                }
            }
        }
    }

    hr = S_OK;

Cleanup:
    ReleaseInterface(pPMCI);
    ReleaseInterface(pPCI);
    ReleaseInterface(pTICoClass);
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CBase:InterfaceSupportsErrorInfo, ISupportErrorInfo
//
//  Synopsis:   Return true if given interface supports error info.
//
//  Arguments:  iid the interface
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBase::InterfaceSupportsErrorInfo(REFIID iid)
{
    const CLASSDESC * pcd;

    pcd = BaseDesc();
    return (pcd->_piidDispinterface &&
            *pcd->_piidDispinterface == iid) ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------
//
//  Member:     CBase::GetClassID, IPersist
//
//  Synopsis:   Method of IPersist interface
//
//  Returns:    HRESULT
//
//---------------------------------------------------------------

STDMETHODIMP
CBase::GetClassID(LPCLSID pclsid)
{
    *pclsid = *BaseDesc()->_pclsid;
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CBase::InvokeDispatchWithThis
//
//  Synopsis:   invokes pDisp adding IUnknown of this
//              named parameter to args list
//
//---------------------------------------------------------------

HRESULT
CBase::InvokeDispatchWithThis (
    IDispatch *     pDisp,
    VARIANT *       pExtraArg,
    REFIID          riid,
    LCID            lcid,
    WORD            wFlags,
    DISPPARAMS *    pdispparams,
    VARIANT *       pvarResult,
    EXCEPINFO *     pexcepinfo,
    IServiceProvider *pSrvProvider,
    IDispatch *     pdispThis) 
{
    HRESULT         hr;
    IDispatchEx  *  pDEX = NULL;
    DISPPARAMS *    pPassedParams = pdispparams;
    IDispatch *     pdispThisLocal = NULL;
    CDispParams     dispParams((pExtraArg ? pdispparams->cArgs + 1 : pdispparams->cArgs),
                                pdispparams->cNamedArgs + 1);

    hr = THR_NOTRACE(pDisp->QueryInterface(IID_IDispatchEx, (void **)&pDEX));
    // Does the object support IDispatchEx then we'll need to pass
    // the this pointer of this object
    if (!hr)
    {
        if (!pdispThis)
        {
            hr = THR(PrivateQueryInterface(IID_IDispatch, (void **)&pdispThisLocal));
            if (hr)
                goto Cleanup;

            pdispThis = pdispThisLocal;
        }

        hr = dispParams.Create(pdispparams);
        if (hr)
            goto Cleanup;

        // Create the named this parameter
        Assert(dispParams.cNamedArgs > 0);
        V_VT(&dispParams.rgvarg[0]) = VT_DISPATCH;
        V_UNKNOWN(&dispParams.rgvarg[0]) = pdispThis;
        dispParams.rgdispidNamedArgs[0] = DISPID_THIS;

        if (pExtraArg)
        {
            UINT     uIdx = dispParams.cArgs - 1;

            memcpy(&(dispParams.rgvarg[uIdx]), pExtraArg, sizeof(VARIANT));
        }

        pPassedParams = &dispParams;
    }

    //
    // Call the function
    //
    hr = pDEX ? THR(pDEX->InvokeEx(DISPID_VALUE,
                                 lcid,
                                 wFlags,
                                 pPassedParams,
                                 pvarResult,
                                 pexcepinfo,
                                 pSrvProvider))         :
                THR(pDisp->Invoke(DISPID_VALUE,
                                  riid,
                                  lcid,
                                  wFlags,
                                  pPassedParams,
                                  pvarResult,
                                  pexcepinfo,
                                  NULL));

    // If we had to pass the this parameter and we had more than
    // 1 parameter then copy the orginal back over (the args could have
    // been byref).
    if (pPassedParams != pdispparams && pPassedParams->cArgs > 1)
    {
        hr = dispParams.MoveArgsToDispParams(pdispparams, pdispparams->cArgs);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pDEX);
    ReleaseInterface(pdispThisLocal);

    RRETURN (hr);
}


//+---------------------------------------------------------------
//
//  Member:     CBase::InvokeDispatchExtraParam
//
//  Synopsis:   invokes pDisp adding pExtraParam as the last
//              parameter to args list
//
//---------------------------------------------------------------

HRESULT
CBase::InvokeDispatchExtraParam (
    IDispatch *     pDisp,
    REFIID          riid,
    LCID            lcid,
    WORD            wFlags,
    DISPPARAMS *    pdispparams,
    VARIANT *       pvarResult,
    EXCEPINFO *     pexcepinfo,
    IServiceProvider *pSrvProvider,
    VARIANT        *pExtraParam) 
{
    HRESULT         hr;
    IDispatchEx  *  pDEX = NULL;
    DISPPARAMS *    pPassedParams = pdispparams;
    CDispParams     dispParams(pdispparams->cArgs, 1);

    Assert(pdispparams->cNamedArgs == 0);

    IGNORE_HR(pDisp->QueryInterface(IID_IDispatchEx, (void **)&pDEX));

    hr = dispParams.Create(pdispparams);
    if (hr)
        goto Cleanup;

    // Add the extra parameter
    dispParams.cNamedArgs = 0;
    delete [] dispParams.rgdispidNamedArgs;
    dispParams.rgdispidNamedArgs = 0;

    // Move the extra parameter.
    memcpy(&dispParams.rgvarg[0], pExtraParam, sizeof(VARIANTARG));

    pPassedParams = &dispParams;

    //
    // Call the function
    //
    hr = pDEX ? THR_NOTRACE(pDEX->InvokeEx(DISPID_VALUE,
                                 lcid,
                                 wFlags,
                                 pPassedParams,
                                 pvarResult,
                                 pexcepinfo,
                                 pSrvProvider))         :
                THR_NOTRACE(pDisp->Invoke(DISPID_VALUE,
                                  riid,
                                  lcid,
                                  wFlags,
                                  pPassedParams,
                                  pvarResult,
                                  pexcepinfo,
                                  NULL));

    // If we had to pass the this parameter and we had more than
    // 1 parameter then copy the orginal back over (the args could have
    // been byref).
    if (pPassedParams != pdispparams && pPassedParams->cArgs > 1)
    {
        hr = dispParams.MoveArgsToDispParams(pdispparams, pdispparams->cArgs - 1);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pDEX);

    RRETURN (hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CBase::Invoke
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------

STDMETHODIMP
CBase::Invoke(
        DISPID dispidMember,
        REFIID riid,
        LCID lcid,
        WORD wFlags,
        DISPPARAMS * pdispparams,
        VARIANT * pvarResult,
        EXCEPINFO * pexcepinfo,
        UINT *)
{
    HRESULT         hr;
    IDispatchEx    *pDispEx;

    if (!IsEqualIID(riid, IID_NULL))
        RRETURN(E_INVALIDARG);

    hr = THR_NOTRACE(PrivateQueryInterface(IID_IDispatchEx, (void **)&pDispEx));
    if (hr)
    {
        // Object doesn't support IDispatchEx use CBase::InvokeEx
        hr = InvokeEx(dispidMember, lcid, wFlags, pdispparams,pvarResult, pexcepinfo, NULL);
    }
    else
    {
        // Object supports IDispatchEx call InvokeEx thru it's v-table.
        hr = pDispEx->InvokeEx(dispidMember, lcid, wFlags, pdispparams,pvarResult, pexcepinfo, NULL);
        ReleaseInterface(pDispEx);
    }

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CBase::GetIDsOfNames
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------

STDMETHODIMP
CBase::GetIDsOfNames(REFIID riid,
                     LPOLESTR *  rgszNames,
                     UINT,
                     LCID,
                     DISPID *    rgdispid)
{
    HRESULT         hr;
    IDispatchEx    *pDispEx;
    BSTR            bstrName = NULL;

    if (!IsEqualIID(riid, IID_NULL))
        RRETURN(E_INVALIDARG);

    if (rgszNames[0] == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    hr = THR_NOTRACE(PrivateQueryInterface(IID_IDispatchEx, (void **)&pDispEx));
    if (hr)
    {
        // Object doesn't support IDispatchEx use CBase::InvokeEx
        hr = THR(FormsAllocString(rgszNames[0], &bstrName));
        if (hr)
            goto Cleanup;

        hr = GetDispID(bstrName, fdexFromGetIdsOfNames, rgdispid);
    }
    else
    {
        // Object supports IDispatchEx call InvokeEx thru it's v-table.
        hr = pDispEx->GetDispID(rgszNames[0], fdexFromGetIdsOfNames, rgdispid);
        ReleaseInterface(pDispEx);
    }

Cleanup:
    FormsFreeString(bstrName);
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Function:   GetArgsActual
//
//  Synopsis:   helper
//
//--------------------------------------------------------------------------

LONG GetArgsActual(DISPPARAMS * pdispparams)
{
    LONG cArgsActual;
    // If the parameters passed in has the named DISPID_THIS paramter, then we
    // don't want to include this parameter in the total number of parameter
    // count.  This named parameter is an additional parameter tacked on by the
    // script engine to handle scoping rules.
    cArgsActual = pdispparams->cArgs;
    if (pdispparams->cNamedArgs && *pdispparams->rgdispidNamedArgs == DISPID_THIS)
    {
        cArgsActual--;  // Don't include DISPID_THIS in argument count.
    }

    return cArgsActual;
}

//+-------------------------------------------------------------------------
//
//  Method:     CBase::InvokeAA
//
//  Synopsis:   helper
//
//--------------------------------------------------------------------------

HRESULT
CBase::InvokeAA(
    DISPID              dispidMember,
    CAttrValue::AATYPE  aaType,
    LCID                lcid,
    WORD                wFlags,
    DISPPARAMS *        pdispparams,
    VARIANT *           pvarResult,
    EXCEPINFO *         pexcepinfo,
    IServiceProvider *  pSrvProvider,
    BOOL                fIsExpando)
{
    HRESULT     hr = DISP_E_MEMBERNOTFOUND;
    LONG        cArgsActual = GetArgsActual(pdispparams);

    if ((cArgsActual == 0) && (wFlags & DISPATCH_PROPERTYGET))
    {
        if (pvarResult)
        {
            hr = GetVariantAt(FindAAIndex(dispidMember, aaType),
                                pvarResult, /* fAllowNullVariant = */FALSE);
            if (!hr)
                goto Cleanup;
        }
    }
    else if (wFlags & DISPATCH_PROPERTYPUT)
    {
        if (pdispparams && cArgsActual == 1)
        {
            // This path here is only for expandos - tree sync and undo for
            // normal attributes goes through a different path
            BOOL    fTreeSync = FALSE;
            BOOL    fCreateUndo = !g_fInVizAct2000 && QueryCreateUndo( TRUE, FALSE, &fTreeSync );
            AAINDEX aaIdx = FindAAIndex(dispidMember, aaType);

            // HACK (JHarding): VizAct 2000 gets confused if we undo expandos, so we have to disable it for them (99897)

            // Get the old value before it's set
            if( fTreeSync || fCreateUndo )
            {
                CVariant vtOld;

                VariantInit( &vtOld );

                if( aaIdx != AA_IDX_UNKNOWN )
                    IGNORE_HR( GetVariantAt( aaIdx, &vtOld, TRUE ) );
                else
                    V_VT(&vtOld) = VT_NULL;

                if( fTreeSync )
                {
                    IGNORE_HR( LogAttributeChange( dispidMember, &vtOld, pdispparams->rgvarg ) );
                }

                if( fCreateUndo )
                {
                    IGNORE_HR( CreatePropChangeUndo( dispidMember, &vtOld, NULL ) );
                }
            }

            if (aaIdx == AA_IDX_UNKNOWN)
            {
                hr = AddVariant(dispidMember,
                                pdispparams->rgvarg,
                                aaType);
                if (fIsExpando)
                {
                    hr = THR(UpdateDomAttrCollection(FALSE, dispidMember));
                    if (hr)
                        goto Cleanup;
                }
            }
            else
            {
                hr = ChangeVariantAt(aaIdx, pdispparams->rgvarg);
            }
            if (hr)
                goto Cleanup;

            hr = OnPropertyChange(dispidMember, 0);
            goto Cleanup;
        }
        else
        {
            // Missing value to set.
            hr = DISP_E_BADPARAMCOUNT;
            goto Cleanup;
        }
    }

    // If the wFlags was marked as a Get/Method and the get failed then try
    // this as a method invoke.  Of if the wFlags was only a method invoke
    // then the hr is set to DISP_E_MEMBERNOTFOUND at the entry ExpandoInvoke.
    if (hr && (wFlags & DISPATCH_METHOD))
    {
        AAINDEX aaidx = FindAAIndex(dispidMember, aaType);
        if (AA_IDX_UNKNOWN == aaidx)
        {
            if (pvarResult)
            {
                VariantClear(pvarResult);
                pvarResult->vt = VT_NULL;
                hr = S_OK;
            }
        }
        else
        {
            IDispatch * pDisp = NULL;
        
            hr = THR(GetDispatchObjectAt(aaidx, &pDisp));
            if (!hr && pDisp)
            {
                hr = THR(InvokeDispatchWithThis(
                    pDisp,
                    NULL,
                    IID_NULL,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    pSrvProvider));
                ReleaseInterface(pDisp);
           }
        }
    }
    else
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }

Cleanup:
    RRETURN (hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CBase::ContextInvokeEx, IDispatchEx
//
//  Synopsis:   Real implementation of InvokeEx.  Uses context passed
//              in for actual calls
//
//--------------------------------------------------------------------------

STDMETHODIMP CBase::ContextInvokeEx(DISPID dispidMember,
                                    LCID lcid,
                                    WORD wFlags,
                                    DISPPARAMS * pdispparams,
                                    VARIANT * pvarResult,
                                    EXCEPINFO * pexcepinfo,
                                    IServiceProvider *pSrvProvider,
                                    IUnknown *pUnkContext)
{
    PerfDbgLog(tagPerfWatch, this, "+CBase::ContextInvokeEx");
    HRESULT         hr = S_OK;
    long            cArgsActual = GetArgsActual(pdispparams);
    DISPPARAMS     *pOldDispParams = NULL;
    CDispParams     dpMissingArgs;

    ITypeInfo * pTI = NULL;
    IUnknown *  pUnk = NULL;

    // clear the per thread EI object to check again after custom Invoke to see if 
    // it was set from a prop\method on failure
    IErrorInfo *pErrorInfo = NULL;

#if DBG == 1
    IErrorInfo *pErrorInfoDbg = NULL;
    hr = GetErrorInfo(0, &pErrorInfoDbg);
    if (!hr)
    {
        Assert(pErrorInfoDbg);
        ::SetErrorInfo(NULL, pErrorInfoDbg);
    }
#endif

    //
    // Handle special performance critical dispids without loading typeinfo.
    //

    if (wFlags & DISPATCH_PROPERTYGET)
    {
        switch (dispidMember)
        {
        case DISPID_ENABLED:
        case DISPID_VALID:
            if (pvarResult == NULL)
            {
                PerfDbgLog(tagPerfWatch, this, "-CBase::ContextInvokeEx");
                RRETURN(E_INVALIDARG);
            }

            V_VT(pvarResult) = VT_BOOL;
            switch (dispidMember)
            {
            case DISPID_ENABLED:
                PerfDbgLog(tagPerfWatch, this, "-CBase::ContextInvokeEx");
                return THR_NOTRACE(GetEnabled(&V_BOOL(pvarResult)));

            case DISPID_VALID:
                PerfDbgLog(tagPerfWatch, this, "-CBase::ContextInvokeEx");
                return THR_NOTRACE(GetValid(&V_BOOL(pvarResult)));

            default:
                Assert(0 && "Logic error");
                break;
            }
            break;

        case DISPID_UNKNOWN:
            // Special case handling if we ever have a condition were
            // something can't be found but the invoke caller expect us
            // to return data (pvarResult) then instead of returning the
            // error DISP_EMEMBERNOTFOUND we'll return DISPID_UNKNOWN with
            // a hr result of S_OK (inn GetIDsOfNamesEx) when the Invoke
            // is called and if we ever get a DISPID_UNKNOWN we'll simply
            // return VT_NULL.  This will JavaScript to compare the result
            // to null and VBScript to detect isnull()
            if (pvarResult)
            {
                VariantClear(pvarResult);
                pvarResult->vt = VT_NULL;
                hr = S_OK;
                goto Cleanup;
            }
            break;

        default:
            break;
        }
    }

    // Are we an expando?
    if (IsExpandoDISPID ( dispidMember ) )
    {

ExpandoInvoke:
        hr = THR(InvokeAA (dispidMember, CAttrValue::AA_Expando,
                lcid, wFlags, pdispparams, pvarResult, pexcepinfo, pSrvProvider, TRUE));

    }
    else
    {
        PROPERTYDESC_METHOD   *pDesc;
        WORD                   wEntry;
        WORD                   wIIDIndex;

#if DBG == 1
        if (IsTagEnabled(tagOleAutomation))
        {
            goto OLEInvoke;
        }
#endif

        // Can we find the properydesc for this dispid, if so then use our
        // custom invoke.
        hr = FindPropDescFromDispID(dispidMember, (PROPERTYDESC **)&pDesc, &wEntry, &wIIDIndex);
        if (hr)
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }
        else
        {
            CustomHandler   pHandler;
            IDispatch      *pDisp;
            CVariant        varTemp;

#if DBG == 1
            if (IsTagEnabled(tagInvokeTrace))
            {
                OutputDebugString(_T("Invoke: "));
                OutputDebugString((pDesc->a.pstrExposedName) ? pDesc->a.pstrExposedName :
                                                               pDesc->a.pstrName);
                OutputDebugString(_T("\r\n"));
            }
#endif  // Output what's happening.

            if (!pvarResult)
            {
                pvarResult = &varTemp;
            }

            Assert(pDesc);

            if ((cArgsActual == 0)                              &&
                (wFlags & DISPATCH_PROPERTYGET)                 &&
                (pDesc->b.dwPPFlags & PROPPARAM_INVOKEGet))
            {
                // If the property supports both get/set then the vtable offset
                // in the propdesc is for the set adding sizeof(void*) gets us to the get
                // property function.
                if (pDesc->b.dwPPFlags & PROPPARAM_INVOKESet)
                {
                    wEntry += sizeof(void*);
                }
                goto CustomInvoke;
            }
            else if ((cArgsActual == 1)                         &&
                     (wFlags & DISPATCH_PROPERTYPUT)            &&
                     (pDesc->b.dwPPFlags & PROPPARAM_INVOKESet))
            {
                goto CustomInvoke;
            }
            // object put or get value property of an object?
            else if ((wFlags & DISPATCH_PROPERTYPUT ||
                      wFlags & DISPATCH_PROPERTYGET)                &&
                     pDesc->b.dwPPFlags & PROPPARAM_INVOKEGet)
            {
                if (cArgsActual > 0 && 
                    (pDesc->b.wInvFunc == IDX_G_IDispatchp ||
                     pDesc->b.wInvFunc == IDX_GS_IDispatchp))
                {
                    // Possible indexed collection access
                    CVariant    varTmp;

                    // Must be QI not PrivateQI, location, navigator, etc. are wrapped
                    // we must delegate to the wrappers.  If the index into the IIDTable
                    // is zero then the wEntry is on the primary default interface otherwise
                    // use the interface in the IIDTable.
                    hr = pUnkContext->QueryInterface(_IIDTable[wIIDIndex] 
                                                     ? *_IIDTable[wIIDIndex] 
                                                     : *BaseDesc()->_piidDispinterface,
                                               (void **) &pDisp);
                    if (hr)
                        goto Cleanup;

                    // If the property is both a get/set then adjust offset to
                    // point to the get property function.
                    if (pDesc->b.dwPPFlags & PROPPARAM_INVOKESet)
                    {
                        wEntry += sizeof(void*);
                    }

                    hr = G_IDispatchp(this,
                                      pSrvProvider,
                                      pDisp,
                                      wEntry,
                                      (PROPERTYDESC_BASIC_ABSTRACT *)pDesc,
                                      wFlags,
                                      NULL,
                                      &varTmp);
                    if (!hr)
                    {
                        if (V_VT(&varTmp) == VT_DISPATCH)
                        {
                            IDispatch  *pDisp = V_DISPATCH(&varTmp);

        				    IDispatchEx *pDispEx;

                            if ( !pDisp )
                            {
                                hr = DISP_E_MEMBERNOTFOUND;
                            }
                            else
                            {
                                hr = pDisp->QueryInterface ( IID_IDispatchEx, (void **)&pDispEx );
                                if ( !hr )
                                {
                                    hr = pDispEx->InvokeEx(DISPID_VALUE,
                                        lcid, wFlags, pdispparams,
                                        pvarResult,pexcepinfo,pSrvProvider);
                                    ReleaseInterface(pDispEx);
                                    SetErrorInfo(hr);
                                }
                                else
                                {
                                    hr = pDisp->Invoke(DISPID_VALUE,
        				                IID_NULL,lcid,wFlags,pdispparams,
                        				pvarResult,pexcepinfo,NULL);
                                    SetErrorInfo(hr);
                                }                            
                                if (FAILED(hr))
                                {
                                    GetErrorInfo(0, &pErrorInfo);
                                    Assert(pErrorInfo && (!pErrorInfoDbg || (pErrorInfoDbg != pErrorInfo)) && "Property or Method did not SetErrorInfo");
                                }
                            }
                        }
                        else
                        {
                            hr = DISP_E_NOTACOLLECTION;
                        }
                    }

                    ReleaseInterface(pDisp);

                    goto Cleanup2;
                }
            }
            else if (wFlags & DISPATCH_METHOD)
            {
                // Check if method and args are at least minimum #.  Note, I
                // longer check the maximum count, JavaScript (Navigator)
                // ignores any arguments greater than max and we will as well.
                // So we wont check:
                //
                //   cArgsActual <= pDesc->d   // #args <= max # of args?
                //
                if (!((pDesc->b.dwPPFlags & PROPPARAM_INVOKEGet)    ||
                       (pDesc->b.dwPPFlags & PROPPARAM_INVOKESet))      &&
                    cArgsActual >= pDesc->e)      // #args >= required minimum args?
                {
                    // It's a method invocation.
                    goto CustomInvoke;
                }
                // Check to see if scriptlet flag is on.
                else if (pDesc->b.dwPPFlags & PROPPARAM_SCRIPTLET)
                {
                    hr = DISP_E_MEMBERNOTFOUND;
                    
                    // Invoke with dispid this, it's a property.
                    AAINDEX aaidx = FindAAIndex(dispidMember, CAttrValue::AA_Internal);
                    if (AA_IDX_UNKNOWN != aaidx)
                    {
                        IDispatch * pDisp = NULL;
                        
                        hr = THR(GetDispatchObjectAt(aaidx, &pDisp));
                        if (!hr && pDisp)
                        {
                            hr = THR(InvokeDispatchWithThis(
                                pDisp,
                                NULL,
                                IID_NULL,
                                lcid,
                                wFlags,
                                pdispparams,
                                pvarResult,
                                pexcepinfo,
                                pSrvProvider));
                            ReleaseInterface(pDisp);
                            if (FAILED(hr))
                            {
                                GetErrorInfo(0, &pErrorInfo);
                                Assert(pErrorInfo && (!pErrorInfoDbg || (pErrorInfoDbg != pErrorInfo)) && "Property or Method did not SetErrorInfo");
                            }
                         }
                    }
                    goto Cleanup;
                }
                else if (!((pDesc->b.dwPPFlags & PROPPARAM_INVOKEGet)    ||
                           (pDesc->b.dwPPFlags & PROPPARAM_INVOKESet))      &&
                    cArgsActual < pDesc->e)      // #args < less than minimum args?
                {
                    // Construct null parameters for each missing parameter.
                    dpMissingArgs.Initialize(pDesc->e, pdispparams->cNamedArgs);

                    hr = dpMissingArgs.Create(pdispparams);
                    if (hr)
                        goto Cleanup;

                    pOldDispParams = pdispparams;
                    pdispparams = &dpMissingArgs;

                    // It's a method invocation.
                    goto CustomInvoke;
                }
            }
            else if ((cArgsActual == 1)                  &&
                     (wFlags & DISPATCH_PROPERTYPUTREF)         &&
                     (pDesc->b.dwPPFlags & PROPPARAM_INVOKESet))
            {
                // Passing argument by reference. 
                goto CustomInvoke;
            }
            else if ((wFlags & DISPATCH_PROPERTYGET) && dispidMember == DISPID_VALUE &&
                pvarResult != NULL && cArgsActual == 0 )
            {
                // PROPGET For default property
                hr = DISP_E_MEMBERNOTFOUND;
                goto Cleanup;
            }
            // Accessing a method w/o arguments (e.g, document.open;).  This
            // would invoke the open as a get property which we'll return as
            // undefined.  Nav3 would do nothing but error if alert(doc.open)
            // we'll return undefined.
            else if (wFlags & DISPATCH_PROPERTYGET &&
                     ((pDesc->b.dwPPFlags & PROPPARAM_INVOKESet) == 0))
            {
                // Compute open expando and get the expando value.
                DISPID  dispIDExpando;
                TCHAR  *pName = const_cast <TCHAR *> (pDesc->a.pstrExposedName ?
                                                pDesc->a.pstrExposedName :
                                                pDesc->a.pstrName);

                // Compute the expando dispid.
                hr = GetExpandoDispID(pName, &dispIDExpando, fdexNameCaseSensitive);
                if (!hr)
                {
                    // Found the expando so get the expando value.
                    dispidMember = dispIDExpando;
                    goto ExpandoInvoke;
                }
                else
                {
                    // Create the CFunctionPointer object and store it in the
                    // attrArray.
                    AAINDEX     aIdx;

                    aIdx = FindAAIndex(dispidMember, CAttrValue::AA_Attribute);
                    if (aIdx == AA_IDX_UNKNOWN)
                    {
                        V_DISPATCH(pvarResult) = (IDispatch *)new CFunctionPointer(this, dispidMember);

                        hr = V_DISPATCH(pvarResult) ?
                                    AddDispatchObject(dispidMember,
                                                      V_DISPATCH(pvarResult),
                                                      CAttrValue::AA_Attribute)
                                    : E_OUTOFMEMORY;
                    }
                    else
                    {
                        // Object already exist.
                        hr = GetDispatchObjectAt(aIdx, &V_DISPATCH(pvarResult));
                    }

                    V_VT(pvarResult) = VT_DISPATCH;

                    // Any error then cleanup the any objects created?
                    if (hr)
                    {
                        VariantClear(pvarResult);
                        V_VT(pvarResult) = VT_NULL;

                        // No expando/function object, return undefined.
                        hr = S_OK;
                    }

                    goto Cleanup;
                }            
            }

            // Catch all error for anything not customed invoked.
            hr = E_NOTIMPL;
            goto Cleanup;

CustomInvoke:
#if 0
if (StrCmpIC(_T("parent"), pDesc->a.pstrExposedName ?
                            pDesc->a.pstrExposedName :
                            pDesc->a.pstrName) == 0)
    DebugBreak(); 
#endif
            pHandler = _HandlerTable[pDesc->b.wInvFunc];
            if (!pHandler)
            {
                hr = DISP_E_MEMBERNOTFOUND;
                goto Cleanup;
            }

            // Must be QI not PrivateQI, location, navigator, etc. are wrapped
            // we must delegate to the wrappers.  If the index into the IIDTable
            // is zero then the wEntry is on the primary default interface otherwise
            // use the interface in the IIDTable.
            hr = pUnkContext->QueryInterface(_IIDTable[wIIDIndex] 
                                                ? *_IIDTable[wIIDIndex] 
                                                : *BaseDesc()->_piidDispinterface,
                                             (void **) &pDisp);
            if (hr)
                goto Cleanup;

            // Before we Invoke, cache the Invoke Context in the Attr Array. Store it for the duration of the
            // Invoke so that we can establish script context

            // Can optimize this by knowing what dispids need to know this info
            // Adding it into the attr array automaticaly AddRef's it
            if ( pSrvProvider )
                AddUnknownObject ( DISPID_INTERNAL_INVOKECONTEXT, pSrvProvider, CAttrValue::AA_Internal );

            hr = (*pHandler)(this, pSrvProvider, pDisp, wEntry, (PROPERTYDESC_BASIC_ABSTRACT *)pDesc, wFlags, pdispparams, pvarResult);

            if (FAILED(hr))
            {
                GetErrorInfo(0, &pErrorInfo);
                Assert(pErrorInfo && (!pErrorInfoDbg || (pErrorInfoDbg != pErrorInfo)) && "Property or Method did not SetErrorInfo");
            }

            // Did we make a method call where we fabricated arguments which were
            // missing?
            if (pOldDispParams)
            {
                // Yes, so move the args back to original dispparams and reset
                // out dispparam pointers.
                HRESULT hr1 = dpMissingArgs.MoveArgsToDispParams(pOldDispParams, pOldDispParams->cArgs);

                pdispparams = pOldDispParams;
                pOldDispParams = NULL;

                if (FAILED(hr1))
                {
                    if (hr == S_OK)
                        hr = hr1;

                    goto Cleanup;
                }
            }

            if ( pSrvProvider )
                FindAAIndexAndDelete ( DISPID_INTERNAL_INVOKECONTEXT, CAttrValue::AA_Internal );
            

            ReleaseInterface(pDisp);
        }

#if DBG==1
        goto Cleanup;

OLEInvoke:
        // Problem, so use ITypeInfo::Invoke
        hr = GetTypeInfo(0, lcid, &pTI);
        if (hr)
            goto Cleanup;

        hr = pUnkContext->QueryInterface(
                            *BaseDesc()->_piidDispinterface,
                            (void **) &pUnk);
        if (hr)
            goto Cleanup;

        hr = pTI->Invoke(
                    pUnk,
                    dispidMember,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    NULL);
#endif
    }

Cleanup:
    // Nav support for coercing object ptrs to Strings
    if ( hr == DISP_E_MEMBERNOTFOUND && (wFlags & DISPATCH_PROPERTYGET) && dispidMember == DISPID_VALUE &&
                pvarResult != NULL && cArgsActual == 0)
    {
        V_VT(pvarResult) = VT_BSTR;
        hr = THR(FormsAllocString ( _T("[object]"),&V_BSTR(pvarResult) ) );
    }

Cleanup2:
    if (hr == S_OK && pvarResult &&
        V_VT(pvarResult) == VT_DISPATCH &&
        V_DISPATCH(pvarResult))
    {
        IDispatch *pdisptemp = V_DISPATCH(pvarResult);
        hr = pdisptemp->QueryInterface(IID_IDispatch, (LPVOID*)&V_DISPATCH(pvarResult));
        ReleaseInterface(pdisptemp);
    }

    if (FAILED(hr) && pexcepinfo)
    {
        pexcepinfo->wCode = 0;
        pexcepinfo->scode = hr;
        if (pErrorInfo)
        {
            pErrorInfo->GetSource(&(pexcepinfo->bstrSource));
            pErrorInfo->GetDescription(&(pexcepinfo->bstrDescription));
            pErrorInfo->GetHelpFile(&(pexcepinfo->bstrHelpFile));
            pErrorInfo->GetHelpContext(&(pexcepinfo->dwHelpContext));
            hr = DISP_E_EXCEPTION;
        }
    }

#if DBG==1    
    ReleaseInterface(pErrorInfoDbg);
#endif

    ReleaseInterface(pErrorInfo);
    ReleaseInterface(pTI);
    ReleaseInterface(pUnk);

    PerfDbgLog(tagPerfWatch, this, "-CBase::ContextInvokeEx");

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CBase::GetDispID, IDispatchEx
//
//  Synopsis:   Delegates to ITypeInfo::GetIDsOfName first if this calls fails
//              then check if the name exist in the propertyDesc array and then
//              the expando list (don't do yet).  If the name doesn't exist in
//              any of those list then create an expando property if grfdex
//              parameter says to and return the dispid of the new expando.
//--------------------------------------------------------------------------

STDMETHODIMP
CBase::GetDispID(BSTR bstrName,
                 DWORD grfdex,
                 DISPID *pid)
{
    HRESULT     hr;
    BOOL fRestricted = FALSE;

    PerfDbgLog1(tagPerfWatch, this, "+CBase::GetDispID (%ls)", bstrName);

    if (!pid)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    hr = CBase::GetInternalDispID(bstrName, pid, grfdex, NULL, NULL, &fRestricted);
    if (fRestricted)
    {
        Assert(DISP_E_UNKNOWNNAME == hr);
        goto Cleanup;
    }

    if (!hr)
    {
        // We found the name, however we'll need to check if the name is a method
        // if so then the builtin method could have been overriden.  So check
        // the attr array for this expando.
        PROPERTYDESC_METHOD    *pDesc;
        WORD                    wEntry;
        WORD                    wIIDIndex;

        hr = FindPropDescFromDispID(*pid,
                                    (PROPERTYDESC **)&pDesc,
                                    &wEntry,
                                    &wIIDIndex);
        if (!hr)
        {
            // Accessing a method, could have changed so it might be expando.
            if ((pDesc->b.dwPPFlags & PROPPARAM_INVOKESet) == 0)
            {
                DISPID  dispIDExpando;

                // Compute the expando dispid.
                hr = GetExpandoDispID(bstrName, &dispIDExpando, grfdex);
                if (!hr)
                {
                    if ((*GetAttrArray())->FindAAIndex(dispIDExpando,
                                                       CAttrValue::AA_Expando) != AA_IDX_UNKNOWN)
                    {
                        // Found the expando so get the expando value.
                        *pid = dispIDExpando;
                    }
                }
            }
        }

        hr = S_OK;
        goto Cleanup;
    }

    // Try expandos
    hr = GetExpandoDispID(bstrName, pid, grfdex);
    if (hr == S_FALSE)
    {
        // If we're returning false then the rgdispid is DISPID_UNKNOWN expando
        // wasn't found but it wasn't added either we'll return VT_NULL on the
        // invoke.
        Assert(*pid == DISPID_UNKNOWN);
        hr = S_OK;
    }
#if DBG == 1
    else if (hr == S_OK)
    {
        if (IsTagEnabled(tagInvokeTrace))
        {
            OutputDebugString(_T("NamesEx expando: "));
            OutputDebugString(bstrName);
            OutputDebugString(_T("\r\n"));
        }
    }
#endif  // Output what's happening.

Cleanup:
    PerfDbgLog1(tagPerfWatch, this, "-CBase::GetDispID (%ls)", bstrName);
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CBase::DeleteMember, IDispatchEx
//
//--------------------------------------------------------------------------

HRESULT
CBase::DeleteMemberByName(BSTR psz,DWORD grfdex)
{
    return E_NOTIMPL;
}

HRESULT
CBase::DeleteMemberByDispID(DISPID id)
{
    return E_NOTIMPL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CBase::GetMemberProperties, IDispatchEx
//
//--------------------------------------------------------------------------

HRESULT
CBase::GetMemberProperties(
                DISPID id,
                DWORD grfdexFetch,
                DWORD *pgrfdex)
{
    return E_NOTIMPL;
}


HRESULT
CBase::GetMemberName(DISPID id, BSTR *pbstrName)
{
    LPCTSTR pszName = NULL;
    PROPERTYDESC *pPropDesc;
    const TCHAR *pstr;
    DISPID expDispid;

    if (!pbstrName)
        return E_INVALIDARG;

    *pbstrName = NULL;
    
    if (IsExpandoDISPID(id, &expDispid))
    {
        GetExpandoName(expDispid, &pszName);
        FormsAllocString(pszName, pbstrName);
    }
    else
    {
        if (FindPropDescFromDispID(id, &pPropDesc, NULL, NULL))
            goto Cleanup;

        pstr = pPropDesc->pstrExposedName ?
                                 pPropDesc->pstrExposedName :
                                 pPropDesc->pstrName;

        FormsAllocString(pstr, pbstrName);
    }

Cleanup:
    return *pbstrName ? S_OK : DISP_E_MEMBERNOTFOUND;
}


//+-------------------------------------------------------------------------
//
//  Method:     CBase::GetNextDispID, IDispatchEx
//
//  Synopsis:   Loop through all property entries in ITypeInfo then enumerate
//              through all expando properties.  Any DISPID handed out here
//              must stay constant (GetDispID should hand out the
//              same).  This routines enumerates regular properties and expando.
//
//  Results:
//              S_OK        - returns next DISPID
//              S_FALSE     - enumeration is done
//              E_nnnn      - call failed.
//--------------------------------------------------------------------------

HRESULT
CBase::GetNextDispID(DWORD grfdex,
                     DISPID id,
                     DISPID *prgid)
{
    HRESULT     hr;
    BSTR        bstr = NULL;

    hr = GetInternalNextDispID(grfdex, id, prgid, &bstr);
    FormsFreeString( bstr );
    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CBase::GetNameSpaceParent, IDispatchEx
//
//--------------------------------------------------------------------------

HRESULT
CBase::GetNameSpaceParent(IUnknown **ppunk)
{
    HRESULT     hr;

    if (!ppunk)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppunk = NULL;
    hr = S_OK;

Cleanup:
    RRETURN(hr);
}


HRESULT
CBase::GetInternalDispID(BSTR           bstrName,
                         DISPID       * pid,
                         DWORD          grfdex, 
                         IDispatch    * pDisp /*= NULL*/,
                         IDispatchEx  * pDispEx /*= NULL*/,
                         BOOL         * pfRestricted /*= NULL*/)
{
    HRESULT                     hr = DISP_E_UNKNOWNNAME;
    const VTABLEDESC           *pVTblDesc;

    pVTblDesc = FindVTableEntryForName (bstrName, 
                                        (!!(grfdex & fdexNameCaseSensitive)));

    if (pVTblDesc)
    {
        const PROPERTYDESC *pPropDesc = pVTblDesc->FastGetPropDesc(VTABLEDESC_BELONGSTOOM);  // Property Description
        Assert(pPropDesc);

        if (pPropDesc->GetPPFlags() & PROPPARAM_RESTRICTED)
        {
            if (pfRestricted)
                *pfRestricted = TRUE;

            goto Cleanup;
        }

        // Variable name usage on a method?
        if ((!!(grfdex & fdexNameEnsure)) &&
            ((pPropDesc->GetPPFlags() & PROPPARAM_INVOKEGet) ||
            (pPropDesc->GetPPFlags() & PROPPARAM_INVOKESet)) == 0)
        {
            // Yes, so if we've got a function here then error we
            // want this as an expando.
            goto Cleanup;
        }
        else
        {
            // Either it's a real method wanted or we're working on a
            // property.
            *pid = pPropDesc->GetDispid();

            if (!_pAA)
            {
                _pAA = new CAttrArray;
                // If new doesn't succeed then no cache is used.
            }

            // Set cache of last found DISPID and vtable desc this cache is
            // used by custom invoke to eliminate search.
            if (_pAA)
            {
                _pAA->SetGINCache(*pid, pVTblDesc);
            }

            hr = S_OK;
            goto Cleanup;           // We're done we can leave now.
        }
    }

    // They better both not be set.
    Assert(!(pDisp && pDispEx));

    // Is there another typeinfo we should look at?
    if (pDisp || pDispEx)
    {
        if (pDispEx) 
        {
            hr = THR_NOTRACE(pDispEx->GetDispID(bstrName, 
                                                grfdex, 
                                                pid));
        }
        else if (pDisp)
        {
            // If control is IDispatch then no case sensitive match.
            ITypeInfo   *pTI = NULL;

            hr = THR(pDisp->GetTypeInfo(0, g_lcidUserDefault, &pTI));
            if (!hr)
            {
                hr = THR_NOTRACE(MatchExactGetIDsOfNames(pTI,
                                                         IID_NULL,
                                                         &bstrName,
                                                         1,
                                                         0,
                                                         pid,
                                                         !!(grfdex & fdexNameCaseSensitive)));
            }

            // We'll enter here if we didn't have a typelib or if
            // MatchExactGetIDsOfNames failed.
            if (hr)
            {
                // Do it the hardway no typelib at all or the typelib didn't
                // expose the prop/metho so lets try it this way.
                hr = THR_NOTRACE(pDisp->GetIDsOfNames(IID_NULL,
                                                      &bstrName,
                                                      1,
                                                      0,
                                                      pid));
            }

            ReleaseInterface(pTI);
        }
    }

Cleanup:
    RRETURN(hr);
}



HRESULT
#ifdef VSTUDIO7
CBase::GetExpandoDispID(LPOLESTR pchName, DISPID *pid, DWORD grfdex, CAttrArray *pAA /* = NULL */)
#else
CBase::GetExpandoDispID(BSTR bstrName, DISPID *pid, DWORD grfdex, CAttrArray *pAA /* = NULL */)
#endif //VSTUDIO7
{
#ifdef VSTUDIO7
    return GetExpandoDISPID(pchName, pid, grfdex, pAA);
#else
    return GetExpandoDISPID(bstrName, pid, grfdex, pAA);
#endif //VSTUDIO7
}

HRESULT
CBase::GetExpandoDISPID(LPTSTR pchName, DISPID *pid, DWORD grfdex, CAttrArray *pAA /* = NULL */)
{
    HRESULT         hr = S_OK;
    CAtomTable     *pat;
    BOOL            fCaseSensitive = (grfdex & fdexNameCaseSensitive) != 0;
    LONG            lIndex;
    LONG            lId;
    BOOL            fFound = FALSE;
    BOOL            fStartFromIndex = FALSE;

    // Assume failure.
    *pid = DISPID_UNKNOWN;
    hr = DISP_E_UNKNOWNNAME;

    // If pAA is not specified or is NULL use the calss memeber value
    if(!pAA) pAA = _pAA;

    // Look in Expando for this property.
    pat = GetAtomTable();
    if(!pat)
        goto Cleanup;

    lIndex = -1;
    do
    {
        lIndex++;

        // The first time search is initiated, fStartFromIndex should be FALSE
        // After the first try, fStartFromIndex should/can be set to TRUE.
        hr = THR_NOTRACE(pat->GetAtomFromName(pchName, &lIndex, &lId, fCaseSensitive, fStartFromIndex));

        fStartFromIndex = TRUE;

        if (!hr)
        {
            *pid = lId;
            Assert(lId >= 0);

            // Make it an expando range.
            *pid += DISPID_EXPANDO_BASE;
            // Outside of range then we've got too many expandos.
            if (*pid > DISPID_EXPANDO_MAX)
            {
                *pid = DISPID_UNKNOWN;
                hr = DISP_E_UNKNOWNNAME;
                goto Cleanup;
            }

            // Verify that this expando truly does exist, a name in the atom
            // table doesn't guarantee that the name is expando.  Consider the
            // case of a named element.  During the event firing the implicit
            // this is the element which when called thru GetDispID will
            // find that name in this routine and assume that it was expando
            // unless we verify that the attrArray for this element truly has
            // this expando.
            if (FindAAIndex(*pid, CAttrValue::AA_Expando, AA_IDX_UNKNOWN, FALSE, pAA) != AA_IDX_UNKNOWN)
            {
                // It's an expando...we found it
                fFound = TRUE;
            }
            else
            {
                // Check if it could be an ActiveX expando?
                DISPID  dispIDactX;

                // remapped to ActiveX expando?
                dispIDactX = (*pid - DISPID_EXPANDO_BASE) + DISPID_ACTIVEX_EXPANDO_BASE;
                // Too many activeX expandos?
                if (dispIDactX <= DISPID_ACTIVEX_EXPANDO_MAX)
                {
                    if (FindAAIndex(dispIDactX, CAttrValue::AA_Expando, AA_IDX_UNKNOWN, FALSE, pAA) != AA_IDX_UNKNOWN)
                    {
                        fFound = TRUE;
                    }
                }
            }
        }
        // Atom tables are alway built case sensitive so if we did not found the name
        //  when doing a case insensitive search that may be because there different
        //  spellings of the same name in the atom table. We need to try them all
    } while(!fCaseSensitive && !fFound && hr == S_OK);

    if(!fFound)
    {
        if((grfdex & fdexNameEnsure) != 0)
        {
            // Add expando.
            hr = AddExpando(pchName, pid);
        }
        else
        {
    // NOTE: ***TLL*** VT_NULL handling wont happen unless we can return S_OK here.
    //         temporary work around to allow foo() to return not defined.
            // Don't error just return success, however the
            // dispid returned is DISPID_UNKNOWN. CBase::Invoke
            // will take care of r-value case to return a
            // VT_NULL for l-value an error will occur.
            hr = DISP_E_UNKNOWNNAME;
        }
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


HRESULT
CBase::GetInternalNextDispID(DWORD grfdex,
                             DISPID id,
                             DISPID *prgid,
                             BSTR *prgbstr,
                             IDispatch *pDisp /* = NULL */)
{
    HRESULT hr = S_FALSE;

    // check the outgoing parameters.
    if (prgid == NULL || prgbstr == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // set to the same as lastid
    *prgid = id;
    *prgbstr = NULL;

    if (IsExpandoDISPID(id))
    {
        goto ExpandoRange;
    }

    // Try to get element properties
    if (!pDisp || (pDisp && ((id & 0xFFFF0000) == DISPID_XOBJ_BASE || id == DISPID_STARTENUM)))
    {
        hr = NextProperty(id, prgbstr, prgid);

        // If we found some properties in NextProperty then we want to start
        // enumerating properties in the activeX control starting at the beginning.
        // The function NextProperty will return S_FALSE and *prgid == id if the
        // last property from NextProperty is id otherwise *prgid == DISPID_UNKNOWN.
        if (hr == S_FALSE && pDisp && *prgid == id)
        {
            id = DISPID_STARTENUM;
        }
    }

    // If we didn't get the current dispid asked for then try the pDisp typeinfo
    // if that was passed.
    if (hr == S_FALSE && pDisp)
    {
        IDispatchEx *pDispEx = NULL;

        hr = THR(pDisp->QueryInterface(IID_IDispatchEx, (void **)&pDispEx));
        if (S_OK == hr && pDispEx)
        {
            hr = THR(pDispEx->GetNextDispID(grfdex, id, prgid));
            ReleaseInterface(pDispEx);
        }
        else
            hr = NextTypeInfoProperty(pDisp, id, prgbstr, prgid);
    }

    // If we still don't have a current dispid asked for then try the expandos.
    if (hr == S_FALSE)
    {
        id = DISPID_STARTENUM;

ExpandoRange:
        hr = GetNextDispIDExpando(id, prgbstr, prgid);
    }

Cleanup:
    RRETURN1(hr, S_FALSE);

}


HRESULT
CBase::NextTypeInfoProperty(
            IDispatch *pDisp,
            DISPID id,
            BSTR *pbstrName,
            DISPID *pid)
{
    HRESULT         hr = S_OK;
    ITypeInfo      *pTI = NULL;
    CTypeInfoNav    tin;
    BOOL            ffound = FALSE;

    *pid = DISPID_UNKNOWN;

    // TODO:    ***TLL*** Need optimization to have a special range for the
    //          object tag properties/attributes so we can ignore traversing
    //          activeX control properties and jump right to the CBase
    //          enumeration of expando or object tag/properties.

    if (pDisp)
    {
        // Loop thru ActiveX properties.
        hr = tin.InitIDispatch(pDisp, &pTI, 0);
        if (hr)
        {
            if (E_NOTIMPL == hr)
            {
                hr = S_FALSE;
            }
            goto Cleanup;
        }

        while ((hr = tin.Next()) == S_OK)
        {
            VARDESC    *pVar;
            FUNCDESC   *pFunc;

            if ((pVar = tin.getVarD()) != NULL)
            {
                if (!ffound)
                {
                    // Match or enumerating at beginning.
                    ffound = (pVar->memid == id) || (id == DISPID_STARTENUM);
                    if (ffound)
                    {
                        continue;
                    }
                }
                else
                {
                    // fill in the outgoing parameters
                    *pid = pVar->memid;
                    break;
                }
            }
            else if ((pFunc = tin.getFuncD()) != NULL)
            {
                if (!ffound)
                {
                    // Match or enumerating at beginning.
                    ffound = (pFunc->memid == id) || (id == DISPID_STARTENUM);
                    if (ffound)
                    {
                        continue;
                    }
                }
                else
                {
                    // Is the next a property get/put?
                    if ((pFunc->invkind == INVOKE_PROPERTYGET) ||
                        (pFunc->invkind == INVOKE_PROPERTYPUT))
                    {
                        // Might be 2 properties get/put
                        if (pFunc->memid != id)
                        {
                            // fill in the outgoing parameters
                            *pid = pFunc->memid;
                            break;
                        }
                        else
                        {
                            continue;
                        }
                    }
                    else
                    {
                        // No, continue until we find a property.
                        continue;
                    }
                }
            }
        }

        // If we succeede on getting a property from ITypeInfo then get the name.
        if (!hr && *pid != DISPID_UNKNOWN && pbstrName)
        {
            UINT         cNames;

            hr = pTI->GetNames(*pid, pbstrName, 1, &cNames);
            if (hr)
                goto Cleanup;

            Assert(cNames == 1);
            goto Cleanup;   // Everything is okay just return.
        }
        else
        {
            if (hr && *pid == DISPID_UNKNOWN)
            {
                // Nothing more to find.
                hr = S_FALSE;
            }
        }
    }

Cleanup:
    ReleaseInterface(pTI);

    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CBase::AddExpando, helper
//
//  Synopsis:   Add an expando property to the attr array.
//
//  Results:    S_OK        - return dispid of found name
//              E_          - unable to add expando
//
//--------------------------------------------------------------------------

HRESULT
CBase::AddExpando (LPOLESTR pszExpandoName, DISPID *pdispID)
{
    HRESULT             hr;
    CAtomTable         *pat;
    BOOL                fExpando;

    pat = GetAtomTable(&fExpando);
    if (!pat || !fExpando)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    hr = pat->AddNameToAtomTable(pszExpandoName, pdispID);
    if (hr)
        goto Cleanup;

    // Make it an expando range.
    *pdispID += DISPID_EXPANDO_BASE;
    if (*pdispID > DISPID_EXPANDO_MAX)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

Cleanup:
    if (hr)
    {
        *pdispID = DISPID_UNKNOWN;
    }

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CBase::SetExpando, helper
//
//  Synopsis:   Set an expando property to the attr array.
//
//--------------------------------------------------------------------------

HRESULT
CBase::SetExpando(LPOLESTR pszExpandoName, VARIANT * pvarPropertyValue)
{
    HRESULT hr;
    DISPID dispIDExpando;
    AAINDEX aaIdx;

    hr = AddExpando(pszExpandoName, &dispIDExpando);
    if (hr)
        goto Cleanup;

    aaIdx = FindAAIndex(dispIDExpando, CAttrValue::AA_Expando);
    if (aaIdx == AA_IDX_UNKNOWN)
        hr = AddVariant(dispIDExpando, pvarPropertyValue, CAttrValue::AA_Expando);
    else
        hr = ChangeVariantAt(aaIdx, pvarPropertyValue);

Cleanup:
    RRETURN(hr);
}


HRESULT
CBase::GetNextDispIDExpando(DISPID currDispID, BSTR *pStrNextName, DISPID *pNextDispID)
{
    HRESULT     hr = S_FALSE;
    AAINDEX     aaNextIdx;

    // Assumption at this point is that expandos are always unique.  Multiple
    // DISPIDs for AA_Expando is not valid.  If the currDispID is 0 then get
    // first occurrance otherwise get the next attribute after the currDispID.

    // Are we looking to return a name if so then currDispID needs to be
    // valid.
    if (currDispID == DISPID_STARTENUM)
    {
        // We need index of first expando.
        aaNextIdx = FindAAIndex(DISPID_UNKNOWN, CAttrValue::AA_Expando);
    }
    else
    {
        // Get index of current dispid.
        aaNextIdx = FindAAIndex(currDispID, CAttrValue::AA_Expando, AA_IDX_UNKNOWN);
        // Compute next expando.
        aaNextIdx = FindAAIndex(DISPID_UNKNOWN, CAttrValue::AA_Expando, aaNextIdx);
    }

    *pNextDispID = GetDispIDAt(aaNextIdx);

    if (*pNextDispID != DISPID_UNKNOWN)
    {
        // Look in Expando for this property.
        CAtomTable     *pat;
        LPCTSTR         pch = NULL;
        DISPID          didOffset;

        pat = GetAtomTable();
        if (!pat)
            goto Cleanup;

        // Compute which kind of expando it is ActiveX or element.
        didOffset = (*pNextDispID >= DISPID_ACTIVEX_EXPANDO_BASE &&
                     *pNextDispID <= DISPID_ACTIVEX_EXPANDO_MAX ) ?
                            DISPID_ACTIVEX_EXPANDO_BASE :
                            DISPID_EXPANDO_BASE;

        hr = THR_NOTRACE(pat->GetNameFromAtom(
                        *pNextDispID - didOffset, &pch));
        if (hr)
            goto Cleanup;

        if (pStrNextName)
        {
            hr = FormsAllocString(pch, pStrNextName);
            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        // End of expando.
        hr = S_FALSE;
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


HRESULT CBase::GetExpandoName ( DISPID expandoDISPID, LPCTSTR *lpPropName )
{
    HRESULT hr;

    Assert ( expandoDISPID >= DISPID_EXPANDO_BASE );

    // Get the name associated with the expando DISPID
    CAtomTable *pat = GetAtomTable();

    if (!pat)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }
    // When we put the dispid in the attr array we offset it by the expando base
    hr = THR(pat->GetNameFromAtom ( expandoDISPID-DISPID_EXPANDO_BASE, lpPropName ));
Cleanup:
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CBase::NextProperty, helper
//
//  Synopsis:   Loop through all property entries in ITypeInfo then enumerate
//              through all expando properties.  Any DISPID handed out here
//              must stay constant (GetIDsOfNamesEx should hand out the
//              same).  This routines enumerates regular properties and expando.
//
//  Results:
//              S_OK        - returns next DISPID after currDispID
//              S_FALSE     - enumeration is done
//              E_nnnn      - call failed.
//--------------------------------------------------------------------------

HRESULT
CBase::NextProperty (DISPID currDispID, BSTR *pStrNextName, DISPID *pNextDispID)
{
    HRESULT     hr = S_FALSE;

    Assert(pNextDispID);

    // Initialize to not found.  If result is S_FALSE and pNextDispID is
    // currDispID then the last known item was a property found in this routine,
    // however there isn't another property after this one.  If pNextDispID is
    // DISPID_UNKNOWN then the last known property wasn't fetched from this
    // routine.  This is important for activex controls so we know when to ask
    // for first property versus next property.
    *pNextDispID = DISPID_UNKNOWN;

    if (IsExpandoDISPID(currDispID))
    {
        goto Cleanup;
    }

    // Enumerate thru attributes and properties.
    if (pStrNextName)
    {
        BOOL                    fPropertyFound = FALSE;
        DWORD                   dwppFlags;
        CPtrBagVTableAggregate::CIterator vTableAggregateIterator(GetStringTableAggregate());

        for (vTableAggregateIterator.Start(VTABLEDESC_BELONGSTOOM); !vTableAggregateIterator.End(); vTableAggregateIterator.Next())
        {
            const VTABLEDESC       *pVTblDesc;
            const PROPERTYDESC     *ppropdesc;

            pVTblDesc = vTableAggregateIterator.Item();

            ppropdesc = pVTblDesc->FastGetPropDesc(VTABLEDESC_BELONGSTOOM);
            Assert(ppropdesc);

            dwppFlags = ppropdesc->GetPPFlags();

            // Only iterate over properties and items which are not hidden.
            if ((dwppFlags & (PROPPARAM_INVOKEGet | PROPPARAM_INVOKESet)) == 0 ||
                (dwppFlags & PROPPARAM_HIDDEN))
                 continue;

            // Get the first property.
            if (currDispID == DISPID_STARTENUM)
            {
                fPropertyFound = TRUE;
            }
            else if (currDispID == ppropdesc->GetDispid())
            {
                // Found a match get the next property.
                fPropertyFound = TRUE;
                *pNextDispID = currDispID;  // Signal we found last one now we
                                            // we need to look for next property.
                 continue;
            }

            // Look at this propertydesc?
            if (fPropertyFound)
            {
                // Yes, we're either the first one or this is the dispid we're
                // looking for.

                const TCHAR * pstr = ppropdesc->pstrExposedName ?
                                         ppropdesc->pstrExposedName :
                                         ppropdesc->pstrName;

                // If property has a leading underscore then don't display.
                if (pstr[0] == _T('_'))
                    continue;

                // allocate the result string
                *pStrNextName = SysAllocString(pstr);
                if (*pStrNextName == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                // We're returning this ID.
                *pNextDispID = ppropdesc->GetDispid();

                hr = S_OK;
                break;
            }
        }
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}

AAINDEX
CBase::FindNextAttach(int idx, DISPID dispID)
{
    AAINDEX     aaidx = AA_IDX_UNKNOWN;
    int         cAttachEvts = 0;

    for (;;)
    {
        aaidx = FindNextAAIndex(dispID, CAttrValue::AA_AttachEvent, aaidx);
        if (aaidx == AA_IDX_UNKNOWN || idx == cAttachEvts)
            break;

        cAttachEvts++;
    };

    return aaidx;
}


HRESULT 
CBase::FindEventName(ITypeInfo *pTISrc, DISPID dispid, BSTR *pBSTR)
{
    int         ievt;
    int         cbEvents;
    UINT        cbstr;
    HRESULT     hr;
    FUNCDESC   *pFDesc = NULL;
    TYPEATTR   *pTAttr = NULL;

    Assert(pTISrc);
    Assert(pBSTR);

    *pBSTR = NULL;

    hr = pTISrc->GetTypeAttr(&pTAttr);
    if (hr)
        goto Cleanup;

    if (pTAttr->typekind != TKIND_DISPATCH)
    {
        hr = E_NOINTERFACE;
        goto Cleanup;
    }

    // Total events.
    cbEvents = pTAttr->cFuncs;
    if (cbEvents == 0)
    {
        hr = E_NOINTERFACE;
        goto Cleanup;
    }

    // Populate the event table.
    for (ievt = 0; ievt < cbEvents; ++ievt)
    {
        hr = pTISrc->GetFuncDesc(ievt, &pFDesc);
        if (hr)
            goto Cleanup;

        // Did we find the event that fired?
        if (dispid == pFDesc->memid)
        {
            // Yes, so return the name.
            hr = pTISrc->GetNames(dispid, pBSTR, 1, &cbstr);
            goto Cleanup;
        }

        pTISrc->ReleaseFuncDesc(pFDesc);
        pFDesc = NULL;
    }

    hr = S_OK;

Cleanup:
    if (pFDesc)
        pTISrc->ReleaseFuncDesc(pFDesc);
    if (pTAttr)
        pTISrc->ReleaseTypeAttr(pTAttr);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CBase::FireEvent, public
//
//  Synopsis:   Fires an event out the primary dispatch event connection point
//              and using the corresponding code pointers living in attr array
//
//  Arguments:  dispidEvent     Dispid of the event to fire
//              dispidProp      Dispid of property where event func is stored
//              pvarResult      Where to store the return value
//              pdispparams     Parameters for Invoke
//              pexcepinfo      Any exception info
//              puArgErr        Error argument
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

enum EVENTTYPE {
    EVENTTYPE_EMPTY = 0,
    EVENTTYPE_OLDSTYLE = 1,
    EVENTTYPE_VBHOOKUP = 2
};

enum EVENT_TYPE { VB_EVENTS, CPC_EVENTS };

HRESULT 
CBase::InvokeEvent(
    DISPID dispidEvent, 
    DISPID dispidProp, 
    IDispatch *pEventObject,
    VARIANT *pvarResult, 
    DISPPARAMS *pdispparams/* = NULL*/,
    EXCEPINFO *pexcepinfo/* = NULL*/,
    UINT *puArgErr/* = NULL*/,
    ITypeInfo *pTIEventSrc/* = NULL*/,
    IDispatch * pdispThis/* = NULL*/)
{
    AAINDEX                         aaidx;
    HRESULT                         hr = S_OK;
    IDispatch *                     pDisp = NULL;
    CVariant                        Var;
    CStackPtrAry<IDispatch *, 2>    arySinks(Mt(CBaseFireEventAry_pv));
    CStackDataAry<WORD, 2>          arySinkType(Mt(CBaseFireTypeAry_pv)); 
    long                            i;
    VARIANT                         varEO;                  // Don't release.
    VARIANT                        *pVarEventObject;
    CDispParams                     dispParams;
    BOOL                            f_CPCEvents = FALSE;
    EVENT_TYPE                      whichEventType;
    CExcepInfo                      ei;
    UINT                            uArgErr;
    DISPPARAMS                      dp = {NULL, NULL, 0, 0};

    if (!pdispparams)
        pdispparams = &dp;

    if (!pexcepinfo)
        pexcepinfo = &ei;

    if (!puArgErr)
        puArgErr = &uArgErr;

    if (pvarResult)
    {
        VariantInit(pvarResult);
    }
    
    //
    //
    // First fire off any properties bound to this event.
    //

    if (dispidProp != DISPID_UNKNOWN)   // Skip property events
    {
        aaidx = FindAAIndex(dispidProp, CAttrValue::AA_Internal);
        if (AA_IDX_UNKNOWN != aaidx)
        {
            hr = THR(GetDispatchObjectAt(aaidx, &pDisp));
            if (!hr && pDisp)
            {
                CAttrValue *pAV = GetAttrValueAt(aaidx);

                pVarEventObject = NULL;

                if (pAV)
                {
                    // If not old style event, and we have an eventObject and we're not firing the onError
                    // event which already has arguments then prepare to pass the event object as an
                    // argument.
                    if (!pAV->IsOldEventStyle() && pEventObject && dispidProp != DISPID_EVPROP_ONERROR)
                    {
                        V_VT(&varEO) = VT_DISPATCH;
                        V_DISPATCH(&varEO) = pEventObject;
                        pVarEventObject = &varEO;;
                    }
                }            

                hr = THR(InvokeDispatchWithThis(
                    pDisp,
                    pVarEventObject,
                    IID_NULL,
                    g_lcidUserDefault,
                    DISPATCH_METHOD,
                    pdispparams,
                    &Var,
                    pexcepinfo,
                    NULL,
                    pdispThis));

                ClearInterface(&pDisp);
        
                if (pvarResult)
                {
                    hr = THR(VariantCopy(pvarResult, &Var));
                    if (hr)
                        goto Cleanup;
                }
            }
        }

        // Fire any attach events.
        IGNORE_HR(InvokeAttachEvents(dispidProp, pdispparams, pvarResult, this, pexcepinfo, puArgErr, pEventObject));
    }

    //
    // Now fire off to anyone listening through the normal connection
    // points.  Remember that these are also just stored in the attr
    // array with a special internal dispid.
    //

    aaidx = AA_IDX_UNKNOWN;
    
    for (;;)
    {
        CAttrValue  *pAV;

        aaidx = FindNextAAIndex(
            DISPID_A_EVENTSINK, 
            CAttrValue::AA_Internal, 
            aaidx);
        if (aaidx == AA_IDX_UNKNOWN)
            break;

        Assert(!pDisp);

        pAV = GetAttrValueAt(aaidx);
        if (pAV)
        {
            if (OK(FetchObject(pAV, VT_UNKNOWN, (void **)&pDisp)) && pDisp)
            {
                WORD    wET;

                hr = THR(arySinks.Append(pDisp));
                if (hr)
                    goto Cleanup;

                wET  = pAV->IsOldEventStyle() ? EVENTTYPE_OLDSTYLE : EVENTTYPE_EMPTY;
                wET |= pAV->IsTridentSink()   ? EVENTTYPE_VBHOOKUP : EVENTTYPE_EMPTY;

                hr = THR(arySinkType.AppendIndirect(&wET, NULL));
                if (hr)
                    goto Cleanup;

                // Upon success arySinks takes over the ref of pDisp
                pDisp = NULL;
            }
        }
    }

    whichEventType = VB_EVENTS;

NextEventSet:

    for (i = 0; i < arySinks.Size(); i++)
    {
        DISPPARAMS *pPassedParams;

        VariantClear(&Var);
        
        // If not old style event, and we have an eventObject and we're not firing the onError
        // event which already has arguments then prepare to pass the event object as an
        // argument.
        if ((!(arySinkType[i] & EVENTTYPE_OLDSTYLE)) && pEventObject && dispidProp != DISPID_EVPROP_ONERROR)
        {
            // Only compute this once.
            if (dispParams.cArgs == 0)
            {
                UINT     uIdx;

                // Fix up pdispparam
                dispParams.Initialize(pdispparams->cArgs + 1, pdispparams->cNamedArgs);
                
                hr = dispParams.Create(pdispparams);
                if (hr)
                    goto Cleanup;

                // Now dispParams.cArgs is > 0.
                uIdx = dispParams.cArgs - 1;

                V_VT(&varEO) = VT_DISPATCH;
                V_DISPATCH(&varEO) = pEventObject;

                memcpy(&(dispParams.rgvarg[uIdx]), &varEO, sizeof(VARIANT));
            }

            pPassedParams = &dispParams;
        }
        else
            pPassedParams = pdispparams;

        if (arySinkType[i] & EVENTTYPE_VBHOOKUP)
        {
            // Are we firing VB_EVENTS?
            if (whichEventType == VB_EVENTS)
            {
                // Yes, so fire the event.
                PROPERTYDESC      *pDesc;
                ITridentEventSink *pTriSink = (ITridentEventSink *)(arySinks[i]);

                if (!FindPropDescFromDispID(dispidProp, (PROPERTYDESC **)&pDesc, NULL, NULL))
                {
                    LPCOLESTR pEventString = (LPCOLESTR)(pDesc->pstrExposedName ? pDesc->pstrExposedName
                                                                      : pDesc->pstrName);
                    IGNORE_HR(pTriSink->FireEvent(pEventString, pPassedParams, &Var, pexcepinfo));
                }
                else if (pTIEventSrc)
                {
                    BSTR    eventName;

                    hr = FindEventName(pTIEventSrc, dispidEvent, &eventName);

                    if (hr == S_OK && eventName)
                    {
                        // ActiveX events don't pass the eventObject argument.
                        IGNORE_HR(pTriSink->FireEvent(eventName, pdispparams, &Var, pexcepinfo));
                    }

                    FormsFreeString(eventName);
                }
            }
        }
        else
        {
            // Firing CPC events yet?
            if (whichEventType == CPC_EVENTS)
            {
                IGNORE_HR(arySinks[i]->Invoke(dispidEvent,
                                              IID_NULL,
                                              g_lcidUserDefault,
                                              DISPATCH_METHOD,
                                              pPassedParams,
                                              &Var,
                                              pexcepinfo,
                                              puArgErr));
            }
            else
            {
                // No, just flag we got some CPC events to fire.
                f_CPCEvents = TRUE;
            }
        }

        // If we had to pass the this parameter and we had more than
        // 1 parameter then copy the orginal back over (the args could have
        // been byref).
        if (pPassedParams != pdispparams && pPassedParams->cArgs > 1)
        {
            hr = dispParams.MoveArgsToDispParams(pdispparams, pdispparams->cArgs);
            if (hr)
                goto Cleanup;
        }

        //
        // Copy return value into pvarResult if there was one.
        //

        if (pvarResult && V_VT(&Var) != VT_EMPTY)
        {
            hr = THR(VariantCopy(pvarResult, &Var));
            if (hr)
                goto Cleanup;
        }
    }

    // Any CPC events?
    if (f_CPCEvents && whichEventType == VB_EVENTS)
    {
        // Yes, and we just finished VB Events so fire all CPC events.
        whichEventType = CPC_EVENTS;
        f_CPCEvents = FALSE;
        goto NextEventSet;
    }

    Assert((whichEventType == CPC_EVENTS && !f_CPCEvents) || whichEventType == VB_EVENTS);

Cleanup:
    ReleaseInterface(pDisp);
    arySinks.ReleaseAll();
    
    RRETURN(hr);
}


HRESULT 
CBase::InvokeAttachEvents(
    DISPID          dispidProp, 
    DISPPARAMS *    pdispparams,
    VARIANT *       pvarResult,
    CBase *         pDocAccessObject,
    EXCEPINFO *     pexcepinfo,
    UINT *          puArgErr,
    IDispatch      *pEventObj)
{
    int                             iNextIdx;
    IDispatch                      *pDisp = NULL;
    CVariant                        Var;
    AAINDEX                         aaidx;
    HRESULT                         hr = S_OK;
    VARIANT                         varEventObj;
    EXCEPINFO                       excepinfo;
    UINT                            uArgErr;
    CStackPtrAry<IDispatch *, 2>    arySinks(Mt(CBaseFireEventAry_pv));
    DISPPARAMS                      dp = {NULL, NULL, 0, 0};

    if (!pDocAccessObject)
        pDocAccessObject = this;

    if (!pdispparams)
        pdispparams = &dp;

    if (!pexcepinfo)
        pexcepinfo = &excepinfo;

    if (!puArgErr)
        puArgErr = &uArgErr;

    if (dispidProp != DISPID_UNKNOWN)   // Skip property events
    {
        // Fire all functions hooked via attachEvent.
        iNextIdx = 0;

        for (;;)
        {
            aaidx = FindNextAttach(iNextIdx, dispidProp);
            if (aaidx == AA_IDX_UNKNOWN)
                break;

            hr = THR(GetDispatchObjectAt(aaidx, &pDisp));
            if (hr)
                goto Cleanup;

            hr = THR(arySinks.Append(pDisp));
            if (hr)
                goto Cleanup;

            iNextIdx++;
        }

        V_DISPATCH(&varEventObj) = pEventObj;
        V_VT(&varEventObj) = VT_DISPATCH;

        // Fire the events:
        for (int i = 0; i < arySinks.Size(); i++)
        {
            if (arySinks[i])
            {
                hr = THR_NOTRACE(InvokeDispatchExtraParam(
                    arySinks[i],
                    IID_NULL,
                    g_lcidUserDefault,
                    DISPATCH_METHOD,
                    pdispparams,
                    &Var,
                    pexcepinfo,
                    NULL,
                    &varEventObj));

                if (pvarResult && V_VT(&Var) != VT_EMPTY)
                {
                    hr = THR(VariantCopy(pvarResult, &Var));
                    if (hr)
                        goto Cleanup;
                }
            }

            Var.Clear();
        }
    }

Cleanup:
    arySinks.ReleaseAll();

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBase::FireEventV, public
//
//  Synopsis:   Fires an event out the primary dispatch event connection point
//              and using the corresponding code pointers living in attr array
//
//  Arguments:  [dispidEvent]  -- DISPID of event to fire
//              [dispidProp]   -- dispid of property where event ptr is stored
//              [pfRetVal]     -- Resultant boolean return value
//              [pbTypes]      -- Pointer to array giving the types of params
//              [...]          -- variable # of Parameters
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT __cdecl
CBase::FireEventV(
    DISPID          dispidEvent,
    DISPID          dispidProp,
    IDispatch    *  pEventObject,
    VARIANT_BOOL *  pfRetVal,
    const BYTE *    pbTypes,
    ...)
{
    HRESULT         hr;
    DISPPARAMS      dp;
    VARIANTARG      av[EVENTPARAMS_MAX];
    CExcepInfo      ei;
    UINT            uArgErr;
    va_list         valParms;
    CVariant        Var;

    va_start(valParms, pbTypes);

    dp.rgvarg = av;
    CParamsToDispParams(&dp, pbTypes, valParms);

    hr = THR(InvokeEvent(dispidEvent, dispidProp, pEventObject, &Var, &dp, &ei, &uArgErr));
    va_end(valParms);

    if (pfRetVal != NULL)
    {
        if (V_VT(&Var) == VT_BOOL) 
            *pfRetVal = V_BOOL(&Var);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CBase::FirePropertyNotify, public
//
//----------------------------------------------------------------------------

HRESULT
CBase::FirePropertyNotify(DISPID dispid, BOOL fOnChanged)
{
    IPropertyNotifySink *   pPNS = NULL;
    HRESULT                 hr = S_OK;
    AAINDEX                 aaidx = AA_IDX_UNKNOWN;
    CStackPtrAry<IPropertyNotifySink *, 2>  arySinks(Mt(CBaseFirePropertyNotify_pv));
    long                    i;

    //
    // Take sinks local first, and then fire to avoid reentrancy problems.
    //
    
    for (;;)
    {
        aaidx = FindNextAAIndex(
            DISPID_A_PROPNOTIFYSINK, 
            CAttrValue::AA_Internal, 
            aaidx);
        if (aaidx == AA_IDX_UNKNOWN)
            break;
            
        Assert(!pPNS);
        if (OK(GetUnknownObjectAt(aaidx, (IUnknown **)&pPNS)) && pPNS)
        {
            hr = THR(arySinks.Append(pPNS));
            if (hr)
                goto Cleanup;

            pPNS = NULL;   // arySinks has taken over ref.
        }
    }

    for (i = 0; i < arySinks.Size(); i++)
    {
        if (fOnChanged)
        {
            IGNORE_HR(arySinks[i]->OnChanged(dispid));
        }
        else
        {
            hr = THR_NOTRACE(arySinks[i]->OnRequestEdit(dispid));
            if (!hr)
            {
                //
                // Somebody doesn't want the change.
                //
                break;
            }
        }
    }
    
Cleanup:
    ReleaseInterface(pPNS);
    arySinks.ReleaseAll();
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CBase::GetEnabled
//
//  Synopsis:   Helper method.  Many objects will simply override this.
//
//--------------------------------------------------------------------------

STDMETHODIMP
CBase::GetEnabled(VARIANT_BOOL * pfEnabled)
{
    if (!pfEnabled)
        RRETURN(E_INVALIDARG);

    *pfEnabled = VB_TRUE;
    return DISP_E_MEMBERNOTFOUND;
}


//+-------------------------------------------------------------------------
//
//  Method:     CBase::GetValid
//
//  Synopsis:   Helper method.  Many objects will simply override this.
//
//--------------------------------------------------------------------------

STDMETHODIMP
CBase::GetValid(VARIANT_BOOL * pfValid)
{
    if (!pfValid)
        RRETURN(E_INVALIDARG);

    *pfValid = VB_TRUE;
    return DISP_E_MEMBERNOTFOUND;
}


////////////////////////////////////////////////////////////////////////////////
//
//  AttrArray helpers:
//
////////////////////////////////////////////////////////////////////////////////


AAINDEX
CBase::FindAAType(CAttrValue::AATYPE aaType, AAINDEX lastIndex)
{
    AAINDEX newIdx = AA_IDX_UNKNOWN;

    if (_pAA)
    {
        int nPos;

        if (lastIndex == AA_IDX_UNKNOWN)
        {
            nPos = 0;
        }
        else
        {
            nPos = ++lastIndex;
        }

        while (nPos < _pAA->Size())
        {
            CAttrValue *pAV = (CAttrValue *)(*_pAA) + nPos;
            // Logical & so we can find more than one type
            if (pAV->AAType() == aaType)
            {
                newIdx = (AAINDEX)nPos;
                break;
            }
            else
            {
                nPos++;
            }
        }
    }
    return newIdx;
}


BOOL
CBase::DidFindAAIndexAndDelete (DISPID dispID, CAttrValue::AATYPE aaType)
{
    BOOL    fRetValue = TRUE;
    AAINDEX aaidx;

    aaidx = FindAAIndex (dispID, aaType);

    if (AA_IDX_UNKNOWN != aaidx)
        DeleteAt (aaidx);
    else
        fRetValue = FALSE;

    return fRetValue;
}


//+------------------------------------------------------------------------
//
//  Member:     CBase::FindNextAAIndex
//
//  Synopsis:   Find next AAIndex with given dispid and aatype
//
//  Arguments:  dispid      Dispid to look for
//              aatype      AAType to look for
//              paaIdx      The aaindex of the last entry, if AA_IDX_UNKNOWN
//                          will return the 
//
//-------------------------------------------------------------------------

AAINDEX
CBase::FindNextAAIndex(
    DISPID              dispid, 
    CAttrValue::AATYPE  aaType, 
    AAINDEX             aaIndex)
{
    CAttrValue *    pAV;

    if (AA_IDX_UNKNOWN == aaIndex)
    {
        return FindAAIndex(dispid, aaType, AA_IDX_UNKNOWN, TRUE);
    }

    aaIndex++;
    if (!_pAA || aaIndex >= (ULONG)_pAA->Size())
        return AA_IDX_UNKNOWN;

    pAV = _pAA->FindAt(aaIndex);
    if (!pAV || pAV->GetDISPID() != dispid || pAV->GetAAType() != aaType)
        return AA_IDX_UNKNOWN;

    return aaIndex;
}


HRESULT
CBase::GetStringAt(AAINDEX aaIdx, LPCTSTR *ppStr)
{
    HRESULT       hr = DISP_E_MEMBERNOTFOUND;
    CAttrValue   *pAV;

    Assert(ppStr);

    *ppStr = NULL;

    // Any attr array?
    if (_pAA)
    {
        pAV = _pAA->FindAt(aaIdx);
        // Found AttrValue?
        if (pAV)
        {
            *ppStr = pAV->GetLPWSTR();
            hr = S_OK;
        }
    }

    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}

HRESULT
CBase::GetIntoBSTRAt(AAINDEX aaIdx, BSTR *pbStr )
{
    HRESULT             hr = DISP_E_MEMBERNOTFOUND;
    CAttrValue   *pAV;

    Assert(pbStr);

    *pbStr = NULL;

    // Any attr array?
    if (_pAA)
    {
        pAV = _pAA->FindAt(aaIdx);
        // Found AttrValue?
        if (pAV)
        {
            hr = S_OK;
            switch ( pAV->GetAVType() )
            {
            case VT_LPWSTR:
                hr = THR(FormsAllocString ( pAV->GetLPWSTR(), pbStr ));
                break;

            default:
                {
                    VARIANT varDest;
                    VariantInit(&varDest);
                    VARIANT varSrc;
                    VariantInit(&varSrc);

                    pAV->GetAsVariantNC(&varSrc);
                    hr = THR(VariantChangeTypeSpecial ( &varDest, &varSrc, VT_BSTR ));
                    if ( hr )
                    {
                        VariantClear ( &varDest );
                        if ( hr == DISP_E_TYPEMISMATCH )
                            hr = S_FALSE;
                        goto Cleanup;
                    }
                    *pbStr = V_BSTR ( &varDest );
                }
                break;
            }
        }
    }
Cleanup:
    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}


HRESULT
CBase::GetIntoStringAt(AAINDEX aaIdx, BSTR *pbStr, LPCTSTR *ppStr)
{
    HRESULT             hr = DISP_E_MEMBERNOTFOUND;
    CAttrValue   *pAV;

    Assert(ppStr);
    Assert (pbStr);

    *ppStr = NULL;
    *pbStr = NULL;

    // Any attr array?
    if (_pAA)
    {
        pAV = _pAA->FindAt(aaIdx);
        // Found AttrValue?
        if (pAV)
            hr = pAV->GetIntoString( pbStr, ppStr );
    }

    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}


HRESULT
CBase::GetPointerAt(AAINDEX aaIdx, void **ppv)
{
    HRESULT       hr = DISP_E_MEMBERNOTFOUND;
    CAttrValue   *pAV;

    Assert(ppv);

    *ppv = NULL;

    // Any attr array?
    if (_pAA)
    {
        pAV = _pAA->FindAt(aaIdx);
        // Found AttrValue?
        if (pAV)
        {
            *ppv = pAV->GetPointer();
            hr = S_OK;
        }
    }

    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}

HRESULT
CBase::GetVariantAt(AAINDEX aaIdx, VARIANT *pVar, BOOL fAllowNullVariant)
{
    HRESULT             hr = S_OK;
    const CAttrValue   * pAV;

    Assert(pVar);

    // Don't have an attr array or attr value will return
    // NULL variant.  Note, this will result in the return result
    // being a null.

    // Any attr array?
    if (_pAA &&  ( ( pAV = _pAA->FindAt(aaIdx) ) != NULL ) )
    {
        hr = pAV->GetIntoVariant(pVar);
        if (hr && fAllowNullVariant)
        {
            pVar->vt = VT_NULL;
        }
    }
    else
    {
        if (fAllowNullVariant)
        {
            pVar->vt = VT_NULL;
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
    }

    RRETURN(hr);
}


HRESULT
CBase::FetchObject(CAttrValue *pAV, VARTYPE vt, void **ppvoid)
{
    HRESULT       hr = DISP_E_MEMBERNOTFOUND;

    Assert(ppvoid);

    // Found AttrValue?
    if (pAV)
    {
        if (pAV->GetAVType() == vt && vt == VT_UNKNOWN)
        {
            *ppvoid = (void *)pAV->GetUnknown();
            if (*ppvoid)
                pAV->GetUnknown()->AddRef();
        }
        else if (pAV->GetAVType() == vt && vt == VT_DISPATCH)
        {
            *ppvoid = (void *)pAV->GetDispatch();
            if (*ppvoid)
                pAV->GetDispatch()->AddRef();
        }

        hr = S_OK;
    }

    RRETURN(hr);
}


HRESULT
CBase::GetObjectAt(AAINDEX aaIdx, VARTYPE vt, void **ppvoid)
{
    HRESULT       hr = DISP_E_MEMBERNOTFOUND;
    CAttrValue   *pAV;

    Assert(ppvoid);

    // Don't have an attr array or attr value will return
    // NULL IUnknown *.
    *ppvoid = NULL;

    // Any attr array?
    if (_pAA)
    {
        pAV = _pAA->FindAt(aaIdx);
        hr = FetchObject(pAV, vt, ppvoid);
    }

    RRETURN(hr);
}

#ifdef _WIN64
HRESULT
CBase::GetCookieAt(AAINDEX aaIdx, DWORD * pdwCookie)
{
    HRESULT       hr = DISP_E_MEMBERNOTFOUND;
    CAttrValue   *pAV;

    Assert(pdwCookie);

    // Don't have an attr array or attr value will return
    // NULL IUnknown *.
    *pdwCookie = 0;

    // Any attr array?
    if (_pAA)
    {
        pAV = _pAA->FindAt(aaIdx);
        if (pAV)
        {
            *pdwCookie = pAV->GetCookie();
            hr = S_OK;
        }
    }

    RRETURN(hr);
}

HRESULT
CBase::SetCookieAt(AAINDEX aaIdx, DWORD dwCookie)
{
    HRESULT       hr = DISP_E_MEMBERNOTFOUND;
    CAttrValue   *pAV;

    // Any attr array?
    if (_pAA)
    {
        pAV = _pAA->FindAt(aaIdx);
        if (pAV)
        {
            pAV->SetCookie(dwCookie);
            hr = S_OK;
        }
    }

    RRETURN(hr);
}
#endif

CAttrValue::AATYPE
CBase::GetAAtypeAt(AAINDEX aaIdx)
{
    CAttrValue::AATYPE aaType = CAttrValue::AA_Undefined;

    // Any attr array?
    if (_pAA)
    {
        CAttrValue     *pAV;

        pAV = _pAA->FindAt(aaIdx);
        // Found AttrValue?
        if (pAV)
        {
            aaType = pAV->GetAAType();
        }
    }

    return aaType;
}

UINT
CBase::GetVariantTypeAt(AAINDEX aaIdx)
{
    if (_pAA)
    {
        CAttrValue     *pAV;

        pAV = _pAA->FindAt(aaIdx);
        // Found AttrValue?
        if (pAV)
        {
            return pAV->GetAVType();
        }
    }

    return VT_EMPTY;
}


HRESULT
CBase::AddSimple(DISPID dispID, DWORD dwSimple, CAttrValue::AATYPE aaType)
{
    VARIANT varNew;

    varNew.vt = VT_I4;
    varNew.lVal = (long)dwSimple;

    RRETURN(CAttrArray::Set(&_pAA, dispID, &varNew, NULL, aaType));
}

HRESULT
CBase::AddAttrArray(DISPID dispID,
                  CAttrArray *pAttrArray,
                  CAttrValue::AATYPE aaType )
{
    VARIANT varNew;

    varNew.vt = CAttrValue::VT_ATTRARRAY;
    varNew.byref = pAttrArray;

    RRETURN(CAttrArray::Set(&_pAA, dispID, &varNew, NULL, aaType));
}

HRESULT
CBase::AddString(DISPID dispID, LPCTSTR pch, CAttrValue::AATYPE aaType)
{
    VARIANT varNew;

    varNew.vt = VT_LPWSTR;
    varNew.byref = (LPVOID)pch;

    RRETURN(CAttrArray::Set(&_pAA, dispID, &varNew, NULL, aaType));
}

HRESULT
CBase::AddPointer(DISPID dispID, void *pValue, CAttrValue::AATYPE aaType)
{
    VARIANT varNew;

    varNew.vt = VT_PTR;
    varNew.byref = pValue;

    RRETURN(CAttrArray::Set(&_pAA, dispID, &varNew, NULL, aaType));
}

HRESULT
CBase::AddBSTR (DISPID dispID, LPCTSTR pch, CAttrValue::AATYPE aaType)
{
    VARIANT varNew;
    HRESULT hr;

    varNew.vt = VT_BSTR;
    hr = THR(FormsAllocString ( pch, &V_BSTR(&varNew) ));
    if ( hr )
        goto Cleanup;

    hr = THR(CAttrArray::Set(&_pAA, dispID, &varNew, NULL, aaType));
    if ( hr )
    {
        FormsFreeString ( V_BSTR(&varNew) );
    }
Cleanup:
    RRETURN(hr);
}

HRESULT
CBase::AddVariant(DISPID dispID, VARIANT *pVar, CAttrValue::AATYPE aaType)
{
    RRETURN(CAttrArray::Set(&_pAA, dispID, pVar, NULL, aaType));
}


HRESULT
CBase::AddUnknownObject(DISPID dispID, IUnknown *pUnk, CAttrValue::AATYPE aaType)
{
    VARIANT varNew;

    varNew.vt = VT_UNKNOWN;

    varNew.punkVal = pUnk;

    RRETURN(CAttrArray::Set(&_pAA, dispID, &varNew, NULL, aaType));
}


//+---------------------------------------------------------------------------------
//
//  Member:     CBase::AddUnknownObjectMultiple
//
//  Synopsis:   Add an object to the attr array allowing for multiple
//              entries at this dispid.
//
//----------------------------------------------------------------------------------

HRESULT
CBase::AddUnknownObjectMultiple(
    DISPID dispID, 
    IUnknown *pUnk, 
    CAttrValue::AATYPE aaType,
    CAttrValue::AAExtraBits wFlags/* = CAttrValue::AA_Extra_Empty*/)
{
    VARIANT var;
    
    V_VT(&var) = VT_UNKNOWN;
    V_UNKNOWN(&var) = pUnk;
    
    RRETURN(CAttrArray::Set(&_pAA, dispID, &var, NULL, aaType, wFlags, TRUE));
}


//+---------------------------------------------------------------------------------
//
//  Member:     CBase::AddDispatchObjectMultiple
//
//  Synopsis:   Add an object to the attr array allowing for multiple
//              entries at this dispid.
//
//----------------------------------------------------------------------------------

HRESULT
CBase::AddDispatchObjectMultiple(
    DISPID dispID, 
    IDispatch *pDisp, 
    CAttrValue::AATYPE aaType,
    CAttrValue::AAExtraBits wFlags/* = CAttrValue::AA_Extra_Empty*/)
{
    VARIANT var;
    
    V_VT(&var) = VT_DISPATCH;
    V_UNKNOWN(&var) = pDisp;
    
    RRETURN(CAttrArray::Set(&_pAA, dispID, &var, NULL, aaType, wFlags, TRUE));
}


HRESULT
CBase::AddDispatchObject(DISPID dispID,
                         IDispatch *pDisp,
                         CAttrValue::AATYPE aaType,
                         CAttrValue::AAExtraBits wFlags/* = CAttrValue::AA_Extra_Empty*/)
{
    VARIANT varNew;

    varNew.vt = VT_DISPATCH;
    varNew.pdispVal = pDisp;

    RRETURN(CAttrArray::Set(&_pAA, dispID, &varNew, NULL, aaType, wFlags));
}


HRESULT
CBase::StoreEventsToHook(InlineEvts *pInlineEvts)
{
    HRESULT     hr = S_OK;
    CAttrValue *pAAHeader;

    if (!_pAA)
    {
        _pAA = new CAttrArray;
        if (!_pAA)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    pAAHeader = _pAA->EnsureHeader();
    if (pAAHeader)
    {
        pAAHeader->SetEventsToHook(pInlineEvts);
    }
    else
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}


InlineEvts *
CBase::GetEventsToHook()
{
    InlineEvts     *pEvts = NULL;
    CAttrValue     *pAAHeader;

    if (_pAA)
    {
        pAAHeader = _pAA->EnsureHeader(FALSE);
        if (pAAHeader)
        {
            pEvts = pAAHeader->GetEventsToHook();
        }
    }

    return pEvts;
}


HRESULT
CBase::ChangeSimpleAt(AAINDEX aaIdx, DWORD dwSimple)
{
    VARIANT varNew;

    varNew.vt = VT_I4;
    varNew.lVal = (long)dwSimple;

    RRETURN(_pAA ? _pAA->SetAt(aaIdx, &varNew) : DISP_E_MEMBERNOTFOUND);
}


HRESULT
CBase::ChangeStringAt(AAINDEX aaIdx, LPCTSTR pch)
{
    VARIANT varNew;

    varNew.vt = VT_LPWSTR;
    varNew.byref = (LPVOID)pch;

    RRETURN(_pAA ? _pAA->SetAt(aaIdx, &varNew) : DISP_E_MEMBERNOTFOUND);
}


HRESULT
CBase::ChangeUnknownObjectAt(AAINDEX aaIdx, IUnknown *pUnk)
{
    VARIANT varNew;

    varNew.vt = VT_UNKNOWN;
    varNew.punkVal = pUnk;

    RRETURN(_pAA ? _pAA->SetAt(aaIdx, &varNew) : DISP_E_MEMBERNOTFOUND);
}


HRESULT
CBase::ChangeDispatchObjectAt(AAINDEX aaIdx, IDispatch *pDisp)
{
    VARIANT varNew;

    varNew.vt = VT_DISPATCH;
    varNew.pdispVal = pDisp;

    RRETURN(_pAA ? _pAA->SetAt(aaIdx, &varNew) : DISP_E_MEMBERNOTFOUND);
}


HRESULT
CBase::ChangeVariantAt(AAINDEX aaIdx, VARIANT *pVar)
{
    RRETURN(_pAA ? _pAA->SetAt(aaIdx, pVar) : DISP_E_MEMBERNOTFOUND);
}


HRESULT
CBase::ChangeAATypeAt(AAINDEX aaIdx, CAttrValue::AATYPE aaType)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;

    // Any attr array?
    if (_pAA)
    {
        CAttrValue     *pAV;

        pAV = _pAA->FindAt(aaIdx);
        // Found AttrValue?
        if (pAV)
        {
            pAV->SetAAType ( aaType );
            hr = S_OK;
        }
    }

    RRETURN(hr);
}

const VTABLEDESC *
CBase::FindVTableEntryForName (LPCTSTR szName, BOOL fCaseSensitive, WORD *pVTblOffset)
{
    const CPtrBagVTableAggregate *pStringTableAggregate = GetStringTableAggregate();
    const VTABLEDESC *pVTableDesc = NULL;

    if(pStringTableAggregate)
    {
        // Retrieve the VTableDesc
        if(fCaseSensitive)
        {
            pVTableDesc = pStringTableAggregate->GetCs(szName, VTABLEDESC_BELONGSTOOM);
        }
        else
        {
            pVTableDesc = pStringTableAggregate->GetCi(szName, VTABLEDESC_BELONGSTOOM);
        }
    }
    return pVTableDesc;
}


#define GETMEMBER_CASE_SENSITIVE    0x00000001
#define GETMEMBER_AS_SOURCE         0x00000002
#define GETMEMBER_ABSOLUTE          0x00000004

HRESULT STDMETHODCALLTYPE
CBase::getAttribute(BSTR bstrPropertyName, LONG lFlags, VARIANT *pvarPropertyValue)
{
    HRESULT hr;
    DISPID dispID;
    DISPPARAMS dp = g_Zero.dispparams;
    CVariant varNULL(VT_NULL);
    PROPERTYDESC *propDesc = NULL;
    IDispatchEx *pDEX = NULL;

    if ( !bstrPropertyName || !pvarPropertyValue )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pvarPropertyValue->vt = VT_NULL;

    hr = THR(PrivateQueryInterface ( IID_IDispatchEx, (void**)&pDEX ));
    if ( hr )
        goto Cleanup;

    hr = pDEX->GetDispID(bstrPropertyName, lFlags & GETMEMBER_CASE_SENSITIVE ?
                                                fdexNameCaseSensitive : 0,
                         &dispID);
    if ( hr )
        goto Cleanup;

    // If we're asked for the SaveAs value - our best guess is to grab the attr array value. This won't
    // always work - but it's the best we can do!
    if ( lFlags & GETMEMBER_AS_SOURCE || lFlags & GETMEMBER_ABSOLUTE )
    {
        // Here we pretty much do what we do at Save time. The only difference is we don't do the GetBaseObject call
        // so certain re-directed properties won't work - e.g. the BODY onXXX properties
        if (IsExpandoDISPID(dispID, &dispID))
        {
            hr = GetIntoBSTRAt ( FindAAIndex ( dispID, CAttrValue::AA_Expando ),
                &V_BSTR(pvarPropertyValue) );
        }
        else
        {
            // Try the Unknown value first...
            hr = GetIntoBSTRAt ( FindAAIndex ( dispID, CAttrValue::AA_UnknownAttr ),
                &V_BSTR(pvarPropertyValue) );
            if ( hr == DISP_E_MEMBERNOTFOUND )
            {
                // No Unknown - try getting the attribute as it would be saved
                hr = FindPropDescFromDispID ( dispID, &propDesc, NULL, NULL );
                Assert(propDesc);
                if (!hr && propDesc->pfnHandleProperty)
                {
                    if (propDesc->pfnHandleProperty) 
                    {
                        hr = propDesc->HandleGetIntoAutomationVARIANT(this, pvarPropertyValue);

                        // This flag only works for URL properties we want to
                        // return the fully expanded URL.

                        if (lFlags & GETMEMBER_ABSOLUTE &&
#ifdef _MAC
                            propDesc->pfnHandleProperty == &PROPERTYDESC::HandleUrlProperty &&
#else
                            propDesc->pfnHandleProperty == PROPERTYDESC::HandleUrlProperty &&
#endif
                            !hr)
                        {
                            hr = ExpandedRelativeUrlInVariant(pvarPropertyValue);
                        }

                        goto Cleanup;
                    }
                    else
                        hr = DISP_E_UNKNOWNNAME;
                }
            }
        }
        
        if (!hr)
        {
            pvarPropertyValue->vt = VT_BSTR;
        }
    }
    else
    {
        // Need to check for an unknown first, because the regular get_'s will return
        // a default. No point in doing this if we're looking at an expando
        if (!IsExpandoDISPID(dispID))
        {
            hr = GetIntoBSTRAt(FindAAIndex(dispID, CAttrValue::AA_UnknownAttr),
                               &V_BSTR(pvarPropertyValue));
            // If this worked - we're done.
            if (!hr)
            {
                pvarPropertyValue->vt = VT_BSTR;
                goto Cleanup;
            }
        } 

        // See if we can get a regular property or expando
        hr = THR(pDEX->InvokeEx(dispID,
                                g_lcidUserDefault,
                                DISPATCH_PROPERTYGET,
                                &dp,
                                pvarPropertyValue,
                                NULL,
                                NULL));
    }


Cleanup:
    ReleaseInterface ( pDEX );
    if ( hr == DISP_E_UNKNOWNNAME || hr == DISP_E_MEMBERNOTFOUND)
    {
        // Couldn't find property - return a Null rather than an error
        hr = S_OK;
    }
    RRETURN ( SetErrorInfo ( hr ) );
}


HRESULT STDMETHODCALLTYPE
CBase::removeAttribute(BSTR strPropertyName, LONG lFlags, VARIANT_BOOL *pfSuccess)
{
    DISPID dispID;
    IDispatchEx *pDEX = NULL;

    if (pfSuccess)
        *pfSuccess = VB_FALSE;

    if (THR_NOTRACE(PrivateQueryInterface ( IID_IDispatchEx, (void**)&pDEX )))
        goto Cleanup;

    if (THR_NOTRACE(pDEX->GetDispID(strPropertyName, lFlags & GETMEMBER_CASE_SENSITIVE ?
                                                    fdexNameCaseSensitive : 0, &dispID)))
        goto Cleanup;

    if (!removeAttributeDispid(dispID))
        goto Cleanup;

    if (pfSuccess)
        *pfSuccess = VB_TRUE;

Cleanup:
    ReleaseInterface ( pDEX );

    RRETURN ( SetErrorInfo ( S_OK ) );
}

// HACKHACK: part of the hack below we need to access these symbols
EXTERN_C const PROPERTYDESC_NUMPROP s_propdescCTableCellrowSpan;
EXTERN_C const PROPERTYDESC_NUMPROP s_propdescCTableCellcolSpan;

BOOL
CBase::removeAttributeDispid(DISPID dispid, const PROPERTYDESC *pPropDesc /*=NULL*/)
{
    AAINDEX aaIx;
    BOOL fExpando;
    CVariant varNULL(VT_NULL);

    if( pPropDesc )
    {
        Assert( pPropDesc->GetDispid() == dispid );
    }

    fExpando = IsExpandoDISPID( dispid );

    // make sure we have a prop desc
    if (!fExpando && !pPropDesc)
    {
        if (dispid == STDPROPID_XOBJ_STYLE)
        {
            pPropDesc = (PROPERTYDESC *)&s_propdescCElementstyle_Str;
        }
        else
        {
            const VTABLEDESC * pVtDesc = _pAA->FindInGINCache(dispid);
            AssertSz(pVtDesc, "And I thought we were guaranteed to get a nonzero VTABLEDESC because of a recent call to GetDisp");
            Assert(pVtDesc->pPropDesc);

            pPropDesc = pVtDesc->FastGetPropDesc(VTABLEDESC_BELONGSTOOM);
            Assert(pPropDesc);
        }
    }

    // find aaIx
    if(dispid != STDPROPID_XOBJ_STYLE)
    {
        aaIx = FindAAIndex ( dispid, fExpando ?
                CAttrValue::AA_Expando :
                CAttrValue::AA_Attribute);
        if (aaIx == AA_IDX_UNKNOWN)
            return FALSE;
    }
    else
    {
        // We cannot delete the inline style object. It is created "on demand".
        // We need to remove it's attrarray that stored on the element.
        aaIx = FindAAIndex ( DISPID_INTERNAL_INLINESTYLEAA, CAttrValue::AA_AttrArray );

        if (aaIx == AA_IDX_UNKNOWN)
            return FALSE;

        CBase *pStyle = NULL;
        GetPointerAt(FindAAIndex(DISPID_INTERNAL_CSTYLEPTRCACHE,CAttrValue::AA_Internal), (void **)&pStyle);
        if (pStyle)
            pStyle->SetAttrArray(NULL);
    }


#ifndef NO_EDIT
    {
        BOOL fTreeSync = FALSE;
        BOOL fCreateUndo = (!fExpando || !g_fInVizAct2000) && QueryCreateUndo(TRUE, FALSE, &fTreeSync);

        // HACK (JHarding): VizAct 2000 gets confused if we undo expandos, so we have to disable it for them (99897)

        if( fCreateUndo || fTreeSync )
        {
            HRESULT     hr;
            CVariant    varOld;
            IDispatch * pDisp = NULL;

            hr = THR(PunkOuter()->QueryInterface(IID_IDispatch, (LPVOID*)&pDisp));
            if (hr)
                goto UndoCleanup;

            // HACKHACK: (jbeda) Hack in response to IE6 bug # 29479.
            //           get_[row|col]Span and put_[row|col]Span are not
            //           symmetric.
            if (pPropDesc
                && (    pPropDesc == &(s_propdescCTableCellrowSpan.a)
                    ||  pPropDesc == &(s_propdescCTableCellcolSpan.a)))
            {
                PROPERTYDESC_NUMPROP *pnumprop = (PROPERTYDESC_NUMPROP*)pPropDesc;
                V_VT(&varOld) = pnumprop->b.vt;
                hr = THR(pnumprop->b.GetNumberProperty(&V_I4(&varOld), this, CVOID_CAST(GetAttrArray())));
                if (hr)
                    goto UndoCleanup;
            }
            else
            {

                hr = THR(GetDispProp(
                               pDisp,
                               dispid,
                               g_lcidUserDefault,
                               &varOld));
                if (hr)
                    goto UndoCleanup;
            }

            if( fTreeSync )
            {
                LogAttributeChange( dispid, &varOld, NULL );
            }

            if( fCreateUndo )
            {
                hr = THR(CreatePropChangeUndo(dispid, &varOld, NULL));
            }
            // Else CVariant destructor cleans up varOld

UndoCleanup:
            ReleaseInterface( pDisp ); 
        }
    }
#endif // NO_EDIT

    if (fExpando)
    {
        IGNORE_HR(UpdateDomAttrCollection(TRUE, dispid));

        // Etherize the DOM expando attr node if present.
        RemoveDOMAttrNode(dispid);
    }

    DeleteAt(aaIx);

    if ( !fExpando )
    {
        CLock Lock (this); // For OnPropertyChange

        // Need to fire a property change event
        if (THR(OnPropertyChange(dispid, pPropDesc->GetdwFlags())))
            return FALSE;
    }

    return TRUE;
}


HRESULT STDMETHODCALLTYPE
CBase::setAttribute(BSTR strPropertyName, VARIANT varPropertyValue, LONG lFlags)
{
    HRESULT hr;
    DISPID dispID;
    DISPPARAMS dp;
    EXCEPINFO   excepinfo;
    UINT uArgError;
    DISPID  dispidPut = DISPID_PROPERTYPUT; // Dispid of prop arg.
    CVariant varNULL(VT_NULL);
    IDispatchEx *pDEX = NULL;
    VARIANT *pVar;

    // Implementation leverages the existing Invoke mechanism

    InitEXCEPINFO(&excepinfo);

    if ( !strPropertyName  )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(PrivateQueryInterface ( IID_IDispatchEx, (void**)&pDEX ));
    if ( hr )
        goto Cleanup;

    hr = THR ( pDEX->GetDispID (strPropertyName, lFlags & GETMEMBER_CASE_SENSITIVE ?
                                    fdexNameCaseSensitive | fdexNameEnsure: fdexNameEnsure, &dispID) );
    if ( hr )
        goto Cleanup;

    pVar = V_ISBYREF(&varPropertyValue) ? V_VARIANTREF(&varPropertyValue) :
                                          &varPropertyValue;

    dp.rgvarg = pVar;
    dp.rgdispidNamedArgs = &dispidPut;
    dp.cArgs = 1;
    dp.cNamedArgs = 1;

    // See if it's accepted as a regular property or expando
    hr = THR ( pDEX->Invoke ( dispID,
                              IID_NULL,
                              g_lcidUserDefault,
                              DISPATCH_PROPERTYPUT,
                              &dp,
                              NULL,
                              &excepinfo,
                              &uArgError ) );

    if ( hr )
    {
        // Failed to parse .. make an unknown
        CVariant varBSTR;
        const PROPERTYDESC *ppropdesc;
        const BASICPROPPARAMS *bpp;

        CLock Lock (this); // For OnPropertyChange

        ppropdesc = FindPropDescForName ( strPropertyName );
        if ( !ppropdesc )
            goto Cleanup;

        // It seems sensible to only allow string values for unknowns so we can always
        // persist them.
        // Try to see if it parses as a valid value
        // Coerce it to a string...
        hr = THR(VariantChangeTypeSpecial ( &varBSTR, pVar, VT_BSTR, NULL, VARIANT_NOVALUEPROP ));
        if ( hr )
            goto Cleanup;

        // Add it as an unknown (invalid) value
        // SetString with fIsUnkown set to TRUE
        hr = CAttrArray::SetString ( &_pAA, ppropdesc,
            (LPTSTR)varBSTR.bstrVal, TRUE );
        if ( hr )
            goto Cleanup;

        bpp = (const BASICPROPPARAMS*)(ppropdesc+1);

        // Need to fire a property change event
        hr = THR(OnPropertyChange(bpp->dispid, bpp->dwFlags, (PROPERTYDESC *)ppropdesc));
    }

Cleanup:
    ReleaseInterface ( pDEX );
    FreeEXCEPINFO(&excepinfo);
    RRETURN ( SetErrorInfo ( hr ) );
}


BOOL
CBase::IsExpandoDISPID (DISPID dispid, DISPID *pOLESiteExpando /*= NULL*/)
{
    DISPID  tmpDispID;

    if (!pOLESiteExpando)
        pOLESiteExpando = &tmpDispID;

    if (dispid >= DISPID_EXPANDO_BASE &&
        dispid <= DISPID_EXPANDO_MAX)
    {
         *pOLESiteExpando = dispid;
    }
    else if (dispid >= DISPID_ACTIVEX_EXPANDO_BASE &&
             dispid <= DISPID_ACTIVEX_EXPANDO_MAX)
    {
        *pOLESiteExpando = (dispid - DISPID_ACTIVEX_EXPANDO_BASE) + DISPID_EXPANDO_BASE;
    }
    else
    {
        *pOLESiteExpando = dispid;
        return FALSE;
    }

    return TRUE;
}


HRESULT
CBase::toString(BSTR *bstrString)
{
    HRESULT    hr;
    DISPPARAMS dp = g_Zero.dispparams;
    CVariant   var;

    if ( !bstrString)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *bstrString = NULL;

     hr = THR ( Invoke ( DISPID_VALUE, IID_NULL, g_lcidUserDefault,
            DISPATCH_PROPERTYGET,  &dp, &var, NULL, NULL ) );
    if(hr)
        goto Cleanup;

    hr = var.CoerceVariantArg(VT_BSTR);
    if(hr)
        goto Cleanup;

    *bstrString = V_BSTR(&var);
    // Don't allow deletion of the BSTR
    V_VT(&var) = VT_EMPTY;
     
Cleanup:
    RRETURN ( SetErrorInfo ( hr ) );
}

const CPtrBagVTableAggregate * 
CBase::GetStringTableAggregate(const CLASSDESC * pBaseDesc /*= NULL*/ ) 
{ 
    if (!pBaseDesc)
        pBaseDesc = BaseDesc();

    if ( pBaseDesc && pBaseDesc->_apHdlDesc ) 
        return pBaseDesc->_apHdlDesc->pStringTableAggregate;
    else
        return NULL;
}

template < UINT nway2pwr > class CNCache;
typedef CNCache < 3 >   C8Cache;


//+---------------------------------------------------------------
//
//  Member:     FindPropDescFromDispID (private)
//
//  Synopsis:   Find a PROPERTYDESC based on the dispid.
//
//  Arguments:  dispidMember    - PROPERTY/METHOD to find
//              ppDesc          - PROPERTYDESC/METHODDESC found
//              pwEntry         - Byte offset in v-table of virtual function
//
//  Returns:    S_OK            everything is fine
//              E_INVALIDARG    ppDesc is NULL
//              S_FALSE         dispidMember not found in PROPDESC array
//--------------------------------------------------------------------------

#define AUTOMATION_VTBL_ENTRIES   7     // Includes IUnknown + IDispatch functions

HRESULT
CBase::FindPropDescFromDispID(DISPID dispidMember, PROPERTYDESC **ppDesc, WORD *pwEntry, WORD *pwIIDIndex)
{
    HRESULT                     hr = S_OK;
    const VTABLEDESC           *pVTblDesc;
    C8Cache *                   pCache = NULL;
    const CBase::CLASSDESC *    pBaseDesc = NULL;
    WHEN_DBG(BOOL               fVerify = TRUE);

    if (!ppDesc)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppDesc = NULL;
    if (pwEntry)
        *pwEntry = 0;
    if (pwIIDIndex)
        *pwIIDIndex = 0;

    // Check cache before we try a linear search?
    pVTblDesc = _pAA ? _pAA->FindInGINCache(dispidMember) : NULL;


    // If that Didn't work, try the TLS hash/cache
    if (!pVTblDesc)
    {
        CHtPvPv *           pht = &TLS(htVTblDescDispIDCaches);

        pBaseDesc = BaseDesc();
        Assert( pBaseDesc );

        pCache = (C8Cache*)pht->Lookup( (void*)pBaseDesc );
        if (pCache)
        {
            if (pCache->Lookup( (DWORD_PTR)dispidMember, (DWORD_PTR*)&pVTblDesc ))
            {
                // set pCache to NULL so we don't try to cache again.
                pCache = NULL;
                goto Found;
            }
        }
        else
        {
            pCache = new C8Cache((DWORD_PTR)DISPID_UNKNOWN, 0x0);
            if (pCache)
            {
                HRESULT hr2 = pht->Insert( (void*)pBaseDesc, pCache );
                if (hr2)
                {
                    delete pCache;
                    pCache = NULL;
                }
            }
        }
    }

    if (!pVTblDesc)
    {
        WHEN_DBG(fVerify = FALSE);

        const CPtrBagVTableAggregate *pStringTableAggregate = GetStringTableAggregate(pBaseDesc);
        if(pStringTableAggregate)
        {
            CPtrBagVTableAggregate::CIterator vTableIterator(pStringTableAggregate);
            const VTABLEDESC  *pVTblDescIter;
        
            for (vTableIterator.Start(VTABLEDESC_BELONGSTOOM); !vTableIterator.End(); vTableIterator.Next())
            {
                const PROPERTYDESC *pPropDesc;

                pVTblDescIter = vTableIterator.Item();
                Assert(pVTblDescIter);

                pPropDesc = pVTblDescIter->FastGetPropDesc(VTABLEDESC_BELONGSTOOM);
                Assert(pPropDesc);

                if (dispidMember == pPropDesc->GetDispid())
                {
                    pVTblDesc = pVTblDescIter;

                    goto Found;
                }
            } // vTableIter loop
        } // pStringTableAggregate if
    }

Found:

#if DBG==1
    // We only do the verify if we used one of the caches (GINcache or hash/cache)
    if (fVerify)
    {
        const VTABLEDESC           *pVTblDescVerify = NULL;

        const CPtrBagVTableAggregate *pStringTableAggregate = GetStringTableAggregate(pBaseDesc);
        if(pStringTableAggregate)
        {
            CPtrBagVTableAggregate::CIterator vTableIterator(pStringTableAggregate);
            const VTABLEDESC  *pVTblDescIter;
        
            for (vTableIterator.Start(VTABLEDESC_BELONGSTOOM); !vTableIterator.End(); vTableIterator.Next())
            {
                const PROPERTYDESC *pPropDesc;

                pVTblDescIter = vTableIterator.Item();
                Assert(pVTblDescIter);

                pPropDesc = pVTblDescIter->FastGetPropDesc(VTABLEDESC_BELONGSTOOM);
                Assert(pPropDesc);

                if (dispidMember == pPropDesc->GetDispid())
                {
                    pVTblDescVerify = pVTblDescIter;
                    break;
                }
            } // vTableIter loop
        } // pStringTableAggregate if

        Assert( pVTblDescVerify == pVTblDesc );
    }
#endif


    if (pVTblDesc)
    {
        *ppDesc = const_cast<PROPERTYDESC *>(pVTblDesc->FastGetPropDesc(VTABLEDESC_BELONGSTOOM));
        Assert(ppDesc);

        if (pwIIDIndex) 
            *pwIIDIndex = (USHORT)pVTblDesc->uVTblEntry >> 8;
        if (pwEntry)
            *pwEntry = ((pVTblDesc->uVTblEntry & 0xff) + AUTOMATION_VTBL_ENTRIES) * sizeof(void *);  // Adjust for IDispatch methods
    }
    else
    {
        hr = S_FALSE;
    }

    // Add to the cache -- even if we didn't find it!
    if (pCache)
        pCache->Cache( (DWORD_PTR)dispidMember, (DWORD_PTR)pVTblDesc );

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+----------------------------------------------------------------------------
//
//  Function:   DeinitVTblDescDispIDCaches
//
//  Synopsis:   Clean up htVTblDescDispIDCaches
//
//  Arguments:  pts - THREADSTATE for current thread
//
//-----------------------------------------------------------------------------
void DeinitVTblDescDispIDCaches(THREADSTATE *pts)
{
    Assert(pts);

    C8Cache *   p8Cache;
    UINT        iIndex;

    for (p8Cache = (C8Cache *)(pts->htVTblDescDispIDCaches.GetFirstEntry(&iIndex)); 
         p8Cache;
         p8Cache = (C8Cache *)(pts->htVTblDescDispIDCaches.GetNextEntry(&iIndex)))
    {
        delete p8Cache;
    }

    pts->htVTblDescDispIDCaches.ReInit();
}

//+---------------------------------------------------------------------------------
//
//  Member:     DefaultMembers
//
//  Synopsis:   sets all class members defined in pdl as members (not attr array)
//              to default value specified in pdl
//
//----------------------------------------------------------------------------------

HRESULT
CBase::DefaultMembers()
{
    HRESULT hr = S_OK;
    CPtrBagVTableAggregate::CIterator vTableIterator(GetStringTableAggregate());
        
    for (vTableIterator.Start(VTABLEDESC_BELONGSTOPARSE); !vTableIterator.End(); vTableIterator.Next())
    {
        const VTABLEDESC *pVTblDesc = vTableIterator.Item();
        const PROPERTYDESC *pPropDesc = pVTblDesc->FastGetPropDesc(VTABLEDESC_BELONGSTOPARSE);
        Assert(pPropDesc);

        const BASICPROPPARAMS *pbpp = (BASICPROPPARAMS *)(pPropDesc + 1);

        if (!(pbpp->dwPPFlags & PROPPARAM_ATTRARRAY))
        {
            hr = pPropDesc->Default(this);
            if (hr)
                goto Cleanup;
        }
    }
Cleanup:
    RRETURN (hr);
}



const ENUMDESC g_enumdescFalseTrue = 
{ 2, 3, {
    { _T("False"),0},
    { _T("True"),-1},
} };


//+---------------------------------------------------------------------------------
//  Member:     GetEnumDescFromDispID - Helper for IPerPropertyBrowsing
//
//  Synopsis:   Returns the enumdesc for given property. It also returns an enumDesk
//                  for booleans
//--------------------------------------------------------------------------------

HRESULT 
CBase::GetEnumDescFromDispID(DISPID dispID, const ENUMDESC **ppEnumDesc)
{
    PROPERTYDESC  * pPropDesc;
    HRESULT         hr;

    // Get the propertydesc by property dispid
    hr = THR(FindPropDescFromDispID(dispID, &pPropDesc, NULL, NULL));
    if(hr)
    {
        if(hr == S_FALSE)
            hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Check if the property is a boolean
    if(pPropDesc->GetBasicPropParams()->wInvFunc == IDX_GS_VARIANTBOOL || 
       pPropDesc->GetBasicPropParams()->wInvFunc == IDX_G_VARIANTBOOL)
    {
        // we have a boolean, return the special enumDesc for Booleans
        *ppEnumDesc = &g_enumdescFalseTrue;
    }
    else
    {    
         // Get the enumDesc
        *ppEnumDesc =  pPropDesc->GetEnumDescriptor();
        if(!(*ppEnumDesc) || !(*ppEnumDesc)->cEnums)
        {
            // No enum description and the property is not boolean, we need to fail
            hr = E_NOTIMPL;
            goto Cleanup;
        }
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------------
//  Member:     IPerPropertyBrowsing::GetDisplayString
//
//  Synopsis:   Returns the value of the property as a string
//--------------------------------------------------------------------------------

HRESULT 
CBase::GetDisplayString(DISPID dispID, BSTR *pBstr)
{
    HRESULT          hr;
    const ENUMDESC * pEnumDesc;
    AAINDEX          idx;
    CAttrValue     * pAV = NULL;
    
    if(!pBstr)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *pBstr = NULL;

    idx = FindAAIndex(dispID, CAttrValue::AA_Attribute);
    if(idx == AA_IDX_UNKNOWN)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    if(_pAA)
    {
        pAV = _pAA->FindAt(idx);
    }

    if(!pAV)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    hr = THR(GetEnumDescFromDispID(dispID, &pEnumDesc));
    if(hr)
        goto Cleanup;

    // Return the corresponding enum string
    hr = THR(pEnumDesc->StringFromEnum(pAV->GetLong(), pBstr));
    if(hr)
        goto Cleanup;
  
Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------------
//  Member:     IPerPropertyBrowsing::MapPropertyToPage
//
//  Synopsis:   We do not support this call
//--------------------------------------------------------------------------------

HRESULT 
CBase::MapPropertyToPage(DISPID dispID, CLSID *pClsid)
{
    if(pClsid)
        *pClsid = CLSID_NULL;
    RRETURN(SetErrorInfo(PERPROP_E_NOPAGEAVAILABLE));
}


//+---------------------------------------------------------------------------------
//  Member:     IPerPropertyBrowsing::GetPredefinedStrings
//
//  Synopsis:   Returns a counted array of strings (LPOLESTR pointers) listing the
//                description of the allowable values that the specified property
//                can accept.
//              dispID - the property to use
//              pCaStringsOut - counted array of the possible property values
//              pCaCookiesOut - counted array of cookies that allow to get the
//                 associated string by calling GetPredefinedValue
//--------------------------------------------------------------------------------

HRESULT 
CBase::GetPredefinedStrings(DISPID dispID, CALPOLESTR  *pCaStringsOut, CADWORD *pCaCookiesOut)
{
    HRESULT          hr;
    const ENUMDESC * pEnumDesc;
    BSTR           * pStrings = NULL;
    DWORD          * pCookies = NULL;
    LPOLESTR         szName;
    TCHAR          * tchName;
    int              nEnums = 0;
    int              nIndex = 0;
    
    if(!pCaStringsOut || !pCaCookiesOut)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(GetEnumDescFromDispID(dispID, &pEnumDesc));
    if(hr)
        goto Cleanup;

    nEnums = pEnumDesc ->cEnums;

    // Allocate the memory for the array of strings    
    pStrings = (BSTR *)CoTaskMemAlloc(sizeof(BSTR) * nEnums);
    if(!pStrings)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Allocate memory for the array of cookies
    pCookies = (DWORD *)CoTaskMemAlloc(sizeof(DWORD) * nEnums);
    if(!pCookies)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Fill the arrays. We use enum indexes as cookies, so it is faster to look
    //  the string up using the cookies later
    for(nIndex = 0; nIndex < nEnums; nIndex++)
    {
        pCookies[nIndex] = nIndex;
        // For enums get the value from the enumdesc
        tchName = pEnumDesc->aenumpairs[nIndex].pszName;
        if(!(*tchName))
            tchName = _T("not set");

        hr = THR(TaskAllocString(tchName, &szName));
        if(hr)
            goto Cleanup;
        pStrings[nIndex] = szName;
    }
    
    // Set the number of values into the return structures
    pCaStringsOut->cElems = pCaCookiesOut->cElems = nEnums;
    // Set the array pointers
    pCaStringsOut->pElems = pStrings;
    pCaCookiesOut->pElems = pCookies;

Cleanup:
    if(hr)
    {   
        for(int i = 0; i < nIndex; i++)
            TaskFreeString(pStrings[i]);
        CoTaskMemFree(pStrings);
        CoTaskMemFree(pCookies);
    }

    RRETURN1(SetErrorInfo(hr), S_FALSE);
}



//+---------------------------------------------------------------------------------
//  Member:     IPerPropertyBrowsing::GetPredefinedValue
//
//  Synopsis:   Returns a Variant containing the value of a property identified with 
//                dispID that is associated with a predefined string (enum) name
//                as returned from GetPredefinedStrings
//              dispID - the property to use
//              dwCookie - the value from GetPredefinedStrings
//              pVarOut - the return value
//--------------------------------------------------------------------------------

HRESULT 
CBase::GetPredefinedValue(DISPID dispID, DWORD dwCookie, VARIANT *pVarOut)
{
    HRESULT          hr;
    const ENUMDESC * pEnumDesc;
    int              nEnums;
    
    if(!pVarOut)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(GetEnumDescFromDispID(dispID, &pEnumDesc));
    if(hr)
        goto Cleanup;

    nEnums = pEnumDesc ->cEnums;

    if(dwCookie >= (DWORD)nEnums)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if(&g_enumdescFalseTrue != pEnumDesc)
    {
        // Return string values for enums
        hr = THR(FormsAllocString(pEnumDesc->aenumpairs[dwCookie].pszName, &V_BSTR(pVarOut)));
        if(hr)
            goto Cleanup;
        V_VT(pVarOut) = VT_BSTR;
    }
    else
    {
        // For booleans return a VARIANT_BOOL
        Assert(dwCookie == 0 || dwCookie == 1);
        V_BOOL(pVarOut) = pEnumDesc->aenumpairs[dwCookie].iVal;
        V_VT(pVarOut) = VT_BOOL;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}



//+-------------------------------------------------------------------------
//
//  Method:     MatchExactGetIDsOfNames, (exported helper used by shdocvw)
//
//  Synopsis:   Loop through all property entries in ITypeInfo does a case
//              sensitive match (GetIDsofNames is case insensitive).
//
//  Results:    S_OK                - return dispid of found name
//              DISP_E_UNKNOWNNAME  - name not found
//
//--------------------------------------------------------------------------
STDAPI
MatchExactGetIDsOfNames(ITypeInfo *pTI,
                        REFIID riid,
                        LPOLESTR *rgszNames,
                        UINT cNames,
                        LCID lcid,
                        DISPID *rgdispid,
                        BOOL fCaseSensitive)
{
    HRESULT         hr = S_OK;
    CTypeInfoNav    tin;
    STRINGCOMPAREFN pfnCompareString;

    if (cNames == 0)
        goto Cleanup;

    if (!IsEqualIID(riid, IID_NULL) || !pTI || !rgszNames || !rgdispid)
        RRETURN(E_INVALIDARG);

    pfnCompareString = fCaseSensitive ? StrCmpC : StrCmpI;

    rgdispid[0] = DISPID_UNKNOWN;

    // Loop thru properties.
    hr = tin.InitITypeInfo(pTI);
    while ((hr = tin.Next()) == S_OK)
    {
        VARDESC        *pVar;
        FUNCDESC       *pFunc;
        DISPID          memid = DISPID_UNKNOWN;

        if ((pVar = tin.getVarD()) != NULL)
        {
            memid = pVar->memid;
        }
        else if ((pFunc = tin.getFuncD()) != NULL)
        {
            memid = pFunc->memid;
        }

        // Got a property?
        if (memid != DISPID_UNKNOWN)
        {
            BSTR            bstrName;
            unsigned int    cNameRet;

            // Get the name.
            hr = THR(pTI->GetNames(memid, &bstrName, 1, &cNameRet));
            if (hr)
                break;

            if (cNameRet == 1)
            {
                // Does it match?
                if (pfnCompareString(rgszNames[0], bstrName) == 0)
                {
                    rgdispid[0] = memid;
                    SysFreeString(bstrName);
                    break;
                }

                SysFreeString(bstrName);
           }
        }
    }

Cleanup:
    if (hr || rgdispid[0] == DISPID_UNKNOWN)
        hr = DISP_E_UNKNOWNNAME;

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     attachEvent
//
//  Synopsis:   Adds an AA_AttachEvent entry to attrarray to support multi-
//              casting of onNNNNN events.
//
//--------------------------------------------------------------------------

HRESULT
CBase::attachEvent(BSTR bstrEvent, IDispatch* pDisp, VARIANT_BOOL *pResult)
{
    HRESULT         hr = S_OK;
    DISPID          dispid;
    IDispatchEx *   pDEXMe = NULL;
    
    if (!pDisp || !bstrEvent || IsPassivating())
        goto Cleanup;

    hr = THR_NOTRACE(PrivateQueryInterface(IID_IDispatchEx, (void **)&pDEXMe));
    if (hr)
        goto Cleanup;
        
    //
    // TODO: (anandra) Always being case sensitive here.  Need to
    // check for VBS and be insensitive then.
    //
    
    hr = THR_NOTRACE(pDEXMe->GetDispID(bstrEvent, fdexNameCaseSensitive | fdexNameEnsure, &dispid));
    if (hr)
        goto Cleanup;

    hr = THR(AddDispatchObjectMultiple(dispid,
                                       pDisp,
                                       CAttrValue::AA_AttachEvent,
                                       CAttrValue::AA_Extra_OldEventStyle));

    // let opp know that an event was attached.
    IGNORE_HR(OnPropertyChange(DISPID_EVPROP_ONATTACHEVENT, 0));

Cleanup:
    if (pResult)
    {
        *pResult = hr ? VARIANT_FALSE : VARIANT_TRUE;
    }
    ReleaseInterface(pDEXMe);
    RRETURN(SetErrorInfo(hr));
}


//+-------------------------------------------------------------------------
//
//  Method:     detachEvent
//
//  Synopsis:   Loops through all AA_AttachEvent entries in the attrarray
//              and removes first entry who's COM identity is the same as
//              the pDisp passed in.
//
//--------------------------------------------------------------------------

HRESULT
CBase::detachEvent(BSTR bstrEvent, IDispatch *pDisp)
{
    AAINDEX         aaidx = AA_IDX_UNKNOWN;
    DISPID          dispid;
    IDispatch *     pThisDisp = NULL;
    HRESULT         hr = S_OK;
    IDispatchEx *   pDEXMe = NULL;
    
    if (!pDisp || !bstrEvent)
        goto Cleanup;

    hr = THR_NOTRACE(PrivateQueryInterface(IID_IDispatchEx, (void **)&pDEXMe));
    if (hr)
        goto Cleanup;
        
    //
    // TODO: (anandra) Always being case sensitive here.  Need to
    // check for VBS and be insensitive then.
    //
    
    hr = THR_NOTRACE(pDEXMe->GetDispID(bstrEvent, fdexNameCaseSensitive, &dispid));
    if (hr)
        goto Cleanup;

    // Find event that has this function pointer.
    for (;;)
    {
        aaidx = FindNextAAIndex(dispid, CAttrValue::AA_AttachEvent, aaidx);
        if (aaidx == AA_IDX_UNKNOWN)
            break;

        ClearInterface(&pThisDisp);
        if (GetDispatchObjectAt(aaidx, &pThisDisp))
            continue;

        if (IsSameObject(pDisp, pThisDisp))
            break;
    };

    // Found item to delete?
    if (aaidx != AA_IDX_UNKNOWN)
    {
        DeleteAt(aaidx);
    }

Cleanup:
    ReleaseInterface(pThisDisp);
    ReleaseInterface(pDEXMe);
    RRETURN(SetErrorInfo(S_OK));
}


EVENTINFO::~EVENTINFO()
{
    delete _pParam ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\core\cdbase\basemso.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1994.
//
//  File:       src\core\cdbase\basemso.cxx
//
//  Contents:   Implementation of IOleCommandTarget
//
//  Classes:    CBase
//
//  Functions:
//
//  History:    12-Sep-95   JuliaC    Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_PRIVCID_H_
#define X_PRIVCID_H_
#include "privcid.h"
#endif

#ifndef X_COREGUID_H_
#define X_COREGUID_H_
#include "coreguid.h"
#endif

#ifndef X_SHELL_H_
#define X_SHELL_H_
#include "shell.h"
#endif

#ifndef X_DWNNOT_H_
#define X_DWNNOT_H_
#include "dwnnot.h"
#endif

DeclareTag(tagMsoCommandTarget, "IOleCommandTarget", "IOleCommandTarget methods in CBase")


//+-------------------------------------------------------------------------
//
//  IOleCommandTarget implementation
//
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Method:     CBase::IsCmdGroupSupported, static
//
//  Synopsis:   Determine if the given command group is supported.
//
//--------------------------------------------------------------------------

BOOL
CBase::IsCmdGroupSupported(const GUID *pguidCmdGroup)
{
    return pguidCmdGroup == NULL || *pguidCmdGroup == CGID_MSHTML ||
            *pguidCmdGroup == CGID_ShellDocView || 
            *pguidCmdGroup == CGID_IWebBrowserPriv ||
            *pguidCmdGroup == CGID_ShortCut ||
            *pguidCmdGroup == CGID_Explorer ||
            *pguidCmdGroup == CGID_DownloadHost;
}

// The following enum is defined by classic MSHTML
enum 
{
    HTMLID_FIND         = 1,
    HTMLID_VIEWSOURCE   = 2,
    HTMLID_OPTIONS      = 3,
    NAMELESS_ENUM_Last_Enum
};


struct MAP 
{ 
    short idm; 
    USHORT usCmdID; 
};

static MAP amapCommandSet95[] =
{
    IDM_OPEN, OLECMDID_OPEN,
    IDM_NEW, OLECMDID_NEW,
    IDM_SAVE, OLECMDID_SAVE,
    IDM_SAVEAS, OLECMDID_SAVEAS,
    IDM_SAVECOPYAS, OLECMDID_SAVECOPYAS,
    IDM_PRINT, OLECMDID_PRINT,
    IDM_PRINTPREVIEW, OLECMDID_PRINTPREVIEW,
    IDM_SHOWPRINT, OLECMDID_SHOWPRINT,
    IDM_SHOWPAGESETUP, OLECMDID_SHOWPAGESETUP,
    IDM_PAGESETUP, OLECMDID_PAGESETUP,
    IDM_SETPRINTTEMPLATE, OLECMDID_SETPRINTTEMPLATE,
    IDM_GETPRINTTEMPLATE, OLECMDID_GETPRINTTEMPLATE,
    IDM_SPELL, OLECMDID_SPELL,
    IDM_PROPERTIES, OLECMDID_PROPERTIES,
    IDM_CUT, OLECMDID_CUT,
    IDM_COPY, OLECMDID_COPY,
    IDM_PASTE, OLECMDID_PASTE,
    IDM_PASTESPECIAL, OLECMDID_PASTESPECIAL,
    IDM_UNDO, OLECMDID_UNDO,
    IDM_REDO, OLECMDID_REDO,
    IDM_SELECTALL, OLECMDID_SELECTALL,
    IDM_CLEARSELECTION, OLECMDID_CLEARSELECTION,
    IDM_STOP, OLECMDID_STOP,
    IDM_REFRESH, OLECMDID_REFRESH,
    IDM_STOPDOWNLOAD, OLECMDID_STOPDOWNLOAD,
    IDM_ENABLE_INTERACTION, OLECMDID_ENABLE_INTERACTION,
    OLECMDID_ONUNLOAD, OLECMDID_ONUNLOAD,
    IDM_INFOVIEW_ZOOM, OLECMDID_ZOOM,
    IDM_INFOVIEW_GETZOOMRANGE, OLECMDID_GETZOOMRANGE,
    OLECMDID_DONTDOWNLOADCSS, OLECMDID_DONTDOWNLOADCSS,
    IDM_DELETE, OLECMDID_DELETE

};

static MAP amapPersistence[] =
{
    IDM_ONPERSISTSHORTCUT,     CMDID_INTSHORTCUTCREATE,
    IDM_SAVEASTHICKET,         CMDID_SAVEASTHICKET,
};

static MAP amapDownloadHost[] =
{
    IDM_DWNH_SETDOWNLOAD,      DWNHCMDID_SETDOWNLOADNOTIFY,
};

static MAP amapShellDocView[] =
{
    IDM_SHDV_FINALTITLEAVAIL,  SHDVID_FINALTITLEAVAIL,
    IDM_SHDV_MIMECSETMENUOPEN, SHDVID_MIMECSETMENUOPEN,
    IDM_SHDV_FONTMENUOPEN,     SHDVID_FONTMENUOPEN,
    IDM_SHDV_PRINTFRAME,       SHDVID_PRINTFRAME,
    IDM_SHDV_PUTOFFLINE,       SHDVID_PUTOFFLINE,
    IDM_SHDV_GOBACK,           SHDVID_GOBACK,
    IDM_SHDV_GOFORWARD,        SHDVID_GOFORWARD,
    IDM_SHDV_CANGOBACK,        SHDVID_CANGOBACK,
    IDM_SHDV_CANGOFORWARD,     SHDVID_CANGOFORWARD,
    IDM_SHDV_CANSUPPORTPICS,   SHDVID_CANSUPPORTPICS,
    IDM_SHDV_CANDEACTIVATENOW, SHDVID_CANDEACTIVATENOW,
    IDM_SHDV_DEACTIVATEMENOW,  SHDVID_DEACTIVATEMENOW,
    IDM_SHDV_NODEACTIVATENOW,  SHDVID_NODEACTIVATENOW,
    IDM_SHDV_SETPENDINGURL,    SHDVID_SETPENDINGURL,
    IDM_SHDV_ISDRAGSOURCE,     SHDVID_ISDRAGSOURCE,
    IDM_SHDV_DOCFAMILYCHARSET, SHDVID_DOCFAMILYCHARSET,
    IDM_SHDV_DOCCHARSET,       SHDVID_DOCCHARSET,
    IDM_SHDV_GETMIMECSETMENU,  SHDVID_GETMIMECSETMENU,
    IDM_SHDV_GETFONTMENU,      SHDVID_GETFONTMENU,
    IDM_SHDV_GETDOCDIRMENU,    SHDVID_GETDOCDIRMENU,
    IDM_SHDV_CANDOCOLORSCHANGE,SHDVID_CANDOCOLORSCHANGE,
    IDM_SHDV_ONCOLORSCHANGE,   SHDVID_ONCOLORSCHANGE,
    IDM_SHDV_ADDMENUEXTENSIONS,SHDVID_ADDMENUEXTENSIONS, // Context Menu Extensions
    IDM_SHDV_PAGEFROMPOSTDATA, SHDVID_PAGEFROMPOSTDATA,
    IDM_SHDV_WINDOWOPEN,       SHDVID_WINDOWOPEN,
};

static MAP amapExplorer[] =
{
    IDM_GETFRAMEZONE,     SBCMDID_MIXEDZONE, 
};

static MAP amapClassicMSHTML[] =
{
    IDM_FIND,                  HTMLID_FIND,
    IDM_VIEWSOURCE,            HTMLID_VIEWSOURCE,
    IDM_OPTIONS,               HTMLID_OPTIONS,
};


//+-------------------------------------------------------------------------
//
//  Method:     CBase::IDMFromCmdID, static
//
//  Synopsis:   Compute menu item identifier from command set and command id.
//
//--------------------------------------------------------------------------

int
CBase::IDMFromCmdID(const GUID *pguidCmdGroup, ULONG ulCmdID)
{
    MAP *pmap;
    int  cmap;

    if (pguidCmdGroup == NULL)
    {
        pmap = amapCommandSet95;
        cmap = ARRAY_SIZE(amapCommandSet95);
    }
    else if (*pguidCmdGroup == CGID_MSHTML)
    {

        // Command identifiers in the Forms3 command set map
        // directly to menu item identifiers.
        return ulCmdID;

    }
    else if (*pguidCmdGroup == CGID_ShellDocView)
    {
        pmap = amapShellDocView;
        cmap = ARRAY_SIZE(amapShellDocView);
    }
    else if (*pguidCmdGroup == CGID_IWebBrowserPriv)
    {
   