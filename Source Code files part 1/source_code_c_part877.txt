BOOL_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    if ((*(VARIANT_BOOL *) pv1) == 0)
        if ((*(VARIANT_BOOL *) pv2) == 0)
            return( 0 );
        else
            return( -1 );
    else
        if ((*(VARIANT_BOOL *) pv2) == 0)
            return( 1 );
        else
            return( 0 );
}

BOOL VTP_BOOL_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( ( ((*(VARIANT_BOOL *) pv1)==0) && ((*(VARIANT_BOOL *) pv2)==0) ) ||
            ( ((*(VARIANT_BOOL *) pv1)!=0) && ((*(VARIANT_BOOL *) pv2)!=0) ) );

}

BOOL VTP_BOOL_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( !VTP_BOOL_EQ( pv1, pv2 ) );
}

//
// VTP_VARIANT
//

int VTP_VARIANT_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return VT_VARIANT_Compare( * (PROPVARIANT *) pv1, * (PROPVARIANT *) pv2 );
}

BOOL VTP_VARIANT_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return VT_VARIANT_LT( * (PROPVARIANT *) pv1, * (PROPVARIANT *) pv2 );
}

BOOL VTP_VARIANT_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return VT_VARIANT_LE( * (PROPVARIANT *) pv1, * (PROPVARIANT *) pv2 );
}

BOOL VTP_VARIANT_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return VT_VARIANT_GE( * (PROPVARIANT *) pv1, * (PROPVARIANT *) pv2 );
}

BOOL VTP_VARIANT_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return VT_VARIANT_GT( * (PROPVARIANT *) pv1, * (PROPVARIANT *) pv2 );
}

BOOL VTP_VARIANT_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return VT_VARIANT_EQ( * (PROPVARIANT *) pv1, * (PROPVARIANT *) pv2 );
}

BOOL VTP_VARIANT_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return VT_VARIANT_NE( * (PROPVARIANT *) pv1, * (PROPVARIANT *) pv2 );
}

//
// VTP_DECIMAL
//

int VTP_DEC_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    PROPVARIANT v1;
    RtlCopyMemory( &v1, pv1, sizeof DECIMAL );
    v1.vt = VT_DECIMAL;

    PROPVARIANT v2;
    RtlCopyMemory( &v2, pv2, sizeof DECIMAL );
    v2.vt = VT_DECIMAL;

    return VT_DEC_Compare( v1, v2 );
}

BOOL VTP_DEC_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_DEC_Compare( pv1, pv2 ) < 0 );
}

BOOL VTP_DEC_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_DEC_Compare( pv1, pv2 ) <= 0 );
}

BOOL VTP_DEC_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_DEC_Compare( pv1, pv2 ) >= 0 );
}

BOOL VTP_DEC_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_DEC_Compare( pv1, pv2 ) > 0 );
}

BOOL VTP_DEC_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_DEC_Compare( pv1, pv2 ) == 0 );
}

BOOL VTP_DEC_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_DEC_Compare( pv1, pv2 ) != 0 );
}

//
// VTP_I1
//

int VTP_I1_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(signed char *) pv1) - (*(signed char *) pv2) );
}

BOOL VTP_I1_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(signed char *) pv1) < (*(signed char *) pv2) );
}

BOOL VTP_I1_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(signed char *) pv1) <= (*(signed char *) pv2) );
}

BOOL VTP_I1_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(signed char *) pv1) >= (*(signed char *) pv2) );
}

BOOL VTP_I1_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(signed char *) pv1) > (*(signed char *) pv2) );
}

BOOL VTP_I1_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(signed char *) pv1) == (*(signed char *) pv2) );
}

BOOL VTP_I1_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(signed char *) pv1) != (*(signed char *) pv2) );
}

BOOL VTP_I1_AllBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(signed char *) pv1) & (*(signed char *) pv2)) == (*(signed char *) pv2) );
}

BOOL VTP_I1_SomeBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(signed char *) pv1) & (*(signed char *) pv2)) != 0 );
}

//
// VTP_UI1
//

int VTP_UI1_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(unsigned char *) pv1) - (*(unsigned char *) pv2) );
}

BOOL VTP_UI1_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(unsigned char *) pv1) < (*(unsigned char *) pv2) );
}

BOOL VTP_UI1_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(unsigned char *) pv1) <= (*(unsigned char *) pv2) );
}

BOOL VTP_UI1_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(unsigned char *) pv1) >= (*(unsigned char *) pv2) );
}

BOOL VTP_UI1_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(unsigned char *) pv1) > (*(unsigned char *) pv2) );
}

BOOL VTP_UI1_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(unsigned char *) pv1) == (*(unsigned char *) pv2) );
}

BOOL VTP_UI1_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(unsigned char *) pv1) != (*(unsigned char *) pv2) );
}

BOOL VTP_UI1_AllBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(unsigned char *) pv1) & (*(unsigned char *) pv2)) == (*(unsigned char *) pv2) );
}

BOOL VTP_UI1_SomeBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(unsigned char *) pv1) & (*(unsigned char *) pv2)) != 0 );
}

//
// VTP_UI2
//

int VTP_UI2_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(USHORT *) pv1) - (*(USHORT *) pv2) );
}

BOOL VTP_UI2_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(USHORT *) pv1) < (*(USHORT *) pv2) );
}

BOOL VTP_UI2_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(USHORT *) pv1) <= (*(USHORT *) pv2) );
}

BOOL VTP_UI2_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(USHORT *) pv1) >= (*(USHORT *) pv2) );
}

BOOL VTP_UI2_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(USHORT *) pv1) > (*(USHORT *) pv2) );
}

BOOL VTP_UI2_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(USHORT *) pv1) == (*(USHORT *) pv2) );
}

BOOL VTP_UI2_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(USHORT *) pv1) != (*(USHORT *) pv2) );
}

BOOL VTP_UI2_AllBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(USHORT *) pv1) & (*(USHORT *) pv2)) == (*(USHORT *) pv2) );
}

BOOL VTP_UI2_SomeBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(USHORT *) pv1) & (*(USHORT *) pv2)) != 0 );
}

//
// VTP_UI4
//

int VTP_UI4_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    ULONG ul1 = * (ULONG *) pv1;
    ULONG ul2 = * (ULONG *) pv2;

    return ( ul1 > ul2 ) ? 1 : ( ul1 < ul2 ) ? -1 : 0;
}

BOOL VTP_UI4_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONG *) pv1) < (*(ULONG *) pv2) );
}

BOOL VTP_UI4_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONG *) pv1) <= (*(ULONG *) pv2) );
}

BOOL VTP_UI4_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONG *) pv1) >= (*(ULONG *) pv2) );
}

BOOL VTP_UI4_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONG *) pv1) > (*(ULONG *) pv2) );
}

BOOL VTP_UI4_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONG *) pv1) == (*(ULONG *) pv2) );
}

BOOL VTP_UI4_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONG *) pv1) != (*(ULONG *) pv2) );
}

BOOL VTP_UI4_AllBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(ULONG *) pv1) & (*(ULONG *) pv2)) == (*(ULONG *) pv2) );
}

BOOL VTP_UI4_SomeBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(ULONG *) pv1) & (*(ULONG *) pv2)) != 0 );
}

//
// VTP_I8
//

int VTP_I8_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(LONGLONG *) pv1) >  (*(LONGLONG *) pv2) ? 1 :
            (*(LONGLONG *) pv1) == (*(LONGLONG *) pv2) ? 0 :
            -1 );
}

BOOL VTP_I8_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(LONGLONG *) pv1) < (*(LONGLONG *) pv2) );
}

BOOL VTP_I8_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(LONGLONG *) pv1) <= (*(LONGLONG *) pv2) );

}

BOOL VTP_I8_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(LONGLONG *) pv1) >= (*(LONGLONG *) pv2) );
}

BOOL VTP_I8_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(LONGLONG *) pv1) > (*(LONGLONG *) pv2) );
}

BOOL VTP_I8_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(LONGLONG *) pv1) == (*(LONGLONG *) pv2) );
}

BOOL VTP_I8_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(LONGLONG *) pv1) != (*(LONGLONG *) pv2) );
}

BOOL VTP_I8_AllBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(LONGLONG *) pv1) & (*(LONGLONG *) pv2)) == (*(LONGLONG *) pv2) );
}

BOOL VTP_I8_SomeBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(LONGLONG *) pv1) & (*(LONGLONG *) pv2)) != 0 );
}

//
// VTP_UI8
//

int VTP_UI8_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONGLONG *) pv1) >  (*(ULONGLONG *) pv2) ? 1 :
            (*(ULONGLONG *) pv1) == (*(ULONGLONG *) pv2) ? 0 :
            -1 );
}

BOOL VTP_UI8_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONGLONG *) pv1) < (*(ULONGLONG *) pv2) );
}

BOOL VTP_UI8_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONGLONG *) pv1) <= (*(ULONGLONG *) pv2) );

}

BOOL VTP_UI8_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONGLONG *) pv1) >= (*(ULONGLONG *) pv2) );
}

BOOL VTP_UI8_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONGLONG *) pv1) > (*(ULONGLONG *) pv2) );
}

BOOL VTP_UI8_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONGLONG *) pv1) == (*(ULONGLONG *) pv2) );
}

BOOL VTP_UI8_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONGLONG *) pv1) != (*(ULONGLONG *) pv2) );
}

BOOL VTP_UI8_AllBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(ULONGLONG *) pv1) & (*(ULONGLONG *) pv2)) == (*(ULONGLONG *) pv2) );
}

BOOL VTP_UI8_SomeBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(ULONGLONG *) pv1) & (*(ULONGLONG *) pv2)) != 0 );
}

//
// VTP_LPSTR
//

int VTP_LPSTR_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return ( lstrcmpiA( (*(char **) pv1), (*(char **) pv2) ) );
}

BOOL VTP_LPSTR_LT( BYTE const *pv1, BYTE const *pv2 )
{
    int rc = lstrcmpiA( (*(char **) pv1), (*(char **) pv2) );

    return( rc < 0 );
}

BOOL VTP_LPSTR_LE( BYTE const *pv1, BYTE const *pv2 )
{
    int rc = lstrcmpiA( (*(char **) pv1), (*(char **) pv2) );

    return( rc <= 0 );
}

BOOL VTP_LPSTR_GE( BYTE const *pv1, BYTE const *pv2 )
{
    int rc = lstrcmpiA( (*(char **) pv1), (*(char **) pv2) );

    return( rc >= 0 );
}

BOOL VTP_LPSTR_GT( BYTE const *pv1, BYTE const *pv2 )
{
    int rc = lstrcmpiA( (*(char **) pv1), (*(char **) pv2) );

    return( rc > 0 );
}

BOOL VTP_LPSTR_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( lstrcmpiA( (*(char **) pv1), (*(char **) pv2) ) == 0 );
}

BOOL VTP_LPSTR_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( lstrcmpiA( (*(char **) pv1), (*(char **) pv2) ) != 0 );
}


//
// VTP_LPWSTR
//

int VTP_LPWSTR_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    int rc = CompareStringW( LOCALE_SYSTEM_DEFAULT,
                             NORM_IGNORECASE,
                             (*(WCHAR **) pv1),
                             -1,
                             (*(WCHAR **) pv2),
                             -1 );

    //
    // rc == 1, means less than
    // rc == 2, means equal
    // rc == 3, means greater than
    //
    return rc - 2;
}

BOOL VTP_LPWSTR_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_LPWSTR_Compare( pv1, pv2 ) < 0 );
}

BOOL VTP_LPWSTR_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_LPWSTR_Compare( pv1, pv2 ) <= 0 );
}

BOOL VTP_LPWSTR_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_LPWSTR_Compare( pv1, pv2 ) >= 0 );
}

BOOL VTP_LPWSTR_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_LPWSTR_Compare( pv1, pv2 ) > 0 );
}

BOOL VTP_LPWSTR_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_LPWSTR_Compare( pv1, pv2 ) == 0 );
}

BOOL VTP_LPWSTR_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_LPWSTR_Compare( pv1, pv2 ) != 0 );
}

//
// VTP_BLOB
//

int VTP_BLOB_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    ULONG len = (*(BLOB **) pv1)->cbSize;
    if ( (*(BLOB **) pv2)->cbSize < len )
        len = (*(BLOB **) pv2)->cbSize;

    int iCmp = memcmp( (*(BLOB **) pv1)->pBlobData,
                       (*(BLOB **) pv2)->pBlobData,
                       len );

    if ( iCmp != 0 || (*(BLOB **) pv1)->cbSize == (*(BLOB **) pv2)->cbSize )
        return( iCmp );

    if ( (*(BLOB **) pv1)->cbSize > (*(BLOB **) pv2)->cbSize )
        return( 1 );
    else
        return( -1 );
}

BOOL VTP_BLOB_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_BLOB_Compare( pv1, pv2 ) < 0 );
}

BOOL VTP_BLOB_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_BLOB_Compare( pv1, pv2 ) <= 0 );
}

BOOL VTP_BLOB_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_BLOB_Compare( pv1, pv2 ) >= 0 );
}

BOOL VTP_BLOB_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_BLOB_Compare( pv1, pv2 ) > 0 );
}

BOOL VTP_BLOB_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(BLOB **) pv1)->cbSize == (*(BLOB **) pv2)->cbSize &&
            memcmp( (*(BLOB **) pv1)->pBlobData,
                    (*(BLOB **) pv2)->pBlobData,
                    (*(BLOB **) pv1)->cbSize ) == 0 );
}

BOOL VTP_BLOB_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(BLOB **) pv1)->cbSize != (*(BLOB **) pv2)->cbSize ||
            memcmp( (*(BLOB **) pv1)->pBlobData,
                      (*(BLOB **) pv2)->pBlobData,
                      (*(BLOB **) pv1)->cbSize ) != 0 );
}

//
// VTP_CF
//

int VTP_CF_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    if ( (* (CLIPDATA **) pv1)->ulClipFmt != (* (CLIPDATA **) pv2)->ulClipFmt )
    {
        return( (* (CLIPDATA **) pv1)->ulClipFmt - (* (CLIPDATA **) pv2)->ulClipFmt );
    }

    ULONG len = CBPCLIPDATA( **(CLIPDATA **) pv1 );

    if ( CBPCLIPDATA( **(CLIPDATA **) pv2 ) < len )
        len = CBPCLIPDATA( **(CLIPDATA **) pv2 );

    int iCmp = memcmp( (* (CLIPDATA **) pv1)->pClipData,
                       (* (CLIPDATA **) pv2)->pClipData,
                       len );

    if ( iCmp != 0 || (* (CLIPDATA **) pv1)->cbSize == (* (CLIPDATA **) pv2)->cbSize)
        return( iCmp );

    if ( (* (CLIPDATA **) pv1)->cbSize > (* (CLIPDATA **) pv2)->cbSize )
        return( 1 );
    else
        return( -1 );
}

BOOL VTP_CF_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_CF_Compare( pv1, pv2 ) < 0 );
}

BOOL VTP_CF_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_CF_Compare( pv1, pv2 ) <= 0 );
}

BOOL VTP_CF_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_CF_Compare( pv1, pv2 ) >= 0 );
}

BOOL VTP_CF_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_CF_Compare( pv1, pv2 ) > 0 );
}

BOOL VTP_CF_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (CLIPDATA **) pv1)->ulClipFmt == (* (CLIPDATA **) pv2)->ulClipFmt &&
            (* (CLIPDATA **) pv1)->cbSize == (* (CLIPDATA **) pv2)->cbSize &&
            memcmp( (* (CLIPDATA **) pv1)->pClipData,
                    (* (CLIPDATA **) pv2)->pClipData,
                    CBPCLIPDATA( **(CLIPDATA **) pv1 )) == 0 );
}

BOOL VTP_CF_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (CLIPDATA **) pv1)->ulClipFmt != (* (CLIPDATA **) pv2)->ulClipFmt &&
            (* (CLIPDATA **) pv1)->cbSize != (* (CLIPDATA **) pv2)->cbSize ||
            memcmp( (* (CLIPDATA **) pv1)->pClipData,
                    (* (CLIPDATA **) pv2)->pClipData,
                    CBPCLIPDATA( **(CLIPDATA **) pv1 )) != 0 );
}

//
// VTP_CLSID.  V means vector ( a pointer to a guid )
//             S meand singleton ( a pointer to a pointer to a guid )
//

int VTP_VV_CLSID_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( pv1, pv2, sizeof GUID ) );
}

int VTP_VS_CLSID_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( pv1, (* (CLSID __RPC_FAR * *) pv2), sizeof GUID ) );
}

int VTP_SV_CLSID_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( (* (CLSID __RPC_FAR * *) pv1), pv2, sizeof GUID ) );
}

int VTP_SS_CLSID_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( (* (CLSID __RPC_FAR * *) pv1), (* (CLSID __RPC_FAR * *) pv2), sizeof GUID ) );
}

BOOL VTP_SS_CLSID_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( (* (CLSID __RPC_FAR * *) pv1), (* (CLSID __RPC_FAR * *) pv2), sizeof GUID ) == 0 );
}

BOOL VTP_SS_CLSID_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( (* (CLSID __RPC_FAR * *) pv1), (* (CLSID __RPC_FAR * *) pv2), sizeof GUID ) != 0 );
}

BOOL VTP_VV_CLSID_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( pv1, pv2, sizeof GUID ) == 0 );
}

BOOL VTP_VV_CLSID_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( pv1, pv2, sizeof GUID ) != 0 );
}

BOOL VTP_VS_CLSID_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( pv1, (* (CLSID __RPC_FAR * *) pv2), sizeof GUID ) == 0 );
}

BOOL VTP_VS_CLSID_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( pv1, (* (CLSID __RPC_FAR * *) pv2), sizeof GUID ) != 0 );
}

BOOL VTP_SV_CLSID_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( (* (CLSID __RPC_FAR * *) pv1), pv2, sizeof GUID ) == 0 );
}

BOOL VTP_SV_CLSID_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( (* (CLSID __RPC_FAR * *) pv1), pv2, sizeof GUID ) != 0 );
}

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

ULONG const CComparators::_iStart = VT_EMPTY;

CComparators::SComparators const CComparators::_aVariantComparators[] = {
    // VT_EMPTY
    { VT_EMPTY_Compare, VTP_EMPTY_Compare,
      { 0,
        0,
        0,
        0,
        VT_EMPTY_EQ,
        VT_EMPTY_NE,
        0,
        0,
        0 },
      { 0,
        0,
        0,
        0,
        VTP_EMPTY_EQ,
        VTP_EMPTY_NE,
        0,
        0,
        0 },
    },

    // VT_NULL
    { VT_NULL_Compare, VTP_NULL_Compare,
      { 0,
        0,
        0,
        0,
        VT_NULL_EQ,
        VT_NULL_NE,
        0,
        0,
        0 },
      { 0,
        0,
        0,
        0,
        VTP_NULL_EQ,
        VTP_NULL_NE,
        0,
        0,
        0 },
    },

    // VT_I2
    { VT_I2_Compare, VTP_I2_Compare,
      { VT_I2_LT,
        VT_I2_LE,
        VT_I2_GT,
        VT_I2_GE,
        VT_I2_EQ,
        VT_I2_NE,
        0,
        VT_I2_AllBits,
        VT_I2_SomeBits
      },
      { VTP_I2_LT,
        VTP_I2_LE,
        VTP_I2_GT,
        VTP_I2_GE,
        VTP_I2_EQ,
        VTP_I2_NE,
        0,
        VTP_I2_AllBits,
        VTP_I2_SomeBits
      },
    },

    // VT_I4
    { VT_I4_Compare, VTP_I4_Compare,
      { VT_I4_LT,
        VT_I4_LE,
        VT_I4_GT,
        VT_I4_GE,
        VT_I4_EQ,
        VT_I4_NE,
        0,
        VT_I4_AllBits,
        VT_I4_SomeBits
      },
      { VTP_I4_LT,
        VTP_I4_LE,
        VTP_I4_GT,
        VTP_I4_GE,
        VTP_I4_EQ,
        VTP_I4_NE,
        0,
        VTP_I4_AllBits,
        VTP_I4_SomeBits
      },
    },

    // VT_R4
    { VT_R4_Compare, VTP_R4_Compare,
      { VT_R4_LT,
        VT_R4_LE,
        VT_R4_GT,
        VT_R4_GE,
        VT_R4_EQ,
        VT_R4_NE,
        0,
        0,
        0,
      },
      { VTP_R4_LT,
        VTP_R4_LE,
        VTP_R4_GT,
        VTP_R4_GE,
        VTP_R4_EQ,
        VTP_R4_NE,
        0,
        0,
        0,
      },
    },

    // VT_R8
    { VT_R8_Compare, VTP_R8_Compare,
      { VT_R8_LT,
        VT_R8_LE,
        VT_R8_GT,
        VT_R8_GE,
        VT_R8_EQ,
        VT_R8_NE,
        0,
        0,
        0,
      },
      { VTP_R8_LT,
        VTP_R8_LE,
        VTP_R8_GT,
        VTP_R8_GE,
        VTP_R8_EQ,
        VTP_R8_NE,
        0,
        0,
        0,
      },
    },

    // VT_CY
    { VT_I8_Compare, VTP_I8_Compare,
      { VT_I8_LT,
        VT_I8_LE,
        VT_I8_GT,
        VT_I8_GE,
        VT_I8_EQ,
        VT_I8_NE,
        0,
        0,
        0
      },
      { VTP_I8_LT,
        VTP_I8_LE,
        VTP_I8_GT,
        VTP_I8_GE,
        VTP_I8_EQ,
        VTP_I8_NE,
        0,
        0,
        0
      },
    },

    // VT_DATE
    { VT_R8_Compare, VTP_R8_Compare,
      { VT_R8_LT,
        VT_R8_LE,
        VT_R8_GT,
        VT_R8_GE,
        VT_R8_EQ,
        VT_R8_NE,
        0,
        0,
        0,
      },
      { VTP_R8_LT,
        VTP_R8_LE,
        VTP_R8_GT,
        VTP_R8_GE,
        VTP_R8_EQ,
        VTP_R8_NE,
        0,
        0,
        0,
      },
    },

    // VT_BSTR
    { VT_BSTR_Compare, VTP_BSTR_Compare,
      { VT_BSTR_LT,
        VT_BSTR_LE,
        VT_BSTR_GT,
        VT_BSTR_GE,
        VT_BSTR_EQ,
        VT_BSTR_NE,
        0,
        0,
        0
      },
      { VTP_BSTR_LT,
        VTP_BSTR_LE,
        VTP_BSTR_GT,
        VTP_BSTR_GE,
        VTP_BSTR_EQ,
        VTP_BSTR_NE,
        0,
        0,
        0
      },
    },

    // VT_DISPATCH
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_ERROR
    { VT_I4_Compare, VTP_I4_Compare,
      { VT_I4_LT,
        VT_I4_LE,
        VT_I4_GT,
        VT_I4_GE,
        VT_I4_EQ,
        VT_I4_NE,
        0,
        VT_I4_AllBits,
        VT_I4_SomeBits
      },
      { VTP_I4_LT,
        VTP_I4_LE,
        VTP_I4_GT,
        VTP_I4_GE,
        VTP_I4_EQ,
        VTP_I4_NE,
        0,
        VTP_I4_AllBits,
        VTP_I4_SomeBits
      },
    },

    // VT_BOOL
    { VT_BOOL_Compare, VTP_BOOL_Compare,
      { 0,
        0,
        0,
        0,
        VT_BOOL_EQ,
        VT_BOOL_NE,
        0,
        0,
        0
      },
      { 0,
        0,
        0,
        0,
        VTP_BOOL_EQ,
        VTP_BOOL_NE,
        0,
        0,
        0
      },
    },

    // VT_VARIANT
    { VT_VARIANT_Compare, VTP_VARIANT_Compare,
      { VT_VARIANT_LT,
        VT_VARIANT_LE,
        VT_VARIANT_GT,
        VT_VARIANT_GE,
        VT_VARIANT_EQ,
        VT_VARIANT_NE,
        0,
        0,
        0,
      },
      { VTP_VARIANT_LT,
        VTP_VARIANT_LE,
        VTP_VARIANT_GT,
        VTP_VARIANT_GE,
        VTP_VARIANT_EQ,
        VTP_VARIANT_NE,
        0,
        0,
        0,
      },
    },

    // VT_UNKNOWN
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_DECIMAL
    { VT_DEC_Compare, VTP_DEC_Compare,
      { VT_DEC_LT,
        VT_DEC_LE,
        VT_DEC_GT,
        VT_DEC_GE,
        VT_DEC_EQ,
        VT_DEC_NE,
        0,
        0,
        0
      },
      { VTP_DEC_LT,
        VTP_DEC_LE,
        VTP_DEC_GT,
        VTP_DEC_GE,
        VTP_DEC_EQ,
        VTP_DEC_NE,
        0,
        0,
        0
      },
    },

    // VARENUM value 15 unused
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_I1
    { VT_I1_Compare, VTP_I1_Compare,
      { VT_I1_LT,
        VT_I1_LE,
        VT_I1_GT,
        VT_I1_GE,
        VT_I1_EQ,
        VT_I1_NE,
        0,
        VT_I1_AllBits,
        VT_I1_SomeBits
      },
      { VTP_I1_LT,
        VTP_I1_LE,
        VTP_I1_GT,
        VTP_I1_GE,
        VTP_I1_EQ,
        VTP_I1_NE,
        0,
        VTP_I1_AllBits,
        VTP_I1_SomeBits
      },
    },

    // VT_UI1
    { VT_UI1_Compare, VTP_UI1_Compare,
      { VT_UI1_LT,
        VT_UI1_LE,
        VT_UI1_GT,
        VT_UI1_GE,
        VT_UI1_EQ,
        VT_UI1_NE,
        0,
        VT_UI1_AllBits,
        VT_UI1_SomeBits
      },
      { VTP_UI1_LT,
        VTP_UI1_LE,
        VTP_UI1_GT,
        VTP_UI1_GE,
        VTP_UI1_EQ,
        VTP_UI1_NE,
        0,
        VTP_UI1_AllBits,
        VTP_UI1_SomeBits
      },
    },

    // VT_UI2
    { VT_UI2_Compare, VTP_UI2_Compare,
      { VT_UI2_LT,
        VT_UI2_LE,
        VT_UI2_GT,
        VT_UI2_GE,
        VT_UI2_EQ,
        VT_UI2_NE,
        0,
        VT_UI2_AllBits,
        VT_UI2_SomeBits
      },
      { VTP_UI2_LT,
        VTP_UI2_LE,
        VTP_UI2_GT,
        VTP_UI2_GE,
        VTP_UI2_EQ,
        VTP_UI2_NE,
        0,
        VTP_UI2_AllBits,
        VTP_UI2_SomeBits
      },
    },

    // VT_UI4
    { VT_UI4_Compare, VTP_UI4_Compare,
      { VT_UI4_LT,
        VT_UI4_LE,
        VT_UI4_GT,
        VT_UI4_GE,
        VT_UI4_EQ,
        VT_UI4_NE,
        0,
        VT_UI4_AllBits,
        VT_UI4_SomeBits
      },
      { VTP_UI4_LT,
        VTP_UI4_LE,
        VTP_UI4_GT,
        VTP_UI4_GE,
        VTP_UI4_EQ,
        VTP_UI4_NE,
        0,
        VTP_UI4_AllBits,
        VTP_UI4_SomeBits
      },
    },

    // VT_I8
    { VT_I8_Compare, VTP_I8_Compare,
      { VT_I8_LT,
        VT_I8_LE,
        VT_I8_GT,
        VT_I8_GE,
        VT_I8_EQ,
        VT_I8_NE,
        0,
        VT_I8_AllBits,
        VT_I8_SomeBits
      },
      { VTP_I8_LT,
        VTP_I8_LE,
        VTP_I8_GT,
        VTP_I8_GE,
        VTP_I8_EQ,
        VTP_I8_NE,
        0,
        VTP_I8_AllBits,
        VTP_I8_SomeBits
      },
    },

    // VT_UI8
    { VT_UI8_Compare, VTP_UI8_Compare,
      { VT_UI8_LT,
        VT_UI8_LE,
        VT_UI8_GT,
        VT_UI8_GE,
        VT_UI8_EQ,
        VT_UI8_NE,
        0,
        VT_UI8_AllBits,
        VT_UI8_SomeBits
      },
      { VTP_UI8_LT,
        VTP_UI8_LE,
        VTP_UI8_GT,
        VTP_UI8_GE,
        VTP_UI8_EQ,
        VTP_UI8_NE,
        0,
        VTP_UI8_AllBits,
        VTP_UI8_SomeBits
      },
    },

    // VT_INT
    { VT_I4_Compare, VTP_I4_Compare,
      { VT_I4_LT,
        VT_I4_LE,
        VT_I4_GT,
        VT_I4_GE,
        VT_I4_EQ,
        VT_I4_NE,
        0,
        VT_I4_AllBits,
        VT_I4_SomeBits
      },
      { VTP_I4_LT,
        VTP_I4_LE,
        VTP_I4_GT,
        VTP_I4_GE,
        VTP_I4_EQ,
        VTP_I4_NE,
        0,
        VTP_I4_AllBits,
        VTP_I4_SomeBits
      },
    },

    // VT_UINT
    { VT_UI4_Compare, VTP_UI4_Compare,
      { VT_UI4_LT,
        VT_UI4_LE,
        VT_UI4_GT,
        VT_UI4_GE,
        VT_UI4_EQ,
        VT_UI4_NE,
        0,
        VT_UI4_AllBits,
        VT_UI4_SomeBits
      },
      { VTP_UI4_LT,
        VTP_UI4_LE,
        VTP_UI4_GT,
        VTP_UI4_GE,
        VTP_UI4_EQ,
        VTP_UI4_NE,
        0,
        VTP_UI4_AllBits,
        VTP_UI4_SomeBits
      },
    },

    // VT_VOID
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_HRESULT
    { VT_I4_Compare, VTP_I4_Compare,
      { VT_I4_LT,
        VT_I4_LE,
        VT_I4_GT,
        VT_I4_GE,
        VT_I4_EQ,
        VT_I4_NE,
        0,
        VT_I4_AllBits,
        VT_I4_SomeBits
      },
      { VTP_I4_LT,
        VTP_I4_LE,
        VTP_I4_GT,
        VTP_I4_GE,
        VTP_I4_EQ,
        VTP_I4_NE,
        0,
        VTP_I4_AllBits,
        VTP_I4_SomeBits
      },
    },

    // VT_PTR
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_SAFEARRAY
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_CARRAY
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_USERDEFINED
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_LPSTR
    { VT_LPSTR_Compare, VTP_LPSTR_Compare,
      { VT_LPSTR_LT,
        VT_LPSTR_LE,
        VT_LPSTR_GT,
        VT_LPSTR_GE,
        VT_LPSTR_EQ,
        VT_LPSTR_NE,
        0,
        0,
        0
      },
      { VTP_LPSTR_LT,
        VTP_LPSTR_LE,
        VTP_LPSTR_GT,
        VTP_LPSTR_GE,
        VTP_LPSTR_EQ,
        VTP_LPSTR_NE,
        0,
        0,
        0
      },
    },

    // VT_LPWSTR
    { VT_LPWSTR_Compare, VTP_LPWSTR_Compare,
      { VT_LPWSTR_LT,
        VT_LPWSTR_LE,
        VT_LPWSTR_GT,
        VT_LPWSTR_GE,
        VT_LPWSTR_EQ,
        VT_LPWSTR_NE,
        0,
        0,
        0
      },
      { VTP_LPWSTR_LT,
        VTP_LPWSTR_LE,
        VTP_LPWSTR_GT,
        VTP_LPWSTR_GE,
        VTP_LPWSTR_EQ,
        VTP_LPWSTR_NE,
        0,
        0,
        0
      },
    }
};

ULONG const CComparators::_cVariantComparators =
    sizeof(CComparators::_aVariantComparators) /
    sizeof(CComparators::_aVariantComparators[0]);

ULONG const CComparators::_iStart2 = VT_FILETIME;

CComparators::SComparators const CComparators::_aVariantComparators2[] = {
    // VT_FILETIME
    { VT_UI8_Compare, VTP_UI8_Compare,
      { VT_UI8_LT,
        VT_UI8_LE,
        VT_UI8_GT,
        VT_UI8_GE,
        VT_UI8_EQ,
        VT_UI8_NE,
        0,
        0,
        0
      },
      { VTP_UI8_LT,
        VTP_UI8_LE,
        VTP_UI8_GT,
        VTP_UI8_GE,
        VTP_UI8_EQ,
        VTP_UI8_NE,
        0,
        0,
        0
      },
    },

    // VT_BLOB
    { VT_BLOB_Compare, VTP_BLOB_Compare,
      { VT_BLOB_LT,
        VT_BLOB_LE,
        VT_BLOB_GT,
        VT_BLOB_GE,
        VT_BLOB_EQ,
        VT_BLOB_NE,
        0,
        0,
        0
      },
      { VTP_BLOB_LT,
        VTP_BLOB_LE,
        VTP_BLOB_GT,
        VTP_BLOB_GE,
        VTP_BLOB_EQ,
        VTP_BLOB_NE,
        0,
        0,
        0
      },
    },

    // VT_STREAM
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_STORAGE
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_STREAMED_OBJECT
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_STORED_OBJECT
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_BLOB_OBJECT
    { VT_BLOB_Compare, VTP_BLOB_Compare,
      { VT_BLOB_LT,
        VT_BLOB_LE,
        VT_BLOB_GT,
        VT_BLOB_GE,
        VT_BLOB_EQ,
        VT_BLOB_NE,
        0,
        0,
        0
      },
      { VTP_BLOB_LT,
        VTP_BLOB_LE,
        VTP_BLOB_GT,
        VTP_BLOB_GE,
        VTP_BLOB_EQ,
        VTP_BLOB_NE,
        0,
        0,
        0
      },
    },

    // VT_CF
    { VT_CF_Compare, VTP_CF_Compare,
      { VT_CF_LT,
        VT_CF_LE,
        VT_CF_GT,
        VT_CF_GE,
        VT_CF_EQ,
        VT_CF_NE,
        0,
        0,
        0
      },
      { VTP_CF_LT,
        VTP_CF_LE,
        VTP_CF_GT,
        VTP_CF_GE,
        VTP_CF_EQ,
        VTP_CF_NE,
        0,
        0,
        0
      },
    },

    // VT_CLSID
    { VT_CLSID_Compare, 0, // Vector special-cased in GetPointerComparator
      { 0,
        0,
        0,
        0,
        VT_CLSID_EQ,
        VT_CLSID_NE,
        0,
        0,
        0
      },
      { 0,
        0,
        0,
        0,
        0,     // Special-cased in GetPointerRelop
        0,     // Special-cased in GetPointerRelop
        0,
        0,
        0
      },
    }
};


ULONG const CComparators::_cVariantComparators2 =
    sizeof(CComparators::_aVariantComparators2) /
    sizeof(CComparators::_aVariantComparators2[0]);

ULONG const SortDescend = 1;
ULONG const SortNullFirst = 2;


inline void ConvertArrayToVector ( PROPVARIANT const & vIn, PROPVARIANT & vOut )
{
    Assert( vIn.vt & VT_ARRAY );
    SAFEARRAY * pSa = vIn.parray;

    ULONG cDataElements = 1;

    for ( unsigned i = 0; i < pSa->cDims; i++ )
    {
        cDataElements *= pSa->rgsabound[i].cElements;
    }
    vOut.vt = (vIn.vt & VT_TYPEMASK) | VT_VECTOR;
    vOut.caub.cElems = cDataElements;
    vOut.caub.pElems = (BYTE *)pSa->pvData;
}


BYTE * _GetNth( PROPVARIANT const & v, unsigned i )
{
    Assert( isVector(v) );
    switch ( getBaseType( v ) )
    {
    case VT_I1 :        // Issue - no defined type for vector of VT_I1
        return (BYTE *) & (v.caub.pElems[i]);
    case VT_UI1 :
        return (BYTE *) & (v.caub.pElems[i]);
    case VT_I2 :
        return (BYTE *) & (v.cai.pElems[i]);
    case VT_UI2 :
        return (BYTE *) & (v.caui.pElems[i]);
    case VT_BOOL :
        return (BYTE *) & (v.cabool.pElems[i]);
    case VT_I4 :
    case VT_INT :
        return (BYTE *) & (v.cal.pElems[i]);
    case VT_UI4 :
    case VT_UINT :
        return (BYTE *) & (v.caul.pElems[i]);
    case VT_R4 :
        return (BYTE *) & (v.caflt.pElems[i]);
    case VT_ERROR :
        return (BYTE *) & (v.cascode.pElems[i]);
    case VT_I8 :
        return (BYTE *) & (v.cah.pElems[i]);
    case VT_UI8 :
        return (BYTE *) & (v.cauh.pElems[i]);
    case VT_R8 :
        return (BYTE *) & (v.cadbl.pElems[i]);
    case VT_CY :
        return (BYTE *) & (v.cacy.pElems[i]);
    case VT_DATE :
        return (BYTE *) & (v.cadate.pElems[i]);
    case VT_FILETIME :
        return (BYTE *) & (v.cafiletime.pElems[i]);
    case VT_CLSID :
        return (BYTE *) & (v.cauuid.pElems[i]);
    case VT_CF :
        return (BYTE *) & (v.caclipdata.pElems[i]);
    case VT_BSTR :
        return (BYTE *) & (v.cabstr.pElems[i]);
    case VT_LPSTR :
        return (BYTE *) & (v.calpstr.pElems[i]);
    case VT_LPWSTR :
        return (BYTE *) & (v.calpwstr.pElems[i]);
    case VT_VARIANT :
        return (BYTE *) & (v.capropvar.pElems[i]);
    case VT_DECIMAL :
        // NOTE: not valid in a vector, but it could occur due to the
        //       simplistic conversion of arrays to vectors.
        DECIMAL * paDec = (DECIMAL *) v.caub.pElems;
        return (BYTE *) (paDec + i);
    }

    // illegal base variant type in vector compare.
    Assert( 0 );
    return 0;
} //_GetNth

//+-------------------------------------------------------------------------
//
//  Member:     VT_VECTOR_Compare, public
//
//  Effects:    Compares two property values, intended to be called when
//              at least one of the arguments is a vector
//
//  Arguments:  [v1]   -- 1st variant to compare
//              [v2]   -- 2nd variant to compare
//
//  History:    1-May-95 dlee     Created
//
//--------------------------------------------------------------------------

int VT_VECTOR_Compare( PROPVARIANT const & v1In, PROPVARIANT const & v2In )
{
    // must be the same datatype, or just sort on type

    if ( ( v1In.vt != v2In.vt ) )
        return v1In.vt - v2In.vt;

    PROPVARIANT v1 = v1In;
    PROPVARIANT v2 = v2In;

    if ( isArray(v1In) )
    {
        Assert( isArray(v2In) );

        SAFEARRAY * pSa1 = v1In.parray;
        SAFEARRAY * pSa2 = v2In.parray;

        if (pSa1->cDims != pSa2->cDims)
            return pSa1->cDims - pSa2->cDims;

        ULONG cDataElements = 1;

        for ( unsigned i = 0; i < pSa1->cDims; i++ )
        {
            if ( pSa1->rgsabound[i].lLbound != pSa2->rgsabound[i].lLbound )
                return pSa1->rgsabound[i].lLbound - pSa2->rgsabound[i].lLbound;
            if ( pSa1->rgsabound[i].cElements != pSa2->rgsabound[i].cElements )
                return pSa1->rgsabound[i].cElements - pSa2->rgsabound[i].cElements;
            cDataElements *= pSa1->rgsabound[i].cElements;
        }

        //
        // arrays match in type, total size and dimensions.  Compare as vectors.
        //
        v1.vt = v2.vt = (v1In.vt & VT_TYPEMASK) | VT_VECTOR;
        v1.caub.cElems = v2.caub.cElems = cDataElements;
        v1.caub.pElems = (BYTE *)pSa1->pvData;
        v2.caub.pElems = (BYTE *)pSa2->pvData;
    }

    Assert( isVector(v1) );

    FPCmp cmp = VariantCompare.GetPointerComparator( v1, v2 );
    if (0 == cmp)
    {
        // Unknown property type or relation used in comparison.
        Assert(0);
        return 0;
    }

    unsigned cMin = __min( v1.cal.cElems, v2.cal.cElems );

    for ( unsigned x = 0; x < cMin; x++ )
    {
        int r = cmp( _GetNth( v1, x), _GetNth( v2, x ) );

        if (0 != r)
            return r;
    }

    // All equal so far up to the minimum cardinality of the vectors.
    // Any difference now would be due to the cardinality.

    return v1.cal.cElems - v2.cal.cElems;
} //VT_VECTOR_Compare

int VTP_VECTOR_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return VT_VECTOR_Compare( ** (PROPVARIANT **) pv1,
                              ** (PROPVARIANT **) pv2 );
} //VTP_VECTOR_Compare

BOOL VT_VECTOR_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Compare( v1, v2 ) < 0;
} //VT_VECTOR_LT

BOOL VT_VECTOR_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Compare( v1, v2 ) <= 0;
} //VT_VECTOR_LE

BOOL VT_VECTOR_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return ! VT_VECTOR_LE( v1, v2 );
} //VT_VECTOR_GT

BOOL VT_VECTOR_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return ! VT_VECTOR_LT( v1, v2 );
} //VT_VECTOR_GE

BOOL VT_VECTOR_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Compare( v1, v2 ) == 0;
} //VT_VECTOR_EQ

BOOL VT_VECTOR_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return !VT_VECTOR_EQ( v1, v2 );
} //VT_VECTOR_NE

BOOL VT_VECTOR_Common(
    PROPVARIANT const & v1,
    PROPVARIANT const & v2,
    ULONG relop )
{
    // must be the same datatype and a vector or it doesn't compare.

    if ( ( v1.vt != v2.vt ) || ! isVector( v1 ) )
        return FALSE;

    // must be same cardinality, or it doesn't compare

    if ( v1.cal.cElems != v2.cal.cElems )
        return FALSE;

    FPRel cmp = VariantCompare.GetPointerRelop( v1, v2, relop );

    if ( 0 == cmp )
        return FALSE;

    unsigned cElems = v1.cal.cElems;

    for ( unsigned x = 0; x < cElems; x++ )
    {
        if ( !cmp( _GetNth( v1, x), _GetNth( v2, x ) ) )
            return FALSE;
    }

    return TRUE;
} //VT_VECTOR_Common

BOOL VT_VECTOR_AllBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Common( v1, v2, PRAllBits );
} //VT_VECTOR_AllBits

BOOL VT_VECTOR_SomeBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Common( v1, v2, PRSomeBits );
} //VT_VECTOR_SomeBits

////////////////////////////////////
////////////////////////////////////
////////////////////////////////////

BOOL VT_VECTOR_Any(
    PROPVARIANT const & v1In,
    PROPVARIANT const & v2In,
    ULONG relop )
{
    //
    // Note: first parameter (v1) is the object's property value
    //       second parameter (v2) is the query restriction
    //
    // return TRUE if any element in v1 holds the relation to any v2 element
    //

    // base type of variant must be the same

    if ( getBaseType( v1In ) != getBaseType( v2In ) )
        return FALSE;

    //
    //  If either argument is a safearray, convert it to a vector
    //
    PROPVARIANT v1 = v1In;
    if (isArray(v1))
        ConvertArrayToVector( v1In, v1 );

    PROPVARIANT v2 = v2In;
    if (isArray(v2))
        ConvertArrayToVector( v2In, v2 );

    // first check for two singletons

    if ( ! isVector( v1 ) && ! isVector( v2 ) )
    {
        FRel cmp = VariantCompare.GetRelop( (VARENUM) v1.vt, relop );

        if ( 0 == cmp )
            return FALSE;
        else
            return cmp( v1, v2 );
    }

    // two vectors or singleton+vector -- get a pointer comparator

    FPRel cmp = VariantCompare.GetPointerRelop( v1, v2, relop );

    if ( 0 == cmp )
        return FALSE;

    // check for two vectors

    if ( isVector( v1 ) && isVector( v2 ) )
    {
        for ( unsigned x1 = 0; x1 < v1.cal.cElems; x1++ )
        {
            for ( unsigned x2 = 0; x2 < v2.cal.cElems; x2++ )
            {
                if ( cmp( _GetNth( v1, x1), _GetNth( v2, x2 ) ) )
                    return TRUE;
            }
        }
    }
    else
    {
        // must be a singleton and a vector

        if ( isVector( v1 ) )
        {
            BYTE * pb2 = (BYTE *) &(v2.lVal);
            if ( VT_DECIMAL == v2.vt )
                pb2 = (BYTE *) &(v2.decVal);

            for ( unsigned i = 0; i < v1.cal.cElems; i++ )
            {
                if ( cmp( _GetNth( v1, i ), pb2 ) )
                    return TRUE;
            }
        }
        else
        {
            BYTE * pb1 = (BYTE *) &(v1.lVal);
            if ( VT_DECIMAL == v1.vt )
                pb1 = (BYTE *) &(v1.decVal);

            for ( unsigned i = 0; i < v2.cal.cElems; i++ )
            {
                if ( cmp( pb1, _GetNth( v2, i ) ) )
                    return TRUE;
            }
        }
    }

    return FALSE;
} //VT_VECTOR_Any

BOOL VT_VECTOR_LT_Any( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Any( v1, v2, PRLT );
} //VT_VECTOR_LT_Any

BOOL VT_VECTOR_LE_Any( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Any( v1, v2, PRLE );
} //VT_VECTOR_LE_Any

BOOL VT_VECTOR_GT_Any( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Any( v1, v2, PRGT );
} //VT_VECTOR_GT_Any

BOOL VT_VECTOR_GE_Any( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Any( v1, v2, PRGE );
} //VT_VECTOR_GE_Any

BOOL VT_VECTOR_EQ_Any( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Any( v1, v2, PREQ );
} //VT_VECTOR_EQ_Any

BOOL VT_VECTOR_NE_Any( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Any( v1, v2, PRNE );
} //VT_VECTOR_NE_Any

BOOL VT_VECTOR_AllBits_Any( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Any( v1, v2, PRAllBits );
} //VT_VECTOR_AllBits_Any

BOOL VT_VECTOR_SomeBits_Any( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Any( v1, v2, PRSomeBits );
} //VT_VECTOR_SomeBits_Any

////////////////////////////////////
////////////////////////////////////
////////////////////////////////////

BOOL VT_VECTOR_All(
    PROPVARIANT const & v1In,
    PROPVARIANT const & v2In,
    ULONG relop )
{
    //
    // Note: first parameter (v1) is the object's property value
    //       second parameter (v2) is the query restriction
    //
    // each element in v2 must hold the relation to each element v1
    // (not necessarily vice-versa)
    //

    // base type of variant must be the same

    if ( getBaseType( v1In ) != getBaseType( v2In ) )
        return FALSE;

    //
    //  If either argument is a safearray, convert it to a vector
    //
    PROPVARIANT v1 = v1In;
    if (isArray(v1))
        ConvertArrayToVector( v1In, v1 );

    PROPVARIANT v2 = v2In;
    if (isArray(v2))
        ConvertArrayToVector( v2In, v2 );

    // first check for two singletons

    if ( ! isVector( v1 ) && ! isVector( v2 ) )
    {
        FRel cmp = VariantCompare.GetRelop( (VARENUM) v1.vt, relop );

        if ( 0 == cmp )
            return FALSE;
        else
            return cmp( v1, v2 );
    }

    // two vectors or singleton+vector -- get a pointer comparator

    FPRel cmp = VariantCompare.GetPointerRelop( v1, v2, relop );

    if ( 0 == cmp )
        return FALSE;

    // check for two vectors

    if ( isVector( v1 ) && isVector( v2 ) )
    {
        for ( unsigned x2 = 0; x2 < v2.cal.cElems; x2++ )
        {
            for ( unsigned x1 = 0; x1 < v1.cal.cElems; x1++ )
            {
                if ( ! cmp( _GetNth( v1, x1), _GetNth( v2, x2 ) ) )
                    return FALSE;
            }
        }
    }
    else
    {
        // must be a singleton and a vector

        if ( isVector( v1 ) )
        {
            BYTE * pb2 = (BYTE *) &(v2.lVal);
            if ( VT_DECIMAL == v2.vt )
                pb2 = (BYTE *) &(v2.decVal);

            for ( unsigned i = 0; i < v1.cal.cElems; i++ )
            {
                if ( ! cmp( _GetNth( v1, i ), pb2 ) )
                    return FALSE;
            }
        }
        else
        {
            BYTE * pb1 = (BYTE *) &(v1.lVal);
            if ( VT_DECIMAL == v1.vt )
                pb1 = (BYTE *) &(v1.decVal);

            for ( unsigned i = 0; i < v2.cal.cElems; i++ )
            {
                if ( ! cmp( pb1, _GetNth( v2, i ) ) )
                    return FALSE;
            }
        }
    }

    return TRUE;
} //VT_VECTOR_All

BOOL VT_VECTOR_LT_All( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_All( v1, v2, PRLT );
} //VT_VECTOR_LT_All

BOOL VT_VECTOR_LE_All( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_All( v1, v2, PRLE );
} //VT_VECTOR_LE_All

BOOL VT_VECTOR_GT_All( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_All( v1, v2, PRGT );
} //VT_VECTOR_GT_All

BOOL VT_VECTOR_GE_All( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_All( v1, v2, PRGE );
} //VT_VECTOR_GE_All

BOOL VT_VECTOR_EQ_All( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_All( v1, v2, PREQ );
} //VT_VECTOR_EQ_All

BOOL VT_VECTOR_NE_All( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_All( v1, v2, PRNE );
} //VT_VECTOR_NE_All

BOOL VT_VECTOR_AllBits_All( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_All( v1, v2, PRAllBits );
} //VT_VECTOR_AllBits_All

BOOL VT_VECTOR_SomeBits_All( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_All( v1, v2, PRSomeBits );
} //VT_VECTOR_SomeBits_All

////////////////////////////////////
////////////////////////////////////
////////////////////////////////////

FRel const CComparators::_aVectorComparators[] =
{
    VT_VECTOR_LT,
    VT_VECTOR_LE,
    VT_VECTOR_GT,
    VT_VECTOR_GE,
    VT_VECTOR_EQ,
    VT_VECTOR_NE,
    0,
    VT_VECTOR_AllBits,
    VT_VECTOR_SomeBits
};

ULONG const CComparators::_cVectorComparators =
    sizeof CComparators::_aVectorComparators /
    sizeof CComparators::_aVectorComparators[0];

FRel const CComparators::_aVectorComparatorsAll[] =
{
    VT_VECTOR_LT_All,
    VT_VECTOR_LE_All,
    VT_VECTOR_GT_All,
    VT_VECTOR_GE_All,
    VT_VECTOR_EQ_All,
    VT_VECTOR_NE_All,
    0,
    VT_VECTOR_AllBits_All,
    VT_VECTOR_SomeBits_All
};

ULONG const CComparators::_cVectorComparatorsAll =
    sizeof CComparators::_aVectorComparatorsAll /
    sizeof CComparators::_aVectorComparatorsAll[0];

FRel const CComparators::_aVectorComparatorsAny[] =
{
    VT_VECTOR_LT_Any,
    VT_VECTOR_LE_Any,
    VT_VECTOR_GT_Any,
    VT_VECTOR_GE_Any,
    VT_VECTOR_EQ_Any,
    VT_VECTOR_NE_Any,
    0,
    VT_VECTOR_AllBits_Any,
    VT_VECTOR_SomeBits_Any
};

ULONG const CComparators::_cVectorComparatorsAny =
    sizeof CComparators::_aVectorComparatorsAny /
    sizeof CComparators::_aVectorComparatorsAny[0];

////////////////////////////////////
////////////////////////////////////
////////////////////////////////////

FCmp CComparators::GetComparator( VARENUM vt )
{
    if ( isVectorOrArray( vt ) )
    {
        return VT_VECTOR_Compare;
    }
    else if ( vt >= _iStart && vt < _iStart + _cVariantComparators )
    {
        return( _aVariantComparators[vt].comparator );
    }
    else if ( vt >= _iStart2 && vt < _iStart2 + _cVariantComparators2 )
    {
        return( _aVariantComparators2[vt - _iStart2].comparator );
    }
    else
    {
        // Unknown property type or relation used in comparison.
        Assert(0);
        return( 0 );
    }
} //GetComparator

FRel CComparators::GetRelop( VARENUM vt, ULONG relop )
{
    if ( ( ( isVectorOrArray( vt ) ) ||
           ( isVectorRelop( relop ) ) ) &&
         ( getBaseRelop( relop ) < _cVectorComparators ) )
    {
        if ( isRelopAny( relop ) )
            return _aVectorComparatorsAny[ getBaseRelop( relop ) ];
        else if ( isRelopAll( relop ) )
            return _aVectorComparatorsAll[ getBaseRelop( relop ) ];
        else
            return _aVectorComparators[ relop ];
    }
    else if ( vt >= _iStart && vt < _cVariantComparators &&
         relop < sizeof(_aVariantComparators[0].relops)/
                 sizeof(_aVariantComparators[0].relops[0] ) )
    {
        return( _aVariantComparators[vt].relops[relop] );
    }
    else if ( vt >= _iStart2 && vt < _iStart2 + _cVariantComparators2 &&
         relop < sizeof(_aVariantComparators2[0].relops)/
                 sizeof(_aVariantComparators2[0].relops[0] ) )
    {
        return( _aVariantComparators2[vt - _iStart2].relops[relop] );
    }
    else
    {
        // Unknown property type or relation used in comparison.
        Assert( 0);
        return( 0 );
    }
} //GetRelop

FPCmp CComparators::GetPointerComparator(
    PROPVARIANT const & v1,
    PROPVARIANT const & v2 )
{
    VARENUM vt = getBaseType( v1 );

    if ( VT_CLSID == vt )
    {
        // GUIDs are the only case of variants where the data inside
        // a singleton is different from an element in a vector.
        // Data in a singleton is a pointer to a guid.
        // Data in the element of a vector is the guid itself.
        // The vector compare code assumes that the layout of singletons
        // and vectors is the same, so we need special-case comparators
        // for GUIDs.

        if ( isVector( v1 ) && isVector( v2 ) )
            return VTP_VV_CLSID_Compare;
        else if ( isVector( v1 ) )
            return VTP_VS_CLSID_Compare;
        else if ( isVector( v2 ) )
            return VTP_SV_CLSID_Compare;
        else
            return VTP_SS_CLSID_Compare;

        Assert( !"unanticipated clsid / vector code path" );
    }

    if ( vt >= _iStart && vt < _iStart + _cVariantComparators )
        return( _aVariantComparators[vt].pointercomparator );
    else if ( vt >= _iStart2 && vt < _iStart2 + _cVariantComparators2 )
        return( _aVariantComparators2[vt - _iStart2].pointercomparator );
    else
    {
        // Unknown property type in comparison.
        Assert( 0 );
        return( 0 );
    }
} //GetPointerComparator

FPRel CComparators::GetPointerRelop(
    PROPVARIANT const & v1,
    PROPVARIANT const & v2,
    ULONG relop )
{
    VARENUM vt = getBaseType( v1 );

    if ( VT_CLSID == vt )
    {
        // GUIDs are the only case of variants where the data inside
        // a singleton is different from an element in a vector.
        // Data in a singleton is a pointer to a guid.
        // Data in the element of a vector is the guid itself.
        // The vector compare code assumes that the layout of singletons
        // and vectors is the same, so we need special-case comparators
        // for GUIDs.

        if ( isVector( v1 ) && isVector( v2 ) )
        {
            if ( PREQ == relop )
                return VTP_VV_CLSID_EQ;
            else if ( PRNE == relop )
                return VTP_VV_CLSID_NE;
            else
                return 0;
        }
        else if ( isVector( v1 ) )
        {
            if ( PREQ == relop )
                return VTP_VS_CLSID_EQ;
            else if ( PRNE == relop )
                return VTP_VS_CLSID_NE;
            else
                return 0;
        }
        else if ( isVector( v2 ) )
        {
            if ( PREQ == relop )
                return VTP_SV_CLSID_EQ;
            else if ( PRNE == relop )
                return VTP_SV_CLSID_NE;
            else
                return 0;
        }
        else
        {
            if ( PREQ == relop )
                return VTP_SS_CLSID_EQ;
            else if ( PRNE == relop )
                return VTP_SS_CLSID_NE;
            else
                return 0;
        }
    }

    if ( vt >= _iStart && vt < _cVariantComparators &&
         relop < sizeof(_aVariantComparators[0].pointerrelops)/
                 sizeof(_aVariantComparators[0].pointerrelops[0] ) )
        return( _aVariantComparators[vt].pointerrelops[relop] );
    else if ( vt >= _iStart2 && vt < _iStart2 + _cVariantComparators2 &&
         relop < sizeof(_aVariantComparators2[0].pointerrelops)/
                 sizeof(_aVariantComparators2[0].pointerrelops[0] ) )
        return( _aVariantComparators2[vt - _iStart2].pointerrelops[relop] );
    else
    {
        // Unknown type or relation used in comparison.
        Assert( 0);
        return( 0 );
    }
} //GetPointerRelop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\adddelete.h ===
// --------------------------------------------------------------------------------------------------------
//
//  File Name:  adddelete.h
//
//  This file declares CAddDeleteWord class, which is used to handle SR AddRemove Word UI case.
//
//  User can open Add/Remove Word dialog by click speech tools -- Add/Delete word item
//
//  Or select the same document range twice.
//
// --------------------------------------------------------------------------------------------------------

#ifndef _ADDDELETE_H
#define _ADDDELETE_H

#include "sapilayr.h"

class CSapiIMX;
class CSpTask;

#define MAX_SELECTED     20
#define MAX_DELIMITER    34

class __declspec(novtable) CAddDeleteWord 
{
public:
    CAddDeleteWord(CSapiIMX *psi);
    virtual ~CAddDeleteWord( );

    ITfRange *GetLastUsedIP(void) {return m_cpRangeLastUsedIP;}

    void SaveLastUsedIPRange( ) 
    {
        // When m_fCurIPIsSelection is true, means this current IP is selected by user.
        if ( m_fCurIPIsSelection && m_cpRangeOrgIP )
        {
            m_cpRangeLastUsedIP.Release();
            m_cpRangeLastUsedIP = m_cpRangeOrgIP; // comptr addrefs
        }
    }

    HRESULT SaveCurIPAndHandleAddDelete_InjectFeedbackUI( );
    HRESULT _SaveCurIPAndHandleAddDeleteUI(TfEditCookie ec, ITfContext *pic);
    HRESULT _HandleAddDeleteWord(TfEditCookie ec,ITfContext *pic);
    HRESULT DisplayAddDeleteUI(WCHAR  *pwzInitWord, ULONG   cchSize);
    HRESULT _DisplayAddDeleteUI(void);

    BOOL    WasAddDeleteUIOpened( )  { return m_fAddDeleteUIOpened; }

    static INT_PTR CALLBACK DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static void SetThis(HWND hWnd, LPARAM lParam)
    {
        SetWindowLongPtr(hWnd, DWLP_USER, (LONG_PTR)lParam);
    }

    static CAddDeleteWord *GetThis(HWND hWnd)
    {
        CAddDeleteWord *p = (CAddDeleteWord *)GetWindowLongPtr(hWnd, DWLP_USER);
        Assert(p != NULL);
        return p;
    }

    BOOL OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam);
    static  WCHAR    m_Delimiter[MAX_DELIMITER];

private:
    CSapiIMX     *m_psi;
    CSpTask      *_pCSpTask;

    BOOL         m_fCurIPIsSelection;
    BOOL         m_fMessagePopUp;         // If the message pop up
    BOOL         m_fToOpenAddDeleteUI;    // If user wants to open Add/delete word by select the same range twice.
    BOOL         m_fAddDeleteUIOpened;    // If the Add/delete UI window was opened.
    BOOL         m_fInDisplayAddDeleteUI; // TRUE if we're in the middle of 
                                          // showing the UI

    // the last used IP Range
    CComPtr<ITfRange> m_cpRangeLastUsedIP;

    // the original IP Range right before user starts to speak
    CComPtr<ITfRange> m_cpRangeOrgIP;
    CSpDynamicString m_dstrInitWord;

};

#endif  // _ADDDELETE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\candlist.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       candlist.cpp
//
//  Contents:   CCandidateList
//
//----------------------------------------------------------------------------

#include "private.h"
#include "ctffunc.h"
#include "candlist.h"

//////////////////////////////////////////////////////////////////////////////
//
// CCandidateString
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor, dtor
//
//----------------------------------------------------------------------------

CCandidateString::CCandidateString(ULONG nIndex, WCHAR *psz, LANGID langid, void *pv, IUnknown *punk, ULONG ulID, HICON hIcon, WCHAR *pwzWord)
{
    _psz = new WCHAR[wcslen(psz) + 1];
    if (_psz)
        wcscpy(_psz, psz);

    _langid = langid;
    _pv = pv;

    m_bstrWord = NULL;
    if (pwzWord)
    {
        m_bstrWord = SysAllocString(pwzWord);
    }
    m_hIcon = hIcon;
    m_ulID = ulID;

    _punk = punk;
    if (_punk)
       _punk->AddRef();
    _pszRead = NULL;

    _nIndex = nIndex;
    _cRef = 1;
}

CCandidateString::~CCandidateString()
{
    if (_punk)
       _punk->Release();
    if (_psz)
        delete[] _psz;
    if(_pszRead)
        delete[] _pszRead;
    SysFreeString(m_bstrWord);
    if (m_hIcon)
        DestroyIcon(m_hIcon);
}

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CCandidateString::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_POINTER;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfCandidateString))
    {
        *ppvObj = (ITfCandidateString *)(this);
    }
    if (m_hIcon && IsEqualIID(riid, IID_ITfCandidateStringIcon))
    {
        *ppvObj = (ITfCandidateStringIcon *)(this);
    }
    if (*ppvObj == NULL)
    {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

STDAPI_(ULONG) CCandidateString::AddRef()
{
    _cRef++;
    return _cRef;
}

STDAPI_(ULONG) CCandidateString::Release()
{
    _cRef--;
    if (0 < _cRef)
        return _cRef;

    delete this;
    return 0;    
}

//+---------------------------------------------------------------------------
//
// GetString
//
//----------------------------------------------------------------------------

HRESULT CCandidateString::GetString(BSTR *pbstr)
{
    if (!pbstr)
       return E_INVALIDARG;

    *pbstr = NULL;

    if (_psz)
    {
        *pbstr = SysAllocString(_psz);
    } 
    
    if(*pbstr)
       return S_OK;

    return E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
// GetIndex
//
//----------------------------------------------------------------------------

HRESULT CCandidateString::GetIndex(ULONG *pnIndex)
{
    *pnIndex = _nIndex;
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CCandidateList
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor, dtor
//
//----------------------------------------------------------------------------


CCandidateList::CCandidateList(CANDLISTCALLBACK pfnCallback, ITfContext *pic, ITfRange *pRange, CANDLISTCALLBACK pfnOptionsCallback)
{
    _pfnCallback = pfnCallback;
    _pfnOptionsCallback = pfnOptionsCallback;
    _pic = pic;
    _pic->AddRef();
    _pRange = pRange;
    _pRange->AddRef();
    _cRef = 1;
}

CCandidateList::~CCandidateList()
{
    _pic->Release();
    _pRange->Release();
    while(_rgCandStr.Count())
    {
        CCandidateString *pCandString;
        pCandString = _rgCandStr.Get(0);
        _rgCandStr.Remove(0, 1);
        delete pCandString;
    }

    while(_rgOptionsStr.Count())
    {
        CCandidateString *pCandString;
        pCandString = _rgOptionsStr.Get(0);
        _rgOptionsStr.Remove(0, 1);
        delete pCandString;
    }
}

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CCandidateList::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_POINTER;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfCandidateList))
    {
        *ppvObj = (ITfCandidateList *)(this);
    }
    if (_pfnOptionsCallback && IsEqualIID(riid, IID_ITfOptionsCandidateList))
    {
        *ppvObj = (ITfOptionsCandidateList *)(this);
    }

    if (*ppvObj == NULL)
    {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

STDAPI_(ULONG) CCandidateList::AddRef()
{
    _cRef++;
    return _cRef;
}

STDAPI_(ULONG) CCandidateList::Release()
{
    _cRef--;
    if (0 < _cRef)
        return _cRef;

    delete this;
    return 0;    
}

//+---------------------------------------------------------------------------
//
// EnumCandidate
//
//----------------------------------------------------------------------------

HRESULT CCandidateList::EnumCandidates(IEnumTfCandidates **ppEnum)
{
    HRESULT hr = S_OK;

    if (!(*ppEnum = new CEnumCandidates(this, FALSE)))
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// GetCandidate
//
//----------------------------------------------------------------------------

HRESULT CCandidateList::GetCandidate(ULONG nIndex, ITfCandidateString **ppCand)
{
    CCandidateString *pCandString;
    int nCnt = _rgCandStr.Count();
    if (nIndex >= (ULONG)nCnt)
        return E_FAIL;

    pCandString = _rgCandStr.Get(nIndex);
    return pCandString->QueryInterface(IID_ITfCandidateString, (void **)ppCand);
}

//+---------------------------------------------------------------------------
//
// GetCandidateNum
//
//----------------------------------------------------------------------------

HRESULT CCandidateList::GetCandidateNum(ULONG *pnCnt)
{
    *pnCnt = (ULONG)_rgCandStr.Count();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// SetResult
//
//----------------------------------------------------------------------------

HRESULT CCandidateList::SetResult(ULONG nIndex, TfCandidateResult imcr)
{
    if (!_pfnCallback)
        return S_OK;

    if (nIndex >= (ULONG)_rgCandStr.Count())
        return E_FAIL;

    return (_pfnCallback)(_pic, _pRange, _rgCandStr.Get(nIndex), imcr);
}

//+---------------------------------------------------------------------------
//
// EnumCandidate
//
//----------------------------------------------------------------------------

HRESULT CCandidateList::EnumOptionsCandidates(IEnumTfCandidates **ppEnum)
{
    HRESULT hr = S_OK;

    if (!(*ppEnum = new CEnumCandidates(this, TRUE)))
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// GetCandidate
//
//----------------------------------------------------------------------------

HRESULT CCandidateList::GetOptionsCandidate(ULONG nIndex, ITfCandidateString **ppCand)
{
    CCandidateString *pCandString;
    int nCnt = _rgOptionsStr.Count();
    if (nIndex >= (ULONG)nCnt)
        return E_FAIL;

    pCandString = _rgOptionsStr.Get(nIndex);
    return pCandString->QueryInterface(IID_ITfCandidateString, (void **)ppCand);
}

//+---------------------------------------------------------------------------
//
// GetCandidateNum
//
//----------------------------------------------------------------------------

HRESULT CCandidateList::GetOptionsCandidateNum(ULONG *pnCnt)
{
    *pnCnt = (ULONG)_rgOptionsStr.Count();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// SetOptionsResult
//
//----------------------------------------------------------------------------

HRESULT CCandidateList::SetOptionsResult(ULONG nIndex, TfCandidateResult imcr)
{
    if (!_pfnOptionsCallback)
        return S_OK;

    if (nIndex >= (ULONG)_rgOptionsStr.Count())
        return E_FAIL;

    return (_pfnOptionsCallback)(_pic, _pRange, _rgOptionsStr.Get(nIndex), imcr);
}

//+---------------------------------------------------------------------------
//
// AddString
//
//----------------------------------------------------------------------------

HRESULT CCandidateList::AddString(WCHAR *psz, LANGID langid, void *pv, IUnknown *punk, CCandidateString **ppCandStr, ULONG ulID, HICON hIcon)
{
    int nCnt = _rgCandStr.Count();
    CCandidateString *pCand = new CCandidateString(nCnt, psz, langid, pv, punk, ulID, hIcon);

    if (!pCand)
        return E_OUTOFMEMORY;

    if (!_rgCandStr.Insert(nCnt, 1))
    {
        pCand->Release();
        return E_OUTOFMEMORY;
    }

    _rgCandStr.Set(nCnt, pCand);

    if (ppCandStr)
    {
        *ppCandStr = pCand;
        (*ppCandStr)->AddRef();
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// AddString
//
//----------------------------------------------------------------------------

HRESULT CCandidateList::AddOption(WCHAR *psz, LANGID langid, void *pv, IUnknown *punk, CCandidateString **ppCandStr, ULONG ulID, HICON hIcon, WCHAR *pwzWord)
{
    int nCnt = _rgOptionsStr.Count();
    CCandidateString *pCand = new CCandidateString(nCnt, psz, langid, pv, punk, ulID, hIcon, pwzWord);

    if (!pCand)
        return E_OUTOFMEMORY;

    if (!_rgOptionsStr.Insert(nCnt, 1))
    {
        pCand->Release();
        return E_OUTOFMEMORY;
    }
    _rgOptionsStr.Set(nCnt, pCand);

    if (ppCandStr)
    {
        *ppCandStr = pCand;
        (*ppCandStr)->AddRef();
    }
    return S_OK;
}

HRESULT CCandidateString::GetWord(BSTR *pbstr)
{
    if (!pbstr)
       return E_INVALIDARG;

    *pbstr = NULL;

    if (m_bstrWord)
    {
        *pbstr = SysAllocString(m_bstrWord);
    } 
    
    if(*pbstr)
       return S_OK;

    return E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
// GetID
//
//----------------------------------------------------------------------------

HRESULT CCandidateString::GetID(ULONG *pulID)
{
    *pulID = m_ulID;
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CEnumCandidates
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor, dtor
//
//----------------------------------------------------------------------------

CEnumCandidates::CEnumCandidates(CCandidateList *pList, BOOL fOptionsCandidates)
{
    _pList = pList;
    _rgCandList = fOptionsCandidates ? &_pList->_rgOptionsStr : &_pList->_rgCandStr;
    _pList->AddRef();
    _nCur = 0;

    _cRef = 1;
}

CEnumCandidates::~CEnumCandidates()
{
    _pList->Release();
}

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CEnumCandidates::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_POINTER;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IEnumTfCandidates))
    {
        *ppvObj = (IEnumTfCandidates *)(this);
    }

    if (*ppvObj == NULL)
    {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

STDAPI_(ULONG) CEnumCandidates::AddRef()
{
    _cRef++;
    return _cRef;
}

STDAPI_(ULONG) CEnumCandidates::Release()
{
    _cRef--;
    if (0 < _cRef)
        return _cRef;

    delete this;
    return 0;    
}

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

HRESULT CEnumCandidates::Clone(IEnumTfCandidates **ppEnum)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// Next
//
//----------------------------------------------------------------------------

HRESULT CEnumCandidates::Next(ULONG ulCount, ITfCandidateString **ppCand, ULONG *pcFetched)
{
    ULONG cFetched = 0;

    while (cFetched < ulCount)
    {
        CCandidateString *pCand;

        if (_nCur >= _rgCandList->Count())
            break;

        pCand = _rgCandList->Get(_nCur);
        if (FAILED(pCand->QueryInterface(IID_ITfCandidateString, (void **)ppCand)))
            break;

        ppCand++;
        cFetched++;
        _nCur++;
    }

    if (pcFetched)
        *pcFetched = cFetched;

    return (cFetched == ulCount) ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
// Reset
//
//----------------------------------------------------------------------------

HRESULT CEnumCandidates::Reset()
{
    _nCur = 0;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Skip
//
//----------------------------------------------------------------------------

HRESULT CEnumCandidates::Skip(ULONG ulCount)
{
    while (ulCount)
    {
        if (_nCur >= _rgCandList->Count())
            break;

        _nCur++;
        ulCount--;
    }

    return ulCount ? S_FALSE : S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\adddelete.cpp ===
//
//
// Sapilayr TIP CAddDeleteWord implementation.
//
//
#include "private.h"
#include "sapilayr.h"
#include "adddelete.h"
#include "mui.h"


WCHAR  CAddDeleteWord::m_Delimiter[MAX_DELIMITER] = {
                    0x0009,0x000A,0x000D,0x0020,
                    0x0022,0x0023,0x0025,0x0026,0x0027,0x0028,0x0029,0x002A,  // "#%&'()*
                    0x002B,0x002C,0x002D,0x002F,0x003A,0x003B,0x003C,0x003D,  // +,-/:;<=
                    0x003E,0x0040,0x005B,0x005D,0x0021,0x002E,0x003F,0x005E,  // >@[]!.?^
                    0x007B,0x007C,0x007D,0x007E,                              // {|}~
                    0x0000
};


// ----------------------------------------------------------------------------------------------------------
//
//  Implementation for CAddDeleteWord
//
// -----------------------------------------------------------------------------------------------------------

CAddDeleteWord::CAddDeleteWord(CSapiIMX *psi) 
{
    m_psi = psi;
    m_cpRangeLastUsedIP = NULL;
    m_fCurIPIsSelection = FALSE;

    _pCSpTask = NULL;

    m_fMessagePopUp = FALSE;
    m_fToOpenAddDeleteUI = FALSE;
    m_fAddDeleteUIOpened = FALSE;
    m_fInDisplayAddDeleteUI = FALSE;
}

CAddDeleteWord::~CAddDeleteWord( ) 
{

};


// This function will be called by SR SPEI_SOUND_START callback function
// It will save current selection or IP.
//
// And compare the current IP with the last saved IP, if both of them are 
// not empty, and have the same start anchor, sptip tip will pop up a 
// message box to ask if user wants to popup SR Add/Remove Word dialog UI.
//
// If Add/Delete UI is not opened, we just want to inject feedbackui as usual

HRESULT  CAddDeleteWord::SaveCurIPAndHandleAddDelete_InjectFeedbackUI( )
{
    HRESULT hr = E_FAIL;

    m_fAddDeleteUIOpened = FALSE;
    hr = m_psi->_RequestEditSession(ESCB_SAVECURIP_ADDDELETEUI, TF_ES_READWRITE);
    return hr;
}


HRESULT CAddDeleteWord::_SaveCurIPAndHandleAddDeleteUI(TfEditCookie ec, ITfContext *pic)
{
    HRESULT  hr = S_OK;
    CComPtr<ITfRange>  cpCurIP;
    CComPtr<ITfRange>  cpLastIP;
    BOOL     fEmptyLast= FALSE;
    BOOL     fEmptyCur = TRUE;

    // Save the current IP first.
#ifdef SHOW_ADD_DELETE_POPUP_MESSAGE
    // if we need to activate this code we need to move this function
    // into the hypothesis handler, otherwise we will reactivate the bug
    // Cicero 3800 - sticky ip behavior makes typing/talking impractical
    // Hence I put a non conditional assert here
    Assert(0);

    m_psi->SaveCurrentIP(ec, pic);
#endif

    // Compare current IP with last saved IP
    // If user selects the same range twice, just open SR Add/remove dialog UI

    cpCurIP = m_psi->GetSavedIP( );
    cpLastIP  = GetLastUsedIP( );

    m_fAddDeleteUIOpened = FALSE;

    if ( cpCurIP )
    {
        // Save the Org IP by cloning the current IP.
        if ( m_cpRangeOrgIP )
            m_cpRangeOrgIP.Release( );

        cpCurIP->Clone(&m_cpRangeOrgIP);

        hr = cpCurIP->IsEmpty(ec, &fEmptyCur);
    }

    m_fCurIPIsSelection = !fEmptyCur;

#ifdef SHOW_ADD_DELETE_POPUP_MESSAGE

    if ( (S_OK == hr) && m_fCurIPIsSelection && cpLastIP)
    {
        hr = cpLastIP->IsEmpty(ec, &fEmptyLast);

        if ( (S_OK == hr) && !fEmptyLast )
        {
            BOOL   fEqualStart = FALSE;
            hr = cpCurIP->IsEqualStart(ec, cpLastIP, TF_ANCHOR_START, &fEqualStart);

            if ( (S_OK == hr) && fEqualStart )
            {
                // Open the dialog UI
                if ( !m_fMessagePopUp )
                {

                    BOOL  fDictStat;

                    // If Mic status is ON, turn it off.

                    fDictStat = m_psi->GetDICTATIONSTAT_DictOnOff( );

                    if ( fDictStat == TRUE)
                    {
                        m_psi->SetDICTATIONSTAT_DictOnOff(FALSE);
                    }

                    DialogBoxParam(g_hInst, 
                                   MAKEINTRESOURCE(IDD_OPEN_ADD_DELETE),
                                   m_psi->_GetAppMainWnd(),
                                   DlgProc,
                                   (LPARAM)this);

                    if ( fDictStat )
                        m_psi->SetDICTATIONSTAT_DictOnOff(TRUE);

                    m_fMessagePopUp = TRUE;
                }

                if ( m_fToOpenAddDeleteUI )
                    hr = _HandleAddDeleteWord(ec, pic);

            }
        }
    }
#endif

#ifdef SHOW_FEEDBACK_AT_SOUNDSTART
    if ( !m_fAddDeleteUIOpened && !m_fCurIPIsSelection)
    {
        BOOL fAware =  IsFocusFullAware(m_psi->_tim);
        hr = m_psi->_AddFeedbackUI(ec, 
                                   fAware ? DA_COLOR_AWARE : DA_COLOR_UNAWARE,
                                   3);
    }
#endif

    return hr;
}


//+---------------------------------------------------------------------------
//
// DlgProc
//
//----------------------------------------------------------------------------

INT_PTR CALLBACK CAddDeleteWord::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR  iRet = TRUE;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            SetThis(hDlg, lParam);
            break;

        case WM_COMMAND:
            GetThis(hDlg)->OnCommand(hDlg, wParam, lParam);
            break;

        default:
            iRet = FALSE;
    }

    return iRet;

}

//+---------------------------------------------------------------------------
//
// OnCommand
//
//----------------------------------------------------------------------------

BOOL CAddDeleteWord::OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam)
{

    switch (LOWORD(wParam))
    {
        case IDOK:

            m_fToOpenAddDeleteUI = TRUE;
            EndDialog(hDlg, 1);
            break;

        case IDCANCEL:

            m_fToOpenAddDeleteUI = FALSE;
            EndDialog(hDlg, 0);
            break;

        default:

            m_fToOpenAddDeleteUI = FALSE;
            return FALSE;
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
// CAddDeleteWord::_HandleAddDeleteWord
//
// Handle Add/Delete Word UI related work.
// This function will be called when user clicks the speech language bar menu 
// and select Add/Delete Word(s)... item.
//
//---------------------------------------------------------------------------+
HRESULT CAddDeleteWord::_HandleAddDeleteWord( TfEditCookie ec,ITfContext *pic )
{

    HRESULT  hr = S_OK;
    WCHAR    *pwzNewWord=NULL;
    CComPtr<ITfRange>  cpCurRange = NULL;
    ULONG    cchSize;
    BOOL     fEmptySelection=TRUE;

    // Get the current Selection

    TraceMsg(TF_GENERAL, "_HandleAddDeleteWord is called");

    if ( pic == NULL )
        return E_FAIL;

    GetSelectionSimple(ec, pic, &cpCurRange);

    // Check to see if the current selection is empty.

    if ( cpCurRange!= NULL )
    {
        hr = cpCurRange->IsEmpty(ec, &fEmptySelection);
        
        if ( hr != S_OK )
            return hr;
    }

    // If the current Selection is not empty, we need to get the correct word to send to the Add/Remove dialog
    // as its initial word.

    if  (( cpCurRange != NULL )  &&  !fEmptySelection )
    {
          ULONG    i, j, iKeep;
          BOOL     fDelimiter;

          // Get the text of the selection.
          // Follow the below rules to get the right word.
          //
          // If the current selection is longer than MAX_SELECED wchars of string, discard the rest.
          // 
          // If there is a delimiter ( space, tab, ... ) inside the selection, take the part prior to the first
          // delimiter as the right word.

          pwzNewWord = (WCHAR *) cicMemAllocClear( (MAX_SELECTED+1) * sizeof(WCHAR) );
          if ( pwzNewWord == NULL )
          {
               hr = E_OUTOFMEMORY;
               return hr;
          }

          cchSize =  MAX_SELECTED;

          hr = cpCurRange->GetText(ec, 0, pwzNewWord, MAX_SELECTED, &cchSize);

          if ( hr  != S_OK )
          {
              // GetRangeText  returns wrong, release the allocated memory

              cicMemFree(pwzNewWord);
              return hr;
          }

          pwzNewWord[cchSize] = L'\0';

          // Get the first delimiter if there is one.
              
          fDelimiter = FALSE;
          iKeep = 0;

          for ( i=0; i < cchSize; i++)
          {
               for ( j=0; j<MAX_DELIMITER; j++)
               {
                   if ( m_Delimiter[j] == 0x0000)
                       break;
                   if  ( pwzNewWord[i] == m_Delimiter[j])
                   {
                       fDelimiter = TRUE;
                       iKeep = i;
                       break;
                   }
               }
               if (  fDelimiter == TRUE )
                   break;
          }
          if ( fDelimiter )
          {
              cchSize = iKeep;
              pwzNewWord[cchSize] = L'\0';
          }
    }
    else
    {
          pwzNewWord = NULL;
          cchSize = 0;
    }

    hr = DisplayAddDeleteUI(pwzNewWord, cchSize);

    if ( pwzNewWord != NULL )
    {
        cicMemFree(pwzNewWord);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// CAddDeleteWord::_DisplayAddDeleteUI
//
// 
// Display the Add/Delete UI with pwszInitWord.
// 
//---------------------------------------------------------------------------+

HRESULT CAddDeleteWord::DisplayAddDeleteUI(WCHAR  *pwzInitWord, ULONG   cchSize)
{
    HRESULT hr = S_OK;

    if (m_fInDisplayAddDeleteUI)
    {
        return hr;
    }
    m_fInDisplayAddDeleteUI = TRUE;

    m_dstrInitWord.Clear();

    if (pwzInitWord != NULL)
        m_dstrInitWord.Append(pwzInitWord, cchSize);

    PostMessage(m_psi->_GetWorkerWnd(), WM_PRIV_ADDDELETE, 0, 0);

    return hr;
}

HRESULT CAddDeleteWord::_DisplayAddDeleteUI(void)
{
    HRESULT   hr = S_OK;
    WCHAR     pwzTitle[64];

    // Display the UI

    pwzTitle[0] = '\0';
    CicLoadStringWrapW(g_hInst, IDS_UI_ADDDELETE, pwzTitle, ARRAYSIZE(pwzTitle));

    CComPtr<ISpRecognizer>    cpRecoEngine;

    m_psi->GetSpeechTask(&_pCSpTask, FALSE);

    if ( _pCSpTask ) 
    {
        hr = _pCSpTask->GetSAPIInterface(IID_ISpRecognizer, (void **)&cpRecoEngine);
        if (S_OK == hr && cpRecoEngine)
        {

            // If Mic status is ON, turn it off.
            DWORD dwDictStatBackup = m_psi->GetDictationStatBackup();

            DWORD dwBefore;
            CComPtr<ITfThreadMgr> cpTim = m_psi->_tim;

            if (S_OK != 
                GetCompartmentDWORD(cpTim, GUID_COMPARTMENT_SPEECH_DISABLED, &dwBefore, FALSE)
                )
            {
                dwBefore = 0;
            }
            SetCompartmentDWORD(m_psi->_GetId(), cpTim, GUID_COMPARTMENT_SPEECH_DISABLED, TF_DISABLE_DICTATION, FALSE);
            cpRecoEngine->DisplayUI(m_psi->_GetAppMainWnd(), pwzTitle, SPDUI_AddRemoveWord, m_dstrInitWord, m_dstrInitWord.Length() * sizeof(WCHAR));

            m_fAddDeleteUIOpened = TRUE;
            SetCompartmentDWORD(m_psi->_GetId(), cpTim, GUID_COMPARTMENT_SPEECH_DISABLED, dwBefore, FALSE);

            // After Add/Remove work is done, restore the previous Mic status.
            SetCompartmentDWORD(m_psi->_GetId(), cpTim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, dwDictStatBackup, FALSE);
        }
    }
    m_fInDisplayAddDeleteUI = FALSE;

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\capital.cpp ===
//
//
// Sapilayr TIP CCapCmdHandler implementation.
//
//
#include "private.h"
#include "sapilayr.h"
#include "capital.h"


// ----------------------------------------------------------------------------------------------------------
//
//  Implementation for CCapCmdHandler 
//
// -----------------------------------------------------------------------------------------------------------

CCapCmdHandler::CCapCmdHandler(CSapiIMX *psi) 
{
    m_psi = psi;
}

CCapCmdHandler::~CCapCmdHandler( ) 
{

};

/*  --------------------------------------------------------
//    Function Name: ProcessCapCommands
//
//    Description: public functions used by command handler
//                 to handle any Capital related dictation
//                 commands.
//
// ----------------------------------------------------------*/
HRESULT   CCapCmdHandler::ProcessCapCommands(CAPCOMMAND_ID idCapCmd, WCHAR *pwszTextToCap, ULONG ulLen )
{
    HRESULT hr = E_FAIL;
    
    if ( !m_psi )
        return E_FAIL;

    if ( (idCapCmd > CAPCOMMAND_MinIdWithText ) && (!pwszTextToCap || !ulLen))
        return E_INVALIDARG;

    WCHAR  *pwszText=NULL; 
    ESDATA esData;

    memset(&esData, 0, sizeof(ESDATA));

    if ( pwszTextToCap )
    {
        esData.pData = pwszTextToCap;
        esData.uByte = (ulLen + 1) * sizeof(WCHAR);
    }

    esData.lData1 = (LONG_PTR)idCapCmd;
    esData.lData2 = (LONG_PTR)ulLen;

    hr = m_psi->_RequestEditSession(ESCB_PROCESS_CAP_COMMANDS, TF_ES_READWRITE,  &esData);

    return hr;
}


/*  --------------------------------------------------------
//    Function Name: _ProcessCapCommands
//
//    Description:   Edit session call back funtion for 
//                   ProcessSelectionWord.
//
//                   it does real work for selection handling
// ----------------------------------------------------------*/
HRESULT CCapCmdHandler::_ProcessCapCommands(TfEditCookie ec,ITfContext *pic, CAPCOMMAND_ID idCapCmd, WCHAR *pwszTextToCap, ULONG ulLen)
{
    HRESULT   hr = S_OK;

    // Get the Dictation Grammar
    TraceMsg(TF_GENERAL, "_ProcessCapCommands() is called");

    if ( m_psi == NULL)
        return E_FAIL;

    CComPtr<ITfRange>    cpIP;

    cpIP = m_psi->GetSavedIP();

    if ( cpIP == NULL )
    {
        // Get the current IP.
        hr = GetSelectionSimple(ec, pic, &cpIP);
    }

    // Start to a new command.
    // Clear all the information saved for the previous command handling.

    m_dstrTextToCap.Clear( );
    m_cpCapRange = cpIP;
    m_idCapCmd = idCapCmd;

    switch ( idCapCmd )
    {
    case  CAPCOMMAND_CapThat        :
    case  CAPCOMMAND_AllCapsThat    :
    case  CAPCOMMAND_NoCapsThat     :
        hr = _HandleCapsThat(ec, pic);
        break;

    case  CAPCOMMAND_CapsOn  :
        hr = _CapsOnOff(ec, pic, TRUE);
        break;
    case CAPCOMMAND_CapsOff :
        hr = _CapsOnOff(ec, pic, FALSE);
        break;

    // Below commands require pwszTextToCap contains real text to be capitalized 
    // injected to the document.

    case CAPCOMMAND_CapIt :
    case CAPCOMMAND_AllCaps :
    case CAPCOMMAND_NoCaps :
        m_dstrTextToCap.Append(pwszTextToCap);
        m_ulLen = ulLen;
        hr = _HandleCapsIt(ec, pic);
        break;

    case CAPCOMMAND_CapLetter :
        hr = _HandleCapsThat(ec, pic, towlower(pwszTextToCap[0]));
        break;

    default :
        break;
    }

    // update the saved ip so that next time the hypothesis will 
    // start from this new selection.
    m_psi->SaveLastUsedIPRange( );
    m_psi->SaveIPRange(NULL);

    return hr;
}

/*  --------------------------------------------------------------
//    Function Name: _SetNewText
//
//    Description:   Inject the new text to m_cpCapRange in
//                   the document and update necessary property
//                   data.
//
// --------------------------------------------------------------*/

HRESULT  CCapCmdHandler::_SetNewText(TfEditCookie ec,ITfContext *pic, WCHAR *pwszNewText, BOOL fSapiText) 
{
    HRESULT             hr = S_OK;
    BOOL                fInsertOk;
    CComPtr<ITfRange>   cpRange;

    if (!pwszNewText)
        return E_INVALIDARG;

    m_cpCapRange->Clone(&cpRange);

    hr = cpRange->AdjustForInsert(ec, wcslen(pwszNewText), &fInsertOk);
    if (S_OK == hr && fInsertOk)
    {
        // start a composition here if we haven't already
        m_psi->_CheckStartComposition(ec, cpRange);

        // set the text
        hr = cpRange->SetText(ec, 0, pwszNewText, -1);


        if ( fSapiText )
        {
            //
            // set attribute range 
            //
            CComPtr<ITfRange>    cpAttrRange = NULL;
            CComPtr<ITfProperty> cpProp = NULL;

            if (hr == S_OK)
            {
                hr = pic->GetProperty(GUID_PROP_SAPI_DISPATTR, &cpProp);
            }
            
            if (S_OK == hr)
            {
                hr = cpRange->Clone(&cpAttrRange);
            }

            if (S_OK == hr && cpAttrRange)
            {
                SetGUIDPropertyData(m_psi->_GetLibTLS( ), ec, cpProp, cpAttrRange, GUID_ATTR_SAPI_INPUT);
            }

            //
            // setup langid property
            //
            //_SetLangID(ec, pic, cpRange, langid);
        }

        if ( hr == S_OK )
        {
            cpRange->Collapse(ec, TF_ANCHOR_END);
            SetSelectionSimple(ec, pic, cpRange);
        }
    }

    return hr;
}

/*  ------------------------------------------------------------------
//    Function Name: _CapsText
//
//    Description:   Generate capitalized text based on current 
//                   Capital command id.
//        
//                   Inside this function, it will allocate memory
//                   for new generated capitaized text.
//                   Caller is responsible for release the allocated
//                   memory 
// -------------------------------------------------------------------*/
HRESULT  CCapCmdHandler::_CapsText(WCHAR **pwszNewText, WCHAR wchLetter)
{
    HRESULT   hr = S_OK;
    WCHAR     *pwszNew, *pwszTextToCap;
    ULONG     i;

    // Generate new text based on the requirement

    if ( !pwszNewText )
        return E_INVALIDARG;

    *pwszNewText = NULL;
    pwszTextToCap = (WCHAR *)m_dstrTextToCap;

    pwszNew = (WCHAR *)cicMemAlloc((m_ulLen+1)*sizeof(WCHAR));
    if ( pwszNew )
    {
        WCHAR  wch;

        switch (m_idCapCmd)
        {
        case CAPCOMMAND_CapThat     :
        case CAPCOMMAND_CapIt       :
        case CAPCOMMAND_CapLetter   :
            {
                BOOL  fFoundFirstAlpha=FALSE;

                for (i=0; i<m_ulLen; i++)
                {
                    wch = pwszTextToCap[i];

                    if ( iswalpha(wch) && !fFoundFirstAlpha )
                    {
                        if ( (wchLetter==0) && (m_idCapCmd != CAPCOMMAND_CapLetter) )
                            pwszNew[i] = towupper(wch);
                        else
                        {
                            if (wch == wchLetter)
                                pwszNew[i] = towupper(wch);
                            else
                                pwszNew[i] = wch;
                        }

                        fFoundFirstAlpha = TRUE;
                    }
                    else
                    {
                        pwszNew[i] = wch;
                        //
                        // We treat apostrophe as a normal character when handling capitalization
                        //
                        if ( (towupper(wch) == towlower(wch)) && ( wch != L'\'') && ( wch != 0x2019) )
                        {
                            // reach to a non-alpha character.
                            // now start to find first alphar for next word.
                            fFoundFirstAlpha = FALSE;
                        }
                    }
                }

                pwszNew[m_ulLen] = L'\0';
            }

            break;
                
        case CAPCOMMAND_AllCapsThat :
        case CAPCOMMAND_AllCaps     :

            for ( i=0; i<m_ulLen; i++)
            {
                wch = pwszTextToCap[i];
                if ( iswalpha(wch) )
                    pwszNew[i] = towupper(wch);
                else
                    pwszNew[i] = wch;
            }

            pwszNew[m_ulLen] = L'\0';
             
            break;

        case CAPCOMMAND_NoCapsThat :
        case CAPCOMMAND_NoCaps     :

            for ( i=0; i<m_ulLen; i++)
            {
                wch = pwszTextToCap[i];

                if ( iswalpha(wch) )
                    pwszNew[i] = towlower(wch);
                else
                    pwszNew[i] = wch;
            }

            pwszNew[m_ulLen] = L'\0';
            break;
        }

        *pwszNewText = pwszNew;
    }

    if ( *pwszNewText != NULL )
        hr = S_OK;
    else
    {
        if ( pwszNew )
            cicMemFree(pwszNew);

        hr = E_FAIL;
    }

    return hr;
}


/*  ------------------------------------------------------------------
//    Function Name: _GetCapPhrase
//
//    Description:   Generate the range to capitalize. 
//                   it could be previous dictated phrase,
//                   or current selection, 
//                   or current word around IP or before IP
//                   depends on the current text situation.
// -------------------------------------------------------------------*/
HRESULT CCapCmdHandler::_GetCapPhrase(TfEditCookie ec,ITfContext *pic, BOOL *fSapiText)
{
    HRESULT  hr = S_OK;
    CComPtr<ITfRange>  cpCapRange;
    BOOL     bSapiText = FALSE;

    if ( !m_psi ) return E_FAIL;
    
    if ( !fSapiText ) return E_INVALIDARG;

    hr = m_psi->_GetCmdThatRange(ec, pic, &cpCapRange);

    if ( hr == S_OK && cpCapRange )
    {
        m_cpCapRange = cpCapRange;

        // Set bSapiText here.
        // If the range is inside a dictated phrase, set bSapiText = TRUE;

        CComPtr<ITfProperty>    cpProp;
        CComPtr<ITfRange>       cpSapiPropRange;
        long                    l1=0, l2=0;

        hr = pic->GetProperty(GUID_PROP_SAPI_DISPATTR, &cpProp);

        if ( hr == S_OK )
            hr = cpProp->FindRange(ec, cpCapRange, &cpSapiPropRange, TF_ANCHOR_START);

        // Is cpRange inside cpSapiPropRange ?
        
        if ( hr == S_OK )
            hr = cpCapRange->CompareStart(ec, cpSapiPropRange,  TF_ANCHOR_START, &l1);

        if ( hr == S_OK )
            hr = cpCapRange->CompareEnd(ec, cpSapiPropRange,  TF_ANCHOR_END, &l2);

        if ( hr == S_OK && (l1>=0  && l2<=0) )
        {
            // the Range is inside SAPI input range.
            bSapiText = TRUE;
        }

        // hr could be S_FALSE, if the range is not dictated.
        // We still treat S_FALSE as S_OK in the return hr.
        if ( SUCCEEDED(hr) )
            hr = S_OK;
    }

    *fSapiText = bSapiText;

    return hr;
}


HRESULT  CCapCmdHandler::_HandleCapsThat(TfEditCookie ec,ITfContext *pic, WCHAR wchLetter)
{
    HRESULT  hr = S_OK;
    BOOL     fSapiText;

    // Get the range to capitalize

    hr = _GetCapPhrase(ec, pic, &fSapiText);

    if ( hr == S_OK ) 
    {
        CComPtr<ITfRange>   cpRangeCloned;
        BOOL     fEmpty = TRUE;

        hr = m_cpCapRange->IsEmpty(ec, &fEmpty);

        if ( hr == S_OK && !fEmpty )
        {
            hr = m_cpCapRange->Clone(&cpRangeCloned);

            // Get the text in the CapRange.
            if ( hr == S_OK )
            {
                ULONG   ucch;

                while(S_OK == hr && (S_OK == cpRangeCloned->IsEmpty(ec, &fEmpty)) && !fEmpty)
                {
                    WCHAR sz[128];

                    hr = cpRangeCloned->GetText(ec, TF_TF_MOVESTART, sz, ARRAYSIZE(sz)-1, &ucch);

                    if (S_OK == hr)
                    {
                        sz[ucch] = L'\0';
                        m_dstrTextToCap.Append(sz);
                    }
                }

                m_ulLen = m_dstrTextToCap.Length( );
            }

            if ( hr==S_OK && m_dstrTextToCap)
            {
                // Generate new text based on the requirement
                WCHAR   *pwszNewText;

                hr = _CapsText(&pwszNewText, wchLetter);

                if ( hr == S_OK )
                {
                    hr = _SetNewText(ec, pic, (WCHAR *)pwszNewText, fSapiText);
                    cicMemFree(pwszNewText);
                }
            }
        }
    }

    return  hr;
}

HRESULT  CCapCmdHandler::_CapsOnOff(TfEditCookie ec,ITfContext *pic, BOOL fOn)
{
    HRESULT  hr = S_OK;


    return  hr;
}

HRESULT  CCapCmdHandler::_HandleCapsIt(TfEditCookie ec,ITfContext *pic)
{
    HRESULT  hr = S_OK;

    if ( m_dstrTextToCap)
    {
        // Generate new text based on the requirement
        WCHAR   *pwszNewText;

        hr = _CapsText(&pwszNewText);

        if ( hr == S_OK )
        {
            hr = _SetNewText(ec, pic, (WCHAR *)pwszNewText, TRUE);
            cicMemFree(pwszNewText);
        }
    }

    return  hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\citn.cpp ===
#include "private.h"
#include "sapilayr.h"
#include "citn.h"
#include "xstring.h"
#include "winnls.h"
#include "wchar.h"

#define MILLION         ((LONGLONG) 1000000)
#define BILLION         ((LONGLONG) 1000000000)
#define MILLION_STR     (L"million")
#define BILLION_STR     (L"billion")


#define MANN         ((LONGLONG) 10000)
#define OKU          ((LONGLONG) 100000000)
#define CHUU         ((LONGLONG) 1000000000000)
#define MANN_STR     (L"\x4E07")
#define OKU_STR      (L"\x5104")
#define CHUU_STR     (L"\x5146")



HRESULT CSimpleITN::InterpretNumberEn
(    
    const SPPHRASEPROPERTY *pProperties, 
    const bool fCardinal,
    DOUBLE *pdblVal,
    WCHAR *pszVal,
    UINT cSize,
    const bool fFinalDisplayFmt
)
{
    if ( !pdblVal || !pszVal || !pProperties)
    {
        return E_POINTER;
    }

    *pszVal = 0;

    int iPositive = 1; 

    const SPPHRASEPROPERTY *pFirstProp = pProperties;

    // Handle negatives
    if ( NEGATIVE == pFirstProp->ulId )
    {
        // There's no such thing as a negative ordinal
        SPDBG_ASSERT( fCardinal );

        // There had better be more stuff following
        SPDBG_ASSERT( pFirstProp->pNextSibling );

        iPositive = -1;

        pFirstProp = pFirstProp->pNextSibling;
    }

    if ( GRID_INTEGER_STANDALONE == pFirstProp->ulId )
    {
        // This is interger number
        TraceMsg(TF_GENERAL, "English Interger Number");

        SPDBG_ASSERT( pFirstProp->pFirstChild);

        pFirstProp = pFirstProp->pFirstChild;


        // Handle the "2.6 million" case, in which case the number
        // has already been formatted
        if ( GRID_INTEGER_MILLBILL == pFirstProp->ulId )
        {
            if ( pFirstProp->pszValue == NULL 
                 || cSize < (wcslen( pFirstProp->pszValue ) + 1) )
            {
                return E_INVALIDARG;
            }
            *pdblVal = pFirstProp->vValue.dblVal * iPositive;
            if ( iPositive < 0 )
            {
                StringCchCopyW( pszVal, cSize,  m_pwszNeg );
            }
            StringCchCatW( pszVal, cSize, pFirstProp->pszValue );

            return S_OK;
        }
        else
        {
            BOOL   fNegative;

            fNegative = (iPositive == -1);

            return InterpretIntegerEn(pFirstProp, 
                                      fCardinal, 
                                      pdblVal, 
                                      pszVal, 
                                      cSize, 
                                      fFinalDisplayFmt, 
                                      fNegative);
        }
    }
    else if ( GRID_FP_NUMBER == pFirstProp->ulId )
    {
        // This is decimal number
        TraceMsg(TF_GENERAL, "English Floating point (decimal) Number");
        SPDBG_ASSERT( pFirstProp->pFirstChild);
        pFirstProp = pFirstProp->pFirstChild;

        // todo for decimal number handling.

        return InterpretDecimalEn(pFirstProp,
                                  fCardinal,
                                  pdblVal,
                                  pszVal,
                                  cSize,
                                  fFinalDisplayFmt,
                                  (iPositive == -1) );
    }

    return S_OK;
}

HRESULT CSimpleITN::InterpretIntegerEn
(   const SPPHRASEPROPERTY *pProperties, 
    const bool fCardinal,
    DOUBLE *pdblVal,
    WCHAR *pszVal,
    UINT cSize,
    const bool fFinalDisplayFmt,
    BOOL  fNegative)
{
    HRESULT   hr=S_OK;
    LONGLONG llValue = 0;

    if ( !pdblVal || !pszVal || !pProperties)
    {
        return E_POINTER;
    }

    *pszVal = 0;

    const SPPHRASEPROPERTY *pFirstProp = pProperties;

    // Handle the digit-by-digit case
    if ( GRID_DIGIT_NUMBER == pFirstProp->ulId )
    {
        const SPPHRASEPROPERTY * pProp;
        int   iNumDigit = 0;

        // iNumDigit is 1 means the current property is ONEDIGIT
        // iNumDigit is 2 means the current property is TWODIGIT.

        // llValue = llValue * ( 10 ^ iNumDigit ) + Value in current property

        for (pProp = pFirstProp->pFirstChild; pProp; pProp ? pProp = pProp->pNextSibling : NULL)
        {

            LONGLONG                 llValCurrent;  // current property's value
            const SPPHRASEPROPERTY  *pPropValue;

            switch ( pProp->ulId)
            {
            case  ONEDIGIT:
                {
                    ASSERT( pProp->pFirstChild );
                    pPropValue = pProp->pFirstChild;
                    ASSERT( VT_UI4 == pPropValue->vValue.vt );

                    llValCurrent = pPropValue->vValue.ulVal;
                    iNumDigit = 1;
                    TraceMsg(TF_GENERAL, "ONEDIGIT: %d", llValCurrent);

                    break;
                }

            case TWODIGIT :
                {
                    ASSERT( pProp->pFirstChild );
                    pPropValue = pProp->pFirstChild;
                    TraceMsg(TF_GENERAL, "TWODIGIT:");

                    if ( pPropValue->ulId == TENS )
                    {
                        const SPPHRASEPROPERTY *pPropOnes;

                        ASSERT(pPropValue->pFirstChild);
                        ASSERT( VT_UI4 == pPropValue->pFirstChild->vValue.vt );

                        llValCurrent = pPropValue->vValue.ulVal * pPropValue->pFirstChild->vValue.ulVal;

                        TraceMsg(TF_GENERAL, "TENS: %d", llValCurrent);

                        pPropOnes = pPropValue->pNextSibling;

                        if ( pPropOnes )
                        {
                            ASSERT(pPropOnes->pFirstChild);
                            ASSERT( VT_UI4 == pPropOnes->pFirstChild->vValue.vt );

                            llValCurrent += pPropOnes->pFirstChild->vValue.ulVal;

                            TraceMsg(TF_GENERAL, "TENS: Second: %d", pPropOnes->pFirstChild->vValue.ulVal);
                        }
                    }
                    else if ( pPropValue->ulId == TEENS )
                    {
                        ASSERT( pPropValue->pFirstChild );
                        ASSERT( VT_UI4 == pPropValue->pFirstChild->vValue.vt );

                        llValCurrent = pPropValue->pFirstChild->vValue.ulVal;

                        TraceMsg(TF_GENERAL, "One Teens, %d", llValCurrent);
                    }
                    else
                    {
                        llValCurrent = 0;
                        TraceMsg(TF_GENERAL, "Wrong ulIds");
                        ASSERT(false);
                    }
                        
                    iNumDigit = 2;

                    break;
                }

            default :
                {
                    iNumDigit = 0;
                    llValCurrent = 0;
                    TraceMsg(TF_GENERAL, "ulId error!");
                    ASSERT(false);
                }
            }

            for (int i=0; i<iNumDigit; i++)
                llValue = llValue * 10;

            llValue += llValCurrent;
            TraceMsg(TF_GENERAL, "llValue=%d", llValue);
        }
    }
    else
    {   for (const SPPHRASEPROPERTY * pProp = pFirstProp; pProp; pProp ? pProp = pProp->pNextSibling : NULL)
        {
            switch(pProp->ulId)
            {
            case ONES:
                {
                    SPDBG_ASSERT(pProp->pFirstChild);
                    llValue += ComputeNum999En( pProp->pFirstChild );
                }
                break;
            case THOUSANDS:
                {    
                    llValue += ComputeNum999En( pProp->pFirstChild ) * 1000;
                }
            break;
            case MILLIONS:
                {
                    SPDBG_ASSERT(pProp->pFirstChild);
                    llValue += ComputeNum999En( pProp->pFirstChild ) * (LONGLONG) 1e6;
                }
                break;
            case BILLIONS:
                {
                    SPDBG_ASSERT(pProp->pFirstChild);
                    llValue += ComputeNum999En( pProp->pFirstChild ) * (LONGLONG) 1e9;
                }
                break;
            case HUNDREDS:
                {
                    SPDBG_ASSERT( pProp->pFirstChild );
                    llValue += ComputeNum999En( pProp->pFirstChild ) * 100;
                }
                break;

            case TENS:
            default:
                SPDBG_ASSERT(false);
            }
        }
    }

    if ( fNegative )
        llValue *= (-1);

    *pdblVal = (DOUBLE) llValue;

    DWORD dwDisplayFlags =  (fCardinal ? 0 : DF_ORDINAL)
                            | (fFinalDisplayFmt ? DF_MILLIONBILLION : 0 );
    hr = MakeDisplayNumber( *pdblVal, dwDisplayFlags, 0, 0, pszVal, cSize );

    return hr;
}



HRESULT CSimpleITN::InterpretDecimalEn
(   const SPPHRASEPROPERTY *pProperties, 
    const bool fCardinal,
    DOUBLE *pdblVal,
    WCHAR *pszVal,
    UINT cSize,
    const bool fFinalDisplayFmt,
    BOOL  fNegative)
{
    HRESULT  hr = S_OK;

    const SPPHRASEPROPERTY *pPropertiesFpPart = NULL;
    const SPPHRASEPROPERTY *pPropertiesPointZero = NULL;
    const SPPHRASEPROPERTY *pPropertiesOnes = NULL;
    const SPPHRASEPROPERTY *pPropertiesZero = NULL;
    const SPPHRASEPROPERTY *pPropertiesPtr;

    if ( !pdblVal || !pszVal || !pProperties)
    {
        return E_POINTER;
    }

    *pszVal = 0;

    for(pPropertiesPtr=pProperties; pPropertiesPtr; pPropertiesPtr=pPropertiesPtr->pNextSibling)
    {
        if (POINT_ZERO == pPropertiesPtr->ulId )
            pPropertiesPointZero = pPropertiesPtr;
        else if ( FP_PART == pPropertiesPtr->ulId )
            pPropertiesFpPart = pPropertiesPtr;
        else if (ONES == pPropertiesPtr->ulId )
            pPropertiesOnes = pPropertiesPtr;
        else if (ZERO == pPropertiesPtr->ulId )
            pPropertiesZero = pPropertiesPtr;
    }

    // Look for optional ONES (optional because you can say 
    // "point five"
    if ( pPropertiesOnes )
    {
        SPDBG_ASSERT(pPropertiesOnes->pFirstChild);

        hr = InterpretIntegerEn( pPropertiesOnes->pFirstChild, 
                                 fCardinal,
                                 pdblVal,
                                 pszVal,
                                 cSize,
                                 fFinalDisplayFmt,
                                 FALSE);

    }
    else if (pPropertiesZero || m_nmfmtDefault.LeadingZero )
    {
        // There should be a leading zero
        StringCchCopyW( pszVal, cSize, L"0" );
    }

    SPDBG_ASSERT(pPropertiesFpPart || pPropertiesPointZero);

    // Put in a decimal separator

    // Set m_nmfmtDefault.lpDecimalSep as L'.'

    if ( m_nmfmtDefault.lpDecimalSep )
    {
        if ( (cSize - wcslen( pszVal )) < (wcslen(m_nmfmtDefault.lpDecimalSep) + 1) )
        {
            return E_INVALIDARG;
        }
        StringCchCatW( pszVal, cSize, m_nmfmtDefault.lpDecimalSep);
    }

    if ( pPropertiesFpPart )
    {
        // Deal with the FP part, which will also have been ITNed correctly

        INT  ulSize = cSize - wcslen(pszVal);

        if ( ulSize < 0 )
            return E_FAIL;

        WCHAR  *pwszFpValue = new WCHAR[ulSize+1];
        DOUBLE dblFPPart;

        if (pwszFpValue) 
        {
            hr = InterpretIntegerEn( pPropertiesFpPart->pFirstChild, 
                                 fCardinal,
                                 &dblFPPart,
                                 pwszFpValue,
                                 ulSize,
                                 fFinalDisplayFmt,
                                 FALSE);

            if ( hr == S_OK )
            {
                StringCchCatW( pszVal, cSize, pwszFpValue);
      
                for ( UINT ui=0; ui < wcslen(pwszFpValue); ui++ )
                {
                    dblFPPart /= (DOUBLE) 10;
                }
                *pdblVal += dblFPPart;
            }

            delete[] pwszFpValue;
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else
    {
        // "point oh": The DOUBLE is already right, just add a "0"
        if ( (cSize - wcslen( pszVal )) < 2 )
        {
            return E_INVALIDARG;
        }
        StringCchCatW( pszVal, cSize, L"0" );
    }

    // Handle the negative sign
    if ( (hr == S_OK) && fNegative)
    {
        *pdblVal = -*pdblVal;

        if ( (cSize = wcslen( pszVal )) < 2 )
        {
            return E_INVALIDARG;
        }

        hr = MakeNumberNegative( pszVal, cSize );
    }

    return hr;
}


HRESULT CSimpleITN::MakeNumberNegative( WCHAR *pwszNumber, UINT cSize  )
{
    // Create a temporary buffer with the non-negated number in it

    if ( (pwszNumber == NULL) || (cSize == 0) )
        return E_POINTER;

    WCHAR *pwszTemp = _wcsdup( pwszNumber );
    if ( !pwszTemp )
    {
        return E_OUTOFMEMORY;
    }

    switch ( m_nmfmtDefault.NegativeOrder )
    {
    case 0:
        // (1.1)
        StringCchCopyW( pwszNumber, cSize, L"(" );
        StringCchCatW( pwszNumber, cSize, pwszTemp );
        StringCchCatW( pwszNumber, cSize, L")" );
        break;

    case 1: case 2:
        // 1: -1.1  2: - 1.1
        StringCchCopyW( pwszNumber,  cSize, m_pwszNeg );
        if ( 2 == m_nmfmtDefault.NegativeOrder )
        {
            StringCchCatW( pwszNumber, cSize, L" " );
        }
        StringCchCatW( pwszNumber, cSize, pwszTemp );
        break;

    case 3: case 4:
        // 3: 1.1-  4: 1.1 -
        StringCchCopyW( pwszNumber, cSize, pwszTemp );
        if ( 4 == m_nmfmtDefault.NegativeOrder )
        {
            StringCchCatW( pwszNumber, cSize, L" " );
        }
        StringCchCatW( pwszNumber, cSize, m_pwszNeg );
        break;

    default:
        SPDBG_ASSERT( false );
        break;
    }

    free( pwszTemp );

    return S_OK;
}   /* CTestITN::MakeNumberNegative */

/***********************************************************************
* _EnsureNumberFormatDefaults 
*
*   Description:
*       This finds all of the defaults for formatting numbers for
*        this user.
*************************************************************************/
HRESULT CSimpleITN::_EnsureNumberFormatDefaults()
{
    LCID lcid = MAKELCID(m_langid, SORT_DEFAULT);

    if (m_pwszNeg != NULL) return S_OK; 

    //
    // we use ansi version so we can run on win9x too
    //
    CHAR szLocaleData[16];
    
    int iRet = GetLocaleInfoA( lcid, LOCALE_IDIGITS, szLocaleData, ARRAYSIZE(szLocaleData) );
    if ( !iRet )
    {
        return E_FAIL;
    }
    m_nmfmtDefault.NumDigits = atoi( szLocaleData );    
    
    iRet = GetLocaleInfoA( lcid, LOCALE_ILZERO, szLocaleData, ARRAYSIZE(szLocaleData) );
    if ( !iRet )
    {
        return E_FAIL;
    }
    // It's always either 0 or 1
    m_nmfmtDefault.LeadingZero = atoi( szLocaleData );

    iRet = GetLocaleInfoA( lcid, LOCALE_SGROUPING, szLocaleData, ARRAYSIZE(szLocaleData) );
    if ( !iRet )
    {
        return E_FAIL;
    }
    // It will look like single_digit;0, or else it will look like
    // 3;2;0
    UINT uiGrouping = *szLocaleData - '0';
    if ( (3 == uiGrouping) && (';' == szLocaleData[1]) && ('2' == szLocaleData[2]) )
    {
        uiGrouping = 32;   
    }
    m_nmfmtDefault.Grouping = uiGrouping;

    iRet = GetLocaleInfoA( lcid, LOCALE_INEGNUMBER, szLocaleData, ARRAYSIZE(szLocaleData) );
    if ( !iRet )
    {
        return E_FAIL;
    }
    m_nmfmtDefault.NegativeOrder = atoi( szLocaleData );

    // Get the negative sign
    iRet = GetLocaleInfoA( lcid,  LOCALE_SNEGATIVESIGN, NULL, 0);
    if ( !iRet )
    {
        return E_FAIL;
    }

    CHAR szNeg[16];

    Assert(iRet < 8);

    int        iLenNeg = iRet + 1;
    m_pwszNeg = new WCHAR[ iLenNeg ];

    if ( m_pwszNeg == NULL )
    {
        return E_OUTOFMEMORY;
    }

    iRet = GetLocaleInfoA( lcid,  LOCALE_SNEGATIVESIGN, szNeg, iRet );

    StringCchCopyW(m_pwszNeg, iLenNeg, AtoW(szNeg));

    iRet = GetLocaleInfoA( lcid, LOCALE_SDECIMAL, NULL, 0);

    if ( !iRet )
        return E_FAIL;

    Assert(iRet < 16);
    
    if ( m_nmfmtDefault.lpDecimalSep )
    {
        delete[] m_nmfmtDefault.lpDecimalSep;
        m_nmfmtDefault.lpDecimalSep = NULL;
    }

    int   iDecSepLen = iRet + 1;
    m_nmfmtDefault.lpDecimalSep = new WCHAR[ iDecSepLen ];

    if ( m_nmfmtDefault.lpDecimalSep == NULL )
    {
        return E_OUTOFMEMORY;
    }

    iRet = GetLocaleInfoA( lcid,  LOCALE_SDECIMAL, szNeg, iRet );

    StringCchCopyW(m_nmfmtDefault.lpDecimalSep, iDecSepLen, AtoW(szNeg));

    iRet = GetLocaleInfoA( lcid, LOCALE_STHOUSAND, NULL, 0);

    if ( !iRet )
        return E_FAIL;

    Assert(iRet < 16);

    if ( m_nmfmtDefault.lpThousandSep )
    {
        delete[] m_nmfmtDefault.lpThousandSep;
        m_nmfmtDefault.lpThousandSep = NULL;
    }

    int   iThousSepLen = iRet + 1;
    m_nmfmtDefault.lpThousandSep = new WCHAR[ iThousSepLen ];

    if ( m_nmfmtDefault.lpThousandSep == NULL )
    {
        return E_OUTOFMEMORY;
    }

    iRet = GetLocaleInfoA( lcid,  LOCALE_STHOUSAND, szNeg, iRet );

    StringCchCopyW(m_nmfmtDefault.lpThousandSep, iThousSepLen, AtoW(szNeg));

    return iRet ? S_OK : E_FAIL;
}

/***********************************************************************
*   MakeDisplayNumber
*
*   Description:
*       Converts a DOUBLE into a displayable
*       number in the range -999,999,999,999 to +999,999,999,999.
*       cSize is the number of chars for which pwszNum has space
*       allocated.
*       If DF_UNFORMATTED is set, all other flags are ignored,
*           and the number is passed back as an optional negative
*           followed by a string of digits
*       If DF_ORDINAL is set in dwDisplayFlags, displays an
*           ordinal number (i.e. tacks on "th" or the appropriate suffix.
*       If DF_WHOLENUMBER is set, lops off the decimal separator
*           and everything after it.  If DF_WHOLENUMBER is not set,
*           then uses the uiDecimalPlaces parameter to determine
*           how many decimal places to display
*       If DF_FIXEDWIDTH is set, will display at least uiFixedWidth
*           digits; otherwise uiFixedWidth is ignored.
*       If DF_NOTHOUSANDSGROUP is set, will not do thousands
*           grouping (commas)
*************************************************************************/
HRESULT CSimpleITN::MakeDisplayNumber(DOUBLE dblNum, 
                         DWORD dwDisplayFlags,
                         UINT uiFixedWidth,
                         UINT uiDecimalPlaces,
                         WCHAR *pwszNum,
                         UINT cSize )
{
    SPDBG_ASSERT( pwszNum );
    SPDBG_ASSERT( !SPIsBadWritePtr( pwszNum, cSize ) );
    *pwszNum = 0;

    // Get the default number formatting.
    // Note that this gets called every time, since otherwise there
    // is no way to pick up changes that the user has made since
    // this process has started.
    HRESULT hr = _EnsureNumberFormatDefaults();
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    // check for straight millions and straight billions
    // This is a workaround for the fact that we can't resolve the ambiguity
    // and get "two million" to go through GRID_INTEGER_MILLBILL

    if ( m_langid != 0x0411 )
    {
        if (( dwDisplayFlags & DF_WHOLENUMBER ) && ( dwDisplayFlags & DF_MILLIONBILLION ) && (dblNum > 0))
        {
            if ( 0 == (( ((LONGLONG) dblNum) % BILLION )) )
            {
                // e.g. for "five billion" get the "5" and then 
                // tack on " billion"
                hr = MakeDisplayNumber( ( dblNum / ((DOUBLE) BILLION) ), 
                    dwDisplayFlags, uiFixedWidth, uiDecimalPlaces, pwszNum, cSize );
                if ( SUCCEEDED( hr ) )
                {
                    StringCchCatW( pwszNum, cSize, L" " );
                    StringCchCatW( pwszNum, cSize, BILLION_STR );
                }
                return hr;
            }
            else if (( ((LONGLONG) dblNum) < BILLION ) && 
                    ( 0 == (( ((LONGLONG) dblNum) % MILLION )) ))
            {
                hr = MakeDisplayNumber( ( dblNum / ((DOUBLE) MILLION) ), 
                    dwDisplayFlags, uiFixedWidth, uiDecimalPlaces, pwszNum, cSize );
                if ( SUCCEEDED( hr ) )
                {
                    StringCchCatW( pwszNum, cSize, L" " );
                    StringCchCatW( pwszNum, cSize, MILLION_STR );
                }
                    return hr;
            }
        }
    }
    else
    {
        if (( dwDisplayFlags & DF_WHOLENUMBER ) && (dblNum > 0))
        {
            if ( 0 == (( ((LONGLONG) dblNum) % CHUU )) )
            {
                hr = MakeDisplayNumber( ( dblNum / ((DOUBLE) CHUU) ), 
                    dwDisplayFlags, uiFixedWidth, uiDecimalPlaces, pwszNum, cSize);
                if ( SUCCEEDED( hr ) )
                {
                    StringCchCatW( pwszNum, cSize, CHUU_STR );
                }
                return hr;
            }
            else if (( ((LONGLONG) dblNum) < CHUU ) && 
                    ( 0 == (( ((LONGLONG) dblNum) % OKU )) ))
            {
                hr = MakeDisplayNumber( ( dblNum / ((DOUBLE) OKU) ), 
                    dwDisplayFlags, uiFixedWidth, uiDecimalPlaces, pwszNum, cSize);
                if ( SUCCEEDED( hr ) )
                {
                    StringCchCatW( pwszNum, cSize, OKU_STR );
                }
                    return hr;
            }
            else if (( ((LONGLONG) dblNum) < OKU ) && 
                    ( 0 == (( ((LONGLONG) dblNum) % MANN )) ))
            {
                hr = MakeDisplayNumber( ( dblNum / ((DOUBLE) MANN) ), 
                    dwDisplayFlags, uiFixedWidth, uiDecimalPlaces, pwszNum, cSize);
                if ( SUCCEEDED( hr ) )
                {
                    StringCchCatW( pwszNum, cSize, MANN_STR );
                }
                return hr;
            }
        }
    }

    // Put in the negative sign if necessary
    if ( dblNum < 0 )
    {
        StringCchCatW( pwszNum, cSize, L"-" );

        // From now on we want to deal with the magnitude of the number
        dblNum *= -1;
    }
   
    SPDBG_ASSERT(m_langid == 0x411 ? dblNum < 1e16 : dblNum < 1e12 );

    WCHAR *pwszTemp = new WCHAR[ cSize ];
    if ( !pwszTemp )
    {
        return E_OUTOFMEMORY;
    }
    *pwszTemp = 0;

    LONGLONG llIntPart = (LONGLONG) dblNum;
    UINT64 uiDigitsLeftOfDecimal;
    if ( dwDisplayFlags & DF_WHOLENUMBER )
    {
        StringCchPrintfW( pwszTemp, cSize, L"%I64d", llIntPart );
        uiDigitsLeftOfDecimal = wcslen( pwszTemp );
    }
    else
    {
        StringCchPrintfW( pwszTemp, cSize, L"%.*f", uiDecimalPlaces, dblNum );
        WCHAR *pwc = wcschr( pwszTemp, L'.' );
        uiDigitsLeftOfDecimal = pwc - pwszTemp;
    }
    

    // The following handles the case where the user said something
    // like "zero zero zero three" and wants to see "0,003"
    BOOL fChangedFirstDigit = false;
    const WCHAR wcFakeFirstDigit = L'1';
    if ( !(dwDisplayFlags & DF_UNFORMATTED) && 
        (dwDisplayFlags & DF_FIXEDWIDTH) && (uiDigitsLeftOfDecimal < uiFixedWidth) )
    {
        // The following handles the case where the user wants leading 
        // zeroes displayed
        
        // Need to pad the front with zeroes
        for ( UINT ui = 0; ui < (uiFixedWidth - uiDigitsLeftOfDecimal); ui++ )
        {
            StringCchCatW( pwszNum, cSize, L"0" );
        }
        
        // HACK
        // In order to force something like "zero zero zero three" 
        // into the form "0,003", we need to make GetNumberFormat() 
        // think that the first digit is 1.
        WCHAR *pwc = wcschr( pwszNum, L'0' );
        SPDBG_ASSERT( pwc );
        *pwc = wcFakeFirstDigit;
        fChangedFirstDigit = true;
    }

    // Copy over the unformatted number after the possible negative sign
    StringCchCatW( pwszNum, cSize, pwszTemp );
    delete[] pwszTemp;

    // If we do not want to format the number, then bail here
    if ( dwDisplayFlags & DF_UNFORMATTED )
    {
        return S_OK;
    }

    // Make a copy so that we can change some fields according to the 
    // flags param
    NUMBERFMTW nmfmt = m_nmfmtDefault;

    // How many decimal places to display?
    if ( dwDisplayFlags & DF_WHOLENUMBER )
    {
        nmfmt.NumDigits = 0;
    }
    else
    {
        // Use the uiDecimalPlaces value to determine how
        // many to display
        nmfmt.NumDigits = uiDecimalPlaces;
    }
    
    // Leading zeroes?
    nmfmt.LeadingZero = (dwDisplayFlags & DF_LEADINGZERO) ? 1 : 0;

    // Thousands grouping?
    if ( dwDisplayFlags & DF_NOTHOUSANDSGROUP )
    {
        nmfmt.Grouping = 0;
    }

#if  0
    
    if ( m_langid == 0x411)
    {
        // Format the number string
        WCHAR *pwszFormattedNum = new WCHAR[ cSize ];
        if ( !pwszFormattedNum )
        {
            return E_OUTOFMEMORY;
        }
        *pwszFormattedNum = 0;

        int iRet;
        do
        {
        
            iRet = GetNumberFormatW( m_langid, 0, pwszNum, &nmfmt, pwszFormattedNum, cSize );
            if ( !iRet && nmfmt.NumDigits )
            {
                // Try displaying fewer digits
                nmfmt.NumDigits--;
            }
        }   while ( !iRet && nmfmt.NumDigits );
        SPDBG_ASSERT( iRet );

        // Copy the formatted number into pwszNum
        StringCchCopyW( pwszNum, cSize, pwszFormattedNum );
        delete[] pwszFormattedNum;
    }
#endif

    // This undoes the hack of changing the first digit
    if ( fChangedFirstDigit )
    {
        // We need to find the first digit and change it back to zero
        WCHAR *pwc = wcschr( pwszNum, wcFakeFirstDigit );
        SPDBG_ASSERT( pwc );
        *pwc = L'0';
    }

    if ( dwDisplayFlags & DF_ORDINAL )
    {
        SPDBG_ASSERT( dwDisplayFlags & DF_WHOLENUMBER );    // sanity

        // This is an ordinal number, tack on the appropriate suffix
        
        // The "st", "nd", "rd" endings only happen when you
        // don't have something like "twelfth"
        if ( ((llIntPart % 100) < 10) || ((llIntPart % 100) > 20) )
        {
            switch ( llIntPart % 10 )
            {
            case 1:
                StringCchCatW( pwszNum, cSize, L"st" );
                break;
            case 2:
                StringCchCatW( pwszNum, cSize, L"nd" );
                break;
            case 3:
                StringCchCatW( pwszNum, cSize, L"rd" );
                break;
            default:
                StringCchCatW( pwszNum, cSize, L"th" );
                break;
            }
        }
        else
        {
            StringCchCatW( pwszNum, cSize, L"th" );
        }
    }

    return S_OK;

}   /* MakeDisplayNumber */

/***********************************************************************
* ComputeNum999 
*
*   Description:
*       Converts a set of SPPHRASEPROPERTYs into a number in
*       [-999, 999].
*       The way these properties is structured is that the top-level 
*       properties contain the place of the number (100s, 10s, 1s)
*       by having the value 100, 10, or 1.
*       The child has the appropriate number value.
*   Return:
*       Value of the number
*************************************************************************/
ULONG CSimpleITN::ComputeNum999En(const SPPHRASEPROPERTY *pProperties )
{
    ULONG ulVal = 0;

    if ( pProperties == NULL )
        return ulVal;

    for (const SPPHRASEPROPERTY * pProp = pProperties; pProp; pProp = pProp->pNextSibling)
    {
        if ( ZERO != pProp->ulId )
        {
            SPDBG_ASSERT( pProp->pFirstChild );
            SPDBG_ASSERT( VT_UI4 == pProp->vValue.vt );
            SPDBG_ASSERT( VT_UI4 == pProp->pFirstChild->vValue.vt );

            ulVal += pProp->pFirstChild->vValue.ulVal * pProp->vValue.ulVal;
        }
    }
    return ulVal;
}


// assume that we have only THOUSANDS(qian), HUNDREDS(bai), TENS(shi), and ONES(ge) here!!
ULONG CSimpleITN::ComputeNum9999Ch(const SPPHRASEPROPERTY *pProperties)
{
    ULONG ulVal = 0;

    if ( !pProperties )
        return ulVal;

    if (pProperties->pFirstChild)
    {
        for (const SPPHRASEPROPERTY * pProp = pProperties; pProp; pProp = pProp->pNextSibling)
        {
            if ( 0 != pProp->ulId )
            {
                SPDBG_ASSERT( pProp->pFirstChild );
                SPDBG_ASSERT( VT_UI4 == pProp->vValue.vt );
                SPDBG_ASSERT( VT_UI4 == pProp->pFirstChild->vValue.vt );

                ulVal += pProp->pFirstChild->vValue.ulVal * pProp->vValue.ulVal;
            }
        }
    }

    return ulVal;
}

ULONG CSimpleITN::ComputeNum10000Ch(const SPPHRASEPROPERTY *pProperties)
{
    ULONG  ulVal = 0;
    WCHAR * pszStopped;

    if ( !pProperties )
        return ulVal;

    ulVal = wcstol(pProperties->pszValue, &pszStopped, 10);

    return ulVal;
}


HRESULT CSimpleITN::InterpretNumberCh(const SPPHRASEPROPERTY *pProperties, 
                            const bool fCardinal,
                            DOUBLE *pdblVal,
                            WCHAR *pszVal,
                            UINT cSize,
                            const bool fFinalDisplayFmt)
{

    HRESULT  hr = S_OK;

    if ( !pdblVal || !pszVal || !pProperties)
    {
        return E_POINTER;
    }

    *pszVal = 0;

    BOOL fNegative = FALSE; 

    const SPPHRASEPROPERTY *pFirstProp = pProperties;

    // Handle negatives
    if ( CHS_NEGATIVE == pFirstProp->ulId )
    {
        // There had better be more stuff following
        SPDBG_ASSERT( pFirstProp->pNextSibling );

        fNegative = TRUE;

        pFirstProp = pFirstProp->pNextSibling;

        TraceMsg(TF_GENERAL, "This is a minus number");
    }

    
    if ( pFirstProp->ulId == CHS_GRID_NUMBER )
    {

        TraceMsg(TF_GENERAL, "Number is interger");

        SPDBG_ASSERT(pFirstProp->pFirstChild);

        pFirstProp = pFirstProp->pFirstChild;

        hr = InterpretIntegerCh(pFirstProp, 
                                fCardinal, 
                                pdblVal, 
                                pszVal, 
                                cSize, 
                                fFinalDisplayFmt, 
                                fNegative);

    }
    else if ( pFirstProp->ulId == CHS_GRID_DECIMAL )
    {
        TraceMsg(TF_GENERAL, "Number is floating pointer decimal");

        SPDBG_ASSERT(pFirstProp->pFirstChild);

        pFirstProp = pFirstProp->pFirstChild;

        hr = InterpretDecimalCh(pFirstProp, 
                                fCardinal, 
                                pdblVal, 
                                pszVal, 
                                cSize, 
                                fFinalDisplayFmt, 
                                fNegative);
    }

    return hr;
}



HRESULT CSimpleITN::InterpretIntegerCh
(   const SPPHRASEPROPERTY *pProperties, 
    const bool fCardinal,
    DOUBLE *pdblVal,
    WCHAR *pszVal,
    UINT cSize,
    const bool fFinalDisplayFmt,
    BOOL  fNegative)
{

    __int64 ulValue = 0;
    ULONG ulLength = 0;
    HRESULT  hr = S_OK;

    if ( !pdblVal || !pszVal || !pProperties)
    {
        return E_POINTER;
    }

    *pszVal = 0;

    const SPPHRASEPROPERTY *pFirstProp = pProperties;

    if ( pFirstProp->ulId == CHS_DIGITS )
    {
        // This must be digit-by-digit case, specially handle it here.

        for(const SPPHRASEPROPERTY * pProp=pFirstProp; pProp; pProp=pProp->pNextSibling)
        {
            ASSERT( pProp->ulId == CHS_DIGITS );
            ASSERT( VT_UI4 == pProp->vValue.vt );
            ulValue = ulValue * 10 + pProp->vValue.ulVal;
        }
    }
    else
    {
        for (const SPPHRASEPROPERTY * pProp = pFirstProp; pProp; pProp ? pProp = pProp->pNextSibling : NULL)
        {
            switch(pProp->ulId)
            {
            case CHS_TENTHOUSANDS_:
                {
                    __int64 v1 = 0;
                    _ASSERT(pProp);
                    SPDBG_ASSERT(pProp);
                    v1 = (__int64) ComputeNum10000Ch(pProp);
                    ulValue += v1 * 10000;
                }
                break;
            case CHS_TENTHOUSANDS:
                {
                    __int64 v1 = 0;
                    _ASSERT(pProp->pFirstChild);
                    SPDBG_ASSERT(pProp->pFirstChild);
                    v1 = (__int64) ComputeNum9999Ch(pProp->pFirstChild);
                    ulValue += v1 * 10000;
                }
                break;
            case CHS_HUNDREDMILLIONS:
                {
                    __int64 v1 = 0;
                    _ASSERT(pProp->pFirstChild);
                    SPDBG_ASSERT(pProp->pFirstChild);
                    v1 = (__int64) ComputeNum9999Ch(pProp->pFirstChild);
                    ulValue += v1 * 100000000;
                }
                break;
            case CHS_ONES:
                {
                    __int64 v1 = 0;
                    SPDBG_ASSERT(pProp->pFirstChild);
                    v1 = (__int64) ComputeNum9999Ch(pProp->pFirstChild);
                    ulValue += v1;
                    pProp = NULL;
                }
                break;
            case CHS_ONES_THOUSANDS:
                {
                    SPDBG_ASSERT(pProp->pFirstChild);
                    ulValue += pProp->pFirstChild->vValue.ulVal;
                    pProp = NULL;
                }
                break;
            case CHS_THOUSANDS:
            case CHS_HUNDREDS:
            default:
                _ASSERT(false);
                SPDBG_ASSERT(false);
            }
        }
    }

    if ( fNegative )
       ulValue *= (-1);

    *pdblVal = (DOUBLE) ulValue;

    DWORD dwDisplayFlags =  (fCardinal ? 0 : DF_ORDINAL);

    return MakeDisplayNumber( *pdblVal, dwDisplayFlags, 0, 0, pszVal, cSize );

}


    
HRESULT CSimpleITN::InterpretDecimalCh
(   const SPPHRASEPROPERTY *pProperties, 
    const bool fCardinal,
    DOUBLE *pdblVal,
    WCHAR *pszVal,
    UINT cSize,
    const bool fFinalDisplayFmt,
    BOOL  fNegative)
{

    HRESULT  hr = S_OK;

    const SPPHRASEPROPERTY *pPropertiesInteger = NULL;
    const SPPHRASEPROPERTY *pPropertiesPtr;

    if ( !pdblVal || !pszVal || !pProperties)
    {
        return E_POINTER;
    }

    *pszVal = 0;

    pPropertiesPtr = pProperties;

    SPDBG_ASSERT( pPropertiesPtr->ulId == CHS_INTEGER);

    pPropertiesInteger = pPropertiesPtr;

    SPDBG_ASSERT(pPropertiesInteger->pFirstChild);

    hr = InterpretIntegerCh( pPropertiesInteger->pFirstChild, 
                             fCardinal,
                             pdblVal,
                             pszVal,
                             cSize,
                             fFinalDisplayFmt,
                             FALSE);
   
    if ( hr == S_OK )
    {
        // Put in a decimal separator

        if ( m_nmfmtDefault.lpDecimalSep )
        {

            if ( (cSize - wcslen( pszVal )) < (wcslen(m_nmfmtDefault.lpDecimalSep) + 1) )
            {
                return E_INVALIDARG;
            }
            StringCchCatW( pszVal, cSize, m_nmfmtDefault.lpDecimalSep);
        }

        // Deal with the FP part, which will also have been ITNed correctly

         INT  ulSize = cSize - wcslen(pszVal);

         if ( ulSize < 0 )
             return E_FAIL;

        WCHAR  *pwszFpValue = new WCHAR[ulSize+1];

        if ( pwszFpValue )
        {
            DOUBLE dblFPPart = 0;

            for(pPropertiesPtr=pPropertiesPtr->pNextSibling; pPropertiesPtr; pPropertiesPtr=pPropertiesPtr->pNextSibling)
            {
                if ( pPropertiesPtr->ulId == CHS_DIGITS )
                {
                    SPDBG_ASSERT( VT_UI4 == pPropertiesPtr->vValue.vt );

                    dblFPPart = dblFPPart * 10 + pPropertiesPtr->vValue.ulVal;

                    StringCchCatW(pwszFpValue, ulSize + 1, pPropertiesPtr->pszValue);
                }
            }

            StringCchCatW( pszVal, cSize, pwszFpValue);
     
            for ( UINT ui=0; ui < wcslen(pwszFpValue); ui++ )
            {
                dblFPPart /= (DOUBLE) 10;
            }

            *pdblVal += dblFPPart;
            delete[] pwszFpValue;
        }
        else
            hr = E_OUTOFMEMORY;
    }

    // Handle the negative sign
    if ( (hr == S_OK) && fNegative)
    {
        *pdblVal = -*pdblVal;

        if ( (cSize = wcslen( pszVal )) < 2 )
        {
            return E_INVALIDARG;
        }

        hr = MakeNumberNegative( pszVal, cSize );
    }

    return hr;

}

// For Japanese.

/***********************************************************************
* CSimpleITN::InterpretNumberJp *
*-----------------------------*
*   Description:
*       Interprets a number in the range -999,999,999,999 to 
*       +999,999,999,999 and sends the properties and
*       replacements to the CFGInterpreterSite as appropriate.
*       The property will be added and the pszValue will be a string 
*       with the correct display number.
*       If fCardinal is set, makes the display a cardinal number;
*       otherwise makes it an ordinal number.
*       The number will be formatted only if it was a properly-formed
*       number (not given digit by digit).
*   Result:
*************************************************************************/
HRESULT CSimpleITN::InterpretNumberJp(const SPPHRASEPROPERTY *pProperties, 
                            const bool fCardinal,
                            DOUBLE *pdblVal,
                            WCHAR *pszVal,
                            UINT cSize,
                            const bool fFinalDisplayFmt)
{

    HRESULT  hr = S_OK;

    if ( !pdblVal || !pszVal || !pProperties)
    {
        return E_POINTER;
    }

    *pszVal = 0;

    BOOL     fNegative = FALSE; 

    const SPPHRASEPROPERTY *pFirstProp = pProperties;

    // Handle negatives
    if ( JPN_NEGATIVE == pFirstProp->ulId )
    {
        // There's no such thing as a negative ordinal
        SPDBG_ASSERT( fCardinal );

        // There had better be more stuff following
        SPDBG_ASSERT( pFirstProp->pNextSibling );

        fNegative = TRUE;

        pFirstProp = pFirstProp->pNextSibling;
    }

    if ( pFirstProp->ulId == JPN_GRID_INTEGER_STANDALONE )
    {
        TraceMsg(TF_GENERAL, "Number is Japanese Interger");

        SPDBG_ASSERT(pFirstProp->pFirstChild);

        pFirstProp = pFirstProp->pFirstChild;

        hr = InterpretIntegerJp(pFirstProp, 
                                fCardinal, 
                                pdblVal, 
                                pszVal, 
                                cSize, 
                                fFinalDisplayFmt, 
                                fNegative);
    }
    else
    {
        TraceMsg(TF_GENERAL, "Number is Japanese Floating pointer number");

        SPDBG_ASSERT(pFirstProp->pFirstChild);

        pFirstProp = pFirstProp->pFirstChild;

        hr = InterpretDecimalJp(pFirstProp, 
                                fCardinal, 
                                pdblVal, 
                                pszVal, 
                                cSize, 
                                fFinalDisplayFmt, 
                                fNegative);
    }

    return hr;

}   /* CSimpleITN::InterpretNumberJp */


/***********************************************************************
* ComputeNum9999Jp *
*----------------*
*   Description:
*       Converts a set of SPPHRASEPROPERTYs into a number in
*       [-9999, 9999].
*       The way these properties is structured is that the top-level 
*       properties contain the place of the number (100s, 10s, 1s)
*       by having the value 100, 10, or 1.
*       The child has the appropriate number value.
*   Return:
*       Value of the number
*************************************************************************/
ULONG CSimpleITN::ComputeNum9999Jp(const SPPHRASEPROPERTY *pProperties )//, ULONG *pVal)
{
    ULONG ulVal = 0;

    if ( !pProperties  )
        return ulVal;

    for (const SPPHRASEPROPERTY * pProp = pProperties; pProp; pProp = pProp->pNextSibling)
    {
        if ( JPN_ZERO != pProp->ulId )
        {
            SPDBG_ASSERT( VT_UI4 == pProp->vValue.vt );

            ulVal += pProp->vValue.ulVal;
        }
    }
    return ulVal;
}   /* ComputeNum9999Jp */

HRESULT CSimpleITN::InterpretIntegerJp
(   const SPPHRASEPROPERTY *pProperties, 
    const bool fCardinal,
    DOUBLE *pdblVal,
    WCHAR *pszVal,
    UINT cSize,
    const bool fFinalDisplayFmt,
    BOOL  fNegative)
{

    HRESULT  hr = S_OK;

    if ( !pdblVal || !pszVal || !pProperties)
    {
        return E_POINTER;
    }

    *pszVal = 0;

    LONGLONG llValue = 0;

    const SPPHRASEPROPERTY *pFirstProp = pProperties;

    // Handle the digit-by-digit case
    if ( JPN_GRID_DIGIT_NUMBER == pFirstProp->ulId )
    {
        UINT uiFixedWidth = 0;
        DOUBLE dblVal = 0;

        for(const SPPHRASEPROPERTY * pPropertiesPtr=pFirstProp->pFirstChild; pPropertiesPtr; pPropertiesPtr=pPropertiesPtr->pNextSibling)
        {
            if ( pPropertiesPtr->ulId == JPN_DIGIT )
            {
                SPDBG_ASSERT( VT_UI4 == pPropertiesPtr->vValue.vt );
                dblVal = dblVal * 10 + pPropertiesPtr->vValue.ulVal;
                uiFixedWidth ++;
           }
        }

        if ( fNegative )
            dblVal *= (-1);

        *pdblVal = dblVal;

        DWORD dwDisplayFlags = DF_WHOLENUMBER | DF_FIXEDWIDTH | DF_NOTHOUSANDSGROUP;
        return MakeDisplayNumber( *pdblVal, dwDisplayFlags, 
                                uiFixedWidth, 0, pszVal, MAX_PATH);
    }

    for (const SPPHRASEPROPERTY * pProp = pFirstProp; pProp; pProp ? pProp = pProp->pNextSibling : NULL)
    {
        switch(pProp->ulId)
        {
        case JPN_ICHIs:
            {
                SPDBG_ASSERT(pProp->pFirstChild);
                llValue += ComputeNum9999Jp( pProp->pFirstChild );
            }
            break;
        case JPN_MANNs:
            {
                llValue += ComputeNum9999Jp( pProp->pFirstChild ) * 10000;
            }
            break;
        case JPN_OKUs:
            {
                SPDBG_ASSERT(pProp->pFirstChild);
                llValue += ComputeNum9999Jp( pProp->pFirstChild ) * (LONGLONG) 1e8;
            }
            break;
        case JPN_CHOOs:
            {
                SPDBG_ASSERT(pProp->pFirstChild);
                llValue += ComputeNum9999Jp( pProp->pFirstChild ) * (LONGLONG) 1e12;
            }
            break;
        default:
            SPDBG_ASSERT(false);
        }
    }

    if ( fNegative )
       llValue *= (-1);

    *pdblVal = (DOUBLE) llValue;

    DWORD dwDisplayFlags = (fCardinal ? 0 : DF_ORDINAL);
    //Special code to handle minus 0.
    if ((fNegative) && (*pdblVal == 0.0f))
    {
        *pszVal = L'-';
        *(pszVal+1) = 0;
        hr = MakeDisplayNumber( *pdblVal, dwDisplayFlags, 0, 0, pszVal+1, cSize-1);
    }
    else
    {
        hr = MakeDisplayNumber( *pdblVal, dwDisplayFlags, 0, 0, pszVal, cSize);
    }

    return hr;
}


    
HRESULT CSimpleITN::InterpretDecimalJp
(   const SPPHRASEPROPERTY *pProperties, 
    const bool fCardinal,
    DOUBLE *pdblVal,
    WCHAR *pszVal,
    UINT cSize,
    const bool fFinalDisplayFmt,
    BOOL  fNegative)
{

    HRESULT hr = S_OK;
    UINT  uiFixedWidth = 0;
    DWORD dwDisplayFlags = 0;
    UINT   uiDecimalPlaces = 0;
    BOOL  bOverWriteNOTHOUSANDSGROUP = FALSE;

    const SPPHRASEPROPERTY *pPropertiesInteger = NULL;
    const SPPHRASEPROPERTY *pPropertiesPtr;

    if ( !pdblVal || !pszVal || !pProperties)
    {
        return E_POINTER;
    }

    *pszVal = 0;

    pPropertiesPtr = pProperties;

    *pdblVal = 0;

    if (m_nmfmtDefault.LeadingZero)
    {
        dwDisplayFlags |= DF_LEADINGZERO;
    }

    if ( JPN_ICHIs == pPropertiesPtr->ulId )
    {

        pPropertiesInteger = pPropertiesPtr;

        SPDBG_ASSERT(pPropertiesInteger->pFirstChild);

        hr = InterpretIntegerJp( pPropertiesInteger->pFirstChild, 
                                 fCardinal,
                                 pdblVal,
                                 pszVal,
                                 cSize,
                                 fFinalDisplayFmt,
                                 FALSE);

        if ( hr == S_OK )
        {

            dwDisplayFlags |= DF_FIXEDWIDTH;

            const WCHAR *pwc;
            for ( uiFixedWidth = 0, pwc = pszVal; *pwc; pwc++ )
            {
                if ( iswdigit( *pwc ) )
                {
                    uiFixedWidth++;
                }
            }
            if (!iswdigit( pszVal[wcslen(pszVal) - 1] ))
            {
                //Ends with Mann, Choo,..
                bOverWriteNOTHOUSANDSGROUP = TRUE;
            }

            // This needs to be here in case the user said "zero"
            dwDisplayFlags |= DF_LEADINGZERO;

            // If there is no thousands separator in its string value,
            // then leave out the thousands separator in the result
            if (m_nmfmtDefault.lpThousandSep && (NULL == wcsstr(pszVal, m_nmfmtDefault.lpThousandSep)) && !bOverWriteNOTHOUSANDSGROUP)
            {
                dwDisplayFlags |= DF_NOTHOUSANDSGROUP;
            }

            pPropertiesPtr = pPropertiesPtr->pNextSibling;
        }
    }
   
    if ( hr == S_OK )
    {
        // Deal with the FP part, which will also have been ITNed correctly

        if ( pPropertiesPtr && (JPN_FP_PART == pPropertiesPtr->ulId) ){

            DOUBLE dblFPPart = 0;
            
            uiDecimalPlaces = 0;

            for(pPropertiesPtr=pPropertiesPtr->pFirstChild; pPropertiesPtr; pPropertiesPtr=pPropertiesPtr->pNextSibling)
            {
                if ( pPropertiesPtr->ulId == JPN_DIGIT )
                {
                    SPDBG_ASSERT( VT_UI4 == pPropertiesPtr->vValue.vt );

                    dblFPPart = dblFPPart * 10 + pPropertiesPtr->vValue.ulVal;

                    uiDecimalPlaces ++;
               }
            }

     
            for ( UINT ui=0; ui < uiDecimalPlaces; ui++ )
            {
                dblFPPart /= (DOUBLE) 10;
            }

            *pdblVal += dblFPPart;
        }
        else if ( pPropertiesPtr && (JPN_FP_PART_D == pPropertiesPtr->ulId) ){

            // The user said "point" and one digit
            SPDBG_ASSERT( VT_UI4 == pPropertiesPtr->pFirstChild->vValue.vt );
            uiDecimalPlaces = 1;
            if ( *pdblVal >= 0 )
            {
                *pdblVal += pPropertiesPtr->pFirstChild->vValue.iVal / 10.0;
            }
            else
            {
                *pdblVal -= pPropertiesPtr->pFirstChild->vValue.iVal / 10.0;
            }

        }
    }

    // Handle the negative sign
    if ( (hr == S_OK) && fNegative)
    {
        *pdblVal = -*pdblVal;

    }

    hr = MakeDisplayNumber( *pdblVal, dwDisplayFlags, uiFixedWidth, uiDecimalPlaces, pszVal, cSize);

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\capital.h ===
#ifndef _CAPITAL_H
#define _CAPITAL_H

#include "sapilayr.h"

class CSapiIMX;
class CSpTask;

typedef enum
{
    CAPCOMMAND_NONE         =  0,
    CAPCOMMAND_CapThat      =  1,
    CAPCOMMAND_AllCapsThat  =  2,
    CAPCOMMAND_NoCapsThat   =  3,
    CAPCOMMAND_CapsOn       =  4,
    CAPCOMMAND_CapsOff      =  5,
    CAPCOMMAND_CapsLetter   =  6,

    CAPCOMMAND_MinIdWithText = 7,
    CAPCOMMAND_CapIt        =  8,
    CAPCOMMAND_AllCaps      =  9,
    CAPCOMMAND_NoCaps       =  10,
    CAPCOMMAND_CapLetter    =  11
} CAPCOMMAND_ID;

class CCapCmdHandler
{
public:
    CCapCmdHandler(CSapiIMX *psi);
    ~CCapCmdHandler( );

    HRESULT  ProcessCapCommands(CAPCOMMAND_ID idCapCmd, WCHAR *pwszTextToCap, ULONG ulLen);
    HRESULT  _ProcessCapCommands(TfEditCookie ec,ITfContext *pic, CAPCOMMAND_ID idCapCmd, WCHAR *pwszTextToCap, ULONG ulLen);

private:
    HRESULT  _GetCapPhrase(TfEditCookie ec,ITfContext *pic, BOOL *fSapiText);

    HRESULT  _SetNewText(TfEditCookie ec,ITfContext *pic, WCHAR *pwszNewText, BOOL fSapiText); 
    HRESULT  _CapsText(WCHAR **pwszNewText, WCHAR wchLetter=0);

    HRESULT  _HandleCapsThat(TfEditCookie ec,ITfContext *pic, WCHAR wchLetter=0);
    HRESULT  _HandleCapsIt(TfEditCookie ec,ITfContext *pic);

    HRESULT  _CapsOnOff(TfEditCookie ec,ITfContext *pic, BOOL fOn);

    CSapiIMX            *m_psi;
    CComPtr<ITfRange>   m_cpCapRange;
    CAPCOMMAND_ID       m_idCapCmd;
    CSpDynamicString    m_dstrTextToCap;
    ULONG               m_ulLen;
};

#endif  // _CAPITAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\candlist.h ===
//+---------------------------------------------------------------------------
//
//  File:       candlist.h
//
//  Contents:   
//
//----------------------------------------------------------------------------

#ifndef CANDLIST_H
#define CANDLIST_H

#include "ptrary.h"
#include "mscandui.h"

class CCandidateString;
typedef HRESULT (*CANDLISTCALLBACK)(ITfContext *pic, ITfRange *pRange, CCandidateString *pCand, TfCandidateResult imcr);

//+---------------------------------------------------------------------------
//
// CCandidateString
//
//----------------------------------------------------------------------------

class CCandidateString : public   ITfCandidateString,
                                    ITfCandidateStringIcon
{
public:
    CCandidateString( ULONG nIndex, WCHAR *psz, LANGID langid, void *pv, IUnknown *punk, 
                        ULONG ulID, HICON hIcon = NULL, WCHAR *pwzWord = NULL);
    ~CCandidateString();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfCandidateString
    //
    STDMETHODIMP GetString(BSTR *pbstr);
    STDMETHODIMP GetIndex(ULONG *pnIndex);

    // ITfCandidateStringIcon
    STDMETHODIMP GetIcon(HICON *phIcon)
    {
        if (m_hIcon)
        {
            *phIcon = m_hIcon;
            return S_OK;
        }
        else
        {
            return E_NOTIMPL;
        }
    }

    STDMETHODIMP GetID(ULONG *pID);
    STDMETHODIMP GetWord(BSTR *pbstr);

    HRESULT SetReadingString(WCHAR *psz)
    {
        _pszRead = new WCHAR[wcslen(psz) + 1];
        if  (!_pszRead )
            return E_OUTOFMEMORY;
        
        StringCchCopyW(_pszRead, wcslen(psz) + 1, psz);
        return S_OK;
    }

    IUnknown *_punk;
    void *_pv;
    ULONG _nIndex;
    WCHAR *_psz;
    WCHAR *_pszRead;
    LANGID _langid;
    int _cRef;

private:
    HICON m_hIcon;
    BSTR m_bstrWord;
    ULONG m_ulID;
};

//+---------------------------------------------------------------------------
//
// CCandidateList
//
//----------------------------------------------------------------------------

class CCandidateList :  public ITfCandidateList, 
                        public ITfOptionsCandidateList
{
public:
    CCandidateList(CANDLISTCALLBACK pfnCallback, ITfContext *pic, ITfRange *pRange, CANDLISTCALLBACK pfnOptionsCallback = NULL);
    ~CCandidateList();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfCandidateList
    //
    STDMETHODIMP EnumCandidates(IEnumTfCandidates **ppEnum);
    STDMETHODIMP GetCandidate(ULONG nIndex, ITfCandidateString **ppCand);
    STDMETHODIMP GetCandidateNum(ULONG *pnCnt);
    STDMETHODIMP SetResult(ULONG nIndex, TfCandidateResult imcr);

    //
    // ITfOptionsCandidateList
    //
    STDMETHODIMP EnumOptionsCandidates(IEnumTfCandidates **ppEnum);
    STDMETHODIMP GetOptionsCandidate(ULONG nIndex, ITfCandidateString **ppCand);
    STDMETHODIMP GetOptionsCandidateNum(ULONG *pnCnt);
    STDMETHODIMP SetOptionsResult(ULONG nIndex, TfCandidateResult imcr);

	// Internal

    HRESULT AddString(WCHAR *psz, LANGID langid, void *pv, IUnknown *punk, CCandidateString **ppCandStr, ULONG ulID = 0, HICON hIcon = NULL);
    HRESULT AddOption(WCHAR *psz, LANGID langid, void *pv, IUnknown *punk, CCandidateString **ppCandStr, ULONG ulID = 0, HICON hIcon = NULL, WCHAR *pwzWord = NULL);
  
    ITfContext *_pic;
    ITfRange *_pRange;
    CPtrArray<CCandidateString> _rgCandStr;
    CPtrArray<CCandidateString> _rgOptionsStr;
    ITfFnReconversion *_pReconv;

    CANDLISTCALLBACK _pfnOptionsCallback;
    CANDLISTCALLBACK _pfnCallback;

    int _cRef;
};


//+---------------------------------------------------------------------------
//
// CEnumCandidates
//
//----------------------------------------------------------------------------

class CEnumCandidates : public IEnumTfCandidates
{
public:
    CEnumCandidates(CCandidateList *pList, BOOL fOptionsCandidates = FALSE);
    ~CEnumCandidates();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IEnumTfCandidates
    //
    STDMETHODIMP Clone(IEnumTfCandidates **ppEnum);
    STDMETHODIMP Next(ULONG ulCount, ITfCandidateString **ppCand, ULONG *pcFetched);
    STDMETHODIMP Reset();
    STDMETHODIMP Skip(ULONG ulCount);

private:
    CCandidateList *_pList;
    CPtrArray<CCandidateString> *_rgCandList;
    int _nCur;
    int _cRef;
};


#endif // CANDLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\crtfree.cpp ===
#include "private.h"

#define CPP_FUNCTIONS
#include "icrtfree.h" // Code to help free modules from the bondage and tyranny of CRT libraries
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\citn.h ===
#ifndef CITN_H
#define CITN_H

#include "sphelper.h"

// Flags for number display
typedef enum DISPLAYFLAGS
{
    DF_UNFORMATTED      = (1L << 0),// No formatting
    DF_ORDINAL          = (1L << 1),// Ordinal number
    DF_WHOLENUMBER      = (1L << 2),// Should be displayed without decimal
    DF_FIXEDWIDTH       = (1L << 3),// Requiring a certain width
    DF_LEADINGZERO      = (1L << 4),// Presence of leading 0 of the number is between 0 and 1
    DF_NOTHOUSANDSGROUP = (1L << 5),// Do not do any thousands grouping (commas)
    DF_MILLIONBILLION   = (1L << 6) // If the number is a flat "millions" or "billions"
                                    // then display as "3 million"
}   DISPLAYFLAGS;

class CSimpleITN
{
public:

    CSimpleITN(LANGID langid)
    {
        m_langid       = langid;
        m_pwszNeg      = NULL;
    }
    ~CSimpleITN()
    {
        if (m_pwszNeg)
            delete m_pwszNeg;

        if ( m_nmfmtDefault.lpDecimalSep )
            delete[] m_nmfmtDefault.lpDecimalSep;

        if ( m_nmfmtDefault.lpThousandSep )
            delete[] m_nmfmtDefault.lpThousandSep;
    }

    HRESULT _EnsureNumberFormatDefaults(void);
    HRESULT MakeNumberNegative( WCHAR *pwszNumber, UINT cSize );
    HRESULT MakeDisplayNumber( DOUBLE dblNum, DWORD dwDisplayFlags,
                               UINT uiFixedWidth, UINT uiDecimalPlaces,
                               WCHAR *pwszNum, UINT cSize );

    HRESULT InterpretNumberSimple(const SPPHRASEPROPERTY *pProperties, 
                            DOUBLE *pdblVal,
                            WCHAR *pszVal,
                            UINT cSize)
    {
        HRESULT hr = _EnsureNumberFormatDefaults();

        if (S_OK != hr)
            return hr;
        

        hr = E_NOTIMPL;
        switch(PRIMARYLANGID(m_langid))
        {
            case LANG_ENGLISH:
                hr = InterpretNumberEn(pProperties, 
                            TRUE,
                            pdblVal,
                            pszVal,
                            cSize,
                            TRUE);
                break;
            case LANG_JAPANESE:
                hr = InterpretNumberJp(pProperties, 
                            TRUE,
                            pdblVal,
                            pszVal,
                            cSize,
                            TRUE);
                break;
            case LANG_CHINESE:
                hr = InterpretNumberCh(pProperties, 
                            TRUE,
                            pdblVal,
                            pszVal,
                            cSize,
                            TRUE);
                break;
            default:
                break;
        }
        return hr;
    }


    HRESULT InterpretNumberEn(const SPPHRASEPROPERTY *pProperties, 
                            const bool fCardinal,
                            DOUBLE *pdblVal,
                            WCHAR *pszVal,
                            UINT cSize,
                            const bool fFinalDisplayFmt);

    HRESULT InterpretIntegerEn(const SPPHRASEPROPERTY *pProperties, 
                            const bool fCardinal,
                            DOUBLE *pdblVal,
                            WCHAR *pszVal,
                            UINT cSize,
                            const bool fFinalDisplayFmt,
                            BOOL  fNegative);

    HRESULT InterpretDecimalEn(const SPPHRASEPROPERTY *pProperties, 
                            const bool fCardinal,
                            DOUBLE *pdblVal,
                            WCHAR *pszVal,
                            UINT cSize,
                            const bool fFinalDisplayFmt,
                            BOOL  fNegative);

    ULONG ComputeNum999En(const SPPHRASEPROPERTY *pProperties );


    HRESULT InterpretNumberJp(const SPPHRASEPROPERTY *pProperties, 
                            const bool fCardinal,
                            DOUBLE *pdblVal,
                            WCHAR *pszVal,
                            UINT cSize,
                            const bool fFinalDisplayFmt);

    HRESULT InterpretIntegerJp(const SPPHRASEPROPERTY *pProperties, 
                            const bool fCardinal,
                            DOUBLE *pdblVal,
                            WCHAR *pszVal,
                            UINT cSize,
                            const bool fFinalDisplayFmt,
                            BOOL  fNegative);
    
    HRESULT InterpretDecimalJp(const SPPHRASEPROPERTY *pProperties, 
                            const bool fCardinal,
                            DOUBLE *pdblVal,
                            WCHAR *pszVal,
                            UINT cSize,
                            const bool fFinalDisplayFmt,
                            BOOL  fNegative);

    ULONG ComputeNum9999Jp(const SPPHRASEPROPERTY *pProperties );

    HRESULT InterpretNumberCh(const SPPHRASEPROPERTY *pProperties, 
                            const bool fCardinal,
                            DOUBLE *pdblVal,
                            WCHAR *pszVal,
                            UINT cSize,
                            const bool fFinalDisplayFmt);

    HRESULT InterpretIntegerCh(const SPPHRASEPROPERTY *pProperties, 
                            const bool fCardinal,
                            DOUBLE *pdblVal,
                            WCHAR *pszVal,
                            UINT cSize,
                            const bool fFinalDisplayFmt,
                            BOOL  fNegative);

    HRESULT InterpretDecimalCh(const SPPHRASEPROPERTY *pProperties, 
                            const bool fCardinal,
                            DOUBLE *pdblVal,
                            WCHAR *pszVal,
                            UINT cSize,
                            const bool fFinalDisplayFmt,
                            BOOL  fNegative);

    ULONG ComputeNum9999Ch(const SPPHRASEPROPERTY *pProperties);
    ULONG ComputeNum10000Ch(const SPPHRASEPROPERTY *pProperties);

private:
    WCHAR       *m_pwszNeg;
    LANGID      m_langid;
    NUMBERFMTW  m_nmfmtDefault;
};


#define BILLIONS                      1
#define MILLIONS                      2
#define THOUSANDS                     3
#define HUNDREDS                      4
#define TENS                          5 
#define ONES                          6
#define TEENS                       200
#define NEGATIVE                      7
#define MILLBILL                      8
#define DIGIT                         9
#define TWODIGIT                     10
#define FP_PART                      11
#define ZERO                         12
#define POINT_ZERO                   13
#define NUMERATOR                    14
#define DENOMINATOR                  15
#define WHOLE                        16
#define ONEDIGIT                     17
#define GRID_INTEGER_99            101
#define GRID_INTEGER_999           102
#define GRID_INTEGER_MILLBILL      103
#define GRID_INTEGER_STANDALONE    104
#define GRID_INTEGER               105
#define GRID_INTEGER_NONNEG        106
#define GRID_DIGIT_NUMBER          107
#define GRID_FP_NUMBER             108
#define GRID_FP_NUMBER_NONNEG      109

// Definition for Chinese Grammar.
#define    CHS_HUNDREDMILLIONS      1
#define    CHS_TENTHOUSANDS         2
#define    CHS_TENTHOUSANDS_        3
#define    CHS_THOUSANDS            4
#define    CHS_HUNDREDS             5
#define    CHS_HUNDREDS_            6
#define    CHS_ONES                 7
#define    CHS_INTEGER              8
#define    CHS_DECIMAL              9
#define    CHS_NEGATIVE             10
#define    CHS_PERIOD               23
#define    CHS_DIGITS               24
#define    CHS_POS_OF_MINUS         27
#define    CHS_ONES_THOUSANDS       28
#define    CHS_GRID_NUMBER          1001
#define    CHS_GRID_NUMBER_MINUS    1002
#define    CHS_GRID_DECIMAL         1003
#define    CHS_GRID_NUMBER_ALL      1004

// Definition for Japanese Grammar
#define    JPN_YENs                 1
#define    JPN_CHOOs                2
#define    JPN_OKUs                 3
#define    JPN_MANNs                4
#define    JPN_SENNs                5
#define    JPN_HYAKUs               6
#define    JPN_JUUs                 7
#define    JPN_ICHIs                8
#define    JPN_NEGATIVE             9
#define    JPN_DIGIT                10
#define    JPN_FP_PART              12
#define    JPN_FP_PART_D            95
#define    JPN_ZERO                 13
#define    JPN_NUMERATOR            14
#define    JPN_DENOMINATOR          15
#define    JPN_WHOLE                16
#define    JPN_GRID_INTEGER_9999          1001
#define    JPN_GRID_INTEGER_STANDALONE    1002
#define    JPN_GRID_INTEGER               1003
#define    JPN_GRID_INTEGER_NONNEG        1004
#define    JPN_GRID_DIGIT_NUMBER          1005
#define    JPN_GRID_FP_NUMBER             1006
#define    JPN_GRID_NUMBER_ALL            1007

#endif // CITN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\correct.h ===
#ifndef _CORRECTION_H
#define _CORRECTION_H

#include "sapilayr.h"

class CSapiIMX;
class CSpTask;

class __declspec(novtable) CCorrectionHandler
{
public:
    CCorrectionHandler(CSapiIMX *psi);
    virtual ~CCorrectionHandler( );

    HRESULT InjectAlternateText(const WCHAR *pwszResult, LANGID langid, ITfContext *pic, BOOL bHandleLeadingSpace=FALSE);
    HRESULT _ProcessAlternateText(TfEditCookie ec, WCHAR *pwszText,LANGID langid, ITfContext *pic, BOOL bHandleLeadingSpace=FALSE);

    HRESULT CorrectThat();
    HRESULT _CorrectThat(TfEditCookie ec, ITfContext *pic);

    HRESULT _ReconvertOnRange(ITfRange *pRange, BOOL  *pfConvertable = NULL);
    HRESULT _DoReconvertOnRange( );

    HRESULT SetReplaceSelection(ITfRange *pRange,  ULONG cchReplaceStart,  ULONG cchReplaceChars, ITfContext *pic);
    HRESULT _SetReplaceSelection(TfEditCookie ec,  ITfContext *pic,  ITfRange *pRange,  ULONG cchReplaceStart,  ULONG cchReplaceChars);

    HRESULT _SaveCorrectOrgIP(TfEditCookie ec, ITfContext *pic);
    HRESULT _RestoreCorrectOrgIP(TfEditCookie ec, ITfContext *pic);
    void    _ReleaseCorrectOrgIP( );

    HRESULT RestoreCorrectOrgIP(ITfContext *pic);

    void    _SetRestoreIPFlag( BOOL fRestore )  {  fRestoreIP = fRestore; };

    HRESULT  _SetSystemReconvFunc( );
    void     _ReleaseSystemReconvFunc( );

private:

    CSapiIMX            *m_psi;
    CComPtr<ITfRange>   m_cpOrgIP;
    BOOL                fRestoreIP;  
                                     // indicates if need to restore IP 
                                     // after an alternate text is injected
                                     // to the doc.

                                     // If no alternate text is injected and the
                                     // candidate UI window is cancelled, it is always
                                     // to restore IP.

    CComPtr<ITfRange>   m_cpCorrectRange;  // the range to be corrected.
    CComPtr<ITfFnReconversion>    m_cpsysReconv;  //The system Reconverston function object.

    
};

#endif  // _CORRECTION_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\correctionimx.h ===
//
// correctionimx.h
//

#pragma once

#include "timsink.h"
#include "mscandui.h"
#include "globals.h"


#define ESCB_RESETTARGETPOS         1
#define ESCB_RECONVERTMYSELF        3
#define ESCB_INJECTALTERNATETEXT    4

enum WINDOWSTATE
{
    WINDOW_HIDE      = 0,
        // Hides the correction widget window.
    WINDOW_SMALL     = 1,
        // Resizes the correction widget window to small.
    WINDOW_SMALLSHOW = 2,
        // Shows the correction widget window in its initial small state.
    WINDOW_LARGE     = 3,
        // Resizes the correction widget window to its large size.
    WINDOW_REFRESH   = 4,
        // Moves the correction widget to a new location but does not change its size.
    WINDOW_LARGECLOSE = 5
        // Resizes the correction widget window to its large size and displays close icon.
};

#ifdef SUPPORT_INTERNAL_WIDGET
class CCorrectionIMX : 
                 public ITfTextInputProcessor,
                 public ITfTextEditSink,
                 public ITfTextLayoutSink,
                 public ITfThreadFocusSink,
                 public ITfKeyTraceEventSink,
                 public CComObjectRoot,
                 public CComCoClass<CCorrectionIMX, &CLSID_CorrectionIMX>
{
public:
    CCorrectionIMX();
    ~CCorrectionIMX();

    STDMETHODIMP FinalConstruct(void);

    BEGIN_COM_MAP(CCorrectionIMX)
        COM_INTERFACE_ENTRY(ITfTextInputProcessor)
        COM_INTERFACE_ENTRY(ITfTextEditSink)
        COM_INTERFACE_ENTRY(ITfTextLayoutSink)
        COM_INTERFACE_ENTRY(ITfThreadFocusSink)
        COM_INTERFACE_ENTRY(ITfKeyTraceEventSink)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(CCorrectionIMX)

    DECLARE_REGISTRY_RESOURCE(IDR_CORRECTIONIMX)

    static HRESULT CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);
    //
    // ITfTextInputProcessor
    //
    STDMETHODIMP Activate(ITfThreadMgr *ptim, TfClientId tid);
    STDMETHODIMP Deactivate();

    // ITfTextEditSink
    STDMETHODIMP OnEndEdit(ITfContext *pic, TfEditCookie ecReadOnly, ITfEditRecord *pEditRecord);

    // ITfTextLayoutSink
    STDMETHODIMP OnLayoutChange( ITfContext *pic, TfLayoutCode lcode, ITfContextView *pView );

    // ITfThreadFocusSink
    STDMETHODIMP OnSetThreadFocus(void);
    STDMETHODIMP OnKillThreadFocus(void);

    // ITfKeyTraceEventSink
    STDMETHODIMP OnKeyTraceDown(WPARAM wParam,LPARAM lParam);
    STDMETHODIMP OnKeyTraceUp(WPARAM wParam,LPARAM lParam);

    TfClientId GetId(void) { return m_tid; }
    ITfContext *GetIC(void) { return m_cpic; }

    CComPtr<ITfThreadMgr> m_cptim;

private:
    // Internal functions
	HRESULT InitICPriv(TfClientId tid, CICPriv *priv, ITfContext *pic);
	HRESULT DeleteICPriv(CICPriv *picp, ITfContext *pic);

    HRESULT GetReconversion(TfEditCookie ec, ITfCandidateList** ppCandList);
    static HRESULT SetResult(ITfContext *pic, ITfRange *pRange, CCandidateString *pCand, TfCandidateResult imcr);
    static HRESULT SetOptionResult(ITfContext *pic, ITfRange *pRange, CCandidateString *pCand, TfCandidateResult imcr);
    HRESULT ShowCandidateList(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfCandidateList *pCandList);

    HRESULT IsWordInDictionary(WCHAR *pwzWord);
    HRESULT AddWordToDictionary(WCHAR *pwzWord);
    HRESULT RemoveWordFromDictionary(WCHAR *pwzWord);

    HRESULT IsCandidateObjectOpen(ITfContext *pic, BOOL *fOpen);
    HRESULT CompareRange(TfEditCookie ecReadOnly, ITfRange *pRange1, ITfRange *pRange2, BOOL *fIdentical);
    HRESULT FindWordRange(TfEditCookie ecReadOnly, ITfRange *pRangeIP, ITfRange **pRangeWord);
    HRESULT DoesUserSelectionMatchReconversion(TfEditCookie ecReadOnly, ITfRange *pRangeUser, ITfRange *pRangeReconv, BOOL *fMatch);

    HRESULT UpdateWidgetLocation(TfEditCookie ec);
    HRESULT Show(WINDOWSTATE eWindowState);
    HRESULT DrawWidget(BYTE uAlpha);
    HRESULT LazyInitializeWindow(void);

    static HRESULT ICCallback(UINT uCode, ITfContext *pic, void *pv);
    static HRESULT DIMCallback(UINT uCode, ITfDocumentMgr *pdim, ITfDocumentMgr *pdimPrevFocus, void *pv);
    static HRESULT EditSessionCallback(TfEditCookie ec, CEditSession *pes);

    static LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    CComPtr<ITfRange> m_cpRangeReconv;
    CComPtr<ITfRange> m_cpRangeUser;
    CComPtr<ITfRange> m_cpRangeWord;
    CComPtr<ITfCandidateUI> m_cpCandUIEx;
    CComPtr<ITfFnReconversion> m_cpSysReconv;

    CComPtr<ITfContext> m_cpic;
    TfClientId          m_tid;

    CThreadMgrEventSink *m_ptimEventSink;

    WCHAR m_wszDelete[MAX_PATH];
    WCHAR m_wszAddPrefix[MAX_PATH];
    WCHAR m_wszAddPostfix[MAX_PATH];

    DWORD m_dwLayoutCookie;
    DWORD m_dwEditCookie;
    DWORD m_dwThreadFocusCookie;
    DWORD m_dwKeyTraceCookie;
    BOOL m_fExpanded;
    RECT m_rcSelection;
    BOOL m_fDisplayAlternatesMyself;

    HWND m_hWnd;

    HICON m_hIconInvoke;
    HICON m_hIconInvokeLarge;
    HICON m_hIconInvokeClose;

    WINDOWSTATE m_eWindowState;
    UINT m_uAlpha;

    CComPtr<ISpLexicon> m_cpLexicon;

    BOOL m_fCandidateOpen;
    BOOL m_fKeyDown;

    ATOM m_hAtom;
};
#endif // SUPPORT_INTERNAL_WIDGET
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\command.cpp ===
//
// command.cpp
// This file contains methods related to C&C grammars' commands handling.
//
//
#include "private.h"
#include "globals.h"
#include "sapilayr.h"
#include "nui.h"
#include "cresstr.h"

#define LB_ID_Correction            200
#define LB_ID_Microphone            201
#define LB_ID_VoiceCmd              202

#define Select_ID_SELECT             1
#define Select_ID_DELETE             2
#define Select_ID_CORRECT            3
#define Select_ID_SELTHROUGH         4
#define Select_ID_DELTHROUGH         5
#define Select_ID_UNSELECT           6
#define Select_ID_SELECTPREV         7
#define Select_ID_SELECTNEXT         8
#define Select_ID_CORRECTPREV        9
#define Select_ID_CORRECTNEXT        10
#define Select_ID_SELSENTENCE        11
#define Select_ID_SELPARAGRAPH       12
#define Select_ID_SELWORD            13
#define Select_ID_SelectAll          14
#define Select_ID_DeletePhrase       15     // Scratch That
#define Select_ID_Convert            16
#define Select_ID_SelectThat         17
#define Select_ID_Finalize           18

#define Navigate_ID_INSERTBEFORE     20
#define Navigate_ID_INSERTAFTER      21
#define Navigate_ID_Go_To_Bottom     22
#define Navigate_ID_Go_To_Top        23
#define Navigate_ID_Move_Home        24
#define Navigate_ID_Move_End         25
        
#define Edit_ID_Undo                 30
#define Edit_ID_Cut                  31
#define Edit_ID_Copy                 32
#define Edit_ID_Paste                33

#define Keyboard_ID_Move_Up          40
#define Keyboard_ID_Move_Down        41
#define Keyboard_ID_Move_Left        42
#define Keyboard_ID_Move_Right       43
#define Keyboard_ID_Page_Up          44
#define Keyboard_ID_Page_Down        45
#define Keyboard_ID_Tab              46
#define Keyboard_ID_Enter            47
#define Keyboard_ID_Backspace        48
#define Keyboard_ID_Delete           49
#define Keyboard_ID_SpaceBar         50

#define Case_ID_CapIt                70	
#define Case_ID_AllCaps              71   
#define Case_ID_NoCaps               72
#define Case_ID_CapThat              73
#define Case_ID_AllCapsThat          74
#define Case_ID_NoCapsThat           75

//
// CSpTask::_DoCommand
//
// review: the rulename may need to be localizable?
//

HRESULT CSpTask::_DoCommand(ULONGLONG ullGramId, SPPHRASE *pPhrase, LANGID langid)
{
    HRESULT hr = S_OK;

    TraceMsg(TF_GENERAL, "_DoCommand is called");

    if ( pPhrase->Rule.pszName )
    {
        switch (ullGramId)
        {
            case GRAM_ID_URLSPELL:
            case GRAM_ID_CCDICT:

                TraceMsg(TF_GENERAL, "Grammar is GRAM_ID_CCDICT");
                
                if (wcscmp(pPhrase->Rule.pszName, c_szDictTBRule) == 0)
                {
                    hr = _HandleDictCmdGrammar(pPhrase, langid);
                }
                else
                    hr = _HandleModeBiasCmd(pPhrase, langid);

                break;

            case GRAM_ID_CMDSHARED:

                TraceMsg(TF_SAPI_PERF, "Grammar is GRAM_ID_CMDSHARED");
                hr = _HandleShardCmdGrammar(pPhrase, langid);
                break;

/*            case  GRAM_ID_NUMMODE:

                TraceMsg(TF_GENERAL, "Grammar is GRAM_ID_NUMMODE");
                hr = _HandleNumModeGrammar(pPhrase, langid);
                break;
*/

            case GRAM_ID_TBCMD:

                TraceMsg(TF_GENERAL, "Grammar is GRAM_ID_TBCMD");
                hr = _HandleToolBarGrammar(pPhrase, langid);
                break;

            case GRID_INTEGER_STANDALONE:

                TraceMsg(TF_GENERAL, "Grammar is GRID_INTEGER_STANDALONE");
                hr = _HandleNumITNGrammar(pPhrase, langid);
                break;

            case GRAM_ID_SPELLING:

                TraceMsg(TF_GENERAL, "Grammar is GRAM_ID_SPELLING");
                hr = _HandleSpellGrammar(pPhrase, langid);
                break;

            default:
                break;
        }

        if (SUCCEEDED(hr) && m_pime && m_pime->IsFocusFullAware(m_pime->_tim))
        {
            // If this is a Cicero full aware application,
            // we need to finalize the composition after the text has
            // been handled ( changed ) successfully for this command.
            hr = m_pime->_FinalizeComposition();
        }

        // Feeding context to the dictation grammar if it is in diction mode.
        if ( SUCCEEDED(hr) && m_pime  && m_pime->GetDICTATIONSTAT_DictOnOff() )
           m_pime->_SetCurrentIPtoSR();

    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// _ShowCommandOnBalloon
//
// Show the command text from currnet Phrase to the Balloon
//----------------------------------------------------------------------------

void CSpTask::_ShowCommandOnBalloon(SPPHRASE *pPhrase)
{

    Assert(pPhrase);


    if (m_pime->GetSpeechUIServer())
    {
        ULONG  ulStartElem, ulNumElems;
        CSpDynamicString dstr;

        ulStartElem = pPhrase->Rule.ulFirstElement;
        ulNumElems = pPhrase->Rule.ulCountOfElements;

        for (ULONG i = ulStartElem; i < ulStartElem + ulNumElems; i++ )
        {
            if (pPhrase->pElements[i].pszDisplayText)
            {
                BYTE           bAttr = 0;

                bAttr = pPhrase->pElements[i].bDisplayAttributes;
                dstr.Append(pPhrase->pElements[i].pszDisplayText);

                if (bAttr & SPAF_ONE_TRAILING_SPACE)
                {
                    dstr.Append(L" ");
                }
                else if (bAttr & SPAF_TWO_TRAILING_SPACES)
                {
                    dstr.Append(L"  ");
                }
            }
        }

        m_pime->GetSpeechUIServer()->UpdateBalloon(TF_LB_BALLOON_RECO, (WCHAR *)dstr, -1);
    }
}

HRESULT CSpTask::_HandleModeBiasCmd(SPPHRASE *pPhrase, LANGID langid)
{

    HRESULT hr = S_OK;

    if (wcscmp(pPhrase->Rule.pszName, c_szDynUrlHist) == 0
     || wcscmp(pPhrase->Rule.pszName, c_szStaticUrlHist) == 0 
     || wcscmp(pPhrase->Rule.pszName, c_szStaticUrlSpell) == 0 )
    {
        // at this moment it's pretty simple, we just handle the first element 
        // for recognition
        //

        if ( pPhrase->pProperties && pPhrase->pProperties[0].pszValue)
        {

            if (wcscmp( pPhrase->pProperties[0].pszValue, L"dict") != 0)
            {
                hr = m_pime->InjectModebiasText(pPhrase->pProperties[0].pszValue, langid);
            }
            else
            {
                ULONG  ulStartElem, ulNumElems;
                CSpDynamicString dstr;

                ulStartElem = pPhrase->Rule.ulFirstElement;
                ulNumElems = pPhrase->Rule.ulCountOfElements;

                for (ULONG i = ulStartElem; i < ulStartElem + ulNumElems; i++ )
                {
                    if (pPhrase->pElements[i].pszDisplayText)
                    {
                        dstr.Append(pPhrase->pElements[i].pszDisplayText);
                    }
                }
                hr = m_pime->InjectModebiasText(dstr, langid);
            }
        }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
// _HandleDictCmdGrammar
//
// Handle all the commands in grammar dictcmd.xml
//
//----------------------------------------------------------------------------
HRESULT CSpTask::_HandleDictCmdGrammar(SPPHRASE *pPhrase, LANGID langid)
{
    HRESULT hr=S_OK;

    Assert(pPhrase);

    
    if ( pPhrase->pProperties == NULL )
        return hr;

    if (wcscmp(pPhrase->Rule.pszName, c_szDictTBRule) == 0)
    {
        //
        // Handling the toolbar commands in Dictation mode.
        // we have at most three commands support in Dictation mode.
        // Microphone, Correction and Voice Command.
        //

        // If current toolbar doesn't contain the button you spoke, 
        // what you said would be injected to the document as a dictated text.
        //
        // such as there is no "Correction" button on the toolbar, but you said "Correction",
        // text "Correction" should be injected to the document.
        //
        BOOL   fButtonClicked = FALSE;

        if (m_pLangBarSink)
        {
            if ( pPhrase->pProperties[0].pszValue )
            {
                // update the balloon
                _ShowCommandOnBalloon(pPhrase);
                fButtonClicked = m_pLangBarSink->ProcessToolbarCmd(pPhrase->pProperties[0].pszValue);
            }
        }

        if ( fButtonClicked )
        {
            m_pime->SaveLastUsedIPRange( );
            m_pime->SaveIPRange(NULL);
        }
        else
        {
            // there is no such as button on the toolbar.
            //
            // Return FAIL so that the consequent functions would inject the 
            // the RecoResult to the document.
                        
            _UpdateBalloon(IDS_DICTATING, IDS_DICTATING_TOOLTIP);
            TraceMsg(TF_SAPI_PERF, "There is such as button on toolbar");
            hr = E_FAIL;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// _HandleShardCmdGrammar
//
// Handle all commands in the shared command grammar shrdcmd.xml
// shared grammar is activated in both dictatin and command modes.
//----------------------------------------------------------------------------
HRESULT CSpTask::_HandleShardCmdGrammar(SPPHRASE *pPhrase, LANGID langid)
{
    HRESULT hr = S_OK;

    Assert(pPhrase);
    
    if ( pPhrase->pProperties == NULL )
        return hr;

    ULONG  idCmd;

    ASSERT( VT_UI4 == pPhrase->pProperties[0].vValue.vt );
    idCmd = (ULONG)pPhrase->pProperties[0].vValue.ulVal;

    if ( idCmd == 0 )
    {
        // This is the bogus command
        TraceMsg(TF_GENERAL, "The Bogus command is recognized!!!");
        return hr;
    }

    if ( 0 == wcscmp(pPhrase->Rule.pszName, c_szSelword) )
    {
        // Handel "Selword" rule
        hr = _HandleSelwordCmds(pPhrase, langid, idCmd);
    }
    else if ( 0 == wcscmp(pPhrase->Rule.pszName, c_szSelThrough) )
    {
        // Handle "Select Through" rule.
        //
        hr = _HandleSelectThroughCmds(pPhrase, langid, idCmd);

    }
    else if (0 == wcscmp(pPhrase->Rule.pszName, c_szSelectSimple))
    {
        // Handle some simple selection commands.
        hr = _HandleSelectSimpleCmds(idCmd);
    } 
    else if ( 0 == wcscmp(pPhrase->Rule.pszName, c_szEditCmds))
    {
        hr = m_pime->ProcessEditCommands(idCmd);
    }
    else if ( 0 == wcscmp(pPhrase->Rule.pszName, c_szNavigationCmds))
    {
        hr = _HandleNavigationCmds(pPhrase, langid, idCmd);
    }
    else if ( 0 == wcscmp(pPhrase->Rule.pszName, c_szCasingCmds))
    {
        hr = _HandleCasingCmds(pPhrase, langid, idCmd);
    }
    else if ( 0 == wcscmp(pPhrase->Rule.pszName, c_szKeyboardCmds))
    {
        hr = _HandleKeyboardCmds(langid, idCmd);
    }

   _ShowCommandOnBalloon(pPhrase);
   return hr;
}

HRESULT CSpTask::_HandleNavigationCmds(SPPHRASE *pPhrase, LANGID langid, ULONG idCmd)
{
    HRESULT  hr = S_OK;

    switch (idCmd)
    {
    case Navigate_ID_Move_Home :
        {
            WCHAR  wszKeys[2];

            wszKeys[0] = VK_HOME;
            wszKeys[1] = '\0';

            hr = m_pime->ProcessControlKeys(wszKeys, 1,langid);
            break;
        }

    case Navigate_ID_Move_End :
        {
            WCHAR  wszKeys[2];

            wszKeys[0] = VK_END;
            wszKeys[1] = '\0';

            hr = m_pime->ProcessControlKeys(wszKeys, 1,langid);
            break;
        }

    case Navigate_ID_Go_To_Bottom :

         hr = m_pime->ProcessSelectWord(NULL, 0, SELECTWORD_GOTOBOTTOM);
         break;
    case Navigate_ID_Go_To_Top :

         hr = m_pime->ProcessSelectWord(NULL, 0, SELECTWORD_GOTOTOP);
         break;

    case Navigate_ID_INSERTBEFORE :
    case Navigate_ID_INSERTAFTER :
        {
            SELECTWORD_OPERATION  sw_type;
            CSpDynamicString      dstrSelected;
            ULONG                 ulLen = 0;
            WORD                  PriLangId;

            ULONG   ulStartSelText = 0; // Start element for the selected text
            ULONG   ulNumSelText=0;     // Number of elements for the selected text.
            ULONG   ulStartElem, ulNumElems;
            ULONG   ulStartDelta=0, ulNumDelta=0;

            if ( idCmd == Navigate_ID_INSERTBEFORE )
                 sw_type = SELECTWORD_INSERTBEFORE;
            else
                 sw_type = SELECTWORD_INSERTAFTER;
          
            PriLangId = PRIMARYLANGID(langid);
 
            if ( PriLangId == LANG_ENGLISH)
            {
                ulStartDelta = 2;
                ulNumDelta = 2 ;
            }
            else if ( PriLangId == LANG_JAPANESE )
            {
                ulStartDelta = 0;
                ulNumDelta =  2;
            }
            else if (PriLangId == LANG_CHINESE)
            {
                ulStartDelta = 1;
                ulNumDelta =  2;
            }

            ulStartElem = pPhrase->Rule.ulFirstElement;
            ulNumElems = pPhrase->Rule.ulCountOfElements;

            ulStartSelText = ulStartElem + ulStartDelta;
            if (ulNumElems > ulNumDelta)
                ulNumSelText = ulNumElems - ulNumDelta;
            else 
                ulNumSelText = 0;
                  
            //
            // Get the text for the selection.
            // 
            for (ULONG i = ulStartSelText; i < ulStartSelText + ulNumSelText; i++ )
            {
                if ( pPhrase->pElements[i].pszDisplayText)
                {
                    BYTE bAttr = pPhrase->pElements[i].bDisplayAttributes;
                    dstrSelected.Append(pPhrase->pElements[i].pszDisplayText);

                    if ( i < ulStartSelText + ulNumSelText-1 )
                    {
                        if (bAttr & SPAF_ONE_TRAILING_SPACE)
                            dstrSelected.Append(L" ");
                        else if (bAttr & SPAF_TWO_TRAILING_SPACES)
                            dstrSelected.Append(L"  ");
                    }
                }
            }
            if ( dstrSelected )
                ulLen = wcslen(dstrSelected);
                    
            hr = m_pime->ProcessSelectWord(dstrSelected, ulLen, sw_type);

            break;
        }

    default :

        break;
    }

    return hr;
}

HRESULT CSpTask::_HandleKeyboardCmds(LANGID langid, ULONG idCmd)
{
    HRESULT hr = S_OK;
    WCHAR   wszKeys[2];

    wszKeys[0] = '\0';

    switch ( idCmd )
    {
    case Keyboard_ID_Tab :
         wszKeys[0] = VK_TAB;
         break;

    case Keyboard_ID_Enter :
        wszKeys[0] =  VK_RETURN;    // { 0x0d, 0x00 }
        break;

    case Keyboard_ID_Backspace :
        wszKeys[0] = VK_BACK;
        break;

    case Keyboard_ID_Delete :
        wszKeys[0] = VK_DELETE;
        break;

    case Keyboard_ID_SpaceBar :
        wszKeys[0] = VK_SPACE;
        break;

    case Keyboard_ID_Move_Up :
         wszKeys[0] = VK_UP;
         break;

    case Keyboard_ID_Move_Down :
         wszKeys[0] = VK_DOWN;
         break;

    case Keyboard_ID_Move_Left :
         wszKeys[0] = VK_LEFT;
         break;

    case Keyboard_ID_Move_Right :
         wszKeys[0] = VK_RIGHT;
         break;

    case Keyboard_ID_Page_Up :
         wszKeys[0] = VK_PRIOR;
         break;

    case Keyboard_ID_Page_Down :
         wszKeys[0] = VK_NEXT;
         break;

    default :
         break;
    }

    if ( wszKeys[0] )
    {
        wszKeys[1] = L'\0';
        hr = m_pime->ProcessControlKeys(wszKeys, 1,langid);
    }

    return hr;
}


HRESULT CSpTask::_HandleCasingCmds(SPPHRASE *pPhrase, LANGID langid, ULONG idCmd)
{
    HRESULT        hr = S_OK;
    CAPCOMMAND_ID  idCapCmd = CAPCOMMAND_NONE;

    Assert(idCmd);
    Assert(pPhrase);

    switch (idCmd)
    {
    case Case_ID_CapIt :
        idCapCmd = CAPCOMMAND_CapIt;

        break;

    case Case_ID_AllCaps :
        idCapCmd = CAPCOMMAND_AllCaps;

        break;

    case Case_ID_NoCaps :
        idCapCmd = CAPCOMMAND_NoCaps;

        break;

    case Case_ID_CapThat :
        idCapCmd = CAPCOMMAND_CapThat;

        break;

    case Case_ID_AllCapsThat :
        idCapCmd = CAPCOMMAND_AllCapsThat;

        break;

    case Case_ID_NoCapsThat :
        idCapCmd = CAPCOMMAND_NoCapsThat;

        break;
    default :
        Assert(0);
        hr = E_FAIL;
        TraceMsg(TF_GENERAL, "Got a wrong casing command!");
        return hr;
    }

    if ( idCapCmd != CAPCOMMAND_NONE )
    {
        // Capitalize command is recognized.
        CCapCmdHandler  *pCapCmdHandler; 
        pCapCmdHandler = m_pime->GetCapCmdHandler( );

        if ( pCapCmdHandler )
        {
            CSpDynamicString dstrTextToCap;
            ULONG            ulLen = 0;

            if ( idCapCmd > CAPCOMMAND_MinIdWithText )
            {
                ULONG   ulNumCmdElem = 2;
                ULONG   ulStartElem, ulNumElems;
               
                ulStartElem = pPhrase->Rule.ulFirstElement;
                ulNumElems = pPhrase->Rule.ulCountOfElements;
                //
                // the two elements are for command itself
                // 
                for (ULONG i = ulStartElem+ulNumCmdElem; i < ulStartElem + ulNumElems; i++ )
                {
                    if ( pPhrase->pElements[i].pszDisplayText)
                    {
                        BYTE bAttr = pPhrase->pElements[i].bDisplayAttributes;

                        dstrTextToCap.Append(pPhrase->pElements[i].pszDisplayText);

                        if (bAttr & SPAF_ONE_TRAILING_SPACE)
                             dstrTextToCap.Append(L" ");
                        else if (bAttr & SPAF_TWO_TRAILING_SPACES)
                             dstrTextToCap.Append(L"  ");
                    }
                }

                if ( dstrTextToCap )
                    ulLen = wcslen(dstrTextToCap);
            }

            pCapCmdHandler->ProcessCapCommands(idCapCmd, dstrTextToCap, ulLen);
        }
    }

    return hr;
}

HRESULT CSpTask::_HandleSelectThroughCmds(SPPHRASE *pPhrase, LANGID langid, ULONG idCmd)
{

    HRESULT hr = S_OK;

    // Select xxx through yyy.

    // dstrText will hold both XXX and YYY. 
    // ulLenXXX keeps the number of characters in XXX part.
    // ulLen keeps the char numbers of the whole text ( XXX + YYY )

    CSpDynamicString   dstrText;
    ULONG              ulLenXXX = 0;  
    ULONG              ulLen = 0;

    ULONG  ulStartElem, ulNumElems;
    ULONG  ulXYStartElem=0, ulXYNumElems=0;  // points to the elements including xxx through yyy.
    BOOL   fPassThrough = FALSE;             // indicates if the "Through" is reached and handled.

    SELECTWORD_OPERATION  sw_type = SELECTWORD_NONE;
    ULONG                 idCommand = 0;
    WCHAR                 *pwszThrough=NULL;


    // This rule has three properties,  the second and third properties are for "select" and "through"
    // the mapping relationship is different based on language.
    const SPPHRASEPROPERTY      *pPropertyFirst = pPhrase->pProperties;
    const SPPHRASEPROPERTY      *pPropertySecond = NULL;
    const SPPHRASEPROPERTY      *pPropertyThird = NULL;

    if ( !pPropertyFirst ) return hr;

    pPropertySecond = pPropertyFirst->pNextSibling;

    if ( !pPropertySecond )  return hr;

    pPropertyThird = pPropertySecond->pNextSibling;

    if ( !pPropertyThird ) return hr;

    ulStartElem = pPhrase->Rule.ulFirstElement;
    ulNumElems = pPhrase->Rule.ulCountOfElements;

    switch ( PRIMARYLANGID(langid) )
    {
    case LANG_ENGLISH :

            ulXYStartElem = ulStartElem + 1;
            ulXYNumElems  = ulNumElems - 1 ;
            // the second property is for "SelectWordCommand"
            // the third property is for "through"
            idCommand = pPropertySecond->vValue.ulVal;
            pwszThrough = (WCHAR *)pPropertyThird->pszValue;

            break;
    case LANG_JAPANESE :

            ulXYStartElem = ulStartElem;
            ulXYNumElems  = ulNumElems - 2 ;
            // the second property is for "through"
            // the third property is for "SelectWordCommand"
            idCommand = pPropertyThird->vValue.ulVal;
            pwszThrough = (WCHAR *)pPropertySecond->pszValue;

            break;
    case LANG_CHINESE :

            ulXYStartElem = ulStartElem + 1;
            ulXYNumElems  = ulNumElems - 1 ;
            // the second property is for "SelectWordCommand"
            // the third property is for "through"
            idCommand = pPropertySecond->vValue.ulVal;
            pwszThrough = (WCHAR *)pPropertyThird->pszValue;

            break;
    default :
            break;
    }

    switch ( idCommand )
    {
    case Select_ID_SELTHROUGH :
        sw_type = SELECTWORD_SELTHROUGH;
        break;

    case Select_ID_DELTHROUGH :
        sw_type = SELECTWORD_DELTHROUGH;
        break;
    }


    // if we cannot find "through" word, return here.
    // or there is a wrong command id.
    if ( !pwszThrough || (sw_type == SELECTWORD_NONE)) return hr;

    for  (ULONG i= ulXYStartElem; i< ulXYStartElem + ulXYNumElems; i++)
    {
        const WCHAR *pElemText;

        pElemText = pPhrase->pElements[i].pszDisplayText;

        if ( !pElemText )
            break;

        if ( 0 == _wcsicmp(pElemText, pwszThrough) )
        {
            // This element is "Through"
            BYTE  bAttrPrevElem;
            fPassThrough = TRUE;

            ulLenXXX = dstrText.Length( );
            // Remove the trail spaces from the previous element.
            if ( i>1 )
            {
                bAttrPrevElem = pPhrase->pElements[i-1].bDisplayAttributes;
                if ( bAttrPrevElem & SPAF_ONE_TRAILING_SPACE )
                    ulLenXXX -- ;
                else if (bAttrPrevElem & SPAF_TWO_TRAILING_SPACES)
                    ulLenXXX -= 2;

                dstrText.TrimToSize(ulLenXXX);
            }
        }
        else
        {
            // This is element for XXX (if fPassThrough is FALSE ) or YYY ( if fPassThrough is TRUE)
            BYTE bAttr = pPhrase->pElements[i].bDisplayAttributes;

            dstrText.Append(pPhrase->pElements[i].pszDisplayText);

            if ( i < ulNumElems-1 )
            {
                if (bAttr & SPAF_ONE_TRAILING_SPACE)
                    dstrText.Append(L" ");
                else if (bAttr & SPAF_TWO_TRAILING_SPACES)
                    dstrText.Append(L"  ");
            }
        }
    }

    ulLen = dstrText.Length( );

    if ( dstrText && ulLenXXX > 0 && ulLen > 0 )
        hr = m_pime->ProcessSelectWord(dstrText, ulLen, sw_type, ulLenXXX);

    return hr;
}

HRESULT CSpTask::_HandleSelectSimpleCmds(ULONG idCmd)
{
    HRESULT hr = S_OK;

    // handle "SelectSimplCmds" rule.

    SELECTWORD_OPERATION sw_type = SELECTWORD_NONE;

    switch ( idCmd )
    {
    case Select_ID_UNSELECT :
        sw_type = SELECTWORD_UNSELECT;
        break;

    case Select_ID_SELECTPREV :
        sw_type = SELECTWORD_SELECTPREV;
        break;

    case Select_ID_SELECTNEXT :
        sw_type = SELECTWORD_SELECTNEXT;
        break;

    case Select_ID_CORRECTPREV :
        sw_type = SELECTWORD_CORRECTPREV;
        break;

    case Select_ID_CORRECTNEXT :
        sw_type = SELECTWORD_CORRECTNEXT;
        break;

    case Select_ID_SELSENTENCE :
        sw_type = SELECTWORD_SELSENTENCE;
        break;

    case Select_ID_SELPARAGRAPH :
        sw_type = SELECTWORD_SELPARAGRAPH;
        break;

    case Select_ID_SELWORD :
        sw_type = SELECTWORD_SELWORD;
        break;

    case Select_ID_SelectThat :
        sw_type = SELECTWORD_SELTHAT;
        break;

    case Select_ID_SelectAll :

        hr = m_pime->ProcessEditCommands(Select_ID_SelectAll);
        break;

    case Select_ID_DeletePhrase :

        // call a function to remove an entire phrase
        hr = m_pime->EraseLastPhrase();
        break;

    case Select_ID_Convert :

        hr = m_pime->CorrectThat();
        break;

    case Select_ID_Finalize :

        hr = m_pime->FinalizeAllCompositions( );
        break;

    default :
        hr = E_FAIL;
        Assert(0);
        return hr;
    }


    if ( sw_type != SELECTWORD_NONE )
        hr = m_pime->ProcessSelectWord(NULL, 0, sw_type);

    return hr;
}


HRESULT CSpTask::_HandleSelwordCmds(SPPHRASE *pPhrase, LANGID langid, ULONG idCmd)
{
    HRESULT   hr = S_OK;

    Assert(idCmd);

    // handle "Select Word" 
    // Get the real word/phrase which will be selected.
    // the phrase will contain following elements:
    //      
    //    <select|delete|Correct <Word0> <Word1> <word2> ...
    //
    // the first element must be gateway word.
    //
    CSpDynamicString dstrSelected;
    ULONG   ulLen = 0;
    ULONG   ulStartSelText = 0; // Start element for the selected text
    ULONG   ulNumSelText=0;     // Number of elements for the selected text.
    ULONG   ulStartElem, ulNumElems;
    ULONG   ulStartDelta=0, ulNumDelta=0;

    SELECTWORD_OPERATION  sw_type;

    switch (idCmd)
    {
    case Select_ID_SELECT :
        sw_type = SELECTWORD_SELECT;
        break;
    case Select_ID_DELETE :
        sw_type = SELECTWORD_DELETE;
        break;
    case Select_ID_CORRECT :
        sw_type = SELECTWORD_CORRECT;
        break;
    default :
        Assert(0);
        hr = E_FAIL;
        return hr;
    }

    WORD   prilangid;

    prilangid = PRIMARYLANGID(langid);

    if ((prilangid == LANG_ENGLISH) || (prilangid == LANG_CHINESE))
    {
         ulStartDelta = 1;
         ulNumDelta = 1;
    }
    else if (prilangid == LANG_JAPANESE)
    {
         ulStartDelta = 0;
         ulNumDelta = 2;
    }

    // Get the start element and number of elements for the text to select.
    ulStartElem = pPhrase->Rule.ulFirstElement;
    ulNumElems = pPhrase->Rule.ulCountOfElements;

    ulStartSelText = ulStartElem + ulStartDelta;
    if (ulNumElems > ulNumDelta)
        ulNumSelText = ulNumElems - ulNumDelta;
    else 
        ulNumSelText = 0;
                  
     //
     // Get the text for the selection.
     // 
     for (ULONG i = ulStartSelText; i < ulStartSelText + ulNumSelText; i++ )
     {
          if ( pPhrase->pElements[i].pszDisplayText)
          {
               BYTE bAttr = pPhrase->pElements[i].bDisplayAttributes;
               dstrSelected.Append(pPhrase->pElements[i].pszDisplayText);

               if ( i < ulStartSelText + ulNumSelText-1 )
               {
                    if (bAttr & SPAF_ONE_TRAILING_SPACE)
                         dstrSelected.Append(L" ");
                     else if (bAttr & SPAF_TWO_TRAILING_SPACES)
                        dstrSelected.Append(L"  ");
               } 
          }
     }

     if ( dstrSelected )
          ulLen = wcslen(dstrSelected);

     if ( ulLen )
     {
         // check if this is "Select All" or "Select That".
         if ( sw_type == SELECTWORD_SELECT )
         {
             if ( _wcsicmp(dstrSelected, CRStr(IDS_SPCMD_SELECT_ALL) ) == 0 )
             {
                 hr = m_pime->ProcessEditCommands(Select_ID_SelectAll);
                 return hr;
             }

             if ( _wcsicmp(dstrSelected, CRStr(IDS_SPCMD_SELECT_THAT)) == 0 )
                sw_type = SELECTWORD_SELTHAT;
         }

         // redirect "Correct <TEXTBUF:That>" to a simple command "Correct That"
         if ( sw_type == SELECTWORD_CORRECT )
         {
             if ( _wcsicmp(dstrSelected, CRStr(IDS_SPCMD_SELECT_THAT)) == 0 )
             {
                hr = m_pime->CorrectThat();
                return hr;
             }
         }

         hr = m_pime->ProcessSelectWord(dstrSelected, ulLen, sw_type);
     }

     return hr;
}


/*
HRESULT CSpTask::_HandleNumModeGrammar(SPPHRASE *pPhrase, LANGID langid)
{
    HRESULT hr = S_OK;

    const WCHAR c_szNumeric[]       = L"number";
    const WCHAR c_sz1stDigit[]      = L"1st_digit";
    const WCHAR c_sz2ndDigit[]      = L"2nd_digit";
    const WCHAR c_sz3rdDigit[]      = L"3rd_digit";

    if (wcscmp(pPhrase->Rule.pszName, c_szNumeric) == 0)
    {
        // Mode bias support
        if (pPhrase->pProperties)
        {
            CSpDynamicString dstr;
       
           for (const SPPHRASEPROPERTY *pProp=pPhrase->pProperties; pProp != NULL; pProp = pProp->pNextSibling)
           {
               if (wcscmp(pProp->pszName, c_sz3rdDigit) == 0 ||
                   wcscmp(pProp->pszName, c_sz2ndDigit) == 0 ||
                   wcscmp(pProp->pszName, c_sz1stDigit) == 0)
               {
                    dstr.Append(pProp->pszValue);
               }
           }
           hr = m_pime->InjectText(dstr, langid);
       }
   }
                
   return hr;
}

*/
//+---------------------------------------------------------------------------
//
// _HandleToolBarGrammar
//
// Handle toolbar commands when command mode.
//----------------------------------------------------------------------------
HRESULT CSpTask::_HandleToolBarGrammar(SPPHRASE *pPhrase, LANGID langid)
{
    HRESULT hr = S_OK;

    Assert(pPhrase);
                
    if (m_pLangBarSink)
    {
        // get the toolbar cmd rule name to check match
                   
        if (0 == wcscmp(pPhrase->Rule.pszName, m_pLangBarSink->GetToolbarCommandRuleName()))
        {
                        
            // update the balloon
            _ShowCommandOnBalloon(pPhrase);

            // call the handler then
            const SPPHRASEPROPERTY *pProp;

            for (pProp=pPhrase->pProperties; pProp != NULL; pProp = pProp->pNextSibling)
            {
               m_pLangBarSink->ProcessToolbarCmd(pProp->pszName);
            }
            m_pime->SaveLastUsedIPRange( );
            m_pime->SaveIPRange(NULL);
        }
    }

    return hr;
}

//+------------------------------------------------------------------------
//
//  _HandleNumITNGrammar
//
//  Handle the number grammar.
//
//+-------------------------------------------------------------------------
HRESULT CSpTask::_HandleNumITNGrammar(SPPHRASE *pPhrase, LANGID langid)
{
    HRESULT hr = S_OK;

    Assert(pPhrase);
                
    if (S_OK == _EnsureSimpleITN())
    {
        DOUBLE dblVal;
        WCHAR  wszVal[128];
                    
        hr = m_pITNFunc->InterpretNumberSimple(pPhrase->pProperties,
                      &dblVal, wszVal, ARRAYSIZE(wszVal));
        if (S_OK == hr)
        {
            int  iLen = wcslen(wszVal);
            if ( (iLen > 0) && (iLen < 127) && (wszVal[iLen-1] != L' ') )
            {
               // Add one trailing space
               wszVal[iLen] = L' ';
               wszVal[iLen + 1] = L'\0';
            }
                        
            hr = m_pime->InjectText(wszVal, langid);
        }
    }
                   
    return hr;
}

//+---------------------------------------------------------------------------
//
// _HandleSpellGrammar
//
// Handing "Spell It", "Spell That", "Spelling Mode" etc. commands
//----------------------------------------------------------------------------
HRESULT CSpTask::_HandleSpellGrammar(SPPHRASE *pPhrase, LANGID langid)
{
    HRESULT hr = S_OK;

    Assert(pPhrase);

    if (0 == wcscmp(pPhrase->Rule.pszName, c_szSpelling))
    {
        // Handel "Spell It"
        ULONG  ulStartElem, ulNumElems;
        CSpDynamicString dstr;

        ulStartElem = pPhrase->Rule.ulFirstElement;
        ulNumElems = pPhrase->Rule.ulCountOfElements;

        //
        // the first element is for the command itself
        // 
        for (ULONG i = ulStartElem+1; i < ulStartElem + ulNumElems; i++ )
        {
            if ( pPhrase->pElements[i].pszDisplayText)
            {
                dstr.Append(pPhrase->pElements[i].pszDisplayText);
                    
                //
                // only the last element needs the attribute 
                // handling
                //
                if (i == ulStartElem + ulNumElems - 1)
                {
                    BYTE bAttr = pPhrase->pElements[i].bDisplayAttributes;
                    if (bAttr & SPAF_ONE_TRAILING_SPACE)
                    {
                        dstr.Append(L" ");
                    }
                    else if (bAttr & SPAF_TWO_TRAILING_SPACES)
                    {
                        dstr.Append(L"  ");
                    }
                }
            }
        }
                    
        hr = m_pime->ProcessSpellIt(dstr, langid);
    }
    else if (0 == wcscmp(pPhrase->Rule.pszName, c_szSpellMode))
    {
        // Handle "Spell Mode" or "Spell That"

        if (pPhrase->pProperties == NULL
           || pPhrase->pProperties[0].pszValue == NULL)
        {
            // this only happens when we hit the bogus word which
            // was added for weight modification
        }
        else if (0 == wcscmp(pPhrase->pProperties[0].pszValue, c_szSpellingMode))
        {
            // Handel "Spelling Mode"

            _SetSpellingGrammarStatus(TRUE, TRUE);
            m_cpRecoCtxt->Resume(0);

            m_pime->SaveLastUsedIPRange( );
            m_pime->SaveIPRange(NULL);

            _ShowCommandOnBalloon(pPhrase);
        }
        else if (0 == wcscmp(pPhrase->pProperties[0].pszValue, c_szSpellThat))
        {
            // Handle "Spell That"
            hr = m_pime->ProcessSpellThat( );
            _ShowCommandOnBalloon(pPhrase);
        }
    }

    return hr;
}

// 
// Hanlders for some commands in CSapiIMX
// 
// Move them from sapilayr.cpp
//


//+---------------------------------------------------------------------------
//
// CSapiIMX::EraseLastPhrase
//
// synopsis - cleans up the feedback UI
// GUID - specifies which feedback UI bar to erase
//
//---------------------------------------------------------------------------+
HRESULT CSapiIMX::EraseLastPhrase(void)
{
    return _RequestEditSession(ESCB_KILLLASTPHRASE, TF_ES_READWRITE);
}

//+---------------------------------------------------------------------------
//
// CSapiIMX::ProcessEditCommands(void)
//
// Handle command keys like "Undo That", "Cut That", "Copy That", "Paste That".
//
//---------------------------------------------------------------------------+
HRESULT CSapiIMX::ProcessEditCommands(LONG  idSharedCmd)
{
    HRESULT             hr = E_FAIL;

    ESDATA  esData;
    memset(&esData, 0, sizeof(ESDATA));
    esData.lData1 = (LONG_PTR)idSharedCmd;

    hr = _RequestEditSession(ESCB_PROCESS_EDIT_COMMAND, TF_ES_READWRITE, &esData);
    return hr;
}

//+---------------------------------------------------------------------------
//
// _ProcessEditCommands
//
// Edit session functions for edit commands handling
//
//----------------------------------------------------------------------------
HRESULT CSapiIMX::_ProcessEditCommands(TfEditCookie ec, ITfContext *pic, LONG  idSharedCmd)
{
    HRESULT hr = S_OK;

    if ( !pic )
        return E_INVALIDARG;

    CDocStatus ds(pic);
    if (ds.IsReadOnly())
       return S_OK;
/*
    CComPtr<ITfRange> cpInsertionPoint;

    if ( cpInsertionPoint = GetSavedIP() )
    {
        // Determine if the saved IP was on this context.
        // if not we just ignore that

        CComPtr<ITfContext> cpic;
        hr = cpInsertionPoint->GetContext(&cpic);

        if (S_OK != hr || cpic != pic)
        {
            cpInsertionPoint.Release();
        }
    }

    if (!cpInsertionPoint)
    {
        hr = GetSelectionSimple(ec, pic, &cpInsertionPoint);
    }
       
    if (hr == S_OK)
    {
        // finalize the previous input for now
        hr = _FinalizePrevComp(ec, pic, cpInsertionPoint);
    }
*/


    if ( hr == S_OK )
    {
        // Handle the cmd by simulating the corresponding key events.
        BYTE   vkChar = 0;

        switch ( idSharedCmd )
        {
        case Edit_ID_Undo  :
           vkChar = (BYTE)'Z';
           break;

        case Edit_ID_Cut   :
        case Edit_ID_Copy  :
            {
                CComPtr<ITfRange>  cpRange;
                _GetCmdThatRange(ec, pic, &cpRange);
                
                if ( cpRange )
                    SetSelectionSimple(ec, pic, cpRange);
   
                if (idSharedCmd == Edit_ID_Cut)
                    vkChar = (BYTE)'X';
                else
                    vkChar = (BYTE)'C';

                break;
            }

        case Edit_ID_Paste :
           vkChar = (BYTE)'V';
           break;

        case Select_ID_SelectAll :
            vkChar = (BYTE)'A';
            break;
        }

        if ( vkChar ) 
        {

            m_ulSimulatedKey = 2;   // it will simulate two key strokes.
            keybd_event((BYTE)VK_CONTROL, 0, 0, 0);
            keybd_event(vkChar, 0, 0, 0);
            keybd_event(vkChar, 0, KEYEVENTF_KEYUP, 0);
            keybd_event((BYTE)VK_CONTROL, 0, KEYEVENTF_KEYUP, 0);
        }
    }

    SaveLastUsedIPRange( );
    SaveIPRange(NULL);
            
    return hr;
}


//+---------------------------------------------------------------------------
//
// CSapiIMX::ProcessControlKeys(void)
//
// Handle command keys like "Tab" or "Enter".
//
//---------------------------------------------------------------------------+
HRESULT CSapiIMX::ProcessControlKeys(WCHAR *pwszKeys, ULONG ulLen, LANGID langid)
{
    HRESULT             hr = E_FAIL;

    if ( pwszKeys == NULL ||  ulLen == 0 )
        return E_INVALIDARG;

    ESDATA  esData;

    memset(&esData, 0, sizeof(ESDATA));
    esData.pData = (void *)pwszKeys;
    esData.uByte = (ulLen+1) * sizeof(WCHAR);
    esData.lData1 = (LONG_PTR)ulLen;
    esData.lData2 = (LONG_PTR)langid;

    hr = _RequestEditSession(ESCB_PROCESSCONTROLKEY, TF_ES_READWRITE, &esData);
    return hr;
}


//+---------------------------------------------------------------------------
//
// CSapiIMX::ProcessSpellIt(WCHAR *pwszText, LANGID langid)
//
//
//---------------------------------------------------------------------------+
HRESULT CSapiIMX::ProcessSpellIt(WCHAR *pwszText, LANGID langid)
{
    if ( pwszText == NULL )
        return E_INVALIDARG;

    ESDATA  esData;

    memset(&esData, 0, sizeof(ESDATA));
    esData.pData = (void *)pwszText;
    esData.uByte = (wcslen(pwszText)+1) * sizeof(WCHAR);
    esData.lData1 = (LONG_PTR)langid;
    
    return _RequestEditSession(ESCB_PROCESS_SPELL_IT, TF_ES_READWRITE, &esData);
}

//+---------------------------------------------------------------------------
//
// CSapiIMX::_ProcessSpellIt(WCHAR *pwszText, LANGID langid)
//
//  Edit Session function for ESCB_PROCESS_SPELL_IT
//
//---------------------------------------------------------------------------+
HRESULT CSapiIMX::_ProcessSpellIt(TfEditCookie ec, ITfContext *pic, WCHAR *pwszText, LANGID langid)
{
    HRESULT  hr = S_OK;

    hr = _ProcessSpelledText(ec, pic, pwszText, langid);

    SaveLastUsedIPRange( );
    SaveIPRange(NULL);
    return hr;
}


//+---------------------------------------------------------------------------
//
// CSapiIMX::ProcessSpellThat(void)
//
//
//---------------------------------------------------------------------------+
HRESULT CSapiIMX::ProcessSpellThat( )
{
    return _RequestEditSession(ESCB_PROCESS_SPELL_THAT, TF_ES_READWRITE);
}

//+---------------------------------------------------------------------------
//
// CSapiIMX::_ProcessSpellThat(void)
//
//  Edit Session function for ESCB_PROCESS_SPELL_THAT
//
//---------------------------------------------------------------------------+
HRESULT CSapiIMX::_ProcessSpellThat(TfEditCookie ec, ITfContext *pic)
{
    HRESULT  hr = S_OK;

    // Get the previous dictated phrase and mark it as selection.
    CComPtr<ITfRange> cpRange;

    hr = _GetCmdThatRange(ec, pic, &cpRange);
    
    if ( hr == S_OK )
        hr =SetSelectionSimple(ec, pic, cpRange);

    // Then turn on spell mode.

    if ( hr == S_OK && m_pCSpTask )
    {
        hr = m_pCSpTask->_SetSpellingGrammarStatus(TRUE, TRUE);
    }

    SaveLastUsedIPRange( );
    SaveIPRange(NULL);
            
    return hr;
}


//+---------------------------------------------------------------------------
//
// _ProcessControlKeys
//
// Real function to handle the control key commands like Tab or Enter.
// 
// It will finialize the previous composing text ( actually characters in 
// Feedback UI).
// 
// and then simulate the related key events.
//---------------------------------------------------------------------------+
HRESULT CSapiIMX::_ProcessControlKeys(TfEditCookie ec, ITfContext *pic, WCHAR *pwszKey, ULONG ulLen, LANGID langid)
{
    HRESULT hr = S_OK;

    if ( !pic  || !pwszKey || (ulLen == 0) )
        return E_INVALIDARG;

    CDocStatus ds(pic);
    if (ds.IsReadOnly())
       return S_OK;
/*
    CComPtr<ITfRange> cpInsertionPoint;

    if ( cpInsertionPoint = GetSavedIP() )
    {
        // Determine if the saved IP was on this context.
        // if not we just ignore that

        CComPtr<ITfContext> cpic;
        hr = cpInsertionPoint->GetContext(&cpic);

        if (S_OK != hr || cpic != pic)
        {
            cpInsertionPoint.Release();
        }
    }

    if (!cpInsertionPoint)
    {
        hr = GetSelectionSimple(ec, pic, &cpInsertionPoint);
    }
       
    if (hr == S_OK)
    {
        // finalize the previous input for now
        // 
        hr = _FinalizePrevComp(ec, pic, cpInsertionPoint);
*/

        if ( hr == S_OK )
        {
            BOOL  fHandleKeySucceed = TRUE;

            // simulate the keys.
            for (ULONG i=0; i<ulLen; i++)
            {
                if ( !HandleKey( pwszKey[i] ) )
                {
                    fHandleKeySucceed = FALSE;
                    break;
                }
            }
    
            if ( fHandleKeySucceed == FALSE )
            {
                hr = InjectText(pwszKey, langid);
            }
        }

//    }

    SaveLastUsedIPRange( );
    SaveIPRange(NULL);
            
    return hr;
}


//+---------------------------------------------------------------------------
//
// _KillLastPhrase
//
//---------------------------------------------------------------------------+
HRESULT CSapiIMX::_KillLastPhrase(TfEditCookie ec, ITfContext *pic)
{
    HRESULT hr = E_FAIL;

#ifdef _TRY_LATER_FOR_AIMM
    TF_STATUS   tss;
    BOOL        fCiceroNative = TRUE;
    

    hr = pic->GetStatus(&tss);
    if (S_OK == hr)
    {
       //
       // see if the client now is AIMM
       //
       if (tss.dwStaticFlags & TS_SS_TRANSITORY) 
       {
           fCiceroNative = FALSE;
       }
    }
#endif

    CComPtr<ITfRange> cpRange;

    hr = _GetCmdThatRange(ec, pic, &cpRange);

    if ( hr == S_OK && cpRange )
    {
        // found our own input and it is not empty
        _CheckStartComposition(ec, cpRange);
        hr = cpRange->SetText(ec, 0, NULL, 0);

        // trigger redrawing
        SetSelectionSimple(ec, pic, cpRange);
    }

#ifdef _TRY_LATER_FOR_AIMM
    else if (fCiceroNative == FALSE)
    {
         CComPtr<ITfRange> pRStart;
         CComPtr<ITfRange> pREnd;
         BOOL fEmpty;

         hr = pic->GetStart(&pRStart);

         if (S_OK == hr)
             hr = pic->GetEnd(&pREnd);

         if (S_OK == hr)
         {
             hr = pRStart->IsEquealStart(ec, pREnd, TF_ANCHOR_END, &fEmpty);
         }
         if (S_OK == hr && fEmpty)
         {
             // - VK_CONTROL(down) + VK_SHIFT(down) + VK_LEFT(down), then
             // - VK_LEFT(up) + VK_SHIFT(up) + VK_CONTROL(up),       then
             // - VK_DELETE(down) + VK_DELETE(up) 
             //
             keybd_event((BYTE)VK_CONTROL, 0, 0, 0);
             keybd_event((BYTE)VK_SHIFT, 0, 0, 0);
             keybd_event((BYTE)VK_LEFT, 0, 0, 0);

             keybd_event((BYTE)VK_CONTROL, 0, KEYEVENTF_KEYUP, 0);
             keybd_event((BYTE)VK_SHIFT, 0, KEYEVENTF_KEYUP, 0);
             keybd_event((BYTE)VK_LEFT, 0, KEYEVENTF_KEYUP, 0);

             keybd_event((BYTE)VK_DELETE, 0, 0, 0);
             keybd_event((BYTE)VK_DELETE, 0, KEYEVENTF_KEYUP, 0);
         }
    }
#endif //  _TRY_LATER_FOR_AIMM

    //
    // these moved from HandleRecognition  
    // 
    SaveLastUsedIPRange( );
    SaveIPRange(NULL);
    return hr;
} 

//
// CSapiIMX::_GetCmdThatRange
//
// We have many "xxx That" commands, all these commands require to get 
// a right range. this method will supply a united way to get the right range.
//
// As a Rule, 
//
// If there is a selection before "XXX That" is recognized, we just use 
// that range. 
// If there is no selection, we will try to find the previous dictated phrase
// or a word case by case.
//
//
// ppRange will hold the returned Range interface pointer, it is caller's 
// responsibility to release the range object.
//

#define  MAX_WORD_LENGTH  32

HRESULT  CSapiIMX::_GetCmdThatRange(TfEditCookie ec, ITfContext *pic, ITfRange **ppRange)
{
    HRESULT hr = S_OK;

    Assert(pic);
    Assert(ppRange);

    CComPtr<ITfRange> cpIP;
    CComPtr<ITfRange> cpRange;
    BOOL              fEmpty = TRUE;
    BOOL              fGotRange = FALSE;

    TraceMsg(TF_GENERAL, "GetCmdThatRange is called");

    *ppRange = NULL;

    // Get the current IP.
    hr = GetSelectionSimple(ec, pic, &cpIP);

    // is ip empty or selection
    if ( hr == S_OK )
        hr = cpIP->IsEmpty(ec, &fEmpty);

    if ( hr == S_OK )
    {
        if ( !fEmpty )
        {
            // current ip is a selection, just use it.
            hr = cpIP->Clone(&cpRange);

            if ( hr == S_OK )
                fGotRange = TRUE;
        }
        else
        {
            WORD   prilangid;

            prilangid = PRIMARYLANGID(m_langid);

            if ((prilangid == LANG_CHINESE) || (prilangid == LANG_JAPANESE) || !_GetIPChangeStatus( ))
            {
                // If the lang is East Asian, we always try to get the previous dictated phrase first.
                // if lang is English, and there is no ip change since last dictated phrase,
                // we will try to get the previous dictated phrase first.
                fGotRange = _FindPrevComp(ec, pic, cpIP, &cpRange, GUID_ATTR_SAPI_INPUT);

                if ( !fGotRange )
                {
                    // With Office Auto-Correction, the static GUID_PROP_SAPI_DISPATTR property 
                    // on the auto-corrected range could be destroyed.
                    // In this case, we may want to rely on our custom property GUID_PROP_SAPIRESULTOBJECT
                    // to find the real previous dictated phrase.
                    CComPtr<ITfRange>		cpRangeTmp;
                    CComPtr<ITfProperty>	cpProp;
                    LONG					l;

                    hr = cpIP->Clone(&cpRangeTmp);
                    // shift to the previous position
                    if ( hr == S_OK )
                        hr = cpRangeTmp->ShiftStart(ec, -1, &l, NULL);
                    
                    if ( hr == S_OK )
                        hr = pic->GetProperty(GUID_PROP_SAPIRESULTOBJECT, &cpProp);

                    if ( hr == S_OK)
                        hr = cpProp->FindRange(ec, cpRangeTmp, &cpRange, TF_ANCHOR_START);

                    if (hr == S_OK && cpRange)
                        hr = cpRange->IsEmpty(ec, &fEmpty);

                    fGotRange = !fEmpty;
                }
            }
        }
    }

    if ( hr == S_OK && !fGotRange )
    {
        // IP must be empty
        // There is no previous dictated phrase, or IP is moved since last dictation.
        // we try to get the word around the ip.
        long               cch=0;
        ULONG              ulch =0;
        CComPtr<ITfRange>  cpRangeTmp;
        WCHAR              pwszTextBuf[MAX_WORD_LENGTH+1];
        ULONG              ulLeft=0, ulRight=0; 

        // Find the first delimiter character in left side from the current IP.
        hr = cpIP->Clone(&cpRangeTmp);
        if ( hr == S_OK )
            hr = cpRangeTmp->ShiftStart(ec, MAX_WORD_LENGTH * (-1), &cch, NULL);

        if ( hr == S_OK && cch < 0 )
            hr = cpRangeTmp->GetText(ec, 0, pwszTextBuf, MAX_WORD_LENGTH, &ulch);

        if ( hr == S_OK && ulch > 0 )
        {
            pwszTextBuf[ulch] = L'\0';

            for ( long i=(long)ulch-1; i>=0; i-- )
            {
                WCHAR  wch;
                wch = pwszTextBuf[i];

                if ( iswpunct(wch) || iswspace(wch) )
                    break;

                ulLeft++;
            }
        }

        // Find the first delimiter character in right side from the right 

        if ( hr == S_OK && cpRangeTmp )
        {
            cpRangeTmp.Release( );
            hr = cpIP->Clone(&cpRangeTmp);
        }

        if ( hr == S_OK )
            hr = cpRangeTmp->ShiftEnd(ec, MAX_WORD_LENGTH, &cch, NULL);

        if ( hr == S_OK && cch > 0 )
            hr = cpRangeTmp->GetText(ec, 0, pwszTextBuf, MAX_WORD_LENGTH, &ulch);

        if ( hr == S_OK && ulch > 0 )
        {
            pwszTextBuf[ulch] = L'\0';

            for ( long i=0; i<(long)ulch; i++ )
            {
                WCHAR  wch;
                wch = pwszTextBuf[i];

                if ( iswpunct(wch) || iswspace(wch) )
                    break;

                ulRight++;
            }
        }

        if ( hr == S_OK )
            hr = cpRangeTmp->Collapse(ec, TF_ANCHOR_START);

        // Move end anchor right number
        if (hr == S_OK && ulRight > 0 )
            hr = cpRangeTmp->ShiftEnd(ec, ulRight, &cch, NULL);

        // Move start anchor left number.
        if ( hr == S_OK && ulLeft > 0 )
            hr = cpRangeTmp->ShiftStart(ec, (long)ulLeft * (-1), &cch, NULL);

        if ( hr == S_OK )
        {
            hr = cpRangeTmp->Clone(&cpRange);
            fGotRange = TRUE;
        }
    }

    if ( hr == S_OK && fGotRange && cpRange )
    {
        *ppRange = cpRange;
        (*ppRange)->AddRef( );

        TraceMsg(TF_GENERAL, "Got the xxx That range!");
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\cutil.cpp ===
// cutil.cpp
//
// file to put misc utility classes implementation
//
#include "private.h"
#include "sapilayr.h"
#include "sphelper.h"
#include "xstring.h"
#include "cregkey.h"
#include "ctflbui.h"
#include "nui.h"


const GUID c_guidProfileBogus = { /* 09ea4e4b-46ce-4469-b450-0de76a435bbb */
    0x09ea4e4b,
    0x46ce,
    0x4469,
    {0xb4, 0x50, 0x0d, 0xe7, 0x6a, 0x43, 0x5b, 0xbb}
  };


/* a5239e24-2bcf-4915-9c5c-fd50c0f69db2 */
const CLSID CLSID_MSLBUI = { 
    0xa5239e24,
    0x2bcf,
    0x4915,
    {0x9c, 0x5c, 0xfd, 0x50, 0xc0, 0xf6, 0x9d, 0xb2}
  };

// const GUID c_guidProfile0 = { /* 55122b58-15bb-11d4-bd48-00105a2799b5 */
//    0x55122b58,
//    0x15bb,
//    0x11d4,
//    {0xbd, 0x48, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
//  };
// const GUID c_guidProfile1 = { /* 55122b59-15bb-11d4-bd48-00105a2799b5 */
//    0x55122b59,
//    0x15bb,
//    0x11d4,
//    {0xbd, 0x48, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
//  };
// const GUID c_guidProfile2 = { /* 55122b5a-15bb-11d4-bd48-00105a2799b5 */
//    0x55122b5a,
//    0x15bb,
//    0x11d4,
//    {0xbd, 0x48, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
//  };

#ifndef USE_SAPI_FOR_LANGDETECTION
static const char c_szSpeechRecognizersKey[] = "Software\\Microsoft\\Speech\\Recognizers";
static const char c_szSpeechRecognizersTokensKey[] = "Software\\Microsoft\\Speech\\Recognizers\\Tokens";
static const char c_szDefault[] =    "DefaultTokenId";

static const char c_szAttribute[]  = "Attributes";
static const char c_szLanguage[]   = "Language";

static const char c_szUseSAPIForLang[] = "UseSAPIForLang";
#endif

static const char c_szProfileRemoved[] = "ProfileRemoved";
static const char c_szProfileInitialized[] = "ProfileInitialized";

_inline BOOL _IsCompatibleLangid(LANGID langidReq, LANGID langidCmp)
{
    if (PRIMARYLANGID(langidReq) == LANG_CHINESE)
    {
        return langidReq == langidCmp;
    }
    else
    {
        return PRIMARYLANGID(langidReq) == PRIMARYLANGID(langidCmp);
    }
}

void _RegisterOrUnRegisterMslbui(BOOL fRegister)
{
    // we just assume the dll is copied to system32
    TCHAR szMslbui[MAX_PATH];
    int cch = GetSystemDirectory(szMslbui, ARRAYSIZE(szMslbui));

    if (!cch)
    {
        return;
    }

    // GetSystemDirectory appends no '\' unless the system
    // directory is the root, such like "c:\"
    if (cch != 3)
    {
        StringCchCat(szMslbui, ARRAYSIZE(szMslbui), TEXT("\\"));
    }
    StringCchCat(szMslbui, ARRAYSIZE(szMslbui), TEXT("mslbui.dll"));

    if (fRegister)
    {
        // load mslbui.dll and register it 
        TF_RegisterLangBarAddIn(CLSID_MSLBUI, AtoW(szMslbui), TF_RLBAI_CURRENTUSER | TF_RLBAI_ENABLE);

    }
    else
    {
        TF_UnregisterLangBarAddIn(CLSID_MSLBUI, TF_RLBAI_CURRENTUSER);
    }
}

//+---------------------------------------------------------------------------
//
// dtor
//
//
//---------------------------------------------------------------------------+
CLangProfileUtil::~CLangProfileUtil()
{
    if (m_langidRecognizers.Count() > 0)
        m_langidRecognizers.Clear();
}

//+---------------------------------------------------------------------------
//
// _RegisterProfiles
//
// synopsis: a rough equivalent of RegisterTIP lib function, only different in
//           trying to cache the profile manager & the category manager
//
//---------------------------------------------------------------------------+
HRESULT CLangProfileUtil::_RegisterAProfile(HINSTANCE hInst, REFCLSID rclsid, const REGTIPLANGPROFILE *plp)
{
    Assert(plp);

    HRESULT hr = S_OK;
    // ensure profile manager
    if (!m_cpProfileMgr)
    {
        hr = TF_CreateInputProcessorProfiles(&m_cpProfileMgr);
    }
    
    // register the clsid
    if (S_OK == hr)
    {
        hr = m_cpProfileMgr->Register(rclsid);
    }
    
    if (S_OK == hr)
    {
        WCHAR wszFilePath[MAX_PATH];
        WCHAR *pv = &wszFilePath[0];

        wszFilePath[0] = L'\0';

        if (wcslen(plp->szIconFile))
        {
            char szFilePath[MAX_PATH];
            WCHAR *pvCur;

            ::GetModuleFileName(hInst, szFilePath, ARRAYSIZE(szFilePath));
            StringCchCopyW(wszFilePath, ARRAYSIZE(wszFilePath), AtoW(szFilePath));

            pv = pvCur = &wszFilePath[0];
            while (*pvCur)
            { 
                if (*pvCur == L'\\')
                    pv = pvCur + 1;
                pvCur++;
            }
            *pv = L'\0';
        }
        StringCchCatW(wszFilePath, ARRAYSIZE(wszFilePath), plp->szIconFile);
        
        hr = m_cpProfileMgr->AddLanguageProfile(rclsid,  
                             plp->langid,  *plp->pguidProfile,  plp->szProfile, 
                             wcslen(plp->szProfile), wszFilePath, wcslen(wszFilePath),
                             plp->uIconIndex);
    }
    
    return hr;
}

//+---------------------------------------------------------------------------
//
// RegisterActiveProfiles(void)
//
// synopsis
//
//
//
//---------------------------------------------------------------------------+
HRESULT CLangProfileUtil::RegisterActiveProfiles(void)
{
    if (_fUserRemovedProfile())
    {
        // remove mslbui when not one speech profile is enabled
        if (!_IsAnyProfileEnabled())
            _RegisterOrUnRegisterMslbui(FALSE);

        return S_FALSE;
    }

    _SetUserInitializedProfile();

    BOOL fEnabled;
    HRESULT hr = _EnsureProfiles(TRUE, &fEnabled);

    // if the speech TIP profile is correctly registered,
    // then we're OK to register the persist UI (mslbui.dll)
    //
    if (S_OK == hr && fEnabled)
        _RegisterOrUnRegisterMslbui(TRUE);
    
    return hr;
}

//+---------------------------------------------------------------------------
//
// IsProfileAvailableForLang(LANGID langid, BOOL *pfAvailable)
//
// synopsis
//
//
//
//---------------------------------------------------------------------------+
HRESULT CLangProfileUtil::IsProfileAvailableForLang(LANGID langid, BOOL *pfAvailable)
{
    if (pfAvailable)
    {
        *pfAvailable = _IsDictationEnabledForLang(langid);
        return S_OK;
    }
    else
        return E_INVALIDARG;
}

//+---------------------------------------------------------------------------
//
//  GetDisplayName(BSTR *pbstrName)
//
//  synopsis
//
//
//---------------------------------------------------------------------------+
HRESULT CLangProfileUtil::GetDisplayName(BSTR *pbstrName)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrName)
    {
        *pbstrName = SysAllocString(L"Register Active profiles for SPTIP");
        if (!*pbstrName)
            hr = E_OUTOFMEMORY;
        else
            hr = S_OK;
    }
    return hr;
}

HRESULT CLangProfileUtil::_EnsureProfiles(BOOL fRegister, BOOL *pfEnabled)
{
    HRESULT hr = S_OK;
    
    if (pfEnabled)
        *pfEnabled = FALSE;

    if (fRegister)
    {
        m_langidRecognizers.Clear();
    }

    if (!m_cpProfileMgr || fRegister)
    {
        if (!m_cpProfileMgr)
        {
            hr = TF_CreateInputProcessorProfiles(&m_cpProfileMgr);
        }
        if (fRegister)
        {
            // if this is a first time initialization, 
            // obtain the list of all languages
            //
            if (S_OK == hr)
            {
                LANGID *pLangIds;
                ULONG  ulCount;
                // plangid will be assigned cotaskmemalloc'd memory
                //
                hr =  m_cpProfileMgr->GetLanguageList(&pLangIds, &ulCount);
                if (S_OK == hr)
                {
                    for (UINT i = 0; i < ulCount; i++)
                    {
                        // here we register profiles
                        // if SR engines are available
                        //
                        BOOL fEnable = FALSE;
                        if (_IsDictationEnabledForLang(pLangIds[i]))
                        {
                            fEnable = TRUE;

                            if (pfEnabled)
                                *pfEnabled = TRUE;
                        } 
                            
                        hr = m_cpProfileMgr->EnableLanguageProfile(
                                                          CLSID_SapiLayr,
                                                          pLangIds[i],
                                                          c_guidProfileBogus,
                                                          fEnable);
                    } // for
                    
                    CoTaskMemFree(pLangIds);
                }
            }
        } // fRegister
    }
    return hr;
}

BOOL CLangProfileUtil::_IsAnyProfileEnabled()
{
    HRESULT hr = S_OK;

    if (!m_cpProfileMgr)
    {
        hr = TF_CreateInputProcessorProfiles(&m_cpProfileMgr);
    }

    LANGID *pLangIds;
    ULONG  ulCount;
    BOOL fEnable = FALSE;

    if (S_OK == hr)
    {
        //
        // plangid will be assigned cotaskmemalloc'd memory
        //
        hr =  m_cpProfileMgr->GetLanguageList(&pLangIds, &ulCount);
    }

    if (S_OK == hr)
    {
        for (UINT i = 0; i < ulCount; i++)
        {
            hr = m_cpProfileMgr->IsEnabledLanguageProfile(CLSID_SapiLayr,
                                                          pLangIds[i],
                                                          c_guidProfileBogus,
                                                          &fEnable);

            if (S_OK == hr && fEnable)
                break;
        }

        CoTaskMemFree(pLangIds);
    }

    return fEnable;
}


//+---------------------------------------------------------------------------
//
//  _GetProfileLangID
//
// synopsis: handle language profiles
//
//---------------------------------------------------------------------------+
HRESULT CLangProfileUtil::_GetProfileLangID(LANGID *plangid)
{
    HRESULT hr = S_OK;
    
    Assert(plangid);

    hr = _EnsureProfiles(FALSE);

    if (hr == S_OK)
    {
        hr = m_cpProfileMgr->GetCurrentLanguage(plangid);
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  _DictationEnabled
//
//  synopsis: 
//
//---------------------------------------------------------------------------+
BOOL CLangProfileUtil::_DictationEnabled(LANGID *plangidRequested)
{
    BOOL fret = FALSE;
    LANGID langidReq = (LANGID)-1;

    HRESULT hr = _GetProfileLangID(&langidReq);
    if (S_OK == hr)
    {
        if (plangidRequested)
            *plangidRequested = langidReq;

        fret = _IsDictationActiveForLang(langidReq);
    }

    return fret;
}

//
// _IsDictationActiveForLang
//
// synopsis: see if the default SR engine is capable for
//           the specified language
//
BOOL CLangProfileUtil::_IsDictationActiveForLang(LANGID langidReq)
{
    return _IsDictationEnabledForLang(langidReq, TRUE);
}

BOOL CLangProfileUtil::_IsDictationEnabledForLang(LANGID langidReq, BOOL fUseDefault)
{
    //
    // try reg first and if it's not compatible try SAPI
    // 
    BOOL fEnabled = FALSE;
    if (_fUseSAPIForLanguageDetection() == FALSE
       && ERROR_SUCCESS == 
        _IsDictationEnabledForLangInReg(langidReq, fUseDefault, &fEnabled))
    {
        return fEnabled;
    }
    return _IsDictationEnabledForLangSAPI(langidReq, fUseDefault);
}

BOOL CLangProfileUtil::_IsDictationEnabledForLangSAPI(LANGID langidReq, BOOL fUseDefault)
{
    BOOL   fEnabled = FALSE;

    WCHAR * pszDefaultTokenId = NULL;

    HRESULT   hr = S_OK;

    if (fUseDefault)
    {
        if (langidReq == m_langidDefault)
            return TRUE;

        SpGetDefaultTokenIdFromCategoryId(SPCAT_RECOGNIZERS, &pszDefaultTokenId);
    }
    CComPtr<IEnumSpObjectTokens> cpEnum;

    if (S_OK == hr)
    {
        char  szLang[MAX_PATH];
        WCHAR wsz[MAX_PATH];

        StringCchPrintfA(szLang, ARRAYSIZE(szLang), "Language=%x", langidReq);
        MultiByteToWideChar(CP_ACP, NULL, szLang, -1, wsz, ARRAYSIZE(wsz));
        hr = SpEnumTokens(SPCAT_RECOGNIZERS, wsz, NULL, &cpEnum);
    }

    while (!fEnabled && S_OK == hr)
    {
        CComPtr<ISpObjectToken> cpToken;
        WCHAR * pszTokenId = NULL;

        hr = cpEnum->Next(1, &cpToken, NULL);

        if (S_OK == hr)
        {
            hr = cpToken->GetId(&pszTokenId);
        }

        if (S_OK == hr)
        {
            Assert(!fUseDefault || pszDefaultTokenId);

            if (!fUseDefault || wcscmp(pszDefaultTokenId, pszTokenId) == 0)
                fEnabled = TRUE;
        }

        if (pszTokenId)
        {
            CoTaskMemFree(pszTokenId);
        }
    }

    if (pszDefaultTokenId)
    {
        CoTaskMemFree(pszDefaultTokenId);
    }

    if (fUseDefault && fEnabled)
    {
        m_langidDefault = langidReq;
    }

    return fEnabled;
}

const TCHAR c_szDefaultDefaultToken[] = TEXT("HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\Recognizers\\Tokens\\MSASREnglish");

const TCHAR c_szDefaultDefaultTokenJpn[] = TEXT("HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\Recognizers\\Tokens\\MSASRJapanese");

const TCHAR c_szDefaultDefaultTokenChs[] = TEXT("HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\Recognizers\\Tokens\\MSASRChinese");


LONG CLangProfileUtil::_IsDictationEnabledForLangInReg(LANGID langidReq, BOOL fUseDefault, BOOL *pfEnabled)
{
    LONG lret = ERROR_SUCCESS;
    // 
    // fUseDefault == TRUE, just see if the current default recognizer
    // matches with the requested langid
    //
    if (fUseDefault)
    { 
        if( m_langidDefault == 0xFFFF)
        {
            char szRegkeyDefaultToken[MAX_PATH];
            CMyRegKey regkey;

            lret = regkey.Open(HKEY_CURRENT_USER, 
                               c_szSpeechRecognizersKey, 
                               KEY_READ);

            if (ERROR_SUCCESS == lret)
            {
                // first obtain the regkey to look at for default token
                lret = regkey.QueryValueCch(szRegkeyDefaultToken, c_szDefault, ARRAYSIZE(szRegkeyDefaultToken));
                regkey.Close();
            }
            else
            {
                if (PRIMARYLANGID(langidReq) == LANG_JAPANESE)
                {
                    StringCchCopy(szRegkeyDefaultToken, ARRAYSIZE(szRegkeyDefaultToken), c_szDefaultDefaultTokenJpn);
                }
                else if (langidReq == 0x804) // CHS
                {
                    StringCchCopy(szRegkeyDefaultToken, ARRAYSIZE(szRegkeyDefaultToken), c_szDefaultDefaultTokenChs);
                }
                else 
                {
                    StringCchCopy(szRegkeyDefaultToken, ARRAYSIZE(szRegkeyDefaultToken), c_szDefaultDefaultToken);
                }
                lret = ERROR_SUCCESS;
            }


            // then get the attribute / language
            if (ERROR_SUCCESS == lret)
            {
                char *psz = szRegkeyDefaultToken;

                //
                // eliminate "KKEY_LOCAL_MACHINE"
                //
                while(*psz && *psz != '\\')
                    psz++;

                if (*psz == '\\')
                {
                    psz++;
           
                    //
                    // open speech/recognizers/tokens key
                    //
                    lret = regkey.Open(HKEY_LOCAL_MACHINE, psz, KEY_READ);
                }
                else
                    m_langidDefault = 0x0000;
            }
        
            if (ERROR_SUCCESS == lret)
            {
                m_langidDefault = _GetLangIdFromRecognizerToken(regkey.m_hKey);
            }
        }
        *pfEnabled = _IsCompatibleLangid(langidReq, m_langidDefault);
        return lret;
    }

    //
    // this is fUseDefault == FALSE case. We want to see
    // if any installed recognizer can satisfy the langid requested.
    //
    if (m_langidRecognizers.Count() == 0)
    {
        CMyRegKey regkey;
        char      szRecognizerName[MAX_PATH];
        lret =  regkey.Open(HKEY_LOCAL_MACHINE, 
                                      c_szSpeechRecognizersTokensKey, 
                                      KEY_READ);

        if(ERROR_SUCCESS == lret)
        {
            CMyRegKey regkeyReco;
            DWORD dwIndex = 0;

            while (ERROR_SUCCESS == 
                   regkey.EnumKey(dwIndex, szRecognizerName, ARRAYSIZE(szRecognizerName)))
            {
                lret = regkeyReco.Open(regkey.m_hKey, szRecognizerName, KEY_READ);
                if (ERROR_SUCCESS == lret)
                { 
                    LANGID langid=_GetLangIdFromRecognizerToken(regkeyReco.m_hKey);
                    if (langid)
                    {
                        LANGID *pl = m_langidRecognizers.Append(1);
                        if (pl)
                            *pl = langid;
                    }
                    regkeyReco.Close();
                }
                dwIndex++;
            }
        }
    }

    BOOL fEnabled = FALSE;

    for (int i = 0 ; i < m_langidRecognizers.Count(); i++)
    {
        LANGID *p= m_langidRecognizers.GetPtr(i);

        if (p)
        {
            if (_IsCompatibleLangid(langidReq, *p))
            {
                fEnabled = TRUE;
                break;
            }
        }
    }
    *pfEnabled = fEnabled;

    return lret;
}

LANGID CLangProfileUtil::_GetLangIdFromRecognizerToken(HKEY hkeyToken)
{
    LANGID      langid = 0;
    char  szLang[MAX_PATH];
    CMyRegKey regkeyAttr;

    LONG lret = regkeyAttr.Open(hkeyToken, c_szAttribute, KEY_READ);
    if (ERROR_SUCCESS == lret)
    {
        lret = regkeyAttr.QueryValueCch(szLang, c_szLanguage, ARRAYSIZE(szLang));
    }
    if (ERROR_SUCCESS == lret)
    {   
        char *psz = szLang;
        while(*psz && *psz != ';')
        {
            langid = langid << 4;

            if (*psz >= 'a' && *psz <= 'f')
            {
                *psz -= ('a' - 'A');
            }

            if (*psz >= 'A' && *psz <= 'F')
            {
                langid += *psz - 'A' + 10;
            }
            else if (*psz >= '0' && *psz <= '9') 
            {
                langid += *psz - '0';
            }
            psz++;
        }
    }
    return langid;
}

BOOL  CLangProfileUtil::_fUseSAPIForLanguageDetection(void)
{
    if (m_uiUseSAPIForLangDetection == 0)
    {
        CMyRegKey regkey;
        if (ERROR_SUCCESS == regkey.Open(HKEY_LOCAL_MACHINE, c_szSapilayrKey, KEY_READ))
        {
            DWORD dw;
            if (ERROR_SUCCESS==regkey.QueryValue(dw, c_szUseSAPIForLang))
            {
                m_uiUseSAPIForLangDetection = dw;
            }
        }

        if (m_uiUseSAPIForLangDetection == 0)
        {
            m_uiUseSAPIForLangDetection = 1;
        }
    }
    return m_uiUseSAPIForLangDetection == 2 ? TRUE : FALSE;
}


BOOL CLangProfileUtil::_fUserRemovedProfile(void)
{
    BOOL bret = FALSE;

    CMyRegKey regkey;

    if (ERROR_SUCCESS == regkey.Open(HKEY_CURRENT_USER, c_szSapilayrKey, KEY_READ))
    {
        DWORD dw;
        if (ERROR_SUCCESS==regkey.QueryValue(dw, c_szProfileRemoved))
        {
            bret = dw > 0 ? TRUE : FALSE;
        }
    }
    return bret;
}

BOOL CLangProfileUtil::_fUserInitializedProfile(void)
{
    BOOL bret = FALSE;

    CMyRegKey regkey;

    if (ERROR_SUCCESS == regkey.Open(HKEY_CURRENT_USER, c_szSapilayrKey, KEY_READ))
    {
        DWORD dw;
        if (ERROR_SUCCESS==regkey.QueryValue(dw, c_szProfileInitialized))
        {
            bret = dw > 0 ? TRUE : FALSE;
        }
    }
    return bret;
}

BOOL CLangProfileUtil::_SetUserInitializedProfile(void)
{
    CMyRegKey regkey;

    if (ERROR_SUCCESS == regkey.Create(HKEY_CURRENT_USER, c_szSapilayrKey))
    {
        DWORD dw = 0x0001;
        if (ERROR_SUCCESS==regkey.SetValue(dw, c_szProfileInitialized))
        {
            return TRUE;
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\debug.c ===
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "private.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI     "cicero.ini"
#define SZ_DEBUGSECTION "SPTIP"
#define SZ_MODULE       "SPTIP"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\cutil.h ===
// cutil.h
//
// file to put misc utility classes implementation
//
#ifndef CUTIL_H
#define CUTIL_H

#include "private.h"
#include "regimx.h"

class CDocStatus
{
public:
    CDocStatus(ITfContext *pic)
    {
        cpic = pic;
    }
    
    BOOL IsReadOnly()
    {
        TF_STATUS ts;
        HRESULT hr = cpic->GetStatus(&ts);
        if (S_OK == hr)
        {
            if (TF_SD_READONLY & ts.dwDynamicFlags)
                return TRUE;
        }
        return FALSE;
    }

private:
    CComPtr<ITfContext> cpic;
};

class __declspec(novtable)  CLangProfileUtil : public ITfFnLangProfileUtil
{
public:
    CLangProfileUtil() 
    {
         m_fProfileInit = FALSE; 
         m_langidDefault = 0xFFFF;
         m_uiUseSAPIForLangDetection = 0;
    }

    virtual ~CLangProfileUtil();

    // ITfFnLangProfileUtil method
    STDMETHODIMP RegisterActiveProfiles(void);
    STDMETHODIMP IsProfileAvailableForLang(LANGID langid, BOOL *pfAvailable);

    // ITfFunction method
    STDMETHODIMP GetDisplayName(BSTR *pbstrName);

    // private APIs
    HRESULT _EnsureProfiles(BOOL fRegister, BOOL *pfEnabled = NULL);
    HRESULT _RegisterAProfile(HINSTANCE hInst, REFCLSID rclsid, const REGTIPLANGPROFILE *plp);
    HRESULT _GetProfileLangID(LANGID *plangid);
    static const REGTIPLANGPROFILE *_GetSPTIPProfileForLang(LANGID langid);
    virtual BOOL    _DictationEnabled(LANGID *plangidRequested = NULL);
    BOOL    _IsDictationActiveForLang(LANGID langidReq);
    BOOL    _IsDictationEnabledForLang(LANGID langidReq, BOOL fUseDefault = FALSE);
    BOOL    _IsDictationEnabledForLangSAPI(LANGID langidReq, BOOL fUseDefault);
    LONG    _IsDictationEnabledForLangInReg(LANGID langidReq, BOOL fUseDefault, BOOL *pfEnabled);

    BOOL    _IsAnyProfileEnabled();
    BOOL    _fUseSAPIForLanguageDetection(void);
    BOOL    _fUserRemovedProfile(void);
    BOOL    _fUserInitializedProfile(void);
    BOOL    _SetUserInitializedProfile(void);

    void    _ResetDefaultLang() {m_langidDefault = 0xFFFF; }
    LANGID _GetLangIdFromRecognizerToken(HKEY hkeyToken);

    CComPtr<ITfInputProcessorProfiles>     m_cpProfileMgr;

    typedef struct {
        DWORD langid;
        DWORD dwStat;
        DWORD lidOverRidden;
    } LANGPROFILESTAT ;

    BOOL    m_fProfileInit;
    LANGID  m_langidDefault;
    UINT    m_uiUseSAPIForLangDetection;
    
    //
    // this is an array of installed recognizers in their langid
    //
    CStructArray<LANGID>             m_langidRecognizers;
};


typedef enum
{
    DA_COLOR_AWARE,
    DA_COLOR_UNAWARE
} ColorType;

class __declspec(novtable)  CColorUtil
{

public:


    CColorUtil() {m_cBitsPixelScreen = 0; m_fHighContrast =0;}
    COLORREF col( int r1, COLORREF col1, int r2, COLORREF col2 )
    {
        int sum = r1 + r2;

        Assert( sum == 10 || sum == 100 || sum == 1000 );
        int r = (r1 * GetRValue(col1) + r2 * GetRValue(col2) + sum/2) / sum;
        int g = (r1 * GetGValue(col1) + r2 * GetGValue(col2) + sum/2) / sum;
        int b = (r1 * GetBValue(col1) + r2 * GetBValue(col2) + sum/2) / sum;
        return RGB( r, g, b );

    }
    COLORREF GetNewLookColor(ColorType ct = DA_COLOR_AWARE)
    {
        InitColorInfo();

        COLORREF cr;
        if (m_cBitsPixelScreen < 8 || m_fHighContrast == TRUE)
        {
            cr = GetSysColor( COLOR_HIGHLIGHT );
        }
        else if (ct == DA_COLOR_AWARE)
        {
            cr = col( 50, GetSysColor( COLOR_HIGHLIGHT ), 
                      50, GetSysColor( COLOR_WINDOW ) );
        }
        else 
        {
            cr = col( 80, GetSysColor( COLOR_INFOBK ), 
                      20, GetSysColor(COLOR_3DSHADOW) );
        }
        return cr;
    }

    void InitColorInfo(void)
    {
        // do nothing if it's initialized already
        if (m_cBitsPixelScreen) return;

        HIGHCONTRAST hicntr = {0};
        HDC hDC = CreateDC("DISPLAY", NULL, NULL, NULL);
    
        // device caps
        m_cBitsPixelScreen = GetDeviceCaps( hDC, BITSPIXEL );
    
        // system paramater info
        hicntr.cbSize = sizeof(HIGHCONTRAST);
        SystemParametersInfo( SPI_GETHIGHCONTRAST, sizeof(HIGHCONTRAST), &hicntr, 0 );
    
        m_fHighContrast = ((hicntr.dwFlags & HCF_HIGHCONTRASTON) != 0);
    
    
        DeleteDC( hDC );
    }

    COLORREF GetTextColor()
    {
        return m_fHighContrast ? GetSysColor(COLOR_HIGHLIGHTTEXT) : GetSysColor(COLOR_WINDOWTEXT);
    }

private:
    int  m_cBitsPixelScreen;
    BOOL m_fHighContrast;
};

extern const GUID c_guidProfileBogus;

extern const GUID c_guidProfile0 ;
extern const GUID c_guidProfile1 ;
extern const GUID c_guidProfile2 ;

extern const REGTIPLANGPROFILE c_rgProfiles[];

#endif // CUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\correct.cpp ===
//
//
// Sapilayr TIP CCorrectionHandler implementation.
//
// Implement correction related dictation commands.
// such as 
//       Correct That
//       Recovert
//       Correction
//
//       Correct <Phrase>
//  
// Move the correction related functions to this separate class
//
//
#include "private.h"
#include "sapilayr.h"
#include "correct.h"


// -------------------------------------------------------
//
//  Implementation for CCorrectionHandler
//
// -------------------------------------------------------

CCorrectionHandler::CCorrectionHandler(CSapiIMX *psi) 
{
    m_psi = psi;
    fRestoreIP = FALSE;
}

CCorrectionHandler::~CCorrectionHandler( ) 
{

};


//
// Save the IP right before the candidate UI is opened.
//
// This IP would be restored if the candidate UI is cancelled.
// Or after the alternate text is injected when correct command requires 
// to restore this ip.
//
// Client can call _SetRestoreIPFlag( ) to indicate if it wants to restore
// the IP after a new alternate text is injected.
//
// Currently "Correct <Phrase>" command wants to restore the IP, but other
// commands "Correct That, Correction, Reconvert" don't want to restore IP.
//
// Everytime the candidate UI is closed, this IP needs to be released to avoid
// any possible memory leak.
//
HRESULT CCorrectionHandler::_SaveCorrectOrgIP(TfEditCookie ec, ITfContext *pic)
{
    CComPtr<ITfRange>   cpSel;

    HRESULT hr = GetSelectionSimple(ec, pic, (ITfRange **)&cpSel);

    if (SUCCEEDED(hr))
    {
        m_cpOrgIP.Release( );
        hr = cpSel->Clone(&m_cpOrgIP);
    }

    return hr;
}

void CCorrectionHandler::_ReleaseCorrectOrgIP( )
{
    if ( m_cpOrgIP )
    {
        // clear m_cpOrgIP so that it would not affect consequent candidate behavior
        // 
        m_cpOrgIP.Release( );
    }

    fRestoreIP = FALSE;
}

// 
// edit session callback function for RESTORE_CORRECT_ORGIP.
//
HRESULT CCorrectionHandler::_RestoreCorrectOrgIP(TfEditCookie ec, ITfContext *pic)
{
    HRESULT hr = S_OK;

    // we just want to restore the original saved IP.
    if ( m_cpOrgIP )
    {
        hr = SetSelectionSimple(ec, pic, m_cpOrgIP);
        _ReleaseCorrectOrgIP( );
    }
    
    return hr;
}

//
// Start an edit session to restore the original IP
//
//
HRESULT CCorrectionHandler::RestoreCorrectOrgIP(ITfContext *pic )
{
    HRESULT hr = E_FAIL;

    if ( !m_psi ) return E_FAIL;

    if (pic)
    {
        hr = m_psi->_RequestEditSession(ESCB_RESTORE_CORRECT_ORGIP, TF_ES_READWRITE, NULL, pic);
    }

    return hr;
}

//
// Handle Correct That, Reconvert commands
//
HRESULT CCorrectionHandler::CorrectThat()
{
    HRESULT hr = E_FAIL;

    if ( !m_psi ) return E_FAIL;

    hr = m_psi->_RequestEditSession(ESCB_RECONV_ONIP, TF_ES_READWRITE);

    return hr;
}

//
// Edit session callback function for CorrectThat.
//
HRESULT CCorrectionHandler::_CorrectThat(TfEditCookie ec, ITfContext *pic)
{
    HRESULT hr = E_FAIL;
    ITfRange *pSel = NULL;

    TraceMsg(TF_GENERAL, "_CorrectThat is called");

    if ( !m_psi ) return E_FAIL;

    if (pic)
    {
        // remove the green bar
        m_psi->_KillFeedbackUI(ec, pic, NULL);

        hr = m_psi->_GetCmdThatRange(ec, pic, &pSel);
    }
    
    if (SUCCEEDED(hr) && pSel)
    {
        hr = _ReconvertOnRange(pSel);
    }
    
    SafeRelease(pSel);

    // moved from _HandleRecognition as this is a command
    //
    m_psi->SaveLastUsedIPRange( );
    m_psi->SaveIPRange(NULL);
    return hr;
}

HRESULT  CCorrectionHandler::_SetSystemReconvFunc( )
{
    HRESULT hr = S_OK;

    if (!m_cpsysReconv)
    {
        CComPtr<ITfFunctionProvider>  cpsysFuncPrv;

        hr = (m_psi->_tim)->GetFunctionProvider(GUID_SYSTEM_FUNCTIONPROVIDER, &cpsysFuncPrv);

        if (hr == S_OK)
            hr = cpsysFuncPrv->GetFunction(GUID_NULL, IID_ITfFnReconversion, (IUnknown **)&m_cpsysReconv);
    }

    return hr;
}

void     CCorrectionHandler::_ReleaseSystemReconvFunc( )
{
    if (m_cpsysReconv)
        m_cpsysReconv.Release( );
}


// 
// CCorrectionHandler::_ReconvertOnRange
// 
// Try to get the candidate UI for the given pRange if this range contains speech alternates
// data.
//
// pRange could be a selection or an IP.
//
//
HRESULT CCorrectionHandler::_ReconvertOnRange(ITfRange *pRange, BOOL  *pfConvertable)
{
    HRESULT hr = E_FAIL;
    ITfRange *pAttrRange = NULL;
    BOOL fConvertable = FALSE;

    TraceMsg(TF_GENERAL, "_ReconvertOnRange is called");

    if ( !pRange )  return E_INVALIDARG;

    hr = pRange->Clone(&pAttrRange);

    if (S_OK == hr && pAttrRange)
    {
        CComPtr<ITfRange>     cpRangeReconv;

        hr = _SetSystemReconvFunc( );    
        if ( hr == S_OK )
            hr = m_cpsysReconv->QueryRange(pAttrRange, &cpRangeReconv, &fConvertable);

        if ( (hr == S_OK) && fConvertable && cpRangeReconv)
        {
            // The text owner could be any other tips, and other tips may want to 
            // request a new R/W edit session to open reconvert UI.
            // Cicero would return E_LOCKED if other tip wants to request edit session while 
            // speech tip is under an edit session.
            //
            // To resolve this problem, speech tip just save the cpRangeReconv post a message
            // to the work window and then immediatelly end this edit session.
            //
            // When the work window receives the private message, the window procedure function 
            // will do a real reconvert work.

            m_cpCorrectRange.Release( );
            hr = cpRangeReconv->Clone(&m_cpCorrectRange);

            if ( hr == S_OK )
                PostMessage(m_psi->_GetWorkerWnd( ), WM_PRIV_DORECONVERT, 0, 0);
        }
    }

    SafeRelease(pAttrRange);

    if ( pfConvertable )
        *pfConvertable = fConvertable;

    return hr;
}

// 
// CCorrectionHandler::_DoReconvertOnRange
// 
// When WM_.... is handled, this function will be called.
// ReconvertOnRange( ) post the above private message and prepare
// all the necessary range data in the class object.
// This function will do the real reconvertion.
//
HRESULT CCorrectionHandler::_DoReconvertOnRange( )
{
    HRESULT hr = E_FAIL;

    TraceMsg(TF_GENERAL, "_DoReconvertOnRange is called");

    if ( !m_cpCorrectRange )  return hr;

    hr = _SetSystemReconvFunc( );

    if ( hr == S_OK )
        hr = m_cpsysReconv->Reconvert(m_cpCorrectRange);
    
    _ReleaseSystemReconvFunc( );

    return hr;
}

//
// Moved here from CSapiIMX
//
HRESULT CCorrectionHandler::SetReplaceSelection(ITfRange *pRange,  ULONG cchReplaceStart,  ULONG cchReplaceChars, ITfContext *pic)
{
    HRESULT hr = E_FAIL;
    ESDATA  esData;

    if ( !m_psi ) return E_FAIL;

    memset(&esData, 0, sizeof(ESDATA));

    esData.lData1 = (LONG_PTR)cchReplaceStart;
    esData.lData2 = (LONG_PTR)cchReplaceChars;
    esData.pRange = pRange;
    
    hr = m_psi->_RequestEditSession(ESCB_SETREPSELECTION, TF_ES_READWRITE, &esData, pic); 

    return hr;
}


//
//  _SetReplaceSelection
//
//  synoposis: calculate the span of text range based on the specified length of 
//             the selected alternate string (cchReplacexxx)
//             then set a selection basedon it.
//
HRESULT CCorrectionHandler::_SetReplaceSelection
(
    TfEditCookie ec, 
    ITfContext *pic,     ITfRange *pRange, 
    ULONG cchReplaceStart, 
    ULONG cchReplaceChars
)
{
    // adjust pRange here
    CComPtr<ITfProperty>    cpProp;
    CComPtr<ITfRange>       cpPropRange;
    CComPtr<ITfRange>       cpClonedPropRange;

    if ( !m_psi ) return E_FAIL;
   
    HRESULT hr = pic->GetProperty(GUID_PROP_SAPIRESULTOBJECT, &cpProp);
    if (S_OK == hr)
    {
        hr = cpProp->FindRange(ec, pRange, &cpPropRange, TF_ANCHOR_START);
    }
    
    if (S_OK == hr)
    {
        hr = cpPropRange->Clone(&cpClonedPropRange);
    }
    if (S_OK == hr)
    {
        hr = cpClonedPropRange->Collapse(ec, TF_ANCHOR_START);
    }

    if (S_OK == hr)
    {
        long cch;
        cpClonedPropRange->ShiftStart(ec, cchReplaceStart, &cch, NULL);
        cpClonedPropRange->ShiftEnd(ec, cchReplaceChars, &cch, NULL);
    }

    SetSelectionSimple(ec, pic, cpClonedPropRange);

    if ( m_psi->GetDICTATIONSTAT_DictOnOff())
        m_psi->_FeedIPContextToSR(ec, pic, cpClonedPropRange); 
        
    // discurd IP
    m_psi->SaveIPRange(NULL);

    return hr;
}


//+---------------------------------------------------------------------------
//
// CCorrectionHandler::InjectAlternateText
//
//----------------------------------------------------------------------------
HRESULT CCorrectionHandler::InjectAlternateText
(
    const WCHAR *pwszResult, 
    LANGID langid, 
    ITfContext *pic,
    BOOL   bHandleLeadingSpace
)
{
    HRESULT hr = E_FAIL;

    Assert(pwszResult);
    Assert(pic);

    if ( !m_psi ) return E_FAIL;

    ESDATA  esData;

    memset(&esData, 0, sizeof(ESDATA));
    esData.pData = (void *)pwszResult;
    esData.uByte = (wcslen(pwszResult)+1) * sizeof(WCHAR);
    esData.lData1 = (LONG_PTR)langid;
    esData.fBool = bHandleLeadingSpace;

    hr = m_psi->_RequestEditSession(ESCB_PROCESS_ALTERNATE_TEXT,TF_ES_READWRITE, &esData, pic);

    return hr;
}


HRESULT CCorrectionHandler::_ProcessAlternateText(TfEditCookie ec, WCHAR *pwszText,LANGID langid, ITfContext *pic, BOOL bHandleLeadingSpace)
{
    HRESULT hr = S_OK;

    if ( !m_psi ) return E_FAIL;

    CComPtr<ITfRange>  cpRangeText;

    // Save the current selection as text range which is used
    // later to handle leading spaces.
    //
    if ( bHandleLeadingSpace )
    {
        CComPtr<ITfRange>  cpSelection;

        hr = GetSelectionSimple(ec, pic, &cpSelection);

        if ( hr == S_OK && cpSelection )
            hr = cpSelection->Clone(&cpRangeText);
    }

    if ( hr == S_OK )
        hr = m_psi->_ProcessTextInternal(ec, pwszText, GUID_ATTR_SAPI_INPUT, langid, pic, TRUE);

    if ( hr == S_OK && bHandleLeadingSpace && pwszText && cpRangeText)
    {
        // If the first element is updated by the alternate phrase
        // speech tip needs to check if this new alternate wants to 
        // consume the leading space or if extra space is required to add
        // between this phrase and previous phrase.
        // 
        BOOL   bConsumeLeadingSpace = FALSE;
        WCHAR  wchFirstChar = pwszText[0];

        if ( iswcntrl(wchFirstChar) || iswpunct(wchFirstChar) )
            bConsumeLeadingSpace = TRUE;

        if ( hr == S_OK)
            hr = m_psi->_ProcessLeadingSpaces(ec, pic, cpRangeText, bConsumeLeadingSpace, langid, FALSE); 
    }

    if ( fRestoreIP )
        _RestoreCorrectOrgIP(ec, pic);
    else
        _ReleaseCorrectOrgIP( );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\correctionimx.cpp ===
//
// correctionimx.cpp
//
#include "private.h"

#ifdef SUPPORT_INTERNAL_WIDGET

#include "globals.h"
#include "timsink.h"
#include "immxutil.h"
#include "sapilayr.h"
#include "spdebug.h"
#include "sphelper.h"
#include "mscandui.h"
#include "computil.h"
#include "ids.h"
#include "cicspres.h"
#include <conio.h>

#define WM_USERLBUTTONDOWN  WM_USER+10000        // Replacement for LBUTTONDOWN to fix raid 8828.

LPCTSTR  g_lpszClassName = TEXT("CorrectionWidget");

// BUGBUG - Pixel values currently. Need to take account of screen DPI.
const ULONG g_uWidgetWidth              = 11;
const ULONG g_uWidgetHeight             = 11;
const ULONG g_uActualWidgetHeight       = 7;
const ULONG g_uExpandedWidgetWidth      = 20;
const ULONG g_uExpandedWidgetHeight     = 16;
const ULONG g_uExpandedWidgetXOffset    = g_uExpandedWidgetWidth - (g_uExpandedWidgetWidth - g_uWidgetWidth)/2;
const ULONG g_uWidgetYOffset            = 0;    // Position expanded widget just touching actual edge of correction list when it's above widget.
const ULONG g_uExpandedWidgetYOffset    = 0;    // Position expanded widget just touching actual edge of correction list when it's above widget.
												// ** These NEED to match the icons and each other to avoid misbehavors. **
												// Small widget MUST be entirely enclosed by large widget.
const ULONG g_cSloppySelection          = 3;

const ULONG g_uTimerLength              = 2500; // Time before the widget starts fading out.
const ULONG g_uTimerFade                = 10;   // Time between alpha decrements for fadeout.
const ULONG g_uAlphaFade                = 4;    // Alpha fade decrement every 10ms for fadeout effect.
const ULONG g_uAlpha                    = 216;  // Should be multiples of g_uAlphaFade
const ULONG g_uAlphaLarge               = 255;  // Can be anything.
const ULONG g_uAlphaInvisible           = 5;    // Needs to be sufficiently non zero that when combined with above, still receives mouse events.
                                                // Can be 4 minimum when combined with alpha 255 for 24/32 bit color mode.
                                                // Needs to be at least 5 when in 16 bit color mode.

const ULONG g_uTimerSloppyMouseLeave    = 500;  // Time after mouse leave correction window that it resizes small.

/****************************************************************************
* CCorrectionIMX::CCorrectionIMX *
*--------------------------------*
*   Description:
*       Constructor for Correction 1Tip.
*     
*   Returns: 
*       None.
*     
*   Args: 
*       None
*
**************************************************************** agarside ***/

CCorrectionIMX::CCorrectionIMX()  : m_dwEditCookie(0),
                                    m_dwLayoutCookie(0),
                                    m_dwThreadFocusCookie(0),
                                    m_dwKeyTraceCookie(0),
                                    m_fExpanded(FALSE),
                                    m_hWnd(NULL),
                                    m_hIconInvoke(NULL),
                                    m_hIconInvokeLarge(NULL),
                                    m_hIconInvokeClose(NULL),
                                    m_eWindowState(WINDOW_HIDE),
                                    m_fDisplayAlternatesMyself(FALSE),
                                    m_fCandidateOpen(FALSE),
                                    m_fKeyDown(FALSE),
                                    m_hAtom(0)
{
    SPDBG_FUNC("CCorrectionIMX::CCorrectionIMX");
    memset(&m_rcSelection, 0, sizeof(m_rcSelection));
}

/****************************************************************************
* CCorrectionIMX::~CCorrectionIMX *
*---------------------------------*
*   Description:
*       Destructor for Correction Tip
*     
*   Returns: 
*       None.
*     
**************************************************************** agarside ***/

CCorrectionIMX::~CCorrectionIMX()
{
    SPDBG_FUNC("CCorrectionIMX::~CCorrectionIMX");
    if (m_hWnd)
    {
        DestroyWindow(m_hWnd);
    }
    if (m_hIconInvoke)
    {
        DestroyIcon(m_hIconInvoke);
        m_hIconInvoke = NULL;
    }
    if (m_hIconInvokeLarge)
    {
        DestroyIcon(m_hIconInvokeLarge);
        m_hIconInvokeLarge = NULL;
    }
    if (m_hIconInvokeClose)
    {
        DestroyIcon(m_hIconInvokeClose);
        m_hIconInvokeClose = NULL;
    }
}

/****************************************************************************
* CCorrectionIMX::FinalConstruct *
*--------------------------------*
*   Description:
*       Preliminary initialization of the object.
*       Creates window class and hidden window for message pump.
*       Loads icon resources.
*     
*   Returns: HRESULT 
*     S_OK  - Everything succeeded.
*     Otherwise, appropriate error code.
*
**************************************************************** agarside ***/

HRESULT CCorrectionIMX::FinalConstruct()
{
    SPDBG_FUNC("CCorrectionIMX::FinalConstruct");
    HRESULT hr = S_OK;

    if (SUCCEEDED(hr))
    {
        m_hIconInvoke      = (HICON)LoadImage(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDI_INVOKE), IMAGE_ICON, g_uWidgetWidth, g_uWidgetHeight, 0);
        ASSERT("Failed to create small invocation icon." && m_hIconInvoke);
        if (!m_hIconInvoke)
        {
            hr = SpHrFromLastWin32Error();
        }
    }
    if (SUCCEEDED(hr))
    {
        m_hIconInvokeLarge = (HICON)LoadImage(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDI_INVOKE), IMAGE_ICON, g_uExpandedWidgetWidth, g_uExpandedWidgetHeight, 0);
        ASSERT("Failed to create large invocation icon." && m_hIconInvokeLarge);
        if (!m_hIconInvokeLarge)
        {
            hr = SpHrFromLastWin32Error();
        }
    }
    if (SUCCEEDED(hr))
    {
        m_hIconInvokeClose = (HICON)LoadImage(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDI_INVOKECLOSE), IMAGE_ICON, g_uExpandedWidgetWidth, g_uExpandedWidgetHeight, 0);
        ASSERT("Failed to create large invocation icon." && m_hIconInvokeClose);
        if (!m_hIconInvokeClose)
        {
            hr = SpHrFromLastWin32Error();
        }
    }

    if (SUCCEEDED(hr))
    {
        if (!CicLoadStringWrapW(g_hInst, IDS_DELETESELECTION, m_wszDelete, ARRAYSIZE(m_wszDelete))
        {
            hr = E_OUTOFMEMORY;
        }
        if (!CicLoadStringWrapW(g_hInst, IDS_ADDTODICTIONARYPREFIX, m_wszAddPrefix, ARRAYSIZE(m_wszAddPrefix))
        {
            hr = E_OUTOFMEMORY;
        }
        if (!CicLoadStringWrapW(g_hInst, IDS_ADDTODICTIONARYPOSTFIX, m_wszAddPostfix, ARRAYSIZE(m_wszAddPostfix))
        {
            hr = E_OUTOFMEMORY;
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::LazyInitializeWindow *
*--------------------------------------*
*   Description:
*
*   Returns: HRESULT 
*
**************************************************************** agarside ***/

HRESULT CCorrectionIMX::LazyInitializeWindow()
{
    SPDBG_FUNC("CCorrectionIMX::LazyInitializeWindow");
    HRESULT hr = S_OK;

    if (m_hWnd)
    {
        return S_OK;
    }

    WNDCLASSEX wndClass;
    memset(&wndClass, 0, sizeof(wndClass));
    wndClass.cbSize = sizeof(wndClass);
    wndClass.style = CS_HREDRAW | CS_VREDRAW;
    wndClass.lpszClassName = g_lpszClassName;
    wndClass.hInstance = _Module.GetModuleInstance();
    wndClass.lpfnWndProc = WndProc;
    wndClass.hCursor = LoadCursor(NULL, IDC_ARROW);
    ATOM hAtom;
    if ((hAtom = RegisterClassEx(&wndClass)) == 0)
    {
        ASSERT("Failed to register window class." && FALSE);
    }
    if (SUCCEEDED(hr))
    {
        m_hAtom = hAtom;
        m_hWnd = CreateWindowEx(WS_EX_TOPMOST | WS_EX_NOACTIVATE | WS_EX_LAYERED, g_lpszClassName, g_lpszClassName, WS_POPUP | WS_DISABLED, 0, 0, g_uWidgetWidth, g_uWidgetHeight, NULL, NULL, _Module.GetModuleInstance(), this);
        ASSERT("Failed to create hidden window." && m_hWnd);
        if (!m_hWnd)
        {
            hr = SpHrFromLastWin32Error();
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::DrawWidget *
*----------------------------*
*   Description:
*
*   Returns: HRESULT 
*
*   Args: 
*     BYTE uAlpha
*
**************************************************************** agarside ***/

HRESULT CCorrectionIMX::DrawWidget(BYTE uAlpha)
{
    SPDBG_FUNC("CCorrectionIMX::DrawWidget");
    HRESULT hr = S_OK;
    
    typedef struct _RGBALPHA {
        BYTE rgbBlue;
        BYTE rgbGreen;
        BYTE rgbRed;
        BYTE rgbAlpha;
    } RGBALPHA;
    
    HDC         hdcScreen = NULL;
    HDC         hdcLayered = NULL;
    RECT        rcWindow;
    SIZE        size;
    BITMAPINFO  BitmapInfo;
    HBITMAP     hBitmapMem = NULL;
    HBITMAP     hBitmapOld = NULL;
    void        *pDIBits;
    int         i;
    int         j;
    POINT       ptSrc;
    POINT       ptDst;
    BLENDFUNCTION Blend;
    BOOL        bRet;
    RGBALPHA    *ppxl;
    
    GetWindowRect( m_hWnd, &rcWindow );
    size.cx = rcWindow.right - rcWindow.left;
    size.cy = rcWindow.bottom - rcWindow.top;
    
    hdcScreen = GetDC( NULL );
    if (hdcScreen == NULL) 
    {
        return E_FAIL;
    }
    
    hdcLayered = CreateCompatibleDC( hdcScreen );
    if (hdcLayered == NULL) 
    {
        ReleaseDC( NULL, hdcScreen );
        return E_FAIL;
    }
    
    // create bitmap
    BitmapInfo.bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    BitmapInfo.bmiHeader.biWidth         = size.cx;
    BitmapInfo.bmiHeader.biHeight        = size.cy;
    BitmapInfo.bmiHeader.biPlanes        = 1;
    BitmapInfo.bmiHeader.biBitCount      = 8 * sizeof(_RGBALPHA);
    BitmapInfo.bmiHeader.biCompression   = BI_RGB;
    BitmapInfo.bmiHeader.biSizeImage     = 0;
    BitmapInfo.bmiHeader.biXPelsPerMeter = 100;
    BitmapInfo.bmiHeader.biYPelsPerMeter = 100;
    BitmapInfo.bmiHeader.biClrUsed       = 0;
    BitmapInfo.bmiHeader.biClrImportant  = 0;
    
    hBitmapMem = CreateDIBSection( hdcScreen, &BitmapInfo, DIB_RGB_COLORS, &pDIBits, NULL, 0 );
    if (pDIBits == NULL) 
    {
        ReleaseDC( NULL, hdcScreen );
        DeleteDC( hdcLayered );
        return E_FAIL;
    }
    
    ICONINFO iconInfo;
    if (m_fExpanded)
    {
        if (m_eWindowState == WINDOW_LARGE)
        {
            bRet = GetIconInfo(m_hIconInvokeLarge, &iconInfo);
        }
        else
        {
            bRet = GetIconInfo(m_hIconInvokeClose, &iconInfo);
        }
    }
    else
    {
        bRet = GetIconInfo(m_hIconInvoke, &iconInfo);
    }
    if (bRet)
    {
        BITMAP bm, bmMask;
        GetObject(iconInfo.hbmColor, sizeof(bm), &bm);
        GetObject(iconInfo.hbmMask, sizeof(bmMask), &bmMask);
        if (bm.bmPlanes==1 && bmMask.bmBitsPixel==1 && bmMask.bmPlanes==1) 
        {
            ASSERT(bm.bmWidth == size.cx);
            ASSERT(bm.bmHeight == size.cy);
            // Copy icon into layered window.
            GetDIBits(hdcScreen, iconInfo.hbmColor, 0, g_uExpandedWidgetHeight, pDIBits, &BitmapInfo, DIB_RGB_COLORS);
            
            UINT uiNumberBytesMask = bmMask.bmHeight * bmMask.bmWidthBytes;
            BYTE *bitmapBytesMask = new BYTE[uiNumberBytesMask];
            if (bitmapBytesMask == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                memset(bitmapBytesMask, 0, uiNumberBytesMask);
                int cBytes = GetBitmapBits(iconInfo.hbmMask,uiNumberBytesMask,bitmapBytesMask);
                ASSERT(cBytes == uiNumberBytesMask);
                if (bRet)
                {
                    for (i = 0; i < size.cy; i++) 
                    {
                        ppxl = (RGBALPHA *)pDIBits + ((size.cy - i - 1) * size.cx);
                        for (j = 0; j < size.cx; j++)
                        {
                            if ( (bitmapBytesMask[i * bmMask.bmWidthBytes + j/8] >> (7 - (j % 8)))&1)
                            {
                                ppxl->rgbRed   = 0;
                                ppxl->rgbBlue  = 0;
                                ppxl->rgbGreen = 0;
                                ppxl->rgbAlpha = g_uAlphaInvisible;
                            }
                            else
                            {
                                ppxl->rgbAlpha = 255;
                            }
                            ppxl++;
                        }
                    }
                }
                delete [] bitmapBytesMask;
            }            
        }
        else
        {
            ASSERT("Correction icon is an invalid bitmap format." && FALSE);
        }
        bRet = DeleteObject (iconInfo.hbmColor); 
        iconInfo.hbmColor=NULL;
        ASSERT(bRet);
        bRet = DeleteObject (iconInfo.hbmMask); 
        iconInfo.hbmMask=NULL;
        ASSERT(bRet);
    }
    
    if (SUCCEEDED(hr))
    {
        ptSrc.x = 0;
        ptSrc.y = 0;
        ptDst.x = rcWindow.left;
        ptDst.y = rcWindow.top;
        Blend.BlendOp             = AC_SRC_OVER;
        Blend.BlendFlags          = 0;
        Blend.SourceConstantAlpha = uAlpha;
        Blend.AlphaFormat         = AC_SRC_ALPHA;
        
        hBitmapOld = (HBITMAP)SelectObject( hdcLayered, hBitmapMem );
        
        bRet = UpdateLayeredWindow(m_hWnd, hdcScreen, &ptDst, &size, hdcLayered, &ptSrc, 0, &Blend, ULW_ALPHA );
        if (!bRet)
        {
            DWORD dw = GetLastError();
        }
        
        SelectObject( hdcLayered, hBitmapOld );
    }
    
    // done
    
    ReleaseDC( NULL, hdcScreen );
    DeleteDC( hdcLayered );
    DeleteObject( hBitmapMem );
    
    return hr;
}

/****************************************************************************
* CCorrectionIMX::Activate *
*--------------------------*
*   Description:
*       Called when Cicero is initialized on a thread.
*       Allows us to initialize any Cicero related objects at this point.     
*
*   Returns: STDAPI 
*       S_OK - Everything successfully initialized.
*       Otherwise, appropriate error code.
*
*   Args: 
*     ITfThreadMgr *ptim
*       Pointer to the thread input manager object for the thread.
*     TfClientId tid
*       Text frameworks client ID for thread.
*
**************************************************************** agarside ***/

STDAPI CCorrectionIMX::Activate(ITfThreadMgr *ptim, TfClientId tid)
{
    HRESULT hr = S_OK;
    SPDBG_FUNC("CCorrectionIMX::Activate");

    ASSERT(m_cptim == NULL);

#if 0
    hr = m_cptim.CoCreateInstance(CLSID_TF_ThreadMgr);

    // Activate the thread manager
    if (S_OK == hr)
    {
        hr = m_cptim->Activate(&m_tid);
    }
#else
    m_cptim = ptim;
#endif

    m_ptimEventSink = new CThreadMgrEventSink(DIMCallback, ICCallback, this);
    if (m_ptimEventSink == NULL)
    {
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        hr = m_ptimEventSink->_Advise(m_cptim);
    }

    CComPtr<ITfSource> cpSource;
    if (SUCCEEDED(hr))
    {
        hr = m_cptim->QueryInterface(IID_ITfSource, (void **)&cpSource);
    }
    if (SUCCEEDED(hr))
    {
        hr = cpSource->AdviseSink(IID_ITfThreadFocusSink, (ITfThreadFocusSink *)this, &m_dwThreadFocusCookie);
    }
    if (SUCCEEDED(hr))
    {
        hr = cpSource->AdviseSink(IID_ITfKeyTraceEventSink, (ITfKeyTraceEventSink *)this, &m_dwKeyTraceCookie);
    }

    if (SUCCEEDED(hr))
    {
        m_ptimEventSink->_InitDIMs(TRUE);
    }
    CComPtr<ITfFunctionProvider> cpSysFuncPrv;
    if (SUCCEEDED(hr))
    {
        hr = m_cptim->GetFunctionProvider(GUID_SYSTEM_FUNCTIONPROVIDER, &cpSysFuncPrv);
    }
    if (SUCCEEDED(hr))
    {
        hr = cpSysFuncPrv->GetFunction(GUID_NULL, IID_ITfFnReconversion, (IUnknown **)&m_cpSysReconv);
    }
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::Deactivate *
*----------------------------*
*   Description:
*       Called when the Cicero thread manager is closing down on a thread.
*       Tip is required to deactivate and release all objects.
*       Guaranteed to be called if we were ever activated except if a 
*       catastrophic failure has already occurred.
*
*   Returns: STDAPI 
*       S_OK  - Everything succeeded.
*       Otherwise, appropriate error code.
*
**************************************************************** agarside ***/

STDAPI CCorrectionIMX::Deactivate()
{
    SPDBG_FUNC("CCorrectionIMX::Deactivate");
    HRESULT hr = S_OK;

    if (m_ptimEventSink)
    {
        hr = m_ptimEventSink->_InitDIMs(FALSE);
        if (SUCCEEDED(hr))
        {
            hr = m_ptimEventSink->_Unadvise();
        }
        delete m_ptimEventSink;
        m_ptimEventSink = NULL;
    }
    CComPtr<ITfSource> cpSource;
    if (m_cptim && m_cptim->QueryInterface(IID_ITfSource, (void **)&cpSource) == S_OK)
    {
        cpSource->UnadviseSink(m_dwThreadFocusCookie);
        cpSource->UnadviseSink(m_dwKeyTraceCookie);
    }
    m_cpRangeReconv = NULL;
    m_cpRangeUser = NULL;
    m_cpRangeWord = NULL;
    m_cpSysReconv = NULL;

    // m_cptim->Deactivate();
    m_cptim.Release();

    if (m_hAtom)
    {
        UnregisterClass((LPCTSTR)m_hAtom, _Module.GetModuleInstance());
    }
    m_hAtom = NULL;

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::OnSetThreadFocus *
*----------------------------------*
*   Description:
*       Called by Cicero when our thread gets focus.
*       We do nothing here.
*
*   Returns: STDAPI 
*
*   Args: 
*     void
*
**************************************************************** agarside ***/

STDAPI CCorrectionIMX::OnSetThreadFocus(void)
{
    SPDBG_FUNC("CCorrectionIMX::OnSetThreadFocus");
    HRESULT hr = S_OK;

    // We do nothing here.

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::OnKillThreadFocus *
*-----------------------------------*
*   Description:
*       Called by Cicero when our thread gets focus.
*       We use this to intelligently hide the widget when the app loses focus.
*
*   Returns: STDAPI 
*
*   Args: 
*     void
*
**************************************************************** agarside ***/

STDAPI CCorrectionIMX::OnKillThreadFocus(void)
{
    SPDBG_FUNC("CCorrectionIMX::OnKillThreadFocus");
    HRESULT hr = S_OK;

    // When we lose focus, we must hide the widget.
    hr = Show(WINDOW_HIDE);

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::OnKeyTraceDown *
*--------------------------------*
*   Description:
*
*   Returns: STDAPI 
*
*   Args: 
*     WPARAM wParam
*     LPARAM lParam
*
**************************************************************** agarside ***/

STDAPI CCorrectionIMX::OnKeyTraceDown(WPARAM wParam,LPARAM lParam)
{
    SPDBG_FUNC("CCorrectionIMX::OnKeyTraceDown");
    HRESULT hr = S_OK;

    m_fKeyDown = TRUE;

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::OnKeyTraceUp *
*------------------------------*
*   Description:
*
*   Returns: STDAPI 
*
*   Args: 
*     WPARAM wParam
*     LPARAM lParam
*
**************************************************************** agarside ***/

STDAPI CCorrectionIMX::OnKeyTraceUp(WPARAM wParam,LPARAM lParam)
{
    SPDBG_FUNC("CCorrectionIMX::OnKeyTraceUp");
    HRESULT hr = S_OK;

    m_fKeyDown = FALSE;

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::OnLayoutChange *
*--------------------------------*
*   Description:
*       Called by Cicero when the document is resized and/or moved provided Cicero
*       application correctly handles this. This allows us to update the location
*       of the widget to match the new location of the associated selection.
*
*   Returns: STDAPI 
*       S_OK  - Everything succeeded.
*       Otherwise, appropriate error code.
*
*   Args: 
*     ITfContext *pic
*       Pointer to the input context which was affected.
*     TfLayoutCode lcode
*       Flag - one of CREATE, CHANGE, DESTROY. We do not currently use this.
*     ITfContextView *pView
*       Pointer to the context view affected.
*
**************************************************************** agarside ***/

STDAPI CCorrectionIMX::OnLayoutChange(ITfContext *pic, TfLayoutCode lcode, ITfContextView *pView)
{
    SPDBG_FUNC("CCorrectionIMX::OnLayoutChange");
    HRESULT hr = S_OK;
	BOOL fInWriteSession = FALSE;
	CEditSession *pes = NULL;

    if (m_cpRangeReconv == NULL)
    {
        return S_OK;
    }

	// ignore events made by client tip
	pic->InWriteSession( m_tid, &fInWriteSession );
	if (fInWriteSession) 
    {
		return S_OK;
	}

	// we only care about the active view
	if (!IsActiveView( pic, (ITfContextView *)pView )) 
    {
		return S_OK;
	}

	pes = new CEditSession( EditSessionCallback );
	// move candidate window
	if (pes) 
    {
		pes->_state.u      = ESCB_RESETTARGETPOS;
		pes->_state.pv     = this;
		pes->_state.wParam = 0;
		pes->_state.pRange = NULL;
		pes->_state.pic    = pic;

		pic->RequestEditSession( m_tid, pes, TF_ES_READ | TF_ES_SYNC, &hr );

		pes->Release();
	}
    else
    {
        hr = E_OUTOFMEMORY;
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::IsCandidateObjectOpen *
*---------------------------------------*
*   Description:
*
*   Returns: HRESULT 
*       Appropriate error code.
*
*   Args: 
*     BOOL *fOpen
*       TRUE if candidate object is open.
*
**************************************************************** agarside ***/

HRESULT CCorrectionIMX::IsCandidateObjectOpen(ITfContext *pic, BOOL *fOpen)
{
    SPDBG_FUNC("CCorrectionIMX::IsCandidateObjectOpen");

    HRESULT hr = S_OK;
    CComPtr<ITfCompartmentMgr> cpCompMgr;
    CComPtr<ITfCompartment>  cpComp;
    CComPtr<ITfContext> cpICTop;
    CComPtr<ITfDocumentMgr> cpDim;
    CComVariant cpVarCandOpen;

    // Default to candidate UI not open in case of failure.
    *fOpen = FALSE;

    cpVarCandOpen.lVal = 0;
    hr = pic->GetDocumentMgr(&cpDim);
    if (SUCCEEDED(hr) && cpDim)
    {
        // Could shortcut check here if cpICTop and pic are the same object (check IUnknowns).
        hr = cpDim->GetTop(&cpICTop);
    }
    if (SUCCEEDED(hr) && cpICTop)
    {
        hr = cpICTop->QueryInterface(&cpCompMgr);
    }
    if (SUCCEEDED(hr) && cpCompMgr)
    {
        hr = cpCompMgr->GetCompartment(GUID_COMPARTMENT_MSCANDIDATEUI_CONTEXT, &cpComp);
    }
    if (SUCCEEDED(hr) && cpComp)
    {
        hr = cpComp->GetValue(&cpVarCandOpen);
        // If the Top IC has this set to one, then this IC was created by the candidate UI object and hence we
        // do *not* want to display the widget.
    }
    if (SUCCEEDED(hr))
    {
        *fOpen = (cpVarCandOpen.lVal == 1);
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::OnEndEdit *
*---------------------------*
*   Description:
*       Called when something causes submission of an edit to the input context.
*
*   Returns: STDAPI 
*       S_OK  - Everything succeeded.
*       Otherwise, appropriate error code.
*
*   Args: 
*     ITfContext *pic
*       Input context affected.
*     TfEditCookie ecReadOnly
*       Read only cookie for immediate use.
*     ITfEditRecord *pEditRecord
*       Pointer to object allowing the details of the edit to be investigated.
*       We use this solely to find out if the selection changed since we do not need
*       to take action based on anything else.
*
**************************************************************** agarside ***/

STDAPI CCorrectionIMX::OnEndEdit(ITfContext *pic, TfEditCookie ecReadOnly, ITfEditRecord *pEditRecord)
{
    SPDBG_FUNC("CCorrectionIMX::OnEndEdit");
    HRESULT hr = S_OK;
    CComPtr<ITfRange> cpRangeUser;
    CComPtr<ITfRange> cpRangeWord;
    CComPtr<ITfRange> cpRangeReconv;
    CComPtr<ITfContextView> cpView;
    BOOL fHideWidget = TRUE;
    BOOL fSelectionChanged = FALSE;
    BOOL fCandOpen = FALSE;
    BOOL fHasFocus = TRUE; // If we fail focus check in any way, assume does have focus.

    m_fDisplayAlternatesMyself = FALSE;

    hr = pic->GetActiveView(&cpView);
    if (SUCCEEDED(hr))
    {
        HWND hWnd;
        hr = cpView->GetWnd(&hWnd);
        if (hWnd == GetFocus())
        {
            fHasFocus = TRUE;
        }
    }

    if (fHasFocus && !m_fCandidateOpen)
    {
        // Candidate list is open. We do not want to display correction widget.
        pEditRecord->GetSelectionStatus(&fSelectionChanged);
        // if (fSelectionChanged) // This is FALSE when IP first put into RichEdit stage! RE also claims IP is at end of previous utterance :-(.
        {
            // Get user selection.
            BOOL fEmpty = FALSE;
            hr = GetSelectionSimple(ecReadOnly, pic, &cpRangeUser);
            if (SUCCEEDED(hr))
            {
                // Check it isn't empty. If it is empty we want to hide the widget.
                hr = cpRangeUser->IsEmpty(ecReadOnly, &fEmpty);
            }
            if (SUCCEEDED(hr) && fEmpty && !m_fKeyDown)
            {
                BOOL fMatch = FALSE;
                if (m_cpRangeUser)
                {
                    cpRangeUser->IsEqualStart(ecReadOnly, m_cpRangeUser, TF_ANCHOR_START, &fMatch);
                    if (!fMatch)
                    {
                        // Check end point.
                        cpRangeUser->IsEqualStart(ecReadOnly, m_cpRangeUser, TF_ANCHOR_END, &fMatch);
                    }
                }
                if (!fMatch)
                {
                    // Find word range (using white space delimiters upto 20 characters either side).
                    FindWordRange(ecReadOnly, cpRangeUser, &cpRangeWord);
                }
            }
            if (!fEmpty)
            {
                cpRangeWord = cpRangeUser;
            }
            if (SUCCEEDED(hr) && cpRangeWord && (!fEmpty || !m_fKeyDown))
            {
                // Get reconversion range.
                BOOL fConvertable = FALSE;
                hr = m_cpSysReconv->QueryRange(cpRangeWord, &cpRangeReconv, &fConvertable);
                // Will validly fail if there is no alternates - e.g. partial words or typed text.
                hr = S_OK;

                BOOL fMatch = FALSE;
                if (SUCCEEDED(hr) && fConvertable)
                {
                    hr = DoesUserSelectionMatchReconversion(ecReadOnly, cpRangeWord, cpRangeReconv, &fMatch);
                    // May not be convertable or ranges may not match.
                }
                if (SUCCEEDED(hr) && fMatch)
                {
                    fHideWidget = FALSE;
                    // Convertable and ranges do match.
                }
                else
                {
                    if (fEmpty)
                    {
                        cpRangeReconv = NULL;
                        cpRangeReconv = cpRangeWord;
                        fHideWidget = FALSE;
                        m_fDisplayAlternatesMyself = TRUE;
                    }
                    else
                    {
                        // Find word range (using white space delimiters upto 20 characters either side).
                        CComPtr<ITfRange> cpRangeWordTmp;
                        CComPtr<ITfRange> cpRangeClone;
                        hr = cpRangeWord->Clone(&cpRangeClone);
                        if (SUCCEEDED(hr))
                        {
                            hr = cpRangeClone->Collapse(ecReadOnly, TF_ANCHOR_START);
                        }
                        if (SUCCEEDED(hr))
                        {
                            LONG pcch = 0;
                            hr = cpRangeClone->ShiftStart(ecReadOnly, 1, &pcch, NULL);
                        }
                        if (SUCCEEDED(hr))
                        {
                            hr = FindWordRange(ecReadOnly, cpRangeClone, &cpRangeWordTmp);
                        }
                        if (cpRangeWordTmp)
                        {
                            fMatch = FALSE;
                            hr = DoesUserSelectionMatchReconversion(ecReadOnly, cpRangeWord, cpRangeWordTmp, &fMatch);
                        }
                        if (SUCCEEDED(hr) && cpRangeWordTmp && fMatch)
                        {
                            cpRangeReconv = NULL;
                            cpRangeReconv = cpRangeWord;
                            fHideWidget = FALSE;
                            m_fDisplayAlternatesMyself = TRUE;
                        }
                    }
                }
            }
        }
    }

    if (m_fCandidateOpen || !fHasFocus)
    {
        SPDBG_REPORT_ON_FAIL(hr);
        return hr;
    }

    if (fHideWidget)
    {
        m_cpRangeReconv = NULL;
        if (cpRangeUser)
        {
            m_cpRangeUser = NULL;
            m_cpRangeUser = cpRangeUser;
        }
        if (cpRangeWord)
        {
            m_cpRangeWord = NULL;
            m_cpRangeWord = cpRangeWord;
        }
        Show(WINDOW_HIDE);
    }
    else
    {
        m_cpRangeUser = NULL;
        m_cpRangeUser = cpRangeUser;
        m_cpRangeWord = NULL;
        m_cpRangeWord = cpRangeWord;
        m_cpRangeReconv = NULL;
        m_cpRangeReconv = cpRangeReconv;
        m_cpic = pic;

        // Update selection screen coordinates to match user selection (not reconversion range).
        hr = UpdateWidgetLocation(ecReadOnly);
        if (SUCCEEDED(hr))
        {
            Show(WINDOW_SMALLSHOW);
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

// PRIVATE FUNCTIONS

/****************************************************************************
* CCorrectionIMX::CompareRange *
*------------------------------*
*   Description:
*       Compare two ranges and set a boolean value TRUE if they match.
*
*   Returns: HRESULT 
*       S_OK  - Everything succeeded.
*       Otherwise, appropriate error code.
*
*   Args: 
*     TfEditCookie ecReadOnly
*       Edit cookie.
*     ITfRange *pRange1
*       First range.
*     ITfRange *pRange2
*       Second range.
*     BOOL *fIdentical
*       Boolean return value. TRUE = ranges match.
*
**************************************************************** agarside ***/

HRESULT CCorrectionIMX::CompareRange(TfEditCookie ecReadOnly, ITfRange *pRange1, ITfRange *pRange2, BOOL *fIdentical)
{
    SPDBG_FUNC("CCorrectionIMX::CompareRange");
    HRESULT hr = S_OK;
    LONG lStartResult = -1, lEndResult = -1;
    *fIdentical = FALSE;

    hr = pRange1->CompareStart(ecReadOnly, pRange2, TF_ANCHOR_START, &lStartResult);
    if (SUCCEEDED(hr))
    {
        hr = pRange1->CompareEnd(ecReadOnly, pRange2, TF_ANCHOR_END, &lEndResult);
    }
    if (SUCCEEDED(hr) && lStartResult == 0 && lEndResult == 0)
    {
        *fIdentical = TRUE;
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::FindWordRange *
*-------------------------------*
*   Description:
*
*   Returns: HRESULT 
*       S_OK  - Everything succeeded.
*       Otherwise, appropriate error code.
*
*   Args: 
*     TfEditCookie ecReadOnly
*       Edit cookie.
*     ITfRange *pRangeIP
*		Range of the IP (zero length)
*     ITfRange *ppRangeWord
*		Returned range of the word found by simple word breaking algorithm.
*
**************************************************************** agarside ***/

HRESULT CCorrectionIMX::FindWordRange(TfEditCookie ecReadOnly, ITfRange *pRangeIP, ITfRange **ppRangeWord)
{
    SPDBG_FUNC("CCorectionIMX::FindWordRange");
    HRESULT hr = S_OK;
    CComPtr<ITfRangeACP> cpRangeIPACP;
    LONG cchStart = 0, cchEnd = 0, iStart = 0, iEnd = 0;
    ULONG cchTotal = 0;
    WCHAR wzText[41];

    *ppRangeWord = NULL;

    if (SUCCEEDED(hr))
    {
        hr = pRangeIP->QueryInterface(IID_ITfRangeACP, (void **)&cpRangeIPACP);
    }
    if (SUCCEEDED(hr))
    {
        hr = cpRangeIPACP->ShiftStart(ecReadOnly, -20, &cchStart, NULL);
    }
    if (SUCCEEDED(hr))
    {
        hr = cpRangeIPACP->ShiftEnd(ecReadOnly, 20, &cchEnd, NULL);
    }
    if (SUCCEEDED(hr))
    {
        hr = cpRangeIPACP->GetText(ecReadOnly, 0, wzText, 40, &cchTotal);
    }
    wzText[cchTotal] = 0;

    if (SUCCEEDED(hr))
    {
        iStart = abs(cchStart);
        while (iStart >= 0)
        {
            iStart --;
            if (wzText[iStart] < 'A' ||
                wzText[iStart] > 'z' ||
                (wzText[iStart] > 'Z' && wzText[iStart] < 'a') )
            {
                break;
            }
        }
        iStart ++;
        if (iStart == abs(cchStart))
        {
            // Special case - do not show widget on IP when IP at start of the word.
            return S_OK;
        }

        iEnd = abs(cchStart);
        while (iEnd < (LONG)cchTotal)
        {
            if (wzText[iEnd] < 'A' ||
                wzText[iEnd] > 'z' ||
                (wzText[iEnd] > 'Z' && wzText[iEnd] < 'a') )
            {
                break;
            }
            iEnd ++;
        }
        if (iEnd == abs(cchStart))
        {
            return S_OK;
        }

        LONG cchTemp;
        if (iStart > 0)
        {
            hr = cpRangeIPACP->ShiftStart(ecReadOnly, iStart, &cchTemp, NULL);
        }
        if (SUCCEEDED(hr))
        {
            if (iEnd < (LONG)cchTotal)
            {
                hr = cpRangeIPACP->ShiftEnd(ecReadOnly, iEnd - cchTotal, &cchTemp, NULL);
            }
        }
        if (SUCCEEDED(hr))
        {
            hr = pRangeIP->Clone(ppRangeWord);
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::DoesUserSelectionMatchReconversion *
*----------------------------------------------------*
*   Description:
*       Compares the user selection to the reconversion range returned by the tip.
*       Need to match up exactly barring a small amount of white space at start and end.
*
*   Returns: HRESULT 
*       S_OK  - Everything succeeded.
*       Otherwise, appropriate error code.
*
*   Args: 
*     TfEditCookie ecReadOnly
*       Edit cookie.
*     ITfRange *pRangeUser
*       User selection range.
*     BOOL *fMatch
*       Boolean return value for whether they match or not.
*
**************************************************************** agarside ***/

HRESULT CCorrectionIMX::DoesUserSelectionMatchReconversion(TfEditCookie ecReadOnly, ITfRange *pRangeUser, ITfRange *pRangeReconv, BOOL *fMatch)
{
    SPDBG_FUNC("CCorrectionIMX::DoesUserSelectionMatchReconversion");
    HRESULT hr = S_OK;
    CComPtr<ITfRangeACP> cpRangeUserACP, cpReconvACP;
    CComPtr<ITfRange> cpRangeClone;

    *fMatch = FALSE;

    hr = pRangeUser->QueryInterface(IID_ITfRangeACP, (void **)&cpRangeUserACP);
    if (SUCCEEDED(hr))
    {
        hr = pRangeReconv->QueryInterface(IID_ITfRangeACP, (void **)&cpReconvACP);
    }

    if (cpRangeUserACP && cpReconvACP)
    {
        while (TRUE)
        {
            LONG iStartSelection, iStartReconv, iEndSelection, iEndReconv;
            ULONG startchars, endchars;
            LONG cch;
            WCHAR starttext[g_cSloppySelection+1], endtext[g_cSloppySelection+1];

            // Get start indexs and end offsets.
            cpRangeUserACP->GetExtent(&iStartSelection, &iEndSelection);
            cpReconvACP->GetExtent(&iStartReconv, &iEndReconv);
            // Convert end character positions to absolute values.
            iEndSelection += iStartSelection;
            iEndReconv += iStartReconv;

            if (abs(iStartSelection-iStartReconv) > g_cSloppySelection || 
                abs(iEndSelection-iEndReconv) > g_cSloppySelection)
            {
                // Two much of a mismatch between selection and reconversion range.
                // Do not display widget.
                break;
            }
            if (abs(iStartSelection-iStartReconv) == 0 &&
                abs(iEndSelection - iEndReconv) == 0)
            {
                // Shortcut check.
                *fMatch = TRUE;
                break;
            }

            if (iStartSelection<iStartReconv)
            {
                hr = cpRangeUserACP->GetText(ecReadOnly, 0, starttext, abs(iStartSelection-iStartReconv), &startchars);
            }
            else
            {
                hr = cpReconvACP->GetText(ecReadOnly, 0, starttext, abs(iStartSelection-iStartReconv), &startchars);
            }
            starttext[startchars] = 0;
            if (SUCCEEDED(hr))
            {
                if (iEndSelection<iEndReconv)
                {
                    hr = pRangeReconv->Clone(&cpRangeClone);
                    if (SUCCEEDED(hr))
                    {
                        hr = cpRangeClone->ShiftStart(ecReadOnly, iEndSelection-iStartReconv, &cch, NULL);
                    }
                }
                else
                {
                    hr = pRangeUser->Clone(&cpRangeClone);
                    if (SUCCEEDED(hr))
                    {
                        hr = cpRangeClone->ShiftStart(ecReadOnly, iEndReconv-iStartSelection, &cch, NULL);
                    }
                }
            }
            if (SUCCEEDED(hr))
            {
                hr = cpRangeClone->GetText(ecReadOnly, 0, endtext, abs(iEndSelection-iEndReconv), &endchars);
                endtext[endchars] = 0;

                UINT i;
                if (iStartSelection != iStartReconv)
                {
                    for (i = 0; i < (UINT)abs(iStartReconv-iStartSelection); i++)
                    {
                        if (starttext[i] != L' ')
                        {
                            break;
                        }
                    }
                    if (i != (UINT)abs(iStartReconv-iStartSelection))
                    {
                        break;
                    }
                }
                if (iEndSelection != iEndReconv)
                {
                    for (i = 0; i < (UINT)abs(iEndReconv-iEndSelection); i++)
                    {
                        if (endtext[i] != L' ' && endtext[i] != 13)
                        {
                            // 13 is found when selection hits end of richedit contents.
                            // Range is 1 longer than it should be and contains a carriage return.
                            break;
                        }
                    }
                    if (i != (UINT)abs(iEndReconv-iEndSelection))
                    {
                        break;
                    }
                }

                *fMatch = TRUE;
                break;
            }
            // We failed. We need to exit the loop now.
            break;
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::GetReconversion *
*---------------------------------*
*   Description:
*
*   Returns: HRESULT 
*
*   Args: 
*     TfEditCookie ec
*     ITfCandidateList** ppCandList
*
**************************************************************** agarside ***/

HRESULT CCorrectionIMX::GetReconversion(TfEditCookie ec, ITfCandidateList** ppCandList)
{
    SPDBG_FUNC("CCorrectionIMX::GetReconversion");
    HRESULT hr = E_NOTIMPL;

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::Show *
*----------------------*
*   Description:
*       Shows / hides / and resizes / repositions correction widget window as
*       requested.
*
*   Returns: HRESULT 
*       S_OK  - Everything succeeded.
*       Otherwise, appropriate error code.
*
*   Args: 
*     WINDOWSTATE eWindowState
*       One of 5 enumerations stating requested action.
*
**************************************************************** agarside ***/

HRESULT CCorrectionIMX::Show(WINDOWSTATE eWindowState)
{
    SPDBG_FUNC("CCorrectionIMX::Show");
    HRESULT hr = S_OK;

    m_eWindowState = eWindowState;

    // First update the expanded state flag.
    switch (m_eWindowState)
    {
        case WINDOW_HIDE:
        case WINDOW_SMALL:
        case WINDOW_SMALLSHOW:
        {
            m_fExpanded = FALSE;
            break;
        }
        case WINDOW_LARGE:
        case WINDOW_LARGECLOSE:
        {
            m_fExpanded = TRUE;
            break;
        }
        case WINDOW_REFRESH:
        {
            break;
        }
        default:
        {
            ASSERT("Reached default in CCorrectionIMX::Show" && FALSE);
        }
    }

    // Need to ensure we delete hRgn3 in all cases below where we do not pass it to SetWindowRgn.
    UINT uTop         = m_rcSelection.top + g_uWidgetYOffset; //( m_rcSelection.top + m_rcSelection.bottom - g_uWidgetHeight ) / 2;
    UINT uTopExpanded = m_rcSelection.top + g_uExpandedWidgetYOffset; //( m_rcSelection.top + m_rcSelection.bottom - g_uExpandedWidgetHeight ) / 2;
    if (SUCCEEDED(hr))
    {
        // Now show/hide the window as requested.
        switch (m_eWindowState)
        {
            case WINDOW_HIDE:
            {
                KillTimer(m_hWnd, ID_HIDETIMER);
                KillTimer(m_hWnd, ID_FADETIMER);
                ShowWindow(m_hWnd, SW_HIDE);
                break;
            }
            case WINDOW_SMALLSHOW:
            {
                if (!m_hWnd)
                {
                    LazyInitializeWindow();
                }
                KillTimer(m_hWnd, ID_FADETIMER);
                SetTimer(m_hWnd, ID_HIDETIMER, g_uTimerLength, NULL);
                // Should be same as WINDOW_SMALL
                SetWindowPos(m_hWnd, HWND_TOPMOST, m_rcSelection.left - g_uWidgetWidth, uTop, g_uWidgetWidth, g_uWidgetHeight, SWP_NOACTIVATE);
                // Now show the window in new location.
                ShowWindow(m_hWnd, SW_SHOWNA);
                DrawWidget(g_uAlpha);
                break;
            }
            case WINDOW_SMALL:
            {
                KillTimer(m_hWnd, ID_FADETIMER);
                SetTimer(m_hWnd, ID_HIDETIMER, g_uTimerLength, NULL);
                // Resize and reposition window.
                SetWindowPos(m_hWnd, HWND_TOPMOST, m_rcSelection.left - g_uWidgetWidth, uTop, g_uWidgetWidth, g_uWidgetHeight, SWP_NOACTIVATE);
                // Now we can switch to TRUE layered window drawing.
                DrawWidget(g_uAlpha);
                break;
            }
            case WINDOW_LARGE:
            case WINDOW_LARGECLOSE:
            {
                KillTimer(m_hWnd, ID_FADETIMER);
                KillTimer(m_hWnd, ID_HIDETIMER);
                // Resize and reposition window.
                SetWindowPos(m_hWnd, HWND_TOPMOST, m_rcSelection.left - g_uExpandedWidgetWidth, uTopExpanded, g_uExpandedWidgetWidth, g_uExpandedWidgetHeight, SWP_NOACTIVATE);
                DrawWidget(g_uAlphaLarge);
                break;
            }
            case WINDOW_REFRESH:
            {
                KillTimer(m_hWnd, ID_FADETIMER);
                // Do not kill hide timer here - the window has moved is all that is happening.
                if (m_fExpanded)
                {
                    SetWindowPos(m_hWnd, HWND_TOPMOST, m_rcSelection.left - g_uExpandedWidgetWidth, uTopExpanded, 0, 0, SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);
                }
                else
                {
                    SetWindowPos(m_hWnd, HWND_TOPMOST, m_rcSelection.left - g_uWidgetWidth, uTop, 0, 0, SWP_NOSIZE | SWP_NOACTIVATE);
                }
                break;
            }
            default:
            {
                ASSERT("Reached default in CCorrectionIMX::Show" && FALSE);
                break;
            }
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::WndProc *
*-------------------------*
*   Description:
*       Windows message handling procedure for hidden window.
*
*   Returns: LRESULT CALLBACK 
*       Appropriate return values based on Windows message received.
*
*   Args: 
*     HWND hWnd
*       Handle to hidden window.
*     UINT uMsg
*       Message number.
*     WPARAM wParam
*       Message data.
*     LPARAM lParam
*       Message data.
*
**************************************************************** agarside ***/
/* static */

LRESULT CALLBACK CCorrectionIMX::WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    SPDBG_FUNC("CCorrectionIMX::WndProc");
    static CCorrectionIMX *_this = NULL;

    switch (uMsg)
    {
        case WM_TIMER:
        {
            if (wParam == ID_HIDETIMER)
            {
                KillTimer(_this->m_hWnd, ID_HIDETIMER);
                _this->m_uAlpha = g_uAlpha;
                SetTimer(_this->m_hWnd, ID_FADETIMER, g_uTimerFade, NULL);
            }
            if (wParam == ID_FADETIMER)
            {
                _this->m_uAlpha -= g_uAlphaFade;
                if (_this->m_uAlpha <= 0)
                {
                    KillTimer(_this->m_hWnd, ID_FADETIMER);
                    _this->Show(WINDOW_HIDE);
                }
                else
                {
                    _this->DrawWidget((BYTE)_this->m_uAlpha);
                }
            }
            if (wParam == ID_MOUSELEAVETIMER)
            {
                POINT pt;
                GetCursorPos(&pt);
                ScreenToClient(hWnd, &pt);
                LPARAM lP = MAKELPARAM(pt.x, pt.y);
                PostMessage(hWnd, WM_MOUSEMOVE, 0, lP);
            }
            break;
        }
        case WM_SETCURSOR:
        {
            if (HIWORD(lParam) == WM_LBUTTONDOWN)
            {
                PostMessage(hWnd, WM_USERLBUTTONDOWN, 0, 0);
                return 1;
            }
            if (HIWORD(lParam) == WM_MOUSEMOVE)
            {
                POINT pt;
                GetCursorPos(&pt);
                ScreenToClient(hWnd, &pt);
                LPARAM lP = MAKELPARAM(pt.x, pt.y);
                PostMessage(hWnd, WM_MOUSEMOVE, 0, lP);
            }
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            return 1;
        }
        case WM_NCCREATE:
        {
            _this = (CCorrectionIMX *)(((CREATESTRUCT *)lParam)->lpCreateParams);
            return 1;
        }
        case WM_MOUSEACTIVATE:
        {
            // We are interested in the mouse click but don't want to activate.
            return MA_NOACTIVATE;
        }
        case WM_MOUSEMOVE:
        {
            ::KillTimer(hWnd, ID_MOUSELEAVETIMER);
            int xPos = LOWORD(lParam); 
            int yPos = HIWORD(lParam); 
            if (!_this->m_fExpanded)
            {
                if (xPos > 0 && yPos > 0 && xPos < g_uWidgetWidth && yPos < g_uWidgetHeight)
                {
                    _this->Show(WINDOW_LARGE);
                    ::SetTimer(hWnd, ID_MOUSELEAVETIMER, g_uTimerSloppyMouseLeave, NULL);
                }
            }
            else
            {
                if (xPos < 0 || yPos < 0 || xPos >= g_uExpandedWidgetWidth || yPos >= g_uExpandedWidgetHeight)
                {
                    if (_this->m_eWindowState != WINDOW_LARGECLOSE)
                    {
                        _this->Show(WINDOW_SMALL);
                    }
                }
                else
                {
                    ::SetTimer(hWnd, ID_MOUSELEAVETIMER, g_uTimerSloppyMouseLeave, NULL);
                }
            }
            return 1;
        }
        case WM_USERLBUTTONDOWN:
        {
            HRESULT hr = S_OK;
            CEditSession *pes;

            // Is it within our window if we are the small widget?
            if (_this->m_fExpanded)
            {
                // Need to call this first, but it will reset the m_fExpanded flag.
                if (_this->m_eWindowState == WINDOW_LARGE)
                {
                    _this->Show(WINDOW_LARGECLOSE);

                    if (_this->m_cpRangeReconv)
                    {
                        if (!_this->m_fDisplayAlternatesMyself)
                        {
                            hr = _this->m_cpSysReconv->Reconvert(_this->m_cpRangeReconv);
                        }
                        else
                        {
                            pes = new CEditSession( EditSessionCallback );
                            if (pes) 
                            {
                                pes->_state.u      = ESCB_RECONVERTMYSELF;
                                pes->_state.pv     = _this;
                                pes->_state.wParam = 0;
                                pes->_state.pRange = _this->m_cpRangeReconv;
                                pes->_state.pic    = _this->GetIC();

                                pes->_state.pic->RequestEditSession( _this->GetId(), pes, TF_ES_ASYNC | TF_ES_READWRITE, &hr);

                                pes->Release();
                            }
                        }
                    }
                }
                else
                {
                    // Send escape character which by design, causes candidate UI to close :-).
                    INPUT escape[2];
                    escape[0].type = INPUT_KEYBOARD;
                    escape[0].ki.wVk = 0;
                    escape[0].ki.wScan = 27;
                    escape[0].ki.dwFlags = KEYEVENTF_UNICODE;
                    escape[1] = escape[0];
                    escape[1].ki.dwFlags = KEYEVENTF_UNICODE | KEYEVENTF_KEYUP;
                    SendInput(2, escape, sizeof(escape[0]));
                }
            }
            else
            {
                return DefWindowProc(hWnd, uMsg, wParam, lParam);
            }

            return 1;
        }
    }
    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

/****************************************************************************
* CCorrectionIMX::UpdateWidgetLocation *
*--------------------------------------*
*   Description:
*       Queries Cicero for the location of the selected text in order to
*       position the widget appropriately. The selection is adjusted when the
*       last the right edge of the document and the selection ends just to the
*       left of the next word on the next line of the document. In this case,
*       we want to display the widget at the right side of the document on the
*       first line so we remove all trailing spaces to find this position.
*
*   Returns: HRESULT
*       S_OK  - Everything succeeded.
*       Otherwise, appropriate error code.
*
*   Args: 
*     void
*
**************************************************************** agarside ***/
HRESULT CCorrectionIMX::UpdateWidgetLocation(TfEditCookie ec)
{
    SPDBG_FUNC("CCorrectionIMX::UpdateWidgetLocation");
    HRESULT hr = S_OK;
    if (m_cpRangeWord)
    {
        CComPtr<ITfRange> cpCollapsedRange;
        hr = m_cpRangeWord->Clone(&cpCollapsedRange);
        if (SUCCEEDED(hr))
        {
            hr = cpCollapsedRange->Collapse(ec, TF_ANCHOR_START);
        }
        BOOL fClipped = FALSE;
        if (SUCCEEDED(hr))
        {
            hr = GetTextExtInActiveView(ec, cpCollapsedRange, &m_rcSelection, &fClipped);
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}
/****************************************************************************
* CCorrectionIMX::EditSessionCallback *
*-------------------------------------*
*   Description:
*       Called by Cicero when a request for an edit session has been granted.
*
*   Returns: HRESULT 
*       S_OK  - Everything succeeded.
*       Otherwise, appropriate error code.
*
*   Args: 
*     TfEditCookie ec
*       Appropriate edit cookie as requested.
*     CEditSession *pes
*       Object containing data and pointers supplied when edit session was requested.
*
**************************************************************** agarside ***/
/* static */

HRESULT CCorrectionIMX::EditSessionCallback(TfEditCookie ec, CEditSession *pes)
{
    SPDBG_FUNC("CCorrectionIMX::EditSessionCallback");
    HRESULT hr = S_OK;
    CCorrectionIMX *_this = (CCorrectionIMX *)pes->_state.pv;
    
    switch (pes->_state.u)
    {
        case ESCB_RESETTARGETPOS: 
        {
            if (_this->m_cpRangeWord)
            {
                // Find new location of selection (range)
                hr = _this->UpdateWidgetLocation(ec);
                if (SUCCEEDED(hr))
                {
                    // Reposition correction widget without resizing.
                    hr = _this->Show(WINDOW_REFRESH);
                }
            }
            break;
        }

        case ESCB_RECONVERTMYSELF:
        {
            CComPtr<ITfCandidateList> cpCandList;
            WCHAR wzText[MAX_PATH];
            WCHAR wzWord[MAX_PATH];
            WCHAR *wzTmp;
            ULONG cchTotal;
            LANGID langid = GetUserDefaultLangID(); // BUGBUG - How should we get this value?

            CCandidateList *pCandList = new CCandidateList(CCorrectionIMX::SetResult, pes->_state.pic, pes->_state.pRange, CCorrectionIMX::SetOptionResult);
            if (NULL == pCandList)
            {
                hr = E_OUTOFMEMORY;
            }
            if (SUCCEEDED(hr))
            {
                hr = SetSelectionSimple(ec, pes->_state.pic, pes->_state.pRange);
            }
            if (SUCCEEDED(hr))
            {
                cchTotal = 0;
                hr = pes->_state.pRange->GetText(ec, 0, wzText, ARRAYSIZE(wzText)-1, &cchTotal);
                wzText[cchTotal] = 0;

                // Space strip word without altering contents of wzText as we use this later on.
                wzTmp = wzText;
                while (*wzTmp == ' ')
                {
                    wzTmp++;
                    cchTotal--;
                }
                wcscpy(wzWord, wzTmp);

                while (cchTotal > 1 && wzWord[cchTotal-1] == ' ')
                {
                    cchTotal--;
                    wzWord[cchTotal] = 0;
                }
            }
            if (SUCCEEDED(hr))
            {
                if (cchTotal > 0)
                {
                    // Toggle case of first letter.
                    WCHAR wzTmp[2];
                    wzTmp[0] = wzText[0];
                    wzTmp[1] = 0;
                    _wcslwr(wzTmp);
                    if (wzTmp[0] == wzText[0])
                    {
                        _wcsupr(wzTmp);
                    }
                    
                    if (SUCCEEDED(hr) && wzText[0] != wzTmp[0])
                    {
                        wzText[0] = wzTmp[0];
                        hr = pCandList->AddString(wzText, langid, (void **)_this, NULL, NULL, 0);
                    }
                }
            }
            if (SUCCEEDED(hr))
            {
                HRESULT tmpHr = _this->IsWordInDictionary(wzWord);
                if ( tmpHr == S_FALSE )
                {
                    CComBSTR cpbstr;
                    cpbstr.Append(_this->m_wszAddPrefix);
                    cpbstr.Append(wzWord);
                    cpbstr.Append(_this->m_wszAddPostfix);
                    hr = pCandList->AddOption(cpbstr, langid, (void **)_this, NULL, NULL, 0, NULL, wzWord);
                }
            }
            if (SUCCEEDED(hr))
            {
                HICON hDeleteIcon = LoadIcon(GetSpgrmrInstance(), MAKEINTRESOURCE(IDI_SPTIP_DELETEICON));
                                             
                hr = pCandList->AddOption(_this->m_wszDelete, langid, (void **)_this, NULL, NULL, 2, hDeleteIcon, NULL);
            }
            if (SUCCEEDED(hr))
            {
                hr = pCandList->QueryInterface(IID_ITfCandidateList, (void **)&cpCandList);
            }
            if (SUCCEEDED(hr))
            {
                hr = _this->ShowCandidateList(ec, pes->_state.pic, pes->_state.pRange, cpCandList);
            }
            if (pCandList)
            {
                pCandList->Release();
            }
            break;
        }
        case ESCB_INJECTALTERNATETEXT:
        {
            CComPtr<ITfRange> cpInsertionPoint;

            hr = GetSelectionSimple(ec, pes->_state.pic, &cpInsertionPoint);
            cpInsertionPoint->SetText(ec, 0, (BSTR)pes->_state.wParam, -1);

            cpInsertionPoint->Collapse(ec, TF_ANCHOR_END);
            SetSelectionSimple(ec, pes->_state.pic, cpInsertionPoint);

            SysFreeString((BSTR)pes->_state.wParam);
            break;
        }
    }
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::IsWordInDictionary *
*------------------------------------*
*   Description:
*
*   Returns: HRESULT 
*
*   Args: 
*     WCHAR *pwzWord
*
**************************************************************** agarside ***/

HRESULT CCorrectionIMX::IsWordInDictionary(WCHAR *pwzWord)
{
    SPDBG_FUNC("CCorrectionIMX::IsWordInDictionary");
    HRESULT hr = S_OK;

	// here we should query the speech user dictionary.
    if (!m_cpLexicon)
    {
        hr = m_cpLexicon.CoCreateInstance(CLSID_SpLexicon);
    }
    if (SUCCEEDED(hr) && m_cpLexicon)
    {
        SPWORDPRONUNCIATIONLIST spwordpronlist; 
        memset(&spwordpronlist, 0, sizeof(spwordpronlist)); 

        // Find out status of word in lexicon.
        hr = m_cpLexicon->GetPronunciations(pwzWord, 0x409, eLEXTYPE_USER | eLEXTYPE_APP, &spwordpronlist);

        if (hr == SPERR_NOT_IN_LEX)
        {
            hr = S_FALSE;
        }
        else if (hr == SP_WORD_EXISTS_WITHOUT_PRONUNCIATION)
        {
			hr = S_OK;
		}

        //free all the buffers
        CoTaskMemFree(spwordpronlist.pvBuffer);
    }
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::AddWordToDictionary *
*-------------------------------------*
*   Description:
*
*   Returns: HRESULT 
*
*   Args: 
*     WCHAR *pwzWord
*
**************************************************************** agarside ***/

HRESULT CCorrectionIMX::AddWordToDictionary(WCHAR *pwzWord)
{
    SPDBG_FUNC("CCorrectionIMX::AddWordToDictionary");
    HRESULT hr = S_OK;

	if (m_cpLexicon) 
    {
        // Add in unknown pronciation.
        hr = m_cpLexicon->AddPronunciation(pwzWord, 0x409, SPPS_Unknown, NULL);
    }
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::RemoveWordFromDictionary *
*------------------------------------------*
*   Description:
*
*   Returns: HRESULT 
*
*   Args: 
*     WCHAR *pwzWord
*
**************************************************************** agarside ***/

HRESULT CCorrectionIMX::RemoveWordFromDictionary(WCHAR *pwzWord)
{
    SPDBG_FUNC("CCorrectionIMX::RemoveWordFromDictionary");
    HRESULT hr = S_OK;

	if (m_cpLexicon) 
    {
        // Since the last paremeter is NULL here, all instances of the word are removed.
    	hr = m_cpLexicon->RemovePronunciation(pwzWord, 0x409, SPPS_Unknown, NULL);

        // IGNORE ERRORS DELIBERATELY HERE.
        ASSERT("Unexpected error trying to clear word in user lexicon." && (SUCCEEDED(hr) || hr == SPERR_NOT_IN_LEX));
        hr = S_OK;
    }
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::ShowCandidateList *
*-----------------------------------*
*   Description:
*
*   Returns: HRESULT 
*
*   Args: 
*     TfEditCookie ec
*     ITfContext *pic
*     ITfRange *pRange
*     ITfCandidateList *pCandList
*
**************************************************************** agarside ***/

HRESULT CCorrectionIMX::ShowCandidateList(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfCandidateList *pCandList)
{
    SPDBG_FUNC("CCorrectionIMX::ShowCandidateList");
    HRESULT hr = S_OK;
    CComPtr<ITfDocumentMgr> cpdim;

    // Create candidate object if necessary. Use previously created object if we have it.
    if (m_cpCandUIEx == NULL)
    {
        hr = m_cpCandUIEx.CoCreateInstance(CLSID_TFCandidateUI);
    }
    if (SUCCEEDED(hr))
    {
        hr = pic->GetDocumentMgr(&cpdim);
    }
    if (SUCCEEDED(hr))
    {
        m_cpCandUIEx->SetClientId(GetId());
    }
    if (SUCCEEDED(hr))
    {
        hr = m_cpCandUIEx->SetCandidateList(pCandList);
    }

    if (SUCCEEDED(hr))
    {
        hr = m_cpCandUIEx->OpenCandidateUI(NULL, cpdim, ec, pRange);
    }

    return S_OK;
}

/****************************************************************************
* CCorrectionIMX::SetResult *
*---------------------------*
*   Description:
*
*   Returns: HRESULT 
*
*   Args: 
*     ITfContext *pic
*     ITfRange *pRange
*     CCandidateString *pCand
*     TfCandidateResult imcr
*
**************************************************************** agarside ***/

HRESULT CCorrectionIMX::SetResult(ITfContext *pic, ITfRange *pRange, CCandidateString *pCand, TfCandidateResult imcr)
{
    SPDBG_FUNC("CCorrectionIMX::SetResult");
    BSTR bstr;
    CCorrectionIMX *_this = (CCorrectionIMX *)pCand->_pv;
    HRESULT hr = S_OK;
	CEditSession *pes = NULL;

    if (imcr == CAND_FINALIZED)
    {
        ULONG ulID = 0;

        pCand->GetID(&ulID);
        switch (ulID)
        {
            case 0: // Reverse capitalized choice.
            {
                pCand->GetString(&bstr);
                pes = new CEditSession( EditSessionCallback );
                if (pes) 
                {
                    pes->_state.u      = ESCB_INJECTALTERNATETEXT;
                    pes->_state.pv     = _this;
                    pes->_state.wParam = (WPARAM)bstr;
                    pes->_state.pRange = pRange;
                    pes->_state.pic    = pic;
                    pic->RequestEditSession( _this->GetId(), pes, TF_ES_ASYNC | TF_ES_READWRITE, &hr);
                    pes->Release();
                    hr = S_OK;
                    // Do not return errors from this function or Cicero will disable the tip.
                }
                // Do not call SysFreeString - called inside edit session.
                break;
            }
            // BUGBUG - Need to handle words starting with non-alphabetic characters better.
        }
    }

    // close candidate UI if it's still there
    if (imcr == CAND_FINALIZED || imcr == CAND_CANCELED)
    {
        if (_this->m_cpCandUIEx)
        {
            _this->m_cpCandUIEx->CloseCandidateUI();
        }
    }
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::SetOptionResult *
*---------------------------------*
*   Description:
*
*   Returns: HRESULT 
*
*   Args: 
*     ITfContext *pic
*     ITfRange *pRange
*     CCandidateString *pCand
*     TfCandidateResult imcr
*
**************************************************************** agarside ***/

HRESULT CCorrectionIMX::SetOptionResult(ITfContext *pic, ITfRange *pRange, CCandidateString *pCand, TfCandidateResult imcr)
{
    SPDBG_FUNC("CCorrectionIMX::SetOptionResult");
    BSTR bstr;
    CCorrectionIMX *_this = (CCorrectionIMX *)pCand->_pv;
    HRESULT hr = S_OK;
	CEditSession *pes = NULL;

    if (imcr == CAND_FINALIZED)
    {
        ULONG ulID = 0;

        pCand->GetID(&ulID);
        switch (ulID)
        {
            case 0: // Add to dictinary...
            {
                if (SUCCEEDED(pCand->GetWord(&bstr)))
                {
                    _this->AddWordToDictionary(bstr);
                    SysFreeString(bstr);
                }
                break;
            }

#ifdef ENABLEDELETE
            case 1: // Delete from dictinary...
            {
                if (SUCCEEDED(pCand->GetWord(&bstr)))
                {
                    _this->RemoveWordFromDictionary(bstr);
                    SysFreeString(bstr);
                }
                break;
#endif

            case 2: // Delete
            {
                bstr = SysAllocString(L"");
                pes = new CEditSession( EditSessionCallback );
                if (pes) 
                {
                    pes->_state.u      = ESCB_INJECTALTERNATETEXT;
                    pes->_state.pv     = _this;
                    pes->_state.wParam = (WPARAM)bstr;
                    pes->_state.pRange = pRange;
                    pes->_state.pic    = pic;
                    pic->RequestEditSession( _this->GetId(), pes, TF_ES_ASYNC | TF_ES_READWRITE, &hr);
                    pes->Release();
                    hr = S_OK;
                }
                break;
            }
        }
    }

    // close candidate UI if it's still there
    if (imcr == CAND_FINALIZED || imcr == CAND_CANCELED)
    {
        if (_this->m_cpCandUIEx)
        {
            _this->m_cpCandUIEx->CloseCandidateUI();
        }
    }
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::ICCallback *
*----------------------------*
*   Description:
*       Called by Cicero when changes happen to the DIM with focus.
*       We need to listen to this so we can hide the widget on a focus change within an app. 
*       (e.g. two instances of Microsoft Word windows)
*
*   Returns: HRESULT 
*       S_OK  - Everything succeeded.
*       Otherwise, appropriate error code.
*
*   Args: 
*     UINT uCode
*       Code specifying change to IC.
*     ITfDicumentMgr *pdim
*     ITfDicumentMgr *pdimPrevFocus
*     void *pv
*
**************************************************************** agarside ***/
/* static */

HRESULT CCorrectionIMX::DIMCallback(UINT uCode, ITfDocumentMgr *pdim, ITfDocumentMgr *pdimPrevFocus, void *pv)
{
    SPDBG_FUNC("CCorrectionIMX::DIMCallback");
    HRESULT hr = S_OK;
    CCorrectionIMX *_this = (CCorrectionIMX *)pv;
    CComPtr<ITfSource> cpSource;

    switch (uCode)
    {
        case TIM_CODE_SETFOCUS:
        {
            hr = _this->Show(WINDOW_HIDE);
            break;
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::ICCallback *
*----------------------------*
*   Description:
*       Called by Cicero when changes happen to an input context.
*       We need to listen to this so we can hook up to edit and layout changes.
*
*   Returns: HRESULT 
*       S_OK  - Everything succeeded.
*       Otherwise, appropriate error code.
*
*   Args: 
*     UINT uCode
*       Code specifying change to IC.
*     ITfContext *pic
*       Interface for the affected IC.
*     void *pv
*       Pointer for change - specific data.
*       We don't use this.
*
**************************************************************** agarside ***/
/* static */

HRESULT CCorrectionIMX::ICCallback(UINT uCode, ITfContext *pic, void *pv)
{
    SPDBG_FUNC("CCorrectionIMX::ICCallback");
    HRESULT hr = S_OK;
    CCorrectionIMX *_this = (CCorrectionIMX *)pv;
    CComPtr<ITfSource> cpSource;
    CICPriv *priv = NULL;

    switch (uCode)
    {
        case TIM_CODE_INITIC:
        {
            if ((priv = GetInputContextPriv(_this->GetId(), pic)) == NULL)
			{
               break;
			}
			_this->InitICPriv(_this->GetId(), priv, pic);

            _this->IsCandidateObjectOpen(pic, &_this->m_fCandidateOpen);
            if (_this->m_fCandidateOpen)
            {
                _this->Show(WINDOW_LARGECLOSE);
            }
            break;
        }

        case TIM_CODE_UNINITIC:
        {
            if ((priv = GetInputContextPriv(_this->GetId(), pic)) == NULL)
			{
                break;
			}
			_this->DeleteICPriv(priv, pic);

            BOOL fOpen;
            _this->IsCandidateObjectOpen(pic, &fOpen);
            if (fOpen)
            {
                _this->m_fCandidateOpen = FALSE;
                // If widget is in LARGECLOSE state, must close it here.
                _this->Show(WINDOW_HIDE);
            }
            break;
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::InitICPriv *
*----------------------------*
*   Description:
*
*   Returns: HRESULT 
*
*   Args: 
*     TfClientId tid
*     CICPriv *priv
*     ITfContext *pic
*
**************************************************************** agarside ***/

HRESULT CCorrectionIMX::InitICPriv(TfClientId tid, CICPriv *priv, ITfContext *pic)
{
    CComPtr<ITfSource> cpSource;
	HRESULT hr = S_OK;

    priv->_tid = tid;
    priv->_pic = pic; // not AddRef'd, this struct is contained in life of the pic

    hr = pic->QueryInterface(IID_ITfSource, (void **)&cpSource);
    if (cpSource)
    {
        hr = cpSource->AdviseSink(IID_ITfTextEditSink, (ITfTextEditSink *)this, &priv->m_dwEditCookie);
        if (SUCCEEDED(hr))
        {
            hr = cpSource->AdviseSink(IID_ITfTextLayoutSink, (ITfTextLayoutSink *)this, &priv->m_dwLayoutCookie);
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
	return hr;
}

/****************************************************************************
* CCorrectionIMX::DeleteICPriv *
*------------------------------*
*   Description:
*
*   Returns: HRESULT 
*
*   Args: 
*     CICPriv *picp
*     ITfContext *pic
*
**************************************************************** agarside ***/

HRESULT CCorrectionIMX::DeleteICPriv(CICPriv *picp, ITfContext *pic)
{
    CComPtr<ITfSource> cpSource;
	HRESULT hr = S_OK;

    if (!picp)
	{
        return E_FAIL;
	}

    hr = pic->QueryInterface(IID_ITfSource, (void **)&cpSource);
	if (SUCCEEDED(hr))
    {
        cpSource->UnadviseSink(picp->m_dwEditCookie);
        cpSource->UnadviseSink(picp->m_dwLayoutCookie);
    }

    // we MUST clear out the private data before cicero is free 
    // to release the ic
    ClearCompartment(GetId(), pic, GUID_IC_PRIVATE, FALSE);

    SPDBG_REPORT_ON_FAIL(hr);
	return hr;
}

//+---------------------------------------------------------------------------
//
// CreateInstance
//
// This is our internal object creator.  We only call this method
// when creating a wrapper for a specific tip, or when an app
// uses TF_CreateThreadMgr.  Never from CoCreateInstance.
//----------------------------------------------------------------------------

/* static */
HRESULT 
CCorrectionIMX::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    return _CreatorClass::CreateInstance(pUnkOuter, riid, ppvObj);
}

#endif // SUPPORT_INTERNAL_WIDGET
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\editsess.h ===
// editsess.h
//
// Edit Session classes declaration
//
#ifndef EDITSESS_H
#define EDITSESS_H

#include "private.h"
#include "sapilayr.h"
#include "playback.h"
#include "fnrecon.h"
#include "propstor.h"
#include "selword.h"

class CSapiIMX;
class CPlayBack;
class CFnReconversion;
class CPropStoreRecoResultObject;
class CPropStoreLMLattice;
class CSelectWord;

//
// Caller puts all the Edit Session in-paramaters to this structure and pass to _RequestEditSession( ).
//
typedef struct _ESData
{
    void     *pData;     // pData pointer to memory.  its size is uByte of bytes.
    UINT      uByte;     // 
    LONG_PTR  lData1;    // m_lData1 and m_lData2 contain constant data.
    LONG_PTR  lData2;    
    BOOL      fBool;
    ITfRange  *pRange;
    IUnknown  *pUnk;
}  ESDATA;

//
// This is a base class for Sptip edit sessions.
// We don't want to inherit the class from CEditSession in inc\editcb.h which doesn't correctly handle some COM pointer
// and /or allocated memeory pointer.

// We don't change the code in lib\editcb.cpp, since it is used by other TIPs.
//

class CEditSessionBase : public ITfEditSession
{
public:
    CEditSessionBase(ITfContext *pContext);
    virtual ~CEditSessionBase();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ITfEditSession
    virtual STDMETHODIMP DoEditSession(TfEditCookie ec) = 0;

    HRESULT _SetEditSessionData(UINT m_idEditSession, void *pData, UINT uBytes, LONG_PTR lData1 = 0, LONG_PTR lData2=0, BOOL fBool = FALSE);

    void  _SetRange(ITfRange *pRange) {  m_cpRange = pRange; }
    void  _SetUnk(IUnknown *punk)     { m_cpunk = punk; }

    ITfRange *_GetRange( )   { return m_cpRange; }
    IUnknown *_GetUnk( )     { return m_cpunk; }
    void     *_GetPtrData( ) { return m_pData; }
    LONG_PTR  _GetData1( )   { return m_lData1; }
    LONG_PTR  _GetData2( )   { return m_lData2; }
    BOOL      _GetBool( )    { return m_fBool; }

    LONG_PTR  _GetRetData( ) { return m_lRetData; }
    IUnknown *_GetRetUnknown( )
    { 
        IUnknown *pUnk = NULL;

        pUnk = m_cpRetUnk;

        if ( pUnk )
            pUnk->AddRef( );

        return pUnk;
    }

    UINT                m_idEditSession;
    CComPtr<ITfContext> m_cpic;

    // Keep the return data for this edit session.
    LONG_PTR            m_lRetData;
    CComPtr<IUnknown>   m_cpRetUnk;

private:
    // Data passed by caller to request a edit session.
    void               *m_pData;     // pData pointer to memory.  its size is uByte of bytes.
    LONG_PTR            m_lData1;    // m_lData1 and m_lData2 contain constant data.
    LONG_PTR            m_lData2;    
    BOOL                m_fBool;
    CComPtr<ITfRange>   m_cpRange;
    CComPtr<IUnknown>   m_cpunk;     // keep any COM pointer.

    LONG _cRef;     // COM ref count
};

//
// Edit Session for CSapiIMX.
//
class CSapiEditSession : public CEditSessionBase
{
public:
    CSapiEditSession(CSapiIMX *pimx, ITfContext *pContext);
    virtual ~CSapiEditSession( );

    STDMETHODIMP DoEditSession(TfEditCookie ec); 

private:
 
    CSapiIMX           *m_pimx;            
};

//
// Edit Session for CSelectWord:  Selection related commands
//
class CSelWordEditSession : public CSapiEditSession
{
public:
    CSelWordEditSession(CSapiIMX *pimx, CSelectWord *pSelWord, ITfContext *pContext);
    virtual ~CSelWordEditSession( );

    STDMETHODIMP DoEditSession(TfEditCookie ec); 

    void _SetUnk2(IUnknown *cpunk)  { m_cpunk2 = cpunk; };
    IUnknown *_GetUnk2( ) { return m_cpunk2; };

    LONG_PTR _GetLenXXX( )  { return m_ulLenXXX; }
    void  _SetLenXXX( LONG_PTR ulLenXXX ) { m_ulLenXXX = ulLenXXX; }
    
private:

    CComPtr<IUnknown>     m_cpunk2;
    LONG_PTR              m_ulLenXXX;   // the charnum of XXX part for "Select XXX through YYY" command.
    CSelectWord           *m_pSelWord;
};

//
// Edit Session for PlayBack
//
class CPlayBackEditSession : public CEditSessionBase
{
public:
    CPlayBackEditSession(CSapiPlayBack *pPlayBack, ITfContext *pContext);
    virtual ~CPlayBackEditSession( );

    STDMETHODIMP DoEditSession(TfEditCookie ec); 

private:
 
    CSapiPlayBack           *m_pPlayBack;            
};


//
// Edit Session for Reconversion
//
class CFnRecvEditSession : public CEditSessionBase
{
public:
    CFnRecvEditSession(CFnReconversion *pFnRecv, ITfRange *pRange, ITfContext *pContext);
    virtual ~CFnRecvEditSession( );

    STDMETHODIMP DoEditSession(TfEditCookie ec); 

private:
 
    CFnReconversion           *m_pFnRecv;            
};

//
// Edit Session for CPropStoreRecoResultObject
//
class CPSRecoEditSession : public CEditSessionBase
{
public:
    CPSRecoEditSession(CPropStoreRecoResultObject *pPropStoreReco, ITfRange *pRange, ITfContext *pContext);
    virtual ~CPSRecoEditSession( );

    STDMETHODIMP DoEditSession(TfEditCookie ec); 

private:
 
    CPropStoreRecoResultObject   *m_pPropStoreReco;            
};


//
// Edit Session for CPropStoreLMLattice
//
class CPSLMEditSession : public CEditSessionBase
{
public:
    CPSLMEditSession(CPropStoreLMLattice *pPropStoreLM, ITfRange *pRange, ITfContext *pContext);
    virtual ~CPSLMEditSession( );

    STDMETHODIMP DoEditSession(TfEditCookie ec); 

private:
 
    CPropStoreLMLattice           *m_pPropStoreLM;            
};

#endif // EDITSESS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\globals.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       globals.cpp
//
//  Contents:   Global variables.
//
//----------------------------------------------------------------------------

#include "private.h"
#include "initguid.h"
#include "mscandui.h"
#include "globals.h"

HINSTANCE g_hInst = NULL;
HINSTANCE g_hInstSpgrmr = NULL;

// used by COM server
HINSTANCE GetServerHINSTANCE(void)
{
    return g_hInst;
}

DWORD g_dwTlsIndex = -1;

CCicCriticalSectionStatic g_cs;

// for combase
CRITICAL_SECTION *GetServerCritSec(void)
{
    return g_cs;
}

//custom property:a414addd-3982-40d5-a664-d4f5de039305 
const GUID GUID_PROP_SAPIRESULTOBJECT = {
    0xa414addd,
    0x3982,
    0x40d5,
    { 0xa6, 0x64, 0xd4, 0xf5, 0xde, 0x03, 0x93, 0x05}
};


/* 46b283a4-4a22-4ced-8ff4-7814cac68e3c */
const GUID GUID_PROP_SAPI_DISPATTR = {
    0x46b283a4,
    0x4a22,
    0x4ced,
    {0x8f, 0xf4, 0x78, 0x14, 0xca, 0xc6, 0x8e, 0x3c}
  };

/* 48a9d381-06eb-4839-a50b-19703269587a */
const GUID GUID_ATTR_SAPI_INPUT = { 
    0x48a9d381,
    0x06eb,
    0x4839,
    {0xa5, 0x0b, 0x19, 0x70, 0x32, 0x69, 0x58, 0x7a}
  };
  
const GUID GUID_ATTR_SAPI_GREENBAR = {
    0x82e6d2c0,
    0x6028,
    0x11d3,
    {0xb5, 0xd6, 0x00, 0xc0, 0x4f, 0xc3, 0x24, 0xa1}
};

const GUID GUID_ATTR_SAPI_GREENBAR2 = {
    0xc3a9e2e8,
    0x738c,
    0x48e0,
    {0xac, 0xc8, 0x43, 0xee, 0xfa, 0xbf, 0x83, 0xc8}
};

const GUID GUID_ATTR_SAPI_REDBAR = {
    0xb1ec93ca,
    0x6028,
    0x11d3,
    {0xb5, 0xd6, 0x00, 0xc0, 0x4f, 0xc3, 0x24, 0xa1}
};

const GUID GUID_ATTR_SAPI_SELECTION = { 
    0xb3c0ef25,
    0xa12f,
    0x4b0e,
    {0xa9, 0x8f, 0x11, 0x63, 0x11, 0xb3, 0xd6, 0x81}
};

/* A91DF761-C6F0-4E12-922A-7E24BFEBFF20 */
const GUID GUID_IC_PRIVATE = { 
    0xA91DF761,
    0xC6F0,
    0x4E12,
    {0x92, 0x2A, 0x7E, 0x24, 0xBF, 0xEB, 0xFF, 0x20}
  };

/* 536402D1-26EA-4024-B890-1004CAE3C1BE */
const GUID GUID_COMPARTMENT_SPEECHPRIV_REFCNT = {
    0x536402D1,
    0x26EA,
    0x4024,
    {0xB8, 0x90, 0x10, 0x04, 0xCA, 0xE3, 0xC1, 0xBE}
};

/* 2f1e5e65-67db-4dbd-b793-7d8d07df248c */
const GUID GUID_COMPARTMENT_SPEECH_LEARNDOC = {
    0x2f1e5e65,
    0x67db,
    0x4dbd,
    {0xb7, 0x93, 0x7d, 0x8d, 0x07, 0xdf, 0x24, 0x8c }
};

/* cd7e8074-9ef6-4298-b76e-bfa9aca40e3b */
const GUID GUID_COMPARTMENT_TTS_STATUS = {
    0xcd7e8074,
    0x9ef6,
    0x4298,
    {0xb7, 0x6e, 0xbf, 0xa9, 0xac, 0xa4, 0x0e, 0x3b}
};

/* e9cee003-2d38-42da-8cb5-e16c3483f8c4 */
const GUID GUID_HOTKEY_TTS_PLAY_STOP = {
    0xe9cee003,
    0x2d38,
    0x42da,
    {0x8c, 0xb5, 0xe1, 0x6c, 0x34, 0x83, 0xf8, 0xc4}
};

/* 1dcadf31-a8e7-49eb-a255-512c9fa9365b */
const GUID GUID_HOTKEY_MODE_DICTATION = {
    0x1dcadf31,
    0xa8e7,
    0x49eb,
    {0xa2, 0x55, 0x51, 0x2c, 0x9f, 0xa9, 0x36, 0x5b}
};

/* a41656ec-a369-4aec-a5bc-769c3d32ccaf */
const GUID GUID_HOTKEY_MODE_COMMAND = {
    0xa41656ec,
    0xa369,
    0x4aec,
    {0xa5, 0xbc, 0x76, 0x9c, 0x3d, 0x32, 0xcc, 0xaf}
};

/* c1a1554f-b715-48e1-921f-716fd7332ce9 */
const GUID GUID_COMPARTMENT_SHARED_BLN_TEXT = {
    0xc1a1554f,
    0xb715,
    0x48e1,
    {0x92, 0x1f, 0x71, 0x6f, 0xd7, 0x33, 0x2c, 0xe9}
};

/* 574e41bb-1bf4-4630-95dd-b143372ac8d0 */
const GUID  GUID_COMPARTMENT_SPEECHUISHOWN = {
    0x574e41bb,
    0x1bf4,
    0x4630,
    {0x95, 0xdd, 0xb1, 0x43, 0x37, 0x2a, 0xc8, 0xd0}
  };

// TABLETPC

/* e7912cf8-5f71-4483-bcb8-fd87de9168e3 */
const GUID GUID_COMPARTMENT_SPEECH_STAGE =       { 
    0xe7912cf8, 
    0x5f71, 
    0x4483, 
    {0xbc, 0xb8, 0xfd, 0x87, 0xde, 0x91, 0x68, 0xe3 } 
};

/* 8d5ee345-e891-4184-8baf-e201c8c6903a */
const GUID GUID_COMPARTMENT_SPEECH_STAGECHANGE = { 
    0x8d5ee345, 
    0xe891, 
    0x4184, 
    {0x8b, 0xaf, 0xe2, 0x01, 0xc8, 0xc6, 0x90, 0x3a } 
};

// {B2B398FC-35AC-4cec-9BE8-F4EFD1738CF3}
const GUID GUID_COMPARTMENT_SPEECH_STAGEDICTATION = {
    0xb2b398fc, 
    0x35ac, 
    0x4cec, 
    {0x9b, 0xe8, 0xf4, 0xef, 0xd1, 0x73, 0x8c, 0xf3 } 
};

// {054AAE20-4BEA-4347-8A35-64A533254A9D}
const GUID CLSID_UIHost = {
    0x054AAE20,
    0x4BEA,
    0x4347,
    { 0x8A,0x35,0x64,0xA5,0x33,0x25,0x4A,0x9D }
};
// END TABLETPC

/* 772ce27f-8c06-4170-a75a-dd4c3103cce2 */
const GUID GUID_COMPARTMENT_SPEECH_PROPERTY_CHANGE = {
    0x772ce27f,
    0x8c06,
    0x4170,
    {0xa7, 0x5a, 0xdd, 0x4c, 0x31, 0x03, 0xcc, 0xe2}
};

/* E7BA80B1-71E6-4EF0-A429-2599A25973FA */
const GUID CLSID_SpPropertyPage = {
    0xE7BA80B1,
    0x71E6,
    0x4EF0,
    {0xA4, 0x29, 0x25, 0x99, 0xA2, 0x59, 0x73, 0xFA}
};


// widget stuff

// {8613E14C-D0C0-4161-AC0F-1DD2563286BC}
const CLSID CLSID_CorrectionIMX = 
{ 0x8613e14c, 0xd0c0, 0x4161, { 0xac, 0xf, 0x1d, 0xd2, 0x56, 0x32, 0x86, 0xbc } };

// miscs
const LARGE_INTEGER c_li0 = { 0, 0 };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\dictctxt.cpp ===
//
// class implementation of CDictContext 
//
// [2/15/00] created
//
#include "private.h"
#include "globals.h"
#include "dictctxt.h"

//
// ctor/dtor
//
CDictContext::CDictContext(ITfContext *pic, ITfRange *pRange)
{
    Assert(pic);
    Assert(pRange);
    
    m_cpic      = pic;
    m_cpRange   = pRange;
    m_pszText   = NULL;
    m_ulSel     = m_ulStartIP = m_ulCchToFeed = 0;
}

CDictContext::~CDictContext()
{
    if (m_pszText)
    {
        cicMemFree(m_pszText);
    }
}

//
// InitializeContext
//
// synopsis: Get Text around an IP and setup character positions
//
HRESULT CDictContext::InitializeContext(TfEditCookie ecReadOnly)
{
    CComPtr<ITfRange> cpRangeCloned;
    CComPtr<ITfRange> cpRangeEndSel;

    HRESULT hr = m_cpRange->Clone(&cpRangeEndSel);

    if (S_OK == hr)
    {
        // create a range to hold the position of current selection
        hr = cpRangeEndSel->Collapse(ecReadOnly, TF_ANCHOR_END); 
    }
    
    if (S_OK == hr)
    {
        hr = m_cpRange->Clone(&cpRangeCloned);
    }

    if (S_OK == hr)
    {
        // we don't want to go beyond an embedded object
        // (this is assuming that hc is const, which it should be)
        TF_HALTCOND hc = {0};
        hc.dwFlags = TF_HF_OBJECT;

        ULONG ulcch    = 0;
        
        hr = cpRangeCloned->Collapse(ecReadOnly, TF_ANCHOR_START);
        if (S_OK == hr)
        {
            TF_HALTCOND hc2 = {0};
            hc2.pHaltRange = cpRangeEndSel;
            hc2.aHaltPos   = TF_ANCHOR_END;
            //
            // get the # of characters in selection
            //
            long cch = 0;
            hr = cpRangeCloned->ShiftEnd(ecReadOnly, CCH_FEED_POSTIP, &cch, &hc2);
            if (S_OK == hr)
            {
                m_ulSel = ulcch = cch;
            }
        }

        if (S_OK == hr)
        {
            long cch;

            Assert(ulcch <= CCH_FEED_POSTIP);

            hr = cpRangeCloned->ShiftEnd(ecReadOnly, CCH_FEED_POSTIP-ulcch, &cch, &hc);
            if (S_OK == hr)
            {
                ulcch += cch;
            }
        }
        
        if (S_OK == hr)
        {
            long cch;
            // Get the offset of IP
            hr = cpRangeCloned->ShiftStart(ecReadOnly, -CCH_FEED_PREIP, &cch, &hc);
            if (S_OK == hr)
            {
                m_ulStartIP = -cch;
                ulcch += -cch;
            }
        }
        
        if (S_OK == hr)
        {
            if (m_pszText)
            {
                cicMemFree(m_pszText);
            }
            
            // could make it smarter to alloc mem that is absolutely needed?
            m_pszText = (WCHAR *)cicMemAlloc((ulcch + 1)*sizeof(WCHAR));

            if (!m_pszText)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                hr = cpRangeCloned->GetText(ecReadOnly, 0, m_pszText, ulcch, &ulcch);

                // if we can't get text beyond the IP, it is not worth feeding this context
                if (S_OK != hr || ulcch < m_ulStartIP)
                {
                    m_ulCchToFeed = 0;
                    hr = E_FAIL;
                }
                else
                {
                    m_ulCchToFeed = ulcch;
                }
            }
        }
    }
    return hr;
}


//
// FeedContextToGrammar
//
// synopsis: feed this IP context to the given grammar
//
HRESULT CDictContext::FeedContextToGrammar(ISpRecoGrammar *pGram)
{
    HRESULT hr = E_FAIL;
    Assert(pGram);
    
    SPTEXTSELECTIONINFO tsi = {0};

    tsi.ulStartActiveOffset  = 0;
    tsi.cchActiveChars = m_ulCchToFeed;
    tsi.ulStartSelection = m_ulStartIP;
    tsi.cchSelection     = m_ulSel; 

    WCHAR *pMemText = (WCHAR *)cicMemAlloc((m_ulCchToFeed+2)*sizeof(WCHAR));

    if (pMemText)
    {
        if (m_ulCchToFeed > 0 && m_pszText)
            wcsncpy(pMemText, m_pszText, m_ulCchToFeed);

        pMemText[m_ulCchToFeed] = L'\0';
        pMemText[m_ulCchToFeed+1] = L'\0';
#ifdef DEBUG
        {
            TraceMsg(TF_GENERAL, "For SetWordSequenceData: Text=\"%S\" cchActiveChars=%d tsi.ulStartSelection=%d, cchSelection=%d",pMemText,tsi.cchActiveChars, tsi.ulStartSelection, tsi.cchSelection);
        }
#endif
        hr = pGram->SetWordSequenceData(pMemText, m_ulCchToFeed + 2, &tsi);

/*  According to billro, the below code is not necessary.

#ifdef DEBUG
            {
                TraceMsg(TF_GENERAL, "For SetTextSelection: tsi.ulStartSelection = %d",tsi.ulStartSelection);
            }
#endif

            // so Fil told me we need to call SetTextSelection again
            if (S_OK == hr)
                hr = pGram->SetTextSelection(&tsi);
*/

        cicMemFree(pMemText);
    }
    
    return  hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\dictctxt.h ===
//
// dictation context class implementation
//
//
#ifndef _DICTCTXT_H_
#define _DICTCTXT_H_

class CDictContext 
{
public:
    CDictContext(ITfContext *pic, ITfRange *pRange);
    ~CDictContext();

    HRESULT InitializeContext(TfEditCookie ecReadOnly);
    HRESULT FeedContextToGrammar(ISpRecoGrammar *pGram);
private:
    CComPtr<ITfContext> m_cpic;
    CComPtr<ITfRange>   m_cpRange;
    WCHAR              *m_pszText;
    ULONG               m_ulStartIP;
    ULONG               m_ulCchToFeed;
    ULONG               m_ulSel;
};

#define CCH_FEED_PREIP    20
#define CCH_FEED_POSTIP   20

#endif //__DICTCTXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\dictation.cpp ===
//
// Dictation.cpp
//
// This file contains functions related to dictation mode handling.
//
//
// They are moved from sapilayr.cpp


#include "private.h"
#include "globals.h"
#include "sapilayr.h"

const GUID *s_KnownModeBias[] =
{
    &GUID_MODEBIAS_NUMERIC
};


//+---------------------------------------------------------------------------
//
// CSapiIMX::InjectText
//
// synopsis - recieve text from ISpTask and insert it to the current selection
//
//
//----------------------------------------------------------------------------

HRESULT CSapiIMX::InjectText(const WCHAR *pwszRecognized, LANGID langid, ITfContext *pic)
{
    if ( pwszRecognized == NULL )
        return E_INVALIDARG;

    ESDATA  esData;

    memset(&esData, 0, sizeof(ESDATA));
    esData.pData = (void *)pwszRecognized;
    esData.uByte = (wcslen(pwszRecognized)+1) * sizeof(WCHAR);
    esData.lData1 = (LONG_PTR)langid;

    return _RequestEditSession(ESCB_PROCESSTEXT, TF_ES_READWRITE, &esData, pic);
}

//+---------------------------------------------------------------------------
//
// CSapiIMX::InjectTextWithoutOwnerID
//
// synopsis - inject text to the clients doc same way InjectText does but 
//            with GUID_PROP_TEXTOWNER cleared out
//
//
//----------------------------------------------------------------------------
HRESULT 
CSapiIMX::InjectTextWithoutOwnerID(const WCHAR *pwszRecognized, LANGID langid)
{
    if ( pwszRecognized == NULL )
        return E_INVALIDARG;

    ESDATA  esData;

    memset(&esData, 0, sizeof(ESDATA));
    esData.pData = (void *)pwszRecognized;
    esData.uByte = (wcslen(pwszRecognized)+1) * sizeof(WCHAR);
    esData.lData1 = (LONG_PTR)langid;
    
    return _RequestEditSession(ESCB_PROCESSTEXT_NO_OWNERID, TF_ES_READWRITE, &esData);
}

//+---------------------------------------------------------------------------
//
// CSapiIMX::HRESULT InjectSpelledText
//
// synopsis - inject spelled text to the clients doc 
//
//
//----------------------------------------------------------------------------
HRESULT CSapiIMX::InjectSpelledText(WCHAR *pwszText, LANGID langid, BOOL fOwnerId)
{
    if ( pwszText == NULL )
        return E_INVALIDARG;

    ESDATA  esData;

    memset(&esData, 0, sizeof(ESDATA));
    esData.pData = (void *)pwszText;
    esData.uByte = (wcslen(pwszText)+1) * sizeof(WCHAR);
    esData.lData1 = (LONG_PTR)langid;
    esData.fBool = fOwnerId;
    
    return _RequestEditSession(ESCB_INJECT_SPELL_TEXT, TF_ES_READWRITE, &esData);
}

//+---------------------------------------------------------------------------
//
// CSapiIMX::InjectModebiasText
//
// synopsis - recieve ModeBias text from ISpTask and insert it to the current 
// selection
//
//----------------------------------------------------------------------------

HRESULT CSapiIMX::InjectModebiasText(const WCHAR *pwszRecognized, LANGID langid)
{
    if ( pwszRecognized == NULL )
        return E_INVALIDARG;

    ESDATA  esData;

    memset(&esData, 0, sizeof(ESDATA));
    esData.pData = (void *)pwszRecognized;
    esData.uByte = (wcslen(pwszRecognized)+1) * sizeof(WCHAR);
    esData.lData1 = (LONG_PTR)langid;

    return _RequestEditSession(ESCB_PROCESS_MODEBIAS_TEXT, TF_ES_READWRITE, &esData);
}

//+--------------------------------------------------------------------------+
//
// CSapiIMX::_ProcessModebiasText
//
//+--------------------------------------------------------------------------+
HRESULT CSapiIMX::_ProcessModebiasText(TfEditCookie ec, WCHAR *pwszText, LANGID langid, ITfContext *picCaller)
{
    HRESULT hr = E_FAIL;

    ITfContext *pic = NULL;

    if (!picCaller)
    {
        GetFocusIC(&pic);
    }
    else
    {
        pic = picCaller;
    }

    hr = _ProcessTextInternal(ec, pwszText, GUID_ATTR_SAPI_INPUT, langid, pic, FALSE);

    if (picCaller == NULL)
    {
        SafeRelease(pic);
    }

    // Before we clear the saved ip range, we need to treat this current ip as last
    // saved ip range if current ip is selected by end user

    SaveLastUsedIPRange( );
    SaveIPRange(NULL);

    return hr;
}

//+---------------------------------------------------------------------------
//
// CSapiIMX::InjectFeedbackUI
//
// synopsis - insert dotted bar to a doc for the length of cch
//
//
//---------------------------------------------------------------------------+
HRESULT CSapiIMX::InjectFeedbackUI(const GUID attr, LONG cch)
{
    ESDATA  esData;

    memset(&esData, 0, sizeof(ESDATA));
    esData.pData = (void *)&attr;
    esData.uByte = sizeof(GUID);
    esData.lData1 = (LONG_PTR)cch;
    
    return _RequestEditSession(ESCB_FEEDBACKUI, TF_ES_READWRITE, &esData);
}

//+---------------------------------------------------------------------------
//
// CSapiIMX::EraseFeedbackUI
//
// synopsis - cleans up the feedback UI
// GUID - specifies which feedback UI bar to erase
//
//---------------------------------------------------------------------------+
HRESULT CSapiIMX::EraseFeedbackUI()
{
    if ( S_OK == IsActiveThread())
    {
        return _RequestEditSession(ESCB_KILLFEEDBACKUI, TF_ES_ASYNC|TF_ES_READWRITE, NULL);
    }
    return S_OK;
}

//+--------------------------------------------------------------------------+
//
// CSapiIMX::__AddFeedbackUI
//
//+--------------------------------------------------------------------------+
HRESULT CSapiIMX::_AddFeedbackUI(TfEditCookie ec, ColorType ct, LONG cch)
{
    HRESULT hr = E_FAIL;
	ITfContext *pic;

    //
    // distinguish unaware applications from cicero aware apps
    //
    GUID attr = ((ct == DA_COLOR_AWARE) ? GUID_ATTR_SAPI_GREENBAR : GUID_ATTR_SAPI_GREENBAR2);
    
    if (cch > 0)
    {
        WCHAR *pwsz = (WCHAR *)cicMemAlloc((cch + 1)*sizeof(WCHAR));
        if (pwsz)
        {
            for (int i = 0; i < cch; i++ )
                pwsz[i] = L'.';
              
            pwsz[i] = L'\0';

            if (GetFocusIC(&pic))
            {
                // When add feedback UI, we should not change current doc's reco result property store
                // so set fPreserveResult as TRUE.
                // Only when the final text is injected to the document, the property store will be 
                // updated.

                hr =  _ProcessTextInternal(ec, pwsz, attr, GetUserDefaultLangID(), pic, TRUE);
                SafeRelease(pic);
			}
            cicMemFree(pwsz);
        }
    }

    return hr;
}

//+--------------------------------------------------------------------------+
//
// CSapiIMX::_ProcessText
//
//+--------------------------------------------------------------------------+
HRESULT CSapiIMX::_ProcessText(TfEditCookie ec, WCHAR *pwszText, LANGID langid, ITfContext *picCaller)
{
    HRESULT hr = E_FAIL;

    ITfContext *pic = NULL;

    if (!picCaller)
	{
        GetFocusIC(&pic);
    }
    else
    {
        pic = picCaller;
    }

    hr = _ProcessTextInternal(ec, pwszText, GUID_ATTR_SAPI_INPUT, langid, pic, FALSE);

    if (picCaller == NULL)
    {
        SafeRelease(pic);
    }
	return hr;
}

//+--------------------------------------------------------------------------+
//
// CSapiIMX::_ProcessTextInternal
//
// common lower level routine for injecting text to docuement
//
//+--------------------------------------------------------------------------+
HRESULT CSapiIMX::_ProcessTextInternal(TfEditCookie ec, WCHAR *pwszText, GUID input_attr, LANGID langid, ITfContext *pic, BOOL fPreserveResult, BOOL fSpelling)
{
    HRESULT       hr = E_FAIL;

    if (pic)
    {
        BOOL       fPureCiceroIC;

        fPureCiceroIC = _IsPureCiceroIC(pic);

        CDocStatus ds(pic);
        if (ds.IsReadOnly())
           return S_OK;

        _fEditing = TRUE;

        // here we compare if the current selection is
        // equal to the saved IP range. If they are equal,
        // it means that the user has not moved the IP since
        // the first hypothesis arrived. In this case we'll
        // update the selection after injecting text, and
        // invalidate the saved IP.
        //
        BOOL         fIPIsSelection = FALSE; // by default
        CComPtr<ITfRange> cpInsertionPoint;

        if ( cpInsertionPoint = GetSavedIP( ) )
        {
            // this is trying to determine
            // if the saved IP was on this context.
            // if not we just ignore that

            CComPtr<ITfContext> cpic;
            hr = cpInsertionPoint->GetContext(&cpic);

            if (S_OK != hr || cpic != pic)
            {
                cpInsertionPoint.Release();
            }
        }

        if (cpInsertionPoint)
        {
            CComPtr<ITfRange> cpSelection;
            hr = GetSelectionSimple(ec, pic, &cpSelection);
            if (SUCCEEDED(hr))
            {
                hr = cpSelection->IsEqualStart(ec, cpInsertionPoint, TF_ANCHOR_START, &fIPIsSelection);
            }
        }
        else
        {
            // if there is no saved IP, selection is an IP
            fIPIsSelection = TRUE;
            hr = GetSelectionSimple(ec, pic, &cpInsertionPoint);
        }
       
        if (hr == S_OK)
        {
            // finalize the previous input for now
            // if this is either feedback UI or alternate selection
            // no need to finalize
            // 
            // Only for AIMM app or CUAS app,
            // finalize the previous dictated phrase here.
            //
            // For full Cicero aware app, it is better to finalize the composition
            // after this dictated text is injected to the document.
            //
            if (!fPureCiceroIC && !fPreserveResult 
                && IsEqualGUID(input_attr, GUID_ATTR_SAPI_INPUT))
            {
                _FinalizePrevComp(ec, pic, cpInsertionPoint);
            }
            
            ITfProperty  *pProp = NULL;
            
            // now inject text
            if (SUCCEEDED(hr))
            {
                // Just check with the app in case it wants to modify 
                // the range. 
                //

                BOOL fInsertOk;
                hr = cpInsertionPoint->AdjustForInsert(ec, wcslen(pwszText), &fInsertOk);
                if (S_OK == hr && fInsertOk)
                {
                    // start a composition here if we haven't already
                    _CheckStartComposition(ec, cpInsertionPoint);

                    // protect the reco property while we modify the text
                    // memo: we might want to preserve the original property instead
                    //       of the current property for LM lattice info We'll check 
                    //       back this later (RTM)
                    //
                    m_fAcceptRecoResultTextUpdates = fPreserveResult;

                    CRecoResultWrap *pRecoWrapOrg = NULL;
                    ITfRange        *pPropRange = NULL;
                    ITfProperty     *pProp_SAPIRESULT = NULL;

                    if (fPreserveResult == TRUE)
                    {
                        if (SUCCEEDED(hr = pic->GetProperty(GUID_PROP_SAPIRESULTOBJECT, &pProp_SAPIRESULT)))
                        {
                            // save out the result data
                            //
                            hr = _PreserveResult(ec, cpInsertionPoint, pProp_SAPIRESULT, &pRecoWrapOrg, &pPropRange);
                        }
                        if (S_OK != hr)
                            pRecoWrapOrg = NULL;
                    }

                    if ( SUCCEEDED(hr) )
                    {
                        // set the text
 
                        hr = cpInsertionPoint->SetText(ec, 0, pwszText, -1);

                        // prwOrg holds a prop data if not NULL
                        if (S_OK == hr && fPreserveResult == TRUE && pPropRange)
                        {
                            hr = _RestoreResult(ec, pPropRange, pProp_SAPIRESULT, pRecoWrapOrg);
                        }
                    }

                    SafeReleaseClear(pPropRange);
                    SafeReleaseClear(pProp_SAPIRESULT);
                    SafeRelease(pRecoWrapOrg);  

                    m_fAcceptRecoResultTextUpdates = FALSE;


                }
            }
            
            //
            // set attribute range, use custom prop to mark speech text
            //
            if (SUCCEEDED(hr))
            {
                if (IsEqualGUID(input_attr, GUID_ATTR_SAPI_INPUT))
                {
                    hr = pic->GetProperty(GUID_PROP_SAPI_DISPATTR, &pProp);
                }
                else
                {
                    hr = pic->GetProperty(GUID_PROP_ATTRIBUTE, &pProp);
                 }
            }

            ITfRange *pAttrRange = NULL;
            if (S_OK == hr)
            {
                // when we insert feedback UI text, we expect the prop
                // range (attribute range) to be extended.
                // if we are attaching our custom GUID_PROP_SAPI_DISPATTR
                // property, we'll attach it phrase by phrase
                //
                if (!IsEqualGUID(input_attr, GUID_ATTR_SAPI_INPUT))
                {
                    hr = _FindPropRange(ec, pProp, cpInsertionPoint, 
                                   &pAttrRange, input_attr, TRUE);
                }
                //
                // findproprange can return S_FALSE when there's no property yet
                //
                if (SUCCEEDED(hr) && !pAttrRange)
                {
                    hr = cpInsertionPoint->Clone(&pAttrRange);
                }
            }

            if (S_OK == hr && pAttrRange)
            {
                SetGUIDPropertyData(&_libTLS, ec, pProp, pAttrRange, input_attr);
            }

            //
            // one more prop stuff for text owner id to fix
            // problem with Japanese spelling
            //
            if (S_OK == hr && fSpelling && !_MasterLMEnabled())
            {
                CComPtr<ITfProperty> cpPropTextOwner;

                hr = pic->GetProperty(GUID_PROP_TEXTOWNER, &cpPropTextOwner);
                if (S_OK == hr)
                {
                    SetGUIDPropertyData(&_libTLS, ec, cpPropTextOwner, pAttrRange, GUID_NULL);
                }
            }

            SafeRelease(pAttrRange);
            SafeRelease(pProp);

            //
            // setup langid property
            //
            _SetLangID(ec, pic, cpInsertionPoint, langid);

            // move the caret
            if (fIPIsSelection)
            {
                cpInsertionPoint->Collapse(ec, TF_ANCHOR_END);
                SetSelectionSimple(ec, pic, cpInsertionPoint);
            }

            // Finalize the composition object here for Cicero aware app.
            if ((hr == S_OK) && fPureCiceroIC  
                && IsEqualGUID(input_attr, GUID_ATTR_SAPI_INPUT))
            {
                _KillFocusRange(ec, pic, NULL, _tid);
            }
        }
       
        // If candidate UI is open, we need to close it now.
        CloseCandUI( );
            
        _fEditing = FALSE;

    }

    // Finally, notify stage process if we are the stage speech tip instance.
    if (m_fStageTip && IsEqualGUID(input_attr, GUID_ATTR_SAPI_INPUT) && fPreserveResult == FALSE)
    {
        SetCompartmentDWORD(_tid, _tim, GUID_COMPARTMENT_SPEECH_STAGEDICTATION, 1, FALSE);
    }


    return hr;
}

//  
// _ProcessSpelledText
// 
// Call back function for edit session ESCB_INJECT_SPELL_TEXT
//
//
HRESULT CSapiIMX::_ProcessSpelledText(TfEditCookie ec, ITfContext *pic, WCHAR *pwszText, LANGID langid, BOOL fOwnerId)
{
    HRESULT             hr = S_OK;
    CComPtr<ITfRange>   cpTextRange;
    CComPtr<ITfRange>   cpCurIP;

    if ( !pic || !pwszText )
        return E_INVALIDARG;
    
    // Keep the current range.
    cpCurIP = GetSavedIP( );

    if ( !cpCurIP )
        GetSelectionSimple(ec, pic, &cpCurIP);

    // We want to clone current ip so that it would not be changed 
    // after _ProcessTextInternal( ) is called.
    //
    if ( cpCurIP )
        cpCurIP->Clone(&cpTextRange);

    if ( !cpTextRange ) return E_FAIL;

    // check if the current selection or empty ip is inside a middle of English word. for English only.
    BOOL      fStartAnchorInMidWord = FALSE;   // Check if the start anchor of pTextRange is in a middle of word
    BOOL      fEndAnchorInMidWord  =  FALSE;   // Check if the end anchor of pTextRange is in a middle of word.

    // When fStartAnchorInMidWord is TRUE, we don't add extra space between this text range and the previous range.
    // When fEndAnchoInMidWord is TRUE, we remove the trailing space in this text range.

    if ( langid == 0x0409 )
    {
        WCHAR               szSurrounding[3]=L"  ";
        LONG                cch;
        CComPtr<ITfRange>   cpClonedRange;

        hr = cpTextRange->Clone(&cpClonedRange);

        if ( hr == S_OK )
            hr = cpClonedRange->Collapse(ec, TF_ANCHOR_START);

        if ( hr == S_OK )
            hr = cpClonedRange->ShiftStart(ec, -1, &cch, NULL);

        if (hr == S_OK && cch != 0)
            hr = cpClonedRange->ShiftEnd(ec, 1, &cch, NULL);

        if ( hr == S_OK && cch != 0 )
            hr = cpClonedRange->GetText(ec, 0, szSurrounding, 2, (ULONG *)&cch);

        if ( hr == S_OK && cch > 0 )
        {
            if ( iswalnum(szSurrounding[0]) && iswalnum(szSurrounding[1]))
                fStartAnchorInMidWord = TRUE;
        }

        szSurrounding[0] = szSurrounding[1]=L' ';
        cpClonedRange.Release( );

        hr = cpTextRange->Clone(&cpClonedRange);

        if ( hr == S_OK )
            hr = cpClonedRange->Collapse(ec, TF_ANCHOR_END);

        if ( hr == S_OK )
            hr = cpClonedRange->ShiftStart(ec, -1, &cch, NULL);

        if (hr == S_OK && cch != 0)
            hr = cpClonedRange->ShiftEnd(ec, 1, &cch, NULL);

        if ( hr == S_OK && cch != 0 )
            hr = cpClonedRange->GetText(ec, 0, szSurrounding, 2, (ULONG *)&cch);

        if ( hr == S_OK && cch == 2 )
        {
            if ( iswalnum(szSurrounding[0]) && iswalnum(szSurrounding[1]) )
                fEndAnchorInMidWord = TRUE;
        }
    }

    // Inject text with or without owner id according to fOwnerId parameter
    // this is a final text injection, we don't want to preserve the speech property data
    // possible divided or shrinked by this text injection.
    //
    hr = _ProcessTextInternal(ec, pwszText, GUID_ATTR_SAPI_INPUT, langid, pic, FALSE, !fOwnerId);

    if ( hr == S_OK  && !fOwnerId)
    {
        BOOL  fConsumeLeadSpaces = FALSE;
        ULONG ulNumTrailSpace = 0;

        if ( iswcntrl(pwszText[0]) || iswpunct(pwszText[0]) )
            fConsumeLeadSpaces = TRUE;

        for ( LONG i=wcslen(pwszText)-1; i > 0; i-- )
        {
            if ( pwszText[i] == L' ' )
                ulNumTrailSpace++;
            else
                break;
        }

        hr = _ProcessSpaces(ec, pic, cpTextRange, fConsumeLeadSpaces, ulNumTrailSpace, langid, fStartAnchorInMidWord, fEndAnchorInMidWord);
    }

    return hr;
}

//
// Handle the spaces after the recogized text is injected to the document.
//
// The handling includes below cases:
//
//    Consume the leading spaces.
//    Remove the possible spaces after the injected text.  English Only
//    Add a space before the injected text if necessary.  English Only.
//
HRESULT CSapiIMX::HandleSpaces(ISpRecoResult *pResult, ULONG ulStartElement, ULONG ulNumElements, ITfRange *pTextRange, LANGID langid)
{
    HRESULT hr = E_FAIL;

    if (pResult && pTextRange)
    {
        BOOL        fConsumeLeadSpaces = FALSE;
        ULONG       ulNumTrailSpace = 0;
        SPPHRASE    *pPhrase = NULL;

        // Check if the first element of the pResult wants to consume the leading spaces 
        // (the trailing spaces in the last phrase) in the documenet.
        //
        // If the disp attrib bit is set as SPAF_CONSUME_LEADING_SPACES, means it wants to consume
        // all the leading spaces in the document.
        //

        hr = S_OK;

        if ( _NeedRemovingSpaceForPunctation( ) )
        {
            hr = pResult->GetPhrase(&pPhrase);

            if ( hr == S_OK )
            {
                ULONG cElements = 0;
                BYTE  bDispAttr;

                cElements = pPhrase->Rule.ulCountOfElements;

                if ( cElements >= (ulStartElement + ulNumElements) )
                {
                    bDispAttr = pPhrase->pElements[ulStartElement].bDisplayAttributes;

                    if ( bDispAttr & SPAF_CONSUME_LEADING_SPACES )
                        fConsumeLeadSpaces = TRUE;

                    bDispAttr = pPhrase->pElements[ulStartElement + ulNumElements - 1].bDisplayAttributes;
                    if ( bDispAttr & SPAF_ONE_TRAILING_SPACE )
                        ulNumTrailSpace = 1;
                    else if ( bDispAttr & SPAF_TWO_TRAILING_SPACES )
                        ulNumTrailSpace = 2;
                }
            }

            if (pPhrase)
                CoTaskMemFree(pPhrase);
        }

        if ( hr == S_OK )
        {
            ESDATA  esData;

            memset(&esData, 0, sizeof(ESDATA));
            esData.lData1 = (LONG_PTR)langid;
            esData.lData2 = (LONG_PTR)ulNumTrailSpace;
            esData.fBool  = fConsumeLeadSpaces;
            esData.pRange = pTextRange;

            hr = _RequestEditSession(ESCB_HANDLESPACES, TF_ES_READWRITE, &esData);
        }
    }

    return hr;
}

//
// CSapiIMX::AttachResult
//
// attaches the result object and keep it *alive*
// until the property is discarded
//
HRESULT CSapiIMX::AttachResult(ISpRecoResult *pResult, ULONG ulStartElement, ULONG ulNumElements)
{
    HRESULT hr = E_FAIL;

    if (pResult)
    {
        ESDATA  esData;
        
        memset(&esData, 0, sizeof(ESDATA));

        esData.lData1 = (LONG_PTR)ulStartElement;
        esData.lData2 = (LONG_PTR)ulNumElements;
        esData.pUnk = (IUnknown *)pResult;

        hr = _RequestEditSession(ESCB_ATTACHRECORESULTOBJ, TF_ES_READWRITE, &esData);
    }

    return hr;
}



//
//  CSapiIMX::_GetSpaceRangeBeyondText
//
//  Get space range beyond the injected text in the document.
//  fBefore is TRUE, Get the space range to contain spaces between 
//                   the previous word and start anchor of the TextRange.
//  fBefore is FALSE,Get space range to contains spaces  between 
//                   the end anchor of the TextRange and next word.
//
//  pulNum  receives the real space number.
//  pfRealTextBeyond indicates if there is real text before or after the text range.
//
//  Caller is responsible to release *ppSpaceRange.
//
HRESULT CSapiIMX::_GetSpaceRangeBeyondText(TfEditCookie ec, ITfRange *pTextRange, BOOL fBefore, ITfRange  **ppSpaceRange, BOOL *pfRealTextBeyond)
{
    HRESULT             hr = S_OK;
    CComPtr<ITfRange>   cpSpaceRange;
    LONG                cch;

    if ( !pTextRange || !ppSpaceRange )
        return E_INVALIDARG;

    *ppSpaceRange = NULL;

    if ( pfRealTextBeyond )
        *pfRealTextBeyond = FALSE;

    hr = pTextRange->Clone(&cpSpaceRange);

    if ( hr == S_OK )
    {
        hr = cpSpaceRange->Collapse(ec, fBefore ? TF_ANCHOR_START  :  TF_ANCHOR_END);
    }

    if ( hr == S_OK )
    {
        if ( fBefore )
            hr = cpSpaceRange->ShiftStart(ec, MAX_CHARS_FOR_BEYONDSPACE * (-1), &cch, NULL);
        else
            hr = cpSpaceRange->ShiftEnd(ec, MAX_CHARS_FOR_BEYONDSPACE, &cch, NULL);
    }

    if ( (hr == S_OK)  && (cch != 0 ) )
    {
        // There are more characters beyond the text range.
        // Determine the real number of spaces in the guessed range.
        //
        // if fBefore TRUE, search the number from end to start anchor.
        // if fBefore FASLE, search the number from start to end anchor.

        WCHAR *pwsz = NULL;
        LONG   lSize = cch;
        LONG   lNumSpaces = 0;
            
        if (cch < 0)
            lSize = cch * (-1);

        pwsz = new WCHAR[lSize + 1];
        if ( pwsz )
        {
            hr = cpSpaceRange->GetText(ec, 0, pwsz, lSize, (ULONG *)&cch);
            if ( hr == S_OK)
            {
                pwsz[cch] = L'\0';

                // calculate the number of trailing or prefix spaces in this range.
                BOOL    bSearchDone = FALSE;
                ULONG   iStart;

                if ( fBefore )
                    iStart = cch - 1;  // Start from the end anchor to Start Anchor.
                else
                    iStart = 0;        // Start from Start Anchor to End Anchor.

                while ( !bSearchDone )
                {
                    if ((pwsz[iStart] != L' ') && (pwsz[iStart] != L'\t'))
                    {
                        bSearchDone = TRUE;

                        if ( pwsz[iStart] > 0x20 && pfRealTextBeyond)
                            *pfRealTextBeyond = TRUE;

                        break;
                    }
                    else
                        lNumSpaces ++;

                    if ( fBefore )
                    {
                        if ( (long)iStart <= 0 )
                            bSearchDone = TRUE;
                        else
                            iStart --;
                    }
                    else
                    {
                        if ( iStart >= (ULONG)cch - 1 )
                            bSearchDone = TRUE;
                        else
                            iStart ++;
                    }
                }
            }

            delete[] pwsz;

            if ( (hr == S_OK) && (lNumSpaces > 0))
            {
                // Shift the range to cover only spaces.
                LONG   NonSpaceNum;
                NonSpaceNum = cch - lNumSpaces;

                if ( fBefore )
                    hr = cpSpaceRange->ShiftStart(ec, NonSpaceNum, &cch, NULL);
                else
                    hr = cpSpaceRange->ShiftEnd(ec, NonSpaceNum * (-1), &cch, NULL);

                // Return this cpSpaceRange to the caller.
                // Caller is responsible for releasing this object.

                if ( hr == S_OK )
                    hr = cpSpaceRange->Clone(ppSpaceRange);
            }
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}

//
// CSapiIMX::_ProcessTrailingSpace
//
// If the next phrase wants to consume leading space,
// we want to remove all the trailing spaces in this text range and the spaces
// between this range and next text range.
// This is for all languages.
//
HRESULT CSapiIMX::_ProcessTrailingSpace(TfEditCookie ec, ITfContext *pic, ITfRange *pTextRange, ULONG ulNumTrailSpace)
{
    HRESULT                 hr = S_OK;
    CComPtr<ITfRange>       cpNextRange;
    CComPtr<ITfRange>       cpSpaceRange;    // Space Range between this range and next text range.
    BOOL                    fHasNextText = FALSE;
    CComPtr<ITfRange>       cpTrailSpaceRange;
    LONG                    cch;

    if ( !pTextRange )
        return E_INVALIDARG;

    hr = pTextRange->Clone(&cpTrailSpaceRange);

    if (hr == S_OK)
        hr = cpTrailSpaceRange->Collapse(ec, TF_ANCHOR_END);

    // Generate the real Trailing Space Range
    if (hr == S_OK && ulNumTrailSpace > 0)
        hr = cpTrailSpaceRange->ShiftStart(ec, (LONG)ulNumTrailSpace * (-1), &cch, NULL);

    // Get the spaces between this range and possible next text range.
    if ( hr == S_OK )
        hr = _GetSpaceRangeBeyondText(ec, pTextRange, FALSE, &cpSpaceRange);

    // if we found the space range, the trailing space range should also include this range.
    if ( hr == S_OK && cpSpaceRange )
        hr = cpTrailSpaceRange->ShiftEndToRange(ec, cpSpaceRange, TF_ANCHOR_END);

    // Determine if there is Next Text range after this cpTrailSpaceRange.
    if (hr == S_OK)
    {
        hr = cpTrailSpaceRange->Clone(&cpNextRange);

        if ( hr == S_OK )
            hr = cpNextRange->Collapse(ec, TF_ANCHOR_END);

        cch = 0;
        if ( hr == S_OK )
            hr = cpNextRange->ShiftEnd(ec, 1, &cch, NULL);

        if ( hr == S_OK && cch != 0 )
            fHasNextText = TRUE;
    }

    if (hr == S_OK && fHasNextText && cpNextRange)
    {
        BOOL    fNextRangeConsumeSpace = FALSE;
        BOOL    fAddOneSpace = FALSE;  // this is only for Hyphen handling, 
                                       // if it is TRUE, a trailing space is required 
                                       // to append.
                                       // so that new text could be like A - B.
        WCHAR   wszText[4];

        hr = cpNextRange->GetText(ec, 0, wszText, 1, (ULONG *)&cch);

        if ((hr == S_OK) && ( iswcntrl(wszText[0]) || iswpunct(wszText[0]) ))
        {
            // if the character is a control character or punctuation character,
            // it means it want to consume the previous spaces.
            fNextRangeConsumeSpace = TRUE;

            if ((wszText[0] == L'-') || (wszText[0] == 0x2013)) // Specially handle Hyphen character.
            {
                // If the next text is "-xxx", there should be no space between 
                // this range and next range.

                // If the next text is "- xxx", there should be a space between 
                // this range and next range, the text would be: "nnn - xxx"
                HRESULT          hret;

                hret = cpNextRange->ShiftEnd(ec, 1, &cch, NULL);

                if ( hret == S_OK && cch > 0 )
                {
                    hret = cpNextRange->GetText(ec, 0, wszText, 2, (ULONG *)&cch);

                    if ( hret == S_OK && cch == 2  && wszText[1] == L' ')
                        fAddOneSpace = TRUE;
                }
            }
        }

        if ( fNextRangeConsumeSpace )
        {
            _CheckStartComposition(ec, cpTrailSpaceRange);
            if ( !fAddOneSpace )
                hr = cpTrailSpaceRange->SetText(ec, 0, NULL, 0);
            else
                hr = cpTrailSpaceRange->SetText(ec, 0, L" ", 1);
        }
    }

    return hr;
}

//
// CSapiIMX::_ProcessLeadingSpaces
//
// If this phrase wants to consume leading spaces, all the spaces before this phrase
// must be removed.
// if the phrase doesn't want to consume leading spaces, and there is no space between
// this phrase and previous phrase for English case, leading space is required to add 
// between these two phrases.
//
HRESULT CSapiIMX::_ProcessLeadingSpaces(TfEditCookie ec, ITfContext *pic, ITfRange *pTextRange, BOOL  fConsumeLeadSpaces, LANGID langid, BOOL fStartInMidWord)
{
    HRESULT  hr = S_OK;

    if (!pTextRange || !pic)
        return E_INVALIDARG;

    // Handle Consuming leading Spaces.
    if (fConsumeLeadSpaces )
    {
        CComPtr<ITfRange> cpLeadSpaceRange;

        hr = _GetSpaceRangeBeyondText(ec, pTextRange, TRUE, &cpLeadSpaceRange);
        if ( hr == S_OK  && cpLeadSpaceRange )
        {
            // Kill all the trailing spaces in the range.
            // start a composition here if we haven't already
            _CheckStartComposition(ec, cpLeadSpaceRange);
            hr = cpLeadSpaceRange->SetText(ec, 0, NULL, 0);
        }
    }

    // Specially handle some other space cases for English
    if ((hr == S_OK) && (langid == 0x0409))
    {
        // If this phrase doesn't consume the leading space, and 
        // there is no any spaces between this text range and a real previous text word.
        // we need to add one space here.

        // if this is a spelled text, and the start anchor of selection or ip is inside
        // of a word, don't add extra leading space.
        //
        if ( hr == S_OK && !fConsumeLeadSpaces && !fStartInMidWord)
        {
            CComPtr<ITfRange> cpLeadSpaceRange;
            BOOL              fRealTextInPreviousWord = FALSE;

            hr = _GetSpaceRangeBeyondText(ec, pTextRange, TRUE, &cpLeadSpaceRange,&fRealTextInPreviousWord);

            if ( hr == S_OK && !cpLeadSpaceRange  && fRealTextInPreviousWord )
            {
                //
                // Specially handle the hyphen case for bug 468907
                //
                // if the previous text is "x-", this  text is "y", 
                // the final text should be like "x-y".
                // we should not add one space in this case.
                //
                // if the previous text is "x -", the final text would be "x - y"
                // the extra space is necessary.

                BOOL   fAddExtraSpace = TRUE;
                CComPtr<ITfRange>   cpPrevTextRange;
                WCHAR               wszTrailTextInPrevRange[3];
                LONG                cch;
                
                // Since previous text range does exist,  ( fRealTextInPreviousWord is TRUE).
                // and there is no space between this range and previous range.
                // we can just rely on pTextRange to shift to previous range and get 
                // its trail characters. ( last two characters, saved in wszTrailTextInPrevRange).

                hr = pTextRange->Clone(&cpPrevTextRange);

                if ( hr == S_OK )
                    hr = cpPrevTextRange->Collapse(ec, TF_ANCHOR_START);

                if ( hr == S_OK )
                    hr = cpPrevTextRange->ShiftStart(ec, -2, &cch, NULL);

                if ( hr == S_OK )
                    hr = cpPrevTextRange->GetText(ec, 0, wszTrailTextInPrevRange, 2, (ULONG *)&cch);

                if ( hr == S_OK && cch == 2 )
                {
                    if ( (wszTrailTextInPrevRange[0] != L' ') && 
                         ((wszTrailTextInPrevRange[1] == L'-') || (wszTrailTextInPrevRange[1] == 0x2013)) )
                        fAddExtraSpace = FALSE;
                }

                if ( fAddExtraSpace )
                {
                    hr = pTextRange->Clone(&cpLeadSpaceRange);

                    if ( hr == S_OK )
                        hr = cpLeadSpaceRange->Collapse(ec, TF_ANCHOR_START);

                    if ( hr == S_OK )
                    {
                        // Insert one Space to this new empty range.
                        _CheckStartComposition(ec, cpLeadSpaceRange);
                        hr = cpLeadSpaceRange->SetText(ec, 0, L" ", 1);
                    }
                }
            }
        }
    }

    return hr;
}


//
//  CSapiIMX::_ProcessSpaces
//
//  Edit session callback function for ESCB_HANDLESPACES.
//
//
HRESULT CSapiIMX::_ProcessSpaces(TfEditCookie ec, ITfContext *pic, ITfRange *pTextRange, BOOL  fConsumeLeadSpaces, ULONG ulNumTrailSpace, LANGID langid, BOOL fStartInMidWord, BOOL fEndInMidWord )
{
    HRESULT  hr = S_OK;

    if (!pTextRange || !pic)
        return E_INVALIDARG;

    hr = _ProcessLeadingSpaces(ec, pic, pTextRange,fConsumeLeadSpaces, langid, fStartInMidWord);

    // Specially handle some other space cases for English
    if ((hr == S_OK) && (langid == 0x0409))
    {
        // Remove all the unnecessary spaces between this text range and next word.
        CComPtr<ITfRange>  cpTrailSpaceRange;

        hr = _GetSpaceRangeBeyondText(ec, pTextRange, FALSE, &cpTrailSpaceRange);
        if ( hr == S_OK && cpTrailSpaceRange )
        {
            _CheckStartComposition(ec, cpTrailSpaceRange);
            hr = cpTrailSpaceRange->SetText(ec, 0, NULL, 0);
        }
    }

    if ( (hr == S_OK) && fEndInMidWord )
    {
        // This is spelled text.
        // EndAnchor is in middle of a word.
        // we just want to remove the trail spaces injected in this text range.

        if ( ulNumTrailSpace )
        {
            CComPtr<ITfRange>       cpTrailSpaceRange;
            LONG                    cch;

            hr = pTextRange->Clone(&cpTrailSpaceRange);

            if (hr == S_OK)
                hr = cpTrailSpaceRange->Collapse(ec, TF_ANCHOR_END);

            // Generate the real Trailing Space Range
            if (hr == S_OK)
                hr = cpTrailSpaceRange->ShiftStart(ec, (LONG)ulNumTrailSpace * (-1), &cch, NULL);

            if ( hr == S_OK && cch != 0 )
            {
                // Remove the spaces.
                _CheckStartComposition(ec, cpTrailSpaceRange);
                hr = cpTrailSpaceRange->SetText(ec, 0, NULL, 0);
            }

            if ( hr == S_OK )
                ulNumTrailSpace = 0;
        }
       
    }

    // If the next phrase wants to consume leading space,
    // we want to remove all the trailing spaces in this text range.
    // This is for all languages.

    if ( hr == S_OK )
        hr = _ProcessTrailingSpace(ec, pic, pTextRange, ulNumTrailSpace);

    return hr;
}

//
// CSapiIMX::_ProcessRecoObject
//
//
HRESULT CSapiIMX::_ProcessRecoObject(TfEditCookie ec, ISpRecoResult *pResult, ULONG ulStartElement, ULONG ulNumElements)
{
    HRESULT hr;
    ITfContext *pic;
    CComPtr<ITfRange> cpInsertionPoint;

    if (!GetFocusIC(&pic))
    {
        return E_OUTOFMEMORY;
    }

    _fEditing = TRUE;
    if (cpInsertionPoint = GetSavedIP())
    {
        // this is trying to determine
        // if the saved IP was on this context.
        // if not we just ignore that
        CComPtr<ITfContext> cpic;
  
        hr = cpInsertionPoint->GetContext(&cpic);
        if (S_OK != hr || cpic != pic)
        {
            cpInsertionPoint.Release();
        }
    }
    // find range to attach property
    if (!cpInsertionPoint)
    {
        CComPtr<ITfRange> cpSelection;
        if (GetSelectionSimple(ec, pic, &cpSelection) == S_OK)
        {
            cpInsertionPoint = cpSelection; // comptr addrefs
        }
    }
   
    if (cpInsertionPoint)
    {
        CComPtr<ITfRange> cpRange;
        
        BOOL fPrSize = _FindPrevComp(ec, pic, cpInsertionPoint, &cpRange, GUID_ATTR_SAPI_INPUT);

        if (!fPrSize)
        {
            hr = E_FAIL; // we may need to assert here?
            goto pr_exit;
        }
        
            
        CComPtr<ITfProperty> cpProp;

        if (SUCCEEDED(hr = pic->GetProperty(GUID_PROP_SAPIRESULTOBJECT, &cpProp)))
        {
            CComPtr<ITfPropertyStore> cpResultStore;
        
            CPropStoreRecoResultObject *prps = new CPropStoreRecoResultObject(this, cpRange);

            if (!prps)
            {
                hr = E_OUTOFMEMORY;
                goto pr_exit;
            }
            
            // determine whether this partial result has an ITN
            SPPHRASE *pPhrase;
            ULONG     ulNumOfITN = 0;
            hr = pResult->GetPhrase(&pPhrase);
            if (S_OK == hr)
            {
                const SPPHRASEREPLACEMENT *pRep = pPhrase->pReplacements;
                for (ULONG ul = 0; ul < pPhrase->cReplacements; ul++)
                {
                    // review: we need to verify if this is really a correct way to determine
                    // whether the ITN fits in the partial result
                    //
                    if (pRep->ulFirstElement >= ulStartElement 
                    && (pRep->ulFirstElement + pRep->ulCountOfElements) <= (ulStartElement + ulNumElements))
                    {
                        ulNumOfITN ++;
                    }
                    pRep++;
                }
                ::CoTaskMemFree(pPhrase);
            }
            
            CRecoResultWrap *prw = new CRecoResultWrap(this, ulStartElement, ulNumElements, ulNumOfITN);
            if (prw)
            {
                hr = prw->Init(pResult);
            }
            else
                hr = E_OUTOFMEMORY;

            // set up the result data
            if (S_OK == hr)
            {
                // save text
                CComPtr<ITfRange> cpRangeTemp;

                hr = cpRange->Clone(&cpRangeTemp);
                if (S_OK == hr)
                {
                    long cch;
                    TF_HALTCOND hc;
                    WCHAR *psz;

                    hc.pHaltRange = cpRange;
                    hc.aHaltPos = TF_ANCHOR_END;
                    hc.dwFlags = 0;
                    cpRangeTemp->ShiftStart(ec, LONG_MAX, &cch, &hc);
                    psz = new WCHAR[cch+1];

                    if (psz)
                    {
                        if ( S_OK == cpRange->GetText(ec, 0, psz, cch, (ULONG *)&cch))
                        {
                            prw->m_bstrCurrentText = SysAllocString(psz);
                            delete[] psz;
                        }
                    }
                } 

                // Init the ITN Show State list in reco wrapper.

                prw->_InitITNShowState(TRUE, 0, 0);

                hr = prps->_InitFromResultWrap(prw); // this addref's
            }

            // get ITfPropertyStore interface
            if (SUCCEEDED(hr))
            {
                hr = prps->QueryInterface(IID_ITfPropertyStore, (void **)&cpResultStore);
                SafeRelease(prps);
            }


            // set the property store for this range property
            if (hr == S_OK)
            {
                hr = cpProp->SetValueStore(ec, cpRange, cpResultStore);
            }
            
            if (_MasterLMEnabled())
            {
                // set up the LM lattice store, only if reco result is given
                // 
                CComPtr<ITfProperty> cpLMProp;

                if ( S_OK == hr &&
                SUCCEEDED(hr = pic->GetProperty(GUID_PROP_LMLATTICE, &cpLMProp)))
                {
                    CPropStoreLMLattice *prpsLMLattice = new CPropStoreLMLattice(this);
                    CComPtr<ITfPropertyStore> cpLatticeStore;

                    if (prpsLMLattice && prw)
                    {
                        hr = prpsLMLattice->_InitFromResultWrap(prw);
                    }
                    else
                        hr = E_OUTOFMEMORY;
        
                    if (S_OK == hr)
                    {
                        hr = prpsLMLattice->QueryInterface(IID_ITfPropertyStore, (void **)&cpLatticeStore);
                    }
        
                    if (S_OK == hr)
                    {
                        hr = cpLMProp->SetValueStore(ec, cpRange, cpLatticeStore);
                    }
                    SafeRelease(prpsLMLattice);
                }
            }
            SafeRelease(prw);
        }
    }

pr_exit:
    _fEditing = FALSE;
    pic->Release();

    return hr;
}

HRESULT CSapiIMX::_PreserveResult(TfEditCookie ec, ITfRange *pRange, ITfProperty *pProp, CRecoResultWrap **ppRecoWrap, ITfRange **ppPropRange)
{
    HRESULT hr;
    ITfRange *pPropRange;
    CComPtr<IUnknown> cpunk;
    
    Assert(ppPropRange);

    hr = pProp->FindRange(ec, pRange, &pPropRange, TF_ANCHOR_START);
    // retrieve the result data and addref it
    //
    if (SUCCEEDED(hr) && pPropRange)
    {
        hr = GetUnknownPropertyData(ec, pProp, pPropRange, &cpunk); 
        *ppPropRange = pPropRange;
        // would be released at the caller
        // pPropRange->Release();

        // get the result object, cpunk points to our wrapper object
        CComPtr<IServiceProvider> cpServicePrv;
        CComPtr<ISpRecoResult>    cpResult;
        CRecoResultWrap *pRecoWrapOrg = NULL;

        if (S_OK == hr)
        {
            hr = cpunk->QueryInterface(IID_IServiceProvider, (void **)&cpServicePrv);
        }
        // get result object
        if (S_OK == hr)
        {
            hr = cpServicePrv->QueryService(GUID_NULL, IID_ISpRecoResult, (void **)&cpResult);
        }

        if (S_OK == hr)
        {
            hr = cpunk->QueryInterface(IID_PRIV_RESULTWRAP, (void **)&pRecoWrapOrg);
        }

        // Now Create a new RecoResult Wrapper based on the org wrapper's data.
        // Clone a new RecoWrapper.

        if ( S_OK == hr )
        {
            CRecoResultWrap *pRecoWrapNew = NULL;
            ULONG           ulStartElement, ulNumElements, ulNumOfITN;

            ulStartElement = pRecoWrapOrg->GetStart( );
            ulNumElements = pRecoWrapOrg->GetNumElements( );
            ulNumOfITN = pRecoWrapOrg->m_ulNumOfITN;

            pRecoWrapNew = new CRecoResultWrap(this, ulStartElement, ulNumElements, ulNumOfITN);

            if ( pRecoWrapNew )
            {
                // Init from RecoResult SR object
                hr = pRecoWrapNew->Init(cpResult);

                if ( S_OK == hr )
                {
                    pRecoWrapNew->SetOffsetDelta( pRecoWrapOrg->_GetOffsetDelta( ) );
                    pRecoWrapNew->SetCharsInTrail( pRecoWrapOrg->GetCharsInTrail( ) );
                    pRecoWrapNew->SetTrailSpaceRemoved( pRecoWrapOrg->GetTrailSpaceRemoved( ) );
                    pRecoWrapNew->m_bstrCurrentText = SysAllocString((WCHAR *)pRecoWrapOrg->m_bstrCurrentText);

                    // Update ITN show-state list .

                    if ( ulNumOfITN > 0 )
                    {
                        SPITNSHOWSTATE  *pITNShowStateOrg;

                        for ( ULONG  iIndex=0; iIndex<ulNumOfITN; iIndex ++ )
                        {
                            pITNShowStateOrg = pRecoWrapOrg->m_rgITNShowState.GetPtr(iIndex);

                            if ( pITNShowStateOrg)
                            {
                                ULONG     ulITNStart;
                                ULONG     ulITNNumElem;
                                BOOL      fITNShown;

                                ulITNStart = pITNShowStateOrg->ulITNStart;
                                ulITNNumElem = pITNShowStateOrg->ulITNNumElem;
                                fITNShown = pITNShowStateOrg->fITNShown;

                                pRecoWrapNew->_InitITNShowState(fITNShown, ulITNStart, ulITNNumElem );
                                             
                            }
                        } // for
                    } // if

                    // Update Offset List
                    if ( pRecoWrapOrg->IsElementOffsetIntialized( ) )
                    {
                        ULONG  ulOffsetNum;
                        ULONG  i;
                        ULONG  ulOffset;

                        ulOffsetNum = pRecoWrapOrg->GetNumElements( ) + 1;

                        for ( i=0; i < ulOffsetNum; i ++ )
                        {
                            ulOffset = pRecoWrapOrg->_GetElementOffsetCch(ulStartElement + i );
                            pRecoWrapNew->_SetElementNewOffset(ulStartElement + i, ulOffset);
                        }
                    }
                }

                SafeRelease(pRecoWrapOrg);

                if ( ppRecoWrap )
                    *ppRecoWrap = pRecoWrapNew;
            }
            else
                hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

HRESULT CSapiIMX::_RestoreResult(TfEditCookie ec, ITfRange *pPropRange, ITfProperty *pProp, CRecoResultWrap *pRecoWrap)
{
    Assert(m_pCSpTask);
        
    CPropStoreRecoResultObject *prps = new CPropStoreRecoResultObject(this, pPropRange);

    HRESULT hr;
    if (prps)
    {
        ITfPropertyStore *pps;
        // restore the result object
        prps->_InitFromResultWrap(pRecoWrap);

        // get ITfPropertyStore interface
        hr = prps->QueryInterface(IID_ITfPropertyStore, (void **)&pps);

        prps->Release();
    
        // re-set the property store for this range property
        if (hr == S_OK)
        {
            hr = pProp->SetValueStore(ec, pPropRange, pps);
            pps->Release();
        }
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}


HRESULT CSapiIMX::_FinalizePrevComp(TfEditCookie ec, ITfContext *pic, ITfRange *pRange)
//
//  the following code assumes single IP with no simaltanious SR going on
//  we always remove the feedback UI and focus range everytime we receive
//  SR result - mainly for demonstration purpose 
//
{
    // kill the Feedback UI for the entire document
    HRESULT hr = _KillFeedbackUI(ec, pic,  NULL);
    
    // also clear the focus range and its display attribute
    if (SUCCEEDED(hr))
    {
        hr = _KillFocusRange(ec, pic, NULL, _tid);
    }
    
    return hr;
}

//
// bogus: very similar to Finalize prev comp. Consolidate this!
//
//
BOOL CSapiIMX::_FindPrevComp(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfRange **ppRangeOut, GUID input_attr)
{
    HRESULT hr = E_FAIL;
    ITfRange *pRangeTmp;
    LONG l;
    BOOL fEmpty;
    BOOL fRet = FALSE;

    // usual stuff
    pRange->Clone(&pRangeTmp);
    
    // set size to 0
    pRangeTmp->Collapse(ec, TF_ANCHOR_START);

    // shift to the previous position
    pRangeTmp->ShiftStart(ec, -1, &l, NULL);

    ITfRange *pAttrRange;

    ITfProperty *pProp = NULL;
    if (SUCCEEDED(pic->GetProperty(GUID_PROP_SAPI_DISPATTR, &pProp)))
    {
        hr = _FindPropRange(ec, pProp, pRangeTmp, &pAttrRange, input_attr);

        if (S_OK == hr && pAttrRange)
        {
            TfGuidAtom attr;
            if (SUCCEEDED(GetGUIDPropertyData(ec, pProp, pAttrRange, &attr)))
            {
                if (IsEqualTFGUIDATOM(&_libTLS, attr, input_attr))
                {
                    hr = pAttrRange->Clone(ppRangeOut);
                }
            }
            pAttrRange->Release();
        }
        pProp->Release();
    }

    pRangeTmp->Release();
    
    if (SUCCEEDED(hr) && *ppRangeOut)
    {
        (*ppRangeOut)->IsEmpty(ec, &fEmpty);
        fRet = !fEmpty;
    }

    return fRet;
}
//
// CSapiIMX::_SetLangID
//
// synopsis - set langid for the given text range 
//
HRESULT CSapiIMX::_SetLangID(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, LANGID langid)
{
    BOOL fEmpty;
    HRESULT hr = E_FAIL;

    pRange->IsEmpty(ec, &fEmpty);

    if (!fEmpty)
    {
        //
        // make langid prop
        //
        ITfProperty *pProp = NULL;

        // set the attrib info
        if (SUCCEEDED(hr = pic->GetProperty(GUID_PROP_LANGID, &pProp)))
        {
            hr = SetLangIdPropertyData(ec, pProp, pRange, langid);
            pProp->Release();
        }
    }

    return hr;
}

//
// CSapiIMX::_FindPropRange
//
//
HRESULT CSapiIMX::_FindPropRange(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, ITfRange **ppAttrRange, GUID input_attr, BOOL fExtend)
{
    // set the attrib info
    ITfRange *pAttrRange = NULL;
    ITfRange *pRangeTmp;
    TfGuidAtom guidAttr = TF_INVALID_GUIDATOM;
    HRESULT hr;
//    LONG l;

    // set the attrib info
    pRange->Clone(&pRangeTmp);

// There is no need to shiftstart to the left again when this function is called.
// This function is called in two different places, one in FindPrevComp( ) and the  
// other is in ProcessTextInternal( ).  FindPrevComp( ) has already shift the start
// anchor to left by 1 already, we don't want to shift again, otherwise, if the phrase
// contains only one char, it will not find the right prev-composition string.
// In function ProcessTextInternal( ), shift start anchor to left is not really required.
// 
// Remove the below two lines will fix cicero bug 3646 & 3649
//     
    
//    pRangeTmp->Collapse(ec, TF_ANCHOR_START);
//    pRangeTmp->ShiftStart(ec, -1, &l, NULL);

    hr = pProp->FindRange(ec, pRangeTmp, &pAttrRange, TF_ANCHOR_START);

    if (S_OK == hr && pAttrRange)
    {
        hr = GetGUIDPropertyData(ec, pProp, pAttrRange, &guidAttr);
    }

    if (SUCCEEDED(hr))
    {
        if (!IsEqualTFGUIDATOM(&_libTLS, guidAttr, input_attr))
        {
            SafeReleaseClear(pAttrRange);
        }
    }

    if (fExtend)
    {
        if (pAttrRange)
        {
           pAttrRange->ShiftEndToRange(ec, pRange, TF_ANCHOR_END);
        }
    }

    *ppAttrRange = pAttrRange;
 
    SafeRelease(pRangeTmp);

    return hr;
}


HRESULT CSapiIMX::_DetectFeedbackUI(TfEditCookie ec, ITfContext *pic, ITfRange *pRange)
{
    BOOL    fDetected;
    HRESULT hr = _KillOrDetectFeedbackUI(ec, pic, pRange, &fDetected);
    if (S_OK == hr)
    {
        if (fDetected)
        {
            hr = _RequestEditSession(ESCB_KILLFEEDBACKUI, TF_ES_ASYNC|TF_ES_READWRITE, NULL);
        }
        
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// _KillFeedbackUI
//
// get rid of the green/red bar thing within the given range
//
//----------------------------------------------------------------------------+

HRESULT CSapiIMX::_KillFeedbackUI(TfEditCookie ec, ITfContext *pic, ITfRange *pRange)
{
    return _KillOrDetectFeedbackUI(ec, pic, pRange, NULL);
}

HRESULT CSapiIMX::_KillOrDetectFeedbackUI(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, BOOL * pfDetection)
{
    HRESULT hr;
    ITfProperty *pProp = NULL;
    ITfRange *pAttrRange = NULL;
    IEnumTfRanges *pEnumPr;

    if (pfDetection)
        *pfDetection = FALSE;

    CDocStatus ds(pic);
    if (ds.IsReadOnly())
       return S_OK;
    
    if (SUCCEEDED(hr = pic->GetProperty(GUID_PROP_ATTRIBUTE, &pProp)))
    {
        hr = pProp->EnumRanges(ec, &pEnumPr, pRange);
        if (SUCCEEDED(hr)) 
        {
            TfGuidAtom guidAttr;
            while( pEnumPr->Next(1, &pAttrRange, NULL) == S_OK )
            {
                if (SUCCEEDED(GetAttrPropertyData(ec, pProp, pAttrRange, &guidAttr)))
                {

                    if ( IsEqualTFGUIDATOM(&_libTLS, guidAttr, GUID_ATTR_SAPI_GREENBAR) ||  IsEqualTFGUIDATOM(&_libTLS, guidAttr, GUID_ATTR_SAPI_GREENBAR2)
                       )
                    {

                        if (pfDetection == NULL)
                        {
                            // we're not detecting the feedback UI
                            // kill this guy
                            ITfRange *pSel;
                            if (SUCCEEDED(pAttrRange->Clone(&pSel)))
                            {
                                // Because we didn't change the speech property data while 
                                // feedback text were injected.
                                //
                                // Now, when the feedback is killed, we don't want to affect
                                // the original speech property data either.
                                // 
                                // set the below flag to prevent the speech property data updated
                                // similar way as in feedback UI injection handling
                                //

                                m_fAcceptRecoResultTextUpdates = TRUE;
                                pSel->SetText(ec, 0, NULL, 0);
                               
                                // CUAS application will not update the composition
                                // while the feedback text is removed based on msctfime
                                // current text update checking logic.
                                //
                                // Call SetSection( ) to forcelly update the edit record 
                                // of the selection status, and then make sure CUAS 
                                // update composition string successfully.
                                // 
                                if ( !_IsPureCiceroIC(pic) )
                                   SetSelectionSimple(ec, pic, pSel);

                                pSel->Release();
                                m_fAcceptRecoResultTextUpdates = FALSE;

                            }
                        }
                        else
                        {
                            *pfDetection = TRUE;
                        }
                    }
                }

                pAttrRange->Release();
            }

            pEnumPr->Release();
        }
        pProp->Release();
    }
    return hr;
}


//+---------------------------------------------------------------------------
//
// MakeResultString
//
//----------------------------------------------------------------------------

HRESULT CSapiIMX::MakeResultString(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, TfClientId tid, CSpTask *pCSpTask)
{
    TraceMsg(TF_GENERAL, "MakeResultString is Called");

    HRESULT hr = S_OK;

    if (pCSpTask != NULL)
    {
        AbortString(ec, pic, pCSpTask);
    }
    _KillFocusRange(ec, pic, NULL, tid);

    return hr;
}

//+---------------------------------------------------------------------------
//
// AbortString
//
//----------------------------------------------------------------------------

HRESULT CSapiIMX::AbortString(TfEditCookie ec, ITfContext *pic, CSpTask *pCSpTask)
{
    // We may consider not to kill the entire feedback UI
    // because SR happens at background and there can be multi-
    // range dictation going at once but for now, we just kill
    // them all for safety. Later on, we'll re-visit this
    // CSpTask::_StopInput kill the feedback UI.
    //
    Assert(pCSpTask);
    pCSpTask->_StopInput();
    _KillFeedbackUI(ec, pic, NULL);

    return S_OK;
}

HRESULT CSapiIMX::_FinalizeComposition()
{
    return _RequestEditSession(ESCB_FINALIZECOMP, TF_ES_READWRITE);
}

HRESULT CSapiIMX::FinalizeAllCompositions( )
{
    return _RequestEditSession(ESCB_FINALIZE_ALL_COMPS, TF_ES_READWRITE);
}

HRESULT CSapiIMX::_FinalizeAllCompositions(TfEditCookie ec, ITfContext *pic )
{
    HRESULT hr = E_FAIL;
    IEnumITfCompositionView *pEnumComp = NULL;
    ITfContextComposition *picc = NULL;
    ITfCompositionView *pCompositionView;
    ITfComposition *pComposition;
    CLSID clsid;
    CICPriv *picp;
    BOOL     fHasOtherComp = FALSE; // When there is composition which is initialized and started
                                    // by other tips, ( especially by Keyboard tips), this variable 
                                    // set to TRUE
    //
    // clear any sptip compositions over the range
    //

    if (pic->QueryInterface(IID_ITfContextComposition, (void **)&picc) != S_OK)
        goto Exit;

    if (picc->FindComposition(ec, NULL, &pEnumComp) != S_OK)
        goto Exit;

    picp = GetInputContextPriv(_tid, pic);

    while (pEnumComp->Next(1, &pCompositionView, NULL) == S_OK)
    {
        if (pCompositionView->GetOwnerClsid(&clsid) != S_OK)
            goto NextComp;

        if (!IsEqualCLSID(clsid, CLSID_SapiLayr))
        {
            fHasOtherComp = TRUE;
            goto NextComp;
        }

        if (pCompositionView->QueryInterface(IID_ITfComposition, (void **)&pComposition) != S_OK)
            goto NextComp;

        // found a composition, terminate it
        pComposition->EndComposition(ec);
        pComposition->Release();

        if (picp != NULL)
        {
            picp->_ReleaseComposition();
        }

NextComp:
        pCompositionView->Release();
    }

    SafeRelease(picp);

    if ( fHasOtherComp )
    {
        // Simulate VK_RETURN to terminate composition started by other tips.
        HandleKey( VK_RETURN );
    }

    hr = S_OK;

Exit:
    SafeRelease(picc);
    SafeRelease(pEnumComp);

    SaveLastUsedIPRange( );
    SaveIPRange(NULL);
    
    return hr;
}


//+---------------------------------------------------------------------------
//
// SaveCurrentIP
//
// synopsis: this is for recognition handler CSpTask to call when
//           The first hypothesis arrives
//
//+---------------------------------------------------------------------------
void CSapiIMX::SaveCurrentIP(TfEditCookie ec, ITfContext *pic)
{
    CComPtr<ITfRange>   cpSel;
    
    HRESULT hr = GetSelectionSimple(ec, pic, (ITfRange **)&cpSel); 
    
   
    if (SUCCEEDED(hr))
    {
        SaveIPRange(cpSel);
    }
}

//+---------------------------------------------------------------------------
//
// _SyncModeBiasWithSelection
//
// synopsis: obtain a read cookie to process selection API
//
//---------------------------------------------------------------------------+
HRESULT CSapiIMX::_SyncModeBiasWithSelection(ITfContext *pic)
{
    return _RequestEditSession(ESCB_SYNCMBWITHSEL, TF_ES_READ|TF_ES_ASYNC, NULL, pic);
}

HRESULT CSapiIMX::_SyncModeBiasWithSelectionCallback(TfEditCookie ec, ITfContext *pic)
{
    ITfRange *sel;

    if (S_OK == GetSelectionSimple(ec, pic, &sel))
    {
        SyncWithCurrentModeBias(ec, sel, pic);
        sel->Release();
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _GetRangeText
//
// synopsis: obtain a read cookie to process selection API
//
//---------------------------------------------------------------------------+
HRESULT CSapiIMX::_GetRangeText(ITfRange *pRange, DWORD dwFlgs, WCHAR *psz, ULONG *pulcch)
{
    HRESULT hr = E_FAIL;
    
    Assert(pulcch);
    Assert(psz);
    Assert(pRange);

    CComPtr<ITfContext> cpic;
    
    hr = pRange->GetContext(&cpic);
    
    if (S_OK == hr)
    {
        CSapiEditSession *pes = new CSapiEditSession(this, cpic);

        if (pes)
        {
            ULONG  ulInitSize;

            ulInitSize = *pulcch;

            pes->_SetEditSessionData(ESCB_GETRANGETEXT, NULL, (UINT)(ulInitSize+1) * sizeof(WCHAR), (LONG_PTR)dwFlgs, (LONG_PTR)*pulcch);
            pes->_SetRange(pRange);

            cpic->RequestEditSession(_tid, pes, TF_ES_READ | TF_ES_SYNC, &hr);

            if ( SUCCEEDED(hr) )
            {
                ULONG   ulNewSize;

                ulNewSize = (ULONG)pes->_GetRetData( );
                if ( ulNewSize > 0 && ulNewSize <= ulInitSize && pes->_GetPtrData( ) != NULL)
                {
                    wcsncpy(psz, (WCHAR *)pes->_GetPtrData( ), ulNewSize);
                    psz[ulNewSize] = L'\0';
                }

                *pulcch = ulNewSize;
            }

            pes->Release( );
        }
    } 

    return hr;
}

//+---------------------------------------------------------------------------
//
//    _IsRangeEmpty
//
//    synopsis: 
//
//---------------------------------------------------------------------------+
BOOL CSapiIMX::_IsRangeEmpty(ITfRange *pRange)
{
    CComPtr<ITfContext> cpic;
    BOOL fEmpty = FALSE;

    pRange->GetContext(&cpic);
    
    if ( cpic )
    {
        _RequestEditSession(ESCB_ISRANGEEMPTY, TF_ES_READ|TF_ES_SYNC, NULL, cpic, (LONG_PTR *)&fEmpty);
    }
    
    return fEmpty;
}


HRESULT CSapiIMX::_HandleHypothesis(CSpEvent &event)
{
    HRESULT hr = E_FAIL;


    m_ulHypothesisNum ++;
    if ( (m_ulHypothesisNum % 3) != 1 )
    {
        TraceMsg(TF_SAPI_PERF, "Discarded hypothesis %i.", m_ulHypothesisNum % 3);
        return S_OK;
    }

    // if it is under hypothesis processing, don't start a new edit session.
    if ( m_IsInHypoProcessing ) 
    {
        TraceMsg(TF_SAPI_PERF, "It is under process for previous hypothesis");
        return S_OK;
    }

    m_IsInHypoProcessing = TRUE;

    ISpRecoResult *pResult = event.RecoResult();
    if (pResult)
    {
        ESDATA  esData;

        memset(&esData, 0, sizeof(ESDATA));
        esData.pUnk = (IUnknown *)pResult;

        // Require it to be asynchronous to guarantee we don't get called before we have had change
        // to process any final recognition events from SAPI. Otherwise the hypothesis gets injected
        // immediately and then the final recognition tries to remove it which fails.

        hr = _RequestEditSession(ESCB_HANDLEHYPOTHESIS, TF_ES_ASYNC | TF_ES_READWRITE, &esData);
    }

    if ( FAILED(hr) )
    {
        // Set flag to indicate hypothesis processing is finished.
        m_IsInHypoProcessing = FALSE;
    }

    // When hr is succeeded, including TF_S_ASYNC, the edit session function will be called, and
    // it will set the flag when the edit session function exits.

    return hr;
}

void CSapiIMX::_HandleHypothesis(ISpRecoResult *pResult, ITfContext *pic, TfEditCookie ec)
{

    // if there is a selection, do not inject
    // feedback UI
    //
    // save the current IP if we haven't done so
    if (m_pCSpTask->_GotReco())
    {
        // Optimization and bugfix. We already have a reco and hence have no need to update
        // the feedback bar. AND if we do, it gets left in the document at dictation off and
        // voice commands since it gets altered immediately before an attempt to remove it which
        // then silently fails.

        // Set flag to indicate hypothesis processing is finished.
        m_IsInHypoProcessing = FALSE;
        return;
    }
    
    Assert(pic);

    CComPtr<ITfRange> cpRange = GetSavedIP();

    if (cpRange)
    {
        CComPtr<ITfContext> cpic;
        if (S_OK == cpRange->GetContext(&cpic))
        {
            if (cpic != pic)
               cpRange.Release();  // this will set NULL to cpRange
        }
    }
    
    if ( !cpRange )
    {
        SaveCurrentIP(ec, pic);
        cpRange = GetSavedIP();
    }

        
    SPPHRASE *pPhrase = NULL;

    HRESULT hr = pResult->GetPhrase(&pPhrase);
    if (SUCCEEDED(hr) && pPhrase )
    {
        BOOL fEmpty = FALSE;
        if ( cpRange )
            cpRange->IsEmpty(ec, &fEmpty);

        if (cpRange && fEmpty && pPhrase->ullGrammarID == GRAM_ID_DICT)
        {
            CSpDynamicString dstr;
            hr = pResult->GetText( SP_GETWHOLEPHRASE, SP_GETWHOLEPHRASE, TRUE, &dstr, NULL ); 
            if (S_OK == hr)
            {
                int cch = wcslen(dstr);
                BOOL fAware =  IsFocusFullAware(_tim);
                if ( cch > (int)m_ulHypothesisLen )
                {
                    _AddFeedbackUI(ec, 
                                   fAware ? DA_COLOR_AWARE : DA_COLOR_UNAWARE,
                                   5);
                    m_ulHypothesisLen = cch;
                }
            }
        }
        CoTaskMemFree(pPhrase);
    }

    // Set flag to indicate hypothesis processing is finished.
    m_IsInHypoProcessing = FALSE;
}


HRESULT CSapiIMX::_HandleFalseRecognition(void)
{
    m_ulHypothesisLen = 0;
    m_ulHypothesisNum = 0;

    return S_OK;
}

HRESULT CSapiIMX::_HandleRecognition(CSpEvent &event, ULONGLONG *pullGramID)
{
    HRESULT hr = S_OK;

    m_ulHypothesisLen = 0;
    m_ulHypothesisNum = 0;

    ISpRecoResult *pResult = event.RecoResult();
    if (pResult)
    {
        SPPHRASE *pPhrase = NULL;

        hr = pResult->GetPhrase(&pPhrase);
        if (S_OK == hr)
        {
            BOOL        fCommand = FALSE;
            ULONGLONG   ullGramId;
            BOOL        fInjectToDoc = TRUE;

            ullGramId = pPhrase->ullGrammarID;

            if ( ullGramId != GRAM_ID_DICT && ullGramId != GRAM_ID_SPELLING )
            {
                // This is a C&C grammar.
                fCommand = TRUE;
            }
            else if ( ullGramId == GRAM_ID_SPELLING )
            {
                const WCHAR  *pwszName;

                pwszName = pPhrase->Rule.pszName;

                if ( pwszName )
                {
                    if (0 == wcscmp(pwszName, c_szSpelling))
                        fCommand = TRUE;
                    else if ( 0 == wcscmp(pwszName, c_szSpellMode) )
                    {
                        fCommand = TRUE;
                        ullGramId = 0;  // return 0 to fool the handler for SPEI_RECOGNITION
                                        // so that it will not call _SetSpellingGrammarStatus(FALSE);
                    }
                }
            }

            if (pullGramID)
                *pullGramID = ullGramId;

            if ( fCommand == TRUE)
            {
                // If we got the final recognition before a SOUND_END event we should remove the
                // feedback here otherwise it can and is left in the document.
                EraseFeedbackUI(); // Ignore HRESULT for better failure behavior.

                // If candidate UI is open, we need to close it now. This means a voice command (such as scratch that)
                // will cause the candidate UI to close if open.
                CloseCandUI( );

                // we process this reco synchronously
                // _DoCommand internal will start edit session if necessary
                hr = m_pCSpTask->_DoCommand(pPhrase->ullGrammarID, pPhrase, pPhrase->LangID);

                if ( SUCCEEDED(hr) )
                {
                    // if the Command hanlder handles the command successfully, we don't
                    // inject the result to the document.
                    // otherwise, we just inject the text to the document.

                    fInjectToDoc = FALSE;
                }
            }

            if ( fInjectToDoc )
            {
                ESDATA  esData;

                memset(&esData, 0, sizeof(ESDATA));

                esData.pUnk = (IUnknown *)pResult;
                hr = _RequestEditSession(ESCB_HANDLERECOGNITION, TF_ES_READWRITE, &esData);
            }
            CoTaskMemFree(pPhrase);
        }
    }
    else
    {
        return E_OUTOFMEMORY;
    }

    return hr;
}

void CSapiIMX::_HandleRecognition(ISpRecoResult *pResult, ITfContext *pic, TfEditCookie ec)
{
    _KillFeedbackUI(ec, pic, NULL);
    m_pCSpTask->_OnSpEventRecognition(pResult, pic, ec);

    // Before we clear the saved ip range, we need to treat this current ip as last 
    // saved ip range if current ip is selected by end user
    SaveLastUsedIPRange( );

    // clear the saved IP range
    SaveIPRange(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\editsess.cpp ===
//
//
// Sapilayr Edit Sessions implementation.
//
//
#include "private.h"
#include "sapilayr.h"

//
// CEditSessionBase
//

CEditSessionBase::CEditSessionBase(ITfContext *pContext)
{
    _cRef = 1;
    m_cpic = pContext;
    m_pData = NULL;
    m_lData1 = 0;
    m_lData2 = 0;
    m_fBool  = FALSE;
    m_lRetData = 0;
}
    

CEditSessionBase::~CEditSessionBase()
{
    if (m_pData)
        cicMemFree(m_pData);  
}

// IUnknown
HRESULT CEditSessionBase::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_INVALIDARG;
     *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfEditSession))
    {
        *ppvObj = SAFECAST(this, CEditSessionBase *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CEditSessionBase::AddRef(void)
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CEditSessionBase::Release(void)
{
    LONG cr = --_cRef;

    Assert(_cRef >= 0);

    if (_cRef == 0)
    {
        delete this;
    }

    return cr;
}

//
// Set input data memeber and m_idEditSession.
//
HRESULT CEditSessionBase::_SetEditSessionData(UINT idEditSession, void *pData, UINT uByte, LONG_PTR lData1, LONG_PTR lData2, BOOL fBool)
{
    HRESULT  hr = S_OK;

    if ( uByte )
    {
        m_pData = cicMemAlloc(uByte);

        if ( m_pData )
        {
            if ( pData )
                memcpy(m_pData, pData, uByte);
        }
        else
            hr = E_OUTOFMEMORY;
    }

    if ( hr == S_OK )
    {
        m_idEditSession = idEditSession;
        m_lData1 = lData1;
        m_lData2 = lData2;
        m_fBool  = fBool;
    }

    return hr;
}


//
//  CSapiEditSession
//
//
CSapiEditSession::CSapiEditSession(CSapiIMX *pimx, ITfContext *pContext) : CEditSessionBase(pContext)
{
    m_pimx = pimx;
    pimx->AddRef( );
}

CSapiEditSession::~CSapiEditSession( ) 
{
    m_pimx->Release( );
}

//
//  Do the real Edit Session handling for CSapiIMX
//
HRESULT CSapiEditSession::DoEditSession(TfEditCookie ec)
{
    HRESULT hr = S_OK;

    Assert(m_pimx);

    switch(m_idEditSession)
    {
        case ESCB_FINALIZECOMP:
            hr = m_pimx->_KillFocusRange(ec, m_cpic, NULL, m_pimx->_GetId( ) );
            break;

        case ESCB_FINALIZE_ALL_COMPS :
            hr = m_pimx->_FinalizeAllCompositions(ec, m_cpic);
            break;

        case ESCB_FEEDBACKUI:

            hr = m_pimx->_AddFeedbackUI(ec, m_pimx->IsFocusFullAware(m_pimx->_tim)
                                            ? DA_COLOR_AWARE : DA_COLOR_UNAWARE,
                                            (LONG)_GetData1( ));

            break;

        case ESCB_KILLFEEDBACKUI:
            hr = m_pimx->_KillFeedbackUI(ec, m_cpic, _GetRange( ));
            break;

        case ESCB_DETECTFEEDBACKUI:
            hr = m_pimx->_DetectFeedbackUI(ec, m_cpic, _GetRange( ));
            break;

        case ESCB_KILLLASTPHRASE:
            hr = m_pimx->_KillLastPhrase(ec, m_cpic);
            break;

        case ESCB_FEEDCURRENTIP:
            hr = m_pimx->_InternalFeedCurrentIPtoSR(ec, m_cpic);
            break;

        case ESCB_PROCESSCONTROLKEY:
            hr = m_pimx->_ProcessControlKeys(ec, m_cpic, (WCHAR *)_GetPtrData( ), (ULONG)_GetData1( ), (LANGID)_GetData2( ));
            break;
        case ESCB_PROCESS_EDIT_COMMAND :
            hr = m_pimx->_ProcessEditCommands(ec, m_cpic, (ULONG)_GetData1( ));
            break;

        case ESCB_PROCESS_SPELL_THAT :
            hr = m_pimx->_ProcessSpellThat(ec, m_cpic);
            break;

        case ESCB_PROCESS_SPELL_IT :
            hr = m_pimx->_ProcessSpellIt(ec, m_cpic, (WCHAR *)_GetPtrData( ), (LANGID)_GetData1( ));
            break;

        case ESCB_TTS_PLAY :
            hr = m_pimx->_TtsPlay(ec, m_cpic);
            break;

        case ESCB_PROCESS_CAP_COMMANDS :
            if ( m_pimx->GetCapCmdHandler( ))
            {
                CCapCmdHandler  *pCapCmdHandler;

                pCapCmdHandler = m_pimx->GetCapCmdHandler( );
               
                hr = pCapCmdHandler->_ProcessCapCommands(ec, 
                                     m_cpic, 
                                     (CAPCOMMAND_ID)_GetData1( ),
                                     (WCHAR *)_GetPtrData( ), 
                                     (ULONG)_GetData2( )
                                     );

            }

            break;


        case ESCB_SETREPSELECTION:
            // Set the selection which covers the parent phrase range to be replaced by an alternate.
            if (m_cpic && _GetRange( )) 
            {
                // adjust selection based on the length of the alternates and the start position in the parent phrase.
                hr = m_pimx->_SetReplaceSelection(ec, m_cpic, _GetRange( ), (ULONG)_GetData1( ), (ULONG)_GetData2( ));
            }
            break;

        case ESCB_PROCESS_ALTERNATE_TEXT:
            // We have already set the right selection before this function is called.
            hr = m_pimx->_ProcessAlternateText(ec,(WCHAR *)_GetPtrData( ),(LANGID)_GetData1( ), m_cpic, _GetBool( ));
            break;

        case ESCB_RESTORE_CORRECT_ORGIP :
            hr = m_pimx->_RestoreCorrectOrgIP(ec, m_cpic);
            break;

        case ESCB_PROCESSTEXT:
            hr = m_pimx->_ProcessText(ec, (WCHAR *)_GetPtrData( ), (LANGID)_GetData1( ), m_cpic);

            break;

/*  we don't use this editsession, it is replaced by ESCB_INJECT_SPELL_TEXT
        case ESCB_PROCESSTEXT_NO_OWNERID:
            if (m_cpic) 
            {
                hr = m_pimx->_ProcessTextInternal(ec, 
                           (WCHAR *)_GetPtrData( ), GUID_ATTR_SAPI_INPUT, 
                           (LANGID)_GetData1( ), m_cpic, 
                           FALSE, TRUE);
            }
            break;
*/

        case ESCB_INJECT_SPELL_TEXT :
            hr = m_pimx->_ProcessSpelledText(ec, m_cpic, (WCHAR *)_GetPtrData( ), (LANGID)_GetData1( ), _GetBool());
            break;

        case ESCB_PROCESS_MODEBIAS_TEXT :
            hr = m_pimx->_ProcessModebiasText(ec, (WCHAR *)_GetPtrData( ), (LANGID)_GetData1( ), m_cpic); 
            break;

        case ESCB_ATTACHRECORESULTOBJ:

            //  m_cpunk contains the pointer to ISpRecoResult object
            hr = m_pimx->_ProcessRecoObject(ec, (ISpRecoResult *)_GetUnk( ), (ULONG)_GetData1( ), (ULONG)_GetData2( ));
            break;

        case ESCB_HANDLESPACES:
            if (_GetRange( ) && m_cpic)
                hr = m_pimx->_ProcessSpaces( ec, 
                                             m_cpic,
                                             _GetRange( ), 
                                             _GetBool( ), 
                                             (ULONG)_GetData2( ), 
                                             (LANGID)_GetData1( ));
            break;
            
        case ESCB_COMPLETE:
            hr = m_pimx->MakeResultString(ec, m_cpic, _GetRange( ), m_pimx->_tid, m_pimx->m_pCSpTask);
            break;

        case ESCB_ABORT:
            hr = m_pimx->AbortString(ec, m_cpic, m_pimx->m_pCSpTask);
            break;

        case ESCB_RECONV_ONIP:
            hr = m_pimx->_CorrectThat(ec, m_cpic);
            break;
            
        case ESCB_UPDATEFILTERSTR:
            hr = m_pimx->_SetFilteringString(ec, (ITfCandidateUI *)_GetUnk( ), m_cpic);
            break;
            
        case ESCB_SYNCMBWITHSEL:
            hr = m_pimx->_SyncModeBiasWithSelectionCallback(ec, m_cpic);
            break;
        
        case ESCB_GETRANGETEXT:

            WCHAR  *pText;
            ULONG  ulSize;
 
            pText = (WCHAR *)_GetPtrData( );
            ulSize = (ULONG)_GetData2( );

            hr =  _GetRange( )->GetText(ec, (ULONG)_GetData1( ), pText, ulSize, (ULONG *)&m_lRetData);
            break;

        case ESCB_ISRANGEEMPTY:
            hr =  _GetRange( )->IsEmpty(ec, (BOOL *)&m_lRetData);
            break;

        case ESCB_HANDLE_ADDDELETE_WORD:
            hr =  m_pimx->_HandleAddDeleteWord(ec, m_cpic);
            break;

        case ESCB_HANDLE_LEARNFROMDOC:
            hr =  m_pimx->_HandleLearnFromDoc(ec, m_cpic, (ITfDocumentMgr *)_GetUnk( ));
            break;

        case ESCB_LEARNDOC_NEXTRANGE:
            hr =  m_pimx->_HandleNextRange(ec, (ULONG)_GetData1( ));
            break;

        case ESCB_HANDLERECOGNITION:
            m_pimx->_HandleRecognition((ISpRecoResult *)_GetUnk( ), m_cpic, ec);
            break; 
            
        case ESCB_HANDLEHYPOTHESIS:
            m_pimx->_HandleHypothesis((ISpRecoResult *)_GetUnk( ), m_cpic, ec);
            break;

        case ESCB_SAVECURIP_ADDDELETEUI:
            hr = m_pimx->_SaveCurIPAndHandleAddDeleteUI(ec, m_cpic);
            break;

        case ESCB_HANDLE_MOUSESINK:

            hr = m_pimx->_HandleMouseSink(ec, (ULONG)_GetData1(), (ULONG)_GetData2(), _GetBool());
            break;

        default:
            Assert(0);
            break;
    }

    return hr;
}


//
//  CSelWordEditSession
//
CSelWordEditSession::CSelWordEditSession(CSapiIMX *pimx, CSelectWord *pSelWord, ITfContext *pContext) : CSapiEditSession(pimx, pContext)
{
    m_pSelWord = pSelWord;
}
    
CSelWordEditSession::~CSelWordEditSession( )
{
}

//
// Real Edit Session handling for Selection related commands.
//
HRESULT CSelWordEditSession::DoEditSession(TfEditCookie ec)
{
    HRESULT hr = S_OK;

    Assert(m_pSelWord);

    switch(m_idEditSession)
    {
        case ESCB_UPDATE_TEXT_BUFFER :
            hr = m_pSelWord->_UpdateTextBuffer(ec, m_cpic, (ISpRecoContext *)_GetUnk(), (ISpRecoGrammar *)_GetUnk2() );
            break;

        case ESCB_PROCESSSELECTWORD :
            hr = m_pSelWord->_HandleSelectWord(ec, m_cpic, (WCHAR *)_GetPtrData( ),(ULONG)_GetData1( ),(SELECTWORD_OPERATION)_GetData2( ), (ULONG)_GetLenXXX( ) );
            break;

        default:
            Assert(0);
            break;
    }

    return hr;
}

//
//  CPlayBackEditSession
//
//
CPlayBackEditSession::CPlayBackEditSession(CSapiPlayBack *pPlayBack, ITfContext *pContext) : CEditSessionBase(pContext)
{
    m_pPlayBack = pPlayBack;
    m_pPlayBack->AddRef( );
}
    
CPlayBackEditSession::~CPlayBackEditSession( )
{
    m_pPlayBack->Release( );
}

//
// Real Edit Session handling for PlayBack.
//
HRESULT CPlayBackEditSession::DoEditSession(TfEditCookie ec)
{
    HRESULT hr = S_OK;

    Assert(m_pPlayBack);

    switch(m_idEditSession)
    {
        case ESCB_PLAYBK_PLAYSND:
            return m_pPlayBack->_PlaySound(ec, _GetRange( ) );

        case ESCB_PLAYBK_PLAYSNDSELECTION:
            return m_pPlayBack->_PlaySoundSelection(ec, m_cpic);

        default:
            Assert(0);
            break;
    }

    return hr;
}

//
//  CFnRecvEditSession
//
CFnRecvEditSession::CFnRecvEditSession(CFnReconversion *pFnRecv, ITfRange *pRange, ITfContext *pContext) : CEditSessionBase(pContext)
{
    m_pFnRecv = pFnRecv;
    m_pFnRecv->AddRef( );
    _SetRange(pRange);
}
    
CFnRecvEditSession::~CFnRecvEditSession( )
{
    m_pFnRecv->Release( );
}

//
// Real Edit Session for Reconvertion.
//
HRESULT CFnRecvEditSession::DoEditSession(TfEditCookie ec)
{
    HRESULT hr = S_OK;

    Assert(m_pFnRecv);

    switch(m_idEditSession)
    {
        case ESCB_RECONV_QUERYRECONV:
            return m_pFnRecv->_QueryReconversion(ec, m_cpic, _GetRange( ), (ITfRange **)&m_cpRetUnk);

        case ESCB_RECONV_GETRECONV:
            return m_pFnRecv->_GetReconversion(ec, m_cpic, _GetRange( ), (ITfCandidateList **)&m_cpRetUnk, TRUE);

        case ESCB_RECONV_RECONV:
            return m_pFnRecv->_Reconvert(ec, m_cpic, _GetRange( ), (BOOL *)&m_lRetData);

        default:
            Assert(0);
            break;
    }

    return hr;
}

//
//  CPSRecoEditSession
//
CPSRecoEditSession::CPSRecoEditSession(CPropStoreRecoResultObject *pPropStoreReco, ITfRange *pRange, ITfContext *pContext) : CEditSessionBase(pContext)
{
    m_pPropStoreReco = pPropStoreReco;
    m_pPropStoreReco->AddRef( );
    _SetRange(pRange);
}
    
CPSRecoEditSession::~CPSRecoEditSession( )
{
    m_pPropStoreReco->Release( );
}

//
// Real Edit Session handling for RecoResult Property Store
//
HRESULT CPSRecoEditSession::DoEditSession(TfEditCookie ec)
{
    HRESULT hr = S_OK;

    Assert(m_pPropStoreReco);

    switch(m_idEditSession)
    {
        case ESCB_PROP_DIVIDE:
            hr = m_pPropStoreReco->_Divide(ec,_GetRange( ),(ITfRange *)_GetUnk( ),(ITfPropertyStore **)&m_cpRetUnk);
            break;

        case ESCB_PROP_SHRINK:
            hr = m_pPropStoreReco->_Shrink(ec,_GetRange( ), (BOOL *)&m_lRetData);
            break;

        case ESCB_PROP_TEXTUPDATE:
            hr = m_pPropStoreReco->_OnTextUpdated(ec, (DWORD)_GetData1( ), _GetRange( ), (BOOL *)&m_lRetData);

            break;
 
        default:
            Assert(0);
            break;
    }

    return hr;
}

//
//  CPSLMEditSession
//
CPSLMEditSession::CPSLMEditSession(CPropStoreLMLattice *pPropStoreLM, ITfRange *pRange, ITfContext *pContext) : CEditSessionBase(pContext)
{
    m_pPropStoreLM = pPropStoreLM;
    m_pPropStoreLM->AddRef( );
    _SetRange(pRange);
}
    
CPSLMEditSession::~CPSLMEditSession( )
{
    m_pPropStoreLM->Release( );
}

// 
// Real edit session for Language Model Property Store.
//
HRESULT CPSLMEditSession::DoEditSession(TfEditCookie ec)
{
    HRESULT hr = S_OK;

    Assert(m_pPropStoreLM);

    switch(m_idEditSession)
    {
        case ESCB_PROP_DIVIDE:
            hr = m_pPropStoreLM->_Divide(ec,_GetRange( ),(ITfRange *)_GetUnk( ), (ITfPropertyStore **)&m_cpRetUnk);
            break;

        default:
            Assert(0);
            break;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\fnrecon.cpp ===
//
// reconv.cpp
//

#include "private.h"
#include "globals.h"
#include "sapilayr.h"
#include "fnrecon.h"
#include "immxutil.h"
#include "candlist.h"
#include "propstor.h"
#include "catutil.h"
#include "osver.h"
#include "mui.h"
#include "tsattrs.h"
#include "cregkey.h"
#include <htmlhelp.h>
#include "TabletTip_i.c"
#include "spgrmr.h"

HRESULT   HandlePhraseElement( CSpDynamicString *pDstr, const WCHAR  *pwszTextThis, BYTE  bAttrThis, BYTE bAttrPrev, ULONG  *pulOffsetThis);

//////////////////////////////////////////////////////////////////////////////
//
// CSapiAlternativeList
//
//////////////////////////////////////////////////////////////////////////////

// ctor/dtor
CSapiAlternativeList::CSapiAlternativeList(LANGID langid, ITfRange *pRange, ULONG  ulMaxCandChars)
{
    m_nItem = 0;
    m_ulStart = 0;
    m_ulcElem = 0;
    m_cAlt = 0;
    m_ppAlt = NULL;
    m_langid = langid;
    m_cpRange = pRange;
    m_fFirstAltInCandidate = FALSE;
    m_fNoAlternate = FALSE;
    m_iFakeAlternate = NO_FAKEALT;
    m_MaxCandChars = ulMaxCandChars;
    m_ulIndexSelect = 0;
}

CSapiAlternativeList::~CSapiAlternativeList()
{
    UINT i;
    for (i = 0; i < m_cAlt; i++)
    {
        if (NULL != m_ppAlt[i])
        {
            m_ppAlt[i]->Release();
        }
    }
    if (m_prgLMAlternates)
    {
        int nItem = m_prgLMAlternates->Count();
        for (i = 0; i < (UINT)nItem; i++)
        {
           CLMAlternates *plmalt = m_prgLMAlternates->Get(i);

           if (plmalt)
               delete plmalt;
       }
       delete m_prgLMAlternates;
   }
   if (m_ppAlt)
       cicMemFree(m_ppAlt);
       
   if (m_rgElemUsed.Count())
   {
       for ( i=0; i<(UINT)m_rgElemUsed.Count(); i++)
       {
           SPELEMENTUSED *pElemUsed;

           pElemUsed = m_rgElemUsed.GetPtr(i);

           if ( pElemUsed && pElemUsed->pwszAltText)
           {
               cicMemFree(pElemUsed->pwszAltText);
               pElemUsed->pwszAltText = NULL;
           }
       }
       m_rgElemUsed.Clear();
   }

}

//
//  AddLMAlternates
//
HRESULT CSapiAlternativeList::AddLMAlternates(CLMAlternates *pLMAlt)
{
    HRESULT hr = E_FAIL;
    BOOL fFoundADup = FALSE;
    if (!pLMAlt)
        return E_INVALIDARG;

    if (!m_prgLMAlternates)
    {
        m_prgLMAlternates =  new CPtrArray<CLMAlternates>;
    }

    if (m_prgLMAlternates)
    {
        int iIdx = m_prgLMAlternates->Count();
        
        // need to find a dup
        for (int i = 0; i < iIdx && !fFoundADup ; i++)
        {
            CLMAlternates *plma = m_prgLMAlternates->Get(i);
            if (plma)
            {
                WCHAR *pszStored = new WCHAR[plma->GetLen()+1];
                WCHAR *pszAdding = new WCHAR[pLMAlt->GetLen()+1];
                
                if (pszStored && pszAdding)
                {

                    plma->GetString(pszStored, plma->GetLen()+1);
                    pLMAlt->GetString(pszAdding, pLMAlt->GetLen()+1);

                    if (!wcscmp(pszAdding, pszStored))
                    {
                        fFoundADup = TRUE;
                    }
                }

                if (pszStored) 
                    delete[] pszStored;

                if (pszAdding) 
                    delete[] pszAdding;
            }
        }
    
        if (!fFoundADup && pLMAlt)
        {
            if (!m_prgLMAlternates->Insert(iIdx, 1))
                return E_OUTOFMEMORY;

            m_prgLMAlternates->Set(iIdx, pLMAlt);
            hr = S_OK;
        }
    }
    return hr;
}

// SetPhraseAlt
//
// synopsis: receive an alternates list as a param and copy the alternates
//           to the array which this class internally maintains.
//           Additionally, a pointer to the reco result wrapper
//           is maintained per CSapiAlternativeList class instance.
//
// params    pResWrap - a pointer to the wrapper object
//           ppAlt - a pointer to the array of phrases that the callar has alloced
//           cAlt - is passed in with the # of real SAPI alternates
//           ulStart - index to the start element in the parent phrase
//           culElem - # of minimum elements used (will get replaced) in the parent phrase.
//
HRESULT CSapiAlternativeList::SetPhraseAlt(CRecoResultWrap *pResWrap, ISpPhraseAlt **ppAlt, ULONG cAlt, ULONG ulStart, ULONG ulcElem, WCHAR *pwszParent)
{
    // setup the info for used elements in parent phrase
    // these are useful for the 0 index (ITN) alternate

    HRESULT  hr = S_OK;
    SPPHRASE *pParentPhrase = NULL;
    CSpDynamicString dstr;

    if ( !pResWrap || !ppAlt || !pwszParent )
        return E_INVALIDARG;

    m_ulStart = ulStart;
    m_ulcElem = ulcElem;



    m_fFirstAltInCandidate = FALSE;  
    m_fNoAlternate = FALSE;
    m_iFakeAlternate = NO_FAKEALT;
    
    // alloc the struct for the used element info
    m_rgElemUsed.Append(cAlt);

    for ( int i=0; i<m_rgElemUsed.Count( ); i++)
    {
        SPELEMENTUSED *pElemUsed;
        if ( pElemUsed = m_rgElemUsed.GetPtr(i))
        {
            pElemUsed->pwszAltText = NULL;
        }
    }

    // comptr releases on the previous object
    // at this indirection
    //
    Assert(pResWrap);
    
    m_cpwrp = pResWrap;
    
    if (m_ppAlt)
    {
        for (UINT i = 0; i < m_cAlt; i++)
        {
            if (NULL != m_ppAlt[i])
            {
                m_ppAlt[i]->Release();
            }
        }
        cicMemFree(m_ppAlt);
        m_ppAlt = NULL;
    }

    m_ppAlt = (ISpPhraseAlt **)cicMemAlloc(sizeof(*ppAlt)*cAlt);
    if (!m_ppAlt)
        return E_OUTOFMEMORY;
    
    Assert(ppAlt);

#ifdef DONTUSE

    // Get the current select text in parent phrase.
    CComPtr<IServiceProvider> cpServicePrv;
    CComPtr<ISpRecoResult>    cpResult;

    hr = m_cpwrp->QueryInterface(IID_IServiceProvider, (void **)&cpServicePrv);

    if ( S_OK == hr )
        hr = cpServicePrv->QueryService(GUID_NULL, IID_ISpRecoResult, (void **)&cpResult);

    if (S_OK == hr)
    {
        CSpDynamicString dstrReplace;

        cpResult->GetPhrase(&pParentPhrase);
 
        for (ULONG i = m_ulStart; i < m_ulStart + m_ulcElem; i++ )
        {
            BOOL      fInsideITN;
            ULONG     ulITNStart, ulITNNumElem;
               
            fInsideITN = m_cpwrp->_CheckITNForElement(pParentPhrase, i, &ulITNStart, &ulITNNumElem, (CSpDynamicString *)&dstrReplace);

            if ( fInsideITN )
            {
                // This element is inside an ITN range.
                if ( i == (ulITNStart + ulITNNumElem - 1) )
                {
                    // This is the last element of the new ITN.
                    // we need to add the replace text to the dstr string 
                    // so that next non-ITN element will get correct offset.

                    dstr.Append( (WCHAR *)dstrReplace );
                }
            }
            else
            {
                if (pParentPhrase->pElements[i].pszDisplayText)
                {
                    const WCHAR   *pwszTextThis;
                    BYTE           bAttrThis = 0;
                    BYTE           bAttrPrev = 0;

                    pwszTextThis = pParentPhrase->pElements[i].pszDisplayText;
                    bAttrThis = pParentPhrase->pElements[i].bDisplayAttributes;

                    if ( i > m_ulStart )
                        bAttrPrev = pParentPhrase->pElements[i-1].bDisplayAttributes;

                    HandlePhraseElement( (CSpDynamicString *)&dstr, pwszTextThis, bAttrThis, bAttrPrev,NULL);
                }
            }
        } // for 

        pwszParent = (WCHAR *)dstr;

        if (pParentPhrase)
            CoTaskMemFree(pParentPhrase); 
    }
#endif
            
    UINT j=0;

    if ( pwszParent )
    {
        ULONG     ulRecoWrpStart, ulRecoWrpNumElements;
        WCHAR    *pwszFakeAlt = NULL;  // This is for Capitalized string for parent phrase.

        if ( iswalpha(pwszParent[0]) )
        {
            int   iStrLen = wcslen(pwszParent); 
            
            pwszFakeAlt = (WCHAR *)cicMemAlloc((iStrLen+1) * sizeof(WCHAR));

            if ( pwszFakeAlt )
            {
                WCHAR  wch;

                wch = pwszParent[0];
                StringCchCopyW(pwszFakeAlt, iStrLen+1,  pwszParent);

                if ( iswlower(wch) )
                    pwszFakeAlt[0] = towupper(wch);
                else
                    pwszFakeAlt[0] = towlower(wch);

                int iLen = wcslen(pwszFakeAlt);

                if ( (iLen > 0) &&  (pwszFakeAlt[iLen-1] < 0x20) )
                    pwszFakeAlt[iLen-1] = L'\0';
            }
        }

        ulRecoWrpStart = pResWrap->GetStart( );
        ulRecoWrpNumElements = pResWrap->GetNumElements( );

        ULONG     ValidParentStart, ValidParentEnd;   // Point to the valid parent element range which could be matched by 
                                                      // the alternative phrase.

        int       ShiftDelta = 2;     // We just want to shift the valid parent element range by ShiftDelta elements from current
                                      // start and end element in parent phrase.

                                      // ie,  ulStart - 3,  ulEnd + 3,   if they are in the valid range of the reco wrapper.   

        ValidParentStart = ulRecoWrpStart;
        if ( ((int)ulStart - ShiftDelta) > (int)ulRecoWrpStart )
            ValidParentStart = ulStart - ShiftDelta;

        ValidParentEnd = ulRecoWrpStart + ulRecoWrpNumElements  - 1;
        if ( ((int)ulStart + (int)ulcElem -1 + ShiftDelta) < (int)ValidParentEnd )
            ValidParentEnd = ulStart + ulcElem - 1 + ShiftDelta;

        CComPtr<ISpRecoResult>    cpResult;
        pResWrap->GetResult(&cpResult);
        cpResult->GetPhrase(&pParentPhrase);

        for (UINT i = 0; (i < cAlt) && (j < cAlt) && *ppAlt; i++, ppAlt++)
        {
            SPPHRASE *pPhrases = NULL;
            ULONG     ulcElements = 0;
            ULONG     ulParentStart     = 0;
            ULONG     ulcParentElements  = 0;
            ULONG     ulLeadSpaceRemoved = 0;

            // Assume the first alt phrase is exactly same as the parent phrase.
            // practically it is true so far.
            // if it is not true in the future, we may need to change logical here!!!

            (*ppAlt)->GetPhrase(&pPhrases);
            (*ppAlt)->GetAltInfo(NULL, &ulParentStart, &ulcParentElements, &ulcElements);

            if ( (ulParentStart >= ValidParentStart) && ( ulParentStart+ulcParentElements -1 <= ValidParentEnd) )
            {
                WCHAR *pwszAlt = (WCHAR *)cicMemAllocClear((m_MaxCandChars+1)*sizeof(WCHAR));

                if ( !pwszAlt )
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }

                BOOL    fAddToCandidateList = FALSE;
                BOOL    fControlCharsInAltPhrase = FALSE;

                // Add code to skip start and end elements which are the same as parent phrase's elements.
                UINT    ulSkipStartWords = 0;
                UINT    ulSkipEndWords = 0;

                for (UINT k = ulParentStart; k < ulStart; k++)
                {
                    if (_wcsicmp(pPhrases->pElements[k].pszDisplayText, pParentPhrase->pElements[k].pszDisplayText) == 0)
                    {
                        // Matching pre-word in alternate. This is redundant.
                        ulSkipStartWords ++;
                    }
                    else
                    {
                        // Do not match. Stop processing.
                        break;
                    }
                }

                for (UINT k = ulParentStart + ulcParentElements - 1; k >= ulStart + ulcElem ; k--)
                {
                    // Count backwards in alternate phrase.
                    UINT l = ulParentStart + ulcElements - ((ulParentStart + ulcParentElements) - k);
                    if (_wcsicmp(pPhrases->pElements[l].pszDisplayText, pParentPhrase->pElements[k].pszDisplayText) == 0)
                    {
                        ulSkipEndWords ++;
                    }
                    else
                    {
                        // Do not match. Stop processing.
                        break;
                    }
                }

                ulParentStart += ulSkipStartWords;
                ulcElements -= ulSkipStartWords + ulSkipEndWords;
                ulcParentElements -= ulSkipStartWords + ulSkipEndWords;

                hr = GetAlternativeText(*ppAlt, pPhrases, (i ==0 ? TRUE : FALSE), ulParentStart, ulcElements, pwszAlt, m_MaxCandChars, &ulLeadSpaceRemoved);

                if ( S_OK == hr )
                {
                    for ( ULONG iIndex =0; iIndex < wcslen(pwszAlt); iIndex++ )
                    {
                        if ( pwszAlt[iIndex] < 0x20 )
                        {
                            fControlCharsInAltPhrase = TRUE;
                            break;
                        }
                    }
                }

                BOOL   fNotDupAlt = TRUE;
                
                if ( S_OK == hr && pwszAlt )
                {
                    fNotDupAlt = _wcsicmp(pwszAlt, pwszParent);
                    if ( fNotDupAlt && (j>0) )
                    {
                        SPELEMENTUSED *pElemUsed;

                        for (UINT x=0; x<j; x++ )
                        {
                            if ( pElemUsed = m_rgElemUsed.GetPtr(x))
                                fNotDupAlt = _wcsicmp(pwszAlt, pElemUsed->pwszAltText);

                            if ( !fNotDupAlt )
                                break;
                        }
                    }
                }

                if ((S_OK == hr) && !fControlCharsInAltPhrase && (pwszAlt[0] != L'\0') && fNotDupAlt)
                {
                    // This is different item from the parent, it should be inserted to the canidate list.
                    // initialize the AltCached item

                    if ( (i > 0) || (pResWrap->_RangeHasITN(ulParentStart, ulcParentElements) > 0 ) )
                    {

                        SPELEMENTUSED *pElemUsed;
                        if ( pElemUsed = m_rgElemUsed.GetPtr(j))
                        {
                            pElemUsed->ulParentStart = ulParentStart;
                            pElemUsed->ulcParentElements = ulcParentElements;
                            pElemUsed->ulcElements = ulcElements;
                            pElemUsed->pwszAltText = pwszAlt;
                            pElemUsed->ulLeadSpaceRemoved = ulLeadSpaceRemoved;

                            m_ppAlt[j] = *ppAlt;
                            m_ppAlt[j]->AddRef();
                            j ++;

                            if ( i == 0 )
                            {
                                // The first Alt phrase is also in the canidate list. the selectedd range must contain ITN.
                                m_fFirstAltInCandidate = TRUE;
                            }

                            fAddToCandidateList = TRUE;
                        }
                    }
                }

                if ( fAddToCandidateList == FALSE )
                {
                    // Same string. or GetAlternativeText returns Error.
                    // don't insert it into the candidate list.

                    // Release the alloced memory 
                    cicMemFree(pwszAlt);
                }

                // Handle Faked Alternate
                if ((i == 0) && (pwszFakeAlt != NULL))
                {
                    // This is the parent phrase, Only the first character is capitalized.
                    SPELEMENTUSED *pElemUsed;
                    if ( pElemUsed = m_rgElemUsed.GetPtr(j))
                    {
                        pElemUsed->ulParentStart = ulParentStart;
                        pElemUsed->ulcParentElements = ulcParentElements;
                        pElemUsed->ulcElements = ulcElements;
                        pElemUsed->pwszAltText = pwszFakeAlt;
                        pElemUsed->ulLeadSpaceRemoved = 0;

                        m_iFakeAlternate = j;
                                        
                        m_ppAlt[j] = *ppAlt;
                        m_ppAlt[j]->AddRef();
                        j ++;
                    }
                }
            }

            if (pPhrases)
                 CoTaskMemFree( pPhrases ); 
        }

        if (pParentPhrase)
        {
            CoTaskMemFree(pParentPhrase); 
        }

        if ( pwszFakeAlt && (m_iFakeAlternate == NO_FAKEALT) )
            cicMemFree(pwszFakeAlt);
    }

    m_cAlt = j;

    if ( S_OK == hr )
    {
        if ( m_cAlt == 0 )
        {
            // There is no available Alternate.
            // Just show string "No Alternate" in the candidate window.
            m_fNoAlternate = TRUE;

            SPELEMENTUSED *pElemUsed;
            WCHAR  *pwszNoAlt=(WCHAR *)cicMemAllocClear(m_MaxCandChars*sizeof(WCHAR));

            if ( (pElemUsed = m_rgElemUsed.GetPtr(0)) && pwszNoAlt )
            {
                pElemUsed->ulParentStart = m_ulStart;
                pElemUsed->ulcParentElements = m_ulcElem;
                pElemUsed->ulcElements = m_ulcElem;
                pElemUsed->ulLeadSpaceRemoved = 0;

                CicLoadStringWrapW(g_hInst, IDS_NO_ALTERNATE, pwszNoAlt, m_MaxCandChars);

                pElemUsed->pwszAltText = pwszNoAlt;

                CComPtr<IServiceProvider> cpServicePrv;
                CComPtr<ISpRecoResult>    cpResult;

                hr = m_cpwrp->QueryInterface(IID_IServiceProvider, (void **)&cpServicePrv);
    
                if ( S_OK == hr )
                    hr = cpServicePrv->QueryService(GUID_NULL, IID_ISpRecoResult, (void **)&cpResult);

                if ( (hr == S_OK) && cpResult ) 
                {
                    m_ppAlt[0] = (ISpPhraseAlt *)(ISpRecoResult *)cpResult;
                    m_ppAlt[0]->AddRef();
                }

                m_cAlt = 1;
            }
        }
    }
    else
    {
        // Release all the allocated memeory and AltCached Items in this function.
        UINT i;
        if (m_ppAlt)
        {
            for (i = 0; i < m_cAlt; i++)
            {
                m_ppAlt[i]->Release();
                m_ppAlt[i] = NULL;
            }
            cicMemFree(m_ppAlt);
            m_ppAlt = NULL;
        }
       
        if (m_rgElemUsed.Count())
        {
            for ( i=0; i<(UINT)m_rgElemUsed.Count(); i++)
            {
                SPELEMENTUSED *pElemUsed;

                pElemUsed = m_rgElemUsed.GetPtr(i);

                if ( pElemUsed && pElemUsed->pwszAltText)
                {
                    cicMemFree(pElemUsed->pwszAltText);
                    pElemUsed->pwszAltText = NULL;
                }
            }

            m_rgElemUsed.Clear();
        }

        m_cAlt = 0;
    }

    return hr;
}

//    GetNumItem
//
//
int CSapiAlternativeList::GetNumItem(void)
{
    if (!m_nItem)
        m_nItem = m_cAlt;
        
    if ( m_prgLMAlternates )
    {
        return m_nItem + m_prgLMAlternates->Count();
    }
    else
        return m_nItem;
}


HRESULT CSapiAlternativeList::_ProcessTrailingSpaces(SPPHRASE *pPhrases, ULONG  ulNextElem, WCHAR *pwszAlt)
{
    HRESULT  hr = S_OK;
    ULONG    ulSize;
    BOOL     fRemoveTrail;

    if ( !pwszAlt || !pPhrases)
        return E_INVALIDARG;

    if ( ulNextElem >= pPhrases->Rule.ulCountOfElements)
    {
        // NextElement is not a valid element
        return hr;
    }

    if ( pPhrases->pElements[ulNextElem].bDisplayAttributes & SPAF_CONSUME_LEADING_SPACES )
        fRemoveTrail = TRUE;
    else
        fRemoveTrail = FALSE;

    if ( !fRemoveTrail )
        return hr;

    ulSize = wcslen(pwszAlt);

    for ( ULONG i=ulSize; i>0; i-- )
    {
        if ( (pwszAlt[i-1] != L' ') && (pwszAlt[i-1] != L'\t') )
            break;

        pwszAlt[i-1] = L'\0';
    }

    return hr;
}

HRESULT CSapiAlternativeList::GetAlternativeText(ISpPhraseAlt *pAlt,SPPHRASE *pPhrases, BOOL  fFirstAlt, ULONG  ulStartElem, ULONG ulNumElems, WCHAR *pwszAlt, int cchAlt, ULONG *pulLeadSpaceRemoved)
{
    HRESULT hr = S_OK;
    CSpDynamicString sds;
    ULONG   ulLeadSpaceRemoved = 0;

    if ( !pPhrases  || !pwszAlt || !cchAlt || !pulLeadSpaceRemoved)
        return E_INVALIDARG;

    if ( !pAlt )
        return E_INVALIDARG;

    // We assume the first phrase in the AltPhrase list is exactly same as the parent phrase.
    // Specially handle it when it contains ITN.

    if ((m_cpwrp->m_ulNumOfITN > 0) && fFirstAlt)
    {
        // the ITN is always index 0
        //
        CSpDynamicString dstr;
        //
        // this seems confusing but fITNShown indicates whether the ITN
        // is displayed on the doc. 

        // We no longer use fITNShown to inidicates the ITN show state.
        // Because there are may be more  ITNs in one phrase, and every ITN may have 
        // different show state on the doc.
        // Now we use an ITNSHOWSTATE list to keep the display state for individual ITN.

        // So we have to include non-ITN in the alternates if the ITN is on the doc,
        // and include the ITN  in the alternates if the non-ITN is on the doc.
        //
                
        ULONG ulRepCount = 0;

        if (pPhrases->Rule.ulCountOfElements > 0)
        {
            for (UINT i = 0; i < pPhrases->Rule.ulCountOfElements; i++ )
            {
                if (i >= ulStartElem && i < ulStartElem + ulNumElems)
                {
                    ULONG  ulITNStart, ulITNNumElem;
                    BOOL   fITNShown = FALSE;
                    BOOL   fInsideITN = FALSE;

                    // Check to see if this element is inside an ITN,
                    // and if this ITN is shown up in the current Doc.

                    for ( ulRepCount=0; ulRepCount<pPhrases->cReplacements; ulRepCount++)
                    {

                        ulITNStart = pPhrases->pReplacements[ulRepCount].ulFirstElement;
                        ulITNNumElem = pPhrases->pReplacements[ulRepCount].ulCountOfElements;
    
                        if ( (i == ulITNStart) && ((i + ulITNNumElem) <= pPhrases->Rule.ulCountOfElements))
                        {
                            // This element is in an ITN.

                            fInsideITN = TRUE;

                            // check if this ITN is shown as ITN in current DOC

                            for ( ULONG iIndex=0; iIndex < m_cpwrp->m_ulNumOfITN; iIndex ++ )
                            {
                                SPITNSHOWSTATE  *pITNShowState;

                                pITNShowState = m_cpwrp->m_rgITNShowState.GetPtr(iIndex);
                                if ( pITNShowState )
                                {
                                    if ( (pITNShowState->ulITNStart == ulITNStart)
                                        && (pITNShowState->ulITNNumElem == ulITNNumElem) )
                                    {
                                        fITNShown = pITNShowState->fITNShown;
                                        break;
                                    }
                                }
                            }

                            break;
                        }
                    }

                    // use ITN version for an alternate when it is not shown in the parent
                    BOOL fUseITN = fInsideITN && !fITNShown;
                            
                    if ( fUseITN && (ulRepCount < pPhrases->cReplacements) )
                    {
                        sds.Append(pPhrases->pReplacements[ulRepCount].pszReplacementText);
                        i += pPhrases->pReplacements[ulRepCount].ulCountOfElements - 1;

                        if (pPhrases->pReplacements[ulRepCount].bDisplayAttributes & SPAF_ONE_TRAILING_SPACE)
                        {
                            sds.Append(L" ");
                        }
                        else if (pPhrases->pReplacements[ulRepCount].bDisplayAttributes & SPAF_TWO_TRAILING_SPACES)
                        {
                            sds.Append(L"  ");
                        }
  
                    }
                    else
                    {
                        const WCHAR   *pwszTextThis;
                        BYTE           bAttrThis = 0;
                        BYTE           bAttrPrev = 0;

                        pwszTextThis = pPhrases->pElements[i].pszDisplayText;
                        bAttrThis = pPhrases->pElements[i].bDisplayAttributes;

                        if ( i > m_ulStart )
                            bAttrPrev = pPhrases->pElements[i-1].bDisplayAttributes;

                        HandlePhraseElement( (CSpDynamicString *)&sds, pwszTextThis, bAttrThis, bAttrPrev,NULL);
                    }
                }
            }
        }
    }
    else
    {
        // This is not the first Altphrase.
        // Or even if it is the first Altphrase, but there is no ITN in this phrase
        ULONG     ulcElements = 0;
        ULONG     ulParentStart     = 0;
        ULONG     ulcParentElements  = 0;

        if (pPhrases->Rule.ulCountOfElements > 0)
        {
            //
            // If the start element is not the first element in parent phrase, 
            // and it has SPAF_CONSUME_LEADING_SPACES attr in parent phrase,
            // but this start element doesn't have SPAF_CONSUME_LEADING_SPACES in
            // the alternate phrase, 
            // in this case, we need to add leading space in this alternate text.
            // the number of spaces can be found from previous element's attribute,
            // or the replacement's attribute if the previous phrase is displayed with
            // replacement text.
            // 
            // Example here, if you dictate: "this is a test, this is good example."
            //
            // element test has one trail space.
            // element "," has SPAF_CONSUME_LEADING_SPACES.
            //
            // When you select "," to get alternate, the alternate could be "of,", "to,"
            // in the alternate phrase, the start element doesn't have SPAF_CONSUME_LEADING_SPACES
            // attr. in this case, the alternate text needs to add one space, so the text would be " of,"
            // " to,". otherwise, when user selects this alternate, the new text would be like
            // "this is a testof,....".  ( there is no space between test and of ).
            //

            if ( ulStartElem > m_cpwrp->GetStart( ) )
            {
                BYTE  bAttrParent, bAttrPrevParent;
                BYTE  bAttrAlternate;
                ULONG ulPrevSpace = 0;
                
                bAttrParent = m_cpwrp->_GetElementDispAttribute(ulStartElem);
                bAttrPrevParent = m_cpwrp->_GetElementDispAttribute(ulStartElem - 1);

                bAttrAlternate = pPhrases->pElements[ulStartElem].bDisplayAttributes;

                if ( bAttrPrevParent & SPAF_ONE_TRAILING_SPACE )
                    ulPrevSpace = 1;
                else if ( bAttrPrevParent & SPAF_TWO_TRAILING_SPACES )
                    ulPrevSpace = 2;

                if ( (bAttrParent & SPAF_CONSUME_LEADING_SPACES)  &&
                     !(bAttrAlternate & SPAF_CONSUME_LEADING_SPACES) &&
                     ulPrevSpace > 0)
                {
                    // Add the required spaces for the previous element
                    // which was removed before when parent phrase showed up.
                    sds.Append( (ulPrevSpace == 1 ? L" " :  L"  ") );
                }

                if ( !(bAttrParent & SPAF_CONSUME_LEADING_SPACES) &&
                     (bAttrAlternate & SPAF_CONSUME_LEADING_SPACES) &&
                     ulPrevSpace > 0 )
                {
                    // the previous element's trailing space needs to be
                    // removed if it is selected.
                    ulLeadSpaceRemoved = ulPrevSpace;
                }
            }
/*
// This code block tries to get Non-ITN form text for the alternate.
// Yakima engine changed design to require ITN form text must be shown up in 
// candidate window.
//
// So this part of code is replaced by the below code block.
//
            for (UINT i = 0; i < pPhrases->Rule.ulCountOfElements; i++ )
            {
                if (i >= ulStartElem && i < ulStartElem + ulNumElems)
                {
                    const WCHAR   *pwszTextThis;
                    BYTE           bAttrThis = 0;
                    BYTE           bAttrPrev = 0;

                    pwszTextThis = pPhrases->pElements[i].pszDisplayText;
                    bAttrThis = pPhrases->pElements[i].bDisplayAttributes;

                    if ( i > ulParentStart )
                        bAttrPrev = pPhrases->pElements[i-1].bDisplayAttributes;

                    HandlePhraseElement( (CSpDynamicString *)&sds, pwszTextThis, bAttrThis, bAttrPrev,NULL);
                }
            }
*/
            BYTE                bAttr = 0;
            CSpDynamicString    sdsAltText;

            if ( pAlt->GetText(ulStartElem, ulNumElems, TRUE, &sdsAltText, &bAttr) == S_OK )
            {
                if (bAttr & SPAF_ONE_TRAILING_SPACE)
                {
                    sdsAltText.Append(L" ");
                }
                else if (bAttr & SPAF_TWO_TRAILING_SPACES)
                {
                    sdsAltText.Append(L"  ");
                }
            }

            if ( sdsAltText )
                sds.Append(sdsAltText);
        }
    }

    if (sds)
    {
        _ProcessTrailingSpaces(pPhrases, ulStartElem + ulNumElems, (WCHAR *)sds);

        int    TextLen;

        TextLen = wcslen( (WCHAR *)sds);        
        if (TextLen > cchAlt )
        {
            // There is not enough buffer to hold this alternate text.
            // Set the first element as NULL to indicate this situation.
            pwszAlt[0] = L'\0';
        }
        else
        {
            // The passed buffer can hold all the alternate text.
            wcsncpy(pwszAlt, sds, TextLen);
            pwszAlt[TextLen] = L'\0';
        }
    }

    if ( pulLeadSpaceRemoved )
        *pulLeadSpaceRemoved = ulLeadSpaceRemoved;

    return hr;
}

HRESULT CSapiAlternativeList::GetProbability(int nId, int * pnPrb)
{
    HRESULT hr = E_INVALIDARG;
    //
    // bogus for now
    //
    if(pnPrb && nId >= 0)
    {
        if ( nId < m_nItem)
        {
            *pnPrb = 10 - nId;
        }
        else if ( m_prgLMAlternates 
               && (nId - m_nItem) < m_prgLMAlternates->Count())
        {
            // we'll be able to get something from LM
            // but not normalized for now anyway
            *pnPrb = 1;
        }
        hr = S_OK;
    }
    
    return hr;
}

HRESULT CSapiAlternativeList::GetCachedAltInfo
(
    ULONG nId,
    ULONG *pulParentStart, 
    ULONG *pulcParentElements, 
    ULONG *pulcElements,
    WCHAR **ppwszText,
    ULONG *pulLeadSpaceRemoved
)
{
    if (nId < m_cAlt)
    {
        SPELEMENTUSED *pElemUsed;
        if ( pElemUsed = m_rgElemUsed.GetPtr(nId))
        {
            if (pulParentStart) 
                *pulParentStart = pElemUsed->ulParentStart;
            if (pulcParentElements) 
                *pulcParentElements = pElemUsed->ulcParentElements;
            if (pulcElements)
                *pulcElements = pElemUsed->ulcElements;
            if ( ppwszText)
                *ppwszText = pElemUsed->pwszAltText;
            if (pulLeadSpaceRemoved )
                *pulLeadSpaceRemoved = pElemUsed->ulLeadSpaceRemoved;
        }
    }
    
    return S_OK;
}

void CSapiAlternativeList::_Commit(ULONG nIdx, ISpRecoResult *pRecoResult)
{

    if ((m_iFakeAlternate != NO_FAKEALT) && (m_iFakeAlternate == (int)nIdx))
    {
        // This is for Faked Alternate.
        // Don't change any thing.
        // just return here.

        return;
    }

    if (m_cpwrp->m_ulNumOfITN > 0)
    {
        // if we now have the ITN shown as the recognized text, it's swapped with non-ITN
        // if we have non-ITN shown as the recognized text, it's swapped with the ITN

        // We should change the show state only for the replaced range, 
        // ( not for all the phrase if uses doesn't select the whole phrase.

        if ((nIdx == 0)  && _IsFirstAltInCandidate() )
        {
            // the ITN alternate has been chosen.
            //

            // we need to invert the show state for all the ITN inside the selection range.

            m_cpwrp->_InvertITNShowStateForRange(m_ulStart, m_ulcElem);

            // we don't have to commit this to SR engine but
            // we need to recalculate the character offsets for 
            // SR elements using the current pharse (set NULL)
            //
            m_cpwrp->_SetElementOffsetCch(NULL);
            return;
        }
    }
    
    // if a non-SR candidate (such as LM's) is chosen, 
    // nIdx would be >= m_cAlt and we don't have to 
    // tell SR about that.
    if(nIdx < m_cAlt)
    {

        // Need to update the real ITN show state list 
        // and then save the real text and get the offset for 
        // all the elements.

        HRESULT hr = m_cpwrp->_UpdateStateWithAltPhrase(m_ppAlt[nIdx]); 

        if ( S_OK == hr )
        {
      
            // Offset value should be based on ITN display status.
            // revise character offsets using the alternate phrase
            m_cpwrp->_SetElementOffsetCch(m_ppAlt[nIdx]);
        }

        if (S_OK == hr)
        {
            hr = m_ppAlt[nIdx]->Commit();
        }

        // we need to invalidate the result object too
        if (S_OK == hr)
        {
            hr = m_cpwrp->Init(pRecoResult);
        } 
    }
}

//+---------------------------------------------------------------------------
//
//    _GetUIFont()
//
//    synopsis: get appropriate logfont based on 
//              the current langid assigned to the alternativelist
//
//    return : TRUE if there's a specific logfont to the langid
//             FALSE if no logfont data is available for the langid
//
//+---------------------------------------------------------------------------
BOOL CSapiAlternativeList::_GetUIFont(BOOL  fVerticalWriting, LOGFONTW *plf)
{
    // other languages will follow later
    //
    const WCHAR c_szFontJPW2K[] = L"Microsoft Sans Serif";
    const WCHAR c_szFontJPOTHER[] = L"MS P Gothic";
    const WCHAR c_szFontJPNVert[] = L"@MS Gothic";
    const WCHAR c_szFontJPNVertWin9x[] =  L"@\xFF2D\xFF33 \xFF30\x30B4\x30B7\x30C3\x30AF"; // @MS P Gothic
    const WCHAR c_szFontCHS[] = L"SimSum";
    const WCHAR c_szFontCHSVert[] = L"@SimSun";
    const WCHAR c_szFontCHSVertLoc[] = L"@\x5b8b\x4f53";

    Assert(plf);

    int iDpi = 96;
    int iPoint = 0;

    HDC hdc = CreateIC("DISPLAY", NULL, NULL, NULL);
    if (hdc)
    {
        iDpi = GetDeviceCaps(hdc, LOGPIXELSY);
        DeleteDC(hdc);
    }
    else
        goto err_exit;



    switch(PRIMARYLANGID(m_langid))
    {
        case LANG_JAPANESE:
            iPoint = 12; // Satori uses 12 point font

            if ( !fVerticalWriting )
            {
                wcsncpy(plf->lfFaceName, 
                        IsOnNT5() ? c_szFontJPW2K : c_szFontJPOTHER,
                        ARRAYSIZE(plf->lfFaceName));
            }
            else
            {
                wcsncpy(plf->lfFaceName, 
                        IsOn98() ? c_szFontJPNVertWin9x : c_szFontJPNVert,
                        ARRAYSIZE(plf->lfFaceName));
            }

            // don't bother to call GetLocaleInfo() for now
            plf->lfCharSet = SHIFTJIS_CHARSET; 
            break;

        case LANG_CHINESE:

            iPoint = 9; 

            if ( !fVerticalWriting )
            {
                wcsncpy(plf->lfFaceName, c_szFontCHS, ARRAYSIZE(plf->lfFaceName));
            }
            else
            {
                wcsncpy(plf->lfFaceName, 
                        IsOnNT5() ? c_szFontCHSVert : c_szFontCHSVertLoc, 
                        ARRAYSIZE(plf->lfFaceName));
            }

            // don't bother to call GetLocaleInfo() for now
            plf->lfCharSet = GB2312_CHARSET; 
            break;

       default:
            break;

    }

    if (iPoint > 0)
        plf->lfHeight = -iPoint * iDpi / 72; 

err_exit:
      
    return iPoint > 0;
}
//////////////////////////////////////////////////////////////////////////////
//
// CFunction
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CFunction::CFunction(CSapiIMX *pImx)
{
    m_pImx = pImx;

    if (m_pImx)
       m_pImx->AddRef();

    m_cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CFunction::~CFunction()
{
    SafeRelease(m_pImx);
}

//+---------------------------------------------------------------------------
//
// CFunction::GetFocusedTarget
//
//----------------------------------------------------------------------------

BOOL CFunction::GetFocusedTarget(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, BOOL bAdjust, ITfRange **ppRangeTmp)
{
    ITfRange *pRangeTmp = NULL;
    ITfRange *pRangeTmp2 = NULL;
    IEnumTfRanges *pEnumTrack = NULL;
    BOOL bRet = FALSE;

    BOOL fWholeDoc = FALSE;

    if (!pRange)
    {
        fWholeDoc = TRUE;

        if (FAILED(GetRangeForWholeDoc(ec, pic, &pRange)))
            return FALSE;
    }

    if (bAdjust)
    {
        //
        // multi owner and PF_FOCUS range support.
        //

        if (FAILED(AdjustRangeByTextOwner(ec, pic,
                                          pRange, 
                                          &pRangeTmp2,
                                          CLSID_SapiLayr))) 
            goto Exit;

        GUID rgGuid[2];
        rgGuid[0] = GUID_ATTR_SAPI_INPUT;
        rgGuid[1] = GUID_ATTR_SAPI_GREENBAR;

        if (FAILED(AdjustRangeByAttribute(m_pImx->_GetLibTLS(),
                                          ec, pic,
                                          pRangeTmp2, 
                                          &pRangeTmp,
                                          rgGuid, ARRAYSIZE(rgGuid)))) 
            goto Exit;
    }
    else
    {
        pRange->Clone(&pRangeTmp);
    }

    ITfRange *pPropRange;
    ITfReadOnlyProperty *pProp;
    //
    // check if there is an intersection of PF_FOCUS range and owned range.
    // if there is no such range, we return FALSE.
    //
    if (FAILED(EnumTrackTextAndFocus(ec, pic, pRangeTmp, &pProp, &pEnumTrack)))
        goto Exit;

    while(pEnumTrack->Next(1, &pPropRange,  0) == S_OK)
    {
        if (IsOwnerAndFocus(m_pImx->_GetLibTLS(), ec, CLSID_SapiLayr, pProp, pPropRange))
            bRet = TRUE;

        pPropRange->Release();
    }

    pProp->Release();

    if (bRet)
    {
        *ppRangeTmp = pRangeTmp;
        (*ppRangeTmp)->AddRef();
    }

Exit:
    SafeRelease(pEnumTrack);
    SafeRelease(pRangeTmp);
    SafeRelease(pRangeTmp2);
    if (fWholeDoc)
        pRange->Release();
    return bRet;
}

HRESULT CFunction::_GetLangIdFromRange(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, LANGID *plangid)
{
    HRESULT hr;
    ITfProperty *pProp;
    LANGID langid;

    // get langid from the given range
    if (SUCCEEDED(hr = pic->GetProperty(GUID_PROP_LANGID, &pProp)))
    {
        GetLangIdPropertyData(ec, pProp, pRange, &langid);
        pProp->Release();
    }
     
    if (SUCCEEDED(hr) && plangid)
         *plangid = langid;
     
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CFnReconversion
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CFnReconversion::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfFnReconversion))
    {
        *ppvObj = SAFECAST(this, CFnReconversion *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CFnReconversion::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDAPI_(ULONG) CFnReconversion::Release()
{
    long cr;

    cr = InterlockedDecrement(&m_cRef);
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CFnReconversion::CFnReconversion(CSapiIMX *psi) : CFunction(psi) , CMasterLMWrap(psi), CBestPropRange( )
{
    m_psal = NULL;
    
    // initialize with the current profile langid
    m_langid = m_pImx->GetLangID();

//    m_MaxCandChars = 0;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CFnReconversion::~CFnReconversion()
{
    if (m_psal)
    {
        delete m_psal;
    }
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

STDAPI CFnReconversion::GetDisplayName(BSTR *pbstrName)
{
    *pbstrName = SysAllocString(L"Reconversion");
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::QueryRange
//
//----------------------------------------------------------------------------

HRESULT CFnReconversion::QueryRange(ITfRange *pRange, ITfRange **ppRange, BOOL *pfConvertable)
{
    CFnRecvEditSession *pes;
    CComPtr<ITfContext> cpic;
    HRESULT hr = E_FAIL;

    if (ppRange == NULL || pfConvertable == NULL || pRange == NULL)
        return E_INVALIDARG;

    *ppRange = NULL;
    *pfConvertable = FALSE;
    
    // call MasterLM when it's available
    //
    _EnsureMasterLM(m_langid);
    if (m_cpMasterLM)
    {
        hr = m_cpMasterLM->QueryRange( pRange, ppRange, pfConvertable );
        
        return  hr;
    }

    if (SUCCEEDED(pRange->GetContext(&cpic)))
    {
        hr = E_OUTOFMEMORY;

        if (pes = new CFnRecvEditSession(this, pRange, cpic))
        {
            pes->_SetEditSessionData(ESCB_RECONV_QUERYRECONV,NULL, 0);
          
            cpic->RequestEditSession(m_pImx->_GetId(), pes, TF_ES_READ | TF_ES_SYNC, &hr);

            if ( SUCCEEDED(hr) )
                *ppRange = (ITfRange *)pes->_GetRetUnknown( );

            pes->Release();
        }

        *pfConvertable = (hr == S_OK);
        if (hr == S_FALSE)
        {
            hr = S_OK;
        }
    }
    return hr;
}


//+---------------------------------------------------------------------------
//
// CFnReconversion::GetReconversion
//
//----------------------------------------------------------------------------

STDAPI CFnReconversion::GetReconversion(ITfRange *pRange, ITfCandidateList **ppCandList)
{
    CFnRecvEditSession *pes;
    ITfContext *pic;
    HRESULT hr = E_FAIL;
    
    // Call master LM when it's available!
    // 
    //
    Assert(pRange);

    _EnsureMasterLM(m_langid);
    if (m_cpMasterLM)
    {
        return m_cpMasterLM->GetReconversion( pRange, ppCandList);
    }

    if (FAILED(pRange->GetContext(&pic)))
        goto Exit;

    hr = E_OUTOFMEMORY;

    if (pes = new CFnRecvEditSession(this, pRange,pic) )
    {
        pes->_SetEditSessionData(ESCB_RECONV_GETRECONV,NULL, 0); 
        pic->RequestEditSession(m_pImx->_GetId(), pes, TF_ES_READ | TF_ES_SYNC, &hr);

        if (SUCCEEDED(hr))
            *ppCandList = (ITfCandidateList *)pes->_GetRetUnknown( );

        pes->Release();
    }

    pic->Release();

Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::_QueryReconversion
//
//----------------------------------------------------------------------------
HRESULT CFnReconversion::_QueryReconversion(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfRange **ppNewRange)
{
    Assert(pic);
    Assert(pRange);
    Assert(ppNewRange);
    Assert(*ppNewRange == NULL);
    
    
    CComPtr<ITfProperty>    cpProp ;
    HRESULT hr = pic->GetProperty(GUID_PROP_SAPIRESULTOBJECT, &cpProp);

    if (SUCCEEDED(hr) && cpProp)
    {
        CComPtr<ITfRange> cpBestPropRange;
        if (S_OK == hr)
        {
            hr = _ComputeBestFitPropRange(ec, cpProp, pRange, &cpBestPropRange, NULL, NULL);
        }
        // adjust start element and num elements
        if (S_OK == hr)
        {
            if (ppNewRange)
            {
                // TODO: this adjustment has to be done per element not phrase
                *ppNewRange = cpBestPropRange;
                (*ppNewRange)->AddRef();
            }
        }
    }
    return hr;
}


//+---------------------------------------------------------------------------
//
// CFnReconversion::_GetSapilayrEngineInstance
//
//----------------------------------------------------------------------------
HRESULT CFnReconversion::_GetSapilayrEngineInstance(ISpRecognizer **ppRecoEngine)
{
#ifdef _WIN64
    return E_NOTIMPL;
#else
    HRESULT hr = E_FAIL;
    CComPtr<ITfFnGetSAPIObject>  cpGetSAPI;

    // we shouldn't release this until we terminate ourselves
    // so we don't use comptr here
    hr = m_pImx->GetFunction(GUID_NULL, IID_ITfFnGetSAPIObject, (IUnknown **)&cpGetSAPI);

    if (S_OK == hr)
    {
        hr = cpGetSAPI->Get(GETIF_RECOGNIZERNOINIT, (IUnknown **)ppRecoEngine);
    }

    return hr;
#endif
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::_GetReconversion
//
//----------------------------------------------------------------------------
HRESULT CFnReconversion::_GetReconversion(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfCandidateList **ppCandList, BOOL fDisableEngine /*=FALSE*/)
{
    WCHAR *pszText = NULL;
    CCandidateList *pCandList  = NULL;
    CComPtr<ITfProperty>    cpProp;
    HRESULT hr;
    BOOL fEmpty;

    if(!pRange)
        return E_FAIL;
    
    Assert(m_pImx);
    ULONG        cAlt = m_pImx->_GetMaxAlternates();
    

    if (pRange->IsEmpty(ec, &fEmpty) != S_OK || fEmpty)
        return E_FAIL;

    // GUID_PROP_SAPIRESULTOBJECT really gets us
    // a wrapper object of ISpRecoResult
    // 
    hr = pic->GetProperty(GUID_PROP_SAPIRESULTOBJECT, &cpProp);
    if (S_OK != hr)
        return  S_FALSE;

    // try to reuse the candidate object if user opens it twice
    // on the same range using the same function instance
    //
    if (m_psal && m_psal->IsSameRange(pRange, ec))
    {
        CComPtr<ITfRange> cpPropRangeTemp;
        hr = cpProp->FindRange(ec, pRange, &cpPropRangeTemp, TF_ANCHOR_START);

        if (S_OK == hr)
            hr = GetCandidateForRange(m_psal, pic, pRange, ppCandList) ;
    }
    else
    {
        // get langid from the range property
        LANGID langid;
        if (FAILED(_GetLangIdFromRange(ec, pic, pRange, &langid)) || (langid == 0))
        {
            langid = GetUserDefaultLangID();
        }

        _SetCurrentLangID(langid);

        if (m_psal)
        {
            delete m_psal;
            m_psal = NULL;
        }

        CSapiAlternativeList *psal = new CSapiAlternativeList(langid, pRange, _GetMaxCandidateChars( ));

        if (psal)
        {
            m_psal = psal;
        }

        if (SUCCEEDED(hr) && cpProp && psal)
        {
            CComPtr<ITfRange>       cpPropRange;
            hr = cpProp->FindRange(ec, pRange, &cpPropRange, TF_ANCHOR_START);
    
            CComPtr<IUnknown> cpunk;
    
            // this punk points to the wrapper
            if (S_OK == hr)
                hr = GetUnknownPropertyData(ec, cpProp, cpPropRange, &cpunk);

            if ((hr == S_OK) && cpunk)
            {

                CSpTask *psp;
            
                hr = m_pImx->GetSpeechTask(&psp);
                if (SUCCEEDED(hr))
                {
                    CRecoResultWrap *pResWrap;
                    hr = cpunk->QueryInterface(IID_PRIV_RESULTWRAP, (void **)&pResWrap);
                    if (S_OK == hr)
                    {
                        CComPtr<ITfRange> cpBestPropRange;
                        ISpPhraseAlt **ppAlt = (ISpPhraseAlt **)cicMemAlloc(cAlt*sizeof(ISpPhraseAlt *));
                        if (!ppAlt)
                        {
                            hr = E_OUTOFMEMORY;
                        }
                        else
                        {
                            ULONG ulStart, ulcElem;
                            hr = _ComputeBestFitPropRange(ec, cpProp, pRange, &cpBestPropRange, &ulStart, &ulcElem);
                            if (S_OK == hr)
                            {
                                m_cpRecoResult.Release();

                                CComPtr<ISpRecognizer> cpEngine;
                                _GetSapilayrEngineInstance(&cpEngine);

                                if (fDisableEngine && cpEngine)
                                {
                                    // We stop the engine deliberately here (whether active or not - cannot afford to check as
                                    // we may get blocked by SAPI). This forces the engine into a synchronization since the audio
                                    // stops and we are guaranteed to be able to display the candidate list object 
                                    // This particular scenario (fDisableEngine == TRUE) occurs with a Word right-click context
                                    // request for alternates. The normal 'display alternates list' scenario is handled in the
                                    // _Reconvert() call since it requires the engine to be re-enabled after the alternates list
                                    // is display to avoid it blocking until the engine hears silence.
                                    cpEngine->SetRecoState(SPRST_INACTIVE_WITH_PURGE);
                                }

                                hr = psp->GetAlternates(pResWrap, ulStart, ulcElem, ppAlt, &cAlt, &m_cpRecoResult);

                                if (fDisableEngine && cpEngine)
                                {
                                    // If the microphone is supposed to be open, we now restart the engine. 
                                    if (m_pImx->GetOnOff())
                                    {
                                        // We need to restart the engine now that we are fully initialized.
                                        cpEngine->SetRecoState(SPRST_ACTIVE);
                                    }
                                }
                            }

                            if ( S_OK == hr )
                            {
                                // Before we call SetPhraseAlt( ), we need to get the current parent text covered
                                // by cpBestPropRange.
                                WCHAR  *pwszParent = NULL;
                                CComPtr<ITfRange> cpParentRange;
                                long   cchChunck = 128;

                                hr = cpBestPropRange->Clone(&cpParentRange);
                                if ( S_OK == hr )
                                {
                                    long cch;
                                    int  iNumOfChunck=1;
                                   
                                    pwszParent = (WCHAR *) cicMemAllocClear((cchChunck+1) * sizeof(WCHAR) );

                                    if ( pwszParent )
                                    {
                                        hr = cpParentRange->GetText(ec, TF_TF_MOVESTART, pwszParent, (ULONG)cchChunck, (ULONG *)&cch);

                                        if ( (S_OK == hr) && ( cch > 0 ) )
                                            pwszParent[cch] = L'\0';
                                    }
                                    else
                                        hr = E_OUTOFMEMORY;

                                    while ( (S_OK == hr) && (cch == cchChunck))
                                    {
                                        long  iNewSize;

                                        iNewSize = ((iNumOfChunck+1) * cchChunck + 1 ) * sizeof(WCHAR);

                                        pwszParent = (WCHAR *)cicMemReAlloc(pwszParent, iNewSize);

                                        if ( pwszParent )
                                        {
                                            WCHAR  *pwszNewPosition;

                                            pwszNewPosition = pwszParent + iNumOfChunck * cchChunck;
                                            hr = cpParentRange->GetText(ec, TF_TF_MOVESTART, pwszNewPosition, (ULONG)cchChunck, (ULONG *)&cch);

                                            if ( (S_OK == hr) && ( cch > 0 ) )
                                                pwszNewPosition[cch] = L'\0';
                                        }
                                        else
                                        {
                                            hr = E_OUTOFMEMORY;
                                        }

                                        iNumOfChunck ++;
                                    }
                                }

                                
                                if (S_OK == hr)
                                {
    
                                   // this is to store the obtained alternate phrases
                                    // to CSapiAlternativeList class instance
                                    // 
                                    hr = psal->SetPhraseAlt(pResWrap, ppAlt, cAlt, ulStart, ulcElem, pwszParent);
                                }

                                if ( pwszParent )
                                    cicMemFree(pwszParent);

                            }
                            if ((hr == S_OK) && ppAlt)
                            {
                                for (UINT i = 0; i < cAlt; i++)
                                {
                                    if (NULL != ppAlt[i])
                                    {
                                        ppAlt[i]->Release();
                                        ppAlt[i] = NULL;
                                    }
                                }
                            }

                            if ( ppAlt )
                                cicMemFree(ppAlt);
                        }
                        
                        pResWrap->Release();
    
                        // get this alternative list processed by external LM
                        //
                        if (S_OK == hr)
                        {
                            Assert(cpBestPropRange);

                            hr = GetCandidateForRange(psal, pic, cpBestPropRange, ppCandList) ;
                        }
                    }
                    psp->Release();
                }
            }
        }
    } 

    return hr;
}

HRESULT CFnReconversion::GetCandidateForRange(CSapiAlternativeList *psal, ITfContext *pic, ITfRange *pRange, ITfCandidateList **ppCandList) 
{
    Assert(psal);

    if ( !psal || !pic || !pRange || !ppCandList )
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    int nItem = psal->GetNumItem();
    WCHAR *pwszAlt = NULL;

    CCandidateList *pCandList = new CCandidateList(SetResult, pic, pRange, SetOption);

    if (!pCandList)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        int nPrb;

        for (int i = 0; SUCCEEDED(hr) && i < nItem ; i++)
        {
            psal->GetCachedAltInfo(i, NULL, NULL,NULL, &pwszAlt);

            if ( pwszAlt )
            {
                hr = psal->GetProbability(i, &nPrb);

                if (SUCCEEDED(hr))
                {
                    // note CSapiAlternateveList has exactly same life span as CFnReconversion
                    pCandList->AddString(pwszAlt, m_langid, psal, this, NULL);
                }
            }
        }

        // Add menu options here.
        HICON hIcon = NULL;
        WCHAR wzTmp[MAX_PATH];

        wzTmp[0] = 0;
        CicLoadStringWrapW(g_hInst, IDS_REPLAY, wzTmp, MAX_PATH);
        if (wzTmp[0] != 0)
        {
            hIcon = (HICON)LoadImage(g_hInst, MAKEINTRESOURCE(ID_ICON_TTSPLAY), IMAGE_ICON, 16, 16,  0);
            pCandList->AddOption(wzTmp, m_langid, NULL, this, NULL, OPTION_REPLAY, hIcon ? hIcon : NULL, NULL);
        }

        wzTmp[0] = 0;
        CicLoadStringWrapW(g_hInst, IDS_DELETE, wzTmp, MAX_PATH);
        if (wzTmp[0] != 0)
        {
            hIcon = (HICON)LoadImage(g_hInstSpgrmr,
                                     MAKEINTRESOURCE(IDI_SPTIP_DELETEICON),
                                     IMAGE_ICON, 16, 16,  0);
            pCandList->AddOption(wzTmp, m_langid, NULL, this, NULL, OPTION_DELETE, hIcon ? hIcon : NULL, NULL);
        }

        if (GetSystemMetrics(SM_TABLETPC) > 0)
        {
            BOOL fDisplayRedo = TRUE;
            DWORD dw = 0;
            CMyRegKey regkey;
   
            if (S_OK == regkey.Open(HKEY_LOCAL_MACHINE, c_szSapilayrKey, KEY_READ ) )
            {
                if (ERROR_SUCCESS == regkey.QueryValue(dw, TEXT("DisableRewrite")))
                {
                    if (dw == 1)
                    {
                        fDisplayRedo = FALSE;
                    }
                }
            }

            if (fDisplayRedo)
            {
                wzTmp[0] = 0;
                CicLoadStringWrapW(g_hInst, IDS_REDO, wzTmp, MAX_PATH);
                if (wzTmp[0] != 0)
                {
                    pCandList->AddOption(wzTmp, m_langid, NULL, this, NULL, OPTION_REDO, NULL, NULL);
                }
            }
        }

        hr = pCandList->QueryInterface(IID_ITfCandidateList, (void **)ppCandList);
        pCandList->Release();
    }
    
    return hr;
}
//+---------------------------------------------------------------------------
//
// CFnReconversion::Reconvert
//
//----------------------------------------------------------------------------

STDAPI CFnReconversion::Reconvert(ITfRange *pRange)
{
    CFnRecvEditSession *pes;
    ITfContext *pic;
    HRESULT hr = E_FAIL;
    
    Assert(pRange);

    if (FAILED(pRange->GetContext(&pic)))
        goto Exit;

    hr = E_OUTOFMEMORY;

    if (pes = new CFnRecvEditSession(this, pRange, pic))
    {
        BOOL  fCallLMReconvert = FALSE;

        pes->_SetEditSessionData(ESCB_RECONV_RECONV, NULL, 0);
        pic->RequestEditSession(m_pImx->_GetId(), pes, TF_ES_READWRITE | TF_ES_ASYNC, &hr);

        if ( SUCCEEDED(hr) )
            fCallLMReconvert = (BOOL)pes->_GetRetData( );

        if (hr == S_OK && fCallLMReconvert)
        {
            // need to call LM reconvert
            Assert(m_cpMasterLM != NULL);
            hr = m_cpMasterLM->Reconvert(pRange);
        }

        pes->Release();        
    }

    pic->Release();

Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::_Reconvert
//
//----------------------------------------------------------------------------

HRESULT CFnReconversion::_Reconvert(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, BOOL *pfCallLMReconvert)
{
    ITfCandidateList *pCandList;
    HRESULT hr;
    CSpTask *psp = NULL;
            
    // Call master LM when it's available!
    //
    // For voice playback, we need to do a little more.
    // we have to call QueryRange first and determine the
    // length of playback here.
    //
    *pfCallLMReconvert = FALSE;

    _EnsureMasterLM(m_langid);
    if (m_cpMasterLM)
    {
        // playback the whole range for now
        //
        CComPtr<ITfProperty> cpProp;
        hr = pic->GetProperty(GUID_PROP_SAPIRESULTOBJECT, &cpProp);
        if (S_OK == hr)
        {
            CComPtr<ITfRange>     cpPropRange;
            CComPtr<IUnknown>     cpunk;
            hr = cpProp->FindRange(ec, pRange, &cpPropRange, TF_ANCHOR_START);
            
            if (S_OK == hr)
            {
                hr = GetUnknownPropertyData(ec, cpProp, cpPropRange, &cpunk);
            }
            if (S_OK == hr)
            {
                CRecoResultWrap *pwrap = (CRecoResultWrap *)(void *)cpunk;
                pwrap->_SpeakAudio(0, 0);
            }
        }

        // after exiting this edit session, caller needs to call m_cpMasterLM->Reconvert
        *pfCallLMReconvert = TRUE;
        return S_OK;
    }

    CComPtr<ISpRecognizer> cpEngine;
    _GetSapilayrEngineInstance(&cpEngine);

    if (cpEngine)
    {
        // We stop the engine deliberately here (whether active or not - cannot afford to check as
        // we may get blocked by SAPI). This forces the engine into a synchronization since the audio
        // stops and we are guaranteed to be able to display the candidate list object 
        cpEngine->SetRecoState(SPRST_INACTIVE_WITH_PURGE);

    }

    if (S_OK != (hr = _GetReconversion(ec, pic, pRange, &pCandList)))
        return hr;
        
    // voice playback

    if ( m_pImx->_EnablePlaybackWhileCandUIOpen( ) )
    {
        if (m_psal)
            m_psal->_Speak();
    }

    hr = ShowCandidateList(ec, pic, pRange, pCandList);

    if (cpEngine)
    {
        // If the microphone is supposed to be open, we now restart the engine. 
        if (m_pImx->GetOnOff())
        {
            // We need to restart the engine now that we are fully initialized.
            cpEngine->SetRecoState(SPRST_ACTIVE);
        }
    }

    pCandList->Release();
    return hr;
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::ShowCandidateList
//
//----------------------------------------------------------------------------

HRESULT CFnReconversion::ShowCandidateList(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfCandidateList *pCandList)
{
    // Determine if current range is vertical writing
    CComPtr<ITfReadOnlyProperty>  cpProperty;
    VARIANT  var;
    BOOL     fVertical = FALSE;
    ULONG    lDirection = 0;

    if ( pic->GetAppProperty(TSATTRID_Text_VerticalWriting, &cpProperty) == S_OK )
    {
        if (cpProperty->GetValue(ec, pRange, &var) == S_OK )
        {
            fVertical = var.boolVal;
        }
    }

    // Get the current text orientation.
    cpProperty.Release( );
    if ( pic->GetAppProperty(TSATTRID_Text_Orientation, &cpProperty) == S_OK )
    {
        if (cpProperty->GetValue(ec, pRange, &var) == S_OK )
        {
            lDirection = var.lVal;
        }
    }

    // During the speech tip activation time, we just want to create candidateui object once for perf improvement.
    if ( m_pImx->_pCandUIEx == NULL )
    {
       CoCreateInstance(CLSID_TFCandidateUI, NULL, CLSCTX_INPROC_SERVER, IID_ITfCandidateUI, (void**)&m_pImx->_pCandUIEx);
    }

    if ( m_pImx->_pCandUIEx )
    {
        ITfDocumentMgr *pdim;
        if (SUCCEEDED(m_pImx->GetFocusDIM(&pdim)))
        {
            
            m_pImx->_pCandUIEx->SetClientId(m_pImx->_GetId());

            ITfCandUIAutoFilterEventSink *pCuiFes = new CCandUIFilterEventSink(this, pic, m_pImx->_pCandUIEx);
            CComPtr<ITfCandUIFnAutoFilter> cpFnFilter;

            if (S_OK == m_pImx->_pCandUIEx->GetFunction(IID_ITfCandUIFnAutoFilter, (IUnknown **)&cpFnFilter))
            {
                cpFnFilter->Advise(pCuiFes);
                cpFnFilter->Enable(TRUE);

            }

            //
            // set the right font size for Japanese and Chinese case
            //
            CComPtr<ITfCandUICandString>       cpITfCandUIObj;
            if (S_OK == m_pImx->_pCandUIEx->GetUIObject(IID_ITfCandUICandString, (IUnknown **)&cpITfCandUIObj))
            {
                Assert(m_psal); // this shouldn't fail

                if (m_psal)
                {
                    LOGFONTW lf = {0};
                    if (m_psal->_GetUIFont(fVertical, &lf))
                    {
                        cpITfCandUIObj->SetFont(&lf);
                    }
                }
            }

            //
            // Set the candidate Ui window's style.
            // 
            // Speech TIP always uses drop-down candidat window.
            //
            CComPtr<ITfCandUIFnUIConfig>  cpFnUIConfig;

            if (S_OK == m_pImx->_pCandUIEx->GetFunction(IID_ITfCandUIFnUIConfig, (IUnknown **)&cpFnUIConfig))
            {
                CANDUISTYLE  style;

                style = CANDUISTY_LIST;
                cpFnUIConfig->SetUIStyle(pic, style);
            }

            // 
            // Set the candidate UI window's direction.
            //

            CComPtr<ITfCandUICandWindow> cpUICandWnd;

            if ( S_OK == m_pImx->_pCandUIEx->GetUIObject(IID_ITfCandUICandWindow, (IUnknown **)&cpUICandWnd) )
            {
                CANDUIUIDIRECTION       dwOption = CANDUIDIR_TOPTOBOTTOM;

                switch ( lDirection )
                {
                case  900 : // Text direction Bottom to Top
                    dwOption = CANDUIDIR_LEFTTORIGHT;
                    break;

                case 1800 : // Text direction Right to Left.
                    dwOption = CANDUIDIR_BOTTOMTOTOP;
                    break;

                case 2700 : // Text direction Top to Bottom.
                    dwOption = dwOption = CANDUIDIR_RIGHTTOLEFT;
                    break;

                default :
                    dwOption = CANDUIDIR_TOPTOBOTTOM;
                    break;
                }

                cpUICandWnd->SetUIDirection(dwOption);

            }

            m_pImx->_pCandUIEx->SetCandidateList(pCandList);

            // Before Open Candidate UI window, we want to save the current IP

            m_pImx->_SaveCorrectOrgIP(ec, pic);

            m_pImx->_pCandUIEx->OpenCandidateUI(NULL, pdim, ec, pRange);

            pCuiFes->Release();
            pdim->Release();
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::SetResult
//
//----------------------------------------------------------------------------

HRESULT CFnReconversion::SetResult(ITfContext *pic, ITfRange *pRange, CCandidateString *pCand, TfCandidateResult imcr)
{
    BSTR bstr;
    HRESULT hr = S_OK;
    CFnReconversion *pReconv = (CFnReconversion *)(pCand->_punk);

    if ((imcr == CAND_FINALIZED) || (imcr == CAND_SELECTED))
    {
        pCand->GetString(&bstr);

        // TODO: here we have to re-calc the range based on the strart element points 
        //       which are indicated from AltInfo.
        ULONG     ulParentStart     = 0;
        ULONG     ulcParentElements  = 0;
        ULONG     ulIndex           = 0;
        ULONG     cchParentStart    = 0;
        ULONG     cchParentReplace  = 0;

        BOOL      fNoAlternate = FALSE;
        
        CSapiAlternativeList *psal = (CSapiAlternativeList *)pCand->_pv;
        
        pCand->GetIndex(&ulIndex);
        
        if (psal)
        {
            CRecoResultWrap *cpRecoWrap;
            ULONG            ulStartElement;
            ULONG            ulLeadSpaceRemoved = 0;

            // save current selection index.

            psal->_SaveCurrentSelectionIndex(ulIndex);

            cpRecoWrap = psal->GetResultWrap();
            ulStartElement = cpRecoWrap->GetStart( );

            psal->GetCachedAltInfo(ulIndex, &ulParentStart, &ulcParentElements,  NULL, NULL, &ulLeadSpaceRemoved);
        
            cchParentStart   = cpRecoWrap->_GetElementOffsetCch(ulParentStart);
            cchParentReplace = cpRecoWrap->_GetElementOffsetCch(ulParentStart + ulcParentElements) - cchParentStart;

            cchParentStart = cchParentStart - cpRecoWrap->_GetElementOffsetCch(ulStartElement) + cpRecoWrap->_GetOffsetDelta( );

            if ( ulLeadSpaceRemoved > 0  && cchParentStart > ulLeadSpaceRemoved)
            {
                cchParentStart -= ulLeadSpaceRemoved;
                cchParentReplace += ulLeadSpaceRemoved;
            }

            fNoAlternate = psal->_IsNoAlternate( );

            if ( !fNoAlternate )
            {
                hr = pReconv->m_pImx->SetReplaceSelection(pRange, cchParentStart,  cchParentReplace, pic);

                if ( (SUCCEEDED(hr))  && (imcr == CAND_FINALIZED) )
                {
                    if ( ulParentStart + ulcParentElements == ulStartElement + cpRecoWrap->GetNumElements( ) )
                    {
                        // The parent selection contains the last element.
                        // if its trailing spaces were removed before, we also want to 
                        // remove the same number of trailing spaces in the new alternative text.

                        // We already considered this case during _Commit( ).
                        // We just need to update the result text which wil be injected.

                        ULONG  ulTSRemoved;

                        ulTSRemoved = cpRecoWrap->GetTrailSpaceRemoved( );

                        if ( ulTSRemoved > 0 )
                        {
                            ULONG   ulTextLen;
                            ULONG   ulRemovedNew = 0;
                        
                            ulTextLen = wcslen(bstr);

                            for ( ULONG i=ulTextLen-1; (int)i>=0 && ulRemovedNew <= ulTSRemoved;  i-- )
                            {
                                if ( bstr[i] == L' ' )
                                {
                                    bstr[i] = L'\0';
                                    ulRemovedNew ++;
                                }
                                else
                                    break;
                            }

                            if ( ulRemovedNew < ulTSRemoved )
                                cpRecoWrap->SetTrailSpaceRemoved( ulRemovedNew );
                        }
                    }

                    pReconv->_Commit(pCand);

                    // If the first element in this RecoWrap is updated by the new alternate
                    // speech tip needs to check if this new alternate wants to 
                    // consume the leading space or if extra space is required to add
                    // between this phrase and previous phrase.
                    // 
                    BOOL   bHandleLeadingSpace = (ulParentStart == ulStartElement) ? TRUE : FALSE;
                    hr = pReconv->m_pImx->InjectAlternateText(bstr, pReconv->m_langid, pic, bHandleLeadingSpace);

                    //
                    // Update the Selection grammar's text buffer.
                    //
                    if ( SUCCEEDED(hr) && pReconv->m_pImx )
                    {
                        CSpTask     *psp = NULL;
                        (pReconv->m_pImx)->GetSpeechTask(&psp);

                        if ( psp )
                        {
                            hr = psp->_UpdateSelectGramTextBufWhenStatusChanged( );
                            psp->Release( );
                        }
                    }
                    //
                }
            }
        }

        SysFreeString(bstr);        
      
        
    }
    // close candidate UI if it's still there
    if (imcr == CAND_FINALIZED || imcr == CAND_CANCELED)
    {
        // Just close the candidate UI, don't release the object, so that the object keeps alive while the 
        // speech tip is activated, this is for performance improvement.
        pReconv->m_pImx->CloseCandUI( );

        if ( imcr == CAND_CANCELED )
        {
            // Just release the stored IP to avoid memory leak.
            // Don't restore it according to the new spec so that
            // user can continue to dictate new text over the selection.
            //

            // If we find this is not a good Usuability,
            // we can change it back to the original behavior.
            pReconv->m_pImx->_ReleaseCorrectOrgIP( );
        }
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::GetTabletTip
//
//----------------------------------------------------------------------------

HRESULT CFnReconversion::GetTabletTip(void)
{
    HRESULT hr = S_OK;
    CComPtr<IUnknown> cpunk;
    
    if (m_cpTabletTip)
    {
        m_cpTabletTip = NULL; // Releases our reference.
    }
    
    hr = CoCreateInstance(CLSID_UIHost, NULL, CLSCTX_LOCAL_SERVER, IID_IUnknown, (void **) &cpunk);
    
    if (SUCCEEDED(hr))
    {
        hr = cpunk->QueryInterface(IID_ITipWindow, (void **) &m_cpTabletTip);
    }
    
    return hr;
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::SetOption
//
//----------------------------------------------------------------------------

HRESULT CFnReconversion::SetOption(ITfContext *pic, ITfRange *pRange, CCandidateString *pCand, TfCandidateResult imcr)
{
    HRESULT hr = S_OK;
    CFnReconversion *pReconv = (CFnReconversion *)(pCand->_punk);

    if (imcr == CAND_FINALIZED)
    {
        ULONG ulID = 0;

        pCand->GetID(&ulID);
        switch (ulID)
        {
            case OPTION_REPLAY:
            {
                // Replay audio. Do not close candidate list.
                CSapiAlternativeList  *psal;
                psal = pReconv->GetCSapiAlternativeList( );
                if ( psal )
                {
                   psal->_Speak( );
                }
                break;
            }

            case OPTION_DELETE: // Delete from dictinary...
            {
                // Close candidate UI.
                pReconv->m_pImx->_pCandUIEx->CloseCandidateUI();

                // Delete the current selection in the document.
                pReconv->m_pImx->HandleKey(VK_DELETE);

                break;
            }

            case OPTION_REDO: // Tablet PC specific option.
            {
                // Close candidate UI.
                pReconv->m_pImx->_pCandUIEx->CloseCandidateUI();

                if (pReconv->m_cpTabletTip == NULL)
                {
                    pReconv->GetTabletTip();
                }
                if (pReconv->m_cpTabletTip)
                {
                    hr = pReconv->m_cpTabletTip->ShowWnd(VARIANT_TRUE);
                    if (FAILED(hr))
                    {
                        // Reget TabletTip and try a second time in case the previous instance was killed.
                        hr = pReconv->GetTabletTip();
                        if (SUCCEEDED(hr))
                        {
                            hr = pReconv->m_cpTabletTip->ShowWnd(VARIANT_TRUE);
                        }
                    }
                }

                break;
            }
        }
    }

    // close candidate UI if it's still there
    if (imcr == CAND_CANCELED)
    {
        if (pReconv->m_pImx->_pCandUIEx)
        {
            pReconv->m_pImx->_pCandUIEx->CloseCandidateUI();
        }
    }
    return hr;
}

//
// _Commit
//
// synopisis: accept the candidate string as the final selection and
//            let SR know the decision has been made
//
void CFnReconversion::_Commit(CCandidateString *pcand)
{
    ULONG nIdx;
    Assert(pcand);

    if (S_OK == pcand->GetIndex(&nIdx))
    {
        // let CSapiAlternativeList class do the real work
        if (m_psal)
            m_psal->_Commit(nIdx, m_cpRecoResult);

        // we no longer need to hold the reco result
        m_cpRecoResult.Release();
    }
}

ULONG  CBestPropRange::_GetMaxCandidateChars( )
{
    if ( m_MaxCandChars == 0 )
    {
        // it is not initialized
        CMyRegKey regkey;
        DWORD     dw = MAX_CANDIDATE_CHARS;

        if (S_OK == regkey.Open(HKEY_LOCAL_MACHINE, c_szSapilayrKey, KEY_READ))
        {
            regkey.QueryValue(dw, c_szMaxCandChars);
        }

        if ( (dw > MAX_CANDIDATE_CHARS) || (dw == 0) )
            dw = MAX_CANDIDATE_CHARS;

        m_MaxCandChars = dw;
    }

    return m_MaxCandChars;
}



//
// FindVisiblePropertyRange
//
// Searches for a property range, skipping over any "empty" (containing only hidden text)
// property spans along the way.
//
// We can encounter hidden property spans (zero-length from a tip's point of view) if the
// user marks some dictated text as hidden in word.
HRESULT FindVisiblePropertyRange(TfEditCookie ec, ITfProperty *pProperty, ITfRange *pTestRange, ITfRange **ppPropertyRange)
{
    BOOL fEmpty;
    HRESULT hr;

    while (TRUE)
    {
        hr = pProperty->FindRange(ec, pTestRange, ppPropertyRange, TF_ANCHOR_START);

        if (hr != S_OK)
            break;

        if ((*ppPropertyRange)->IsEmpty(ec, &fEmpty) != S_OK)
        {
            hr = E_FAIL;
            break;
        }

        if (!fEmpty)
            break;

        // found an empty property span
        // this means it contains only hidden text, so skip it
        if (pTestRange->ShiftStartToRange(ec, *ppPropertyRange, TF_ANCHOR_END) != S_OK)
        {
            hr = E_FAIL;
            break;
        }

        (*ppPropertyRange)->Release();
    }

    if (hr != S_OK)
    {
        *ppPropertyRange = NULL;
    }

    return hr;
}

//
//    _ComputeBestFitPropRange
//
//    synopsis: returns the range that includes at least one SPPHRASE element
//              which also includes the specified (incoming) range
//              *pulStart should include the start element used in the reco result
//              *pulcElem should include the # of elements used
//
HRESULT CBestPropRange::_ComputeBestFitPropRange
(
    TfEditCookie ec, 
    ITfProperty *pProp, 
    ITfRange *pRangeIn, 
    ITfRange **ppBestPropRange, 
    ULONG *pulStart, 
    ULONG *pulcElem
)
{
    HRESULT hr = E_FAIL;
    CComPtr<ITfRange> cpPropRange ;
    CComPtr<IUnknown> cpunk;
    ULONG ucch;

    BOOL    fBeyondPropRange = FALSE;


    TraceMsg(TF_GENERAL, "_ComputeBestFitPropRange is called");

    // find the reco result with a span that includes the given range
    Assert(pProp);
    Assert(pRangeIn);

    CComPtr<ITfRange> cpRange ;
    hr = pRangeIn->Clone(&cpRange);
    if (S_OK == hr)
    {
        hr = FindVisiblePropertyRange(ec, pProp, cpRange, &cpPropRange);
    }

    if ( hr == S_FALSE ) 
    {
        // if this is not a selection and the IP is at the last position of this region, we just try to reconvert on the possible previous 
        // dictated phrase.
        BOOL   fTryPreviousPhrase = FALSE;
        BOOL   fEmpty = FALSE;

        // Add code here to check it meets the condition.

        if ( S_OK == cpRange->IsEmpty(ec, &fEmpty) && fEmpty )
        {
            CComPtr<ITfRange> cpRangeTmp;

            if ( S_OK == cpRange->Clone(&cpRangeTmp) )
            {
                LONG  cch = 0;
                if ( (S_OK == cpRangeTmp->ShiftStart(ec, 1, &cch, NULL)) && (cch < 1) )
                {
                    // it is at the end of a region or entire document.
                    fTryPreviousPhrase = TRUE;
                }
            }
        }

        if ( fTryPreviousPhrase )
        {
            LONG  cch;

            hr = cpRange->ShiftStart(ec,  -1, &cch,  NULL);

            if ( hr == S_OK )
            {
                hr = cpRange->Collapse(ec, TF_ANCHOR_START);
            }

            if ( hr == S_OK )
            {
                hr = FindVisiblePropertyRange(ec, pProp, cpRange, &cpPropRange);
            }
        }
    }

    // get a wrapper for the prop range
    if (S_OK == hr)
    {    
        hr = GetUnknownPropertyData(ec, pProp, cpPropRange, &cpunk);
    }
    if ((hr == S_OK) && cpunk)
    {
        // first calculate the # of chars upto the start anchor of the given range
        //
        CComPtr<ITfRange>       cpClonedPropRange;
        if (S_OK == hr)
        {
            hr = cpPropRange->Clone(&cpClonedPropRange);
        }
            
        if (S_OK == hr)
        {
            hr = cpClonedPropRange->ShiftEndToRange(ec, cpRange, TF_ANCHOR_START);
        }
        
        ULONG ulCchToSelection = 0;
        ULONG ulCchInSelection = 0;
        BOOL fEmpty;
        if (S_OK == hr)
        {
            CSpDynamicString dstr;
            while(S_OK == hr && (S_OK == cpClonedPropRange->IsEmpty(ec, &fEmpty)) && !fEmpty)
            {
                WCHAR sz[64];

                hr = cpClonedPropRange->GetText(ec, TF_TF_MOVESTART, sz, ARRAYSIZE(sz)-1, &ucch);
                if (S_OK == hr)
                {
                    sz[ucch] = L'\0';
                    dstr.Append(sz);
                }
            }
            ulCchToSelection = dstr.Length();
        }

        // then  calc the # of chars upto the end anchor of the given range
        if(S_OK == hr)
        {
            hr = cpRange->IsEmpty(ec, &fEmpty);
            if (S_OK == hr && !fEmpty)
            {
                CComPtr<ITfRange> cpClonedGivenRange;
                hr = cpRange->Clone(&cpClonedGivenRange);
                // compare the end of the given range and proprange,
                // if the given range goes beyond proprange, snap it
                // within the proprange
                if (S_OK == hr)
                {
                    LONG lResult;
                    hr = cpClonedGivenRange->CompareEnd(ec, cpPropRange, TF_ANCHOR_END, &lResult);
                    if (S_OK == hr && lResult > 0)
                    {
                        // the end of the given range is beyond the proprange
                        // we need to snap it before getting text
                        hr = cpClonedGivenRange->ShiftEndToRange(ec, cpPropRange, TF_ANCHOR_END);

                        fBeyondPropRange = TRUE;

                    }
                    // now we get the text we use to calc the # of elements
                    CSpDynamicString dstr;
                    while(S_OK == hr && (S_OK == cpClonedGivenRange->IsEmpty(ec, &fEmpty)) && !fEmpty)
                    {
                        WCHAR sz[64];
                        hr = cpClonedGivenRange->GetText(ec, TF_TF_MOVESTART, sz, ARRAYSIZE(sz)-1, &ucch);
                        if (S_OK == hr)
                        {
                            sz[ucch] = L'\0';
                            dstr.Append(sz);
                        }
                    }
                    ulCchInSelection = dstr.Length();

                    // If there are some spaces in the beginning of the selection,
                    // we need to shift the start of the selection to the next non-space character.

                    if ( ulCchInSelection > 0 )
                    {
                        WCHAR   *pStr;

                        pStr = (WCHAR *)dstr;

                        while ( (*pStr == L' ') || (*pStr == L'\t'))
                        {
                            ulCchInSelection --;
                            ulCchToSelection ++;
                            pStr ++;
                        }

                        if ( *pStr == L'\0' )
                        {
                            // This selection contains only spaces. no other non-space character.
                            // we don't want to get alternate for this selection.
                            // just return here.

                            if (ppBestPropRange != NULL )
                                *ppBestPropRange = NULL;

                            if ( pulStart != NULL )
                                *pulStart = 0;

                            if (pulcElem != NULL )
                                *pulcElem = 0;

                            return S_FALSE;
                        }

                    }
                    
                }
            }
        }
            
        // get the result object cpunk points to our wrapper object
        CComPtr<IServiceProvider> cpServicePrv;
        CComPtr<ISpRecoResult>    cpResult;
        SPPHRASE *pPhrases = NULL;
        CRecoResultWrap *pResWrap = NULL;

        if (S_OK == hr)
        {
            hr = cpunk->QueryInterface(IID_IServiceProvider, (void **)&cpServicePrv);
        }
        // get result object 
        if (S_OK == hr)
        {
            hr = cpServicePrv->QueryService(GUID_NULL, IID_ISpRecoResult, (void **)&cpResult);
        }

        // now we can see how many elements we can use
        if (S_OK == hr)
        {
            hr = cpResult->GetPhrase(&pPhrases);
        }

        if (S_OK == hr)
        {
            hr = cpunk->QueryInterface(IID_PRIV_RESULTWRAP, (void **)&pResWrap); 
        }

        if (S_OK == hr && pPhrases)
        {
            // calc the start anchor of the new range
#ifdef NOUSEELEMENTOFFSET                
            CSpDynamicString dstr;
#endif
            long cchToElem_i = 0;
            long cchAfterElem_i = 0;
            BOOL  fStartFound = FALSE;
            ULONG i;
            ULONG ulNumElements;
            
            CComPtr<ITfRange> cpNewRange;
            hr = cpRange->Clone(&cpNewRange);

            if ( fBeyondPropRange )
            {
                hr = cpNewRange->ShiftEndToRange(ec, cpPropRange, TF_ANCHOR_END);
            }

            if ( ulCchInSelection > _GetMaxCandidateChars( ) )
            {
                // If the selection has more than MaxCandidate Chars, we need to shift the range end
                // to left so that it contains at most MaxCandidate Chars in the selection.
                long cch;

                cch = (long)_GetMaxCandidateChars( ) - (long)ulCchInSelection;
                ulCchInSelection = _GetMaxCandidateChars( );
                cpNewRange->ShiftEnd(ec, cch, &cch, NULL);
            }

            ulNumElements = pResWrap->GetNumElements();
           
            // get start element and # of elements via wrapper object
            if ((S_OK == hr)  && ulNumElements > 0 )
            {
                ULONG  ulStart;
                ULONG  ulEnd;
                ULONG  ulOffsetStart;
                ULONG  ulDelta;

                ulStart = pResWrap->GetStart();
                ulEnd = ulStart + pResWrap->GetNumElements() - 1;

                ulDelta = pResWrap->_GetOffsetDelta( );
                ulOffsetStart = pResWrap->_GetElementOffsetCch(ulStart);

                for (i = ulStart; i <= ulEnd; i++ )
                {
#ifdef NOUSEELEMENTOFFSET                
                    //  CleanupConsider: replace this logic with pResWrap->GetElementOffsets(i)
                    //  where we cache the calculated offsets
                    //
                    if (pPhrases->pElements[i].pszDisplayText)
                    {
                        cchToElem_i = dstr.Length();

                        dstr.Append(pPhrases->pElements[i].pszDisplayText);
                    
                    
                        if (pPhrases->pElements[i].bDisplayAttributes & SPAF_ONE_TRAILING_SPACE)
                        {
                            dstr.Append(L" ");
                        }
                        else if (pPhrases->pElements[i].bDisplayAttributes & SPAF_TWO_TRAILING_SPACES)
                        {
                            dstr.Append(L"  ");
                        }
                        cchAfterElem_i = dstr.Length();
                    }
                    else
                        break;
#else    
                    // when i < # of elements, it's guaranteed that we have n = i + 1
                    //
                    cchToElem_i = pResWrap->_GetElementOffsetCch(i) - ulOffsetStart + ulDelta;
                    cchAfterElem_i = pResWrap->_GetElementOffsetCch(i+1) - ulOffsetStart + ulDelta;
#endif                 

                    if ( ulCchInSelection == 0 )
                    {
                        // we need to specially handle this case that no character is in selection
                        // user just puts a cursor right before a character.

                        // We just want to find out which element would contain this IP.
                        // and then shift anchors to this element's start and end position.

                        if ( (ULONG)cchAfterElem_i  > ulCchToSelection )
                        {
                            // This element is the right element to contain this IP.
                            long cch;

                            // this is usually reverse shifting
                            // Shift the start anchor to this element's start position.

                            cpNewRange->ShiftStart(ec, cchToElem_i - ulCchToSelection, &cch, NULL);

                    
                            // store the starting element used

                            TraceMsg(TF_GENERAL, "Start element = %d", i);
                        
                            if (pulStart)
                            {
                                *pulStart = i;
                            }

                            // Shift the end anchor to this element's end position.
                            cpNewRange->ShiftEnd(ec, 
                                              cchAfterElem_i - ulCchToSelection, 
                                              &cch, NULL);


                            TraceMsg(TF_GENERAL, "End Element = %d", i);
                           
                            break;
                        }
                    }
                    else
                    {
                        // 1) shift the start anchor of prop range based on the element offsets of 
                        //    the result object, comparing it with the start anchor (ulCchToSelection) 
                        //    of the given range 
                        //    - choose the start elements that is right before the start anchor.
                        //
                        if ((ULONG)cchAfterElem_i > ulCchToSelection && !fStartFound) 
                        {
                            long cch;
                            // this is usually reverse shifting
                            cpNewRange->ShiftStart(ec, cchToElem_i - ulCchToSelection, &cch, NULL);

                    
                            // store the starting element used

                            TraceMsg(TF_GENERAL, "Start element = %d", i);
                        
                            if (pulStart)
                            {
                                *pulStart = i;
                            }
                            fStartFound = TRUE;
                        }
                        // 2) shift the end anchor of prop range based on the the element offset 
                        //    and the # of elements of result object,
                        //    comparing it with the end anchor of the given range (ulCchToSelection+ulCchInSelection)
                        //    - the element so the span ends right after the end anchor of the given range.
                        //
                        if ((ULONG)cchAfterElem_i >= ulCchToSelection + ulCchInSelection)
                        {
                            long cch;

                            if ( ulCchInSelection >= _GetMaxCandidateChars( ) )
                            {
                                // The selection contains MaxCand chars, we should make sure the char number
                                // in new proprange less than MaxCand.

                                if ( (ULONG)cchAfterElem_i > ulCchToSelection + ulCchInSelection )
                                {
                                    // if keeping this element, the total char number will larger than MaxCand.
                                    // So use the previous element as the last element.
                                    if ( i > ulStart )   // This conditon should always be true.
                                    {
                                        i--;
                                        cchAfterElem_i = pResWrap->_GetElementOffsetCch(i+1) - ulOffsetStart + ulDelta;
                                    }
                                }
                            }

                            cpNewRange->ShiftEnd(ec, 
                                              cchAfterElem_i - (ulCchToSelection + ulCchInSelection), 
                                              &cch, NULL);

                            TraceMsg(TF_GENERAL, "End Element = %d", i);

                            break;
                        }
                    }
                }
                if (pulcElem && pulStart)
                {
                   // we need to check if the current selection contains any ITN range.
                   // If it contains ITN range, we need to change the start and num of elements if
                   // the start element or end element is inside an ITN range.

                    BOOL  fInsideITN;
                    ULONG ulITNStart, ulITNNumElem;
                    ULONG ulEndElem;

                    ulEndElem = i;  // Current end element

                    if ( i > ulEnd )
                        ulEndElem = ulEnd;

                    fInsideITN = pResWrap->_CheckITNForElement(NULL, *pulStart, &ulITNStart, &ulITNNumElem, NULL );

                    if ( fInsideITN && (ulITNStart < *pulStart) )
                        *pulStart = ulITNStart;

                    fInsideITN = pResWrap->_CheckITNForElement(NULL, ulEndElem, &ulITNStart, &ulITNNumElem, NULL );

                    if ( fInsideITN && ulEndElem < (ulITNStart + ulITNNumElem - 1) )
                        ulEndElem = ulITNStart + ulITNNumElem - 1;

                    *pulcElem = ulEndElem - *pulStart + 1;

                    TraceMsg(TF_GENERAL, "Final Best Range: start=%d num=%d", *pulStart, *pulcElem);
 
                }
       
            }
            CoTaskMemFree( pPhrases );

            if ( ulNumElements > 0 )
            {
                Assert(cpNewRange);
                Assert(ppBestPropRange);
                *ppBestPropRange = cpNewRange;        

                (*ppBestPropRange)->AddRef();
            }
            else
                hr = S_FALSE;
        }
        SafeRelease(pResWrap);
    }
    return hr;
}

//
//
// CCandUIFilterEventSink
//
//
STDMETHODIMP CCandUIFilterEventSink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfCandUIAutoFilterEventSink))
    {
        *ppvObj = SAFECAST(this, CCandUIFilterEventSink *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CCandUIFilterEventSink::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CCandUIFilterEventSink::Release(void)
{
    long cr;

    cr = --m_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

HRESULT CCandUIFilterEventSink::OnFilterEvent(CANDUIFILTEREVENT ev)
{
    HRESULT hr = S_OK;
    
    // Temporally comment out the below code to fix bug 4777.
    //
    // To fully support the specification of filter feature, we need to change more code
    // in SetFilterString( ) to use the correct parent range in current document so that the filter
    // string is injected to a correct position.
    // 
    // We also want to change code to restore the original document text when the canidate UI is 
    // cancelled.
    //
    //

//    if (ev == CANDUIFEV_UPDATED)
    if ( ev == CANDUIFEV_NONMATCH )
    {
        // When we got non-matching notification, we need to inject the previous filter string to the document.
        if (m_pfnReconv)
        {
            Assert(m_pfnReconv);
            Assert(m_pfnReconv->m_pImx);
            
            ESDATA  esData;

            memset(&esData, 0, sizeof(ESDATA));
            esData.pUnk = (IUnknown *)m_pCandUI;
            m_pfnReconv->m_pImx->_RequestEditSession(ESCB_UPDATEFILTERSTR,TF_ES_READWRITE, &esData, m_pic);
        }
    }

    return hr; // looks like S_OK is expected anyways
}

/*   this filter event is no longer used.

HRESULT CCandUIFilterEventSink::OnAddCharToFilterStringEvent(CANDUIFILTEREVENT ev, WCHAR  wch, int nItemVisible, BOOL *bEten)
{

    HRESULT hr = S_OK;

    if ( (bEten == NULL) ||  (ev != CANDUIFEV_ADDCHARTOFILTER))
        return E_INVALIDARG;

    *bEten = FALSE;

    if ( nItemVisible == 0 )
    {
        if ( (wch <= L'9')  && (wch >= L'1') )
        {
            // we need to select the speified candidate text.
            // if candidate UI is open, we need to select the right alternate.

            if ( m_pCandUI )
            {
                ULONG   ulIndex;

                ulIndex = wch - L'0';

                m_pCandUI->ProcessCommand(CANDUICMD_SELECTLINE, ulIndex);
            }
            *bEten = TRUE;
        }
        else if ( wch == L' ' )
        {
            if ( m_pCandUI )
            {
                m_pCandUI->ProcessCommand(CANDUICMD_MOVESELNEXT, 0);
            }
            *bEten = TRUE;
        }

    }
    return hr;

}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\fnrecon.h ===
//
// fnrecon.h
//

#ifndef FNRECON_H
#define FNRECON_H

#include "private.h"
#include "ctffunc.h"
#include "sapilayr.h"
#include "candlist.h"
#include "mscandui.h"
#include "ptrary.h"
#include "lmobj.h"
#include "propstor.h"
#include "strary.h"
#include "TabletTip.h"

#define OPTION_REPLAY 0
#define OPTION_DELETE 1
#define OPTION_REDO   2

class CSapiIMX;
class CCandUIFilterEventSink;
class CCandUIExtButtonEventSink;
class CSapiAlternativeList ;

//////////////////////////////////////////////////////////////////////////////
//
// CFunction
//
//////////////////////////////////////////////////////////////////////////////

class CFunction
{
public:
    CFunction(CSapiIMX *pImx);
    ~CFunction();

protected:
    BOOL GetFocusedTarget(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, BOOL bAdjust, ITfRange **ppRangeTmp);

    HRESULT _GetLangIdFromRange(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, LANGID *plangid);

friend CSapiIMX;
    CSapiIMX    *m_pImx;
    long        m_cRef;
};

//
// The member functions in this class are extracted from CFnReconversion,
// We create this new class for a separate functionality that computes best prop range
// for the given selected range.
// This Class could be inherited by CFnReconversion and CSapiPlayBack.
//
class __declspec(novtable) CBestPropRange  
{

public:
    CBestPropRange( )
    {
        m_MaxCandChars = 0;
    }

    ~CBestPropRange( )
    {  
    }

    HRESULT _ComputeBestFitPropRange(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, ITfRange **ppBestPropRange, ULONG *pulStart,  ULONG *pulcElem);    
    ULONG   _GetMaxCandidateChars( );

private:
    ULONG          m_MaxCandChars;
};


class CFnReconversion : public ITfFnReconversion,
                        public CFunction,
                        public CMasterLMWrap,
                        public CBestPropRange
{
public:
    CFnReconversion(CSapiIMX *psi);
    ~CFnReconversion();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfFunction
    //
    STDMETHODIMP GetDisplayName(BSTR *pbstrCand);

    //
    // ITfFnReconversion
    //
    STDMETHODIMP QueryRange(ITfRange *pRange, ITfRange **ppNewRange, BOOL *pfConvertable);
    STDMETHODIMP GetReconversion(ITfRange *pRange, ITfCandidateList **ppCandList);
    STDMETHODIMP Reconvert(ITfRange *pRange);
    
    static HRESULT SetResult(ITfContext *pic, ITfRange *pRange, CCandidateString *pCand, TfCandidateResult imcr);
    static HRESULT SetOption(ITfContext *pic, ITfRange *pRange, CCandidateString *pCand, TfCandidateResult imcr);

    HRESULT _Reconvert(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, BOOL *pfCallLMReconvert);

    HRESULT _GetReconversion(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfCandidateList **ppCandList, BOOL fDisableEngine = FALSE);

    HRESULT _QueryReconversion(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfRange **ppNewRange);
    
    void _SetCurrentLangID(LANGID langid) { m_langid = langid;}
    
    HRESULT GetCandidateForRange(CSapiAlternativeList *psal, ITfContext *pic, ITfRange *pRange, ITfCandidateList **ppCandList) ;

    void _Commit(CCandidateString *pcand);

    CSapiAlternativeList  *GetCSapiAlternativeList(  )  { return m_psal; }

    HRESULT CFnReconversion::_GetSapilayrEngineInstance(ISpRecognizer **ppRecoEngine);

    friend CCandUIFilterEventSink;
    friend CCandUIExtButtonEventSink;

    // TABLET PC
    HRESULT GetTabletTip(void);
    CComPtr<ITipWindow>     m_cpTabletTip;

private:
    HRESULT ShowCandidateList(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfCandidateList *pCandList);
    
    LANGID         m_langid;
    CSapiAlternativeList  *m_psal;

    CComPtr<ISpRecoResult>  m_cpRecoResult;

};


class CCandUIFilterEventSink : public ITfCandUIAutoFilterEventSink
{
public:
    CCandUIFilterEventSink(CFnReconversion *pfnReconv, ITfContext *pic, ITfCandidateUI *pCandUI)
    {
        m_pic = pic;
        m_pic->AddRef();
        m_pfnReconv = pfnReconv;
        m_pfnReconv->AddRef();

        m_pCandUI = pCandUI;
        m_cRef = 1;
    }

    ~CCandUIFilterEventSink()
    {
        SafeRelease(m_pic);
        SafeRelease(m_pfnReconv);
    }

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfCandUIAutoFilterEventSink
    //
    STDMETHODIMP OnFilterEvent(CANDUIFILTEREVENT ev);
//    STDMETHODIMP OnAddCharToFilterStringEvent(CANDUIFILTEREVENT ev, WCHAR  wch, int nItemVisible, BOOL *bEten);
    
    ITfContext *m_pic;
private:
    CFnReconversion *m_pfnReconv;
    ITfCandidateUI  *m_pCandUI;
    
    long     m_cRef;
};

class CSapiAlternativeList
{
public:
    CSapiAlternativeList(LANGID langid, ITfRange *pRange, ULONG  ulMaxCandChars);
    ~CSapiAlternativeList();
    
    int GetNumItem();

    HRESULT SetPhraseAlt(CRecoResultWrap *pResWrap, ISpPhraseAlt **ppAlt, ULONG cAlt, ULONG ulStart, ULONG ulcElem, WCHAR  *pwszParent);
    HRESULT GetCachedAltInfo(ULONG nId, ULONG *pulParentStart, ULONG *pulcParentElements, ULONG *pulcElements, WCHAR **ppwszText, ULONG *pulLeadSpaceRemoved=NULL);

    HRESULT GetAlternativeText(ISpPhraseAlt *pAlt, SPPHRASE *pPhrases, BOOL  fFirstAlt, ULONG  ulStartElem, ULONG ulNumElems, WCHAR *pwszAlt, int cchAlt, ULONG *pulLeadSpaceRemoved);
    HRESULT GetProbability(int nId, int * nProb);
    
    HRESULT AddLMAlternates(CLMAlternates *pLMAlt);
    
    BOOL    IsSameRange(ITfRange *pRange, TfEditCookie ec)
    {
        Assert(m_cpRange);
        BOOL fEq = FALSE;
        
        HRESULT hr = pRange->IsEqualStart(ec,
                                          m_cpRange,
                                          TF_ANCHOR_START,
                                          &fEq);
        if (S_OK == hr )
        {
            if (fEq)
            {
                hr =  pRange->IsEqualEnd(ec,
                                         m_cpRange,
                                         TF_ANCHOR_END,
                                         &fEq);
            }
        }
        return S_OK == hr && fEq;
    }
    
    void _Commit(ULONG nIdx, ISpRecoResult *pRecoResult);

    // Keep the current selection index
    //
    void _SaveCurrentSelectionIndex(ULONG  ulIndexSelect)
    {
        m_ulIndexSelect = ulIndexSelect;
    }

    void _Speak(void)
    {
        if( m_cpwrp )
        {
            ULONG   ulParentStart=0, ulParentNumElems=0;

            if ( S_OK == GetCachedAltInfo(m_ulIndexSelect, &ulParentStart, &ulParentNumElems, NULL, NULL) )
            {
                m_cpwrp->_SpeakAudio(ulParentStart, ulParentNumElems);
            }
        }
    }
    
    HRESULT _ProcessTrailingSpaces(SPPHRASE *pPhrases, ULONG  ulNextElem, WCHAR *pwszAlt);

    CRecoResultWrap *GetResultWrap() { return m_cpwrp; }
    
    BOOL _GetUIFont(BOOL  fVerticalWriting, LOGFONTW * plf);

    BOOL _IsFirstAltInCandidate( ) { return m_fFirstAltInCandidate; }
    BOOL _IsNoAlternate( ) { return m_fNoAlternate; }

    int  _GetFakeAltIndex( ) { return m_iFakeAlternate; }
   
private:
    int   m_nItem;
    ULONG m_ulStart;
    ULONG m_ulcElem;

    ISpPhraseAlt         **m_ppAlt;
    ULONG                  m_cAlt;
    CComPtr<ITfRange>      m_cpRange;

    CPtrArray<CLMAlternates> *m_prgLMAlternates;
    typedef struct
    {
        ULONG     ulParentStart;
        ULONG     ulcParentElements;
        ULONG     ulcElements;
        ULONG     ulLeadSpaceRemoved;   // the number of leading space to remove.
        WCHAR     *pwszAltText;
    } SPELEMENTUSED;
    CStructArray<SPELEMENTUSED> m_rgElemUsed;
    
    LANGID                   m_langid;
    CComPtr<CRecoResultWrap> m_cpwrp;

    BOOL                     m_fFirstAltInCandidate; 
    BOOL                     m_fNoAlternate;

    int                      m_iFakeAlternate;

    ULONG                    m_MaxCandChars;
    ULONG                    m_ulIndexSelect;  // keep the index of the current selection in the candidate Window.
};


#define    NO_FAKEALT       -1

#endif // FNRECON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\icpriv.h ===
//
// icpriv.h
//

#pragma once


//
// Input Context private data storage
// < would be the place to store C&C grammar >
//
class CICPriv : public IUnknown
{
public:
    CICPriv (ITfContext *pic)
    {
        _pic = pic;
        _cRefCompositions = 0;
        _cRef = 1;
    }

    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    void _AddRefComposition() { _cRefCompositions++; }
    void _ReleaseComposition() 
    { 
        if ( _cRefCompositions > 0)
            _cRefCompositions--; 
    }

    LONG _GetCompositionCount() { return _cRefCompositions; }

    CTextEventSink *m_pTextEvent;
    TfClientId _tid;
    ITfContext *_pic; // not AddRef'd!
    DWORD m_dwEditCookie;
    DWORD m_dwLayoutCookie;
    LONG _cRefCompositions;
    LONG _cRef;
};

CICPriv *GetInputContextPriv(TfClientId tid, ITfContext *pic);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\hwxink.h ===
/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#define iverbInkRecog 351
#define iverbInkAlternates 352

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/


#ifndef __HWXInk_h__
#define __HWXInk_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ITfRange_FWD_DEFINED__
#define __ITfRange_FWD_DEFINED__
typedef interface ITfRange ITfRange;
#endif 	/* __ITfRange_FWD_DEFINED__ */

#ifndef __IInk_FWD_DEFINED__
#define __IInk_FWD_DEFINED__
typedef interface IInk IInk;
#endif 	/* __IInk_FWD_DEFINED__ */


#ifndef __ILineInfo_FWD_DEFINED__
#define __ILineInfo_FWD_DEFINED__
typedef interface ILineInfo ILineInfo;
#endif 	/* __ILineInfo_FWD_DEFINED__ */

#ifndef __IThorFnConversion_FWD_DEFINED__
#define __IThorFnConversion_FWD_DEFINED__
typedef interface IThorFnConversion IThorFnConversion;
#endif 	/* __IThorFnConversion_FWD_DEFINED__ */

#ifndef __Ink_FWD_DEFINED__
#define __Ink_FWD_DEFINED__

#ifdef __cplusplus
typedef class Ink Ink;
#else
typedef struct Ink Ink;
#endif /* __cplusplus */

#endif 	/* __Ink_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_HWXInk_0000 */
/* [local] */ 

typedef struct  tagINKMETRIC
    {
    UINT iHeight;
    UINT iFontAscent;
    UINT iFontDescent;
    UINT iWeight;
    BOOL fFontHDC;
    DWORD dwAmbientProps;
    COLORREF color;
    BOOL fItalic;
    UINT nItalicPitch;
    DWORD dwReserved;
    }	INKMETRIC;

typedef struct  tagSTROKEHEADER
    {
    UINT cByteCount;
    UINT cByteOffset;
    DWORD dwFlags;
    RECT rectBounds;
    }	STROKEHEADER;

typedef struct  tagSTROKE
    {
    UINT cPoints;
    BOOL fUpStroke;
    POINT __RPC_FAR *pPoints;
    UINT __RPC_FAR *pPressure;
    UINT __RPC_FAR *pTime;
    UINT __RPC_FAR *pAngle;
    }	STROKE;

typedef struct  tagSTROKELIST
    {
    UINT cStrokes;
    STROKE __RPC_FAR *pStrokes;
    }	STROKELIST;


enum __MIDL___MIDL_itf_HWXInk_0000_0001
    {	LOSSY	= 0x1,
	LOSSLESS	= 0x2,
	XYPOINTS	= 0x4,
	PRESSURE	= 0x8,
	TIME	= 0x10,
	ANGLE	= 0x20
    };


extern RPC_IF_HANDLE __MIDL_itf_HWXInk_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_HWXInk_0000_v0_0_s_ifspec;

#ifndef __IInk_INTERFACE_DEFINED__
#define __IInk_INTERFACE_DEFINED__

/* interface IInk */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IInk;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03F8E511-43A1-11D3-8BB6-0080C7D6BAD5")
    IInk : public IDispatch
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IInkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IInk __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IInk __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IInk __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IInk __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IInk __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IInk __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IInk __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } IInkVtbl;

    interface IInk
    {
        CONST_VTBL struct IInkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInk_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInk_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInk_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInk_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IInk_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IInk_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IInk_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInk_INTERFACE_DEFINED__ */


#ifndef __ILineInfo_INTERFACE_DEFINED__
#define __ILineInfo_INTERFACE_DEFINED__

/* interface ILineInfo */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ILineInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9C1C5AD5-F22F-4DE4-B453-A2CC482E7C33")
    ILineInfo : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetFormat( 
            INKMETRIC __RPC_FAR *pim) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetFormat( 
            INKMETRIC __RPC_FAR *pim) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetInkExtent( 
            INKMETRIC __RPC_FAR *pim,
            UINT __RPC_FAR *pnWidth) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TopCandidates( 
            UINT nCandidateNum,
            BSTR __RPC_FAR *pbstrRecogWord,
            UINT __RPC_FAR *pcchRecogWord,
            LONG fAllowRecog,
            LONG fForceRecog) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Recognize( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStroke( 
            UINT iStroke,
            STROKE __RPC_FAR *pStroke) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStroke( 
            UINT iStroke,
            STROKE __RPC_FAR *pStroke) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddPoints( 
            UINT iStroke,
            STROKE __RPC_FAR *pStroke,
            BOOL fUpStroke,
            UINT nFrameHeight) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILineInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ILineInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ILineInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ILineInfo __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFormat )( 
            ILineInfo __RPC_FAR * This,
            INKMETRIC __RPC_FAR *pim);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFormat )( 
            ILineInfo __RPC_FAR * This,
            INKMETRIC __RPC_FAR *pim);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInkExtent )( 
            ILineInfo __RPC_FAR * This,
            INKMETRIC __RPC_FAR *pim,
            UINT __RPC_FAR *pnWidth);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TopCandidates )( 
            ILineInfo __RPC_FAR * This,
            UINT nCandidateNum,
            BSTR __RPC_FAR *pbstrRecogWord,
            UINT __RPC_FAR *pcchRecogWord,
            LONG fAllowRecog,
            LONG fForceRecog);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Recognize )( 
            ILineInfo __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStroke )( 
            ILineInfo __RPC_FAR * This,
            UINT iStroke,
            STROKE __RPC_FAR *pStroke);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStroke )( 
            ILineInfo __RPC_FAR * This,
            UINT iStroke,
            STROKE __RPC_FAR *pStroke);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddPoints )( 
            ILineInfo __RPC_FAR * This,
            UINT iStroke,
            STROKE __RPC_FAR *pStroke,
            BOOL fUpStroke,
            UINT nFrameHeight);
        
        END_INTERFACE
    } ILineInfoVtbl;

    interface ILineInfo
    {
        CONST_VTBL struct ILineInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILineInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILineInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILineInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILineInfo_SetFormat(This,pim)	\
    (This)->lpVtbl -> SetFormat(This,pim)

#define ILineInfo_GetFormat(This,pim)	\
    (This)->lpVtbl -> GetFormat(This,pim)

#define ILineInfo_GetInkExtent(This,pim,pnWidth)	\
    (This)->lpVtbl -> GetInkExtent(This,pim,pnWidth)

#define ILineInfo_TopCandidates(This,nCandidateNum,pbstrRecogWord,pcchRecogWord,fAllowRecog,fForceRecog)	\
    (This)->lpVtbl -> TopCandidates(This,nCandidateNum,pbstrRecogWord,pcchRecogWord,fAllowRecog,fForceRecog)

#define ILineInfo_Recognize(This)	\
    (This)->lpVtbl -> Recognize(This)

#define ILineInfo_SetStroke(This,iStroke,pStroke)	\
    (This)->lpVtbl -> SetStroke(This,iStroke,pStroke)

#define ILineInfo_GetStroke(This,iStroke,pStroke)	\
    (This)->lpVtbl -> GetStroke(This,iStroke,pStroke)

#define ILineInfo_AddPoints(This,iStroke,pStroke,fUpStroke,nFrameHeight)	\
    (This)->lpVtbl -> AddPoints(This,iStroke,pStroke,fUpStroke,nFrameHeight)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILineInfo_SetFormat_Proxy( 
    ILineInfo __RPC_FAR * This,
    INKMETRIC __RPC_FAR *pim);


void __RPC_STUB ILineInfo_SetFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILineInfo_GetFormat_Proxy( 
    ILineInfo __RPC_FAR * This,
    INKMETRIC __RPC_FAR *pim);


void __RPC_STUB ILineInfo_GetFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILineInfo_GetInkExtent_Proxy( 
    ILineInfo __RPC_FAR * This,
    INKMETRIC __RPC_FAR *pim,
    UINT __RPC_FAR *pnWidth);


void __RPC_STUB ILineInfo_GetInkExtent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILineInfo_TopCandidates_Proxy( 
    ILineInfo __RPC_FAR * This,
    UINT nCandidateNum,
    BSTR __RPC_FAR *pbstrRecogWord,
    UINT __RPC_FAR *pcchRecogWord,
    LONG fAllowRecog,
    LONG fForceRecog);


void __RPC_STUB ILineInfo_TopCandidates_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILineInfo_Recognize_Proxy( 
    ILineInfo __RPC_FAR * This);


void __RPC_STUB ILineInfo_Recognize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILineInfo_SetStroke_Proxy( 
    ILineInfo __RPC_FAR * This,
    UINT iStroke,
    STROKE __RPC_FAR *pStroke);


void __RPC_STUB ILineInfo_SetStroke_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILineInfo_GetStroke_Proxy( 
    ILineInfo __RPC_FAR * This,
    UINT iStroke,
    STROKE __RPC_FAR *pStroke);


void __RPC_STUB ILineInfo_GetStroke_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILineInfo_AddPoints_Proxy( 
    ILineInfo __RPC_FAR * This,
    UINT iStroke,
    STROKE __RPC_FAR *pStroke,
    BOOL fUpStroke,
    UINT nFrameHeight);


void __RPC_STUB ILineInfo_AddPoints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILineInfo_INTERFACE_DEFINED__ */

#ifndef __IThorFnConversion_INTERFACE_DEFINED__
#define __IThorFnConversion_INTERFACE_DEFINED__

/* interface IThorFnConversion */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IThorFnConversion;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("62130000-ED22-4015-B038-A04CD0866E69")
    IThorFnConversion : public ITfFunction
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryRange( 
            /* [in] */ ITfRange __RPC_FAR *pRange,
            /* [unique][out][in] */ ITfRange __RPC_FAR *__RPC_FAR *ppNewRange,
            /* [out] */ BOOL __RPC_FAR *pfConvertable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Convert( 
            /* [in] */ ITfRange __RPC_FAR *pRange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IThorFnConversionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IThorFnConversion __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IThorFnConversion __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IThorFnConversion __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDisplayName )( 
            IThorFnConversion __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryRange )( 
            IThorFnConversion __RPC_FAR * This,
            /* [in] */ ITfRange __RPC_FAR *pRange,
            /* [unique][out][in] */ ITfRange __RPC_FAR *__RPC_FAR *ppNewRange,
            /* [out] */ BOOL __RPC_FAR *pfConvertable);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Convert )( 
            IThorFnConversion __RPC_FAR * This,
            /* [in] */ ITfRange __RPC_FAR *pRange);
        
        END_INTERFACE
    } IThorFnConversionVtbl;

    interface IThorFnConversion
    {
        CONST_VTBL struct IThorFnConversionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IThorFnConversion_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IThorFnConversion_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IThorFnConversion_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IThorFnConversion_GetDisplayName(This,pbstrName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbstrName)


#define IThorFnConversion_QueryRange(This,pRange,ppNewRange,pfConvertable)	\
    (This)->lpVtbl -> QueryRange(This,pRange,ppNewRange,pfConvertable)

#define IThorFnConversion_Convert(This,pRange)	\
    (This)->lpVtbl -> Convert(This,pRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IThorFnConversion_QueryRange_Proxy( 
    IThorFnConversion __RPC_FAR * This,
    /* [in] */ ITfRange __RPC_FAR *pRange,
    /* [unique][out][in] */ ITfRange __RPC_FAR *__RPC_FAR *ppNewRange,
    /* [out] */ BOOL __RPC_FAR *pfConvertable);


void __RPC_STUB IThorFnConversion_QueryRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IThorFnConversion_Convert_Proxy( 
    IThorFnConversion __RPC_FAR * This,
    /* [in] */ ITfRange __RPC_FAR *pRange);


void __RPC_STUB IThorFnConversion_Convert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IThorFnConversion_INTERFACE_DEFINED__ */

#ifndef __HWXINKLib_LIBRARY_DEFINED__
#define __HWXINKLib_LIBRARY_DEFINED__

/* library HWXINKLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_HWXINKLib;

EXTERN_C const CLSID CLSID_Ink;

#ifdef __cplusplus

class DECLSPEC_UUID("13DE4A42-8D21-4C8E-BF9C-8F69CB068FCA")
Ink;
#endif
#endif /* __HWXINKLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\keyevent.h ===
#ifndef _KEYEVENT_H
#define _KEYEVENT_H

#include "sapilayr.h"
#include "kes.h"

class CSapiIMX;
class CSpTask;

#define TF_MOD_WIN                          0x00010000

extern const KESPRESERVEDKEY g_prekeyList[];
extern KESPRESERVEDKEY g_prekeyList_Mode[];

// Speech tip itself Keyevent sink class derived from the basic CKeyEventSink

class CSptipKeyEventSink : public CKeyEventSink
{
public:

    CSptipKeyEventSink (KESCALLBACK pfnCallback, void *pv) : CKeyEventSink(pfnCallback, pv)
    {
    }

    CSptipKeyEventSink(KESCALLBACK pfnCallback, KESPREKEYCALLBACK pfnPrekeyCallback, void *pv) : CKeyEventSink(pfnCallback, pfnPrekeyCallback, pv)
    {

    }

    ~CSptipKeyEventSink() 
    { 
    }

    HRESULT _RegisterEx(ITfThreadMgr *ptim, TfClientId tid, const KESPRESERVEDKEY *pprekey);
};

#endif  // _KEYEVENT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\ids.h ===
// IDs and flags defined for SAPI TFX

#ifndef IDS_H

#define IDS_H

#define ESCB_PROCESSTEXT  0
#define ESCB_ATTACHAUDIO  1
#define ESCB_ATTACHRESULT 2
#define ESCB_FEEDBACKUI   3
#define ESCB_KILLFEEDBACKUI   4
#define ESCB_KILLLASTPHRASE   5

#define ESCB_MAKERESULTSTRING           6
#define ESCB_CONVERT      7
#define ESCB_REVERT       8
#define ESCB_ABORT        9
#define ESCB_COMPLETE    10
#define ESCB_PROCESS_ALTERNATE_TEXT   11
#define ESCB_ATTACHRECORESULTOBJ      12
#define ESCB_SYNCMBWITHSEL            13
#define ESCB_GETRANGETEXT             14
#define ESCB_ISRANGEEMPTY             15
#define ESCB_HANDLEHYPOTHESIS         16
#define ESCB_HANDLERECOGNITION        17
#define ESCB_HANDLESPACES             18
#define ESCB_DETECTFEEDBACKUI         19

#define ESCB_PLAYBK_PLAYSND           20
#define ESCB_RECONV_QUERYRECONV       21
#define ESCB_RECONV_GETRECONV         22
#define ESCB_RECONV_RECONV            23
#define ESCB_PLAYBK_PLAYSNDSELECTION  24
#define ESCB_RECONV_ONIP              25
#define ESCB_FINALIZECOMP             26
#define ESCB_PROCESSTEXT_NO_OWNERID   27
#define ESCB_FINALIZE_ALL_COMPS       28

#define ESCB_UPDATEFILTERSTR          30

#define ESCB_PROP_DIVIDE              40
#define ESCB_PROP_TEXTUPDATE          41
#define ESCB_PROP_SHRINK              42

#define ESCB_HANDLE_ADDDELETE_WORD    50
#define ESCB_HANDLE_LEARNFROMDOC      51
#define ESCB_LEARNDOC_NEXTRANGE       52


#define ESCB_PROCESSCONTROLKEY        60
#define ESCB_FEEDCURRENTIP            61

#define ESCB_SETREPSELECTION          70
#define ESCB_SAVECURIP_ADDDELETEUI    71

#define ESCB_PROCESSSELECTWORD        80
#define ESCB_UPDATE_TEXT_BUFFER       81
#define ESCB_PROCESS_CAP_COMMANDS     82

#define ESCB_TTS_PLAY                 90

#define ESCB_RESTORE_CORRECT_ORGIP    100
#define ESCB_PROCESS_EDIT_COMMAND     110
#define ESCB_PROCESS_SPELL_THAT       111
#define ESCB_PROCESS_SPELL_IT         112
#define ESCB_PROCESS_MODEBIAS_TEXT    113

#define ESCB_INJECT_SPELL_TEXT        120
#define ESCB_HANDLE_MOUSESINK         121

// status flags
#define SAPILAYR_STAT_GETAUDIO 0x0100
#define SAPILAYR_STAT_DICTON   0x0200
#define SAPILAYR_STAT_PLAYBACK 0x0400
#define SAPILAYR_STAT_WHATEVER 0x0800

// res ids
#define ID_ICON_DICTON         1
#define ID_ICON_DICTOFF        2
#define ID_ICON_AUDIOON        3
#define ID_ICON_AUDIOOFF       4
#define ID_ICON_CFGMENU        5
#define ID_ICON_MICROPHONE     6
#define ID_ICON_COMMANDING     7
#define ID_ICON_DICTATION      8
#define ID_ICON_TTSPLAY        9
#define ID_ICON_TTSSTOP        10
#define ID_ICON_TTSPAUSE       11
#define ID_ICON_MIC_PROPPAGE   12

// grammar ids
#define GRAM_ID_DICT           1 // general dictation grammar id
#define GRAM_ID_CCDICT         2 // dictation command grammar id
#define GRAM_ID_NUMMODE        3 // mode bias grammar id
#define GRAM_ID_TBCMD          4 // grammar id for toolbar C&C
#define GRAM_ID_SPELLING       5 // grammar id for spelling
#define GRAM_ID_CMDSHARED      6 // grammar id for shared commands available for both Dictation and command mode.
#define GRAM_ID_SLEEP          7 // dynamical grammar for "Go to Sleep" and "Wakeup"

#define GRAM_ID_URLSPELL       8 // grammar id for spelling used in url mode

#define RULE_ID_TBCMD          10 // grammar rule id for toolbar
#define RULE_ID_URLHIST        11 // grammar rule id for url history

// string ids


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        204
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
#define IDS_CMD_FILE           100
#define IDS_NUMMODE_CMD_FILE   101
#define IDS_SHARDCMD_FILE      102

#define IDS_INT_NONE           200
#define IDS_INT_NOISE          201
#define IDS_INT_NOSIGNAL       202
#define IDS_INT_TOOLOUD        203
#define IDS_INT_TOOQUIET       204
#define IDS_INT_TOOFAST        205
#define IDS_INT_TOOSLOW        206

#define IDS_INTTOOLTIP_NONE           210
#define IDS_INTTOOLTIP_NOISE          211
#define IDS_INTTOOLTIP_NOSIGNAL       212
#define IDS_INTTOOLTIP_TOOLOUD        213
#define IDS_INTTOOLTIP_TOOQUIET       214
#define IDS_INTTOOLTIP_TOOFAST        215
#define IDS_INTTOOLTIP_TOOSLOW        216
#define IDS_DICTATING                 217
#define IDS_DICTATING_TOOLTIP         218

#define IDS_UI_TRAINING        300
#define IDS_UI_ADDDELETE       301

// menu strings
#define IDS_MIC_DIS_DICTCMD    390 
#define IDS_MIC_OPTIONS        400
#define IDS_MIC_TRAINING       401
#define IDS_MIC_ADDDELETE      402
#define IDS_MIC_CURRENTUSER    403
#define IDS_MIC_SAVEDATA       404


#define IDS_NUI_CFGMENU_TOOLTIP     405
#define IDS_NUI_CFGMENU_TEXT        406
#define IDS_NUI_BALLOON_TOOLTIP     407
#define IDS_NUI_BALLOON_TEXT        408
#define IDS_NUI_MICROPHONE_TOOLTIP  409
#define IDS_NUI_MICROPHONE_TEXT     410
#define IDS_NUI_COMMANDING_TOOLTIP  411
#define IDS_NUI_COMMANDING_TEXT     412
#define IDS_NUI_DICTATION_TOOLTIP   413
#define IDS_NUI_DICTATION_TEXT      414
#define IDS_NUI_STARTINGSPEECH      415
#define IDS_NUI_BEGINDICTATION      416
#define IDS_NUI_BEGINVOICECMD       417

#define IDS_MIC_SHOWBALLOON         420
#define IDS_MIC_CUASSTATUS          421

#ifdef CHANGE_MIC_TOOLTIP_ONTHEFLY
#define IDS_NUI_MICROPHONE_ON_TOOLTIP  430
#define IDS_NUI_MICROPHONE_OFF_TOOLTIP  431
#endif

#define IDS_NUI_TTSPLAY_TOOLTIP     450
#define IDS_NUI_TTSPLAY_TEXT        451
#define IDS_NUI_TTSSTOP_TOOLTIP     452
#define IDS_NUI_TTSSTOP_TEXT        453
#define IDS_NUI_TTSPAUSE_TOOLTIP    454
#define IDS_NUI_TTSPAUSE_TEXT       455
#define IDS_NUI_TTSRESUME_TOOLTIP   456
#define IDS_NUI_TTSRESUME_TEXT      457

#define IDS_NO_ALTERNATE            500

#define IDS_DEFAULT_PROFILE         600

#define IDS_LISTENING                       700
#define IDS_LISTENING_TOOLTIP               701
#define IDS_BALLOON_DICTAT_PAUSED           702
#define IDS_BALLOON_TOOLTIP_IP_INSIDE_WORD  703
#define IDS_BALLOON_TOOLTIP_TYPING          704

#define IDS_CANDBTN_HELP_TOOLTIP            720               
#define IDS_CANDBTN_DELETE_TOOLTIP          721
#define IDS_CANDBTN_PREVIOUS_TOOLTIP        722
#define IDS_CANDBTN_NEXT_TOOLTIP            723 
#define IDS_CANDBTN_PLAY_TOOLTIP            724  

#define IDS_GO_TO_SLEEP                     750
#define IDS_WAKE_UP                         751

#define IDS_PROPERTYPAGE_TITLE          760
#define IDS_HELPFILESpPropPage          761
#define IDS_DOCSTRINGSpPropPage         762

#define IDS_SPCMD_SELECT_ALL            800
#define IDS_SPCMD_SELECT_THAT           801

#define IDS_REPLAY                      810
#define IDS_DELETE                      811
#define IDS_REDO                        812

#define IDS_CUAS_RESTART_TITLE          850
#define IDS_CUAS_RESTART_CUASON         851
#define IDS_CUAS_RESTART_CUASOFF        852

// widget
#define IDS_PROJNAME                    900
#define IDI_INVOKE                      902
#define IDS_ADDTODICTIONARYPREFIX       902
#define ID_HIDETIMER                    903
#define IDS_ADDTODICTIONARYPOSTFIX      903
#define ID_FADETIMER                    904
#define IDS_DELETESELECTION             904
#define ID_MOUSELEAVETIMER              905

#define IDI_DELETEICON                  911
#define IDI_INVOKECLOSE                 913
// cfgs
#define ID_DICTATION_COMMAND_CFG       200
#define ID_NUMMODE_COMMAND_CFG         201
#define ID_SPELLING_TOPIC_CFG          202 
#define ID_SHAREDCMD_CFG               203

// timer ID
#define TIMER_ID_OPENCLOSE     101
#define TIMER_ID_CHARTYPED     102


// menu IDs
#define IDM_MIC_ONOFF                  1
#define IDM_MIC_OPTIONS                2
#define IDM_MIC_SHAREDENGINE           3
#define IDM_MIC_INPROCENGINE           4
#define IDM_MIC_TRAINING               5
#define IDM_MIC_ADDDELETE              6
#define IDM_MIC_CURRENTUSER            8
#define IDM_MIC_SAVEDATA               9
#define IDM_MIC_SHOWBALLOON            10
#define IDM_MIC_DIS_DICTCMD            11
#define IDM_MIC_CUASSTATUS             12


#define IDM_MIC_USERSTART            100
#define IDM_MIC_USEREND              200

// private messages
#define WM_PRIV_FEEDCONTEXT      WM_APP+0
#define WM_PRIV_LBARSETFOCUS     WM_APP+1
#define WM_PRIV_SPEECHOPTION     WM_APP+2
#define WM_PRIV_ONSETTHREADFOCUS WM_APP+3
#define WM_PRIV_SPEECHOPENCLOSE  WM_APP+4
#define WM_PRIV_OPTIONS          WM_APP+5
#define WM_PRIV_ADDDELETE        WM_APP+6
#define WM_PRIV_DORECONVERT      WM_APP+7

// lbarsystemmenuitem
#define IDM_CUSTOM_MENU_START       7000

// Dialog ID
#define IDD_OPEN_ADD_DELETE         1000
#define IDD_PROPERTY_PAGE           1001
#define IDD_PP_DIALOG_ADVANCE       1002
#define IDD_PP_DIALOG_BUTTON_SET    1003

// Item Id in the property page dialog

#define IDC_GP_VOICE_COMMANDS       2000
#define IDC_GP_MODE_BUTTONS         2001

#define IDC_PP_SHOW_BALLOON         2010
#define IDC_PP_LMA                  2011
#define IDC_PP_HIGH_CONFIDENCE      2012
#define IDC_PP_SAVE_SPDATA          2013
#define IDC_PP_REMOVE_SPACE         2014
#define IDC_PP_DIS_DICT_TYPING      2015
#define IDC_PP_PLAYBACK             2016
#define IDC_PP_DICT_CANDUI_OPEN     2017
#define IDC_PP_DICTCMDS             2018
#define IDC_PP_ASSIGN_BUTTON        2019

#define IDC_PP_BUTTON_MB_SETTING    2020

#define IDC_PP_BUTTON_ADVANCE       2030
#define IDC_PP_BUTTON_LANGBAR       2031
#define IDC_PP_BUTTON_SPCPL         2032

#define IDC_DESCRIPT_TEXT           (-1)

// For voice command Setting dialog

#define IDC_GP_ADVANCE_SET          2100

#define IDC_PP_SELECTION_CMD        2110
#define IDC_PP_NAVIGATION_CMD       2111
#define IDC_PP_CASING_CMD           2112
#define IDC_PP_EDITING_CMD          2113
#define IDC_PP_KEYBOARD_CMD         2114
#define IDC_PP_LANGBAR_CMD          2115
#define IDC_PP_TTS_CMD              2116

//#define IDC_PP_MAXNUM_ALTERNATES    2118
//#define IDC_PP_MAXCHARS_ALTERNATE   2119

#define IDC_PP_DICTATION_CMB        2200
#define IDC_PP_COMMAND_CMB          2201

// Candidate UI Buttons ID

#define ID_CANDBTN_HELP             100
#define ID_CANDBTN_DELETE           101
//#define ID_CANDBTN_PREVIOUS         102
//#define ID_CANDBTN_NEXT             103
#define ID_CANDBTN_PLAY             104

#endif // IDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\init.cpp ===
//
// init.cpp
//

#include "private.h"
#include "globals.h"
#include "immxutil.h"
#include "osver.h"
#include "mui.h"

DECLARE_OSVER();

//+---------------------------------------------------------------------------
//
// DllInit
//
// Called on our first CoCreate.  Use this function to do initialization that
// would be unsafe during process attach, like anything requiring a LoadLibrary.
//
//----------------------------------------------------------------------------
BOOL DllInit(void)
{
    BOOL fRet = TRUE;

    EnterCriticalSection(GetServerCritSec());

    if (DllRefCount() != 1)
        goto Exit;

    fRet = TFInitLib();
    InitOSVer();

Exit:
    LeaveCriticalSection(GetServerCritSec());

    return fRet;
}

//+---------------------------------------------------------------------------
//
// DllUninit
//
// Called after the dll ref count drops to zero.  Use this function to do
// uninitialization that would be unsafe during process deattach, like
// FreeLibrary calls.
//
//----------------------------------------------------------------------------

void DllUninit(void)
{
    EnterCriticalSection(GetServerCritSec());

    if (DllRefCount() != 0)
        goto Exit;

    TFUninitLib();
    MuiFlushDlls(g_hInst);

Exit:
    LeaveCriticalSection(GetServerCritSec());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\keyevent.cpp ===
//
//
// Sapilayr TIP Key event related functions.
//
//
#include "private.h"
#include "sapilayr.h"
#include "nui.h"
#include "keyevent.h"
#include "cregkey.h"

//
// hot key for TTS Play/Stop.
const KESPRESERVEDKEY g_prekeyList[] =
{
    { &GUID_HOTKEY_TTS_PLAY_STOP,    { 'S',  TF_MOD_WIN },   L"TTS Speech" },
    { NULL,  { 0,    0}, NULL }
};

KESPRESERVEDKEY g_prekeyList_Mode[] = 
{
    { &GUID_HOTKEY_MODE_DICTATION, {VK_F11 , 0}, L"Dictation Button" },
    { &GUID_HOTKEY_MODE_COMMAND,   {VK_F12 , 0}, L"Command Button" },
    { NULL,  { 0,    0}, NULL }
};


//+---------------------------------------------------------------------------
//
// CSptipKeyEventSink::RegisterEx:   Registr the special speech mode buttons.
//
//----------------------------------------------------------------------------

HRESULT CSptipKeyEventSink::_RegisterEx(ITfThreadMgr *ptim, TfClientId tid, const KESPRESERVEDKEY *pprekey)
{
    HRESULT hr;
    ITfKeystrokeMgr_P *pKeyMgr;

    if (FAILED(ptim->QueryInterface(IID_ITfKeystrokeMgr_P, (void **)&pKeyMgr)))
        return E_FAIL;

    hr = E_FAIL;

    while (pprekey->pguid)
    {
        if (FAILED(pKeyMgr->PreserveKeyEx(tid, 
                                        *pprekey->pguid,
                                        &pprekey->tfpk,
                                        pprekey->psz,
                                        wcslen(pprekey->psz),
                                        TF_PKEX_SYSHOTKEY | TF_PKEX_NONEEDDIM)))
            goto Exit;

        pprekey++;
    }

    ptim->AddRef();

    hr = S_OK;

Exit:
    SafeRelease(pKeyMgr);
    return hr;
}


HRESULT CSapiIMX::_PreKeyEventCallback(ITfContext *pic, REFGUID rguid, BOOL *pfEaten, void *pv)
{
    CSapiIMX *_this = (CSapiIMX *)pv;
    CSpeechUIServer *pSpeechUIServer;
    BOOL            fButtonEnable;

    TraceMsg(TF_SPBUTTON, "_PreKeyEventCallback is called");

    *pfEaten = FALSE;
    if (_this == NULL)
        return S_OK;

    pSpeechUIServer = _this->GetSpeechUIServer( );

    if (!pSpeechUIServer)
        return S_OK;

    fButtonEnable = pSpeechUIServer->GetTtsButtonStatus( );

    if (IsEqualGUID(rguid, GUID_HOTKEY_TTS_PLAY_STOP))
    {
        if ( fButtonEnable )
        {
            _this->_HandleEventOnPlayButton( );
            *pfEaten = TRUE;
        }
    }
    else if ( IsEqualGUID(rguid, GUID_HOTKEY_MODE_DICTATION) ||
              IsEqualGUID(rguid, GUID_HOTKEY_MODE_COMMAND) )
    {
        if ( _this->_IsModeKeysEnabled( ) )
            *pfEaten = TRUE;
        else
            *pfEaten = FALSE;
    }

    TraceMsg(TF_SPBUTTON, "_PreKeyEventCallback fEaten=%d", *pfEaten);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _KeyEventCallback
//
//----------------------------------------------------------------------------

HRESULT CSapiIMX::_KeyEventCallback(UINT uCode, ITfContext *pic, WPARAM wParam, LPARAM lParam, BOOL *pfEaten, void *pv)
{
    CSapiIMX *pimx;
    HRESULT hr = S_OK;
    CSapiIMX *_this = (CSapiIMX *)pv;

    *pfEaten = FALSE;

    Assert(uCode != KES_CODE_FOCUS); // we should never get this callback because we shouldn't take the keyboard focus

    if (!(uCode & KES_CODE_KEYDOWN))
        return S_OK; // only want key downs

    if (pic == NULL) // no focus ic?
        return S_OK;

    pimx = (CSapiIMX *)pv;

    *pfEaten = TRUE;

    switch (wParam & 0xFF)
    {
        case VK_F8:
        if (!(uCode & KES_CODE_TEST))
        {
            CSapiPlayBack *ppb;
            if (ppb = new CSapiPlayBack(pimx))
            {
                CPlayBackEditSession *pes;
                if (pes = new CPlayBackEditSession(ppb, pic))
                {
                    pes->_SetEditSessionData(ESCB_PLAYBK_PLAYSNDSELECTION, NULL, 0);
                  
                    pic->RequestEditSession(_this->_tid, pes, TF_ES_READ | TF_ES_SYNC, &hr);
                    pes->Release();
                }
                ppb->Release();
            }
        }
        break;
        case VK_ESCAPE:
        if (!(uCode & KES_CODE_TEST))
        {
            if (_this->m_pCSpTask)
                hr = _this->m_pCSpTask->_StopInput();
        }
        *pfEaten = FALSE;
        break;
        default:
        *pfEaten = FALSE;

#ifdef LONGHORN
        //
        // For english composition scenario, I'm trying to see if this works. 
        // Note that this is not the final design to support typing while
        // composing dictation. m_pMouseSink != NULL only when composition
        // is active so I'm overriding it as a flag. 
        //
        if (_this->GetLangID() == 0x0409)
        {
            if ((BYTE)wParam != VK_LEFT && (BYTE)wParam != VK_RIGHT 
            && (isprint((BYTE)wParam) 
                || (VK_OEM_1 <= (BYTE)wParam && (BYTE)wParam < VK_OEM_8)) 
            && _this->m_pMouseSink)
            {
                WCHAR wc[3];
                BYTE keystate[256];

                if (GetKeyboardState(keystate))
                {
                    if (ToUnicodeEx(wParam,(UINT)lParam, keystate, wc,
                                ARRAYSIZE(wc), 0, GetKeyboardLayout(NULL)) > 0)
                    {

                        *pfEaten = TRUE; // want this key only if there is 
                                         // a printable character

                        if (!(uCode & KES_CODE_TEST))
                        {
                            // we don't handle deadkeys here for now
                            wc[1] = L'\0';
                            // call InjectSpelledText() with fOwnerId == TRUE
                            hr = _this->InjectSpelledText(wc, _this->GetLangID(), TRUE);
                        }
                    }
                }
            }
        }
        break;
#endif
    }
  
    return hr;
}


//
//  ITfKeyTraceEventSink method functions.
//
//
STDAPI CSapiIMX::OnKeyTraceUp(WPARAM wParam,LPARAM lParam)
{
    // We just check KeyDown, ignore KeyUp event.
    // so just return S_OK immediately.

    TraceMsg(TF_SPBUTTON, "OnKeyTraceUp is called");

    UNREFERENCED_PARAMETER(lParam);
    HandleModeKeyEvent( (DWORD)wParam, FALSE);

    return S_OK;
}

//
// Take use this method to detect if user is typing 
//
// if it is typing, disable dictation rule temporally.
//
STDAPI CSapiIMX::OnKeyTraceDown(WPARAM wParam,LPARAM lParam)
{
    BOOL   fDictOn;

    TraceMsg(TF_SPBUTTON, "OnKeyTraceDown is called, wParam=%x", wParam);

    if ( HandleModeKeyEvent((DWORD)wParam, TRUE ))
    {
        // if the mode key is pressed, don't disable dictation as usual.
        return S_OK;
    }

    fDictOn = (GetOnOff( ) && GetDICTATIONSTAT_DictOnOff( ));

    if (fDictOn && !m_ulSimulatedKey && m_pCSpTask && 
        S_OK == IsActiveThread()) // Only want this to happen on the active thread which could be the stage.
    {
        // User is typing.
        //
        // Temporally disable Dictation if Dictation Mode is ON
        //

        if ( _NeedDisableDictationWhileTyping( ) )
        {
		    if ( _GetNumCharTyped( ) == 0 )
		    {
                m_pCSpTask->_SetDictRecoCtxtState(FALSE);
                m_pCSpTask->_SetRecognizerInterest(0);
                m_pCSpTask->_UpdateBalloon(IDS_BALLOON_DICTAT_PAUSED, IDS_BALLOON_TOOLTIP_TYPING);
	        }
            // 
            // and then start a timer to watch for the end of typing.
            //
            _SetCharTypeTimer( );
        }
    }

    if ( m_ulSimulatedKey > 0 )
        m_ulSimulatedKey --;

    return S_OK;
}


// +--------------------------------------------------------------------------
// HandleModeKeySettingChange
//
//   When any mode button setting is changed, such as mode button's
//   enable/disable status change, virtual keys for dictation and command
//   are changed, this function will respond for this change.
//
// ---------------------------------------------------------------------------
void CSapiIMX::HandleModeKeySettingChange(BOOL  fSetttingChanged )
{
    BOOL  fModeKeyEnabled = _IsModeKeysEnabled( );
    DWORD dwDictVirtKey = _GetDictationButton( );
    DWORD dwCommandVirtKey = _GetCommandButton( );

    if ( !fSetttingChanged || !_pkes )  return;

    // mode button setting is changed.

    // unregister the hotkey first if the keys were registered before.
    if ( m_fModeKeyRegistered )
    {
        _pkes->_Unregister(_tim, _tid, (const KESPRESERVEDKEY *)g_prekeyList_Mode);
        m_fModeKeyRegistered = FALSE;
    }

    // Update the virtual keys in g_prekeyList_Mode
    g_prekeyList_Mode[0].tfpk.uVKey = (UINT)dwDictVirtKey;
    g_prekeyList_Mode[1].tfpk.uVKey = (UINT)dwCommandVirtKey;

    // register hotkeys again based on the mode button enable status setting
    if ( fModeKeyEnabled )
    {
        _pkes->_RegisterEx(_tim, _tid, (const KESPRESERVEDKEY *)g_prekeyList_Mode);
        m_fModeKeyRegistered = TRUE;
    }
}

// +--------------------------------------------------------------------------
// HandleModeKeyEvent
//
//   dwModeKey to indicate which mode key is process.
//   fDown to indicate if the button is down or up
//
// Return TRUE means this key is a correct mode key and processed sucessfully
// otherwisze, the keyevent is not handled correctly or not a mode key.
// ---------------------------------------------------------------------------
BOOL  CSapiIMX::HandleModeKeyEvent(DWORD   dwModeKey,  BOOL fDown)
{
    BOOL    fRet=FALSE;
    BOOL    fModeKeyEnabled;
    DWORD   DictVirtKey, CommandVirtKey;

    fModeKeyEnabled = _IsModeKeysEnabled( );
    DictVirtKey = _GetDictationButton( );
    CommandVirtKey = _GetCommandButton( );

    if ( fModeKeyEnabled && ((dwModeKey == DictVirtKey) || (dwModeKey == CommandVirtKey)) )
    {
        if ( !m_pSpButtonControl )
            m_pSpButtonControl = new SpButtonControl(this);

        if ( m_pSpButtonControl )
        {
            // GetMessageTime( ) will return the real time when
            // KEYDOWN and KEYUP event was generated.
            UINT   uTimeKey=(UINT)GetMessageTime( );

            if ( dwModeKey == DictVirtKey )
                m_pSpButtonControl->SetDictationButton(fDown,uTimeKey);
            else
                m_pSpButtonControl->SetCommandingButton(fDown, uTimeKey);

            fRet = TRUE;
        }
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\lbarsink.cpp ===
#include "private.h"
#include "sapilayr.h"
#include "globals.h"
#include "lbarsink.h"
#include "immxutil.h"
#include "mui.h"
#include "slbarid.h"
#include "nui.h"


//////////////////////////////////////////////////////////////////////////////
//
// CLangBarSink
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CLangBarSink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfLangBarEventSink))
    {
        *ppvObj = SAFECAST(this, ITfLangBarEventSink *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CLangBarSink::AddRef()
{
    return ++m_cRef;
}

STDAPI_(ULONG) CLangBarSink::Release()
{
    m_cRef--;
    Assert(m_cRef >= 0);

    if (m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLangBarSink::CLangBarSink(CSpTask  *pSpTask) 
{
    Dbg_MemSetThisName(TEXT("CLangBarSink"));

    Assert(pSpTask);

    m_pSpTask = pSpTask;
    m_pSpTask->AddRef();
    
    m_nNumItem  = 0;
    m_fInitSink = FALSE;
    m_fPosted  = FALSE;
    m_fGrammarBuiltOut = FALSE;
    
    m_hDynRule = NULL;

    m_cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLangBarSink::~CLangBarSink()
{
    if (m_cplbm)
    {
        m_cplbm->UnadviseEventSink(m_dwlbimCookie);
    }
    _UninitItemList();
    SafeRelease(m_pSpTask);
}


//+---------------------------------------------------------------------------
//
// SetFocus
//
//----------------------------------------------------------------------------

HRESULT  CLangBarSink::OnSetFocus(DWORD dwThreadId)
{
    TraceMsg(TF_LB_SINK, "CLangBarSink::OnSetFocus, dwThreadId=%d",dwThreadId); 

    if (m_fPosted == TRUE) return S_OK;

    HWND hwnd = m_pSpTask->GetTip()->_GetWorkerWnd();
    if (hwnd)
    {
        PostMessage(hwnd, WM_PRIV_LBARSETFOCUS, 0, 0);
        m_fPosted = TRUE;
    }
    return S_OK;
}
HRESULT CLangBarSink::_OnSetFocus()
{

    HRESULT hr = S_OK;
    CSapiIMX *pime = m_pSpTask->GetTip();

    TraceMsg(TF_LB_SINK, "LBSINK: _OnSetFocus is called back");
 
    if ( !pime )
        return E_FAIL;

    // this _tim check is needed because on Win98 the worker window's
    // winproc may get called after the window is destroyed.
    // In theory we should be ok since we destory the window which calls
    // _OnSetFocus() via private message before we release tim
    //
    if (pime->_tim &&
        pime->IsActiveThread() == S_OK)
    {
        // do we have to do anything?
        hr = _InitItemList();
        BOOL    fCmdOn;

        fCmdOn = pime->GetOnOff( ) && pime->GetDICTATIONSTAT_CommandingOnOff( );

        // the dynamic toolbar grammar is available only for Voice command mode.
        if ( fCmdOn && pime->_LanguageBarCmdEnabled( ))
        {
            if (hr==S_OK && !m_fGrammarBuiltOut && pime->_IsDictationActiveForLang(GetPlatformResourceLangID()))
            {
                // build C/C grammar
                hr = _BuildGrammar();
                _ActivateGrammar(TRUE);
            }
        }
    }
    m_fPosted = FALSE;
    return hr;
}

//+---------------------------------------------------------------------------
//
// ThreadTerminate
//
//----------------------------------------------------------------------------

HRESULT CLangBarSink::OnThreadTerminate(DWORD dwThreadId)
{
    //
    // check if the thread is us, release the dynamic grammar object
    // via sptask
    // 
    _UninitItemList();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnThreadItemChange
//
//----------------------------------------------------------------------------

HRESULT CLangBarSink::OnThreadItemChange(DWORD dwThreadId)
{
    //PerfConsider: This is called many times when assembly changes
    //         This will be corrected in the future but for now
    //         we re-initialize unnecessary things again/again.

    // check if the thread is us, 
    // to un-initialize the grammar then rebuild the one

    TraceMsg(TF_LB_SINK, "CLangBarSink::OnThreadItemChange, dwThreadId=%d", dwThreadId);

    _UninitItemList();
    
    OnSetFocus(dwThreadId);
    
    // call sptask to rebuild grammar here
    
    return S_OK;
}


//+---------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

HRESULT CLangBarSink::Init()
{
    TraceMsg(TF_LB_SINK, "CLangBarSink::Init is called");

    HRESULT hr = _EnsureLangBarMgrs();
   
    if (!m_fInitSink)
    {
        // the sink leaks if we call this twice
        if (S_OK == hr)
        {
            hr = m_cplbm->AdviseEventSink(this, NULL, 0, &m_dwlbimCookie);
        }
        m_fInitSink = TRUE;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// Uninit
//
//----------------------------------------------------------------------------
HRESULT CLangBarSink::Uninit()
{
    TraceMsg(TF_LB_SINK, "CLangBarSink::Uninit is called");
    if (m_cplbm)
    {
        m_cplbm->UnadviseEventSink(m_dwlbimCookie);
        m_cplbm.Release();
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _EnsureLangBarMgrs
//
//----------------------------------------------------------------------------
HRESULT CLangBarSink::_EnsureLangBarMgrs()
{
    HRESULT hr = S_OK;
    
    TraceMsg(TF_LB_SINK, "CLangBarSink::_EnsureLangBarMgrs is called");

    if (!m_cplbm)
    {
        hr = TF_CreateLangBarMgr(&m_cplbm);
    }

    if (S_OK == hr && !m_cplbim)
    {
        DWORD dw;
        hr = m_cplbm->GetThreadLangBarItemMgr(GetCurrentThreadId(), &m_cplbim, &dw);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// _AddLBarItem
//
//----------------------------------------------------------------------------

void CLangBarSink::_AddLBarItem(ITfLangBarItem *plbItem)
{
    if (plbItem)
    {
        int nCnt = m_rgItem.Count();
        if (m_rgItem.Insert(nCnt, 1))
        {
            plbItem->AddRef();
            m_rgItem.Set(nCnt, plbItem);
            m_nNumItem++;
        } 
    } 
}

//+---------------------------------------------------------------------------
//
// _InitItemList
//
//----------------------------------------------------------------------------

HRESULT CLangBarSink::_InitItemList()
{
    TraceMsg(TF_LB_SINK, "CLangBarSink::_InitItemList is called");

    if (0 != m_nNumItem)   
    {
        TraceMsg(TF_LB_SINK, "m_nNumItem=%d, Don't continue InitItemList",m_nNumItem);
        return S_OK;
    }
    
    HRESULT hr = E_FAIL;
    CComPtr<IEnumTfLangBarItems> cpEnum;

    Assert(m_cplbim);

    if (SUCCEEDED(hr = m_cplbim->EnumItems(&cpEnum)))
    {
        ITfLangBarItem * plbi;
        while (S_OK == cpEnum->Next(1, &plbi, NULL))
        {
            hr = S_OK; // OK if there's at least one
            DWORD dwStatus;
            plbi->GetStatus(&dwStatus);
        
            // add buttons that are not diabled or hidden
            if ((dwStatus & (TF_LBI_STATUS_HIDDEN|TF_LBI_STATUS_DISABLED))==0)
            {
                _AddLBarItem(plbi);
            }
            plbi->Release();
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// _UninitItemList
//
//----------------------------------------------------------------------------

void CLangBarSink::_UninitItemList()
{
    TraceMsg(TF_LB_SINK, "CLangBarSink::_UninitItemList is called");

    if (int nCnt = m_rgItem.Count())
    {
        int i = 0;
        while (i < nCnt)
        {
            ITfLangBarItem * plbi = m_rgItem.Get(i);
            if (plbi)
                plbi->Release();
            i++;
        }
        m_rgItem.Clear();
    }
    
    m_nNumItem = 0;
    _UnloadGrammar();
}


//+---------------------------------------------------------------------------
// 
//    _BuildGrammar
//
//     synopsis: build a C&C grammar based on text labels of langbar
//               items
//
//     BuildGrammar( ) works only when the mode is in Voice command mode.
//
//     we have make sure only when voice command is ON and dictation command 
//     is enabled, this function is called.
//----------------------------------------------------------------------------
HRESULT CLangBarSink::_BuildGrammar()
{
    HRESULT hr = E_FAIL;
    // get sptask and create a grammar

    TraceMsg(TF_LB_SINK, "_BuildGrammar is called");
    if (m_pSpTask)
    {
        CComPtr<ISpRecoContext> cpReco;
        
        // get the grammar loaded to the dictation reco context
        // 
        // it will use the Voice command mode recon context.

        hr = m_pSpTask->GetRecoContextForCommand(&cpReco);

        TraceMsg(TF_LB_SINK, "TBarGrammar: GetRecoContextForCommand, hr=%x", hr);

        if (S_OK == hr)
        {
            // we don't need to re-create grammar object
            if (!m_cpSpGrammar)
            {
                hr = cpReco->CreateGrammar(GRAM_ID_TBCMD, &m_cpSpGrammar);

                TraceMsg(TF_LB_SINK, "TBarGrammar: Create TOOLBar Grammar");
            }
        }
        if (S_OK == hr)  
        {
            hr = m_cpSpGrammar->ResetGrammar(GetPlatformResourceLangID());
            TraceMsg(TF_LB_SINK, "TBarGrammar: ResetGrammar");
        }
        if (S_OK == hr)
        {
            // get the rule handle
            m_cpSpGrammar->GetRule(GetToolbarCommandRuleName(), RULE_ID_TBCMD, SPRAF_TopLevel|SPRAF_Active|SPRAF_Dynamic, TRUE, &m_hDynRule);
            TraceMsg(TF_LB_SINK, "TBarGrammar:Get Rule Handle");
            
            // then activate the rule
        }
        
        if (S_OK == hr)
        {
            // enumerate all the buttons,
            // see if they are either ITfLangBarItemBitmapButton
            // or ITfLangBarItemButton, that have OnClick method on them
            BSTR bstr;
            int nBtns = m_rgItem.Count();

            for (int i = 0; i < nBtns; i++)
            {
                GUID guidItem;

                if (_GetButtonText(i, &bstr, &guidItem) && bstr)
                {
                    // item and property 
                    // the item can include optional string (?please etc)
                    // if (_IsItemEnabledForCommand(guidItem))

                    if ( !IsEqualGUID(guidItem, GUID_LBI_SAPILAYR_COMMANDING) )
                    {
                        SPPROPERTYINFO pi = {0};
                        pi.pszName = bstr;
                        m_cpSpGrammar->AddWordTransition(m_hDynRule, NULL, bstr, L" ", SPWT_LEXICAL, (float)1.01, &pi);

                        TraceMsg(TF_LB_SINK, "TBarGrammar: button %S added to grammar", bstr);
                    }

                    SysFreeString(bstr);
                }
            }
            //
            // add a bogus string that has significant weight so we out weight
            // others
            //
            SPPROPERTYINFO pi = {0};
            const WCHAR c_szBogus[] = L"zhoulotskunosprok";

            pi.pszName = c_szBogus;
            m_cpSpGrammar->AddWordTransition(m_hDynRule, NULL, c_szBogus, L" ", SPWT_LEXICAL, (float)1000.01, &pi);

            TraceMsg(TF_LB_SINK, "TBarGrammar: start commit ...");
            m_cpSpGrammar->Commit(0);
            TraceMsg(TF_LB_SINK, "TBarGrammar:Done commit ...");

            m_fGrammarBuiltOut = TRUE;
        }
    }

    TraceMsg(TF_LB_SINK, "_BuildGrammar is done!!!!");

    return hr;
}

//+---------------------------------------------------------------------------
//
//     _UnloadGrammar
//
//
//----------------------------------------------------------------------------
HRESULT CLangBarSink::_UnloadGrammar()
{
    // clear the rule
    HRESULT hr = S_OK;

    TraceMsg(TF_LB_SINK, "CLangBarSink::_UnloadGrammar is called");

    if (m_cpSpGrammar)
    {
        hr = _ActivateGrammar(FALSE);
        if (S_OK == hr)
        {
            hr = m_cpSpGrammar->ClearRule(m_hDynRule);

            if ( hr == S_OK )
                m_fGrammarBuiltOut = FALSE; // Next time, the grammar needs to be rebuilt.
        }
    }


    return hr;
}

//+---------------------------------------------------------------------------
//
//    _ActivateGrammar
//
//     synopsis:
//
//----------------------------------------------------------------------------
HRESULT CLangBarSink::_ActivateGrammar(BOOL fActive)
{
    HRESULT hr =  S_OK;

    TraceMsg(TF_LB_SINK, "TBarGrammar: ActivateGrammar=%d", fActive);
           
    if (m_cpSpGrammar)
    {
        m_cpSpGrammar->SetRuleState(GetToolbarCommandRuleName(), NULL, fActive ? SPRS_ACTIVE : SPRS_INACTIVE);
    }

    TraceMsg(TF_LB_SINK, "TBarGrammar: ActivateGrammar is done");

    return hr;
}

//+---------------------------------------------------------------------------
//
//     ProcessToolBarCommand
//
//     When return value is TRUE, there is corresponding button on the toolbar
//     otherwise the return value is FALSE
//----------------------------------------------------------------------------
BOOL CLangBarSink::ProcessToolbarCmd(const WCHAR *szProperty)
{
    BOOL  fRet=FALSE;

    Assert(szProperty);

    // go through items in the array and call onclick method
    // if there is a match
    if (szProperty)
    {
        int nBtns = m_rgItem.Count();

        for (int i = 0; i < nBtns; i++)
        {
            BSTR bstr;
            if (_GetButtonText(i, &bstr, NULL) && bstr)
            {
                if (0 == wcscmp(szProperty, bstr))
                {
                    HRESULT hr = E_FAIL;

                    CComPtr<ITfLangBarItemButton>       cplbiBtn ;
                    CComPtr<ITfLangBarItemBitmapButton> cplbiBmpBtn ;
                    POINT pt = {0, 0};
                    ITfLangBarItem * plbi = m_rgItem.Get(i);
                    if (plbi)
                    {
                        hr = plbi->QueryInterface(IID_ITfLangBarItemButton, (void **)&cplbiBtn);
#ifndef TOOLBAR_CMD_FOR_MENUS
                        // this code removes the toolbar command from thoese
                        // items with menus

                        TF_LANGBARITEMINFO info;
                        if (S_OK == hr)
                        {
                            hr = plbi->GetInfo(&info);
                        }
                        if (info.dwStyle & TF_LBI_STYLE_BTN_MENU)
                        {
                            // do not click on buttons with menu items
                            // since we don't hanle commands for the items
                        }
                        else
#endif
                        if (S_OK == hr)
                        {
                            // is it OK to call OnClick without specifying rect?
                            hr = cplbiBtn->OnClick(TF_LBI_CLK_LEFT, pt, NULL);

                            // OnClick would start a new edit session for some buttons, such
                            // as "Correction"
                            //
                            // The return value could be TS_S_ASYNC or S_OK depends on how
                            // the application grants the edit request.
                            //
                            // We need to check if the hr value is successful.
                            // not only S_OK.

                            if ( SUCCEEDED(hr) )
                                fRet = TRUE;
                        }
#ifdef TOOLBAR_CMD_FOR_MENUS 
                        TF_LANGBARITEMINFO info;
                        RECT rc = {0};
                        if (S_OK == hr)
                        {
                            hr = plbi->GetInfo(&info);
                        }
                        if (S_OK == hr)
                        {
                            hr = m_cplbim->GetItemFloatingRect(0, info.guidItem, &rc);
                        }

                        if (S_OK == hr)
                        {
                            HWND hwnd = FindWindow(NULL, TF_FLOATINGLANGBAR_WNDTITLEA);
                            if (hwnd)
                            {
                                DWORD  dw;
                                POINT poi;
 
                                poi.x =  (rc.right + rc.left)/2,
                                poi.y =  (rc.top + rc.bottom)/2,
 
                                ::ScreenToClient(hwnd, &poi);
 
                                dw = MAKELONG(LOWORD(poi.x), LOWORD(poi.y));
                                
                                PostMessage(hwnd, WM_LBUTTONDOWN, MK_LBUTTON, dw);
                                PostMessage(hwnd, WM_LBUTTONUP, 0, dw);
                           }
                        }
#endif
                    }

                    if (!cplbiBtn)
                    {
                        hr = plbi->QueryInterface(IID_ITfLangBarItemBitmapButton, (void **)&cplbiBmpBtn);
                        if (S_OK == hr)
                        {
                            hr = cplbiBtn->OnClick(TF_LBI_CLK_LEFT, pt, NULL);

                            if ( S_OK == hr )
                                fRet = TRUE;
                        }
                    }
                    break;
                } // if (0 == wcscmpi(szProperty, bstr))
                
                SysFreeString(bstr);
            } // if (_GetButtonText(i, bstr))
            
        } // for
    }

    return fRet;
}

//+---------------------------------------------------------------------------
//
//    GetButtonText
//
//----------------------------------------------------------------------------
BOOL CLangBarSink::_GetButtonText(int iBtn, BSTR *pbstr, GUID *pguid)
{
    HRESULT hr = E_FAIL;

    CComPtr<ITfLangBarItemButton>       cplbiBtn ;
    CComPtr<ITfLangBarItemBitmapButton> cplbiBmpBtn ;
    
    Assert(iBtn < m_rgItem.Count());
    Assert(pbstr);
    *pbstr = NULL;

    ITfLangBarItem * plbi = m_rgItem.Get(iBtn);


    if (plbi)
    {
        hr = plbi->QueryInterface(IID_ITfLangBarItemButton, (void **)&cplbiBtn);
        if (S_OK == hr)
        {
            hr = cplbiBtn->GetTooltipString(pbstr);
        }
    }
    // only in case when the button does not have a
    // regular interface we'd qi for bitmapbutton
    if (!cplbiBtn)
    {
        hr = plbi->QueryInterface(IID_ITfLangBarItemBitmapButton, (void **)&cplbiBmpBtn);
        if (S_OK == hr)
        {
            hr = cplbiBmpBtn->GetTooltipString(pbstr);
        }
    }

    TF_LANGBARITEMINFO Info = {0};

    if (S_OK == hr)
    {
        hr = plbi->GetInfo(&Info);
    }

    if (S_OK == hr)
    {
        if (pguid)
        {
            memcpy(pguid, &(Info.guidItem), sizeof(GUID));
        }

        if (Info.dwStyle & TF_LBI_STYLE_BTN_MENU)
        {
            // do not create commands for buttons with menu items
            // since we don't hanle commands for the items
            hr = S_FALSE;
        }
    }

    if (S_OK != hr && *pbstr)
    {
        // avoid mem leak
        SysFreeString(*pbstr);
    }
    
    return S_OK == hr;
}

//+---------------------------------------------------------------------------
//
// OnModalInput
//
//----------------------------------------------------------------------------

STDAPI CLangBarSink::OnModalInput(DWORD dwThreadId, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// ShowFloating
//
//----------------------------------------------------------------------------

STDAPI CLangBarSink::ShowFloating(DWORD dwFlags)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// GetItemFloatingRect
//
//----------------------------------------------------------------------------

STDAPI CLangBarSink::GetItemFloatingRect(DWORD dwThreadId, REFGUID rguid, RECT *prc)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\lmlattic.h ===
//
//	LM Lattice Object class definition
//

#ifndef LMLATTIC_H
#define LMLATTIC_H


//
// CLMLattice
//
//
class CLMLattice : public ITfLMLattice
{
public:
    // ctor / dtor
	CLMLattice(CSapiIMX *p_tip, IUnknown *pResWrap);
	~CLMLattice();

	// IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
	// ITfLMLattice
    STDMETHODIMP QueryType(REFGUID refguidType, BOOL *pfSupported);
    STDMETHODIMP EnumLatticeElements( DWORD dwFrameStart,
                                      REFGUID refguidType,
                                      IEnumTfLatticeElements **ppEnum);

private:
    CComPtr<IUnknown>    m_cpResWrap;
    ULONG m_ulStartSRElement;
    ULONG m_ulNumSRElements;
    CSapiIMX  *m_pTip;
	LONG m_cRef;
};

//
// CEnumLatticeElements
//
class CEnumLatticeElements : public IEnumTfLatticeElements, 
                             public CStructArray<TF_LMLATTELEMENT>
{
public:
    // ctor / dtor
	CEnumLatticeElements(DWORD dwFrameStart);
	~CEnumLatticeElements();

	// IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// ITfEnumLatticeElements
    STDMETHODIMP Clone(IEnumTfLatticeElements **ppEnum);
    STDMETHODIMP Next(ULONG ulCount, TF_LMLATTELEMENT *rgsElements, ULONG *pcFetched);
    STDMETHODIMP Reset();
    STDMETHODIMP Skip(ULONG ulCount);
	
    // internal APIs
    HRESULT  _InitFromPhrase 
    ( 
        SPPHRASE *pPhrase,       // pointer to a phrase object
        ULONG ulStartElem,        // start/num elements used in this phrase
        ULONG ulNumElem           // for this lattice
    );

    ULONG _Find(DWORD dwFrame, ULONG *pul);
private:

	DWORD m_dwFrameStart;
	ULONG m_ulCur;
	ULONG m_ulTotal;

	LONG m_cRef;
};


#endif // LMLATTIC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\lbarsink.h ===
#ifndef _LBARSINK_H_
#define _LBARSINK_H_

#include "private.h"
#include "sapilayr.h"
#include "ptrary.h"

extern const GUID GUID_LBI_SAPILAYR_MICROPHONE;
extern const GUID GUID_LBI_SAPILAYR_COMMANDING;

//////////////////////////////////////////////////////////////////////////////
//
// CLangBarSink
//
//////////////////////////////////////////////////////////////////////////////
class CSapiIMX;
class CSpTask;
class CLangBarSink:  public ITfLangBarEventSink
{
public:
    CLangBarSink(CSpTask *pSpTask);
    ~CLangBarSink();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfLangBarEventSink
    //
    STDMETHODIMP OnSetFocus(DWORD dwThreadId);
    STDMETHODIMP OnThreadTerminate(DWORD dwThreadId);
    STDMETHODIMP OnThreadItemChange(DWORD dwThreadId);
    STDMETHODIMP GetWindow(HWND *phwnd);
    STDMETHODIMP OnModalInput(DWORD dwThreadId, UINT uMsg, WPARAM wParam, LPARAM lParam);
    STDMETHODIMP ShowFloating(DWORD dwFlags);
    STDMETHODIMP GetItemFloatingRect(DWORD dwThreadId, REFGUID rguid, RECT *prc);

    // public methods
    HRESULT Init();
    HRESULT Uninit();
    WCHAR * GetToolbarCommandRuleName() {return L"TBRule";}
    BOOL    ProcessToolbarCmd(const WCHAR *szProperty);
    HRESULT   _OnSetFocus();
    BOOL _IsItemEnabledForCommand(REFGUID rguidItem)
    {
        if (IsEqualGUID(GUID_TFCAT_TIP_SPEECH, rguidItem))
            return FALSE;
        
        return TRUE;
    }

    BOOL  _IsTBGrammarBuiltOut( ) { return m_fGrammarBuiltOut; }
    HRESULT  _ActivateGrammar(BOOL fActive);

private:
    HRESULT  _InitItemList();
    void     _UninitItemList();

    HRESULT  _BuildGrammar();
    HRESULT  _UnloadGrammar();


    HRESULT _EnsureLangBarMgrs();
    
    void _AddLBarItem(ITfLangBarItem *plbItem);

    BOOL _GetButtonText(int iBtn, BSTR *pbstr, GUID *pguid);

    DWORD    m_dwlbimCookie;

    CComPtr<ITfLangBarMgr>         m_cplbm;
    CComPtr<ITfLangBarItemMgr>     m_cplbim;
    CComPtr<ISpRecoGrammar>        m_cpSpGrammar;
    SPSTATEHANDLE                  m_hDynRule;

    CPtrArray<ITfLangBarItem> m_rgItem;
    int                    m_nNumItem;
    BOOL                   m_fInitSink;
    CSpTask               *m_pSpTask;
    BOOL                   m_fPosted ;
    BOOL                   m_fGrammarBuiltOut;   // Is the grammar built out since last time button list was changed?

    int m_cRef;
};

#endif _LBARSINK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\globals.h ===
//+---------------------------------------------------------------------------
//
//  File:       globals.h
//
//  Contents:   Global variable declarations.
//
//----------------------------------------------------------------------------

#ifndef GLOBALS_H
#define GLOBALS_H

#include "private.h"
#include "ciccs.h"

extern HINSTANCE g_hInst;
extern HINSTANCE g_hInstSpgrmr;
extern DWORD g_dwTlsIndex;
extern const GUID GUID_PROP_SAPI_DISPATTR;
extern const GUID GUID_PROP_SAPIRESULTOBJECT; // ISpRecoResult object
extern const GUID GUID_ATTR_SAPI_INPUT;
extern const GUID GUID_ATTR_SAPI_GREENBAR;
extern const GUID GUID_ATTR_SAPI_GREENBAR2;
extern const GUID GUID_ATTR_SAPI_REDBAR;
extern const GUID GUID_ATTR_SAPI_SELECTION;
extern const GUID GUID_IC_PRIVATE;
extern const GUID GUID_COMPARTMENT_SPEECHPRIV_REFCNT;
extern const GUID GUID_COMPARTMENT_SPEECH_LEARNDOC;
extern const GUID GUID_COMPARTMENT_TTS_STATUS;
extern const GUID GUID_COMPARTMENT_SHARED_BLN_TEXT;
extern const GUID GUID_COMPARTMENT_SPEECHUISHOWN;
extern const GUID GUID_COMPARTMENT_SPEECH_STAGE;
extern const GUID GUID_COMPARTMENT_SPEECH_STAGECHANGE;
extern const GUID GUID_COMPARTMENT_SPEECH_STAGEDICTATION;
extern const GUID CLSID_UIHost;
extern const GUID GUID_COMPARTMENT_SPEECH_PROPERTY_CHANGE;
extern const GUID CLSID_SpPropertyPage;
extern const LARGE_INTEGER c_li0;

extern const GUID GUID_HOTKEY_TTS_PLAY_STOP;
extern const GUID GUID_HOTKEY_MODE_DICTATION;
extern const GUID GUID_HOTKEY_MODE_COMMAND;

extern CCicCriticalSectionStatic g_cs;

// tablet stuff
extern const CLSID CLSID_CorrectionIMX;
extern const GUID GUID_IC_PRIVATE;

const TCHAR c_szStatusWndClass[] = TEXT("SapiLayrStatusWndClass");
const TCHAR c_szStatusWndName[] = TEXT("SapiLayer");
const TCHAR c_szWorkerWndClass[]   = TEXT("SapiTipWorkerClassV1.0");

const TCHAR c_szSapilayrKey[]      = TEXT("SOFTWARE\\Microsoft\\CTF\\Sapilayr\\");
const TCHAR c_szDocBlockSize[]     = TEXT("docblocksize");
const TCHAR c_szMaxCandChars[]     = TEXT("MaxCandChars");

// Rule and property values in shrdcmd.xml
const WCHAR c_szSelword[]       = L"selword";
const WCHAR c_szSelThrough[]    = L"SelectThrough";
const WCHAR c_szSelectSimple[]  = L"SelectSimpleCmds";
const WCHAR c_szEditCmds[]      = L"EditCmds";
const WCHAR c_szNavigationCmds[]= L"NavigationCmds";
const WCHAR c_szCasingCmds[]    = L"CasingCmds";
const WCHAR c_szKeyboardCmds[]  = L"KeyboardCmds";

// Rule and property values in spell.xml
const WCHAR c_szSpelling[]      = L"spelling";
const WCHAR c_szSpellMode[]     = L"spellmode";
const WCHAR c_szSpellThat[]     = L"spellthat";
const WCHAR c_szSpellingMode[]  = L"spellingmode";

// Rule and property values in dictcmd.xml
const WCHAR c_szDictTBRule[]    = L"ToolbarCmd";  // Diction toolbar command rule name in dictcmd.xml
const WCHAR c_szDynUrlHist[]    = L"UrlDynHistory";  // modebias command for Url History
const WCHAR c_szStaticUrlHist[] = L"UrlHistory";
const WCHAR c_szStaticUrlSpell[] = L"UrlSpelling";

const WCHAR c_szHttp[]          = L"http";
const WCHAR c_szDot[]           = L"dot";
const WCHAR c_szSlash[]         = L"slash";
const WCHAR c_szColon[]         = L"colon";
const WCHAR c_szTilda[]         = L"tilda";
const WCHAR c_szWWWDot[]        = L"www dot";
const WCHAR c_szDotCom[]        = L"dot com";
const WCHAR c_szDotHtml[]        = L"dot html";
const WCHAR c_szDotExe[]        = L"dot exe";
const WCHAR c_szWWW[]           = L"www";
const WCHAR c_szCom[]           = L"com";
const WCHAR c_szHtml[]          = L"html";
const WCHAR c_szExe[]          =  L"exe";

const WCHAR c_szHttpSla2[]         = L"http://";
const WCHAR c_szSymDot[]           = L".";
const WCHAR c_szSymSlash[]         = L"/";
const WCHAR c_szSymColon[]         = L":";
const WCHAR c_szSymTilda[]         = L"~";
const WCHAR c_szSymWWWDot[]        = L"www.";
const WCHAR c_szSymDotCom[]        = L".com";
const WCHAR c_szSymDotExe[]        = L".exe";
const WCHAR c_szSymDotHtml[]       = L".html";

#define    MAX_CANDIDATE_CHARS    128
#define    MAX_ALTERNATES_NUM     20


// global typedef
typedef struct {
    GUID guidFormatId;
}SRPROPHEADER;

//
// per thread information.
//
class CSpeechUIServer;
typedef struct {
    CSpeechUIServer *psus;
}SPTIPTHREAD;

SPTIPTHREAD *GetSPTIPTHREAD();
void FreeSPTIPTHREAD();
void UninitProcess();
void LoadSpgrmrModule();

#define    TF_SAPI_PERF   0x00010000     // for SAPI perf tracing
#define    TF_LB_SINK     0x00020000     // for Language Bar sink related code tracing
#define    TF_SPBUTTON    0x00040000     // for speech button & mode change tracing.

#endif // GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\learndoc.h ===
#ifndef _LEARNDOC_H
#define _LEARNDOC_H

#include "sapilayr.h"

class CSapiIMX;
class CSpTask;

#define SIZE_DOCUMENT_BLOCK   256 
#define SIZE_FIRST_BLOCK      64 

// This structure will keep the feed state for specified dim.
typedef struct _DimRef
{
    ITfDocumentMgr  *pDim;
    BOOL             _fFeed;
}  DIMREF;

class __declspec(novtable) CLearnFromDoc 
{
public:
    CLearnFromDoc(CSapiIMX *psi);
    virtual ~CLearnFromDoc( );

    BOOL  GetLearnFromDoc( ) { return _fLearnFromDoc; }
    void  UpdateLearnDocState( );

    HRESULT HandleLearnFromDoc(ITfDocumentMgr *pDim = NULL);

    ULONG _GetDocBlockSize( );

    HRESULT _HandleLearnFromDoc(TfEditCookie ec,ITfContext *pic, ITfDocumentMgr *pDim);
    HRESULT _GetNextRangeEditSession( );
    HRESULT _HandleNextRange(TfEditCookie ec, ULONG cchSizeRange);
    HRESULT _GetNextRangeContent(TfEditCookie ec, ULONG cchSizeRange);
    HRESULT _FeedContentRangeToSR( );
    HRESULT _UpdateRecoContextInterestSet(BOOL fLearnFromDoc );

    BOOL    _HasMoreContent( )  {  return _fMoreContent; }

    HRESULT _AddDimToList(ITfDocumentMgr  *pDim, BOOL fFed );
    HRESULT _RemoveDimFromList(ITfDocumentMgr  *pDim);
    HRESULT _SetDimFeedState(ITfDocumentMgr  *pDim, BOOL fFed );
    HRESULT _IsDimAlreadyFed(ITfDocumentMgr  *pDim, BOOL *fFeed);
    HRESULT _ClearDimList( );
    HRESULT _ResetDimListFeedState( );

private:

    CSapiIMX     *m_psi;
    WCHAR        *m_pwszDocBlock;
    ULONG         _cchBlockSize;
    ULONG         _cchContent;   // size of the real document block content in WCHAR.

    CComPtr<ITfRange>         _cpStartRange;  // This is for Cicero App's Doc Content Range.

    BOOL                      _fMoreContent;
    ITfContext               *_pic;
    CSpTask                  *_pCSpTask;
// PerfConsider: we may need to change this CPtrArray to CPtrStruct.
    CPtrArray<DIMREF>         _rgDim;
    BOOL                      _fLearnFromDoc;
};

#endif  // _LEARNDOC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\lmlattic.cpp ===
//
// lmlattice.cpp
//
// implelementation of ITfLMLattice object, IEnumTfLatticeElements object
//

#include "private.h"
#include "sapilayr.h"
#include "lmlattic.h"

//
// CLMLattice
//
//

// ctor / dtor
CLMLattice::CLMLattice(CSapiIMX *p_tip, IUnknown *pResWrap)
{
    m_cpResWrap = pResWrap;
    m_pTip = p_tip;
    if (m_pTip)
    {
        m_pTip->AddRef();
    }
    m_cRef = 1;
}

CLMLattice::~CLMLattice()
{
    if (m_pTip)
    {
        m_pTip->Release();
    }
}

// IUnknown
HRESULT CLMLattice::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hr;
    Assert(ppvObj);
    
    if (IsEqualIID(riid, IID_IUnknown)
    ||  IsEqualIID(riid, IID_ITfLMLattice))
    {
        *ppvObj = this;
        hr = S_OK;
        this->m_cRef++;
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }
    return hr;
}

ULONG CLMLattice::AddRef(void)
{
    this->m_cRef++;
    return this->m_cRef;
}

ULONG CLMLattice::Release(void)
{
    this->m_cRef--;
    if (this->m_cRef > 0)
    {
        return this->m_cRef;
    }
    delete this;
    return 0;
}

// ITfLMLattice
HRESULT CLMLattice::QueryType(REFGUID refguidType, BOOL *pfSupported)
{
    HRESULT hr = E_INVALIDARG;

    if (pfSupported)
    {
         *pfSupported = IsEqualGUID(refguidType, GUID_LMLATTICE_VER1_0);
         if (*pfSupported)
             hr = S_OK;
    }
    return hr;
}

HRESULT CLMLattice::EnumLatticeElements( DWORD dwFrameStart, REFGUID refguidType, IEnumTfLatticeElements **ppEnum)
{
    if (!ppEnum)
       return E_INVALIDARG;
       
    *ppEnum = NULL;
       
    if (!IsEqualGUID(refguidType, GUID_LMLATTICE_VER1_0))
       return E_INVALIDARG;

    HRESULT hr = E_FAIL;
    // get alternates and cache the returned cotaskmem
    ULONG ulcMaxAlt = m_pTip->_GetMaxAlternates();
    ISpPhraseAlt **ppAlt = NULL;
 
    CComPtr<IServiceProvider> cpServicePrv;
    CComPtr<ISpRecoResult> cpRecoResult;
    CRecoResultWrap *pWrap = NULL;
    ULONG    ulStartInWrp, ulNumInWrp;
    
    //  QI the service provider first then get to the sapi interface
    //
    hr = m_cpResWrap->QueryInterface(IID_IServiceProvider, (void **)&cpServicePrv);
 
    if (SUCCEEDED(hr))
    {
        hr = m_cpResWrap->QueryInterface(IID_PRIV_RESULTWRAP, (void **)&pWrap);
    }

    if (SUCCEEDED(hr))
    {
        hr = cpServicePrv->QueryService(GUID_NULL, IID_ISpRecoResult, (void **)&cpRecoResult);
    }


    ulStartInWrp = pWrap->GetStart();
    ulNumInWrp = pWrap->GetNumElements();

    if ( SUCCEEDED(hr))
    {
        // Get the Alternates for current RecoResult.
        ppAlt = (ISpPhraseAlt **)cicMemAlloc(ulcMaxAlt * sizeof(ISpPhraseAlt *));
        if (ppAlt)
        {
            hr = cpRecoResult->GetAlternates(
                                    ulStartInWrp, 
                                    ulNumInWrp, 
                                    ulcMaxAlt, 
                                    ppAlt,          /* [out] ISpPhraseAlt **ppPhrases, */
                                    &ulcMaxAlt      /* [out] ULONG *pcPhrasesReturned */
                                 );
        }
        else
            hr = E_OUTOFMEMORY;
 
    }
    
    // OK now create an instance of enumerator
    CEnumLatticeElements *pEnumLE = NULL;

    if ( SUCCEEDED(hr) )
    {
        pEnumLE = new CEnumLatticeElements(dwFrameStart);

        if (!pEnumLE)
           hr = E_OUTOFMEMORY;

        if (S_OK == hr)
        {
            for ( ULONG i=0; i<ulcMaxAlt; i++)
            {
                SPPHRASE *pPhrase = NULL;
                ULONG     ulStart, ulNum;
                ULONG     ulStartInPar, ulNumInParent;

                ppAlt[i]->GetPhrase(&pPhrase);
                ppAlt[i]->GetAltInfo(NULL, &ulStartInPar, &ulNumInParent, &ulNum);

                if ( (ulStartInPar >= ulStartInWrp) && (ulStartInPar+ulNumInParent <= ulStartInWrp+ulNumInWrp) )
                {
                    // This is a valid alternate
                    if( SUCCEEDED(hr) )
                    {
                        ulStart = ulStartInPar;
                        hr = pEnumLE->_InitFromPhrase(pPhrase, ulStart, ulNum);
                    }
                }

                if (pPhrase)
                {
                    CoTaskMemFree(pPhrase);
                }
            }
        }
    }
        
    if (S_OK == hr)
    {
        hr = pEnumLE->QueryInterface(IID_IEnumTfLatticeElements, (void **)ppEnum);
    }
    
    SafeRelease(pEnumLE);

    if ( ppAlt )
    {
        // Release references to alternate phrases.
        for (int i = 0; i < (int)ulcMaxAlt; i++)
        {
            if (NULL != (ppAlt)[i])
            {
                ((ppAlt)[i])->Release();
            }
        }

        cicMemFree(ppAlt);
    }

    return hr;
}

//
// CEnumLatticeElements
//
//

// ctor / dtor
CEnumLatticeElements::CEnumLatticeElements(DWORD dwFrameStart)
{
	m_dwFrameStart = dwFrameStart;
	m_ulCur = (ULONG)-1;
	m_ulTotal = 0;

	m_cRef = 1;
}

CEnumLatticeElements::~CEnumLatticeElements()
{
    // clean up the lattice elements here
    int  ulCount;
    TF_LMLATTELEMENT * pLE;

    ulCount = (int) Count( );

    TraceMsg(TF_GENERAL, "CEnumLatticeElements::~CEnumLatticeElements: ulCount=%d", ulCount);

    if (ulCount)
    {
        for (int i = 0; i < ulCount; i++)
        {
            pLE = GetPtr(i);
            if ( pLE && pLE->bstrText)
            {
                ::SysFreeString(pLE->bstrText);
                pLE->bstrText=0;
            }
        }
    }
}

// IUnknown
HRESULT CEnumLatticeElements::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hr;
    Assert(ppvObj);
    
    if (IsEqualIID(riid, IID_IUnknown)
    ||  IsEqualIID(riid, IID_IEnumTfLatticeElements))
    {
        *ppvObj = this;
        hr = S_OK;
        this->m_cRef++;
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }
    return hr;
}

ULONG CEnumLatticeElements::AddRef(void)
{
    this->m_cRef++;
    return this->m_cRef;
}

ULONG CEnumLatticeElements::Release(void)
{
    this->m_cRef--;
    if (this->m_cRef > 0)
    {
        return this->m_cRef;
    }
    delete this;
    return 0;
}

// ITfEnumLatticeElements
HRESULT CEnumLatticeElements::Clone(IEnumTfLatticeElements **ppEnum)
{
    HRESULT hr = E_INVALIDARG;
    if (ppEnum)
    {
        CEnumLatticeElements *pele = new CEnumLatticeElements(m_dwFrameStart);

        if ( !pele )
           return E_OUTOFMEMORY;

        if (pele->Append(Count()))
        {
            for (int i = 0; i < Count(); i++)
            {
                *(pele->GetPtr(i)) = *GetPtr(i);
                Assert((pele->GetPtr(i))->bstrText);
                (pele->GetPtr(i))->bstrText = SysAllocString(GetPtr(i)->bstrText);

            }
            
	        pele->m_dwFrameStart = m_dwFrameStart;
            hr = pele->QueryInterface(IID_IEnumTfLatticeElements, (void **)ppEnum);
        }
        else
        {
            delete pele;
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
HRESULT CEnumLatticeElements::Next(ULONG ulCount, TF_LMLATTELEMENT *rgsElements, ULONG *pcFetched)
{
    if (ulCount == 0 
        || rgsElements == NULL
        || pcFetched   == NULL
    )
        return E_INVALIDARG;
        
    // find the start position
    if (m_dwFrameStart == -1)
    {
        m_ulCur = m_dwFrameStart = 0;
    }
    else
    {
        if (m_ulCur == (ULONG)-1)
        {
            _Find(m_dwFrameStart, &m_ulCur);
        }
    }
    
    if (m_ulCur >= m_ulTotal)
    {
        // no more elements but OK
        *pcFetched = 0;
    }
    else
    {
        // something to return
        for (ULONG ul = m_ulCur; 
             ul < m_ulTotal && ul - m_ulCur < ulCount; 
             ul++)
        {
            rgsElements[ul-m_ulCur] = *GetPtr(ul);
        }
        *pcFetched = ul - m_ulCur;
    }

    return S_OK;
}

HRESULT CEnumLatticeElements::Reset()
{
    m_ulCur = (ULONG)-1;
    return S_OK;
}

HRESULT CEnumLatticeElements::Skip(ULONG ulCount)
{
    // find the start position
    if (m_dwFrameStart == -1)
    {
        m_ulCur = m_dwFrameStart = 0;
    }
    else
    {
        if (m_ulCur == (ULONG)-1)
        {
            _Find(m_dwFrameStart, &m_ulCur);
        }
    }
    
    m_ulCur += ulCount;
    
    if (m_ulCur > m_ulTotal)
        m_ulCur = m_ulTotal;

    return E_NOTIMPL;
}

//
// internal APIs
//

HRESULT  CEnumLatticeElements::_InitFromPhrase
(
    SPPHRASE *pPhrase, 
    ULONG ulStartElem, 
    ULONG ulNumElem
)
{
    Assert(pPhrase);

    if ( pPhrase == NULL)
        return E_INVALIDARG;

    HRESULT hr = S_OK;

    // allocate the initial slots
    if (!Append(ulNumElem))
    {
        hr = E_OUTOFMEMORY;
    }
    
    if (S_OK == hr)
    {
        long   lEndElem;
        long   indexOrgList;
        long   indexNewList;

        lEndElem = min(pPhrase->Rule.ulCountOfElements, ulStartElem + ulNumElem);
        lEndElem --; // Real position ( offset from 0 ) for the last element

        indexNewList = Count( ) - 1;
        indexOrgList = indexNewList - ulNumElem;

        m_ulTotal += ulNumElem;

        TraceMsg(TF_GENERAL, "_InitFromPhrase: m_ulTotal=%d", m_ulTotal);

        // FutureConsider: ITN has to be considered here!
        for (long i=lEndElem; i>=(long)ulStartElem; i--)
        {
            TF_LMLATTELEMENT * pLE;

            // Compare all the elements in the Org list from End to start 
            // with this new element's dwFrameStart,  
            // If dwFrameStart of the element in Org list is larger than(or equal to)
            // this element's dwFrameStart, just move the org element
            // to the current available position in the new list.

            // until we find an element in the org list whose dwFrameStart is less than 
            // this element's dwFrameStart. we need to move this element to the 
            // new current available item in the new list.

            // Current available position in the new list is from End to Start.

            while ( (indexOrgList >=0) && (indexNewList >=0) && (S_OK == hr) )
            {
                pLE = GetPtr(indexOrgList);
                if (pLE)
                {
                    if ( pLE->dwFrameStart >= pPhrase->pElements[i].ulAudioTimeOffset )
                    {
                        // Move this Org element to a new postion in new List.
                        TF_LMLATTELEMENT * pNewLE;

                        pNewLE = GetPtr(indexNewList);
                        if ( pNewLE)
                        {
                            pNewLE->dwFrameStart = pLE->dwFrameStart;
                            pNewLE->dwFrameLen = pLE->dwFrameLen;
                            pNewLE->dwFlags = pLE->dwFlags;
                            pNewLE->iCost = pLE->iCost;
                            pNewLE->bstrText = pLE->bstrText;

                            pLE->dwFrameStart = 0;
                            pLE->dwFrameLen = 0;
                            pLE->dwFlags = 0;
                            pLE->iCost = 0;
                            pLE->bstrText = 0;
                        }

                        // update the index position in both org and new list
                        indexNewList --;
                        indexOrgList --;
                    }
                    else
                    {
                        // current element from this phrase should be moved to the new list
                        break;
                    }
                }
                else
                { 
                    TraceMsg(TF_GENERAL, "CEnumLatticeElements::_InitFromPhrase: pLE is NULL");
                    hr = E_FAIL;
                    break;
                }
            }  //while


            if ( (S_OK == hr) && (indexNewList >=0) )
            {
                pLE = GetPtr(indexNewList);
                if (pLE)
                {
                    pLE->dwFrameStart = pPhrase->pElements[i].ulAudioTimeOffset;
                    pLE->dwFrameLen   = pPhrase->pElements[i].ulAudioSizeTime;

                    pLE->dwFlags      = 0; // for now
                    pLE->iCost        = pPhrase->pElements[i].ActualConfidence;
                
                    pLE->bstrText     = SysAllocString(pPhrase->pElements[i].pszDisplayText);

                    TraceMsg(TF_GENERAL, "i=%d, dwFramStart=%d bstrText=%S", i, pLE->dwFrameStart, pLE->bstrText); 

                    indexNewList--;
                }
            }

        }  // for
    }  // if

    return hr;
}

//
// _Find()
//
// slightly modified version of array find
//
ULONG CEnumLatticeElements::_Find(DWORD dwFrame, ULONG *pul)
{
    int iMatch = -1;
    int iMid = -1;
    int iMin = 0;
    int iMax = _cElems;

    while(iMin < iMax)
    {
        iMid = (iMin + iMax) / 2;
        DWORD dwCur = GetPtr(iMid)->dwFrameStart;
        if (dwFrame < dwCur)
        {
            iMax = iMid;
        }
        else if (dwFrame > dwCur)
        {
            iMin = iMid + 1;
        }
        else
        {
            iMatch = iMid;
            break;
        }
    }

    if (pul)
    {
        if ((iMatch == -1) && (iMid >= 0))
        {
            if (dwFrame < GetPtr(iMid)->dwFrameStart)
                iMid--;
        }
        *pul = iMid;
    }
    return iMatch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\lmobj.h ===
//
//    lmobj.h
//
//    LMOBJ class definition

#ifndef LMOBJ_H
#define LMOBJ_H

#include "private.h"
#include "sapilayr.h"
#include "candlist.h"
#include "ptrary.h"
#include "initguid.h"
//#include "msime.h"
#include "fnrecon.h"

#if  0
class CSapiAlternativeList;

class CLMObject
{
public:
    CLMObject() { m_pFELang = 0; }
    ~CLMObject();
    
    HRESULT InitLM();

    HRESULT AddHomonymsToAlternates(CSapiAlternativeList *pAlternates);
#ifdef LATER
    HRESULT FilterAlternates(CSapiAlternativeList *pAlternates);
#endif
    BOOL    InitOK (void) { return m_fInitOK; }

private:
    IFELanguage              *m_pFELang;
    BOOL                     m_fInitOK;
};

#endif  // if 0

//
// LMAlternates
//
// right now this is nothing more than a wrapper object of
// a single unicode string, but this may need to accomodate
// SRPHRASE objects in the future.
//
class CLMAlternates
{
public:
    ~CLMAlternates()
    {
        if (m_szAlternates)
        {
            delete[] m_szAlternates;
        }
    }

    HRESULT SetString(WCHAR *psz, int cch)
    {
        if (psz)
        {
            if (m_szAlternates)
            {
                delete[] m_szAlternates;
            }
            m_szAlternates = new WCHAR[cch+1];
            if (m_szAlternates)
            {
                wcsncpy(m_szAlternates, psz, cch);
                m_szAlternates[cch] = L'\0';
                
                m_cch = min(cch, (int)wcslen(m_szAlternates));

                return S_OK;
            }
        }
        return E_INVALIDARG;
    }
    HRESULT GetString(WCHAR *psz, int cch)
    {
        if (m_szAlternates && psz)
        {
            wcsncpy(psz, m_szAlternates, cch);        
            return S_OK;
        }
        return E_FAIL;
    }
    
    int GetLen() {return m_cch;}
    
private:
    WCHAR *m_szAlternates;
    int    m_cch;
};


class CSapiIMX;
class CMasterLMWrap
{
public:
    CMasterLMWrap(CSapiIMX *psi) 
    {
        m_langidMasterLM = (LANGID)-1;
        m_fLMInited      = FALSE;
        m_psi            = psi;
    }
    
    void _EnsureMasterLM(LANGID langidRequested);
    
protected: 
    LANGID                    m_langidMasterLM;
    CComPtr<ITfFnLMProcessor> m_cpMasterLM;
    BOOL                      m_fLMInited;
    CSapiIMX                  *m_psi;
};
#endif // LMOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\learndoc.cpp ===
//
//
// Sapilayr TIP CLearnFromDoc implementation.
//
//
#include "private.h"
#include "sapilayr.h"
#include "learndoc.h"

#include "cregkey.h"

// ----------------------------------------------------------------------------------------------------------
//
//  Implementation for CLeanrFromDoc
//
// -----------------------------------------------------------------------------------------------------------

CLearnFromDoc::CLearnFromDoc(CSapiIMX *psi) 
{
    m_psi = psi;
    m_pwszDocBlock = NULL;
    _pic = NULL;
    _pCSpTask = NULL;
    _cpStartRange = NULL;
    _cchBlockSize = -1;
    _fMoreContent = FALSE;
    _fLearnFromDoc = FALSE;
}

CLearnFromDoc::~CLearnFromDoc( ) 
{
    if ( m_pwszDocBlock )
        cicMemFree(m_pwszDocBlock);

    _ClearDimList( );
};


void  CLearnFromDoc::UpdateLearnDocState( )
{
    DWORD  dw;

    GetCompartmentDWORD(m_psi->_tim, GUID_COMPARTMENT_SPEECH_LEARNDOC, &dw, FALSE);

    if ( dw != 0 )
        _fLearnFromDoc = TRUE;
    else
        _fLearnFromDoc = FALSE;

    if ( _fLearnFromDoc == FALSE )
    {
        if ( m_pwszDocBlock )
        {
            cicMemFree(m_pwszDocBlock);
            m_pwszDocBlock = NULL;
        }
        _UpdateRecoContextInterestSet(FALSE);
        _ResetDimListFeedState( );
    }
}

ULONG CLearnFromDoc::_GetDocBlockSize( )
{
    if (_cchBlockSize == (ULONG)-1)
    {
        CMyRegKey regkey;
        if (S_OK == regkey.Open(HKEY_LOCAL_MACHINE, c_szSapilayrKey, KEY_READ))
        {
            DWORD dw;
            if (ERROR_SUCCESS==regkey.QueryValue(dw, c_szDocBlockSize))
            {
                _cchBlockSize = dw;
            }
        }

        if (_cchBlockSize == (ULONG)-1)
        {
            _cchBlockSize = SIZE_DOCUMENT_BLOCK;
        }

        if ( _cchBlockSize < SIZE_FIRST_BLOCK )
            _cchBlockSize = SIZE_FIRST_BLOCK;  // the first block size is the minimize size.
    }
    return _cchBlockSize;
}


HRESULT   CLearnFromDoc::HandleLearnFromDoc(ITfDocumentMgr *pDim )
{
    HRESULT  hr = S_OK;
    CComPtr<ITfContext> cpic=NULL;
    ITfDocumentMgr *dim;

    if ( !m_psi )
        return E_FAIL;

    if ( m_psi->GetFocusIC(&cpic) && (GetLearnFromDoc( ) == TRUE))
    {
        if ( !pDim )
        {
            // Try to get the Dim from current focused IC.
            hr = cpic->GetDocumentMgr(&dim);
        }
        else
        {
            dim = pDim;
            dim->AddRef( );
        }

        if ( !dim )
            hr = E_FAIL;

        if ( S_OK == hr ) 
        {   
            // Check to see if this doc has already been fed to SR LM engine.
            BOOL fFedAlready = FALSE;
            hr = _IsDimAlreadyFed(dim, &fFedAlready);

            if ( (S_OK == hr) && !fFedAlready )
            {
                // Check to if the current doc is ReadOnly or not.
                TF_STATUS  docStatus;
                hr = cpic->GetStatus(&docStatus);

                if ( S_OK == hr && !(docStatus.dwStaticFlags & TF_SD_READONLY) )
                {
                    ESDATA  esData;

                    memset(&esData, 0, sizeof(ESDATA));
                    esData.pUnk = (IUnknown *)dim;
                    hr = m_psi->_RequestEditSession(ESCB_HANDLE_LEARNFROMDOC,TF_ES_READ, &esData, cpic);
                }
            }

            dim->Release();
        }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
// CSapiIMX::_HandleLearnFromDoc
//
// Let the speech engine learn from existing document content and have 
// more accurate dictation recognition.
// This function will be called when user clicks the speech language bar menu 
// and select Learn From Document... item.
//
//---------------------------------------------------------------------------+

HRESULT CLearnFromDoc::_HandleLearnFromDoc(TfEditCookie ec,ITfContext *pic, ITfDocumentMgr *pDim )
{
   
    HRESULT   hr = S_OK;
    ULONG     cchBlock;
    BOOL      fFeedAlready;

    // Get the Dictation Grammar

    TraceMsg(TF_GENERAL, "_HandleLearnFromDoc() is called");

    if ( m_psi == NULL)
        return E_FAIL;

    if ( !pDim  || !pic )
        return E_INVALIDARG;

    _pic = pic;

    m_psi->GetSpeechTask(&_pCSpTask, FALSE); 

    if ( _pCSpTask == NULL )
    {
        // _sptask is not yet initialized, just return.
        TraceMsg(TF_GENERAL, "_HandleLearnFromDoc: _pCspTask is NULL");
        goto CleanUp;
    }
    
    cchBlock = _GetDocBlockSize( );

    if ( m_pwszDocBlock == NULL)
    {
        m_pwszDocBlock = (WCHAR *) cicMemAlloc( (cchBlock+1)*sizeof(WCHAR)  );
        if (m_pwszDocBlock == NULL)
        {
            TraceMsg(TF_GENERAL, "_HandleLearnFromDoc: m_pwszDocBlock Out of Memory");
            hr = E_OUTOFMEMORY;
            goto CleanUp;
        }
    }

    fFeedAlready = FALSE;

    hr = _IsDimAlreadyFed(pDim, &fFeedAlready);

    if ( (hr != S_OK) || fFeedAlready )
    {
        // This DIM has already been fed to SR Engine.
        // or we got problem to get the feed state for this dim.
        // stop here.
        goto CleanUp;
    }

    // Get the range for the document.
    _cpStartRange.Release( );
    hr = _pic->GetStart(ec, &_cpStartRange);
    if ((hr != S_OK) || (_cpStartRange == NULL))
    {
        TraceMsg(TF_GENERAL, "_HandleLearnFromDoc: _cpStartRange is NULL");
        goto CleanUp;
    }
    
    // Change the sptask interersting setting

    _UpdateRecoContextInterestSet(TRUE);

    // This is the first range of the document. just small size of block.
    hr = _GetNextRangeContent(ec, SIZE_FIRST_BLOCK);

        // Feed to SR Engine.
   if ( (hr == S_OK) && _fMoreContent)
   {
       hr = _FeedContentRangeToSR( );
       if ( hr == S_OK)
       {
           _SetDimFeedState(pDim, TRUE);
       }
       else
           _fMoreContent = FALSE;
    }

CleanUp:
    return hr;
}


//+---------------------------------------------------------------------------
//
//    _GetNextRangeContent
//
//    Get the Next Range (block) of document content. 
//    
//    update the flag to indicate if there is effective content
//    
//   ec:             EditCookie
//   cchSizeRange:   Required block size
//  
//             At the first time, we just feed a very small size of charcters
//             to the Engine so that it will not interfere with current dictation
//             handling of engine.
// 
//             After we get the ADAPTATION notification from Engine, we will feed 
//             normal size of block ( specified in registry ) to engine.
//
//---------------------------------------------------------------------------+

HRESULT CLearnFromDoc::_GetNextRangeContent(TfEditCookie ec, ULONG cchSizeRange)
{

    HRESULT  hr = S_OK;
    LONG     lShift = 0;
        
    TraceMsg(TF_GENERAL, "_GetNextRangeContent is Called");

    if ( m_pwszDocBlock == NULL)
    {
        m_pwszDocBlock = (WCHAR *) cicMemAlloc( (_cchBlockSize+1)*sizeof(WCHAR));
    	if (m_pwszDocBlock == NULL)
    	{
    		TraceMsg(TF_GENERAL, "_GetNextRangeContent: m_pwszDocBlock Out of Memory");
    		hr = E_OUTOFMEMORY;
    		return hr;
    	}
   }
            
    // assume there is no more content.
    _fMoreContent = FALSE;

    // This is Cicero App's Document,  we use Cicero interfaces to get the whole document.
    // We already get the cpStartRange.

    hr = _cpStartRange->GetText(ec, TF_TF_MOVESTART | TF_TF_IGNOREEND, m_pwszDocBlock, cchSizeRange, &_cchContent );

    if ( hr!= S_OK )  goto CleanUp;

    // If the last character is not a word-break char for English case, 
    // we don't want to keep this half word for this chunk text, it will go to next
    // chunk. 

    // we just want to shift back some charaters to hit a word-breaker.

    WORD    prilangid;

    prilangid = PRIMARYLANGID(m_psi->GetLangID( ));


    if ( prilangid != LANG_JAPANESE && prilangid != LANG_CHINESE )
    {
        if ( _cchContent > 0 )
        {
            while ( _cchContent > 0  )
            {
                if ( iswalpha(m_pwszDocBlock[_cchContent-1]) )
                {
                    m_pwszDocBlock[_cchContent-1] = L'\0';
                    lShift ++;
                    _cchContent--;
                }
                else
                    break;
            }

            if ( lShift > 0 )
            {
                lShift *= ( -1 );

                long  cch;
                _cpStartRange->ShiftEnd(ec, lShift, &cch, NULL);
            }
        }
    }

    TraceMsg(TF_GENERAL, "Text Content in Cicero Doc Buffer  _cchContent=%d---------------->", _cchContent);
#ifdef DEBUG
    {
        ULONG x;
        for (x=0; x<_cchContent; x++)
        {
            char szbuf[4];
            szbuf[0] = (char)(m_pwszDocBlock[x]);
            szbuf[1] = '\0';
            OutputDebugString(szbuf);
        }
        OutputDebugString("\n");
    }
#endif
    TraceMsg(TF_GENERAL, "Text Content in CiceroDoc Over -------------------!");

    if ( _cchContent > 0  || lShift > 0)
        // There is more content.
        _fMoreContent = TRUE;
    else
        _fMoreContent = FALSE;

CleanUp:

    return hr;
}

//+---------------------------------------------------------------------------
//
//    _FeedContentRangeToSR
//
//    Feed the current Range (block) of document content to the SR Engine. 
//
//---------------------------------------------------------------------------+

HRESULT CLearnFromDoc::_FeedContentRangeToSR( )
{
    HRESULT  hr = S_OK;
    WCHAR    *pCoMemText;
    CComPtr<ISpRecoContext>  cpRecoCtxt;

    TraceMsg(TF_GENERAL, "_FeedContentRangeToSR( ) is called");

    hr = _pCSpTask->GetSAPIInterface(IID_ISpRecoContext, (void **)&cpRecoCtxt );

    if ( (hr != S_OK) || (cpRecoCtxt == NULL) )
        return E_FAIL;

    // Feed this block of document content to speech dictation.
    if ( (_cchContent > 0) && (m_pwszDocBlock != NULL))
    {
        pCoMemText = (WCHAR *)CoTaskMemAlloc((_cchContent+1)*sizeof(WCHAR));

        if ( pCoMemText )
        {
            wcsncpy(pCoMemText, m_pwszDocBlock, _cchContent);
            pCoMemText[_cchContent] = L'\0';

            hr = cpRecoCtxt->SetAdaptationData(pCoMemText, _cchContent);

            if ( hr != S_OK)
                TraceMsg(TF_GENERAL, "_FeedContentRangeToSR: SetAdaptationData Failed");
        }
    }

    return hr;
}

HRESULT CLearnFromDoc::_GetNextRangeEditSession( )
{
    HRESULT  hr = S_OK;
    ESDATA   esData;

    Assert(m_psi);
    memset(&esData, 0, sizeof(ESDATA));
    esData.lData1 = (LONG_PTR)_cchBlockSize;
    hr = m_psi->_RequestEditSession(ESCB_LEARNDOC_NEXTRANGE, TF_ES_READ, &esData, _pic);

    return hr;
}

//+---------------------------------------------------------------------------
//
//    _HandleNextRange
//
//    Handle the Next Range (block) of document content, get and feed it and 
//    then update the status.
//
//   ec:             EditCookie
//   cchSizeRange:   Required block size
//
//---------------------------------------------------------------------------+
HRESULT CLearnFromDoc::_HandleNextRange(TfEditCookie ec, ULONG cchSizeRange)
{
    HRESULT  hr = S_OK;

    hr = _GetNextRangeContent(ec, cchSizeRange);

    if ( hr == S_OK  && _fMoreContent)
    {
        // This next range contains valid content, feed it to SR Engine.
        hr = _FeedContentRangeToSR( );
    }

    if ( (hr != S_OK) || !_fMoreContent )
    {
        // Error happened or no more content, update the interest set.
       hr = _UpdateRecoContextInterestSet(FALSE);
    }

    return hr;
}


//+-----------------------------------------------------------------------------------------
//
//    _UpdateRecoContextInterestSet
//
//    Update the RecoContext's interested notification event setting
//
//    if fLearnFromDoc is TRUE, we are interested in getting notification of SPEI_ADAPTATION
//    if fLearnFromDoc is FALSE, we are not interested in that notification
//
//-------------------------------------------------------------------------------------------+

HRESULT CLearnFromDoc::_UpdateRecoContextInterestSet( BOOL fLearnFromDoc )
{

    HRESULT   hr = S_OK;
    CComPtr<ISpRecoContext>  cpRecoCtxt;
    ULONGLONG ulInterest = SPFEI(SPEI_SOUND_START) | 
                                 SPFEI(SPEI_SOUND_END) | 
                                 SPFEI(SPEI_PHRASE_START) |
                                 SPFEI(SPEI_RECOGNITION) | 
                                 SPFEI(SPEI_RECO_OTHER_CONTEXT) | 
                                 SPFEI(SPEI_HYPOTHESIS) | 
                                 SPFEI(SPEI_INTERFERENCE) |
                                 SPFEI(SPEI_FALSE_RECOGNITION);
    if ( _pCSpTask == NULL )
        return hr;

    hr = _pCSpTask->GetSAPIInterface(IID_ISpRecoContext, (void **)&cpRecoCtxt );

    if ( (hr != S_OK) || (cpRecoCtxt == NULL) )
        return E_FAIL;

    if ( fLearnFromDoc )
        ulInterest |= SPFEI(SPEI_ADAPTATION);
    else
        ulInterest &= ~(SPFEI(SPEI_ADAPTATION));

    hr = cpRecoCtxt->SetInterest(ulInterest, ulInterest);
    return hr;
}

//+-----------------------------------------------------------------------------------------
//
//    _AddDimToList
//
//    Add a DIM to the dim list, and set the feed state  
//
//    This function would be called by TIM_CODE_INITDIM callback.
//
//-------------------------------------------------------------------------------------------+

HRESULT CLearnFromDoc::_AddDimToList(ITfDocumentMgr  *pDim, BOOL fFed )
{

    HRESULT  hr = S_OK;
    int      nCnt = _rgDim.Count();
    int      i;
    BOOL     bFound;
    DIMREF   *dimRef;

    TraceMsg(TF_GENERAL, "_AddDimToList is called");

    if ( !pDim )
        return E_INVALIDARG;

    // Check to see if this dim is already added.
    bFound = FALSE;
    for (i=0; i < nCnt; i++)
    {
        dimRef = (DIMREF   *)_rgDim.Get(i);

        if ( dimRef->pDim == pDim )
        {
            bFound = TRUE;
            TraceMsg(TF_GENERAL, "This dim has already been added to the dim list");
            break;
        }
    }

    if (bFound)
    {
        // Set the state.
        dimRef->_fFeed = fFed;
    }
    else
    {
        dimRef = (DIMREF   *)cicMemAllocClear(sizeof(DIMREF));
        if ( dimRef == NULL)
            return E_OUTOFMEMORY;

        dimRef->_fFeed = fFed;
        dimRef->pDim = pDim;

        if (!_rgDim.Insert(nCnt, 1))
        {
            cicMemFree(dimRef);
            return E_OUTOFMEMORY;
        }
         
        pDim->AddRef( );
        _rgDim.Set(nCnt, dimRef);
    }

    return hr;

}

//+-----------------------------------------------------------------------------------------
//
//    _RemoveDimFromList
//
//    Remove a DIM from the internal dim list, and release the DIM itself.   
//
//    This function would be called by TIM_CODE_UNINITDIM callback.
//
//-------------------------------------------------------------------------------------------+

HRESULT CLearnFromDoc::_RemoveDimFromList(ITfDocumentMgr  *pDim)
{
    HRESULT  hr = S_OK;
    int      nCnt = _rgDim.Count();
    int      i;
    DIMREF   *dimRef;

    TraceMsg(TF_GENERAL, "_RemoveDimFromList is called");

    if ( pDim == NULL)
        return E_INVALIDARG;

    // Check to see if this dim is already added.
    for (i=0; i < nCnt; i++)
    {
        dimRef = (DIMREF   *)_rgDim.Get(i);

        if ( dimRef->pDim == pDim )
        {
            // free the DIM.
            (dimRef->pDim)->Release( );
            dimRef->pDim = NULL;

            // Remove it from the list
            _rgDim.Remove(i, 1);

            // Remove the structure itself.
            cicMemFree(dimRef);

            break;
        }
    }

    return hr;
}

//+-----------------------------------------------------------------------------------------
//
//    _SetDimFeedState
//
//    Set the feed state for the specified DIM.   
//
//    fFed is TRUE means this DIM is already fed to the Engine.
//
//-------------------------------------------------------------------------------------------+

HRESULT CLearnFromDoc::_SetDimFeedState(ITfDocumentMgr  *pDim, BOOL fFed )
{

    HRESULT  hr = S_OK;
    int      nCnt = _rgDim.Count();
    int      i;
    DIMREF   *dimRef;

    TraceMsg(TF_GENERAL, "_SetDimFeedState is called");

    if ( pDim == NULL)
        return E_INVALIDARG;

    // Check to see if this dim is already added.
    for (i=0; i < nCnt; i++)
    {
        dimRef = (DIMREF   *)_rgDim.Get(i);

        if ( dimRef->pDim == pDim )
        {
            // Set the feed state for this DIM.
            dimRef->_fFeed = fFed;
            break;
        }
    }

    return hr;

}

//+-----------------------------------------------------------------------------------------
//
//    _IsDimAlreadyFed
//
//    Check to see if the dim is already fed to the Engine.   
//
//-------------------------------------------------------------------------------------------+

HRESULT    CLearnFromDoc::_IsDimAlreadyFed(ITfDocumentMgr  *pDim, BOOL  *fFeed)
{

    HRESULT  hr = S_OK;
    int      nCnt = _rgDim.Count();
    int      i;
    DIMREF   *dimRef;

    TraceMsg(TF_GENERAL, "_IsDimAlreadyFed is called");

    if ( (pDim == NULL) || (fFeed == NULL))
        return E_INVALIDARG;

    *fFeed = FALSE;

    // Check to see if this dim is already added.
    for (i=0; i < nCnt; i++)
    {
        dimRef = (DIMREF   *)_rgDim.Get(i);

        if ( dimRef->pDim == pDim )
        {
            // Get the feed state for this DIM.
            *fFeed = dimRef->_fFeed;
            TraceMsg(TF_GENERAL, "IsDimAlreadyFed: pDim=%x, fFeed=%s", (UINT_PTR)pDim,  *fFeed ? "TRUE":"FALSE");
            break;
        }
    }
       
    return hr;

}

// CleanUpConsider: above _IsDimAlreadyFed and _SetDimFeedState have similar code, we may supply a new internal base function, and let 
// above two functions call it with different param set.


//+-----------------------------------------------------------------------------------------
//
//    _ClearDimList
//
//    Release all the DIMs in the DIM List, and clear the list itself. 
//
//
//-------------------------------------------------------------------------------------------+

HRESULT CLearnFromDoc::_ClearDimList( )
{
    HRESULT  hr = S_OK;
    int      nCnt = _rgDim.Count();
    int      i;
    DIMREF   *dimRef;

    TraceMsg(TF_GENERAL, "_ClearDimList is called");

    for (i=0; i < nCnt; i++)
    {
        dimRef = (DIMREF   *)_rgDim.Get(i);

        // free the DIM.
        if ( dimRef->pDim)
        {
           (dimRef->pDim)->Release( );
           dimRef->pDim = NULL;
        }

        // Remove it from the list
        _rgDim.Remove(i, 1);

        // Remove the structure itself.
        cicMemFree(dimRef);
    }

    return hr;
}

//+-----------------------------------------------------------------------------------------
//
//    _ResetDimListFeedState
//
//    set feed state for all the dims in internal dim list as FALSE 
//
//    This function would be called when user turns off the Learn from Doc.
//
//-------------------------------------------------------------------------------------------+

HRESULT CLearnFromDoc::_ResetDimListFeedState( )
{
    HRESULT  hr = S_OK;
    int      nCnt = _rgDim.Count();
    int      i;
    DIMREF   *dimRef;

    TraceMsg(TF_GENERAL, "_ResetDimListFeedState is called");

    for (i=0; i < nCnt; i++)
    {
        dimRef = (DIMREF   *)_rgDim.Get(i);

        // Set the feed state for this DIM as FALSE
        dimRef->_fFeed = FALSE;
    }

    return hr;

}


// CleanUpConsider: above _ClearDimList and _ResetDimListFeedState have similar code, we may supply a new internal base function, and let 
// above two functions call it with different param set.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\lmobj.cpp ===
//
// LMOBJ.CPP
//
// implements a wrapper for external LM that we use for
// pre-processing SR lattice
//
//

#include "private.h"
#include "globals.h"
#include "sapilayr.h"
#include "fnrecon.h"
//#include "lmobj.h"
//#include "catutil.h"

//
// CMasterLMWrap implementation
//

//+---------------------------------------------------------------------------
//
// CMasterLMWrap::_EnsureMasterLM
//
//----------------------------------------------------------------------------
void CMasterLMWrap::_EnsureMasterLM(LANGID langidRequested)
{
    // langidRequested is given based on langid of reconversion range
    // m_langidMasterLM is based on the last master LMTIP we worked with
    //
    if (TRUE == m_fLMInited)
        return;
    
    if (!m_psi->_MasterLMEnabled())
        return;

    if ( !m_cpMasterLM || m_langidMasterLM != langidRequested )
    {
        m_cpMasterLM.Release();
    
        CComPtr<IEnumGUID>            cpEnum;
        HRESULT hr = LibEnumItemsInCategory(m_psi->_GetLibTLS(), GUID_TFCAT_TIP_MASTERLM, &cpEnum);   
        if (S_OK == hr)
        {
            GUID guidLMTIP;
            BOOL    fLangOK = FALSE;
            while(cpEnum->Next(1, &guidLMTIP, NULL) == S_OK && !fLangOK)
            {
                ITfFunctionProvider           *pFuncPrv = NULL;

                // check if the TIP can accomodate the language
                Assert(m_psi->_tim);
                hr = m_psi->_tim->GetFunctionProvider(guidLMTIP, &pFuncPrv);
                if (S_OK == hr)
                {
                    CComPtr<IUnknown>             cpunk;
                    CComPtr<ITfFnLMProcessor>     cpLMTIP;
                    hr = pFuncPrv->GetFunction(GUID_NULL, IID_ITfFnLMProcessor, &cpunk);
                    if (S_OK == hr)
                    {
                        hr = cpunk->QueryInterface(IID_ITfFnLMProcessor, (void **)&cpLMTIP);
                    }
                    
                    if (S_OK == hr)
                    {
                        hr = cpLMTIP->QueryLangID(langidRequested, &fLangOK);
                    }
                    
                    if (fLangOK == TRUE)
                    {
                        m_cpMasterLM = cpLMTIP;
                        m_langidMasterLM = langidRequested;
                    }
                    
                    SafeReleaseClear(pFuncPrv);
                } // if S_OK == GetFunctionProvider()
                
            } // while next
            
        } // if LibEnumItemsInCategory() == S_OK
        m_fLMInited = TRUE;
    } // if !m_cpMasterLM
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\private.h ===
//+---------------------------------------------------------------------------
//
//  File:       private.h
//
//  Contents:   Private header for sapilayr project.
//
//----------------------------------------------------------------------------

#ifndef _PRIVATE_H_
#define _PRIVATE_H_

#define _OLEAUT32_

#include <windows.h>
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h> 

//#include <windowsx.h>
#include <ccstock.h>
#include <debug.h>
#include <ole2.h>
#include <ocidl.h>
#include <olectl.h>
#include <servprov.h>
#include "combase.h"
#include "msctfp.h"
#include "ctffunc.h"
#include "ctfspui.h"
#include "helpers.h"
#include <tchar.h>
#ifdef __cplusplus
#include <sapi.h>
#include <atlbase.h>
#include <sphelper.h>
#endif // __cplusplus
#include "mem.h" // must be last

#endif  // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\nui.h ===
//
// nui.h
//

#ifndef NUI_H
#define NUI_H

#include "private.h"
#include "nuibase.h"
#include "timsink.h"
#include "sysbtn.h"

#define SORT_MICROPHONE      100
#define SORT_DICTATION       300
#define SORT_COMMANDING      400
#define SORT_BALLOON         500
#define SORT_TTSPLAYSTOP     510
#define SORT_TTSPAUSERESUME  520
#define SORT_CFGMENUBUTTON   600

// If Enable bit is 1, Show active buttons, 
// If it is 0, Gray the buttons.

// If Toggled bit is 1, show stop or resume buttons respectively.
// If it is 0, show play or pause buttons respectively.
#define TF_TTS_PLAY_STOP_TOGGLED     0x0001   
#define TF_TTS_PAUSE_RESUME_TOGGLED  0x0002

#define TF_TTS_BUTTON_ENABLE         0x0008

extern const IID IID_PRIV_CSPEECHUISERVER;
extern const GUID GUID_LBI_SAPILAYR_MICROPHONE;
extern const GUID GUID_LBI_SAPILAYR_CFGMENUBUTTON;
extern const GUID GUID_LBI_SAPILAYR_BALLOON;

class CSapiIMX;
class CLBarItemMicrophone;
class CLBarItemCfgMenuButton;
class CLBarItemBalloon;
class CLBarItemCommanding;
class CLBarItemDictation;
class CLBarItemSystemButtonBase;
class CLBarItemTtsPlayStop;
class CLBarItemTtsPauseResume;


#define ADDREMOVEITEMFUNCDEF(item_name)              \
    void AddItem ## item_name ## ();                 \
    void RemoveItem ## item_name ## ();              \
    void DisableItem ## item_name ## (BOOL fDisable);

#define ADDREMOVEITEMFUNC(item_name)                                          \
    __inline void CSpeechUIServer::AddItem ## item_name ## ()                 \
    {                                                                         \
        if (!_plbi ## item_name ## )                                          \
            _plbi ## item_name ##  = new CLBarItem ## item_name ## (this);    \
        if (_plbi ## item_name ## )                                           \
            _lbim->AddItem(_plbi ## item_name ## );                           \
    }                                                                         \
                                                                              \
    __inline void CSpeechUIServer::RemoveItem ## item_name ## ()              \
    {                                                                         \
        if (_plbi ## item_name ## )                                           \
            _lbim->RemoveItem(_plbi ## item_name ## );                        \
    }                                                                         \
                                                                              \
    __inline void CSpeechUIServer::DisableItem ## item_name ## (BOOL fDisable) \
    {                                                                         \
    if (!_plbi ## item_name ## )                                              \
        return;                                                               \
    _plbi ## item_name ## ->SetOrClearStatus(TF_LBI_STATUS_DISABLED,          \
                                             fDisable);                       \
    if (_plbi ## item_name ## ->GetSink())                                    \
       _plbi ## item_name ## ->GetSink()->OnUpdate(TF_LBI_STATUS);            \
    }

#define TOGGLEITEMFUNCDEF(item_name)                                          \
    void ToggleItem ## item_name ## (BOOL fOn);

#define TOGGLEITEMFUNC(item_name)                                             \
    __inline void CSpeechUIServer::ToggleItem ## item_name ## (BOOL fOn)      \
    {                                                                         \
    if (!_plbi ## item_name ## )                                              \
        return;                                                               \
    _plbi ## item_name ## ->SetOrClearStatus(TF_LBI_STATUS_BTN_TOGGLED, fOn); \
    if (_plbi ## item_name ## ->GetSink())                                    \
       _plbi ## item_name ## ->GetSink()->OnUpdate(TF_LBI_STATUS);            \
    }


//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemTtsPlayStop
//
//////////////////////////////////////////////////////////////////////////////

class CLBarItemTtsPlayStop : public CLBarItemButtonBase
{
public:
    CLBarItemTtsPlayStop(CSpeechUIServer *psus);
    ~CLBarItemTtsPlayStop();

    STDMETHODIMP GetIcon(HICON *phIcon);

    HRESULT   UpdateStatus( );

private:
    HRESULT OnLButtonUp(const POINT pt, const RECT *prcArea);
    CSpeechUIServer *_psus;
};

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemTtsPauseResume
//
//////////////////////////////////////////////////////////////////////////////

class CLBarItemTtsPauseResume : public CLBarItemButtonBase
{
public:
    CLBarItemTtsPauseResume(CSpeechUIServer *psus);
    ~CLBarItemTtsPauseResume();

    STDMETHODIMP GetIcon(HICON *phIcon);

    HRESULT   UpdateStatus( );

private:
    HRESULT OnLButtonUp(const POINT pt, const RECT *prcArea);
    CSpeechUIServer *_psus;
};


//////////////////////////////////////////////////////////////////////////////
//
// CSpeechUIServer
//
//////////////////////////////////////////////////////////////////////////////

class CSpeechUIServer : public ITfSpeechUIServer,
                        public CComObjectRoot_CreateSingletonInstance_Verify<CSpeechUIServer>
{
public:
    CSpeechUIServer();
    ~CSpeechUIServer();

    BEGIN_COM_MAP_IMMX(CSpeechUIServer)
        COM_INTERFACE_ENTRY_IID(IID_PRIV_CSPEECHUISERVER, CSpeechUIServer)
        COM_INTERFACE_ENTRY(ITfSpeechUIServer)
    END_COM_MAP_IMMX()

    static BOOL VerifyCreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj) { return TRUE; }
    static void PostCreateInstance(REFIID riid, void *pvObj);

    //
    // ITfSpeechUIServer
    //
    STDMETHODIMP Initialize();
    STDMETHODIMP ShowUI(BOOL fShow);
    STDMETHODIMP UpdateBalloon(TfLBBalloonStyle style,
                               const WCHAR *pch,
                               ULONG cch);

    //
    // internal API
    //
    void _EnsureSpeechProfile();

    HRESULT UpdateBalloonAndTooltip
    (
        TfLBBalloonStyle style, 
        const WCHAR *pch, 
        ULONG cch,
        const WCHAR *pchTooltip,
        ULONG cchTooltip
    );

    static CSpeechUIServer *_GetThis() 
    { 
        SPTIPTHREAD *pstt = GetSPTIPTHREAD();
        if (!pstt)
            return NULL;

        return pstt->psus;
    }

    static BOOL _SetThis(CSpeechUIServer *_this)
    { 
        SPTIPTHREAD *ptt = GetSPTIPTHREAD();
        if (!ptt)
            return FALSE;

        ptt->psus = _this;
        return TRUE;
    }

    BOOL GetOnOff()
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_OPENCLOSE, &dw, TRUE);
        return dw ? TRUE : FALSE;
    }

#ifdef TF_DISABLE_SPEECH
    BOOL GetDisabled()
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_DISABLED, &dw, FALSE);
        return (dw & TF_DISABLE_SPEECH) ? TRUE : FALSE;
    }

    BOOL GetDictationDisabled()
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_DISABLED, &dw, FALSE);
        return (dw & TF_DISABLE_DICTATION) ? TRUE : FALSE;
    }

    BOOL GetCommandingDisabled()
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_DISABLED, &dw, FALSE);
        return (dw & TF_DISABLE_COMMANDING) ? TRUE : FALSE;
    }
#else
    BOOL GetDisabled()
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_DISABLED, &dw, FALSE);
        return dw  ? TRUE : FALSE;
    }
#endif

    DWORD GetUIStatus()
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_UI_STATUS, &dw, TRUE);
        return dw;
        
    }

    DWORD GetDictStatus()
    {
        DWORD dwLocal, dwGlobal;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, &dwLocal, FALSE);
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_GLOBALSTATE, &dwGlobal, TRUE);
		dwLocal = (dwLocal & (TF_DICTATION_ENABLED | TF_COMMANDING_ENABLED)) + 
			 (dwGlobal & (TF_DICTATION_ON | TF_COMMANDING_ON));
        return dwLocal;
       
    }

    void SetDictStatus()
    {
        DWORD  dwGlobal=0;
        DWORD  dwNewState;

        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_GLOBALSTATE, &dwGlobal, TRUE);

        dwNewState = dwGlobal ^ TF_DICTATION_ON;

        if ( dwNewState | TF_DICTATION_ON )
            dwNewState &= ~TF_COMMANDING_ON;  // it is not possible that both Dication On and Command On

        SetCompartmentDWORD(0, 
                            _tim, 
                            GUID_COMPARTMENT_SPEECH_GLOBALSTATE, 
                            dwNewState,
                            TRUE);
    }

    void SetCmdStatus()
    {
        DWORD  dwGlobal=0;
        DWORD  dwNewState;

        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_GLOBALSTATE, &dwGlobal, TRUE);

        dwNewState = dwGlobal ^ TF_COMMANDING_ON;

        if ( dwNewState | TF_COMMANDING_ON )
            dwNewState &= ~TF_DICTATION_ON;

        SetCompartmentDWORD(0, 
                            _tim, 
                            GUID_COMPARTMENT_SPEECH_GLOBALSTATE, 
                            dwNewState,
                            TRUE);
    }

    void SetCfgMenu(BOOL fReady)
    {
        DWORD dw;
        HRESULT hr = GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_CFGMENU, &dw, FALSE);
        if (S_OK == hr)
        {
            BOOL  fReadyNow = (dw > 0);
            if (fReadyNow == fReady)
                return;
        }
        SetCompartmentDWORD(0, _tim, GUID_COMPARTMENT_SPEECH_CFGMENU, fReady, FALSE);
    }

    BOOL GetTtsPlayOnOff(  )
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_TTS_STATUS, &dw, FALSE);
        return (dw & TF_TTS_PLAY_STOP_TOGGLED ? TRUE : FALSE);
    }

    void SetTtsPlayOnOff( BOOL  fOn )
    {
        DWORD    dw;
        HRESULT  hr = S_OK;
        BOOL     fEnabled;

        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_TTS_STATUS, &dw, FALSE);
        fEnabled = ( dw & TF_TTS_BUTTON_ENABLE) ? TRUE : FALSE;
        if ( fEnabled )
        {
            dw = (dw & ~TF_TTS_PLAY_STOP_TOGGLED) | (fOn ? TF_TTS_PLAY_STOP_TOGGLED : 0 );

            hr = SetCompartmentDWORD(0, 
                                    _tim, 
                                    GUID_COMPARTMENT_TTS_STATUS, 
                                    dw,
                                    FALSE);
            if ( hr == S_OK )
            {
                // update the icon, text, tooltip for Play/Stop botton.
                if ( _plbiTtsPlayStop )
                    _plbiTtsPlayStop->UpdateStatus( );
            }
        }
    }

    BOOL GetTtsPauseOnOff(  )
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_TTS_STATUS, &dw, FALSE);
        return (dw & TF_TTS_PAUSE_RESUME_TOGGLED ? TRUE : FALSE);
    }

    void SetTtsPauseOnOff( BOOL  fOn )
    {
        DWORD    dw;
        HRESULT  hr;
        BOOL     fEnabled;

        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_TTS_STATUS, &dw, FALSE);
        fEnabled = ( dw & TF_TTS_BUTTON_ENABLE) ? TRUE : FALSE;
        if ( fEnabled )
        {
            
            dw = (dw & ~TF_TTS_PAUSE_RESUME_TOGGLED) | (fOn ? TF_TTS_PAUSE_RESUME_TOGGLED : 0);

            hr = SetCompartmentDWORD(0, 
                                    _tim, 
                                    GUID_COMPARTMENT_TTS_STATUS, 
                                    dw,
                                    FALSE);
            if ( hr == S_OK )
            {
                // update the icon, text, tooltip for Pause/Resume botton.
                if ( _plbiTtsPauseResume )
                    _plbiTtsPauseResume->UpdateStatus( );
            }
        }
    }

    BOOL GetTtsButtonStatus(  )
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_TTS_STATUS, &dw, FALSE);
        return (dw & TF_TTS_BUTTON_ENABLE ?  TRUE : FALSE );
    }

    void SetTtsButtonStatus( BOOL  fEnable )
    {
        DWORD  dw;

        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_TTS_STATUS, &dw, FALSE);
        dw = (dw & ~TF_TTS_BUTTON_ENABLE) | (fEnable ? TF_TTS_BUTTON_ENABLE : 0);
        SetCompartmentDWORD(0, 
                            _tim, 
                            GUID_COMPARTMENT_TTS_STATUS, 
                            dw,
                            FALSE);
    }

    void SetIMX(CSapiIMX *pimx)
    {
        _pimx = pimx;
    }

    // TABLETPC
    HRESULT IsActiveThread()
    {
        if (m_fStageTip)
        {
            // To avoid a race condition with no immediately available solution, we are now active only when the stage is visible.
            if (m_fStageVisible)
            {
                return S_OK;
            }
            else
            {
                return S_FALSE;
            }
        }
        else if (m_fStageVisible)
        {
            // Stage is visible. We are always inactive since we are not the stage.
            return S_FALSE;
        }
        else
        {
            // Stage is not visible. We're active if we have focus as normal Cicero.
            BOOL fThreadFocus = FALSE;
            HRESULT hr = S_OK;
            hr = _tim->IsThreadFocus(&fThreadFocus);
            hr = (S_OK == hr) ? ( (fThreadFocus) ? S_OK : S_FALSE ) : hr;
            return hr;
        }
    }

    ITfThreadMgr *GetTIM() {return _tim;}
    CSapiIMX *GetIMX() {return _pimx;}

    HRESULT SetBalloonSAPIInitFlag(BOOL fSet);
   
private:
    ADDREMOVEITEMFUNCDEF(Microphone)
    ADDREMOVEITEMFUNCDEF(CfgMenuButton)
    ADDREMOVEITEMFUNCDEF(Balloon)
    ADDREMOVEITEMFUNCDEF(Commanding)
    ADDREMOVEITEMFUNCDEF(Dictation)
    ADDREMOVEITEMFUNCDEF(TtsPlayStop)
    ADDREMOVEITEMFUNCDEF(TtsPauseResume)
#ifdef CHANGE_MIC_TOOLTIP_ONTHEFLY
    HRESULT  _ToggleMicrophone(BOOL fOn);
#else
        TOGGLEITEMFUNCDEF(Microphone);
#endif
    TOGGLEITEMFUNCDEF(Commanding);
    TOGGLEITEMFUNCDEF(Dictation);
    TOGGLEITEMFUNCDEF(TtsPlayStop);
    TOGGLEITEMFUNCDEF(TtsPauseResume);

    static HRESULT _CompEventSinkCallback(void *pv, REFGUID rguid);

    ITfThreadMgr *_tim;
    ITfLangBarItemMgr *_lbim;
    CSapiIMX *_pimx;
    BOOL _fShown;
    BOOL m_fCommandingReady;
    // TABLET
    BOOL m_fStageTip;
    BOOL m_fStageVisible;
    DWORD  m_cRef;

    CLBarItemMicrophone    *_plbiMicrophone;
    CLBarItemCfgMenuButton *_plbiCfgMenuButton;
    CLBarItemBalloon       *_plbiBalloon;
    CLBarItemCommanding    *_plbiCommanding;
    CLBarItemDictation     *_plbiDictation;
    CLBarItemTtsPlayStop     *_plbiTtsPlayStop;
    CLBarItemTtsPauseResume  *_plbiTtsPauseResume;

    ATOM                   m_hAtom;

    CCompartmentEventSink *_pCes;
};

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemMicrophone
//
//////////////////////////////////////////////////////////////////////////////

class CLBarItemMicrophone : public CLBarItemButtonBase
{
public:
    CLBarItemMicrophone(CSpeechUIServer *psus);
    ~CLBarItemMicrophone();

    STDMETHODIMP GetIcon(HICON *phIcon);

private:
    HRESULT OnLButtonUp(const POINT pt, const RECT *prcArea);
    CSpeechUIServer *_psus;
};

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemCfgMenuButton
//
//////////////////////////////////////////////////////////////////////////////

class CLBarItemCfgMenuButton : public CLBarItemSystemButtonBase
{
public:
    CLBarItemCfgMenuButton(CSpeechUIServer *psus);
    ~CLBarItemCfgMenuButton();

    //
    // ITfNotifyUI
    //
    STDMETHODIMP GetIcon(HICON *phIcon);

    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT uID);

private:
    CSpeechUIServer *_psus;
};

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemBalloon
//
//////////////////////////////////////////////////////////////////////////////

class CLBarItemBalloon : public CLBarItemBalloonBase
{
public:
    CLBarItemBalloon(CSpeechUIServer *psus);
    ~CLBarItemBalloon();

    STDMETHODIMP GetBalloonInfo(TF_LBBALLOONINFO *pInfo);
    void Set(TfLBBalloonStyle style, const WCHAR *psz);

    BOOL NeedUpdate(TfLBBalloonStyle style, const WCHAR *psz)
    {
        return  (!_bstrText || _style != style || wcscmp(_bstrText, psz) != 0);
    }
    void SetToFireInitializeSAPI(BOOL fSet)
    {
        m_fFireInitializeSapi = fSet;
    }

    TfLBBalloonStyle GetStyle(void)
    {
        return _style;
    }
    void SetStyle(TfLBBalloonStyle style)
    {
        _style = style;
    }

private:
    BSTR _bstrText;
    TfLBBalloonStyle _style;

    CSpeechUIServer *_psus;
    BOOL    m_fFireInitializeSapi;
};

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemDictation
//
//////////////////////////////////////////////////////////////////////////////

class CLBarItemDictation : public CLBarItemButtonBase
{
public:
    CLBarItemDictation(CSpeechUIServer *psus);
    ~CLBarItemDictation();

    STDMETHODIMP GetIcon(HICON *phIcon);

private:
    HRESULT OnLButtonUp(const POINT pt, const RECT *prcArea);
    CSpeechUIServer *_psus;
};

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemCommanding
//
//////////////////////////////////////////////////////////////////////////////

class CLBarItemCommanding : public CLBarItemButtonBase
{
public:
    CLBarItemCommanding(CSpeechUIServer *psus);
    ~CLBarItemCommanding();

    STDMETHODIMP GetIcon(HICON *phIcon);

private:
    HRESULT OnLButtonUp(const POINT pt, const RECT *prcArea);
    CSpeechUIServer *_psus;
};

ADDREMOVEITEMFUNC(Microphone)
ADDREMOVEITEMFUNC(CfgMenuButton)
ADDREMOVEITEMFUNC(Balloon)
ADDREMOVEITEMFUNC(Commanding)
ADDREMOVEITEMFUNC(Dictation)
ADDREMOVEITEMFUNC(TtsPlayStop)
ADDREMOVEITEMFUNC(TtsPauseResume)

#ifndef CHANGE_MIC_TOOLTIP_ONTHEFLY
TOGGLEITEMFUNC(Microphone);
#endif
TOGGLEITEMFUNC(Commanding);
TOGGLEITEMFUNC(Dictation);
TOGGLEITEMFUNC(TtsPlayStop);
TOGGLEITEMFUNC(TtsPauseResume);


#endif // NUI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\playback.h ===
//
// Audio playback function obj class definition
//
//

#ifndef _PLAYBACK_H
#define _PLAYBACK_H 

#include "fnrecon.h"

class CSapiIMX;
class CBestPropRange;

class CDictRange : public CBestPropRange
{
public:
    CDictRange( );
    ~CDictRange( );

    HRESULT Initialize(TfEditCookie ec, ITfContext *pic, ITfRange *pRange);

    BOOL    IsDictRangeFound( )  { return m_fFoundDictRange; }
    BOOL    GetStartElem( )      { return m_ulStart; }
    BOOL    GetNumElem( )        { return m_ulcElem; }

    ITfProperty *GetProp( );      
    ITfRange    *GetDictRange( ); 
    
private:

    HRESULT  _GetOverlapRange(TfEditCookie ec, ITfRange *pRange1, ITfRange *pRange2, ITfRange **ppOverlapRange);

    BOOL                  m_fFoundDictRange;
    ITfProperty          *m_pProp;
    ITfRange             *m_pDictatRange;
    ULONG                 m_ulStart;
    ULONG                 m_ulcElem;
};

class CSapiPlayBack : public ITfFnPlayBack
{
public:
    CSapiPlayBack(CSapiIMX *psi);
    ~CSapiPlayBack();
    
    // iunknown
    //
    STDMETHODIMP QueryInterface(REFGUID riid, LPVOID *ppobj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ITfFunction
    //
    STDMETHODIMP GetDisplayName(BSTR *pbstrCand);
    STDMETHODIMP IsEnabled(BOOL *pfEnable);

    // ITfFnPlayBack
    //
    
    STDMETHODIMP QueryRange(ITfRange *pRange, ITfRange **ppNewRange, BOOL *pfPlayable);
    STDMETHODIMP Play(ITfRange *pRange);

    HRESULT _PlaySound(TfEditCookie ec, ITfRange *pRange);
    HRESULT _PlaySoundSelection(TfEditCookie ec, ITfContext *pic);
    
private:
    HRESULT EnsureIXMLDoc(void);
    HRESULT GetDataID(BSTR bstrCAndXml, int nId, GUID *pguidData);
    HRESULT FindSoundRange(TfEditCookie ec, ITfRange *pRange, ITfProperty **ppProp, ITfRange **ppPropRange, ITfRange **ppSndRange);

    HRESULT PlayTextData(TfEditCookie ec, ITfRange *pRangeText);
    HRESULT PlayAudioData(TfEditCookie ec, ITfRange *pRangeAudio, ITfProperty *pProp, ULONG ulStart, ULONG ulcElem);
    HRESULT GetInkObjectText(TfEditCookie ec, ITfRange *pRange, BSTR *pbstrWord,UINT *pcchWord);

    IXMLDOMDocument *m_pIXMLDoc;
    CSapiIMX    *m_psi;
    ITfContext *m_pIC;
    LONG       m_cRef;
};

#endif // ndef _PLAYBACK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\playback.cpp ===
//
// Audio playback function impl.
//
//
#include "private.h"
#include "sapilayr.h"
#include "playback.h"
#include "immxutil.h"
#include "propstor.h"
#include "hwxink.h"

//
// ctor/dtor
//

CSapiPlayBack::CSapiPlayBack(CSapiIMX *psi)
{
    m_psi = psi;
    m_pIC = NULL;
    m_cRef = 1;
}

CSapiPlayBack::~CSapiPlayBack()
{
    SafeRelease(m_pIC);
}

//
// IUnknown
//

STDMETHODIMP CSapiPlayBack::QueryInterface(REFGUID riid, LPVOID *ppvObj)
{
    Assert(ppvObj);
    *ppvObj = NULL;
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfFnPlayBack))
    {
        *ppvObj = SAFECAST(this, CSapiPlayBack *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSapiPlayBack::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CSapiPlayBack::Release(void)
{
    long cr;

    cr = InterlockedDecrement(&m_cRef);
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//
// ITfFunction
//

STDMETHODIMP CSapiPlayBack::GetDisplayName(BSTR *pbstrName)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrName)
    {
        *pbstrName = SysAllocString(L"PlayBack Voice");
        if (!*pbstrName)
            hr = E_OUTOFMEMORY;
        else
            hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CSapiPlayBack::IsEnabled(BOOL *pfEnable)
{
    *pfEnable = TRUE;
    return S_OK;
}
//
// CSapiPlayBack::FindSoundRange
//
// synopsis - finds matching range with sound data for the given 
//            text range
//            callar is responsible for releasing the returned range object
//
HRESULT 
CSapiPlayBack::FindSoundRange(TfEditCookie ec, ITfRange *pRange, ITfProperty **ppProp, ITfRange **ppPropRange, ITfRange **ppSndRange)
{
    
    ITfProperty *pProp = NULL;
    ITfRange *pPropRange = NULL;

    Assert(pRange);
    *ppProp = NULL;

    HRESULT hr = m_pIC->GetProperty(GUID_PROP_SAPIRESULTOBJECT, &pProp);
    
    if (SUCCEEDED(hr) && pProp)
    {
        ITfRange *pRangeSize0;

        pRange->Clone(&pRangeSize0);
        pRangeSize0->Collapse(ec, TF_ANCHOR_START); // findrange would fail if this failed
        hr = pProp->FindRange(ec, pRangeSize0, &pPropRange, TF_ANCHOR_START);

        pRangeSize0->Release();
        *ppProp = pProp;
        pProp->AddRef();
    }
    
    if (SUCCEEDED(hr) && pPropRange)
    {
        ITfRange *pRangeForSound;
        hr = pPropRange->Clone(&pRangeForSound);
        if (ppSndRange && SUCCEEDED(hr))
        {
            hr = pRangeForSound->Clone(ppSndRange);
            pRangeForSound->Release();
        }
        if (ppPropRange && pPropRange && SUCCEEDED(hr))
        {
            hr = pPropRange->Clone(ppPropRange);
        }

        SafeRelease(pPropRange);
    }
    else
    {
        if (ppPropRange)
            *ppPropRange = NULL;
            
        if (ppSndRange)
            *ppSndRange = NULL;
    }

    SafeRelease(pProp);
    
    return hr;
}

// ITfFnPlayBack
//
//
STDAPI CSapiPlayBack::QueryRange(ITfRange *pRange, ITfRange **ppNewRange, BOOL *pfPlayable)
{
    //
    // always ok because of TTS.
    //
    if (ppNewRange)
    {
         pRange->Clone(ppNewRange);
    }
    *pfPlayable = TRUE;
    return S_OK;
}

// ITfFnPlayBack
//
// play the audio stream attached to the range 
// TODO: use TTS if:
//       1) the given range has less text
//       then the stream prop
//       2) the audio property is not found
//
STDAPI CSapiPlayBack::Play(ITfRange *pRange)
{
    HRESULT hr = E_OUTOFMEMORY;

    if ( !m_psi ) 
        return E_FAIL;

    SafeRelease(m_pIC);
    m_psi->GetFocusIC(&m_pIC);

    if (m_pIC)
    {
        CPlayBackEditSession  *pes;

        if (pes = new CPlayBackEditSession(this, m_pIC))
        {
            pes->_SetEditSessionData(ESCB_PLAYBK_PLAYSND, NULL, 0);
            pes->_SetRange(pRange);

            m_pIC->RequestEditSession(m_psi->_GetId(), pes, TF_ES_READ /*| TF_ES_SYNC */, &hr);
            pes->Release();
        }
    }

    return hr;
}

HRESULT CSapiPlayBack::_PlaySound(TfEditCookie ec, ITfRange *pRange)
{
    HRESULT     hr = S_OK; 
    LONG        l;
    ITfRange    *pRangeForSound = NULL;
    ITfRange    *pRangeCurrent = NULL;
    BOOL        fEmpty;
    ULONG       ulStart, ulcElem;
    
    // playback one phrase for no selection
    pRange->IsEmpty(ec, &fEmpty);
    if (fEmpty)
    {
        ITfProperty *pProp = NULL;
        hr = FindSoundRange(ec, pRange, &pProp, NULL, &pRangeForSound);
        if (SUCCEEDED(hr) && pRangeForSound)
        {
            pRange->ShiftStartToRange(ec, pRangeForSound, TF_ANCHOR_START);
            pRange->ShiftEndToRange(ec, pRangeForSound, TF_ANCHOR_END);
            pRangeForSound->Release();
        }
        SafeReleaseClear(pProp);
    }
    // setting up a range object on our own
    
    hr = pRange->Clone(&pRangeCurrent);

    while(SUCCEEDED(hr) && pRangeCurrent->IsEmpty(ec, &fEmpty) == S_OK && !fEmpty)
    {
        ITfProperty *pProp = NULL;
        // get the first dictated range

        CDictRange   *pDictRange = new CDictRange( );

        if ( pDictRange )
        {
            hr = pDictRange->Initialize(ec, m_pIC, pRangeCurrent);

            if ( SUCCEEDED(hr) && pDictRange->IsDictRangeFound( ))
            {
                // Found a dictated range.
                pRangeForSound = pDictRange->GetDictRange( );
                ulStart = pDictRange->GetStartElem( );
                ulcElem = pDictRange->GetNumElem( );
                pProp = pDictRange->GetProp( );

                // if start anchor of pRangeForSound is larger than start anchor of pRangeCurrent,
                // we need to send the text between these two anchors to spVoice first.

                hr = pRangeCurrent->CompareStart(ec, pRangeForSound, TF_ANCHOR_START, &l);

                if ( SUCCEEDED(hr) && l < 0 )
                {
                    CComPtr<ITfRange>  cpRangeText;
                
                    hr = pRangeCurrent->Clone(&cpRangeText);

                    if ( SUCCEEDED(hr) )
                    {
                        hr = cpRangeText->ShiftEndToRange(ec, pRangeForSound, TF_ANCHOR_START);
                    }

                    if ( SUCCEEDED(hr) )
                        hr = PlayTextData(ec, cpRangeText);
                }

                // Then play the audio data.

                if (SUCCEEDED(hr) )
                {
                    hr = PlayAudioData(ec, pRangeForSound, pProp, ulStart, ulcElem);
                }

            }
            else
            {
                // There is no dictated phrase in this range.
                // just speak all the rest text at once.
                SafeRelease(pRangeForSound);
                hr = pRangeCurrent->Clone(&pRangeForSound);

                if ( SUCCEEDED(hr) )
                    hr = PlayTextData(ec, pRangeCurrent);
            }

            SafeReleaseClear(pProp);

            // next range
            pRangeCurrent->ShiftStartToRange(ec, pRangeForSound, TF_ANCHOR_END);
            pRangeForSound->Release();

            delete  pDictRange;
        }
        else
            hr = E_OUTOFMEMORY;

    }  // end of while

    SafeRelease(pRangeCurrent);

    return hr;
}

//
//  CSapiPlayBack::PlayTextData
//
//  Playing the text by default voice
//
//  This is for Non-Dictated text.  pRangeText contains all the Non-Dictated text

const GUID GUID_TS_SERVICE_DATAOBJECT={0x6086fbb5, 0xe225, 0x46ce, {0xa7, 0x70, 0xc1, 0xbb, 0xd3, 0xe0, 0x5d, 0x7b}};
const IID IID_ILineInfo = {0x9C1C5AD5,0xF22F,0x4DE4,{0xB4,0x53,0xA2,0xCC,0x48,0x2E,0x7C,0x33}};

HRESULT CSapiPlayBack::GetInkObjectText(TfEditCookie ec, ITfRange *pRange, BSTR *pbstrWord,UINT *pcchWord)
{
    HRESULT               hr = S_OK;
    CComPtr<IDataObject>  cpDataObject;
    CComPtr<ILineInfo>    cpLineInfo;

    if ( !pRange || !pbstrWord || !pcchWord )
        return E_FAIL;

    *pbstrWord = NULL;
    *pcchWord = 0;

    hr = pRange->GetEmbedded(ec, 
                             GUID_TS_SERVICE_DATAOBJECT, 
                             IID_IDataObject,
                             (IUnknown **)&cpDataObject);
    if ( hr == S_OK )
    {
        hr = cpDataObject->QueryInterface(IID_ILineInfo, (void **)&cpLineInfo);
    }

    if ( hr == S_OK  && cpLineInfo)
    {
        hr = cpLineInfo->TopCandidates(0, pbstrWord, pcchWord, 0, 0);
    }
    else
    {
        // it doesn't support ILineInfoi or IDataObject. 
        // But it is not an error, the code should not terminate here.
        hr = S_OK;
    }


    return hr;
}


HRESULT CSapiPlayBack::PlayTextData(TfEditCookie ec, ITfRange *pRangeText)
{
    HRESULT           hr = S_OK;
    CComPtr<ITfRange> cpRangeCloned;
    BOOL              fEmpty = TRUE;
    CSpDynamicString  dstrText;
    CSpTask          *psp;
    WCHAR             sz[128];
    ULONG             iIndex = 0;
    ULONG             ucch;

    if ( m_psi == NULL ) return E_FAIL;

    if ( !pRangeText ) return E_INVALIDARG;

    hr = pRangeText->Clone(&cpRangeCloned);

    // Get the text from the pRangeCloned
    while(S_OK == hr && (S_OK == cpRangeCloned->IsEmpty(ec, &fEmpty)) && !fEmpty)
    {
        WCHAR                 szEach[2];
        BOOL                  fHitInkObject = FALSE;
        BSTR                  bstr = NULL;

        fHitInkObject = FALSE;
        hr = cpRangeCloned->GetText(ec, TF_TF_MOVESTART, szEach, ARRAYSIZE(szEach)-1, &ucch);
        if (S_OK == hr && ucch > 0)
        {
            szEach[ucch] = L'\0';
            if ( szEach[0] == TF_CHAR_EMBEDDED )
            {
                // This is an embedded object.
                // Check to see if it is Ink Object. currently we support only Inkobject TTSed
                CComPtr<ITfRange>     cpRangeTmp;

                // Shift the start anchor back by 1 char.
                hr = cpRangeCloned->Clone(&cpRangeTmp);

                if ( hr == S_OK )
                {
                    LONG   cch;
                    hr = cpRangeTmp->ShiftStart(ec, -1, &cch, 0 );
                }

                if ( hr == S_OK )
                    hr = GetInkObjectText(ec, cpRangeTmp, &bstr,(UINT *)&ucch);

                if ( hr == S_OK  && ucch > 0  && bstr)
                    fHitInkObject = TRUE;
            }

            if ( fHitInkObject)
            {
                // Fill the previous text to dstrText.
                if ( iIndex > 0 )
                {
                    sz[iIndex] = L'\0';
                    dstrText.Append(sz);
                    iIndex = 0;
                }

                // Fill this Ink Object text
                dstrText.Append(bstr);
                SysFreeString(bstr);
            }
            else
            {
                if ( iIndex >= ARRAYSIZE(sz)-1 )
                {
                    sz[ARRAYSIZE(sz)-1] = L'\0';
                    dstrText.Append(sz);
                    iIndex=0;
                }

                sz[iIndex] = szEach[0];
                iIndex ++;
            }
        }
        else
        {
            // hr is not S_OK or ucch is zero.
            // we just want to exit here.
            TraceMsg(TF_GENERAL, "PlayTextData: ucch=%d", ucch);

            break;
        }
    }

    // Fill the last run of text.
    if ( iIndex > 0 )
    {
        sz[iIndex] = L'\0';
        dstrText.Append(sz);
        iIndex = 0;
    }

    // Play the text through TTS service.
    if ((hr == S_OK) && dstrText)
    {
        hr = m_psi->GetSpeechTask(&psp);
        if (hr == S_OK)
        {
            hr = psp->_SpeakText((WCHAR *)dstrText);
            psp->Release();
        }
    }

    return hr;
}

//
//  CSapiPlayBack::PlayAudioData
// 
//  Playing the sound by Aduio Data
// 
//  This is for Dictated text.  pRangeAudio keeps the dictated text range.

HRESULT CSapiPlayBack::PlayAudioData(TfEditCookie ec, ITfRange *pRangeAudio, ITfProperty *pProp, ULONG ulStart, ULONG ulcElem )
{
    HRESULT           hr = S_OK;
    CSpTask          *psp;
    VARIANT           var;

    if ( m_psi == NULL )  return E_FAIL;

    if ( !pRangeAudio  || !pProp ) return E_INVALIDARG;

    hr = pProp->GetValue(ec, pRangeAudio, &var);
            
    if (S_OK == hr)
    {
        Assert(var.vt == VT_UNKNOWN);
        IUnknown *punk = var.punkVal;
        if (punk)
        {
            // get the wrapper object
            CRecoResultWrap *pWrap;
                    
            hr = punk->QueryInterface(IID_PRIV_RESULTWRAP, (void **)&pWrap);
            if (S_OK == hr)
            {
               // hr = pWrap->_SpeakAudio(0,0); // better calculate the length accurately
                CComPtr<ISpRecoResult> cpResult;

                hr = pWrap->GetResult(&cpResult);

                if (S_OK == hr)
                {
                    CComPtr<ISpStreamFormat> cpStream;

                    if ((ulStart == 0) && (ulcElem == 0))
                    {
                        // We don't set the start element and number of elems.
                        // it must be for the whole recoWrap.
                        ulStart = pWrap->GetStart();
                        ulcElem = pWrap->GetNumElements();
                    }

                    hr = cpResult->GetAudio(ulStart, ulcElem, &cpStream);

                    if ( S_OK == hr )
                    {
                        hr = m_psi->GetSpeechTask(&psp);
                        if (SUCCEEDED(hr))
                        {
                            hr = psp->_SpeakAudio(cpStream);
                            psp->Release();
                        }
                    }
                }

                pWrap->Release();
            }
            punk->Release();
        }
    }

    return hr;
}

//
// CSapiPlayBack::GetDataID
//
// This method is incomplete for now, until we figure out
// the usage of dataid
//
HRESULT CSapiPlayBack::GetDataID(BSTR bstrCandXml, int nId, GUID *pguidData)
{
    // 1) parse the list and find RANGEDATA
    IXMLDOMNodeList *pNList   = NULL;
    IXMLDOMElement  *pElm = NULL;
    IXMLDOMNode *pNode;
    VARIANT_BOOL bSuccessful;

    HRESULT hr = EnsureIXMLDoc();

    if (SUCCEEDED(hr))
    {
        hr = m_pIXMLDoc->loadXML(bstrCandXml, &bSuccessful);
    }   
    
    // get <RANGEDATA> element
    if (SUCCEEDED(hr) && bSuccessful)
    {
        BSTR bstrRange    = SysAllocString(L"RANGEDATA");
        if (bstrRange)
        {
            hr = m_pIXMLDoc->getElementsByTagName(bstrRange, &pNList);
            SysFreeString(bstrRange);
        }
        else
            hr = E_OUTOFMEMORY;
    }
    
    if (SUCCEEDED(hr) && pNList)
    {
        if (pNList->nextNode(&pNode) == S_OK)
            hr = pNode->QueryInterface(IID_IXMLDOMElement,(void **)&pElm);
            
        pNList->Release();
    }
    // then <MICROSOFTSPEECH> ...
    if (SUCCEEDED(hr) && pElm)
    {
        BSTR bstrSpchPriv = SysAllocString(L"MICROSOFTSPEECH");
        if (bstrSpchPriv)
        {
            hr = pElm->getElementsByTagName(bstrSpchPriv, &pNList);
            SysFreeString(bstrSpchPriv);
        }
        else
            hr = E_OUTOFMEMORY;
            
        pElm->Release();
    }
    
    if (SUCCEEDED(hr) && pNList)
    {
        if (pNList->nextNode(&pNode) == S_OK)
            hr = pNode->QueryInterface(IID_IXMLDOMElement,(void **)&pElm);
        
        pNList->Release();
    }
    
    // <DATAID>
    // right now assuming the speech element
    // is put at the level of <rangedata>
    // ignoring nId here
    if (SUCCEEDED(hr) && pElm)
    {
        BSTR bstrDataId = SysAllocString(L"DATAID");
        if (bstrDataId)
        {
            hr = pElm->getElementsByTagName(bstrDataId, &pNList);
            SysFreeString(bstrDataId);
        }
        else
            hr = E_OUTOFMEMORY;
            
        pElm->Release();
    }
    // impl later...
    // so, here we'll get the real dataid and be done
    
    if (SUCCEEDED(hr) && pNList)
    {
        pNList->Release();
    }
    
    return hr;
}

HRESULT CSapiPlayBack::_PlaySoundSelection(TfEditCookie ec, ITfContext *pic)
{
    ITfRange *pSelection;
    HRESULT hr = E_FAIL;

    if (GetSelectionSimple(ec, pic, &pSelection) == S_OK)
    {
        hr = _PlaySound(ec, pSelection);
        pSelection->Release();
    }
    return hr;

}

HRESULT CSapiPlayBack::EnsureIXMLDoc(void)
{
    HRESULT hr = S_OK;
    IXMLDOMDocument *pIXMLDocument;
    if (!m_pIXMLDoc)
    {
        if (SUCCEEDED(hr = CoCreateInstance(CLSID_DOMDocument,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           IID_IXMLDOMDocument,
                           (void **) &pIXMLDocument)))
        {
            m_pIXMLDoc = pIXMLDocument;
        }
    }

    return hr;    
}

//
// Implementation for Class CDictRange
//
//

//
// ctor/dtor
//
CDictRange::CDictRange( )  : CBestPropRange( )
{
    m_fFoundDictRange = FALSE;
    m_pProp = NULL;
    m_pDictatRange = NULL;
    m_ulStart = 0;
    m_ulcElem = 0;
}


CDictRange::~CDictRange( )
{
    SafeRelease(m_pProp);
    SafeRelease(m_pDictatRange);
}


ITfProperty *CDictRange::GetProp( )      
{
    if ( m_pProp )
        m_pProp->AddRef( );

    return m_pProp; 
}

ITfRange  *CDictRange::GetDictRange( ) 
{ 
    if ( m_pDictatRange )
        m_pDictatRange->AddRef( );

    return m_pDictatRange; 
}
 

HRESULT  CDictRange::_GetOverlapRange(TfEditCookie ec, ITfRange *pRange1, ITfRange *pRange2, ITfRange **ppOverlapRange)
{
    HRESULT  hr = E_FAIL;
    LONG     l1=0;    
    LONG     l2=0;

    CComPtr<ITfRange>   cpRangeOverlap;

    if ( !pRange1 || !pRange2 || !ppOverlapRange  )
        return E_INVALIDARG;

    *ppOverlapRange = NULL;

    // Get the overlapping part of pRange and cpPropRange, and then calculate the 
    // best matched propRange.

    hr = pRange1->Clone( &cpRangeOverlap );
                
    if ( SUCCEEDED(hr) )
        hr = pRange1->CompareStart(ec, pRange2, TF_ANCHOR_START, &l1);

    if ( SUCCEEDED(hr) && l1 < 0 )
    {
        // Start anchor of pRange1 is before the start anchor of the
        // pRange2.
        hr = cpRangeOverlap->ShiftStartToRange(ec, pRange2, TF_ANCHOR_START);
    }

    if ( SUCCEEDED(hr) )
        hr = cpRangeOverlap->CompareEnd(ec, pRange2, TF_ANCHOR_END, &l2);

    if ( SUCCEEDED(hr) && l2 > 0)
    {
        // End anchor of cpRangeOverlap is after the end anchor of the pRange2.
        hr = cpRangeOverlap->ShiftEndToRange(ec, pRange2, TF_ANCHOR_END);
    }

    if ( SUCCEEDED(hr) )
        hr = cpRangeOverlap->Clone(ppOverlapRange);

    return hr;
}

//
// CDictRange::Initialize
//
// synopsis - Get the necessary input parameters, (ec, pic, and pRange), 
//            and then search the first dictated range inside the given range. 
//            if it finds the first dictated range, update the related 
//            data memebers.
//  
//            if it doesn't find any dictated range, mark as not found.
//
HRESULT CDictRange::Initialize(TfEditCookie ec, ITfContext *pic, ITfRange *pRange)
{
    CComPtr<ITfRange>    cpPropRange = NULL;
    HRESULT              hr;

    m_fFoundDictRange = FALSE;
    m_pProp = NULL;
    m_pDictatRange = NULL;
    m_ulStart = 0;
    m_ulcElem = 0;

    if ( !pic || !pRange )  return E_INVALIDARG;

    hr = pic->GetProperty(GUID_PROP_SAPIRESULTOBJECT, &m_pProp);
    
    if ( SUCCEEDED(hr) && m_pProp)
    {
        CComPtr<ITfRange> cpRangeCurrent;
        LONG    cch;
        
        hr = pRange->Clone(&cpRangeCurrent);
        
        if ( SUCCEEDED(hr) )
        {
            hr = cpRangeCurrent->Collapse(ec, TF_ANCHOR_START); 
        }

        while ( SUCCEEDED(hr) && !m_fFoundDictRange )
        {
            cpPropRange.Release( );
            hr = m_pProp->FindRange(ec, cpRangeCurrent, &cpPropRange, TF_ANCHOR_START);

            if ( SUCCEEDED(hr) && cpPropRange )
            {
                // Found the first Dictated phrase.
                CComPtr<ITfRange>   cpRangeOverlap;

                // Get the overlapping part of pRange and cpPropRange, and then calculate the 
                // best matched propRange.

                hr = _GetOverlapRange(ec, pRange, cpPropRange, &cpRangeOverlap);

                if ( SUCCEEDED(hr) )
                {
                    // Calculate the best matched propRange and ulStart, ulcElem.
                    cpPropRange.Release( );
                    hr = _ComputeBestFitPropRange(ec, m_pProp, cpRangeOverlap, &cpPropRange, &m_ulStart, &m_ulcElem);
                }

                if (SUCCEEDED(hr) && (m_ulcElem > 0))
                {
                    m_fFoundDictRange = TRUE;
                }
            }

            if ( SUCCEEDED(hr) && !m_fFoundDictRange)
            {
                // cpRangeCurrent shift forward one character. and try again.

                hr = cpRangeCurrent->ShiftStart(ec, 1, &cch, NULL);

                if ( SUCCEEDED(hr) && (cch==0))
                {
                    // Hit a region or the end of doc.
                    // check to see if there is more region.
                    BOOL    fNoRegion = TRUE;
                    
                    hr = cpRangeCurrent->ShiftStartRegion(ec, TF_SD_FORWARD, &fNoRegion);

                    if ( fNoRegion )
                    {
                        TraceMsg(TF_GENERAL, "Reach to end of doc");
                        break;
                    }
                    else
                        TraceMsg(TF_GENERAL, "Shift over to another region!");
                }
                
                if ( SUCCEEDED(hr) )
                {
                    // check to see if cpRangeCurrent is beyond of the pRange.
                    hr = pRange->CompareEnd(ec, cpRangeCurrent, TF_ANCHOR_END, &cch);

                    if ( SUCCEEDED(hr) && cch <= 0 )
                    {
                        // cpRangeCurrent Now is beyond of specified range, exit while statement.
                        TraceMsg(TF_GENERAL, "reach to the end of original range");

                        break;
                    }
                }
            }
        }
    }

    if (SUCCEEDED(hr) && cpPropRange && m_fFoundDictRange)
    {
        hr = cpPropRange->Clone(&m_pDictatRange);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\nui.cpp ===
//
// nui.cpp
//

#include "private.h"
#include "immxutil.h"
#include "sapilayr.h"
#include "xstring.h"
#include "nui.h"
#include "ids.h"
#include "cicspres.h"
#include "cresstr.h"
#include "slbarid.h"
#include "ptrary.h"
#include "ctffunc.h"


/* ad8d338b-fb07-4e06-8d5b-911baad9eeb3 */
const IID IID_PRIV_CSPEECHUISERVER = { 
    0xad8d338b,
    0xfb07,
    0x4e06,
    {0x8d, 0x5b, 0x91, 0x1b, 0xaa, 0xd9, 0xee, 0xb3}
  };

/* e49d6ff3-1fff-43ba-b835-3a122e98a1c9 */
const GUID GUID_LBI_SAPILAYR_MICROPHONE = { 
    0xe49d6ff3,
    0x1fff,
    0x43ba,
    {0xb8, 0x35, 0x3a, 0x12, 0x2e, 0x98, 0xa1, 0xc9}
  };

/* 3f9ea2e3-75d6-4879-86c2-2bcc2b6fa46e */
const GUID GUID_LBI_SAPILAYR_BALLOON = { 
    0x3f9ea2e3,
    0x75d6,
    0x4879,
    {0x86, 0xc2, 0x2b, 0xcc, 0x2b, 0x6f, 0xa4, 0x6e}
  };

/* 17f9fa7f-a9ed-47b5-8bcd-eebb94b2e6ca */
const GUID GUID_LBI_SAPILAYR_COMMANDING = { 
    0x17f9fa7f,
    0xa9ed,
    0x47b5,
    {0x8b, 0xcd, 0xee, 0xbb, 0x94, 0xb2, 0xe6, 0xca}
  };

/* 49261a4a-87df-47fc-8a68-6ea07ba82a87 */
const GUID GUID_LBI_SAPILAYR_DICTATION = { 
    0x49261a4a,
    0x87df,
    0x47fc,
    {0x8a, 0x68, 0x6e, 0xa0, 0x7b, 0xa8, 0x2a, 0x87}
  };

/* 791b4403-0cda-4fe1-b748-517d049fde08 */
const GUID GUID_LBI_SAPILAYR_TTS_PLAY_STOP = {
    0x791b4403,
    0x0cda,
    0x4fe1,
    {0xb7, 0x48, 0x51, 0x7d, 0x04, 0x9f, 0xde, 0x08}
  };

/* e6fbfc9d-a2e0-4203-a27b-af2353e6a44e */
const GUID GUID_LBI_SAPILAYR_TTS_PAUSE_RESUME = {
    0xe6fbfc9d,
    0xa2e0,
    0x4203,
    {0xa2, 0x7b, 0xaf, 0x23, 0x53, 0xe6, 0xa4, 0x4e}
  };

CPtrArray<SPTIPTHREAD> *g_rgstt = NULL;



//+---------------------------------------------------------------------------
//
// GetSPTIPTHREAD
//
//----------------------------------------------------------------------------

SPTIPTHREAD *GetSPTIPTHREAD()
{
    SPTIPTHREAD *pstt;

    if (g_dwTlsIndex == (DWORD)-1)
        return NULL;

    pstt = (SPTIPTHREAD *)TlsGetValue(g_dwTlsIndex);
    if (!pstt)
    {
        pstt = (SPTIPTHREAD *)cicMemAllocClear(sizeof(SPTIPTHREAD));
        if (!TlsSetValue(g_dwTlsIndex, pstt))
        {
            cicMemFree(pstt);
            pstt = NULL;
        }

        EnterCriticalSection(g_cs);

        if (!g_rgstt)
            g_rgstt = new CPtrArray<SPTIPTHREAD>;
        
        if (g_rgstt)
        {
            if (g_rgstt->Insert(0, 1))
            {
                g_rgstt->Set(0, pstt);
            }
            else
            {
                TlsSetValue(g_dwTlsIndex, NULL);
                cicMemFree(pstt);
                pstt = NULL;
            }
        }

        LeaveCriticalSection(g_cs);
    }

    return pstt;
}

//+---------------------------------------------------------------------------
//
// FreeSPTIPTHREAD
//
//----------------------------------------------------------------------------

void FreeSPTIPTHREAD()
{
    SPTIPTHREAD *pstt;

    if (g_dwTlsIndex == (DWORD)-1)
        return;

    pstt = (SPTIPTHREAD *)TlsGetValue(g_dwTlsIndex);
    if (pstt)
    {
        EnterCriticalSection(g_cs);

        if (g_rgstt)
        {
            int nCnt = g_rgstt->Count();
            while (nCnt)
            {
                nCnt--;
                if (g_rgstt->Get(nCnt) == pstt)
                {
                    g_rgstt->Remove(nCnt, 1);
                    break;
                }
            }
        }

        LeaveCriticalSection(g_cs);

        cicMemFree(pstt);
        TlsSetValue(g_dwTlsIndex, NULL);
    }

    return;
}

//+---------------------------------------------------------------------------
//
// UninitProcess()
//
//+---------------------------------------------------------------------------

void UninitProcess()
{
    //
    // FreeSPTIPTHREAD2() removes psfn from PtrArray.
    //
    if (g_rgstt)
    {
        while(g_rgstt->Count())
        {
            SPTIPTHREAD *pstt = g_rgstt->Get(0);
            g_rgstt->Remove(0, 1);
            cicMemFree(pstt);
        }
        delete g_rgstt;
        g_rgstt = NULL;
    }

    //
    // Free speech grammar resource module(SPGRMR.DLL)
    //
    if (g_hInstSpgrmr)
    {
        FreeLibrary(g_hInstSpgrmr);
    }

    //
    // Free XP SP1 resource module(XPSP1RES.DLL) if it is loaded.
    //
    FreeCicResInstance();
}

//+---------------------------------------------------------------------------
//
// LoadSpgrmrModule()
//
//+---------------------------------------------------------------------------

void LoadSpgrmrModule()
{
    if (!g_hInstSpgrmr)
    {
        TCHAR szSpgrmrPath[MAX_PATH + 32];

        if (GetWindowsDirectory(szSpgrmrPath, MAX_PATH))
        {
            StringCchCat(szSpgrmrPath,
                         ARRAYSIZE(szSpgrmrPath),
                         TEXT("\\IME\\SPGRMR.DLL"));

            g_hInstSpgrmr = LoadLibrary(szSpgrmrPath);
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// CSpeechUIServer
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// PostCreateInstance
//
//----------------------------------------------------------------------------

void CSpeechUIServer::PostCreateInstance(REFIID riid, void *pvObj)
{
    if (IsEqualGUID(riid, IID_ITfSpeechUIServer))
    {
        ((CSpeechUIServer *)pvObj)->_EnsureSpeechProfile();
    }
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CSpeechUIServer::CSpeechUIServer()
{
    _SetThis(this);

    _tim = NULL;
    _lbim = NULL;
    _fShown = FALSE;
    m_fCommandingReady  = FALSE;
}


//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CSpeechUIServer::~CSpeechUIServer()
{
    if (_fShown)
        ShowUI(FALSE);

    if (_pCes)
    {
        _pCes->_Unadvise();
        SafeReleaseClear(_pCes);
    }

    SafeRelease(_plbiMicrophone);
    SafeRelease(_plbiCfgMenuButton);
    SafeRelease(_plbiBalloon);
    SafeRelease(_plbiDictation);
    SafeRelease(_plbiCommanding);
    SafeRelease(_plbiTtsPlayStop);
    SafeRelease(_plbiTtsPauseResume);
    SafeRelease(_tim);
    SafeRelease(_lbim);

    GlobalDeleteAtom(m_hAtom);

    _SetThis(NULL);
}

//+---------------------------------------------------------------------------
//
// Initialize
//
//----------------------------------------------------------------------------

STDAPI CSpeechUIServer::Initialize()
{
    HRESULT hr;
    if (_tim)
        return S_OK;

    if (FAILED(hr = TF_CreateThreadMgr(&_tim)))
        return hr;

    if (FAILED(hr = GetService(_tim, 
                               IID_ITfLangBarItemMgr, 
                               (IUnknown **)&_lbim)))
        return hr;

    if (!(_pCes = new CCompartmentEventSink(_CompEventSinkCallback, this)))
    {
        return E_OUTOFMEMORY;
    }

    _pCes->_Advise(_tim, GUID_COMPARTMENT_SPEECH_OPENCLOSE, TRUE);
    _pCes->_Advise(_tim, GUID_COMPARTMENT_SPEECH_DISABLED, FALSE);
    _pCes->_Advise(_tim, GUID_COMPARTMENT_SPEECH_GLOBALSTATE, TRUE);
    _pCes->_Advise(_tim, GUID_COMPARTMENT_SPEECH_UI_STATUS, TRUE);
    _pCes->_Advise(_tim, GUID_COMPARTMENT_SHARED_BLN_TEXT, TRUE); 
    _pCes->_Advise(_tim, GUID_COMPARTMENT_TTS_STATUS, FALSE);
    //TABLETPC
    _pCes->_Advise(_tim, GUID_COMPARTMENT_SPEECH_STAGE, FALSE);
    _pCes->_Advise(_tim, GUID_COMPARTMENT_SPEECH_STAGECHANGE, TRUE);

    // SetCompartmentDWORD(0, _tim, GUID_COMPARTMENT_SPEECH_UI_STATUS, 7, TRUE);

    // this is for TABLET
    DWORD  dw = 0;
    GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_STAGECHANGE, &dw, TRUE);
    m_fStageVisible = dw ? TRUE : FALSE;
    m_fStageTip = FALSE;

    return S_OK;
}

// internal API specially added for ctfmon
extern "C" 
HRESULT WINAPI TF_CreateLangProfileUtil(ITfFnLangProfileUtil **ppFnLangUtil);
extern "C" HRESULT WINAPI TF_InvalidAssemblyListCacheIfExist();

void CSpeechUIServer::_EnsureSpeechProfile()
{
    CLangProfileUtil *pCLangUtil = NULL;
    CSapiIMX         *pimx;

    
    if (pimx = GetIMX())
    {
        pCLangUtil = SAFECAST(pimx, CLangProfileUtil *);
        pCLangUtil->AddRef();
    }
    else
    {
        // ref gets added by the API
        TF_CreateLangProfileUtil((ITfFnLangProfileUtil **)&pCLangUtil);
    }

    if (pCLangUtil)
    {
        // do this only once when profiles are not populated for the user
        if(!pCLangUtil->_fUserInitializedProfile())
        {
            if (S_OK == pCLangUtil->RegisterActiveProfiles())
                TF_InvalidAssemblyListCacheIfExist();
        }
    }

    SafeRelease(pCLangUtil);

}

//+---------------------------------------------------------------------------
//
// ShowUI
//
//----------------------------------------------------------------------------
STDAPI CSpeechUIServer::ShowUI(BOOL fShow)
{
    DWORD dwDictState = GetDictStatus();

    if (fShow)
    {
        BOOL fOn = GetOnOff();
        BOOL fDisabled = GetDisabled();
#ifdef TF_DISABLE_SPEECH
        BOOL fDictationDisabled = GetDictationDisabled();
        BOOL fCommandingDisabled = GetCommandingDisabled();
#endif

        SetCompartmentDWORD(0, _tim,
                            GUID_COMPARTMENT_SPEECHUISHOWN,
                            TF_SPEECHUI_SHOWN,
                            FALSE);

        AddItemMicrophone();
        DisableItemMicrophone(fDisabled);
        if (_pimx)
        {
            AddItemCfgMenuButton();
            DisableItemCfgMenuButton(fDisabled);

            if (!fDisabled)
            {
                SetCfgMenu(TRUE);
            }
        }

        if (fOn)
        {
            DWORD dwUIState = GetUIStatus();

            if (!(dwUIState & TF_DISABLE_BALLOON))
            {
                AddItemBalloon();
                DisableItemBalloon(fDisabled);
            }
            else
                RemoveItemBalloon();
    
            AddItemCommanding();
            AddItemDictation();
            DisableItemCommanding(fDisabled || fCommandingDisabled);
            DisableItemDictation(fDisabled || fDictationDisabled || !(dwDictState & TF_DICTATION_ENABLED));
            ToggleItemCommanding((dwDictState & TF_COMMANDING_ON) ? TRUE : FALSE);
            ToggleItemDictation((dwDictState & TF_DICTATION_ON) ? TRUE : FALSE);
        }
        else
        {
            RemoveItemBalloon();
            RemoveItemCommanding();
            RemoveItemDictation();
        }

#ifdef CHANGE_MIC_TOOLTIP_ONTHEFLY
        _ToggleMicrophone(fOn);
#else
        ToggleItemMicrophone(fOn);
#endif

        // Handle TTS Play & Stop Buttons
        BOOL fTTSButtonEnable; 

        AddItemTtsPlayStop( );
        AddItemTtsPauseResume( );

        fTTSButtonEnable = GetTtsButtonStatus();

        DisableItemTtsPlayStop( !fTTSButtonEnable );
        DisableItemTtsPauseResume( !fTTSButtonEnable );

        if ( fTTSButtonEnable )
        {
            BOOL fTTSPlayOn;
            BOOL fTTSPauseOn;

            fTTSPlayOn = GetTtsPlayOnOff( );
            ToggleItemTtsPlayStop(fTTSPlayOn);
            fTTSPauseOn = GetTtsPauseOnOff( );
            ToggleItemTtsPauseResume(fTTSPauseOn);
        }
    }
    else
    {
        RemoveItemMicrophone();
        SetCfgMenu(FALSE);

        RemoveItemCfgMenuButton();
        RemoveItemBalloon();
        RemoveItemCommanding();
        RemoveItemDictation();
        RemoveItemTtsPlayStop( );
        RemoveItemTtsPauseResume( );

        SetCompartmentDWORD(0, _tim,
                            GUID_COMPARTMENT_SPEECHUISHOWN,
                            0, FALSE);
    }

    _fShown = fShow;
    return S_OK;
}
//+---------------------------------------------------------------------------
//
// UpdateBalloon
//
//----------------------------------------------------------------------------

STDAPI CSpeechUIServer::UpdateBalloon(TfLBBalloonStyle style,
                                      const WCHAR *pch,
                                      ULONG cch)
{
     UpdateBalloonAndTooltip(style, pch, cch, NULL, 0);
     return S_OK;
}

//
// UpdateBalloonAndTooltip (internal method)
//
//
//
HRESULT CSpeechUIServer::UpdateBalloonAndTooltip
(
    TfLBBalloonStyle style, 
    const WCHAR *pch, 
    ULONG cch,
    const WCHAR *pchTooltip,
    ULONG cchTooltip
)
{
        // check if it has same style and string already
    if ((_plbiBalloon && _plbiBalloon->NeedUpdate(style, pch)) || GetSystemMetrics(SM_TABLETPC) > 0)
    {
          
        // we don't pick up out proc tooltip 
        if (pchTooltip && _plbiBalloon)
            _plbiBalloon->SetToolTip((WCHAR *)pchTooltip);

        // this is a private channel for non-cicero UI plugin
        // they pick up this global compartment notification,
        // and store the string for displaying what's set to 
        // any of the balloon objects in the system by Cicero apps. 
        // it should be deleted right after sent to non-cicero threads
        // to avoid ref count management
        //
        if (m_hAtom) 
        {
            GlobalDeleteAtom(m_hAtom);
        }

        m_hAtom = GlobalAddAtomW(pch);
        if (m_hAtom && _tim)
        {
            DWORD  dw;

            dw = m_hAtom + (style << 16);
            SetCompartmentDWORD(0, _tim, GUID_COMPARTMENT_SHARED_BLN_TEXT, dw, TRUE);
        }
         
    }

    return S_OK;
}

HRESULT CSpeechUIServer::SetBalloonSAPIInitFlag(BOOL fSet)
{
    HRESULT hr = E_FAIL;

    if (_plbiBalloon)
    {
        _plbiBalloon->SetToFireInitializeSAPI(fSet);

        hr = S_OK;
    }

    return hr;
}

#ifdef CHANGE_MIC_TOOLTIP_ONTHEFLY
//
// ToggleMicrophone (internal method)
//
// synopsis: toggle microphone button and set tooltip accordingly
//
HRESULT CSpeechUIServer::_ToggleMicrophone(BOOL fOn)
{
    if (!_plbiMicrophone)
        return E_FAIL;


    static WCHAR s_szTooltipOff[MAX_PATH] = {0};
    static WCHAR s_szTooltipOn[MAX_PATH] = {0};

    if (!s_szTooltipOff[0])
    {
        CicLoadStringWrapW(g_hInst, IDS_NUI_MICROPHONE_ON_TOOLTIP,
                                    s_szTooltipOff,
                                    ARRAYSIZE(s_szTooltipOff));
    }
    if (!s_szTooltipOn[0])
    {
         CicLoadStringWrapW(g_hInst,  IDS_NUI_MICROPHONE_OFF_TOOLTIP,
                                      s_szTooltipOn,
                                      ARRAYSIZE(s_szTooltipOn));
    }

    WCHAR szMicTooltip[MAX_PATH];

    StringCchCopyW(szMicTooltip, ARRAYSIZE(szMicTooltip), fOn ? s_szTooltipOn : s_szTooltipOff);

    _plbiMicrophone->SetToolTip((WCHAR *)szMicTooltip);

    _plbiMicrophone->SetOrClearStatus(TF_LBI_STATUS_BTN_TOGGLED, fOn); 
    if (_plbiMicrophone->GetSink())
       _plbiMicrophone->GetSink()->OnUpdate(TF_LBI_STATUS);

    return S_OK;
}
#endif

//----------------------------------------------------------------------------
//
// _CompEventSinkCallback (static)
//
//----------------------------------------------------------------------------
HRESULT CSpeechUIServer::_CompEventSinkCallback(void *pv, REFGUID rguid)
{
    CSpeechUIServer *_this = (CSpeechUIServer *)pv;

    if ((IsEqualGUID(rguid, GUID_COMPARTMENT_SPEECH_OPENCLOSE)) ||
        (IsEqualGUID(rguid, GUID_COMPARTMENT_SPEECH_DISABLED)) ||
        (IsEqualGUID(rguid, GUID_COMPARTMENT_TTS_STATUS)))
    {
        if (IsEqualGUID(rguid, GUID_COMPARTMENT_SPEECH_OPENCLOSE))
        {
           TraceMsg(TF_SAPI_PERF, "GUID_COMPARTMENT_SPEECH_OPENCLOSE to be handled in NUI");
        }

        _this->ShowUI(_this->_fShown);

        if (IsEqualGUID(rguid, GUID_COMPARTMENT_SPEECH_OPENCLOSE))
        {
           TraceMsg(TF_SAPI_PERF, "GUID_COMPARTMENT_SPEECH_OPENCLOSE is handled in NUI ::ShowUI");
        }

        return S_OK;
    }
    else if (IsEqualGUID(rguid, GUID_COMPARTMENT_SPEECH_GLOBALSTATE))
    {
        HRESULT hr = S_OK;
        BOOL fFocus;
        if ( (S_OK == _this->_tim->IsThreadFocus(&fFocus) && fFocus) ||
              S_OK == _this->IsActiveThread())
        {
            // We switch states immediately if we have focus or we are the active thread.
            // This allows the stage speech tip instance to turn on/off dictation at the correct time
            // and allows other speech tip instances to turn on C&C only if they have focus (since the
            // stage application does not care about focus-based C&C).
            DWORD dwLocal, dwGlobal;
            GetCompartmentDWORD(_this->_tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, &dwLocal, FALSE);
            GetCompartmentDWORD(_this->_tim, GUID_COMPARTMENT_SPEECH_GLOBALSTATE, &dwGlobal, TRUE);
            dwGlobal = dwGlobal & (TF_DICTATION_ON + TF_COMMANDING_ON);
            if ( (dwLocal&(TF_DICTATION_ON + TF_COMMANDING_ON)) != dwGlobal)
            {
                dwLocal = (dwLocal & ~(TF_DICTATION_ON + TF_COMMANDING_ON)) + dwGlobal;
                SetCompartmentDWORD(0, _this->_tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, dwLocal, FALSE);
            }
        }
        _this->ShowUI(_this->_fShown);
        return hr;
    }
    else if (IsEqualGUID(rguid, GUID_COMPARTMENT_SPEECH_UI_STATUS))
    {
        DWORD dwDictState = _this->GetDictStatus();
        BOOL fOn = _this->GetOnOff();
        DWORD dwUIState = _this->GetUIStatus();

        if (fOn &&
            (dwDictState  & (TF_DICTATION_ENABLED | TF_COMMANDING_ENABLED)) &&
            !(dwUIState & TF_DISABLE_BALLOON))
        {
            BOOL fDisabled = _this->GetDisabled();
            _this->AddItemBalloon();
            _this->DisableItemBalloon(fDisabled);
        }
        else
            _this->RemoveItemBalloon();

        if (fOn && !(dwUIState & TF_DISABLE_BALLOON))
        {
            // when balloon is shown and
            // for the first time commanding is set on, 
            // we show "Begin Voice Command" as a hint
            // that now user can start speaking
            //
            if (!_this->m_fCommandingReady &&
               (dwDictState & TF_COMMANDING_ON))
            {
                
                WCHAR sz[128];
                sz[0] = '\0';
                CicLoadStringWrapW(g_hInst, IDS_NUI_BEGINVOICECMD, sz, ARRAYSIZE(sz));
       
                _this->UpdateBalloon(TF_LB_BALLOON_RECO, sz , -1);
                _this->m_fCommandingReady = TRUE;
            }
        }
    }
    else if (IsEqualGUID(rguid, GUID_COMPARTMENT_SHARED_BLN_TEXT))
    {
        if (_this->_plbiBalloon&&
           !(TF_LBI_STATUS_HIDDEN & _this->_plbiBalloon->GetStatusInternal()))
        {
            DWORD   dw;

            if (SUCCEEDED(GetCompartmentDWORD(_this->_tim, rguid, &dw, TRUE)))
            {
                ATOM hAtom = (WORD)dw & 0xffff;
                WCHAR szAtom[MAX_PATH] = {0};
                TfLBBalloonStyle     style;

                style = (TfLBBalloonStyle) (dw >> 16);

                GlobalGetAtomNameW(hAtom, szAtom, ARRAYSIZE(szAtom));

                _this->_plbiBalloon->Set(style, szAtom);

                if (_this->_plbiBalloon->GetSink())
                {
                    _this->_plbiBalloon->GetSink()->OnUpdate(TF_LBI_BALLOON);
                }
            }
        }
    }
// TABLETPC
    else if (IsEqualGUID(rguid, GUID_COMPARTMENT_SPEECH_STAGE))
    {
		_this->m_fStageTip = TRUE;
    }
    else if (IsEqualGUID(rguid, GUID_COMPARTMENT_SPEECH_STAGECHANGE))
    {
        HRESULT hr = S_OK;
        DWORD dw;

        GetCompartmentDWORD(_this->_tim, GUID_COMPARTMENT_SPEECH_STAGECHANGE, &dw, TRUE);
		_this->m_fStageVisible = dw ? TRUE:FALSE;
    }
// TABLETPC
    return S_FALSE;
}

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemMicrophone
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItemMicrophone::CLBarItemMicrophone(CSpeechUIServer *psus)
{
    Dbg_MemSetThisName(TEXT("CLBarItemMicrophone"));

    _psus = psus;
    InitNuiInfo(CLSID_SYSTEMLANGBARITEM_SPEECH, 
                GUID_LBI_SAPILAYR_MICROPHONE,
                 TF_LBI_STYLE_HIDDENSTATUSCONTROL 
               | TF_LBI_STYLE_BTN_TOGGLE 
               | TF_LBI_STYLE_SHOWNINTRAY, 
                SORT_MICROPHONE,
                CRStr(IDS_NUI_MICROPHONE_TOOLTIP));

    SetToolTip(CRStr(IDS_NUI_MICROPHONE_TOOLTIP));
    SetText(CRStr(IDS_NUI_MICROPHONE_TEXT));
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLBarItemMicrophone::~CLBarItemMicrophone()
{
}


//+---------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CLBarItemMicrophone::GetIcon(HICON *phIcon)
{
    if (!phIcon)
        return E_INVALIDARG;

    TraceMsg(TF_SAPI_PERF, "Microphone::GetIcon is called");
    *phIcon = LoadSmIcon(g_hInst, MAKEINTRESOURCE(ID_ICON_MICROPHONE));
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnLButtonUp
//
//----------------------------------------------------------------------------

HRESULT CLBarItemMicrophone::OnLButtonUp(const POINT pt, const RECT *prcArea)
{
     TraceMsg(TF_SAPI_PERF, "Microphone button is hit");
     return ToggleCompartmentDWORD(0,
                                   _psus->GetTIM(),
                                   GUID_COMPARTMENT_SPEECH_OPENCLOSE, 
                                   TRUE);
}


//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemCfgmenuButton
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItemCfgMenuButton::CLBarItemCfgMenuButton(CSpeechUIServer *psus)
{
    Dbg_MemSetThisName(TEXT("CLBarItemCfgMenuButton"));

    _psus = psus;
    InitNuiInfo(CLSID_SYSTEMLANGBARITEM_SPEECH, 
                GUID_LBI_SAPILAYR_CFGMENUBUTTON,
                TF_LBI_STYLE_BTN_MENU,
                SORT_CFGMENUBUTTON,
                CRStr(IDS_NUI_CFGMENU_TOOLTIP));

    SetToolTip(CRStr(IDS_NUI_CFGMENU_TOOLTIP));
    SetText(CRStr(IDS_NUI_CFGMENU_TEXT));
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLBarItemCfgMenuButton::~CLBarItemCfgMenuButton()
{
}


//+---------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CLBarItemCfgMenuButton::GetIcon(HICON *phIcon)
{
    if (!phIcon)
        return E_INVALIDARG;

    *phIcon = LoadSmIcon(g_hInst, MAKEINTRESOURCE(ID_ICON_CFGMENU));
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// InitMenu
//
//----------------------------------------------------------------------------

STDAPI CLBarItemCfgMenuButton::InitMenu(ITfMenu *pMenu)
{
    UINT nTipCurMenuID = IDM_CUSTOM_MENU_START;
    _InsertCustomMenus(pMenu, &nTipCurMenuID);
    
    CSapiIMX::_SysLBarCallback(IDSLB_INITMENU, _psus->GetIMX(), pMenu, 0);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnMenuSelect
//
//----------------------------------------------------------------------------

STDAPI CLBarItemCfgMenuButton::OnMenuSelect(UINT uID)
{
    HRESULT hr;

    if (uID >= IDM_CUSTOM_MENU_START)
        hr =  CLBarItemSystemButtonBase::OnMenuSelect(uID);
    else
        hr = CSapiIMX::_SysLBarCallback(IDSLB_ONMENUSELECT, _psus->GetIMX(), NULL, uID);
    return hr;
}



//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemBalloon
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItemBalloon::CLBarItemBalloon(CSpeechUIServer *psus)
{
    Dbg_MemSetThisName(TEXT("CLBarItemBalloon"));

    _psus = psus;
    InitNuiInfo(CLSID_SYSTEMLANGBARITEM_SPEECH, 
                GUID_LBI_SAPILAYR_BALLOON,
                0, 
                SORT_BALLOON,
                CRStr(IDS_NUI_BALLOON_TEXT));

    SIZE size;
    size.cx = 100;
    size.cy = 16;
    SetPreferedSize(&size);
    SetToolTip(CRStr(IDS_NUI_BALLOON_TOOLTIP));

    // by default Balloon is hidden.
    // SetStatusInternal(TF_LBI_STATUS_HIDDEN);

    m_fFireInitializeSapi = FALSE;

}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLBarItemBalloon::~CLBarItemBalloon()
{
    if (_bstrText)
        SysFreeString(_bstrText);
}

//+---------------------------------------------------------------------------
//
// GetBalloonInfo
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBalloon::GetBalloonInfo(TF_LBBALLOONINFO *pInfo)
{
    pInfo->style = _style;
    pInfo->bstrText = SysAllocString(_bstrText);

    //
    // If the flag is set, we're asked to fire an event to set
    // a timer to start SAPI intialization
    //
    if (m_fFireInitializeSapi)
    {
        // turns the flag off
        SetToFireInitializeSAPI(FALSE);

        TraceMsg(TF_SAPI_PERF, "GetBalloonInfo is called");

        CSapiIMX *pimx = _psus->GetIMX();
        if (pimx)
        {
            pimx->_EnsureWorkerWnd();

            SetTimer(pimx->_GetWorkerWnd(), TIMER_ID_OPENCLOSE, 100, NULL);
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Set
//
//----------------------------------------------------------------------------

void CLBarItemBalloon::Set(TfLBBalloonStyle style, const WCHAR *psz) 
{
    if (_bstrText)
        SysFreeString(_bstrText);

    _bstrText = SysAllocString(psz);
    if (_bstrText)
    {
        SetToolTip(_bstrText);
    }

    _style = style;

}

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemDictation
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItemDictation::CLBarItemDictation(CSpeechUIServer *psus)
{
    Dbg_MemSetThisName(TEXT("CLBarItemDictation"));

    _psus = psus;
    InitNuiInfo(CLSID_SYSTEMLANGBARITEM_SPEECH, 
                GUID_LBI_SAPILAYR_DICTATION,
                TF_LBI_STYLE_BTN_TOGGLE, 
                SORT_DICTATION,
                CRStr(IDS_NUI_DICTATION_TOOLTIP));

    SetToolTip(CRStr(IDS_NUI_DICTATION_TOOLTIP));
    SetText(CRStr(IDS_NUI_DICTATION_TEXT));
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLBarItemDictation::~CLBarItemDictation()
{
}


//+---------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CLBarItemDictation::GetIcon(HICON *phIcon)
{
    if (!phIcon)
        return E_INVALIDARG;

    *phIcon = LoadSmIcon(g_hInst, MAKEINTRESOURCE(ID_ICON_DICTATION));
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnLButtonUp
//
//----------------------------------------------------------------------------

HRESULT CLBarItemDictation::OnLButtonUp(const POINT pt, const RECT *prcArea)
{
    _psus->SetDictStatus();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemCommanding
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItemCommanding::CLBarItemCommanding(CSpeechUIServer *psus)
{
    Dbg_MemSetThisName(TEXT("CLBarItemCommanding"));

    _psus = psus;
    InitNuiInfo(CLSID_SYSTEMLANGBARITEM_SPEECH, 
                GUID_LBI_SAPILAYR_COMMANDING,
                TF_LBI_STYLE_BTN_TOGGLE, 
                SORT_COMMANDING,
                CRStr(IDS_NUI_COMMANDING_TOOLTIP));

    SetToolTip(CRStr(IDS_NUI_COMMANDING_TOOLTIP));
    SetText(CRStr(IDS_NUI_COMMANDING_TEXT));
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLBarItemCommanding::~CLBarItemCommanding()
{
}


//+---------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CLBarItemCommanding::GetIcon(HICON *phIcon)
{
    if (!phIcon)
        return E_INVALIDARG;

    *phIcon = LoadSmIcon(g_hInst, MAKEINTRESOURCE(ID_ICON_COMMANDING));
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnLButtonUp
//
//----------------------------------------------------------------------------

HRESULT CLBarItemCommanding::OnLButtonUp(const POINT pt, const RECT *prcArea)
{
    _psus->SetCmdStatus();
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemTtsPlayStop
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItemTtsPlayStop::CLBarItemTtsPlayStop(CSpeechUIServer *psus)
{
    Dbg_MemSetThisName(TEXT("CLBarItemTtsPlayStop"));

    _psus = psus;
    InitNuiInfo(CLSID_SYSTEMLANGBARITEM_SPEECH, 
                GUID_LBI_SAPILAYR_TTS_PLAY_STOP,
                TF_LBI_STYLE_BTN_TOGGLE | TF_LBI_STYLE_HIDDENBYDEFAULT, 
                SORT_TTSPLAYSTOP,
                CRStr(IDS_NUI_TTSPLAY_TOOLTIP));

    SetToolTip(CRStr(IDS_NUI_TTSPLAY_TOOLTIP));
    SetText(CRStr(IDS_NUI_TTSPLAY_TEXT));
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLBarItemTtsPlayStop::~CLBarItemTtsPlayStop()
{
}


//+---------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CLBarItemTtsPlayStop::GetIcon(HICON *phIcon)
{
    BOOL     fTTSPlayOn;

    if (!phIcon)
        return E_INVALIDARG;

    if (!_psus)  return E_FAIL;

    fTTSPlayOn = _psus->GetTtsPlayOnOff( );

    if ( fTTSPlayOn )
    {
        *phIcon = LoadSmIcon(g_hInst, MAKEINTRESOURCE(ID_ICON_TTSSTOP));
    }
    else
    {
        *phIcon = LoadSmIcon(g_hInst, MAKEINTRESOURCE(ID_ICON_TTSPLAY));
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnLButtonUp
//
//----------------------------------------------------------------------------

HRESULT CLBarItemTtsPlayStop::OnLButtonUp(const POINT pt, const RECT *prcArea)
{
    HRESULT                 hr = S_OK;
    CSapiIMX                *pimx;

    if ( _psus == NULL)  return E_FAIL;

    pimx = _psus->GetIMX();

    if ( pimx )
    {
        hr = pimx->_HandleEventOnPlayButton( );
    }

    return hr;
}

// +-------------------------------------------------------------------------
//
// UpdateStatus
//
//      Update the text, tooltips, and icons based on current Play/Stop 
//      button's status.
// +-------------------------------------------------------------------------

HRESULT CLBarItemTtsPlayStop::UpdateStatus( )
{
    HRESULT  hr = S_OK;
    BOOL     fTTSPlayOn;

    if (!_psus)  return E_FAIL;

    fTTSPlayOn = _psus->GetTtsPlayOnOff( );

    if ( fTTSPlayOn )  // Toggled status
    {
        SetToolTip(CRStr(IDS_NUI_TTSSTOP_TOOLTIP));
        SetText(CRStr(IDS_NUI_TTSSTOP_TEXT));
    }
    else
    {
        SetToolTip(CRStr(IDS_NUI_TTSPLAY_TOOLTIP));
        SetText(CRStr(IDS_NUI_TTSPLAY_TEXT));
    }

    if ( GetSink( ) )
        GetSink( )->OnUpdate(TF_LBI_ICON | TF_LBI_TEXT | TF_LBI_TOOLTIP);

    // Update the toolbar command grammar to use the new tooltip text
    // Speak Text  or  Stop speaking

    CSapiIMX   *pImx;

    pImx = _psus->GetIMX( );

    if ( pImx)
    {
        CSpTask           *psp;

        pImx->GetSpeechTask(&psp);
        if (psp)
        {
            if ( psp->m_pLangBarSink )
                (psp->m_pLangBarSink)->OnThreadItemChange(0);

            psp->Release();
        }
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemTtsPauseResume
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItemTtsPauseResume::CLBarItemTtsPauseResume(CSpeechUIServer *psus)
{
    Dbg_MemSetThisName(TEXT("CLBarItemTtsPauseResume"));

    _psus = psus;
    InitNuiInfo(CLSID_SYSTEMLANGBARITEM_SPEECH, 
                GUID_LBI_SAPILAYR_TTS_PAUSE_RESUME,
                TF_LBI_STYLE_BTN_TOGGLE | TF_LBI_STYLE_HIDDENBYDEFAULT, 
                SORT_TTSPAUSERESUME,
                CRStr(IDS_NUI_TTSPAUSE_TOOLTIP));

    SetToolTip(CRStr(IDS_NUI_TTSPAUSE_TOOLTIP));
    SetText(CRStr(IDS_NUI_TTSPAUSE_TEXT));
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLBarItemTtsPauseResume::~CLBarItemTtsPauseResume()
{
}


//+---------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CLBarItemTtsPauseResume::GetIcon(HICON *phIcon)
{
    if (!phIcon)
        return E_INVALIDARG;

    *phIcon = LoadSmIcon(g_hInst, MAKEINTRESOURCE(ID_ICON_TTSPAUSE));

    return S_OK;

}

//+---------------------------------------------------------------------------
//
// OnLButtonUp
//
//----------------------------------------------------------------------------

HRESULT CLBarItemTtsPauseResume::OnLButtonUp(const POINT pt, const RECT *prcArea)
{
    HRESULT                 hr = S_OK;
    CSapiIMX                *pimx;

    if ( _psus == NULL)  return E_FAIL;

    pimx = _psus->GetIMX();

    if (pimx)
    {
        hr = pimx->_HandleEventOnPauseButton( );
    }

    return hr;
}

// +-------------------------------------------------------------------------
//
// UpdateStatus
//
//     Update text, tooltips, icons for Pause/Resume buttons
//     based on current status.
// +-------------------------------------------------------------------------

HRESULT CLBarItemTtsPauseResume::UpdateStatus( )
{
    HRESULT  hr = S_OK;
    BOOL     fTTSPauseOn;

    if (!_psus)  return E_FAIL;

    fTTSPauseOn = _psus->GetTtsPauseOnOff( );

    if ( fTTSPauseOn )  // Toggled status
    {
        SetToolTip(CRStr(IDS_NUI_TTSRESUME_TOOLTIP));
        SetText(CRStr(IDS_NUI_TTSRESUME_TEXT));
    }
    else
    {
        SetToolTip(CRStr(IDS_NUI_TTSPAUSE_TOOLTIP));
        SetText(CRStr(IDS_NUI_TTSPAUSE_TEXT));
    }

    if ( GetSink( ) )
        GetSink( )->OnUpdate(TF_LBI_TEXT | TF_LBI_TOOLTIP);

    // Update the toolbar command grammar to use the new tooltip text
    // Pause Speaking  or  Resume speaking

    CSapiIMX   *pImx;

    pImx = _psus->GetIMX( );

    if ( pImx)
    {
        CSpTask           *psp;

        pImx->GetSpeechTask(&psp);
        if (psp)
        {
            if ( psp->m_pLangBarSink )
                (psp->m_pLangBarSink)->OnThreadItemChange(0);

            psp->Release();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\miscfunc.cpp ===
//
//
// Sapilayr TIP Misc function impl.
//
//
#include "private.h"
#include "sapilayr.h"
#include "nui.h"
#include "miscfunc.h"

//////////////////////////////////////////////////////////////////////////////
//
// CGetSAPIObject
//
//////////////////////////////////////////////////////////////////////////////

//
// ctor / dtor
//

CGetSAPIObject::CGetSAPIObject(CSapiIMX *psi)
{
    m_psi = psi;
    m_psi->AddRef();
    m_psi->GetFocusIC(&m_cpIC); // AddRef in the call
    m_cRef = 1; 
}

CGetSAPIObject::~CGetSAPIObject()
{
    if (m_psi)
        m_psi->Release();
}

//
// IUnknown
//
STDMETHODIMP CGetSAPIObject::QueryInterface(REFGUID riid, LPVOID *ppvObj)
{
    Assert(ppvObj);
    *ppvObj = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfFnGetSAPIObject))
    {
        *ppvObj = SAFECAST(this, CGetSAPIObject *);
    }
    
    if (*ppvObj)
    {
       AddRef();
       return S_OK;
   }
   
   return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CGetSAPIObject::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CGetSAPIObject::Release(void)
{
    long cr;
    cr = InterlockedDecrement(&m_cRef);
    Assert(cr >= 0);
    
    if (cr == 0)
    {
        delete this;
    }
    return cr;
}

//
// ITfFunction
//
STDMETHODIMP CGetSAPIObject::GetDisplayName(BSTR *pbstrName)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrName)
    {
        *pbstrName = SysAllocString(L"Get SAPI objects");
        if (!*pbstrName)
            hr = E_OUTOFMEMORY;
        else
            hr = S_OK;
    }
    return hr;
}

// 
// ITfFnGetSAPIObject
//

static const struct {
    TfSapiObject sObj;
    const GUID  *riid; 
    BOOL        fInit;
} SapiInterfaceTbl[] =
{
    {GETIF_RESMGR                , &IID_ISpResourceManager, TRUE },

    {GETIF_RECOCONTEXT           , &IID_ISpRecoContext,  TRUE},

    {GETIF_RECOGNIZER            , &IID_ISpRecognizer,  TRUE},
    {GETIF_VOICE                 , &IID_ISpVoice,  TRUE},
    {GETIF_DICTGRAM              , &IID_ISpRecoGrammar,  TRUE},
    {GETIF_RECOGNIZERNOINIT      , &IID_ISpRecognizer,  FALSE},

};

STDMETHODIMP CGetSAPIObject::Get(TfSapiObject sObj, IUnknown **ppunk)
{
    HRESULT hr = S_FALSE;

    //
    // sObj is an index to SapiInterfaceTbl[]
    //
    Assert(GETIF_RESMGR == 0);

    if (ppunk)
        *ppunk = NULL;

    if(sObj < ARRAYSIZE(SapiInterfaceTbl))
    {
        CSpTask *psptask = NULL;
        if (S_OK == m_psi->GetSpeechTask(&psptask, SapiInterfaceTbl[sObj].fInit))
        {
            hr = psptask->GetSAPIInterface(*(SapiInterfaceTbl[sObj].riid), (void **)ppunk);
        }
        SafeRelease(psptask);
    }
    return hr;
}


// 
// IsSupported() (internal) 
//               returns S_OK when the passed in IID is supported, 
//               otherwise returns S_FALSE
//
//
HRESULT CGetSAPIObject::IsSupported(REFIID riid, TfSapiObject *psObj)
{
    HRESULT hr = S_FALSE;

    Assert(psObj);

    for (int i = 0; i < ARRAYSIZE(SapiInterfaceTbl); i++)
    {
        Assert(i == SapiInterfaceTbl[i].sObj);

        if (IsEqualGUID(*SapiInterfaceTbl[i].riid, riid))
        {
            *psObj = SapiInterfaceTbl[i].sObj;
            hr = S_OK;

            break;
        }
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CFnBalloon
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CFnBalloon::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfFnBalloon))
    {
        *ppvObj = SAFECAST(this, CFnBalloon *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CFnBalloon::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDAPI_(ULONG) CFnBalloon::Release()
{
    long cr;

    cr = InterlockedDecrement(&_cRef);
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CFnBalloon::CFnBalloon(CSapiIMX *psi) : CFunction(psi)
{
    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CFnBalloon::~CFnBalloon()
{
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

STDAPI CFnBalloon::GetDisplayName(BSTR *pbstrName)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrName)
    {
        *pbstrName = SysAllocString(L"Speech Conversion");
        if (!*pbstrName)
            hr = E_OUTOFMEMORY;
        else
            hr = S_OK;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// CFnBalloon::UpdateBalloon
//
//----------------------------------------------------------------------------

STDAPI CFnBalloon::UpdateBalloon(TfLBBalloonStyle style, const WCHAR *pch, ULONG cch)
{
    HRESULT hr = S_OK;
    if (!m_pImx->GetSpeechUIServer())
        return hr;

    m_pImx->GetSpeechUIServer()->UpdateBalloon(style, pch, cch);
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CFnAbort
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CFnAbort::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfFnAbort))
    {
        *ppvObj = SAFECAST(this, CFnAbort *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CFnAbort::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDAPI_(ULONG) CFnAbort::Release()
{
    long cr;

    cr = InterlockedDecrement(&_cRef);
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CFnAbort::CFnAbort(CSapiIMX *psi) : CFunction(psi)
{
    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CFnAbort::~CFnAbort()
{
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

STDAPI CFnAbort::GetDisplayName(BSTR *pbstrName)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrName)
    {
        *pbstrName = SysAllocString(L"Speech Abort Pending Conversion");
        if (!*pbstrName)
            hr = E_OUTOFMEMORY;
        else
            hr = S_OK;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// CFnAbort::Abort
//
//----------------------------------------------------------------------------

HRESULT CFnAbort::Abort(ITfContext *pctxt)
{
    HRESULT hr;

    Assert(m_pImx);
    Assert(pctxt);

    // put up the hour glass
    HCURSOR hCur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    hr = m_pImx->_RequestEditSession(ESCB_ABORT,TF_ES_READWRITE | TF_ES_SYNC, NULL, pctxt);

    if (hCur)
       SetCursor(hCur);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  CFnConfigure::Show
//
//----------------------------------------------------------------------------
STDMETHODIMP CFnConfigure::Show(HWND hwndParent, LANGID langid, REFGUID rguidProfile)
{
    m_psi->_InvokeSpeakerOptions( TRUE );

    return S_OK;
};


//+---------------------------------------------------------------------------
//
//  CFnPropertyUIStatus implementation
//
//----------------------------------------------------------------------------

//
// IUnknown
//
STDMETHODIMP CFnPropertyUIStatus::QueryInterface(REFGUID riid, LPVOID *ppvObj)
{
    Assert(ppvObj);
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfFnPropertyUIStatus))
    {
        *ppvObj = SAFECAST(this, CFnPropertyUIStatus *);
    }

    if (*ppvObj)
    {
       AddRef();
       return S_OK;
   }

   return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CFnPropertyUIStatus::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CFnPropertyUIStatus::Release(void)
{
    long cr;
    cr = InterlockedDecrement(&m_cRef);
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }
    return cr;
}

STDMETHODIMP CFnPropertyUIStatus::GetStatus(REFGUID refguidProp, DWORD *pdw)
{
    HRESULT hr = S_FALSE;

    if (pdw)
    {
        *pdw = 0;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr) &&
        IsEqualGUID(refguidProp, GUID_PROP_SAPIRESULTOBJECT))
    {
        *pdw |= m_psi->_SerializeEnabled() ? 
                       TF_PROPUI_STATUS_SAVETOFILE : 0;
        hr = S_OK;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\miscfunc.h ===
#ifndef _MISCFUNC_H
#define _MISCFUNC_H
#include "sapilayr.h"

class CSapiIMX;

//////////////////////////////////////////////////////////////////////////////
//
// CGetSAPIObject
//
//////////////////////////////////////////////////////////////////////////////

class CGetSAPIObject : public ITfFnGetSAPIObject
{
public:
    CGetSAPIObject(CSapiIMX *psi);
    ~CGetSAPIObject();

    // IUnknown
    //
    STDMETHODIMP QueryInterface(REFGUID riid, LPVOID *ppobj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ITfFunction
    STDMETHODIMP GetDisplayName(BSTR *pbstrCand);

    // ITfFnGetSAPIObject
    STDMETHODIMP Get(TfSapiObject sObj, IUnknown **ppunk); 

    // internal API IsSupported()
    HRESULT IsSupported(REFIID riid, TfSapiObject *psObj);

private:
    CSapiIMX           *m_psi;
    CComPtr<ITfContext> m_cpIC;
    LONG       m_cRef;

};

//////////////////////////////////////////////////////////////////////////////
//
// CFnBalloon
//
//////////////////////////////////////////////////////////////////////////////

class CFnBalloon : public ITfFnBalloon,
                      public CFunction
{
public:
    CFnBalloon(CSapiIMX *psi);
    ~CFnBalloon();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfFunction
    //
    STDMETHODIMP GetDisplayName(BSTR *pbstrCand);

    //
    // ITfFnBalloon
    //
    STDMETHODIMP UpdateBalloon(TfLBBalloonStyle style, const WCHAR *pch, ULONG cch);

private:
    long _cRef;
};

//////////////////////////////////////////////////////////////////////////////
//
// CFnAbort
//
//////////////////////////////////////////////////////////////////////////////

class CFnAbort : public ITfFnAbort,
                 public CFunction
{
public:
    CFnAbort(CSapiIMX *psi);
    ~CFnAbort();

    // IUnknown
    //
    STDMETHODIMP QueryInterface(REFGUID riid, LPVOID *ppobj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ITfFunction
    STDMETHODIMP GetDisplayName(BSTR *pbstrCand);

    // ITfFnAbort
    STDMETHODIMP Abort(ITfContext *pic);

private:
    CSapiIMX   *m_psi;
    LONG       _cRef;
};

//////////////////////////////////////////////////////////////////////////////
//
// CFnConfigure
//
// synopsis: implements ITfFnConfigure
//
//////////////////////////////////////////////////////////////////////////////

class __declspec(novtable) CFnConfigure : public ITfFnConfigure
{
public:
    CFnConfigure(CSapiIMX *psi) {m_psi = psi;}
    ~CFnConfigure() {}

    // ITfFunction method
    STDMETHODIMP GetDisplayName(BSTR *pbstrName)
    {
        HRESULT hr = E_INVALIDARG;

        if (pbstrName)
        {
            *pbstrName = SysAllocString(L"Show configuration UI for SR");
            if (!*pbstrName)
                hr = E_OUTOFMEMORY;
            else
                hr = S_OK;
        }
        return hr;
    }


    // ITfFnConfigure methods
    STDMETHODIMP Show(HWND hwnd, LANGID langid, REFGUID rguidProfile);

    CSapiIMX *m_psi;

};

class CFnPropertyUIStatus : public ITfFnPropertyUIStatus
{
public:
    CFnPropertyUIStatus(CSapiIMX *psi) {m_psi = psi; m_cRef = 1;}
    ~CFnPropertyUIStatus() {}

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ITfFunction method
    STDMETHODIMP GetDisplayName(BSTR *pbstrName)
    {
        HRESULT hr = E_INVALIDARG;

        if (pbstrName)
        {
            *pbstrName = SysAllocString(L"Get UI setting status of SPTIP");
            if (!*pbstrName)
                hr = E_OUTOFMEMORY;
            else
                hr = S_OK;
        }
        return hr;
    }


    // ITfFnPropertyUIStatus methods
    STDMETHODIMP GetStatus(REFGUID refguidProp, DWORD *pdw);
    

    STDMETHODIMP SetStatus(REFGUID refguidProp, DWORD dw)
    {
        return E_NOTIMPL;
    }

    CSapiIMX *m_psi;
    LONG       m_cRef;
};

#endif // ndef _MISCFUNC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\propitem.cpp ===
// This is implementation for CSpPropItemsServer

#include "private.h"
#include "globals.h"
#include "propitem.h"
#include "cregkey.h"

extern "C" HRESULT WINAPI TF_GetGlobalCompartment(ITfCompartmentMgr **pCompMgr);

// Common functions about Setting /Getting global compartment values.

HRESULT _SetGlobalCompDWORD(REFGUID rguid, DWORD   dw)
{
    HRESULT hr = S_OK;

    CComPtr<ITfCompartmentMgr>  cpGlobalCompMgr;
    CComPtr<ITfCompartment>     cpComp;
    VARIANT                     var;

    hr = TF_GetGlobalCompartment(&cpGlobalCompMgr);

    if ( hr == S_OK )
        hr = cpGlobalCompMgr->GetCompartment(rguid, &cpComp);

    if ( hr == S_OK )
    {
        var.vt = VT_I4;
        var.lVal = dw;
        hr = cpComp->SetValue(0, &var);
    }

    return hr;
}

HRESULT _GetGlobalCompDWORD(REFGUID rguid, DWORD  *pdw)
{
    HRESULT hr = S_OK;

    CComPtr<ITfCompartmentMgr>  cpGlobalCompMgr;
    CComPtr<ITfCompartment>     cpComp;
    VARIANT                     var;

    hr = TF_GetGlobalCompartment(&cpGlobalCompMgr);

    if ( hr == S_OK )
        hr = cpGlobalCompMgr->GetCompartment(rguid, &cpComp);

    if ( hr == S_OK )
        hr = cpComp->GetValue(&var);

    if ( hr == S_OK)
    {
        Assert(var.vt == VT_I4);
        *pdw = var.lVal;
    }

    return hr;
}

//
// ctor
//


CPropItem::CPropItem(PROP_ITEM_ID idPropItem, LPCTSTR lpszValueName, PROP_STATUS psDefault)
{
    int    iLen = lstrlen(lpszValueName);
    m_lpszValueName = (LPTSTR)cicMemAlloc((iLen+1) * sizeof(TCHAR));
    if ( m_lpszValueName )
    {
        StringCchCopy(m_lpszValueName, iLen+1, lpszValueName);
    }
    m_psDefault = psDefault;
    m_psStatus = PROP_UNINITIALIZED;
    m_fIsStatus = TRUE;
    m_PropItemId = idPropItem;

    m_pguidComp = NULL;
    m_dwMaskBit = 0;
}

CPropItem::CPropItem(PROP_ITEM_ID idPropItem, LPCTSTR lpszValueName, DWORD  dwDefault)
{
    int    iLen = lstrlen(lpszValueName);
    
    m_lpszValueName = (LPTSTR)cicMemAlloc((iLen+1) * sizeof(TCHAR));
    if ( m_lpszValueName )
    {
        StringCchCopy(m_lpszValueName,iLen+1, lpszValueName);
    }

    m_dwDefault = dwDefault;
    m_dwValue = UNINIT_VALUE;
    m_fIsStatus = FALSE;
    m_PropItemId = idPropItem;

    m_pguidComp = NULL;
    m_dwMaskBit = 0;
}

CPropItem::CPropItem(PROP_ITEM_ID idPropItem, GUID *pguidComp, DWORD  dwMaskBit,   PROP_STATUS  psDefault)
{
    m_lpszValueName = NULL;
    m_psDefault = psDefault;
    m_psStatus = PROP_UNINITIALIZED;
    m_fIsStatus = TRUE;
    m_PropItemId = idPropItem;

    m_pguidComp = (GUID *) cicMemAlloc(sizeof(GUID));

    if ( m_pguidComp && pguidComp)
        CopyMemory(m_pguidComp, pguidComp, sizeof(GUID));

    m_dwMaskBit = dwMaskBit;
}


CPropItem::CPropItem(CPropItem *pItem)
{
    Assert(pItem);

    m_PropItemId = pItem->GetPropItemId( );
    m_fIsStatus = pItem->IsStatusPropItem( );

    if ( pItem->IsGlobalCompartPropItem( ) )
    {
        // This is a Global compartment property item.
        m_lpszValueName = NULL;

        m_pguidComp = (GUID *) cicMemAlloc(sizeof(GUID));

        if (m_pguidComp)
            CopyMemory(m_pguidComp, pItem->GetCompGuid( ), sizeof(GUID));

        m_dwMaskBit = pItem->GetMaskBit( );
    }
    else
    {
        // This is a registry value property item.
        m_pguidComp = NULL;
        m_dwMaskBit = 0;

        TCHAR   *pItemRegValue;

        pItemRegValue = pItem->GetRegValue( );

        Assert(pItemRegValue);

        int iStrLen;

        iStrLen = lstrlen(pItemRegValue);

        m_lpszValueName = (LPTSTR)cicMemAlloc((iStrLen+1) * sizeof(TCHAR));
        if ( m_lpszValueName )
        {
            StringCchCopy(m_lpszValueName, iStrLen+1, pItemRegValue);
        }
    }

    if ( m_fIsStatus )
    {
        m_psDefault = pItem->GetPropDefaultStatus( );
        m_psStatus  = pItem->GetPropStatus( ) ? PROP_ENABLED : PROP_DISABLED;
    }
    else
    {
        m_dwDefault = pItem->GetPropDefaultValue( );
        m_dwValue   = pItem->GetPropValue( );
    }
}

CPropItem::~CPropItem( )
{
    if ( m_lpszValueName )
        cicMemFree(m_lpszValueName);

    if ( m_pguidComp )
        cicMemFree(m_pguidComp);
}

//
// Common method functions to get and set values from /to registry
//
HRESULT  CPropItem::_GetRegValue(HKEY  hRootKey, DWORD  *pdwValue)
{
    HRESULT  hr=S_FALSE;

    Assert(hRootKey);
    Assert(pdwValue);

    if ( IsGlobalCompartPropItem( ) ) return S_FALSE;

    CMyRegKey regkey;
    DWORD     dw;

    hr = regkey.Open(hRootKey, c_szSapilayrKey, KEY_READ);
    if (S_OK == hr )
    {
        if (ERROR_SUCCESS==regkey.QueryValue(dw, m_lpszValueName))
           *pdwValue = dw;
        else
            hr = S_FALSE;
    }

    return hr;
}
    
void  CPropItem::_SetRegValue(HKEY  hRootKey, DWORD  dwValue)
{
    Assert(hRootKey);

    if ( IsGlobalCompartPropItem( ) )
        return;

    // Registry setting
    CMyRegKey regkey;
    if (S_OK == regkey.Create(hRootKey, c_szSapilayrKey))
    {
        regkey.SetValue(dwValue, m_lpszValueName); 
    }
}


BOOL  CPropItem::GetPropStatus(BOOL fForceFromReg )
{

    // Cleanup: if we can introuce two separate derived classes for status property and value property,
    // there is no need to check m_fIsStatus this way.
    //
    // Compiler will detect any potential wrong code.
    if ( !m_fIsStatus )
        return FALSE;

    if (fForceFromReg || (m_psStatus == PROP_UNINITIALIZED) )
    {
        DWORD dw;

        if ( IsGlobalCompartPropItem( ) )
        {
            if ( S_OK == _GetGlobalCompDWORD(*m_pguidComp, &dw) )
                m_psStatus = (dw & m_dwMaskBit) ? PROP_ENABLED : PROP_DISABLED;
        }
        else
        {
            // This is Registry setting
            if ( (S_OK == _GetRegValue(HKEY_CURRENT_USER, &dw)) ||
                 (S_OK == _GetRegValue(HKEY_LOCAL_MACHINE, &dw)) )
            {
                m_psStatus = (dw > 0) ? PROP_ENABLED : PROP_DISABLED;
            }
        }


        if (m_psStatus == PROP_UNINITIALIZED)
            m_psStatus  = m_psDefault; 
    }

    return PROP_ENABLED == m_psStatus;
}

DWORD CPropItem::GetPropValue(BOOL fForceFromReg )
{
    if ( m_fIsStatus )
        return UNINIT_VALUE;

    if (fForceFromReg || (m_dwValue == UNINIT_VALUE) )
    {
        if ( (S_OK != _GetRegValue(HKEY_CURRENT_USER, &m_dwValue)) &&
             (S_OK != _GetRegValue(HKEY_LOCAL_MACHINE,&m_dwValue)) )
        {
            m_dwValue  = m_dwDefault; 
        }
    }

    return m_dwValue;
}

void CPropItem::SetPropStatus(BOOL fEnable)
{
    if ( m_fIsStatus )
        m_psStatus = fEnable ? PROP_ENABLED : PROP_DISABLED;
}

void CPropItem::SetPropValue(DWORD dwValue )
{
    if ( !m_fIsStatus )
        m_dwValue = dwValue;
}

void CPropItem::SaveDefaultRegValue( )
{
    if ( IsGlobalCompartPropItem( ) )
        return;
    
    DWORD  dw;

    if ( m_fIsStatus )
        dw = (m_psDefault == PROP_ENABLED ? 1 : 0 );
    else
        dw = m_dwDefault;

    _SetRegValue(HKEY_LOCAL_MACHINE, dw);
}

void CPropItem::SavePropData( )
{
    DWORD  dw;

    if ( m_fIsStatus )
        dw = (DWORD)GetPropStatus( );
    else
        dw = GetPropValue( );

    if ( IsGlobalCompartPropItem( ) )
    {
        // Global compartment setting
        if ( m_pguidComp && m_dwMaskBit )
        {
            DWORD dwComp;

            _GetGlobalCompDWORD(*m_pguidComp, &dwComp);

            if ( dw )
                dwComp |= m_dwMaskBit;
            else
                dwComp &= ~m_dwMaskBit;

            _SetGlobalCompDWORD(*m_pguidComp, dwComp);
        }
    }
    else 
    {
        // Registry setting
        _SetRegValue(HKEY_CURRENT_USER, dw);
    }
}

//
// CSpPropItemsServer
//
CSpPropItemsServer::CSpPropItemsServer( )
{
    m_fInitialized = FALSE;
    m_PropItems = NULL;

}


CSpPropItemsServer::CSpPropItemsServer(CSpPropItemsServer *pItemBaseServer, PROP_ITEM_ID idPropMin, PROP_ITEM_ID idPropMax)
{
    Assert(pItemBaseServer);
    m_dwNumOfItems = 0;
    m_fInitialized = FALSE;

    m_PropItems = (CPropItem **) cicMemAlloc(((DWORD)idPropMax - (DWORD)idPropMin + 1) * sizeof(CPropItem  *));

    if ( m_PropItems )
    {
        DWORD  dwPropItemId;

        for (dwPropItemId=(DWORD)idPropMin; dwPropItemId<= (DWORD)idPropMax; dwPropItemId ++ )
        {
            // Find the propitem from the Base Server
            CPropItem  *pItem;

            pItem = pItemBaseServer->_GetPropItem((PROP_ITEM_ID)dwPropItemId);
            if ( pItem )
            {
                m_PropItems[m_dwNumOfItems] = (CPropItem *) new CPropItem(pItem);

                if ( m_PropItems[m_dwNumOfItems] )
                    m_dwNumOfItems ++;
            }
        }

        if ( m_dwNumOfItems > 0 )
            m_fInitialized = TRUE;
        else
            cicMemFree(m_PropItems);
    }
}

CSpPropItemsServer::~CSpPropItemsServer( )
{
    if ( m_PropItems )
    {
        Assert(m_dwNumOfItems);

        DWORD i;

        for ( i=0; i< m_dwNumOfItems; i++)
        {
            if ( m_PropItems[i] )
                delete m_PropItems[i];
        }

        cicMemFree(m_PropItems);
    }
}

LPCTSTR pszGetSystemMetricsKey = _T("System\\WPA\\TabletPC");
LPCTSTR pszGSMRegValue = _T("Installed");

HRESULT CSpPropItemsServer::_Initialize( )
{
    HRESULT  hr = S_OK;
    
    if ( m_fInitialized )
        return hr;

    m_dwNumOfItems = (DWORD) PropId_Max_Item_Id;

    m_PropItems = (CPropItem **) cicMemAlloc(m_dwNumOfItems * sizeof(CPropItem  *));

    if ( m_PropItems )
    {
        // Initializing the settings for all the items

        // If we add new more item later, please update this array value as well.
        PROP_ITEM  PropItems[ ] = {

            // Items in top property page
          {PropId_Cmd_Select_Correct,   c_szSelectCmd,      NULL, 0, TRUE,   PROP_ENABLED    },
          {PropId_Cmd_Navigation,       c_szNavigateCmd,    NULL, 0, TRUE,   PROP_ENABLED    },
          {PropId_Cmd_Casing,           c_szCaseCmd,        NULL, 0, TRUE,   PROP_ENABLED    },
          {PropId_Cmd_Editing,          c_szEditCmd,        NULL, 0, TRUE,   PROP_ENABLED    },
          {PropId_Cmd_Keyboard,         c_szKeyboardCmd,    NULL, 0, TRUE,   PROP_ENABLED    },
          {PropId_Cmd_TTS,              c_szTTSCmd,         NULL, 0, TRUE,   PROP_ENABLED    },
          {PropId_Cmd_Language_Bar,     c_szLangBarCmd,     NULL, 0, TRUE,   PROP_ENABLED    },
          {PropId_Cmd_DictMode,         c_szDictCmd,        NULL, 0, TRUE,   PROP_ENABLED    },
          {PropId_Mode_Button,          c_szModeButton,     NULL, 0, TRUE,   PROP_DISABLED   },

          // Items in Advanced Setting dialog
          {PropId_Hide_Balloon,         NULL, (GUID *)&GUID_COMPARTMENT_SPEECH_UI_STATUS,TF_DISABLE_BALLOON,TRUE,PROP_DISABLED},
          {PropId_Support_LMA,          c_szEnableLMA,      NULL, 0, TRUE,   PROP_ENABLED    },
          {PropId_High_Confidence,      c_szHighConf,       NULL, 0, TRUE,   PROP_ENABLED    },
          {PropId_Save_Speech_Data,     c_szSerialize,      NULL, 0, TRUE,   PROP_DISABLED   },
          {PropId_Remove_Space,         c_szRemoveSpace,    NULL, 0, TRUE,   PROP_ENABLED    },
          {PropId_DisDict_Typing,       c_szDisDictTyping,  NULL, 0, TRUE,   PROP_ENABLED    },
          {PropId_PlayBack,             c_szPlayBack,       NULL, 0, TRUE,   PROP_DISABLED   },
          {PropId_Dict_CandOpen,        c_szDictCandOpen,   NULL, 0, TRUE,   PROP_ENABLED    },
          {PropId_Max_Alternates,       c_szNumAlt,         NULL, 0, FALSE,  9               },
          {PropId_MaxChar_Cand,         c_szMaxCandChars,   NULL, 0, FALSE,  128             },

          // Items in ModeButton Setting dialog
          {PropId_Dictation_Key,        c_szDictKey,        NULL, 0, FALSE,  VK_F11          },
          {PropId_Command_Key,          c_szCmdKey,         NULL, 0, FALSE,  VK_F12          },

          // Items not in any property page and dialogs
          {PropId_Context_Feeding,      c_szCtxtFeed,       NULL, 0, TRUE,   PROP_ENABLED    },
          {PropId_Dict_ModeBias,        c_szDictModebias,   NULL, 0, TRUE,   PROP_ENABLED    },
          {PropId_LM_Master_Cand,       c_szMasterLM,       NULL, 0, TRUE,   PROP_DISABLED   },
        };

        DWORD  i;

        CMyRegKey regkey;
        DWORD dwInstalled = 0;
        BOOL fIsTabletPC = FALSE; // Default to false.

        if (S_OK == regkey.Open(HKEY_LOCAL_MACHINE, pszGetSystemMetricsKey, KEY_READ))
        {
            if (ERROR_SUCCESS == regkey.QueryValue(dwInstalled, pszGSMRegValue))
            {
                fIsTabletPC = ( dwInstalled != 0 );
                // Only set fIsTabletPC to TRUE when key exists and contains non-zero.
            }
        }

        for ( i=0; i< m_dwNumOfItems; i++ )
        {
            PROP_ITEM_ID  PropId;

            PropId = PropItems[i].idPropItem;

            // Tablet PC has different default value for some of the propitems.
            if (fIsTabletPC)
            {
                switch (PropId)
                {
                case PropId_Cmd_DictMode :
                case PropId_DisDict_Typing :
                    PropItems[i].psDefault = PROP_DISABLED;
                    break;

                case PropId_Max_Alternates :
                    PropItems[i].dwDefault = 6;
                    break;

                default:
                    // keep the same setting for other items.
                    break;
                }
            }

            if ( PropItems[i].pguidComp )
            {
                // This is global compartment setting
                m_PropItems[i] = (CPropItem *)new CPropItem(PropId, PropItems[i].pguidComp, PropItems[i].dwMaskBit, PropItems[i].psDefault);
            }
            else
            {
                if ( PropItems[i].fIsStatus )
                    m_PropItems[i] = (CPropItem *)new CPropItem(PropId, PropItems[i].lpszValueName, PropItems[i].psDefault);
                else
                    m_PropItems[i] = (CPropItem *)new CPropItem(PropId, PropItems[i].lpszValueName, PropItems[i].dwDefault);
            }

            if ( !m_PropItems[i] )
            {
                hr = E_OUTOFMEMORY;

                // Release the allocated memory

                for ( ; i> 0; i-- )
                {
                    if ( m_PropItems[i-1] )
                        delete m_PropItems[i-1];
                }

                cicMemFree(m_PropItems);
                break;
            }
        }

        if ( hr == S_OK )
            m_fInitialized = TRUE;
    }


    if ( m_fInitialized )
        hr = S_OK;
    else
        hr = E_FAIL;

    return hr;
}


CPropItem  *CSpPropItemsServer::_GetPropItem(PROP_ITEM_ID idPropItem)
{
    CPropItem    *pItem = NULL;

    if ( !m_fInitialized )
        _Initialize( );

    if ( m_fInitialized )
    {
        for ( DWORD i=0; i< m_dwNumOfItems; i++)
        {
            if ( m_PropItems[i] && (idPropItem == m_PropItems[i]->GetPropItemId( )) )
            {
                // Found it.
                pItem = m_PropItems[i];
                break;
            }
        }
    }

    return pItem;
}

DWORD CSpPropItemsServer::_GetPropData(PROP_ITEM_ID idPropItem, BOOL fForceFromReg )
{
    DWORD         dwRet = 0;
    CPropItem    *pItem = NULL;

    pItem = _GetPropItem(idPropItem);

    if ( pItem )
    {
        if ( pItem->IsStatusPropItem( ) )
            dwRet = pItem->GetPropStatus(fForceFromReg);
        else
            dwRet = pItem->GetPropValue(fForceFromReg);
    }

    return dwRet;
}

DWORD CSpPropItemsServer::_GetPropDefaultData(PROP_ITEM_ID idPropItem )
{
    DWORD         dwRet = 0;
    CPropItem    *pItem = NULL;

    pItem = _GetPropItem(idPropItem);

    if ( pItem )
    {
        if ( pItem->IsStatusPropItem( ) )
            dwRet = pItem->GetPropDefaultStatus( );
        else
            dwRet = pItem->GetPropDefaultValue( );
    }

    return dwRet;
}
void  CSpPropItemsServer::_SetPropData(PROP_ITEM_ID idPropItem, DWORD dwData )
{
    Assert(m_fInitialized);
    Assert(m_PropItems);

    CPropItem    *pItem = NULL;

    pItem = _GetPropItem(idPropItem);

    if ( pItem )
    {
        if ( pItem->IsStatusPropItem( ) )
            pItem->SetPropStatus((BOOL)dwData);
        else
            pItem->SetPropValue(dwData);
    }
}

//
// Save all the property data managed by this server to registry or global compartment
//
// when Apply or OK buttons on the property page is pressed, 
// this function will be called.
//
void  CSpPropItemsServer::_SavePropData( )
{
    Assert(m_fInitialized);
    Assert(m_PropItems);

    CPropItem    *pItem = NULL;

    for ( DWORD i=0; i<m_dwNumOfItems; i++ )
    {
        pItem = m_PropItems[i];

        if ( pItem )
        {
            pItem->SavePropData( );
        }
    }
}

//
//
// Save all the default value to HKLM registry
// Self-Registration will call this method to set default value for all the properties.
//
//
void CSpPropItemsServer::_SaveDefaultData( )
{
    if ( !m_fInitialized )
        _Initialize( );

    if ( m_fInitialized && m_PropItems )
    {
        CPropItem    *pItem = NULL;

        for ( DWORD i=0; i<m_dwNumOfItems; i++ )
        {
            pItem = m_PropItems[i];

            if ( pItem )
                pItem->SaveDefaultRegValue( );
        }
    }
}

//
// Merge some prop data form other items server
//
// When a property item data is changed in Advanced or Mode button dialog, since these dialogs have 
// their own property server, all these changes need to be merged back to the base property server,
// so that they can be saved to the registry when user click "Apply" or "OK" in the top property page.
//

HRESULT CSpPropItemsServer::_MergeDataFromServer(CSpPropItemsServer *pItemBaseServer, PROP_ITEM_ID idPropMin, PROP_ITEM_ID idPropMax)
{
    HRESULT  hr = S_OK;

    Assert(pItemBaseServer);

    DWORD  dwData, idPropItem;

    for ( idPropItem=(DWORD)idPropMin; idPropItem<= (DWORD)idPropMax; idPropItem++)
    {
        dwData =  pItemBaseServer->_GetPropData((PROP_ITEM_ID)idPropItem);
        _SetPropData((PROP_ITEM_ID)idPropItem, dwData);
    }

    return hr;
}

//
//
// CSpPropItemsServerWrap
//

//
// Update our internal data members from Registry.
//
// When sapilayr TIP gets notified of the change of the registry value,
// it will call this method to renew its internal data with new registry data.
//
void    CSpPropItemsServerWrap::_RenewAllPropDataFromReg( )
{
    DWORD  dwPropItem;

    for (dwPropItem=(DWORD)PropId_Min_Item_Id; dwPropItem < (DWORD)PropId_Max_Item_Id; dwPropItem ++ )
    {
        DWORD  dwOldValue, dwNewValue;

        dwOldValue = _GetPropData((PROP_ITEM_ID)dwPropItem, FALSE);

        // Update the value by forcelly getting it from registry.
        dwNewValue = _GetPropData((PROP_ITEM_ID)dwPropItem, TRUE);
        m_bChanged[dwPropItem] = (dwOldValue != dwNewValue ? TRUE : FALSE);
    }
}

//
//
//
//
ULONG CSpPropItemsServerWrap::_GetMaxAlternates( )
{
    ULONG  ulMaxAlts;

    ulMaxAlts = _GetPropData(PropId_Max_Alternates);

    if ( ulMaxAlts > MAX_ALTERNATES_NUM || ulMaxAlts == 0 )
        ulMaxAlts = MAX_ALTERNATES_NUM;

    return ulMaxAlts;
}


//
// ULONG  CBestPropRange::_GetMaxCandidateChars( )
//
//
ULONG  CSpPropItemsServerWrap::_GetMaxCandidateChars( )
{
    ULONG ulMaxCandChars;

    ulMaxCandChars = _GetPropData(PropId_MaxChar_Cand);

    if ( ulMaxCandChars > MAX_CANDIDATE_CHARS || ulMaxCandChars == 0 )
        ulMaxCandChars = MAX_CANDIDATE_CHARS;

    return ulMaxCandChars;
}

BOOL    CSpPropItemsServerWrap::_AllCmdsEnabled( )
{
    BOOL  fEnable;

    fEnable = _SelectCorrectCmdEnabled( ) &&
              _NavigationCmdEnabled( ) &&
              _CasingCmdEnabled( ) &&
              _EditingCmdEnabled( ) &&
              _KeyboardCmdEnabled( ) &&
              _TTSCmdEnabled( ) &&
              _LanguageBarCmdEnabled( );

    return fEnable;
}


BOOL CSpPropItemsServerWrap::_AllCmdsDisabled( )
{
    BOOL  fDisable;

    fDisable = !_SelectCorrectCmdEnabled( ) &&
               !_NavigationCmdEnabled( ) &&
               !_CasingCmdEnabled( ) &&
               !_EditingCmdEnabled( ) &&
               !_KeyboardCmdEnabled( ) &&
               !_TTSCmdEnabled( ) &&
               !_LanguageBarCmdEnabled( );

    return fDisable;



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\propitem.h ===
//
#ifndef _PROPITEM_H
#define  _PROPITEM_H

const TCHAR c_szNumAlt[]           = TEXT("NumAlt");
const TCHAR c_szMasterLM[]         = TEXT("MasterLM");
const TCHAR c_szCtxtFeed[]         = TEXT("ContextFeed");
const TCHAR c_szEnableLMA[]        = TEXT("EnableLMA");
const TCHAR c_szSerialize[]        = TEXT("Serialize");
const TCHAR c_szDictModebias[]     = TEXT("DictModebias");

// const TCHAR c_szDocBlockSize[]     = TEXT("docblocksize");
// const TCHAR c_szMaxCandChars[]     = TEXT("MaxCandChars");

const TCHAR c_szDictCmd[]          = TEXT("DictationCommands"); // Enable / Disbale commands in Dictation mode
const TCHAR c_szKeyboardCmd[]      = TEXT("KeyboardCmd");
const TCHAR c_szSelectCmd[]        = TEXT("SelectCmd");
const TCHAR c_szNavigateCmd[]      = TEXT("NavigateCmd");
const TCHAR c_szCaseCmd[]          = TEXT("CasingCmd");
const TCHAR c_szEditCmd[]          = TEXT("EditCmd");
const TCHAR c_szLangBarCmd[]       = TEXT("LangBarCmd");
const TCHAR c_szTTSCmd[]           = TEXT("TTSCmd");
 
const TCHAR c_szModeButton[]       = TEXT("ModeButton");
const TCHAR c_szDictKey[]          = TEXT("DictationKey");
const TCHAR c_szCmdKey[]           = TEXT("CommandKey");

const TCHAR c_szHighConf[]         = TEXT("HighConfidenceForShortWord");
const TCHAR c_szRemoveSpace[]      = TEXT("RemoveSpaceForSymbol");
const TCHAR c_szDisDictTyping[]    = TEXT("DisableDictTyping");
const TCHAR c_szPlayBack[]         = TEXT("PlayBackCandUI");
const TCHAR c_szDictCandOpen[]     = TEXT("DictCandOpen");
                                          
#define  UNINIT_VALUE    0xffff

// 
// Take use of the below enum type as a common status type to replace 
// the many previous similar enum types for different individual items, 
// such as KEYCMD,  LMSTAT, GSTAT, DICTCMD, etc.
// 
typedef enum
{
    PROP_UNINITIALIZED  = 0x0,
    PROP_ENABLED        = 0x1,   
    PROP_DISABLED       = 0x2    
} PROP_STATUS;

typedef enum
{
    PropId_Min_Item_Id          = 0,

    // Property Items in the top property page.
    PropId_Min_InPropPage       = 0,
    PropId_Hide_Balloon         = 0,            // Enable/Disable hiding speech balloon
    PropId_Support_LMA          = 1,            // Enable/Disable LMA Support
    PropId_High_Confidence      = 2,            // Require High Confidence for short words
    PropId_Save_Speech_Data     = 3,            // Enable/Disable Save Speech Data 
    PropId_Remove_Space         = 4,            // Enable removing whitespace for punctations
    PropId_DisDict_Typing       = 5,            // Support disabling dictation while typing
    PropId_PlayBack             = 6,            // Enable playback audio while candidate UI is to open.
    PropId_Dict_CandOpen        = 7,            // Allow dictation while candidate UI is open.
    PropId_Cmd_DictMode         = 8,            // Enable/Disable all commands in dictation mode
    PropId_Mode_Button          = 9,            // Enable/Disable Mode Buttons
    PropId_MaxId_InPropPage     = 9,

    // Property Items in the voice command setting dialog
    PropId_MinId_InVoiceCmd     = 10,
    PropId_Cmd_Select_Correct   = 10,             // Enable/Disable Selection commands
    PropId_Cmd_Navigation       = 11,            // Enalbe/Disable Navigation commands
    PropId_Cmd_Casing           = 12,            // Enable/Disable Casing Commands
    PropId_Cmd_Editing          = 13,            // Enable/Disable Editing Commands
    PropId_Cmd_Keyboard         = 14,            // Enable/Disable Keyboard simulation commands
    PropId_Cmd_TTS              = 15,            // Enable/Disable TTS commands
    PropId_Cmd_Language_Bar     = 16,            // Enable/Disalbe Langauge Bar commands
    PropId_MaxId_InVoiceCmd     = 16,

    // Property Items in the Mode button setting dialog
    PropId_MinId_InModeButton   = 17,
    PropId_Dictation_Key        = 17,           // Virtual key for Dictation Key
    PropId_Command_Key          = 18,           // Virtual key for Command Key
    PropId_MaxId_InModeButton   = 18,

    // Property items which are not configurable through property page.
    PropId_Max_Alternates       = 19,           // Maximum number of alternates
    PropId_MaxChar_Cand         = 20,           // Maximum number of candidate characters
    PropId_Context_Feeding      = 21,            // Enable/Disable Context Feeding
    PropId_Dict_ModeBias        = 22,            // Enable/Disable Dictation while ModeBias
    PropId_LM_Master_Cand       = 23,            // Enable/Disable Master LM for candidates

    PropId_Max_Item_Id          = 24

} PROP_ITEM_ID;


typedef struct _Prop_Item
{
    PROP_ITEM_ID       idPropItem;
    const TCHAR       *lpszValueName;

    GUID               *pguidComp;
    DWORD              dwMaskBit;
    BOOL               fIsStatus;      // TRUE means this is Enable/Disable item
                                       // FALSE means this is a value item, DWORD
    union 
    {
        DWORD          dwDefault;
        PROP_STATUS    psDefault;
    };

}  PROP_ITEM;


class _declspec(novtable) CPropItem
{
public: 
    CPropItem(PROP_ITEM_ID idPropItem, LPCTSTR lpszValueName, PROP_STATUS psDefault);
    CPropItem(PROP_ITEM_ID idPropItem, LPCTSTR lpszValueName, DWORD       dwDefault);
    CPropItem(PROP_ITEM_ID idPropItem, GUID *pguidComp, DWORD  dwMaskBit,   PROP_STATUS  psDefault);
    CPropItem(CPropItem *pItem);
    ~CPropItem( );

    BOOL  GetPropStatus(BOOL fForceFromReg=FALSE);
    DWORD GetPropValue(BOOL fForceFromReg=FALSE );

    void SetPropStatus(BOOL fEnable);
    void SetPropValue(DWORD dwValue);

    void SavePropData( );
    void SaveDefaultRegValue( );

    BOOL IsStatusPropItem( ) { return m_fIsStatus; }
    PROP_ITEM_ID GetPropItemId( ) {  return m_PropItemId; }

    BOOL IsGlobalCompartPropItem( )  { return ((m_pguidComp && !m_lpszValueName) ? TRUE : FALSE); }

    TCHAR  *GetRegValue( )  { return m_lpszValueName; }
    GUID   *GetCompGuid( )  { return m_pguidComp; }
    DWORD  GetMaskBit( )    { return m_dwMaskBit; }

    PROP_STATUS  GetPropDefaultStatus( ) { return  m_psDefault; }
    DWORD        GetPropDefaultValue( )  { return m_dwDefault; }
    
private:

    HRESULT   _GetRegValue(HKEY  hRootKey, DWORD  *dwValue);
    void      _SetRegValue(HKEY  hRootKey, DWORD  dwValue);

    PROP_ITEM_ID   m_PropItemId;
    TCHAR         *m_lpszValueName;
    GUID          *m_pguidComp;
    DWORD          m_dwMaskBit;
    BOOL           m_fIsStatus;  // TRUE means this prop keeps bool (Enable/Disable).
                                 // FALSE means this prop keeps raw data (ulong).
    union 
    {
        DWORD        m_dwDefault;
        PROP_STATUS  m_psDefault;
    };

    union 
    {
        DWORD        m_dwValue;
        PROP_STATUS  m_psStatus;
    };
};

        
class __declspec(novtable) CSpPropItemsServer
{
public:
    CSpPropItemsServer( );
    CSpPropItemsServer(CSpPropItemsServer *pItemBaseServer, PROP_ITEM_ID idPropMin, PROP_ITEM_ID idPropMax);
    ~CSpPropItemsServer( );

    CPropItem  *_GetPropItem(PROP_ITEM_ID idPropItem);
    DWORD   _GetPropData(PROP_ITEM_ID idPropItem, BOOL fForceFromReg=FALSE );
    DWORD   _GetPropDefaultData(PROP_ITEM_ID idPropItem);
    void    _SetPropData(PROP_ITEM_ID idPropItem, DWORD dwData);
    
    void    _SavePropData(  );
    void    _SaveDefaultData( );

    DWORD   _GetNumPropItems( ) { return m_dwNumOfItems; }
    HRESULT _MergeDataFromServer(CSpPropItemsServer *pItemBaseServer, PROP_ITEM_ID idPropMin, PROP_ITEM_ID idPropMax);

private:

    HRESULT      _Initialize( );

    CPropItem    **m_PropItems;
    BOOL         m_fInitialized;
    DWORD        m_dwNumOfItems;
};

// 
// This is a server wrap derived by CSapiIMX.
//
class __declspec(novtable) CSpPropItemsServerWrap : public CSpPropItemsServer
{
public:
    CSpPropItemsServerWrap( )
    {
#if 0
        for (DWORD i=0; i<(DWORD)PropId_Max_Item_Id; i++)
            m_bChanged[i] = FALSE;
#else
        memset(m_bChanged, 0, sizeof(m_bChanged));
#endif    
    };

    ~CSpPropItemsServerWrap( ){ };

    ULONG   _GetMaxAlternates( );
    ULONG   _GetMaxCandidateChars( );

    BOOL    _MasterLMEnabled( ) { return (BOOL)_GetPropData(PropId_LM_Master_Cand); }

    BOOL    _ContextFeedEnabled( ) { return (BOOL)_GetPropData(PropId_Context_Feeding); }

    BOOL    _IsModeBiasDictationEnabled( ) { return (BOOL) _GetPropData(PropId_Dict_ModeBias); }

    BOOL    _SerializeEnabled( ) { return (BOOL) _GetPropData(PropId_Save_Speech_Data);}

    BOOL    _LMASupportEnabled( ) { return (BOOL) _GetPropData(PropId_Support_LMA); }

    BOOL    _RequireHighConfidenceForShorWord( ) { return (BOOL) _GetPropData(PropId_High_Confidence); }

    BOOL    _NeedRemovingSpaceForPunctation( ) {  return (BOOL) _GetPropData(PropId_Remove_Space);}

    BOOL    _NeedDisableDictationWhileTyping( ) {  return (BOOL) _GetPropData(PropId_DisDict_Typing); }

    BOOL    _EnablePlaybackWhileCandUIOpen( ) {return (BOOL) _GetPropData(PropId_PlayBack); }

    BOOL    _AllowDictationWhileCandOpen( ) { return (BOOL) _GetPropData(PropId_Dict_CandOpen); }

    BOOL    _SelectCorrectCmdEnabled( )  { return (BOOL) _GetPropData(PropId_Cmd_Select_Correct); }

    BOOL    _NavigationCmdEnabled( ) { return (BOOL) _GetPropData(PropId_Cmd_Navigation); }

    BOOL    _CasingCmdEnabled( )  { return (BOOL) _GetPropData(PropId_Cmd_Casing); }

    BOOL    _EditingCmdEnabled( )  { return (BOOL) _GetPropData(PropId_Cmd_Editing); }

    BOOL    _KeyboardCmdEnabled( ) { return (BOOL) _GetPropData(PropId_Cmd_Keyboard); }

    BOOL    _TTSCmdEnabled( )  { return (BOOL) _GetPropData(PropId_Cmd_TTS); }

    BOOL    _LanguageBarCmdEnabled( )  { return (BOOL) _GetPropData(PropId_Cmd_Language_Bar); }

    BOOL    _AllDictCmdsDisabled( ) { return !(BOOL) _GetPropData(PropId_Cmd_DictMode); }

    BOOL    _AllCmdsEnabled( );  
    BOOL    _AllCmdsDisabled( );
    void    _RenewAllPropDataFromReg( );

    BOOL    _IsModeKeysEnabled( ) { return (BOOL) _GetPropData(PropId_Mode_Button); }

    DWORD   _GetDictationButton( ) { return _GetPropData(PropId_Dictation_Key); }

    DWORD   _GetCommandButton( ) { return _GetPropData(PropId_Command_Key); }

    BOOL    _IsPropItemChangedSinceLastRenew(PROP_ITEM_ID idPropItem)  { return m_bChanged[(DWORD)idPropItem]; }

private:

    BOOL    m_bChanged[(DWORD)PropId_Max_Item_Id];  // indicates if the items have been changed since last
                                                    // renew from Registry.
};
#endif // _PROPITEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\propstor.h ===
//
// property store class implementation
//

#ifndef PROPSTOR_H
#define PROPSTOR_H

#include "strary.h"

extern const IID IID_PRIV_RESULTWRAP;

typedef enum 
{
    DivideNormal = 1,
    DivideInsideFirstElement=2 ,
    DivideInDelta = 3,
    CurRangeNoElement = 4,

}  DIVIDECASE;


// A Data structure to keep the ITN position and showstate.

typedef struct _tagSPITNSHOWSTATE
{
    ULONG     ulITNStart;
    ULONG     ulITNNumElem;
    BOOL      fITNShown;
} SPITNSHOWSTATE;

// A Data Structure to keep the data in Reco Wrapper which will be saved during serialization.

typedef struct _tagRecoWrapData
{

    ULONG  ulSize;  // size of this structure + plus the size of text string in bytes.
    ULONG  ulStartElement;
    ULONG  ulNumElements;
    ULONG  ulOffsetDelta;
    ULONG  ulCharsInTrail;
    ULONG  ulTrailSpaceRemoved;
    ULONG  ulNumOfITN;
    ULONG  ulOffsetNum;
    SPITNSHOWSTATE *pITNShowState;
    ULONG  *pulOffset;
    WCHAR  *pwszText;

}  RECOWRAPDATA;

class CSapiIMX;

//
// A wrapper object for ISpRecoResult used to 
// track what portion of a phrase object is being
// used for the range
//
class CRecoResultWrap : public IServiceProvider
{
public:
    CRecoResultWrap(CSapiIMX *pimx, ULONG ulStartElement, ULONG ulNumElements, ULONG ulNumOfITN) ;

    ~CRecoResultWrap();

    // IUnknown
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // IServiceProvider
    STDMETHODIMP QueryService( REFGUID guidService,  REFIID riid,  void** ppv );


    // Clone this object.
    HRESULT Clone(CRecoResultWrap **ppRw);
    
    // APIs
    HRESULT Init(ISpRecoResult *pRecoResult);

    ULONG   GetStart(void)       {return m_ulStartElement;}
    ULONG   GetNumElements(void) {return m_ulNumElements;}

    HRESULT GetResult(ISpRecoResult **ppRecoResult );

    BOOL   IsElementOffsetIntialized( ) {  return m_pulElementOffsets == NULL ? FALSE : TRUE; }

    void    SetStart(ULONG ulStartElement )  {  m_ulStartElement = ulStartElement; return; }
    void    SetNumElements(ULONG ulNumElements ) { m_ulNumElements = ulNumElements; return; }
    void    SetOffsetDelta( ULONG  delta ) { m_OffsetDelta = delta; return; }

    ULONG   _GetOffsetDelta( ) { return m_OffsetDelta; }

    void    SetCharsInTrail( ULONG  ulCharsInTrail ) { m_ulCharsInTrail = ulCharsInTrail; }
    ULONG   GetCharsInTrail( ) { return m_ulCharsInTrail; }

    ULONG   GetTrailSpaceRemoved( ) {  return m_ulTrailSpaceRemoved; }
    void    SetTrailSpaceRemoved( ULONG ulTrailSpaceRemoved ) { m_ulTrailSpaceRemoved = ulTrailSpaceRemoved; return; }
    
    HRESULT _SpeakAudio(ULONG ulStart, ULONG ulcElem);
    
    ULONG   _GetElementOffsetCch(ULONG ulElement);
    void    _SetElementOffsetCch(ISpPhraseAlt *pAlt);

    HRESULT _SetElementNewOffset(ULONG  ulElement, ULONG ulNewOffset);

    ULONG   _RangeHasITN(ULONG  ulStartElement, ULONG  ulNumElements);
    
    BOOL    _CheckITNForElement(SPPHRASE *pPhrase, ULONG ulElement, ULONG *pulITNStart, ULONG *pulITNNumElem, CSpDynamicString *pdstrReplace); 

    BYTE    _GetElementDispAttribute(ULONG  ulElement);

    HRESULT  _InitITNShowState(BOOL  fITNShown, ULONG ulITNStart, ULONG ulITNNumElements);
    HRESULT  _InvertITNShowStateForRange( ULONG  ulStartElement,  ULONG ulNumElements );

    HRESULT  _UpdateStateWithAltPhrase( ISpPhraseAlt  *pSpPhraseAlt );

    void  _UpdateInternalText(ISpPhrase *pPhrase);
    BOOL  _CanIgnoreChange(ULONG ich, WCHAR *pszChange, int cch);

    ULONG m_ulNumOfITN;         // the number of ITN in this range ( from start element to end element in this recowrap.

    CStructArray<SPITNSHOWSTATE> m_rgITNShowState;  

    BSTR  m_bstrCurrentText;     // the current text for the parent pharse
    
private:

    CSapiIMX *m_pimx;

    ULONG m_ulStartElement;
    ULONG m_ulNumElements;
    
    ULONG *m_pulElementOffsets;

    ULONG  m_OffsetDelta;         // This is for Divide use,  if prop is divided at a middle of an element,
                                  // this element would be discarded, but we need to keep the char number of the rest in this element,
                                  // so that the next range would keep correct offsets for every element.

    ULONG  m_ulCharsInTrail;      // This will keep the number of trailing part which is at the end part of the 
                                  // current parent text, and is not in any valid phrase element.
                                  // By default this value is 0.

    //
    //  Now a whole parent text would be composed of following three parts:
    //           Delta part   +  valid elements  + Trailing Part.
    //
    //  For example:   the original parent text is "This is a good example for testing ".
    //  After divided many times, it could become to the new string like:
    //
    //                  "s is a good example for tes"
    //
    //  Here "s " is Delta part.
    //       "a good example for " is composed of valid elements. ( and can be change by correction later)
    //       "tes"  is trailing part.
    //
    //  m_OffsetDelta will keep the number of characters in Delta part.
    //  m_ulCharsInTrail will keep the number of characters in Trailing part.
    //

    ULONG   m_ulTrailSpaceRemoved;  // Keep the number of trailing spaces which were
                                    // removed from the original phrase text.

                                    // The Initialize value for this data member is 0,
                                    // But after Property Divided or Shrinked, the new 
                                    // property range could have some trailing spaces
                                    // removed, and this data memeber needs to update.

    SPSERIALIZEDRESULT *m_pSerializedRecoResult;

    int m_cRef;

#ifdef DEBUG
    DWORD m_dbg_dwId;
#endif // DEBUG
};

//
// [12/21/99 - implementing propstore for non-serialized SAPI result object]
//
//
class CPropStoreRecoResultObject: public ITfPropertyStore
{
public:
    CPropStoreRecoResultObject(CSapiIMX *pimx, ITfRange *pRange);
    ~CPropStoreRecoResultObject();

    // IUnknown
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ITfPropertyStore
    STDMETHODIMP GetType(GUID *pguid);
    STDMETHODIMP GetDataType(DWORD *pdwReserved);
    STDMETHODIMP GetData(VARIANT *pvarValue);
    STDMETHODIMP OnTextUpdated(DWORD dwFlags, ITfRange *pRange, BOOL *pfAccept);
    STDMETHODIMP Shrink(ITfRange *pRange, BOOL *pfFree);
    STDMETHODIMP Divide(ITfRange *pRangeThis, ITfRange *pRangeNew, ITfPropertyStore **ppPropStore);
    STDMETHODIMP Clone(ITfPropertyStore **ppPropStore);
    STDMETHODIMP GetPropertyRangeCreator(CLSID *pclsid);
    STDMETHODIMP Serialize(IStream *pStream, ULONG *pcb);

    // public APIs
    HRESULT _InitFromRecoResult(ISpRecoResult *pResult, RECOWRAPDATA *pRecoWrapData);
    HRESULT _InitFromIStream(IStream *pStream, int iSize, ISpRecoContext *pRecoCtxt);
    HRESULT _InitFromResultWrap(IUnknown  *pResWrap);

    HRESULT _Divide(TfEditCookie ec, ITfRange *pR1, ITfRange *pR2, ITfPropertyStore **ppPs);
    HRESULT _Shrink(TfEditCookie ec, ITfRange *pRange,BOOL *pfFree);
    HRESULT _OnTextUpdated(TfEditCookie ec, DWORD dwFlags, ITfRange *pRange, BOOL *pfAccept);

private:

    CComPtr<IUnknown>           m_cpResultWrap;
    CComPtr<ITfRange>           m_cpRange;
    
    CSapiIMX                   *m_pimx;

    int m_cRef;
};

class CPropStoreLMLattice: public ITfPropertyStore
{
public:
    CPropStoreLMLattice(CSapiIMX *pimx);
    ~CPropStoreLMLattice();

    // IUnknown
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ITfPropertyStore
    STDMETHODIMP GetType(GUID *pguid);
    STDMETHODIMP GetDataType(DWORD *pdwReserved);
    STDMETHODIMP GetData(VARIANT *pvarValue);
    STDMETHODIMP OnTextUpdated(DWORD dwFlags, ITfRange *pRange, BOOL *pfAccept);
    STDMETHODIMP Shrink(ITfRange *pRange, BOOL *pfFree);
    STDMETHODIMP Divide(ITfRange *pRangeThis, ITfRange *pRangeNew, ITfPropertyStore **ppPropStore);
    STDMETHODIMP Clone(ITfPropertyStore **ppPropStore);
    STDMETHODIMP GetPropertyRangeCreator(CLSID *pclsid);
    STDMETHODIMP Serialize(IStream *pStream, ULONG *pcb);

    // public APIs
    HRESULT _InitFromResultWrap(IUnknown  *pResWrap);

    HRESULT _Divide(TfEditCookie ec, ITfRange *pR1, ITfRange *pR2, ITfPropertyStore **ppPs);
private:

    CComPtr<IUnknown>           m_cpResultWrap;
    CComPtr<ITfLMLattice>       m_cpLMLattice;
    
    CSapiIMX                   *m_pimx;
    int m_cRef;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\recosleep.cpp ===
// RecoSleep.cpp : implement "Go to Sleep" and "Wakeup" commands.

#include "private.h"
#include "globals.h"
#include "RecoSleep.h"
#include "mui.h"
#include "ids.h"
#include "cicspres.h"

CRecoSleepClass::CRecoSleepClass(CSpTask *pSpTask) 
{
    Assert(pSpTask);

    m_pSpTask = pSpTask;
    m_pSpTask->AddRef( );

    StringCchCopyW(m_wszRule, ARRAYSIZE(m_wszRule), L"SleepRule");
    m_wszSleep[0] = L'\0';
    m_wszWakeup[0] = L'\0';
    m_fSleeping = FALSE;
    m_Initialized = FALSE;
}

CRecoSleepClass::~CRecoSleepClass( )
{
    if ( m_cpRecoContext )
        m_cpRecoContext->SetNotifySink(NULL);

    SafeRelease(m_pSpTask);
}

HRESULT CRecoSleepClass::InitRecoSleepClass( )
{
    HRESULT  hr = S_OK;

    if ( m_Initialized )
        return hr;

    Assert(m_pSpTask);

    // Get the same Recognizer instance from CSpTask.

    hr = m_pSpTask->GetSAPIInterface(IID_ISpRecognizer, (void **)&m_cpRecoEngine);

    if ( SUCCEEDED(hr) )
        hr = m_cpRecoEngine->CreateRecoContext(&m_cpRecoContext);

    // set recognition notification
    CComPtr<ISpNotifyTranslator> cpNotify;
    hr = cpNotify.CoCreateInstance(CLSID_SpNotifyTranslator);

    // set this class instance to notify control object
    if (SUCCEEDED(hr))
        hr = cpNotify->InitCallback( NotifyCallback, 0, (LPARAM)this );

    if (SUCCEEDED(hr))
        hr = m_cpRecoContext->SetNotifySink(cpNotify);

    // set the events we're interested in
    if( SUCCEEDED( hr ) )
    {
        const ULONGLONG ulInterest = SPFEI(SPEI_RECOGNITION); 
        hr = m_cpRecoContext->SetInterest(ulInterest, ulInterest);
    }

    m_fSleeping = FALSE;

    CicLoadStringWrapW(g_hInst, IDS_GO_TO_SLEEP,   m_wszSleep,  ARRAYSIZE(m_wszSleep));
    CicLoadStringWrapW(g_hInst, IDS_WAKE_UP,       m_wszWakeup, ARRAYSIZE(m_wszWakeup));

    hr = m_cpRecoContext->CreateGrammar(GRAM_ID_SLEEP, &m_cpSleepGrammar);

    //Create the sleep dynamic rule
    if (SUCCEEDED(hr))
       hr = m_cpSleepGrammar->GetRule(m_wszRule, 0, SPRAF_TopLevel | SPRAF_Active, TRUE, &m_hSleepRule);

    if (SUCCEEDED(hr))
        hr = m_cpSleepGrammar->SetRuleState(NULL, NULL, SPRS_INACTIVE);

    if (SUCCEEDED(hr))
        hr = m_cpSleepGrammar->ClearRule(m_hSleepRule);

    if (SUCCEEDED(hr))
        hr = m_cpSleepGrammar->AddWordTransition(m_hSleepRule, NULL, m_wszSleep, L" ", SPWT_LEXICAL, 1.0, NULL);

    if (SUCCEEDED(hr))
        hr = m_cpSleepGrammar->AddWordTransition(m_hSleepRule, NULL, m_wszWakeup, L" ", SPWT_LEXICAL, 1.0, NULL);

    if (SUCCEEDED(hr))
        hr = m_cpSleepGrammar->Commit(NULL);

    if (SUCCEEDED(hr))
        hr = m_cpSleepGrammar->SetRuleState(NULL, NULL, SPRS_ACTIVE);

    if ( SUCCEEDED(hr) )
        m_Initialized = TRUE;

    return hr;
}

void CRecoSleepClass::NotifyCallback(WPARAM wParam, LPARAM lParam )
{
    CRecoSleepClass *_this = (CRecoSleepClass *)lParam;
    CSpEvent event;

    if ( !_this->m_cpRecoContext)
        return;

    while (event.GetFrom(_this->m_cpRecoContext) == S_OK)
    {
        // We just care about SPEI_RECOGNITION event.
        if (event.eEventId == SPEI_RECOGNITION)
        {
            CComPtr<ISpRecoResult> cpRecoResult = event.RecoResult();
            if (cpRecoResult)
            {
                SPPHRASE *pPhrase = NULL;
                if (S_OK == cpRecoResult->GetPhrase(&pPhrase) )
                {
                    _this->ProcessSleepGrammar(pPhrase);
                    CoTaskMemFree(pPhrase);
                }
            }
        }
    }

    return;
}

HRESULT CRecoSleepClass::ProcessSleepGrammar( SPPHRASE *pPhrase )
{
    HRESULT hr = S_OK;

    Assert(pPhrase);
    ULONGLONG   ullGramId = pPhrase->ullGrammarID;

    if ( ullGramId != GRAM_ID_SLEEP )
        return hr;

    // Check the rule name 
    if (0 == wcscmp(pPhrase->Rule.pszName, m_wszRule) )
    {
        ULONG   ulStartElem, ulNumElems;
        CSpDynamicString dstrCommand;
               
        ulStartElem = pPhrase->Rule.ulFirstElement;
        ulNumElems = pPhrase->Rule.ulCountOfElements;

        for (ULONG i = ulStartElem; i < ulStartElem + ulNumElems; i++ )
        {
            if ( pPhrase->pElements[i].pszDisplayText)
            {
                BYTE bAttr = pPhrase->pElements[i].bDisplayAttributes;

                dstrCommand.Append(pPhrase->pElements[i].pszDisplayText);

                if ( i < ulStartElem + ulNumElems-1 )
                {
                    if (bAttr & SPAF_ONE_TRAILING_SPACE)
                        dstrCommand.Append(L" ");
                    else if (bAttr & SPAF_TWO_TRAILING_SPACES)
                        dstrCommand.Append(L"  ");
                }
            }
        }

        if ( dstrCommand )
        {
            BOOL   fProcessed = FALSE;

            if ((!wcscmp(dstrCommand, m_wszSleep)) && (!m_fSleeping))
            {
                hr = m_cpSleepGrammar->SetGrammarState(SPGS_EXCLUSIVE);
                m_fSleeping = TRUE;
                TraceMsg(TF_ALWAYS, "SetGrammarState to SPGS_EXCLUSIVE, hr=%x", hr);
                fProcessed = TRUE;
            }
            else if ((!wcscmp(dstrCommand, m_wszWakeup)) && (m_fSleeping))
            {
                hr = m_cpSleepGrammar->SetGrammarState(SPGS_ENABLED);
                m_fSleeping = FALSE;
                TraceMsg(TF_ALWAYS, "SetGrammarState to SPGS_ENABLED, hr=%x", hr);
                fProcessed = TRUE;
            }

            if ( fProcessed )
                m_pSpTask->_ShowCommandOnBalloon(pPhrase);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\proppage.h ===
#ifndef _PROPPAGE_H
#define _PROPPAGE_H

#include "Sapilayr.h"   
#ifdef USE_IPROPERTYPAGE
#include "atlctl.h"
#endif // USE_IPROPERTYPAGE
#include "sptiphlp.h"
extern CComModule _Module;
#include "atlwin.h"

typedef struct _ControlID_PropID_Mapping
{
    WORD            idCtrl;
    PROP_ITEM_ID    idPropItem;
    BOOL            fEdit;     // TRUE means this is a edit control
                               // FALS means this is a check control
}  CONTROL_PROP_MAP;

typedef struct _KeyName_VK_Map
{
    LPCTSTR        pKeyName;
    WORD           wVKey;
}  KEYNAME_VK_MAP;

class CSpAdvanceSetting;
class CSpModeButtonSetting;

#ifdef USE_IPROPERTYPAGE

/////////////////////////////////////////////////////////////////////////////
// CSpPropertyPage
class  CSpPropertyPage :// public IPropertyPage,
                        public CComObjectRoot,
                        public CComCoClass<CSpPropertyPage, &CLSID_SpPropertyPage>,
                        public IPropertyPageImpl<CSpPropertyPage>,
                        public CDialogImpl<CSpPropertyPage>
{
public:
	CSpPropertyPage();
	~CSpPropertyPage();

    enum {IDD = IDD_PROPERTY_PAGE};

    typedef IPropertyPageImpl<CSpPropertyPage> PPBaseClass;

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSpPropertyPage) 
	    COM_INTERFACE_ENTRY(IPropertyPage)
    END_COM_MAP()

    IMMX_DECLARE_REGISTRY_RESOURCE(IDR_PROPERTY_PAGE)

    BEGIN_MSG_MAP(CSpPropertyPage)
        COMMAND_ID_HANDLER(IDC_PP_SELECTION_CMD,        OnCheckButtonSetting)
        COMMAND_ID_HANDLER(IDC_PP_NAVIGATION_CMD,       OnCheckButtonSetting)
        COMMAND_ID_HANDLER(IDC_PP_CASING_CMD,           OnCheckButtonSetting)
        COMMAND_ID_HANDLER(IDC_PP_EDITING_CMD,          OnCheckButtonSetting)
        COMMAND_ID_HANDLER(IDC_PP_KEYBOARD_CMD,         OnCheckButtonSetting)
        COMMAND_ID_HANDLER(IDC_PP_LANGBAR_CMD,          OnCheckButtonSetting)
        COMMAND_ID_HANDLER(IDC_PP_TTS_CMD,              OnCheckButtonSetting)
        COMMAND_ID_HANDLER(IDC_PP_DISABLE_DICTCMD,      OnCheckButtonSetting)
        COMMAND_ID_HANDLER(IDC_PP_ASSIGN_BUTTON,        OnCheckButtonSetting)
        COMMAND_ID_HANDLER(IDC_PP_BUTTON_MB_SETTING,    OnPushButtonClicked)
        COMMAND_ID_HANDLER(IDC_PP_BUTTON_ADVANCE,       OnPushButtonClicked)
        COMMAND_ID_HANDLER(IDC_PP_BUTTON_LANGBAR,       OnPushButtonClicked)

        CHAIN_MSG_MAP(IPropertyPageImpl<CSpPropertyPage>)
    END_MSG_MAP()

//-- Methods

    STDMETHOD(Activate)(HWND hWndParent, LPCRECT prc,BOOL bModal);

	STDMETHOD(Apply)(void);

    LRESULT OnCheckButtonSetting(WORD wNotifyCode, WORD wID, HWND hWndCtl,BOOL& bHandled);
    LRESULT OnPushButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl,BOOL& bHandled);

private:

//-- Methods
    
    HRESULT InitPropertyPage();

//-- Members

    // GUI stuff
    HWND                            m_hWndParent;
    CSpPropItemsServer             *m_SpPropItemsServer;
    DWORD                           m_dwNumCtrls;
    CONTROL_PROP_MAP               *m_IdCtrlPropMap;
    CSpAdvanceSetting              *m_SpAdvanceSet;
};

#endif // USE_IPROPERTYPAGE

static TCHAR c_szHelpFile[]    = TEXT("input.hlp");

// Class for the Advanced setting dialog
                        
class CSpAdvanceSetting : public CDialogImpl<CSpAdvanceSetting>
{
public:

    CSpAdvanceSetting( );
    ~CSpAdvanceSetting( );

    enum {IDD = IDD_PP_DIALOG_ADVANCE};

    BEGIN_MSG_MAP(CSpAdvanceSetting)

        MESSAGE_HANDLER(WM_INITDIALOG, OnInitAdvanceDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextHelp)
        MESSAGE_HANDLER(WM_HELP, OnContextHelp)

        COMMAND_ID_HANDLER(IDC_PP_SELECTION_CMD,        OnCheckButtonSetting)
        COMMAND_ID_HANDLER(IDC_PP_NAVIGATION_CMD,       OnCheckButtonSetting)
        COMMAND_ID_HANDLER(IDC_PP_CASING_CMD,           OnCheckButtonSetting)
        COMMAND_ID_HANDLER(IDC_PP_EDITING_CMD,          OnCheckButtonSetting)
        COMMAND_ID_HANDLER(IDC_PP_KEYBOARD_CMD,         OnCheckButtonSetting)
        COMMAND_ID_HANDLER(IDC_PP_LANGBAR_CMD,          OnCheckButtonSetting)
//        COMMAND_ID_HANDLER(IDC_PP_TTS_CMD,              OnCheckButtonSetting)

/*
        COMMAND_ID_HANDLER(IDC_PP_MAXCHARS_ALTERNATE,   OnEditControlSetting)
        COMMAND_ID_HANDLER(IDC_PP_MAXNUM_ALTERNATES,    OnEditControlSetting)
*/
        COMMAND_ID_HANDLER(IDOK,                        OnPushButtonClicked)
        COMMAND_ID_HANDLER(IDCANCEL,                    OnPushButtonClicked)

    END_MSG_MAP()

    INT_PTR DoModalW(HWND hWndParent = ::GetActiveWindow(), LPARAM dwInitParam = NULL)
    {
        ATLASSERT(m_hWnd == NULL);
        _Module.AddCreateWndData(&m_thunk.cd, (CDialogImpl<CSpAdvanceSetting> *)this);
        return ::DialogBoxParamW(GetCicResInstance(g_hInst, CSpAdvanceSetting::IDD),
                    MAKEINTRESOURCEW(CSpAdvanceSetting::IDD),
                    hWndParent, CSpAdvanceSetting::StartDialogProc, dwInitParam);
    }


    LRESULT OnCheckButtonSetting(WORD wNotifyCode, WORD wID, HWND hWndCtl,BOOL& bHandled);
//    LRESULT OnEditControlSetting(WORD wNotifyCode, WORD wID, HWND hWndCtl,BOOL& bHandled);
    LRESULT OnPushButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl,BOOL& bHandled);

    LRESULT OnInitAdvanceDialog(UINT uMsg, WPARAM wParam, LPARAM lParam,BOOL& bHandled );
    LRESULT OnContextHelp(UINT uMsg, WPARAM wParam, LPARAM lParam,BOOL& bHandled );

    BOOL    IsItemStatusChanged( );

private:

    CSpPropItemsServer             *m_SpPropBaseServer;
    CSpPropItemsServer             *m_SpPropItemsServer;
    DWORD                           m_dwNumCtrls;
    CONTROL_PROP_MAP               *m_IdCtrlPropMap;

};

// Class for the Mode Button Setting dialog
                        
class CSpModeButtonSetting : public CDialogImpl<CSpModeButtonSetting>
{
public:

    CSpModeButtonSetting( );
    ~CSpModeButtonSetting( );

    enum {IDD = IDD_PP_DIALOG_BUTTON_SET};

    BEGIN_MSG_MAP(CSpModeButtonSetting)

        MESSAGE_HANDLER(WM_INITDIALOG, OnInitModeButtonDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextHelp)
        MESSAGE_HANDLER(WM_HELP, OnContextHelp)

        COMMAND_ID_HANDLER(IDC_PP_DICTATION_CMB,        OnCombBoxSetting)
        COMMAND_ID_HANDLER(IDC_PP_COMMAND_CMB,          OnCombBoxSetting)

        COMMAND_ID_HANDLER(IDOK,                        OnPushButtonClicked)
        COMMAND_ID_HANDLER(IDCANCEL,                    OnPushButtonClicked)
	
    END_MSG_MAP()

    INT_PTR DoModalW(HWND hWndParent = ::GetActiveWindow(), LPARAM dwInitParam = NULL)
    {
        ATLASSERT(m_hWnd == NULL);
        _Module.AddCreateWndData(&m_thunk.cd, (CDialogImpl<CSpModeButtonSetting> *)this);
        return ::DialogBoxParamW(GetCicResInstance(g_hInst, CSpModeButtonSetting::IDD),
                    MAKEINTRESOURCEW(CSpModeButtonSetting::IDD),
                    hWndParent, CSpModeButtonSetting::StartDialogProc, dwInitParam);
    }

    LRESULT OnCombBoxSetting(WORD wNotifyCode, WORD wID, HWND hWndCtl,BOOL& bHandled);
    LRESULT OnPushButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl,BOOL& bHandled);

    LRESULT OnInitModeButtonDialog(UINT uMsg, WPARAM wParam, LPARAM lParam,BOOL& bHandled );
    LRESULT OnContextHelp(UINT uMsg, WPARAM wParam, LPARAM lParam,BOOL& bHandled );

private:

    CSpPropItemsServer             *m_SpPropBaseServer;
    CSpPropItemsServer             *m_SpPropItemsServer;
    DWORD                           m_dwNumCtrls;
    CONTROL_PROP_MAP               *m_IdCtrlPropMap;
};

class CSptipPropertyPage 
{
public:

    CSptipPropertyPage ( WORD wDlgId, BOOL fLaunchFromInputCpl );
    ~CSptipPropertyPage ( );

    static INT_PTR CALLBACK SpPropertyPageProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

    LRESULT OnCheckButtonSetting(WORD wNotifyCode, WORD wID, HWND hWndCtl);
    LRESULT OnPushButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl);
    LRESULT OnApply( );

    LRESULT OnInitSptipPropPageDialog( HWND hDlg );

    WORD    GetDlgResId( ) { return m_wDlgId; }
    DLGPROC GetDlgProc( )  { return SpPropertyPageProc; }

    BOOL    IsPageDirty( ) { return m_fIsDirty; }
    void    SetDirty( BOOL fDirty ); 

private:

//-- Members

    WORD                            m_wDlgId;
    HWND                            m_hDlg;
    CSpPropItemsServer             *m_SpPropItemsServer;
    DWORD                           m_dwNumCtrls;
    CONTROL_PROP_MAP               *m_IdCtrlPropMap;
    CSpAdvanceSetting              *m_SpAdvanceSet;
    CSpModeButtonSetting           *m_SpModeBtnSet;
    BOOL                            m_fIsDirty;
    BOOL                            m_fLaunchFromInputCpl;   // indicates if the property page is launched from input cpl.
};

#endif // _PROPPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\proppage.cpp ===
// PropPage.cpp : Implementation of CSpPropertyPage
#include "private.h"

#include "globals.h"
#include "PropPage.h"
#include "commctrl.h"
#include "cregkey.h"
#include "cresstr.h"
#include "cicspres.h"

extern HRESULT _SetGlobalCompDWORD(REFGUID rguid, DWORD   dw);
extern HRESULT _GetGlobalCompDWORD(REFGUID rguid, DWORD  *pdw);

// only used for dialogs, not the class factory!
CComModule _Module;

//
//  Context Help Ids.
//

static int aSptipPropIds[] =
{
    IDC_PP_ASSIGN_BUTTON,       IDH_PP_ASSIGN_BUTTON,
    IDC_PP_BUTTON_MB_SETTING,   IDH_PP_BUTTON_MB_SETTING,
    IDC_PP_SHOW_BALLOON,        IDH_PP_SHOW_BALLOON,
    IDC_PP_LMA,                 IDH_PP_LMA,
    IDC_PP_HIGH_CONFIDENCE,     IDH_PP_HIGH_CONFIDENCE,
    IDC_PP_SAVE_SPDATA,         IDH_PP_SAVE_SPDATA,
    IDC_PP_REMOVE_SPACE,        IDH_PP_REMOVE_SPACE,
    IDC_PP_DIS_DICT_TYPING,     IDH_PP_DIS_DICT_TYPING,
    IDC_PP_PLAYBACK,            IDH_PP_PLAYBACK,
    IDC_PP_DICT_CANDUI_OPEN,    IDH_PP_DICT_CANDUI_OPEN,
    IDC_PP_BUTTON_ADVANCE,      IDH_PP_BUTTON_ADVANCE,
    IDC_PP_BUTTON_SPCPL,        IDH_PP_BUTTON_SPCPL,
    IDC_PP_BUTTON_LANGBAR,      IDH_PP_BUTTON_LANGBAR,
    IDC_PP_DICTCMDS,            IDH_PP_DICTCMDS,
    0, 0
};


static int aSptipVoiceDlgIds[] =
{
    IDC_PP_SELECTION_CMD,       IDH_PP_SELECTION_CMD,
    IDC_PP_NAVIGATION_CMD,      IDH_PP_NAVIGATION_CMD,
    IDC_PP_CASING_CMD,          IDH_PP_CASING_CMD,
    IDC_PP_EDITING_CMD,         IDH_PP_EDITING_CMD,
    IDC_PP_KEYBOARD_CMD,        IDH_PP_KEYBOARD_CMD,
    IDC_PP_TTS_CMD,             IDH_PP_TTS_CMD,
    IDC_PP_LANGBAR_CMD,         IDH_PP_LANGBAR_CMD,
    0, 0
};

static int aSptipButtonDlgIds[] =
{
    IDC_PP_DICTATION_CMB,       IDH_PP_DICTATION_CMB,
    IDC_PP_COMMAND_CMB,         IDH_PP_COMMAND_CMB,
    0, 0
};


#ifdef USE_IPROPERTYPAGE

/////////////////////////////////////////////////////////////////////////////
// CSpPropertyPage

//////////////////////////////////////////////////////////////////////////////
//
//  CSpPropertyPage::CSpPropertyPage
//
//  Description:    Constructor: initializes member variables
//
//////////////////////////////////////////////////////////////////////////////

CSpPropertyPage::CSpPropertyPage() : m_hWndParent(NULL)
{
	m_dwTitleID = IDS_PROPERTYPAGE_TITLE;
	m_dwHelpFileID = IDS_HELPFILESpPropPage;
	m_dwDocStringID = IDS_DOCSTRINGSpPropPage;

    m_SpPropItemsServer = NULL;
    m_dwNumCtrls = 0;
    m_IdCtrlPropMap = NULL;
    m_SpAdvanceSet = NULL;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CSpPropertyPage::~CSpPropertyPage
//
//  Description:    Destructor: clean up the array of CSpListenerItems
//
//////////////////////////////////////////////////////////////////////////////

CSpPropertyPage::~CSpPropertyPage()
{
    if ( m_SpPropItemsServer )
        delete m_SpPropItemsServer;

    if ( m_IdCtrlPropMap )
        cicMemFree(m_IdCtrlPropMap);

    if ( m_SpAdvanceSet )
        delete m_SpAdvanceSet;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CSpPropertyPage::Activate
//
//  Description:    Initializes the property page:
//                      - calls Activate on the base class
//                      - initializes the common controls
//                      - initializes the property page dialog
//
//  Parameters:     hWndParent - handle to parent (host) window
//                  prc - RECT of the parent
//                  bModal - modality of the window
//
//  Return Values:  S_OK
//
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CSpPropertyPage::Activate(
    HWND hWndParent,
    LPCRECT prc,
    BOOL bModal)
{

    InitCommonControls();

    Assert(hWndParent != NULL);

    m_hWndParent = hWndParent;

    HRESULT hr = PPBaseClass::Activate(hWndParent, prc, bModal);

    hr = InitPropertyPage();

    if (SUCCEEDED(hr))
    {
        SetDirty(FALSE);
    }
    
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CSpPropertyPage::Apply
//
//  Description:    Calls CommitChanges and if SUCCEEDED sets the dirty bit
//
//  Parameters:     none
//
//  Return Values:  S_OK, E_FAIL
//
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CSpPropertyPage::Apply(void)
{

    HRESULT hr = S_OK; 

    if ( IsPageDirty( ) != S_OK ) return hr;

    // change the registry settings here. !!!
    Assert(m_SpPropItemsServer);
    m_SpPropItemsServer->_SavePropData( );

    // Notify all the Cicero Applications of these registry settings change.

    if ( SUCCEEDED(hr) )
    {
        hr = _SetGlobalCompDWORD(GUID_COMPARTMENT_SPEECH_PROPERTY_CHANGE, 1);
    }

    if (SUCCEEDED(hr))
    {
        SetDirty(FALSE);
    }
    
	return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CSpPropertyPage::InitPropertyPage
//
//  Description:    Initializes the property page:
//                      - initializes the listview
//                      - loads the listener info into the listview
//
//  Parameters:     none
//
//  Return Values:  S_OK
//
//////////////////////////////////////////////////////////////////////////////

HRESULT CSpPropertyPage::InitPropertyPage()
{
    HRESULT  hr = S_OK;

    // Add some initialization code here.
    if ( !m_SpPropItemsServer )
        m_SpPropItemsServer = (CSpPropItemsServer *) new CSpPropItemsServer;

    if ( !m_SpPropItemsServer )
        return E_FAIL;

    if ( !m_IdCtrlPropMap )
    {
        CONTROL_PROP_MAP IdCtrlPropMap[] =
        {
            //    idCtrl,                     idPropItem,            fEdit

            {IDC_PP_SELECTION_CMD,      PropId_Cmd_Select_Correct,  FALSE},
            {IDC_PP_NAVIGATION_CMD,     PropId_Cmd_Navigation,      FALSE},
            {IDC_PP_CASING_CMD,         PropId_Cmd_Casing,          FALSE},
            {IDC_PP_EDITING_CMD,        PropId_Cmd_Editing,         FALSE},
            {IDC_PP_KEYBOARD_CMD,       PropId_Cmd_Keyboard,        FALSE},
            {IDC_PP_LANGBAR_CMD,        PropId_Cmd_Language_Bar,    FALSE},
            {IDC_PP_TTS_CMD,            PropId_Cmd_TTS,             FALSE},
            {IDC_PP_DISABLE_DICTCMD,    PropId_Cmd_DisDict,         FALSE},
            {IDC_PP_ASSIGN_BUTTON,      PropId_Mode_Button,         FALSE},   
            { 0,                        PropId_Max_Item_Id,         FALSE }

        };

        DWORD   dwPropItems = 0;

        while (IdCtrlPropMap[dwPropItems].idCtrl != 0 )
              dwPropItems ++;

        m_IdCtrlPropMap = (CONTROL_PROP_MAP  *)cicMemAlloc(dwPropItems * sizeof(CONTROL_PROP_MAP));

        if ( m_IdCtrlPropMap == NULL )
            return E_OUTOFMEMORY;

        for ( DWORD i=0; i<dwPropItems; i++)
        {
            m_IdCtrlPropMap[i].fEdit = IdCtrlPropMap[i].fEdit;
            m_IdCtrlPropMap[i].idCtrl= IdCtrlPropMap[i].idCtrl;
            m_IdCtrlPropMap[i].idPropItem = IdCtrlPropMap[i].idPropItem;
        }

        m_dwNumCtrls = dwPropItems;
    }


    for (DWORD i=0; i<m_dwNumCtrls; i++ )
    {
        WORD          idCtrl;
        PROP_ITEM_ID  idPropItem;
        BOOL          fEditControl;

        idCtrl = m_IdCtrlPropMap[i].idCtrl;
        idPropItem = m_IdCtrlPropMap[i].idPropItem;
        fEditControl = m_IdCtrlPropMap[i].fEdit;

        // BugBug:  There is no edit control in current property page.
        // all the edit controls are moved to advanced setting dialog.
        // temporally keep the code here, but after we finish the code for the 
        // advcanced setting dialog, please optimize code here.
        //
        if ( fEditControl )
        {
            SetDlgItemInt(idCtrl, (UINT)m_SpPropItemsServer->_GetPropData(idPropItem));
        }
        else
        {
            BOOL    fEnable;
            LPARAM  bst_Status;

            fEnable = (BOOL)m_SpPropItemsServer->_GetPropData(idPropItem);

            bst_Status = fEnable ? BST_CHECKED : BST_UNCHECKED;

            SendDlgItemMessage(idCtrl, BM_SETCHECK, bst_Status);
        }
    }

    // Specially handle the Mode button settings.

    if (! m_SpPropItemsServer->_GetPropData(PropId_Mode_Button) )
    {
        ::EnableWindow(GetDlgItem(IDC_PP_BUTTON_MB_SETTING), FALSE);
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CSpPropertyPage::OnCheckButtonSetting
//
//  Description:    Handle all the change in the checked buttons related to   
//                  speech tip setting. the status is Enable/Disable.
//
//  Return Values:  S_OK
//
//////////////////////////////////////////////////////////////////////////////
LRESULT CSpPropertyPage::OnCheckButtonSetting(WORD wNotifyCode,WORD wID,HWND hWndCtl,BOOL& bHandled)
{
    HRESULT         hr = S_OK;
    BOOL            fChecked = FALSE;
    BOOL            fEnable = FALSE;
    PROP_ITEM_ID    idPropItem = PropId_Max_Item_Id;  // means not initialized

    Assert(m_SpPropItemsServer);
    Assert(m_IdCtrlPropMap);

    // Find the prop item ID associated with this checked box button.
    for ( DWORD i=0; i<m_dwNumCtrls; i++)
    {
        if ( m_IdCtrlPropMap[i].idCtrl == wID )
        {
            idPropItem = m_IdCtrlPropMap[i].idPropItem;
            break;
        }
    }

    if ( idPropItem >= PropId_Max_Item_Id )
    {
        // we don't find the control ID from our list, this is not possible, some thing wrong already.
        // exit here.
        return E_FAIL;
    }

    if ( wNotifyCode != BN_CLICKED )
        return hr;

    if ( ::SendMessage(hWndCtl, BM_GETCHECK, 0, 0 ) == BST_CHECKED )
        fChecked = TRUE;

    fEnable = fChecked;

    m_SpPropItemsServer->_SetPropData(idPropItem, fEnable);

    // Specially hanlde Mode Buttons.

    if ( wID == IDC_PP_ASSIGN_BUTTON )
    {
        ::EnableWindow(GetDlgItem(IDC_PP_BUTTON_MB_SETTING), fEnable);
    }

    SetDirty(TRUE);

    return hr;
}



//////////////////////////////////////////////////////////////////////////////
//
//  CSpPropertyPage::OnPushButtonClicked
//
//  Description:    When the pushbutton is pressed in this page, this function   
//                  will be called to open corresponding dialog.
//
//  Return Values:  S_OK
//
//////////////////////////////////////////////////////////////////////////////
LRESULT CSpPropertyPage::OnPushButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl,BOOL& bHandled)
{

    HRESULT hr = S_OK;

    switch (wID)
    {
    case IDC_PP_BUTTON_ADVANCE :

        if (m_SpAdvanceSet)
        {
            delete m_SpAdvanceSet;
            m_SpAdvanceSet = NULL;
        }

        m_SpAdvanceSet = (CSpAdvanceSetting *) new CSpAdvanceSetting( );

        if ( m_SpAdvanceSet )
        {
            int nRetCode;

            nRetCode = m_SpAdvanceSet->DoModal(m_hWndParent, (LPARAM)m_SpPropItemsServer);

            if ( nRetCode == IDOK )
                SetDirty(TRUE);

            delete m_SpAdvanceSet;
            m_SpAdvanceSet = NULL;
        }

        break;

    case IDC_PP_BUTTON_LANGBAR :
        {
            TCHAR szCmdLine[MAX_PATH];
            TCHAR szInputPath[MAX_PATH];
            int cch = GetSystemDirectory(szInputPath, ARRAYSIZE(szInputPath));

            if (cch > 0)
            {
                // GetSystemDirectory appends no '\' unless the system
                // directory is the root, such like "c:\"
                if (cch != 3)
                    StringCchCat(szInputPath, ARRAYSIZE(szInputPath),TEXT("\\"));

                StringCchCat(szInputPath, ARRAYSIZE(szInputPath), TEXT("input.dll"));

                StringCchPrintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("rundll32 shell32.dll,Control_RunDLL \"%s\""),szInputPath);

                // start Language Bar control panel applet
                RunCPLSetting(szCmdLine);
            }

            break;
        }

    case IDC_PP_BUTTON_MB_SETTING :
        break;

    default :

        Assert(0);
        break;
    }
    
    return hr;
}

#endif // USE_IPROPERTYPAGE

//
//
// CSpAdvanceSetting
//

CSpAdvanceSetting::CSpAdvanceSetting()
{
//	m_dwTitleID = IDS_PROPERTYPAGE_TITLE;
//	m_dwHelpFileID = IDS_HELPFILESpPropPage;
//	m_dwDocStringID = IDS_DOCSTRINGSpPropPage;

    m_SpPropItemsServer = NULL;
    m_dwNumCtrls = 0;
    m_IdCtrlPropMap = NULL;
}


CSpAdvanceSetting::~CSpAdvanceSetting( )
{
    if ( m_SpPropItemsServer )
        delete m_SpPropItemsServer;

    if ( m_IdCtrlPropMap )
        cicMemFree(m_IdCtrlPropMap);
}

LRESULT CSpAdvanceSetting::OnInitAdvanceDialog(UINT uMsg, WPARAM wParam, LPARAM lParam,BOOL& bHandled )
{

    Assert(lParam);
    m_SpPropBaseServer = (CSpPropItemsServer *)lParam;

    // Add some initialization code here.
    if ( !m_SpPropItemsServer )
        m_SpPropItemsServer = (CSpPropItemsServer *) new CSpPropItemsServer(m_SpPropBaseServer, PropId_MinId_InVoiceCmd, PropId_MaxId_InVoiceCmd);

    if ( !m_SpPropItemsServer )
        return FALSE;

    if ( !m_IdCtrlPropMap )
    {
        // Please make sure the array items are sorted by control id, and make sure the control id are sequent number,
        // so that we can use it to map to an index in the array easily.
        //

        CONTROL_PROP_MAP IdCtrlPropMap[] =
        {
            //    idCtrl,                     idPropItem,            fEdit

            {IDC_PP_SELECTION_CMD,      PropId_Cmd_Select_Correct,  FALSE},
            {IDC_PP_NAVIGATION_CMD,     PropId_Cmd_Navigation,      FALSE},
            {IDC_PP_CASING_CMD,         PropId_Cmd_Casing,          FALSE},
            {IDC_PP_EDITING_CMD,        PropId_Cmd_Editing,         FALSE},
            {IDC_PP_KEYBOARD_CMD,       PropId_Cmd_Keyboard,        FALSE},
            {IDC_PP_LANGBAR_CMD,        PropId_Cmd_Language_Bar,    FALSE},
//            {IDC_PP_TTS_CMD,            PropId_Cmd_TTS,             FALSE},

//            {IDC_PP_MAXNUM_ALTERNATES,  PropId_Max_Alternates,      TRUE},
//            {IDC_PP_MAXCHARS_ALTERNATE, PropId_MaxChar_Cand,        TRUE},
            { 0,                        PropId_Max_Item_Id,         FALSE }

        };

        DWORD   dwPropItems = ARRAYSIZE(IdCtrlPropMap) - 1;

        m_IdCtrlPropMap = (CONTROL_PROP_MAP  *)cicMemAlloc(dwPropItems * sizeof(CONTROL_PROP_MAP));

        if ( m_IdCtrlPropMap == NULL )
            return E_OUTOFMEMORY;

        for ( DWORD i=0; i<dwPropItems; i++)
        {
            m_IdCtrlPropMap[i] = IdCtrlPropMap[i];
        }

        m_dwNumCtrls = dwPropItems;
    }


    for (DWORD i=0; i<m_dwNumCtrls; i++ )
    {
        WORD          idCtrl;
        PROP_ITEM_ID  idPropItem;
        BOOL          fEditControl;

        idCtrl = m_IdCtrlPropMap[i].idCtrl;
        idPropItem = m_IdCtrlPropMap[i].idPropItem;
        fEditControl = m_IdCtrlPropMap[i].fEdit;

        if ( fEditControl )
        {
            SetDlgItemInt(idCtrl, (UINT)m_SpPropItemsServer->_GetPropData(idPropItem));
        }
        else
        {
            BOOL    fEnable;
            LPARAM  bst_Status;

            fEnable = (BOOL)m_SpPropItemsServer->_GetPropData(idPropItem);

            bst_Status = fEnable ? BST_CHECKED : BST_UNCHECKED;

            SendDlgItemMessage(idCtrl, BM_SETCHECK, bst_Status);
        }
    }

    return TRUE;  
}

LRESULT CSpAdvanceSetting::OnContextHelp(UINT uMsg, WPARAM wParam, LPARAM lParam,BOOL& bHandled )
{
    HRESULT hr = S_OK;

    switch (uMsg)
    {
    case  WM_HELP  :

        ::WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                 c_szHelpFile,
                 HELP_WM_HELP,
                 (DWORD_PTR)(LPTSTR)aSptipVoiceDlgIds );
        break;

    case  WM_CONTEXTMENU  :      // right mouse click

        ::WinHelp(  (HWND)wParam,
                 c_szHelpFile,
                 HELP_CONTEXTMENU,
                 (DWORD_PTR)(LPTSTR)aSptipVoiceDlgIds );
        break;

    default :
        break;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CSpAdvanceSetting::OnCheckButtonSetting
//
//  Description:    Handle all the change in the checked buttons in the Advanced
//                  setting dialog. the status is Enable/Disable.
//
//  Return Values:  S_OK
//
//////////////////////////////////////////////////////////////////////////////

LRESULT CSpAdvanceSetting::OnCheckButtonSetting(WORD wNotifyCode, WORD wID, HWND hWndCtl,BOOL& bHandled)
{
    HRESULT         hr = S_OK;
    BOOL            fChecked = FALSE;
    BOOL            fEnable = FALSE;
    PROP_ITEM_ID    idPropItem = PropId_Max_Item_Id;  // means not initialized

    Assert(m_SpPropItemsServer);
    Assert(m_IdCtrlPropMap);

    // Find the prop item ID associated with this checked box button.
    Assert( wID >= IDC_PP_SELECTION_CMD );
    idPropItem = m_IdCtrlPropMap[wID - IDC_PP_SELECTION_CMD].idPropItem;

    if ( idPropItem >= PropId_Max_Item_Id )
    {
        // we don't find the control ID from our list, this is not possible, some thing wrong already.
        // exit here.
        return E_FAIL;
    }

    if ( wNotifyCode != BN_CLICKED )
        return hr;

    if ( ::SendMessage(hWndCtl, BM_GETCHECK, 0, 0) == BST_CHECKED )
        fChecked = TRUE;

    fEnable = fChecked;

    m_SpPropItemsServer->_SetPropData(idPropItem, fEnable);

    return hr;
}

/*

//////////////////////////////////////////////////////////////////////////////
//
//  CSpAdvanceSetting::OnEditControlSetting
//
//  Description:    Handle all the change in the edit controls related to   
//                  speech tip setting. the value is editable.
//
//  Return Values:  S_OK
//
//////////////////////////////////////////////////////////////////////////////

LRESULT CSpAdvanceSetting::OnEditControlSetting(WORD wNotifyCode, WORD wID, HWND hWndCtl,BOOL& bHandled)
{
    HRESULT         hr = S_OK;
    ULONG           ulValue = 0;
    PROP_ITEM_ID    idPropItem = PropId_Max_Item_Id;  // means not initialized

    Assert(m_SpPropItemsServer);
    Assert(m_IdCtrlPropMap);

    Assert( wID >= IDC_PP_SHOW_BALLOON );
    idPropItem = m_IdCtrlPropMap[wID - IDC_PP_SHOW_BALLOON].idPropItem;

    if ( idPropItem >= PropId_Max_Item_Id )
    {
        // we don't find the control ID from our list, this is not possible, some thing wrong already.
        // exit here.
        return E_FAIL;
    }

    if ( wNotifyCode != EN_CHANGE )
        return hr;

    ulValue = (ULONG) GetDlgItemInt(wID);

    m_SpPropItemsServer->_SetPropData(idPropItem, ulValue);

    // Enable OK button due to EditBox value change.
    ::EnableWindow(GetDlgItem(IDOK), TRUE);

    return hr;
}

*/

//////////////////////////////////////////////////////////////////////////////
//
//  CSpAdvanceSetting::IsItemStatusChanged
//
//  Description:    Check to see if some items' status have been changed
//                  since the dialog open.
//
//  Return Values:  S_OK
//
////////////////////////////////////////////////////////////////////////////// 
BOOL    CSpAdvanceSetting::IsItemStatusChanged( )
{
    BOOL   fChanged = FALSE;

    // Comparing the current item status with the base server's item status 
    // to determine if there is any item changed

    if ( m_SpPropItemsServer  && m_SpPropBaseServer)
    {
        DWORD   idPropItem;
        DWORD   dwOrgData, dwCurData;

        for (idPropItem = (DWORD)PropId_MinId_InVoiceCmd; idPropItem <= (DWORD)PropId_MaxId_InVoiceCmd; idPropItem++ )
        {
            dwCurData = m_SpPropItemsServer->_GetPropData((PROP_ITEM_ID)idPropItem);
            dwOrgData = m_SpPropBaseServer->_GetPropData((PROP_ITEM_ID)idPropItem);

            if ( dwCurData != dwOrgData )
            {
                fChanged = TRUE;
                break;
            }
        }
    }

    return fChanged;
}

LRESULT CSpAdvanceSetting::OnPushButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl,BOOL& bHandled)
{
    HRESULT  hr=S_OK;
    int      nRetCode;

    Assert(m_SpPropItemsServer);
    Assert(m_SpPropBaseServer);
    Assert(m_IdCtrlPropMap);

    if ( wID != IDOK && wID != IDCANCEL )
        return E_FAIL;

    nRetCode = FALSE;   // Means no item changed

    if ( wID == IDOK && IsItemStatusChanged( ))
    {
        //Merge back all the change to the base property server.
        m_SpPropBaseServer->_MergeDataFromServer(m_SpPropItemsServer, PropId_MinId_InVoiceCmd, PropId_MaxId_InVoiceCmd);
        nRetCode = TRUE;
    }

    EndDialog(nRetCode);
    return hr;
}


//
//
// CSpModeButtonSetting
//

KEYNAME_VK_MAP  pName_VK_Table[] = {
        { TEXT("F1"),       VK_F1      },
        { TEXT("F2"),       VK_F2      },
        { TEXT("F3"),       VK_F3      },
        { TEXT("F4"),       VK_F4      },
        { TEXT("F5"),       VK_F5      },
        { TEXT("F6"),       VK_F6      },
        { TEXT("F7"),       VK_F7      },
        { TEXT("F8"),       VK_F8      },
        { TEXT("F9"),       VK_F9      },
        { TEXT("F10"),      VK_F10     },
        { TEXT("F11"),      VK_F11     },
        { TEXT("F12"),      VK_F12     },
        { TEXT("Space"),    VK_SPACE   },
        { TEXT("Esc"),      VK_ESCAPE  },
        { TEXT("PgUp"),     VK_PRIOR   },
        { TEXT("PgDn"),     VK_NEXT    },
        { TEXT("Home"),     VK_HOME    },
        { TEXT("End"),      VK_END     },
        { TEXT("Left"),     VK_LEFT    },
        { TEXT("Right"),    VK_RIGHT   },
        { TEXT("Up"),       VK_UP      },
        { TEXT("Down"),     VK_DOWN    },
        { TEXT("Insert"),   VK_INSERT  },
        { TEXT("Delete"),   VK_DELETE  },
        { TEXT("+"),        VK_ADD     },
        { TEXT("-"),        VK_SUBTRACT },
        { TEXT("/"),        VK_DIVIDE   },
        { TEXT("*"),        VK_MULTIPLY },
        { TEXT("Enter"),    VK_RETURN   },
        { TEXT("Tab"),      VK_TAB      },
        { TEXT("Pause"),    VK_PAUSE    },
        { TEXT("ScrollLock"), VK_SCROLL },
        { TEXT("NumLock"),    VK_NUMLOCK  },
};

CSpModeButtonSetting::CSpModeButtonSetting()
{
//	m_dwTitleID = IDS_PROPERTYPAGE_TITLE;
//	m_dwHelpFileID = IDS_HELPFILESpPropPage;
//	m_dwDocStringID = IDS_DOCSTRINGSpPropPage;

    m_SpPropItemsServer = NULL;
    m_dwNumCtrls = 0;
    m_IdCtrlPropMap = NULL;
}


CSpModeButtonSetting::~CSpModeButtonSetting( )
{
    if ( m_SpPropItemsServer )
        delete m_SpPropItemsServer;

    if ( m_IdCtrlPropMap )
        cicMemFree(m_IdCtrlPropMap);
}

LRESULT CSpModeButtonSetting::OnInitModeButtonDialog(UINT uMsg, WPARAM wParam, LPARAM lParam,BOOL& bHandled )
{

    Assert(lParam);
    m_SpPropBaseServer = (CSpPropItemsServer *)lParam;

    // Add some initialization code here.
    if ( !m_SpPropItemsServer )
        m_SpPropItemsServer = (CSpPropItemsServer *) new CSpPropItemsServer(m_SpPropBaseServer, PropId_MinId_InModeButton, PropId_MaxId_InModeButton);

    if ( !m_SpPropItemsServer )
        return FALSE;

    if ( !m_IdCtrlPropMap )
    {
        // Please make sure the array items are sorted by control id, and make sure the control id are sequent number,
        // so that we can use it to map to an index in the array easily.
        //
        CONTROL_PROP_MAP IdCtrlPropMap[] =
        {
            //    idCtrl,                     idPropItem,        fEdit
            {IDC_PP_DICTATION_CMB,      PropId_Dictation_Key,    FALSE },
            {IDC_PP_COMMAND_CMB,        PropId_Command_Key,      FALSE },
            { 0,                        PropId_Max_Item_Id,      FALSE }
        };

        DWORD   dwPropItems = ARRAYSIZE(IdCtrlPropMap) - 1;

        m_IdCtrlPropMap = (CONTROL_PROP_MAP  *)cicMemAlloc(dwPropItems * sizeof(CONTROL_PROP_MAP));

        if ( m_IdCtrlPropMap == NULL )
            return E_OUTOFMEMORY;

        for ( DWORD i=0; i<dwPropItems; i++)
        {
            m_IdCtrlPropMap[i] = IdCtrlPropMap[i];
        }

        m_dwNumCtrls = dwPropItems;
    }

    for (DWORD i=0; i<m_dwNumCtrls; i++ )
    {
        WORD          idCtrl;
        PROP_ITEM_ID  idPropItem;
        DWORD         dwPropData;
        HWND          hCombBox;

        idCtrl = m_IdCtrlPropMap[i].idCtrl;
        idPropItem = m_IdCtrlPropMap[i].idPropItem;
        dwPropData = m_SpPropItemsServer->_GetPropData(idPropItem);

        hCombBox = GetDlgItem(idCtrl);

        if ( hCombBox )
        {
            int iIndex, iIndexDef = CB_ERR;  // CB_ERR is -1

            // Initialize the list box items
            for ( int j = 0; j < ARRAYSIZE(pName_VK_Table); j++ )
            {
                iIndex = (int)::SendMessage(hCombBox, CB_ADDSTRING, 0, (LPARAM)pName_VK_Table[j].pKeyName);
                ::SendMessage(hCombBox, CB_SETITEMDATA, iIndex, (LPARAM)(void*)&pName_VK_Table[j]);

                if ( pName_VK_Table[j].wVKey == dwPropData )
                    iIndexDef = j;
            }

            // Set the current selection based on property item data.
            if ( iIndexDef != CB_ERR )
                ::SendMessage(hCombBox, CB_SETCURSEL, iIndexDef, 0 );
        }
    }

    return TRUE;  
}


//////////////////////////////////////////////////////////////////////////////
//
//  CSpModeButtonSetting::OnCombBoxSetting
//
//  Description:    Handle all the change in the CombBox controls related to   
//                  mode button setting. 
//
//  Return Values:  S_OK
//
//////////////////////////////////////////////////////////////////////////////

LRESULT CSpModeButtonSetting::OnCombBoxSetting(WORD wNotifyCode, WORD wID, HWND hWndCtl,BOOL& bHandled)
{
    HRESULT         hr = S_OK;
    KEYNAME_VK_MAP  *pCurKeyData;
    int             iIndex;
    PROP_ITEM_ID    idPropItem = PropId_Max_Item_Id;  // means not initialized

    if ( wNotifyCode != CBN_SELCHANGE )
        return hr;

    Assert(m_SpPropItemsServer);
    Assert(m_IdCtrlPropMap);

    Assert(wID >= IDC_PP_DICTATION_CMB);
    idPropItem = m_IdCtrlPropMap[wID - IDC_PP_DICTATION_CMB].idPropItem;

    if ( idPropItem >= PropId_Max_Item_Id )
    {
        // we don't find the control ID from our list, this is not possible, some thing wrong already.
        // exit here.
        return E_FAIL;
    }

    iIndex = (int)::SendMessage(hWndCtl, CB_GETCURSEL, 0, 0);
    pCurKeyData = (KEYNAME_VK_MAP *)::SendMessage(hWndCtl, CB_GETITEMDATA, iIndex, 0);

    if ( pCurKeyData )
    {
        m_SpPropItemsServer->_SetPropData(idPropItem, pCurKeyData->wVKey);
    }

    return hr;
}

LRESULT CSpModeButtonSetting::OnContextHelp(UINT uMsg, WPARAM wParam, LPARAM lParam,BOOL& bHandled )
{
    HRESULT hr = S_OK;

    switch (uMsg)
    {
    case  WM_HELP  :
	
        ::WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                 c_szHelpFile,
                 HELP_WM_HELP,
                 (DWORD_PTR)(LPTSTR)aSptipButtonDlgIds );
        break;

    case WM_CONTEXTMENU  :      // right mouse click

        ::WinHelp((HWND)wParam,
                 c_szHelpFile,
                 HELP_CONTEXTMENU,
                 (DWORD_PTR)(LPTSTR)aSptipButtonDlgIds );
        break;

    default:
        break;
    }


    return hr;
}


LRESULT CSpModeButtonSetting::OnPushButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl,BOOL& bHandled)
{
    HRESULT  hr=S_OK;
    int      nRetCode;

    Assert(m_SpPropItemsServer);
    Assert(m_SpPropBaseServer);
    Assert(m_IdCtrlPropMap);

    if ( wID != IDOK && wID != IDCANCEL )
        return E_FAIL;

    nRetCode = wID;

    if ( wID == IDOK )
    {
        //Merge back all the change to the base property server.
        m_SpPropBaseServer->_MergeDataFromServer(m_SpPropItemsServer, PropId_MinId_InModeButton, PropId_MaxId_InModeButton);
    }

    EndDialog(nRetCode);
    return hr;
}

//
//
//  Class CSptipPropertyPage
//
//

CSptipPropertyPage::CSptipPropertyPage ( WORD wDlgId, BOOL fLaunchFromInputCpl )
{
    m_wDlgId = wDlgId;
    m_SpPropItemsServer = NULL;
    m_dwNumCtrls = 0;
    m_IdCtrlPropMap = NULL;
    m_SpAdvanceSet = NULL;
    m_SpModeBtnSet = NULL;
    m_hDlg = NULL;
    m_fLaunchFromInputCpl = fLaunchFromInputCpl;
}

CSptipPropertyPage::~CSptipPropertyPage ( )
{
    if ( m_SpPropItemsServer )
        delete m_SpPropItemsServer;

    if ( m_IdCtrlPropMap )
        cicMemFree(m_IdCtrlPropMap);

    if ( m_SpAdvanceSet )
        delete m_SpAdvanceSet;

    if ( m_SpModeBtnSet )
        delete m_SpModeBtnSet;
}


//////////////////////////////////////////////////////////////////////////////
//
//  CSptipPropertyPage::SetDirty
//
//  Description:    When there is any setting changed in the property page   
//                  by user, this function is called to notify the property 
//                  sheet of the status change. Property sheet will activate
//                  Apply button.
//
//  Return Values:  NONE
//
//////////////////////////////////////////////////////////////////////////////
void  CSptipPropertyPage::SetDirty(BOOL fDirty)
{
    HWND hwndParent = ::GetParent( m_hDlg );
    m_fIsDirty = fDirty;
    ::SendMessage( hwndParent, m_fIsDirty ? PSM_CHANGED : PSM_UNCHANGED, (WPARAM)(m_hDlg), 0 );
}


//////////////////////////////////////////////////////////////////////////////
//
//  CSptipPropertyPage::OnCheckButtonSetting
//
//  Description:    Handle all the change in the checked buttons related to   
//                  speech tip setting. the status is Enable/Disable.
//
//  Return Values:  S_OK
//
//////////////////////////////////////////////////////////////////////////////
LRESULT CSptipPropertyPage::OnCheckButtonSetting(WORD wNotifyCode, WORD wID, HWND hWndCtl)
{
    HRESULT         hr = S_OK;
    BOOL            fChecked = FALSE;
    BOOL            fEnable = FALSE;
    PROP_ITEM_ID    idPropItem = PropId_Max_Item_Id;  // means not initialized

    Assert(m_SpPropItemsServer);
    Assert(m_IdCtrlPropMap);

    if ( wNotifyCode != BN_CLICKED )
        return hr;

    // Find the prop item ID associated with this checked box button.
    for ( DWORD i=0; i<m_dwNumCtrls; i++)
    {
        if ( m_IdCtrlPropMap[i].idCtrl == wID )
        {
            idPropItem = m_IdCtrlPropMap[i].idPropItem;
            break;
        }
    }

    if ( idPropItem >= PropId_Max_Item_Id )
    {
        // we don't find the control ID from our list, this is not possible, some thing wrong already.
        // exit here.
        return E_FAIL;
    }

    if ( ::SendMessage(hWndCtl, BM_GETCHECK, 0, 0 ) == BST_CHECKED )
        fChecked = TRUE;

    // Specially handle "Show Balloon" item.

    if ( wID == IDC_PP_SHOW_BALLOON )
        fEnable = !fChecked;
    else
        fEnable = fChecked;

    m_SpPropItemsServer->_SetPropData(idPropItem, fEnable);

    // Specially hanlde Mode Buttons.

    if ( wID == IDC_PP_ASSIGN_BUTTON )
    {
        ::EnableWindow(::GetDlgItem(m_hDlg, IDC_PP_BUTTON_MB_SETTING), fEnable);
    }

    SetDirty(TRUE);

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CSptipPropertyPage::OnPushButtonClicked
//
//  Description:    When pushed button is pressed, this function is called
//                  to respond it.   
//
//  Return Values:  S_OK
//
//////////////////////////////////////////////////////////////////////////////

const TCHAR c_szcplsKey[]    = TEXT("software\\microsoft\\windows\\currentversion\\control panel\\cpls");

LRESULT CSptipPropertyPage::OnPushButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl)
{
    HRESULT hr = S_OK;

    switch (wID)
    {
    case IDC_PP_BUTTON_ADVANCE :

        if (m_SpAdvanceSet)
        {
            delete m_SpAdvanceSet;
            m_SpAdvanceSet = NULL;
        }

        m_SpAdvanceSet = (CSpAdvanceSetting *) new CSpAdvanceSetting( );

        if ( m_SpAdvanceSet )
        {
            int nRetCode;

            nRetCode = m_SpAdvanceSet->DoModalW(m_hDlg, (LPARAM)m_SpPropItemsServer);

            if ( nRetCode == TRUE)
                SetDirty(TRUE);

            delete m_SpAdvanceSet;
            m_SpAdvanceSet = NULL;
        }

        break;

    case IDC_PP_BUTTON_LANGBAR :
        {
            TCHAR szCmdLine[MAX_PATH];
            TCHAR szInputPath[MAX_PATH];
            int cch = GetSystemDirectory(szInputPath, ARRAYSIZE(szInputPath));

            if (cch > 0)
            {
                // GetSystemDirectory appends no '\' unless the system
                // directory is the root, such like "c:\"
                if (cch != 3)
                    StringCchCat(szInputPath,ARRAYSIZE(szInputPath),TEXT("\\"));

                StringCchCat(szInputPath, ARRAYSIZE(szInputPath), TEXT("input.dll"));

                StringCchPrintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("rundll32 shell32.dll,Control_RunDLL \"%s\""),szInputPath);

                // start Language Bar control panel applet
                RunCPLSetting(szCmdLine);
            }

            break;
        }

    case IDC_PP_BUTTON_SPCPL :
        {
            // these have to be Ansi based, as we support non-NT
            TCHAR szCplPath[MAX_PATH];
            TCHAR szCmdLine[MAX_PATH];
            CMyRegKey regkey;

            szCplPath[0] = TEXT('\0');
            if (S_OK == regkey.Open(HKEY_LOCAL_MACHINE, c_szcplsKey, KEY_READ))
            {
                LONG lret;
                
                lret = regkey.QueryValueCch(szCplPath, TEXT("Speech"), ARRAYSIZE(szCplPath));
            }

            if ( szCplPath[0] )
            {
                StringCchPrintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("rundll32 shell32.dll,Control_RunDLL \"%s\""),szCplPath);

                // start speech control panel applet
                RunCPLSetting(szCmdLine);
            }

            break;
        }

    case IDC_PP_BUTTON_MB_SETTING :
        if (m_SpModeBtnSet)
        {
            delete m_SpModeBtnSet;
            m_SpModeBtnSet = NULL;
        }

        m_SpModeBtnSet = (CSpModeButtonSetting *) new CSpModeButtonSetting( );

        if ( m_SpModeBtnSet )
        {
            int nRetCode;
            DWORD   dwDictOrg,  dwCommandOrg;
            DWORD   dwDictNew,  dwCommandNew;

            dwDictOrg = m_SpPropItemsServer->_GetPropData(PropId_Dictation_Key);
            dwCommandOrg = m_SpPropItemsServer->_GetPropData(PropId_Command_Key);

            nRetCode = m_SpModeBtnSet->DoModalW(m_hDlg, (LPARAM)m_SpPropItemsServer);

            dwDictNew = m_SpPropItemsServer->_GetPropData(PropId_Dictation_Key);
            dwCommandNew = m_SpPropItemsServer->_GetPropData(PropId_Command_Key);

            if ( (dwDictNew != dwDictOrg) || (dwCommandNew != dwCommandOrg) )
                SetDirty(TRUE);

            delete m_SpModeBtnSet;
            m_SpModeBtnSet = NULL;
        }

        break;

    default :

        Assert(0);
        break;
    }
    
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CSptipPropertyPage::OnInitSptipPropPageDialog
//
//  Description:    This function responds to the WM_INITDIALOG message
//                  Getting the initial value for all the property items,
//                  and show the correct status in the related control items.   
//
//  Return Values:  S_OK
//
//////////////////////////////////////////////////////////////////////////////
LRESULT CSptipPropertyPage::OnInitSptipPropPageDialog(HWND hDlg )
{
    HRESULT  hr=S_OK;

    m_hDlg = hDlg;

    if ( !m_SpPropItemsServer )
        m_SpPropItemsServer = (CSpPropItemsServer *) new CSpPropItemsServer;

    if ( !m_SpPropItemsServer )
        return E_FAIL;

    if ( !m_IdCtrlPropMap )
    {
        CONTROL_PROP_MAP IdCtrlPropMap[] =
        {
            //    idCtrl,                     idPropItem,            fEdit
            {IDC_PP_SHOW_BALLOON,       PropId_Hide_Balloon,        FALSE},
            {IDC_PP_LMA,                PropId_Support_LMA,         FALSE},    
            {IDC_PP_HIGH_CONFIDENCE,    PropId_High_Confidence,     FALSE},    
            {IDC_PP_SAVE_SPDATA,        PropId_Save_Speech_Data,    FALSE},
            {IDC_PP_REMOVE_SPACE,       PropId_Remove_Space,        FALSE},    
            {IDC_PP_DIS_DICT_TYPING,    PropId_DisDict_Typing,      FALSE},    
            {IDC_PP_PLAYBACK,           PropId_PlayBack,            FALSE},    
            {IDC_PP_DICT_CANDUI_OPEN,   PropId_Dict_CandOpen,       FALSE},    
            {IDC_PP_DICTCMDS,           PropId_Cmd_DictMode,        FALSE},
            {IDC_PP_ASSIGN_BUTTON,      PropId_Mode_Button,         FALSE},   
            { 0,                        PropId_Max_Item_Id,         FALSE }

        };

        DWORD   dwPropItems = ARRAYSIZE(IdCtrlPropMap) -1 ;

        m_IdCtrlPropMap = (CONTROL_PROP_MAP  *)cicMemAlloc(dwPropItems * sizeof(CONTROL_PROP_MAP));

        if ( m_IdCtrlPropMap == NULL )
            return E_OUTOFMEMORY;

        for ( DWORD i=0; i<dwPropItems; i++)
        {
            m_IdCtrlPropMap[i] = IdCtrlPropMap[i];
        }

        m_dwNumCtrls = dwPropItems;
    }


    for (DWORD i=0; i<m_dwNumCtrls; i++ )
    {
        WORD          idCtrl;
        PROP_ITEM_ID  idPropItem;
        BOOL          fEditControl;

        idCtrl = m_IdCtrlPropMap[i].idCtrl;
        idPropItem = m_IdCtrlPropMap[i].idPropItem;
        fEditControl = m_IdCtrlPropMap[i].fEdit;

        // BugBug:  There is no edit control in current property page.
        // all the edit controls are moved to advanced setting dialog.
        // temporally keep the code here, but after we finish the code for the 
        // advcanced setting dialog, please optimize code here.
        //
        if ( fEditControl )
        {
            ::SetDlgItemInt(m_hDlg, idCtrl, (UINT)m_SpPropItemsServer->_GetPropData(idPropItem), TRUE);
        }
        else
        {
            BOOL    fEnable;
            LPARAM  bst_Status;

            fEnable = (BOOL)m_SpPropItemsServer->_GetPropData(idPropItem);

            // Specially handle "Show Balloon" button.
            // Since internally we have "Hide_Balloon" property, it should be oppsite to 
            // to the check status of the button.

            if ( idPropItem == PropId_Hide_Balloon )
                bst_Status = fEnable ? BST_UNCHECKED : BST_CHECKED;
            else
                bst_Status = fEnable ? BST_CHECKED : BST_UNCHECKED;
            
            ::SendDlgItemMessage(m_hDlg, idCtrl, BM_SETCHECK, bst_Status, 0);
        }
    }

    // Specially handle the Mode button settings.

    if (! m_SpPropItemsServer->_GetPropData(PropId_Mode_Button) )
    {
        ::EnableWindow(::GetDlgItem(m_hDlg, IDC_PP_BUTTON_MB_SETTING), FALSE);
    }

    // if the property page is launched from input cpl, we don't want to show 
    // language bar buttons in this page.

    if ( m_fLaunchFromInputCpl )
    {
        ::ShowWindow(::GetDlgItem(m_hDlg, IDC_PP_BUTTON_LANGBAR), SW_HIDE);
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CSptipPropertyPage::OnApply
//
//  Description:    When Apply or OK button is clicked, this function will
//                  check if there is any item status change, if changed,
//                  save the data to the persistent storage, and notify 
//                  Cicero application to update their status.
//
//  Return Values:  S_OK
//
//////////////////////////////////////////////////////////////////////////////
LRESULT CSptipPropertyPage::OnApply( ) 
{
    HRESULT hr = S_OK; 

    if ( !IsPageDirty( ) ) return hr;

    // change the registry settings here. !!!
    Assert(m_SpPropItemsServer);
    m_SpPropItemsServer->_SavePropData( );

    // Notify all the Cicero Applications of these registry settings change.

    if ( SUCCEEDED(hr) )
    {
        hr = _SetGlobalCompDWORD(GUID_COMPARTMENT_SPEECH_PROPERTY_CHANGE, 1);
    }

    if (SUCCEEDED(hr))
    {
        SetDirty(FALSE);
    }
    
	return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CSptipPropertyPage::SpPropertyPageProc
//
//  Description:    Message handling procedure callback function for 
//                  the dialog.
//
//  Return Values:  required value per message.
//
//////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CSptipPropertyPage::SpPropertyPageProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    INT iRet = 0;
    CSptipPropertyPage *pSpProp = (CSptipPropertyPage *)::GetWindowLongPtr(hDlg, GWLP_USERDATA);

    switch (message)
    {
    case WM_INITDIALOG:
        {
            PROPSHEETPAGEW *pPropSheetPage =  (PROPSHEETPAGEW *)(lParam);

            Assert(pPropSheetPage);

            ::SetWindowLongPtr(hDlg, GWLP_USERDATA, pPropSheetPage->lParam);
            pSpProp = (CSptipPropertyPage *)(pPropSheetPage->lParam);

            if ( pSpProp )
               pSpProp->OnInitSptipPropPageDialog(hDlg);

            iRet = TRUE;

            break;
        }

    case WM_NOTIFY:

        Assert(pSpProp);
        switch (((NMHDR*)lParam)->code)
        {
        case PSN_APPLY:

            pSpProp->OnApply();
            break;

        case PSN_QUERYCANCEL:  // user clicks the Cancel button

            //pSpProp->OnCancel();
            break;
        }
        break;

    case  WM_HELP  :
	
        WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                 c_szHelpFile,
                 HELP_WM_HELP,
                 (DWORD_PTR)(LPTSTR)aSptipPropIds );
        break;

    case  WM_CONTEXTMENU  :      // right mouse click
    
        WinHelp( (HWND)wParam,
                 c_szHelpFile,
                 HELP_CONTEXTMENU,
                 (DWORD_PTR)(LPTSTR)aSptipPropIds );
        break;
    
    case ( WM_COMMAND ) :
        {
            Assert(pSpProp);

            switch (LOWORD(wParam))
            {
            case IDC_PP_SHOW_BALLOON        :
            case IDC_PP_LMA                 :       
            case IDC_PP_HIGH_CONFIDENCE     :           
            case IDC_PP_SAVE_SPDATA         :          
            case IDC_PP_REMOVE_SPACE        :         
            case IDC_PP_DIS_DICT_TYPING     :          
            case IDC_PP_PLAYBACK            :              
            case IDC_PP_DICT_CANDUI_OPEN    :
            case IDC_PP_DICTCMDS            :
            case IDC_PP_ASSIGN_BUTTON       :
                
                if ( pSpProp )
                   pSpProp->OnCheckButtonSetting( HIWORD(wParam), LOWORD(wParam), (HWND)lParam );
                break;

            case IDC_PP_BUTTON_MB_SETTING   :
            case IDC_PP_BUTTON_ADVANCE      :
            case IDC_PP_BUTTON_LANGBAR      :
            case IDC_PP_BUTTON_SPCPL        :
                
                if ( pSpProp )
                   pSpProp->OnPushButtonClicked( HIWORD(wParam), LOWORD(wParam), (HWND)lParam );

                break;

            default :
                iRet = 0;
            }

            iRet = TRUE;
            break;
        }

    case  WM_DESTROY :
        {
            Assert(pSpProp);

            if ( pSpProp )
                delete pSpProp;

            break;
        }
    }

    return (iRet);
}

//
// CSapiIMX::InvokeSpeakerOptions 
//
//
void CSapiIMX::_InvokeSpeakerOptions( BOOL fLaunchFromInputCpl )
{
    PROPSHEETHEADERW psh;
    HPROPSHEETPAGE  phPages[2];

    // check if this proppage has already shown up and got focus.

    HWND    hWndFore;

    hWndFore = ::GetForegroundWindow( );

    if ( hWndFore )
    {
        WCHAR   wszTextTitle[MAX_PATH];

        GetWindowTextW(hWndFore, wszTextTitle, ARRAYSIZE(wszTextTitle));

        if ( wcscmp(wszTextTitle, CRStr(IDS_PROPERTYPAGE_TITLE)) == 0 )
        {
            // the proppage has beeb shown and got focus.
            // don't show it again.

            return;
        }
    }
       
    ::InitCommonControls( );

    // Initialize the property sheet header.
    psh.dwSize = sizeof(PROPSHEETHEADERW);
    psh.dwFlags = 0;
    psh.hwndParent = ::GetActiveWindow( );
    psh.hInstance = GetCicResInstance(g_hInst, IDS_PROPERTYPAGE_TITLE);
    psh.pszCaption = MAKEINTRESOURCEW(IDS_PROPERTYPAGE_TITLE);
    psh.nStartPage = 0;
    psh.phpage = phPages;
    psh.nPages = 0;

    // Add one page for now.
    // extendable for the future.

    CSptipPropertyPage  *pSpProp = (CSptipPropertyPage *) new CSptipPropertyPage(IDD_PROPERTY_PAGE, fLaunchFromInputCpl);

    if ( pSpProp )
    {
        PROPSHEETPAGEW   psp;

        psp.dwSize = sizeof(PROPSHEETPAGEW);
        psp.dwFlags = PSP_DEFAULT;
        psp.hInstance = GetCicResInstance(g_hInst, pSpProp->GetDlgResId());
        psp.pszTemplate = MAKEINTRESOURCEW( pSpProp->GetDlgResId( ) );
        psp.pfnDlgProc = pSpProp->GetDlgProc( );
        psp.lParam = (LPARAM) pSpProp;

        phPages[psh.nPages] = ::CreatePropertySheetPageW(&psp);

        if (phPages[psh.nPages])
            psh.nPages ++;
    }

    // If there is at least one page exists, create the property sheet.
    //
    if ( psh.nPages > 0 )
        ::PropertySheetW(&psh);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\recosleep.h ===
// RecoSleep.h : implement "Go to Sleep" and "Wakeup" commands.

#ifndef RECO_SLEEP_H
#define RECO_SLEEP_H

#include "private.h"
#include "sapilayr.h"
#include "sapi.h"

class CSpTask;
class CRecoSleepClass
{
public:

    CRecoSleepClass(CSpTask *pSpTask ); 
    ~CRecoSleepClass( );

    HRESULT InitRecoSleepClass( );
    HRESULT ProcessSleepGrammar( SPPHRASE *pPhrase );

    static void NotifyCallback(WPARAM wParam, LPARAM lParam );

    BOOL   IsInSleep( )  { return  m_fSleeping; }

private:
    
    CSpTask                *m_pSpTask;
    CComPtr<ISpRecognizer>  m_cpRecoEngine;
    CComPtr<ISpRecoContext> m_cpRecoContext;
    CComPtr<ISpRecoGrammar> m_cpSleepGrammar;

    WCHAR                   m_wszRule[MAX_PATH];
    WCHAR                   m_wszSleep[MAX_PATH];
    WCHAR                   m_wszWakeup[MAX_PATH];
    BOOL                    m_fSleeping;

    SPSTATEHANDLE           m_hSleepRule;
    BOOL                    m_Initialized;
};

#endif  // RECO_SLEEP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\propstor.cpp ===
//
// property store class implementation
//

// includes
#include "private.h"
#include "globals.h"
#include "sapilayr.h"
#include "propstor.h"
#include "ids.h"
#include "cicspres.h"
#include "lmlattic.h"

#ifdef DEBUG

#include "wchar.h"

void DebugPrintOut(WCHAR   *pwszStrName, WCHAR  *pwszStr)
{

    WCHAR   wszBuf[80];
    int     iLen, i, j;

    TraceMsg(TF_GENERAL, "the value of %S is", pwszStrName );

    iLen = wcslen(pwszStr);

    j = 0;
    for ( i=0; i<iLen; i++)
    {
        if ( (pwszStr[i] < 0x80) && pwszStr[i] > 0x1f )
        {
            wszBuf[j] = pwszStr[i];
            j ++;
        }
        else
        {
            WCHAR  buf[8];

            StringCchPrintfW(buf, ARRAYSIZE(buf), L" %4X ", (int)pwszStr[i] );

            for ( int x=0; x< (int)wcslen(buf); x++)
            {
                wszBuf[j] = buf[x];
                j++;
            }
        }
    }

    wszBuf[j] = L'\0';

    TraceMsg(TF_GENERAL, "%S", wszBuf);
}
#endif

// ------------------------------------------------------------------------------------------------------------
//  This is a global or standalone function which will be called by CRecoResultWrap and CSapiAlternativeList
//
//  This function receives the phrase text buffer, this element's display text and display attribute, and 
//  previous element's display attribute.
//
//  On Exit, it will update the phrase text buffer to append this element's text, and return the real offset
//  length value for this element.
//
// -------------------------------------------------------------------------------------------------------------

HRESULT   HandlePhraseElement( CSpDynamicString *pDstr, const WCHAR  *pwszTextThis, BYTE  bAttrThis, BYTE bAttrPrev, ULONG  *pulOffsetThis)
{
    HRESULT  hr=S_OK;

    ULONG  ulPrevLen;

    if ( !pDstr || !pwszTextThis )
        return E_INVALIDARG;

    ulPrevLen = pDstr->Length( );

    if ( (ulPrevLen > 0) && (bAttrThis & SPAF_CONSUME_LEADING_SPACES) )
    {
       // This element wants to remove the trailing spaces of the previous element.
        ULONG  ulPrevTrailing = 0;

        if ( bAttrPrev &  SPAF_ONE_TRAILING_SPACE )
            ulPrevTrailing = 1;
        else if ( bAttrPrev & SPAF_TWO_TRAILING_SPACES )
            ulPrevTrailing = 2;

        if ( ulPrevLen >= ulPrevTrailing )
        {
            ulPrevLen = ulPrevLen - ulPrevTrailing;
            pDstr->TrimToSize(ulPrevLen);
        }
    }

    if ( pulOffsetThis )
        *pulOffsetThis = ulPrevLen;
      
    pDstr->Append(pwszTextThis);
          
    if (bAttrThis & SPAF_ONE_TRAILING_SPACE)
    {
        pDstr->Append(L" ");
    }
    else if (bAttrThis & SPAF_TWO_TRAILING_SPACES)
    {
        pDstr->Append(L"  ");
    }
    
    return hr;
}

//
// CRecoResult implementation
//

// ctor

CRecoResultWrap::CRecoResultWrap(CSapiIMX *pimx, ULONG ulStartElement, ULONG ulNumElements, ULONG ulNumOfITN) 
{
    m_cRef = 1;
    m_ulStartElement = ulStartElement;
    m_ulNumElements = ulNumElements;
    
    // ITN is shown by default if the reco result has it
    // the shown status can change after user goes through
    // correction UI
    //

    m_ulNumOfITN = ulNumOfITN;

    m_pimx = pimx;

    m_pulElementOffsets = NULL;
    m_bstrCurrentText   = NULL;   

    m_OffsetDelta = 0;
    m_ulCharsInTrail = 0;
    m_ulTrailSpaceRemoved = 0;
    m_pSerializedRecoResult = NULL;

#ifdef DEBUG
    static DWORD s_dbg_Id = 0;
    m_dbg_dwId = s_dbg_Id++;
#endif // DEBUG
}

CRecoResultWrap::~CRecoResultWrap()  
{
    if (m_pulElementOffsets)
        delete[] m_pulElementOffsets;

    if (m_bstrCurrentText)
        SysFreeString(m_bstrCurrentText);

    if (m_rgITNShowState.Count())
        m_rgITNShowState.Clear();

    if (m_pSerializedRecoResult)
    {
        CoTaskMemFree(m_pSerializedRecoResult);
    }
}

//
// Init function
//
HRESULT CRecoResultWrap::Init(ISpRecoResult *pRecoResult)
{
    // serialize the given reco result and keep the cotaskmem
    if (m_pSerializedRecoResult != NULL)
    {
        CoTaskMemFree(m_pSerializedRecoResult);
    }
    
    Assert(pRecoResult);

    return pRecoResult->Serialize(&m_pSerializedRecoResult);
}

//
// GetResult
//
HRESULT CRecoResultWrap::GetResult(ISpRecoResult **ppResult)
{
    if ( m_pSerializedRecoResult == NULL)
        return E_PENDING;

    // this is a tricky part, we need to access ISpRecoContext
    // and don't want to hold onto it. We get it via CSapiIMX
    // instance which must be always available during session
    //
    Assert(m_pimx);

    CComPtr<ISpRecoContext> cpRecoCtxt;

    //
    // GetFunction ensures SAPI is initialized
    //
    HRESULT hr = m_pimx->GetFunction(GUID_NULL, IID_ISpRecoContext, (IUnknown **)&cpRecoCtxt);
    if (S_OK == hr)
    {
        hr = cpRecoCtxt->DeserializeResult(m_pSerializedRecoResult, ppResult);
    }

    //
    // callar is resposible to release this result object
    //
    return hr;
}

//
// IUnknown
//
STDMETHODIMP CRecoResultWrap::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hr;
    Assert(ppvObj);
    
    if (IsEqualIID(riid, IID_IUnknown)
    ||  IsEqualIID(riid, IID_PRIV_RESULTWRAP)
    ||  IsEqualIID(riid, IID_IServiceProvider))
    {
        *ppvObj = this;
        hr = S_OK;
        this->m_cRef++;
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }
    return hr;
}

STDMETHODIMP_(ULONG) CRecoResultWrap::AddRef(void)
{
    this->m_cRef++;
    return this->m_cRef;
}

STDMETHODIMP_(ULONG) CRecoResultWrap::Release(void)
{
    this->m_cRef--;
    if (this->m_cRef > 0)
    {
        return this->m_cRef;
    }
    delete this;
    return 0;
}

// IServiceProvider
//
STDMETHODIMP CRecoResultWrap::QueryService(REFGUID guidService,  REFIID riid,  void** ppv)
{
    HRESULT hr = S_OK;
    Assert(ppv);
    
    if (!IsEqualIID(guidService, GUID_NULL))
    {
        hr =  E_FAIL;
    }
    
    if (SUCCEEDED(hr))
    {
        if (IsEqualIID(riid, IID_IUnknown))
        {
            *ppv = this;
            hr = S_OK;
            this->m_cRef++;
        }
        else if (IsEqualIID(riid, IID_ISpRecoResult))
        {
            CComPtr<ISpRecoResult> cpResult;

            hr = GetResult(&cpResult);
            if (S_OK == hr)
            {
                hr = cpResult->QueryInterface(riid, ppv);
            }
        }
        else
        {
            *ppv = NULL;
            hr = E_NOINTERFACE;
        }
    }
    return hr;
}


//
// Clone this RecoResultWrap object.
//
HRESULT CRecoResultWrap::Clone(CRecoResultWrap **ppRw)
{
    HRESULT                 hr = S_OK;
    CRecoResultWrap         *prw;
    CComPtr<ISpRecoResult>  cpResult;
    ULONG                   iIndex;

    if ( !ppRw ) return E_INVALIDARG;

    *ppRw = NULL;
         
    prw = new CRecoResultWrap(m_pimx, m_ulStartElement, m_ulNumElements, m_ulNumOfITN);
    if ( prw )
    {
        hr = GetResult(&cpResult);

        if (S_OK == hr)
        {
            hr = prw->Init(cpResult);
        }

        if (S_OK == hr)
        {
            prw->SetOffsetDelta(m_OffsetDelta);
            prw->SetCharsInTrail(m_ulCharsInTrail);
            prw->SetTrailSpaceRemoved( m_ulTrailSpaceRemoved );
            prw->m_bstrCurrentText = SysAllocString((WCHAR *)m_bstrCurrentText);

            // Update ITN show-state list .

            if ( m_ulNumOfITN > 0 )
            {
                SPITNSHOWSTATE  *pITNShowState;

                for (iIndex=0; iIndex<m_ulNumOfITN; iIndex ++ )
                {
                    pITNShowState = m_rgITNShowState.GetPtr(iIndex);

                    if ( pITNShowState)
                    {
                        prw->_InitITNShowState(
                                     pITNShowState->fITNShown, 
                                     pITNShowState->ulITNStart, 
                                     pITNShowState->ulITNNumElem);
                    }
                } // for
            } // if

            // Update the Offset list for the second range.

            if (m_pulElementOffsets)
            {
                ULONG  ulOffset;
                ULONG  ulNumOffset;

                ulNumOffset = m_ulStartElement+m_ulNumElements;

                for ( iIndex=0; iIndex <= ulNumOffset; iIndex ++ )
                {
                    ulOffset = m_pulElementOffsets[iIndex];
                    prw->_SetElementNewOffset(iIndex, ulOffset);
                }
            }
        }

        if ( S_OK == hr )
        {
           // Return this prw to the caller.
            *ppRw = prw;
        }
        else 
        {
            // Something wrong when update the data members.
            // Release the newly created object.
            delete prw;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//
//   _SpeakAudio()
//
//   synopsis: playback audio based on the elements used in this result object
//
HRESULT CRecoResultWrap::_SpeakAudio(ULONG ulStart, ULONG ulcElem)
{
    HRESULT hr = E_FAIL;
    CComPtr<ISpRecoResult> cpResult;

    hr = GetResult(&cpResult);

    if (S_OK == hr)
    {
        if (ulcElem == 0)
        {
            ulStart = GetStart();
            ulcElem = GetNumElements();
        }
        hr = cpResult->SpeakAudio( ulStart, ulcElem, SPF_ASYNC, NULL);
    }
    return hr;
}

//
//    _SetElementOffset(ULONG  ulElement, ULONG ulNewOffset);
//
//    This function is to update the offset for some element.
//    It is used after property divide or shrink, some element's
//    length is changed ( by removing trailing spaces etc.).
//

HRESULT  CRecoResultWrap::_SetElementNewOffset(ULONG  ulElement, ULONG ulNewOffset)
{
    HRESULT  hr = S_OK;

    
    if ((ulElement > m_ulStartElement + m_ulNumElements) || (ulElement < m_ulStartElement))
    {
        // This ulElement is not a valid element.
        hr = E_INVALIDARG;
        return hr;
    }

    if (!m_pulElementOffsets)
    {
        m_pulElementOffsets = new ULONG[m_ulStartElement+m_ulNumElements+1];
  
        if ( !m_pulElementOffsets )
            return E_OUTOFMEMORY;
        else
           for ( ULONG i=0; i<m_ulStartElement+m_ulNumElements+1; i++ )
                 m_pulElementOffsets[i] = -1;
    }

    m_pulElementOffsets[ulElement] = ulNewOffset;

    return hr;
}


//
//    _GetElementOffsetCch
//
//    synopsis: returns the start cch of the given SPPHRASEELEMENT
//
ULONG   CRecoResultWrap::_GetElementOffsetCch(ULONG ulElement)
{
    ULONG ulOffset = 0;
    
    if (ulElement > m_ulStartElement + m_ulNumElements)
    {
         Assert(m_ulNumElements > 0);
         ulElement = m_ulStartElement + m_ulNumElements;
    }
    else if (ulElement < m_ulStartElement)
    {
        ulElement = m_ulStartElement;
    }
    
    if (!m_pulElementOffsets)
    {
        _SetElementOffsetCch(NULL);
    }

    // m_pulElement could be null at memory stressed situation
    if ( m_pulElementOffsets )
    {
        ulOffset = m_pulElementOffsets[ulElement];
    }

    return ulOffset;
}

//
//    _SetElementOffsetCch
//
//    synopsis:  
//
//
//  Before this function is called, we have to make sure that all the internal ITN show-state list 
//  has already been updated for the current phrase.
//
//  So here we just relay on the correct ITN information to get the right real text string for 
//  current phrase and the offsets of all elemenets in this phrase.

void   CRecoResultWrap::_SetElementOffsetCch(ISpPhraseAlt *pAlt)
{
    if (m_pulElementOffsets)
    {
        delete[] m_pulElementOffsets;

        m_pulElementOffsets = NULL;
    }
        
    SPPHRASE *pPhrase = NULL;
    HRESULT  hr       = S_OK;

    CComPtr<ISpPhrase> cpPhrase;

    if (pAlt)
    {
       cpPhrase = pAlt;
    }
    else
    {
        CComPtr<ISpRecoResult> cpResult;
        hr = GetResult(&cpResult);

        //
        // we're called for initialization, use current parent pharse object
        //
        cpPhrase = cpResult;
    }

    if (S_OK == hr)
    {
        _UpdateInternalText(cpPhrase);
        
        hr = cpPhrase->GetPhrase(&pPhrase);
    }

    ULONG cElements = 0;
    if (S_OK == hr && pPhrase)
    {
        cElements = pPhrase->Rule.ulCountOfElements;

        // the last colmun (+1) shows offset for the end of the last element

        if ( m_pulElementOffsets )
            delete[] m_pulElementOffsets;

        m_pulElementOffsets = new ULONG[cElements+1]; 
    
        if (cElements > 0 && m_pulElementOffsets)
        {
            CSpDynamicString dstr;
            CSpDynamicString dstrReplace;
        
             
            for (ULONG i = 0; i < cElements; i++ )
            {
                BOOL      fInsideITN;
                ULONG     ulITNStart, ulITNNumElem;
                
                fInsideITN = _CheckITNForElement(pPhrase, i, &ulITNStart, &ulITNNumElem, (CSpDynamicString *)&dstrReplace);

                if ( fInsideITN )
                {
                    m_pulElementOffsets[i] = dstr.Length();

                    // This element is inside an ITN range.
                    if ( i == (ulITNStart + ulITNNumElem - 1) )
                    {
                        // This is the last element of the new ITN.
                        // we need to add the replace text to the dstr string 
                        // so that next non-ITN element will get correct offset.

                        dstr.Append( (WCHAR *)dstrReplace );
                    }
                }
                else
                {
                    if (pPhrase->pElements[i].pszDisplayText)
                    {
                        // get cch up to this element. 
                        // the offset is 0 for elem 0
                        //
                        const WCHAR   *pwszTextThis;
                        BYTE           bAttrThis = 0;
                        BYTE           bAttrPrev = 0;
                        ULONG          ulOffset = 0;

                        pwszTextThis = pPhrase->pElements[i].pszDisplayText;
                        bAttrThis = pPhrase->pElements[i].bDisplayAttributes;

                        if ( i > 0 )
                            bAttrPrev = pPhrase->pElements[i-1].bDisplayAttributes;

                        HandlePhraseElement( (CSpDynamicString *)&dstr, pwszTextThis, bAttrThis, bAttrPrev,&ulOffset);
                        m_pulElementOffsets[i] = ulOffset;
                    }
                }
            } // for 
            
            // store the last columun
            m_pulElementOffsets[cElements] = dstr.Length() - m_ulTrailSpaceRemoved;

        } // if m_pulElementOffsets
    }
    
    if (pPhrase)
        ::CoTaskMemFree(pPhrase);
}

//
// _UpdateInternalText()
//
// synopsis: this function updates the internal bstr that covers
//           parent phrase wrapped by our own result object, based on 
//           the given phrase object and our internal pointer to
//           the starting element and # of element
//
// perf after beta1: consolidate this with _SetElementOffsetCch()
//
//
void CRecoResultWrap::_UpdateInternalText(ISpPhrase *pSpPhrase)
{
    CSpDynamicString dstrReplace;
    CSpDynamicString dstr;
    CSpDynamicString dstrDelta, dstrTrail;
    ULONG            ulLenCurText = 0;

    if ( m_bstrCurrentText )
    {
        ulLenCurText = wcslen(m_bstrCurrentText);

        if ( m_OffsetDelta > 0 &&  m_OffsetDelta <= ulLenCurText )
        {
            dstrDelta.Append(m_bstrCurrentText, m_OffsetDelta);
        }

        if ( m_ulCharsInTrail > 0  && m_ulCharsInTrail <= ulLenCurText )
        {
            WCHAR   *pwszTrail;

            pwszTrail = m_bstrCurrentText + ulLenCurText - m_ulCharsInTrail ;
            dstrTrail.Append(pwszTrail, m_ulCharsInTrail);
        }
    }
    else
    {
        // m_bstrCurrentText doesn't exist, but m_OffsetDelta or m_ulCharsInTrail
        // is not 0, sounds it is not a possible case.

        // But for safety sake, we just still keep the same number of spaces.

        if ( m_OffsetDelta > 0 )
        {
           for (ULONG i=0; i<m_OffsetDelta; i++)
               dstrDelta.Append(L" ");
        }

        if ( m_ulCharsInTrail > 0 )
        {
           for (ULONG i=0; i<m_ulCharsInTrail; i++)
               dstrTrail.Append(L" ");
        }
    }

    if ( m_ulNumElements == 0 )
    {
        // There is no valid element in this range.
        //
        // Just keep the delta string and Trailing string if they are existing.

        if ( m_OffsetDelta > 0 )
            dstr.Append( (WCHAR *)dstrDelta );

        if ( m_ulCharsInTrail > 0)
            dstr.Append((WCHAR *)dstrTrail);

        if ( m_bstrCurrentText )
            SysFreeString(m_bstrCurrentText);

        m_bstrCurrentText = SysAllocString((WCHAR *)dstr);

        return;
    }
    

    if ( pSpPhrase == NULL )
        return;

    // We cannot call pPhrase->GetText( ) to get the real phrase text, because GetText(  ) 
    // assumes all the ITN range have the same show-state, ( ITN or NON_ITN).
    // But there are some cases like some ITN shown as ITN, some other ITN ranges shown as normal 
    // text after user selects a candidate.
    // 

    // When the reco wrapper is first generated right after the text is recognized by SR engine,
    // we can call GetText(  ) to get the real text of the phrase.
    //
    // After that, user may change it by selecting alternative text.
    
    dstr.Clear( );

    if(m_OffsetDelta > 0)
    {
        // There are some characters which are not part of any elements in the range begining.
        // we need to keep these characters.

        dstr.Append((WCHAR *)dstrDelta);
    }
     
    if (m_bstrCurrentText) 
    {
       SysFreeString(m_bstrCurrentText);
       m_bstrCurrentText = NULL;
    }

    SPPHRASE *pPhrase = NULL;

    pSpPhrase->GetPhrase(&pPhrase);

    for (ULONG i = m_ulStartElement; i < m_ulStartElement + m_ulNumElements; i++ )
    {
        BOOL      fInsideITN;
        ULONG     ulITNStart, ulITNNumElem;
                
        fInsideITN = _CheckITNForElement(pPhrase, i, &ulITNStart, &ulITNNumElem, (CSpDynamicString *)&dstrReplace);

        if ( fInsideITN )
        {
            // This element is inside an ITN range.
            if ( i == (ulITNStart + ulITNNumElem - 1) )
            {
                // This is the last element of the new ITN.
                // we need to add the replace text to the dstr string 
                // so that next non-ITN element will get correct offset.

                dstr.Append( (WCHAR *)dstrReplace );
            }
        }
        else
        {
            if (pPhrase->pElements[i].pszDisplayText)
            {
                const WCHAR   *pwszTextThis;
                BYTE           bAttrThis = 0;
                BYTE           bAttrPrev = 0;

                pwszTextThis = pPhrase->pElements[i].pszDisplayText;
                bAttrThis = pPhrase->pElements[i].bDisplayAttributes;

                if ( i > m_ulStartElement )
                    bAttrPrev = pPhrase->pElements[i-1].bDisplayAttributes;

                HandlePhraseElement( (CSpDynamicString *)&dstr, pwszTextThis, bAttrThis, bAttrPrev,NULL);
            }
        }
    } // for 
            
    if ( m_ulCharsInTrail > 0)
        dstr.Append((WCHAR *)dstrTrail);

    // If there were some trail spaces removed, we also need to remove the same number of spaces when
    // we try to get the new phrase text.

    if ( m_ulTrailSpaceRemoved > 0 )
    {
        ULONG   ulNewRemoved = 0;
        WCHAR   *pwszNewText = (WCHAR *)dstr;

        ulLenCurText = wcslen(pwszNewText);
        
        for (ULONG i=ulLenCurText-1; ((long)i>0) && (ulNewRemoved <= m_ulTrailSpaceRemoved); i-- )
        {
            if ( pwszNewText[i] == L' ' )
            {
                pwszNewText[i] = L'\0';
                ulNewRemoved ++;
            }
            else
                break;
        }

        m_ulTrailSpaceRemoved = ulNewRemoved;
    }

    // store the last columun
    m_bstrCurrentText = SysAllocString((WCHAR *)dstr);

    if ( pPhrase )
        ::CoTaskMemFree(pPhrase);
        
}

BOOL CRecoResultWrap::_CanIgnoreChange(ULONG ich, WCHAR *pszChange, int cch)
{
    // see if the given text is within tolerable range
    
    BOOL bret = FALSE;
    WCHAR *pszCurrentText = NULL;
    
    // set up an offset to the current face text
    if (m_bstrCurrentText)
    {
        if (ich < SysStringLen(m_bstrCurrentText))
        {
            pszCurrentText = m_bstrCurrentText;
            pszCurrentText += ich;
        }
    }
    // 1) compare it ignoring the case
    if (pszCurrentText)
    {
        int i = _wcsnicmp(pszCurrentText, pszChange, cch);
        if (i == 0)
        {
           bret = TRUE;
        }
    }
    return bret;
}

//------------------------------------------------------------------------------------------//
//
//  CRecoResultWrap::_RangeHasITN
//
//  Determine if the partial of phrase between ulStart Element and ulStart+ulcElement -1 
//  has ITN.
//
//  return the ITN number,  or 0 if there is no ITN.
//
//------------------------------------------------------------------------------------------//

ULONG  CRecoResultWrap::_RangeHasITN(ULONG  ulStartElement, ULONG  ulNumElements)
{
    ULONG   ulNumOfITN = 0;
    CComPtr<ISpRecoResult> cpResult;
    HRESULT  hr;

    hr = GetResult(&cpResult);

    // determine whether this partial result has an ITN
    SPPHRASE *pPhrase;
    if (S_OK == hr)
        hr = cpResult->GetPhrase(&pPhrase);

    if (S_OK == hr)
    {
        const SPPHRASEREPLACEMENT *pRep = pPhrase->pReplacements;
        for (ULONG ul = 0; ul < pPhrase->cReplacements; ul++)
        {
            // review: we need to verify if this is really a correct way to determine
            // whether the ITN fits in the partial result
            //
            if (pRep->ulFirstElement >= ulStartElement
                && (pRep->ulFirstElement + pRep->ulCountOfElements) <= (ulStartElement + ulNumElements))
            {
                ulNumOfITN ++;
            }
            pRep++;
        }
        ::CoTaskMemFree(pPhrase);
    }

    return ulNumOfITN;
}

// -----------------------------------------------------------------------------------------
//  CRecoResultWrap::_InitITNShowState
//
//  It will initialize show-state for the given ITN  or all the ITNs in this recowrap.
//
//  Normally this function will be called after the reco wrapper is genertaed.
//
//  When the reco wrap is first generated after a text is recognized by SR engine, all the 
//  ITNs in this reco wrap have the same showstate, it is convinent to set the show state
//  for all the ITNs at one time. in this case, caller could just set both ulITNStart and 
//  ulITNNumElements as 0.
//
//  When the new reco wrap is generated by property divide, shrink or deserialized from
//  IStream, or after an alternative text is selected from candidate window, we cannot 
//  assume all the ITNs in the reco wrapper have the same show state. In this case, 
//  caller can initialize the show state one ITN by one ITN, it can set ulITNStart and 
//  ulITNNumElements to identify this ITN.
//
// ------------------------------------------------------------------------------------------

HRESULT  CRecoResultWrap::_InitITNShowState(BOOL  fITNShown, ULONG ulITNStart, ULONG ulITNNumElements )
{

    HRESULT   hr = S_OK;
    ULONG     ulNumOfITN = 0;
    SPPHRASE *pPhrase;

    TraceMsg(TF_GENERAL, "CRecoResultWrap::_InitITNShowState is called");

    if ( m_ulNumOfITN == 0 ) 
    {
        // There is no ITN in this reco wrapper, just return here.
        TraceMsg(TF_GENERAL, "There is no ITN");
        return hr;
    }

    // The list of SPITNSHOWSTATE is already generated, we just need to set the value for 
    // every structure member.

    if ( (ulITNStart == 0 ) && (ulITNNumElements == 0 ) )
    {
        // All the ITNs in this Reco wrapper have the same show status.
        // we will calculate the every ITN start and end elements based 
        // on current reco result phrase.

        // We want to alloc the structure list.

        if ( m_rgITNShowState.Count( ) )
            m_rgITNShowState.Clear( );

        m_rgITNShowState.Append(m_ulNumOfITN);


        CComPtr<ISpRecoResult> cpResult;

        hr = GetResult(&cpResult);
        if (S_OK == hr)
        {
            hr = cpResult->GetPhrase(&pPhrase);
        }

        if (S_OK == hr)
        {
            const SPPHRASEREPLACEMENT *pRep = pPhrase->pReplacements;
            for (ULONG ul = 0; ul < pPhrase->cReplacements; ul++)
            {
                if (pRep->ulFirstElement >= m_ulStartElement
                    && (pRep->ulFirstElement + pRep->ulCountOfElements) <= (m_ulStartElement + m_ulNumElements))
                {
                    // Get an ITN

                    SPITNSHOWSTATE  *pITNShowState;

                    if ( pITNShowState = m_rgITNShowState.GetPtr(ulNumOfITN))
                    {
                        pITNShowState->ulITNStart = pRep->ulFirstElement;
                        pITNShowState->ulITNNumElem = pRep->ulCountOfElements;
                        pITNShowState->fITNShown = fITNShown;
                    }

                    ulNumOfITN ++;

                    if ( ulNumOfITN > m_ulNumOfITN )
                    {
                        // Something wrong, return here to avoid AV
                        break;
                    }
                }
                pRep++;
            }
            ::CoTaskMemFree(pPhrase);
        }
    }
    else
    {
        // Set the display status for given ITN.
        // Check to see if this is a valid ITN.
        if ( ulITNNumElements > 0 )
        {
            ULONG   ulIndex = 0;
            SPITNSHOWSTATE  *pITNShowState = NULL;

            ulIndex = m_rgITNShowState.Count( );

            m_rgITNShowState.Append(1);

            if ( pITNShowState = m_rgITNShowState.GetPtr(ulIndex))
            {
                pITNShowState->ulITNStart = ulITNStart;
                pITNShowState->ulITNNumElem = ulITNNumElements;
                pITNShowState->fITNShown = fITNShown;
            }
        }
    }

    return hr;
}

// --------------------------------------------------------------------------------------------
//  CRecoResultWrap::_InvertITNShowStateForRange
//
//  Invert the show state for all the ITNs in the give range ( ulStartElement, to ulNumElements)
//
//  
// --------------------------------------------------------------------------------------------

HRESULT  CRecoResultWrap::_InvertITNShowStateForRange( ULONG  ulStartElement,  ULONG ulNumElements )
{
    HRESULT  hr = S_OK;

    TraceMsg(TF_GENERAL,"CRecoResultWrap::_InvertITNShowStateForRange is called, ulStartElement=%d ulNumElements=%d", ulStartElement,ulNumElements); 
    if ( m_ulNumOfITN > 0  && ulNumElements > 0 )
    {
        //
        // check to see if there is any ITN inside the given range.
        //
        ULONG   ulIndex = 0;

        for ( ulIndex=0; ulIndex < m_ulNumOfITN; ulIndex ++ )
        {
            SPITNSHOWSTATE  *pITNShowState;
            if ( pITNShowState = m_rgITNShowState.GetPtr(ulIndex))
            {
                if ((pITNShowState->ulITNStart >= ulStartElement) && 
                    (pITNShowState->ulITNStart + pITNShowState->ulITNNumElem <= ulStartElement + ulNumElements))
                {
                    // This ITN is inside the given range, just invert the show state.
                    pITNShowState->fITNShown = !pITNShowState->fITNShown;
                }
            }
        }
    }

    return hr;
}


// --------------------------------------------------------------------------------------------------
//
//  CRecoResultWrap::_UpdateStateWithAltPhrase
//
//  When an Alt phrase is going to used to replace current parent phrase, this method function
//  will update related memeber data, like m_ulNumOfITN, m_ulNumElements, ITN show state list.
//
// ---------------------------------------------------------------------------------------------------

HRESULT  CRecoResultWrap::_UpdateStateWithAltPhrase( ISpPhraseAlt  *pSpPhraseAlt )
{

    // This code is moved from UpdateInternalText( ).
    // This part code in UpdateInternalText( ) is used only by SetResult( ) when select an alternative from
    // candidate list.
    HRESULT hr = S_OK;
    ULONG ulParentStart;
    ULONG cElements;
    ULONG cElementsInParent;

    CComPtr<ISpPhraseAlt> cpAlt;

    TraceMsg(TF_GENERAL,"CRecoResultWrap::_UpdateStateWithAltPhrase is called");

    if ( pSpPhraseAlt == NULL )
        return E_INVALIDARG;

    cpAlt=pSpPhraseAlt;

    hr = cpAlt->GetAltInfo(NULL, &ulParentStart, &cElementsInParent, &cElements);

    if (S_OK == hr)
    {

        SPITNSHOWSTATE  *pOrgITNShowState = NULL;

        // case:  there is ITN number change.
        //    
        //        there is element number change.

        Assert(ulParentStart >= m_ulStartElement);
        Assert(ulParentStart+cElementsInParent <= m_ulStartElement+m_ulNumElements);

        TraceMsg(TF_GENERAL, "Original Num of ITNs =%d", m_ulNumOfITN);

        if ( cElements != cElementsInParent )
        {
            // There is element number change.
            // we need to update the start position for all the ITNs which are not in the selection range.

            for ( ULONG uIndex=0; uIndex < m_ulNumOfITN; uIndex ++)
            {
                SPITNSHOWSTATE *pITNShowState;

                pITNShowState = m_rgITNShowState.GetPtr(uIndex);

                if ( pITNShowState && pITNShowState->ulITNStart >= (ulParentStart + cElementsInParent) )
                {
                    long  newStart;

                    newStart = (long)pITNShowState->ulITNStart + (long)(cElements - cElementsInParent);

                    pITNShowState->ulITNStart = (ULONG)newStart;
                }
            }

            // set the new element number to reco wrapper.

            long lNewNumElements = (long)m_ulNumElements + (long)(cElements - cElementsInParent);
            m_ulNumElements = (ULONG)lNewNumElements;

        }

        if ( m_ulNumOfITN > 0 )
        {
            pOrgITNShowState = (SPITNSHOWSTATE  *) cicMemAllocClear( m_ulNumOfITN * sizeof(SPITNSHOWSTATE) );

            if ( pOrgITNShowState )
            {
                for (ULONG  i=0; i< m_ulNumOfITN; i++ )
                {
                    SPITNSHOWSTATE *pITNShowState;

                    pITNShowState = m_rgITNShowState.GetPtr(i);
                    
                    pOrgITNShowState[i].ulITNStart = pITNShowState->ulITNStart;
                    pOrgITNShowState[i].ulITNNumElem = pITNShowState->ulITNNumElem;
                    pOrgITNShowState[i].fITNShown = pITNShowState->fITNShown;
                }
            }
            else
                hr = E_OUTOFMEMORY;
                    
        }

        if ( m_rgITNShowState.Count( ) )
            m_rgITNShowState.Clear( );

        // Generate a new ITN list for new phrase.
        if ( hr == S_OK )
        {
            SPPHRASE *pPhrase;
            hr = cpAlt->GetPhrase(&pPhrase);

            if (S_OK == hr)
            {
                const SPPHRASEREPLACEMENT *pRep = pPhrase->pReplacements;
                ULONG ulNumOfITN = 0;

                for (ULONG ul = 0; ul < pPhrase->cReplacements; ul++)
                {
                    ULONG ulITNStart, ulITNNumElem;
                    BOOL  fITNShown = FALSE;

                    ulITNStart = pRep->ulFirstElement;
                    ulITNNumElem = pRep->ulCountOfElements;

                    if ( (ulITNStart >= m_ulStartElement)
                        && ((ulITNStart + ulITNNumElem) <= (m_ulStartElement + m_ulNumElements)) )
                    {
                        // Get an ITN
                        SPITNSHOWSTATE  *pITNShowState;

                        m_rgITNShowState.Append(1);

                        pITNShowState = m_rgITNShowState.GetPtr(ulNumOfITN);

                        if ( pITNShowState) 
                        {

                            // If this ITN is inside the selection range, it show state will be set as TRUE. ITN.
                            // Other it will keep the same show state as orgITNShowState.

                            if ( (ulITNStart >= ulParentStart) &&
                                 ((ulITNStart+ulITNNumElem) <= (ulParentStart + cElements)) )
                            {
                                // This ITN is inside the selection range.
                                 fITNShown = TRUE;
                            }
                            else
                            {
                                // Get the original show state from orgITNShowState
                                for ( ULONG j=0; j<m_ulNumOfITN; j ++ )
                                {
                                    if ( (pOrgITNShowState[j].ulITNStart == ulITNStart) && 
                                         (pOrgITNShowState[j].ulITNNumElem == ulITNNumElem ) )
                                    {
                                         fITNShown = pOrgITNShowState[j].fITNShown;
                                         break;
                                    }
                                }
                            }

                            pITNShowState->ulITNNumElem = ulITNNumElem;
                            pITNShowState->ulITNStart = ulITNStart;
                            pITNShowState->fITNShown = fITNShown; 
                        }

                        ulNumOfITN ++;
                    }

                    pRep ++;
                }

                m_ulNumOfITN = ulNumOfITN;

                TraceMsg(TF_GENERAL, "New Num of ITNs =%d", m_ulNumOfITN);

                ::CoTaskMemFree(pPhrase);

            }
        }

        if ( pOrgITNShowState )
            cicMemFree(pOrgITNShowState);
    }

    return hr;
}

//------------------------------------------------------------------------------------------//
//
//  CRecoResultWrap::_GetElementDispAttribute
//
//  Return the display attribute for the given element, if it is inside of an ITN, and the ITN
//  is showing, return the replacement text's attribute.
//  
//------------------------------------------------------------------------------------------//
BYTE    CRecoResultWrap::_GetElementDispAttribute(ULONG  ulElement)
{
    SPPHRASE                *pPhrase = NULL;
    BYTE                    bAttr = 0;
    CComPtr<ISpRecoResult>  cpResult;
    HRESULT                 hr;

    hr = GetResult(&cpResult);
    if (hr == S_OK)
        hr = cpResult->GetPhrase(&pPhrase);

    if ( hr == S_OK && pPhrase)
    {
        BOOL        fInsideITN;
        ULONG       ulITNStart, ulITNNumElem;

        fInsideITN = _CheckITNForElement(NULL, ulElement, &ulITNStart, &ulITNNumElem, NULL);

        if ( !fInsideITN )
            bAttr = pPhrase->pElements[ulElement].bDisplayAttributes;
        else
        {
            const SPPHRASEREPLACEMENT  *pPhrReplace;
            pPhrReplace = pPhrase->pReplacements;

            if ( pPhrReplace )
            {
                for ( ULONG i=0; i<pPhrase->cReplacements; i++)
                {
                    if ( (ulITNStart == pPhrReplace[i].ulFirstElement) 
                         && (ulITNNumElem == pPhrReplace[i].ulCountOfElements) )
                    {
                        bAttr = pPhrReplace[i].bDisplayAttributes;
                        break;
                    }
                }
            }
        }
    }

    if ( pPhrase )
        ::CoTaskMemFree(pPhrase);

    return bAttr;
}


//------------------------------------------------------------------------------------------//
//
//  CRecoResultWrap::_CheckITNForElement
//
//  Determine if the specifed element is inside of an ITN range in the phrase. 
//  If it is, the return value would be TRUE, and pulStartElement, pulEndElement will be 
//  set as the real start element and num of elements of the ITN range, dstrReplace will hold 
//  the replace text string.
//
//  If the element is not inside an ITN range, return value would be FALSE, all other out 
//  parameters will not be set.
//  
//------------------------------------------------------------------------------------------//

BOOL  CRecoResultWrap::_CheckITNForElement(SPPHRASE *pPhrase, ULONG ulElement, ULONG *pulITNStart, ULONG *pulITNNumElem, CSpDynamicString *pdstrReplace)
{
    BOOL        fInsideITN = FALSE;
    SPPHRASE   *pMyPhrase;

    pMyPhrase = pPhrase;

    if ( pMyPhrase == NULL )
    {
        CComPtr<ISpRecoResult> cpResult;

        HRESULT hr = GetResult(&cpResult);

        if (S_OK == hr)
        {
            hr = cpResult->GetPhrase(&pMyPhrase);
        }

        if (S_OK != hr)
            return fInsideITN;
    }

    if ( m_ulNumOfITN )
    {
        // Check to see if this element is inside an ITN range.
        ULONG  ulITNStart;
        ULONG  ulITNNumElem;

        for ( ULONG iIndex=0; iIndex<m_ulNumOfITN; iIndex++ )
        {
            SPITNSHOWSTATE  *pITNShowState;
            if ( pITNShowState = m_rgITNShowState.GetPtr(iIndex))
            {
                ulITNStart = pITNShowState->ulITNStart;
                ulITNNumElem = pITNShowState->ulITNNumElem;

                if ( (ulElement >= ulITNStart) && ( ulElement < ulITNStart + ulITNNumElem) )
                {
                    // found this ITN in our internal ITN show state list.
                     fInsideITN = pITNShowState->fITNShown; 
                    break;
                }
            }
        }

        if ( fInsideITN )
        {
            if ( pulITNStart )
                *pulITNStart = ulITNStart;

            if ( pulITNNumElem )
                *pulITNNumElem = ulITNNumElem;

            if ( pdstrReplace )
            {
                const SPPHRASEREPLACEMENT  *pPhrReplace;
                pPhrReplace = pMyPhrase->pReplacements;

                for ( ULONG j=0; j<pMyPhrase->cReplacements; j++)
                {
            
                    if ( (ulITNStart == pPhrReplace[j].ulFirstElement) 
                         && (ulITNNumElem == pPhrReplace[j].ulCountOfElements) )
                    {

                        pdstrReplace->Clear( );
                        pdstrReplace->Append(pPhrReplace[j].pszReplacementText);

                        if (pPhrReplace[j].bDisplayAttributes & SPAF_ONE_TRAILING_SPACE)
                            pdstrReplace->Append(L" ");
                        else if (pPhrReplace[j].bDisplayAttributes & SPAF_TWO_TRAILING_SPACES)
                            pdstrReplace->Append(L"  ");

                        break;
                    }
                }
                
            }
        }
    }

    if ( !pPhrase && pMyPhrase )
        ::CoTaskMemFree(pMyPhrase);

    return fInsideITN;
}


//
// CPropStoreRecoResultObject implementation
//

// ctor

CPropStoreRecoResultObject::CPropStoreRecoResultObject(CSapiIMX *pimx, ITfRange *pRange)
{
    m_cpResultWrap   = NULL;

    if ( pRange )
       pRange->Clone(&m_cpRange);  //  Use a clone range to keep the original Range.
                                   //  It would be useful to handle property shrink and divide.
    else
       m_cpRange = pRange;
    
    m_pimx = pimx;

    m_cRef  = 1;
}

// dtor
CPropStoreRecoResultObject::~CPropStoreRecoResultObject()
{
}


// IUnknown
STDMETHODIMP CPropStoreRecoResultObject::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hr;

    Assert(ppvObj);

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ITfPropertyStore))
    {
        *ppvObj = this;
        hr = S_OK;

        this->m_cRef++;
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }

    return hr;
}

STDMETHODIMP_(ULONG) CPropStoreRecoResultObject::AddRef(void)
{
    this->m_cRef++;

    return this->m_cRef;
}

STDMETHODIMP_(ULONG) CPropStoreRecoResultObject::Release(void)
{
    this->m_cRef--;

    if (this->m_cRef > 0)
    {
        return this->m_cRef;
    }
    delete this;

    return 0;
}

// ITfPropertyStore

STDMETHODIMP CPropStoreRecoResultObject::GetType(GUID *pguid)
{
    HRESULT hr = E_INVALIDARG;
    if (pguid)
    {
        *pguid = GUID_PROP_SAPIRESULTOBJECT;
        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP CPropStoreRecoResultObject::GetDataType(DWORD *pdwReserved)
{
    HRESULT hr = E_INVALIDARG;
    if (pdwReserved)
    {
        *pdwReserved = 0;
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CPropStoreRecoResultObject::GetData(VARIANT *pvarValue)
{
    HRESULT hr = E_INVALIDARG;

    if (pvarValue)
    {
        QuickVariantInit(pvarValue);

        if (m_cpResultWrap)
        {
            IUnknown *pUnk;

            hr = m_cpResultWrap->QueryInterface(IID_IUnknown, (void**)&pUnk);
            if (SUCCEEDED(hr))
            {
                pvarValue->vt = VT_UNKNOWN;
                pvarValue->punkVal = pUnk;
                hr = S_OK;
            }
        }
    }

    return hr;
}

STDMETHODIMP CPropStoreRecoResultObject::OnTextUpdated(DWORD dwFlags, ITfRange *pRange, BOOL *pfAccept)
{
    HRESULT hr = S_OK;
    *pfAccept = FALSE;

    Assert(pRange);

    if (m_pimx->_AcceptRecoResultTextUpdates())
    {
        *pfAccept = TRUE;
    }
    else
    {
        CComPtr<ITfContext> cpic;
        hr = pRange->GetContext(&cpic);

        if (SUCCEEDED(hr) && cpic)
        {
            CPSRecoEditSession *pes;
            if (pes = new CPSRecoEditSession(this, pRange, cpic))
            {
                pes->_SetEditSessionData(ESCB_PROP_TEXTUPDATE, NULL, 0, (LONG_PTR)dwFlags);
                cpic->RequestEditSession(m_pimx->_GetId(), pes, TF_ES_READ | TF_ES_SYNC, &hr);

                if ( SUCCEEDED(hr) )
                    *pfAccept = (BOOL)pes->_GetRetData( );

                pes->Release();
            }
        }
    
    }
    return hr;
}

STDMETHODIMP CPropStoreRecoResultObject::Shrink(ITfRange *pRange, BOOL *pfFree)
{

    HRESULT     hr = S_OK;

    if (m_pimx->_MasterLMEnabled())
    {
        return S_FALSE; // temporary solution to avoid nested editsessions
    }
    else
    {
        // Shrink this property store to reflect to the new doc Range  (pRange).

        // If the new range contains more than one element of recognized phrase,
        // we just update the property store and keep this property store.  
        //  *pfFree is set FALSE on exit.

        // If the new range cannot contain even one complete element of recognized phrase,
        // we just want to discard this property store, let Cicero engine to release this
        // property store.
        // *pfFree is set TRUE on exit.

        Assert(pRange);
        Assert(pfFree);

        if ( !pRange || !pfFree )
        {
            return E_INVALIDARG;
        }

        CComPtr<ITfContext> cpic;
        hr = pRange->GetContext(&cpic);

        if (SUCCEEDED(hr) && cpic)
        {
            CPSRecoEditSession *pes;
            if (pes = new CPSRecoEditSession(this, pRange, cpic))
            {
                pes->_SetEditSessionData(ESCB_PROP_SHRINK, NULL, 0);
                cpic->RequestEditSession(m_pimx->_GetId(), pes, TF_ES_READ | TF_ES_SYNC, &hr);

                if ( SUCCEEDED(hr) )
                    *pfFree = (BOOL)pes->_GetRetData( );

                pes->Release();
            }
        }
        return hr;
    }
}

STDMETHODIMP CPropStoreRecoResultObject::Divide(ITfRange *pRangeThis, ITfRange *pRangeNew, ITfPropertyStore **ppPropStore)
{

    if (m_pimx->_MasterLMEnabled())
    {
        return S_FALSE; // temporary solution to avoid nested editsessions
    }
    else
    {
        // 12/17/1999
        // [dividing a range implementation strategy]
        //
        // - pRangeThis contains the text range *before* the dividing point
        // - pRangeNew contrains the range *after* the dividing point
        // - First, adjust this property store to correctly hold a start element and #of element
        //   for pRangeThis
        // - then create a new property store for pRangeNew, which will share the same 
        //   result blob. 
        //
    
        // just an experiment to see if cutting the range works.
        // *ppPropStore = NULL;
        Assert(ppPropStore);
        Assert(pRangeThis);
        Assert(pRangeNew);

        CComPtr<ITfContext> cpic;
        HRESULT hr = pRangeThis->GetContext(&cpic);

        if (SUCCEEDED(hr) && cpic)
        {
            CPSRecoEditSession *pes;
            if (pes = new CPSRecoEditSession(this, pRangeThis, cpic))
            {
                pes->_SetUnk((IUnknown *)pRangeNew);
                pes->_SetEditSessionData(ESCB_PROP_DIVIDE, NULL, 0);
                cpic->RequestEditSession(m_pimx->_GetId(), pes, TF_ES_READ | TF_ES_SYNC, &hr);

                if ( SUCCEEDED(hr) )
                    *ppPropStore = (ITfPropertyStore *)pes->_GetRetUnknown( );

                pes->Release();
            }
        }
        return hr;
    }
}

//
// CPropStoreRecoResultObject::_OnTextUpdated
//
// the text has been modified in the document, this function just wants to determine
// if the property needs to change also.
// if pfAccept returns TRUE, means the property keep unchanged. ( propbaly it is capitalizing).
// if pfAccept returns FALSE, means the property needs to be changed to map to the new text ranges.
//
// consequently, property dividing or shrinking will be taken by cicero engine.
//
HRESULT CPropStoreRecoResultObject::_OnTextUpdated(TfEditCookie ec, DWORD dwFlags, ITfRange *pRange, BOOL *pfAccept)
{
    // if the change is only about capitalizing we'll ignore the changes

    Assert(pRange);
    Assert(pfAccept);

    long cch;
    ULONG ichUpdate = 0;
    TF_HALTCOND hc;
    CComPtr<ITfRange> cpRangeTemp;
    CComPtr<ITfRange> cpPropRangeTemp;
    CRecoResultWrap   *pResultWrap;

    BOOL *pfKeepProp = pfAccept;
    BOOL fCorrection = (dwFlags & TF_TU_CORRECTION);

    *pfKeepProp = FALSE;

    HRESULT hr = S_OK;

    pResultWrap = (CRecoResultWrap *)(void *)m_cpResultWrap;

    // if there's no current text don't try to save the prop
    if (pResultWrap->m_bstrCurrentText == NULL)
        return hr;

    // did the run change size?  we won't accept the change if
    // the run changed size
    if (m_cpRange->Clone(&cpPropRangeTemp) != S_OK)
    {
        hr = E_FAIL;
        return hr;
    }

    hc.pHaltRange = cpPropRangeTemp;
    hc.aHaltPos = TF_ANCHOR_END;
    hc.dwFlags = 0;

    if (cpPropRangeTemp->ShiftStart(ec, LONG_MAX, &cch, &hc) != S_OK)
    {
        hr = E_FAIL;
        return hr;
    }

    if ((ULONG)cch != wcslen(pResultWrap->m_bstrCurrentText))
        return hr;

    // text has not changed size

    // correction?
    if (fCorrection)
    {
        *pfKeepProp = TRUE;
        return hr;
    }

    // everything from here below is about
    // checking for a case change only

    // calculate the offset of update
    cpPropRangeTemp.Release( );
    hr = m_cpRange->Clone(&cpPropRangeTemp);
    if (S_OK == hr)
    {
        hc.pHaltRange = pRange;
        hc.aHaltPos = TF_ANCHOR_START;
        hc.dwFlags = 0;
        hr = cpPropRangeTemp->ShiftStart(ec, LONG_MAX, &cch, &hc);
        ichUpdate = cch;
    }

    // calculate cch of the update 
    if (S_OK == hr)
    {
        hr = pRange->Clone(&cpRangeTemp);
    }
    
    if (S_OK == hr)
    {
        WCHAR *psz;

        hc.pHaltRange = pRange;
        hc.aHaltPos = TF_ANCHOR_END;
        hc.dwFlags = 0;
        cpRangeTemp->ShiftStart(ec, LONG_MAX, &cch, &hc);
        psz = new WCHAR[cch+1];

        if (psz)
        {
            if ( S_OK == pRange->GetText(ec, 0, psz, cch, (ULONG *)&cch))
            {
                *pfKeepProp = pResultWrap->_CanIgnoreChange(ichUpdate, psz, cch);
            }
            delete[] psz;
        }
    } 

    return hr;
}

//
// CPropStoreRecoResultObject::_Divide
//
// synopsis : receives edit cookie from edit session
//            so that we can manipulate with ranges
//            to set starting elements/# of elements
//
//
HRESULT CPropStoreRecoResultObject::_Divide(TfEditCookie ec, ITfRange *pR1, ITfRange *pR2, ITfPropertyStore **ppPs) 
{
    HRESULT                     hr = S_OK;
    CRecoResultWrap            *cpResultWrap;

    long                        cchFirst = 0;   // the number of characters in the first range.
    long                        cchSecond = 0;  // the number of characters in the Second range.
    long                        cchSecondStart; // Offset of first char in the second range.
                                                // it starts from the original range's start-point.
    long                        cchOrgLen;      // Number of characters in original text string.

    int                         iElementOffsetChanged = 0;  // If the end point of the first range
                                                            // is exactly in the last space char of 
                                                            // one element, the new offset range for
                                                            // this element in the first range needs 
                                                            // to be updated.

    WCHAR                       *psz=NULL;
    ULONG                       iElement;
    ULONG                       ulStartElement, ulNumElement;
    ULONG                       ulFirstEndElement, ulNextStartElement;
    ULONG                       ulFirstStartOffset;
    DIVIDECASE                  dcDivideCase;
    CComPtr<ITfRange>           cpRangeTemp;
    ULONG                       ulFirstDelta, ulSecondDelta;
    ULONG                       ulFirstTrail, ulSecondTrail;
    ULONG                       ulFirstTSpaceRemoved, ulSecondTSpaceRemoved;
    CStructArray<SPITNSHOWSTATE> rgOrgITNShowState;

    CSpDynamicString            dstrOrg, dstrFirst, dstrSecond;

    TraceMsg(TF_GENERAL, "CPropStoreRecoResultObject::_Divide is called, this=0x%x", (INT_PTR)this);

    if ( !pR1 || !pR2 )
        return E_INVALIDARG;

    // Update this property store to keep pR1 instead of the original whole range.
    CComPtr<ITfRange> cpRange;
    hr = pR1->Clone(&cpRange);
    if (S_OK == hr)
    {
        m_cpRange = cpRange;
    }
    else
        return hr;

    Assert(m_cpRange);

    // Update m_cpResultWrap for Range1.  especially for data member m_bstrCurrentText, m_ulStartElement, m_ulNumElements, ulNumOfITN,
    // and m_pulElementOffsets

    cpResultWrap = (CRecoResultWrap *)(void *)m_cpResultWrap;

    if ( cpResultWrap == NULL)
        return E_FAIL;

    if ( cpResultWrap->m_bstrCurrentText == NULL)
         cpResultWrap->_SetElementOffsetCch(NULL);  // To update internal text also.

    if ( cpResultWrap->m_bstrCurrentText == NULL)
        return E_FAIL;

    // Initialize the text for the first range and second range.
    dstrOrg.Append(cpResultWrap->m_bstrCurrentText);
    cchOrgLen = wcslen(cpResultWrap->m_bstrCurrentText);

    if ( cpResultWrap->IsElementOffsetIntialized( ) == FALSE )
    {
        cpResultWrap->_SetElementOffsetCch(NULL);
    }

    // Calculate how many elements will be in the first Range.

    hr = pR1->Clone(&cpRangeTemp);

    if ( hr == S_OK )
    {
        TF_HALTCOND        hc;
        
        hc.pHaltRange = pR1;
        hc.aHaltPos = TF_ANCHOR_END;
        hc.dwFlags = 0;
        cpRangeTemp->ShiftStart(ec, LONG_MAX, &cchFirst, &hc);

        if ( cchFirst == 0 )
            return E_FAIL;
    }
    else
        return E_FAIL;

    // Calculate how many chars are in the second range.
    cpRangeTemp.Release( );
    hr = pR2->Clone(&cpRangeTemp);

    if ( hr == S_OK )
    {
        TF_HALTCOND        hc;
        
        hc.pHaltRange = pR2;
        hc.aHaltPos = TF_ANCHOR_END;
        hc.dwFlags = 0;
        cpRangeTemp->ShiftStart(ec, LONG_MAX, &cchSecond, &hc);
    }

    if ( cchSecond == 0 )
        return E_FAIL;

    cchSecondStart = cchOrgLen - cchSecond;

    if ( cchSecondStart < cchFirst )
    {
        // Normally, it is not possible case, but for safety reason, just check it here.
        cchSecondStart = cchFirst;
    }

    TraceMsg(TF_GENERAL, "cchFirst=%d, cchSecondStart=%d", cchFirst, cchSecondStart);

    ulStartElement = cpResultWrap->GetStart( );
    ulNumElement = cpResultWrap->GetNumElements( );

    ulFirstEndElement = ulStartElement + ulNumElement - 1;
    ulNextStartElement = ulStartElement + ulNumElement;

    ulFirstStartOffset = cpResultWrap->_GetElementOffsetCch(ulStartElement);

    ulFirstDelta = cpResultWrap->_GetOffsetDelta( );
    ulSecondDelta = 0;

    ulFirstTrail= 0;
    ulSecondTrail = cpResultWrap->GetCharsInTrail( );

    ulFirstTSpaceRemoved = 0;
    ulSecondTSpaceRemoved = cpResultWrap->GetTrailSpaceRemoved( );

    dcDivideCase = DivideNormal;

    if ( (cchFirst >= cchOrgLen) || (cchSecondStart >= cchOrgLen) )
    {
        // Something is wrong here already.
        // It is better to stop here and return error 
        // to avoid any possible crash in the below code!
        return E_FAIL;
    }

    psz = (WCHAR *)dstrOrg;
    psz += cchSecondStart; // need to account for deleted text as well
    dstrSecond.Append(psz);


    psz = (WCHAR *)dstrOrg;
    dstrFirst.Append(psz);
    psz = (WCHAR *)dstrFirst;
    psz[cchFirst] = L'\0';

    if ( ulNumElement == 0 )
    {
        // There is no any valid element in this range.
        //
        // we just update the m_bstrCurrentText, don't generate a property store 
        // for second range.
        dcDivideCase = CurRangeNoElement;
    }
    else
    {
        // At least one element in this property range.
        BOOL     fFoundFirstEnd = FALSE;
        BOOL     fFoundSecondStart = FALSE;

        for ( iElement=ulStartElement; iElement < ulStartElement + ulNumElement; iElement++)
        {
            ULONG   cchAfterElem_i;  // length of text range from StartElement to this element ( include this element).
            ULONG   cchToElem_i;     // Length of text range from startElement to start of this element. ( exclude this elem).

            cchAfterElem_i =  cpResultWrap->_GetElementOffsetCch(iElement+1) - ulFirstStartOffset + ulFirstDelta;
            cchToElem_i = cpResultWrap->_GetElementOffsetCch(iElement) - ulFirstStartOffset + ulFirstDelta;

            if ( !fFoundFirstEnd )
            {
                // Try to find First End element and ulFirstTrail for the first range
                if ( cchFirst <= (long)ulFirstDelta )
                {
                    // Divide at the point which is not belong to any element of the phrase

                    ulFirstTrail = 0;
                    ulFirstDelta = cchFirst;
                    dcDivideCase = DivideInDelta;
                    fFoundFirstEnd = TRUE;

                    TraceMsg(TF_GENERAL, "The first range is divided inside Delta part");
                }
                else
                {
                    if ( cchAfterElem_i == (ULONG)cchFirst )
                    {
                        // This is the end element for the first range.
                        ulFirstEndElement = iElement;
                        ulFirstTrail = 0;

                        fFoundFirstEnd = TRUE;
                    }
                    else if ( cchAfterElem_i > (ULONG)cchFirst )
                    {
                        if ( ((WCHAR *)dstrOrg)[cchFirst] == L' ')
                        {
                            // This is also the end elemenet.
                            // just divide in at a space char.
                            ulFirstEndElement = iElement;

                            ulFirstTrail = 0;

                            // The trailing space is now removed from the original element.
                            // we need to update the length for this element. ( update the offset 
                            // for next element).

                            iElementOffsetChanged = cchAfterElem_i - cchFirst;
                            ulFirstTSpaceRemoved = iElementOffsetChanged;
                        }
                        else
                        {
                            // check to see if current element is inside an ITN.

                            BOOL  fInsideITN;
                            ULONG ulITNStart, ulITNNumElem;
                            ULONG ulCurElement;

                            fInsideITN = cpResultWrap->_CheckITNForElement(NULL, iElement, &ulITNStart, &ulITNNumElem, NULL);
    
                            if ( fInsideITN )
                                ulCurElement = ulITNStart;
                            else
                                ulCurElement = iElement;

                            ulFirstEndElement = ulCurElement - 1;                   

                            // The previous one is EndElement if there is a previous element
                            // Discard this element.
                            // Divide at a valid element

                            // If divide in the first element, specially handle it.
                            if ( ulCurElement == ulStartElement)
                            {
                                dcDivideCase = DivideInsideFirstElement;
                                TraceMsg(TF_GENERAL, "The first range is divided inside the first element");
                            }

                            // The first part of this element would become
                            // the trail part of the first range.
                            ulFirstTrail = (ULONG)cchFirst - cchToElem_i;
                                
                        }

                        fFoundFirstEnd = TRUE;
                    }
                }
            }

            if ( fFoundFirstEnd )
            {
                // Now the data for the first range is completed.
                // we want to find data for the second range.

                // We want to find the start element and ulSecondDelta for the second range.

                if ( (long)cchToElem_i >= cchSecondStart )
                {
                    // Find the element which is the first element after the start point of second
                    // range.

                    ulNextStartElement = iElement;
                    ulSecondDelta = cchToElem_i - cchSecondStart;

                    fFoundSecondStart = TRUE;
                    break;
                }
            }

        }  // for

        if ( !fFoundFirstEnd )
        {
            // Cannot find the first end element from the above code.
            // it must be divided in the trailing part.

            // we just want to change the ulCharsInTrail for the first range.
            ULONG  ulValidLenInFirstRange;

            // ulValidLenInFirstRange is the number of Delta chars and valid elements' chars.

            ulValidLenInFirstRange = cpResultWrap->_GetElementOffsetCch(ulStartElement + ulNumElement) - ulFirstStartOffset + ulFirstDelta;

            ulFirstTrail = cchFirst - ulValidLenInFirstRange;

        }

        if ( !fFoundSecondStart )
        {
            // The second start point must be in Last element or in the Trailing part in the original range.
            // The second range will not contain any valid element.

            ulSecondTrail = 0;
            ulSecondDelta = cchOrgLen - cchSecondStart;

            ulNextStartElement = ulStartElement + ulNumElement; // This is not a valid element number in the original
                                                                // range. using this value means there is no valid element
                                                                // in the second range. 
        }
    }

    
    TraceMsg(TF_GENERAL, "ulStartElement = %d ulNumElement=%d", ulStartElement, ulNumElement);
    TraceMsg(TF_GENERAL, "ulFirstEndElement = %d ulNextStartElement=%d", ulFirstEndElement, ulNextStartElement);
    TraceMsg(TF_GENERAL, "The First Range text =\"%S\", delta=%d, Trail=%d, TSRemoved=%d", (WCHAR *)dstrFirst, ulFirstDelta, ulFirstTrail, ulFirstTSpaceRemoved); 
    TraceMsg(TF_GENERAL, "The second range text =\"%S\", delta=%d, Trail=%d, TSRemoved=%d", (WCHAR *)dstrSecond, ulSecondDelta, ulSecondTrail, ulSecondTSpaceRemoved); 

    if (cpResultWrap->m_bstrCurrentText)
        SysFreeString(cpResultWrap->m_bstrCurrentText);

    cpResultWrap->m_bstrCurrentText = SysAllocString((WCHAR *)dstrFirst); 
    
    // Keep the ITN show-state for the second reco wrap use.
    if ( cpResultWrap->m_ulNumOfITN )
    {
        rgOrgITNShowState.Append(cpResultWrap->m_ulNumOfITN);

        for (ULONG  i=0; i<cpResultWrap->m_ulNumOfITN; i++)
        {
            SPITNSHOWSTATE  *pITNShowState;
            if ( pITNShowState = rgOrgITNShowState.GetPtr(i))
            {
                SPITNSHOWSTATE *pITNShowStateSource;
                
                pITNShowStateSource = cpResultWrap->m_rgITNShowState.GetPtr(i);

                pITNShowState->ulITNStart = pITNShowStateSource->ulITNStart;
                pITNShowState->ulITNNumElem = pITNShowStateSource->ulITNNumElem;
                pITNShowState->fITNShown = pITNShowStateSource->fITNShown;
            }
        }
    }

    // Keep the Offset list for second range

    ULONG     *pulOffsetForSecond = NULL;

    if ( (ulStartElement + ulNumElement - ulNextStartElement) > 0 )
    {
        ULONG   ulNextNumOffset;

        ulNextNumOffset =  ulStartElement + ulNumElement - ulNextStartElement + 1;

        pulOffsetForSecond = new ULONG[ulNextNumOffset];

        if ( pulOffsetForSecond )
        {
            ULONG  i;
            ULONG  ulOffset;

            for ( i=0; i < ulNextNumOffset;  i++ )
            {
                ulOffset = cpResultWrap->_GetElementOffsetCch(ulNextStartElement + i );
                pulOffsetForSecond[i] = ulOffset;
            }
        }
        else
            hr = E_OUTOFMEMORY;
    }

    switch ( dcDivideCase )
    {
    case DivideNormal :

        ULONG   ulNumOfITN;
        ULONG   ulFirstNumElement;

        ulFirstNumElement = ulFirstEndElement - ulStartElement + 1;
        cpResultWrap->SetNumElements(ulFirstNumElement);

        // update the ITN show-state list.
        if (cpResultWrap->m_ulNumOfITN > 0)
        {
            ulNumOfITN = cpResultWrap->_RangeHasITN(ulStartElement, ulFirstNumElement);
            if ( cpResultWrap->m_ulNumOfITN > ulNumOfITN )
            {
                // There is ITN number change
                // need to remove the ITNs which are not in this range.
               cpResultWrap->m_rgITNShowState.Remove(ulNumOfITN, cpResultWrap->m_ulNumOfITN - ulNumOfITN);
               cpResultWrap->m_ulNumOfITN = ulNumOfITN;
            }

        }

        if ( iElementOffsetChanged > 0 )
        {
            // Some trailing spaces are removed from end element of the first range.
            ULONG  ulNewOffset;

            ulNewOffset = cpResultWrap->_GetElementOffsetCch(ulFirstEndElement + 1);
            cpResultWrap->_SetElementNewOffset(ulFirstEndElement + 1, ulNewOffset - iElementOffsetChanged);
        }

        cpResultWrap->SetCharsInTrail(ulFirstTrail);
        cpResultWrap->SetTrailSpaceRemoved( ulFirstTSpaceRemoved );

        break;

    case DivideInsideFirstElement :
    case DivideInDelta :

        cpResultWrap->SetNumElements(0);
        cpResultWrap->m_ulNumOfITN = 0;
        cpResultWrap->SetOffsetDelta(ulFirstDelta);
        cpResultWrap->SetCharsInTrail(ulFirstTrail);
        cpResultWrap->SetTrailSpaceRemoved( ulFirstTSpaceRemoved );

        break;

    case CurRangeNoElement :
      
        TraceMsg(TF_GENERAL, "There is no element in original range");
        cpResultWrap->SetNumElements(0);
        cpResultWrap->m_ulNumOfITN = 0;
        break;
    }

    // Now generate a new properstore for the new range pR2.
    // if the new property store is required.

    if ( ppPs == NULL )
        return hr;

    if (dcDivideCase == CurRangeNoElement )
    {
        // there is no any element in the original property range.
        *ppPs = NULL;
        return hr;
    }

    CPropStoreRecoResultObject *prps = NULL;
    if (S_OK == hr)
        prps = new CPropStoreRecoResultObject(m_pimx, pR2);

    if (prps)
    {
        hr = prps->QueryInterface(IID_ITfPropertyStore, (void **)ppPs);

        if (SUCCEEDED(hr))
        {
            CRecoResultWrap *prw;
            ULONG            ulNextNum;
            ULONG            ulNumOfITN;
            CComPtr<ISpRecoResult> cpResult;

            if ( ulNextStartElement >= ulStartElement + ulNumElement)
            {
                // It is divided at the last element of the original range. 
                // We will just generate a property store for this Cicero ver 1.0
                // to avoid the original property store be removed by Cicero engine.

                // FutureConsider: if Cicero changes the logic in the future, we need to change
                // this code as well so that we don't need to generate a property store
                // for this second range.

                ulNextNum = 0;
                ulNumOfITN = 0;
                ulSecondTSpaceRemoved = 0;

            }
            else
            {
                ulNextNum = ulStartElement + ulNumElement - ulNextStartElement;
                ulNumOfITN = cpResultWrap->_RangeHasITN(ulNextStartElement, ulNextNum);
            }
            
            prw = new CRecoResultWrap(m_pimx, ulNextStartElement, ulNextNum, ulNumOfITN);
            if ( prw != NULL )
            {
                hr = cpResultWrap->GetResult(&cpResult);
            }
            else
            {
                // Check interface pointer ref  leak problem.
                return E_OUTOFMEMORY;
            }

            if (S_OK == hr)
            {
                hr = prw->Init(cpResult);
            }

            if (S_OK == hr)
            {
                prw->SetOffsetDelta(ulSecondDelta);
                prw->SetCharsInTrail(ulSecondTrail);
                prw->SetTrailSpaceRemoved( ulSecondTSpaceRemoved );
                prw->m_bstrCurrentText = SysAllocString((WCHAR *)dstrSecond);

                // Update ITN show-state list .

                if ( ulNumOfITN > 0 )
                {
                    SPITNSHOWSTATE  *pITNShowState;
                    ULONG           ulOrgNumOfITN;

                    ulOrgNumOfITN = rgOrgITNShowState.Count( );
                
                    for ( ULONG  iIndex=0; iIndex<ulOrgNumOfITN; iIndex ++ )
                    {
                        pITNShowState = rgOrgITNShowState.GetPtr(iIndex);

                        if ( pITNShowState)
                        {
                            if ( (pITNShowState->ulITNStart 
                                  >= ulNextStartElement) &&
                                 (pITNShowState->ulITNStart + 
                                  pITNShowState->ulITNNumElem) 
                                  <= (ulNextStartElement + ulNextNum) )
                            {
                                prw->_InitITNShowState(
                                         pITNShowState->fITNShown, 
                                         pITNShowState->ulITNStart, 
                                         pITNShowState->ulITNNumElem);
                            }
                        }
                    } // for
                } // if

                // Update the Offset list for the second range.

                if ( (ulNextNum > 0) && pulOffsetForSecond )
                {
                    ULONG  i;
                    ULONG  ulOffset;

                    for ( i=0; i <= ulNextNum; i ++ )
                    {
                        ulOffset = pulOffsetForSecond[i];
                        prw->_SetElementNewOffset(ulNextStartElement + i, ulOffset);
                    }
                }

                hr = prps->_InitFromResultWrap(prw);
            }
            prw->Release( );
        }
        prps->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if ( rgOrgITNShowState.Count( ) )
        rgOrgITNShowState.Clear( );

    if ( pulOffsetForSecond )
        delete[] pulOffsetForSecond;

    return hr;
}

//
//   CPropStoreRecoResultObject::_Shrink
//
//    receive EditCookie from edit session.
//    try to determine the new range's attribute to update the property store or notify 
//    the ctf engine to discard it.
//

HRESULT CPropStoreRecoResultObject::_Shrink(TfEditCookie ec, ITfRange *pRange,BOOL *pfFree)
{
    HRESULT                 hr = S_OK;
    WCHAR                  *pwszNewText = NULL;
    long                    cchNew = 0;
    WCHAR                  *pwszOrgText = NULL; 
    CSpDynamicString        dstrOrg;
    long                    cchOrg = 0;
    CComPtr<ITfRange>       cpRangeTemp;
    CRecoResultWrap        *cpResultWrap;
    long                    iStartOffset;  // the offset from start of the new range to the 
                                            // original range start point.
    long                    iLastOffset;   // The offset from the last character of new range 
                                            // to the original range start point.
    ULONG                   ulNewStartElement, ulNewNumElements, ulNewDelta, ulNewTrail, ulNewTSRemoved;
    ULONG                   ulOrgStartElement, ulOrgNumElements, ulOrgDelta, ulOrgTrail, ulOrgTSRemoved;

    BOOL                    fShrinkToWrongPos = FALSE;

    int                     iElementOffsetChanged = 0;  // If the new range just remove the 
                                                        // trailing space of original text,
                                                        // the new valid start and end element
                                                        // will keep unchanged, but the length of
                                                        // new end element is changed.

    TraceMsg(TF_GENERAL, "CPropStoreRecoResultObject::_Shrink is called, this=0x%x", (INT_PTR)this);

    if ( !pRange || !pfFree )  return E_INVALIDARG;

    // Set *pfFree as TRUE intially in case there is an error occuring.
    *pfFree = TRUE;

    cpResultWrap = (CRecoResultWrap *)(void *)m_cpResultWrap;

    if ( cpResultWrap == NULL )  return E_FAIL;

    if ( (WCHAR *)cpResultWrap->m_bstrCurrentText == NULL )
        cpResultWrap->_SetElementOffsetCch(NULL);  // To update internal text based.

    dstrOrg.Append((WCHAR *)cpResultWrap->m_bstrCurrentText);
    pwszOrgText = (WCHAR *)dstrOrg;

    ulOrgNumElements = cpResultWrap->GetNumElements( );
    ulOrgStartElement = cpResultWrap->GetStart( );
    ulOrgDelta = cpResultWrap->_GetOffsetDelta(  );
    ulOrgTrail = cpResultWrap->GetCharsInTrail( );
    ulOrgTSRemoved = cpResultWrap->GetTrailSpaceRemoved( );
    if ( pwszOrgText )
        cchOrg = wcslen(pwszOrgText);
    
    if ( (ulOrgNumElements ==0) || (pwszOrgText == NULL) || (cchOrg == 0) )
    {
        // This property store doesn't have resultwrap or doesn't have valid element.
        // let cicero engine free this property store.
        return hr;
    }

    pwszNewText = new WCHAR[cchOrg+1];

    // try to get the new text pointed by pRange and character number this text.
    if ( pwszNewText )
    {
        hr = pRange->Clone( &cpRangeTemp );
        if ( hr == S_OK) 
        {
            hr = cpRangeTemp->GetText(ec, 0, pwszNewText, cchOrg, (ULONG *)&cchNew);
        }

        // Get the new range's StartOffset and LastOffset in the original property range.

        iStartOffset = 0;
        iLastOffset = cchOrg;

        if ( hr == S_OK && cchNew > 0 )
        {
            long    i;
            BOOL    fFoundNewString=FALSE;

            for (i=0; i<=(cchOrg-cchNew); i++)
            {
                WCHAR   *pwszOrg;

                pwszOrg = pwszOrgText + i;

                if ( wcsncmp(pwszOrg, pwszNewText, cchNew) == 0 )
                {
                    // Found the match

                    iStartOffset = i;
                    iLastOffset = i + cchNew;
                    fFoundNewString = TRUE;
                    break;
                }
            }

            // If we cannot find the new text as the substring in the original property text.
            // It must be shrinked to a wrong place.

            fShrinkToWrongPos = !fFoundNewString;

        }

    }
    else
        hr = E_OUTOFMEMORY;
  
    if ( hr != S_OK  || fShrinkToWrongPos) 
        goto CleanUp;

    TraceMsg(TF_GENERAL, "Shrink: NewText: cchNew=%d :\"%S\"", cchNew, pwszNewText);
    TraceMsg(TF_GENERAL, "Shrink: OrgText: cchOrg=%d :\"%S\"", cchOrg, pwszOrgText);
    TraceMsg(TF_GENERAL, "Shrink: Org: StartElem=%d NumElem=%d Delta=%d, Trail=%d, TSRemoved=%d", ulOrgStartElement, ulOrgNumElements, ulOrgDelta, ulOrgTrail, ulOrgTSRemoved);
    TraceMsg(TF_GENERAL, "Shrink: iStartOffset=%d, iLastOffset=%d", iStartOffset, iLastOffset);

    if ( cpResultWrap->IsElementOffsetIntialized( ) == FALSE )
        cpResultWrap->_SetElementOffsetCch(NULL);

    ulNewStartElement = ulOrgStartElement;
    ulNewDelta = ulOrgDelta;
    ulNewTrail = ulOrgTrail;

    // Calculate ulNewStartElement and ulNewDelta.
    if ( (ULONG)iStartOffset <= ulOrgDelta )
    {
        ulNewDelta = ulOrgDelta - iStartOffset;
        ulNewStartElement = ulOrgStartElement;
    }
    else
    {
        ULONG     iElement;
        ULONG     ulOrgStartOffset;

        ulOrgStartOffset = cpResultWrap->_GetElementOffsetCch(ulOrgStartElement);

        for ( iElement=ulOrgStartElement; iElement < ulOrgStartElement + ulOrgNumElements; iElement++)
        {
            ULONG   ulToElement;
            ULONG   ulAfterElement;

            ulToElement = cpResultWrap->_GetElementOffsetCch(iElement) - ulOrgStartOffset + ulOrgDelta;
            ulAfterElement = cpResultWrap->_GetElementOffsetCch(iElement+1) - ulOrgStartOffset + ulOrgDelta;

            if ( ulToElement == (ULONG)iStartOffset )
            {
                ulNewStartElement = iElement;
                ulNewDelta = 0;
                break;
            }
            else  
            {
                if ( (ulToElement < (ULONG)iStartOffset) && (ulAfterElement > (ULONG)iStartOffset)) 
                {
                    ulNewStartElement = iElement + 1;
                    ulNewDelta = ulAfterElement - iStartOffset;
                    break;
                }
            }
        }
    }

    // Calculate new ulNewNumElements.

    ulNewNumElements = 0;

    if ( iLastOffset == cchOrg )
    {
        // 
         ULONG  ulNewEndElement;

        // New End is the same as org End.
        ulNewEndElement = ulOrgStartElement + ulOrgNumElements - 1;

        ulNewNumElements = 1 + ulNewEndElement - ulNewStartElement;
 
    }
    else
    {
        long      iElement;
        ULONG     ulOrgStartOffset;
        ULONG     ulOrgEndElement;
        ULONG     ulNewEndElement;
        BOOL      fFound;

        ulOrgEndElement = ulOrgStartElement + ulOrgNumElements - 1;
        ulOrgStartOffset = cpResultWrap->_GetElementOffsetCch(ulOrgStartElement);
       
        fFound = FALSE;
        for ( iElement=(long)ulOrgEndElement; iElement >= (long)ulOrgStartElement; iElement--)
        {
            ULONG   ulToElement;
            ULONG   ulAfterElement;
            BOOL    fInsideITN;
            ULONG   ulITNStart, ulITNNumElem;
            ULONG   ulCurElement;

            ulToElement = cpResultWrap->_GetElementOffsetCch(iElement) - ulOrgStartOffset + ulOrgDelta;
            ulAfterElement = cpResultWrap->_GetElementOffsetCch(iElement+1) - ulOrgStartOffset + ulOrgDelta;

            if ( iElement == (long)ulOrgEndElement  && ( ulAfterElement <= (ULONG)iLastOffset ) )
            {
                // This org last element would be the new last element
                ulNewEndElement = iElement;
                ulNewTrail = (ULONG)iLastOffset - ulAfterElement;
                fFound = TRUE;
                break;
            }

            fInsideITN = cpResultWrap->_CheckITNForElement(NULL, iElement, &ulITNStart, &ulITNNumElem, NULL);
            
            if ( fInsideITN )
                ulCurElement = ulITNStart;
            else
                ulCurElement = iElement;

            if ( ulToElement == (ULONG)iLastOffset )
            {
                ulNewEndElement = ulCurElement - 1;
                ulNewTrail = 0;
               
                fFound = TRUE;
                break;
            }

            if ( (ulToElement < (ULONG)iLastOffset) && (ulAfterElement > (ULONG)iLastOffset)) 
            {
                if ( pwszOrgText[iLastOffset] == L' ')
                {
                    // The trailing space is now removed from the original element.
                    // we need to update the length for this element. ( update the offset 
                    // for next element).

                    iElementOffsetChanged = ulAfterElement - iLastOffset;

                    if ( fInsideITN )
                        ulNewEndElement = ulITNStart + ulITNNumElem - 1;
                    else
                        ulNewEndElement = iElement;

                    ulNewTrail = 0;
                }
                else
                {
                    ulNewEndElement = ulCurElement - 1;
                    ulNewTrail = (ULONG)iLastOffset - ulToElement;
                }

                fFound = TRUE;
                break;
            }

        }

        if ( fFound )
            ulNewNumElements = 1 + ulNewEndElement - ulNewStartElement;
    }

    ulNewTSRemoved = ulOrgTSRemoved + iElementOffsetChanged;

    TraceMsg(TF_GENERAL, "Shrink: New: StartElem=%d NumElem=%d Delta=%d, Trail=%d, TSRemoved=%d", ulNewStartElement, ulNewNumElements, ulNewDelta, ulNewTrail, ulNewTSRemoved);

    // If there is no valid element in the new range, discard this property store
    // otherwise, keep it and update the related data members.

    if ( ulNewNumElements > 0 )
    {
        ULONG  ulNumOfITN;

        *pfFree = FALSE;
        
        CComPtr<ITfRange> cpRange;
        hr = pRange->Clone(&cpRange);

        if (S_OK == hr)
        {
            m_cpRange = cpRange;

            cpResultWrap->SetStart(ulNewStartElement);
            cpResultWrap->SetNumElements(ulNewNumElements);
            cpResultWrap->SetOffsetDelta(ulNewDelta);
            cpResultWrap->SetCharsInTrail(ulNewTrail);
            cpResultWrap->SetTrailSpaceRemoved( ulNewTSRemoved );

            ulNumOfITN = cpResultWrap->_RangeHasITN(ulNewStartElement, ulNewNumElements);

            cpResultWrap->m_ulNumOfITN = ulNumOfITN;

            // Update ITN show-state list

            if ( ulNumOfITN > 0 )
            {
                SPITNSHOWSTATE  *pITNShowState;
                ULONG           ulOrgNumOfITN;

                ulOrgNumOfITN = cpResultWrap->m_rgITNShowState.Count( );
                
                for ( ULONG iIndex=ulOrgNumOfITN; iIndex>0; iIndex -- )
                {
                    pITNShowState = cpResultWrap->m_rgITNShowState.GetPtr(iIndex-1);

                    if ( pITNShowState)
                    {
                        if ( (pITNShowState->ulITNStart < ulNewStartElement) ||
                             (pITNShowState->ulITNStart + pITNShowState->ulITNNumElem) > (ulNewStartElement + ulNewNumElements) )
                        {
                            // This ITN is not in the new Range
                            cpResultWrap->m_rgITNShowState.Remove(iIndex-1, 1);
                        }
                    }
                }
            }
            else
                if ( cpResultWrap->m_rgITNShowState.Count( ) )
                    cpResultWrap->m_rgITNShowState.Clear( );
                
            if ( cpResultWrap->m_bstrCurrentText )
                SysFreeString(cpResultWrap->m_bstrCurrentText);

            cpResultWrap->m_bstrCurrentText = SysAllocString(pwszNewText);

            if ( iElementOffsetChanged != 0 )
            {
                ULONG  ulNewOffset;
                ULONG  ulElemAfterEnd;

                ulElemAfterEnd = ulNewStartElement + ulNewNumElements;
                ulNewOffset = cpResultWrap->_GetElementOffsetCch(ulElemAfterEnd);
                cpResultWrap->_SetElementNewOffset(ulElemAfterEnd, ulNewOffset - iElementOffsetChanged);
            }
        }
    }

CleanUp:
    if ( pwszNewText )  delete[] pwszNewText;
    return hr;
}

//
// CPropStoreRecoResultObject::Clone
//
// synopsis : make a new cloned propstore which shares the same SAPI result
//            object as the current class instance
//
//
STDMETHODIMP CPropStoreRecoResultObject::Clone(ITfPropertyStore **ppPropStore)
{
    HRESULT hr;
    CPropStoreRecoResultObject *prps = new CPropStoreRecoResultObject(m_pimx, m_cpRange);
    if (prps)
    {
        hr = prps->QueryInterface(IID_ITfPropertyStore, (void **)ppPropStore);

        if (SUCCEEDED(hr))
        {
            CRecoResultWrap *prw = NULL;
            CRecoResultWrap *pRecoWrapOrg = NULL;

            if ( m_cpResultWrap )
            {
                hr = m_cpResultWrap->QueryInterface(IID_PRIV_RESULTWRAP, (void **)&pRecoWrapOrg);

                if ( hr == S_OK )
                {
                    hr = pRecoWrapOrg->Clone(&prw);
                }

                SafeRelease(pRecoWrapOrg);

                if ( hr == S_OK )
                   hr = prps->_InitFromResultWrap(prw);

                SafeRelease(prw);
            }
        }
        prps->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CPropStoreRecoResultObject::GetPropertyRangeCreator(CLSID *pclsid)
{
    HRESULT hr = E_INVALIDARG;

    if (pclsid)
    {
        *pclsid = CLSID_SapiLayr;
        hr = S_OK;
    }

    return hr;
}

//
// CPropStoreRecoResultObject::Serialize
//
// synopsis: takes a pointer to an IStream and get the current
//           SAPI result object serialized
//
// changes from CResultPropertyStore:
//           Uses SAPI's result object to get the blob
//           serialized. ISpResultObject has to be cloned
//           in order to keep the object alive after
//           'detaching' it.
//
//
STDMETHODIMP CPropStoreRecoResultObject::Serialize(IStream *pStream, ULONG *pcb)
{
    HRESULT hr = E_FAIL;

    TraceMsg(TF_GENERAL, "Serialize is called, this = 0x%x", (INT_PTR)this);
    
    if (m_cpResultWrap && pStream)
    {
        CComPtr<IServiceProvider> cpServicePrv;
        CComPtr<ISpRecoResult> cpRecoResult;
        SPSERIALIZEDRESULT *pResBlock;
        ULONG ulrw1 = 0;
        ULONG ulrw2 = 0;

        CRecoResultWrap     *cpRecoWrap;
        ULONG               ulSizeRecoWrap, ulTextNum, ulITNSize;
        ULONG               ulOffsetSize, ulOffsetNum;
        RECOWRAPDATA       *pRecoWrapData;

        cpRecoWrap = (CRecoResultWrap *)(void *)m_cpResultWrap; 

        // We want to save m_ulStartElement, m_ulNumElements, m_OffsetDelta, ulNumOfITN, m_bstrCurrentText 
        // and a list of ITN show state structure in the RecoResultWrap to the serialized stream.

        ulTextNum = 0;
        if (cpRecoWrap->m_bstrCurrentText) 
        {
            ulTextNum = wcslen(cpRecoWrap->m_bstrCurrentText) + 1; // plus NULL terminator
        }

        ulITNSize = cpRecoWrap->m_ulNumOfITN * sizeof(SPITNSHOWSTATE);

        if ( cpRecoWrap->IsElementOffsetIntialized( ) )
            ulOffsetNum = cpRecoWrap->GetNumElements( ) + 1;
        else 
            ulOffsetNum = 0;

        ulOffsetSize = ulOffsetNum * sizeof(ULONG);

        // Serialiezed data will contain RECOWRAPDATA struct, ITN show-state list, Offset list and m_bstrCurrentText.

        ulSizeRecoWrap = sizeof(RECOWRAPDATA) + ulITNSize + ulOffsetSize + sizeof(WCHAR) * ulTextNum;

        pRecoWrapData = (RECOWRAPDATA  *)cicMemAllocClear(ulSizeRecoWrap);

        if (pRecoWrapData)
        {
            WCHAR   *pwszText;

            pRecoWrapData->ulSize = ulSizeRecoWrap;
            pRecoWrapData->ulStartElement = cpRecoWrap->GetStart( );
            pRecoWrapData->ulNumElements = cpRecoWrap->GetNumElements( );
            pRecoWrapData->ulOffsetDelta = cpRecoWrap->_GetOffsetDelta( );
            pRecoWrapData->ulCharsInTrail = cpRecoWrap->GetCharsInTrail( );
            pRecoWrapData->ulTrailSpaceRemoved = cpRecoWrap->GetTrailSpaceRemoved( );
            pRecoWrapData->ulNumOfITN = cpRecoWrap->m_ulNumOfITN;
            pRecoWrapData->ulOffsetNum = ulOffsetNum;

            // Save the ITN show-state list

            if ( cpRecoWrap->m_ulNumOfITN > 0 )
            {
                SPITNSHOWSTATE *pITNShowState;

                pITNShowState = (SPITNSHOWSTATE *)((BYTE *)pRecoWrapData + sizeof(RECOWRAPDATA));

                for ( ULONG i=0; i<cpRecoWrap->m_ulNumOfITN; i++)
                {
                    SPITNSHOWSTATE *pITNShowStateSource;

                    pITNShowStateSource = cpRecoWrap->m_rgITNShowState.GetPtr(i);

                    if ( pITNShowStateSource )
                    {
                        pITNShowState->fITNShown = pITNShowStateSource->fITNShown;
                        pITNShowState->ulITNNumElem = pITNShowStateSource->ulITNNumElem;
                        pITNShowState->ulITNStart = pITNShowStateSource->ulITNStart;

                        pITNShowState ++;
                    }
                }
            }

            // Save the offset list

            if ( ulOffsetSize > 0 )
            {
                ULONG   *pulOffset;

                pulOffset = (ULONG *)((BYTE *)pRecoWrapData + sizeof(RECOWRAPDATA) + ulITNSize);

                for (ULONG i=0; i<ulOffsetNum; i++)
                {
                    pulOffset[i] = cpRecoWrap->_GetElementOffsetCch(pRecoWrapData->ulStartElement + i );
                }
            }

            if (cpRecoWrap->m_bstrCurrentText) 
            {
                pwszText = (WCHAR *)((BYTE *)pRecoWrapData + sizeof(RECOWRAPDATA) + ulITNSize + ulOffsetSize);
                StringCchCopyW(pwszText, ulTextNum, cpRecoWrap->m_bstrCurrentText);
            }

            hr = pStream->Write(
                               pRecoWrapData,       
                               ulSizeRecoWrap,   // the number of bytes to copy
                               &ulrw1 
                               );

            if ( SUCCEEDED(hr) && (ulrw1 == ulSizeRecoWrap))
            {

                //  QI the service provider first then get to the sapi interface
                //
                hr = m_cpResultWrap->QueryInterface(IID_IServiceProvider, (void **)&cpServicePrv);
                if (SUCCEEDED(hr))
                {
                    hr = cpServicePrv->QueryService(GUID_NULL, IID_ISpRecoResult, (void **)&cpRecoResult);
                }

                // 'detach' the result to a mem chunk
                //
                if (SUCCEEDED(hr))
                {
                    hr = cpRecoResult->Serialize(&pResBlock);
                }
        
                // serialize the chunk to the stream
                //
                if (SUCCEEDED(hr) && pResBlock)
                {
                    hr = pStream->Write(
                            pResBlock,       
                            (ULONG)pResBlock->ulSerializedSize,   // the number of bytes to copy
                            &ulrw2 
                        );
    
                    if (pcb)
                        *pcb = ulrw1 + ulrw2;
                
                    // no need for the detached mem chunk
                    CoTaskMemFree(pResBlock);
                }
            }

            cicMemFree(pRecoWrapData);
        }
        else
            hr = E_OUTOFMEMORY;
    } 

    return hr;
}

//
// CPropStoreRecoResultObject::_InitFromIStream
//
// stores IStream copied from param
//
HRESULT CPropStoreRecoResultObject::_InitFromIStream(IStream *pStream, int iSize, ISpRecoContext *pRecoCtxt)
{
    HRESULT hr = S_OK;
    ULONG   ulSize = (ULONG)iSize;

    if (!pStream) return E_INVALIDARG;

    // alloc the mem chunk for the reco
    // blob
    if ( ulSize == 0 )
    {
        STATSTG stg;
        hr = pStream->Stat(&stg, STATFLAG_NONAME);
        
        if (SUCCEEDED(hr))
            ulSize = (int)stg.cbSize.LowPart;
    }
    
    // got size from given stream or param
    
    if (SUCCEEDED(hr))
    {

        // First We want to get RECOWRAPDATA at the begining of the stream.
        RECOWRAPDATA  rwData;

        hr = pStream->Read(
                        &rwData,                  // the destination buf
                        sizeof(RECOWRAPDATA),    // the number of bytes to read
                        NULL
                        );

        if ( SUCCEEDED(hr) )
        {
            
            ULONG  ulITNSize;
            SPITNSHOWSTATE *pITNShowState = NULL;

            ulITNSize = rwData.ulNumOfITN * sizeof(SPITNSHOWSTATE);

            if ( ulITNSize > 0 )
            {
                
                pITNShowState = (SPITNSHOWSTATE *)cicMemAllocClear(ulITNSize);
                rwData.pITNShowState = pITNShowState;

                if ( pITNShowState )
                {
                    hr = pStream->Read(
                                    pITNShowState,       // the destination buf
                                    ulITNSize,           // the number of bytes to read
                                    NULL
                                    );
                }
                else
                    hr = E_OUTOFMEMORY;
            }

            ULONG   *pulOffsetElement = NULL;
            ULONG   ulOffsetSize, ulOffsetNum;

            ulOffsetNum = rwData.ulOffsetNum;
            ulOffsetSize = ulOffsetNum * sizeof(ULONG);

            if ( SUCCEEDED(hr) && ulOffsetSize > 0 )
            {
                pulOffsetElement = (ULONG *) cicMemAllocClear(ulOffsetSize);
                rwData.pulOffset = pulOffsetElement;

                if ( pulOffsetElement )
                {
                    hr = pStream->Read(
                                    pulOffsetElement,    // the destination buf
                                    ulOffsetSize,        // the number of bytes to read
                                    NULL
                                    );
                }
                else
                    hr = E_OUTOFMEMORY;
            }
            
            if ( SUCCEEDED(hr))
            {
             
                ULONG  ulTextSize;
                WCHAR  *pwszText;

                ulTextSize = rwData.ulSize - sizeof(RECOWRAPDATA) - ulITNSize - ulOffsetSize;
                pwszText = (WCHAR *) cicMemAllocClear(ulTextSize);

                rwData.pwszText = pwszText; 

                if ( pwszText )
                {
                    hr = pStream->Read(
                                    pwszText,       // the destination buf
                                    ulTextSize,     // the number of bytes to read
                                    NULL
                                    );

                    if ( SUCCEEDED(hr) )
                    {
                        // prepare cotaskmem chunk
                        SPSERIALIZEDRESULT *pResBlock = (SPSERIALIZEDRESULT *)CoTaskMemAlloc(ulSize - rwData.ulSize + sizeof(ULONG)*4);
                        if (pResBlock)
                        {
                            CComPtr<ISpRecoResult> cpResult;

                            hr = pStream->Read(
                                            pResBlock,               // the destination buf
                                            ulSize - rwData.ulSize,  // the number of bytes to read
                                            NULL
                                        );

                            if (S_OK == hr)
                            {
                                // now create a reco result from the blob data
                                hr = pRecoCtxt->DeserializeResult(pResBlock, &cpResult);
                            }
        
                            CoTaskMemFree(pResBlock);
            
                            if (S_OK == hr)
                            {
                                _InitFromRecoResult(cpResult, &rwData);
                            }
                        }
                    }
                    cicMemFree(pwszText);
                }
                else
                    hr = E_OUTOFMEMORY;
            }

            if ( (hr == S_OK) && (pITNShowState != NULL) )
                cicMemFree(pITNShowState);

            if ( pulOffsetElement != NULL )
                cicMemFree(pulOffsetElement);

        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

     return hr;
}

HRESULT CPropStoreRecoResultObject::_InitFromRecoResult(ISpRecoResult *pResult, RECOWRAPDATA *pRecoWrapData)
{
    HRESULT hr = S_OK;
    ULONG ulStartElement = 0;
    ULONG ulNumElements = 0;
    ULONG ulNumOfITN = 0;
    ULONG ulOffsetNum = 0;
    
    m_cpResultWrap.Release();

    if ( pRecoWrapData == NULL )
        return E_INVALIDARG;
    
    // get start/num of elements
    ulStartElement = pRecoWrapData->ulStartElement;
    ulNumElements = pRecoWrapData->ulNumElements;
    ulNumOfITN = pRecoWrapData->ulNumOfITN;
    ulOffsetNum = pRecoWrapData->ulOffsetNum;

    CRecoResultWrap *prw = new CRecoResultWrap(m_pimx, ulStartElement, ulNumElements, ulNumOfITN);

    if (prw)
    {
        hr = prw->Init(pResult);
    }    
    else
        hr = E_OUTOFMEMORY;

    if (S_OK == hr)
    {
        m_cpResultWrap = SAFECAST(prw, IUnknown *);

        prw->SetOffsetDelta(pRecoWrapData->ulOffsetDelta);
        prw->SetCharsInTrail(pRecoWrapData->ulCharsInTrail);
        prw->SetTrailSpaceRemoved(pRecoWrapData->ulTrailSpaceRemoved);
        prw->m_bstrCurrentText = SysAllocString(pRecoWrapData->pwszText);

        // Update ITN show-state list

        if ( (ulNumOfITN > 0) && pRecoWrapData->pITNShowState )
        {
            SPITNSHOWSTATE *pITNShowState;

            pITNShowState = pRecoWrapData->pITNShowState;

            for ( ULONG i=0; i<ulNumOfITN; i++)
            {
                prw->_InitITNShowState(pITNShowState->fITNShown, pITNShowState->ulITNStart, pITNShowState->ulITNNumElem);
                pITNShowState ++;
            }
        }

        // Update the element Offset list.

        if ( (ulOffsetNum > 0)  &&  (pRecoWrapData->pulOffset ))
        {

            ULONG   *pulOffset;
            
            pulOffset = pRecoWrapData->pulOffset;

            for (ULONG i=0; i< ulOffsetNum; i++)
            {
                prw->_SetElementNewOffset(i + ulStartElement, pulOffset[i] );
            }
        }

        prw->Release();
    }
    
    return hr;
}

HRESULT CPropStoreRecoResultObject::_InitFromResultWrap(IUnknown *pResWrap)
{
    m_cpResultWrap.Release();

    m_cpResultWrap = pResWrap;
    
    if (m_cpResultWrap)
    {
        return S_OK;
    }
    else
        return E_INVALIDARG;
}        


// end of CPropStoreRecoResultObject implementation


//
// CPropStoreLMLattice implementation
//

// ctor
CPropStoreLMLattice::CPropStoreLMLattice(CSapiIMX *pimx)
{
    // init a shared recognition context
    m_cpResultWrap   = NULL;
    
    m_pimx = pimx;

    m_cRef  = 1;
}

// dtor
CPropStoreLMLattice::~CPropStoreLMLattice()
{
}


// IUnknown
STDMETHODIMP CPropStoreLMLattice::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hr;

    Assert(ppvObj);

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ITfPropertyStore))
    {
        *ppvObj = this;
        hr = S_OK;

        this->m_cRef++;
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }

    return hr;
}

STDMETHODIMP_(ULONG) CPropStoreLMLattice::AddRef(void)
{
    this->m_cRef++;

    return this->m_cRef;
}

STDMETHODIMP_(ULONG) CPropStoreLMLattice::Release(void)
{
    this->m_cRef--;

    if (this->m_cRef > 0)
    {
        return this->m_cRef;
    }
    delete this;

    return 0;
}

// ITfPropertyStore

STDMETHODIMP CPropStoreLMLattice::GetType(GUID *pguid)
{
    HRESULT hr = E_INVALIDARG;
    if (pguid)
    {
        *pguid = GUID_PROP_LMLATTICE;
        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP CPropStoreLMLattice::GetDataType(DWORD *pdwReserved)
{
    HRESULT hr = E_INVALIDARG;
    if (pdwReserved)
    {
        *pdwReserved = 0;
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CPropStoreLMLattice::GetData(VARIANT *pvarValue)
{
    HRESULT hr = E_INVALIDARG;

    if (pvarValue)
    {
        QuickVariantInit(pvarValue);

        if (m_cpResultWrap)
        {
            // return ITfLMLattice object
            // we defer the creation of LMlattice object until
            // the time master LM TIP actually access it
            //
            if (!m_cpLMLattice)
            {
                CLMLattice *pLattice = new CLMLattice(m_pimx, m_cpResultWrap);
                if (pLattice)
                {
                    m_cpLMLattice = pLattice;
                    pLattice->Release();
                }

            }
            
            if (m_cpLMLattice)
            {
                IUnknown *pUnk = NULL;
                pvarValue->vt = VT_UNKNOWN;
                hr = m_cpLMLattice->QueryInterface(IID_IUnknown, (void**)&pUnk);
                if (S_OK == hr)
                {
                    pvarValue->punkVal = pUnk;
                }

            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    return hr;
}

STDMETHODIMP CPropStoreLMLattice::OnTextUpdated(DWORD dwFlags, ITfRange *pRange, BOOL *pfAccept)
{
    *pfAccept = FALSE;
    if (dwFlags & TF_TU_CORRECTION)
    {
        *pfAccept = TRUE;
    }
    
    return S_OK;
}

STDMETHODIMP CPropStoreLMLattice::Shrink(ITfRange *pRange, BOOL *pfFree)
{
    // could we have something done here?
    *pfFree = TRUE;
    return S_OK;
}

STDMETHODIMP CPropStoreLMLattice::Divide(ITfRange *pRangeThis, ITfRange *pRangeNew, ITfPropertyStore **ppPropStore)
{
    // 12/17/1999
    // [dividing a range implementation strategy]
    //
    // - pRangeThis contains the text range *before* the dividing point
    // - pRangeNew contrains the range *after* the dividing point
    // - First, adjust this property store to correctly hold a start element and #of element
    //   for pRangeThis
    // - then create a new property store for pRangeNew, which will share the same 
    //   result blob. 
    //
    
    // just an experiment to see if cutting the range works.
    // *ppPropStore = NULL;
    Assert(ppPropStore);
    Assert(pRangeThis);
    Assert(pRangeNew);

    CComPtr<ITfContext> cpic;
    HRESULT hr = pRangeThis->GetContext(&cpic);

    if (SUCCEEDED(hr) && cpic)
    {
        CPSLMEditSession *pes;
        if (pes = new CPSLMEditSession(this, pRangeThis, cpic))
        {
            pes->_SetEditSessionData(ESCB_PROP_DIVIDE, NULL, 0); 
            pes->_SetUnk((IUnknown *)pRangeNew);
            cpic->RequestEditSession(m_pimx->_GetId(), pes, TF_ES_READ | TF_ES_SYNC, &hr);

            if ( SUCCEEDED(hr) )
                *ppPropStore = (ITfPropertyStore *)pes->_GetRetUnknown( );

            pes->Release();
        }
    }
    return hr;
}

//
// CPropStoreLMLattice::_Divide
//
// synopsis : receives edit cookie from edit session
//            so that we can manipulate with ranges
//            to set starting elements/# of elements
//
//
HRESULT CPropStoreLMLattice::_Divide(TfEditCookie ec, ITfRange *pR1, ITfRange *pR2, ITfPropertyStore **ppPs) 
{
    // TODO: based on the given ranges, we calculate the offsets of elements and return a new propstore with
    //       later half of elements 
    
    // some clarifications: in case the lattice object has never been accessed, our result wrap object processes
    // ITfPropertyStore::Divide and Shrink for us. 
    //
    
    return Clone(ppPs);
}

//
// CPropStoreLMLattice::Clone
//
// synopsis : make a new cloned propstore which shares the same SAPI result
//            object as the current class instance
//
//
STDMETHODIMP CPropStoreLMLattice::Clone(ITfPropertyStore **ppPropStore)
{
    HRESULT hr;
    CPropStoreLMLattice *prps = new CPropStoreLMLattice(m_pimx);
    if (prps)
    {
        hr = prps->QueryInterface(IID_ITfPropertyStore, (void **)ppPropStore);

        if (SUCCEEDED(hr))
        {
            hr = prps->_InitFromResultWrap(m_cpResultWrap);
        }
        prps->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CPropStoreLMLattice::GetPropertyRangeCreator(CLSID *pclsid)
{
    HRESULT hr = E_INVALIDARG;

    if (pclsid)
    {
        *pclsid = CLSID_SapiLayr;
        hr = S_OK;
    }

    return hr;
}

//
// CPropStoreLMLattice::Serialize
//
// synopsis: I don't believe it is very useful to get lattice data
//           persisted to doc file. We can always generate it on the fly
//           from device native blob data
//          
//
STDMETHODIMP CPropStoreLMLattice::Serialize(IStream *pStream, ULONG *pcb)
{
    return E_NOTIMPL; 
}


HRESULT CPropStoreLMLattice::_InitFromResultWrap(IUnknown *pResWrap)
{
    m_cpResultWrap.Release();

    m_cpResultWrap = pResWrap;
    
    if (m_cpResultWrap)
    {
        return S_OK;
    }
    else
        return E_INVALIDARG;
}        


// private IID for reco result wrapper
//
//   IID_PRIV_RESULTWRAP 
//   b3407713-50d7-4465-97f9-87ad1e752dc5
//
const IID IID_PRIV_RESULTWRAP =  {
    0xb3407713,
    0x50d7,
    0x4465,
    {0x97, 0xf9, 0x87, 0xad, 0x1e, 0x75, 0x2d, 0xc5}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\sapilayr.cpp ===
//
//  sapilayr.cpp
//
//  implementation of CSapiIMX class body 
//

#include "private.h"
#include "immxutil.h"
#include "sapilayr.h"
#include "globals.h"
#include "propstor.h"
#include "timsink.h"
#include "kes.h"
#include "nui.h"
#include "dispattr.h"
#include "lbarsink.h"
#include "miscfunc.h"
#include "nuibase.h"
#include "xstring.h"
#include "dictctxt.h"
#include "mui.h"
#include "cregkey.h"
#include "oleacc.h"

// {9597CB34-CF6A-11d3-8D69-00500486C135}
static const GUID GUID_OfficeSpeechMode = {
    0x9597cb34,
    0xcf6a,
    0x11d3,
    { 0x8d, 0x69, 0x0, 0x50, 0x4, 0x86, 0xc1, 0x35}
};

STDAPI CICPriv::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IUnknown *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CICPriv::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CICPriv::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

CICPriv *GetInputContextPriv(TfClientId tid, ITfContext *pic)
{
    CICPriv *picp;
    IUnknown *punk;
    GetCompartmentUnknown(pic, GUID_IC_PRIVATE, &punk);

    if (!punk)
    {
        // need to init priv data
        if (picp = new CICPriv(pic))
        {
            SetCompartmentUnknown(tid, pic, GUID_IC_PRIVATE, picp);
        }
    }
    else
    {
        picp = (CICPriv *)punk;
    }

    return picp;
}

CICPriv *EnsureInputContextPriv(CSapiIMX *pimx, ITfContext *pic)
{
    CICPriv *picp = GetInputContextPriv(pimx->_GetId(), pic);
    
    return picp;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CSapiIMX::CSapiIMX() : CFnConfigure(this),  CLearnFromDoc(this), CAddDeleteWord(this), CSelectWord(this),
                       CTextToSpeech(this), CCorrectionHandler(this)
{
    m_pCSpTask  = NULL;
    
    m_hwndWorker = NULL;

    _fDeactivated = TRUE;
    _fEditing = FALSE;
    _tid          = TF_CLIENTID_NULL;
    _cRef = 1;

    //
    // Init DisplayAttribute Provider
    //

    // default 
    COLORREF crBk = GetNewLookColor();
    COLORREF crText = GetTextColor();
    
    // add feedback UI colors
    TF_DISPLAYATTRIBUTE da;
    StringCchCopyW(szProviderName, ARRAYSIZE(szProviderName), L"SAPI Layer");

    SetAttributeColor(&da.crText, crText);
    SetAttributeColor(&da.crBk,   crBk);
    da.lsStyle = TF_LS_NONE;
    da.fBoldLine = FALSE;
    ClearAttributeColor(&da.crLine);
    da.bAttr = TF_ATTR_INPUT;
    Add(GUID_ATTR_SAPI_GREENBAR, L"SAPI Feedback Bar", &da);

    // color for level 2 application (for CUAS)
    crBk = GetNewLookColor(DA_COLOR_UNAWARE);

    SetAttributeColor(&da.crText, crText);
    SetAttributeColor(&da.crBk,   crBk);
    da.lsStyle = TF_LS_NONE;
    da.fBoldLine = FALSE;
    ClearAttributeColor(&da.crLine);
    da.bAttr = TF_ATTR_INPUT;
    Add(GUID_ATTR_SAPI_GREENBAR2, L"SAPI Feedback Bar for Unaware app", &da);
    
    SetAttributeColor(&da.crText, crText);
    SetAttributeColor(&da.crBk,   RGB(255, 0, 0));
    da.lsStyle = TF_LS_NONE;
    da.fBoldLine = FALSE;
    ClearAttributeColor(&da.crLine);
    da.bAttr = TF_ATTR_INPUT;
    Add(GUID_ATTR_SAPI_REDBAR, L"SAPI Red bar", &da);

    // create another dap for simulate 'inverted text' for selection
    SetAttributeColor(&da.crBk, GetSysColor( COLOR_HIGHLIGHT ));
    SetAttributeColor(&da.crText,   GetSysColor( COLOR_HIGHLIGHTTEXT ));
    da.lsStyle = TF_LS_NONE;
    da.fBoldLine = FALSE;
    ClearAttributeColor(&da.crLine);
    da.bAttr = TF_ATTR_TARGET_CONVERTED;
    Add(GUID_ATTR_SAPI_SELECTION, L"SPTIP selection ", &da);

    m_fSharedReco = TRUE;
    m_fShowBalloon = FALSE;

    m_pLanguageChangeNotifySink = NULL;

    m_pSpeechUIServer = NULL;
    m_szCplPath[0]    = _T('\0');
    m_pCapCmdHandler = NULL;
    m_fIPIsUpdated = FALSE;
    m_dwNumCharTyped = 0;
    m_ulSimulatedKey = 0;
    m_pSpButtonControl = NULL;
    m_fModeKeyRegistered = FALSE;

    m_fStartingComposition = FALSE;

    m_fStageTip = FALSE;
    m_fStageVisible = FALSE;
    m_hwndStage = NULL;

    m_ulHypothesisLen = 0;
    m_ulHypothesisNum = 0;

    m_IsInHypoProcessing = FALSE;

    _pCandUIEx = NULL;

    m_pMouseSink = NULL;
    m_fMouseDown = FALSE;
    m_ichMouseSel = 0;

    m_uLastEdge    = 0;
    m_lTimeLastClk = 0;

#ifdef SUPPORT_INTERNAL_WIDGET
    m_fNoCorrectionUI = FALSE;
#endif
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CSapiIMX::~CSapiIMX()
{
    if (m_pSpeechUIServer)
    {
        m_pSpeechUIServer->SetIMX(NULL);
        m_pSpeechUIServer->Release();
        m_pSpeechUIServer = NULL;
    }
   
    ClearCandUI( );

    if (m_hwndWorker)
    {
        DestroyWindow(m_hwndWorker);
    }

    if ( m_pCapCmdHandler )
       delete m_pCapCmdHandler;
}


//+---------------------------------------------------------------------------
//
// PrivateAPI for profile stuff
//
//
//----------------------------------------------------------------------------
extern "C" 
HRESULT WINAPI TF_CreateLangProfileUtil(ITfFnLangProfileUtil **ppFnLangUtil)
{
    return CSapiIMX::CreateInstance(NULL, IID_ITfFnLangProfileUtil, (void **)ppFnLangUtil);
}

//+---------------------------------------------------------------------------
//
// OnSetThreadFocus
//
//----------------------------------------------------------------------------

STDAPI CSapiIMX::OnSetThreadFocus()
{
    TraceMsg(TF_SAPI_PERF, "OnSetThreadFocus is called");

    BOOL  fOn = GetOnOff( );

    // When Microphone is OFF, don't set any speech status to the local compartment.
    // this will cause Office App initialize their SAPI objects if the mode is C&C 
    // even if Microphone OFF.

    // Later when the Microphone is ON, this mode data will be updated correctly
    // inside the MICROPHONE_OPENCLOSE handling.
    //
    if ( fOn )
    {
        // TABLETPC
        // We switch states to match the global state whenever we get focus.
        // This may or may not trigger changes depending on the the stage visibility and dictation state.
        DWORD dwLocal, dwGlobal;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, &dwLocal, FALSE);
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_GLOBALSTATE, &dwGlobal, TRUE);
        dwGlobal = dwGlobal & (TF_DICTATION_ON | TF_COMMANDING_ON);
        if ( (dwLocal & (TF_DICTATION_ON | TF_COMMANDING_ON)) != dwGlobal)
        {
            dwLocal = (dwLocal & ~(TF_DICTATION_ON | TF_COMMANDING_ON)) + dwGlobal;
            SetCompartmentDWORD(_tid, _tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, dwLocal, FALSE);
            // Now we are guaranteed the local dictation state matches the global one.
        }
    }

#ifdef SYSTEM_GLOBAL_MIC_STATUS
    // 
    // The microphone UI status compartment is updated whenever the reco state 
    // changes. What we need to do here is to reset the dictation status
    // and others things that we skip doing when the thread doesn't have 
    // a focus
    //
    //
    MIC_STATUS ms = MICSTAT_NA;

    if (m_pCSpTask)
    {
         ms = m_pCSpTask->_GetInputOnOffState() ? MICSTAT_ON : MICSTAT_OFF;
    }
    _HandleOpenCloseEvent(ms);
#else
    _HandleOpenCloseEvent();
#endif

#ifdef SUPPORT_INTERNAL_WIDGET
    // create widget instance here
    if (!m_fNoCorrectionUI && !m_cpCorrectionUI)
    { 
        if (S_OK == m_cpCorrectionUI.CoCreateInstance(CLSID_CorrectionIMX))
        {
            // the real widget is installed
            m_cpCorrectionUI.Release();
            m_fNoCorrectionUI  = TRUE;
        }
        else if (SUCCEEDED(CCorrectionIMX::CreateInstance(NULL,  IID_ITfTextInputProcessor,  (void **)&m_cpCorrectionUI)))
        {
            m_cpCorrectionUI->Activate(_tim, _tid);
        }
    }
#endif
    
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnKillThreadFocus
//
//----------------------------------------------------------------------------

STDAPI CSapiIMX::OnKillThreadFocus()
{
    // When the Application gets focus again, it will rely on the 
    // current status from compartment, and then decides which RecoContext
    // needs to be activated.
    //
    TraceMsg(TF_SAPI_PERF, "CSapiIMX::OnKillThreadFocus is called");

    // TABLETPC
    if (m_pCSpTask && S_OK != IsActiveThread())
    {
        m_pCSpTask->_SetDictRecoCtxtState(FALSE);
        m_pCSpTask->_SetCmdRecoCtxtState(FALSE);
    }

    // close candidate UI forcefully when focus shifts
    CloseCandUI( );

    return S_OK;
}

BOOL CSapiIMX::InitializeSpeechButtons()
{
    BOOL fSREnabled = _DictationEnabled();

    SetDICTATIONSTAT_DictEnabled(fSREnabled);
    
    // We need to see if the app has commanding if it is, then it 
    // needs the mic even when dictation is disabled
    //
    if (m_pSpeechUIServer)
    {
        BOOL fShow = (fSREnabled || IsDICTATIONSTAT_CommandingEnable());

        m_pSpeechUIServer->ShowUI(fShow);
    }

    return fSREnabled;
}
//+---------------------------------------------------------------------------
//
// Activate
//
//----------------------------------------------------------------------------

STDAPI CSapiIMX::Activate(ITfThreadMgr *ptim, TfClientId tid)
{
    ITfLangBarItemMgr *plbim = NULL;
    ITfKeystrokeMgr_P *pksm = NULL;
    ITfSourceSingle *sourceSingle;
    ITfSource *source;
    ITfContext *pic = NULL;
    BOOL fSREnabledForLanguage = FALSE;
    TfClientId tidLast = _tid;
    
    _tid = tid;

    // Load spgrmr.dll module for speech grammar.
    LoadSpgrmrModule();

    // register notify UI stuff
    HRESULT hr = GetService(ptim, IID_ITfLangBarItemMgr, (IUnknown **)&plbim);

    if (SUCCEEDED(hr))
    {
        plbim->GetItem(GUID_TFCAT_TIP_SPEECH, &m_cpMicButton);
        SafeRelease(plbim);
    }

    // regular stuff for activate
    Assert(_tim == NULL);
    _tim = ptim;
    _tim->AddRef();


    if (_tim->QueryInterface(IID_ITfSource, (void **)&source) == S_OK)
    {
        source->AdviseSink(IID_ITfThreadFocusSink, (ITfThreadFocusSink *)this, &_dwThreadFocusCookie);
        source->AdviseSink(IID_ITfKeyTraceEventSink, (ITfKeyTraceEventSink *)this, &_dwKeyTraceCookie);
        source->Release();
    }

    // force data options to get set
    SetAudioOnOff(TRUE);

    // Register compartment sink for TIP status
    if (!(m_pCes = new CCompartmentEventSink(_CompEventSinkCallback, this)))
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    m_pCes->_Advise(_tim, GUID_COMPARTMENT_SAPI_AUDIO, FALSE);
    m_pCes->_Advise(_tim, GUID_COMPARTMENT_SPEECH_OPENCLOSE, TRUE);
    m_pCes->_Advise(_tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, FALSE);
    m_pCes->_Advise(_tim, GUID_COMPARTMENT_SPEECH_LEARNDOC, FALSE);
    m_pCes->_Advise(_tim, GUID_COMPARTMENT_SPEECH_CFGMENU, FALSE);
    m_pCes->_Advise(_tim, GUID_COMPARTMENT_SPEECH_PROPERTY_CHANGE, TRUE);
#ifdef TF_DISABLE_SPEECH
    m_pCes->_Advise(_tim, GUID_COMPARTMENT_SPEECH_DISABLED, FALSE);
#endif
    //TABLETPC
    m_pCes->_Advise(_tim, GUID_COMPARTMENT_SPEECH_STAGE, FALSE);
    m_pCes->_Advise(_tim, GUID_COMPARTMENT_SPEECH_STAGECHANGE, TRUE);
    // Get initial stage visibility. Note - keep after above _Advise for stage change event.
    DWORD  dw = 0;
    GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_STAGECHANGE, &dw, TRUE);
    m_fStageVisible = dw ? TRUE : FALSE;
    // ENDTABLETPC
   
    //  profile activation sink 
    if (!m_pActiveLanguageProfileNotifySink)
    {
        if (!(m_pActiveLanguageProfileNotifySink = 
              new CActiveLanguageProfileNotifySink(_ActiveTipNotifySinkCallback, this)))
        {
            hr = E_OUTOFMEMORY;
            goto Exit; 
        }
        m_pActiveLanguageProfileNotifySink->_Advise(_tim);
    }
        
    if (!m_pSpeechUIServer &&
        FAILED(CSpeechUIServer::CreateInstance(NULL, 
                                               IID_PRIV_CSPEECHUISERVER, 
                                               (void **)&m_pSpeechUIServer)))
    {
        hr = E_OUTOFMEMORY;
        goto Exit; 
    }

    SetCompartmentDWORD(_tid,_tim,GUID_COMPARTMENT_SPEECH_LEARNDOC,_LMASupportEnabled(),FALSE);

    if (m_pSpeechUIServer)
    {
        m_pSpeechUIServer->SetIMX(this);
        m_pSpeechUIServer->Initialize();
        m_pSpeechUIServer->ShowUI(TRUE);
    }

    
    fSREnabledForLanguage = InitializeSpeechButtons();
    SetDICTATIONSTAT_DictEnabled(fSREnabledForLanguage);

    // language change notification sink 
    // this call better be after calling InitializeSpeechButtons because we
    // want to skip calling _EnsureProfiles to get ITfLanguageProfileNotifySink
    //
    if (!m_pLanguageChangeNotifySink)
    {
        if (!(m_pLanguageChangeNotifySink = 
              new CLanguageProfileNotifySink(_LangChangeNotifySinkCallback, this)))
        {
            hr = E_OUTOFMEMORY;
            goto Exit; 
        }
        m_pLanguageChangeNotifySink->_Advise(m_cpProfileMgr);
    }

    // now we inherit what is previously set as a mic status
    // 
#ifdef SYSTEM_GLOBAL_MIC_STATUS
    if (m_pCSpTask)
    {
        SetOnOff(m_pCSpTask->_GetInputOnOffState());
    }
#else
    // see if microphone is 'ON' and if so, check if we're indeed running
    // we check tidLast because it is normal we get activated again with
    // same client id, and it means we've kept our life across sessions
    // we don't want to reject global mic status in this case, otherwise
    // we'll see bugs like cicero#3386
    //
    if (GetOnOff() && tidLast != tid)
    {
        // this code has to stay before the first call to _EnsureWorkerWnd()
        HWND hwnd = FindWindow(c_szWorkerWndClass, NULL);
        if (!IsWindow(hwnd))
        {
           // no one is running us but we somehow persisted the state
           // let's just kill the 'on' state here
           // SetOnOff(FALSE);
        }
    }
#endif

    // show / hide balloon following global compartment
    m_fShowBalloon = GetBalloonStatus();
    
    // thread event sink init
    if ((m_timEventSink = new CThreadMgrEventSink(_DIMCallback, _ICCallback, this)) == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    else
    {
        m_timEventSink->_Advise(_tim);
        m_timEventSink->_InitDIMs(TRUE);
    }
    
    if (SUCCEEDED(GetService(_tim, IID_ITfKeystrokeMgr_P, (IUnknown **)&pksm)))
    {
        if (_pkes = new CSptipKeyEventSink(_KeyEventCallback, _PreKeyEventCallback, this))
        {    
            pksm->AdviseKeyEventSink(_tid, _pkes, FALSE);

            _pkes->_Register(_tim, _tid, g_prekeyList);

            // register mode button hotkeys if they are enabled.
            HandleModeKeySettingChange(TRUE);

        }
        pksm->Release();
    }
    

    // func provider registeration
    IUnknown *punk;
    if (SUCCEEDED(QueryInterface(IID_IUnknown, (void **)&punk)))
    {
        if (SUCCEEDED(_tim->QueryInterface(IID_ITfSourceSingle, (void **)&sourceSingle)))
        {
            sourceSingle->AdviseSingleSink(_tid, IID_ITfFunctionProvider, punk);
            sourceSingle->Release();
        }
        punk->Release();
    }

    Assert(_fDeactivated);
    _fDeactivated = FALSE;

    // TABLETPC
    if (S_OK == IsActiveThread())
    {
        // init any UI
        OnSetThreadFocus();
    }
    
    hr = S_OK;

Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
// Deactivate
//
//----------------------------------------------------------------------------

STDAPI CSapiIMX::Deactivate()
{
    ITfKeystrokeMgr *pksm = NULL;
    ITfSourceSingle *sourceSingle;    
    ITfSource *source;

    // this ensures no context feed activity is taken place
    SetDICTATIONSTAT_DictOnOff(FALSE);

    // finalize any pending compositions, this may be async
    CleanupAllContexts(_tim, _tid, this);

    // Free the system reconvertion function if it is set.

    _ReleaseSystemReconvFunc( );

    // delete SpButtonControl object

    if ( m_pSpButtonControl )
    {
        delete m_pSpButtonControl;
        m_pSpButtonControl = NULL;
    }

    // TABLETPC
    if (S_OK != IsActiveThread())
    {
        // shutdown any UI
        OnKillThreadFocus();
    }

    if (_tim->QueryInterface(IID_ITfSource, (void **)&source) == S_OK)
    {
        source->UnadviseSink(_dwThreadFocusCookie);
        source->UnadviseSink(_dwKeyTraceCookie);
        source->Release();
    }

    // unregister notify UI stuff
    if (m_pSpeechUIServer && !IsDICTATIONSTAT_CommandingEnable())
    {
        m_pSpeechUIServer->SetIMX(NULL);
        m_pSpeechUIServer->Release();
        m_pSpeechUIServer = NULL;
    }

#ifdef SUPPORT_INTERNAL_WIDGET
    // deactivate the widget correction
    if (m_cpCorrectionUI)
    {
        m_cpCorrectionUI->Deactivate();
        m_cpCorrectionUI.Release();
    }
#endif

    // regular stuff for activate
    ClearCandUI( );

    if (SUCCEEDED(_tim->QueryInterface(IID_ITfSourceSingle, (void **)&sourceSingle)))
    {
        sourceSingle->UnadviseSingleSink(_tid, IID_ITfFunctionProvider);
        sourceSingle->Release();
    }

    // thread event sink deinit
    if (m_timEventSink)
    {
        m_timEventSink->_InitDIMs(FALSE);
        m_timEventSink->_Unadvise();
        SafeReleaseClear(m_timEventSink);
    }

    if (_pkes != NULL)
    {
        _pkes->_Unregister(_tim, _tid, g_prekeyList);

        if ( m_fModeKeyRegistered )
        {
            _pkes->_Unregister(_tim, _tid, (const KESPRESERVEDKEY *)g_prekeyList_Mode);
            m_fModeKeyRegistered = FALSE;
        }
        
        SafeReleaseClear(_pkes);
    }

    if (SUCCEEDED(GetService(_tim, IID_ITfKeystrokeMgr, (IUnknown **)&pksm)))
    {
        pksm->UnadviseKeyEventSink(_tid);
        pksm->Release();
    }
    if (m_pCes)
    {
        m_pCes->_Unadvise();
        SafeReleaseClear(m_pCes);
    }

    if (m_pLBarItemSink)
    {
        m_pLBarItemSink->_Unadvise();
        SafeReleaseClear(m_pLBarItemSink);
    }

    if (m_pMouseSink)
    {
        m_pMouseSink->_Unadvise();
        SafeReleaseClear(m_pMouseSink);
    }
    
    // clean up active notify sink
    if (m_pActiveLanguageProfileNotifySink)
    {
        m_pActiveLanguageProfileNotifySink->_Unadvise();
        SafeReleaseClear(m_pActiveLanguageProfileNotifySink);
    }

    if (m_pLanguageChangeNotifySink)
    {
        m_pLanguageChangeNotifySink->_Unadvise();
        SafeReleaseClear(m_pLanguageChangeNotifySink);
    }

    if (m_hwndWorker)
    {
        DestroyWindow(m_hwndWorker);
        m_hwndWorker = NULL;
    }
    DeinitializeSAPI();

    SafeReleaseClear(_tim);

    TFUninitLib_Thread(&_libTLS);

    Assert(!_fDeactivated);
    _fDeactivated  = TRUE;

    return S_OK;
}

HRESULT CSapiIMX::InitializeSAPI(BOOL fLangOverride)
{
    HRESULT hr = S_OK;

    TraceMsg(TF_SAPI_PERF, "CSapiIMX::InitializeSAPI is called");

    if (m_pCSpTask)
    {
        if (!m_pCSpTask->_IsCallbackInitialized())
        {
            hr = m_pCSpTask->InitializeCallback();
        }
        TraceMsg(TF_SAPI_PERF, "CSapiIMX::InitializeSAPI is initialized, hr=%x\n", hr);
        return hr;
    }


    HCURSOR hCur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // create CSpTask instance
        m_pCSpTask = new CSpTask(this);
    if (m_pCSpTask)
    {
//        LANGID m_langid;

        // check to see if profile lang matches with SR lang
        m_fDictationEnabled = _DictationEnabled(&m_langid);
    
        hr = m_pCSpTask->InitializeSAPIObjects(m_langid);

        if (S_OK == hr && !_fDeactivated &&
           (m_fDictationEnabled || IsDICTATIONSTAT_CommandingEnable()))
        {
            // set callback
            hr = m_pCSpTask->InitializeCallback();
        }

        if (S_OK == hr)
        {
            hr = m_pCSpTask->_LoadGrammars();
        }

        if (S_OK == hr)
        {
            // toolbar command
            m_pCSpTask->_InitToolbarCommand(fLangOverride);
        }
    }
    if (hCur)
        SetCursor(hCur);

    TraceMsg(TF_SAPI_PERF, "CSapiIMX::InitializeSAPI is done!!!!!  hr=%x\n", hr);
    return hr;
}


HRESULT CSapiIMX::DeinitializeSAPI()
{
    TraceMsg(TF_SAPI_PERF, "DeinitializeSAPI is called");
    if (m_pCSpTask)
    {
         // toolbar command 
        m_pCSpTask->_UnInitToolbarCommand();

        // set dication status
        SetDICTATIONSTAT_DictOnOff(FALSE);

        // - deinitialize SAPI
        m_pCSpTask->_ReleaseSAPI();

        delete m_pCSpTask;
        m_pCSpTask = NULL;
    }
    
    return S_OK;
}

HRESULT CSapiIMX::_ActiveTipNotifySinkCallback(REFCLSID clsid, REFGUID guidProfile, BOOL fActivated, void *pv)
{
    if (IsEqualGUID(clsid, CLSID_SapiLayr))
    {
        CSapiIMX *pimx = (CSapiIMX *)pv;
        if (fActivated)
        {
            BOOL fSREnabledForLanguage = pimx->InitializeSpeechButtons();
        
            pimx->SetDICTATIONSTAT_DictEnabled(fSREnabledForLanguage);
        }
        else
        {
            // finalize any pending compositions, this may be async
            CleanupAllContexts(pimx->_tim, pimx->_tid, pimx);

            // when deactivating, we have to deinitialize SAPI so that 
            // we can re-initialize SAPI after getting a new assembly
            pimx->DeinitializeSAPI();
        }
    }
    return S_OK;
}


HRESULT CSapiIMX::_LangChangeNotifySinkCallback(BOOL fChanged, LANGID langid, BOOL *pfAccept, void *pv)
{
    CSapiIMX *pimx = (CSapiIMX *)pv;

     
    if (fChanged)
    {
        pimx->m_fDictationEnabled = pimx->InitializeSpeechButtons();
        
        pimx->SetDICTATIONSTAT_DictEnabled(pimx->m_fDictationEnabled);

        if (!pimx->m_fDictationEnabled)
        {
            // finalize any pending compositions, this may be async
            CleanupAllContexts(pimx->_tim, pimx->_tid, pimx);

            if (!pimx->IsDICTATIONSTAT_CommandingEnable())
                pimx->DeinitializeSAPI();

        }
/*   With the Global Mode state supporting, we don't want this message for languag switch handling.
        else
        {
            if (pimx->_GetWorkerWnd())
            {
                TraceMsg(TF_SAPI_PERF, "Send WM_PRIV_ONSETTHREADFOCUS message");
                PostMessage(pimx->_GetWorkerWnd(), WM_PRIV_ONSETTHREADFOCUS, 0, 0);
            }
        }
*/

    }
    
    return S_OK;
}

//
//
// ITfCreatePropertyStore implementation
//
//
STDMETHODIMP
CSapiIMX::CreatePropertyStore(
        REFGUID guidProp, 
        ITfRange *pRange,  
        ULONG cb, 
        IStream *pStream, 
        ITfPropertyStore **ppStore
)
{
    HRESULT hr = E_FAIL;
    //
    // 
    //
    if (IsEqualGUID(guidProp, GUID_PROP_SAPIRESULTOBJECT))
    {
        CPropStoreRecoResultObject *pPropStore;
        CComPtr<ISpRecoContext> cpRecoCtxt;
        
        // ensure SAPI is initialized
        InitializeSAPI(TRUE);
        
        hr = m_pCSpTask->GetSAPIInterface(IID_ISpRecoContext, (void **)&cpRecoCtxt);
        
        pPropStore = new CPropStoreRecoResultObject(this, pRange);
        if (pPropStore)
        {
            hr = pPropStore->_InitFromIStream(pStream, cb, cpRecoCtxt);
            
            if (SUCCEEDED(hr))
                hr = pPropStore->QueryInterface(IID_ITfPropertyStore, (void **)ppStore);

            pPropStore->Release();
        }
    }
    
    return hr;
}

STDAPI CSapiIMX::IsStoreSerializable(REFGUID guidProp, ITfRange *pRange, ITfPropertyStore *pPropStore, BOOL *pfSerializable)
{
    *pfSerializable = FALSE;
    if (IsEqualGUID(guidProp, GUID_PROP_SAPIRESULTOBJECT))
    {
        *pfSerializable = TRUE;
    }

    return S_OK;
}

STDMETHODIMP CSapiIMX::GetType(GUID *pguid)
{
    HRESULT hr = E_INVALIDARG;
    if (pguid)
    {
        *pguid = CLSID_SapiLayr;
        hr = S_OK;
    }
    
    return hr;
}

STDMETHODIMP CSapiIMX::GetDescription(BSTR *pbstrDesc)
{
    const WCHAR c_wszNameSapiLayer[] = L"Cicero Sapi function Layer";
    HRESULT hr = S_OK;
    BSTR pbstr;
    if (!(pbstr = SysAllocString(c_wszNameSapiLayer)))
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CSapiIMX::GetFunction(REFGUID rguid, REFIID riid, IUnknown **ppunk)
{
    if (!ppunk)
        return E_INVALIDARG;

    *ppunk = NULL;

    HRESULT hr = E_NOTIMPL;

    if (!IsEqualGUID(rguid, GUID_NULL))
        return hr;

    if (IsEqualIID(riid, IID_ITfFnGetSAPIObject))
    {
        *ppunk = new CGetSAPIObject(this);
    }
    else
    {

        if (IsEqualGUID(riid, IID_ITfFnPlayBack))
        {
            *ppunk = new CSapiPlayBack(this);
        }
        else if (IsEqualGUID(riid, IID_ITfFnReconversion))
        {
            *ppunk = new CFnReconversion(this);
        }
        else if (IsEqualIID(riid, IID_ITfFnAbort))
        {
            *ppunk = new CFnAbort(this);
        }
        else if (IsEqualIID(riid, IID_ITfFnBalloon))
        {
            *ppunk = new CFnBalloon(this);
        }
        else if (IsEqualIID(riid, IID_ITfFnPropertyUIStatus))
        {
            *ppunk = new CFnPropertyUIStatus(this);
        }
        else
        {
            // This class decides if it's necessary to initialize
            // SAPI to retrieve the requested interface
            //
            CComPtr<CGetSAPIObject> cpGetSapi;
            cpGetSapi.Attach(new CGetSAPIObject(this));

            //
            //
            //
            if (cpGetSapi)
            {
                TfSapiObject tfSapiObj;

                // this returns S_FALSE if the iid does not match
                hr = cpGetSapi->IsSupported(riid, &tfSapiObj);

                if (S_OK == hr)
                {
                    // *ppunk is initialized w/ NULL in GetSAPIInterface()
                    // ppunk should get addref'd
                    hr = cpGetSapi->Get(tfSapiObj, ppunk);
                }
                else
                    hr = E_NOTIMPL;


                if (hr == E_NOTIMPL)
                {
                    // should we care?
                    // this indicates that the caller has requested an interface
                    // that we are not dealing with.
                    // The caller could just detect this failure and do their own stuff. 
                    TraceMsg(TF_GENERAL, "Caller requested SAPI interface Cicero doesn't handle");
                }
            }
        }
    }
    if (*ppunk)
    {
        hr = S_OK;
    }

    return hr;   
}

//+---------------------------------------------------------------------------
//
// _TextEventSinkCallback
//
//----------------------------------------------------------------------------

HRESULT CSapiIMX::_TextEventSinkCallback(UINT uCode, void *pv, void *pvData)
{
    TESENDEDIT *pee = (TESENDEDIT *)pvData;
    HRESULT hr = E_FAIL;

    Assert(uCode == ICF_TEXTDELTA); // the only one we asked for

    CSapiIMX *pimx = (CSapiIMX *)pv;

    if (pimx->_fEditing)
        return S_OK;

    pimx->HandleTextEvent(pee->pic, pee);

    hr = S_OK;

    return hr;
}

void CSapiIMX::HandleTextEvent(ITfContext *pic, TESENDEDIT *pee)
{
    ITfRange *pRange = NULL;
    
    Assert(pic);
    Assert(pee);

	if (!m_pCSpTask)
	{
		return;
	}

	// Get the selection/IP if it's updated
    BOOL fUpdated = FALSE;
	if (S_OK == _GetSelectionAndStatus(pic, pee, &pRange, &fUpdated))
	{
		// Handle context feed
        if (fUpdated)
        {
            _FeedIPContextToSR(pee->ecReadOnly, pic, pRange);

            BOOL   fEmpty = FALSE;
            BOOL   fSelection;

            // Get current selection status.
            if  ( pRange != NULL )
                pRange->IsEmpty(pee->ecReadOnly, &fEmpty);

            fSelection = !fEmpty;

            if ( fSelection != m_pCSpTask->_GetSelectionStatus( ) )
            {
                m_pCSpTask->_SetSelectionStatus(fSelection);
                m_pCSpTask->_SetSpellingGrammarStatus(GetDICTATIONSTAT_DictOnOff());
            }
        } 

		// Handle mode bias property data
		SyncWithCurrentModeBias(pee->ecReadOnly, pRange, pic);

		SafeRelease(pRange);
	}

    // m_fIPIsUpdated just keeps if there is IP change by other tips or keyboard typing
    // since last dictation. It doesn't care about the ip change caused by speech tip itself,
    // those ip changes would include feedback ui inject and final text inject.
    // 
    // Every time when a dictation or spelling phrase is recognized, this value should be
    // reset to FALSE.
    //
    // Here m_fIPIsUpdated should not just keep the last value returned by _GetSelectionAndStatus,
    // There is a scenario like, user move the ip to other place and then speak a command ( with some
    // some hypothesis feedback before the command is recognized).
    // In this case we should treat it as ip changed since last dictation, but the last value returned
    // from _GetSelectionAndStatus could be FALSE, because _GetSelectionAndStatus treats Sptip-injected 
    // feedback tex as non-ipchanged.
    //
    // So only when m_fIPIsUpdated is FALSE, we get new value from _GetSelectionAndStatus, 
    // otherwise, keep it till the next dictation.

    if ( m_fIPIsUpdated == FALSE )
       m_fIPIsUpdated = fUpdated;

}

void CSapiIMX::_FeedIPContextToSR(TfEditCookie ecReadOnly, ITfContext *pic, ITfRange *pRange)
{
    if (GetOnOff() == TRUE && _ContextFeedEnabled())
    {
        CDictContext *pdc = new CDictContext(pic, pRange);
        if (pdc)
        {
            if (GetDICTATIONSTAT_DictOnOff() == TRUE &&
                S_OK == pdc->InitializeContext(ecReadOnly))
            {
                Assert(m_pCSpTask);
                m_pCSpTask->FeedDictContext(pdc);
            }
            else
               delete pdc;
       
        }
    }
}

void CSapiIMX::_SetCurrentIPtoSR(void)
{
    _RequestEditSession(ESCB_FEEDCURRENTIP, TF_ES_READ);
}

HRESULT CSapiIMX::_InternalFeedCurrentIPtoSR(TfEditCookie ecReadOnly, ITfContext *pic)
{
    CComPtr<ITfRange> cpRange;
    HRESULT hr = GetSelectionSimple(ecReadOnly, pic, &cpRange);

    if (S_OK == hr)
    {
        _FeedIPContextToSR(ecReadOnly, pic, cpRange);
    }
    return hr;
}


BOOL CSapiIMX::HandleKey(WCHAR ch)
{
    m_ulSimulatedKey = 1;
    keybd_event((BYTE)ch, 0, 0, 0);
    keybd_event((BYTE)ch, 0, KEYEVENTF_KEYUP, 0);
    return TRUE;
}

const TCHAR c_szcplsKey[]    = TEXT("software\\microsoft\\windows\\currentversion\\control panel\\cpls");
void CSapiIMX::GetSapiCplPath(TCHAR *szCplPath, int cchSizePath)
{
    if (!m_szCplPath[0])
    {
        CMyRegKey regkey;
        if (S_OK == regkey.Open(HKEY_LOCAL_MACHINE, c_szcplsKey, KEY_READ))
        {
            LONG lret = regkey.QueryValueCch(m_szCplPath, TEXT("SapiCpl"), ARRAYSIZE(m_szCplPath));

            if (lret != ERROR_SUCCESS)
               lret = regkey.QueryValueCch(m_szCplPath, TEXT("Speech"), ARRAYSIZE(m_szCplPath));

            if (lret != ERROR_SUCCESS)
                m_szCplPath[0] = _T('\0'); // maybe we get lucky next time
        }
    }
    StringCchCopy(szCplPath, cchSizePath, m_szCplPath);
}



HRESULT CSapiIMX::_GetSelectionAndStatus(ITfContext *pic, TESENDEDIT *pee, ITfRange **ppRange, BOOL *pfUpdated)
{
    
    BOOL    fWriteSession;
    HRESULT hr = pic->InWriteSession(_tid, &fWriteSession);

    Assert(pfUpdated);
    *pfUpdated = FALSE;

    if (S_OK == hr)
    {
        // we don't want to pick up changes done by ourselves
        if (!fWriteSession)
        {
            hr = pee->pEditRecord->GetSelectionStatus(pfUpdated);
        }
        else
        {
            // returns S_FALSE when in write session
            hr = S_FALSE;
        }
    }

    if (S_OK == hr )
    {
        Assert(ppRange);
        hr = GetSelectionSimple(pee->ecReadOnly, pic, ppRange);
    }

    return hr;
}

void CSapiIMX::SyncWithCurrentModeBias(TfEditCookie ec, ITfRange *pRange, ITfContext *pic)
{
    ITfReadOnlyProperty *pProp = NULL;
    VARIANT var;
    QuickVariantInit(&var);

    if (pic->GetAppProperty(GUID_PROP_MODEBIAS, &pProp) != S_OK)
    {
        pProp = NULL;
        goto Exit;
    }

    pProp->GetValue(ec, pRange, &var);

    if (_gaModebias != (TfGuidAtom)var.lVal)
    {
        GUID guid;
        _gaModebias = (TfGuidAtom)var.lVal;
        GetGUIDFromGUIDATOM(&_libTLS, _gaModebias, &guid);
 
        BOOL fActive;
        if (!IsEqualGUID(guid, GUID_MODEBIAS_NONE))
        {
            fActive = TRUE;
        }
        else
        {
            fActive = FALSE;
        }
        // mode bias has to be remembered
        if (m_pCSpTask)
            m_pCSpTask->_SetModeBias(fActive, guid);
    }
Exit:
    VariantClear(&var);
    SafeRelease(pProp);
}



HRESULT CSapiIMX::_HandleTrainingWiz()
{
    WCHAR sz[64];
    sz[0] = '\0';
    CicLoadStringWrapW(g_hInst, IDS_UI_TRAINING, sz, ARRAYSIZE(sz));

    CComPtr<ISpRecognizer>    cpRecoEngine;
    HRESULT hr = m_pCSpTask->GetSAPIInterface(IID_ISpRecognizer, (void **)&cpRecoEngine);
    if (S_OK == hr && cpRecoEngine)
    {
        DWORD dwDictStatBackup = GetDictationStatBackup();

        DWORD dwBefore;

        if (S_OK != GetCompartmentDWORD(_tim, 
                                        GUID_COMPARTMENT_SPEECH_DISABLED, 
                                        &dwBefore, 
                                        FALSE) )
        {
            dwBefore = 0;
        }

        SetCompartmentDWORD(0, _tim, GUID_COMPARTMENT_SPEECH_DISABLED, TF_DISABLE_DICTATION, FALSE);

        cpRecoEngine->DisplayUI(_GetAppMainWnd(), sz, SPDUI_UserTraining, NULL, 0);

        SetCompartmentDWORD(0, _tim, GUID_COMPARTMENT_SPEECH_DISABLED, dwBefore, FALSE);
        SetDictationStatAll(dwDictStatBackup);
    }

    return hr;
}

HRESULT CSapiIMX::_RequestEditSession(UINT idEditSession, DWORD dwFlag, ESDATA *pesData, ITfContext *picCaller, LONG_PTR *pRetData, IUnknown **ppRetUnk)
{
    CSapiEditSession    *pes;
    CComPtr<ITfContext> cpic;
    HRESULT             hr = E_FAIL;

    // callers can intentionally give us a NULL pic
    if (picCaller == NULL)
    {
        GetFocusIC(&cpic);
    }
    else
	{
        cpic = picCaller;
	}

    if (cpic)
    {
        if (pes = new CSapiEditSession(this, cpic))
        {
            if ( pesData )
            {
                pes->_SetRange(pesData->pRange);
                pes->_SetUnk(pesData->pUnk);
                pes->_SetEditSessionData(idEditSession, pesData->pData, pesData->uByte, pesData->lData1, pesData->lData2, pesData->fBool);
            }
            else
                pes->_SetEditSessionData(idEditSession, NULL, 0);

            cpic->RequestEditSession(_tid, pes, dwFlag, &hr);

            // if caller wants to get the return value from the edit session, it has to set SYNC edit session.
            if ( pRetData )
                *pRetData = pes->_GetRetData( );

            if ( ppRetUnk )
                *ppRetUnk = pes->_GetRetUnknown( );

            pes->Release();
        }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
// _DIMCallback
//
//----------------------------------------------------------------------------
HRESULT CSapiIMX::_DIMCallback(UINT uCode, ITfDocumentMgr *dim, ITfDocumentMgr * pdimPrevFocus, void *pv)
{
    CSapiIMX *_this = (CSapiIMX *)pv;

    switch (uCode)
    {
        case TIM_CODE_INITDIM:
            //
            // Add this dim to the LearnFromDoc internal dim list with fFeed as FALSE.
            TraceMsg(TF_GENERAL, "TIM_CODE_INITDIM callback is called, DIM is %x", (INT_PTR)dim);
            _this->_AddDimToList(dim, FALSE);

            break;
            // clean up any reference to ranges
        case TIM_CODE_UNINITDIM:

            TraceMsg(TF_GENERAL, "TIM_CODE_UNINITDIM callback is called, DIM is %x", (INT_PTR)dim);
            _this->_RemoveDimFromList(dim);

            if (_this->m_pCSpTask)
                _this->m_pCSpTask->CleanupDictContext();

            //DIM is to destroyed, we want to stop speaking if TTS is playing
            if ( _this->_IsInPlay( ) )
            {
                _this->_HandleEventOnPlayButton( );
            }

            break;

        case TIM_CODE_SETFOCUS:
            TraceMsg(TF_GENERAL, "TIM_CODE_SETFOCUS callback is called, DIM is %x", (INT_PTR)dim);

            if ( !_this->m_fStageTip )
            {
                // The stage tip is a special instance of a RichEdit control that wants to stay active (i.e. enabled)
                // regardless of focus elsewhere in the hosting application. This way dictaion always goes to the stage.
                // This relies on a written-in-stone contract that only one Cicero enabled text input control exists in
                // said application.
                _this->SetDICTATIONSTAT_DictEnabled(dim ? _this->m_fDictationEnabled : FALSE);
            }

            // When TIM_CODE_SETFOCUS is called means there is a document focus change.
            // No matter what DIM is getting focus now, we just need to close the existing 
            // candidate list menu.
            // NOTE - for the TabletTip stage instance, do we want to close the candidate UI. This means when the user clicks in
            // the area surrounding the stage RichEdit or on the titlebar, the correction menu (and widget) get dismissed.
            // This means when TabletTip is dragged around with either of these visible, the correction widget or menu gets dismissed
            // since the first step of the drag is a click in the titlebar. NOTE - if we disable this code here it still gets dismissed
            // so there is another handler somewhere triggering that.

            _this->CloseCandUI( );

            if ( dim )
            {
                // A DIM is getting focus, when LearnFromDoc is set, we need to feed 
                // the existing document to the Dictation grammar.

                // And we need to check if we already feed the document for this dim to the SREngine.
                // if we did, we don't feed it again for the same document.

                if ( _this->GetLearnFromDoc( ) == TRUE )
                {
                    HRESULT  hr = S_OK;

                    hr = _this->HandleLearnFromDoc( dim );
                }
                else
                    TraceMsg(TF_GENERAL, "Learn From DOC is set to FALSE");

                // We want to check if this new DIM is AIMM aware or pure Cicero aware,
                // so that we can determine if we want to disble TTS buttons.
                ITfContext  *pic;

                dim->GetTop(&pic);

                if ( pic )
                {
                    _this->_SetTTSButtonStatus( pic );


                    // for the top ic, we hook the modebias change
                    // notification so that we can set up the corresponding
                    // grammar for the bias
                    //
                    if (_this->GetDICTATIONSTAT_DictOnOff())
                        _this->_SyncModeBiasWithSelection(pic);

                    SafeRelease(pic);
                }

            }

            break;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _ICCallback
//
//----------------------------------------------------------------------------

/* static */
HRESULT CSapiIMX::_ICCallback(UINT uCode, ITfContext *pic, void *pv)
{
    HRESULT hr = E_FAIL;
    CSapiIMX *_this = (CSapiIMX *)pv;
    CICPriv *priv;
    ITfContext *picTest;

    switch (uCode)
    {
        case TIM_CODE_INITIC:
            if ((priv = EnsureInputContextPriv(_this, pic)) != NULL)
            {
                _this->_InitICPriv(priv, pic);
                priv->Release();

                // We want to check if this IC is under a foucs DIM, and if it is AIMM aware or pure Cicero aware,
                // so that we can determine if we want to disble TTS buttons.
                ITfDocumentMgr  *pFocusDIM = NULL, *pThisDIM = NULL;

                _this->GetFocusDIM(&pFocusDIM);

                pic->GetDocumentMgr(&pThisDIM);

                if ( pFocusDIM == pThisDIM )
                {
                    _this->_SetTTSButtonStatus( pic );
                }

                SafeRelease(pFocusDIM);
                SafeRelease(pThisDIM);

                hr = S_OK;
            }
            break;

        case TIM_CODE_UNINITIC:
            // start setfocus code
            if ((priv = GetInputContextPriv(_this->_tid, pic)) != NULL)
            {
                _this->_DeleteICPriv(priv, pic);
                priv->Release();
                hr = S_OK;
            }

            if (_this->m_cpRangeCurIP != NULL) // should m_cpRangeCurIP be per-ic and stored in icpriv?
            {
                // free up m_cpRangeCurIP if it belongs to this context
                if (_this->m_cpRangeCurIP->GetContext(&picTest) == S_OK)
                {
                    if (pic == picTest)
                    {
                        _this->m_cpRangeCurIP.Release();
                    }
                    picTest->Release();
                }
            }

            // IC is getting popped. We need to reset cicero awareness
            // status based on the bottom IC. This assumes IC stack to
            // be 2 at maximum.
            //
            if (pic)
            {
                CComPtr<ITfContext>  cpicTop;
                CComPtr<ITfDocumentMgr> cpdim;

                hr = pic->GetDocumentMgr(&cpdim);

                if (S_OK == hr)
                {
                    cpdim->GetBase(&cpicTop);
                }

                if ( cpicTop )
                {
                    _this->_SetTTSButtonStatus( cpicTop );
                }
            }
            break;

    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// _DeleteICPriv
//
//----------------------------------------------------------------------------

void CSapiIMX::_DeleteICPriv(CICPriv *priv, ITfContext *pic)
{

    if (!priv)
        return;

    if (priv->m_pTextEvent)
    {
        priv->m_pTextEvent->_Unadvise();
        SafeReleaseClear(priv->m_pTextEvent); 
    }

    // we MUST clear out the private data before cicero is free to release the ic
    ClearCompartment(_tid, pic, GUID_IC_PRIVATE, FALSE);

    // this is it, we won't need the private data any longer
}

//+---------------------------------------------------------------------------
//
// _InitICPriv
//
//----------------------------------------------------------------------------

void CSapiIMX::_InitICPriv(CICPriv *priv, ITfContext *pic)
{

    if (!priv->m_pTextEvent)
    {
        if ((priv->m_pTextEvent = new CTextEventSink(CSapiIMX::_TextEventSinkCallback, this)) != NULL)
        {
            priv->m_pTextEvent->_Advise(pic, ICF_TEXTDELTA);
        }
    }
}


//+---------------------------------------------------------------------------
//
// _KillFocusRange
//
// get rid of the focusrange within the given range
//
//---------------------------------------------------------------------------+

HRESULT CSapiIMX::_KillFocusRange(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, TfClientId tid)
{
    HRESULT hr = E_FAIL;
    IEnumITfCompositionView *pEnumComp = NULL;
    ITfContextComposition *picc = NULL;
    ITfCompositionView *pCompositionView;
    ITfComposition *pComposition;
    CLSID clsid;
    CICPriv *picp;

    //
    // clear any sptip compositions over the range
    //

    if (pic->QueryInterface(IID_ITfContextComposition, (void **)&picc) != S_OK)
        goto Exit;

    if (picc->FindComposition(ec, pRange, &pEnumComp) != S_OK)
        goto Exit;

    // tid will be TF_CLIENTID_NULL when we're deactivated, in which case we
    // don't want to mess with the composition count
    picp = (tid == TF_CLIENTID_NULL) ? NULL : GetInputContextPriv(tid, pic);

    while (pEnumComp->Next(1, &pCompositionView, NULL) == S_OK)
    {
        if (pCompositionView->GetOwnerClsid(&clsid) != S_OK)
            goto NextComp;

        // make sure we ignore other TIPs' compositions!
        if (!IsEqualCLSID(clsid, CLSID_SapiLayr))
            goto NextComp;

        if (pCompositionView->QueryInterface(IID_ITfComposition, (void **)&pComposition) != S_OK)
            goto NextComp;

        // found a composition, terminate it
        pComposition->EndComposition(ec);
        pComposition->Release();

        if (picp != NULL)
        {
            picp->_ReleaseComposition();
        }

NextComp:
        pCompositionView->Release();
    }

    SafeRelease(picp);

    hr = S_OK;

Exit:
    SafeRelease(picc);
    SafeRelease(pEnumComp);

    return hr;
}


//+---------------------------------------------------------------------------
//
// _SetFocusToStageIfStage
//
// Many voice commands (particularly selection and correction) do not make
// sense unless the focus is in the stage. This adjusts focus so the commands
// work as the user will expect.
//
//---------------------------------------------------------------------------+
HRESULT CSapiIMX::_SetFocusToStageIfStage(void)
{
    HRESULT hr = S_OK;

    if (m_fStageTip)
    {
        ASSERT(m_hwndStage && L"Have null HWND for stage.");
        if (m_hwndStage)
        {
            CComPtr<IAccessible> cpAccessible;
            hr = AccessibleObjectFromWindow(m_hwndStage, OBJID_WINDOW, IID_IAccessible, (void **)&cpAccessible);
            if (SUCCEEDED(hr) && cpAccessible)
            {
                CComVariant cpVar = CHILDID_SELF;
                hr = cpAccessible->accSelect(SELFLAG_TAKEFOCUS, cpVar);
            }

        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// _SetFilteringString
//
// When non-matching event is notified, this function is called to inject 
// previous filtering string to the parent document.
//
//---------------------------------------------------------------------------+
HRESULT CSapiIMX::_SetFilteringString(TfEditCookie ec, ITfCandidateUI *pCandUI, ITfContext *pic)
{
    HRESULT hr = E_FAIL;

    ITfRange *pRange;

    BSTR bstr;

    CDocStatus ds(pic);
    if (ds.IsReadOnly())
       return S_OK;

    if (SUCCEEDED(GetSelectionSimple(ec, pic, &pRange )))
    {
        CComPtr<ITfProperty> cpProp;
        LANGID langid = 0x0409;

        // get langid from the given range
        if (SUCCEEDED(hr = pic->GetProperty(GUID_PROP_LANGID, &cpProp)))
        {
            GetLangIdPropertyData(ec, cpProp, pRange, &langid);
        }
        
        CComPtr<ITfCandUIFnAutoFilter> cpFnFilter;
        hr = _pCandUIEx->GetFunction(IID_ITfCandUIFnAutoFilter, (IUnknown **)&cpFnFilter);

 
        if (S_OK == hr && SUCCEEDED(cpFnFilter->GetFilteringString( CANDUIFST_DETERMINED, &bstr )))
        {
            hr = SetTextAndProperty(&_libTLS, ec, pic, pRange, bstr, SysStringLen(bstr), langid, NULL);
            SysFreeString( bstr );
        }

        pRange->Collapse( ec, TF_ANCHOR_END );
        SetSelectionSimple(ec, pic, pRange);

        // we don't want to inject undetermined string to the document anymore. 
        // Cicero will inject the non-matching keyboard char
        // to the document right after the determined filter string.

        pRange->Release();
    }
    return hr;
}


//----------------------------------------------------------------------------
//
// _CompEventSinkCallback (static)
//
//----------------------------------------------------------------------------
HRESULT CSapiIMX::_CompEventSinkCallback(void *pv, REFGUID rguid)
{
    CSapiIMX *_this = (CSapiIMX *)pv;
    BOOL fOn;

    if (IsEqualGUID(rguid, GUID_COMPARTMENT_SAPI_AUDIO))
    {
        fOn = _this->GetAudioOnOff();

        if (_this->m_pCSpTask)
            _this->m_pCSpTask->_SetAudioRetainStatus(fOn);
        return S_OK;
    }
    else if (IsEqualGUID(rguid, GUID_COMPARTMENT_SPEECH_OPENCLOSE))
    {
        HRESULT hr = S_OK;

#ifdef SAPI_PERF_DEBUG
        DWORD dw;
        GetCompartmentDWORD(_this->_tim, GUID_COMPARTMENT_SPEECH_OPENCLOSE, &dw, TRUE);
        TraceMsg(TF_SAPI_PERF, "GUID_COMPARTMENT_SPEECH_OPENCLOSE event : %i. \n", dw);
#endif        
        // TABLETPC
        if ( S_OK != _this->IsActiveThread() )
        {
            TraceMsg(TF_GENERAL, "SPEECH_OPENCLOSE, App doesn't get Focus!");
            return hr;
        }

        TraceMsg(TF_GENERAL, "SPEECH_OPENCLOSE, App GETs Focus!");

        DWORD dwLocal, dwGlobal;
        GetCompartmentDWORD(_this->_tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, &dwLocal, FALSE);
        GetCompartmentDWORD(_this->_tim, GUID_COMPARTMENT_SPEECH_GLOBALSTATE, &dwGlobal, TRUE);
        dwGlobal = dwGlobal & (TF_DICTATION_ON + TF_COMMANDING_ON);

        if ( (dwLocal & (TF_DICTATION_ON + TF_COMMANDING_ON)) != dwGlobal)
        {
            dwLocal = (dwLocal & ~(TF_DICTATION_ON + TF_COMMANDING_ON)) + dwGlobal;
            SetCompartmentDWORD(_this->_tid, _this->_tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, dwLocal, FALSE);
        }


        // first time...
        if (!_this->m_pCSpTask)
        {
            //
            // put "Starting Speech..." in the balloon
            //
            if (_this->GetOnOff() && _this->GetBalloonStatus())
            {
       
               _this->SetBalloonStatus(TRUE, TRUE); // force update

               // make sure balloon is shown
               _this->GetSpeechUIServer()->ShowUI(TRUE);

               // Ask the speech ui server to set the SAPI initializing 
               // flag to the balloon so it'll do it at the first callback
               //
               hr = _this->GetSpeechUIServer()->SetBalloonSAPIInitFlag(TRUE);

               WCHAR sz[128];
               sz[0] = '\0';
               CicLoadStringWrapW(g_hInst, IDS_NUI_STARTINGSPEECH, sz, ARRAYSIZE(sz));
               _this->GetSpeechUIServer()->UpdateBalloon(TF_LB_BALLOON_RECO, sz, -1);
               TraceMsg(TF_SAPI_PERF, "Show Starting speech ...");
            }

            // TABLETPC
            // BUGBUG - Do we need this now I have fixed the _HandleOpenCloseEvent to work in whichever sptip actually has focus?
            if (_this->m_fStageTip)
            {
                // Since the stage may not have focus, the delayed mechanism above will not result
                // in dictation activating in the stage since the delayed activation will happen in the
                // cicero app with focus - except that the stage is visible hence the app with focus
                // will simply ignore it. Not what we want when the stage is activating.

                // Ignore above hresult in case of failure - this is the more important call.
                hr =  _this->_HandleOpenCloseEvent();
            }
        }
        else 
        {
            hr =  _this->_HandleOpenCloseEvent();
        }


        // Office App uses its own global compartment GUID_OfficeSpeechMode to keep the current mode,
        // so that next time the application starts, it checks this value to initalize SAPI objects 
        // even if Microphone is OFF.

        // Since we have already used our own global compartment GUID_COMPARTMENT_SPEECH_GLOBALSTATE to 
        // keep the speech mode system wide, there is no need for Office to use that global compartment 
        // for its own usage that way.
        //
        // So when Microphone is OFF, we just reset the global compartment GUID_OfficeSpeechMode.
        if ( !_this->GetOnOff( ) )
        {
            SetCompartmentDWORD(_this->_tid, _this->_tim, GUID_OfficeSpeechMode, 0, TRUE);
        }
        
        // when we have a temporary composistion such as
        // CUAS level2 or AIMM level3, we don't want to
        // finalize on going composition each time mic turns off
        // because it also shutdown chance for correction
        //
        if (S_OK == hr && _this->IsFocusFullAware(_this->_tim))
        {
            hr = _this->_FinalizeComposition();
        }
        return hr;
    }
    else if (IsEqualGUID(rguid, GUID_COMPARTMENT_SPEECH_STAGE))
    {
        DWORD  dw = 0;
        GetCompartmentDWORD(_this->_tim, GUID_COMPARTMENT_SPEECH_STAGE, &dw, FALSE);
        Assert(dw && L"NULL HWND passed in GUID_COMPARTMENT_SPEECH_STAGE");
        if (dw != 0)
        {
            _this->m_hwndStage = (HWND) dw;
            _this->m_fStageTip = TRUE;
        }
    }
    // TABLETPC
    else if (IsEqualGUID(rguid, GUID_COMPARTMENT_SPEECH_STAGECHANGE))
    {
        HRESULT hr = S_OK;
        DWORD dw;

        GetCompartmentDWORD(_this->_tim, GUID_COMPARTMENT_SPEECH_STAGECHANGE, &dw, TRUE);
		_this->m_fStageVisible = dw ? TRUE:FALSE;
        if (S_OK == _this->IsActiveThread())
        {
            _this->OnSetThreadFocus();
        }
        else
        {
            _this->OnKillThreadFocus();
        }
    }
    // TABLETPC
    else if (IsEqualGUID(rguid, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT))
    {
        _this->m_fDictationEnabled = _this->GetDICTATIONSTAT_DictEnabled();

#ifdef SAPI_PERF_DEBUG
        DWORD   dw;
        GetCompartmentDWORD(_this->_tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, &dw, FALSE);
        TraceMsg(TF_SAPI_PERF, "GUID_COMPARTMENT_SPEECH_DICTATIONSTAT is set in SAPIIMX, dw=%x", dw);
#endif

        HRESULT hr;

        // TABLETPC
        hr = _this->IsActiveThread();

        if ( hr == S_OK )
        {
            BOOL    fDictOn, fCmdOn;
            BOOL    fDisable;

            fOn = _this->GetOnOff();
            fDisable = _this->Get_SPEECH_DISABLED_Disabled();

            fDictOn = fOn && _this->GetDICTATIONSTAT_DictOnOff() && _this->GetDICTATIONSTAT_DictEnabled( ) && !fDisable && !_this->Get_SPEECH_DISABLED_DictationDisabled();
            fCmdOn = fOn  && _this->GetDICTATIONSTAT_CommandingOnOff( ) && !fDisable && !_this->Get_SPEECH_DISABLED_CommandingDisabled(); 

            if ( _this->m_pCSpTask )
            {
                hr = _this->m_pCSpTask->_SetDictRecoCtxtState(fDictOn);
                if ( hr == S_OK )
                    hr = _this->m_pCSpTask->_SetCmdRecoCtxtState(fCmdOn);

                if ((fDictOn || fCmdOn ) && _this->m_pSpeechUIServer)
                {
                    WCHAR sz[128];
                    sz[0] = '\0';

                    if (fDictOn)
                    {
                        CicLoadStringWrapW(g_hInst, IDS_NUI_DICTATION_TEXT, sz, ARRAYSIZE(sz));
                    
                        hr = _this->m_pSpeechUIServer->UpdateBalloon(TF_LB_BALLOON_RECO, sz , -1);
                        TraceMsg(TF_SAPI_PERF, "Show \"Dictation\"");
                    }
                    else if ( fCmdOn )
                    {
                        CicLoadStringWrapW(g_hInst, IDS_NUI_COMMANDING_TEXT, sz, ARRAYSIZE(sz));
                    
                        hr = _this->m_pSpeechUIServer->UpdateBalloon(TF_LB_BALLOON_RECO, sz , -1);
                        TraceMsg(TF_SAPI_PERF, "Show \"Voice command\"");
                    }
                }

                if (fDictOn)
                {
                    hr = _this->HandleLearnFromDoc( );
                    if ( S_OK == hr )
                        _this->_SetCurrentIPtoSR();

                }
            }

            if (S_OK == hr)
            {
                hr = _this->EraseFeedbackUI();

                if (S_OK == hr)
                    hr = _this->_FinalizeComposition();
            }
            TraceMsg(TF_SAPI_PERF, "GUID_COMPARTMENT_SPEECH_DICTATIONSTAT exit normally");
        }
        else
            TraceMsg(TF_SAPI_PERF, "GUID_COMPARTMENT_SPEECH_DICTATIONSTAT exits when the app doesn't get focus!");

        return hr;
    }
    else  if (IsEqualGUID(rguid, GUID_COMPARTMENT_SPEECH_LEARNDOC))
    {
         _this->UpdateLearnDocState( );
         return S_OK;
    }
    else if (IsEqualGUID(rguid,GUID_COMPARTMENT_SPEECH_PROPERTY_CHANGE) )
    {
        TraceMsg(TF_GENERAL, "GUID_COMPARTMENT_SPEECH_PROPERTY_CHANGE is set!");

        // Renew all the property values from the registry.
        _this->_RenewAllPropDataFromReg(  );

        // Specially handle some of property changes.

        if ( _this->_IsPropItemChangedSinceLastRenew(PropId_Support_LMA) )
            SetCompartmentDWORD(_this->_GetId( ), _this->_tim, GUID_COMPARTMENT_SPEECH_LEARNDOC, _this->_LMASupportEnabled( ), FALSE);

        // Specially handle mode button setting changes

        BOOL   fModeButtonChanged;

        fModeButtonChanged = _this->_IsPropItemChangedSinceLastRenew(PropId_Mode_Button) ||
                             _this->_IsPropItemChangedSinceLastRenew(PropId_Dictation_Key) ||
                             _this->_IsPropItemChangedSinceLastRenew(PropId_Command_Key);
                             
        _this->HandleModeKeySettingChange( fModeButtonChanged );

        // For command category items, it will update grammars's status.
        // Update the grammar's status.

        CSpTask           *psp;
        _this->GetSpeechTask(&psp);

        if ( psp )
        {
            DWORD  dwActiveMode = ACTIVE_IN_BOTH_MODES;  // indicates which mode will change the grammar status.
            BOOL   bDictCmdChanged = _this->_IsPropItemChangedSinceLastRenew(PropId_Cmd_DictMode);

            if ( _this->_AllDictCmdsDisabled( ) )
            {
                // All the commands are disabled in dication mode.
                psp->_ActivateCmdInDictMode(FALSE);

                //Needs to activate spelling grammar in dictation mode.
                psp->_ActiveCategoryCmds(DC_CC_Spelling, TRUE, ACTIVE_IN_DICTATION_MODE);

                // Needs to activate "Force Num" grammar in dication strong mode.
                psp->_ActiveCategoryCmds(DC_CC_Num_Mode, TRUE, ACTIVE_IN_DICTATION_MODE);

                // Needs to activate language bar grammar in dictation strong mode for mode switching commands.
                psp->_ActiveCategoryCmds(DC_CC_LangBar, _this->_LanguageBarCmdEnabled( ), ACTIVE_IN_DICTATION_MODE );

                // Only need to change grammar status in command mode.
                dwActiveMode = ACTIVE_IN_COMMAND_MODE;
            }
            else
            {
                // if this was changed since latst renew.
                if ( bDictCmdChanged )
                {
                    psp->_ActiveCategoryCmds(DC_CC_SelectCorrect, _this->_SelectCorrectCmdEnabled( ), ACTIVE_IN_DICTATION_MODE);
                    psp-> _ActiveCategoryCmds(DC_CC_Navigation, _this->_NavigationCmdEnabled( ), ACTIVE_IN_DICTATION_MODE );
                    psp->_ActiveCategoryCmds(DC_CC_Casing, _this->_CasingCmdEnabled( ), ACTIVE_IN_DICTATION_MODE );
                    psp->_ActiveCategoryCmds(DC_CC_Editing, _this->_EditingCmdEnabled( ), ACTIVE_IN_DICTATION_MODE );
                    psp->_ActiveCategoryCmds(DC_CC_Keyboard, _this->_KeyboardCmdEnabled( ), ACTIVE_IN_DICTATION_MODE );
                    psp->_ActiveCategoryCmds(DC_CC_TTS, _this->_TTSCmdEnabled( ), ACTIVE_IN_DICTATION_MODE );
                    psp->_ActiveCategoryCmds(DC_CC_LangBar, _this->_LanguageBarCmdEnabled( ), ACTIVE_IN_DICTATION_MODE );
                    psp->_ActiveCategoryCmds(DC_CC_Num_Mode, TRUE, ACTIVE_IN_DICTATION_MODE);
                    psp->_ActiveCategoryCmds(DC_CC_Spelling, TRUE, ACTIVE_IN_DICTATION_MODE);

                    if ( _this->_SelectCorrectCmdEnabled( ) || _this->_NavigationCmdEnabled( ) )
                    {
                        psp->_UpdateSelectGramTextBufWhenStatusChanged( );
                    }

                    dwActiveMode = ACTIVE_IN_COMMAND_MODE;
                }
            }

            if ( _this->_IsPropItemChangedSinceLastRenew(PropId_Cmd_Select_Correct) )
                psp->_ActiveCategoryCmds(DC_CC_SelectCorrect, _this->_SelectCorrectCmdEnabled( ), dwActiveMode);

            if ( _this->_IsPropItemChangedSinceLastRenew(PropId_Cmd_Navigation) )
                psp-> _ActiveCategoryCmds(DC_CC_Navigation, _this->_NavigationCmdEnabled( ), dwActiveMode );

            if ( _this->_IsPropItemChangedSinceLastRenew(PropId_Cmd_Casing) )
                psp->_ActiveCategoryCmds(DC_CC_Casing, _this->_CasingCmdEnabled( ), dwActiveMode );

            if ( _this->_IsPropItemChangedSinceLastRenew(PropId_Cmd_Editing) )
                psp->_ActiveCategoryCmds(DC_CC_Editing, _this->_EditingCmdEnabled( ), dwActiveMode );

            if ( _this->_IsPropItemChangedSinceLastRenew(PropId_Cmd_Keyboard) )
                psp->_ActiveCategoryCmds(DC_CC_Keyboard, _this->_KeyboardCmdEnabled( ), dwActiveMode );

            if ( _this->_IsPropItemChangedSinceLastRenew(PropId_Cmd_TTS) )
                psp->_ActiveCategoryCmds(DC_CC_TTS, _this->_TTSCmdEnabled( ), dwActiveMode );

            if ( _this->_IsPropItemChangedSinceLastRenew(PropId_Cmd_Language_Bar) )
                psp->_ActiveCategoryCmds(DC_CC_LangBar, _this->_LanguageBarCmdEnabled( ), dwActiveMode );

            // Check to see if we need to fill text to selection grammar.
            if ( _this->_IsPropItemChangedSinceLastRenew(PropId_Cmd_Select_Correct)  ||
                 _this->_IsPropItemChangedSinceLastRenew(PropId_Cmd_Navigation) )
            {
                BOOL  bUpdateText;

                bUpdateText = _this->_SelectCorrectCmdEnabled( ) || _this->_NavigationCmdEnabled( );

                if ( bUpdateText )
                {
                    psp->_UpdateSelectGramTextBufWhenStatusChanged( );
                }
            }

            psp->Release( );
        }

        return S_OK;
    }
#ifdef TF_DISABLE_SPEECH
    else if (IsEqualGUID(rguid, GUID_COMPARTMENT_SPEECH_DISABLED))
    {
        BOOL fDictationDisabled = _this->Get_SPEECH_DISABLED_DictationDisabled() ? TRUE : FALSE;
        BOOL fCommandingDisabled = _this->Get_SPEECH_DISABLED_CommandingDisabled() ? TRUE : FALSE;

        if (fDictationDisabled)
            _this->SetDICTATIONSTAT_DictOnOff(FALSE);

        if (fCommandingDisabled)
            _this->SetDICTATIONSTAT_CommandingOnOff(FALSE);

        return S_OK; 
    }
#endif
    

    return S_FALSE;
}


HRESULT CSapiIMX::_HandleOpenCloseEvent(MIC_STATUS ms)
{
    HRESULT hr = S_OK;

    BOOL fOn;

    TraceMsg(TF_SAPI_PERF, "_HandleOpenCloseEvent is called, ms=%d", (int)ms);

    if (ms == MICSTAT_NA)
    {
        fOn = GetOnOff();
    }
    else
    {
        fOn = (ms == MICSTAT_ON) ? TRUE : FALSE;
    }

    if (fOn)
    {
        // if no one so far set dictation status, we assume
        // there's no C&C button so we can synchronize dictation
        // status with mic
        //
        InitializeSAPI(TRUE);

        if (m_fDictationEnabled == TRUE)
        {
            //
            // if the caller wants to set the mic status (!= NA)
            // we also want to make sure dictation status follow that
            //
            _SetCurrentIPtoSR();

            // whenever dictation is turned on, we need to sync
            // with the current modebias
            //
            CComPtr<ITfContext> cpic;
            if (GetFocusIC(&cpic))
            {
                _gaModebias = 0;
                _SyncModeBiasWithSelection(cpic);
            }
        }
    }

    if (m_pCSpTask)
    {
        m_pCSpTask->_SetInputOnOffState(fOn);
    }
        
    return hr;
}


//+---------------------------------------------------------------------------
//
// _SysLBarCallback
//
//----------------------------------------------------------------------------

HRESULT CSapiIMX::_SysLBarCallback(UINT uCode, void *pv, ITfMenu *pMenu, UINT wID)
{
    CSapiIMX *pew = (CSapiIMX *)pv;
    HRESULT hr = S_OK;

    if (uCode == IDSLB_INITMENU)
    {
        WCHAR sz[128];

        BOOL fOn = pew->GetOnOff();

        sz[0] = '\0';
        CicLoadStringWrapW(g_hInst, IDS_MIC_OPTIONS, sz, ARRAYSIZE(sz));
        LangBarInsertMenu(pMenu, IDM_MIC_OPTIONS, sz);
#ifdef TEST_SHARED_ENGINE
        LangBarInsertMenu(pMenu, IDM_MIC_SHAREDENGINE, L"Use shared engine", pew->m_fSharedReco);
        LangBarInsertMenu(pMenu, IDM_MIC_INPROCENGINE, L"Use inproc engine", !pew->m_fSharedReco);
#endif

        sz[0] = '\0';
        CicLoadStringWrapW(g_hInst, IDS_MIC_TRAINING, sz, ARRAYSIZE(sz));
        LangBarInsertMenu(pMenu, IDM_MIC_TRAINING, sz);

        sz[0] = '\0';
        CicLoadStringWrapW(g_hInst, IDS_MIC_ADDDELETE, sz, ARRAYSIZE(sz));
        LangBarInsertMenu(pMenu, IDM_MIC_ADDDELETE, sz);

        // insert sub menu for user profile stuff
        ITfMenu *pSubMenu = NULL;
        
        sz[0] = '\0';
        CicLoadStringWrapW(g_hInst, IDS_MIC_CURRENTUSER, sz, ARRAYSIZE(sz));
        hr = LangBarInsertSubMenu(pMenu, sz, &pSubMenu);
        if (S_OK == hr)
        {
            CComPtr<IEnumSpObjectTokens> cpEnum;
            CComPtr<ISpRecognizer>       cpEngine;
            ISpObjectToken *pUserProfile = NULL;
            CSpDynamicString dstrDefaultUser;
            
            // ensure SAPI is initialized
            hr = pew->InitializeSAPI(TRUE);
            if (S_OK == hr)
            {
                // get the current default user
                hr = pew->m_pCSpTask->GetSAPIInterface(IID_ISpRecognizer, (void **)&cpEngine);
            }
            if (S_OK == hr)
            {
                hr = cpEngine->GetRecoProfile(&pUserProfile);
            }
            
            if (S_OK == hr)
            {
                hr = SpGetDescription(pUserProfile, &dstrDefaultUser);
                SafeRelease(pUserProfile);
            }

            if (S_OK == hr)
            {
                hr = SpEnumTokens (SPCAT_RECOPROFILES, NULL, NULL, &cpEnum);
            }
            if (S_OK == hr)
            {
                int idUser = 0;
                while (cpEnum->Next(1, &pUserProfile, NULL) == S_OK)
                {
                    // dstr frees itself
                    CSpDynamicString dstrUser;
                    hr = SpGetDescription(pUserProfile, &dstrUser);
                    if (S_OK == hr)
                    {
                        BOOL fDefaultUser = (wcscmp(dstrUser, dstrDefaultUser) == 0);
                        Assert(idUser < IDM_MIC_USEREND);
                        LangBarInsertMenu(pSubMenu, IDM_MIC_USERSTART + idUser++, dstrUser, fDefaultUser);
                    }
                    SafeRelease(pUserProfile);
                }
            }
            pSubMenu->Release();
        }

    }
    else if (uCode == IDSLB_ONMENUSELECT)
    {
        if ( wID == IDM_MIC_ONOFF )
        {
            // toggle mic
            pew->SetOnOff(!pew->GetOnOff());
        }
        // Invoke SAPI UI stuff...
        else if (wID ==  IDM_MIC_TRAINING)
        {
            hr = pew->_HandleTrainingWiz();
        } 
        else if (wID == IDM_MIC_ADDDELETE)
        {
            // A editsession callback will handle this requirement first
            // if the edit session fails, we will just display the UI
            // without any initial words.

            hr = pew->_RequestEditSession(ESCB_HANDLE_ADDDELETE_WORD, TF_ES_READ);

            if ( FAILED(hr) )
                hr = pew->DisplayAddDeleteUI( NULL, 0 );

        }
        else if (wID == IDM_MIC_OPTIONS)
        {
            PostMessage(pew->_GetWorkerWnd(), WM_PRIV_OPTIONS, 0, 0);
        }
        else if (wID >= IDM_MIC_USERSTART && wID < IDM_MIC_USEREND)
        {
            CComPtr<IEnumSpObjectTokens> cpEnum;
            CComPtr<ISpObjectToken>      cpProfile;
            // change the current user
            // 
            // this is still a hack, until we get an OnEndMenu event for LangBarItemSink
            // for now I just assume SAPI enumerates profiles in same order always
            //
            // what we should really do is to set up an arry to associate IDs with
            // user profiles and clean them up when OnEndMenu comes to us
            //

            if (S_OK == hr)
            {
                hr = SpEnumTokens (SPCAT_RECOPROFILES, NULL, NULL, &cpEnum);
            }
            
            if (S_OK == hr)
            {
                ULONG ulidUser = wID - IDM_MIC_USERSTART;
                ULONG ulFetched;

                CPtrArray<ISpObjectToken> rgpProfile;
                rgpProfile.Append(ulidUser+1);

                // trasform 0 base index to num of profile
                 hr = cpEnum->Next(ulidUser+1, rgpProfile.GetPtr(0), &ulFetched);
                 if (S_OK == hr && ulFetched == ulidUser+1)
                 {
                     // get the profile which is selected
                     cpProfile = rgpProfile.Get(ulidUser);
                     
                     // clean up
                     for(ULONG i = 0; i <= ulidUser ; i++)
                     {
                         rgpProfile.Get(i)->Release();
                     }
                 }
            }

            if (S_OK == hr && cpProfile)
            {
                hr = SpSetDefaultTokenForCategoryId(SPCAT_RECOPROFILES, cpProfile);

                if ( S_OK == hr )
                {
                    CComPtr<ISpRecognizer>     cpEngine;
                    hr = pew->m_pCSpTask->GetSAPIInterface(IID_ISpRecognizer, (void **)&cpEngine);
                    if (S_OK == hr)
                    {
                        SPRECOSTATE State;

                        if (S_OK == cpEngine->GetRecoState(&State))
                        {
                            cpEngine->SetRecoState(SPRST_INACTIVE);
                            hr = cpEngine->SetRecoProfile(cpProfile);
                            cpEngine->SetRecoState(State);
                        }
                    }
                }
            }
        }
#ifdef TEST_SHARED_ENGINE
        else if (wID == IDM_MIC_SHAREDENGINE || wID ==  IDM_MIC_INPROCENGINE)
        {
            pew->m_fSharedReco = wID == IDM_MIC_SHAREDENGINE ? TRUE : FALSE;
            pew->_ReinitializeSAPI();
        }
#endif
    }
    return hr;
}

void CSapiIMX::_ReinitializeSAPI(void)
{
   TraceMsg(TF_SAPI_PERF, "_ReinitializeSAPI is called");

   DeinitializeSAPI();
   InitializeSAPI(TRUE);
}

//+---------------------------------------------------------------------------
//
// OnCompositionTerminated
//
// Cicero calls this method when one of our compositions is terminated.
//----------------------------------------------------------------------------

STDAPI CSapiIMX::OnCompositionTerminated(TfEditCookie ec, ITfComposition *pComposition)
{
    ITfRange *pRange = NULL;
    ITfContext *pic = NULL;
    ITfContext *picTest;
    CICPriv *picp;
    HRESULT hr;

    TraceMsg(TF_GENERAL, "OnCompositionTerminated is Called");

    hr = E_FAIL;

    if (pComposition->GetRange(&pRange) != S_OK)
        goto Exit;
    if (pRange->GetContext(&pic) != S_OK)
        goto Exit;

    if (_fDeactivated)
    {
        // CleanupConsider: benwest: I don't think this can happen anymore...
        hr = MakeResultString(ec, pic, pRange, TF_CLIENTID_NULL, NULL);
    }
    else
    {
        // Close candidate ui if it is up.
        CloseCandUI( );

        // take note we're done composing
        if (picp = GetInputContextPriv(_tid, pic))
        {
            picp->_ReleaseComposition();
            picp->Release();
        }
        if (!m_fStartingComposition)
        {
            hr = MakeResultString(ec, pic, pRange, _tid, m_pCSpTask);
        }
        else
        {
            // just avoid terminating recognition when we are just about
            // to start composition.
            hr = S_OK; 
        }
    }

    // free up m_cpRangeCurIP if it belongs to this context
    if (m_cpRangeCurIP != NULL &&
        m_cpRangeCurIP->GetContext(&picTest) == S_OK)
    {
        if (pic == picTest)
        {
            m_cpRangeCurIP.Release();
        }
        picTest->Release();
    }

    // unadvise mouse sink
    if (m_pMouseSink)
    {
        m_pMouseSink->_Unadvise();
        SafeReleaseClear(m_pMouseSink);
    }

Exit:
    SafeRelease(pRange);
    SafeRelease(pic);

    return hr;
}

//+---------------------------------------------------------------------------
//
// _FindComposition
//
//----------------------------------------------------------------------------

/* static */
BOOL CSapiIMX::_FindComposition(TfEditCookie ec, ITfContextComposition *picc, ITfRange *pRange, ITfCompositionView **ppCompositionView)
{
    ITfCompositionView *pCompositionView;
    IEnumITfCompositionView *pEnum;
    ITfRange *pRangeView = NULL;
    BOOL fFoundComposition;
    LONG l;
    CLSID clsid;
    HRESULT hr;

    if (picc->FindComposition(ec, pRange, &pEnum) != S_OK)
    {
        Assert(0);
        return FALSE;
    }

    fFoundComposition = FALSE;

    while (!fFoundComposition && pEnum->Next(1, &pCompositionView, NULL) == S_OK)
    {
        hr = pCompositionView->GetOwnerClsid(&clsid);
        Assert(hr == S_OK);

        // make sure we ignore other TIPs' compositions!
        if (!IsEqualCLSID(clsid, CLSID_SapiLayr))
            goto NextRange;

        hr = pCompositionView->GetRange(&pRangeView);
        Assert(hr == S_OK);

        if (pRange->CompareStart(ec, pRangeView, TF_ANCHOR_START, &l) == S_OK &&
            l >= 0 &&
            pRange->CompareEnd(ec, pRangeView, TF_ANCHOR_END, &l) == S_OK &&
            l <= 0)
        {
            // our test range is within this composition range
            fFoundComposition = TRUE;
        }

NextRange:
        SafeRelease(pRangeView);
        if (fFoundComposition && ppCompositionView != NULL)
        {
            *ppCompositionView = pCompositionView;
        }
        else
        {
            pCompositionView->Release();
        }
    }

    pEnum->Release();

    return fFoundComposition;
}

//+---------------------------------------------------------------------------
//
// _CheckStartComposition
//
//----------------------------------------------------------------------------

void CSapiIMX::_CheckStartComposition(TfEditCookie ec, ITfRange *pRange)
{
    ITfContext *pic;
    ITfContextComposition *picc;
    ITfComposition *pComposition;
    CICPriv *picp;
    HRESULT hr;

    if (pRange->GetContext(&pic) != S_OK)
        return;

    hr = pic->QueryInterface(IID_ITfContextComposition, (void **)&picc);
    Assert(hr == S_OK);

    // is pRange already included in a composition range?
    if (_FindComposition(ec, picc, pRange, NULL))
        goto Exit; // there's already a composition, we're golden

    // need to create a new composition, or at least try

    m_fStartingComposition = TRUE;
    if (picc->StartComposition(ec, pRange, this, &pComposition) == S_OK)
    {
        if (pComposition != NULL) // NULL if the app rejects the composition
        {
            // take note we're composing
            if (picp = GetInputContextPriv(_tid, pic))
            {
                picp->_AddRefComposition();
                picp->Release();
            }
            // create mouse sink here for unfinalized composition buffer
            if (!IsFocusFullAware(_tim) && !m_pMouseSink)
            {
                m_pMouseSink = new CMouseSink(_MouseSinkCallback, this);
                if (m_pMouseSink)
                {
                    CComPtr<ITfRange> cpRange;
                    hr = pComposition->GetRange(&cpRange);
                    if (S_OK == hr)
                    {
                        hr = m_pMouseSink->_Advise(cpRange, pic);
                    }
                    // mouse not pressed, no selection first
                    m_fMouseDown = FALSE;
                    m_ichMouseSel = 0;
                }
            }

            // we already set up the sink, so we'll use ITfContextComposition::FindComposition
            // to get this guy back when we want to terminate it
            // Cicero will hold a ref to the object until someone terminates it
            pComposition->Release();
        }
    }

    m_fStartingComposition = FALSE;

Exit:
    pic->Release();
    picc->Release();       
}


//+---------------------------------------------------------------------------
//
// IsInterestedInContext
//
//----------------------------------------------------------------------------

HRESULT CSapiIMX::IsInterestedInContext(ITfContext *pic, BOOL *pfInterested)
{
    CICPriv *picp;

    *pfInterested = FALSE;

    if (picp = GetInputContextPriv(_tid, pic))
    {
        // we only need access to ic's with active compositions
        *pfInterested = (picp->_GetCompositionCount() > 0);
        picp->Release();
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CleanupContext
//
// This method is a callback for the library helper CleanupAllContexts.
// We have to be very careful here because we may be called _after_ this tip
// has been deactivated, if the app couldn't grant a lock right away.
//----------------------------------------------------------------------------

HRESULT CSapiIMX::CleanupContext(TfEditCookie ecWrite, ITfContext *pic)
{
    // all sptip cares about is finalizing compositions
    CleanupAllCompositions(ecWrite, pic, CLSID_SapiLayr, _CleanupCompositionsCallback, this);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _CleanupCompositionsCallback
//
//----------------------------------------------------------------------------

/* static */
void CSapiIMX::_CleanupCompositionsCallback(TfEditCookie ecWrite, ITfRange *rangeComposition, void *pvPrivate)
{
    ITfContext *pic;
    CICPriv *picp;
    CSapiIMX *_this = (CSapiIMX *)pvPrivate;

    if (rangeComposition->GetContext(&pic) != S_OK)
        return;

    if (_this->_fDeactivated)
    {
        // this is a cleanup callback.  _tid, m_pCSpTask should already have been cleaned up
        _this->MakeResultString(ecWrite, pic, rangeComposition, TF_CLIENTID_NULL, NULL);
    }
    else
    {
        // during a profile switch we will still be active and need to clear the composition count on this ic
        if (picp = GetInputContextPriv(_this->_tid, pic))
        {
            // clear the composition count for this ic
            picp->_ReleaseComposition();
            picp->Release();
        }

        _this->MakeResultString(ecWrite, pic, rangeComposition, _this->_tid, _this->m_pCSpTask);
    }

    pic->Release();
}

//+---------------------------------------------------------------------------
//
//  _IsDoubleClick
//
//  returns TRUE only if the last position is same and lbutton down happens
//  within the time defined for double click
//
//----------------------------------------------------------------------------
BOOL CSapiIMX::_IsDoubleClick(ULONG uEdge, ULONG uQuadrant, DWORD dwBtnStatus)
{
    if (dwBtnStatus & MK_LBUTTON)
    {
        LONG   lTime=GetMessageTime();
        if (!m_fMouseDown && m_uLastEdge == uEdge && m_uLastQuadrant == uQuadrant)
        {
            if (lTime > m_lTimeLastClk && lTime < m_lTimeLastClk + 500) // use 500 ms for now
            {
                return TRUE;
            }
        }
        m_uLastEdge = uEdge;
        m_uLastQuadrant = uQuadrant;
        m_lTimeLastClk = lTime;
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//    _MouseSinkCallback
//
//    synopsis: set the current IP on the composition range based on
//              uEdge parameter. We don't probably care too much about
//              eQuadrant for speech composition
//
//----------------------------------------------------------------------------
  
/* static */
HRESULT CSapiIMX::_MouseSinkCallback(ULONG uEdge, ULONG uQuadrant, DWORD dwBtnStatus, BOOL *pfEaten, void *pv)
{
    CSapiIMX *_this = (CSapiIMX *)pv;

    Assert(pv);

    BOOL fDoubleClick = _this->_IsDoubleClick(uEdge, uQuadrant, dwBtnStatus);

    ESDATA  esData = {0};

    esData.lData1 = (LONG_PTR)uEdge;
    esData.lData2 = (LONG_PTR)dwBtnStatus;
    esData.fBool  = fDoubleClick;

    if (pfEaten)
        *pfEaten = TRUE;
    
    return _this->_RequestEditSession(ESCB_HANDLE_MOUSESINK, TF_ES_READWRITE, &esData);
}

HRESULT CSapiIMX::_HandleMouseSink(TfEditCookie ec, ULONG uEdge, ULONG uBtnStatus, BOOL fDblClick)
{
    CComPtr<ITfDocumentMgr> cpDim;
    CComPtr<ITfContext>     cpic;
    CComPtr<ITfContextComposition> cpicc;
    CComPtr<IEnumITfCompositionView> cpEnumComp;
    CComPtr<ITfCompositionView> cpCompositionView;
    CComPtr<ITfRange>           cpRangeComp;
    CComPtr<ITfRange>           cpRangeSel;

    // if the btn up comes, the next time we'll destroy the selection
    // nothing we need to do in this turn
    BOOL fLeftBtn = (uBtnStatus & MK_LBUTTON) > 0 ? TRUE : FALSE;

    if (!fLeftBtn)
    {
        m_ichMouseSel = 0;
        m_fMouseDown = FALSE;
        return S_OK;
    }

    // Close candidate ui if it is up.
    CloseCandUI( );


    HRESULT hr = GetFocusDIM(&cpDim);

    if(S_OK == hr)
    {
        hr= cpDim->GetBase(&cpic);
    }

    if (S_OK == hr)
    {
        hr = cpic->QueryInterface(IID_ITfContextComposition, (void **)&cpicc);
    }


    if (S_OK == hr)
    {
        hr = cpicc->EnumCompositions(&cpEnumComp);
    }

    if (S_OK == hr)
    {
        while ((hr = cpEnumComp->Next(1, &cpCompositionView, NULL)) == S_OK)
        {
            hr = cpCompositionView->GetRange(&cpRangeComp);
            if (S_OK == hr)
                break;

            // prepare for the next turn
            cpCompositionView.Release();
        }
    }
    
    if (S_OK == hr)
    {
        if (fDblClick)
        {
           WCHAR wsz[256] = {0}; // the buffer is 256 chars max
           ULONG  cch = 0;

           CComPtr<ITfRange> cpRangeWord;

           // obtain the text within the entire composition
           hr = cpRangeComp->Clone(&cpRangeWord);
           if (S_OK == hr)
           {
               hr = cpRangeWord->GetText(ec, 0, wsz, 255, &cch);
           }

           // get the left side edge char position, looking at delimiters
           if (S_OK == hr)
           {
               WCHAR *psz = &wsz[uEdge];
 
               while (psz > wsz)
               {
                   if (!iswalpha(*psz))
                   {
                       psz++;
                       break;
                   }
                   psz--;
               }
               // re-posisition ich
               m_ichMouseSel = psz - wsz;

               // get the right side word boundary, also based on delimiters 
               psz = &wsz[uEdge];

               while( psz < &wsz[cch] )
               {
                   if (!iswalpha(*psz))
                   {
                       break;
                   }

                   psz++;
               }
               // reposition uEdge
               uEdge = psz - wsz;
           }
           
           // pretend lbutton was previously down to get the same effect of
           // dragging selection
           //
           m_fMouseDown = TRUE;
           
        }
    }

    if (S_OK == hr)
    {
        hr = cpRangeComp->Clone(&cpRangeSel);
    }

    if (S_OK == hr)
    {
        if(m_fMouseDown)
        {
            // if the mouse is down the last time and still down this time
            // it means it was dragged like this _v_>>>>_v_ or _v_<<<<_v_
            // we'll have to make a selection accordingly
        
            // 1) place the IP to the previous position
            long cch;
            hr = cpRangeSel->ShiftStart(ec,  m_ichMouseSel, &cch, NULL);
            if (S_OK == hr)
            {
            // 2) prepare for extension
         
                hr = cpRangeSel->Collapse( ec, TF_ANCHOR_START);
            }
        }
    }

    if (S_OK == hr)
    {
        long ich = (long) (uEdge);
        long cch;
        

        // 3) see if there's a prev selection and if there is,
        // calculate the dir and width of selection
        // note that we've already had ich set to the pos at above 1) & 2)

        long iich = 0;
        if (m_fMouseDown)
        {
            iich = ich - m_ichMouseSel;
        }

        if (iich > 0) // sel towards the end
        {
            hr = cpRangeSel->ShiftEnd(ec, iich, &cch, NULL);
        }
        else if (iich < 0) // sel towards the start
        {
            hr = cpRangeSel->ShiftStart(ec, iich, &cch, NULL);
        }
        else // no width sel == an IP
        {
            hr = cpRangeSel->ShiftStart(ec, ich, &cch, NULL);

            if (S_OK == hr) // collapse it only when there's no selection
            {
                hr = cpRangeSel->Collapse( ec, TF_ANCHOR_START);
            }
        }

        // preserve the ip position so we can make a selection later
        // a tricky thing is you have to remember the pos where you
        // have started to "drag" not the pos you just updated
        // so we need this only for the first time we started selection

        if (!m_fMouseDown)
            m_ichMouseSel = ich;
    }


    if (S_OK == hr)
    {
        BOOL fSetSelection = TRUE;
        CComPtr<ITfRange> cpRangeCur;
        HRESULT tmpHr = S_OK;
        
        tmpHr = GetSelectionSimple(ec, cpic, &cpRangeCur);
        if (SUCCEEDED(tmpHr) && cpRangeCur)
        {
            LONG l = 0;
            if (cpRangeCur->CompareStart(ec, cpRangeSel, TF_ANCHOR_START, &l) == S_OK && l == 0 &&
                cpRangeCur->CompareEnd(ec, cpRangeSel, TF_ANCHOR_END, &l) == S_OK && l == 0)
            {
                fSetSelection = FALSE;
            }
        }

        if (fSetSelection)
        {
            CComPtr<ITfProperty> cpProp;

            hr = cpic->GetProperty(GUID_PROP_ATTRIBUTE, &cpProp);

            if (S_OK == hr)
            {
                SetGUIDPropertyData(&_libTLS, ec, cpProp, cpRangeCur, GUID_NULL);
                SetGUIDPropertyData(&_libTLS, ec, cpProp, cpRangeSel, GUID_ATTR_SAPI_SELECTION);
            }

            hr = SetSelectionSimple(ec, cpic, cpRangeSel);
        }
    }

    m_fMouseDown = fLeftBtn;
  
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\spbtnctrl.cpp ===
// SpBtnCtrl.cpp : Implement SpButtonControl which is to control the speech mode and status.
//
#include "private.h"
#include "SpBtnCtrl.h"

/////////////////////////////////////////////////////////////////////////////
//
HRESULT SpButtonControl::SetDictationButton(BOOL fButtonDown, UINT uTimePressed)
{
    return _SetButtonDown(DICTATION_BUTTON, fButtonDown, uTimePressed);
}

HRESULT SpButtonControl::SetCommandingButton(BOOL fButtonDown, UINT uTimePressed)
{
    return _SetButtonDown(COMMANDING_BUTTON, fButtonDown, uTimePressed);
}

HRESULT SpButtonControl::_SetButtonDown(DWORD dwButton, BOOL fButtonDown, UINT uTimePressed)
{
    BOOL fDictationOn = FALSE;
    BOOL fCommandingOn = FALSE;
    BOOL fMicrophoneOn = FALSE;

    DWORD dwMyState		= dwButton ? TF_COMMANDING_ON : TF_DICTATION_ON;
    DWORD dwOtherState	= dwButton ? TF_DICTATION_ON : TF_COMMANDING_ON;

    if (uTimePressed == 0)
        uTimePressed = GetTickCount();

    if (m_ulButtonDownTime[1 - dwButton])
    {
        // Other button pressed but not released.
        // In this scenario we ignore the second press since there is no perfect answer to what we could do instead.
        return S_OK;
    }

    fMicrophoneOn = GetMicrophoneOn( );
    fDictationOn  = GetDictationOn( );
    fCommandingOn = GetCommandingOn( );

    BOOL fMyStateOn     = dwButton ? fCommandingOn : fDictationOn;
    BOOL fOtherStateOn  = dwButton ? fDictationOn : fCommandingOn;

    TraceMsg(TF_SPBUTTON, "uTimePressed=%d MicrophoneOnOff=%d", uTimePressed, fMicrophoneOn);
    TraceMsg(TF_SPBUTTON, "fDictationOn=%d,fCommandingOn=%d", fDictationOn,fCommandingOn);
    TraceMsg(TF_SPBUTTON, "fMyStateOn=%d, OtherStateOn=%d", fMyStateOn, fOtherStateOn);

    if (fButtonDown)
    {
        // Button has been pressed.
        if ( m_ulButtonDownTime[dwButton] )
        {
            TraceMsg(TF_SPBUTTON, "Double down event on speech button");
            return S_OK;
        }

        // Now we store the time to detect a press-and-hold.
        m_ulButtonDownTime[dwButton] = uTimePressed;

        if (fMicrophoneOn)
        {
            // Microphone is ON
            if (fCommandingOn && fDictationOn)
            {
                // Both dictation and commanding are on.
                // Switch microphone off, disable other state.
                m_fMicrophoneOnAtDown[dwButton] = TRUE;
                SetState(dwMyState);
            }
            if (fOtherStateOn)
            {
                // Leave microphone on, switch state.
                // Need to store other state to reset if it's a press-and-hold.
                m_fPreviouslyOtherStateOn[dwButton] = TRUE;
                SetState(dwMyState);
            }
            else if (fMyStateOn)
            {
                // Switch microphone off.
                m_fMicrophoneOnAtDown[dwButton] = TRUE;
            }
            else
            {
                // Microphone on but no state defined.
                // Switch microphone off, enable dictation.
                m_fMicrophoneOnAtDown[dwButton] = TRUE;
                SetState(dwMyState);
            }
        }
        else
        {
            // Microphone is OFF
            if (fCommandingOn && fDictationOn)
            {
                // Both dictation and commanding are on.
                // Switch microphone on, disable my state.
                SetState(dwMyState);
                SetMicrophoneOn(TRUE);
            }
            if (fOtherStateOn)
            {
                // Switch microphone on, switch state.
                SetState(dwMyState);
                SetMicrophoneOn(TRUE);
            }
            else if (fMyStateOn)
            {
                // Switch microphone on.
                SetMicrophoneOn(TRUE);
            }
            else
            {
                // Microphone off and no state defined.
                // Switch microphone on, enable my state.
                SetState(dwMyState);
                SetMicrophoneOn(TRUE);
            }
        }
    }
    else
    {
        // Button released.
#ifdef DEBUG
        if ( m_ulButtonDownTime[dwButton] == 0 )
		    TraceMsg(TF_SPBUTTON, "Speech button released without being pressed.");

		// Since the button has previously been pressed, the other state should not be enabled.
        if ( fOtherStateOn )
		    TraceMsg(TF_SPBUTTON, "Other speech state incorrectly enabled on button release.");
#endif

        // Will wrap after 49.7 days of continuous use.
        DWORD dwTimeElapsed = uTimePressed - m_ulButtonDownTime[dwButton];
        m_ulButtonDownTime[dwButton] = 0;

        // Is this a quick press or a press-and-hold action?
        if (dwTimeElapsed < PRESS_AND_HOLD)
        {
            // This is a quick release.
            if (m_fMicrophoneOnAtDown[dwButton])
            {
                // Microphone was on at button down. Need to switch microphone off.
                SetMicrophoneOn(FALSE);
            }

            m_fPreviouslyOtherStateOn[dwButton] = FALSE;
            m_fMicrophoneOnAtDown[dwButton] = FALSE;
        }
        else
        {
            // This is a press-and-hold.
            // We must either stop the microphone or return to other state.

            TraceMsg(TF_SPBUTTON, "press-and-hold button!");

            if (m_fPreviouslyOtherStateOn[dwButton])
            {
                // Other state was previously on. Leave microphone on, switch state.
                TraceMsg(TF_SPBUTTON, "Other state was previously on, leave Microphone On, switch state");

                SetState(dwOtherState);
                m_fPreviouslyOtherStateOn[dwButton] = FALSE;
            }
            else
            {
                // Other state was not previously on. Switch microphone off.
                TraceMsg(TF_SPBUTTON, "Other state was not previous on, switch microphone off");

                SetMicrophoneOn(FALSE);
                m_fMicrophoneOnAtDown[dwButton] = FALSE;
            }
        }
    }

    return S_OK;
}

BOOL SpButtonControl::GetDictationOn( )
{
    DWORD   dwGLobal;
    GetCompartmentDWORD(m_pimx->_tim, GUID_COMPARTMENT_SPEECH_GLOBALSTATE, &dwGLobal, TRUE);

    return (dwGLobal & TF_DICTATION_ON ) ? TRUE : FALSE;
}

BOOL SpButtonControl::GetCommandingOn( )
{
    DWORD   dwGLobal;
    GetCompartmentDWORD(m_pimx->_tim, GUID_COMPARTMENT_SPEECH_GLOBALSTATE, &dwGLobal, TRUE);

    return (dwGLobal & TF_COMMANDING_ON ) ? TRUE : FALSE;
}

HRESULT SpButtonControl::SetCommandingOn(void)
{
    HRESULT  hr;

    DWORD dw = TF_COMMANDING_ON;
    hr = SetCompartmentDWORD(m_pimx->_GetId( ), m_pimx->_tim, GUID_COMPARTMENT_SPEECH_GLOBALSTATE, dw, TRUE);
    return hr;
}

HRESULT SpButtonControl::SetDictationOn(void)
{
    HRESULT  hr;

    DWORD dw = TF_DICTATION_ON;
    hr = SetCompartmentDWORD(m_pimx->_GetId( ), m_pimx->_tim, GUID_COMPARTMENT_SPEECH_GLOBALSTATE, dw, TRUE);
    return hr;
}

HRESULT SpButtonControl::SetState(DWORD dwState)
{
    HRESULT hr = S_OK;
	
    if (dwState == TF_DICTATION_ON)
    {
        hr = SetDictationOn();
    }
    else if (dwState == TF_COMMANDING_ON)
    {
        hr = SetCommandingOn();
    }
    else
    {
        TraceMsg(TF_SPBUTTON, "Unknown speech state requested.");
        Assert(0);
        hr = E_INVALIDARG;
    }

    return hr;
}

BOOL SpButtonControl::GetMicrophoneOn( )
{
    Assert(m_pimx);
    return m_pimx->GetOnOff( );
}

void SpButtonControl::SetMicrophoneOn(BOOL fOn)
{
    Assert(m_pimx);
    m_pimx->SetOnOff(fOn, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\spbtnctrl.h ===
//
// SpBtnCtrl.h
//

#ifndef SPBTNCTRL_H
#define SPBTNCTRL_H

#include "private.h"
#include "globals.h"
#include "sapilayr.h"

#define PRESS_AND_HOLD      600
#define DICTATION_BUTTON    0
#define COMMANDING_BUTTON   1

// class CSapiIMX;

/////////////////////////////////////////////////////////////////////////////
// SpButtonControl

class SpButtonControl 
{
public:
	SpButtonControl(CSapiIMX *pImx) 
	{
        m_pimx = pImx;
		m_fPreviouslyOtherStateOn[0] = FALSE;
		m_fPreviouslyOtherStateOn[1] = FALSE;
		m_fMicrophoneOnAtDown[0] = FALSE;
		m_fMicrophoneOnAtDown[1] = FALSE;
		m_ulButtonDownTime[0] = 0;
		m_ulButtonDownTime[1] = 0;
	}

    ~SpButtonControl() 
    {
    }

public:
	HRESULT SetCommandingButton(BOOL fButtonDown, UINT uTimePressed);
	HRESULT SetDictationButton(BOOL fButtonDown, UINT uTimePressed);

private:
	HRESULT _SetButtonDown(DWORD dwButton, BOOL fButtonDown, UINT uTimePressed);
	BOOL    GetCommandingOn( );
	BOOL    GetDictationOn( );
	HRESULT SetCommandingOn(void);
	HRESULT SetDictationOn(void);
	HRESULT SetState(DWORD dwState);
	BOOL    GetMicrophoneOn( );
	void    SetMicrophoneOn(BOOL fOn);

    CSapiIMX                   *m_pimx;

	BOOL m_fPreviouslyOtherStateOn[2];
	BOOL m_fMicrophoneOnAtDown[2];
	ULONG m_ulButtonDownTime[2];
};

#endif // SPBTNCTRL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\sptask.cpp ===
//
// sptask.cpp
// 
// implements a notification callback ISpTask
//
// created: 4/30/99
//
//

#include "private.h"
#include "globals.h"
#include "sapilayr.h"
#include "propstor.h"
#include "dictctxt.h"
#include "nui.h"
#include "mui.h"
#include "shlguid.h"
#include "spgrmr.h"


//
//
// CSpTask class impl
//
//
STDMETHODIMP CSpTask::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) 
  /*  ||  IsEqualIID(riid, IID_ISpNotifyCallback) */
    )
    {
        *ppvObj = SAFECAST(this, CSpTask *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSpTask::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CSpTask::Release(void)
{
    long cr;

    cr = --m_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//
// ctor
//
//
CSpTask::CSpTask(CSapiIMX *pime)
{
    //  CSpTask is initialized with an TFX instance
    //  so store the pointer to the TFX   

    TraceMsg(TF_SAPI_PERF, "CSpTask is generated");

    m_pime = pime;
    
    // addref so it doesn't go away during session
    m_pime->AddRef();
    
    // init data members here
    m_cpResMgr = NULL;
    m_cpRecoCtxt = NULL;
    m_cpRecoCtxtForCmd = NULL;
    m_cpRecoEngine = NULL;
    m_cpVoice = NULL;
    m_bInSound = NULL;
    m_bGotReco = NULL; 

    m_fSapiInitialized  = FALSE;
    m_fDictationReady   = FALSE;
    
    m_fInputState = FALSE;
    m_pLangBarSink   = NULL;

    // M2 SAPI workaround
    m_fIn_Activate = FALSE;
    m_fIn_SetModeBias = FALSE;
    m_fIn_GetAlternates = FALSE;
    m_fIn_SetInputOnOffState = FALSE;

    m_fSelectStatus = FALSE;  // By default, current selection is empty.
    m_fDictationDeactivated =  FALSE;
    m_fSpellingModeEnabled  =  FALSE;
    m_fCallbackInitialized = FALSE;

    m_fSelectionEnabled = FALSE;
    m_fDictationInitialized = FALSE;

    m_fDictCtxtEnabled = FALSE;
    m_fCmdCtxtEnabled = FALSE;

    m_fTestedForOldMicrosoftEngine = FALSE;
    m_fOldMicrosoftEngine = FALSE;

#ifdef RECOSLEEP
    m_pSleepClass = NULL;
#endif

    m_cRef = 1;
}

CSpTask::~CSpTask()
{
    TraceMsg(TF_SAPI_PERF, "CSpTask is destroyed");
    
    if (m_pdc)
        delete m_pdc;

    if (m_pITNFunc)
        delete m_pITNFunc;

    m_pime->Release();
}
//
// CSpTask::_InitializeSAPIObjects
//
// initialize SAPI objects for SR
// later we'll get other objects initialized here
// (TTS, audio etc)
//
HRESULT CSpTask::InitializeSAPIObjects(LANGID langid)
{

    TraceMsg(TF_SAPI_PERF, "CSpTask::InitializeSAPIObjects is called");

    if (m_fSapiInitialized == TRUE)
    {
        TraceMsg(TF_SAPI_PERF, "CSpTask::InitializeSAPIObjects is intialized already\n");
        return S_OK;
    }


    // m_xxx are CComPtrs from ATL
    //
    HRESULT hr = m_cpResMgr.CoCreateInstance( CLSID_SpResourceManager );

    TraceMsg(TF_SAPI_PERF, "CLSID_SpResourceManager is created, hr=%x", hr);


    if (!m_pime->IsSharedReco())
    {
        // create a recognition engine

        TraceMsg(TF_SAPI_PERF,"Inproc engine is generated");
        if( SUCCEEDED( hr ) )
        {
    
            hr = m_cpRecoEngine.CoCreateInstance( CLSID_SpInprocRecognizer );
        }
    
        if (SUCCEEDED(hr))
        {
            CComPtr<ISpObjectToken> cpAudioToken;
            SpGetDefaultTokenFromCategoryId(SPCAT_AUDIOIN, &cpAudioToken);
            if (SUCCEEDED(hr))
            {
                m_cpRecoEngine->SetInput(cpAudioToken, TRUE);
            }
        }
    }
    else
    {
        hr = m_cpRecoEngine.CoCreateInstance( CLSID_SpSharedRecognizer );
        TraceMsg(TF_SAPI_PERF, "Shared Engine is generated! hr=%x", hr);
    }

    // create the recognition context
    if( SUCCEEDED( hr ) )
    {
        hr = m_cpRecoEngine->CreateRecoContext( &m_cpRecoCtxt );

        TraceMsg(TF_SAPI_PERF, "RecoContext is generated, hr=%x", hr);
    }
    
    GUID guidFormatId = GUID_NULL;
    WAVEFORMATEX *pWaveFormatEx = NULL;
    if (SUCCEEDED(hr))
    {
        hr = SpConvertStreamFormatEnum(SPSF_8kHz8BitMono, &guidFormatId, &pWaveFormatEx);

        TraceMsg(TF_SAPI_PERF, "SpConvertStreamFormatEnum is done, hr=%x", hr);
    }

    if (SUCCEEDED(hr))
    {
        hr = m_cpRecoCtxt->SetAudioOptions(SPAO_RETAIN_AUDIO, &guidFormatId, pWaveFormatEx);

        TraceMsg(TF_SAPI_PERF, "RecoContext SetAudioOptions, RETAIN AUDIO, hr=%x", hr);

        if (pWaveFormatEx)
            ::CoTaskMemFree(pWaveFormatEx);
    }

    if( SUCCEEDED( hr ) )
    {
        hr = m_cpVoice.CoCreateInstance( CLSID_SpVoice );

        TraceMsg(TF_SAPI_PERF, "SpVoice is generated, hr=%x", hr);
    }

    if ( SUCCEEDED(hr) )
    {
        // this has to be extended so that
        // we choose default voice as far as lang matches
        // and pick the best match if not
        // 
        // hr = _SetVoice(langid);
    }

    //
    if ( SUCCEEDED(hr) )
    {
        m_langid = _GetPreferredEngineLanguage(langid);

        TraceMsg(TF_SAPI_PERF, "_GetPreferredEngineLanguage is Done, m_langid=%x", m_langid);
    }

#ifdef RECOSLEEP
    InitSleepClass( );
#endif
    
    if (SUCCEEDED(hr))
        m_fSapiInitialized = TRUE;

    TraceMsg(TF_SAPI_PERF, "InitializeSAPIObjects  is Done!!!!!, hr=%x\n", hr);

    return hr;
}


//
// CSpTask::_InitializeSAPIForCmd
//
// initialize SAPI RecoContext for Voice Command mode
//
// this function should be called after _InitializeSAPIObject.
//
HRESULT CSpTask::InitializeSAPIForCmd( )
{

    TraceMsg(TF_SAPI_PERF, "InitializeSAPIForCmd is called");
    HRESULT hr = S_OK;

    if (!m_cpRecoCtxtForCmd && m_cpRecoEngine && m_langid)
    {
        hr = m_cpRecoEngine->CreateRecoContext( &m_cpRecoCtxtForCmd );
        TraceMsg(TF_SAPI_PERF, "m_cpRecoCtxtForCmd is generated, hr=%x", hr);
    
        // Set the RecoContextState as DISABLE by default to improve SAPI Perf.
        //
        // After initializing, caller must set the context state explicitly.

        if ( SUCCEEDED(hr) )
        {
            hr = m_cpRecoCtxtForCmd->SetContextState(SPCS_DISABLED);
            m_fCmdCtxtEnabled = FALSE;
        }

        TraceMsg(TF_SAPI_PERF, "Initialize Callback for RecoCtxtForCmd");

        // set recognition notification
        CComPtr<ISpNotifyTranslator> cpNotify;

        if ( SUCCEEDED(hr) )
            hr = cpNotify.CoCreateInstance(CLSID_SpNotifyTranslator);

        TraceMsg(TF_SAPI_PERF, "SpNotifyTranslator for RecoCtxtForCmd is generated, hr=%x", hr);

        // set this class instance to notify control object
        if (SUCCEEDED(hr))
        {
            m_pime->_EnsureWorkerWnd();

            hr = cpNotify->InitCallback( NotifyCallbackForCmd, 0, (LPARAM)this );
        }
        if (SUCCEEDED(hr))
        {
            hr = m_cpRecoCtxtForCmd->SetNotifySink(cpNotify);
            TraceMsg(TF_SAPI_PERF, "SetNotifySink for RecoCtxtForCmd is Done, hr=%x", hr);
        }

        // set the events we're interested in
        if( SUCCEEDED( hr ) )
        {
            const ULONGLONG ulInterest = SPFEI(SPEI_RECOGNITION) |
                                         SPFEI(SPEI_FALSE_RECOGNITION) |
                                         SPFEI(SPEI_RECO_OTHER_CONTEXT);

            hr = m_cpRecoCtxtForCmd->SetInterest(ulInterest, ulInterest);
            TraceMsg(TF_SAPI_PERF, "SetInterest for m_cpRecoCtxtForCmd is Done, hr=%x", hr);
        }

        TraceMsg(TF_SAPI_PERF, "InitializeCallback for m_cpRecoCtxtForCmd is done!!! hr=%x", hr);

        // Load the shard command grammars and activate them by default.

        if (SUCCEEDED(hr) )
        {
            hr = m_cpRecoCtxtForCmd->CreateGrammar(GRAM_ID_CMDSHARED, &m_cpSharedGrammarInVoiceCmd);
            TraceMsg(TF_SAPI_PERF, "Create SharedCmdGrammar In Voice cmd, hr=%x", hr);
        }    

        if (S_OK == hr)
        {
           hr = S_FALSE;

           // try resource first because loading cmd from file takes
           // quite long time
           //
           if (m_langid == 0x409 ||    // English
               m_langid == 0x411 ||    // Japanese
               m_langid == 0x804 )     // Simplified Chinese
           {
               hr = m_cpSharedGrammarInVoiceCmd->LoadCmdFromResource(
                                                         g_hInstSpgrmr,
                                                         (const WCHAR*)MAKEINTRESOURCE(ID_SPTIP_SHAREDCMD_CFG),
                                                         L"SRGRAMMAR", 
                                                         m_langid, 
                                                         SPLO_DYNAMIC);

               TraceMsg(TF_SAPI_PERF, "Load shared cmd.cfg, hr=%x", hr);
           }

           if (S_OK != hr)
           {
               // in case if we don't have built-in grammar
               // it provides a way for customer to localize their grammars in different languages
               _GetCmdFileName(m_langid);
               if (m_szShrdCmdFile[0])
               {
                   hr = m_cpSharedGrammarInVoiceCmd->LoadCmdFromFile(m_szShrdCmdFile, SPLO_DYNAMIC);
               } 
           }

           // Activate the grammar by default

           if ( hr == S_OK )
           {
               if (m_pime->_AllCmdsEnabled( ))
               {
                    hr = m_cpSharedGrammarInVoiceCmd->SetRuleState(NULL,  NULL, SPRS_ACTIVE);
                    TraceMsg(TF_SAPI_PERF, "Set rules status in m_cpSharedGrammarInVoiceCmd");
               }
               else
               {
                    // Some category commands are disabled.
                    // active them individually.

                    hr = _ActiveCategoryCmds(DC_CC_SelectCorrect, m_pime->_SelectCorrectCmdEnabled( ), ACTIVE_IN_COMMAND_MODE);

                    if ( hr == S_OK )
                        hr = _ActiveCategoryCmds(DC_CC_Navigation, m_pime->_NavigationCmdEnabled( ), ACTIVE_IN_COMMAND_MODE);

                    if ( hr == S_OK )
                        hr = _ActiveCategoryCmds(DC_CC_Casing, m_pime->_CasingCmdEnabled( ), ACTIVE_IN_COMMAND_MODE);

                    if ( hr == S_OK )
                        hr = _ActiveCategoryCmds(DC_CC_Editing, m_pime->_EditingCmdEnabled( ), ACTIVE_IN_COMMAND_MODE);

                    if ( hr == S_OK )
                        hr = _ActiveCategoryCmds(DC_CC_Keyboard, m_pime->_KeyboardCmdEnabled( ), ACTIVE_IN_COMMAND_MODE );

                    if ( hr == S_OK )
                        hr = _ActiveCategoryCmds(DC_CC_TTS, m_pime->_TTSCmdEnabled( ), ACTIVE_IN_COMMAND_MODE);

                    if ( hr == S_OK )
                        hr = _ActiveCategoryCmds(DC_CC_LangBar, m_pime->_LanguageBarCmdEnabled( ), ACTIVE_IN_COMMAND_MODE);
                }
           }

           if (S_OK != hr)
           {
               m_cpSharedGrammarInVoiceCmd.Release();
           }
           else if ( PRIMARYLANGID(m_langid) == LANG_ENGLISH  || 
                     PRIMARYLANGID(m_langid) == LANG_JAPANESE ||
                     PRIMARYLANGID(m_langid) == LANG_CHINESE )
           {
              // means this language's grammar support Textbuffer commands.
              m_fSelectionEnabled = TRUE;
           }

#ifdef RECOSLEEP
           InitSleepClass( );
#endif
        }
        TraceMsg(TF_SAPI_PERF, "Finish the initalization for RecoCtxtForCmd");
    }
     
    TraceMsg(TF_SAPI_PERF, "InitializeSAPIForCmd exits!");

    return hr;
}

#ifdef RECOSLEEP
void  CSpTask::InitSleepClass( )
{
   // Load the Sleep/Wakeup grammar.
   if ( !m_pSleepClass )
   {
       m_pSleepClass = new CRecoSleepClass(this);
       if ( m_pSleepClass )
          m_pSleepClass->InitRecoSleepClass( );
   }
}

BOOL  CSpTask::IsInSleep( )
{
    BOOL  fSleep = FALSE;

    if ( m_pSleepClass )
        fSleep = m_pSleepClass->IsInSleep( );

    return fSleep;
}
#endif

HRESULT   CSpTask::_SetDictRecoCtxtState( BOOL  fEnable )
{
    HRESULT hr = S_OK;

    TraceMsg(TF_SAPI_PERF, "_SetDictRecoCtxtState is called, fEnable=%d", fEnable);

    if ( m_cpRecoCtxt && (fEnable != m_fDictCtxtEnabled))
    {
        if (fEnable )
        {
            // if Voice command reco Context is enabled, just disable it.
            if (m_cpRecoCtxtForCmd && m_fCmdCtxtEnabled)
            {
                hr = m_cpRecoCtxtForCmd->SetContextState(SPCS_DISABLED);
                m_fCmdCtxtEnabled = FALSE;
                TraceMsg(TF_SAPI_PERF, "Disable Voice command Reco Context");
            }

            // Build toolbar grammar if it is not built out yet.
            if (m_pLangBarSink && !m_pLangBarSink->_IsTBGrammarBuiltOut( ))
                m_pLangBarSink->_OnSetFocus( );

            // Enable Dictation Reco Context.
            if ( hr == S_OK )
            {
                hr = m_cpRecoCtxt->SetContextState(SPCS_ENABLED);
                TraceMsg(TF_SAPI_PERF, "Enable Dictation Reco Context");

                if ( hr == S_OK && !m_fDictationReady )
                {
                    WCHAR sz[128];
                    sz[0] = '\0';
                    CicLoadStringWrapW(g_hInst, IDS_NUI_BEGINDICTATION, sz, ARRAYSIZE(sz));

                    m_pime->GetSpeechUIServer()->UpdateBalloon(TF_LB_BALLOON_RECO, sz , -1);
                    m_fDictationReady   = TRUE;
                    TraceMsg(TF_SAPI_PERF, "Show Begin Dictation!");
                }
            }
        }
        else
        {
           hr = m_cpRecoCtxt->SetContextState(SPCS_DISABLED);
           TraceMsg(TF_SAPI_PERF, "Disable Dictation Reco Context");
        }

        if ( hr == S_OK )
        {
            m_fDictCtxtEnabled = fEnable;
        }
    }

    TraceMsg(TF_SAPI_PERF, "_SetDictRecoCtxtState exit");

    return hr;
}

HRESULT   CSpTask::_SetCmdRecoCtxtState( BOOL fEnable )
{
    TraceMsg(TF_SAPI_PERF, "_SetCmdRecoCtxtState is called, fEnable=%d", fEnable);
    HRESULT hr = S_OK;

    if ( fEnable != m_fCmdCtxtEnabled )
    {
        if ( fEnable )
        {
            if ( !m_cpRecoCtxtForCmd )
                hr = InitializeSAPIForCmd( );

            if ( hr == S_OK && m_cpRecoCtxtForCmd )
            {
                // Disable Dictation Context if it is enabled now.
                if (m_cpRecoCtxt && m_fDictCtxtEnabled)
                {
                    hr = m_cpRecoCtxt->SetContextState(SPCS_DISABLED);
                    m_fDictCtxtEnabled = FALSE;
                    TraceMsg(TF_SAPI_PERF, "DISABLE Dictation RecoContext");
                }

                if ( hr == S_OK && m_pime && !m_pime->_AllCmdsDisabled( ) )
                {
                    // Build toolbar grammar if it is not built out yet.
                    if (m_pLangBarSink && !m_pLangBarSink->_IsTBGrammarBuiltOut( ))
                        m_pLangBarSink->_OnSetFocus( );

                    // Fill text to selection grammar's buffer.

                     _UpdateTextBuffer(m_cpRecoCtxtForCmd);

                    hr = m_cpRecoCtxtForCmd->SetContextState(SPCS_ENABLED);
                    m_fCmdCtxtEnabled = fEnable;
                    TraceMsg(TF_SAPI_PERF, "Enable Voice command Reco Context");
                }
            }
        }
        else if ( m_cpRecoCtxtForCmd ) // fEnable is FALSE
        {
            hr = m_cpRecoCtxtForCmd->SetContextState(SPCS_DISABLED);
            m_fCmdCtxtEnabled = FALSE;
            TraceMsg(TF_SAPI_PERF, "Disable Voice Command Reco Context");
        }
    }

    TraceMsg(TF_SAPI_PERF, "_SetCmdRecoCtxtState exits");
    return hr;
}



LANGID CSpTask::_GetPreferredEngineLanguage(LANGID langid)
{
    SPRECOGNIZERSTATUS   stat;
    LANGID               langidRet = 0;

    // (possible TODO) After M3 SPG may come up with GetAttrRank API that 
    //       would give us the info about whether a token has a particular 
    //       attrib supported. Then we could use that for checking langid
    //       a recognizer supports without using the real engine instance.
    //       We could also consolidate a method to check if SR is enabled
    //       for the current language once we have that.
    // 
    Assert(m_cpRecoEngine);
    if (S_OK == m_cpRecoEngine->GetStatus(&stat))
    {
        for (ULONG ulId = 0; ulId < stat.cLangIDs; ulId++)
        {
            if (langid == stat.aLangID[ulId])
            {
                langidRet =  langid;
                break;
            }
        }
        if (!langidRet)
        {
            // if there's no match, just return the most prefered one
            langidRet = stat.aLangID[0];
        }
    }
    return langidRet;
}

HRESULT CSpTask::_SetVoice(LANGID langid)
{
    CComPtr<ISpObjectToken> cpToken;

    char  szLang[MAX_PATH];
    WCHAR wsz[MAX_PATH];

    StringCchPrintfA(szLang,ARRAYSIZE(szLang), "Language=%x", langid);
    MultiByteToWideChar(CP_ACP, NULL, szLang, -1, wsz, ARRAYSIZE(wsz));

    HRESULT hr = SpFindBestToken( SPCAT_VOICES, wsz, NULL, &cpToken);

    if (S_OK == hr)
    {
        hr = m_cpVoice->SetVoice(cpToken);
    }
    return hr;
}

//
// GetSAPIInterface(riid, (void **)ppunk)
// 
// here, try pass through the given IID
//       to SAPI5 interface
// 
// CComPtr<ISpResourceManager> m_cpResMgr;
// CComPtr<ISpRecoContext>     m_cpRecoCtxt;
// CComPtr<ISpRecognizer>      m_cpRecoEngine;
// CComPtr<ISpVoice>           m_cpVoice;
// 
// the above 5 interfaces are currently used by
// Cicero/Sapi Layer 
//
// if a client calls ITfFunctionProvider::GetFunction()
// for a SAPI interface, we return what we've already 
// instantiated so the caller can setup options
// for the currently used SAPI objects (reco ctxt for ex)
//
HRESULT CSpTask::GetSAPIInterface(REFIID riid, void **ppunk)
{
    Assert(ppunk);
    
    *ppunk = NULL;

    
    if (IsEqualGUID(riid, IID_ISpResourceManager))
    {
        *ppunk = m_cpResMgr;
    }
    else if (IsEqualGUID(riid,IID_ISpRecoContext))
    {
        *ppunk = m_cpRecoCtxt;
    }
    else if (IsEqualGUID(riid,IID_ISpRecognizer))
    {
        *ppunk = m_cpRecoEngine;
    }
    else if (IsEqualGUID(riid,IID_ISpVoice))
    {
        *ppunk = m_cpVoice;
    }
    else if (IsEqualGUID(riid,IID_ISpRecoGrammar))
    {
        *ppunk = m_cpDictGrammar;
    }
    if(*ppunk)
    {
        ((IUnknown *)(*ppunk))->AddRef();
    }
    
    return *ppunk ? S_OK : E_NOTIMPL;
}


// 
// Get RecoContext for Voice Command mode.
//
HRESULT CSpTask::GetRecoContextForCommand(ISpRecoContext **ppRecoCtxt)
{
    HRESULT hr = E_FAIL;

    Assert(ppRecoCtxt);

    if ( m_cpRecoCtxtForCmd )
    {
        *ppRecoCtxt = m_cpRecoCtxtForCmd;
        (*ppRecoCtxt)->AddRef( );
        hr = S_OK;
    }

    return hr; 
}

// test: use Message callback
LRESULT CALLBACK CSapiIMX::_WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CSapiIMX *_this = (CSapiIMX *)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    CSpTask  *_sptask = _this ? _this->m_pCSpTask : NULL;

    switch(uMsg)
    {
        case WM_CREATE:
        {
            CREATESTRUCT *pcs = (CREATESTRUCT *)lParam;
            if (pcs)
            {
                SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)(pcs->lpCreateParams));
            }
            break; 
        }
        case WM_TIMER:

        if ( wParam != TIMER_ID_CHARTYPED )
            KillTimer( hWnd, wParam );

        if (wParam == TIMER_ID_OPENCLOSE)
        {
            // i've seen this null case once but is it possible?
            TraceMsg(TF_SAPI_PERF, "TIMER_ID_OPENCLOSE is fired off ...");
            if (_this->_tim)
                _this->_HandleOpenCloseEvent(MICSTAT_ON);
        }
        else if ( wParam == TIMER_ID_CHARTYPED )
        {
            DWORD   dwNumCharTyped;
            BOOL    fDictOn;

            fDictOn = _this->GetOnOff( ) && _this->GetDICTATIONSTAT_DictOnOff( );
            dwNumCharTyped = _this->_GetNumCharTyped( );

            TraceMsg(TF_GENERAL, "dwNumCharTyped=%d", dwNumCharTyped);

            _this->_KillCharTypeTimer( );

            Assert(S_OK == _this->IsActiveThread());
            // We should never try to reactivate dictation on a thread that shouldn't be active.

            if ( fDictOn && _sptask && (S_OK == _this->IsActiveThread()) )
            {
                if ( dwNumCharTyped <= 1 )
                {
                    // There is no more typing during this period
                    // possible, user finished typing.
                    // 
                    // we need to resume dication again if the Dictation mode is ON.
                    ULONGLONG ulInterest = SPFEI(SPEI_SOUND_START) |
                             SPFEI(SPEI_SOUND_END) |
                             SPFEI(SPEI_PHRASE_START) |
                             SPFEI(SPEI_RECOGNITION) |
                             SPFEI(SPEI_FALSE_RECOGNITION) |
                             SPFEI(SPEI_RECO_OTHER_CONTEXT) |
                             SPFEI(SPEI_HYPOTHESIS) |
                             SPFEI(SPEI_INTERFERENCE) |
                             SPFEI(SPEI_ADAPTATION);

                    _sptask->_SetDictRecoCtxtState(TRUE);
                    _sptask->_SetRecognizerInterest(ulInterest);
                    _sptask->_UpdateBalloon(IDS_LISTENING, IDS_LISTENING_TOOLTIP);
                }
                else
                {
                    // There are more typing during this period,
                    // we want to set another timer to watch the end of the typing.
                    //
                    _this->_SetCharTypeTimer( );
                }
            }
        }

        break;
        case WM_PRIV_FEEDCONTEXT:
        if (_sptask && lParam != NULL && _sptask->m_pdc)
        {
            _sptask->m_pdc->FeedContextToGrammar(_sptask->m_cpDictGrammar);
            delete _sptask->m_pdc;
            _sptask->m_pdc = NULL;
        }
        break;
        case WM_PRIV_LBARSETFOCUS:
            if (_sptask)
                _sptask->m_pLangBarSink->_OnSetFocus();
            break;
        case WM_PRIV_SPEECHOPTION:
            {
                _this->_ResetDefaultLang();
                BOOL fSREnabledForLanguage = _this->InitializeSpeechButtons();
        
                _this->SetDICTATIONSTAT_DictEnabled(fSREnabledForLanguage);
            }
            break;
        case WM_PRIV_ADDDELETE:
            _this->_DisplayAddDeleteUI();
            break;

        case WM_PRIV_SPEECHOPENCLOSE:
            TraceMsg(TF_SAPI_PERF, "WM_PRIV_SPEECHOPENCLOSE is handled");
            _this->_HandleOpenCloseEvent();
            break;
        
        case WM_PRIV_OPTIONS:
            _this->_InvokeSpeakerOptions();
            break;

        case WM_PRIV_DORECONVERT :
            _this->_DoReconvertOnRange( );
            break;

        default:
            return DefWindowProc(hWnd, uMsg, wParam, lParam);
    }
    return 0;
}

void CSpTask::NotifyCallbackForCmd(WPARAM wParam, LPARAM lParam )
{
    CSpTask *_this = (CSpTask *)lParam;

    // SAPI M2 work around which is to be removed when M3 comes up. 
    // See comments in  CSpTask::_SetInputOnOffState for more detail
    //
    // TABLETPC - NEEDED TO ALLOW FINAL RECOGNITIONS TO BE RECEIVED AFTER AUDIO STOPPED.
/*    if (_this->m_fInputState == FALSE)
    {
        return;
    }*/

    if (_this->m_pime->fDeactivated())
        return;

    if (!_this->m_cpRecoCtxtForCmd)
    {
        return;
    }

    _this->SharedRecoNotify(_this->m_cpRecoCtxtForCmd);

    return;
}


void CSpTask::NotifyCallback( WPARAM wParam, LPARAM lParam )
{
    CSpTask *_this = (CSpTask *)lParam;

    // SAPI M2 work around which is to be removed when M3 comes up. 
    // See comments in  CSpTask::_SetInputOnOffState for more detail
    //

    // TABLETPC - NEEDED TO ALLOW FINAL RECOGNITIONS TO BE RECEIVED AFTER AUDIO STOPPED.
/*    if (_this->m_fInputState == FALSE)
    {
        return;
    }*/

    if (_this->m_pime->fDeactivated())
        return;

    if (!_this->m_cpRecoCtxt)
    {
        return;
    }

    _this->SharedRecoNotify(_this->m_cpRecoCtxt);

    return;
}

// This is real handler for the recognition notification.
//
// it could be shared by two RecoContexts.
//
void  CSpTask::SharedRecoNotify(ISpRecoContext *pRecoCtxt)
{
    CSpEvent event;
#ifdef SAPI_PERF_DEBUG
   static  int  iCount = 0;

   if ( iCount == 0 )
   {
      TraceMsg(TF_SAPI_PERF, "The first time Get Notification from Engine!!!");
      iCount ++;
   }
#endif

    Assert (pRecoCtxt);

    while ( event.GetFrom(pRecoCtxt) == S_OK )
    {
        switch (event.eEventId)
        {
            case SPEI_SOUND_START:
                ATLASSERT(!m_bInSound);
                m_bInSound = TRUE;
                break;

            case SPEI_INTERFERENCE:
                //
                // we do not need interference when not in dictation
                // mode
                //
                if (m_pime->GetDICTATIONSTAT_DictOnOff() &&
                    S_OK == m_pime->IsActiveThread())
                {
                    _HandleInterference((ULONG)(event.lParam)); 
                }
                break;

            case SPEI_PHRASE_START:
                ATLASSERT(m_bInSound);
                m_bGotReco = FALSE;

                if (m_pime->GetDICTATIONSTAT_DictOnOff() &&
                    S_OK == m_pime->IsActiveThread())
                {
                    // Before inject feedback UI, we need to save the current IP
                    // and check if we want to pop up the Add/Remove SR dialog UI.

                    // And then inject FeedbackUI as usual

                    m_pime->SaveCurIPAndHandleAddDelete_InjectFeedbackUI( );

                    // show "dictating..." to the balloon
                    _ShowDictatingToBalloon(TRUE);
                }

                break;

            case SPEI_HYPOTHESIS:
                ATLASSERT(!m_bGotReco);


                // if current microphone status is OFF
                // we do not want to show any hypothesis
                // at least
                //

                // DO NOT HAVE DEBUG CODE TO SHOW ENGINE STATE. CAN BLOCK CICERO AND CHANGE BEHAVIOR.
                if (!GetSystemMetrics(SM_TABLETPC))
                    _ShowDictatingToBalloon(TRUE);

                //
                // we do not need the feedback UI when not in dictation
                // mode
                //
                if (m_pime->GetDICTATIONSTAT_DictOnOff() &&
                    S_OK == m_pime->IsActiveThread())
                {
                    m_pime->_HandleHypothesis(event);
                }
                
                break;

            case SPEI_RECO_OTHER_CONTEXT:
            case SPEI_FALSE_RECOGNITION:
            {
                HRESULT hr = S_OK;

                if ( event.eEventId == SPEI_FALSE_RECOGNITION )
                {
                    // Set 'What was that?' feedback text.
                    _UpdateBalloon(IDS_INT_NOISE, IDS_INTTOOLTIP_NOISE);
                }

                // set this flag anyways
                //
                ATLASSERT(!m_bGotReco);
                m_bGotReco = TRUE;

                // Reset hypothesis counters.
                m_pime->_HandleFalseRecognition();

                hr = m_pime->EraseFeedbackUI();
                ATLASSERT("Failed to erase potential feedback on a false recognition." && SUCCEEDED(hr));

                break;
            }

            case SPEI_RECOGNITION:

                // Set 'Listening...' feedback text. Can be overwritten by command feedback.
                _UpdateBalloon(IDS_LISTENING, IDS_LISTENING_TOOLTIP);

                // set this flag anyways
                //
                ATLASSERT(!m_bGotReco);
                m_bGotReco = TRUE;

                ULONGLONG ullGramID;

                if ( S_OK == m_pime->IsActiveThread() )
                {
                    m_pime->_HandleRecognition(event, &ullGramID);
                }

                // if ( _GetSelectionStatus( ) )
                if (ullGramID == GRAM_ID_SPELLING)
                {
                    _SetSelectionStatus(FALSE);
                    _SetSpellingGrammarStatus(FALSE);
                }

                _UpdateTextBuffer(pRecoCtxt);

                if ( (ullGramID == GRAM_ID_DICT) || (ullGramID == GRAM_ID_SPELLING) )
                {
                    // Update Balloon.
                    if (!GetSystemMetrics(SM_TABLETPC))
                        _UpdateBalloon(IDS_LISTENING, IDS_LISTENING_TOOLTIP);

                    // every time dictated text is injected, we want to watch 
                    // again if there is IP change after that. 
                    // so clear the flag now.
                    m_pime->_SetIPChangeStatus( FALSE );
                }

                break;

            case SPEI_SOUND_END:
                m_bInSound = FALSE;

                break;
                
            case SPEI_ADAPTATION:
                TraceMsg(TF_GENERAL, "Get SPEI_ADAPTATION notification");

                if ( m_pime->_HasMoreContent( ) )
                {
                     m_pime->_GetNextRangeEditSession( );
                }
                else
                    // There is no more content for this doc.
                    // set the interesting event value to avoid this notification.
                    m_pime->_UpdateRecoContextInterestSet(FALSE);

                break;
#ifdef SYSTEM_GLOBAL_MIC_STATUS
            case SPEI_RECO_STATE_CHANGE:
                m_pime->SetOnOff(_GetInputOnOffState());
                break;
#endif

            default:
                break;
        }
    }
    return;
}

HRESULT CSpTask::_UpdateTextBuffer(ISpRecoContext *pRecoCtxt)
{
    HRESULT  hr = S_OK;

    if ( !_IsSelectionEnabled( ) )
       return S_OK;

    if ( !pRecoCtxt || !m_pime)
        return E_FAIL;

    if ( m_pime->_SelectCorrectCmdEnabled( ) || m_pime->_NavigationCmdEnabled( ) )
    {
        BOOL  fDictOn, fCmdOn;

        fDictOn = m_pime->GetOnOff( ) && m_pime->GetDICTATIONSTAT_DictOnOff( );
        fCmdOn = m_pime->GetOnOff( ) && m_pime->GetDICTATIONSTAT_CommandingOnOff( );


        if ( fDictOn && m_cpSharedGrammarInDict && !m_pime->_AllDictCmdsDisabled( ))
            hr = m_pime->UpdateTextBuffer(pRecoCtxt, m_cpSharedGrammarInDict);
        else if (fCmdOn && m_cpSharedGrammarInVoiceCmd )
            hr = m_pime->UpdateTextBuffer(pRecoCtxt, m_cpSharedGrammarInVoiceCmd);
    }

    return hr;
}

// When selection grammar status is changed from inactive to active
// this function will be called to fill text to the grammar buffer.
//
HRESULT  CSpTask::_UpdateSelectGramTextBufWhenStatusChanged(  )
{
    BOOL  fDictOn, fCmdOn;
    HRESULT  hr = S_OK;

    // Check current mode status.

    fDictOn = m_pime->GetDICTATIONSTAT_DictOnOff( );
    fCmdOn =  m_pime->GetDICTATIONSTAT_CommandingOnOff( );

    if ( fDictOn )
        hr = _UpdateTextBuffer(m_cpRecoCtxt);
    else if ( fCmdOn )
        hr = _UpdateTextBuffer(m_cpRecoCtxtForCmd);

    return hr;
}


HRESULT CSpTask::_OnSpEventRecognition(ISpRecoResult *pResult, ITfContext *pic, TfEditCookie ec)
{
    HRESULT hr = S_OK;
    BOOL fDiscard = FALSE;
    BOOL fCtrlSymChar = FALSE;  // Control or Punctuation character

   
    if (pResult)
    {
        static const WCHAR szUnrecognized[] = L"<Unrecognized>";
        LANGID langid;
        
        SPPHRASE *pPhrase;

        hr = pResult->GetPhrase(&pPhrase);
        if (SUCCEEDED(hr) && pPhrase)
        {
            // AJG - ADDED FILTERING CODE.
            switch (pPhrase->Rule.ulCountOfElements)
            {
                case 0:
                {
                    ASSERT(pPhrase->Rule.ulCountOfElements != 0);
                    // SHOULD NEVER OCCUR.
                    break;
                }
                case 1:
                {
                    const SPPHRASEELEMENT *pElement;

                    pElement = pPhrase->pElements;

                    if (!m_fTestedForOldMicrosoftEngine)
                    {
                        // Test token name to see if it contains MSASREnglish.
                        CComPtr<ISpObjectToken> cpRecoToken;
                        WCHAR *pwszCoMemTokenId;
                        m_cpRecoEngine->GetRecognizer(&cpRecoToken);
                        if (cpRecoToken)
                        {
                            if (SUCCEEDED(cpRecoToken->GetId(&pwszCoMemTokenId)))
                            {
                                if (wcsstr(pwszCoMemTokenId, L"MSASREnglish") != NULL)
                                {
                                    // It is an old Microsoft engine. Check for registry key that tells us to disable the heuristic anyway.
                                    BOOL fDisableHeuristicAnyway = FALSE;
                                    if (FAILED(cpRecoToken->MatchesAttributes(L"DisableCiceroConfidence", &fDisableHeuristicAnyway)) || fDisableHeuristicAnyway == FALSE)
                                    {
                                        m_fOldMicrosoftEngine = TRUE;
                                        // Means we *will* apply single word confidence heuristic to improve performance.
                                    }
                                }
                                CoTaskMemFree(pwszCoMemTokenId);
                            }
                        }

                        // One of lazy initialization. Do not do this again.
                        m_fTestedForOldMicrosoftEngine = TRUE;
                    }
                    if (m_fOldMicrosoftEngine && m_pime->_RequireHighConfidenceForShorWord( ) )
                    {
                        // Only apply this heuristic to 5.x Microsoft engines (Token name contains MSASREnglish).
                        if (pElement && pElement->ActualConfidence != 1 &&
                            (!pElement->pszLexicalForm || wcslen(pElement->pszLexicalForm) <= 5) &&
                            (!pElement->pszDisplayText || wcslen(pElement->pszDisplayText) <= 5) )
                        {
                            TraceMsg(TF_GENERAL, "Discarded Result : Single Word, Low Confidence!");
                            _UpdateBalloon(IDS_INT_NOISE, IDS_INTTOOLTIP_NOISE );
                            fDiscard = TRUE;
                        }
                    }


                    if (pPhrase->pElements[0].pszDisplayText )
                    {
                        WCHAR  wch;

                        wch = pPhrase->pElements[0].pszDisplayText[0];

                        if ( iswcntrl(wch) || iswpunct(wch) )
                            fCtrlSymChar = TRUE;
                    }

                }
                case 2:
                {
                    // Do something here?
                }
                default:
                {
                    // Do no filtering of the result.
                }
            }
            // AJG - CHECK WE AREN'T IN THE MIDDLE OF A WORD. NOT GENERALLY A DESIRED 'FEATURE'. CAUSES ANNOYING ERRORS.
            // if this is spelled text, don't check if it is inside of a word.
            if ((pPhrase->ullGrammarID != GRAM_ID_SPELLING) && _IsSelectionInMiddleOfWord(ec) && !fCtrlSymChar)
            {
                TraceMsg(TF_GENERAL, "Discarded Result : IP is in middle of a word!");
                _UpdateBalloon(IDS_BALLOON_DICTAT_PAUSED, IDS_BALLOON_TOOLTIP_IP_INSIDE_WORD);
                fDiscard = TRUE;
            }
        }

        if ( SUCCEEDED(hr) && fDiscard )
        {
          
           // This phrase will not be injected to the document.
           // the code needs to feed context to the SR engine so that
           // SR engine will not base on wrong assumption.

           if ( m_pime  && m_pime->GetDICTATIONSTAT_DictOnOff() )
              m_pime->_SetCurrentIPtoSR();

        }

        if (SUCCEEDED(hr) && pPhrase && !fDiscard)
        {
            // retrieve LANGID from phrase
            langid = pPhrase->LangID;

            // SPPHRASE includes non-serialized text
            CSpDynamicString dstr;
            ULONG ulNumElements = pPhrase->Rule.ulCountOfElements;

            hr = _GetTextFromResult(pResult, langid, dstr);

            if ( hr == S_OK )
            {
                // check the current IP to see if it was a selection,
                // then see if the best hypothesis already matches the current
                // selection. 

                int lCommitHypothesis = 0;
                for (int nthHypothesis = 1;_DoesSelectionHaveMatchingText(dstr, ec); nthHypothesis++)
                {
                    CSpDynamicString dsNext;

                    TraceMsg(TF_GENERAL, "Switched to alternate result as main result exactly matched selection!");

                    // We could add one to request hypothesis since 1 = the main phrase and we already know that matched.
                    // However I don't believe this is guaranteed to be the case by SAPI - it just happens to be the case
                    // with the Microsoft engine.
                    if (_GetNextBestHypothesis(pResult, nthHypothesis, &ulNumElements, langid, dstr, dsNext, ec))
                    {
                        dstr.Clear();
                        dstr.Append(dsNext);
                        // Need to commit phrase to prevent stored result object being out of sync with count of
                        // elements in wrapping object.
                        lCommitHypothesis = nthHypothesis;
                        // Note - at this point, we don't know if we can use it. We have to loop once more to determine this.
                    }
                    else
                    {
                        TraceMsg(TF_SAPI_PERF, "No alternate found that differed from the user selection.\n");
                        // No more alternate phrase
                        // There is no any alt phrase which has different text from current selection.
                        // should stop here, otherwise, infinite loop.
                        lCommitHypothesis = 0;
                        // Reset element count to match primary phrase.
                        ulNumElements = pPhrase->Rule.ulCountOfElements;
                        // Reset text:
                        dstr.Clear();
                        hr = _GetTextFromResult(pResult, langid, dstr);
                        break;
                    }
                }

                if (0 != lCommitHypothesis)
                {
                    ULONG cAlt = lCommitHypothesis;
                    ISpPhraseAlt **ppAlt = (ISpPhraseAlt **)cicMemAlloc(cAlt*sizeof(ISpPhraseAlt *));
                    if (ppAlt)
                    {
                        memset(ppAlt, 0, cAlt * sizeof(ISpPhraseAlt *)); 
                        hr = pResult->GetAlternates( 0, ulNumElements, cAlt,  ppAlt,  &cAlt );

                        Assert( cAlt == lCommitHypothesis );

                        if ((S_OK == hr) && (cAlt == lCommitHypothesis))
                        {
                            ((ppAlt)[lCommitHypothesis-1])->Commit();
                        }

                        // Release references to alternate phrases.
                        for (UINT i = 0; i < cAlt; i++)
                        {
                            if (NULL != (ppAlt)[i])
                            {
                                ((ppAlt)[i])->Release();
                            }
                        }
            
                        cicMemFree(ppAlt);
                    }
                }

                CComPtr<ITfRange>  cpTextRange;
                ITfRange *pSavedIP;

                pSavedIP = m_pime->GetSavedIP( );

                if (pSavedIP)
                    pSavedIP->Clone(&cpTextRange);

                // this call will have to be per element. see my comment below.
                if (pPhrase->ullGrammarID == GRAM_ID_SPELLING)
                {
                    hr = m_pime->InjectSpelledText(dstr, langid);
                }
                else 
                {
                    hr = m_pime->InjectText(dstr, langid);

                    if ( hr == S_OK )
                    {
                        // now we use the result object directly to attach
                        // to a docuement.
                        // the result object gets addref'd in the Attach() 
                        // call.
                        //
                        hr = m_pime->AttachResult(pResult, 0, ulNumElements);
                    }

                    // Handle spaces carefully and specially.
                    if ( hr == S_OK  && cpTextRange )
                    {
                        hr = m_pime->HandleSpaces(pResult, 0, ulNumElements, cpTextRange, langid);
                    }
                }
            }
        }

        if ( pPhrase)
            ::CoTaskMemFree( pPhrase );
    }

    return hr;
}

//
// _GetTextFromResult
//
// synopsis: get text from phrase considering space control
//           based on locale
//
HRESULT CSpTask::_GetTextFromResult(ISpRecoResult *pResult, LANGID langid, CSpDynamicString &dstr)
{
    BYTE bAttr;
    HRESULT  hr = S_OK;
    
    Assert(pResult);

    if ( !pResult )
        return E_INVALIDARG;

    hr = pResult->GetText(SP_GETWHOLEPHRASE, SP_GETWHOLEPHRASE, TRUE, &dstr, &bAttr);

    if ( hr == S_OK )
    {
        if (bAttr & SPAF_ONE_TRAILING_SPACE)
        {
            dstr.Append(L" ");
        }
        else if (bAttr & SPAF_TWO_TRAILING_SPACES)
        {
            dstr.Append(L"  ");
        }

        if (bAttr & SPAF_CONSUME_LEADING_SPACES)
        {
            // we need to figure out the correct behavior based on LANGID
        }
    }

    return hr;
}

//
// _IsSelectionInMiddleOfWord
//
// synopsis: check if the current IP is empty and inside of a word
//          
BOOL CSpTask::_IsSelectionInMiddleOfWord(TfEditCookie ec)
{
    BOOL fInsideWord = FALSE;

    if ( m_langid == 0x0409 )
    {
        if (CComPtr<ITfRange> cpInsertionPoint =  m_pime->GetSavedIP())
        {
            WCHAR szSurrounding[3] = L"  ";

            // clone the IP range since we want to move the anchor
            //
            CComPtr<ITfRange> cpClonedRange;
            cpInsertionPoint->Clone(&cpClonedRange);

            BOOL fEmpty;
            cpClonedRange->IsEmpty(ec, &fEmpty);
            if (fEmpty)
            {
                LONG    l1, l2;
                ULONG   ul;
                HRESULT hr;

                cpClonedRange->Collapse(ec, TF_ANCHOR_START);
                cpClonedRange->ShiftStart(ec, -1, &l1, NULL);
                cpClonedRange->ShiftEnd(ec, 1, &l2, NULL);
                if (l1 != 0) // Not at start of document.
                {
                    hr = cpClonedRange->GetText(ec, TF_TF_MOVESTART, szSurrounding, (l2!=0)?(2):(1), &ul);
                    if (SUCCEEDED(hr) && iswalpha(szSurrounding[0]) && iswalpha(szSurrounding[1]) )
                    {
                        fInsideWord = TRUE;
                    }
                }
                // if l1 == 0, means the ip is at the start of document.
                // fInsideWord is set to FALSE already by default.
            }
        }
    }
    return fInsideWord;
}

//
// DoesSelectionHaveMatchingText
//
// synopsis: check if the current saved IP has a selection that matches the text
//           passed in
//
#define SPACEBUFFER 4
// 2 characters either side of a word or phrase.

BOOL CSpTask::_DoesSelectionHaveMatchingText(WCHAR *psz, TfEditCookie ec)
{
    BOOL fMatch = FALSE;
    Assert(psz);

    if ( !psz )
    {
        return FALSE;
    }

    WCHAR *pszStripped = psz;
    ULONG ulCch = wcslen(psz);

    // Remove trailing space.
    while (ulCch > 0 && psz[ulCch-1] == L' ')
    {
        // Do not set null terminating character as this is a passed in string.
        ulCch --;
    }
    // Skip leading space in input text.
    while (pszStripped[0] == L' ')
    {
        pszStripped ++;
        ulCch --;
    }
    // Now have space-stripped word pointed to by pszTmp and with length ulCch

    if (CComPtr<ITfRange> cpInsertionPoint =  m_pime->GetSavedIP())
    {
        WCHAR *szRange = new WCHAR[ulCch+SPACEBUFFER+1];
        WCHAR *szRangeStripped = szRange;
       
        if (szRange)
        {
            // clone the IP range since we want to move the anchor
            //
            CComPtr<ITfRange> cpClonedRange;
            cpInsertionPoint->Clone(&cpClonedRange);
 
            ULONG cchRange; // max is the reco result
            
            HRESULT hr = cpClonedRange->GetText(ec, TF_TF_MOVESTART, szRange, ulCch+SPACEBUFFER, &cchRange);
            // Remove trailing space.
            while (cchRange > 0 && szRange[cchRange-1] == L' ')
            {
                // Can set null terminating character as this is our string.
                szRange[cchRange-1] = 0;
                cchRange --;
            }
            // Skip leading space in input text.
            while (szRangeStripped[0] == L' ')
            {
                szRangeStripped ++;
                cchRange --;
            }
            // Now have space-stripped word pointed to by pszTmp and with length ulCch
            if (S_OK == hr && cchRange > 0 && cchRange == ulCch)
            {
                if (wcsnicmp(pszStripped, szRangeStripped, ulCch) == 0) // Case insensitive compare.
                {
                    fMatch = TRUE;
                }
            }
            delete [] szRange;
        }
    }
    return fMatch;
}

//
// GetNextBestHypothesis
//
// synopsis: this actually gets the nth alternative from the given reco result
//           then adjusts the length accordingly based on the current selection
//          
//
BOOL CSpTask::_GetNextBestHypothesis
(
    ISpRecoResult *pResult, 
    ULONG nthHypothesis,
    ULONG *pulNumElements, 
    LANGID langid, 
    WCHAR *pszBest, 
    CSpDynamicString & dsNext,
    TfEditCookie ec
)
{
    if ( pulNumElements )
       *pulNumElements = 0;

    // get the entire text & length from the saved IP
    if (CComPtr<ITfRange> cpInsertionPoint =  m_pime->GetSavedIP())
    {
        CSpDynamicString dstr;
        CComPtr<ITfRange> cpClonedRange;
        CComPtr<ISpRecoResult> cpRecoResult;
        
        // clone the range since we move the anchor
        HRESULT hr = cpInsertionPoint->Clone(&cpClonedRange);
        
        ULONG cchRangeBuf = wcslen(pszBest);
        
        cchRangeBuf *= 2; // guess the possible # of char

        WCHAR *szRangeBuf = new WCHAR[cchRangeBuf+1];

        if ( !szRangeBuf )
        {
            // Error: Out of Memory 
            // Return here as FALSE.
            return FALSE;
        }

        while(S_OK == hr && !_IsRangeEmpty(ec, cpClonedRange))
        {
            hr = m_pime->_GetRangeText(cpClonedRange, TF_TF_MOVESTART, szRangeBuf, &cchRangeBuf);
            if (S_OK == hr)
            {
                szRangeBuf[cchRangeBuf] = L'\0';
                dstr.Append(szRangeBuf);
            }
        }
        delete [] szRangeBuf;

        // then get a best matching length of next best hypothesis

        // the current recognition should at least have a good guess for # of elements
        // since it turned out to be longer than the IP range.
        //
        Assert(pulNumElements);
        
        ISpPhraseAlt **ppAlt = (ISpPhraseAlt **)cicMemAlloc(nthHypothesis*sizeof(ISpPhraseAlt *));
        ULONG         cAlt = 0;
        if (!ppAlt)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            memset(ppAlt, 0, nthHypothesis * sizeof(ISpPhraseAlt *));
            hr = pResult->GetAlternates( 0, *pulNumElements, nthHypothesis,  ppAlt,  &cAlt );
        }
        
        if (S_OK == hr)
        {
            UINT  i;
            SPPHRASE *pPhrase;
            
            if (nthHypothesis > cAlt)
            {
                *pulNumElements = 0;
                goto no_more_alt;
            }
            
            Assert(nthHypothesis); // 1 based, can't be 0

            hr = ((ppAlt)[nthHypothesis-1])->GetPhrase(&pPhrase);
            if (S_OK == hr)
            {
                for (i = 0; i < pPhrase->Rule.ulCountOfElements; i++ )
                {
                    int cchElement = wcslen(pPhrase->pElements[i].pszDisplayText) + 1;

                    WCHAR *szElement = new WCHAR[cchElement + 2];

                    if ( szElement )
                    {
                        // add +2 for trailing spaces
                        ParseSRElementByLocale(szElement, cchElement+2, pPhrase->pElements[i].pszDisplayText, 
                                                         langid, pPhrase->pElements[i].bDisplayAttributes );

                        dsNext.Append(szElement);

                        delete [] szElement;
                    }
                    else
                    {
                        // Out of Memory.
                        // stop here.
                        break;
                    }
                }
                // now i holds the number of elements that we want to use in the result
                // object
                *pulNumElements = i; 

                ::CoTaskMemFree(pPhrase);
            } // if S_OK == GetPhrase
        } // if S_OK == GetAlternates

no_more_alt:
        // Release phrase alternates objects.
        for (UINT i = 0; i < cAlt; i++)
        {
            if (NULL != ((ppAlt)[i]))
            {
                ((ppAlt)[i])->Release();
            }
        }
        // Free memory for array holding references to alternates objects.
        if (ppAlt)
        {
            ::cicMemFree(ppAlt);
        }

    }
    
    return *pulNumElements > 0;
}





void CSapiIMX::_EnsureWorkerWnd(void)
{
    if (!m_hwndWorker)
    {
        m_hwndWorker = CreateWindow(c_szWorkerWndClass, "", WS_POPUP,
                       0,0,0,0,
                       NULL, 0, g_hInst, this); 
    }

}

//
//  CSapiIMX::_GetAppMainWnd
//
//  This function gets the real main window of current application.
//  This main window would be used as the parent window of Add/Delete dialog
//  and Training wizard.
//
HWND    CSapiIMX::_GetAppMainWnd(void)
{

    HWND   hParentWnd = NULL;
    HWND   hMainWnd = NULL;

    hMainWnd = GetFocus( );

    if ( hMainWnd != NULL )
    {
        hParentWnd = GetParent(hMainWnd);

        while ( hParentWnd != NULL )
        {
            hMainWnd = hParentWnd;
            hParentWnd = GetParent(hMainWnd);
        }
    }

    return hMainWnd;
}
//
//    CSpTask::InitializeCallback
//
//
HRESULT CSpTask::InitializeCallback()
{
    TraceMsg(TF_SAPI_PERF, "CSpTask::InitializeCallback is called");

    if (m_fCallbackInitialized)
    {
        TraceMsg(TF_SAPI_PERF, "m_fCallbackInitialized is true");
        return S_OK;
    }

    if (!m_fSapiInitialized)
        return S_FALSE; // can't do this without SAPI

    // set recognition notification
    CComPtr<ISpNotifyTranslator> cpNotify;
    HRESULT hr = cpNotify.CoCreateInstance(CLSID_SpNotifyTranslator);
    TraceMsg(TF_SAPI_PERF, "SpNotifyTranslator for Reco is generated, hr=%x", hr);


    // set this class instance to notify control object
    if (SUCCEEDED(hr))
    {
        m_pime->_EnsureWorkerWnd();

        hr = cpNotify->InitCallback( NotifyCallback, 0, (LPARAM)this );
        TraceMsg(TF_SAPI_PERF, "InitCallback is Done, hr=%x", hr);
    }
    if (SUCCEEDED(hr))
    {
        hr = m_cpRecoCtxt->SetNotifySink(cpNotify);
        TraceMsg(TF_SAPI_PERF, "SetNotifySink is Done, hr=%x", hr);
    }

    // set the events we're interested in
    if( SUCCEEDED( hr ) )
    {
        const ULONGLONG ulInterest = SPFEI(SPEI_SOUND_START) | 
                                     SPFEI(SPEI_SOUND_END) | 
                                     SPFEI(SPEI_PHRASE_START) |
                                     SPFEI(SPEI_RECOGNITION) | 
                                     SPFEI(SPEI_RECO_OTHER_CONTEXT) |
                                     SPFEI(SPEI_FALSE_RECOGNITION) | 
                                     SPFEI(SPEI_HYPOTHESIS) | 
                                     SPFEI(SPEI_RECO_STATE_CHANGE) | 
                                     SPFEI(SPEI_INTERFERENCE); 

        hr = m_cpRecoCtxt->SetInterest(ulInterest, ulInterest);
        TraceMsg(TF_SAPI_PERF, "SetInterest is Done, hr=%x", hr);
    }

    if ( SUCCEEDED(hr) && m_cpVoice)
    {
        // set recognition notification
        CComPtr<ISpNotifyTranslator> cpNotify;
        hr = cpNotify.CoCreateInstance(CLSID_SpNotifyTranslator);

        TraceMsg(TF_SAPI_PERF, "Create SpNotifyTranslator for spVoice, hr=%x", hr);

        // set this class instance to notify control object
        if (SUCCEEDED(hr))
        {
            m_pime->_EnsureWorkerWnd();

            hr = cpNotify->InitCallback( SpeakNotifyCallback, 0, (LPARAM)this );
            TraceMsg(TF_SAPI_PERF, "InitCallback for SpVoice, hr=%x", hr);
        }
        if (SUCCEEDED(hr))
        {
            hr = m_cpVoice->SetNotifySink(cpNotify);
            TraceMsg(TF_SAPI_PERF, "SetNotifySink for SpVoice, hr=%x", hr);
        }

        if ( hr == S_OK )
        {
            const ULONGLONG  ulInterestSpeak = SPFEI(SPEI_WORD_BOUNDARY) | 
                                               SPFEI(SPEI_START_INPUT_STREAM) |
                                               SPFEI(SPEI_END_INPUT_STREAM);
            
          hr = m_cpVoice->SetInterest(ulInterestSpeak, ulInterestSpeak);
          TraceMsg(TF_SAPI_PERF, "SetInterest for spVoice, hr=%x", hr);
        }
    }

    m_fCallbackInitialized = TRUE;

    TraceMsg(TF_SAPI_PERF, "CSpTask::InitializeCallback is called is done!!!  hr=%x", hr);

    return hr;
}

//
// _LoadGrammars
//
// synopsis - load CFG for dictation and commands available during dictation
//

HRESULT CSpTask::_LoadGrammars()
{
   HRESULT hr = E_FAIL;

   TraceMsg(TF_SAPI_PERF, "CSpTask::_LoadGrammars is called");
   
   if (m_cpRecoCtxt)
   {
       
       hr = m_cpRecoCtxt->CreateGrammar(GRAM_ID_DICT, &m_cpDictGrammar);

       TraceMsg(TF_SAPI_PERF, "Create Dict Grammar, hr=%x", hr);
       
       if (SUCCEEDED(hr))
       {
           hr = m_cpDictGrammar->LoadDictation(NULL, SPLO_STATIC);
           TraceMsg(TF_SAPI_PERF, "Load Dictation, hr = %x", hr);
       }

       if ( S_OK == hr && m_langid != 0x0804)  // Chinese Engine doesn't support SPTOPIC_SPELLING, 
                                 // This is the temporal workaround.
       {
            // we keep going regardless of availabillity of spelling topic
            // in the SR engine for the language so we use internal HRESULT
            // for this block of code
            //
            HRESULT hrInternal;

            // Load Spelling topic
            hrInternal = m_cpRecoCtxt->CreateGrammar(GRAM_ID_SPELLING, &m_cpSpellingGrammar);

            TraceMsg(TF_SAPI_PERF, "Create Spelling grammar, hrInternal=%x", hrInternal);

            if (SUCCEEDED(hrInternal))
            {
                hrInternal = m_cpSpellingGrammar->LoadDictation(SPTOPIC_SPELLING, SPLO_STATIC);
                TraceMsg(TF_SAPI_PERF, "Load Spelling dictation grammar, hrInternal=%x", hrInternal);
            }

             
            // this is now an experiment for English/Japanese only
            //
            if (SUCCEEDED(hrInternal))
            {
                hrInternal = m_cpSpellingGrammar->LoadCmdFromResource(
                                             g_hInstSpgrmr,
                                             (const WCHAR*)MAKEINTRESOURCE(ID_SPTIP_SPELLING_TOPIC_CFG),
                                             L"SRGRAMMAR", 
                                             m_langid, 
                                             SPLO_STATIC);

                TraceMsg(TF_SAPI_PERF, "Load CFG grammar spell.cfg, hr=%x", hrInternal);

            }

            if (S_OK == hrInternal)
            {
                m_fSpellingModeEnabled = TRUE;
            }
            else
                m_fSpellingModeEnabled = FALSE;

            TraceMsg(TF_SAPI_PERF, "m_fSpellingModeEnabled=%d", m_fSpellingModeEnabled);
       }
       
       //
       // load the dictation mode commands
       //
       if (SUCCEEDED(hr) )
       {
           hr = m_cpRecoCtxt->CreateGrammar(GRAM_ID_CCDICT, &m_cpDictCmdGrammar);
           TraceMsg(TF_SAPI_PERF, "Create DictCmdGrammar, hr=%x", hr);
       }    
       if (S_OK == hr)
       {
           hr = S_FALSE;


           // try resource first because loading cmd from file takes
           // quite long time
           //
           if (m_langid == 0x409 ||    // English
               m_langid == 0x411 ||    // Japanese
               m_langid == 0x804 )     // Simplified Chinese
           {
               hr = m_cpDictCmdGrammar->LoadCmdFromResource(
                                                         g_hInstSpgrmr,
                                                         (const WCHAR*)MAKEINTRESOURCE(ID_SPTIP_DICTATION_COMMAND_CFG),
                                                         L"SRGRAMMAR", 
                                                         m_langid, 
                                                         SPLO_DYNAMIC);

               TraceMsg(TF_SAPI_PERF, "Load dictcmd.cfg, hr=%x", hr);
           }

           if (S_OK != hr)
           {
               // in case if we don't have built-in grammar
               _GetCmdFileName(m_langid);
               if (m_szCmdFile[0])
               {
                   hr = m_cpDictCmdGrammar->LoadCmdFromFile(m_szCmdFile, SPLO_DYNAMIC);
               } 
           }
               
           if (S_OK != hr)
           {
               m_cpDictCmdGrammar.Release();
           }
       } 

       // load shared command grammars

       if (SUCCEEDED(hr) )
       {
           hr = m_cpRecoCtxt->CreateGrammar(GRAM_ID_CMDSHARED, &m_cpSharedGrammarInDict);
           TraceMsg(TF_SAPI_PERF, "Create SharedCmdGrammarInDict, hr=%x", hr);
       }    

       if (S_OK == hr)
       {
           hr = S_FALSE;

           if (m_langid == 0x409 ||    // English
               m_langid == 0x411 ||    // Japanese
               m_langid == 0x804 )     // Simplified Chinese
           {
               hr = m_cpSharedGrammarInDict->LoadCmdFromResource(
                                                         g_hInstSpgrmr,
                                                         (const WCHAR*)MAKEINTRESOURCE(ID_SPTIP_SHAREDCMD_CFG),
                                                         L"SRGRAMMAR", 
                                                         m_langid, 
                                                         SPLO_DYNAMIC);

               TraceMsg(TF_SAPI_PERF, "Load Shrdcmd.cfg, hr=%x", hr);
           }

           if (S_OK != hr)
           {
               // in case if we don't have built-in grammar
               // it provides a way for customer to localize their grammars in different languages
               _GetCmdFileName(m_langid);
               if (m_szShrdCmdFile[0])
               {
                   hr = m_cpSharedGrammarInDict->LoadCmdFromFile(m_szShrdCmdFile, SPLO_DYNAMIC);
               } 
           }

           if (S_OK != hr)
           {
               m_cpSharedGrammarInDict.Release();
           }
           else if ( PRIMARYLANGID(m_langid) == LANG_ENGLISH  ||
                     PRIMARYLANGID(m_langid) == LANG_JAPANESE ||
                     PRIMARYLANGID(m_langid) == LANG_CHINESE)
           { 
              // means this language's grammar support Textbuffer commands.
              m_fSelectionEnabled = TRUE;   
           }

       } 
       
       //
       //  load mode bias grammars
       //
       if (S_OK == hr)
       {
           hr = m_cpRecoCtxt->CreateGrammar(GRID_INTEGER_STANDALONE, &m_cpNumModeGrammar);
           TraceMsg(TF_SAPI_PERF, "Create NumModeGrammar, hr=%x", hr);
       }
       if (S_OK == hr)
       {
           hr = S_FALSE;

           
           // try resource first because loading cmd from file takes
           // quite long time
           //
           if ( m_langid == 0x409        // English
                || m_langid == 0x411     // Japanese
                || m_langid == 0x804     // Simplified Chinese
              )    
           {
                hr = m_cpNumModeGrammar->LoadCmdFromResource(
                                            g_hInstSpgrmr,
                                            (const WCHAR*)MAKEINTRESOURCE(ID_SPTIP_NUMMODE_COMMAND_CFG),
                                            L"SRGRAMMAR", 
                                            m_langid,  
                                            SPLO_DYNAMIC);

                TraceMsg(TF_SAPI_PERF, "Load dictnum.cfg, hr=%x", hr);
           }

           if (S_OK != hr)
           {
               // in case if we don't have buit-in grammar
               //
               if (m_szNumModeCmdFile[0])
               {
                   hr = m_cpNumModeGrammar->LoadCmdFromFile(m_szNumModeCmdFile, SPLO_DYNAMIC);
               }
           }

           if (S_OK != hr)
           {
               m_cpNumModeGrammar.Release();
           }
       }
   }

   // By default, Activate all the grammars and Disable the context for Perfomance.

    if ( SUCCEEDED(hr) )
    {
        hr = m_cpRecoCtxt->SetContextState(SPCS_DISABLED);
        m_fDictCtxtEnabled = FALSE;
    }

    // Activate Dictation and spell.

    if ( SUCCEEDED(hr) )
    {
        hr = _ActiveDictOrSpell(DC_Dictation, TRUE);

        if ( hr == S_OK )
            hr = _ActiveDictOrSpell(DC_Dict_Spell, TRUE);
    }

    // Automatically active all rules in C&C grammars.

    if ( SUCCEEDED(hr) )
    {
        if ( m_pime->_AllDictCmdsDisabled( ) )
        {
           hr = _ActivateCmdInDictMode(FALSE);

           // Still needs to activate spelling grammar if it exists.
           if ( hr == S_OK )
               hr = _ActiveCategoryCmds(DC_CC_Spelling, TRUE, ACTIVE_IN_DICTATION_MODE);

           // Needs to activate "Force Num" grammar in dication strong mode.
           if ( hr == S_OK )
               hr = _ActiveCategoryCmds(DC_CC_Num_Mode, TRUE, ACTIVE_IN_DICTATION_MODE);

            if ( hr == S_OK )
                hr = _ActiveCategoryCmds(DC_CC_LangBar, m_pime->_LanguageBarCmdEnabled( ), ACTIVE_IN_DICTATION_MODE);
        }
        else
        {
            if ( m_pime->_AllCmdsEnabled( ) )
                hr = _ActivateCmdInDictMode(TRUE);
            else
            {
                // Some category commands are disabled.
                // active them individually.

                hr = _ActiveCategoryCmds(DC_CC_SelectCorrect, m_pime->_SelectCorrectCmdEnabled( ), ACTIVE_IN_DICTATION_MODE);

                if ( hr == S_OK )
                    hr = _ActiveCategoryCmds(DC_CC_Navigation, m_pime->_NavigationCmdEnabled( ), ACTIVE_IN_DICTATION_MODE);

                if ( hr == S_OK )
                    hr = _ActiveCategoryCmds(DC_CC_Casing, m_pime->_CasingCmdEnabled( ), ACTIVE_IN_DICTATION_MODE);

                if ( hr == S_OK )
                    hr = _ActiveCategoryCmds(DC_CC_Editing, m_pime->_EditingCmdEnabled( ), ACTIVE_IN_DICTATION_MODE);

                if ( hr == S_OK )
                    hr = _ActiveCategoryCmds(DC_CC_Keyboard, m_pime->_KeyboardCmdEnabled( ), ACTIVE_IN_DICTATION_MODE);

                if ( hr == S_OK )
                    hr = _ActiveCategoryCmds(DC_CC_TTS, m_pime->_TTSCmdEnabled( ), ACTIVE_IN_DICTATION_MODE);

                if ( hr == S_OK )
                    hr = _ActiveCategoryCmds(DC_CC_LangBar, m_pime->_LanguageBarCmdEnabled( ), ACTIVE_IN_DICTATION_MODE);

                if ( hr == S_OK )
                    hr = _ActiveCategoryCmds(DC_CC_Num_Mode, TRUE, ACTIVE_IN_DICTATION_MODE);

                if ( hr == S_OK )
                    hr = _ActiveCategoryCmds(DC_CC_Spelling, TRUE, ACTIVE_IN_DICTATION_MODE);
            }
        }
    }

    // we don't fail even if C&C grammars are not available

    TraceMsg(TF_SAPI_PERF, "CSpTask::_LoadGrammars is done!!!!");
    return S_OK;
}

WCHAR * CSpTask::_GetCmdFileName(LANGID langid)
{

    if (!m_szCmdFile[0])
    {
        _GetCmdFileName(langid, m_szCmdFile, ARRAYSIZE(m_szCmdFile), IDS_CMD_FILE);
    }

    // load the name of shared commands grammar
    if (!m_szShrdCmdFile[0])
    {
        _GetCmdFileName(langid, m_szShrdCmdFile, ARRAYSIZE(m_szShrdCmdFile), IDS_SHARDCMD_FILE);
    }

    // load the name of optional grammar
    if (!m_szNumModeCmdFile[0])
    {
        _GetCmdFileName(langid, m_szNumModeCmdFile, ARRAYSIZE(m_szNumModeCmdFile), IDS_NUMMODE_CMD_FILE );
    }
    
    return m_szCmdFile;
}

void CSpTask::_GetCmdFileName(LANGID langid, WCHAR *sz, int cch, DWORD dwId)
{
/*
    // now we only have a command file for English/Japanese
    // when cfgs are available, we'll get the name of cmd file
    // and the rule names from resources using findresourceex
    //
    if ((PRIMARYLANGID(langid) == LANG_ENGLISH)
        || (PRIMARYLANGID(langid) == LANG_JAPANESE)
        || (PRIMARYLANGID(langid) == LANG_CHINESE))
    {

// To supply customers a way to localize their grammars in different languages,
// we don't want the above condition check.
*/
        char szFilePath[MAX_PATH];
        char *pszFileName;
        char szCp[MAX_PATH];
        int  ilen;

        if (!GetModuleFileName(g_hInst, szFilePath, ARRAYSIZE(szFilePath)))
            return;
        
        // is this dbcs safe?
        pszFileName = strrchr(szFilePath, (int)'\\');
        
        if (pszFileName)
        {
            pszFileName++;
            *pszFileName = '\0';
        }
        else
        {
            szFilePath[0] = '\\';
            szFilePath[1] = '\0';
            pszFileName = &szFilePath[1];
        }

        ilen = lstrlen(szFilePath);
        
        CicLoadStringA(g_hInst, dwId, pszFileName, ARRAYSIZE(szFilePath)-ilen);
                
        if (GetLocaleInfo(langid, LOCALE_IDEFAULTANSICODEPAGE, szCp, ARRAYSIZE(szCp))>0)
        {
            int iACP = atoi(szCp); 
        
            MultiByteToWideChar(iACP, NULL, szFilePath, -1, sz, cch);
        }
//    }
}

void CSpTask::_ReleaseSAPI(void)
{
    // - release data or memory from recognition context
    // - release interfaces if they are not defined as CComPtr
    _UnloadGrammars();

    m_cpResMgr.Release();

    if ( m_cpVoice)
        m_cpVoice->SetNotifySink(NULL);

    m_cpVoice.Release();

    if (m_cpRecoCtxt)
        m_cpRecoCtxt->SetNotifySink(NULL);

    if ( m_cpRecoCtxtForCmd )
        m_cpRecoCtxtForCmd->SetNotifySink(NULL);

#ifdef RECOSLEEP
    if ( m_pSleepClass )
    {
        delete m_pSleepClass;
        m_pSleepClass = NULL;
    }
#endif

    m_cpRecoCtxt.Release();
    m_cpRecoCtxtForCmd.Release();
    m_cpRecoEngine.Release();
    m_fSapiInitialized  = FALSE;
}

HRESULT CSpTask::_SetAudioRetainStatus(BOOL fRetain)
{
    HRESULT hr = E_FAIL;
    // FutureConsider: support the data format
    if (m_cpRecoCtxt)
        hr = m_cpRecoCtxt->SetAudioOptions(fRetain?SPAO_RETAIN_AUDIO: SPAO_NONE, NULL, NULL);

    if (m_cpRecoCtxtForCmd)
       hr = m_cpRecoCtxtForCmd->SetAudioOptions(fRetain?SPAO_RETAIN_AUDIO: SPAO_NONE, NULL, NULL);
   
    return hr;
}

HRESULT CSpTask::_SetRecognizerInterest(ULONGLONG ulInterest)
{
    HRESULT  hr = S_OK;

    if ( m_cpRecoCtxt )
    {
        hr = m_cpRecoCtxt->SetInterest(ulInterest, ulInterest);
    }

    return hr;
}
//
//
// Activate all the command grammas in Dictation mode. 
//
// By default we want to set SPRS_ACTIVE to all the command grammar rules
// in dictation mode unless user disables some of commands through dictation 
// property page. 
// 
// Please note:  Only when all the commands are enabled, this function is called.
//
// otherwise,
//
// When some of the commands are disabled, we should active individual cateogry commands by
// calling _ActiveCategoryCmds( ).
// 
HRESULT CSpTask::_ActivateCmdInDictMode(BOOL fActive)
{
    HRESULT hr = E_FAIL;
    BOOL    fRealActive = fActive;

    TraceMsg(TF_SAPI_PERF, "CSpTask::_ActivateCmdInDictMode is called, fActive=%d", fActive);

    if (m_cpRecoCtxt)
    { 
        // Automatically active or inactive all rules in grammar.

        // Rules in Dictcmd.cfg

        if ( m_cpDictCmdGrammar )
        {
            hr = m_cpDictCmdGrammar->SetRuleState(c_szDictTBRule,  NULL, fRealActive? SPRS_ACTIVE: SPRS_INACTIVE);
            TraceMsg(TF_SAPI_PERF, "Set rules status in DictCmdGrammar, fRealActive=%d", fRealActive);
        }

        // Rules in Sharedcmd.cfg

        if ( m_cpSharedGrammarInDict )
        {
            hr = m_cpSharedGrammarInDict->SetRuleState(NULL,  NULL, fRealActive? SPRS_ACTIVE: SPRS_INACTIVE);
            TraceMsg(TF_SAPI_PERF, "Set rules status in SharedCmdGrammar In Dictation Mode, fRealActive=%d", fRealActive);
        }

        // Rules in ITN grammar

        if ( hr == S_OK && m_cpNumModeGrammar )
        {
            hr = m_cpNumModeGrammar->SetRuleState(NULL,  NULL, fRealActive? SPRS_ACTIVE: SPRS_INACTIVE);
            TraceMsg(TF_SAPI_PERF, "Set rules status in m_cpNumModeGrammar, fRealActive=%d", fRealActive);
        }

        // Rules in Spell grammar

        if ( m_cpSpellingGrammar )
        {
            hr = m_cpSpellingGrammar->SetRuleState(NULL,  NULL, fRealActive? SPRS_ACTIVE: SPRS_INACTIVE);
            TraceMsg(TF_SAPI_PERF, "Set rules status in m_cpSpellingGrammar, fRealActive=%d", fRealActive);
        }
    }
    
    TraceMsg(TF_SAPI_PERF, "Exit from CSpTask::_ActivateCmdInDictMode");

    return hr;
}

//
// Active commands by category.
//
// Some commands are dictation mode only such as "spell that" and Number mode commands.
// some others are available in both modes, 
//
// When some category commands are disabled, caller must call this function instead of
// _ActivateCmdInDictMode to set individual category commands.
//
HRESULT CSpTask::_ActiveCategoryCmds(DICT_CATCMD_ID  dcId, BOOL fActive, DWORD   dwMode)
{
    HRESULT  hr = S_OK;
    BOOL     fActiveDictMode, fActiveCommandMode;

    if ( dcId >= DC_Max )  return E_INVALIDARG;

    if (m_fIn_Activate)
        return hr;

    fActiveDictMode = (m_cpRecoCtxt && (dwMode & ACTIVE_IN_DICTATION_MODE) ) ? TRUE : FALSE;

    if ( m_cpRecoCtxtForCmd  && m_cpSharedGrammarInVoiceCmd && ( dwMode & ACTIVE_IN_COMMAND_MODE) )
        fActiveCommandMode = TRUE;
    else
        fActiveCommandMode = FALSE;

    m_fIn_Activate = TRUE;

    switch (dcId)
    {
    case DC_CC_SelectCorrect :

        // This category includes below rules in different grammars.
        //
        // shrdcmd.xml:
        //      selword, SelectThrough, SelectSimpleCmds,
        //
        // dictcmd.xml:
        //      commands
        //

        TraceMsg(TF_SAPI_PERF, "DC_CC_SelectCorrect status: %d, mode=%d", fActive, dwMode);

        if ( fActiveDictMode)
        {
            // for dictation mode
            if ( m_cpSharedGrammarInDict )
            {
                hr = m_cpSharedGrammarInDict->SetRuleState(c_szSelword,  NULL, fActive? SPRS_ACTIVE: SPRS_INACTIVE);

                if ( hr == S_OK )
                    hr = m_cpSharedGrammarInDict->SetRuleState(c_szSelThrough,  NULL, fActive? SPRS_ACTIVE: SPRS_INACTIVE);

                if ( hr == S_OK )
                    hr = m_cpSharedGrammarInDict->SetRuleState(c_szSelectSimple,  NULL, fActive? SPRS_ACTIVE: SPRS_INACTIVE);
            }
        }

        if ( (hr == S_OK) && fActiveCommandMode ) 
        {
            // for voice command mode
            hr = m_cpSharedGrammarInVoiceCmd->SetRuleState(c_szSelword,  NULL, fActive? SPRS_ACTIVE: SPRS_INACTIVE);

            if ( hr == S_OK )
                hr = m_cpSharedGrammarInVoiceCmd->SetRuleState(c_szSelThrough,  NULL, fActive? SPRS_ACTIVE: SPRS_INACTIVE);

            if ( hr == S_OK )
                hr = m_cpSharedGrammarInVoiceCmd->SetRuleState(c_szSelectSimple,  NULL, fActive? SPRS_ACTIVE: SPRS_INACTIVE);
        }

        break;

    case DC_CC_Navigation :

        // This category includes rule NavigationCmds in shrdcmd.xml
        // 

        TraceMsg(TF_SAPI_PERF, "DC_CC_Navigation status: %d, mode=%d", fActive, dwMode);

        if ( fActiveDictMode && m_cpSharedGrammarInDict)
        {
            // for dictation mode
            hr = m_cpSharedGrammarInDict->SetRuleState(c_szNavigationCmds,  NULL, fActive? SPRS_ACTIVE: SPRS_INACTIVE);
        }

        if ( (hr == S_OK) && fActiveCommandMode ) 
        {
            // for voice command mode
            hr = m_cpSharedGrammarInVoiceCmd->SetRuleState(c_szNavigationCmds,  NULL, fActive? SPRS_ACTIVE: SPRS_INACTIVE);
        }
        
        break;

    case DC_CC_Casing :

        // This category includes rule CasingCmds in shrdcmd.xml
        TraceMsg(TF_SAPI_PERF, "DC_CC_Casing status: %d, mode=%d", fActive, dwMode);

        if ( fActiveDictMode && m_cpSharedGrammarInDict )
        {
            // for dictation mode
            hr = m_cpSharedGrammarInDict->SetRuleState(c_szCasingCmds,  NULL, fActive? SPRS_ACTIVE: SPRS_INACTIVE);
        }

        if ( (hr == S_OK) && fActiveCommandMode) 
        {
            // for voice command mode
            hr = m_cpSharedGrammarInVoiceCmd->SetRuleState(c_szCasingCmds,  NULL, fActive? SPRS_ACTIVE: SPRS_INACTIVE);
        }

        break;

    case DC_CC_Editing :

        // This category includes rule EditCmds in shrdcmd.xml
        TraceMsg(TF_SAPI_PERF, "DC_CC_Editing status: %d, mode=%d", fActive, dwMode);

        if ( fActiveDictMode && m_cpSharedGrammarInDict)
        {
            // for dictation mode
            hr = m_cpSharedGrammarInDict->SetRuleState(c_szEditCmds,  NULL, fActive? SPRS_ACTIVE: SPRS_INACTIVE);
        }

        if ( (hr == S_OK) && fActiveCommandMode) 
        {
            // for voice command mode
            hr = m_cpSharedGrammarInVoiceCmd->SetRuleState(c_szEditCmds,  NULL, fActive? SPRS_ACTIVE: SPRS_INACTIVE);
        }

        break;

    case DC_CC_Keyboard :

        // This category includes rule KeyboardCmds in shrdcmd.xml
        TraceMsg(TF_SAPI_PERF, "DC_CC_Keyboard status: %d, mode=%d", fActive, dwMode);

        if ( fActiveDictMode && m_cpSharedGrammarInDict)
        {
            // for dictation mode
            hr = m_cpSharedGrammarInDict->SetRuleState(c_szKeyboardCmds,  NULL, fActive? SPRS_ACTIVE: SPRS_INACTIVE);
        }

        if ( (hr == S_OK) && fActiveCommandMode) 
        {
            // for voice command mode
            hr = m_cpSharedGrammarInVoiceCmd->SetRuleState(c_szKeyboardCmds,  NULL, fActive? SPRS_ACTIVE: SPRS_INACTIVE);
        }

        break;

    case DC_CC_TTS :

        // The rule for this category is not implemented yet!!!

        break;

    case DC_CC_LangBar :

        // This category includes rule ToolbarCmd in dictcmd.xml for dictation mode.
        // for voice command mode, it is a dynamical rule.
        //

        TraceMsg(TF_SAPI_PERF, "DC_CC_LangBar status: %d, mode=%d", fActive, dwMode);

        if ( fActiveDictMode && m_cpDictCmdGrammar)
        {
            // for dictation mode
            hr = m_cpDictCmdGrammar->SetRuleState(c_szDictTBRule,  NULL, fActive? SPRS_ACTIVE: SPRS_INACTIVE);
        }

        if ( (hr == S_OK) && fActiveCommandMode ) 
        {
            // for voice command mode
            // Change toolbar grammar status if it has already been built.
            if (m_pLangBarSink && m_pLangBarSink->_IsTBGrammarBuiltOut( ))
                m_pLangBarSink->_ActivateGrammar(fActive);
        }

        break;

    case DC_CC_Num_Mode        :
        
        if (fActiveDictMode && m_cpNumModeGrammar)
        {
            hr = m_cpNumModeGrammar->SetRuleState(NULL,  NULL, fActive ? SPRS_ACTIVE: SPRS_INACTIVE);
            TraceMsg(TF_SAPI_PERF, "CC Number rule status changed to %d", fActive);
        }
        break;

    case DC_CC_UrlHistory :
        
        if (fActiveDictMode && m_cpDictCmdGrammar)
        {
            hr = m_cpDictCmdGrammar->SetRuleState(c_szStaticUrlHist,  NULL, fActive ? SPRS_ACTIVE: SPRS_INACTIVE);
            if (S_OK == hr)
                hr = m_cpDictCmdGrammar->SetRuleState(c_szDynUrlHist,  NULL, fActive ? SPRS_ACTIVE: SPRS_INACTIVE);
            
            if (S_OK == hr && m_cpUrlSpellingGrammar)
            {
                 hr = m_cpUrlSpellingGrammar->SetRuleState(c_szStaticUrlSpell, NULL, fActive ? SPRS_ACTIVE: SPRS_INACTIVE);

            }
        }
        break;

    case DC_CC_Spelling :

        if ( fActiveDictMode && m_cpSpellingGrammar )
        {
            hr = m_cpSpellingGrammar->SetRuleState(NULL,  NULL, fActive? SPRS_ACTIVE: SPRS_INACTIVE);
            TraceMsg(TF_SAPI_PERF, "Set rules status in m_cpSpellingGrammar, fActive=%d", fActive);
        }
        break;
    }

    m_fIn_Activate = FALSE;

    return hr;
}


// Set the status for Dictation grammar or spelling grammar In Dictation mode only.
HRESULT CSpTask::_ActiveDictOrSpell(DICT_CATCMD_ID  dcId, BOOL fActive)
{
    HRESULT  hr = S_OK;

    if ( dcId >= DC_Max )  return E_INVALIDARG;

    if (m_fIn_Activate)
        return hr;

    m_fIn_Activate = TRUE;

    switch (dcId)
    {
        case DC_Dictation       :   
            if (m_cpDictGrammar) 
            {
                hr = m_cpDictGrammar->SetDictationState(fActive ? SPRS_ACTIVE : SPRS_INACTIVE);
                TraceMsg(TF_SAPI_PERF, "Dictation status changed to %d", fActive);
            }
            break;
        case DC_Dict_Spell      :
            if (m_cpSpellingGrammar)
            {
                hr = _SetSpellingGrammarStatus(fActive);
                TraceMsg(TF_SAPI_PERF, "Dict Spell status changed to %d", fActive);
            }
            break;
    }

    m_fIn_Activate = FALSE;

    return hr;
}

HRESULT CSpTask::_SetSpellingGrammarStatus( BOOL fActive, BOOL fForce)
{
    HRESULT  hr = S_OK;

    TraceMsg(TF_GENERAL, "_SetSpellingGrammarStatus is called, fActive=%d, m_fSelectStatus=%d",fActive, m_fSelectStatus);

 
    if ( m_cpSpellingGrammar )
    {
        // if dictation is previously deactivated because of 'force' spelling
        // we need to reactivate the dictation grammar
        if (m_fDictationDeactivated)
        {
             hr = _ActiveDictOrSpell(DC_Dictation, TRUE);
             if (S_OK == hr)
             {
                 m_fDictationDeactivated =  FALSE;
             }
         }

        //  if this is 'force' mode, we deactivate dictation for the moment
        if (fForce)
        {
            hr = _ActiveDictOrSpell(DC_Dictation, FALSE);
            if (S_OK == hr)
            {
               m_fDictationDeactivated =  TRUE;
            }
        }

        if ( (m_fSelectStatus || fForce) && fActive) // It is not empty 
            hr = m_cpSpellingGrammar->SetDictationState(SPRS_ACTIVE);
        else
            hr = m_cpSpellingGrammar->SetDictationState(SPRS_INACTIVE);
        
    }

    return hr;
}

HRESULT CSpTask::_AddUrlPartsToGrammar(STATURL *pStat)
{
    Assert(pStat);

    // get a url broken down to pieces
    if (!pStat->pwcsUrl)
        return S_FALSE;

    WCHAR *pch = pStat->pwcsUrl;
    
    const WCHAR c_szHttpSlash2[] = L"http://";

    // skip the prefixed http: stuff because we've already added it by now
    if (_wcsnicmp(pch, c_szHttpSlash2, ARRAYSIZE(c_szHttpSlash2)-1) == 0)
        pch += ARRAYSIZE(c_szHttpSlash2)-1;

    WCHAR *pchWord = pch;
    HRESULT hr = S_OK;

    // an assumption 1) people speak the first portion of URL www.microsoft.com 
    // as a sentence

    WCHAR *pchUrl = pch;      // points either biggining of url or 
                              // right after 'http://' add the first part 
    BOOL  fUrlAdded = FALSE;  // of url that is between after this and '/'

    while(S_OK == hr && *pch)
    {
        if (*pch == L'/')
        {
            if (!fUrlAdded)
            {
                if( pch - pchUrl > 1)
                {
                    WCHAR ch = *pch;
                    *pch = L'\0'; 

                    SPPROPERTYINFO pi = {0};
                    pi.pszValue = pchUrl;
                    hr = m_cpDictCmdGrammar->AddWordTransition(m_hRuleUrlHist, NULL, pchUrl, L".", SPWT_LEXICAL, (float)1, &pi);
                    *pch = ch;
                }
                fUrlAdded = TRUE;
            }
            else
            {
                *pch = L'\0'; 

                break;
            }
        }

        if (*pch == L'.' || *pch == L'/' || *pch == L'?' || *pch == '=' || *pch =='&')
        {
            WCHAR ch = *pch;

            *pch = L'\0';

            // reject 1 character parts
            if (pch - pchWord > 1)
            {
                SPPROPERTYINFO pi = {0};
                pi.pszValue = pchWord; 

                if (wcscmp(c_szWWW, pchWord) != 0 && wcscmp(c_szCom, pchWord) != 0)
                {
                    // a few words can possibly return 'ambiguity' errors
                    // we need to ignore it and continue. so we're not checking
                    // the return here.
                    //
                    m_cpDictCmdGrammar->AddWordTransition(m_hRuleUrlHist, NULL, pchWord, L" ", SPWT_LEXICAL, (float)1, &pi);
                }
            }
            *pch = ch;

            pchWord = pch + 1;
        }
        pch++;
    }

    // add the last part of URL
    if (S_OK == hr && *pchWord && pch - pchWord > 1)
    {
        SPPROPERTYINFO pi = {0};
        pi.pszValue = pchWord; 
        hr = m_cpDictCmdGrammar->AddWordTransition(m_hRuleUrlHist, NULL, pchWord, L" ", SPWT_LEXICAL, (float)1, &pi);
    }
    // add the first part of url if we haven't yet
    if (S_OK == hr && !fUrlAdded && pch - pchUrl > 1)
    {
       SPPROPERTYINFO pi = {0};
       pi.pszValue = pchUrl;
       hr = m_cpDictCmdGrammar->AddWordTransition(m_hRuleUrlHist, NULL, pchUrl, L".", SPWT_LEXICAL, (float)1, &pi);
    }

    return hr;
}

BOOL CSpTask::_EnsureModeBiasGrammar()
{
    HRESULT hr = S_OK;

    if ( m_cpDictCmdGrammar )
    {
        // Check if the grammar has a static rule UrlSpelling
        SPSTATEHANDLE hRuleUrlSpell = 0;
        hr = m_cpDictCmdGrammar->GetRule(c_szStaticUrlSpell, 0, SPRAF_TopLevel|SPRAF_Active, FALSE, &hRuleUrlSpell);

        if ( !hRuleUrlSpell )
            return FALSE;
    }

    // ensure spelling LM
    if (!m_cpUrlSpellingGrammar)
    {
        CComPtr<ISpRecoGrammar> cpUrlSpelling;
        hr = m_cpRecoCtxt->CreateGrammar(GRAM_ID_URLSPELL, &cpUrlSpelling);

        // load dictation with spelling topic
        if (S_OK == hr)
        {
            hr = cpUrlSpelling->LoadDictation(SPTOPIC_SPELLING, SPLO_STATIC);
        }

        // load the 'rule' for the free form dictation
        if (S_OK == hr)
        {
            // i'm sharing the command cfg here for spelling with dictation
            // command for simplicity
            //
            hr = cpUrlSpelling->LoadCmdFromResource( g_hInstSpgrmr,
                                    (const WCHAR*)MAKEINTRESOURCE(ID_SPTIP_DICTATION_COMMAND_CFG),
                                    L"SRGRAMMAR", 
                                    m_langid, 
                                    SPLO_STATIC);
        }

        if (S_OK == hr)
        {
            m_cpUrlSpellingGrammar = cpUrlSpelling; // add the ref count
        }
    }

    if (m_hRuleUrlHist)
    {
        hr = m_cpDictCmdGrammar->ClearRule(m_hRuleUrlHist);
        m_hRuleUrlHist = 0;
    }

    if (S_OK == hr)
        hr = m_cpDictCmdGrammar->GetRule(c_szDynUrlHist, 0, SPRAF_TopLevel|SPRAF_Active|SPRAF_Dynamic, TRUE, &m_hRuleUrlHist);
    

    // first add basic parts for URL
    CComPtr<IUrlHistoryStg> cpUrlHistStg;
    if (S_OK == hr)
    {   
        hr = CoCreateInstance(CLSID_CUrlHistory, NULL, CLSCTX_INPROC_SERVER, IID_IUrlHistoryStg, (void **)&cpUrlHistStg);
    }

    CComPtr<IEnumSTATURL> cpEnumUrl;
    if (S_OK == hr)
    {
        hr = cpUrlHistStg->EnumUrls(&cpEnumUrl);
    }

    if (S_OK == hr)
    {
        int i = 0;
        STATURL stat;
        stat.cbSize = SIZEOF(stat.cbSize);
        while(i < 10 && S_OK == hr && cpEnumUrl->Next(1, &stat, NULL)==S_OK && stat.pwcsUrl)
        { 
            hr = _AddUrlPartsToGrammar(&stat);
            i++;
        }
    }

    if (S_OK == hr)
    {   
        hr = m_cpDictCmdGrammar->Commit(0);
    }

    return (S_OK == hr) ? TRUE : FALSE;
}

HRESULT CSpTask::_SetModeBias(BOOL fActive, REFGUID rGuid)
{
    HRESULT hr = S_OK;
    BOOL    fKillDictation = FALSE;

    if (m_fIn_SetModeBias)
        return E_FAIL;

    m_fIn_SetModeBias = TRUE;
    if (m_cpDictGrammar)
    {
        fKillDictation = !m_pime->_IsModeBiasDictationEnabled();
        if (fActive)
        {
            BOOL fUrlHistory = FALSE;

            if (IsEqualGUID(GUID_MODEBIAS_URLHISTORY, rGuid)
                || IsEqualGUID(GUID_MODEBIAS_FILENAME, rGuid))
                fUrlHistory = TRUE;


            // first deactivate rules when we are not setting them
            if (!fUrlHistory && m_fUrlHistoryMode)
            {
                hr = _ActiveCategoryCmds(DC_CC_UrlHistory, FALSE, ACTIVE_IN_DICTATION_MODE);
            }

            // this check with m_fUrlHistoryMode is preventing us from updating url dynamic grammar
            // when mic is re-opened. we think removing this won't cause much perf degredation.
            //
            if (fUrlHistory /* && !m_fUrlHistoryMode */)
            {
                if (m_cpDictCmdGrammar && m_pime->GetDICTATIONSTAT_DictOnOff() && _EnsureModeBiasGrammar())
                {
                    hr = _ActiveCategoryCmds(DC_CC_UrlHistory, TRUE, ACTIVE_IN_DICTATION_MODE);                    
                }
                else
                    fUrlHistory = FALSE;

                if (fUrlHistory)
                {
                    fKillDictation = TRUE;
                }
            }

            // sync the global status
            m_fUrlHistoryMode = fUrlHistory;
        }
        else
        {
            // reset all modebias
            if (m_fUrlHistoryMode)
                _ActiveCategoryCmds(DC_CC_UrlHistory, FALSE, ACTIVE_IN_DICTATION_MODE);
        }
    

        // kill dictation grammar when mode requires it
        // we should activate dictation only when deactivating
        // the modebias grammar *and* when we are the focus
        // thread because we've already deactivated dictation
        // when focus switched away
        //
        if (/* !fActive && */
            m_cpDictGrammar && 
            m_pime->GetDICTATIONSTAT_DictOnOff() && 
            S_OK == m_pime->IsActiveThread())
        {
#ifdef _DEBUG_
            TCHAR szModule[MAX_PATH];
            GetModuleFileName(NULL, szModule, ARRAYSIZE(szModule));

            TraceMsg(TF_GENERAL, "%s : CSpTask::_SetModeBias() - Turning Dictation grammar %s", szModule, fKillDictation ? "Off" : "On");
#endif
            if (!fActive && fKillDictation)
            {
                fKillDictation = FALSE;
            } 

            hr = _ActiveDictOrSpell(DC_Dictation, fKillDictation ? SPRS_INACTIVE : SPRS_ACTIVE);
        }
    }    
    m_fIn_SetModeBias = FALSE;
    return hr;
}

void CSpTask::_SetInputOnOffState(BOOL fOn)
{
    TraceMsg(TF_GENERAL, "_SetInputOnOffState is called, fOn=%d", fOn);

    if (m_fIn_SetInputOnOffState)
        return;

    m_fIn_SetInputOnOffState = TRUE;

    // here we make sure we erase feedback UI 

    // We only adjust these if we are the active thread. Otherwise leave in current state since we either do
    // not have focus or the stage is visible. This maintains our previous behavior where we would not get here
    // if we were not the active thread.
    if (S_OK == m_pime->IsActiveThread())
    {
        if (fOn)
        {
            if (!m_pime->Get_SPEECH_DISABLED_DictationDisabled() && m_pime->GetDICTATIONSTAT_DictOnOff())
                _SetDictRecoCtxtState(TRUE);

            if ( !m_pime->Get_SPEECH_DISABLED_CommandingDisabled( ) && m_pime->GetDICTATIONSTAT_CommandingOnOff( ) )
                _SetCmdRecoCtxtState(TRUE);
        }
        else
        {
            _SetDictRecoCtxtState(FALSE);
            _SetCmdRecoCtxtState(FALSE);
            _StopInput();
        }
    }

    // Regardless of focus / stage visibility, we need to turn on the engine if necessary here since there
    // may be *no* speech tip with focus to do this. This means we may have multiple tips turning the reco
    // state on / off simultaneously.
    if(m_cpRecoEngine)
    {
        m_fInputState = fOn;

        if ( _GetInputOnOffState( ) != fOn )
        {
            TraceMsg(TF_GENERAL, "Call SetRecoState, %s", fOn ? "SPRST_ACTIVE" : "SPRST_INACTIVE");

            m_cpRecoEngine->SetRecoState(fOn ? SPRST_ACTIVE : SPRST_INACTIVE);
        }

        // DO NOT ADD DEBUGGING CODE HERE TO PRINT OUT STATE - CAN BLOCK CICERO RESULTING
        // IN DIFFERENT BEHAVIOR TO THE RELEASE VERSION.
    }

    m_fIn_SetInputOnOffState = FALSE;
}

BOOL CSpTask::_GetInputOnOffState(void)
{
    BOOL fRet = FALSE;

    if(m_cpRecoEngine)
    {
        SPRECOSTATE srs;
        
        m_cpRecoEngine->GetRecoState(&srs);

        if (srs == SPRST_ACTIVE)
        {
            fRet = TRUE;  // on
        }
        else if (srs == SPRST_INACTIVE)
        {
            fRet = FALSE;  // off
        }
        // anything else is 'off'
    }
    return fRet;
}

HRESULT CSpTask::_StopInput(void)
{
    HRESULT hr = S_OK;

    TraceMsg(TF_SAPI_PERF, "_StopInput is called");

    if (!m_bInSound && m_pime->GetDICTATIONSTAT_DictOnOff()) 
    {
        TraceMsg(TF_SAPI_PERF, "m_bInSound is FALSE, GetDICTATIONSTAT_DictOnOff returns TRUE");

        return S_OK;
    }

    m_pime->EraseFeedbackUI();

    _ShowDictatingToBalloon(FALSE);

	return S_OK;
}

//    _ClearQueuedRecoEvent(void)
//
//    synopsis: get rid of remaining events from reco context's 
//              event queue. This is only called from _StopInput()
//              when TerminateComposition() is called, or Mic is
//              turned off
//
//
void  CSpTask::_ClearQueuedRecoEvent(void)
{
    if (m_cpRecoCtxt)
    {
        SPEVENTSOURCEINFO esi;

        if (S_OK == m_cpRecoCtxt->GetInfo(&esi))
        {
            ULONG ulcount = esi.ulCount;
            CSpEvent event;
            while(ulcount > 0)
            {
                if (S_OK == event.GetFrom(m_cpRecoCtxt))
                {
                    event.Clear();
                }
                ulcount--;
            }
        }
    }
}

// CSpTask::GetResltObjectFromStream()
//
// synopsis - a wrapper function that takes a stream ptr to a SAPI result blob
//            and gets alternates out of the object
//
HRESULT CSpTask::GetResultObjectFromStream(IStream *pStream, ISpRecoResult **ppResult)
{
    LARGE_INTEGER li0 = {0, 0};
    HRESULT hr = E_INVALIDARG;
    SPSERIALIZEDRESULT *pPhraseBlob = 0;
    
    if (pStream)
    {
        hr = pStream->Seek(li0, STREAM_SEEK_SET, NULL);

        STATSTG stg;
        if (hr == S_OK)
        {
            hr = pStream->Stat(&stg, STATFLAG_NONAME);
        }
        if (SUCCEEDED(hr))
            pPhraseBlob = (SPSERIALIZEDRESULT *)CoTaskMemAlloc(stg.cbSize.LowPart+sizeof(ULONG)*4);

        if (pPhraseBlob)
            hr = pStream->Read(pPhraseBlob, stg.cbSize.LowPart, NULL);
        else
            hr = E_OUTOFMEMORY;

        if (SUCCEEDED(hr))
        {
            ISpRecoResult *pResult;

            if (SUCCEEDED(m_cpRecoCtxt->DeserializeResult(pPhraseBlob, &pResult)) && pResult)
            {
                if (ppResult)
                {
                    pResult->AddRef();
                    *ppResult = pResult;
                }
                pResult->Release();
            }
        }
    }
    
    return hr;
}

//
// GetAlternates
//
HRESULT CSpTask::GetAlternates(CRecoResultWrap *pResultWrap, ULONG ulStartElem, ULONG ulcElem, ISpPhraseAlt **ppAlt, ULONG *pcAlt, ISpRecoResult **ppRecoResult)
{
    HRESULT hr = E_INVALIDARG;

    if (m_fIn_GetAlternates)
        return E_FAIL;
    
    m_fIn_GetAlternates = TRUE;

    Assert(pResultWrap);
    Assert(ppAlt);
    Assert(pcAlt);
    
    hr = pResultWrap->GetResult(ppRecoResult);
    
    if (S_OK == hr && *ppRecoResult)
    {
    
        hr = (*ppRecoResult)->GetAlternates(
                    ulStartElem, 
                    ulcElem, 
                    *pcAlt, 
                    ppAlt, /* [out] ISpPhraseAlt **ppPhrases, */
                    pcAlt /* [out] ULONG *pcPhrasesReturned */
                    );
    }
    
    m_fIn_GetAlternates = FALSE;
    return hr;
}


HRESULT CSpTask::_SpeakText(WCHAR *pwsz)
{
    HRESULT hr = E_FAIL;

    if (m_cpVoice)
       hr = m_cpVoice->Speak( pwsz, /* SPF_DEFAULT */ SPF_ASYNC /* | SPF_PURGEBEFORESPEAK*/, NULL );

    return hr;
}

HRESULT CSpTask::_SpeakAudio( ISpStreamFormat *pStream )
{
    HRESULT hr = E_FAIL;

    if ( !pStream )
       return E_INVALIDARG;

    if (m_cpVoice)
       hr = m_cpVoice->SpeakStream(pStream, SPF_ASYNC, NULL); 

    return hr;
}

void CSapiIMX::RegisterWorkerClass(HINSTANCE hInstance)
{
    WNDCLASSEX  wndclass;

    memset(&wndclass, 0, sizeof(wndclass));
    wndclass.cbSize        = sizeof(wndclass);
    wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
    wndclass.hInstance     = hInstance;
    wndclass.lpfnWndProc   = CSapiIMX::_WndProc;
    wndclass.lpszClassName = c_szWorkerWndClass;
    wndclass.cbWndExtra    = 8;
    RegisterClassEx(&wndclass);
}

//
// ParseSRElementByLocale
//
// Parse SR result elements in locale specific mannar
//
// dependency caution: this function has to be rewritten when SAPI5 changes
//                     SR element format, which is very likely
//
// 12/15/99          : As of SAPI1214, an element now includes display text,
//                     lexical form, pronunciation separately. this function
//                     takes the display text at szSrc.
//                     langid parameter is not used at this moment
//
HRESULT CSpTask::ParseSRElementByLocale(WCHAR *szDst, int cchDst, const WCHAR * szSrc, LANGID langid, BYTE bAttr)
{
    if (!szDst || !szSrc || !cchDst)
    {
        return E_INVALIDARG;
    }

    // handle leading space.
    if (bAttr & SPAF_CONSUME_LEADING_SPACES)
    {
        const WCHAR *psz = szSrc;
        while(*psz && *psz == L' ')
        {
            psz++;
        }
        szSrc = psz;
    }
    
    wcsncpy(szDst, szSrc, cchDst - 2); // -2 for possible sp

    // handle trailing space
    if (bAttr & SPAF_ONE_TRAILING_SPACE)
    {
        StringCchCatW(szDst, cchDst,  L" ");
    }
    else if (bAttr & SPAF_TWO_TRAILING_SPACES)
    {
        StringCchCatW(szDst,cchDst, L"  ");
    }

    return S_OK;
}


//
// FeedDictContext
//
// synopsis: feed the text surrounding the current IP to SR engine
//
void CSpTask::FeedDictContext(CDictContext *pdc)
{
    Assert(pdc);
    if (!m_pime->_GetWorkerWnd())
    {
        delete pdc;
        return ;
    }
    
    // wait until the current feeding is done
    // it's not efficient to feed IP everytime user
    // click around
    if (m_pdc)
    {
        delete pdc;
        return;
    }

    if (!m_cpDictGrammar)
    {
        delete pdc;
        return;
    }

    // remove unprocessed messages from the queue
    // FutureConsider: this could be moved to wndproc so that
    //         we can remove this private msg at the
    //         moment we process it. It depends on 
    //         profiling we'll do.
    //
    MSG msg;
    while(PeekMessage(&msg, m_pime->_GetWorkerWnd(), WM_PRIV_FEEDCONTEXT, WM_PRIV_FEEDCONTEXT, TRUE))
        ;
   
   // queue up the context
   m_pdc = pdc;
   PostMessage(m_pime->_GetWorkerWnd(), WM_PRIV_FEEDCONTEXT, 0, (LPARAM)TRUE);
}

void CSpTask::CleanupDictContext(void)
{
    if (m_pdc)
        delete m_pdc;

    m_pdc = NULL;
}

// _UpdateBalloon(  )

void CSpTask::_UpdateBalloon(ULONG  uidBalloon,  ULONG  uidBalloonTooltip)
{
    WCHAR wszBalloonText[MAX_PATH] = {0};
    WCHAR wszBalloonTooltip[MAX_PATH] = {0};

#ifndef RECOSLEEP
    if (!m_pime->GetSpeechUIServer())
#else
    if (!m_pime->GetSpeechUIServer() || IsInSleep( ))
#endif
        return;

    CicLoadStringWrapW(g_hInst, uidBalloon, wszBalloonText, ARRAYSIZE(wszBalloonText));
    CicLoadStringWrapW(g_hInst, uidBalloonTooltip, wszBalloonTooltip, ARRAYSIZE(wszBalloonTooltip));

    if (wszBalloonText[0] && wszBalloonTooltip[0])
    {
        m_pime->GetSpeechUIServer()->UpdateBalloonAndTooltip(TF_LB_BALLOON_RECO, 
                                                             wszBalloonText, -1, 
                                                             wszBalloonTooltip, -1 );
    }

    return;
}

//
// ShowDictatingToBalloon
//
//
void CSpTask::_ShowDictatingToBalloon(BOOL fShow)
{
#ifndef RECOSLEEP
    if (!m_pime->GetSpeechUIServer())
#else
    if (!m_pime->GetSpeechUIServer() || IsInSleep( ))
#endif
        return;

    static WCHAR s_szDictating[MAX_PATH] = {0};
    static WCHAR s_szDictatingTooltip[MAX_PATH] = {0};

    if (!s_szDictating[0])
    {
        CicLoadStringWrapW(g_hInst, IDS_DICTATING,
                                    s_szDictating,
                                    ARRAYSIZE(s_szDictating));
    }
    if (!s_szDictatingTooltip[0])
    {
         CicLoadStringWrapW(g_hInst,  IDS_DICTATING_TOOLTIP,
                                      s_szDictatingTooltip,
                                      ARRAYSIZE(s_szDictatingTooltip));
    }

    if (fShow && s_szDictating[0] && s_szDictatingTooltip[0])
    {
        m_pime->GetSpeechUIServer()->UpdateBalloonAndTooltip(TF_LB_BALLOON_RECO, s_szDictating, -1, s_szDictatingTooltip, -1 );
    }
    else if (!fShow)
    {
        m_pime->GetSpeechUIServer()->UpdateBalloonAndTooltip(TF_LB_BALLOON_RECO, L" ", -1, L" ", -1 );
    }
}
//
// _HandleInterference
//
// synopsis: bubble up reco errors to the balloon UI
//
//
void CSpTask::_HandleInterference(ULONG lParam)
{
    if (!m_pime->GetSpeechUIServer())
        return;

    WCHAR sz[MAX_PATH];
    WCHAR szTooltip[MAX_PATH];
    
    if (S_OK == 
       _GetLocSRErrorString((SPINTERFERENCE)lParam, 
                            sz, ARRAYSIZE(sz),
                            szTooltip, ARRAYSIZE(szTooltip)))
    {
        m_pime->GetSpeechUIServer()->UpdateBalloonAndTooltip(TF_LB_BALLOON_RECO, sz, -1, szTooltip, -1 );
    }
}

HRESULT CSpTask::_GetLocSRErrorString
(
    SPINTERFERENCE sif, 
    WCHAR *psz, ULONG cch,
    WCHAR *pszTooltip, ULONG cchTooltip
)
{
    HRESULT hr = E_FAIL;

    static struct
    {
        ULONG uidRes;
        WCHAR szErr[MAX_PATH];
        ULONG uidResTooltip;
        WCHAR szTooltip[MAX_PATH];
    } rgIntStr[] =
    {
        {IDS_INT_NONE, {0}, IDS_INTTOOLTIP_NONE, {0}},
        {IDS_INT_NOISE, {0}, IDS_INTTOOLTIP_NOISE, {0}},
        {IDS_INT_NOSIGNAL, {0}, IDS_INTTOOLTIP_NOSIGNAL, {0}},
        {IDS_INT_TOOLOUD, {0}, IDS_INTTOOLTIP_TOOLOUD, {0}},
        {IDS_INT_TOOQUIET, {0}, IDS_INTTOOLTIP_TOOQUIET, {0}},
        {IDS_INT_TOOFAST, {0}, IDS_INTTOOLTIP_TOOFAST, {0}},
        {IDS_INT_TOOSLOW, {0}, IDS_INTTOOLTIP_TOOSLOW, {0}}
    };
    
    if ((ULONG)sif < ARRAYSIZE(rgIntStr)-1)
    {
        if (!rgIntStr[sif].szErr[0])
        {
            hr = CicLoadStringWrapW(g_hInst,
                                    rgIntStr[sif].uidRes,
                                    rgIntStr[sif].szErr,
                                    ARRAYSIZE(rgIntStr[0].szErr)) > 0 ? S_OK : E_FAIL;
            if (S_OK == hr)
            {
                hr = CicLoadStringWrapW(g_hInst,
                                        rgIntStr[sif].uidResTooltip,
                                        rgIntStr[sif].szTooltip,
                                        ARRAYSIZE(rgIntStr[0].szTooltip)) > 0 ? S_OK : E_FAIL;
            }
        }
        else
            hr = S_OK; // the value is cached
    }
    if (S_OK == hr)
    {
        Assert(psz);
        wcsncpy(psz, rgIntStr[sif].szErr, cch);

        Assert(pszTooltip);
        wcsncpy(pszTooltip, rgIntStr[sif].szTooltip, cchTooltip);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\sapilayr.h ===
//
// sapilayr.h
//
#ifndef SAPILAYR_H
#define SAPILAYR_H

#include "private.h"
#include "globals.h"
#include "tes.h"
#include "mes.h"
#include "ids.h"
#include "cicspres.h"
#include "playback.h"
#include "fnrecon.h"
#include "dap.h"
#include "mscandui.h"
#include "strary.h"
#include "sink.h"
#include "computil.h"
#include "mscandui.h"
#include "syslbar.h"
#include "lbarsink.h"
#include "ats.h"
#include "cleanup.h"
#include "cutil.h"
#include "miscfunc.h"
#include "learndoc.h"
#include "adddelete.h"
#include "selword.h"
#include "tts.h"
#include "correct.h"
#include "capital.h"
#include "immxutil.h"
#include "citn.h"
#include "lpns.h"
#include "editsess.h"
#ifdef RECOSLEEP
#include "RecoSleep.h"
#endif
#include "nui.h"

#include "keyevent.h"
#include "SpBtnCtrl.h"
#include "PropItem.h"
#include "icpriv.h"
#include "correctionimx.h"
#include "urlhist.h"


#ifdef DEBUG
#define TEST_SHARED_ENGINE
#endif

// SAPI5.0 speech notification interface
//
//     this class must be derived from ISpClass defined in sapi.h
//     ISpNotifyControl object takes this class object to callback 
//
class CSptipKeyEventSink;
class CThreadMgrEventSink;
class CSapiIMX;
class CICPriv;
class CRecoResultWrap;
class CDictContext;
class CLangProfileUtil;
class CFnConfigure;
class CLearnFromDoc;
class CAddDeleteWord;
class CSelectWord;
class CTextToSpeech;
class CCorrectionHandler;
class CCapCmdHandler;
class CSapiEditSession;
#ifdef RECOSLEEP
class CRecoSleepClass;
#endif
class SpButtonControl;

class CSpPropItemsServerWrap;
class CCandUIExtBtnHandler;

typedef enum 
{
    DC_Dictation        =  0,
    DC_Dict_Spell       =  1,
    DC_CC_SelectCorrect =  2,
    DC_CC_Navigation    =  3,
    DC_CC_Casing        =  4,
    DC_CC_Editing       =  5,
    DC_CC_Keyboard      =  6,
    DC_CC_TTS           =  7,
    DC_CC_LangBar       =  8,
    DC_CC_Num_Mode      =  9,
    DC_CC_Spelling      = 10,
    DC_CC_UrlHistory    = 11,
    DC_Max              = 12
} DICT_CATCMD_ID;

//
//  used by CSpTask::_ActiveCategoryCmds to indicate which mode's grammars status to be changed
//
#define    ACTIVE_IN_DICTATION_MODE    0x0001
#define    ACTIVE_IN_COMMAND_MODE      0x0002
#define    ACTIVE_IN_BOTH_MODES        0x0003

class CSpTask // : public IUnknown
{
public:
    CSpTask(CSapiIMX *pime);
    ~CSpTask(void);


    // ISpNotifyCallback
    static void NotifyCallback( WPARAM wParam, LPARAM lParam );
    static void NotifyCallbackForCmd(WPARAM wParam, LPARAM lParam );
    static void SpeakNotifyCallback( WPARAM wParam, LPARAM lParam );

    void   SharedRecoNotify(ISpRecoContext *pRecoCtxt);

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    HRESULT InitializeSAPIObjects(LANGID langid);
    HRESULT InitializeCallback();

    HRESULT CSpTask::InitializeSAPIForCmd( );
    
    HRESULT GetSAPIInterface(REFIID riid, void ** ppobj);
    HRESULT GetRecoContextForCommand(ISpRecoContext **ppRecoCtxt);

    void _ReleaseSAPI(void);

    HRESULT _SetAudioRetainStatus(BOOL fRetain);
    HRESULT _ActivateCmdInDictMode(BOOL fActive);
    HRESULT _ActiveDictOrSpell(DICT_CATCMD_ID  drId, BOOL fActive);
    HRESULT _ActiveCategoryCmds(DICT_CATCMD_ID  drId, BOOL fActive, DWORD   dwMode);

    HRESULT _SpeakText(WCHAR  *pwsz);
    HRESULT _SpeakAudio(ISpStreamFormat *pStream);
    HRESULT _LoadGrammars(void);
    HRESULT _GetLocaleInfo(LANGID *plangid);
    HRESULT GetResultObjectFromStream(IStream *pStream, ISpRecoResult **ppResult);
    HRESULT GetAlternates(CRecoResultWrap *pResultWrap, ULONG ulStartElem, ULONG ulcElem, ISpPhraseAlt **ppAlt, ULONG *pcAlt, ISpRecoResult **ppResult);
    
    HRESULT ParseSRElementByLocale(WCHAR *szDst, int cchDst, const WCHAR * szSrc, LANGID langid, BYTE bAttr);
    
    HRESULT _OnSpEventRecognition(ISpRecoResult *pResult, ITfContext *pic, TfEditCookie ec);
    HRESULT _DoCommand(ULONGLONG ullGramId, SPPHRASE *pPhrase, LANGID langid);
    HRESULT _HandleDictCmdGrammar(SPPHRASE *pPhrase, LANGID langid);
    HRESULT _HandleShardCmdGrammar(SPPHRASE *pPhrase, LANGID langid);
//    HRESULT _HandleNumModeGrammar(SPPHRASE *pPhrase, LANGID langid);
    HRESULT _HandleToolBarGrammar(SPPHRASE *pPhrase, LANGID langid);
    HRESULT _HandleNumITNGrammar(SPPHRASE *pPhrase, LANGID langid);
    HRESULT _HandleSpellGrammar(SPPHRASE *pPhrase, LANGID langid);

    HRESULT _HandleCasingCmds(SPPHRASE *pPhrase, LANGID langid, ULONG idCmd);
    HRESULT _HandleNavigationCmds(SPPHRASE *pPhrase, LANGID langid, ULONG idCmd);
    HRESULT _HandleSelwordCmds(SPPHRASE *pPhrase, LANGID langid, ULONG idCmd);
    HRESULT _HandleSelectThroughCmds(SPPHRASE *pPhrase, LANGID langid, ULONG idCmd);
    HRESULT _HandleSelectSimpleCmds(ULONG idCmd);
    HRESULT _HandleKeyboardCmds(LANGID langid, ULONG idCmd);

    HRESULT _HandleModeBiasCmd(SPPHRASE *pPhrase, LANGID langid);


    void    _ShowCommandOnBalloon(SPPHRASE *pPhrase);

    WCHAR *_GetCmdFileName(LANGID langid);
    void _GetCmdFileName(LANGID langid, WCHAR *sz, int cch, DWORD dwId);
    
    // method to sync to SAPI's own mic status
    void   _SetInputOnOffState(BOOL fOn);
    BOOL   _GetInputOnOffState(void);

    HRESULT _StopInput(void);
    void    _ClearQueuedRecoEvent(void);
    LANGID  _GetPreferredEngineLanguage(LANGID langid);
    HRESULT _SetVoice(LANGID langid);
    HRESULT _AddUrlPartsToGrammar(STATURL *pStat);
    BOOL    _EnsureModeBiasGrammar();
    HRESULT _SetModeBias(BOOL fActive, REFGUID refGuid);
    HRESULT _SetRecognizerInterest(ULONGLONG ulInterest);
    
    // toolbar command functions
    void _InitToolbarCommand(BOOL fLangOverride)
    {
        TraceMsg(TF_SAPI_PERF, "_InitToolbarCommand is called, fLangOverride=%d", fLangOverride);

        // initialize langbar sink for C&C
        if (!m_pLangBarSink)
        {
            if (CLangBarSink *plbs = new CLangBarSink(this))
            {
                if (S_OK == plbs->Init())
                {
                    if (fLangOverride)
                    {
//                        plbs->OnSetFocus(0);
                    }
                    m_pLangBarSink = plbs;
                }
                else
                   plbs->Release();
            }
        }
    }

    void _UnInitToolbarCommand()
    {
        TraceMsg(TF_SAPI_PERF, "_UnInitToolbarCommand is called");

        if (m_pLangBarSink)
        {
            m_pLangBarSink->Uninit();
        }
        SafeReleaseClear(m_pLangBarSink);
    }

    void _UnloadGrammars()
    {
        m_cpDictGrammar.Release();
        m_cpSpellingGrammar.Release();
        if ( m_cpDictCmdGrammar )
            m_cpDictCmdGrammar->ClearRule(m_hRuleUrlHist);
        m_cpDictCmdGrammar.Release();
        m_cpNumModeGrammar.Release();
        m_cpSharedGrammarInDict.Release();
        m_cpSharedGrammarInVoiceCmd.Release();
    }
    
    HRESULT _GetTextFromResult(ISpRecoResult *pResult, LANGID langid, CSpDynamicString &dstr);
    BOOL _DoesSelectionHaveMatchingText(WCHAR *psz, TfEditCookie ec);
    BOOL _IsSelectionInMiddleOfWord(TfEditCookie ec);
    BOOL _GetNextBestHypothesis(ISpRecoResult *pResult, ULONG ntheHypothesis, ULONG *pulNumElements,  
                                LANGID langid,  WCHAR *pszBest,  CSpDynamicString & dsNext, TfEditCookie ec);
                                
    BOOL _IsRangeEmpty(TfEditCookie ec, ITfRange *prange)
    {
        BOOL fEmpty;
        Assert(prange);
        if (S_OK != prange->IsEmpty(ec, &fEmpty))
        {
            fEmpty = FALSE;
        }
        return fEmpty;
    }

    HRESULT _EnsureSimpleITN(void)
    {
        if (m_pITNFunc)
            return S_OK;

        m_pITNFunc = new CSimpleITN(m_langid);

        return m_pITNFunc == NULL ? E_OUTOFMEMORY: S_OK;
    }

    HRESULT   _SetDictRecoCtxtState( BOOL  fEnable );
    HRESULT   _SetCmdRecoCtxtState( BOOL fEnable );
    
    void FeedDictContext(CDictContext *pdc);
    void CleanupDictContext(void);

    void _HandleInterference(ULONG lparam);
    void _ShowDictatingToBalloon(BOOL fShow);
    void _UpdateBalloon(ULONG  uidBalloon,  ULONG  uidBalloonTooltip);

    HRESULT _GetLocSRErrorString ( SPINTERFERENCE sif,  WCHAR *psz, ULONG cch, WCHAR *pszTooltip, ULONG cchTooltip );
    
    LANGID  _GetCurrentLangID(void) { return m_langid; }
    CSapiIMX *GetTip(void)          { return m_pime; }


    BOOL   _GetSelectionStatus( ) { return m_fSelectStatus; }
    void   _SetSelectionStatus( BOOL  fSelection)  {  m_fSelectStatus = fSelection; }

    HRESULT _SetSpellingGrammarStatus(BOOL fActive, BOOL fForce = FALSE);

    BOOL   _IsCallbackInitialized(void) { return m_fCallbackInitialized;}

    HRESULT  _UpdateTextBuffer(ISpRecoContext *pRecoCtxt);
    BOOL     _IsSelectionEnabled( )  { return m_fSelectionEnabled; }

    HRESULT  _UpdateSelectGramTextBufWhenStatusChanged(  );

    ISpVoice *_GetSpVoice( )  { return m_cpVoice; }

    BOOL     _GotReco(void) { return m_bGotReco; }

#ifdef RECOSLEEP
    void     InitSleepClass( );
    BOOL     IsInSleep( );
#endif

    HCURSOR m_hOrgCur;

    // langbar event sink class instance
    CLangBarSink               *m_pLangBarSink;

    // used for context feed
    CDictContext               *m_pdc;

    CComPtr<ISpRecoGrammar>     m_cpDictGrammar;
    CComPtr<ISpRecoGrammar>     m_cpSpellingGrammar;
    CComPtr<ISpRecoGrammar>     m_cpUrlSpellingGrammar;
private:
    // SAPI 50 object pointers
    CComPtr<ISpResourceManager> m_cpResMgr;
    CComPtr<ISpRecoContext>     m_cpRecoCtxt;
    CComPtr<ISpRecoContext>     m_cpRecoCtxtForCmd;
    CComPtr<ISpRecognizer>      m_cpRecoEngine;
    CComPtr<ISpVoice>           m_cpVoice;
    CComPtr<ISpRecoGrammar>     m_cpDictCmdGrammar;
    CComPtr<ISpRecoGrammar>     m_cpSharedGrammarInDict;
    CComPtr<ISpRecoGrammar>     m_cpSharedGrammarInVoiceCmd;
    CComPtr<ISpRecoGrammar>     m_cpNumModeGrammar;

#ifdef RECOSLEEP
    CRecoSleepClass            *m_pSleepClass;
#endif
    
    // TRUE if sapi is initialized
    BOOL m_fSapiInitialized;
    BOOL m_fCallbackInitialized;

    // this is TRUE once dictation grammar is activated
    BOOL m_fDictationReady;
    BOOL m_fInputState;
    
    // other data members
    BOOL m_bInSound;
    BOOL m_bGotReco; 

    // M2 SAPI workaround
    BOOL m_fIn_Activate;
    BOOL m_fIn_SetModeBias;
    BOOL m_fIn_GetAlternates;
    BOOL m_fIn_SetInputOnOffState;

    // modebias stuff
    BOOL m_fUrlHistoryMode;
    SPSTATEHANDLE                  m_hRuleUrlHist;

    // save the current user langid for the fallback case
    LANGID m_langid;

    // Sapi TFX object
    CSapiIMX *m_pime;
    
    WCHAR m_szCmdFile[MAX_PATH];
    WCHAR m_szNumModeCmdFile[MAX_PATH];
    WCHAR m_szShrdCmdFile[MAX_PATH];

    CSimpleITN   *m_pITNFunc;
    BOOL         m_fSelectStatus;      // FALSE means empty  (IP).
                                       // TRUE means selected. ( real Selection )
    BOOL          m_fDictationDeactivated;
    BOOL          m_fSpellingModeEnabled;

    BOOL          m_fSelectionEnabled;
    BOOL          m_fDictationInitialized;

    // Status (Enable or Disable) of RecoContexts.
    BOOL          m_fDictCtxtEnabled;
    BOOL          m_fCmdCtxtEnabled;

    BOOL          m_fTestedForOldMicrosoftEngine;
    BOOL          m_fOldMicrosoftEngine;

    DWORD  m_cRef;
};
const DWORD LANGSTAT_OVERRIDDEN = 0x1;

#define MAX_CHARS_FOR_BEYONDSPACE  20

//
// TIP object definition for SAPI layer
//

class CSapiIMX :        public ITfTextInputProcessor,
                        public ITfCreatePropertyStore,
                        public ITfThreadFocusSink,
                        public ITfFunctionProvider,
                        public ITfCompositionSink,
                        public ITfKeyTraceEventSink,
                        public CDisplayAttributeProvider,
                        public ICleanupContextsClient,
                        public CComObjectRoot_CreateInstance<CSapiIMX>,
                        public CLangProfileUtil,
                        public CFnConfigure,
                        public CLearnFromDoc,
                        public CAddDeleteWord,
                        public CSelectWord,
                        public CTextToSpeech,
                        public CCorrectionHandler,
                        public CColorUtil,
                        public CSpPropItemsServerWrap
{
public:
    CSapiIMX();
    ~CSapiIMX();

    BEGIN_COM_MAP_IMMX(CSapiIMX)
        COM_INTERFACE_ENTRY(ITfTextInputProcessor)
        COM_INTERFACE_ENTRY(ITfCreatePropertyStore)
        COM_INTERFACE_ENTRY(ITfDisplayAttributeProvider)
        COM_INTERFACE_ENTRY(ITfFunctionProvider)
        COM_INTERFACE_ENTRY(ITfThreadFocusSink)
        COM_INTERFACE_ENTRY(ITfCompositionSink)
        COM_INTERFACE_ENTRY(ITfKeyTraceEventSink)
        COM_INTERFACE_ENTRY(ITfFnLangProfileUtil)
        COM_INTERFACE_ENTRY(ITfFnConfigure)
    END_COM_MAP_IMMX()

    ITfThreadMgr *_tim;

    // ITfTextInputProcessor methods
    STDMETHODIMP Activate(ITfThreadMgr *ptim, TfClientId tid);
    STDMETHODIMP Deactivate();

    // ITfThreadFocusSink
    STDMETHODIMP OnSetThreadFocus();
    STDMETHODIMP OnKillThreadFocus();

    // ITfCreatePropertyStore methods
    STDMETHODIMP IsStoreSerializable(REFGUID guidProp, 
                                    ITfRange *pRange, 
                                    ITfPropertyStore *pPropStore, 
                                    BOOL *pfSerializable);
    STDMETHODIMP CreatePropertyStore(REFGUID guidProp, 
                                     ITfRange *pRange, 
                                     ULONG cb, 
                                     IStream *pStream, 
                                     ITfPropertyStore **ppStore);
    
    // ITfFunctionProvider methods
    STDMETHODIMP GetType(GUID *pguid);
    STDMETHODIMP GetDescription(BSTR *pbstrDesc);
    STDMETHODIMP GetFunction(REFGUID rguid, REFIID riid, IUnknown **ppunk);

    // ITfCompositionSink
    STDMETHODIMP OnCompositionTerminated(TfEditCookie ecWrite, ITfComposition *pComposition);

    // ITfKeyTraceEventSink
    STDMETHODIMP OnKeyTraceDown(WPARAM wParam,LPARAM lParam);
    STDMETHODIMP OnKeyTraceUp(WPARAM wParam,LPARAM lParam);

    // ICleanupContextsClient
    HRESULT IsInterestedInContext(ITfContext *pic, BOOL *pfInterested);
    HRESULT CleanupContext(TfEditCookie ecWrite, ITfContext *pic);

    // a public method called from ISpTask
    HRESULT InjectSpelledText(WCHAR *pwszText, LANGID langid, BOOL fOwnerId = FALSE);
    HRESULT InjectText(const WCHAR *pwszRecognized, LANGID langid, ITfContext *pic = NULL);
    HRESULT InjectTextWithoutOwnerID(const WCHAR *pwszRecognized, LANGID langid);
    HRESULT InjectModebiasText(const WCHAR *pwszRecognized, LANGID langid);
    HRESULT InjectFeedbackUI(const GUID attr, LONG cch);
    HRESULT EraseFeedbackUI();
    HRESULT AttachResult(ISpRecoResult *pResult, ULONG ulStartElement, ULONG ulNumElements);
    HRESULT HandleSpaces(ISpRecoResult *pResult, ULONG ulStartElement, ULONG ulNumElements, ITfRange *pTextRange, LANGID langid);
    
    HRESULT EraseLastPhrase(void);
    HRESULT ProcessControlKeys(WCHAR *pwszKeys, ULONG ulLen, LANGID langid);
    HRESULT ProcessEditCommands(LONG  idSharedCmd);
    HRESULT ProcessSpellThat( );
    HRESULT ProcessSpellIt(WCHAR *pwszText, LANGID langid);

    BOOL  HandleModeKeyEvent(DWORD   dwModeKey,  BOOL fDown);
    void  HandleModeKeySettingChange(BOOL  fSetttingChanged );

    BOOL fDeactivated(void) { return _fDeactivated; }

    // called from CAudioPlayBack
    HRESULT GetSpeechTask(CSpTask **ppSpTask, BOOL fInit = TRUE) 
    {
        if (fInit == TRUE)
            InitializeSAPI(TRUE);

        if (ppSpTask && (*ppSpTask = m_pCSpTask))
        {
            (*ppSpTask)->AddRef();

            return  S_OK;
        }

        return E_FAIL;
    }
    
    //
    // IsFocusFullAware
    //
    // a global function to detect the current focus is on 
    // Cicero full aware document
    //
    BOOL IsFocusFullAware(ITfThreadMgr *ptim)
    {
        if (m_fStageTip)
        {
            return TRUE;
        }

        DWORD dw = 0;
        // the name the compartment is inappropriate now because this is 
        // maily used for disabling TTS buttons
        if (ptim)
        {
            GetCompartmentDWORD(ptim, GUID_COMPARTMENT_TTS_STATUS, &dw, FALSE);
        }
        return (dw & TF_TTS_BUTTON_ENABLE ?  TRUE : FALSE );
    }

    HRESULT GetFocusDIM(ITfDocumentMgr **ppdim)
    {
        Assert(ppdim);
        *ppdim = NULL;
        if (_tim != NULL)
        {
            _tim->GetFocus(ppdim);
        }
        return *ppdim ? S_OK : E_FAIL;
    }

    BOOL  GetFocusIC(ITfContext **ppic)
    {
        ITfDocumentMgr *pdim = NULL;
        DWORD dwCandOpen = 0;
        HRESULT hr = S_OK;
        Assert(ppic != NULL);
        *ppic = NULL;

        if ( !m_fStageTip )
        {
            // This is not Stage Tip. Handle it as normal.
            hr = GetFocusDIM(&pdim);
        }
        else
        {
            // TABLET PC
            // Special case for Stage TIP

            // No focus DIM - send input to stage instead.
            // NOTE - We are GUARANTEED there is only one document manager for the stage.
            // We can therefore simply grab the first one and it will be the correct one.
            // SIMILARLY, the document manager has only ONE context, so we can simply grab
            // the top one and it will be the correct one.

            if (!m_cpStageDim)
            {
                // m_cpStageDim has not been initialized yet.
                IEnumTfDocumentMgrs *docenum;
                hr = _tim->EnumDocumentMgrs(&docenum);
                if (docenum)
                {
                    ULONG fetched;
                    hr = docenum->Next(1, &m_cpStageDim, &fetched);
                    docenum->Release();
                }
            }
            if (m_cpStageDim)
            {
                pdim = (ITfDocumentMgr *)m_cpStageDim;
                pdim->AddRef();
            }
        }

        if (pdim)
        {
            pdim->GetTop(ppic);

            if (*ppic)
            {
                // If candidate UI context, switch to GetBase() for document IC.
                GetCompartmentDWORD((IUnknown *)(*ppic), GUID_COMPARTMENT_MSCANDIDATEUI_CONTEXT, &dwCandOpen, FALSE);
                if (dwCandOpen)
                {
                    (*ppic)->Release();
                    *ppic = NULL;

                    if ( _AllowDictationWhileCandOpen( ) )
                        pdim->GetBase(ppic);
                }
            }

            pdim->Release();
        }

        return *ppic ? TRUE : FALSE;
    }

    HRESULT _SetFocusToStageIfStage(void);

    ITfCandidateUI *_pCandUIEx;

    void CloseCandUI( )
    {
        if ( _pCandUIEx )
            _pCandUIEx->CloseCandidateUI();
    }

    void ClearCandUI( )
    {
        if (_pCandUIEx)
        {
            // Close the UI if it is open.
            _pCandUIEx->CloseCandidateUI( );

            // And then release the object.
            _pCandUIEx->Release();
            _pCandUIEx = NULL;
        }
    }

    BOOL GetOnOff()
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_OPENCLOSE, &dw, TRUE);
        return dw ? TRUE : FALSE;
    }

    void SetOnOff(BOOL fOn, BOOL fForce = FALSE)
    {
        if (!fForce && fOn == GetOnOff())
            return;

        DWORD dw = fOn ? 1 : 0;
       
        SetCompartmentDWORD(_tid, _tim, GUID_COMPARTMENT_SPEECH_OPENCLOSE, dw, TRUE);
    }
    
    BOOL GetBalloonStatus()
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_UI_STATUS, &dw, TRUE);
        
        return (dw & TF_DISABLE_BALLOON) ? FALSE : TRUE;
        
    }
    void SetBalloonStatus(BOOL fShow, BOOL fForce = FALSE)
    {
        if (!fForce && fShow == GetBalloonStatus())
            return;

        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_UI_STATUS, &dw, TRUE);
        dw &= ~TF_DISABLE_BALLOON;
        dw |= fShow ? 0: TF_DISABLE_BALLOON;
        SetCompartmentDWORD(_tid, _tim, GUID_COMPARTMENT_SPEECH_UI_STATUS, dw, TRUE);
    }

    BOOL GetAudioOnOff()
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SAPI_AUDIO, &dw, FALSE);
        return dw ? TRUE : FALSE;
    }

    void SetAudioOnOff(BOOL fOn)
    {
        if (fOn == GetAudioOnOff())
            return;

        SetCompartmentDWORD(_tid, _tim, GUID_COMPARTMENT_SAPI_AUDIO, fOn ? 0x01 : 0x00, FALSE);
    }

    BOOL GetDICTATIONSTAT_DictEnabled()
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, &dw, FALSE);
        return (dw & TF_DICTATION_ENABLED) ? TRUE : FALSE;
        
    }
    void SetDICTATIONSTAT_DictEnabled(BOOL fEnable)
    {
        Assert(!m_fStageTip || fEnable); // Stage tip instance should never disable dictation.
        if (fEnable == GetDICTATIONSTAT_DictEnabled())
            return;

        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, &dw, FALSE);
        dw &= ~TF_DICTATION_ENABLED;
        dw |= fEnable ? TF_DICTATION_ENABLED : 0;
        SetCompartmentDWORD(_tid, _tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, dw, FALSE);
    }
    
    BOOL   GetDICTATIONSTAT_DictOnOff()
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, &dw, FALSE);
        return (dw & TF_DICTATION_ON) ? TRUE : FALSE;
    }

    void   SetDICTATIONSTAT_DictOnOff(BOOL fOn, BOOL fForce = FALSE)
    {
        if (!fForce && fOn == GetDICTATIONSTAT_DictOnOff())
            return;

        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, &dw, FALSE);
        dw &= ~TF_DICTATION_ON;
        dw |= fOn ? TF_DICTATION_ON : 0;
        SetCompartmentDWORD(_tid, _tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, dw, FALSE);
    }

    BOOL   IsDICTATIONSTAT_CommandingEnable() 
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, &dw, FALSE);
        return (dw & TF_COMMANDING_ENABLED) ? TRUE : FALSE;
    }

    void   SetDICTATIONSTAT_CommandingOnOff(BOOL fOn) 
    {
        DWORD dw;
        HRESULT hr = GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, &dw, FALSE);
        if (S_OK != hr)
            return;

        BOOL fCurrentState = (dw & TF_COMMANDING_ON) ? TRUE : FALSE;

        if (fOn != fCurrentState)
        {
            dw &= ~TF_COMMANDING_ON;
            dw |= fOn ? TF_COMMANDING_ON : 0;
            SetCompartmentDWORD(_tid, _tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, dw, FALSE);
        }
    }

    BOOL   GetDICTATIONSTAT_CommandingOnOff()
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, &dw, FALSE);
        return (dw & TF_COMMANDING_ON) ? TRUE : FALSE;
    }
    
#ifdef TF_DISABLE_SPEECH
    BOOL Get_SPEECH_DISABLED_Disabled()
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_DISABLED, &dw, FALSE);
        return (dw & TF_DISABLE_SPEECH) ? TRUE : FALSE;
    }

    BOOL Get_SPEECH_DISABLED_DictationDisabled()
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_DISABLED, &dw, FALSE);
        return (dw & TF_DISABLE_DICTATION) ? TRUE : FALSE;
    }

    BOOL Get_SPEECH_DISABLED_CommandingDisabled()
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_DISABLED, &dw, FALSE);
        return (dw & TF_DISABLE_COMMANDING) ? TRUE : FALSE;
    }

    DWORD GetDictationStatBackup(void)
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, &dw, FALSE);
        return dw;
    }

    void SetDictationStatAll(DWORD dw)
    {
        SetCompartmentDWORD(_tid, _tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, dw, FALSE);
    }
#endif
    
    BOOL IsSharedReco() {return m_fSharedReco;  }

    LANGID GetLangID()  {return m_langid;}
    
    // worker window stuff
    static LRESULT CALLBACK _WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static void RegisterWorkerClass(HINSTANCE hInstance);
    void     _EnsureWorkerWnd(void);
    HWND    _GetWorkerWnd(void)     { return m_hwndWorker; }
    HWND    _GetAppMainWnd(void);

    HRESULT _ProcessText(TfEditCookie ec, WCHAR *pwszText, LANGID langid, ITfContext *pic);
    HRESULT _RequestEditSession(UINT idEditSession, DWORD dwFlag, ESDATA *pesData=NULL, ITfContext *picCaller=NULL, LONG_PTR *pRetData=NULL, IUnknown **ppRetUnk = NULL);

    TfClientId _GetId() { return _tid; }
    
    ITfRange *GetSavedIP(void) {return m_cpRangeCurIP;}
    
    void SaveIPRange(ITfRange *pRange) 
    {
        m_cpRangeCurIP.Release();
        m_cpRangeCurIP = pRange; // comptr addrefs
    }
    void SaveCurrentIP (TfEditCookie ec, ITfContext *pic);

    HRESULT  _GetCmdThatRange(TfEditCookie ec, ITfContext *pic, ITfRange **ppRange);
    
    HRESULT InitializeSAPI(BOOL fLangOverride);
    HRESULT DeinitializeSAPI();
    void    _ReinitializeSAPI(void);

    HRESULT _FinalizeComposition();
    HRESULT FinalizeAllCompositions( );

    LIBTHREAD *_GetLibTLS()
    {
        return &_libTLS;
    }
    
    HRESULT _GetRangeText(ITfRange *pRange, DWORD dwFlgs, WCHAR *psz, ULONG *pulcch);
    BOOL    _IsRangeEmpty(ITfRange *pRange);
    HRESULT _HandleHypothesis(CSpEvent &event);
    void    _HandleHypothesis(ISpRecoResult *pResult, ITfContext *pic, TfEditCookie ec);
    HRESULT _HandleFalseRecognition(void);
    HRESULT _HandleRecognition(CSpEvent &event, ULONGLONG *pullGramID);
    void    _HandleRecognition(ISpRecoResult *pResult, ITfContext *pic, TfEditCookie ec);
    void    _FeedIPContextToSR(TfEditCookie ecReadOnly, ITfContext *pic, ITfRange *pRange);
    void     _SetCurrentIPtoSR(void);
    HRESULT  _InternalFeedCurrentIPtoSR(TfEditCookie ecReadOnly, ITfContext *pic);

    BOOL    HandleKey(WCHAR ch);

    void _InvokeSpeakerOptions( BOOL  fLaunchFromInputCpl = FALSE);

    BOOL   _GetIPChangeStatus( )  { return m_fIPIsUpdated; }
    void   _SetIPChangeStatus(BOOL fUpdated )  { m_fIPIsUpdated = fUpdated; }

    void   _SetCharTypeTimer(  )  
    { 
        //  if m_dwNumCharTyped is 0, means this is the first time to set this timer, or 
		//  the previous timer has been killed, we need to start another timer.
		//
		//  if m_dwNumCharTyped is larger than 0, means the timer has already been started,
		//  but not yet been killed. we don't need to set the timer again, just increase the
		//  m_dwNumCharTyped.
		//
		//  m_dwNumCharTyped wants to keep the number of key strokes during this timer period.
		//

        if ( m_dwNumCharTyped == 0)
        {
            SetTimer(m_hwndWorker, TIMER_ID_CHARTYPED, 400, NULL);
        }

		m_dwNumCharTyped++;
    }

    void _KillCharTypeTimer( )
    {
        if ( m_dwNumCharTyped )
        {
            KillTimer(m_hwndWorker, TIMER_ID_CHARTYPED);
            m_dwNumCharTyped = 0;
        }
    }

    DWORD  _GetNumCharTyped( )   { return m_dwNumCharTyped; }

    BOOL _AcceptRecoResultTextUpdates()
    {
        return m_fAcceptRecoResultTextUpdates;
    }

    HRESULT _AddFeedbackUI(TfEditCookie ec, ColorType ct, LONG cch);
    void _CheckStartComposition(TfEditCookie ec, ITfRange *pRange);
    HRESULT _FinalizePrevComp(TfEditCookie ec, ITfContext *pic, ITfRange *pRange);

    CCapCmdHandler  *GetCapCmdHandler( ) {
        if ( !m_pCapCmdHandler )
        {
            m_pCapCmdHandler = new CCapCmdHandler(this);
        }

        return m_pCapCmdHandler;
    }

    // TABLETPC
    HRESULT IsActiveThread()
    {
        if (m_fStageTip)
        {
            // To avoid a race condition with no immediately available solution, we are now active only when the stage is visible.
            if (m_fStageVisible)
            {
                return S_OK;
            }
            else
            {
                return S_FALSE;
            }
        }
        else if (m_fStageVisible)
        {
            // Stage is visible. We are always inactive since we are not the stage.
            return S_FALSE;
        }
        else
        {
            // Stage is not visible. We're active if we have focus as normal Cicero.
            BOOL fThreadFocus = FALSE;
            HRESULT hr = S_OK;
            hr = _tim->IsThreadFocus(&fThreadFocus);
            hr = (S_OK == hr) ? ( (fThreadFocus) ? S_OK : S_FALSE ) : hr;
            return hr;
        }
    }

    // TABLETPC
    BOOL IsStageTip(void)
    {
        return m_fStageTip;
    }

    friend CCorrectionHandler;
    friend CCapCmdHandler;
    friend CSapiEditSession;

private:
    HRESULT _ProcessTextInternal(TfEditCookie ec, WCHAR *pwszText, GUID input_attr, LANGID langid, ITfContext *pic, BOOL fPreserveResult, BOOL fSpelling = FALSE);
    HRESULT _ProcessSpelledText(TfEditCookie ec, ITfContext *pic, WCHAR *pwszText, LANGID langid, BOOL fOwnerId = FALSE);
    HRESULT _ProcessModebiasText(TfEditCookie ec, WCHAR *pwszText, LANGID langid, ITfContext *pic);
    HRESULT _ProcessSpelledTextWithOwner(TfEditCookie ec, ITfContext *pic, WCHAR *pwszText, LANGID langid)
            {
                return _ProcessSpelledText(ec, pic, pwszText, langid, TRUE);
            }
    HRESULT _ProcessRecoObject(TfEditCookie ec, ISpRecoResult *pResult, ULONG ulStartElement, ULONG ulNumElements);
    HRESULT _PreserveResult(TfEditCookie ec, ITfRange *pRange, ITfProperty *pProp, CRecoResultWrap **ppRecoWrap, ITfRange **ppPropRange);
    HRESULT _RestoreResult(TfEditCookie ec, ITfRange *pPropRange, ITfProperty *pProp, CRecoResultWrap *pRecoWrap);
    HRESULT _SetFilteringString(TfEditCookie ec, ITfCandidateUI *pCandUI, ITfContext *pic);
    HRESULT _HandleTrainingWiz(void);
    HRESULT _ProcessSpaces(TfEditCookie ec, ITfContext *pic, ITfRange *pTextRange, BOOL  fConsumeLeadSpaces, ULONG ulNumTrailSpace, LANGID langid, BOOL fStartInMidWord=FALSE, BOOL fEndInMidWord=FALSE);
    HRESULT _ProcessLeadingSpaces(TfEditCookie ec, ITfContext *pic, ITfRange *pTextRange, BOOL  fConsumeLeadSpaces, LANGID langid, BOOL fStartInMidWord=FALSE);

    HRESULT _GetSpaceRangeBeyondText(TfEditCookie ec, ITfRange *pTextRange, BOOL fBefore, ITfRange  **ppSpaceRange, BOOL *pfRealTextBeyond = NULL);
    HRESULT _ProcessTrailingSpace(TfEditCookie ec, ITfContext *pic, ITfRange *pTextRange, ULONG ulNumTrailSpace);

    // private utility routines
    HRESULT _FindPropRange(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, ITfRange **ppAttrRange, GUID input_attr, BOOL fExtend = FALSE);
    HRESULT _SetLangID(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, LANGID langid);
    HRESULT _KillFeedbackUI(TfEditCookie ec, ITfContext *pic, ITfRange *pRange);
    HRESULT _KillOrDetectFeedbackUI(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, BOOL * pfDetection);
    HRESULT _DetectFeedbackUI(TfEditCookie ec, ITfContext *pic, ITfRange *pRange);
    HRESULT _KillFocusRange(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, TfClientId tid);
    HRESULT _KillLastPhrase(TfEditCookie ec, ITfContext *pic);
    HRESULT _ProcessControlKeys(TfEditCookie ec, ITfContext *pic, WCHAR *pwszKey, ULONG ulLen, LANGID langid);
    HRESULT _ProcessEditCommands(TfEditCookie ec, ITfContext *pic, LONG  idSharedCmd);
    HRESULT _ProcessSpellThat(TfEditCookie ec, ITfContext *pic);
    HRESULT _ProcessSpellIt(TfEditCookie ec, ITfContext *pic, WCHAR *pwszText, LANGID langid); 

    HRESULT _FinalizeAllCompositions(TfEditCookie ec, ITfContext *pic);

    static BOOL _FindComposition(TfEditCookie ec, ITfContextComposition *picc, ITfRange *pRange, ITfCompositionView **ppCompositionView);
    static void _CleanupCompositionsCallback(TfEditCookie ecWrite, ITfRange *rangeComposition, void *pvPrivate);


    static HRESULT _CompEventSinkCallback(void *pv, REFGUID rguid);
    
    int _FindPrevComp(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfRange **ppRangeOut, GUID input_attr);
    
    // hack up for Office as of  8/20
    HRESULT MakeResultString(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, TfClientId tid, CSpTask *pCSpTask);
    HRESULT AbortString(TfEditCookie ec, ITfContext *pic, CSpTask *pCSpTask);

    // hacks for SAPI objects
    void _ShutDown(BOOL bMode);

    // callback entry point for CTextEventSink
    static HRESULT _TextEventSinkCallback(UINT uCode, void *pv, void *pvData);
    
    static HRESULT _ICCallback(UINT uCode, ITfContext *pic, void *pv);
    static HRESULT _DIMCallback(UINT uCode, ITfDocumentMgr *dim, ITfDocumentMgr * pdimPrevFocus, void *pv);
    static HRESULT _PreKeyCallback(ITfContext *pic, REFGUID rguid, BOOL *pfEaten, void *pv);
    static HRESULT _KeyEventCallback(UINT uCode, ITfContext *pic, WPARAM wParam, LPARAM lParam, BOOL *pfEaten, void *pv);
    static HRESULT _PreKeyEventCallback(ITfContext *pic, REFGUID rguid, BOOL *pfEaten, void *pv);

    BOOL _IsDoubleClick(ULONG uEdge, ULONG uQuadrant, DWORD dwBtnStatus);
    static HRESULT _MouseSinkCallback(ULONG uEdge, ULONG uQuadrant, DWORD dwBtnStatus, BOOL *pfEaten, void *pv);
    HRESULT _HandleMouseSink(TfEditCookie ec, ULONG uEdge, ULONG uBtnStatus, BOOL fDblClick);
    void _DeleteICPriv(CICPriv *priv, ITfContext *pic);
    void _InitICPriv(CICPriv *priv, ITfContext *pic);
    HRESULT _GetSelectionAndStatus(ITfContext *pic, TESENDEDIT *pee, ITfRange **ppRange, BOOL *pfUpdated);
    void HandleTextEvent(ITfContext *pic, TESENDEDIT *pee);
    void SyncWithCurrentModeBias(TfEditCookie ec, ITfRange *pRange, ITfContext *pic);
    HRESULT _SyncModeBiasWithSelection(ITfContext *pic);
    HRESULT _SyncModeBiasWithSelectionCallback(TfEditCookie ec, ITfContext *pic);



    typedef enum 
    {
        MICSTAT_NA  = 0x0,
        MICSTAT_OFF = 0x1,
        MICSTAT_ON  = 0x2
    
    } MIC_STATUS;
    HRESULT _HandleOpenCloseEvent(MIC_STATUS ms = MICSTAT_NA);
    

    // our cicero client id
    TfClientId _tid;

    // set FALSE if we're between Activate/Deactivate calls
    BOOL _fDeactivated;

    // 'in editing' flag
    BOOL _fEditing;

    // current mode bias
    TfGuidAtom _gaModebias;

    CSpTask *m_pCSpTask;

    // Cicero object pointers
    CThreadMgrEventSink *m_timEventSink;
    
    HWND m_hwndWorker;
    
    // compartment (storage) event sink
    CCompartmentEventSink *m_pCes;

public:
    // System lang bar item event sink
    CSystemLBarSink *m_pLBarItemSink;
    static HRESULT _SysLBarCallback(UINT uCode, void *pv, ITfMenu *pMenu, UINT wID);
    CSpeechUIServer *GetSpeechUIServer() {return m_pSpeechUIServer;}
private:
    static HRESULT _ActiveTipNotifySinkCallback(REFCLSID clsid, REFGUID guidProfile, BOOL fActivated, void *pv);
    static HRESULT _LangChangeNotifySinkCallback(BOOL fChanged, LANGID langid, BOOL *pfAccept, void *pv);
    
    BOOL InitializeSpeechButtons();

    void GetSapiCplPath(TCHAR *szCplPath, int cchSizePath);

    // Notify UI
    CSpeechUIServer *m_pSpeechUIServer;
    BOOL  m_fShowBalloon;
    
    CComPtr<ITfLangBarItem>  m_cpMicButton;

#ifdef SUPPORT_INTERNAL_WIDGET
    // widget instance
    CComPtr<ITfTextInputProcessor> m_cpCorrectionUI;
    BOOL                           m_fNoCorrectionUI;
#endif

    // Hotkey event sink
    CSptipKeyEventSink *_pkes;
    DWORD _dwHotKeyCookie[3];

    DWORD _dwThreadFocusCookie;
    DWORD _dwKeyTraceCookie;
    
    // the current saved IP
    CComPtr<ITfRange> m_cpRangeCurIP;
    
    LANGID                                 m_langid;
    
    BOOL               m_fIPIsUpdated;  
                       // Check to see if IP is updated after dictation.

    DWORD              m_dwNumCharTyped;  // Keep the Number of Char typed during the timer period.

                                          // Every time user types a char,we want to temporally disable
                                          // dictation if current dictation mode is on.
                                          //
                                          // After we temporally disable the dication, we need to 
                                          // monitor a period of time to see if the typing or
                                          // editing is finished, and then we can enable dication
                                          // again.

    ULONG              m_ulSimulatedKey;  // Indicates if the key event is simulated by speech tip
                                          // dictation command, such as "Next Line", "Tab", 
                                          // "Next Cell", "Backspace", Space, SpaceBar. etc.
                                          // "Ctrl+C", "Ctrl+V" may contain more keystrokes.
                                          // This member would keep the number of simulated keys.
                                          // If the key is not simulated, this value is 0.

    SpButtonControl    *m_pSpButtonControl;
    BOOL                m_fModeKeyRegistered;
    
    // active input processor notify sink
    // PerfConsider: have this object expose the iface directly instead of allocating a heap object
    CActiveLanguageProfileNotifySink *m_pActiveLanguageProfileNotifySink;
    CLanguageProfileNotifySink       *m_pLanguageChangeNotifySink;

    // mouse stuff
    CMouseSink                       *m_pMouseSink;
    BOOL                              m_fMouseDown;
    ULONG                             m_ichMouseSel;

    ULONG                             m_uLastEdge;
    ULONG                             m_uLastQuadrant;
    LONG                              m_lTimeLastClk;

   
    CCapCmdHandler    *m_pCapCmdHandler; 

    BOOL m_fSharedReco;
    BOOL m_fDictationEnabled;

    BOOL m_fAcceptRecoResultTextUpdates : 1; // set true to preserve reco property data during SetText
    BOOL m_fStartingComposition : 1; // set true when blocked by StartComposition() call

    LIBTHREAD   _libTLS; // tls for the helper library. Since this object is apt threaded,
                         // all members are accessed in a single thread
                         // also, cicero will only create a single instance of this obj per thread
    TCHAR  m_szCplPath[MAX_PATH];

    // TABLETPC
    BOOL m_fStageTip;
    BOOL m_fStageVisible;
    HWND m_hwndStage;
    CComPtr<ITfDocumentMgr>    m_cpStageDim;
    ULONG                      m_ulHypothesisLen;
    ULONG                      m_ulHypothesisNum;

    BOOL                       m_IsInHypoProcessing;


    long _cRef;
};
// defines maximum # of alternates to get for candidate
#define MAX_NUM_ALTERNATES                48

#define LATER_FOR_BUG1001

#endif // SAPILAYR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\selword.cpp ===
//
//
// Sapilayr TIP CSelectWord implementation.
//
//
#include "private.h"
#include "sapilayr.h"
#include "selword.h"

// ----------------------------------------------------------------------------------------------------------
//
//  Implementation for CSearchString
//
// -----------------------------------------------------------------------------------------------------------

CSearchString::CSearchString( )
{
    m_pwszTextSrchFrom = NULL;
    m_langid = 0;
    m_fInitialized = FALSE;
}

CSearchString::~CSearchString( )
{
}

//
//  Initialize
//  
//  Initialize searched string and string to search from, calculate the length for 
//  these two strings.
//
//  Also initialze the search runs based on current selection offsets.
//
HRESULT  CSearchString::Initialize(WCHAR *SrchStr, WCHAR *SrchFromStr, LANGID langid, ULONG ulSelStartOff, ULONG ulSelLen)
{
    HRESULT  hr = S_OK;

    if ( m_fInitialized )
    {
        // Clean up the previous Initialization data.
        m_dstrTextToSrch.Clear( );

        m_fInitialized = FALSE;
    }

    if ( !SrchStr || !SrchFromStr )
        return E_INVALIDARG;

    m_langid = langid;

    m_pwszTextSrchFrom = SrchFromStr;
    m_dstrTextToSrch.Append(SrchStr);

    m_ulSrchFromLen = wcslen(SrchFromStr);
    m_ulSrchLen = wcslen(SrchStr);

    if ( _InitSearchRun(ulSelStartOff, ulSelLen) )
    {
        m_fInitialized = TRUE;
    }
    else
    {
        // Something wrong when Initialize Search Run
        // cleanup the string

        m_dstrTextToSrch.Clear( );
        m_pwszTextSrchFrom = NULL;
        m_ulSrchFromLen = m_ulSrchLen = 0;
        
        m_fInitialized = FALSE;
        hr = E_FAIL;
    }

    return hr;
}

//
//  Set data for each Search Run
//
//
void   CSearchString::_SetRun(Search_Run_Id  idSearchRun, ULONG ulStart, ULONG ulEnd, BOOL fStartToEnd)
{
    if ( idSearchRun >= SearchRun_MaxRuns )  return;
    m_pSearchRun[idSearchRun].ulStart = ulStart;
    m_pSearchRun[idSearchRun].ulEnd = ulEnd;
    m_pSearchRun[idSearchRun].fStartToEnd = fStartToEnd;
    return;
}

//
//  CSearchString::_InitSearchRun
//  
//  Initialize all possible search runs based on 
//  Current selection.
//
//
BOOL    CSearchString::_InitSearchRun(ULONG ulSelStartOff, ULONG ulSelLen)
{
    ULONG  ulDeltaForExpand = 20;
    ULONG  ulStart, ulEnd;
    
    if (!m_pwszTextSrchFrom || !m_ulSrchFromLen )
        return FALSE;

    // Initialize all the search run.
    for (int  id=SearchRun_Selection; id < SearchRun_MaxRuns; id++)
    {
        _SetRun((Search_Run_Id)id, 0, 0, FALSE);
    }

    // Initialize the Selection search run.

    ulStart = ulSelStartOff;
    ulEnd = ulStart + ulSelLen;

    if ( ulStart >= m_ulSrchFromLen )
        ulStart = m_ulSrchFromLen - 1;

    if ( ulEnd >= m_ulSrchFromLen )
        ulEnd = m_ulSrchFromLen - 1;

    if ( m_langid == 0x0409 )
    {
        // Find the word around the current IP or selection
        WCHAR   wch;

        // Find the first character which is not an alpha letter.
        while ( ulStart > 0 )
        {
            wch = m_pwszTextSrchFrom[ulStart-1];
            if ( !iswalpha(wch) )
            {
              // Found first non-alpha character before IP
              // the previous character must be the first char of a word.
                break;
            }
            ulStart --;
        }

        // Find the first character which is not an alpha letter
        while ( ulEnd < m_ulSrchFromLen-1)
        {
            wch = m_pwszTextSrchFrom[ulEnd+1];
            if ( !iswalpha(wch) )
            {
               // Found the first non-alpha character after IP
               break;
            }
            ulEnd ++;
        }
    }

    _SetRun(SearchRun_Selection, ulStart, ulEnd, TRUE);

    // Initialize the enlarged selection run

    if ( ulStart < ulDeltaForExpand)
         ulStart = 0;
    else
         ulStart = ulStart - ulDeltaForExpand;

    if ( ulEnd + ulDeltaForExpand > (m_ulSrchFromLen-1) )
         ulEnd = m_ulSrchFromLen-1;
    else
         ulEnd = ulEnd + ulDeltaForExpand;

    _SetRun(SearchRun_LargeSelection, ulStart, ulEnd, TRUE );

    // Initialize SearchRun_BeforeSelection run
    if ( ulStart > 0 )
    {
        ULONG  ulEndTmp;

        if ( ulSelStartOff >= m_ulSrchFromLen )
            ulEndTmp = m_ulSrchFromLen-1;
        else
            ulEndTmp = ulSelStartOff;

        _SetRun(SearchRun_BeforeSelection, 0, ulEndTmp , FALSE);
    }

    // Initialize SearchRun_AfterSelection if it exists.

    if ( ulEnd < (m_ulSrchFromLen-1) )
    {
        ulStart = ulSelStartOff+ ulSelLen;
        ulEnd = m_ulSrchFromLen-1;

        _SetRun(SearchRun_AfterSelection, ulStart, ulEnd, TRUE);
    }

    return TRUE;
}

//
//  Search m_dstrTextToSrch from m_pwszTextSrchFrom in one search run.
//
//  return TRUE if this run of m_pwszTextSrchFrom contains m_dstrTextToSrch
//  and update the data member m_ulFoundOffset.
//
BOOL     CSearchString::_SearchOneRun(Search_Run_Id  idSearchRun)
{
    BOOL     fFound = FALSE;
    ULONG    ulStart, ulEnd;
    BOOL     fStartToEnd;

    if ( !m_fInitialized || idSearchRun >= SearchRun_MaxRuns )
        return fFound;

    m_ulFoundOffset = 0;

    ulStart = m_pSearchRun[idSearchRun].ulStart;
    ulEnd   = m_pSearchRun[idSearchRun].ulEnd;
    fStartToEnd = m_pSearchRun[idSearchRun].fStartToEnd;

    if (ulStart >= m_ulSrchFromLen || ulEnd >= m_ulSrchFromLen)
        return fFound;

    if ( ulStart > ulEnd )
    {
        // swap the anchors
        ULONG  ulTemp;

        ulTemp  = ulEnd;
        ulEnd   = ulStart;
        ulStart = ulTemp;
    }

    if ( (ulEnd - ulStart + 1) >= m_ulSrchLen )
    {
        BOOL    bSearchDone = FALSE;
        ULONG   iStart;

        if ( fStartToEnd )
            iStart = ulStart;
        else
            iStart = ulEnd-m_ulSrchLen + 1;

        while ( !bSearchDone )
        {
            WCHAR   *pwszTmp;
                
            pwszTmp = m_pwszTextSrchFrom + iStart;
            if ( _wcsnicmp(m_dstrTextToSrch, pwszTmp, m_ulSrchLen) == 0 )
            {
                // if the string is in middle of a word in the FromStr
                // ignore it, find again.
                BOOL   fInMiddleWord = FALSE;

                if ( m_langid == 0x0409 )
                {
                    WCHAR szSurrounding[3] = L"  ";

                    if (iStart > 0)
                        szSurrounding[0] = m_pwszTextSrchFrom[iStart - 1];

                    if (iStart + m_ulSrchLen < m_ulSrchFromLen)
                        szSurrounding[1] = m_pwszTextSrchFrom[iStart + m_ulSrchLen];

                    if (iswalpha(szSurrounding[0]) || iswalpha(szSurrounding[1]) )
                        fInMiddleWord = TRUE;
                }
                
                if ( !fInMiddleWord )
                {
                    fFound = TRUE;
                    m_ulFoundOffset = iStart;
                    bSearchDone = TRUE;
                    break;
                }
            }

            if ( fStartToEnd )
            {
                if ( iStart >= ulEnd-m_ulSrchLen + 1 )
                    bSearchDone = TRUE;
                else
                    iStart ++;
            }
            else
            {
                if ( (long)iStart <= (long)ulStart )
                    bSearchDone = TRUE;
                else
                    iStart --;
            }
        }
    }

    return fFound;
}

//
//  Search all the search runs 
//
//  returns TRUE or FALSE and the offset of the matched substring.
//
BOOL     CSearchString::Search(ULONG  *pulOffset, ULONG  *pulSelSize)
{
    BOOL  fFound = FALSE;
    
    if ( !m_fInitialized ) return FALSE;

    for (int idRun=SearchRun_Selection; idRun < SearchRun_MaxRuns; idRun++ )
    {
        fFound = _SearchOneRun((Search_Run_Id)idRun);

        if ( fFound )
            break;
    }

    if ( fFound && pulOffset)
    {
        *pulOffset = m_ulFoundOffset;

        if ( pulSelSize ) 
        {
            ULONG         ulWordLen = m_ulSrchLen;

            // check if there are some trail spaces after the word.
            // include those trail spaces in the selection.

            for ( ULONG  i= m_ulFoundOffset + m_ulSrchLen; i<m_ulSrchFromLen; i++ )
            {
                if ( m_pwszTextSrchFrom[i] == L' ')
                    ulWordLen ++;
                else
                    break;
            }

            *pulSelSize = ulWordLen;
        }
    }

    return fFound;
}

// ----------------------------------------------------------------------------------------------------------
//
//  Implementation for CSelectWord
//
// -----------------------------------------------------------------------------------------------------------

CSelectWord::CSelectWord(CSapiIMX *psi) 
{
    m_psi = psi;
    m_pwszSelectedWord = NULL;
    m_ulLenSelected = 0;
}

CSelectWord::~CSelectWord( ) 
{

};

/*  --------------------------------------------------------
//    Function Name: UpdateTextBuffer
//
//    Description: Get current active text, fill them to the
//                 selword grammar's text buffer.
//
//                 After every recognition, we want to update 
//                 text buffer again based on new text.
//
// ----------------------------------------------------------*/
HRESULT  CSelectWord::UpdateTextBuffer(ISpRecoContext *pRecoCtxt, ISpRecoGrammar *pCmdGrammar)
{
    HRESULT               hr = E_FAIL;
    CComPtr<ITfContext>   cpic = NULL;
    CSelWordEditSession   *pes;

    if ( !pCmdGrammar  || !pRecoCtxt)
        return E_INVALIDARG;

    if ( !m_psi )
        return E_FAIL;

    // Start an edit session, get current active text, fill to the selword grammar, active it
    // and then resume the grammar state.

    if (m_psi->GetFocusIC(&cpic) && cpic )
    {
        if (pes = new CSelWordEditSession(m_psi, this, cpic))
        {
            pes->_SetEditSessionData(ESCB_UPDATE_TEXT_BUFFER, NULL, 0);
            pes->_SetUnk((IUnknown *)pRecoCtxt);
            pes->_SetUnk2((IUnknown *)pCmdGrammar);

            cpic->RequestEditSession(m_psi->_GetId( ), pes, TF_ES_READ, &hr);
            pes->Release();
        }
    }

    return hr;
}

/*  --------------------------------------------------------
//    Function Name: _UpdateTextBuffer
//
//    Description:  Edit session callback function for 
//                  UpdateTextBuffer.
//
//                  It will do the real work about extracting
//                  text and updating grammar buffer.
//
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_UpdateTextBuffer(TfEditCookie ec,ITfContext *pic, ISpRecoContext *pRecoCtxt, ISpRecoGrammar *pCmdGrammar)
{
    HRESULT   hr = S_OK;
    BOOL      fPaused = FALSE;

    // Get current active text, fill to the selword grammar.

    hr = _GetTextAndSelectInCurrentView(ec, pic, NULL, NULL);

    if ( hr == S_OK )
    {
        pRecoCtxt->Pause(0);
        fPaused = TRUE;
    }

    if ((hr == S_OK) && m_dstrActiveText)
    {
        // AddWordSequenceData to the grammar.

        SPTEXTSELECTIONINFO tsi = {0};
        ULONG     ulLen;

        ulLen = wcslen(m_dstrActiveText);

        tsi.ulStartActiveOffset = 0;
        tsi.cchActiveChars = ulLen;
        tsi.ulStartSelection = 0;
        tsi.cchSelection     = ulLen;

        WCHAR *pMemText = (WCHAR *)cicMemAlloc((ulLen+2)*sizeof(WCHAR));

        if (pMemText)
        {
            memcpy(pMemText, m_dstrActiveText, sizeof(WCHAR) * ulLen);
            pMemText[ulLen] = L'\0';
            pMemText[ulLen + 1] = L'\0';

            hr = pCmdGrammar->SetWordSequenceData(pMemText, ulLen + 2, &tsi);

            cicMemFree(pMemText);
        }
    }

    // Resume the recoContext.

    if ( fPaused )
    {
        pRecoCtxt->Resume(0);

    }

    return hr;
}

/*  --------------------------------------------------------
//    Function Name: _GetTextAndSelectInCurrentView
//
//    Description:  Get text from currect active view.
//                  ( visible area )
//
//                  it is a common function called by other
//                  edit session callback functions
//
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_GetTextAndSelectInCurrentView(TfEditCookie ec,ITfContext *pic, ULONG *pulOffSelStart, ULONG  *pulSelLen) 
{
    HRESULT  hr = S_OK;

    TraceMsg(TF_GENERAL, "CSelectWord::_GetTextAndSelectInCurrentView is called");

    if ( !pic ) return E_FAIL;

    CComPtr<ITfRange>   cpRangeView;

    // Get the Active View Range
    hr = _GetActiveViewRange(ec, pic, &cpRangeView);

    if( hr == S_OK )
    {
        CComPtr<ITfRange>   cpRangeCloned;
        BOOL                fCareSelection = FALSE;
        CComPtr<ITfRange>   cpCurSelection;
        ULONG               ulSelStartOffset = 0;
        ULONG               ulSelLen = 0;
        BOOL                fIPInsideActiveView = FALSE;
        BOOL                fIPIsEmpty = TRUE;

        m_cpActiveRange = cpRangeView;

        // Clean all the text filled previously.
        m_dstrActiveText.Clear( );

        if ( pulOffSelStart && pulSelLen )
        {
            fCareSelection = TRUE;
        }

        if ( fCareSelection )
        {
            //
            // Get the current selection and try to get the offset 
            // for this selection's start anchor and length.
            //

            if ( hr == S_OK )
                hr = GetSelectionSimple(ec, pic, &cpCurSelection);

            if ( hr == S_OK )
            {
                long                l1=0, l2=0;
                CComPtr<ITfRange>   cpRangeTemp;
            
                hr = m_cpActiveRange->Clone(&cpRangeTemp);

                if ( hr == S_OK )
                {
                    hr = cpCurSelection->CompareStart(ec, m_cpActiveRange,  TF_ANCHOR_START, &l1);
                    if ( hr == S_OK )
                        hr = cpCurSelection->CompareEnd(ec, m_cpActiveRange,  TF_ANCHOR_END, &l2);
                }

                if ( hr == S_OK && (l1>=0  && l2<=0) )
                {
                    // the IP is inside this active view.

                    fIPInsideActiveView = TRUE;
                    hr = cpCurSelection->IsEmpty(ec, &fIPIsEmpty);
                }
            }
        }

        if ( hr == S_OK )
        {
            // Get the text from the current active window view
            if ( !fIPInsideActiveView || !fCareSelection )
            {
                hr = m_cpActiveRange->Clone(&cpRangeCloned);
                if ( hr == S_OK )
                    hr = _GetTextFromRange(ec, cpRangeCloned, m_dstrActiveText);
            }
            else
            {
                // Ip is inside active view
                // Get the text from Start anchor of active view to start anchor of 
                // selection first to get the offset of the select start anchor.
                hr = m_cpActiveRange->Clone(&cpRangeCloned);

                if ( hr == S_OK )
                    hr = cpRangeCloned->ShiftEndToRange(ec, cpCurSelection, TF_ANCHOR_START);

                if ( hr == S_OK)
                    hr = _GetTextFromRange(ec, cpRangeCloned, m_dstrActiveText);

                if ( hr == S_OK )
                    ulSelStartOffset = m_dstrActiveText.Length( );

                // Get the length of selection if it is not empty.
                if ( hr == S_OK && !fIPIsEmpty)
                {
                    ULONG   ulLenOrg;

                    ulLenOrg = m_dstrActiveText.Length( );

                    hr = _GetTextFromRange(ec, cpCurSelection, m_dstrActiveText);

                    if ( hr == S_OK )
                       ulSelLen = m_dstrActiveText.Length( ) - ulLenOrg;
                }

                if ( hr == S_OK )
                    hr = cpRangeCloned->ShiftStartToRange(ec, cpCurSelection, TF_ANCHOR_END);

                if ( hr == S_OK )
                    hr = cpRangeCloned->ShiftEndToRange(ec, m_cpActiveRange, TF_ANCHOR_END);

                if ( hr == S_OK)
                    hr = _GetTextFromRange(ec, cpRangeCloned, m_dstrActiveText);
            }
        }

        if ( hr == S_OK  && pulOffSelStart && pulSelLen)
        {
            *pulOffSelStart = ulSelStartOffset;
            *pulSelLen = ulSelLen;
        }
    }

#ifdef DEBUG
    if ( m_dstrActiveText )
    {
        TraceMsg(TF_GENERAL, "dstrText is : =================================");
        TraceMsg(TF_GENERAL, "%S",(WCHAR *)m_dstrActiveText);
        TraceMsg(TF_GENERAL, "================================================");
    }
#endif

    return hr;
}

//
// GetText from a given range.
//
HRESULT  CSelectWord::_GetTextFromRange(TfEditCookie ec, ITfRange *pRange, CSpDynamicString &dstr)
{
    HRESULT             hr = S_OK;
    CComPtr<ITfRange>   cpRangeCloned;
    BOOL                fEmpty = TRUE;

    if ( !pRange ) return E_FAIL;

    hr = pRange->Clone(&cpRangeCloned);

    // Get the text from the given range
    while(S_OK == hr && (S_OK == cpRangeCloned->IsEmpty(ec, &fEmpty)) && !fEmpty)
    {
        WCHAR            sz[128];
        ULONG            ucch;
        hr = cpRangeCloned->GetText(ec, TF_TF_MOVESTART, sz, ARRAYSIZE(sz)-1, &ucch);

        if ( ucch == 0 )
        {
            TraceMsg(TF_GENERAL, "cch is 0 after GetText call in _GetTextFromRange");
            break;
        }

        if (S_OK == hr)
        {
            sz[ucch] = L'\0';
            dstr.Append(sz);
        }
    }

    return hr;
}

/* ------------------------------------------------------------
//    Function Name : _GetCUASCompositionRange
//
//    Description:  Get the range to cover all the text in 
//                  Non-Cicero aware application's composition
//                  window. (include AIMM app and CUAS app). 
// ------------------------------------------------------------*/
HRESULT  CSelectWord::_GetCUASCompositionRange(TfEditCookie ec, ITfContext *pic, ITfRange **ppRangeView)
{
    HRESULT                     hr = S_OK;
    CComPtr<ITfRange>           cpRangeStart, cpRangeEnd;

    Assert(ppRangeView);
    Assert(pic);

    hr = pic->GetStart(ec, &cpRangeStart);

    if ( hr == S_OK )
        hr = pic->GetEnd(ec, &cpRangeEnd);

    if (hr == S_OK && cpRangeStart && cpRangeEnd)
    {
        hr = cpRangeStart->ShiftEndToRange(ec, cpRangeEnd, TF_ANCHOR_END);

        if (hr == S_OK && ppRangeView)
            hr = cpRangeStart->Clone(ppRangeView);
    }

    return hr;
}


/* --------------------------------------------------------
//    Function Name : _GetActiveViewRange
//
//    Description:  Get the range to cover current active
//                  view ( visible area ), no matter if the
//                  text is in horizontal or vertical or 
//                  even bidi. 
//
//                  It is a common function called by other
//                  edit session callback functions
//
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_GetActiveViewRange(TfEditCookie ec, ITfContext *pic, ITfRange **ppRangeView)
{
    HRESULT                     hr = S_OK;
    CComPtr<ITfContextView>     pContextView;
    RECT                        rcTextWindow;
    CComPtr<ITfRange>           cpRangeStart, cpRangeEnd;
    CComPtr<ITfRange>           cpRangeView;

    BOOL                        fPureCicero = TRUE;

    Assert(ppRangeView);
    Assert(pic);

    fPureCicero = m_psi->_IsPureCiceroIC( pic );

    if ( !fPureCicero )
    {
        hr = _GetCUASCompositionRange(ec, pic, ppRangeView);
        return hr;
    }

    hr = pic->GetActiveView(&pContextView);

    // Get the text view window rectangle.
    if ( hr == S_OK )
        hr = pContextView->GetScreenExt(&rcTextWindow);

    if ( hr == S_OK )
    {
        POINT               CornerPoint[4];
        CComPtr<ITfRange>   cpRangeCorner[4];
        LONG                i;

        // Get ranges for four corners.
        // Upper Left point
        CornerPoint[0].x = rcTextWindow.left;
        CornerPoint[0].y = rcTextWindow.top;

        // Upper Right Point
        CornerPoint[1].x = rcTextWindow.right;
        CornerPoint[1].y = rcTextWindow.top;

        // Lower Left point
        CornerPoint[2].x = rcTextWindow.left;
        CornerPoint[2].y = rcTextWindow.bottom;

        // Lower Right point
        CornerPoint[3].x = rcTextWindow.right;
        CornerPoint[3].y = rcTextWindow.bottom;

        i = 0;
        do 
        {
            hr = pContextView->GetRangeFromPoint(ec, &(CornerPoint[i]),GXFPF_NEAREST,&(cpRangeCorner[i]));
            i++;
        } while (hr == S_OK && i<ARRAYSIZE(cpRangeCorner));

        // Now try to get the start range and end range.

        if (hr == S_OK)
        {
            cpRangeStart = cpRangeCorner[0];
            cpRangeEnd = cpRangeCorner[0];

            i = 1;
            do 
            {
                long l;

                hr = cpRangeStart->CompareStart(ec, cpRangeCorner[i], TF_ANCHOR_START, &l);

                if ( hr == S_OK  && l > 0)
                {
                    // this range is in front of the current Start range.
                    cpRangeStart = cpRangeCorner[i];
                }

                if ( hr == S_OK )
                    hr = cpRangeEnd->CompareStart(ec, cpRangeCorner[i], TF_ANCHOR_START, &l);

                if ( hr == S_OK && l < 0 )
                {
                    // This range is behind of current end range.
                    cpRangeEnd = cpRangeCorner[i];
                }

                i++;
            } while ( hr == S_OK && i<ARRAYSIZE(cpRangeCorner));
        }
    }

    // Now generate the new active view range.

    if (hr == S_OK && cpRangeStart && cpRangeEnd)
    {
        cpRangeView = cpRangeStart;
        hr = cpRangeView->ShiftEndToRange(ec, cpRangeEnd, TF_ANCHOR_END);

        if (hr == S_OK && ppRangeView)
            hr = cpRangeView->Clone(ppRangeView);
    }

    return hr;
}

/*  --------------------------------------------------------
//    Function Name: ProcessSelectWord
//
//    Description: public functions used by command handler
//                 to handle any selecton related dictation
//                 commands.
//
// ----------------------------------------------------------*/
HRESULT   CSelectWord::ProcessSelectWord(WCHAR *pwszSelectedWord, ULONG  ulLen, SELECTWORD_OPERATION sw_type, ULONG ulLenXXX)
{
    HRESULT hr = E_FAIL;
    CComPtr<ITfContext> cpic = NULL;

    if ( !m_psi )
        return E_FAIL;

    if ( (sw_type < SELECTWORD_MAXTEXTBUFF ) && (pwszSelectedWord == NULL ||  ulLen == 0) )
        return E_INVALIDARG;

    if ( m_psi->GetFocusIC(&cpic) && cpic )
    {
		CSelWordEditSession *pes;

        if (pes = new CSelWordEditSession(m_psi, this, cpic))
        {
            pes->_SetEditSessionData(ESCB_PROCESSSELECTWORD, 
                                     (void *)pwszSelectedWord, 
                                     (ulLen+1) * sizeof(WCHAR), 
                                     (LONG_PTR)ulLen, 
                                     (LONG_PTR)sw_type);

            pes->_SetLenXXX( (LONG_PTR)ulLenXXX );
            cpic->RequestEditSession(m_psi->_GetId( ), pes, TF_ES_READWRITE, &hr);
        }
        pes->Release();
    }
    return hr;
}


/*  --------------------------------------------------------
//    Function Name: _HandleSelectWord
//
//    Description:   Edit session call back funtion for 
//                   ProcessSelectionWord.
//
//                   it does real work for selection handling
// ----------------------------------------------------------*/
HRESULT CSelectWord::_HandleSelectWord(TfEditCookie ec,ITfContext *pic, WCHAR *pwszSelectedWord, ULONG  ulLen, SELECTWORD_OPERATION sw_type, ULONG ulLenXXX)
{
    HRESULT   hr = S_OK;

    // Get the Dictation Grammar

    TraceMsg(TF_GENERAL, "_HandleSelectWord() is called");

    if ( m_psi == NULL)
        return E_FAIL;

    m_pwszSelectedWord = pwszSelectedWord;
    m_ulLenSelected = ulLen;

    // Deliberately ignore return code.
    (void)m_psi->_SetFocusToStageIfStage();

    switch ( sw_type )
    {
    case  SELECTWORD_SELECT :
        hr = _SelectWord(ec, pic);
        break;

    case  SELECTWORD_DELETE :
        hr = _DeleteWord(ec, pic);
        break;

    case  SELECTWORD_INSERTBEFORE :
        hr = _InsertBeforeWord(ec, pic);
        break;

    case  SELECTWORD_INSERTAFTER  :
        hr = _InsertAfterWord(ec, pic);
        break;

    case SELECTWORD_CORRECT :
        hr = _CorrectWord(ec, pic);
        break;

    case SELECTWORD_UNSELECT :
        hr = _Unselect(ec, pic);
        break;

    case SELECTWORD_SELECTPREV :
        hr = _SelectPreviousPhrase(ec, pic);
        break;

    case SELECTWORD_SELECTNEXT :
        hr = _SelectNextPhrase(ec, pic);
        break;

    case SELECTWORD_CORRECTPREV :
        hr = _CorrectPreviousPhrase(ec, pic);
        break;

    case SELECTWORD_CORRECTNEXT :
        hr = _CorrectNextPhrase(ec, pic);
        break;

    case SELECTWORD_SELTHROUGH :
        hr = _SelectThrough(ec, pic, pwszSelectedWord, ulLen, ulLenXXX);
        break;

    case SELECTWORD_DELTHROUGH :
        hr = _DeleteThrough(ec, pic, pwszSelectedWord, ulLen, ulLenXXX);
        break;

    case SELECTWORD_GOTOBOTTOM :
        hr = _GoToBottom(ec, pic);
        break;
    case SELECTWORD_GOTOTOP :
        hr = _GoToTop(ec, pic);
        break;

    case SELECTWORD_SELSENTENCE :
    case SELECTWORD_SELPARAGRAPH :
    case SELECTWORD_SELWORD :
        hr = _SelectSpecialText(ec, pic, sw_type);
        break;

    case SELECTWORD_SELTHAT :
        hr = _SelectThat(ec, pic);
        break;
  
    default :
        break;
    }

    // update the saved ip so that next time the hypothesis will 
    // start from this new selection.
    m_psi->SaveLastUsedIPRange( );
    m_psi->SaveIPRange(NULL);

    return hr;
}

//
// This function will shift the exact number of characters as required.
// it will shift over any regions.
//
// Now it supports only FORWARD shifting.
//
// For StartAnchor shift, it will shift required number of characters until it reaches to 
// a non-region character.
//
HRESULT CSelectWord::_ShiftComplete(TfEditCookie ec, ITfRange *pRange, LONG cchLenToShift, BOOL fStart)
{
    HRESULT hr = S_OK;
    long    cchTotal = 0;
    BOOL    fNoRegion;
    LONG    cch;

    Assert(pRange);                    
    do
    {
        // Assume there is no region.
        fNoRegion = TRUE;
        if ( fStart )
            hr = pRange->ShiftStart(ec, cchLenToShift - cchTotal, &cch, NULL);
        else
            hr = pRange->ShiftEnd(ec, cchLenToShift - cchTotal, &cch, NULL);
                
        cchTotal += cch;
        if ( (hr == S_OK) && (cchTotal < cchLenToShift))
        {
            // region?
            hr = pRange->ShiftStartRegion(ec, TF_SD_FORWARD, &fNoRegion);
        }
    }
    while (hr == S_OK && cchTotal < cchLenToShift && !fNoRegion);

    if (hr == S_OK && !fNoRegion && fStart)
    {
        // We want to shift all the possible regions until it reaches a non-region character
        do 
        {
            hr = pRange->ShiftStartRegion(ec, TF_SD_FORWARD, &fNoRegion);
        } while ( hr == S_OK && !fNoRegion );
    }

    return hr;
}

/*  --------------------------------------------------------
//    Function Name: _FindSelect
//
//    Description:  search the active view text to find the 
//                  the first matched string after the current
//                  selection or IP.
//
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_FindSelect(TfEditCookie ec, ITfContext *pic, BOOL  *fFound)
{
    HRESULT             hr = S_OK;
    CComPtr<ITfRange>   cpRangeSelected;
    ULONG               ulSelStartOff;
    ULONG               ulSelLen;

    TraceMsg(TF_GENERAL, "CSelectWord::_FindSelect is called");

    if ( !fFound ) return E_INVALIDARG;

    *fFound = FALSE;

    hr = _GetTextAndSelectInCurrentView(ec, pic, &ulSelStartOff, &ulSelLen);

    // Search the required string from the document text.

    if ( hr == S_OK )
        hr = m_cpActiveRange->Clone(&cpRangeSelected);

    if ( hr == S_OK && m_dstrActiveText)
    {
        ULONG   ulLen;
        
        ulLen = wcslen(m_dstrActiveText);

        if ( ulLen >= m_ulLenSelected )
        {
            BOOL   bFound = FALSE;
            ULONG  iStartOffset = 0;
            ULONG  iWordLen = m_ulLenSelected;
            CSearchString  *pSearchStr = new CSearchString( );
                
            if ( pSearchStr )
            {
                hr = pSearchStr->Initialize(m_pwszSelectedWord,
                                            (WCHAR *)m_dstrActiveText,
                                            m_psi->GetLangID( ),
                                            ulSelStartOff,
                                            ulSelLen);

                if ( hr == S_OK )
                {
                    bFound = pSearchStr->Search( &iStartOffset, &iWordLen );
                }

                delete pSearchStr;

                if ( bFound )
                {
                    hr = _ShiftComplete(ec, cpRangeSelected, (LONG)iStartOffset, TRUE);

                    if ( hr == S_OK )
                    {
                        hr = cpRangeSelected->Collapse(ec, TF_ANCHOR_START);
                    }

                    if ( hr == S_OK )
                         hr = _ShiftComplete(ec, cpRangeSelected, (LONG)iWordLen, FALSE);

                    if ( hr == S_OK )
                    {
                        m_cpSelectRange.Release( );
                        hr = cpRangeSelected->Clone(&m_cpSelectRange);
                    }

                    *fFound = bFound;
                }
            }
        }
    }

    return hr;

}
/*  --------------------------------------------------------
//    Function Name: _SelectWord
//
//    Description:  Handle Select <Phrase> command.
//
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_SelectWord(TfEditCookie ec,ITfContext *pic)
{
    HRESULT             hr = S_OK;
    BOOL                fFound = FALSE;

    TraceMsg(TF_GENERAL, "CSelectWord::_SelectWord is called");

    hr = _FindSelect(ec, pic, &fFound);

    if ( hr == S_OK  && fFound )
    {
        // Set the new selection.
        hr = SetSelectionSimple(ec, pic, m_cpSelectRange);
    }

    return hr;
}

/*  --------------------------------------------------------
//    Function Name: _DeleteWord
//
//    Description:  Handle Delete <Phrase> command
//
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_DeleteWord(TfEditCookie ec,ITfContext *pic)
{
    HRESULT             hr = S_OK;
    BOOL                fFound = FALSE;

    TraceMsg(TF_GENERAL, "CSelectWord::_DeleteWord is called");

    hr = _FindSelect(ec, pic, &fFound);

    if ( hr == S_OK  && fFound )
    {
        // Set the new selection.
        hr = SetSelectionSimple(ec, pic, m_cpSelectRange);
        if ( hr == S_OK )
        {
            // start a composition here if we haven't already
            m_psi->_CheckStartComposition(ec, m_cpSelectRange);
            // set the text
            hr = m_cpSelectRange->SetText(ec,0, NULL, 0);
        }
    }

    return hr;
}

/*  --------------------------------------------------------
//    Function Name: _InsertAfterWord
//
//    Description:  Handle Delete <Phrase> command
//
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_InsertAfterWord(TfEditCookie ec,ITfContext *pic)
{
    HRESULT             hr = S_OK;
    BOOL                fFound = FALSE;

    TraceMsg(TF_GENERAL, "CSelectWord::_InsertAfterWord is called");

    hr = _FindSelect(ec, pic, &fFound);

    if ( hr == S_OK  && fFound )
    {
        // Set the new selection.
        hr =  m_cpSelectRange->Collapse(ec, TF_ANCHOR_END);

        // If there is a space right after the selected word, we just need to move
        // the insertion point to a next non-space character.

        if ( hr == S_OK )
        {
            CComPtr<ITfRange>  cpRangeTmp;
            long               cch=0;
            WCHAR              wszTempText[2];

            hr = m_cpSelectRange->Clone(&cpRangeTmp);

            while ( hr == S_OK && cpRangeTmp ) 
            {
                hr = cpRangeTmp->ShiftEnd(ec, 1, &cch, NULL);

                if ( hr == S_OK && cch == 1 )
                {
                    hr = cpRangeTmp->GetText(ec, 0, wszTempText, 1, (ULONG *)&cch);

                    if ( hr == S_OK  && wszTempText[0] == L' ')
                    {
                        hr = cpRangeTmp->Collapse(ec, TF_ANCHOR_END);
                    }
                    else
                    {
                        hr = cpRangeTmp->Collapse(ec, TF_ANCHOR_START);
                        break;
                    }
                    
                }
                else
                    break;
            } 
            
            if ( hr == S_OK )
            {
                hr = SetSelectionSimple(ec, pic, cpRangeTmp);
            }
        }
    }

    return hr;
}


/*  --------------------------------------------------------
//    Function Name: _InsertBeforeWord
//
//    Description:  Handle "Insert Before <Phrase>" command
//
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_InsertBeforeWord(TfEditCookie ec,ITfContext *pic)
{
    HRESULT             hr = S_OK;
    BOOL                fFound = FALSE;

    TraceMsg(TF_GENERAL, "CSelectWord::_InsertBeforeWord is called");

    hr = _FindSelect(ec, pic, &fFound);

    if ( hr == S_OK  && fFound )
    {
        // Set the new selection.
        hr =  m_cpSelectRange->Collapse(ec, TF_ANCHOR_START);

        if ( hr == S_OK )
        {
           hr = SetSelectionSimple(ec, pic, m_cpSelectRange);
        }
    }

    return hr;
}

/*  --------------------------------------------------------
//    Function Name: _Unselect
//
//    Description: Handle "Unselect that" command
//                 Unselect current selection.
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_Unselect(TfEditCookie ec,ITfContext *pic)
{
    HRESULT            hr;
    CComPtr<ITfRange>  cpInsertionPoint;

    hr = GetSelectionSimple(ec, pic, &cpInsertionPoint);

    if ( hr == S_OK && cpInsertionPoint)
    {
        // Set the new selection.
        hr =  cpInsertionPoint->Collapse(ec, TF_ANCHOR_END);

        if ( hr == S_OK )
        {
           hr = SetSelectionSimple(ec, pic, cpInsertionPoint);
        }
    }

    return hr;
}

/*  --------------------------------------------------------
//    Function Name: _CorrectWord
//
//    Description:  Handle "Correct <Phrase>" command
//
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_CorrectWord(TfEditCookie ec,ITfContext *pic)
{
    HRESULT   hr = S_OK;
    BOOL      fFound = FALSE;

    // Find the required phrase
    hr = _FindSelect(ec, pic, &fFound);

    if ( hr == S_OK  && fFound )
    {
        //
        // Try to open the correction window based on current found range.
        //
        // After the candidate UI window is closed, IP needs to be restored
        // to the original one.
        BOOL   fConvertable = FALSE;

        m_psi->_SetRestoreIPFlag(TRUE);
        hr = m_psi->_ReconvertOnRange(m_cpSelectRange, &fConvertable);

        if (hr == S_OK && !fConvertable )
        {
            // No alternate assoicated with this range, 
            // just simply select the text so that user can reconvert it in other ways.
            hr = SetSelectionSimple(ec, pic, m_cpSelectRange);
        }
    }

    return hr;
}

/*  --------------------------------------------------------
//    Function Name: _GetPrevOrNextPhrase
//
//    Description: Get the real range for "Previous Phrase" or
//                 "Next Phrase", based on current ip.
//                 It could be called by _SelectPreviousPhrase,
//                 _SelectNextPhrase, _CorrectPreviousPhrase,
//                 or _CorrectNextPhrase.
// ----------------------------------------------------------*/

HRESULT CSelectWord::_GetPrevOrNextPhrase(TfEditCookie ec, ITfContext *pic, BOOL  fPrev, ITfRange **ppRangeOut)
{
    HRESULT              hr = S_OK;
    CComPtr<ITfRange>    cpIP;
    CComPtr<ITfRange>    cpFoundRange;
    CComPtr<ITfRange>    cpRangeTmp;
    CComPtr<ITfProperty> cpProp = NULL;
    LONG                 l;
    BOOL                 fEmpty = TRUE;

    if ( !ppRangeOut ) 
        return E_INVALIDARG;

    *ppRangeOut = NULL;

    ASSERT(m_psi);
    cpIP = m_psi->GetSavedIP();

    if ( cpIP == NULL )
    {
        // Get the current IP.
        hr = GetSelectionSimple(ec, pic, &cpIP);
    }

    if ( hr == S_OK && cpIP )
    { 
        hr = cpIP->Clone(&cpRangeTmp);
    }

    if ( hr != S_OK || !cpIP )
        return hr;

    if ( fPrev )
    {
        hr = cpRangeTmp->Collapse(ec, TF_ANCHOR_START);

        if ( hr == S_OK )
        {
            // shift to the previous position
            hr = cpRangeTmp->ShiftStart(ec, -1, &l, NULL);
        }
    }
    else
    {
        hr = cpRangeTmp->Collapse(ec, TF_ANCHOR_END);
        if ( hr == S_OK )
        {
            hr = cpRangeTmp->ShiftEnd(ec, 1, &l, NULL);
        }

        if ( hr == S_OK )
        {
            // shift to the next position
            hr = cpRangeTmp->ShiftStart(ec, 1, &l, NULL);
        }
    }

    if ( hr == S_OK )
        hr = pic->GetProperty(GUID_PROP_SAPI_DISPATTR, &cpProp);

    if ( hr == S_OK && cpProp)
    {
        TfGuidAtom guidAttr = TF_INVALID_GUIDATOM;

        hr = cpProp->FindRange(ec, cpRangeTmp, &cpFoundRange, TF_ANCHOR_START);

        if (S_OK == hr && cpFoundRange)
        {
            hr = GetGUIDPropertyData(ec, cpProp, cpFoundRange, &guidAttr);
     
            if (hr == S_OK)
            {
                TfGuidAtom  guidSapiInput;

                GetGUIDATOMFromGUID(m_psi->_GetLibTLS( ), GUID_ATTR_SAPI_INPUT, &guidSapiInput);

                if ( guidSapiInput == guidAttr )
                {
                    // Found the dictated phrase.
                    // is it empty?

                    cpFoundRange->IsEmpty(ec, &fEmpty);
                }
            }
        }
        else
        {
            // With Office Auto-Correction, the static GUID_PROP_SAPI_DISPATTR property 
            // on the auto-corrected range could be destroyed.
            // In this case, we may want to rely on our custom property GUID_PROP_SAPIRESULTOBJECT
            // to find the real previous dictated phrase.

            cpProp.Release( );  // to avoid memory leak.

            if ( cpFoundRange )
                cpFoundRange.Release( );

            hr = pic->GetProperty(GUID_PROP_SAPIRESULTOBJECT, &cpProp);

            if ( hr == S_OK && cpProp)
                hr = cpProp->FindRange(ec, cpRangeTmp, &cpFoundRange, TF_ANCHOR_START);

            if (hr == S_OK && cpFoundRange)
                hr = cpFoundRange->IsEmpty(ec, &fEmpty);
        }
    }

    // Set new selection if the found range is not empty.
    if ( (hr == S_OK) && cpFoundRange  && !fEmpty )
    {
        cpFoundRange->Clone(ppRangeOut);
    }

    return hr;
}


HRESULT  CSelectWord::_SelectPrevOrNextPhrase(TfEditCookie ec, ITfContext *pic, BOOL  fPrev)
{
    HRESULT             hr = S_OK;
    CComPtr<ITfRange>   cpRange;

    hr = _GetPrevOrNextPhrase(ec, pic, fPrev, &cpRange);

    if ( hr == S_OK  && cpRange )
    {
        hr = SetSelectionSimple(ec, pic, cpRange);
    }
     
    return hr;

}
/*  --------------------------------------------------------
//    Function Name: _SelectPreviousPhrase
//
//    Description: Handle "Select Previous Phrase" command
//                 select previous phrase.
//
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_SelectPreviousPhrase(TfEditCookie ec,ITfContext *pic)
{
    return _SelectPrevOrNextPhrase(ec, pic, TRUE);
}

/*  --------------------------------------------------------
//    Function Name: _SelectNextPhrase
//
//    Description: Handle "Select Next Phrase" command
//                 select next phrase.
//
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_SelectNextPhrase(TfEditCookie ec,ITfContext *pic)
{
    return _SelectPrevOrNextPhrase(ec, pic, FALSE);
}


/*  --------------------------------------------------------
//    Function Name: _CorrectPrevOrNextPhrase
//
//    Description: Handle "Correct Previous/Next Phrase" command,
//
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_CorrectPrevOrNextPhrase(TfEditCookie ec,ITfContext *pic, BOOL fPrev)
{
    HRESULT             hr = S_OK;
    CComPtr<ITfRange>   cpRange;

    // Get the previous phrase range.
    hr = _GetPrevOrNextPhrase(ec, pic, fPrev, &cpRange);

    if ( hr == S_OK  && cpRange )
    {
        //
        // Try to open the correction window based on current found range.
        //
        // After the candidate UI window is closed, IP needs to be restored
        // to the original one.
        BOOL   fConvertable = FALSE;

        m_psi->_SetRestoreIPFlag(TRUE);
        hr = m_psi->_ReconvertOnRange(cpRange, &fConvertable);

        if (hr == S_OK && !fConvertable )
        {
            // No alternate assoicated with this range, 
            // just simply select the text so that user can reconvert it in other ways.
            hr = SetSelectionSimple(ec, pic, m_cpSelectRange);
        }

    }

    return hr;
}

/*  --------------------------------------------------------
//    Function Name: _CorrectPreviousPhrase
//
//    Description: Handle "Correct Previous Phrase" command
//
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_CorrectPreviousPhrase(TfEditCookie ec,ITfContext *pic)
{
    return _CorrectPrevOrNextPhrase(ec, pic, TRUE);
}

/*  --------------------------------------------------------
//    Function Name: _CorrectNextPhrase
//
//    Description: Handle "Correct Next Phrase" command
//                 correct next phrase.
//
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_CorrectNextPhrase(TfEditCookie ec,ITfContext *pic)
{
    return _CorrectPrevOrNextPhrase(ec, pic, FALSE);
}


/*  --------------------------------------------------------
//    Function Name: _GetThroughRange
//
//    Description: Get the range for commands "command XXX through YYY"
//                 
//    pwszText: contains text "XXX + YYY"
//    ulLen   : length of pwszText
//    ulLenXXX: length of "XXX"
//
// ----------------------------------------------------------*/

HRESULT  CSelectWord::_GetThroughRange(TfEditCookie ec, ITfContext *pic, WCHAR *pwszText, ULONG ulLen, ULONG ulLenXXX, ITfRange **ppRange)
{
    HRESULT             hr = S_OK;
    WCHAR               *pwszXXX = NULL, *pwszYYY = NULL;

    TraceMsg(TF_GENERAL, "CSelectWord::_GetThroughRange is called");

    Assert(ulLen);
    Assert(ulLenXXX);
    Assert(pwszText);
        
    if ( !ppRange || ulLen < ulLenXXX ) return E_INVALIDARG;

    *ppRange = NULL;

    pwszXXX = (WCHAR *)cicMemAlloc( (ulLenXXX+1) * sizeof(WCHAR) );
    if ( pwszXXX )
    {
        wcsncpy(pwszXXX, pwszText, ulLenXXX);
        pwszXXX[ulLenXXX] = L'\0';

        pwszYYY = (WCHAR *)cicMemAlloc( (ulLen - ulLenXXX + 1) * sizeof(WCHAR));

        if ( pwszYYY )
        {
            wcsncpy(pwszYYY, pwszText+ulLenXXX, ulLen-ulLenXXX);
            pwszYYY[ulLen-ulLenXXX] = L'\0';

            BOOL                fFoundXXX = FALSE;
            BOOL                fFoundYYY = FALSE;
            CComPtr<ITfRange>   cpRangeXXX;

            // Found XXX.
            m_pwszSelectedWord = pwszXXX;
            m_ulLenSelected = ulLenXXX;
            hr = _FindSelect(ec, pic, &fFoundXXX);

            if ( hr == S_OK && fFoundXXX && m_cpSelectRange)
            {
                m_cpSelectRange->Clone(&cpRangeXXX);
                // Found YYY
                SetSelectionSimple(ec, pic, m_cpSelectRange);
                m_pwszSelectedWord = pwszYYY;
                m_ulLenSelected = ulLen - ulLenXXX;
                hr = _FindSelect(ec, pic, &fFoundYYY); 
            }

            if ( hr == S_OK  && fFoundYYY )
            {
                long l;
                CComPtr<ITfRange>  cpSelRange;

                // m_cpSelectRange now points to the YYY range.
                hr = cpRangeXXX->CompareStart(ec, m_cpSelectRange,  TF_ANCHOR_START, &l);

                if ( hr == S_OK )
                {
                    if ( l < 0 )
                    {
                        // XXX is prior to YYY, normal case
                        cpSelRange = cpRangeXXX;
                        hr = cpSelRange->ShiftEndToRange(ec, m_cpSelectRange, TF_ANCHOR_END);
                    }
                    else if ( l > 0 )
                    {
                        // XXX is after YYY.
                        //
                        // such as document has text like:  ... YYY ...... XXX...
                        // and you say "Select XXX through YYY
                        //
                        cpSelRange = m_cpSelectRange;
                        hr = cpSelRange->ShiftEndToRange(ec, cpRangeXXX, TF_ANCHOR_END);
                    }
                    else
                    {
                        // Select XXX through XXX.  here YYY is XXX.
                        cpSelRange = m_cpSelectRange;
                    }
                }

                // Set the new selection.

                if ( hr == S_OK )
                {
                    cpSelRange->Clone(ppRange);
                }
            }

            cicMemFree(pwszYYY);
        }

        cicMemFree(pwszXXX);
    }

    return hr;

}

/*  --------------------------------------------------------
//    Function Name: _SelectThrough
//
//    Description: Handle command "Select XXX through YYY"
//                 
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_SelectThrough(TfEditCookie ec, ITfContext *pic, WCHAR *pwszText, ULONG ulLen, ULONG ulLenXXX)
{
    HRESULT             hr = S_OK;
    CComPtr<ITfRange>   cpRange;

    TraceMsg(TF_GENERAL, "CSelectWord::_SelectThrough is called");
  
    if ( ulLen < ulLenXXX ) return E_INVALIDARG;

    hr = _GetThroughRange(ec, pic, pwszText, ulLen, ulLenXXX, &cpRange);

    if ( hr == S_OK && cpRange )
        hr = SetSelectionSimple(ec, pic, cpRange);

    return hr;
}

/*  --------------------------------------------------------
//    Function Name: _DeleteThrough
//
//    Description: Handle command "Delete XXX through YYY"
//                 
// ----------------------------------------------------------*/

HRESULT  CSelectWord::_DeleteThrough(TfEditCookie ec, ITfContext *pic, WCHAR *pwszText, ULONG ulLen, ULONG ulLenXXX)
{
    HRESULT             hr = S_OK;
    CComPtr<ITfRange>   cpRange;

    TraceMsg(TF_GENERAL, "CSelectWord::_DeleteThrough is called");
  
    if ( ulLen < ulLenXXX ) return E_INVALIDARG;

    hr = _GetThroughRange(ec, pic, pwszText, ulLen, ulLenXXX, &cpRange);

    if ( hr == S_OK && cpRange )
    {
        BOOL fEmpty = TRUE;
        
        cpRange->IsEmpty(ec, &fEmpty);
        
        if ( !fEmpty )
        {
            // Set the new selection.
            hr = SetSelectionSimple(ec, pic, cpRange);
            if ( hr == S_OK )
            {
                // start a composition here if we haven't already
                m_psi->_CheckStartComposition(ec, cpRange);
                // set the text
                hr = cpRange->SetText(ec,0, NULL, 0);
            }       
        }
    }

    return hr;
}

/*  --------------------------------------------------------
//    Function Name: _GoToBottom
//
//    Description: Handle command "Go to Bottom"
//                 move the IP to the end anchor of the 
//                 current active view range.
//                 
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_GoToBottom(TfEditCookie ec,ITfContext *pic)
{
    HRESULT hr = S_OK;

    CComPtr<ITfRange>   cpRangeView;

    // Get the Active View Range
    hr = _GetActiveViewRange(ec, pic, &cpRangeView);

    // Collapse to the end anchor of the active view
    if ( hr == S_OK )
        hr = cpRangeView->Collapse(ec, TF_ANCHOR_END);

    // Set selection to the end of active view.
    if ( hr == S_OK )
        hr = SetSelectionSimple(ec, pic, cpRangeView);
 
    return hr;
}

/*  --------------------------------------------------------
//    Function Name: _GoToTop
//
//    Description: Handle command "Go To Top"
//                 Move the IP to the start anchor of the
//                 current active view range.
//                 
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_GoToTop(TfEditCookie ec,ITfContext *pic)
{
    HRESULT hr = S_OK;

    CComPtr<ITfRange>   cpRangeView;

    // Get the Active View Range
    hr = _GetActiveViewRange(ec, pic, &cpRangeView);

    // Collapse to the start anchor of the active view
    if ( hr == S_OK )
        hr = cpRangeView->Collapse(ec, TF_ANCHOR_START);

    // Set selection to the start of active view.
    if ( hr == S_OK )
        hr = SetSelectionSimple(ec, pic, cpRangeView);
 
    return hr;
}

#define MAX_PARA_SIZE       512
#define VK_NEWLINE          0x0A
#define MAX_WORD_SIZE       30
#define MAX_SENTENCE_SIZE   256

/*  --------------------------------------------------------
//    Function Name: _SelectSpecialText
//
//    Description: This is a common function for 
//                 "Select Sentence"
//                 "Select Paragraph"
//                 "Select Word"
//                 
//    sw_type indicates which command would be handled
//                 
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_SelectSpecialText(TfEditCookie ec,ITfContext *pic, SELECTWORD_OPERATION sw_Type)
{
    HRESULT             hr = S_OK;
    CComPtr<ITfRange>   cpRangeSelect;
    CComPtr<ITfRange>   cpRangeRightClone;
    LONG                cch = 0;
    ULONG               cchText = 0;
    int                 i = 0;
    int                 cchLeftEnd = 0;
    ULONG               ulBufSize = 0;
    WCHAR               *pwszTextBuf;

    if ( sw_Type != SELECTWORD_SELSENTENCE    && 
         sw_Type != SELECTWORD_SELPARAGRAPH   && 
         sw_Type != SELECTWORD_SELWORD )
    {
        return E_INVALIDARG;
    }

    // 
    // "Select Word" only works for English Now.
    //
    if ( sw_Type == SELECTWORD_SELWORD && m_psi->GetLangID( ) != 0x0409 )
        return E_NOTIMPL;

    switch (sw_Type)
    {
    case SELECTWORD_SELSENTENCE :
        ulBufSize = MAX_SENTENCE_SIZE;
        break;

    case SELECTWORD_SELPARAGRAPH :
        ulBufSize = MAX_PARA_SIZE;
        break;

    case SELECTWORD_SELWORD :
        ulBufSize = MAX_WORD_SIZE;
        break;
    }

    pwszTextBuf = (WCHAR *)cicMemAlloc( (ulBufSize+1) * sizeof(WCHAR) );

    if ( !pwszTextBuf )
        return E_OUTOFMEMORY;

    hr = GetSelectionSimple(ec, pic, &cpRangeSelect);

    if ( hr == S_OK )
        hr = cpRangeSelect->Collapse(ec, TF_ANCHOR_START);

    //
    // Find the start anchor of the special pattern text.
    //
    
    if ( hr == S_OK )
        hr = cpRangeSelect->ShiftStart(ec, (-1 * ulBufSize), &cch, NULL);

    if  ( hr == S_OK && cch != 0)
    {
        hr = cpRangeSelect->GetText(ec, 0,pwszTextBuf, (-1 * cch), &cchText);
     
        // Find the nearest delimiter left to the IP
        if ( hr == S_OK )
        {
            Assert(cchText == (-1 *cch) );
    
            for(i = ((LONG)cchText-1); i>=0; i--)
            {
                BOOL fDelimiter = FALSE;

                switch (sw_Type)
                {
                case SELECTWORD_SELSENTENCE :
                    fDelimiter = _IsSentenceDelimiter(pwszTextBuf[i]);
                    break;

                case SELECTWORD_SELPARAGRAPH :
                    fDelimiter = _IsParagraphDelimiter(pwszTextBuf[i]);
                    break;

                case SELECTWORD_SELWORD :
                    fDelimiter = _IsWordDelimiter(pwszTextBuf[i]);
                    break;

                }
    
                if(fDelimiter)    
                {
                    break;
                }
            }
    
            i++; // positioning the first character in the searched range.
    
            hr = cpRangeSelect->ShiftStart(ec, i, &cch, NULL);

            cchLeftEnd = (LONG)cchText - i;// total characters to the beginning of range
        }
    }

    //
    // Find the End Anchor of the special text range
    //
    
    if ( hr == S_OK )
        hr = cpRangeSelect->Clone(&cpRangeRightClone);

    if ( hr == S_OK )
        hr = cpRangeRightClone->Collapse(ec, TF_ANCHOR_END);

    // make sure this right band range not skip over to the next region.
    cchText = cch = 0;

    if ( hr == S_OK )
        hr = cpRangeRightClone->ShiftEnd(ec, ulBufSize, &cch, NULL);

    if ( hr == S_OK && cch != 0 )
        hr = cpRangeRightClone->GetText(ec, TF_TF_MOVESTART, pwszTextBuf, ulBufSize, &cchText); 

    if ( hr == S_OK )
    {
        for(i = 0; i< (LONG)cchText; i++)
        {
            BOOL fDelimiter = FALSE;

            switch (sw_Type)
            {
            case SELECTWORD_SELSENTENCE :
                fDelimiter = _IsSentenceDelimiter(pwszTextBuf[i]);
                break;

            case SELECTWORD_SELPARAGRAPH :
                fDelimiter = _IsParagraphDelimiter(pwszTextBuf[i]);
                break;

            case SELECTWORD_SELWORD :
                fDelimiter = _IsWordDelimiter(pwszTextBuf[i]);
                break;

            }
    
            if(fDelimiter)    
            {
                break;
            }        
        }

        if ( (int)cchText > i )
        {
            if ( sw_Type == SELECTWORD_SELSENTENCE )
            {
                // For select sentence, the right sentence delimiter such as ".', '?', '!' is also 
                // selected.  to be compatible with Office behavior.
                if ( (int)cchText > (i+1) )
                    hr = cpRangeRightClone->ShiftStart(ec, -((LONG)cchText - i - 1), &cch, NULL);
            }
            else
                hr = cpRangeRightClone->ShiftStart(ec, -((LONG)cchText - i), &cch, NULL);
        }
    }

    if ( hr == S_OK )
        hr = cpRangeSelect->ShiftEndToRange(ec, cpRangeRightClone, TF_ANCHOR_START);

    // Set selection 

    if ( hr == S_OK )
        hr = SetSelectionSimple(ec, pic, cpRangeSelect);

    cicMemFree(pwszTextBuf);

    return hr;
}

//
// Check if the current char is a delimiter of Sentence
//
BOOL  CSelectWord::_IsSentenceDelimiter(WCHAR  wch)
{
    BOOL  fDelimiter = FALSE;

    BOOL  fIsQuest = ( (wch == '?') || 
                       (wch == 0xFF1F) );               // Full width Question Mark

    BOOL  fIsPeriod = ((wch == '.')    || 
                       (wch == 0x00B7) ||               // Middle Dot
                       (wch == 0x3002) ||               // Ideographic period
                       (wch == 0xFF0E) ||               // Full width period
                       (wch == 0x2026) );               // Horizontal Ellipsis

    BOOL  fIsExclamMark = ( (wch == '!')   ||
                            (wch == 0xFF01) );          // Full width Exclamation Mark

    BOOL  fIsReturn = ( (wch == VK_RETURN)  ||  (wch == VK_NEWLINE) );

    fDelimiter = (fIsQuest || fIsPeriod || fIsExclamMark || fIsReturn);

    return fDelimiter;
}

//
// Check if the current char is a delimiter of Paragraph
//
BOOL  CSelectWord::_IsParagraphDelimiter(WCHAR wch)
{
    BOOL  fDelimiter = FALSE;

    if( (wch == VK_RETURN) || (wch == VK_NEWLINE) ) 
        fDelimiter = TRUE;

    return fDelimiter;
}

// 
// Check if the current char is a word delimiter
//
BOOL  CSelectWord::_IsWordDelimiter(WCHAR wch)
{
    return (iswalpha(wch) == FALSE);
}

//
// Handle "Select That" command
//
HRESULT  CSelectWord::_SelectThat(TfEditCookie ec,ITfContext *pic)
{
    HRESULT             hr = S_OK;
    CComPtr<ITfRange>   cpRangeThat;

    hr = m_psi->_GetCmdThatRange(ec, pic, &cpRangeThat);

    if ( hr == S_OK )
        hr = SetSelectionSimple(ec, pic, cpRangeThat);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\selword.h ===
#ifndef _SELWORD_H
#define _SELWORD_H

#include "sapilayr.h"

typedef struct  _SearchRun 
{
    ULONG   ulStart;
    ULONG   ulEnd;
    BOOL    fStartToEnd;
}  SEARCHRUN;

typedef enum
{
    SearchRun_Selection         = 0,
    SearchRun_LargeSelection    = 1,
    SearchRun_BeforeSelection   = 2,
    SearchRun_AfterSelection    = 3,
    SearchRun_MaxRuns           = 4
} Search_Run_Id;

class CSearchString
{
public: 
    CSearchString( );
    ~CSearchString( );

    HRESULT  Initialize(WCHAR *SrchStr, WCHAR *SrchFromStr, LANGID langid, ULONG ulSelStartOff, ULONG ulSelLen);
    BOOL     Search(ULONG  *pulOffset, ULONG  *pulSelSize=NULL);
private:
    BOOL     _SearchOneRun(Search_Run_Id  idSearchRun);
    BOOL     _InitSearchRun(ULONG ulSelStartOff, ULONG ulSelLen);

    void     _SetRun(Search_Run_Id  idSearchRun, ULONG ulStart, ULONG ulEnd, BOOL fStartToEnd);

    CSpDynamicString    m_dstrTextToSrch;
    LANGID              m_langid;
    WCHAR              *m_pwszTextSrchFrom;
    ULONG               m_ulSrchLen;
    ULONG               m_ulSrchFromLen;
    SEARCHRUN           m_pSearchRun[SearchRun_MaxRuns];
    BOOL                m_fInitialized;
    ULONG               m_ulFoundOffset;  // Offset in m_pwszTextSrchFrom that matches SearchStr.
};

class CSapiIMX;
class CSpTask;

typedef enum
{
    SELECTWORD_NONE         =  0,
    SELECTWORD_SELECT       =  1,
    SELECTWORD_DELETE       =  2,
    SELECTWORD_INSERTBEFORE =  3,
    SELECTWORD_INSERTAFTER  =  4,
    SELECTWORD_CORRECT      =  5,
    SELECTWORD_SELTHROUGH   =  6,    // Select xxx through yyy
    SELECTWORD_DELTHROUGH   =  7,    // Delete xxx through yyy
    SELECTWORD_MAXTEXTBUFF  = 11,
    SELECTWORD_UNSELECT     = 11,
    SELECTWORD_SELECTPREV   = 12,    // Select previous phrase.
    SELECTWORD_SELECTNEXT   = 13,    // Select next phrase.
    SELECTWORD_CORRECTPREV  = 14,    // Correct previous phrase.
    SELECTWORD_CORRECTNEXT  = 15,    // Correct next phrase.
    SELECTWORD_GOTOBOTTOM   = 16,    // Go To Bottom
    SELECTWORD_GOTOTOP      = 17,    // Go To Top
    SELECTWORD_SELSENTENCE  = 18,    // Select Sentence
    SELECTWORD_SELPARAGRAPH = 19,    // Select Paragraph
    SELECTWORD_SELWORD      = 20,    // Select Word
    SELECTWORD_SELTHAT      = 21,    // Select That
    SELECTWORD_MAXCMDID     = 100
} SELECTWORD_OPERATION;

class __declspec(novtable) CSelectWord
{
public:
    CSelectWord(CSapiIMX *psi);
    virtual ~CSelectWord( );

    HRESULT  ProcessSelectWord(WCHAR *pwszSelectedWord, ULONG  ulLen, SELECTWORD_OPERATION m_sw_type, ULONG ulLenXXX = 0);
    HRESULT  _HandleSelectWord(TfEditCookie ec,ITfContext *pic,WCHAR *pwszSelectedWord, ULONG  ulLen, SELECTWORD_OPERATION m_sw_type, ULONG ulLenXXX = 0);

    HRESULT  UpdateTextBuffer(ISpRecoContext *pRecoCtxt, ISpRecoGrammar *pCmdGrammar);
    HRESULT  _UpdateTextBuffer(TfEditCookie ec,ITfContext *pic, ISpRecoContext *pRecoCtxt, ISpRecoGrammar *pCmdGrammar);

    HRESULT  _GetPrevOrNextPhrase(TfEditCookie ec,ITfContext *pic, BOOL fPrev, ITfRange **ppRangeOut);

    HRESULT  _ShiftComplete(TfEditCookie ec, ITfRange *pRange, LONG cchLenToShift, BOOL fStart);

    HRESULT  _GetActiveViewRange(TfEditCookie ec, ITfContext *pic, ITfRange **ppRangeView);

private:

    HRESULT  _SelectWord(TfEditCookie ec,ITfContext *pic);
    HRESULT  _DeleteWord(TfEditCookie ec,ITfContext *pic);
    HRESULT  _InsertAfterWord(TfEditCookie ec,ITfContext *pic);
    HRESULT  _InsertBeforeWord(TfEditCookie ec,ITfContext *pic);

    HRESULT  _SelectThrough(TfEditCookie ec, ITfContext *pic, WCHAR *pwszText, ULONG ulLen, ULONG ulLenXXX);
    HRESULT  _DeleteThrough(TfEditCookie ec, ITfContext *pic, WCHAR *pwszText, ULONG ulLen, ULONG ulLenXXX);

    HRESULT  _GetThroughRange(TfEditCookie ec, ITfContext *pic, WCHAR *pwszText, ULONG ulLen, ULONG ulLenXXX, ITfRange **ppRange);

    HRESULT  _GetTextAndSelectInCurrentView(TfEditCookie ec,ITfContext *pic, ULONG *pulOffSelStart=NULL, ULONG  *pulSelLen=NULL);
    HRESULT  _FindSelect(TfEditCookie ec, ITfContext *pic, BOOL  *fFound);

    HRESULT  _GetCUASCompositionRange(TfEditCookie ec, ITfContext *pic, ITfRange **ppRangeView);

    HRESULT  _GetTextFromRange(TfEditCookie ec, ITfRange *pRange, CSpDynamicString &dstr);

    HRESULT  _Unselect(TfEditCookie ec,ITfContext *pic);

    HRESULT  _CorrectWord(TfEditCookie ec,ITfContext *pic);

    HRESULT  _SelectPrevOrNextPhrase(TfEditCookie ec, ITfContext *pic, BOOL  fPrev);
    HRESULT  _SelectPreviousPhrase(TfEditCookie ec,ITfContext *pic);
    HRESULT  _SelectNextPhrase(TfEditCookie ec,ITfContext *pic);

    HRESULT  _SelectThat(TfEditCookie ec,ITfContext *pic);

    HRESULT  _CorrectPrevOrNextPhrase(TfEditCookie ec,ITfContext *pic, BOOL fPrev);
    HRESULT  _CorrectNextPhrase(TfEditCookie ec,ITfContext *pic);
    HRESULT  _CorrectPreviousPhrase(TfEditCookie ec,ITfContext *pic);
    HRESULT  _GoToBottom(TfEditCookie ec,ITfContext *pic);
    HRESULT  _GoToTop(TfEditCookie ec,ITfContext *pic);

    HRESULT  _SelectSpecialText(TfEditCookie ec,ITfContext *pic, SELECTWORD_OPERATION sw_Type);

    BOOL     _IsSentenceDelimiter(WCHAR  wch);
    BOOL     _IsParagraphDelimiter(WCHAR wch);
    BOOL     _IsWordDelimiter(WCHAR wch);

    CSapiIMX     *m_psi;
    WCHAR        *m_pwszSelectedWord;
    ULONG        m_ulLenSelected;

    CComPtr<ITfRange>   m_cpActiveRange;
    CComPtr<ITfRange>   m_cpSelectRange;
    CSpDynamicString    m_dstrActiveText;

};

#endif  // _SELWORD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\server.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       server.cpp
//
//  Contents:   COM server functionality.
//
//----------------------------------------------------------------------------

#include "private.h"
#include "globals.h"
#include "sapilayr.h"
#include "regsvr.h"
#include "regimx.h"
#include "status.h"
#include "catutil.h"
#include "cregkey.h"
#include "nui.h"
#include "mui.h"
#include "proppage.h"
#include "immxutil.h"

#ifdef DEBUG
DWORD g_dwThreadDllMain = 0;
#endif

BEGIN_COCLASSFACTORY_TABLE
    DECLARE_COCLASSFACTORY_ENTRY(CLSID_SapiLayr, CSapiIMX, TEXT("Cicero SAPI Layer IMX"))
    DECLARE_COCLASSFACTORY_ENTRY(CLSID_SpeechUIServer, CSpeechUIServer, TEXT("Cicero SAPI Layer Speech UI Server"))
END_COCLASSFACTORY_TABLE

extern CComModule _Module;

//+---------------------------------------------------------------------------
//
// ProcessAttach
//
//----------------------------------------------------------------------------

BOOL ProcessAttach(HINSTANCE hInstance)
{
    CcshellGetDebugFlags();
    Dbg_MemInit(TEXT("SPTIP"), NULL);
   
    g_hInst = hInstance;
    g_dwTlsIndex = TlsAlloc();
    
    if (!g_cs.Init())
        return FALSE;

    CSapiIMX::RegisterWorkerClass(hInstance);

    MuiLoadResource(hInstance, TEXT("sptip.dll"));

    _Module.Init(NULL, hInstance);

    return TRUE;
}


//+---------------------------------------------------------------------------
//
// ProcessDettach
//
//----------------------------------------------------------------------------

void ProcessDettach(HINSTANCE hInstance)
{
    _Module.Term();

    MuiClearResource();

    UninitProcess();

    g_cs.Delete();
    TlsFree(g_dwTlsIndex);

    Dbg_MemUninit();
}

//+---------------------------------------------------------------------------
//
// DllMain
//
//----------------------------------------------------------------------------

STDAPI_(BOOL) DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID pvReserved)
{
    BOOL bRet = TRUE;
#ifdef DEBUG
    g_dwThreadDllMain = GetCurrentThreadId();
#endif

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            //
            // Now real DllEntry point is _DllMainCRTStartup.
            // _DllMainCRTStartup does not call our DllMain(DLL_PROCESS_DETACH)
            // if our DllMain(DLL_PROCESS_ATTACH) fails.
            // So we have to clean this up.
            //
            if (!ProcessAttach(hInstance))
            {
                ProcessDettach(hInstance);
                bRet = FALSE;
            }
            break;

        case DLL_THREAD_ATTACH:
            break;

        case DLL_PROCESS_DETACH:
            ProcessDettach(hInstance);
            break;

        case DLL_THREAD_DETACH:
            FreeSPTIPTHREAD();
            break;
    }

#ifdef DEBUG
    g_dwThreadDllMain = 0;
#endif

    return bRet;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppvObj)
{
    return COMBase_DllGetClassObject(rclsid, riid, ppvObj);
}

STDAPI DllCanUnloadNow(void)
{
    return COMBase_DllCanUnloadNow();
}

const REGISTERCAT c_rgRegCat[] =
{
    {&GUID_TFCAT_TIP_SPEECH,       &CLSID_SapiLayr},
    {&GUID_TFCAT_PROPSTYLE_STATIC, &GUID_PROP_SAPI_DISPATTR},
    {&GUID_TFCAT_PROPSTYLE_CUSTOM, &GUID_PROP_SAPIRESULTOBJECT},
    {&GUID_TFCAT_PROP_AUDIODATA,   &GUID_PROP_SAPIRESULTOBJECT},
    {&GUID_TFCAT_PROPSTYLE_CUSTOM, &GUID_PROP_LMLATTICE},
    {&GUID_TFCAT_DISPLAYATTRIBUTEPROVIDER,     &CLSID_SapiLayr},
    {&GUID_TFCAT_DISPLAYATTRIBUTEPROPERTY,     &GUID_PROP_SAPI_DISPATTR},
    {NULL, NULL}
};

REGTIPLANGPROFILE rgNulProf[] = {
    {0x0FFFF, &c_guidProfileBogus, L"Speech Recognition",  L"sptip.dll",  0, IDS_DEFAULT_PROFILE},
    {0, NULL, L"",  L"",  0, 0},
};


STDAPI DllRegisterServer(void)
{
    WCHAR szDAP[]    = L"SAPI Layer Display Attribute Provider";
    WCHAR szDAProp[] = L"SAPI Layer Display Attribute Property";
    WCHAR szDefaultProf[128];
    HRESULT hr = E_FAIL;
    CComPtr<ITfInputProcessorProfiles> cpProfileMgr;

    TFInitLib();

    if (COMBase_DllRegisterServer() != S_OK)
        goto Exit;

    if (CicLoadStringWrapW(g_hInst, IDS_DEFAULT_PROFILE, szDefaultProf, ARRAYSIZE(szDefaultProf)))
        StringCchCopyW(rgNulProf->szProfile,ARRAYSIZE(rgNulProf->szProfile), szDefaultProf);

    if (!RegisterTIP(g_hInst, CLSID_SapiLayr, L"SapiLayer TIP", rgNulProf))
        goto Exit;

    if (FAILED(RegisterCategories(CLSID_SapiLayr, c_rgRegCat)))
        goto Exit;

    if (FAILED(TF_CreateInputProcessorProfiles(&cpProfileMgr)))
        goto Exit;
        
    cpProfileMgr->EnableLanguageProfileByDefault( CLSID_SapiLayr,
                                                  0xffff,
                                                  c_guidProfileBogus,
                                                  FALSE);
    // Save the default property values to HKLM

    CSpPropItemsServer   *pSpPropServer;

    pSpPropServer = (CSpPropItemsServer   *) new CSpPropItemsServer;

    if ( pSpPropServer )
    {
        pSpPropServer->_SaveDefaultData( );
        delete pSpPropServer;
    }

    hr = S_OK;

Exit:
    TFUninitLib( );
    return hr;
}

STDAPI DllUnregisterServer(void)
{
    HRESULT hr = E_FAIL;

    TFInitLib();

    if (COMBase_DllUnregisterServer() != S_OK)
        goto Exit;

    if (FAILED(UnregisterCategories(CLSID_SapiLayr, c_rgRegCat)))
        goto Exit;

    if (!UnregisterTIP(CLSID_SapiLayr))
        goto Exit;

    hr = S_OK;

Exit:
    TFUninitLib( );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\case\case.h ===
//
// case.h
//
// CCaseTextService declaration.
//

#ifndef CASE_H
#define CASE_H

class CLangBarItemButton;
class CSnoopWnd;

class CCaseTextService : public ITfTextInputProcessor,
                         public ITfThreadMgrEventSink,
                         public ITfTextEditSink,
                         public ITfThreadFocusSink,
                         public ITfKeyEventSink
{
public:
    CCaseTextService();
    ~CCaseTextService();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ITfTextInputProcessor
    STDMETHODIMP Activate(ITfThreadMgr *pThreadMgr, TfClientId tfClientId);
    STDMETHODIMP Deactivate();

    // ITfThreadMgrEventSink
    STDMETHODIMP OnInitDocumentMgr(ITfDocumentMgr *pDocMgr);
    STDMETHODIMP OnUninitDocumentMgr(ITfDocumentMgr *pDocMgr);
    STDMETHODIMP OnSetFocus(ITfDocumentMgr *pDocMgrFocus, ITfDocumentMgr *pDocMgrPrevFocus);
    STDMETHODIMP OnPushContext(ITfContext *pContext);
    STDMETHODIMP OnPopContext(ITfContext *pContext);

    // ITfThreadFocusSink
    STDMETHODIMP OnSetThreadFocus();
    STDMETHODIMP OnKillThreadFocus();

    // ITfTextEditSink
    STDMETHODIMP OnEndEdit(ITfContext *pContext, TfEditCookie ecReadOnly, ITfEditRecord *pEditRecord);

    // ITfKeyEventSink
    STDMETHODIMP OnSetFocus(BOOL fForeground);
    STDMETHODIMP OnTestKeyDown(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP OnKeyDown(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP OnTestKeyUp(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP OnKeyUp(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP OnPreservedKey(ITfContext *pContext, REFGUID rguid, BOOL *pfEaten);

    // CClassFactory factory callback
    static HRESULT CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);

    // server registration
    static BOOL RegisterProfiles();
    static void UnregisterProfiles();
    static BOOL RegisterCategories(BOOL fRegister);
    static BOOL RegisterServer();
    static void UnregisterServer();

    // language bar menu handlers
    static void _Menu_HelloWord(CCaseTextService *_this);
    static void _Menu_FlipSel(CCaseTextService *_this);
    static void _Menu_FlipDoc(CCaseTextService *_this);
    static void _Menu_ShowSnoopWnd(CCaseTextService *_this);
    static void _Menu_FlipKeys(CCaseTextService *_this);

    ITfThreadMgr *_GetThreadMgr() { return _pThreadMgr; }
    TfClientId _GetClientId() { return _tfClientId; }
    BOOL _IsSnoopWndVisible() { return _fShowSnoop; }
    BOOL _IsKeyFlipping() { return _fFlipKeys; }

private:
    // init methods
    BOOL _InitLanguageBar();
    BOOL _InitThreadMgrSink();
    BOOL _InitSnoopWnd();
    BOOL _InitTextEditSink(ITfDocumentMgr *pDocMgr);
    BOOL _InitKeystrokeSink();
    BOOL _InitPreservedKey();

    // uninit methods
    void _UninitLanguageBar();
    void _UninitThreadMgrSink();
    void _UninitSnoopWnd();
    void _UninitKeystrokeSink();
    void _UninitPreservedKey();

    //
    // state
    //

    ITfThreadMgr *_pThreadMgr;
    TfClientId _tfClientId;

    BOOL _fShowSnoop; // hide/show the snoop window popup
    CSnoopWnd *_pSnoopWnd;

    BOOL _fFlipKeys;

    CLangBarItemButton *_pLangBarItem;

    DWORD _dwThreadMgrEventSinkCookie;
    DWORD _dwThreadFocusSinkCookie;
    DWORD _dwTextEditSinkCookie;
    ITfContext *_pTextEditSinkContext;

    LONG _cRef;     // COM ref count
};


#endif // CASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\sptiphlp.h ===
//
//  Header Files for speech tip context help ids.
//

#ifndef SPTIPHLP_H
#define SPTIPHLP_H

// Id starts from 4000

// Speech tip property page

#define IDH_PP_ASSIGN_BUTTON                              4000
#define IDH_PP_BUTTON_MB_SETTING                          4001
#define IDH_PP_SHOW_BALLOON                               4002
#define IDH_PP_LMA                                        4003
#define IDH_PP_HIGH_CONFIDENCE                            4004
#define IDH_PP_SAVE_SPDATA                                4005
#define IDH_PP_REMOVE_SPACE                               4006
#define IDH_PP_DIS_DICT_TYPING                            4007
#define IDH_PP_PLAYBACK                                   4008
#define IDH_PP_DICT_CANDUI_OPEN                           4009
#define IDH_PP_BUTTON_ADVANCE                             4010
#define IDH_PP_BUTTON_SPCPL                               4011
#define IDH_PP_BUTTON_LANGBAR                             4012


// Voice command settings Dialog 
#define IDH_PP_SELECTION_CMD                              4020
#define IDH_PP_NAVIGATION_CMD                             4021
#define IDH_PP_CASING_CMD                                 4022
#define IDH_PP_EDITING_CMD                                4023
#define IDH_PP_KEYBOARD_CMD                               4024
#define IDH_PP_TTS_CMD                                    4025
#define IDH_PP_LANGBAR_CMD                                4026
#define IDH_PP_DICTCMDS                                   4027

// Mode button configuration
#define IDH_PP_DICTATION_CMB                              4030
#define IDH_PP_COMMAND_CMB                                4031

#endif // SPTIPHLP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\sysbtn.cpp ===
//
// sysbtn.cpp
//

#include "private.h"
#include "globals.h"
#include "immxutil.h"
#include "sapilayr.h"
#include "xstring.h"
#include "sysbtn.h"
#include "nui.h"

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemSystemButtonBase
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CLBarItemSystemButtonBase::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfLangBarItem))
    {
        *ppvObj = SAFECAST(this, ITfLangBarItem *);
    }
    else if (IsEqualIID(riid, IID_ITfLangBarItemButton))
    {
        *ppvObj = SAFECAST(this, ITfLangBarItemButton *);
    }
    else if (IsEqualIID(riid, IID_ITfSource))
    {
        *ppvObj = SAFECAST(this, ITfSource *);
    }
    else if (IsEqualIID(riid, IID_ITfSystemLangBarItem))
    {
        *ppvObj = SAFECAST(this, ITfSystemLangBarItem *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CLBarItemSystemButtonBase::AddRef()
{
    return CLBarItemButtonBase::AddRef();
}

STDAPI_(ULONG) CLBarItemSystemButtonBase::Release()
{
    return CLBarItemButtonBase::Release();
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItemSystemButtonBase::CLBarItemSystemButtonBase()
{
}

//----------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLBarItemSystemButtonBase::~CLBarItemSystemButtonBase()
{
    if (_pMenuMap)
        delete _pMenuMap;
}

//+---------------------------------------------------------------------------
//
// AdviseSink
//
//----------------------------------------------------------------------------

STDAPI CLBarItemSystemButtonBase::AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie)
{
    HRESULT hr;

    hr = CLBarItemButtonBase::AdviseSink(riid, punk, pdwCookie);
    if( S_OK != hr)
    {

        const IID *rgiid = &IID_ITfSystemLangBarItemSink;
        hr = GenericAdviseSink(riid, punk, &rgiid, &_rgEventSinks, 1, pdwCookie);
        if (hr == S_OK)
        {
            // adjust the cookie so we don't overlap with idle detector sinks
            *pdwCookie = GenericChainToCookie(*pdwCookie, 1);
        }
    }

    

    return hr;
}

//+---------------------------------------------------------------------------
//
// UnadviseSink
//
//----------------------------------------------------------------------------

STDAPI CLBarItemSystemButtonBase::UnadviseSink(DWORD dwCookie)
{
    HRESULT hr =  CLBarItemButtonBase::UnadviseSink(dwCookie);
    if (hr == S_OK)
       return hr;

    dwCookie = GenericUnchainToCookie(dwCookie, 1);
    return GenericUnadviseSink(&_rgEventSinks, 1, dwCookie);
}

//+---------------------------------------------------------------------------
//
// GetInfo
//
//----------------------------------------------------------------------------

STDAPI CLBarItemSystemButtonBase::GetInfo(TF_LANGBARITEMINFO *pInfo)
{
    return CLBarItemButtonBase::GetInfo(pInfo);
}

//+---------------------------------------------------------------------------
//
// Show
//
//----------------------------------------------------------------------------

STDAPI CLBarItemSystemButtonBase::Show(BOOL fShow)
{
    return CLBarItemButtonBase::Show(fShow);
}

//----------------------------------------------------------------------------
//
// SetIcon
//
//----------------------------------------------------------------------------

STDAPI CLBarItemSystemButtonBase::SetIcon(HICON hIcon)
{
    CLBarItemButtonBase::SetIcon(hIcon);
    return S_OK;
}

//----------------------------------------------------------------------------
//
// SetTooltipString
//
//----------------------------------------------------------------------------

STDAPI CLBarItemSystemButtonBase::SetTooltipString(WCHAR *pchToolTip, ULONG cch)
{
    SetToolTip(pchToolTip);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _InsertCustomMenus
//
//----------------------------------------------------------------------------

BOOL CLBarItemSystemButtonBase::_InsertCustomMenus(ITfMenu *pMenu, UINT *pnTipCurMenuID)
{
    int nCntEventSink;
    int i;
    BOOL bRet = FALSE;

    //
    // Insert Custom item to menu
    //
    ClearMenuMap();

    nCntEventSink = _rgEventSinks.Count();
    for (i = 0; i < nCntEventSink; i++)
    {
         CCicLibMenu *pMenuTmp;
         GENERICSINK *pSink;
         ITfSystemLangBarItemSink *plbSink;

         
         if (!_pMenuMap)
             _pMenuMap = new CStructArray<TIPMENUITEMMAP>;

         if (!_pMenuMap)
         {
             Assert(0);
             goto Exit;
         }


         pMenuTmp = new CCicLibMenu;
         if (!pMenuTmp)
         {
             goto Exit;
         }

         pSink = _rgEventSinks.GetPtr(i);

         if (SUCCEEDED(pSink->pSink->QueryInterface(
                                      IID_ITfSystemLangBarItemSink,
                                      (void **)&plbSink)))
         {
             if (SUCCEEDED(plbSink->InitMenu(pMenuTmp)))
             {
                 if (*pnTipCurMenuID > IDM_CUSTOM_MENU_START)
                     LangBarInsertSeparator(pMenu);

                 *pnTipCurMenuID = _MergeMenu(pMenu, 
                                            pMenuTmp, 
                                            plbSink, 
                                            _pMenuMap, 
                                            *pnTipCurMenuID);
             }
             plbSink->Release();
         }
         else
         {
             Assert(0);
         }

         pMenuTmp->Release();
    }

    bRet = TRUE;
Exit:
    return bRet;
}

//+---------------------------------------------------------------------------
//
// _MergeMenu
//
//----------------------------------------------------------------------------
#define MIIM_ALL  ( MIIM_STATE | MIIM_ID | MIIM_SUBMENU | MIIM_CHECKMARKS | MIIM_STRING | MIIM_BITMAP | MIIM_FTYPE )

UINT CLBarItemSystemButtonBase::_MergeMenu(ITfMenu *pMenu, 
                                     CCicLibMenu *pMenuTip, 
                                     ITfSystemLangBarItemSink *plbSink, 
                                     CStructArray<TIPMENUITEMMAP> *pMenuMap, 
                                     UINT &nCurID)
{
    int i;
    int nMenuCnt = pMenuTip->GetItemCount();

    if (nMenuCnt <= 0)
        return nCurID;

    for (i = 0; i < nMenuCnt; i++)
    {
        CCicLibMenuItem *pItem = pMenuTip->GetItem(i);
        TIPMENUITEMMAP *ptmm;
        int nCnt;

        nCnt = pMenuMap->Count();
        if (!pMenuMap->Insert(nCnt, 1))
            return nCurID;

        ptmm = pMenuMap->GetPtr(nCnt);
        ptmm->plbSink = plbSink;
        ptmm->nOrgID = pItem->GetId();
        ptmm->nTmpID = nCurID++;

        if (pItem->GetSubMenu())
        {
            ITfMenu *pSubMenu = NULL;
            if (SUCCEEDED(pMenu->AddMenuItem((UINT)-1,
                                             pItem->GetFlags(),
                                             pItem->GetBitmap(),
                                             pItem->GetBitmapMask(),
                                             pItem->GetText(),
                                             wcslen(pItem->GetText()),
                                             &pSubMenu)))
            {
                _MergeMenu(pSubMenu, 
                           pItem->GetSubMenu(), 
                           plbSink, 
                           pMenuMap, 
                           nCurID);

                pSubMenu->Release();
            }
        }
        else
        {
            pMenu->AddMenuItem(ptmm->nTmpID,
                               pItem->GetFlags(),
                               pItem->GetBitmap(),
                               pItem->GetBitmapMask(),
                               pItem->GetText(),
                               wcslen(pItem->GetText()),
                               NULL);
        }
    }

    return nCurID;
}

STDAPI CLBarItemSystemButtonBase::OnMenuSelect(UINT wID)
{
   HRESULT hr = S_OK;
   int nMenuMapoCnt = _pMenuMap->Count();
   for (int i = 0; i < nMenuMapoCnt; i++)
   {
       TIPMENUITEMMAP *ptmm;
       ptmm = _pMenuMap->GetPtr(i);
       if (ptmm->nTmpID == (UINT)wID)
       {
           hr = ptmm->plbSink->OnMenuSelect(ptmm->nOrgID);
           break;
       }
   }
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\sysbtn.h ===
//
// sysbtn.h
//

#ifndef SYSBTN_H
#define SYSBTN_H

#include "private.h"
#include "nuibase.h"
#include "lbmenu.h"
#include "ids.h"
#include "cicspres.h"


typedef struct tag_TIPMENUITEMMAP {
    ITfSystemLangBarItemSink *plbSink;
    UINT nOrgID;
    UINT nTmpID;
} TIPMENUITEMMAP;

class __declspec(novtable)  
CLBarItemSystemButtonBase : public CLBarItemButtonBase,
                            public ITfSystemLangBarItem
{
public:
    CLBarItemSystemButtonBase();
    ~CLBarItemSystemButtonBase();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfSource
    //
    STDMETHODIMP AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie);
    STDMETHODIMP UnadviseSink(DWORD dwCookie);

    //
    // ITfLangBarItem
    //
    STDMETHODIMP GetInfo(TF_LANGBARITEMINFO *pInfo);
    STDMETHODIMP Show(BOOL fShow);

    //
    // ITfSystemLangBarItem
    //
    STDMETHODIMP SetIcon(HICON hIcon);
    STDMETHODIMP SetTooltipString(WCHAR *pchToolTip, ULONG cch);

    //
    STDMETHODIMP OnMenuSelect(UINT wID);

protected:
    BOOL _InsertCustomMenus(ITfMenu *pMenu, UINT *pnTipCurMenuID);
    UINT _MergeMenu(ITfMenu *pMenu, CCicLibMenu *pMenuTip, ITfSystemLangBarItemSink *plbSink, CStructArray<TIPMENUITEMMAP> *pMenuMap, UINT &nCurID);

    CStructArray<TIPMENUITEMMAP> *_pMenuMap;
    void ClearMenuMap()
    {
        if (_pMenuMap)
            _pMenuMap->Clear();
    }


    CStructArray<GENERICSINK> _rgEventSinks; // ITfSystemLangBarItemSink
};

#endif SYSBTN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\case\dllmain.cpp ===
//
// dllmain.cpp
//
// DllMain module entry point.
//

#include "globals.h"
#include "snoop.h"

//+---------------------------------------------------------------------------
//
// DllMain
//
//----------------------------------------------------------------------------

BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID pvReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:

            g_hInst = hInstance;

            if (!InitializeCriticalSectionAndSpinCount(&g_cs, 0))
                return FALSE;

            CSnoopWnd::_InitClass();

            break;

        case DLL_PROCESS_DETACH:

            CSnoopWnd::_UninitClass();

            DeleteCriticalSection(&g_cs);

            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\tts.h ===
#ifndef _TTS_H
#define _TTS_H

#include "sapilayr.h"
#include "kes.h"

class CSapiIMX;
class CSpTask;

class __declspec(novtable) CTextToSpeech
{
public:
    CTextToSpeech(CSapiIMX *psi);
    virtual ~CTextToSpeech( );

    HRESULT  TtsPlay( );
    HRESULT  TtsStop( );
    HRESULT  TtsPause( );
    HRESULT  TtsResume( );

    HRESULT  _TtsPlay(TfEditCookie ec,ITfContext *pic);
    HRESULT  _SetTTSButtonStatus(ITfContext  *pic);
    BOOL     _IsPureCiceroIC(ITfContext  *pic);

    HRESULT  _HandleEventOnPlayButton( );
    HRESULT  _HandleEventOnPauseButton( );

    BOOL     _IsInPlay( ) { return m_fIsInPlay; }
    BOOL     _IsInPause( ) { return m_fIsInPause; }
    void     _SetPlayMode(BOOL  fIsInPlay )
    { 
        m_fIsInPlay = fIsInPlay; 
        // Temporally enable or disable dictation if dictation is ON

        // if it Is In Play, Disable Dictation.
        // if it Is Not In Play, Enable Dicatation.
        _SetDictation(!fIsInPlay);
    };

    void     _SetPauseMode(BOOL fIsInPause )  
    { 
        m_fIsInPause = fIsInPause;
        // Temporally enable or disable dictation if dictation is ON
        //
        // if it is In pause, Enable dictation.
        // if it is not In pause, Disable Dication.
        _SetDictation(fIsInPause);
    };

private:

    void     _SetDictation( BOOL fEnable );

    CSapiIMX               *m_psi;
    CComPtr<ITfFnPlayBack>  m_cpPlayBack;
    BOOL                    m_fPlaybackInitialized;
    BOOL                    m_fIsInPlay;
    BOOL                    m_fIsInPause;
};

#endif  // _TTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\case\case.cpp ===
//
// case.cpp
//
// IUnknown, ITfTextInputProcessor implementation.
//

#include "globals.h"
#include "case.h"

//+---------------------------------------------------------------------------
//
// CreateInstance
//
//----------------------------------------------------------------------------

/* static */
HRESULT CCaseTextService::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    CCaseTextService *pCase;
    HRESULT hr;

    if (ppvObj == NULL)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (NULL != pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    if ((pCase = new CCaseTextService) == NULL)
        return E_OUTOFMEMORY;

    hr = pCase->QueryInterface(riid, ppvObj);

    pCase->Release(); // caller still holds ref if hr == S_OK

    return hr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CCaseTextService::CCaseTextService()
{
    DllAddRef();

    _pThreadMgr = NULL;
    _tfClientId = TF_CLIENTID_NULL;

    _fShowSnoop = FALSE;
    _pSnoopWnd = NULL;

    _pLangBarItem = NULL;

    _fFlipKeys = FALSE;

    _dwThreadMgrEventSinkCookie = TF_INVALID_COOKIE;
    _dwThreadFocusSinkCookie = TF_INVALID_COOKIE;
    _dwTextEditSinkCookie = TF_INVALID_COOKIE;
    _pTextEditSinkContext = NULL;

    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CCaseTextService::~CCaseTextService()
{
    DllRelease();
}

//+---------------------------------------------------------------------------
//
// QueryInterface
//
//----------------------------------------------------------------------------

STDAPI CCaseTextService::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfTextInputProcessor))
    {
        *ppvObj = (ITfTextInputProcessor *)this;
    }
    else if (IsEqualIID(riid, IID_ITfThreadMgrEventSink))
    {
        *ppvObj = (ITfThreadMgrEventSink *)this;
    }
    else if (IsEqualIID(riid, IID_ITfThreadFocusSink))
    {
        *ppvObj = (ITfThreadFocusSink *)this;
    }
    else if (IsEqualIID(riid, IID_ITfTextEditSink))
    {
        *ppvObj = (ITfTextEditSink *)this;
    }
    else if (IsEqualIID(riid, IID_ITfKeyEventSink))
    {
        *ppvObj = (ITfKeyEventSink *)this;
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//+---------------------------------------------------------------------------
//
// AddRef
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CCaseTextService::AddRef()
{
    return ++_cRef;
}

//+---------------------------------------------------------------------------
//
// Release
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CCaseTextService::Release()
{
    LONG cr = --_cRef;

    assert(_cRef >= 0);

    if (_cRef == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// Activate
//
//----------------------------------------------------------------------------

STDAPI CCaseTextService::Activate(ITfThreadMgr *pThreadMgr, TfClientId tfClientId)
{
    _pThreadMgr = pThreadMgr;
    _pThreadMgr->AddRef();

    _tfClientId = tfClientId;

    if (!_InitLanguageBar())
        goto ExitError;

    if (!_InitThreadMgrSink())
        goto ExitError;

    if (!_InitSnoopWnd())
        goto ExitError;

    if (!_InitKeystrokeSink())
        goto ExitError;

    if (!_InitPreservedKey())
        goto ExitError;

    return S_OK;

ExitError:
    Deactivate(); // cleanup any half-finished init
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
// Deactivate
//
//----------------------------------------------------------------------------

STDAPI CCaseTextService::Deactivate()
{
    _UninitSnoopWnd();
    _UninitThreadMgrSink();
    _UninitLanguageBar();
    _UninitKeystrokeSink();
    _UninitPreservedKey();

    // we MUST release all refs to _pThreadMgr in Deactivate
    SafeReleaseClear(_pThreadMgr);

    _tfClientId = TF_CLIENTID_NULL;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\case\editsess.h ===
//
// editsess.h
//
// CEditSessionBase declaration.
//

#ifndef EDITSESS_H
#define EDITSESS_H

class CEditSessionBase : public ITfEditSession
{
public:
    CEditSessionBase(ITfContext *pContext)
    {
        _cRef = 1;
        _pContext = pContext;
        _pContext->AddRef();
    }
    virtual ~CEditSessionBase()
    {
        _pContext->Release();
    }

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj)
    {
        if (ppvObj == NULL)
            return E_INVALIDARG;

        *ppvObj = NULL;

        if (IsEqualIID(riid, IID_IUnknown) ||
            IsEqualIID(riid, IID_ITfEditSession))
        {
            *ppvObj = (ITfLangBarItemButton *)this;
        }

        if (*ppvObj)
        {
            AddRef();
            return S_OK;
        }

        return E_NOINTERFACE;
    }
    STDMETHODIMP_(ULONG) AddRef(void)
    {
        return ++_cRef;
    }
    STDMETHODIMP_(ULONG) Release(void)
    {
        LONG cr = --_cRef;

        assert(_cRef >= 0);

        if (_cRef == 0)
        {
            delete this;
        }

        return cr;
    }

    // ITfEditSession
    virtual STDMETHODIMP DoEditSession(TfEditCookie ec) = 0;

protected:
    ITfContext *_pContext;

private:
    LONG _cRef;     // COM ref count
};

#endif // EDITSESS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\case\editsink.cpp ===
//
// editsink.cpp
//
// ITfTextEditSink implementation.
//

#include "globals.h"
#include "case.h"
#include "snoop.h"

//+---------------------------------------------------------------------------
//
// OnEndEdit
//
// Called by the system whenever anyone releases a write-access document lock.
//----------------------------------------------------------------------------

STDAPI CCaseTextService::OnEndEdit(ITfContext *pContext, TfEditCookie ecReadOnly, ITfEditRecord *pEditRecord)
{
    BOOL fSelectionChanged;
    IEnumTfRanges *pEnumTextChanges;
    ITfRange *pRange;

    // we'll use the endedit notification to update the snoop window

    // did the selection change?
    if (pEditRecord->GetSelectionStatus(&fSelectionChanged) == S_OK &&
        fSelectionChanged)
    {
        _pSnoopWnd->_UpdateText(ecReadOnly, pContext, NULL);
        return S_OK;
    }

    // text modification?
    if (pEditRecord->GetTextAndPropertyUpdates(TF_GTP_INCL_TEXT, NULL, 0, &pEnumTextChanges) == S_OK)
    {
        if (pEnumTextChanges->Next(1, &pRange, NULL) == S_OK)
        {
            // arbitrary update the snoop window with the first change
            // there may be more than one in the enumerator, but we don't care here
            _pSnoopWnd->_UpdateText(ecReadOnly, pContext, pRange);
            pRange->Release();
        }

        pEnumTextChanges->Release();
    }

    // if we get here, only property values changed

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _InitTextEditSink
//
// Init a text edit sink on the topmost context of the document.
// Always release any previous sink.
//----------------------------------------------------------------------------

BOOL CCaseTextService::_InitTextEditSink(ITfDocumentMgr *pDocMgr)
{
    ITfSource *pSource;
    BOOL fRet;

    // clear out any previous sink first

    if (_dwTextEditSinkCookie != TF_INVALID_COOKIE)
    {
        if (_pTextEditSinkContext->QueryInterface(IID_ITfSource, (void **)&pSource) == S_OK)
        {
            pSource->UnadviseSink(_dwTextEditSinkCookie);
            pSource->Release();
        }

        _pTextEditSinkContext->Release();
        _pTextEditSinkContext = NULL;
        _dwTextEditSinkCookie = TF_INVALID_COOKIE;
    }

    if (pDocMgr == NULL)
        return TRUE; // caller just wanted to clear the previous sink

    // setup a new sink advised to the topmost context of the document

    if (pDocMgr->GetTop(&_pTextEditSinkContext) != S_OK)
        return FALSE;

    if (_pTextEditSinkContext == NULL)
        return TRUE; // empty document, no sink possible

    fRet = FALSE;

    if (_pTextEditSinkContext->QueryInterface(IID_ITfSource, (void **)&pSource) == S_OK)
    {
        if (pSource->AdviseSink(IID_ITfTextEditSink, (ITfTextEditSink *)this, &_dwTextEditSinkCookie) == S_OK)
        {
            fRet = TRUE;
        }
        else
        {
            _dwTextEditSinkCookie = TF_INVALID_COOKIE;
        }
        pSource->Release();
    }

    if (fRet == FALSE)
    {
        _pTextEditSinkContext->Release();
        _pTextEditSinkContext = NULL;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sapilayr\tts.cpp ===
//
//
// Sapilayr TIP CTextToSpeech implementation.
//
//
#include "private.h"
#include "sapilayr.h"
#include "nui.h"
#include "tts.h"


// -------------------------------------------------------
//
//  Implementation for CTextToSpeech
//
// -------------------------------------------------------

CTextToSpeech::CTextToSpeech(CSapiIMX *psi) 
{
    m_psi = psi;
    m_fPlaybackInitialized = FALSE;
    m_fIsInPlay = FALSE;
    m_fIsInPause = FALSE;
}

CTextToSpeech::~CTextToSpeech( ) 
{

};

/*  --------------------------------------------------------
//    Function Name: _SetDictation
//
//    Description: Temporally change the dictation status  
//                 while TTS is playing. 
//
//
// ----------------------------------------------------------*/

void     CTextToSpeech::_SetDictation( BOOL fEnable )
{
    BOOL    fDictOn;

    fDictOn = m_psi->GetDICTATIONSTAT_DictOnOff() && m_psi->GetOnOff() &&
         !m_psi->Get_SPEECH_DISABLED_Disabled()  && !m_psi->Get_SPEECH_DISABLED_DictationDisabled();

    // Only when the dictation status now is On, we change the 
    // status based on required value.

    if ( fDictOn )
    {
        // Temporally Enable/disable dictation.
        CSpTask           *psp;
        m_psi->GetSpeechTask(&psp); 

        if (psp)
        {
            if (psp->m_cpDictGrammar)
            {
                (psp->m_cpDictGrammar)->SetDictationState(fEnable ? SPRS_ACTIVE: SPRS_INACTIVE);
            }

            psp->Release();
        }
    }
}


/*  --------------------------------------------------------
//    Function Name: TtsPlay
//
//    Description: Play sound for currect selection or text 
//                 in visible area. 
//
//
// ----------------------------------------------------------*/
HRESULT  CTextToSpeech::TtsPlay( )
{
    HRESULT              hr = E_FAIL;

    if ( !m_psi )
        return E_FAIL;

    if ( !m_fPlaybackInitialized  )
    {
        hr = m_psi->GetFunction(GUID_NULL, IID_ITfFnPlayBack, (IUnknown **)&m_cpPlayBack);

        if ( hr == S_OK )
            m_fPlaybackInitialized = TRUE;
    }

    if ( m_fPlaybackInitialized )
    {
        // Stop the possible previous speaking 
        TtsStop( );

        hr = m_psi->_RequestEditSession(ESCB_TTS_PLAY, TF_ES_READWRITE);
    }

    return hr;
}

/*  --------------------------------------------------------
//   Function Name: _TtsPlay
//
//   Description:   Edit session callback function for
//                  TtsPlay (ESCB_TTS_PLAY) 
//                  It will call ITfFnPlayBack->Play( ). 
//   
// ----------------------------------------------------------*/
HRESULT  CTextToSpeech::_TtsPlay(TfEditCookie ec,ITfContext *pic)
{
    HRESULT             hr = S_OK;
    CComPtr<ITfRange>   cpSelRange = NULL;
    BOOL                fEmpty = TRUE;
    BOOL                fPlayed = FALSE;

    hr = GetSelectionSimple(ec, pic, &cpSelRange);

    if ( hr == S_OK )
        cpSelRange->IsEmpty(ec, &fEmpty);

    if ( hr == S_OK && !fEmpty && m_cpPlayBack)
    {
        hr = m_cpPlayBack->Play(cpSelRange);
        fPlayed = TRUE;
    }
    else 
    {
        CComPtr<ITfRange>         cpRangeView;

        // Get the Active View Range
        hr = m_psi->_GetActiveViewRange(ec, pic, &cpRangeView);

        if( hr == S_OK )
        {
            if ( cpSelRange )
            {
                LONG    l;
                hr = cpRangeView->CompareStart(ec, cpSelRange, TF_ANCHOR_START, &l);

                if ( hr == S_OK && l > 0 )
                {
                    // Current selection is not in current active view.
                    // Use Start Anchor in active view as start point.
                    cpSelRange.Release( );
                    hr = cpRangeView->Clone(&cpSelRange);
                }
            }
            else
            {
                cpSelRange.Release( );
                hr = cpRangeView->Clone(&cpSelRange);
            }

            if ( hr == S_OK && cpSelRange )
            {
                hr = cpSelRange->ShiftEndToRange(ec, cpRangeView, TF_ANCHOR_END);

                if ( hr == S_OK )
                {
                    cpSelRange->IsEmpty(ec, &fEmpty);

                    if ( hr == S_OK && !fEmpty)
                    {
                        hr = m_cpPlayBack->Play(cpSelRange);
                        fPlayed = TRUE;
                    }
                }
            }
        }
    }


    if (!fPlayed )
    {
        CSpeechUIServer *pSpeechUIServer;
        pSpeechUIServer = m_psi->GetSpeechUIServer( );

        if ( pSpeechUIServer )
           pSpeechUIServer->SetTtsPlayOnOff( FALSE );
    }

    return hr;
}

/*  --------------------------------------------------------
//    Function Name: TtsStop
//
//    Description:   Stop current TTS playing immediately
//                   
//                   update the TTS session status.
//
// ----------------------------------------------------------*/
HRESULT  CTextToSpeech::TtsStop( )
{
    HRESULT   hr=S_OK;

    if ( _IsInPlay( ) && m_psi )
    {
        CComPtr<ISpVoice>  cpSpVoice;
        CSpTask           *psp;

        hr = m_psi->GetSpeechTask(&psp); 
        if (hr == S_OK)
        {
            cpSpVoice = psp->_GetSpVoice( );
            if ( cpSpVoice )
                hr = cpSpVoice->Speak( NULL, SPF_PURGEBEFORESPEAK, NULL );
            psp->Release();

            _SetPlayMode(FALSE);
        }
    }

    return hr;
}

/*  --------------------------------------------------------
//    Function Name: TtsPause
//
//    Description:   Pause current TTS playing immediately
//                   
//                   update the TTS session status.
//
// ----------------------------------------------------------*/
HRESULT  CTextToSpeech::TtsPause( )
{
    HRESULT   hr=S_OK;

    if ( _IsInPlay( ) && m_psi )
    {
        CComPtr<ISpVoice>  cpSpVoice;
        CSpTask           *psp;

        hr = m_psi->GetSpeechTask(&psp); 
        if (hr == S_OK)
        {
            cpSpVoice = psp->_GetSpVoice( );
            if ( cpSpVoice )
                hr = cpSpVoice->Pause( );
            psp->Release();

            _SetPauseMode(TRUE);
        }
    }

    return hr;
}

/*  --------------------------------------------------------
//    Function Name: TtsResume
//
//    Description:   Resume previous paused playing                   
//                   update the TTS session status.
//
// ----------------------------------------------------------*/
HRESULT  CTextToSpeech::TtsResume( )
{
    HRESULT   hr=S_OK;

    if ( _IsInPause( ) && m_psi )
    {
        CComPtr<ISpVoice>  cpSpVoice;
        CSpTask           *psp;

        hr = m_psi->GetSpeechTask(&psp); 
        if (hr == S_OK)
        {
            cpSpVoice = psp->_GetSpVoice( );
            if ( cpSpVoice )
                hr = cpSpVoice->Resume( );
            psp->Release();

            _SetPauseMode(FALSE);
        }
    }

    return hr;
}

/*  --------------------------------------------------------
//    Function Name: _IsPureCiceroIC
//
//    Description:   Check current IC attribute to 
//                   determine it is PureCicero aware
//                   or AIMM aware.
//                  
// ----------------------------------------------------------*/
BOOL  CTextToSpeech::_IsPureCiceroIC(ITfContext  *pic)
{
    BOOL        fCiceroNative = FALSE;
    HRESULT     hr = S_OK;

    if ( pic )
    {
        TF_STATUS   tss;

        hr = pic->GetStatus(&tss);
        if (S_OK == hr)
        {
            //
            // If TS_SS_TRANSITORY is not set, means it is Cicero Aware.
            //
            if (!(tss.dwStaticFlags & TS_SS_TRANSITORY) )
               fCiceroNative = TRUE;
        }
    }

    return fCiceroNative;
}

/*  --------------------------------------------------------
//    Function Name: _SetTTSButtonStatus
//
//    Description:   Based on current IC attribute to 
//                   determine if to active or gray
//                   TTS buttons on toolbar.
//                   
//                   This  function will be called under
//                   TIM_CODE_SETFOCUS and TIM_CODE_INITIC.
// ----------------------------------------------------------*/
HRESULT  CTextToSpeech::_SetTTSButtonStatus(ITfContext  *pic)
{
    BOOL        fCiceroNative;
    HRESULT     hr = S_OK;
    CSpeechUIServer *pSpeechUIServer;

    TraceMsg(TF_GENERAL, "CTextToSpeech::_SetTTSButtonStatus is called");

    if ( !m_psi )
        return E_FAIL;

    fCiceroNative = _IsPureCiceroIC(pic);

    pSpeechUIServer = m_psi->GetSpeechUIServer( );

    if ( pSpeechUIServer )
    {
        pSpeechUIServer->SetTtsButtonStatus( fCiceroNative );
    }

    return hr;
}

/*  --------------------------------------------------------
//    Function Name: _HandleEventOnPlayButton
//
//    Description:   Handle mouse click event on Play button
//                   or Hotkey Windows+S. 
//                   
//                   it would be called by button's OnButtonUp
//                   callback function, and by Hotkey handler.
//
// ----------------------------------------------------------*/

HRESULT  CTextToSpeech::_HandleEventOnPlayButton( )
{
    HRESULT         hr = S_OK;
    BOOL            fTTSPlayOn;
    CSpeechUIServer *pSpeechUIServer;

    if ( !m_psi ) return E_FAIL;

    pSpeechUIServer = m_psi->GetSpeechUIServer( );

    if ( pSpeechUIServer == NULL)  return E_FAIL;

    fTTSPlayOn = pSpeechUIServer->GetTtsPlayOnOff( );

    if ( fTTSPlayOn )
    {
        // It is under Play mode.
        // Click this button to stop playing.

        // If it is under Pause mode, the Speaker needs to be resumed first.
        BOOL  fTTSPauseOn;

        fTTSPauseOn = pSpeechUIServer->GetTtsPauseOnOff( );

        if ( fTTSPauseOn )
        {
            // Under pause mode
            pSpeechUIServer->SetTtsPauseOnOff(FALSE);
            hr = TtsResume( );
        }
    }

    if  ( (hr == S_OK) && fTTSPlayOn )
    {
        // It has already been in Play mode.
        // click this to stop playing.
        hr = TtsStop( );
    }
    else
    {
        // It is not in Playing mode.
        hr = TtsPlay( );
    }

    pSpeechUIServer->SetTtsPlayOnOff( !fTTSPlayOn );

    return hr;

}

/*  --------------------------------------------------------
//    Function Name: _HandleEventOnPauseButton
//
//    Description:   Handle mouse click event on Pause Button.
//                   it would be called by Pause button's 
//                   OnLButtonUp callback function.
//
// ----------------------------------------------------------*/

HRESULT  CTextToSpeech::_HandleEventOnPauseButton( )
{
    HRESULT                 hr = S_OK;
    BOOL                    fTTSPauseOn;
    BOOL                    fTTSPlayOn;
    CSpeechUIServer *pSpeechUIServer;

    if ( !m_psi ) return E_FAIL;

    pSpeechUIServer = m_psi->GetSpeechUIServer( );

    if ( pSpeechUIServer == NULL)  return E_FAIL;

    fTTSPauseOn = pSpeechUIServer->GetTtsPauseOnOff( );
    fTTSPlayOn = pSpeechUIServer->GetTtsPlayOnOff( );

    if  ( fTTSPauseOn )
    {
        // It has already been in Pause mode.
        // click this to resume playing.
        hr = TtsResume( );
    }
    else
    {
        // It is not in Pause mode.

        if ( fTTSPlayOn )
        {
            hr = TtsPause( );
        }
    }

    if ( fTTSPlayOn )
        pSpeechUIServer->SetTtsPauseOnOff( !fTTSPauseOn );
    else
    {
        // If it is not under Play mode, click Pause button should not change the status.
        pSpeechUIServer->SetTtsPauseOnOff( FALSE );
    }
        
    return hr;
}

/*  --------------------------------------------------------
//   Function Name: SpeakNotifyCallback
//
//   Description:  This is callback for m_cpSpVoice in CSptask.
//                 Only SPEI_START_INPUT_STREAM &
//                 SPEI_END_INPUT_STREAM are insterested.
//                 
//                 When the input stream is over, we want
//                 to update the TTS buttons' toggle status
// ----------------------------------------------------------*/
void CSpTask::SpeakNotifyCallback( WPARAM wParam, LPARAM lParam )
{
    USES_CONVERSION;
    CSpEvent          event;
    CSpTask           *_this = (CSpTask *)lParam;
    CSapiIMX          *psi = NULL;
    CSpeechUIServer   *pSpeechUIServer = NULL;
    CComPtr<ISpVoice> cpVoice = NULL;
    
    if ( _this )
       cpVoice = _this->_GetSpVoice( );

    if (!_this || !cpVoice)
    {
        return;
    }

    psi = _this->GetTip( );

    if ( psi )
        pSpeechUIServer = psi->GetSpeechUIServer( );
    else
        return;

    while ( event.GetFrom(cpVoice) == S_OK )
    {
        switch (event.eEventId)
        {
            case SPEI_START_INPUT_STREAM  :
                TraceMsg(TF_GENERAL,"SPEI_START_INPUT_STREAM is notified");
                psi->_SetPlayMode(TRUE);

                // Update the toggle status for Play button.
                if ( pSpeechUIServer )
                    pSpeechUIServer->SetTtsPlayOnOff( TRUE );

                break;

            case SPEI_END_INPUT_STREAM :
                TraceMsg(TF_GENERAL,"SPEI_END_INPUT_STREAM is notified");
                psi->_SetPlayMode(FALSE);

                // Update the toggle status for Play button.
                if ( pSpeechUIServer )
                    pSpeechUIServer->SetTtsPlayOnOff( FALSE );

                break;
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\case\flipsel.cpp ===
//
// flipsel.cpp
//
// "Flip Selection" menu item handler.
//

#include "globals.h"
#include "case.h"
#include "editsess.h"

class CFlipEditSession : public CEditSessionBase
{
public:
    CFlipEditSession(ITfContext *pContext) : CEditSessionBase(pContext) {}

    // ITfEditSession
    STDMETHODIMP DoEditSession(TfEditCookie ec);
};

//+---------------------------------------------------------------------------
//
// _Menu_FlipSel
//
// Toggle the case of the selected text in the focus context.
//----------------------------------------------------------------------------

void CCaseTextService::_Menu_FlipSel(CCaseTextService *_this)
{
    ITfDocumentMgr *pFocusDoc;
    ITfContext *pContext;
    CFlipEditSession *pFlipEditSession;
    HRESULT hr;

    // get the focus document
    if (_this->_pThreadMgr->GetFocus(&pFocusDoc) != S_OK)
        return;

    // we want the topmost context, since the main doc context could be
    // superceded by a modal tip context
    if (pFocusDoc->GetTop(&pContext) != S_OK)
    {
        pContext = NULL;
        goto Exit;
    }

    if (pFlipEditSession = new CFlipEditSession(pContext))
    {
        // we need a document write lock to insert text
        // the CHelloEditSession will do all the work when the
        // CFlipEditSession::DoEditSession method is called by the context
        pContext->RequestEditSession(_this->_tfClientId, pFlipEditSession, TF_ES_READWRITE | TF_ES_ASYNCDONTCARE, &hr);

        pFlipEditSession->Release();
    }

Exit:
    SafeRelease(pContext);
    pFocusDoc->Release();    
}

//+---------------------------------------------------------------------------
//
// DoEditSession
//
//----------------------------------------------------------------------------

STDAPI CFlipEditSession::DoEditSession(TfEditCookie ec)
{
    TF_SELECTION tfSelection;
    ULONG cFetched;

    // get the selection
    if (_pContext->GetSelection(ec, TF_DEFAULT_SELECTION, 1, &tfSelection, &cFetched) != S_OK ||
        cFetched == 0)
    {
        // no selection
        return S_OK;
    }

    // do the work
    ToggleCase(ec, tfSelection.range, FALSE);

    // release the range
    tfSelection.range->Release();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\case\flipdoc.cpp ===
//
// flipdoc.cpp
//
// "Flip Doc" menu item handler.
//

#include "globals.h"
#include "case.h"
#include "editsess.h"

class CFlipDocEditSession : public CEditSessionBase
{
public:
    CFlipDocEditSession(ITfContext *pContext) : CEditSessionBase(pContext) {}

    // ITfEditSession
    STDMETHODIMP DoEditSession(TfEditCookie ec);
};

//+---------------------------------------------------------------------------
//
// _Menu_FlipDoc
//
// Toggle the case of the entire document.
//----------------------------------------------------------------------------

void CCaseTextService::_Menu_FlipDoc(CCaseTextService *_this)
{
    ITfDocumentMgr *pFocusDoc;
    ITfContext *pContext;
    CFlipDocEditSession *pFlipEditSession;
    HRESULT hr;

    // get the focus document
    if (_this->_pThreadMgr->GetFocus(&pFocusDoc) != S_OK)
        return;

    // we want the topmost context, since the main doc context could be
    // superceded by a modal tip context
    if (pFocusDoc->GetTop(&pContext) != S_OK)
    {
        pContext = NULL;
        goto Exit;
    }

    if (pFlipEditSession = new CFlipDocEditSession(pContext))
    {
        // we need a document write lock to insert text
        // the CHelloEditSession will do all the work when the
        // CFlipDocEditSession::DoEditSession method is called by the context
        pContext->RequestEditSession(_this->_tfClientId, pFlipEditSession, TF_ES_READWRITE | TF_ES_ASYNCDONTCARE, &hr);

        pFlipEditSession->Release();
    }

Exit:
    SafeRelease(pContext);
    pFocusDoc->Release();    
}

//+---------------------------------------------------------------------------
//
// DoEditSession
//
//----------------------------------------------------------------------------

STDAPI CFlipDocEditSession::DoEditSession(TfEditCookie ec)
{
    ITfRange *pRangeStart;

    // get the head of the doc
    if (_pContext->GetStart(ec, &pRangeStart) != S_OK)
        return E_FAIL;

    // do the work
    ToggleCase(ec, pRangeStart, TRUE);

    pRangeStart->Release();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\case\globals.cpp ===
//
// globals.cpp
//
// Global variables.
//

#include "globals.h"

HINSTANCE g_hInst;

LONG g_cRefDll = -1; // -1 /w no refs, for win95 InterlockedIncrement/Decrement compat

CRITICAL_SECTION g_cs;

/* 6565d455-5030-4c0f-8871-83f6afde514f */
const CLSID c_clsidCaseTextService = { 0x6565d455, 0x5030, 0x4c0f, {0x88, 0x71, 0x83, 0xf6, 0xaf, 0xde, 0x51, 0x4f} };

/* 4d5459db-7543-42c0-9204-9195b91f6fb8 */
const GUID c_guidCaseProfile = { 0x4d5459db, 0x7543, 0x42c0, {0x92, 0x04, 0x91, 0x95, 0xb9, 0x1f, 0x6f, 0xb8} };

/* 01679c88-5141-4ee5-a47f-c8d586ff37e1 */
const GUID c_guidLangBarItemButton = { 0x01679c88, 0x5141, 0x4ee5, {0xa4, 0x7f, 0xc8, 0xd5, 0x86, 0xff, 0x37, 0xe1} };

//+---------------------------------------------------------------------------
//
// ToggleChar
//
// Toggle the case of a single char.
//----------------------------------------------------------------------------

WCHAR ToggleChar(WCHAR ch)
{
    // toggle english ascii
    if ((ch >= 'a' && ch <= 'z') ||
        (ch >= 'A' && ch <= 'Z'))
    {
        return ch ^ 32;
    }
     
    // give up for non-ascii
    return ch;
}

//+---------------------------------------------------------------------------
//
// ToggleCase
//
// Toggle the case of all text covered by the range.  The input range is
// collapsed to its end point on exit.
//
// If fIgnoreRangeEnd == TRUE, all text following the start of range will be
// toggled, and the range will be collapsed at the end-of-doc on exit.
//----------------------------------------------------------------------------

void ToggleCase(TfEditCookie ec, ITfRange *pRange, BOOL fIgnoreRangeEnd)
{
    ITfRange *pRangeToggle;
    ULONG cch;
    ULONG i;
    DWORD dwFlags;
    WCHAR achText[64];

    // backup the current range
    if (pRange->Clone(&pRangeToggle) != S_OK)
        return;

    dwFlags = TF_TF_MOVESTART | (fIgnoreRangeEnd ? TF_TF_IGNOREEND : 0);

    while (TRUE)
    {
        // grab the next block of chars
        if (pRange->GetText(ec, dwFlags, achText, ARRAYSIZE(achText), &cch) != S_OK)
            break;

        // out of text?
        if (cch == 0)
            break;

        // toggle the case
        for (i=0; i<cch; i++)
        {
            achText[i] = ToggleChar(achText[i]);
        }

        // shift pRangeToggle so it covers just the text we read
        if (pRangeToggle->ShiftEndToRange(ec, pRange, TF_ANCHOR_START) != S_OK)
            break;

        // replace the text
        pRangeToggle->SetText(ec, 0, achText, cch);

        // prepare for next iteration
        pRangeToggle->Collapse(ec, TF_ANCHOR_END);
    }
    
    pRangeToggle->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\case\hello.cpp ===
//
// hello.cpp
//
// "Hello World" menu item handler.
//

#include "globals.h"
#include "case.h"
#include "editsess.h"

class CHelloEditSession : public CEditSessionBase
{
public:
    CHelloEditSession(ITfContext *pContext) : CEditSessionBase(pContext) {}

    // ITfEditSession
    STDMETHODIMP DoEditSession(TfEditCookie ec);
};

//+---------------------------------------------------------------------------
//
// _Menu_HelloWord
//
// Insert the string "Hello world!" to the focus context.
//----------------------------------------------------------------------------

void CCaseTextService::_Menu_HelloWord(CCaseTextService *_this)
{
    ITfDocumentMgr *pFocusDoc;
    ITfContext *pContext;
    CHelloEditSession *pHelloEditSession;
    HRESULT hr;

    // get the focus document
    if (_this->_pThreadMgr->GetFocus(&pFocusDoc) != S_OK)
        return;

    // we want the topmost context, since the main doc context could be
    // superceded by a modal tip context
    if (pFocusDoc->GetTop(&pContext) != S_OK)
    {
        pContext = NULL;
        goto Exit;
    }

    if (pHelloEditSession = new CHelloEditSession(pContext))
    {
        // we need a document write lock to insert text
        // the CHelloEditSession will do all the work when the
        // CHelloEditSession::DoEditSession method is called by the context
        pContext->RequestEditSession(_this->_tfClientId, pHelloEditSession, TF_ES_READWRITE | TF_ES_ASYNCDONTCARE, &hr);

        pHelloEditSession->Release();
    }

Exit:
    SafeRelease(pContext);
    pFocusDoc->Release();    
}

//+---------------------------------------------------------------------------
//
// DoEditSession
//
//----------------------------------------------------------------------------

STDAPI CHelloEditSession::DoEditSession(TfEditCookie ec)
{
    InsertTextAtSelection(ec, _pContext, L"Hello world!", wcslen(L"Hello world!"));
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// InsertTextAtSelection
//
//----------------------------------------------------------------------------

void InsertTextAtSelection(TfEditCookie ec, ITfContext *pContext, const WCHAR *pchText, ULONG cchText)
{
    ITfInsertAtSelection *pInsertAtSelection;
    ITfRange *pRange;
    TF_SELECTION tfSelection;

    // we need a special interface to insert text at the selection
    if (pContext->QueryInterface(IID_ITfInsertAtSelection, (void **)&pInsertAtSelection) != S_OK)
        return;

    // insert the text
    if (pInsertAtSelection->InsertTextAtSelection(ec, 0, pchText, cchText, &pRange) != S_OK)
        goto Exit;

    // update the selection, we'll make it an insertion point just past
    // the inserted text.
    pRange->Collapse(ec, TF_ANCHOR_END);

    tfSelection.range = pRange;
    tfSelection.style.ase = TF_AE_NONE;
    tfSelection.style.fInterimChar = FALSE;

    pContext->SetSelection(ec, 1, &tfSelection);

    pRange->Release();

Exit:
    pInsertAtSelection->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\case\precomp.cpp ===
//
// precomp.cpp
//
// Stub for vc precompiled header.
//

#include "globals.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\case\globals.h ===
//
// globals.h
//
// Global variable declarations.
//

#ifndef GLOBALS_H
#define GLOBALS_H

#include <windows.h>
#include <ole2.h>
#include <olectl.h>
#include <assert.h>
#include "msctf.h"

void DllAddRef();
void DllRelease();

void ToggleCase(TfEditCookie ec, ITfRange *range, BOOL fIgnoreRangeEnd);
void InsertTextAtSelection(TfEditCookie ec, ITfContext *pContext, const WCHAR *pchText, ULONG cchText);

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

#define CASE_LANGID    MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US)

#define CASE_DESC    L"Case Text Service"
#define CASE_DESC_A   "Case Text Service"
#define CASE_MODEL   TEXT("Apartment")

#define LANGBAR_ITEM_DESC L"Case Menu" // max 32 chars!

#define CASE_ICON_INDEX  0

#define SafeRelease(punk)       \
{                               \
    if ((punk) != NULL)         \
    {                           \
        (punk)->Release();      \
    }                           \
}                   

#define SafeReleaseClear(punk)  \
{                               \
    if ((punk) != NULL)         \
    {                           \
        (punk)->Release();      \
        (punk) = NULL;          \
    }                           \
}                   

//+---------------------------------------------------------------------------
//
// SafeStringCopy
//
// Copies a string from one buffer to another.  wcsncpy does not always
// null-terminate the destination buffer; this function does.
//----------------------------------------------------------------------------

inline void SafeStringCopy(WCHAR *pchDst, ULONG cchMax, const WCHAR *pchSrc)
{
    if (cchMax > 0)
    {
        wcsncpy(pchDst, pchSrc, cchMax);
        pchDst[cchMax-1] = '\0';
    }
}

extern HINSTANCE g_hInst;

extern LONG g_cRefDll;

extern CRITICAL_SECTION g_cs;

extern const CLSID c_clsidCaseTextService;

extern const GUID c_guidCaseProfile;

extern const GUID c_guidLangBarItemButton;

#endif // GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\case\keys.cpp ===
//
// keys.cpp
//
// ITfKeyEventSink implementation.
//

#include "globals.h"
#include "case.h"
#include "editsess.h"

class CKeystrokeEditSession : public CEditSessionBase
{
public:
    CKeystrokeEditSession(ITfContext *pContext, WPARAM wParam) : CEditSessionBase(pContext)
    {
        _wParam = wParam;
    }

    // ITfEditSession
    STDMETHODIMP DoEditSession(TfEditCookie ec);

private:
    WPARAM _wParam;
};


/* 5d6d1b1e-64f2-47cd-9fe1-4e032c2dae77 */
static const GUID GUID_PRESERVEDKEY_FLIPCASE = { 0x5d6d1b1e, 0x64f2, 0x47cd, {0x9f, 0xe1, 0x4e, 0x03, 0x2c, 0x2d, 0xae, 0x77} };
// arbitrary hotkey: ctl-f
static const TF_PRESERVEDKEY c_FlipCaseKey = { 'F', TF_MOD_CONTROL };


//+---------------------------------------------------------------------------
//
// IsKeyEaten
//
//----------------------------------------------------------------------------

inline BOOL IsKeyEaten(BOOL fFlipKeys, WPARAM wParam)
{
    // we're only interested in VK_A - VK_Z, when the "Flip Keys" menu option
    // is on
    return fFlipKeys && (wParam >= 'A') && (wParam <= 'Z');
}

//+---------------------------------------------------------------------------
//
// _Menu_FlipKeys
//
// Advise or unadvise a keystroke sink.
//----------------------------------------------------------------------------

/* static */
void CCaseTextService::_Menu_FlipKeys(CCaseTextService *_this)
{
    _this->_fFlipKeys = !_this->_fFlipKeys;
}

//+---------------------------------------------------------------------------
//
// _InitKeystrokeSink
//
// Advise a keystroke sink.
//----------------------------------------------------------------------------

BOOL CCaseTextService::_InitKeystrokeSink()
{
    ITfKeystrokeMgr *pKeystrokeMgr;
    HRESULT hr;

    if (_pThreadMgr->QueryInterface(IID_ITfKeystrokeMgr, (void **)&pKeystrokeMgr) != S_OK)
        return FALSE;

    hr = pKeystrokeMgr->AdviseKeyEventSink(_tfClientId, (ITfKeyEventSink *)this, TRUE);

    pKeystrokeMgr->Release();

    return (hr == S_OK);
}

//+---------------------------------------------------------------------------
//
// _UninitKeystrokeSink
//
// Unadvise a keystroke sink.  Assumes we have advised one already.
//----------------------------------------------------------------------------

void CCaseTextService::_UninitKeystrokeSink()
{
    ITfKeystrokeMgr *pKeystrokeMgr;

    if (_pThreadMgr->QueryInterface(IID_ITfKeystrokeMgr, (void **)&pKeystrokeMgr) != S_OK)
        return;

    pKeystrokeMgr->UnadviseKeyEventSink(_tfClientId);

    pKeystrokeMgr->Release();
}

//+---------------------------------------------------------------------------
//
// _InitPreservedKey
//
// Register a hot key.
//----------------------------------------------------------------------------

BOOL CCaseTextService::_InitPreservedKey()
{
    ITfKeystrokeMgr *pKeystrokeMgr;
    HRESULT hr;

    if (_pThreadMgr->QueryInterface(IID_ITfKeystrokeMgr, (void **)&pKeystrokeMgr) != S_OK)
        return FALSE;

    hr = pKeystrokeMgr->PreserveKey(_tfClientId, GUID_PRESERVEDKEY_FLIPCASE,
                                    &c_FlipCaseKey, L"Toggle Case",
                                    wcslen(L"Toggle Case"));

    pKeystrokeMgr->Release();

    return (hr == S_OK);
}

//+---------------------------------------------------------------------------
//
// _UninitPreservedKey
//
// Uninit a hot key.
//----------------------------------------------------------------------------

void CCaseTextService::_UninitPreservedKey()
{
    ITfKeystrokeMgr *pKeystrokeMgr;

    if (_pThreadMgr->QueryInterface(IID_ITfKeystrokeMgr, (void **)&pKeystrokeMgr) != S_OK)
        return;

    pKeystrokeMgr->UnpreserveKey(GUID_PRESERVEDKEY_FLIPCASE, &c_FlipCaseKey);

    pKeystrokeMgr->Release();
}

//+---------------------------------------------------------------------------
//
// OnSetFocus
//
// Called by the system whenever this service gets the keystroke device focus.
//----------------------------------------------------------------------------

STDAPI CCaseTextService::OnSetFocus(BOOL fForeground)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnTestKeyDown
//
// Called by the system to query this service wants a potential keystroke.
//----------------------------------------------------------------------------

STDAPI CCaseTextService::OnTestKeyDown(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    *pfEaten = IsKeyEaten(_fFlipKeys, wParam);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnKeyDown
//
// Called by the system to offer this service a keystroke.  If *pfEaten == TRUE
// on exit, the application will not handle the keystroke.
//----------------------------------------------------------------------------

STDAPI CCaseTextService::OnKeyDown(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    CKeystrokeEditSession *pEditSession;
    HRESULT hr = S_OK;

    *pfEaten = IsKeyEaten(_fFlipKeys, wParam);

    if (*pfEaten)
    {
        // we'll insert a char ourselves in place of this keystroke
        if ((pEditSession = new CKeystrokeEditSession(pContext, wParam)) == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        // we need a lock to do our work
        // nb: this method is one of the few places where it is legal to use
        // the TF_ES_SYNC flag
        if (pContext->RequestEditSession(_tfClientId, pEditSession, TF_ES_SYNC | TF_ES_READWRITE, &hr) != S_OK)
        {
            hr = E_FAIL;
        }

        pEditSession->Release();
    }

Exit:
    if (hr != S_OK)
    {
        *pfEaten = FALSE;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// DoEditSession
//
//----------------------------------------------------------------------------

STDAPI CKeystrokeEditSession::DoEditSession(TfEditCookie ec)
{
    WCHAR wc;

    // we want to toggle the english case of the keystroke
    // nb: this is quick-and-dirty code, not intended to demonstrate the
    // correct way to flip capitalization!

    if (GetKeyState(VK_SHIFT) & 0x8000)
    {
        // shift-key, make it lowercase
        wc = (WCHAR)(_wParam | 32);
    }
    else
    {
        // else make it capital
        wc = (WCHAR)_wParam;
    }

    InsertTextAtSelection(ec, _pContext, &wc, 1);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnTestKeyUp
//
// Called by the system to query this service wants a potential keystroke.
//----------------------------------------------------------------------------

STDAPI CCaseTextService::OnTestKeyUp(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    *pfEaten = IsKeyEaten(_fFlipKeys, wParam);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnKeyUp
//
// Called by the system to offer this service a keystroke.  If *pfEaten == TRUE
// on exit, the application will not handle the keystroke.
//----------------------------------------------------------------------------

STDAPI CCaseTextService::OnKeyUp(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    *pfEaten = IsKeyEaten(_fFlipKeys, wParam);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnPreservedKey
//
// Called when a hotkey (registered by us, or by the system) is typed.
//----------------------------------------------------------------------------

STDAPI CCaseTextService::OnPreservedKey(ITfContext *pContext, REFGUID rguid, BOOL *pfEaten)
{
    if (IsEqualGUID(rguid, GUID_PRESERVEDKEY_FLIPCASE))
    {
        _Menu_FlipDoc(this);
        *pfEaten = TRUE;
    }
    else
    {
        *pfEaten = FALSE;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\case\langbar.cpp ===
//
// langbar.cpp
//
// Language bar ui code.
//

#include "globals.h"
#include "case.h"
#include "resource.h"

#define CASE_LANGBARITEMSINK_COOKIE 0x0fab0fab

const struct
{
    const WCHAR *pchDesc;
    void (*pfnHandler)(CCaseTextService *_this);
}
c_rgMenuItems[] =
{
    { L"Show Snoop Wnd", CCaseTextService::_Menu_ShowSnoopWnd }, // must match MENU_SHOWSNOOP_INDEX
    { L"Hello World", CCaseTextService::_Menu_HelloWord },
    { L"Flip Selection", CCaseTextService::_Menu_FlipSel },
    { L"Flip Doc", CCaseTextService::_Menu_FlipDoc },
    { L"Flip Keystrokes", CCaseTextService::_Menu_FlipKeys }, // must match MENU_FLIPKEYS_INDEX
};

#define MENU_SHOWSNOOP_INDEX    0
#define MENU_FLIPKEYS_INDEX     4

class CLangBarItemButton : public ITfLangBarItemButton,
                           public ITfSource
{
public:
    CLangBarItemButton(CCaseTextService *pCase);
    ~CLangBarItemButton();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ITfLangBarItem
    STDMETHODIMP GetInfo(TF_LANGBARITEMINFO *pInfo);
    STDMETHODIMP GetStatus(DWORD *pdwStatus);
    STDMETHODIMP Show(BOOL fShow);
    STDMETHODIMP GetTooltipString(BSTR *pbstrToolTip);

    // ITfLangBarItemButton
    STDMETHODIMP OnClick(TfLBIClick click, POINT pt, const RECT *prcArea);
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);
    STDMETHODIMP GetIcon(HICON *phIcon);
    STDMETHODIMP GetText(BSTR *pbstrText);

    // ITfSource
    STDMETHODIMP AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie);
    STDMETHODIMP UnadviseSink(DWORD dwCookie);

private:
    CCaseTextService *_pCase;
    ITfLangBarItemSink *_pLangBarItemSink;
    TF_LANGBARITEMINFO _tfLangBarItemInfo;
    LONG _cRef;
};

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLangBarItemButton::CLangBarItemButton(CCaseTextService *pCase)
{
    DllAddRef();

    _tfLangBarItemInfo.clsidService = c_clsidCaseTextService;
    _tfLangBarItemInfo.guidItem = c_guidLangBarItemButton;
    _tfLangBarItemInfo.dwStyle = TF_LBI_STYLE_BTN_MENU;
    _tfLangBarItemInfo.ulSort = 0;
    SafeStringCopy(_tfLangBarItemInfo.szDescription, ARRAYSIZE(_tfLangBarItemInfo.szDescription), LANGBAR_ITEM_DESC);

    _pCase = pCase;
    _pCase->AddRef();
    _pLangBarItemSink = NULL;

    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLangBarItemButton::~CLangBarItemButton()
{
    DllRelease();
    _pCase->Release();
}

//+---------------------------------------------------------------------------
//
// QueryInterface
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfLangBarItem) ||
        IsEqualIID(riid, IID_ITfLangBarItemButton))
    {
        *ppvObj = (ITfLangBarItemButton *)this;
    }
    else if (IsEqualIID(riid, IID_ITfSource))
    {
        *ppvObj = (ITfSource *)this;
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//+---------------------------------------------------------------------------
//
// AddRef
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CLangBarItemButton::AddRef()
{
    return ++_cRef;
}

//+---------------------------------------------------------------------------
//
// Release
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CLangBarItemButton::Release()
{
    LONG cr = --_cRef;

    assert(_cRef >= 0);

    if (_cRef == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// GetInfo
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::GetInfo(TF_LANGBARITEMINFO *pInfo)
{
    *pInfo = _tfLangBarItemInfo;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetStatus
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::GetStatus(DWORD *pdwStatus)
{
    *pdwStatus = 0;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Show
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::Show(BOOL fShow)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// GetTooltipString
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::GetTooltipString(BSTR *pbstrToolTip)
{
    *pbstrToolTip = SysAllocString(LANGBAR_ITEM_DESC);

    return (*pbstrToolTip == NULL) ? E_OUTOFMEMORY : S_OK;
}

//+---------------------------------------------------------------------------
//
// OnClick
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::OnClick(TfLBIClick click, POINT pt, const RECT *prcArea)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// InitMenu
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::InitMenu(ITfMenu *pMenu)
{
    int i;
    DWORD dwFlags;

    for (i=0; i<ARRAYSIZE(c_rgMenuItems); i++)
    {
        switch (i)
        {
            case MENU_SHOWSNOOP_INDEX:
                dwFlags = _pCase->_IsSnoopWndVisible() ? TF_LBMENUF_CHECKED : 0;
                break;

            case MENU_FLIPKEYS_INDEX:
                dwFlags = _pCase->_IsKeyFlipping() ? TF_LBMENUF_CHECKED : 0;
                break;

            default:
                // all other items are plain
                dwFlags = 0;
                break;
        }

        pMenu->AddMenuItem(i, dwFlags, NULL, NULL, c_rgMenuItems[i].pchDesc, wcslen(c_rgMenuItems[i].pchDesc), NULL);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnMenuSelect
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::OnMenuSelect(UINT wID)
{
    c_rgMenuItems[wID].pfnHandler(_pCase);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::GetIcon(HICON *phIcon)
{
    *phIcon = (HICON)LoadImage(g_hInst, TEXT("IDI_CASE"), IMAGE_ICON, 16, 16, 0);
 
    return (*phIcon != NULL) ? S_OK : E_FAIL;
}

//+---------------------------------------------------------------------------
//
// GetText
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::GetText(BSTR *pbstrText)
{
    *pbstrText = SysAllocString(LANGBAR_ITEM_DESC);

    return (*pbstrText == NULL) ? E_OUTOFMEMORY : S_OK;
}

//+---------------------------------------------------------------------------
//
// AdviseSink
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie)
{
    if (!IsEqualIID(IID_ITfLangBarItemSink, riid))
        return CONNECT_E_CANNOTCONNECT;

    if (_pLangBarItemSink != NULL)
        return CONNECT_E_ADVISELIMIT;

    if (punk->QueryInterface(IID_ITfLangBarItemSink, (void **)&_pLangBarItemSink) != S_OK)
    {
        _pLangBarItemSink = NULL;
        return E_NOINTERFACE;
    }

    *pdwCookie = CASE_LANGBARITEMSINK_COOKIE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// UnadviseSink
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::UnadviseSink(DWORD dwCookie)
{
    if (dwCookie != CASE_LANGBARITEMSINK_COOKIE)
        return CONNECT_E_NOCONNECTION;

    if (_pLangBarItemSink == NULL)
        return CONNECT_E_NOCONNECTION;

    _pLangBarItemSink->Release();
    _pLangBarItemSink = NULL;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _InitLanguageBar
//
//----------------------------------------------------------------------------

BOOL CCaseTextService::_InitLanguageBar()
{
    ITfLangBarItemMgr *pLangBarItemMgr;
    BOOL fRet;

    if (_pThreadMgr->QueryInterface(IID_ITfLangBarItemMgr, (void **)&pLangBarItemMgr) != S_OK)
        return FALSE;

    fRet = FALSE;

    if ((_pLangBarItem = new CLangBarItemButton(this)) == NULL)
        goto Exit;

    if (pLangBarItemMgr->AddItem(_pLangBarItem) != S_OK)
    {
        _pLangBarItem->Release();
        _pLangBarItem = NULL;
        goto Exit;
    }

    fRet = TRUE;

Exit:
    pLangBarItemMgr->Release();
    return fRet;
}

//+---------------------------------------------------------------------------
//
// _UninitLanguageBar
//
//----------------------------------------------------------------------------

void CCaseTextService::_UninitLanguageBar()
{
    ITfLangBarItemMgr *pLangBarItemMgr;

    if (_pLangBarItem == NULL)
        return;

    if (_pThreadMgr->QueryInterface(IID_ITfLangBarItemMgr, (void **)&pLangBarItemMgr) == S_OK)
    {
        pLangBarItemMgr->RemoveItem(_pLangBarItem);
        pLangBarItemMgr->Release();
    }

    _pLangBarItem->Release();
    _pLangBarItem = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\case\resource.h ===
//
// resource.h
//
// Resource declarations.
//

#ifndef RESOURCE_H
#define RESOURCE_H

//#define IDI_CASE        0

#endif // RESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\case\server.cpp ===
//
// server.cpp
//
// COM server exports.
//

#include "globals.h"
#include "case.h"

void FreeGlobalObjects(void);

class CClassFactory;
static CClassFactory *g_ObjectInfo[1] = { NULL };

//+---------------------------------------------------------------------------
//
//  DllAddRef
//
//----------------------------------------------------------------------------

void DllAddRef(void)
{
    InterlockedIncrement(&g_cRefDll);
}

//+---------------------------------------------------------------------------
//
//  DllRelease
//
//----------------------------------------------------------------------------

void DllRelease(void)
{
    if (InterlockedDecrement(&g_cRefDll) < 0) // g_cRefDll == -1 with zero refs
    {
        EnterCriticalSection(&g_cs);

        // need to check ref again after grabbing mutex
        if (g_ObjectInfo[0] != NULL)
        {
            FreeGlobalObjects();
        }
        assert(g_cRefDll == -1);

        LeaveCriticalSection(&g_cs);
    }
}

//+---------------------------------------------------------------------------
//
//  CClassFactory declaration with IClassFactory Interface
//
//----------------------------------------------------------------------------

class CClassFactory : public IClassFactory
{
public:
    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IClassFactory methods
    STDMETHODIMP CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);
    STDMETHODIMP LockServer(BOOL fLock);

    // Constructor
    CClassFactory(REFCLSID rclsid, HRESULT (*pfnCreateInstance)(IUnknown *pUnkOuter, REFIID riid, void **ppvObj))
        : _rclsid(rclsid)
    {
        _pfnCreateInstance = pfnCreateInstance;
    }

public:
    REFCLSID _rclsid;
    HRESULT (*_pfnCreateInstance)(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);
};

//+---------------------------------------------------------------------------
//
//  CClassFactory::QueryInterface
//
//----------------------------------------------------------------------------

STDAPI CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = this;
        DllAddRef();
        return NOERROR;
    }
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

//+---------------------------------------------------------------------------
//
//  CClassFactory::AddRef
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CClassFactory::AddRef()
{
    DllAddRef();
    return g_cRefDll+1; // -1 w/ no refs
}

//+---------------------------------------------------------------------------
//
//  CClassFactory::Release
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CClassFactory::Release()
{
    DllRelease();
    return g_cRefDll+1; // -1 w/ no refs
}

//+---------------------------------------------------------------------------
//
//  CClassFactory::CreateInstance
//
//----------------------------------------------------------------------------

STDAPI CClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    return _pfnCreateInstance(pUnkOuter, riid, ppvObj);
}

//+---------------------------------------------------------------------------
//
//  CClassFactory::LockServer
//
//----------------------------------------------------------------------------

STDAPI CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
    {
        DllAddRef();
    }
    else
    {
        DllRelease();
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  BuildGlobalObjects
//
//----------------------------------------------------------------------------

void BuildGlobalObjects(void)
{
    // Build CClassFactory Objects

    g_ObjectInfo[0] = new CClassFactory(c_clsidCaseTextService, CCaseTextService::CreateInstance);

    // You can add more object info here.
    // Don't forget to increase number of item for g_ObjectInfo[],
}

//+---------------------------------------------------------------------------
//
//  FreeGlobalObjects
//
//----------------------------------------------------------------------------

void FreeGlobalObjects(void)
{
    // Free CClassFactory Objects
    for (int i = 0; i < ARRAYSIZE(g_ObjectInfo); i++)
    {
        if (NULL != g_ObjectInfo[i])
        {
            delete g_ObjectInfo[i];
            g_ObjectInfo[i] = NULL;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  DllGetClassObject
//
//----------------------------------------------------------------------------

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppvObj)
{
    if (g_ObjectInfo[0] == NULL)
    {
        EnterCriticalSection(&g_cs);

            // need to check ref again after grabbing mutex
            if (g_ObjectInfo[0] == NULL)
            {
                BuildGlobalObjects();
            }

        LeaveCriticalSection(&g_cs);
    }

    if (IsEqualIID(riid, IID_IClassFactory) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        for (int i = 0; i < ARRAYSIZE(g_ObjectInfo); i++)
        {
            if (NULL != g_ObjectInfo[i] &&
                IsEqualGUID(rclsid, g_ObjectInfo[i]->_rclsid))
            {
                *ppvObj = (void *)g_ObjectInfo[i];
                DllAddRef();    // class factory holds DLL ref count
                return NOERROR;
            }
        }
    }

    *ppvObj = NULL;

    return CLASS_E_CLASSNOTAVAILABLE;
}

//+---------------------------------------------------------------------------
//
//  DllCanUnloadNow
//
//----------------------------------------------------------------------------

STDAPI DllCanUnloadNow(void)
{
    if (g_cRefDll >= 0) // -1 with no refs
        return S_FALSE;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  DllUnregisterServer
//
//----------------------------------------------------------------------------

STDAPI DllUnregisterServer(void)
{
    CCaseTextService::RegisterCategories(FALSE);
    CCaseTextService::UnregisterProfiles();
    CCaseTextService::UnregisterServer();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  DllRegisterServer
//
//----------------------------------------------------------------------------

STDAPI DllRegisterServer(void)
{
    // register this service's profile with the tsf
    if (!CCaseTextService::RegisterServer() ||
        !CCaseTextService::RegisterProfiles() ||
        !CCaseTextService::RegisterCategories(TRUE))
    {
        DllUnregisterServer(); // cleanup any loose ends
        return E_FAIL;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\case\register.cpp ===
//
// register.cpp
//
// Server registration code.
//

#include <windows.h>
#include <ole2.h>
#include "msctf.h"
#include "globals.h"
#include "case.h"

#define CLSID_STRLEN 38  // strlen("{xxxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxx}")

const struct
{
    const GUID *pguidCategory;
    const GUID *pguid;
}
c_rgCategories[] =
{
    { &GUID_TFCAT_TIP_KEYBOARD, &c_clsidCaseTextService },
};

static const TCHAR c_szInfoKeyPrefix[] = TEXT("CLSID\\");
static const TCHAR c_szInProcSvr32[] = TEXT("InProcServer32");
static const TCHAR c_szModelName[] = TEXT("ThreadingModel");

//+---------------------------------------------------------------------------
//
//  RegisterProfiles
//
//----------------------------------------------------------------------------

BOOL CCaseTextService::RegisterProfiles()
{
    ITfInputProcessorProfiles *pInputProcessProfiles;
    WCHAR achIconFile[MAX_PATH];
    char achFileNameA[MAX_PATH];
    DWORD cchA;
    int cchIconFile;
    HRESULT hr;

    hr = CoCreateInstance(CLSID_TF_InputProcessorProfiles, NULL, CLSCTX_INPROC_SERVER,
                          IID_ITfInputProcessorProfiles, (void**)&pInputProcessProfiles);

    if (hr != S_OK)
        return E_FAIL;

    hr = pInputProcessProfiles->Register(c_clsidCaseTextService);

    if (hr != S_OK)
        goto Exit;

    cchA = GetModuleFileNameA(g_hInst, achFileNameA, ARRAYSIZE(achFileNameA));

    cchIconFile = MultiByteToWideChar(CP_ACP, 0, achFileNameA, cchA, achIconFile, ARRAYSIZE(achIconFile)-1);
    achIconFile[cchIconFile] = '\0';

    hr = pInputProcessProfiles->AddLanguageProfile(c_clsidCaseTextService,
                                  CASE_LANGID, 
                                  c_guidCaseProfile, 
                                  CASE_DESC, 
                                  wcslen(CASE_DESC),
                                  achIconFile,
                                  cchIconFile,
                                  CASE_ICON_INDEX);

Exit:
    pInputProcessProfiles->Release();
    return (hr == S_OK);
}

//+---------------------------------------------------------------------------
//
//  UnregisterProfiles
//
//----------------------------------------------------------------------------

void CCaseTextService::UnregisterProfiles()
{
    ITfInputProcessorProfiles *pInputProcessProfiles;
    HRESULT hr;

    hr = CoCreateInstance(CLSID_TF_InputProcessorProfiles, NULL, CLSCTX_INPROC_SERVER,
                          IID_ITfInputProcessorProfiles, (void**)&pInputProcessProfiles);

    if (hr != S_OK)
        return;

    pInputProcessProfiles->Unregister(c_clsidCaseTextService);
    pInputProcessProfiles->Release();
}

//+---------------------------------------------------------------------------
//
//  RegisterCategories
//
//----------------------------------------------------------------------------

BOOL CCaseTextService::RegisterCategories(BOOL fRegister)
{
    ITfCategoryMgr *pCategoryMgr;
    int i;
    HRESULT hr;

    hr = CoCreateInstance(CLSID_TF_CategoryMgr, NULL, CLSCTX_INPROC_SERVER, 
                          IID_ITfCategoryMgr, (void**)&pCategoryMgr);

    if (hr != S_OK)
        return E_FAIL;

    for (i=0; i<ARRAYSIZE(c_rgCategories); i++)
    {
        if (fRegister)
        {
            hr = pCategoryMgr->RegisterCategory(c_clsidCaseTextService,
                   *c_rgCategories[i].pguidCategory, *c_rgCategories[i].pguid);
        }
        else
        {
            hr = pCategoryMgr->UnregisterCategory(c_clsidCaseTextService,
                   *c_rgCategories[i].pguidCategory, *c_rgCategories[i].pguid);
        }

        if (hr != S_OK)
            break;
    }

    pCategoryMgr->Release();
    return (hr == S_OK);
}

//+---------------------------------------------------------------------------
//
// CLSIDToStringA
//
//----------------------------------------------------------------------------

BOOL CLSIDToStringA(REFGUID refGUID, char *pchA)
{
    static const BYTE GuidMap[] = {3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-',
                                   8, 9, '-', 10, 11, 12, 13, 14, 15};

    static const char szDigits[] = "0123456789ABCDEF";

    int i;
    char *p = pchA;

    const BYTE * pBytes = (const BYTE *) &refGUID;

    *p++ = '{';
    for (i = 0; i < sizeof(GuidMap); i++)
    {
        if (GuidMap[i] == '-')
        {
            *p++ = '-';
        }
        else
        {
            *p++ = szDigits[ (pBytes[GuidMap[i]] & 0xF0) >> 4 ];
            *p++ = szDigits[ (pBytes[GuidMap[i]] & 0x0F) ];
        }
    }

    *p++ = '}';
    *p   = '\0';

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// RecurseDeleteKey
//
// RecurseDeleteKey is necessary because on NT RegDeleteKey doesn't work if the
// specified key has subkeys
//----------------------------------------------------------------------------
LONG RecurseDeleteKey(HKEY hParentKey, LPCTSTR lpszKey)
{
    HKEY hKey;
    LONG lRes;
    FILETIME time;
    TCHAR szBuffer[256];
    DWORD dwSize = ARRAYSIZE(szBuffer);

    if (RegOpenKey(hParentKey, lpszKey, &hKey) != ERROR_SUCCESS)
        return ERROR_SUCCESS; // let's assume we couldn't open it because it's not there

    lRes = ERROR_SUCCESS;
    while (RegEnumKeyEx(hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL, &time)==ERROR_SUCCESS)
    {
        szBuffer[ARRAYSIZE(szBuffer)-1] = '\0';
        lRes = RecurseDeleteKey(hKey, szBuffer);
        if (lRes != ERROR_SUCCESS)
            break;
        dwSize = ARRAYSIZE(szBuffer);
    }
    RegCloseKey(hKey);

    return lRes == ERROR_SUCCESS ? RegDeleteKey(hParentKey, lpszKey) : lRes;
}

//+---------------------------------------------------------------------------
//
//  RegisterServer
//
//----------------------------------------------------------------------------

BOOL CCaseTextService::RegisterServer()
{
    DWORD dw;
    HKEY hKey;
    HKEY hSubKey;
    BOOL fRet;
    TCHAR achIMEKey[ARRAYSIZE(c_szInfoKeyPrefix) + CLSID_STRLEN];
    TCHAR achFileName[MAX_PATH];

    if (!CLSIDToStringA(c_clsidCaseTextService, achIMEKey + ARRAYSIZE(c_szInfoKeyPrefix) - 1))
        return FALSE;
    memcpy(achIMEKey, c_szInfoKeyPrefix, sizeof(c_szInfoKeyPrefix)-sizeof(TCHAR));

    if (fRet = RegCreateKeyEx(HKEY_CLASSES_ROOT, achIMEKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, &dw)
            == ERROR_SUCCESS)
    {
        fRet &= RegSetValueEx(hKey, NULL, 0, REG_SZ, (BYTE *)CASE_DESC_A, (lstrlen(CASE_DESC_A)+1)*sizeof(TCHAR))
            == ERROR_SUCCESS;

        if (fRet &= RegCreateKeyEx(hKey, c_szInProcSvr32, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hSubKey, &dw)
            == ERROR_SUCCESS)
        {
            dw = GetModuleFileNameA(g_hInst, achFileName, ARRAYSIZE(achFileName));

            fRet &= RegSetValueEx(hSubKey, NULL, 0, REG_SZ, (BYTE *)achFileName, (lstrlen(achFileName)+1)*sizeof(TCHAR)) == ERROR_SUCCESS;
            fRet &= RegSetValueEx(hSubKey, c_szModelName, 0, REG_SZ, (BYTE *)CASE_MODEL, (lstrlen(CASE_MODEL)+1)*sizeof(TCHAR)) == ERROR_SUCCESS;
            RegCloseKey(hSubKey);
        }
        RegCloseKey(hKey);
    }

    return fRet;
}

//+---------------------------------------------------------------------------
//
//  UnregisterServer
//
//----------------------------------------------------------------------------

void CCaseTextService::UnregisterServer()
{
    TCHAR achIMEKey[ARRAYSIZE(c_szInfoKeyPrefix) + CLSID_STRLEN];

    if (!CLSIDToStringA(c_clsidCaseTextService, achIMEKey + ARRAYSIZE(c_szInfoKeyPrefix) - 1))
        return;
    memcpy(achIMEKey, c_szInfoKeyPrefix, sizeof(c_szInfoKeyPrefix)-sizeof(TCHAR));

    RecurseDeleteKey(HKEY_CLASSES_ROOT, achIMEKey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\case\tmgrsink.cpp ===
//
// tmgrsink.cpp
//
// ITfThreadMgrEventSink implementation.
//

#include "globals.h"
#include "case.h"
#include "snoop.h"

//+---------------------------------------------------------------------------
//
// OnInitDocumentMgr
//
// Sink called by the framework just before the first context is pushed onto
// a document.
//----------------------------------------------------------------------------

STDAPI CCaseTextService::OnInitDocumentMgr(ITfDocumentMgr *pDocMgr)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnUninitDocumentMgr
//
// Sink called by the framework just after the last context is popped off a
// document.
//----------------------------------------------------------------------------

STDAPI CCaseTextService::OnUninitDocumentMgr(ITfDocumentMgr *pDocMgr)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnSetFocus
//
// Sink called by the framework when focus changes from one document to
// another.  Either document may be NULL, meaning previously there was no
// focus document, or now no document holds the input focus.
//----------------------------------------------------------------------------

STDAPI CCaseTextService::OnSetFocus(ITfDocumentMgr *pDocMgrFocus, ITfDocumentMgr *pDocMgrPrevFocus)
{
    // track text changes on the focus doc
    // we are guarenteed a final OnSetFocus(NULL, ..) which we use for cleanup
    _InitTextEditSink(pDocMgrFocus);

    // let's update the snoop window with text from the new focus context
    _pSnoopWnd->_UpdateText(NULL);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnPushContext
//
// Sink called by the framework when a context is pushed.
//----------------------------------------------------------------------------

STDAPI CCaseTextService::OnPushContext(ITfContext *pContext)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnPopContext
//
// Sink called by the framework when a context is popped.
//----------------------------------------------------------------------------

STDAPI CCaseTextService::OnPopContext(ITfContext *pContext)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _InitThreadMgrSink
//
// Advise our sink.
//----------------------------------------------------------------------------

BOOL CCaseTextService::_InitThreadMgrSink()
{
    ITfSource *pSource;
    BOOL fRet;

    if (_pThreadMgr->QueryInterface(IID_ITfSource, (void **)&pSource) != S_OK)
        return FALSE;

    fRet = FALSE;

    if (pSource->AdviseSink(IID_ITfThreadMgrEventSink, (ITfThreadMgrEventSink *)this, &_dwThreadMgrEventSinkCookie) != S_OK)
    {
        // make sure we don't try to Unadvise _dwThreadMgrEventSinkCookie later
        _dwThreadMgrEventSinkCookie = TF_INVALID_COOKIE;
        goto Exit;
    }

    fRet = TRUE;

Exit:
    pSource->Release();
    return fRet;
}

//+---------------------------------------------------------------------------
//
// _UninitThreadMgrSink
//
// Unadvise our sink.
//----------------------------------------------------------------------------

void CCaseTextService::_UninitThreadMgrSink()
{
    ITfSource *pSource;

    if (_dwThreadMgrEventSinkCookie == TF_INVALID_COOKIE)
        return; // never Advised

    if (_pThreadMgr->QueryInterface(IID_ITfSource, (void **)&pSource) == S_OK)
    {
        pSource->UnadviseSink(_dwThreadMgrEventSinkCookie);
        pSource->Release();
    }

    _dwThreadMgrEventSinkCookie = TF_INVALID_COOKIE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\case\snoop.h ===
//
// snoop.h
//
// CSnoopWnd declaration.
//

#ifndef SNOOP_H
#define SNOOP_H

#define MAX_SNOOP_TEXT  32

class CCaseTextService;
class CUpdateTextEditSession;

class CSnoopWnd
{
public:
    CSnoopWnd(CCaseTextService *pCase);

    static BOOL _InitClass();
    static void _UninitClass();

    BOOL _Init();
    void _Uninit();

    void _Show();
    void _Hide();

    void _UpdateText(ITfRange *pRange);
    void _UpdateText(TfEditCookie ec, ITfContext *pContext, ITfRange *pRange);

private:

    friend CUpdateTextEditSession;

    static LRESULT CALLBACK _WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _OnPaint(HWND hWnd, HDC hdc);

    static void _SetThis(HWND hWnd, LPARAM lParam)
    {
        SetWindowLongPtr(hWnd, GWLP_USERDATA, 
                         (LONG_PTR)((CREATESTRUCT *)lParam)->lpCreateParams);
    }

    static CSnoopWnd *_GetThis(HWND hWnd)
    {
        return (CSnoopWnd *)GetWindowLongPtr(hWnd, GWLP_USERDATA);
    }

    CCaseTextService *_pCase;
    HWND _hWnd;
    ULONG _cchText;
    WCHAR _achText[MAX_SNOOP_TEXT];
    static ATOM _atomWndClass;
};

#endif // SNOOP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\mark\editsess.h ===
//
// editsess.h
//
// CEditSessionBase declaration.
//

#ifndef EDITSESS_H
#define EDITSESS_H

class CEditSessionBase : public ITfEditSession
{
public:
    CEditSessionBase(ITfContext *pContext)
    {
        _cRef = 1;
        _pContext = pContext;
        _pContext->AddRef();
    }
    virtual ~CEditSessionBase()
    {
        _pContext->Release();
    }

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj)
    {
        if (ppvObj == NULL)
            return E_INVALIDARG;

        *ppvObj = NULL;

        if (IsEqualIID(riid, IID_IUnknown) ||
            IsEqualIID(riid, IID_ITfEditSession))
        {
            *ppvObj = (ITfLangBarItemButton *)this;
        }

        if (*ppvObj)
        {
            AddRef();
            return S_OK;
        }

        return E_NOINTERFACE;
    }
    STDMETHODIMP_(ULONG) AddRef(void)
    {
        return ++_cRef;
    }
    STDMETHODIMP_(ULONG) Release(void)
    {
        LONG cr = --_cRef;

        assert(_cRef >= 0);

        if (_cRef == 0)
        {
            delete this;
        }

        return cr;
    }

    // ITfEditSession
    virtual STDMETHODIMP DoEditSession(TfEditCookie ec) = 0;

protected:
    ITfContext *_pContext;

private:
    LONG _cRef;     // COM ref count
};

#endif // EDITSESS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\case\snoop.cpp ===
//
// snoop.cpp
//
// CSnoopWnd implementation.
//

#include "globals.h"
#include "snoop.h"
#include "case.h"
#include "editsess.h"

class CUpdateTextEditSession : public CEditSessionBase
{
public:
    CUpdateTextEditSession(ITfContext *pContext, ITfRange *pRange, CSnoopWnd *pSnoopWnd) : CEditSessionBase(pContext)
    {
        _pSnoopWnd = pSnoopWnd;
        _pRange = pRange;
        if (_pRange != NULL)
        {
            _pRange->AddRef();
        }
    }
    ~CUpdateTextEditSession()
    {
        SafeRelease(_pRange);
    }

    // ITfEditSession
    STDMETHODIMP DoEditSession(TfEditCookie ec);

private:
    CSnoopWnd *_pSnoopWnd;
    ITfRange *_pRange;
};


#define SNOOP_X_POS     0
#define SNOOP_Y_POS     0

#define SNOOP_WIDTH     300
#define SNOOP_HEIGHT    (SNOOP_WIDTH / 3)

ATOM CSnoopWnd::_atomWndClass = 0;

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CSnoopWnd::CSnoopWnd(CCaseTextService *pCase)
{
    _pCase = pCase; // no AddRef because CSnoopWnd is contained in the
                    // pCase lifetime
    _hWnd = NULL;
    _cchText = 0;
}

//+---------------------------------------------------------------------------
//
// _InitClass
//
//----------------------------------------------------------------------------

/* static */
BOOL CSnoopWnd::_InitClass()
{
    WNDCLASS wc;

    wc.style = 0;
    wc.lpfnWndProc = CSnoopWnd::_WndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = g_hInst;
    wc.hIcon = NULL;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = NULL;
    wc.lpszMenuName = NULL;
    wc.lpszClassName = TEXT("SnoopWndClass");

    _atomWndClass = RegisterClass(&wc);

    return (_atomWndClass != 0);
}

//+---------------------------------------------------------------------------
//
// _UninitClass
//
//----------------------------------------------------------------------------

/* static */
void CSnoopWnd::_UninitClass()
{
    if (_atomWndClass != 0)
    {
        UnregisterClass((LPCTSTR)_atomWndClass, g_hInst);
    }
}


//+---------------------------------------------------------------------------
//
// _Init
//
//----------------------------------------------------------------------------

BOOL CSnoopWnd::_Init()
{
    // nb: on windows 2000, you can use WS_EX_NOACTIVATE to prevent windows
    // from taking the foreground.  We don't use that here for compatibility.
    // Instead, we use WS_DISABLED, which can be burdensome for more complex
    // ui.

    _hWnd = CreateWindowEx(WS_EX_TOPMOST | WS_EX_TOOLWINDOW,
                           (LPCTSTR)_atomWndClass,
                           TEXT("Snoop Window"),
                           WS_BORDER | WS_DISABLED | WS_POPUP,
                           SNOOP_X_POS, SNOOP_Y_POS,
                           SNOOP_WIDTH, SNOOP_HEIGHT,
                           NULL,
                           NULL,
                           g_hInst,
                           this);

    return (_hWnd != NULL);
}

//+---------------------------------------------------------------------------
//
// _Uninit
//
//----------------------------------------------------------------------------

void CSnoopWnd::_Uninit()
{
    if (_hWnd != NULL)
    {
        DestroyWindow(_hWnd);
        _hWnd = NULL;
    }
}

//+---------------------------------------------------------------------------
//
// _Show
//
//----------------------------------------------------------------------------

void CSnoopWnd::_Show()
{
    ShowWindow(_hWnd, SW_SHOWNA);
}

//+---------------------------------------------------------------------------
//
// _Hide
//
//----------------------------------------------------------------------------

void CSnoopWnd::_Hide()
{
    ShowWindow(_hWnd, SW_HIDE);
}

//+---------------------------------------------------------------------------
//
// _UpdateText
//
//----------------------------------------------------------------------------

void CSnoopWnd::_UpdateText(ITfRange *pRange)
{
    ITfDocumentMgr *pdmFocus;
    ITfContext *pContext;
    CUpdateTextEditSession *pEditSession;
    HRESULT hr;

    if (pRange == NULL)
    {
        // caller wants us to just use the selection in the focus doc
        if (_pCase->_GetThreadMgr()->GetFocus(&pdmFocus) != S_OK)
            return;

        hr = pdmFocus->GetTop(&pContext);

        pdmFocus->Release();

        if (hr != S_OK)
            return;
    }
    else if (pRange->GetContext(&pContext) != S_OK)
        return;

    if (pEditSession = new CUpdateTextEditSession(pContext, pRange, this))
    {
        // we need a document read lock to scan text
        // the CUpdateTextEditSession will do all the work when the
        // CUpdateTextEditSession::DoEditSession method is called by the context
        pContext->RequestEditSession(_pCase->_GetClientId(), pEditSession, TF_ES_READ | TF_ES_ASYNCDONTCARE, &hr);

        pEditSession->Release();
    }

    pContext->Release();
}

//+---------------------------------------------------------------------------
//
// DoEditSession
//
//----------------------------------------------------------------------------

STDAPI CUpdateTextEditSession::DoEditSession(TfEditCookie ec)
{
    _pSnoopWnd->_UpdateText(ec, _pContext, _pRange);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _UpdateText
//
//----------------------------------------------------------------------------

void CSnoopWnd::_UpdateText(TfEditCookie ec, ITfContext *pContext, ITfRange *pRange)
{
    LONG cchBefore;
    LONG cchAfter;
    TF_SELECTION tfSelection;
    ULONG cFetched;
    BOOL fReleaseRange = FALSE;

    if (pRange == NULL)
    {
        // caller wants us to use the selection
        if (pContext->GetSelection(ec, TS_DEFAULT_SELECTION, 1, &tfSelection, &cFetched) != S_OK ||
            cFetched != 1)
        {
            return;
        }

        pRange = tfSelection.range; // no AddRef, take ownership of the pointer
        fReleaseRange = TRUE;
    }

    // arbitrarily grab some text before and after the range start anchor

    pRange->Collapse(ec, TF_ANCHOR_START);

    pRange->ShiftStart(ec, -MAX_SNOOP_TEXT / 2, &cchBefore, NULL);

    cchBefore = -cchBefore; // we shifted backwards, so make count a positive number

    pRange->GetText(ec, 0, _achText, cchBefore, (ULONG *)&cchBefore);

    pRange->Collapse(ec, TF_ANCHOR_END);

    pRange->ShiftEnd(ec, MAX_SNOOP_TEXT - cchBefore, &cchAfter, NULL);

    pRange->GetText(ec, 0, _achText + cchBefore, cchAfter, (ULONG *)&cchAfter);

    _cchText = cchBefore + cchAfter;

    // force a repaint

    InvalidateRect(_hWnd, NULL, TRUE);

    if (fReleaseRange)
    {
        pRange->Release();
    }
}

//+---------------------------------------------------------------------------
//
// _WndProc
//
// Snoop window proc.
//----------------------------------------------------------------------------

/* static */
LRESULT CALLBACK CSnoopWnd::_WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HDC hdc;
    PAINTSTRUCT ps;

    switch (uMsg)
    {
        case WM_CREATE:
            _SetThis(hWnd, lParam);
            return 0;

        case WM_PAINT:
            hdc = BeginPaint(hWnd, &ps);
            _GetThis(hWnd)->_OnPaint(hWnd, hdc);
            EndPaint(hWnd, &ps);
            return 0;
    }

    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

//+---------------------------------------------------------------------------
//
// _OnPaint
//
// WM_PAINT handler for CSnoopWnd.
//----------------------------------------------------------------------------

void CSnoopWnd::_OnPaint(HWND hWnd, HDC hdc)
{
    RECT rc;

    // background
    GetClientRect(hWnd, &rc);
    FillRect(hdc, &rc, (HBRUSH)GetStockObject(LTGRAY_BRUSH));

    // text
    TextOutW(hdc, 0, 0, _achText, _cchText);
}

//+---------------------------------------------------------------------------
//
// _InitSnoopWnd
//
// Create and init the snoop window.
//----------------------------------------------------------------------------

BOOL CCaseTextService::_InitSnoopWnd()
{
    BOOL fThreadfocus;
    ITfSource *pSource = NULL;

    // create a snoop window

    if ((_pSnoopWnd = new CSnoopWnd(this)) == NULL)
        return FALSE;

    if (!_pSnoopWnd->_Init())
        goto ExitError;

    // we also need a thread focus sink

    if (_pThreadMgr->QueryInterface(IID_ITfSource, (void **)&pSource) != S_OK)
    {
        pSource = NULL;
        goto ExitError;
    }

    if (pSource->AdviseSink(IID_ITfThreadFocusSink, (ITfThreadFocusSink *)this, &_dwThreadFocusSinkCookie) != S_OK)
    {
        // make sure we don't try to Unadvise _dwThreadFocusSinkCookie later
        _dwThreadFocusSinkCookie = TF_INVALID_COOKIE;
        goto ExitError;
    }

    pSource->Release();

    // we may need to display the snoop window right now
    // our thread focus sink won't be called until something changes,
    // so we need to check the current state.

    if (_pThreadMgr->IsThreadFocus(&fThreadfocus) == S_OK && fThreadfocus)
    {
        OnSetThreadFocus();
    }

    return TRUE;

ExitError:
    SafeRelease(pSource);
    _UninitSnoopWnd();
    return FALSE;
}

//+---------------------------------------------------------------------------
//
// _UninitSnoopWnd
//
// Uninit and free the snoop window, unadvise the thread focus sink.
//----------------------------------------------------------------------------

void CCaseTextService::_UninitSnoopWnd()
{
    ITfSource *pSource;

    if (_pSnoopWnd != NULL)
    {
        _pSnoopWnd->_Uninit();
        delete _pSnoopWnd;
    }

    if (_dwThreadFocusSinkCookie != TF_INVALID_COOKIE)
    {
        if (_pThreadMgr->QueryInterface(IID_ITfSource, (void **)&pSource) == S_OK)
        {
            pSource->UnadviseSink(_dwThreadFocusSinkCookie);
            pSource->Release();
        }

        _dwThreadFocusSinkCookie = TF_INVALID_COOKIE;
    }
}

//+---------------------------------------------------------------------------
//
// _Menu_ShowSnoopWnd
//
// Show or hide the snoop window.
//----------------------------------------------------------------------------

void CCaseTextService::_Menu_ShowSnoopWnd(CCaseTextService *_this)
{
    _this->_fShowSnoop = !_this->_fShowSnoop;

    if (_this->_fShowSnoop)
    {
        _this->_pSnoopWnd->_Show();
    }
    else
    {
        _this->_pSnoopWnd->_Hide();
    }
}

//+---------------------------------------------------------------------------
//
// OnSetThreadFocus
//
// Called by the system when the thread/appartment of this text service gains
// the ui focus.
//----------------------------------------------------------------------------

STDAPI CCaseTextService::OnSetThreadFocus()
{
    if (_fShowSnoop)
    {
        _pSnoopWnd->_Show();
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnKillThreadFocus
//
// Called by the system when the thread/appartment of this text service loses
// the ui focus.
//----------------------------------------------------------------------------

STDAPI CCaseTextService::OnKillThreadFocus()
{
    // only show our snoop window when our thread has the focus.
    if (_fShowSnoop)
    {
        _pSnoopWnd->_Hide();
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\mark\cleanup.cpp ===
//
// cleanup.cpp
//
// ITfCleanupContextDurationSink, ITfCleanupContextSink implementation.
//

#include "globals.h"
#include "mark.h"

//+---------------------------------------------------------------------------
//
// ITfCleanupContextDurationSink::OnStartCleanupContext
//
// TSF calls this method before it starts making OnCleanupContext callbacks.
// When this happens, we know we're just about to be shut down, and this will
// be our last chance to modify text in the document.  So we'll set a flag so
// we know not to initialize any contexts that might get created during the
// shutdown.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::OnStartCleanupContext()
{
    _fCleaningUp = TRUE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// ITfCleanupContextDurationSink::OnEndCleanupContext
//
// Clear the cleanup flag.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::OnEndCleanupContext()
{
    _fCleaningUp = FALSE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// ITfCleanupContextSink::OnCleanupContext
//
// The system calls this method if we're about to be deactivated.  It's our
// last chance to modify text in the context.  This is the time to abort any
// ongoing compositions.
//
// You won't see this callback shutting down the app if the app destroys all
// contexts before deactivating TSF.  Another way to get here is by installing
// a non-english keyboard layout or text service.  If you switch languages
// from english, the mark text service will be shut down before the context,
// and this method will be called.
//
// There's intentionally no way to get an edit cookie when a context is popped.
// In this case, it is assumed the context state is going to be thrown away.
// It's the owner's responsibility to terminate any compositions/text services
// before a Pop if they care about the contents afterwards.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::OnCleanupContext(TfEditCookie ecWrite, ITfContext *pContext)
{
    // this sample has nothing to do here...a real text service wouldn't bother
    // to advise the sink in the first place if it took no action
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _InitCleanupContextSink
//
//----------------------------------------------------------------------------

BOOL CMarkTextService::_InitCleanupContextDurationSink()
{
    return AdviseSingleSink(_tfClientId, _pThreadMgr, (ITfCleanupContextDurationSink *)this,
                            IID_ITfCleanupContextDurationSink);
}

//+---------------------------------------------------------------------------
//
// _UninitCleanupContextSink
//
//----------------------------------------------------------------------------

void CMarkTextService::_UninitCleanupContextDurationSink()
{
    UnadviseSingleSink(_tfClientId, _pThreadMgr, IID_ITfCleanupContextDurationSink);
}

//+---------------------------------------------------------------------------
//
// _InitCleanupContextSink
//
//----------------------------------------------------------------------------

BOOL CMarkTextService::_InitCleanupContextSink(ITfContext *pContext)
{
    return AdviseSingleSink(_tfClientId, pContext, (ITfCleanupContextSink *)this,
                            IID_ITfCleanupContextSink);
}

//+---------------------------------------------------------------------------
//
// _UninitCleanupContextSink
//
//----------------------------------------------------------------------------

void CMarkTextService::_UninitCleanupContextSink(ITfContext *pContext)
{
    UnadviseSingleSink(_tfClientId, pContext, IID_ITfCleanupContextSink);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\mark\compart.cpp ===
//
// compart.cpp
//
// Compartment example.
//

#include "globals.h"
#include "mark.h"

//+---------------------------------------------------------------------------
//
// _InitCompartment
//
// Initialize a compartment on a particular context.
//
// The Mark sample doesn't really do any with its context compartment, this
// code is purely for demonstration purposes.
//----------------------------------------------------------------------------

BOOL CMarkTextService::_InitContextCompartment(ITfContext *pContext)
{
    ITfCompartmentMgr *pCompartmentMgr;
    ITfCompartment *pCompartment;
    VARIANT varValue;
    HRESULT hr;

    // we want the mgr associated with pContext
    if (pContext->QueryInterface(IID_ITfCompartmentMgr, (void **)&pCompartmentMgr) != S_OK)
        return FALSE;

    hr = E_FAIL;

    if (pCompartmentMgr->GetCompartment(c_guidMarkContextCompartment, &pCompartment) != S_OK)
        goto Exit;

    // if we don't initialize the value, it will be VT_EMPTY
    // but let's initialize it to 0

    // NB: to keep things simple, we use a VT_I4
    // but you could use VT_UNKNOWN and store a pointer to anything
    varValue.vt = VT_I4;
    varValue.lVal = 0; // arbitrary value

    hr = pCompartment->SetValue(_tfClientId, &varValue);

    pCompartment->Release();

Exit:
    pCompartmentMgr->Release();

    return (hr == S_OK);
}

//+---------------------------------------------------------------------------
//
// _UninitCompartment
//
// Uninitialize a compartment on a particular context.
//
// The Mark sample doesn't really do any with its context compartment, this
// code is purely for demonstration purposes.
//----------------------------------------------------------------------------

void CMarkTextService::_UninitCompartment(ITfContext *pContext)
{
    ITfCompartmentMgr *pCompartmentMgr;

    // we want the mgr associated with pContext
    if (pContext->QueryInterface(IID_ITfCompartmentMgr, (void **)&pCompartmentMgr) != S_OK)
        return;

    pCompartmentMgr->ClearCompartment(_tfClientId, c_guidMarkContextCompartment);

    pCompartmentMgr->Release();
}

//+---------------------------------------------------------------------------
//
// _Menu_OnSetGlobalCompartment
//
// Callback for the "Set Global Compartment" menu item.
// Set the value of our global compartment.  This will trigger a callback
// on our compartment change sinks in every thread/instance of this service.
//----------------------------------------------------------------------------

/* static */
void CMarkTextService::_Menu_OnSetGlobalCompartment(CMarkTextService *_this)
{
    ITfCompartmentMgr *pCompartmentMgr;
    ITfCompartment *pCompartment;
    VARIANT varValue;

    // we want the global mgr
    if (_this->_pThreadMgr->GetGlobalCompartment(&pCompartmentMgr) != S_OK)
        return;

    if (pCompartmentMgr->GetCompartment(c_guidMarkGlobalCompartment, &pCompartment) != S_OK)
    {
        pCompartment = NULL;
        goto Exit;
    }

    // let's toggle the value
    // notice that global compartments are persisted, unlike all others
    if (FAILED(pCompartment->GetValue(&varValue))) // will return S_FALSE if varValue.vt == VT_EMPTY
        goto Exit;

    if (varValue.vt == VT_EMPTY)
    {
        // if we get here, the compartment has never been initialized
        varValue.vt = VT_I4;
        varValue.lVal = 0;
    }

    // toggle value
    varValue.lVal = ~varValue.lVal;

    pCompartment->SetValue(_this->_tfClientId, &varValue);

Exit:
    SafeRelease(pCompartment);
    pCompartmentMgr->Release();
}

//+---------------------------------------------------------------------------
//
// _InitGlobalCompartment
//
// Ininit a change sink on our global compartment.  The system will call us
// back anytime the compartment is modified from any thread in the desktop.
//
// NB: ITfCompartmentEventSink's attached to thread local compartments will
// only get callbacks to changes that occur within a single thread.  Global
// compartments are different.
//----------------------------------------------------------------------------

BOOL CMarkTextService::_InitGlobalCompartment()
{
    ITfCompartmentMgr *pCompartmentMgr;
    ITfCompartment *pCompartment;
    BOOL fRet;

    // we want the global mgr
    if (_pThreadMgr->GetGlobalCompartment(&pCompartmentMgr) != S_OK)
        return FALSE;

    fRet = FALSE;

    if (pCompartmentMgr->GetCompartment(c_guidMarkGlobalCompartment, &pCompartment) != S_OK)
        goto Exit;

    fRet = AdviseSink(pCompartment, (ITfCompartmentEventSink *)this,
                      IID_ITfCompartmentEventSink, &_dwGlobalCompartmentEventSinkCookie);

    pCompartment->Release();

    if (!fRet)
    {
        // don't try to unadvise a bogus cookie later
        _dwGlobalCompartmentEventSinkCookie = TF_INVALID_COOKIE;
    }

Exit:
    pCompartmentMgr->Release();
    return fRet;
}

//+---------------------------------------------------------------------------
//
// _UninitCompartment
//
// Unitialize the global compartment if we have previously accessed it.
// This method only frees resources the system has allocated in this thread.
// Other threads can still access the global compartment, and the value (which
// is persisted across the desktop) does not change.
//
// Also, uninit the change sink we attached to the compartment.
//----------------------------------------------------------------------------

void CMarkTextService::_UninitGlobalCompartment()
{
    ITfCompartmentMgr *pCompartmentMgr;
    ITfCompartment *pCompartment;

    // we want the global mgr
    if (_pThreadMgr->GetGlobalCompartment(&pCompartmentMgr) != S_OK)
        return;

    // unadvise our event sink
    if (pCompartmentMgr->GetCompartment(c_guidMarkGlobalCompartment, &pCompartment) == S_OK)
    {
        UnadviseSink(pCompartment, &_dwGlobalCompartmentEventSinkCookie);
        pCompartment->Release();
    }

    // let the system free resources associated with the compartment on this
    // thread
    pCompartmentMgr->ClearCompartment(_tfClientId, c_guidMarkGlobalCompartment);

    pCompartmentMgr->Release();
}

//+---------------------------------------------------------------------------
//
// ITfCompartmentEventSink::OnChange
//
// TSF calls this method anytime our private global compartment is modified,
// even from other threads/processes.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::OnChange(REFGUID rguidCompartment)
{
    // nothing to do in this sample
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\mark\compose.cpp ===
//
// compose.cpp
//
// Composition code.
//

#include "globals.h"
#include "mark.h"
#include "editsess.h"

class CCompositionEditSession : public CEditSessionBase
{
public:
    CCompositionEditSession(ITfContext *pContext, CMarkTextService *pMark) : CEditSessionBase(pContext)
    {
        _pMark = pMark;
        _pMark->AddRef();
    }
    ~CCompositionEditSession()
    {
        _pMark->Release();
    }

    // ITfEditSession
    STDMETHODIMP DoEditSession(TfEditCookie ec);

private:
    CMarkTextService *_pMark;
};

class CTerminateCompositionEditSession : public CEditSessionBase
{
public:
    CTerminateCompositionEditSession(CMarkTextService *pMark, ITfContext *pContext) : CEditSessionBase(pContext)
    {
        _pMark = pMark;
        _pMark->AddRef();
    }
    ~CTerminateCompositionEditSession()
    {
        _pMark->Release();
    }

    // ITfEditSession
    STDMETHODIMP DoEditSession(TfEditCookie ec)
    {
        _pMark->_TerminateComposition(ec);
        return S_OK;
    }

private:
    CMarkTextService *_pMark;
};

//+---------------------------------------------------------------------------
//
// _TerminateCompositionInContext
//
//----------------------------------------------------------------------------

void CMarkTextService::_TerminateCompositionInContext(ITfContext *pContext)
{
    CTerminateCompositionEditSession *pEditSession;
    HRESULT hr;

    if (pEditSession = new CTerminateCompositionEditSession(this, pContext))
    {
        pContext->RequestEditSession(_tfClientId, pEditSession, TF_ES_ASYNCDONTCARE | TF_ES_READWRITE, &hr);
        pEditSession->Release();
    }
}

//+---------------------------------------------------------------------------
//
// _Menu_OnComposition
//
// Callback for the "Start/End Composition" menu item.
// If we have a composition, end it.  Otherwise start a new composition over
// the selection of the current focus context.
//----------------------------------------------------------------------------

/* static */
void CMarkTextService::_Menu_OnComposition(CMarkTextService *_this)
{
    ITfDocumentMgr *pFocusDoc;
    ITfContext *pContext;
    CCompositionEditSession *pCompositionEditSession;
    HRESULT hr;

    // get the focus document
    if (_this->_pThreadMgr->GetFocus(&pFocusDoc) != S_OK)
        return;

    // we want the topmost context, since the main doc context could be
    // superceded by a modal tip context
    if (pFocusDoc->GetTop(&pContext) != S_OK)
    {
        pContext = NULL;
        goto Exit;
    }

    if (pCompositionEditSession = new CCompositionEditSession(pContext, _this))
    {
        // we need a document write lock
        // the CCompositionEditSession will do all the work when the
        // CCompositionEditSession::DoEditSession method is called by the context
        pContext->RequestEditSession(_this->_tfClientId, pCompositionEditSession, TF_ES_READWRITE | TF_ES_ASYNCDONTCARE, &hr);

        pCompositionEditSession->Release();
    }

Exit:
    SafeRelease(pContext);
    pFocusDoc->Release();    
}

//+---------------------------------------------------------------------------
//
// DoEditSession
//
//----------------------------------------------------------------------------

STDAPI CCompositionEditSession::DoEditSession(TfEditCookie ec)
{
    ITfInsertAtSelection *pInsertAtSelection;
    ITfContextComposition *pContextComposition;
    ITfComposition *pComposition;
    ITfRange *pRangeComposition;
    ITfRange *pRangeInsert;
    ITfContext *pCompositionContext;
    HRESULT hr;
    BOOL fEqualContexts;

    // get an interface on the context we can use to deal with compositions
    if (_pContext->QueryInterface(IID_ITfContextComposition, (void **)&pContextComposition) != S_OK)
        return E_FAIL;

    hr = E_FAIL;

    pInsertAtSelection = NULL;

    if (_pMark->_IsComposing())
    {
        // we have a composition, let's terminate it
        
        // it's possible our current composition is in another context...let's find out
        fEqualContexts = TRUE;
        if (_pMark->_GetComposition()->GetRange(&pRangeComposition) == S_OK)
        {
            if (pRangeComposition->GetContext(&pCompositionContext) == S_OK)
            {
                fEqualContexts = IsEqualUnknown(pCompositionContext, _pContext);
                if (!fEqualContexts)
                {
                    // need an edit session in the composition context
                    _pMark->_TerminateCompositionInContext(pCompositionContext);
                }
                pCompositionContext->Release();
            }
            pRangeComposition->Release();
        }

        // if the composition is in pContext, we already have an edit cookie
        if (fEqualContexts)
        {
            _pMark->_TerminateComposition(ec);
        }
    }
    else
    {
        // let's start a new composition over the current selection
        // this is totally contrived, a real text service would have
        // some meaningful logic to trigger this

        // first, test where a keystroke would go in the document if we did an insert
        // we need a special interface to insert text at the selection
        if (_pContext->QueryInterface(IID_ITfInsertAtSelection, (void **)&pInsertAtSelection) != S_OK)
        {
            pInsertAtSelection = NULL;
            goto Exit;
        }

        if (pInsertAtSelection->InsertTextAtSelection(ec, TF_IAS_QUERYONLY, NULL, 0, &pRangeInsert) != S_OK)
            goto Exit;

        // start the composition
        if (pContextComposition->StartComposition(ec, pRangeInsert, _pMark, &pComposition) != S_OK)
        {
            pComposition = NULL;
        }

        pRangeInsert->Release();

        // _pComposition may be NULL even if StartComposition return S_OK, this mean the application
        // rejected the composition

        if (pComposition != NULL)
        {
            _pMark->_SetComposition(pComposition);
            // underline the composition text to give the user some feedback UI
            _pMark->_SetCompositionDisplayAttributes(ec);
        }
    }

    // if we make it here, we've succeeded
    hr = S_OK;

Exit:
    SafeRelease(pInsertAtSelection);
    pContextComposition->Release();

    return hr;
}

//+---------------------------------------------------------------------------
//
// OnCompositionTerminated
//
// Callback for ITfCompositionSink.  The system calls this method whenever
// someone other than this service ends a composition.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::OnCompositionTerminated(TfEditCookie ecWrite, ITfComposition *pComposition)
{
    // we already have the composition cached, so we can ignore pComposition...

    // all this service wants to do is clear the display property
    _ClearCompositionDisplayAttributes(ecWrite);

    // releae our cached composition
    SafeReleaseClear(_pComposition);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _ClearCompositionDisplayAttributes
//
//----------------------------------------------------------------------------

void CMarkTextService::_ClearCompositionDisplayAttributes(TfEditCookie ec)
{
    ITfRange *pRangeComposition;
    ITfContext *pContext;
    ITfProperty *pDisplayAttributeProperty;

    // we need a range and the context it lives in
    if (_pComposition->GetRange(&pRangeComposition) != S_OK)
        return;

    if (pRangeComposition->GetContext(&pContext) != S_OK)
    {
        pContext = NULL;
        goto Exit;
    }

    // get our the display attribute property
    if (pContext->GetProperty(GUID_PROP_ATTRIBUTE, &pDisplayAttributeProperty) != S_OK)
        goto Exit;

    // clear the value over the range
    pDisplayAttributeProperty->Clear(ec, pRangeComposition);

    pDisplayAttributeProperty->Release();

Exit:
    pRangeComposition->Release();
    SafeRelease(pContext);
}

//+---------------------------------------------------------------------------
//
// _SetCompositionDisplayAttributes
//
//----------------------------------------------------------------------------

BOOL CMarkTextService::_SetCompositionDisplayAttributes(TfEditCookie ec)
{
    ITfRange *pRangeComposition;
    ITfContext *pContext;
    ITfProperty *pDisplayAttributeProperty;
    VARIANT var;
    HRESULT hr;

    // we need a range and the context it lives in
    if (_pComposition->GetRange(&pRangeComposition) != S_OK)
        return FALSE;

    hr = E_FAIL;

    if (pRangeComposition->GetContext(&pContext) != S_OK)
    {
        pContext = NULL;
        goto Exit;
    }

    // get our the display attribute property
    if (pContext->GetProperty(GUID_PROP_ATTRIBUTE, &pDisplayAttributeProperty) != S_OK)
        goto Exit;

    // set the value over the range
    // the application will use this guid atom to lookup the acutal rendering information
    var.vt = VT_I4; // we're going to set a TfGuidAtom
    var.lVal = _gaDisplayAttribute; // our cached guid atom for c_guidMarkDisplayAttribute

    hr = pDisplayAttributeProperty->SetValue(ec, pRangeComposition, &var);

    pDisplayAttributeProperty->Release();

Exit:
    pRangeComposition->Release();
    SafeRelease(pContext);
    return (hr == S_OK);
}

//+---------------------------------------------------------------------------
//
// _InitDisplayAttributeGuidAtom
//
// Because it's expensive to map our display attribute GUID to a TSF
// TfGuidAtom, we do it once when Activate is called.
//----------------------------------------------------------------------------

BOOL CMarkTextService::_InitDisplayAttributeGuidAtom()
{
    ITfCategoryMgr *pCategoryMgr;
    HRESULT hr;

    if (CoCreateInstance(CLSID_TF_CategoryMgr,
                         NULL, 
                         CLSCTX_INPROC_SERVER, 
                         IID_ITfCategoryMgr, 
                         (void**)&pCategoryMgr) != S_OK)
    {
        return FALSE;
    }

    hr = pCategoryMgr->RegisterGUID(c_guidMarkDisplayAttribute, &_gaDisplayAttribute);

    pCategoryMgr->Release();
        
    return (hr == S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\mark\dllmain.cpp ===
//
// dllmain.cpp
//
// DllMain module entry point.
//

#include "globals.h"

//+---------------------------------------------------------------------------
//
// DllMain
//
//----------------------------------------------------------------------------

BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID pvReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:

            g_hInst = hInstance;

            if (!InitializeCriticalSectionAndSpinCount(&g_cs, 0))
                return FALSE;

            break;

        case DLL_PROCESS_DETACH:

            DeleteCriticalSection(&g_cs);

            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\mark\dap.cpp ===
//
// dap.cpp
//
// ITfDisplayAttributeProvider implementation.
//

#include "globals.h"
#include "mark.h"

static const TCHAR c_szAttributeInfoKey[] = TEXT("Software\\Mark Text Service");
static const TCHAR c_szAttributeInfoValueName[] = TEXT("DisplayAttr");

// this text service has only a single display attribute so we'll use
// a single static object.
class CDisplayAttributeInfo : public ITfDisplayAttributeInfo
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void)
    {
        return DllAddRef();
    }
    STDMETHODIMP_(ULONG) Release(void)
    {
        return DllRelease();
    }

    // ITfDisplayAttributeInfo
    STDMETHODIMP GetGUID(GUID *pguid);
    STDMETHODIMP GetDescription(BSTR *pbstrDesc);
    STDMETHODIMP GetAttributeInfo(TF_DISPLAYATTRIBUTE *ptfDisplayAttr);
    STDMETHODIMP SetAttributeInfo(const TF_DISPLAYATTRIBUTE *ptfDisplayAttr);
    STDMETHODIMP Reset();

private:
    static const TF_DISPLAYATTRIBUTE _c_DefaultDisplayAttribute;
}
g_DisplayAttributeInfo;

const TF_DISPLAYATTRIBUTE CDisplayAttributeInfo::_c_DefaultDisplayAttribute =
{
    { TF_CT_COLORREF, RGB(255, 0, 0) },     // text color
    { TF_CT_NONE, 0 },                      // background color (TF_CT_NONE => app default)
    TF_LS_SOLID,                            // underline style
    FALSE,                                  // underline boldness
    { TF_CT_COLORREF, RGB(255, 0, 0) },     // underline color
    TF_ATTR_INPUT                           // attribute info
};

//+---------------------------------------------------------------------------
//
// QueryInterface
//
//----------------------------------------------------------------------------

STDAPI CDisplayAttributeInfo::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfDisplayAttributeInfo))
    {
        *ppvObj = (ITfDisplayAttributeInfo *)this;
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------------------
//
// GetGUID
//
//----------------------------------------------------------------------------

STDAPI CDisplayAttributeInfo::GetGUID(GUID *pguid)
{
    if (pguid == NULL)
        return E_INVALIDARG;

    *pguid = c_guidMarkDisplayAttribute;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetDescription
//
//----------------------------------------------------------------------------

STDAPI CDisplayAttributeInfo::GetDescription(BSTR *pbstrDesc)
{
    BSTR bstrDesc;

    if (pbstrDesc == NULL)
        return E_INVALIDARG;

    *pbstrDesc = NULL;

    if ((bstrDesc = SysAllocString(L"Mark Display Attribute")) == NULL)
        return E_OUTOFMEMORY;

    *pbstrDesc = bstrDesc;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetAttributeInfo
//
//----------------------------------------------------------------------------

STDAPI CDisplayAttributeInfo::GetAttributeInfo(TF_DISPLAYATTRIBUTE *ptfDisplayAttr)
{
    HKEY hKeyAttributeInfo;
    LONG lResult;
    DWORD cbData;

    if (ptfDisplayAttr == NULL)
        return E_INVALIDARG;

    lResult = E_FAIL;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, c_szAttributeInfoKey, 0, KEY_READ, &hKeyAttributeInfo) == ERROR_SUCCESS)
    {
        cbData = sizeof(*ptfDisplayAttr);

        lResult = RegQueryValueEx(hKeyAttributeInfo, c_szAttributeInfoValueName,
                                  NULL, NULL,
                                  (LPBYTE)ptfDisplayAttr, &cbData);

        RegCloseKey(hKeyAttributeInfo);
    }

    if (lResult != ERROR_SUCCESS || cbData != sizeof(*ptfDisplayAttr))
    {
        // go with the defaults
        *ptfDisplayAttr = _c_DefaultDisplayAttribute;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// SetAttributeInfo
//
//----------------------------------------------------------------------------

STDAPI CDisplayAttributeInfo::SetAttributeInfo(const TF_DISPLAYATTRIBUTE *ptfDisplayAttr)
{
    HKEY hKeyAttributeInfo;
    LONG lResult;

    lResult = RegCreateKeyEx(HKEY_CURRENT_USER, c_szAttributeInfoKey, 0, TEXT(""),
                             REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                             &hKeyAttributeInfo, NULL);

    if (lResult != ERROR_SUCCESS)
        return E_FAIL;

    lResult = RegSetValueEx(hKeyAttributeInfo, c_szAttributeInfoValueName,
                            0, REG_BINARY, (const BYTE *)ptfDisplayAttr,
                            sizeof(*ptfDisplayAttr));

    RegCloseKey(hKeyAttributeInfo);

    return (lResult == ERROR_SUCCESS) ? S_OK : E_FAIL;
}

//+---------------------------------------------------------------------------
//
// Reset
//
//----------------------------------------------------------------------------

STDAPI CDisplayAttributeInfo::Reset()
{
    return SetAttributeInfo(&_c_DefaultDisplayAttribute);
}

class CEnumDisplayAttributeInfo : public IEnumTfDisplayAttributeInfo
{
public:
    CEnumDisplayAttributeInfo();
    ~CEnumDisplayAttributeInfo();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumTfDisplayAttributeInfo
    STDMETHODIMP Clone(IEnumTfDisplayAttributeInfo **ppEnum);
    STDMETHODIMP Next(ULONG ulCount, ITfDisplayAttributeInfo **rgInfo, ULONG *pcFetched);
    STDMETHODIMP Reset();
    STDMETHODIMP Skip(ULONG ulCount);

private:
    LONG _iIndex; // next display attribute to enum
    LONG _cRef; // COM ref count
};

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CEnumDisplayAttributeInfo::CEnumDisplayAttributeInfo()
{
    DllAddRef();

    _iIndex = 0;
    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CEnumDisplayAttributeInfo::~CEnumDisplayAttributeInfo()
{
    DllRelease();
}

//+---------------------------------------------------------------------------
//
// QueryInterface
//
//----------------------------------------------------------------------------

STDAPI CEnumDisplayAttributeInfo::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IEnumTfDisplayAttributeInfo))
    {
        *ppvObj = (IEnumTfDisplayAttributeInfo *)this;
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//+---------------------------------------------------------------------------
//
// AddRef
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CEnumDisplayAttributeInfo::AddRef()
{
    return ++_cRef;
}

//+---------------------------------------------------------------------------
//
// Release
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CEnumDisplayAttributeInfo::Release()
{
    LONG cr = --_cRef;

    assert(_cRef >= 0);

    if (_cRef == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// Clone
//
// Returns a copy of the object.
//----------------------------------------------------------------------------

STDAPI CEnumDisplayAttributeInfo::Clone(IEnumTfDisplayAttributeInfo **ppEnum)
{
    CEnumDisplayAttributeInfo *pClone;

    if (ppEnum == NULL)
        return E_INVALIDARG;

    *ppEnum = NULL;

    if ((pClone = new CEnumDisplayAttributeInfo) == NULL)
        return E_OUTOFMEMORY;

    // the clone should match this object's state
    pClone->_iIndex = _iIndex;

    *ppEnum = pClone;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Next
//
// Returns an array of display attribute info objects supported by this service.
//----------------------------------------------------------------------------

STDAPI CEnumDisplayAttributeInfo::Next(ULONG ulCount, ITfDisplayAttributeInfo **rgInfo, ULONG *pcFetched)
{
    ULONG cFetched;

    if (pcFetched == NULL)
    {
        // technically this is only legal if ulCount == 1, but we won't check
        pcFetched = &cFetched;
    }

    *pcFetched = 0;

    if (ulCount == 0)
        return S_OK;

    // we only have a single display attribute to enum, so this is trivial

    if (_iIndex == 0)
    {
        *rgInfo = &g_DisplayAttributeInfo;
        (*rgInfo)->AddRef();
        *pcFetched = 1;
        _iIndex++;
    }

    return (*pcFetched == ulCount) ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
// Reset
//
// Resets the enumeration.
//----------------------------------------------------------------------------

STDAPI CEnumDisplayAttributeInfo::Reset()
{
    _iIndex = 0;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Skip
//
// Skips past objects in the enumeration.
//----------------------------------------------------------------------------

STDAPI CEnumDisplayAttributeInfo::Skip(ULONG ulCount)
{
    // we have only a single item to enum
    // so we can just skip it and avoid any overflow errors
    if (ulCount > 0 && _iIndex == 0)
    {
        _iIndex++;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// EnumDisplayAttributeInfo
//
//----------------------------------------------------------------------------

STDAPI CMarkTextService::EnumDisplayAttributeInfo(IEnumTfDisplayAttributeInfo **ppEnum)
{
    CEnumDisplayAttributeInfo *pAttributeEnum;

    if (ppEnum == NULL)
        return E_INVALIDARG;

    *ppEnum = NULL;

    if ((pAttributeEnum = new CEnumDisplayAttributeInfo) == NULL)
        return E_OUTOFMEMORY;

    *ppEnum = pAttributeEnum;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetDisplayAttributeInfo
//
//----------------------------------------------------------------------------

STDAPI CMarkTextService::GetDisplayAttributeInfo(REFGUID guidInfo, ITfDisplayAttributeInfo **ppInfo)
{
    if (ppInfo == NULL)
        return E_INVALIDARG;

    *ppInfo = NULL;

    // unsupported GUID?
    if (!IsEqualGUID(guidInfo, c_guidMarkDisplayAttribute))
        return E_INVALIDARG;

    *ppInfo = &g_DisplayAttributeInfo;
    (*ppInfo)->AddRef();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\mark\precomp.cpp ===
//
// precomp.cpp
//
// Stub for vc precompiled header.
//

#include "globals.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\mark\globals.cpp ===
//
// globals.cpp
//
// Global variables.
//

#include "globals.h"

HINSTANCE g_hInst;

LONG g_cRefDll = -1; // -1 /w no refs, for win95 InterlockedIncrement/Decrement compat

CRITICAL_SECTION g_cs;

/* 23e97bc9-f2d3-4b25-8ef3-d78391bf2150 */
const CLSID c_clsidMarkTextService = { 0x23e97bc9, 0xf2d3, 0x4b25, {0x8e, 0xf3, 0xd7, 0x83, 0x91, 0xbf, 0x21, 0x50} };

/* a2767f97-e735-461a-84ba-7a7ecad24827 */
const GUID c_guidMarkProfile = { 0xa2767f97, 0xe735, 0x461a, {0x84, 0xba, 0x7a, 0x7e, 0xca, 0xd2, 0x48, 0x27} };

/* c74a88d5-6614-439b-8880-2dd8e6cd91a7 */
const GUID c_guidLangBarItemButton = { 0xc74a88d5, 0x6614, 0x439b, {0x88, 0x80, 0x2d, 0xd8, 0xe6, 0xcd, 0x91, 0xa7} };

/* d81face6-845c-45e7-a2af-1c5fc7adf667 */
const GUID c_guidMarkDisplayAttribute = { 0xd81face6, 0x845c, 0x45e7, {0xa2, 0xaf, 0x1c, 0x5f, 0xc7, 0xad, 0xf6, 0x67} };

/* eadc084c-6130-4222-82e5-c528c1f4abbb */
const GUID c_guidMarkContextCompartment = { 0xeadc084c, 0x6130, 0x4222, {0x82, 0xe5, 0xc5, 0x28, 0xc1, 0xf4, 0xab, 0xbb} };

/* 947d9d1c-7a4c-4392-b37c-34017c6c7fe1 */
const GUID c_guidMarkGlobalCompartment = { 0x947d9d1c, 0x7a4c, 0x4392, {0xb3, 0x7c, 0x34, 0x01, 0x7c, 0x6c, 0x7f, 0xe1} };

/* 3042ae6a-4697-4f7d-acdf-20a972fee027 */
const GUID c_guidCaseProperty = { 0x3042ae6a, 0x4697, 0x4f7d, {0xac, 0xdf, 0x20, 0xa9, 0x72, 0xfe, 0xe0, 0x27} };

/* d05a182a-7782-4e61-a2ea-6a4794ab7aaa */
const GUID c_guidCustomProperty = { 0xd05a182a, 0x7782, 0x4e61, {0xa2, 0xea, 0x6a, 0x47, 0x94, 0xab, 0x7a, 0xaa} };

//+---------------------------------------------------------------------------
//
// AdviseSink
//
//----------------------------------------------------------------------------

BOOL AdviseSink(IUnknown *pSourceIn, IUnknown *pSink, REFIID riid, DWORD *pdwCookie)
{
    ITfSource *pSource;
    HRESULT hr;

    if (pSourceIn->QueryInterface(IID_ITfSource, (void **)&pSource) != S_OK)
        return FALSE;

    hr = pSource->AdviseSink(riid, pSink, pdwCookie);

    pSource->Release();

    if (hr != S_OK)
    {
        // make sure we don't try to Unadvise pdwCookie later
        *pdwCookie = TF_INVALID_COOKIE;
        return FALSE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// UnadviseSink
//
//----------------------------------------------------------------------------

void UnadviseSink(IUnknown *pSourceIn, DWORD *pdwCookie)
{
    ITfSource *pSource;

    if (*pdwCookie == TF_INVALID_COOKIE)
        return; // never Advised

    if (pSourceIn->QueryInterface(IID_ITfSource, (void **)&pSource) == S_OK)
    {
        pSource->UnadviseSink(*pdwCookie);
        pSource->Release();
    }

    *pdwCookie = TF_INVALID_COOKIE;
}

//+---------------------------------------------------------------------------
//
// AdviseSingleSink
//
//----------------------------------------------------------------------------

BOOL AdviseSingleSink(TfClientId tfClientId, IUnknown *pSourceIn, IUnknown *pSink, REFIID riid)
{
    ITfSourceSingle *pSource;
    HRESULT hr;

    if (pSourceIn->QueryInterface(IID_ITfSourceSingle, (void **)&pSource) != S_OK)
        return FALSE;

    hr = pSource->AdviseSingleSink(tfClientId, riid, pSink);

    pSource->Release();

    return (hr == S_OK);
}

//+---------------------------------------------------------------------------
//
// UnadviseSingleSink
//
//----------------------------------------------------------------------------

void UnadviseSingleSink(TfClientId tfClientId, IUnknown *pSourceIn, REFIID riid)
{
    ITfSourceSingle *pSource;

    if (pSourceIn->QueryInterface(IID_ITfSourceSingle, (void **)&pSource) == S_OK)
    {
        pSource->UnadviseSingleSink(tfClientId, riid);
        pSource->Release();
    }
}

//+---------------------------------------------------------------------------
//
// IsRangeCovered
//
// Returns TRUE if pRangeTest is entirely contained within pRangeCover.
//----------------------------------------------------------------------------

BOOL IsRangeCovered(TfEditCookie ec, ITfRange *pRangeTest, ITfRange *pRangeCover)
{
    LONG lResult;

    if (pRangeCover->CompareStart(ec, pRangeTest, TF_ANCHOR_START, &lResult) != S_OK ||
        lResult > 0)
    {
        return FALSE;
    }

    if (pRangeCover->CompareEnd(ec, pRangeTest, TF_ANCHOR_END, &lResult) != S_OK ||
        lResult < 0)
    {
        return FALSE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// IsEqualUnknown
//
// Returns TRUE if punk1 and punk2 refer to the same object.  We must QI for
// IUnknown to be guarenteed a reliable test, per the COM rules.
//----------------------------------------------------------------------------

BOOL IsEqualUnknown(IUnknown *interface1, IUnknown *interface2)
{
    IUnknown *punk1;
    IUnknown *punk2;

    if (interface1->QueryInterface(IID_IUnknown, (void **)&punk1) != S_OK)
        return FALSE;

    punk1->Release(); // we don't actually need to dereference these guys, just want to compare them

    if (interface2->QueryInterface(IID_IUnknown, (void **)&punk2) != S_OK)
        return FALSE;

    punk2->Release();

    return (punk1 == punk2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\mark\editsink.cpp ===
//
// editsink.cpp
//
// ITfTextEditSink implementation.
//

#include "globals.h"
#include "mark.h"

//+---------------------------------------------------------------------------
//
// OnEndEdit
//
// Called by the system whenever anyone releases a write-access document lock.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::OnEndEdit(ITfContext *pContext, TfEditCookie ecReadOnly, ITfEditRecord *pEditRecord)
{
    ITfRange *pRangeComposition;
    IEnumTfRanges *pEnumRanges;
    ITfRange *pRange;
    ITfContext *pCompositionContext;
    TF_SELECTION tfSelection;
    BOOL fResult;
    BOOL fCancelComposition;
    ULONG cFetched;

    if (_pComposition == NULL)
        return S_OK;

    // are we responsible for the edit?
    if (pContext->InWriteSession(_tfClientId, &fResult) == S_OK && fResult)
        return S_OK;

    // is this the context our composition lives in?
    if (_pComposition->GetRange(&pRangeComposition) != S_OK)
        return S_OK;

    if (pRangeComposition->GetContext(&pCompositionContext) != S_OK)
        goto Exit;

    fResult = IsEqualUnknown(pCompositionContext, pContext);

    pCompositionContext->Release();

    if (!fResult)
        goto Exit; // different context

    fCancelComposition = FALSE;

    // we're composing in this context, cancel the composition if anything suspicious happened

    // did the selection move outside the composition?
    if (pEditRecord->GetSelectionStatus(&fResult) == S_OK && fResult)
    {
        if (pContext->GetSelection(ecReadOnly, TF_DEFAULT_SELECTION, 1, &tfSelection, &cFetched) == S_OK &&
            cFetched == 1)
        {
            if (_pComposition->GetRange(&pRangeComposition) == S_OK)
            {
                fResult = IsRangeCovered(ecReadOnly, tfSelection.range, pRangeComposition);

                pRangeComposition->Release();

                if (!fResult)
                {
                    fCancelComposition = TRUE;
                }
            }
            tfSelection.range->Release();
        }
    }

    if (fCancelComposition)
        goto CancelComposition;

    // did someone else edit the document text?
    if (pEditRecord->GetTextAndPropertyUpdates(TF_GTP_INCL_TEXT, NULL, 0, &pEnumRanges) == S_OK)
    {
        // is the enumerator empty?
        if (pEnumRanges->Next(1, &pRange, NULL) == S_OK)
        {
            pRange->Release();
            fCancelComposition = TRUE;
        }
        pEnumRanges->Release();
    }

    if (fCancelComposition)
    {
CancelComposition:
        // we need a write edit session to cancel the composition
        _TerminateCompositionInContext(pContext);
    }

Exit:
    pRangeComposition->Release();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _InitTextEditSink
//
// Init a text edit sink on the topmost context of the document.
// Always release any previous sink.
//----------------------------------------------------------------------------

BOOL CMarkTextService::_InitTextEditSink(ITfDocumentMgr *pDocMgr)
{
    ITfSource *pSource;
    BOOL fRet;

    // clear out any previous sink first

    if (_dwTextEditSinkCookie != TF_INVALID_COOKIE)
    {
        if (_pTextEditSinkContext->QueryInterface(IID_ITfSource, (void **)&pSource) == S_OK)
        {
            pSource->UnadviseSink(_dwTextEditSinkCookie);
            pSource->Release();
        }

        _pTextEditSinkContext->Release();
        _pTextEditSinkContext = NULL;
        _dwTextEditSinkCookie = TF_INVALID_COOKIE;
    }

    if (pDocMgr == NULL)
        return TRUE; // caller just wanted to clear the previous sink

    // setup a new sink advised to the topmost context of the document

    if (pDocMgr->GetTop(&_pTextEditSinkContext) != S_OK)
        return FALSE;

    if (_pTextEditSinkContext == NULL)
        return TRUE; // empty document, no sink possible

    fRet = FALSE;

    if (_pTextEditSinkContext->QueryInterface(IID_ITfSource, (void **)&pSource) == S_OK)
    {
        if (pSource->AdviseSink(IID_ITfTextEditSink, (ITfTextEditSink *)this, &_dwTextEditSinkCookie) == S_OK)
        {
            fRet = TRUE;
        }
        else
        {
            _dwTextEditSinkCookie = TF_INVALID_COOKIE;
        }
        pSource->Release();
    }

    if (fRet == FALSE)
    {
        _pTextEditSinkContext->Release();
        _pTextEditSinkContext = NULL;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\mark\keys.cpp ===
//
// keys.cpp
//
// ITfKeyEventSink implementation.
//

#include "globals.h"
#include "mark.h"
#include "editsess.h"

class CKeystrokeEditSession : public CEditSessionBase
{
public:
    CKeystrokeEditSession(CMarkTextService *pMark, ITfContext *pContext, WPARAM wParam) : CEditSessionBase(pContext)
    {
        _pMark = pMark;
        _pMark->AddRef();
        _wParam = wParam;
    }
    ~CKeystrokeEditSession()
    {
        _pMark->Release();
    }

    // ITfEditSession
    STDMETHODIMP DoEditSession(TfEditCookie ec);

private:
    CMarkTextService *_pMark;
    WPARAM _wParam;
};

//+---------------------------------------------------------------------------
//
// _HandleReturn
//
// Returns S_OK to eat the keystroke, S_FALSE otherwise.
//----------------------------------------------------------------------------

HRESULT CMarkTextService::_HandleReturn(TfEditCookie ec, ITfContext *pContext)
{
    // just terminate the composition
    _TerminateComposition(ec);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _HandleArrowKey
//
// Update the selection within a composition.
// Returns S_OK to eat the keystroke, S_FALSE otherwise.
//----------------------------------------------------------------------------

HRESULT CMarkTextService::_HandleArrowKey(TfEditCookie ec, ITfContext *pContext, WPARAM wParam)
{
    ITfRange *pRangeComposition;
    LONG cch;
    BOOL fEqual;
    TF_SELECTION tfSelection;
    ULONG cFetched;

    // get the selection
    if (pContext->GetSelection(ec, TF_DEFAULT_SELECTION, 1, &tfSelection, &cFetched) != S_OK ||
        cFetched != 1)
    {
        // no selection?
        return S_OK; // eat the keystroke
    }

    // get the composition range
    if (_pComposition->GetRange(&pRangeComposition) != S_OK)
        goto Exit;

    // adjust the selection, we won't do anything fancy

    if (wParam == VK_LEFT)
    {
        if (tfSelection.range->IsEqualStart(ec, pRangeComposition, TF_ANCHOR_START, &fEqual) == S_OK &&
            !fEqual)
        {
            tfSelection.range->ShiftStart(ec, -1, &cch, NULL);
        }
        tfSelection.range->Collapse(ec, TF_ANCHOR_START);
    }
    else
    {
        // VK_RIGHT
        if (tfSelection.range->IsEqualEnd(ec, pRangeComposition, TF_ANCHOR_END, &fEqual) == S_OK &&
            !fEqual)
        {
            tfSelection.range->ShiftEnd(ec, +1, &cch, NULL);
        }
        tfSelection.range->Collapse(ec, TF_ANCHOR_END);
    }

    pContext->SetSelection(ec, 1, &tfSelection);

    pRangeComposition->Release();

Exit:
    tfSelection.range->Release();
    return S_OK; // eat the keystroke
}

//+---------------------------------------------------------------------------
//
// _HandleKeyDown
//
// If the keystroke happens within a composition, eat the key and return S_OK.
// Otherwise, do nothing and return S_FALSE.
//----------------------------------------------------------------------------

HRESULT CMarkTextService::_HandleKeyDown(TfEditCookie ec, ITfContext *pContext, WPARAM wParam)
{
    ITfRange *pRangeComposition;
    TF_SELECTION tfSelection;
    ULONG cFetched;
    HRESULT hr;
    WCHAR ch;
    BOOL fCovered;

    if (wParam < 'A' || wParam > 'Z')
        return S_OK; // just eat the key if it's not in a range we know how to handle

    hr = S_OK; // return S_FALSE to NOT eat the key

    // convert the wParam to a WCHAR
    if (GetKeyState(VK_SHIFT) & 0x8000)
    {
        // shift-key, leave it uppercase
        ch = (WCHAR)wParam;
    }
    else
    {
        // else make it lowercase
        ch = (WCHAR)(wParam | 32);
    }

    // first, test where a keystroke would go in the document if we did an insert
    if (pContext->GetSelection(ec, TF_DEFAULT_SELECTION, 1, &tfSelection, &cFetched) != S_OK || cFetched != 1)
        return S_FALSE;

    // is the insertion point covered by a composition?
    if (_pComposition->GetRange(&pRangeComposition) == S_OK)
    {
        fCovered = IsRangeCovered(ec, tfSelection.range, pRangeComposition);

        pRangeComposition->Release();

        if (!fCovered)
        {
            hr = S_FALSE; // don't eat the key, it's outside our composition
            goto Exit;
        }
    }

    // insert the text
    // we use SetText here instead of InsertTextAtSelection because we've already started a composition
    // we don't want to the app to adjust the insertion point inside our composition
    if (tfSelection.range->SetText(ec, 0, &ch, 1) != S_OK)
        goto Exit;

    // update the selection, we'll make it an insertion point just past
    // the inserted text.
    tfSelection.range->Collapse(ec, TF_ANCHOR_END);

    pContext->SetSelection(ec, 1, &tfSelection);

    // apply our dislay attribute property to the inserted text
    // we need to apply it to the entire composition, since the
    // display attribute property is static, not static compact
    _SetCompositionDisplayAttributes(ec);

Exit:
    tfSelection.range->Release();
    return hr;
}

//+---------------------------------------------------------------------------
//
// _InitKeystrokeSink
//
// Advise a keystroke sink.
//----------------------------------------------------------------------------

BOOL CMarkTextService::_InitKeystrokeSink()
{
    ITfKeystrokeMgr *pKeystrokeMgr;
    HRESULT hr;

    if (_pThreadMgr->QueryInterface(IID_ITfKeystrokeMgr, (void **)&pKeystrokeMgr) != S_OK)
        return FALSE;

    hr = pKeystrokeMgr->AdviseKeyEventSink(_tfClientId, (ITfKeyEventSink *)this, TRUE);

    pKeystrokeMgr->Release();

    return (hr == S_OK);
}

//+---------------------------------------------------------------------------
//
// _UninitKeystrokeSink
//
// Unadvise a keystroke sink.  Assumes we have advised one already.
//----------------------------------------------------------------------------

void CMarkTextService::_UninitKeystrokeSink()
{
    ITfKeystrokeMgr *pKeystrokeMgr;

    if (_pThreadMgr->QueryInterface(IID_ITfKeystrokeMgr, (void **)&pKeystrokeMgr) != S_OK)
        return;

    pKeystrokeMgr->UnadviseKeyEventSink(_tfClientId);

    pKeystrokeMgr->Release();
}

//+---------------------------------------------------------------------------
//
// OnSetFocus
//
// Called by the system whenever this service gets the keystroke device focus.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::OnSetFocus(BOOL fForeground)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnTestKeyDown
//
// Called by the system to query if this service wants a potential keystroke.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::OnTestKeyDown(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    *pfEaten = (_pComposition != NULL);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnKeyDown
//
// Called by the system to offer this service a keystroke.  If *pfEaten == TRUE
// on exit, the application will not handle the keystroke.
//
// This text service is interested in handling keystrokes to demonstrate the
// use the compositions.  Some apps will cancel compositions if they receive
// keystrokes while a compositions is ongoing.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::OnKeyDown(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    CKeystrokeEditSession *pEditSession;
    HRESULT hr;

    hr = E_FAIL;
    *pfEaten = FALSE;

    if (_pComposition != NULL) // only eat keys while composing
    {
        // we'll insert a char ourselves in place of this keystroke
        if ((pEditSession = new CKeystrokeEditSession(this, pContext, wParam)) == NULL)
            goto Exit;

        // we need a lock to do our work
        // nb: this method is one of the few places where it is legal to use
        // the TF_ES_SYNC flag
        if (pContext->RequestEditSession(_tfClientId, pEditSession, TF_ES_SYNC | TF_ES_READWRITE, &hr) != S_OK)
        {
            hr = E_FAIL;
        }

        pEditSession->Release();
    }

Exit:
    // if we made it all the way to the RequestEditSession, then hr is ultimately the
    // return code from CKeystrokeEditSession::DoEditSession.  Our DoEditSession method
    // return S_OK to signal that the keystroke should be eaten, S_FALSE otherwise.
    if (hr == S_OK)
    {
        *pfEaten = TRUE;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// DoEditSession
//
//----------------------------------------------------------------------------

STDAPI CKeystrokeEditSession::DoEditSession(TfEditCookie ec)
{
    switch (_wParam)
    {
        case VK_LEFT:
        case VK_RIGHT:
            return _pMark->_HandleArrowKey(ec, _pContext, _wParam);

        case VK_RETURN:
            return _pMark->_HandleReturn(ec, _pContext);

        case VK_SPACE:
            return S_OK;
    }

    return _pMark->_HandleKeyDown(ec, _pContext, _wParam);
}

//+---------------------------------------------------------------------------
//
// OnTestKeyUp
//
// Called by the system to query this service wants a potential keystroke.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::OnTestKeyUp(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    *pfEaten = FALSE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnKeyUp
//
// Called by the system to offer this service a keystroke.  If *pfEaten == TRUE
// on exit, the application will not handle the keystroke.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::OnKeyUp(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    *pfEaten = FALSE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnPreservedKey
//
// Called when a hotkey (registered by us, or by the system) is typed.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::OnPreservedKey(ITfContext *pContext, REFGUID rguid, BOOL *pfEaten)
{
    *pfEaten = FALSE;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\mark\globals.h ===
//
// globals.h
//
// Global variable declarations.
//

#ifndef GLOBALS_H
#define GLOBALS_H

#include <windows.h>
#include <ole2.h>
#include <olectl.h>
#include <assert.h>
#include "msctf.h"

LONG DllAddRef();
LONG DllRelease();

BOOL AdviseSink(IUnknown *pSource, IUnknown *pSink, REFIID riid, DWORD *pdwCookie);
void UnadviseSink(IUnknown *pSource, DWORD *pdwCookie);

BOOL AdviseSingleSink(TfClientId tfClientId, IUnknown *pSource, IUnknown *pSink, REFIID riid);
void UnadviseSingleSink(TfClientId tfClientId, IUnknown *pSource, REFIID riid);

BOOL IsRangeCovered(TfEditCookie ec, ITfRange *pRangeTest, ITfRange *pRangeCover);

BOOL IsEqualUnknown(IUnknown *interface1, IUnknown *interface2);

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

#define MARK_LANGID    MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US)

#define MARK_DESC    L"Mark Text Service"
#define MARK_DESC_A   "Mark Text Service"
#define MARK_MODEL   TEXT("Apartment")

#define LANGBAR_ITEM_DESC L"Mark Menu" // max 32 chars!

#define MARK_ICON_INDEX  0

#define SafeRelease(punk)       \
{                               \
    if ((punk) != NULL)         \
    {                           \
        (punk)->Release();      \
    }                           \
}                   

#define SafeReleaseClear(punk)  \
{                               \
    if ((punk) != NULL)         \
    {                           \
        (punk)->Release();      \
        (punk) = NULL;          \
    }                           \
}                   

//+---------------------------------------------------------------------------
//
// SafeStringCopy
//
// Copies a string from one buffer to another.  wcsncpy does not always
// null-terminate the destination buffer; this function does.
//----------------------------------------------------------------------------

inline void SafeStringCopy(WCHAR *pchDst, ULONG cchMax, const WCHAR *pchSrc)
{
    if (cchMax > 0)
    {
        wcsncpy(pchDst, pchSrc, cchMax);
        pchDst[cchMax-1] = '\0';
    }
}

extern HINSTANCE g_hInst;

extern LONG g_cRefDll;

extern CRITICAL_SECTION g_cs;

extern const CLSID c_clsidMarkTextService;
extern const GUID c_guidMarkProfile;
extern const GUID c_guidLangBarItemButton;
extern const GUID c_guidMarkDisplayAttribute;
extern const GUID c_guidMarkContextCompartment;
extern const GUID c_guidMarkGlobalCompartment;
extern const GUID c_guidCaseProperty;
extern const GUID c_guidCustomProperty;

#endif // GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\mark\langbar.cpp ===
//
// langbar.cpp
//
// Language bar ui code.
//

#include "globals.h"
#include "mark.h"
#include "resource.h"

#define MARK_LANGBARITEMSINK_COOKIE 0x0fab0fab

const struct
{
    const WCHAR *pchDesc;
    void (*pfnHandler)(CMarkTextService *_this);
}
c_rgMenuItems[] =
{
    { L"Start/End Composition", CMarkTextService::_Menu_OnComposition },
    { L"Set Global Compartment", CMarkTextService::_Menu_OnSetGlobalCompartment },
    { L"Set Case Property", CMarkTextService::_Menu_OnSetCaseProperty },
    { L"Set Custom Property", CMarkTextService::_Menu_OnSetCustomProperty },
    { L"View Case Property", CMarkTextService::_Menu_OnViewCaseProperty },
    { L"View Custom Property", CMarkTextService::_Menu_OnViewCustomProperty },
};

class CLangBarItemButton : public ITfLangBarItemButton,
                           public ITfSource
{
public:
    CLangBarItemButton(CMarkTextService *pMark);
    ~CLangBarItemButton();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ITfLangBarItem
    STDMETHODIMP GetInfo(TF_LANGBARITEMINFO *pInfo);
    STDMETHODIMP GetStatus(DWORD *pdwStatus);
    STDMETHODIMP Show(BOOL fShow);
    STDMETHODIMP GetTooltipString(BSTR *pbstrToolTip);

    // ITfLangBarItemButton
    STDMETHODIMP OnClick(TfLBIClick click, POINT pt, const RECT *prcArea);
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);
    STDMETHODIMP GetIcon(HICON *phIcon);
    STDMETHODIMP GetText(BSTR *pbstrText);

    // ITfSource
    STDMETHODIMP AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie);
    STDMETHODIMP UnadviseSink(DWORD dwCookie);

private:
    CMarkTextService *_pMark;
    ITfLangBarItemSink *_pLangBarItemSink;
    TF_LANGBARITEMINFO _tfLangBarItemInfo;
    LONG _cRef;
};

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLangBarItemButton::CLangBarItemButton(CMarkTextService *pMark)
{
    DllAddRef();

    _tfLangBarItemInfo.clsidService = c_clsidMarkTextService;
    _tfLangBarItemInfo.guidItem = c_guidLangBarItemButton;
    _tfLangBarItemInfo.dwStyle = TF_LBI_STYLE_BTN_MENU;
    _tfLangBarItemInfo.ulSort = 0;
    SafeStringCopy(_tfLangBarItemInfo.szDescription, ARRAYSIZE(_tfLangBarItemInfo.szDescription), LANGBAR_ITEM_DESC);

    _pMark = pMark;
    _pMark->AddRef();
    _pLangBarItemSink = NULL;

    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLangBarItemButton::~CLangBarItemButton()
{
    DllRelease();
    _pMark->Release();
}

//+---------------------------------------------------------------------------
//
// QueryInterface
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfLangBarItem) ||
        IsEqualIID(riid, IID_ITfLangBarItemButton))
    {
        *ppvObj = (ITfLangBarItemButton *)this;
    }
    else if (IsEqualIID(riid, IID_ITfSource))
    {
        *ppvObj = (ITfSource *)this;
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//+---------------------------------------------------------------------------
//
// AddRef
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CLangBarItemButton::AddRef()
{
    return ++_cRef;
}

//+---------------------------------------------------------------------------
//
// Release
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CLangBarItemButton::Release()
{
    LONG cr = --_cRef;

    assert(_cRef >= 0);

    if (_cRef == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// GetInfo
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::GetInfo(TF_LANGBARITEMINFO *pInfo)
{
    *pInfo = _tfLangBarItemInfo;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetStatus
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::GetStatus(DWORD *pdwStatus)
{
    *pdwStatus = 0;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Show
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::Show(BOOL fShow)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// GetTooltipString
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::GetTooltipString(BSTR *pbstrToolTip)
{
    *pbstrToolTip = SysAllocString(LANGBAR_ITEM_DESC);

    return (*pbstrToolTip == NULL) ? E_OUTOFMEMORY : S_OK;
}

//+---------------------------------------------------------------------------
//
// OnClick
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::OnClick(TfLBIClick click, POINT pt, const RECT *prcArea)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// InitMenu
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::InitMenu(ITfMenu *pMenu)
{
    int i;

    for (i=0; i<ARRAYSIZE(c_rgMenuItems); i++)
    {
        pMenu->AddMenuItem(i, 0, NULL, NULL, c_rgMenuItems[i].pchDesc, wcslen(c_rgMenuItems[i].pchDesc), NULL);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnMenuSelect
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::OnMenuSelect(UINT wID)
{
    c_rgMenuItems[wID].pfnHandler(_pMark);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::GetIcon(HICON *phIcon)
{
    *phIcon = (HICON)LoadImage(g_hInst, TEXT("IDI_MARK"), IMAGE_ICON, 16, 16, 0);

    return (*phIcon != NULL) ? S_OK : E_FAIL;
}

//+---------------------------------------------------------------------------
//
// GetText
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::GetText(BSTR *pbstrText)
{
    *pbstrText = SysAllocString(LANGBAR_ITEM_DESC);

    return (*pbstrText == NULL) ? E_OUTOFMEMORY : S_OK;
}

//+---------------------------------------------------------------------------
//
// AdviseSink
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie)
{
    if (!IsEqualIID(IID_ITfLangBarItemSink, riid))
        return CONNECT_E_CANNOTCONNECT;

    if (_pLangBarItemSink != NULL)
        return CONNECT_E_ADVISELIMIT;

    if (punk->QueryInterface(IID_ITfLangBarItemSink, (void **)&_pLangBarItemSink) != S_OK)
    {
        _pLangBarItemSink = NULL;
        return E_NOINTERFACE;
    }

    *pdwCookie = MARK_LANGBARITEMSINK_COOKIE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// UnadviseSink
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::UnadviseSink(DWORD dwCookie)
{
    if (dwCookie != MARK_LANGBARITEMSINK_COOKIE)
        return CONNECT_E_NOCONNECTION;

    if (_pLangBarItemSink == NULL)
        return CONNECT_E_NOCONNECTION;

    _pLangBarItemSink->Release();
    _pLangBarItemSink = NULL;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _InitLanguageBar
//
//----------------------------------------------------------------------------

BOOL CMarkTextService::_InitLanguageBar()
{
    ITfLangBarItemMgr *pLangBarItemMgr;
    BOOL fRet;

    if (_pThreadMgr->QueryInterface(IID_ITfLangBarItemMgr, (void **)&pLangBarItemMgr) != S_OK)
        return FALSE;

    fRet = FALSE;

    if ((_pLangBarItem = new CLangBarItemButton(this)) == NULL)
        goto Exit;

    if (pLangBarItemMgr->AddItem(_pLangBarItem) != S_OK)
    {
        _pLangBarItem->Release();
        _pLangBarItem = NULL;
        goto Exit;
    }

    fRet = TRUE;

Exit:
    pLangBarItemMgr->Release();
    return fRet;
}

//+---------------------------------------------------------------------------
//
// _UninitLanguageBar
//
//----------------------------------------------------------------------------

void CMarkTextService::_UninitLanguageBar()
{
    ITfLangBarItemMgr *pLangBarItemMgr;

    if (_pLangBarItem == NULL)
        return;

    if (_pThreadMgr->QueryInterface(IID_ITfLangBarItemMgr, (void **)&pLangBarItemMgr) == S_OK)
    {
        pLangBarItemMgr->RemoveItem(_pLangBarItem);
        pLangBarItemMgr->Release();
    }

    _pLangBarItem->Release();
    _pLangBarItem = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\mark\mark.cpp ===
//
// mark.cpp
//
// IUnknown, ITfTextInputProcessor implementation.
//

#include "globals.h"
#include "mark.h"

//+---------------------------------------------------------------------------
//
// CreateInstance
//
//----------------------------------------------------------------------------

/* static */
HRESULT CMarkTextService::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    CMarkTextService *pMark;
    HRESULT hr;

    if (ppvObj == NULL)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (NULL != pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    if ((pMark = new CMarkTextService) == NULL)
        return E_OUTOFMEMORY;

    hr = pMark->QueryInterface(riid, ppvObj);

    pMark->Release(); // caller still holds ref if hr == S_OK

    return hr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CMarkTextService::CMarkTextService()
{
    DllAddRef();

    _pThreadMgr = NULL;
    _tfClientId = TF_CLIENTID_NULL;

    _pComposition = NULL;

    _fCleaningUp = FALSE;

    _gaDisplayAttribute = TF_INVALID_GUIDATOM;

    _pLangBarItem = NULL;

    _dwThreadMgrEventSinkCookie = TF_INVALID_COOKIE;
    _dwThreadFocusSinkCookie = TF_INVALID_COOKIE;
    _dwTextEditSinkCookie = TF_INVALID_COOKIE;
    _dwGlobalCompartmentEventSinkCookie = TF_INVALID_COOKIE;

    _pTextEditSinkContext = NULL;

    _hWorkerWnd = NULL;

    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CMarkTextService::~CMarkTextService()
{
    DllRelease();
}

//+---------------------------------------------------------------------------
//
// QueryInterface
//
//----------------------------------------------------------------------------

STDAPI CMarkTextService::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfTextInputProcessor))
    {
        *ppvObj = (ITfTextInputProcessor *)this;
    }
    else if (IsEqualIID(riid, IID_ITfDisplayAttributeProvider))
    {
        *ppvObj = (ITfDisplayAttributeProvider *)this;
    }
    else if (IsEqualIID(riid, IID_ITfCreatePropertyStore))
    {
        *ppvObj = (ITfCreatePropertyStore *)this;
    }
    else if (IsEqualIID(riid, IID_ITfThreadMgrEventSink))
    {
        *ppvObj = (ITfThreadMgrEventSink *)this;
    }
    else if (IsEqualIID(riid, IID_ITfTextEditSink))
    {
        *ppvObj = (ITfTextEditSink *)this;
    }
    else if (IsEqualIID(riid, IID_ITfCleanupContextSink))
    {
        *ppvObj = (ITfCleanupContextSink *)this;
    }
    else if (IsEqualIID(riid, IID_ITfCleanupContextDurationSink))
    {
        *ppvObj = (ITfCleanupContextDurationSink *)this;
    }
    else if (IsEqualIID(riid, IID_ITfCompartmentEventSink))
    {
        *ppvObj = (ITfCompartmentEventSink *)this;
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//+---------------------------------------------------------------------------
//
// AddRef
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CMarkTextService::AddRef()
{
    return ++_cRef;
}

//+---------------------------------------------------------------------------
//
// Release
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CMarkTextService::Release()
{
    LONG cr = --_cRef;

    assert(_cRef >= 0);

    if (_cRef == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// Activate
//
//----------------------------------------------------------------------------

STDAPI CMarkTextService::Activate(ITfThreadMgr *pThreadMgr, TfClientId tfClientId)
{
    _pThreadMgr = pThreadMgr;
    _pThreadMgr->AddRef();

    _tfClientId = tfClientId;

    if (!_InitLanguageBar())
        goto ExitError;

    if (!_InitThreadMgrSink())
        goto ExitError;

    if (!_InitDisplayAttributeGuidAtom())
        goto ExitError;

    if (!_InitCleanupContextDurationSink())
        goto ExitError;

    if (!_InitGlobalCompartment())
        goto ExitError;

    if (!_InitWorkerWnd())
        goto ExitError;

    if (!_InitKeystrokeSink())
        goto ExitError;

    return S_OK;

ExitError:
    Deactivate(); // cleanup any half-finished init
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
// Deactivate
//
//----------------------------------------------------------------------------

STDAPI CMarkTextService::Deactivate()
{
    _UninitThreadMgrSink();
    _UninitLanguageBar();
    _UninitCleanupContextDurationSink();
    _UninitGlobalCompartment();
    _UninitWorkerWnd();
    _UninitKeystrokeSink();
    _InitTextEditSink(NULL);

    // we MUST release all refs to _pThreadMgr in Deactivate
    SafeReleaseClear(_pThreadMgr);

    _tfClientId = TF_CLIENTID_NULL;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\mark\mark.h ===
//
// mark.h
//
// CMarkTextService declaration.
//

#ifndef MARK_H
#define MARK_H

class CLangBarItemButton;

class CMarkTextService : public ITfTextInputProcessor,
                         public ITfDisplayAttributeProvider,
                         public ITfCreatePropertyStore,
                         public ITfThreadMgrEventSink,
                         public ITfTextEditSink,
                         public ITfCompositionSink,
                         public ITfCleanupContextDurationSink,
                         public ITfCleanupContextSink,
                         public ITfCompartmentEventSink,
                         public ITfKeyEventSink
{
public:
    CMarkTextService();
    ~CMarkTextService();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ITfTextInputProcessor
    STDMETHODIMP Activate(ITfThreadMgr *pThreadMgr, TfClientId tfClientId);
    STDMETHODIMP Deactivate();

    // ITfDisplayAttributeProvider
    STDMETHODIMP EnumDisplayAttributeInfo(IEnumTfDisplayAttributeInfo **ppEnum);
    STDMETHODIMP GetDisplayAttributeInfo(REFGUID guidInfo, ITfDisplayAttributeInfo **ppInfo);

    // ITfCreatePropertyStore
    STDMETHODIMP IsStoreSerializable(REFGUID guidProperty, ITfRange *pRange, ITfPropertyStore *pPropertyStore, BOOL *pfSerializable);
    STDMETHODIMP CreatePropertyStore(REFGUID guidProperty, ITfRange *pRange, ULONG cb, IStream *pStream, ITfPropertyStore **ppStore);

    // ITfThreadMgrEventSink
    STDMETHODIMP OnInitDocumentMgr(ITfDocumentMgr *pDocMgr);
    STDMETHODIMP OnUninitDocumentMgr(ITfDocumentMgr *pDocMgr);
    STDMETHODIMP OnSetFocus(ITfDocumentMgr *pDocMgrFocus, ITfDocumentMgr *pDocMgrPrevFocus);
    STDMETHODIMP OnPushContext(ITfContext *pContext);
    STDMETHODIMP OnPopContext(ITfContext *pContext);

    // ITfTextEditSink
    STDMETHODIMP OnEndEdit(ITfContext *pContext, TfEditCookie ecReadOnly, ITfEditRecord *pEditRecord);

    // ITfCompositionSink
    STDMETHODIMP OnCompositionTerminated(TfEditCookie ecWrite, ITfComposition *pComposition);

    // ITfCleanupContextDurationSink
    STDMETHODIMP OnStartCleanupContext();
    STDMETHODIMP OnEndCleanupContext();

    // ITfCleanupContextSink
    STDMETHODIMP OnCleanupContext(TfEditCookie ecWrite, ITfContext *pContext);

    // ITfCompartmentEventSink
    STDMETHODIMP OnChange(REFGUID rguidCompartment);

    // ITfKeyEventSink
    STDMETHODIMP OnSetFocus(BOOL fForeground);
    STDMETHODIMP OnTestKeyDown(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP OnKeyDown(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP OnTestKeyUp(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP OnKeyUp(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP OnPreservedKey(ITfContext *pContext, REFGUID rguid, BOOL *pfEaten);

    // CClassFactory factory callback
    static HRESULT CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);

    // server registration
    static BOOL RegisterProfiles();
    static void UnregisterProfiles();
    static BOOL RegisterCategories(BOOL fRegister);
    static BOOL RegisterServer();
    static void UnregisterServer();

    // language bar menu handlers
    static void _Menu_OnComposition(CMarkTextService *_this);
    static void _Menu_OnSetGlobalCompartment(CMarkTextService *_this);
    static void _Menu_OnSetCaseProperty(CMarkTextService *_this);
    static void _Menu_OnViewCaseProperty(CMarkTextService *_this);
    static void _Menu_OnViewCustomProperty(CMarkTextService *_this);
    static void _Menu_OnSetCustomProperty(CMarkTextService *_this);

    // keystroke handlers
    HRESULT _HandleKeyDown(TfEditCookie ec, ITfContext *pContext, WPARAM wParam);
    HRESULT _HandleArrowKey(TfEditCookie ec, ITfContext *pContext, WPARAM wParam);
    HRESULT _HandleReturn(TfEditCookie ec, ITfContext *pContext);

    // callbacks for CCompositionEditSession
    BOOL _IsComposing()
    {
        return _pComposition != NULL;
    }
    ITfComposition *_GetComposition()
    {
        return _pComposition;
    }
    void _SetComposition(ITfComposition *pComposition)
    {
        _pComposition = pComposition;
    }
    void _TerminateComposition(TfEditCookie ec)
    {
        if (_pComposition != NULL)
        {
            _ClearCompositionDisplayAttributes(ec);
            _pComposition->EndComposition(ec);
            SafeReleaseClear(_pComposition);
        }
    }
    void _TerminateCompositionInContext(ITfContext *pContext);
    void _ClearCompositionDisplayAttributes(TfEditCookie ec);
    BOOL _SetCompositionDisplayAttributes(TfEditCookie ec);

    // messages for the worker wnd
    enum { WM_DISPLAY_PROPERTY = WM_USER + 1 };
    // property methods
    void _ViewCaseProperty(TfEditCookie ec, ITfContext *pContext);
    void _SetCaseProperty(TfEditCookie ec, ITfContext *pContext);
    void _ViewCustomProperty(TfEditCookie ec, ITfContext *pContext);
    void _SetCustomProperty(TfEditCookie ec, ITfContext *pContext);

private:
    // init methods
    BOOL _InitLanguageBar();
    BOOL _InitThreadMgrSink();
    BOOL _InitTextEditSink(ITfDocumentMgr *pDocMgr);
    BOOL _InitDisplayAttributeGuidAtom();
    BOOL _InitCleanupContextDurationSink();
    BOOL _InitCleanupContextSink(ITfContext *pContext);
    BOOL _InitContextCompartment(ITfContext *pContext);
    BOOL _InitGlobalCompartment();
    BOOL _InitWorkerWnd();
    BOOL _InitKeystrokeSink();

    // uninit methods
    void _UninitLanguageBar();
    void _UninitThreadMgrSink();
    void _UninitCleanupContextDurationSink();
    void _UninitCleanupContextSink(ITfContext *pContext);
    void _UninitCompartment(ITfContext *pContext);
    void _UninitGlobalCompartment();
    void _UninitWorkerWnd();
    void _UninitKeystrokeSink();

    // property methods
    void _RequestPropertyEditSession(ULONG ulCallback);
    static LRESULT CALLBACK _WorkerWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    //
    // state
    //

    ITfThreadMgr *_pThreadMgr;
    TfClientId _tfClientId;
    
    ITfComposition *_pComposition; // pointer to an ongoing composition, or NULL if there is none

    BOOL _fCleaningUp;

    TfGuidAtom _gaDisplayAttribute;

    CLangBarItemButton *_pLangBarItem;

    DWORD _dwThreadMgrEventSinkCookie;
    DWORD _dwThreadFocusSinkCookie;
    DWORD _dwTextEditSinkCookie;
    DWORD _dwGlobalCompartmentEventSinkCookie;

    ITfContext *_pTextEditSinkContext;

    HWND _hWorkerWnd;
    // buffers for the popup property displays
    WCHAR _achDisplayText[64];
    WCHAR _achDisplayPropertyText[64];

    LONG _cRef;     // COM ref count
};


#endif // MARK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\mark\property.cpp ===
//
// property.cpp
//
// Property code.
//

#include "globals.h"
#include "mark.h"
#include "editsess.h"
#include "pstore.h"

// callback code for CPropertyEditSession
#define VIEW_CASE_PROPERTY   0
#define SET_CASE_PROPERTY    1
#define VIEW_CUSTOM_PROPERTY 2
#define SET_CUSTOM_PROPERTY  3

const TCHAR c_szWorkerWndClass[] = TEXT("Mark Worker Wnd Class");

class CPropertyEditSession : public CEditSessionBase
{
public:
    CPropertyEditSession(CMarkTextService *pMark, ITfContext *pContext, ULONG ulCallback) : CEditSessionBase(pContext)
    {
        _pMark = pMark;
        _pMark->AddRef();
        _ulCallback = ulCallback;
    }
    ~CPropertyEditSession()
    {
        _pMark->Release();
    }

    // ITfEditSession
    STDMETHODIMP DoEditSession(TfEditCookie ec)
    {
        switch (_ulCallback)
        {
            case VIEW_CASE_PROPERTY:
                _pMark->_ViewCaseProperty(ec, _pContext);
                break;
            case SET_CASE_PROPERTY:
                _pMark->_SetCaseProperty(ec, _pContext);
                break;
            case VIEW_CUSTOM_PROPERTY:
                _pMark->_ViewCustomProperty(ec, _pContext);
                break;
            case SET_CUSTOM_PROPERTY:
                _pMark->_SetCustomProperty(ec, _pContext);
                break;
        }
        return S_OK;
    }

private:
    CMarkTextService *_pMark;
    ULONG _ulCallback;
};

//+---------------------------------------------------------------------------
//
// _RequestEditSession
//
// Helper function.  Schedules an edit session for a particular property
// related callback.
//----------------------------------------------------------------------------

void CMarkTextService::_RequestPropertyEditSession(ULONG ulCallback)
{
    ITfDocumentMgr *pFocusDoc;
    ITfContext *pContext;
    CPropertyEditSession *pPropertyEditSession;
    HRESULT hr;

    // get the focus document
    if (_pThreadMgr->GetFocus(&pFocusDoc) != S_OK)
        return;

    if (pFocusDoc == NULL)
        return; // no focus

    // we want the topmost context, since the main doc context could be
    // superceded by a modal tip context
    if (pFocusDoc->GetTop(&pContext) != S_OK)
    {
        pContext = NULL;
        goto Exit;
    }

    if (pPropertyEditSession = new CPropertyEditSession(this, pContext, ulCallback))
    {
        // we need a document write lock
        // the CPropertyEditSession will do all the work when the
        // CPropertyEditSession::DoEditSession method is called by the context
        pContext->RequestEditSession(_tfClientId, pPropertyEditSession, TF_ES_READWRITE | TF_ES_ASYNCDONTCARE, &hr);

        pPropertyEditSession->Release();
    }

Exit:
    SafeRelease(pContext);
    pFocusDoc->Release();
}

//+---------------------------------------------------------------------------
//
// _SetCaseProperty
//
//----------------------------------------------------------------------------

void CMarkTextService::_SetCaseProperty(TfEditCookie ec, ITfContext *pContext)
{
    TF_SELECTION tfSelection;
    ITfProperty *pCaseProperty;
    ITfRange *pRangeChar;
    WCHAR ch;
    ULONG cchRead;
    ULONG cFetched;
    VARIANT varValue;

    // get the case property
    if (pContext->GetProperty(c_guidCaseProperty, &pCaseProperty) != S_OK)
        return;

    // get the selection
    if (pContext->GetSelection(ec, TF_DEFAULT_SELECTION, 1, &tfSelection, &cFetched) != S_OK ||
        cFetched != 1)
    {
        // no selection or something went wrong
        tfSelection.range = NULL;
        goto Exit;
    }

    // get a helper range ready for the loop
    if (tfSelection.range->Clone(&pRangeChar) != S_OK)
        goto Exit;

    // set the value char-by-char over the selection
    while (TRUE)
    {
        // read one char, the TF_TF_MOVESTART flag will advance the start anchor
        if (tfSelection.range->GetText(ec, TF_TF_MOVESTART, &ch, 1, &cchRead) != S_OK)
            break;

        // any more text to read?
        if (cchRead != 1)
            break;

        // make pRange cover just the one char we read
        if (pRangeChar->ShiftEndToRange(ec, tfSelection.range, TF_ANCHOR_START) != S_OK)
            break;

        // set the value
        varValue.vt = VT_I4;
        varValue.lVal = (ch >= 'A' && ch <= 'Z');

        if (pCaseProperty->SetValue(ec, pRangeChar, &varValue) != S_OK)
            break;

        // advance pRange for next iteration
        if (pRangeChar->Collapse(ec, TF_ANCHOR_END) != S_OK)
            break;
    }
    
    pRangeChar->Release();

Exit:
    SafeRelease(tfSelection.range);
    pCaseProperty->Release();
}

//+---------------------------------------------------------------------------
//
// _Menu_OnSetCaseProperty
//
// Callback for the "Set Case Property" menu item.
// Set the value for a private "case" property over the text covered by the
// selection.  The case property is private to this text service, which defines
// it as:
//
//      static compact, per character
//      VT_I4, !0 => character is within 'A' - 'Z', 0 => anything else.
//      
//----------------------------------------------------------------------------

/* static */
void CMarkTextService::_Menu_OnSetCaseProperty(CMarkTextService *_this)
{
    _this->_RequestPropertyEditSession(SET_CASE_PROPERTY);
}

//+---------------------------------------------------------------------------
//
// _ViewCaseProperty
//
//----------------------------------------------------------------------------

void CMarkTextService::_ViewCaseProperty(TfEditCookie ec, ITfContext *pContext)
{
    TF_SELECTION tfSelection;
    ITfProperty *pCaseProperty;
    ULONG cchRead;
    LONG cch;
    ULONG cFetched;
    ULONG i;
    VARIANT varValue;

    // get the case property
    if (pContext->GetProperty(c_guidCaseProperty, &pCaseProperty) != S_OK)
        return;

    // get the selection
    if (pContext->GetSelection(ec, TF_DEFAULT_SELECTION, 1, &tfSelection, &cFetched) != S_OK ||
        cFetched != 1)
    {
        // no selection or something went wrong
        tfSelection.range = NULL;
        goto Exit;
    }

    // grab the text
    if (tfSelection.range->GetText(ec, 0, _achDisplayText, ARRAYSIZE(_achDisplayText)-1, &cchRead) != S_OK)
        goto Exit;

    // prepare for the loop
    if (tfSelection.range->Collapse(ec, TF_ANCHOR_START) != S_OK)
        goto Exit;

    // get the property value char-by-char over the selection
    for (i=0; i < cchRead; i++)
    {
        // advance pRange for next iteration, cover the next char
        if (tfSelection.range->ShiftStartToRange(ec, tfSelection.range, TF_ANCHOR_END) != S_OK)
            break;
        if (tfSelection.range->ShiftEnd(ec, 1, &cch, NULL) != S_OK)
            break;
        if (cch != 1) // hit a region boundary?
            break;

        switch (pCaseProperty->GetValue(ec, tfSelection.range, &varValue))
        {
            case S_OK:
                // the property value has been set, use it
                // 'U' --> uppercase
                // 'L' --> lowercase
                _achDisplayPropertyText[i] = varValue.lVal ? 'U' : 'L';
                break;
            case S_FALSE:
                // no property value set, varValue.vt == VT_EMPTY
                // '?' --> no value
                _achDisplayPropertyText[i] = '?';
                break;
            default:
                // error
                // '!' --> error
                _achDisplayPropertyText[i] = '!';
                break;
        }
    }
    for (; i<cchRead; i++) // error case
    {
        _achDisplayPropertyText[i] = '!';
    }

    _achDisplayPropertyText[cchRead] = '\0';
    _achDisplayText[cchRead] = '\0';

    // we can't change the focus while holding a lock
    // so postpone the UI until we've released our lock
    PostMessage(_hWorkerWnd, CMarkTextService::WM_DISPLAY_PROPERTY, 0, 0);

Exit:
    SafeRelease(tfSelection.range);
    pCaseProperty->Release();
}

//+---------------------------------------------------------------------------
//
// _Menu_OnViewCaseProperty
//
// Menu callback.  Displays a popup with "case" property values over the
// current selection.
//----------------------------------------------------------------------------

/* static */
void CMarkTextService::_Menu_OnViewCaseProperty(CMarkTextService *_this)
{
    _this->_RequestPropertyEditSession(VIEW_CASE_PROPERTY);
}

//+---------------------------------------------------------------------------
//
// _ViewCustomProperty
//
// Display the value of this text service's custom property over the text
// covered by the selection.
//----------------------------------------------------------------------------

void CMarkTextService::_ViewCustomProperty(TfEditCookie ec, ITfContext *pContext)
{
    TF_SELECTION tfSelection;
    ITfProperty *pCustomProperty;
    ITfRange *pSelRange;
    ITfRange *pPropertySpanRange;
    ULONG cchRead;
    ULONG cFetched;
    LONG cch;
    VARIANT varValue;
    HRESULT hr;

    // get the case property
    if (pContext->GetProperty(c_guidCustomProperty, &pCustomProperty) != S_OK)
        return;

    // get the selection
    if (pContext->GetSelection(ec, TF_DEFAULT_SELECTION, 1, &tfSelection, &cFetched) != S_OK ||
        cFetched != 1)
    {
        // no selection or something went wrong
        pSelRange = NULL;
        goto Exit;
    }
    // free up tfSelection so we can re-use it below
    pSelRange = tfSelection.range;

    // the selection may not exactly match a span of text covered by the
    // custom property....so we'll return the value over the start anchor of
    // the selection.

    // we need to collapse the range because GetValue will return VT_EMPTY
    // if the query range is not completely covered by the property span
    if (pSelRange->Collapse(ec, TF_ANCHOR_START) != S_OK)
        goto Exit;
    // the query range must also cover at least one char
    if (pSelRange->ShiftEnd(ec, 1, &cch, NULL) != S_OK)
        goto Exit;

    hr = pCustomProperty->GetValue(ec, pSelRange, &varValue);

    switch (hr)
    {
        case S_OK:
            // there's a value at the selection start anchor
            // let's find out exactly what text is covered
            _achDisplayText[0] = '\0';
            if (pCustomProperty->FindRange(ec, pSelRange, &pPropertySpanRange, TF_ANCHOR_START) == S_OK)
            {
                if (pPropertySpanRange->GetText(ec, 0, _achDisplayText, ARRAYSIZE(_achDisplayText)-1, &cchRead) != S_OK)
                {
                    cchRead = 0;
                }
                _achDisplayText[cchRead] = '\0';
                // let's update the selection to give the user feedback
                tfSelection.range = pPropertySpanRange;
                pContext->SetSelection(ec, 1, &tfSelection);
                pPropertySpanRange->Release();
            }
            // write the value
            wsprintfW(_achDisplayPropertyText, L"%i", varValue.lVal);
            break;

        case S_FALSE:
            // the property has no value, varValue.vt == VT_EMPTY
            _achDisplayText[0] = '\0';
            SafeStringCopy(_achDisplayPropertyText, ARRAYSIZE(_achDisplayPropertyText), L"- No Value -");
            break;
        default:
            goto Exit; // error
    }

    // we can't change the focus while holding a lock
    // so postpone the UI until we've released our lock
    PostMessage(_hWorkerWnd, CMarkTextService::WM_DISPLAY_PROPERTY, 0, 0);

Exit:
    SafeRelease(pSelRange);
    pCustomProperty->Release();
}

//+---------------------------------------------------------------------------
//
// _Menu_OnViewCustomProperty
//
// Menu callback for "View Custom Property".
//----------------------------------------------------------------------------

/* static */
void CMarkTextService::_Menu_OnViewCustomProperty(CMarkTextService *_this)
{
    _this->_RequestPropertyEditSession(VIEW_CUSTOM_PROPERTY);
}

//+---------------------------------------------------------------------------
//
// _InitWorkerWnd
//
// Called from Activate.  Create a worker window to receive private windows
// messages.
//----------------------------------------------------------------------------

BOOL CMarkTextService::_InitWorkerWnd()
{
    WNDCLASS wc;

    memset(&wc, 0, sizeof(wc));
    wc.lpfnWndProc = _WorkerWndProc;
    wc.hInstance = g_hInst;
    wc.lpszClassName = c_szWorkerWndClass;

    if (RegisterClass(&wc) == 0)
        return FALSE;

    _hWorkerWnd = CreateWindow(c_szWorkerWndClass, TEXT("Mark Worker Wnd"),
                               0, 0, 0, 0, 0, NULL, NULL, g_hInst, this);

    return (_hWorkerWnd != NULL);
}

//+---------------------------------------------------------------------------
//
// _UninitWorkerWnd
//
// Called from Deactivate.  Destroy the worker window.
//----------------------------------------------------------------------------

void CMarkTextService::_UninitWorkerWnd()
{
    if (_hWorkerWnd != NULL)
    {
        DestroyWindow(_hWorkerWnd);
        _hWorkerWnd = NULL;
    }
    UnregisterClass(c_szWorkerWndClass, g_hInst);
}

//+---------------------------------------------------------------------------
//
// _WorkerWndProc
//
//----------------------------------------------------------------------------

/* static */
LRESULT CALLBACK CMarkTextService::_WorkerWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CMarkTextService *_this;
    int cch;
    char achText[128];

    switch (uMsg)
    {
        case WM_CREATE:
            // save the this pointer we originally passed into CreateWindow
            SetWindowLongPtr(hWnd, GWLP_USERDATA, 
                             (LONG_PTR)((CREATESTRUCT *)lParam)->lpCreateParams);
            return 0;

        case WM_DISPLAY_PROPERTY:
            _this = (CMarkTextService *)GetWindowLongPtr(hWnd, GWLP_USERDATA);

            // bring up a message box with the contents of _achDisplayText
            
            // first, convert from unicode
            cch = WideCharToMultiByte(CP_ACP, 0, _this->_achDisplayText, wcslen(_this->_achDisplayText),
                                      achText, ARRAYSIZE(achText)-1, NULL, NULL);

            if (cch < ARRAYSIZE(achText) - 1)
            {
                achText[cch++] = '\n';
            }
            if (cch < ARRAYSIZE(achText) - 1)
            {
                cch += WideCharToMultiByte(CP_ACP, 0, _this->_achDisplayPropertyText, wcslen(_this->_achDisplayPropertyText),
                                           achText+cch, ARRAYSIZE(achText)-cch-1, NULL, NULL);
            }
            achText[cch] = '\0';

            // bring up the display
            MessageBoxA(NULL, achText, "Property View", MB_OK);

            return 0;
    }

    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

//+---------------------------------------------------------------------------
//
// _Menu_OnSetCustomProperty
//
// Callback for the "Set Custom Property" menu item.
//----------------------------------------------------------------------------

/* static */
void CMarkTextService::_Menu_OnSetCustomProperty(CMarkTextService *_this)
{
    _this->_RequestPropertyEditSession(SET_CUSTOM_PROPERTY);
}

//+---------------------------------------------------------------------------
//
// _SetCustomProperty
//
// Assign a custom property to the text covered by the selection.
//----------------------------------------------------------------------------

void CMarkTextService::_SetCustomProperty(TfEditCookie ec, ITfContext *pContext)
{
    TF_SELECTION tfSelection;
    ITfProperty *pCustomProperty;
    CCustomPropertyStore *pCustomPropertyStore;
    ULONG cFetched;

    // get the case property
    if (pContext->GetProperty(c_guidCustomProperty, &pCustomProperty) != S_OK)
        return;

    // get the selection
    if (pContext->GetSelection(ec, TF_DEFAULT_SELECTION, 1, &tfSelection, &cFetched) != S_OK ||
        cFetched != 1)
    {
        // no selection or something went wrong
        tfSelection.range = NULL;
        goto Exit;
    }

    if ((pCustomPropertyStore = new CCustomPropertyStore) == NULL)
        goto Exit;

    pCustomProperty->SetValueStore(ec, tfSelection.range, pCustomPropertyStore);

    // TSF will hold a reference to pCustomPropertyStore is the SetValueStore succeeded
    // but we need to release ours
    pCustomPropertyStore->Release();

Exit:
    pCustomProperty->Release();
    SafeRelease(tfSelection.range);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\mark\pstore.cpp ===
//
// pstore.cpp
//
// CCustomPropertyStore implementation, ITfPropertyStore example.
//

#include "globals.h"
#include "pstore.h"
#include "mark.h"

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CCustomPropertyStore::CCustomPropertyStore()
{
    // assign some arbitrary state to this object, for demonstration purposes
    _dwState = GetTickCount();

    DllAddRef();
    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CCustomPropertyStore::~CCustomPropertyStore()
{
    DllRelease();
}

//+---------------------------------------------------------------------------
//
// QueryInterface
//
//----------------------------------------------------------------------------

STDAPI CCustomPropertyStore::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfPropertyStore))
    {
        *ppvObj = (ITfPropertyStore *)this;
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//+---------------------------------------------------------------------------
//
// AddRef
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CCustomPropertyStore::AddRef()
{
    return ++_cRef;
}

//+---------------------------------------------------------------------------
//
// Release
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CCustomPropertyStore::Release()
{
    LONG cr = --_cRef;

    assert(_cRef >= 0);

    if (_cRef == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// GetType
//
// Returns the GUID of the property this store is assigned to.
//----------------------------------------------------------------------------

STDAPI CCustomPropertyStore::GetType(GUID *pguidType)
{
    *pguidType = c_guidCustomProperty;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetDataType
//
//----------------------------------------------------------------------------

STDAPI CCustomPropertyStore::GetDataType(DWORD *pdwReserved)
{
    // this method is reserved, pdwReserved must be set 0
    *pdwReserved = 0;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetData
//
// Returns the data held by this store.
//----------------------------------------------------------------------------

STDAPI CCustomPropertyStore::GetData(VARIANT *pvarValue)
{
    pvarValue->vt = VT_I4; // dword value for this store
    pvarValue->lVal = _dwState;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnTextUpdated
//
// Called by TSF when the text covered by this store is modified.
//----------------------------------------------------------------------------

STDAPI CCustomPropertyStore::OnTextUpdated(DWORD dwFlags, ITfRange *pRangeNew, BOOL *pfAccept)
{
    // we will throw away this store (give up) anytime the text is modified.
    // If we did set pfAccept TRUE, the store would be maintained.
    *pfAccept = FALSE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Shrink
//
// Called when the text covered by this store is truncated.
//----------------------------------------------------------------------------

STDAPI CCustomPropertyStore::Shrink(ITfRange *pRangeNew, BOOL *pfFree)
{
    // give up and free this store
    *pfFree = TRUE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Divide
//
// Called when text covered by the store is deleted, such that the store is
// split in two.  We have the option of freeing the store, or keeping the
// store which moves to cover just pRangeThis (the leftmost text) in which
// case we must provide a new store for the rightmost text as well.
//----------------------------------------------------------------------------

STDAPI CCustomPropertyStore::Divide(ITfRange *pRangeThis, ITfRange *pRangeNew, ITfPropertyStore **ppPropertyStore)
{
    // just give up
    // a NULL ppPropertyStore tells TSF to release this store
    *ppPropertyStore = NULL;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Clone
//
// Return a new store with a copy of this store's state.
//----------------------------------------------------------------------------

STDAPI CCustomPropertyStore::Clone(ITfPropertyStore **ppCloneOut)
{
    CCustomPropertyStore *pClone;

    *ppCloneOut = NULL;

    if ((pClone = new CCustomPropertyStore) == NULL)
        return E_OUTOFMEMORY;

    pClone->_dwState = _dwState;

    *ppCloneOut = pClone;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetPropertyRangeCreator
//
// Returns the owning text service.  Used by TSF during Unserialization.
//----------------------------------------------------------------------------

STDAPI CCustomPropertyStore::GetPropertyRangeCreator(CLSID *pclsid)
{
    *pclsid = c_clsidMarkTextService;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Serialize
//
// Copy this store's state to a binary stream.  This stream will later be returned
// to this text service to recreate the store in a later session.
//----------------------------------------------------------------------------

STDAPI CCustomPropertyStore::Serialize(IStream *pStream, ULONG *pcb)
{
    return pStream->Write(&_dwState, sizeof(_dwState), pcb);
}

//+---------------------------------------------------------------------------
//
// IsStoreSerializable
//
//----------------------------------------------------------------------------

STDAPI CMarkTextService::IsStoreSerializable(REFGUID guidProperty, ITfRange *pRange, ITfPropertyStore *pPropertyStore, BOOL *pfSerializable)
{
    // we don't have any complicated logic, we'll let all our custom property values be serialized
    *pfSerializable = IsEqualGUID(guidProperty, c_guidCustomProperty);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CreatePropertyStore
//
// Unserializes a custom property.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::CreatePropertyStore(REFGUID guidProperty, ITfRange *pRange, ULONG cb, IStream *pStream, ITfPropertyStore **ppStore)
{
    CCustomPropertyStore *pStore;
    DWORD dwState;

    *ppStore = NULL;

    if (!IsEqualGUID(guidProperty, c_guidCustomProperty))
        return E_INVALIDARG;

    if (cb != sizeof(DWORD))
        return E_INVALIDARG;

    if ((pStore = new CCustomPropertyStore) == NULL)
        return E_OUTOFMEMORY;

    if (pStream->Read(&dwState, sizeof(DWORD), &cb) != S_OK || cb != sizeof(DWORD))
    {
        pStore->Release();
        return E_FAIL;
    }

    pStore->_SetState(dwState);
    *ppStore = pStore;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\mark\resource.h ===
//
// resource.h
//
// Resource declarations.
//

#ifndef RESOURCE_H
#define RESOURCE_H

//#define IDI_MARK        0

#endif // RESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\mark\pstore.h ===
//
// pstore.h
//
// CCustomPropertyStore
//

#ifndef PSTORE_H
#define PSTORE_H

class CCustomPropertyStore : public ITfPropertyStore
{
public:
    CCustomPropertyStore();
    ~CCustomPropertyStore();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ITfPropertyStore
    STDMETHODIMP GetType(GUID *pguidType);
    STDMETHODIMP GetDataType(DWORD *pdwReserved);
    STDMETHODIMP GetData(VARIANT *pvarValue);
    STDMETHODIMP OnTextUpdated(DWORD dwFlags, ITfRange *pRangeNew, BOOL *pfAccept);
    STDMETHODIMP Shrink(ITfRange *pRangeNew, BOOL *pfFree);
    STDMETHODIMP Divide(ITfRange *pRangeThis, ITfRange *pRangeNew, ITfPropertyStore **ppPropertyStore);
    STDMETHODIMP Clone(ITfPropertyStore **ppClone);
    STDMETHODIMP GetPropertyRangeCreator(CLSID *pclsid);
    STDMETHODIMP Serialize(IStream *pStream, ULONG *pcb);

    void _SetState(DWORD dwState)
    {
        _dwState = dwState;
    }

private:
    DWORD _dwState;
    LONG _cRef;     // COM ref count
};

#endif // PSTORE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\mark\register.cpp ===
//
// register.cpp
//
// Server registration code.
//

#include <windows.h>
#include <ole2.h>
#include "msctf.h"
#include "globals.h"
#include "mark.h"

#define CLSID_STRLEN 38  // strlen("{xxxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxx}")

const struct
{
    const GUID *pguidCategory;
    const GUID *pguid;
}
c_rgCategories[] =
{
    { &GUID_TFCAT_TIP_KEYBOARD, &c_clsidMarkTextService },
    { &GUID_TFCAT_DISPLAYATTRIBUTEPROVIDER, &c_clsidMarkTextService },
    { &GUID_TFCAT_PROPSTYLE_STATICCOMPACT, &c_guidCaseProperty },
    { &GUID_TFCAT_PROPSTYLE_CUSTOM, &c_guidCustomProperty },    
};

static const TCHAR c_szInfoKeyPrefix[] = TEXT("CLSID\\");
static const TCHAR c_szInProcSvr32[] = TEXT("InProcServer32");
static const TCHAR c_szModelName[] = TEXT("ThreadingModel");

//+---------------------------------------------------------------------------
//
//  RegisterProfiles
//
//----------------------------------------------------------------------------

BOOL CMarkTextService::RegisterProfiles()
{
    ITfInputProcessorProfiles *pInputProcessProfiles;
    WCHAR achIconFile[MAX_PATH];
    char achFileNameA[MAX_PATH];
    DWORD cchA;
    int cchIconFile;
    HRESULT hr;

    hr = CoCreateInstance(CLSID_TF_InputProcessorProfiles, NULL, CLSCTX_INPROC_SERVER,
                          IID_ITfInputProcessorProfiles, (void**)&pInputProcessProfiles);

    if (hr != S_OK)
        return E_FAIL;

    hr = pInputProcessProfiles->Register(c_clsidMarkTextService);

    if (hr != S_OK)
        goto Exit;

    cchA = GetModuleFileNameA(g_hInst, achFileNameA, ARRAYSIZE(achFileNameA));

    cchIconFile = MultiByteToWideChar(CP_ACP, 0, achFileNameA, cchA, achIconFile, ARRAYSIZE(achIconFile)-1);
    achIconFile[cchIconFile] = '\0';

    hr = pInputProcessProfiles->AddLanguageProfile(c_clsidMarkTextService,
                                  MARK_LANGID, 
                                  c_guidMarkProfile, 
                                  MARK_DESC, 
                                  wcslen(MARK_DESC),
                                  achIconFile,
                                  cchIconFile,
                                  MARK_ICON_INDEX);

Exit:
    pInputProcessProfiles->Release();
    return (hr == S_OK);
}

//+---------------------------------------------------------------------------
//
//  UnregisterProfiles
//
//----------------------------------------------------------------------------

void CMarkTextService::UnregisterProfiles()
{
    ITfInputProcessorProfiles *pInputProcessProfiles;
    HRESULT hr;

    hr = CoCreateInstance(CLSID_TF_InputProcessorProfiles, NULL, CLSCTX_INPROC_SERVER,
                          IID_ITfInputProcessorProfiles, (void**)&pInputProcessProfiles);

    if (hr != S_OK)
        return;

    pInputProcessProfiles->Unregister(c_clsidMarkTextService);
    pInputProcessProfiles->Release();
}

//+---------------------------------------------------------------------------
//
//  RegisterCategories
//
//----------------------------------------------------------------------------

BOOL CMarkTextService::RegisterCategories(BOOL fRegister)
{
    ITfCategoryMgr *pCategoryMgr;
    int i;
    HRESULT hr;

    hr = CoCreateInstance(CLSID_TF_CategoryMgr, NULL, CLSCTX_INPROC_SERVER, 
                          IID_ITfCategoryMgr, (void**)&pCategoryMgr);

    if (hr != S_OK)
        return E_FAIL;

    for (i=0; i<ARRAYSIZE(c_rgCategories); i++)
    {
        if (fRegister)
        {
            hr = pCategoryMgr->RegisterCategory(c_clsidMarkTextService,
                   *c_rgCategories[i].pguidCategory, *c_rgCategories[i].pguid);
        }
        else
        {
            hr = pCategoryMgr->UnregisterCategory(c_clsidMarkTextService,
                   *c_rgCategories[i].pguidCategory, *c_rgCategories[i].pguid);
        }

        if (hr != S_OK)
            break;
    }

    pCategoryMgr->Release();
    return (hr == S_OK);
}

//+---------------------------------------------------------------------------
//
// CLSIDToStringA
//
//----------------------------------------------------------------------------

BOOL CLSIDToStringA(REFGUID refGUID, char *pchA)
{
    static const BYTE GuidMap[] = {3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-',
                                   8, 9, '-', 10, 11, 12, 13, 14, 15};

    static const char szDigits[] = "0123456789ABCDEF";

    int i;
    char *p = pchA;

    const BYTE * pBytes = (const BYTE *) &refGUID;

    *p++ = '{';
    for (i = 0; i < sizeof(GuidMap); i++)
    {
        if (GuidMap[i] == '-')
        {
            *p++ = '-';
        }
        else
        {
            *p++ = szDigits[ (pBytes[GuidMap[i]] & 0xF0) >> 4 ];
            *p++ = szDigits[ (pBytes[GuidMap[i]] & 0x0F) ];
        }
    }

    *p++ = '}';
    *p   = '\0';

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// RecurseDeleteKey
//
// RecurseDeleteKey is necessary because on NT RegDeleteKey doesn't work if the
// specified key has subkeys
//----------------------------------------------------------------------------
LONG RecurseDeleteKey(HKEY hParentKey, LPCTSTR lpszKey)
{
    HKEY hKey;
    LONG lRes;
    FILETIME time;
    TCHAR szBuffer[256];
    DWORD dwSize = ARRAYSIZE(szBuffer);

    if (RegOpenKey(hParentKey, lpszKey, &hKey) != ERROR_SUCCESS)
        return ERROR_SUCCESS; // let's assume we couldn't open it because it's not there

    lRes = ERROR_SUCCESS;
    while (RegEnumKeyEx(hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL, &time)==ERROR_SUCCESS)
    {
        szBuffer[ARRAYSIZE(szBuffer)-1] = '\0';
        lRes = RecurseDeleteKey(hKey, szBuffer);
        if (lRes != ERROR_SUCCESS)
            break;
        dwSize = ARRAYSIZE(szBuffer);
    }
    RegCloseKey(hKey);

    return lRes == ERROR_SUCCESS ? RegDeleteKey(hParentKey, lpszKey) : lRes;
}

//+---------------------------------------------------------------------------
//
//  RegisterServer
//
//----------------------------------------------------------------------------

BOOL CMarkTextService::RegisterServer()
{
    DWORD dw;
    HKEY hKey;
    HKEY hSubKey;
    BOOL fRet;
    TCHAR achIMEKey[ARRAYSIZE(c_szInfoKeyPrefix) + CLSID_STRLEN];
    TCHAR achFileName[MAX_PATH];

    if (!CLSIDToStringA(c_clsidMarkTextService, achIMEKey + ARRAYSIZE(c_szInfoKeyPrefix) - 1))
        return FALSE;
    memcpy(achIMEKey, c_szInfoKeyPrefix, sizeof(c_szInfoKeyPrefix)-sizeof(TCHAR));

    if (fRet = RegCreateKeyEx(HKEY_CLASSES_ROOT, achIMEKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, &dw)
            == ERROR_SUCCESS)
    {
        fRet &= RegSetValueEx(hKey, NULL, 0, REG_SZ, (BYTE *)MARK_DESC_A, (lstrlen(MARK_DESC_A)+1)*sizeof(TCHAR))
            == ERROR_SUCCESS;

        if (fRet &= RegCreateKeyEx(hKey, c_szInProcSvr32, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hSubKey, &dw)
            == ERROR_SUCCESS)
        {
            dw = GetModuleFileNameA(g_hInst, achFileName, ARRAYSIZE(achFileName));

            fRet &= RegSetValueEx(hSubKey, NULL, 0, REG_SZ, (BYTE *)achFileName, (lstrlen(achFileName)+1)*sizeof(TCHAR)) == ERROR_SUCCESS;
            fRet &= RegSetValueEx(hSubKey, c_szModelName, 0, REG_SZ, (BYTE *)MARK_MODEL, (lstrlen(MARK_MODEL)+1)*sizeof(TCHAR)) == ERROR_SUCCESS;
            RegCloseKey(hSubKey);
        }
        RegCloseKey(hKey);
    }

    return fRet;
}

//+---------------------------------------------------------------------------
//
//  UnregisterServer
//
//----------------------------------------------------------------------------

void CMarkTextService::UnregisterServer()
{
    TCHAR achIMEKey[ARRAYSIZE(c_szInfoKeyPrefix) + CLSID_STRLEN];

    if (!CLSIDToStringA(c_clsidMarkTextService, achIMEKey + ARRAYSIZE(c_szInfoKeyPrefix) - 1))
        return;
    memcpy(achIMEKey, c_szInfoKeyPrefix, sizeof(c_szInfoKeyPrefix)-sizeof(TCHAR));

    RecurseDeleteKey(HKEY_CLASSES_ROOT, achIMEKey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\softkbd\debug.c ===
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include <windows.h>
#include <ccstock.h>

// Define some things for debug.h
//
#define SZ_DEBUGINI     "cicero.ini"
#define SZ_DEBUGSECTION "SOFTKBD"
#define SZ_MODULE       "SOFTKBD"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\mark\server.cpp ===
//
// server.cpp
//
// COM server exports.
//

#include "globals.h"
#include "mark.h"

void FreeGlobalObjects(void);

class CClassFactory;
static CClassFactory *g_ObjectInfo[1] = { NULL };

//+---------------------------------------------------------------------------
//
//  DllAddRef
//
//----------------------------------------------------------------------------

LONG DllAddRef(void)
{
    return InterlockedIncrement(&g_cRefDll) + 1;
}

//+---------------------------------------------------------------------------
//
//  DllRelease
//
//----------------------------------------------------------------------------

LONG DllRelease(void)
{
    if (InterlockedDecrement(&g_cRefDll) < 0) // g_cRefDll == -1 with zero refs
    {
        EnterCriticalSection(&g_cs);

        // need to check ref again after grabbing mutex
        if (g_ObjectInfo[0] != NULL)
        {
            FreeGlobalObjects();
        }
        assert(g_cRefDll == -1);

        LeaveCriticalSection(&g_cs);
    }

    return g_cRefDll+1;
}

//+---------------------------------------------------------------------------
//
//  CClassFactory declaration with IClassFactory Interface
//
//----------------------------------------------------------------------------

class CClassFactory : public IClassFactory
{
public:
    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IClassFactory methods
    STDMETHODIMP CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);
    STDMETHODIMP LockServer(BOOL fLock);

    // Constructor
    CClassFactory(REFCLSID rclsid, HRESULT (*pfnCreateInstance)(IUnknown *pUnkOuter, REFIID riid, void **ppvObj))
        : _rclsid(rclsid)
    {
        _pfnCreateInstance = pfnCreateInstance;
    }

public:
    REFCLSID _rclsid;
    HRESULT (*_pfnCreateInstance)(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);
};

//+---------------------------------------------------------------------------
//
//  CClassFactory::QueryInterface
//
//----------------------------------------------------------------------------

STDAPI CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = this;
        DllAddRef();
        return NOERROR;
    }
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

//+---------------------------------------------------------------------------
//
//  CClassFactory::AddRef
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CClassFactory::AddRef()
{
    DllAddRef();
    return g_cRefDll+1; // -1 w/ no refs
}

//+---------------------------------------------------------------------------
//
//  CClassFactory::Release
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CClassFactory::Release()
{
    DllRelease();
    return g_cRefDll+1; // -1 w/ no refs
}

//+---------------------------------------------------------------------------
//
//  CClassFactory::CreateInstance
//
//----------------------------------------------------------------------------

STDAPI CClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    return _pfnCreateInstance(pUnkOuter, riid, ppvObj);
}

//+---------------------------------------------------------------------------
//
//  CClassFactory::LockServer
//
//----------------------------------------------------------------------------

STDAPI CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
    {
        DllAddRef();
    }
    else
    {
        DllRelease();
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  BuildGlobalObjects
//
//----------------------------------------------------------------------------

void BuildGlobalObjects(void)
{
    // Build CClassFactory Objects

    g_ObjectInfo[0] = new CClassFactory(c_clsidMarkTextService,
                                        CMarkTextService::CreateInstance);

    // You can add more object info here.
    // Don't forget to increase number of item for g_ObjectInfo[],
}

//+---------------------------------------------------------------------------
//
//  FreeGlobalObjects
//
//----------------------------------------------------------------------------

void FreeGlobalObjects(void)
{
    // Free CClassFactory Objects
    for (int i = 0; i < ARRAYSIZE(g_ObjectInfo); i++)
    {
        if (NULL != g_ObjectInfo[i])
        {
            delete g_ObjectInfo[i];
            g_ObjectInfo[i] = NULL;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  DllGetClassObject
//
//----------------------------------------------------------------------------

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppvObj)
{
    if (g_ObjectInfo[0] == NULL)
    {
        EnterCriticalSection(&g_cs);

            // need to check ref again after grabbing mutex
            if (g_ObjectInfo[0] == NULL)
            {
                BuildGlobalObjects();
            }

        LeaveCriticalSection(&g_cs);
    }

    if (IsEqualIID(riid, IID_IClassFactory) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        for (int i = 0; i < ARRAYSIZE(g_ObjectInfo); i++)
        {
            if (NULL != g_ObjectInfo[i] &&
                IsEqualGUID(rclsid, g_ObjectInfo[i]->_rclsid))
            {
                *ppvObj = (void *)g_ObjectInfo[i];
                DllAddRef();    // class factory holds DLL ref count
                return NOERROR;
            }
        }
    }

    *ppvObj = NULL;

    return CLASS_E_CLASSNOTAVAILABLE;
}

//+---------------------------------------------------------------------------
//
//  DllCanUnloadNow
//
//----------------------------------------------------------------------------

STDAPI DllCanUnloadNow(void)
{
    if (g_cRefDll >= 0) // -1 with no refs
        return S_FALSE;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  DllUnregisterServer
//
//----------------------------------------------------------------------------

STDAPI DllUnregisterServer(void)
{
    CMarkTextService::RegisterCategories(FALSE);
    CMarkTextService::UnregisterProfiles();
    CMarkTextService::UnregisterServer();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  DllRegisterServer
//
//----------------------------------------------------------------------------

STDAPI DllRegisterServer(void)
{
    // register this service's profile with the tsf
    if (!CMarkTextService::RegisterServer() ||
        !CMarkTextService::RegisterProfiles() ||
        !CMarkTextService::RegisterCategories(TRUE))
    {
        DllUnregisterServer(); // cleanup any loose ends
        return E_FAIL;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\sdk\mark\tmgrsink.cpp ===
//
// tmgrsink.cpp
//
// ITfThreadMgrEventSink implementation.
//

#include "globals.h"
#include "mark.h"

//+---------------------------------------------------------------------------
//
// OnInitDocumentMgr
//
// Sink called by the framework just before the first context is pushed onto
// a document.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::OnInitDocumentMgr(ITfDocumentMgr *pDocMgr)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnUninitDocumentMgr
//
// Sink called by the framework just after the last context is popped off a
// document.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::OnUninitDocumentMgr(ITfDocumentMgr *pDocMgr)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnSetFocus
//
// Sink called by the framework when focus changes from one document to
// another.  Either document may be NULL, meaning previously there was no
// focus document, or now no document holds the input focus.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::OnSetFocus(ITfDocumentMgr *pDocMgrFocus, ITfDocumentMgr *pDocMgrPrevFocus)
{
    // we'll track edit changes in the focus document, the only place we start compositions
    _InitTextEditSink(pDocMgrFocus);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnPushContext
//
// Sink called by the framework when a context is pushed.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::OnPushContext(ITfContext *pContext)
{
    // ignore new contexts that appear while were uninitializing
    if (!_fCleaningUp)
    {
        _InitCleanupContextSink(pContext);
        _InitContextCompartment(pContext);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnPopContext
//
// Sink called by the framework when a context is popped.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::OnPopContext(ITfContext *pContext)
{
    _UninitCleanupContextSink(pContext);
    _UninitCompartment(pContext);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _InitThreadMgrSink
//
// Advise our sink.
//----------------------------------------------------------------------------

BOOL CMarkTextService::_InitThreadMgrSink()
{
    return AdviseSink(_pThreadMgr, (ITfThreadMgrEventSink *)this,
                      IID_ITfThreadMgrEventSink, &_dwThreadMgrEventSinkCookie);
}

//+---------------------------------------------------------------------------
//
// _UninitThreadMgrSink
//
// Unadvise our sink.
//----------------------------------------------------------------------------

void CMarkTextService::_UninitThreadMgrSink()
{
    UnadviseSink(_pThreadMgr, &_dwThreadMgrEventSinkCookie);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\softkbd\funcprv.h ===
/**************************************************************************\
* Module Name: funcprv.cpp
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
* Declaration of function provider. 
*
* History:
*         11-April-2000  weibz     Created
\**************************************************************************/

#ifndef FUNCPRV_H
#define FUNCPRV_H

#include "private.h"
#include "fnprbase.h"

class CSoftkbdIMX;

class CFunctionProvider : public CFunctionProviderBase
{
public:
    CFunctionProvider(CSoftkbdIMX *pimx);

    //
    // ITfFunctionProvider
    //
    STDMETHODIMP GetFunction(REFGUID rguid, REFIID riid, IUnknown **ppunk);

    CSoftkbdIMX *_pimx;
};

#endif // FUNCPRV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\softkbd\funcprv.cpp ===
/**************************************************************************\
* Module Name: funcprv.cpp
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
* Implementation of function provider. 
*
* History:
*         11-April-2000  weibz     Created
\**************************************************************************/


#include "private.h"
#include "globals.h"
#include "softkbdimx.h"
#include "funcprv.h"
#include "helpers.h"
#include "immxutil.h"
#include "fnsoftkbd.h"


//////////////////////////////////////////////////////////////////////////////
//
// CFunctionProvider
//
//////////////////////////////////////////////////////////////////////////////


CFunctionProvider::CFunctionProvider(CSoftkbdIMX *pimx) : CFunctionProviderBase(pimx->_GetId())
{
    Init(CLSID_SoftkbdIMX, L"SoftkbdIMX TFX");
    _pimx = pimx;
}

//+---------------------------------------------------------------------------
//
// GetFunction
//
//----------------------------------------------------------------------------

STDAPI CFunctionProvider::GetFunction(REFGUID rguid, REFIID riid, IUnknown **ppunk)
{
    *ppunk = NULL;

    if (!IsEqualIID(rguid, GUID_NULL))
        return E_NOINTERFACE;

    if (IsEqualIID(riid, IID_ITfFnSoftKbd))
    {
        *ppunk = new CFnSoftKbd(this);
    }

    if (*ppunk)
        return S_OK;

    return E_NOINTERFACE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\softkbd\fnsoftkbd.cpp ===
/**************************************************************************\
* Module Name: fnsoftkbd.cpp
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
* Implementation of SoftKbd function object so that other TIPs can control 
* this SoftKbd IMX behavior.
*
* History:
*         11-April-2000  weibz     Created
\**************************************************************************/

#include "private.h"
#include "globals.h"
#include "softkbdimx.h"
#include "fnsoftkbd.h"
#include "funcprv.h"
#include "helpers.h"


//////////////////////////////////////////////////////////////////////////////
//
// CFnSoftKbd
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CFnSoftKbd::QueryInterface(REFIID riid, void **ppvObj)
{

    if ( ppvObj == NULL )
    	return E_FAIL;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfFnSoftKbd))
    {
        *ppvObj = SAFECAST(this, CFnSoftKbd *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CFnSoftKbd::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDAPI_(ULONG) CFnSoftKbd::Release()
{
    long cr;

    cr = InterlockedDecrement(&_cRef);
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CFnSoftKbd::CFnSoftKbd(CFunctionProvider *pFuncPrv)
{

    _pFuncPrv = pFuncPrv;
    _pFuncPrv->AddRef();

    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CFnSoftKbd::~CFnSoftKbd()
{

    SafeRelease(_pFuncPrv);
}

//+---------------------------------------------------------------------------
//
// GetDisplayName
//
//----------------------------------------------------------------------------

STDAPI CFnSoftKbd::GetDisplayName(BSTR *pbstrName)
{

    HRESULT  hr = S_OK;

    if ( pbstrName == NULL )
    {
    	hr = E_FAIL;
    	return hr;
    }

    *pbstrName = SysAllocString(L"FnSoftKbd");

    if ( *pbstrName == NULL )
    {
    	hr = E_OUTOFMEMORY;
    }

    return hr;
}
//+---------------------------------------------------------------------------
//
// IsEnabled
//
//----------------------------------------------------------------------------

STDAPI CFnSoftKbd::IsEnabled(BOOL *pfEnable)
{
    HRESULT  hr = S_OK;

    if ( pfEnable == NULL )
    {
    	hr = E_FAIL;
    	return hr;
    }

    *pfEnable = TRUE;

    return hr;
}

//+---------------------------------------------------------------------------
//
// GetSoftKbdLayoutId
//
//    Get the soft keyboard Id for specified type.
//   
//    Current supported types are:
//             SOFTKBD_TYPE_US_STANDARD
//             SOFTKBD_TYPE_US_SYMBOL
//        
//----------------------------------------------------------------------------


STDAPI  CFnSoftKbd::GetSoftKbdLayoutId(DWORD dwLayoutType, DWORD *lpdwLayoutId)
{

    HRESULT   hr;

    hr = S_OK;

    if ( lpdwLayoutId == NULL )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    if ( (_pFuncPrv == NULL) || (_pFuncPrv->_pimx == NULL) )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    switch (dwLayoutType) {

    case  SOFTKBD_TYPE_US_STANDARD  :

    	   *lpdwLayoutId = (_pFuncPrv->_pimx->_KbdStandard).dwSoftKbdLayout;

    	   break;

    case SOFTKBD_TYPE_US_SYMBOL :

           *lpdwLayoutId = (_pFuncPrv->_pimx->_KbdSymbol).dwSoftKbdLayout;

    	   break;

    default :

    	   hr = E_FAIL;
    }


CleanUp:
    return hr;
}

//+---------------------------------------------------------------------------
//
// SetActiveLayoutId
//
//    Set Current Active soft keyboard layout. the layout Id is returned from
//    GetSoftKbdLayoutId( ).
//
//----------------------------------------------------------------------------

STDAPI  CFnSoftKbd::SetActiveLayoutId(DWORD  dwLayoutId )
{

    HRESULT   hr;

    hr = S_OK;

    if ( (_pFuncPrv == NULL) || (_pFuncPrv->_pimx == NULL) )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    _pFuncPrv->_pimx->SetSoftKBDLayout( dwLayoutId );

CleanUp:
    return hr;
}

//+---------------------------------------------------------------------------
//
// SetSoftKbdOnOff
//
//    Set the current soft keyboard window show status. On or Off based on fOn
//
//----------------------------------------------------------------------------


STDAPI  CFnSoftKbd::SetSoftKbdOnOff(BOOL  fOn )
{

    HRESULT   hr;

    hr = S_OK;

    if ( (_pFuncPrv == NULL) || (_pFuncPrv->_pimx == NULL) )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    _pFuncPrv->_pimx->SetSoftKBDOnOff( fOn );

CleanUp:
    return hr;
}


//+---------------------------------------------------------------------------
//
// GetActiveLayoutId
//
//    Get Current Active soft keyboard layout.
//
//----------------------------------------------------------------------------

STDAPI  CFnSoftKbd::GetActiveLayoutId(DWORD  *lpdwLayoutId )
{
    HRESULT   hr;

    hr = S_OK;

    if ( lpdwLayoutId == NULL )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    if ( (_pFuncPrv == NULL) || (_pFuncPrv->_pimx == NULL) )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    *lpdwLayoutId = _pFuncPrv->_pimx->GetSoftKBDLayout( );

CleanUp:
    return hr;

}


//+---------------------------------------------------------------------------
//
// GetSoftKbdOnOff
//
//    Get the current soft keyboard window show status. 
//
//----------------------------------------------------------------------------


STDAPI  CFnSoftKbd::GetSoftKbdOnOff(BOOL  *lpfOn )
{

    HRESULT   hr;

    hr = S_OK;

    if ( lpfOn == NULL )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    if ( (_pFuncPrv == NULL) || (_pFuncPrv->_pimx == NULL) )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    *lpfOn = _pFuncPrv->_pimx->GetSoftKBDOnOff(  );

CleanUp:
    return hr;

}


STDAPI  CFnSoftKbd::SetSoftKbdPosSize(POINT StartPoint, WORD width, WORD height)
{

    HRESULT  hr;
    ISoftKbd *pSoftKbd;

    hr = S_OK;

    if ( (_pFuncPrv == NULL) || (_pFuncPrv->_pimx == NULL) )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    if ( _pFuncPrv->_pimx->_SoftKbd == NULL )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    pSoftKbd = _pFuncPrv->_pimx->_SoftKbd;

    pSoftKbd->AddRef( );

    hr = pSoftKbd->SetSoftKeyboardPosSize(StartPoint, width, height );

    SafeRelease(pSoftKbd);

CleanUp:

    return hr;
}


STDAPI  CFnSoftKbd::SetSoftKbdColors(COLORTYPE  colorType, COLORREF Color)
{

    HRESULT   hr;
    ISoftKbd *pSoftKbd;

    hr = S_OK;

    if ( (_pFuncPrv == NULL) || (_pFuncPrv->_pimx == NULL) )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    if ( _pFuncPrv->_pimx->_SoftKbd == NULL )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    pSoftKbd = _pFuncPrv->_pimx->_SoftKbd;

    pSoftKbd->AddRef( );

    hr = pSoftKbd->SetSoftKeyboardColors( colorType, Color );

    SafeRelease(pSoftKbd);


CleanUp:

    return hr;

}


STDAPI  CFnSoftKbd::GetSoftKbdPosSize(POINT *lpStartPoint,WORD *lpwidth,WORD *lpheight)
{

    HRESULT   hr;
    ISoftKbd *pSoftKbd;

    hr = S_OK;

    if ( (lpStartPoint==NULL) || (lpwidth == NULL) || (lpheight == NULL))
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    if ( (_pFuncPrv == NULL) || (_pFuncPrv->_pimx == NULL) )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    if ( _pFuncPrv->_pimx->_SoftKbd == NULL )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    pSoftKbd = _pFuncPrv->_pimx->_SoftKbd;

    pSoftKbd->AddRef( );

    hr = pSoftKbd->GetSoftKeyboardPosSize(lpStartPoint, lpwidth, lpheight );

    SafeRelease(pSoftKbd);


CleanUp:

    return hr;
}


STDAPI  CFnSoftKbd::GetSoftKbdColors(COLORTYPE  colorType, COLORREF *lpColor)
{

    HRESULT   hr;
    ISoftKbd *pSoftKbd;

    hr = S_OK;

    if ( (_pFuncPrv == NULL) || (_pFuncPrv->_pimx == NULL) )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    if ( _pFuncPrv->_pimx->_SoftKbd == NULL )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    pSoftKbd = _pFuncPrv->_pimx->_SoftKbd;

    pSoftKbd->AddRef( );

    hr = pSoftKbd->GetSoftKeyboardColors(colorType, lpColor );

    SafeRelease(pSoftKbd);


CleanUp:

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\softkbd\fnsoftkbd.h ===
/**************************************************************************\
* Module Name: fnsoftkbd.h
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
* Declaration of SoftKbd function object. This Function object could be used
* by other Tips to control Softkbd IMX's behavior.
*
* History:
*         11-April-2000  weibz     Created
\**************************************************************************/


#ifndef FNSOFTKBD_H
#define FNSOFTKBD_H

#include "private.h"

#include "softkbd.h"

class CFunctionProvider;

//////////////////////////////////////////////////////////////////////////////
//
// CFnSoftKbd
//
//////////////////////////////////////////////////////////////////////////////

class CFnSoftKbd : public ITfFnSoftKbd
{
public:
    CFnSoftKbd(CFunctionProvider *pFuncPrv);
    ~CFnSoftKbd();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfFunction
    //
    STDMETHODIMP GetDisplayName(BSTR *pbstrCand);
    STDMETHODIMP IsEnabled(BOOL *pfEnable);

    //
    // ITfFnSoftKbd
    //

    STDMETHODIMP GetSoftKbdLayoutId(DWORD dwLayoutType, DWORD *lpdwLayoutId);
    STDMETHODIMP SetActiveLayoutId(DWORD  dwLayoutId );
    STDMETHODIMP SetSoftKbdOnOff(BOOL  fOn );
    STDMETHODIMP SetSoftKbdPosSize(POINT StartPoint, WORD width, WORD height);
    STDMETHODIMP SetSoftKbdColors(COLORTYPE  colorType, COLORREF Color);
    STDMETHODIMP GetActiveLayoutId(DWORD  *lpdwLayoutId );
    STDMETHODIMP GetSoftKbdOnOff(BOOL  *lpfOn );
    STDMETHODIMP GetSoftKbdPosSize(POINT *lpStartPoint,WORD *lpwidth,WORD *lpheight);
    STDMETHODIMP GetSoftKbdColors(COLORTYPE  colorType, COLORREF *lpColor);

private:
    friend CSoftkbdIMX;

    CFunctionProvider *_pFuncPrv; 

    long _cRef;
};

#endif // FNSOFTKBD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\softkbd\globals.cpp ===
/**************************************************************************\
* Module Name: globals.cpp
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
*  Global Definition for Soft Keyboard Component.
*
* History:
*         28-March-2000  weibz     Created
\**************************************************************************/

#include "private.h"
#include "globals.h"

#define CPP_FUNCTIONS
#include "icrtfree.h"

CCicCriticalSectionStatic g_cs;

// for combase
CRITICAL_SECTION *GetServerCritSec(void)
{
    return g_cs;
}

/* ca01de3f-1433-4d60-9324-14307fd943df */
/*extern const GUID GUID_ATTR_SOFTKBDIMX_INPUT = { 
    0xca01de3f,
    0x1433,
    0x4d60,
    {0x93, 0x24, 0x14, 0x30, 0x7f, 0xd9, 0x43, 0xdf}
  };
*/

/* 31f4d5e3-c2da-41bc-902c-d62648447daa */
extern const GUID GUID_IC_PRIVATE = { 
    0x31f4d5e3,
    0xc2da,
    0x41bc,
    {0x90, 0x2c, 0xd6, 0x26, 0x48, 0x44, 0x7d, 0xaa}
  };

extern  const GUID GUID_LBI_SOFTKBDIMX_MODE = {/*7883eed0-e859-4357-a348-006e73ea680f */
    0x7883eed0,
    0xe859,
    0x4357,
    {0xa3, 0x48, 0x00, 0x6e, 0x73, 0xea, 0x68, 0x0f}
  };

/* def9364c-ce29-447f-ae02-076714aeaf6f */
extern const GUID GUID_COMPARTMENT_SOFTKBD_KBDLAYOUT = {
    0xdef9364c,
    0xce29,
    0x447f,
    {0xae, 0x02, 0x07, 0x67, 0x14, 0xae, 0xaf, 0x6f}

};

/* e9221414-d6c8-4885-834e-b11ba641c4f2 */
extern const GUID GUID_COMPARTMENT_SOFTKBD_WNDPOSITION = {
    0xe9221414,
    0xd6c8,
    0x4885,
    {0x83, 0x4e, 0xb1, 0x1b, 0xa6, 0x41, 0xc4, 0xf2}
};


extern PICTUREKEY  gPictureKeys[NUM_PICTURE_KEYS]= {

       // uScanCode,    uVKey,   PictBitmap
       { KID_LWINLOGO,  VK_LWIN,   L"IDB_WINLOGO" },
       { KID_RWINLOGO,  VK_RWIN,   L"IDB_WINLOGO" },
       { KID_APPS,      VK_APPS,   L"IDB_APPS" },

       { KID_LEFT,      VK_LEFT,   L"IDB_LEFT" },
       { KID_RIGHT,     VK_RIGHT,  L"IDB_RIGHT" },
       { KID_UP,        VK_UP,     L"IDB_UP" },
       { KID_DOWN,      VK_DOWN,   L"IDB_DOWN" },

       { KID_ESC,       VK_ESCAPE, L"IDB_ESC" },

       { KID_BACK,      VK_BACK,   L"IDB_BACK" },
       { KID_TAB,       VK_TAB,    L"IDB_TAB" },
       { KID_CAPS,      VK_CAPITAL,L"IDB_CAPITAL" },
       { KID_ENTER,     VK_RETURN, L"IDB_RETURN" },
       { KID_LSHFT,     VK_SHIFT,  L"IDB_SHIFT" },
       { KID_RSHFT,     VK_SHIFT,  L"IDB_SHIFT" },
       { KID_CTRL,      VK_CONTROL,L"IDB_CONTROL" },
       { KID_RCTRL,     VK_CONTROL,L"IDB_CONTROL" },
       { KID_ALT,       VK_MENU,   L"IDB_ALT" },
       { KID_RALT,      VK_RMENU,  L"IDB_ALTGR" },
       { KID_DELETE,    VK_DELETE, L"IDB_DELETE" },
     


       { 0,0,NULL}
};
    	

extern  PICTUREKEY  gJpnPictureKeys[NUM_PICTURE_KEYS] = {

       // uScanCode,    uVKey,   PictBitmap
       { KID_LWINLOGO,  VK_LWIN,   L"IDB_WINLOGO" },
       { KID_RWINLOGO,  VK_RWIN,   L"IDB_WINLOGO" },
       { KID_APPS,      VK_APPS,   L"IDB_APPS" },

       { KID_LEFT,      VK_LEFT,   L"IDB_LEFT" },
       { KID_RIGHT,     VK_RIGHT,  L"IDB_RIGHT" },
       { KID_UP,        VK_UP,     L"IDB_UP" },
       { KID_DOWN,      VK_DOWN,   L"IDB_DOWN" },

       { KID_ESC,       VK_ESCAPE, L"IDB_ESC" },

       { KID_BACK,      VK_BACK,   L"IDB_JPNBACK" },
       { KID_TAB,       VK_TAB,    L"IDB_TAB" },
       { KID_CAPS,      VK_CAPITAL,L"IDB_JPNCAPITAL" },
       { KID_ENTER,     VK_RETURN, L"IDB_JPNRETURN" },
       { KID_LSHFT,     VK_SHIFT,  L"IDB_SHIFT" },
       { KID_RSHFT,     VK_SHIFT,  L"IDB_SHIFT" },
       { KID_CTRL,      VK_CONTROL,L"IDB_CONTROL" },
       { KID_RCTRL,     VK_CONTROL,L"IDB_CONTROL" },
       { KID_ALT,       VK_MENU,   L"IDB_ALT" },
       { KID_RALT,      VK_MENU,   L"IDB_ALT" },
       { KID_DELETE,    VK_DELETE, L"IDB_DELETE" },
       { KID_CONVERT,   VK_CONVERT,L"IDB_CONVERT" },
       { KID_NONCONVERT,VK_NONCONVERT, L"IDB_NONCONVERT" },
       { KID_KANA,      0, L"IDB_KANA" },
       { KID_FULLHALF,  0, L"IDB_FULLHALF" },


       { 0,0,NULL}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\softkbd\icrtfree.h ===
//
// Code to help free modules from the bondage and tyranny of CRT libraries
//
// Include this header in a single component and #define CPP_FUNCTIONS
//


#if defined(__cplusplus) && defined(CPP_FUNCTIONS)

#include "mem.h"
#undef new

void *  __cdecl operator new(size_t nSize)
{
    return cicMemAllocClear((UINT)nSize);
}

void  __cdecl operator delete(void *pv)
{
    cicMemFree(pv);
}

extern "C" int __cdecl _purecall(void) {return 0;}

#endif

#ifdef __cplusplus
extern "C" {
#endif

#if defined(DEFINE_FLOAT_STUFF)
// If you aren't using any floating-point CRT functions and you know
// you aren't performing any float conversions or arithmetic, yet the
// linker wants these symbols declared, then define DEFINE_FLOAT_STUFF.
//
// Warning: declaring these symbols in a component that needs floating
// point support from the CRT will produce undefined results.  (You will
// need fp support from the CRT if you simply perform fp arithmetic.)

int _fltused = 0;
void __cdecl _fpmath(void) { }
#endif

#ifdef __cplusplus
};
#endif

//
// This file should be included in a global component header
// to use the following
//

#ifndef __CRTFREE_H_
#define __CRTFREE_H_

#ifdef __cplusplus

#ifndef _M_PPC
#pragma intrinsic(memcpy)
#pragma intrinsic(memcmp)
#pragma intrinsic(memset)
#endif

#endif

#endif  // __CRTFREE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\softkbd\globals.h ===
//+---------------------------------------------------------------------------
//
//  File:       globals.h
//
//  Contents:   Global variable declarations.
//
//----------------------------------------------------------------------------

#ifndef GLOBALS_H
#define GLOBALS_H

#include "private.h"
#include "ciccs.h"

extern HINSTANCE g_hInst;

extern CCicCriticalSectionStatic g_cs;

extern const CLSID CLSID_SoftkbdIMX;
// extern const GUID GUID_ATTR_SOFTKBDIMX_INPUT;
extern const GUID GUID_IC_PRIVATE;

const TCHAR c_szIMXOwnerWndClass[] = TEXT("SoftkbdIMXOwnerWndClass");

const TCHAR c_szCTFTIPKey[] = TEXT("SOFTWARE\\Microsoft\\CTF\\TIP\\");
const TCHAR c_szLanguageProfileKey[] = TEXT("LanguageProfile");

const TCHAR c_szSoftKbdUIWndClassName[] = TEXT("SoftkbdUIWndFrame");

extern const GUID GUID_LBI_SOFTKBDIMX_MODE;
extern const GUID GUID_COMPARTMENT_SOFTKBD_KBDLAYOUT;
extern const GUID GUID_COMPARTMENT_SOFTKBD_WNDPOSITION;

extern const GUID c_guidProfile;
extern const GUID c_guidProfileSym;

#define  SafeFreePointer(pv)   if ( (pv) != NULL ) {  \
                                      cicMemFree(pv);  \
                                      (pv) = NULL; }     

#define CHECKHR(x) {hr = x; if (FAILED(hr)) goto CleanUp;}


#define   NUM_PICTURE_KEYS    40

// Type definition for picture keys in standard soft keyboards.

typedef struct  _tagPictureKey {

    UINT      uScanCode;   // same as KeyId in the XML file
    UINT      uVkey;
    LPWSTR    PictBitmap;
}  PICTUREKEY,  FAR  * LPPICTUREKEY;

extern   PICTUREKEY  gPictureKeys[NUM_PICTURE_KEYS];
extern   PICTUREKEY  gJpnPictureKeys[NUM_PICTURE_KEYS];


#define  KID_LWINLOGO       0xE05B
#define  KID_RWINLOGO       0xE05C
#define  KID_APPS           0xE05D

#define  KID_LEFT           0xE04B
#define  KID_RIGHT          0xE04D
#define  KID_UP             0xE048
#define  KID_DOWN           0xE050

#define  KID_ESC            0x01
#define  KID_BACK           0x0E
#define  KID_TAB            0x0F
#define  KID_CAPS           0x3A
#define  KID_ENTER          0x1C
#define  KID_LSHFT          0x2A
#define  KID_RSHFT          0x36
#define  KID_CTRL           0x1D
#define  KID_RCTRL          0xE01D
#define  KID_ALT            0x38
#define  KID_RALT           0xE038
#define  KID_SPACE          0x39

#define  KID_DELETE         0xE053

#define  KID_F1             0x3B
#define  KID_F2             0x3C
#define  KID_F3             0x3D
#define  KID_F4             0x3E
#define  KID_F5             0x3F
#define  KID_F6             0x40
#define  KID_F7             0x41
#define  KID_F8             0x42
#define  KID_F9             0x43
#define  KID_F10            0x44
#define  KID_F11            0x57
#define  KID_F12            0x58

#define  KID_CONVERT        0x79
#define  KID_NONCONVERT     0x7B
#define  KID_KANA           0x70
#define  KID_FULLHALF       0x29    // special used by Japan 106 Key

// These defintions are for Transparency of soft keyboard window.
// used by SetLayeredWindowAttributes( )

#if(_WIN32_WINNT < 0x0500)
#define WS_EX_LAYERED           0x00080000
#define LWA_COLORKEY            0x00000001
#define LWA_ALPHA               0x00000002
#define ULW_COLORKEY            0x00000001
#define ULW_ALPHA               0x00000002
#define ULW_OPAQUE              0x00000004
#endif /* _WIN32_WINNT < 0x0500 */


typedef enum { none = 0, CapsLock, Shift, Ctrl, Alt, Kana, AltGr, NumLock}  MODIFYTYPE;

#define      MODIFIER_CAPSLOCK    0x0002
#define      MODIFIER_SHIFT       0x0004
#define      MODIFIER_CTRL        0x0008
#define      MODIFIER_ALT         0x0010
#define      MODIFIER_KANA        0x0020
#define      MODIFIER_ALTGR       0x0040
#define      MODIFIER_NUMLOCK     0x0080

 
#endif // GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\softkbd\init.cpp ===
/**************************************************************************\
* Module Name: init.cpp
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
*  Initialization functions for Soft Keyboard Component.
*
* History:
*         28-March-2000  weibz     Created
\**************************************************************************/

#include "private.h"
#include "globals.h"
#include "immxutil.h"
#include "osver.h"
#include "commctrl.h"
#include "cuilib.h"
#include "mui.h"

DECLARE_OSVER();


//+---------------------------------------------------------------------------
//
// DllInit
//
// Called on our first CoCreate.  Use this function to do initialization that
// would be unsafe during process attach, like anything requiring a LoadLibrary.
//
//----------------------------------------------------------------------------
BOOL DllInit(void)
{
    BOOL fRet = TRUE;

    EnterCriticalSection(GetServerCritSec());

    if (DllRefCount() != 1)
        goto Exit;

    fRet = TFInitLib();
    InitUIFLib();
    InitOSVer();

Exit:
    LeaveCriticalSection(GetServerCritSec());

    return fRet;
}

//+---------------------------------------------------------------------------
//
// DllUninit
//
// Called after the dll ref count drops to zero.  Use this function to do
// uninitialization that would be unsafe during process deattach, like
// FreeLibrary calls.
//
//----------------------------------------------------------------------------

void DllUninit(void)
{
    EnterCriticalSection(GetServerCritSec());

    if (DllRefCount() != 0) 
        goto Exit;

    DoneUIFLib();
    TFUninitLib();
    MuiFlushDlls(g_hInst);

Exit:
    LeaveCriticalSection(GetServerCritSec());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\softkbd\maskbmp.h ===
//
// maskbmp.h
//


#ifndef MASKBMP_H
#define MASKBMP_H


#include "cmydc.h"

extern HINSTANCE g_hInst;

class CMaskBitmap
{
public:
    CMaskBitmap(HBITMAP hBmp)
    {
        BITMAP bmp;
        _hbmpOrg = hBmp;
        int nRet = GetObject(hBmp,sizeof(BITMAP), &bmp);
        Assert(nRet);
        _cx = bmp.bmWidth;
        _cy = bmp.bmHeight;
        _hbmp = NULL;
        _hbmpMask = NULL;
    }

    ~CMaskBitmap()
    {
       // Clear();
    }

    void Clear()
    {
        if (_hbmp)
        {
            DeleteObject(_hbmp);
            _hbmp = NULL;
        }

        if (_hbmpMask)
        {
            DeleteObject(_hbmpMask);
            _hbmpMask = NULL;
        }
    }

    BOOL Init(COLORREF rgb)
    {
        Clear();

        CBitmapDC hdcSrc(TRUE);
        CBitmapDC hdcDst(TRUE);
        CBitmapDC hdcMask(TRUE);
        CBitmapDC hdcMask2(TRUE);
        CSolidBrush hbrFore(rgb);

        HBRUSH hbrBlack = (HBRUSH)GetStockObject(BLACK_BRUSH);
        HBRUSH hbrWhite = (HBRUSH)GetStockObject(WHITE_BRUSH);
        DWORD     DSPDxax;

        DSPDxax  = 0x00E20746L;

        COLORREF   crBLACK = RGB(0,0,0);
        COLORREF   crWHITE = RGB(255,255,255);
    
        hdcMask.SetBitmap(_cx, _cy, 1, 1);
        hdcDst.SetCompatibleBitmap(_cx, _cy);
        hdcSrc.SetBitmap(_hbmpOrg);
 
        // Generate mask to mask background color of original bitmap. WHITE
        BitBlt(hdcDst, 0, 0, _cx, _cy,hdcSrc, 0, 0, SRCCOPY);
        SetBkColor(hdcDst, crWHITE);
        BitBlt(hdcMask, 0, 0, _cx, _cy, hdcDst, 0, 0, SRCCOPY);
        _hbmpMask = hdcMask.GetBitmapAndKeep();

		// Generate mask to mask the foreground color of original bitmap:  BLACK
        hdcMask2.SetBitmap(_cx, _cy, 1, 1);
        SetBkColor(hdcDst, crBLACK);
        BitBlt(hdcMask2, 0, 0, _cx, _cy, hdcDst, 0, 0, SRCCOPY);

		// Change the original foreground color to specified rgb
        SelectObject(hdcDst, hbrFore);
        SetBkColor(hdcDst, crWHITE);
        BitBlt(hdcDst, 0, 0, _cx, _cy, hdcMask2, 0, 0, DSPDxax);

		// Change the original background WHITE color to BLACK to meet CUILIB's requirement.
        SelectObject(hdcDst, hbrBlack);
        SetBkColor(hdcDst, crWHITE);
        BitBlt(hdcDst, 0, 0, _cx, _cy, hdcMask, 0, 0, DSPDxax);

        _hbmp = hdcDst.GetBitmapAndKeep();
   
        DeleteObject(hbrBlack);
        DeleteObject(hbrWhite);
        return TRUE;
    }

    HBITMAP GetBmp() {return _hbmp;}
    HBITMAP GetBmpMask() {return _hbmpMask;}
    

private:
    int _cx;
    int _cy;
    HBITMAP _hbmpOrg;
    HBITMAP _hbmp;
    HBITMAP _hbmpMask;
};

#endif // MASKBMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\softkbd\nui.h ===
//
// nui.h
//

#ifndef NUI_H
#define NUI_H

#include "private.h"
#include "nuibase.h"

class CSoftkbdIMX;

class CLBarItem : public CLBarItemButtonBase
{
public:
    CLBarItem(CSoftkbdIMX *pimx);
    ~CLBarItem();

    STDMETHODIMP GetIcon(HICON *phIcon);
    void UpdateToggle();

private:
    HRESULT OnLButtonUp(const POINT pt, const RECT *prcArea);

    CSoftkbdIMX *_pimx;
};

#endif // NUI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\softkbd\nui.cpp ===
/**************************************************************************\
* Module Name: nui.cpp
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
*  Lang Bar Items for  Soft Keyboard TIP.
*
* History:
*         28-March-2000  weibz     Created
\**************************************************************************/

#include "private.h"
#include "slbarid.h"
#include "globals.h"
#include "softkbdimx.h"
#include "nui.h"
#include "xstring.h"
#include "immxutil.h"
#include "helpers.h"
#include "mui.h"
#include "computil.h"


//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItem::CLBarItem(CSoftkbdIMX *pimx)
{

    WCHAR   wszToolTipText[MAX_PATH];

    Dbg_MemSetThisName(TEXT("CLBarItem"));

    LoadStringWrapW(g_hInst, IDS_SFTKBD_TIP_TEXT, wszToolTipText, MAX_PATH);

    InitNuiInfo(CLSID_SoftkbdIMX,
                GUID_LBI_SOFTKBDIMX_MODE,
                TF_LBI_STYLE_BTN_TOGGLE | TF_LBI_STYLE_SHOWNINTRAY, 
                0, 
                wszToolTipText);

    _pimx = pimx;

    SetToolTip(wszToolTipText);
    SetText(wszToolTipText);
    UpdateToggle();
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLBarItem::~CLBarItem()
{
}

//+---------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CLBarItem::GetIcon(HICON *phIcon)
{
    BOOL fOn = FALSE;

    fOn = _pimx->GetSoftKBDOnOff( );

    *phIcon = LoadSmIcon(g_hInst, MAKEINTRESOURCE(ID_ICON_STANDARD));

    return S_OK;
}


//+---------------------------------------------------------------------------
//
// OnLButtonUp
//
//----------------------------------------------------------------------------

HRESULT CLBarItem::OnLButtonUp(const POINT pt, const RECT *prcArea)
{
     return ToggleCompartmentDWORD(_pimx->_GetId(), 
                                   _pimx->_tim, 
                                   GUID_COMPARTMENT_HANDWRITING_OPENCLOSE, 
                                   FALSE);
}

//+---------------------------------------------------------------------------
//
// UpdateToggle
//
//----------------------------------------------------------------------------

void CLBarItem::UpdateToggle()
{
    DWORD dwHWState = 0;

    GetCompartmentDWORD(_pimx->_tim, 
                        GUID_COMPARTMENT_HANDWRITING_OPENCLOSE, 
                        &dwHWState,
                        FALSE);

    SetOrClearStatus(TF_LBI_STATUS_BTN_TOGGLED, dwHWState);
    if (_plbiSink)
        _plbiSink->OnUpdate(TF_LBI_STATUS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\softkbd\private.h ===
//+---------------------------------------------------------------------------
//
//  File:       private.h
//
//  Contents:   Private header for simx project.
//
//----------------------------------------------------------------------------


#ifndef _PRIVATE_H_
#define _PRIVATE_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define _OLEAUT32_

#include <windows.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#include <ccstock.h>
#include <debug.h>
#include <ole2.h>
#include <ocidl.h>
#include <olectl.h>
#include <initguid.h>
#include "msctf.h"
#include "msctfp.h"
#include "combase.h"
#include "mem.h"
#include "chkobj.h"
#include <atlbase.h>
#include "osver.h"

#endif  // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\softkbd\resource.h ===
#define IDS_MENU_ON        200
#define IDS_MENU_OFF       201

#define IDS_SFTKBD_TIP_TEXT  300

#define IDS_SFTKBD_STANDARD_PROFILE  400
#define IDS_SFTKBD_SYMBOL_PROFILE    401

//
// Icon
//
#define ID_ICON_STANDARD   100
#define ID_ICON_SYMBOL     101
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\softkbd\softkbd.cpp ===
/**************************************************************************\
* Module Name: softkbd.cpp
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
*  Main functions for Soft Keyboard Component.
*
* History:
*         28-March-2000  weibz     Created
\**************************************************************************/

#include "private.h"
#include "resource.h"
#include <initguid.h>
#include "SoftKbd.h"

#include "SoftKbdc.h"
#include "SoftkbdIMX.h"

#include "regimx.h"
#include "catutil.h"

#include "mui.h"
#include "immxutil.h"

#ifdef DEBUG
DWORD g_dwThreadDllMain = 0;
#endif

HINSTANCE  g_hInst;

// used by COM server
HINSTANCE GetServerHINSTANCE(void)
{
    return g_hInst;
}

BEGIN_COCLASSFACTORY_TABLE
    DECLARE_COCLASSFACTORY_ENTRY(CLSID_SoftKbd, CSoftKbd, TEXT("SoftKbd Class"))
    DECLARE_COCLASSFACTORY_ENTRY(CLSID_SoftkbdIMX, CSoftkbdIMX, TEXT("SoftKbdIMX Class"))
    DECLARE_COCLASSFACTORY_ENTRY(CLSID_SoftkbdRegistry, CSoftkbdRegistry, TEXT("SoftKbdRegistry Class"))
END_COCLASSFACTORY_TABLE

const GUID c_guidProfile = { /* 0965500c-82f3-49c2-9f00-01c2feacaa0b */
    0x0965500c,
    0x82f3,
    0x49c2,
    {0x9f, 0x00, 0x01, 0xc2, 0xfe, 0xac, 0xaa, 0x0b}
  };

const GUID c_guidProfileSym = {  // b2a54871-05f6-4bfc-b97d-0fdf0cbfa57d
    0xb2a54871,
    0x05f6,
    0x4bfc,
    {0xb9, 0x7d, 0x0f, 0xdf, 0x0c, 0xbf, 0xa5, 0x7d}
};

extern REGTIPLANGPROFILE c_rgProf[] =
{
    {0,  &GUID_NULL,      L"", L"",   0,  0}
};

//+---------------------------------------------------------------------------
//
// ProcessAttach
//
//----------------------------------------------------------------------------

BOOL ProcessAttach(HINSTANCE hInstance)
{
    if (!g_cs.Init())
        return FALSE;

    CcshellGetDebugFlags();
    Dbg_MemInit(TEXT("SOFTKBDIMX"), NULL);

    g_hInst = hInstance;

    MuiLoadResource(hInstance, TEXT("softkbd.dll"));

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// ProcessDettach
//
//----------------------------------------------------------------------------

void ProcessDettach(HINSTANCE hInstance)
{
    MuiClearResource();

    g_cs.Delete();

    Dbg_MemUninit();
}

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    BOOL bRet = TRUE;
#ifdef DEBUG
    g_dwThreadDllMain = GetCurrentThreadId();
#endif

    switch (dwReason)
    {
     case DLL_PROCESS_ATTACH:
            //
            // Now real DllEntry point is _DllMainCRTStartup.
            // _DllMainCRTStartup does not call our DllMain(DLL_PROCESS_DETACH)
            // if our DllMain(DLL_PROCESS_ATTACH) fails.
            // So we have to clean this up.
            //
            if (!ProcessAttach(hInstance))
            {
                ProcessDettach(hInstance);
                bRet = FALSE;
            }
            break;

     case DLL_THREAD_ATTACH:
            break;

     case DLL_PROCESS_DETACH:
            ProcessDettach(hInstance);
            break;

     case DLL_THREAD_DETACH:
            break;
   }

#ifdef DEBUG
    g_dwThreadDllMain = 0;
#endif

   return bRet;

}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return COMBase_DllCanUnloadNow();
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return COMBase_DllGetClassObject(rclsid, riid, ppv);
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hr = E_FAIL;

    TFInitLib();

    // registers object, typelib and all interfaces in typelib
    if (COMBase_DllRegisterServer() != S_OK)
       goto Exit;

    if (!RegisterTIP(g_hInst, CLSID_SoftkbdIMX, L"On-screen keyboard", c_rgProf))
        goto Exit;

    if ( FAILED(RegisterCategory(CLSID_SoftkbdIMX, GUID_TFCAT_TIP_HANDWRITING, CLSID_SoftkbdIMX)))
        goto Exit;

    hr = S_OK;
Exit:
    TFUninitLib( );
    return hr;
    
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hr=E_FAIL;

    TFInitLib();

    if (COMBase_DllUnregisterServer() != S_OK) 
       goto Exit;

    if (FAILED(UnregisterCategory(CLSID_SoftkbdIMX, GUID_TFCAT_TIP_HANDWRITING, CLSID_SoftkbdIMX)))
        goto Exit;

    if (!UnregisterTIP(CLSID_SoftkbdIMX))
        goto Exit;

    hr=S_OK;

Exit:
    TFUninitLib( );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\softkbd\softkbdes.cpp ===
/**************************************************************************\
* Module Name: softkbdes.cpp
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
* Soft Keyboard Event Sink for the Symbol layout 
*
* History:
*         28-March-2000  weibz     Created
\**************************************************************************/

#include "private.h"
#include "globals.h"
#include "immxutil.h"
#include "proputil.h"
#include "helpers.h"
#include "editcb.h"
#include "dispattr.h"
#include "computil.h"
#include "regsvr.h"

#include "Softkbdimx.h"
#include "SoftKbdES.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSoftKeyboardEventSink::CSoftKeyboardEventSink(CSoftkbdIMX *pSoftKbdIMX, 
                                               DWORD        dwSoftLayout)
{
     _pSoftKbdIMX = pSoftKbdIMX;
     _dwSoftLayout= dwSoftLayout;

     _fCaps = FALSE;
     _fShift= FALSE;
     
     _tid = pSoftKbdIMX->_tid;
     _tim = pSoftKbdIMX->_tim;

     _tim->AddRef( );
    
     _cRef = 1;
}

CSoftKeyboardEventSink::~CSoftKeyboardEventSink()
{

    SafeReleaseClear(_tim);

}


//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CSoftKeyboardEventSink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ISoftKeyboardEventSink))
    {
        *ppvObj = SAFECAST(this, CSoftKeyboardEventSink *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CSoftKeyboardEventSink::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CSoftKeyboardEventSink::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//
//  ISoftKeyboardEventSink
//


STDAPI CSoftKeyboardEventSink::OnKeySelection(KEYID KeySelected, WCHAR  *lpszLabel)
{

    ITfContext   *pic;
    HRESULT      hr;
    CEditSession *pes;

    hr = S_OK;

    switch ( KeySelected )
    {

      case  KID_CTRL  :
      case  KID_ALT   :
                      // doesn't handle
                      // just return
                     break;

      case  KID_CAPS  :

                     _fCaps = !_fCaps;

                     if ( _fCaps == _fShift )
                        // use state 0
                        (_pSoftKbdIMX->_KbdSymbol).dwCurLabel = 0; 

                     else
                        // use state 1

                        (_pSoftKbdIMX->_KbdSymbol).dwCurLabel = 1;

                     hr = SetCompartmentDWORD(_tid, _tim, GUID_COMPARTMENT_SOFTKBD_KBDLAYOUT, _dwSoftLayout, FALSE);

                     break;

      case  KID_LSHFT :
      case  KID_RSHFT :
                     
                     _fShift = !_fShift;

                     if ( _fCaps == _fShift )
                        // use state 0
                         
                        (_pSoftKbdIMX->_KbdSymbol).dwCurLabel = 0;

                     else
                        // use state 1

                        (_pSoftKbdIMX->_KbdSymbol).dwCurLabel = 1;

                     hr = SetCompartmentDWORD(_tid, _tim, GUID_COMPARTMENT_SOFTKBD_KBDLAYOUT, _dwSoftLayout, FALSE);

                     break;

      case  KID_F1  :
      case  KID_F2  :
      case  KID_F3  :
      case  KID_F4  :
      case  KID_F5  :
      case  KID_F6  :
      case  KID_F7  :
      case  KID_F8  :
      case  KID_F9  :
      case  KID_F10 :
      case  KID_F11 :
      case  KID_F12 :
      case  KID_TAB :

                      // simulate a key event and send to system.

      case  KID_ENTER :
      case  KID_ESC   :
      case  KID_SPACE :
      case  KID_BACK  :
      case  KID_UP    :
      case  KID_DOWN  :
      case  KID_LEFT  :
      case  KID_RIGHT :

    	  	  {

    		      BYTE        bVk, bScan;
    		      int         j, jIndex;
    		      KEYID       keyId;
    		      BOOL        fExtendKey, fPictureKey;

    		      keyId = KeySelected;
    		      fPictureKey = FALSE;

    		      for ( j=0; j<NUM_PICTURE_KEYS; j++)
    			  {

    			      if ( gPictureKeys[j].uScanCode == keyId )
    				  {
    				      // This is a picture key.
    				      // it may be a extended key.

    				     jIndex = j;

    				     fPictureKey = TRUE;

    				     break;
    				  }

    		          if ( gPictureKeys[j].uScanCode == 0 )
    				  {
    			         // This is the last item in gPictureKeys.
    			         break;
    				  }

    			  }


    		      fExtendKey = FALSE;

    		      if ( fPictureKey )
    			  {
    			      if ( (keyId & 0xFF00) == 0xE000 )
    				  {
    				      fExtendKey = TRUE;
                          bScan = (BYTE)(keyId & 0x000000ff);
    				  }
                      else
                          bScan = (BYTE)keyId;

     			      bVk = (BYTE)(gPictureKeys[jIndex].uVkey);
    			  }
    		      else
    			  {

    		         bScan = (BYTE)keyId;
    	             bVk = (BYTE)MapVirtualKeyEx((UINT)bScan, 1, 0);
    			  }

    		      if ( fExtendKey )
    			  {
    			     keybd_event(bVk, bScan, (DWORD)KEYEVENTF_EXTENDEDKEY, 0);
    			     keybd_event(bVk, bScan, (DWORD)(KEYEVENTF_EXTENDEDKEY | KEYEVENTF_KEYUP), 0);
    			  }
    		      else
    			  {
                     keybd_event(bVk, bScan, 0, 0);
    		         keybd_event(bVk, bScan, (DWORD)KEYEVENTF_KEYUP, 0);
    			  }

    		      break;
    		  }

      default         :


              if ( lpszLabel == NULL )
              {
                 hr = E_FAIL;

                 return hr;
              }

              pic = _pSoftKbdIMX->GetIC( );

              if ( pic == NULL )
              {
                  return hr;
              }

              if (pes = new CEditSession(CSoftkbdIMX::_EditSessionCallback))
              {

                 WCHAR   *lpLabel;
                 int     i, iLen;

                 iLen = (int) wcslen(lpszLabel);
                 lpLabel = (WCHAR *)cicMemAllocClear((iLen+1)*sizeof(WCHAR));
                
                 if ( lpLabel == NULL )
                 {
                    // not enough memory.

                    hr = E_OUTOFMEMORY;
                    return hr;
                 }

                 for ( i=0; i<iLen; i++)
                     lpLabel[i] = lpszLabel[i];

                 lpLabel[iLen] = L'\0';

                 pes->_state.u = ESCB_KEYLABEL;
                 pes->_state.pv = _pSoftKbdIMX;
                 pes->_state.wParam = (WPARAM)KeySelected;
                 pes->_state.lParam = (LPARAM)lpLabel;
                 pes->_state.pic = pic;
    	         pes->_state.pv1 = NULL;

                 pic->RequestEditSession(_pSoftKbdIMX->_tid, 
                                  pes, 
                                  TF_ES_READWRITE, 
                                  &hr);

                 if ( FAILED(hr) )
                 {
                     SafeFreePointer(lpLabel);
                 }

                 SafeRelease(pes);

              }
              else
    	         hr = E_FAIL;

    		  SafeRelease(pic);

              break;
    }
 
    return hr;

}


CSoftKbdWindowEventSink::CSoftKbdWindowEventSink(CSoftkbdIMX *pSoftKbdIMX) 
{
                                               
     _pSoftKbdIMX = pSoftKbdIMX;
   
     _cRef = 1;
}

CSoftKbdWindowEventSink::~CSoftKbdWindowEventSink()
{

}


//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CSoftKbdWindowEventSink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ISoftKbdWindowEventSink))
    {
        *ppvObj = SAFECAST(this, CSoftKbdWindowEventSink *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CSoftKbdWindowEventSink::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CSoftKbdWindowEventSink::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//
//  ISoftKbdWindowEventSink
//


STDAPI CSoftKbdWindowEventSink::OnWindowClose( )
{

    HRESULT   hr = S_OK;

    if ( _pSoftKbdIMX != NULL )
    	_pSoftKbdIMX->SetSoftKBDOnOff(FALSE);

    return hr;
}

STDAPI CSoftKbdWindowEventSink::OnWindowMove(int xWnd, int yWnd, int width, int height)
{

    HRESULT   hr = S_OK;

    if ( _pSoftKbdIMX != NULL )
        _pSoftKbdIMX->SetSoftKBDPosition(xWnd, yWnd);

// support size change later.
    UNREFERENCED_PARAMETER(width);
    UNREFERENCED_PARAMETER(height);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\softkbd\softkbdes.h ===
// SoftKbdES.h: interface for the SoftKeyboardEventSink class.
//
//////////////////////////////////////////////////////////////////////
#ifndef __SOFTKBDES_H__
#define __SOFTKBDES_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "softkbd.h"

class CSoftkbdIMX;


class CSoftKeyboardEventSink : public ISoftKeyboardEventSink  
{
public:
    CSoftKeyboardEventSink(CSoftkbdIMX *pSoftKbdIMX, DWORD dwSoftLayout);
    ~CSoftKeyboardEventSink();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ISoftKeyboardEventSink
    //

    STDMETHODIMP OnKeySelection(KEYID KeySelected, WCHAR  *lpszLabel);

//    void SetTidDim(TfClientId tid, ITfDocumentMgr *dim);
//    void ReleaseTidDim( );

private:

    long          _cRef;
    DWORD         _dwSoftLayout;
    CSoftkbdIMX  *_pSoftKbdIMX;
    BOOL          _fCaps;
    BOOL          _fShift;
    TfClientId    _tid;
    ITfThreadMgr *_tim;

};


class CSoftKbdWindowEventSink : public ISoftKbdWindowEventSink  
{
public:
    CSoftKbdWindowEventSink(CSoftkbdIMX *pSoftKbdIMX);
    ~CSoftKbdWindowEventSink();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ISoftKbdWindowEventSink
    //

    STDMETHODIMP OnWindowClose( );
    STDMETHODIMP OnWindowMove( int xWnd,int yWnd, int width, int height);

private:

    long          _cRef;
    CSoftkbdIMX  *_pSoftKbdIMX;
};
#endif //
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\softkbd\softkbdc.h ===
/**************************************************************************\
* Module Name: softkbdc.h
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
* Declaration of CSoftKbd 
*
* History:
*         28-March-2000  weibz     Created
\**************************************************************************/

#ifndef __SOFTKBDC_H_
#define __SOFTKBDC_H_

#include "resource.h"       

#include <windows.h>
#include "globals.h"
#include "SoftKbd.h"
#include "msxml.h"
#include "helpers.h"

#define   MAX_KEY_NUM   256

#define   NON_KEYBOARD  -1

#define   IdTimer_MonitorMouse  0x1000
#define   MONITORMOUSE_ELAPSE   8000

// we assume no keyboard has more than 256 keys

#define   KID_ICON          0x100
#define   KID_CLOSE         0x101

#define   DWCOOKIE_SFTKBDWNDES   0x2000

extern HINSTANCE  g_hInst;

#define  LABEL_TEXT    1
#define  LABEL_PICTURE 2

#define  LABEL_DISP_ACTIVE  1
#define  LABEL_DISP_GRAY    2

typedef struct tagActiveLabel {  // label for current active state.
    KEYID      keyId;
    WCHAR     *lpLabelText;
    WORD       LabelType;
    WORD       LabelDisp;
} ACTIVELABEL, *PACTIVELABEL;
 
typedef struct tagKeyLabels {  // labels for all states.
    KEYID     keyId;
    WORD      wNumModComb; // number of modifier combination states.
    BSTR      *lppLabelText;
    WORD      *lpLabelType;
    WORD      *lpLabelDisp;
                           // Every lppLabelText maps to one lpLabelType 
} KEYLABELS, *PKEYLABELS, FAR * LPKEYLABELS;

typedef struct tagKeyMap {

   WORD       wNumModComb;    // number of modifier combination states.
   WORD       wNumOfKeys;
   WCHAR      wszResource[MAX_PATH];  // Keep the resource file path if
                                      // any key has picture as its label
                                      //
   KEYLABELS  lpKeyLabels[MAX_KEY_NUM];

   HKL        hKl;
   struct tagKeyMap  *pNext;

} KEYMAP, *PKEYMAP, FAR * LPKEYMAP;

typedef struct tagKEYDES {

    KEYID       keyId;
    WORD        wLeft;  // relative to the left-top point of the layout window described in KEYBOARD.
    WORD        wTop;
    WORD        wWidth;
    WORD        wHeight;
    MODIFYTYPE  tModifier;
} KEYDES, FAR  * LPKEYDES;

typedef struct tagKbdLayout {

    WORD      wLeft;
    WORD      wTop;
    WORD      wWidth;
    WORD      wHeight;
    WORD      wMarginWidth;
    WORD      wMarginHeight;
    BOOL      fStandard;  // TRUE means this is a standard keyboard;
                          // FALSE means a user-defined keyboard layout.

    WORD      wNumberOfKeys;
    KEYDES    lpKeyDes[MAX_KEY_NUM];
   
} KBDLAYOUT, *PKBDLAYOUT, FAR * LPKBDLAYOUT;


typedef struct tagKbdLayoutDes {

    DWORD     wKbdLayoutID;
    WCHAR     KbdLayoutDesFile[MAX_PATH];
    ISoftKeyboardEventSink  *pskbes;
                  // Soft Keyboard Event Sink should be per Soft Keyboard.
    WORD     ModifierStatus;   // Every bit stands for one modifier's status
                               //
                               // CapsLock bit 1
                               // Shift    bit 2
                               // Ctrl     bit 3
                               // Alt      bit 4
                               // Kana     bit 5
                               // NumLock  bit 6
                               //
                               // Etc.
    KBDLAYOUT kbdLayout;

    KEYMAP    *lpKeyMapList;

    DWORD     CurModiState;
    HKL       CurhKl;

    struct tagKbdLayoutDes  *pNext;

} KBDLAYOUTDES, * PKBDLAYOUTDES, FAR * LPKBDLAYOUTDES;


class CSoftkbdUIWnd;

/////////////////////////////////////////////////////////////////////////////
// CSoftKbd
class CSoftKbd : 
    public CComObjectRoot_CreateInstance<CSoftKbd>,
    public ISoftKbd
{
public:
    CSoftKbd();
    ~CSoftKbd();

BEGIN_COM_MAP_IMMX(CSoftKbd)
    COM_INTERFACE_ENTRY(ISoftKbd)
END_COM_MAP_IMMX()

// ISoftKbd
public:

    STDMETHOD(Initialize)();
    STDMETHOD(EnumSoftKeyBoard)(/*[in]*/ LANGID langid, /*[out]*/ DWORD *lpdwKeyboard);
    STDMETHOD(SelectSoftKeyboard)(/*[in]*/ DWORD  dwKeyboardId);
    STDMETHOD(CreateSoftKeyboardLayoutFromXMLFile)(/*[in, string]*/ WCHAR  *lpszKeyboardDesFile, /*[in]*/ INT  szFileStrLen, /*[out]*/ DWORD *pdwLayoutCookie);
    STDMETHOD(CreateSoftKeyboardLayoutFromResource)(/*[in]*/ WCHAR *lpszResFile, /*[in, string] */ WCHAR  *lpszResType, /*[in, string] */ WCHAR *lpszXMLResString, /*[out] */ DWORD *lpdwLayoutCookie);
    STDMETHOD(ShowSoftKeyboard)(/*[in]*/ INT iShow);
    STDMETHOD(SetKeyboardLabelText)(/*[in]*/ HKL  hKl );
    STDMETHOD(SetKeyboardLabelTextCombination)(/*[in]*/ DWORD  nModifierCombination);
    STDMETHOD(CreateSoftKeyboardWindow)(/*[in]*/ HWND hOwner, /*in*/ TITLEBAR_TYPE Titlebar_type, /*[in]*/ INT xPos, /*[in]*/ INT yPos, /*[in]*/ INT width, /*[in]*/ INT height );
    STDMETHOD(DestroySoftKeyboardWindow)();
    STDMETHOD(GetSoftKeyboardPosSize)(/*[out]*/ POINT *lpStartPoint, /*[out]*/ WORD *lpwidth, /*[out]*/ WORD *lpheight);
    STDMETHOD(GetSoftKeyboardColors)(/*[in]*/ COLORTYPE  colorType,  /*[out]*/ COLORREF *lpColor);
    STDMETHOD(GetSoftKeyboardTypeMode)(/*[out]*/ TYPEMODE  *lpTypeMode);
    STDMETHOD(GetSoftKeyboardTextFont)(/*[out]*/ LOGFONTW  *pLogFont);
    STDMETHOD(SetSoftKeyboardPosSize)(/*[in]*/ POINT StartPoint, /*[in]*/ WORD width, /*[in]*/ WORD height);
    STDMETHOD(SetSoftKeyboardColors)(/*[in]*/ COLORTYPE  colorType, /*[in]*/ COLORREF Color);
    STDMETHOD(SetSoftKeyboardTypeMode)(/*[in]*/ TYPEMODE TypeMode);
    STDMETHOD(SetSoftKeyboardTextFont)(/*[in]*/ LOGFONTW  *pLogFont);
    STDMETHOD(ShowKeysForKeyScanMode)(/*[in]*/ KEYID  *lpKeyID, /*[in]*/ INT iKeyNum, /*[in]*/ BOOL fHighL);
    STDMETHOD(AdviseSoftKeyboardEventSink)(/* [in]*/DWORD dwKeyboardId,/*[in] */REFIID riid, /*[in, iid_is(riid)] */IUnknown *punk, /*[out] */DWORD *pdwCookie);
    STDMETHOD(UnadviseSoftKeyboardEventSink)(/*[in] */DWORD dwCookie);

    // Following public functions will be called by CSoftkbdUIWnd.

    HRESULT        _HandleKeySelection(KEYID keyId);
    HRESULT        _HandleTitleBarEvent( DWORD  dwId );

    KBDLAYOUTDES  *_GetCurKbdLayout( )   {  return _lpCurKbdLayout; }
    DWORD          _GetCurKbdLayoutID( ) {  return _wCurKbdLayoutID; }
    ACTIVELABEL   *_GetCurLabel(  )      {  return _CurLabel; }
    RECT          *_GetTitleBarRect( )   {  return &_TitleBarRect; }
    ISoftKbdWindowEventSink *_GetSoftKbdWndES( ) { return _pskbdwndes; }

private:    
    KBDLAYOUTDES  *_lpKbdLayoutDesList;
    KBDLAYOUTDES  *_lpCurKbdLayout;
    DWORD          _wCurKbdLayoutID;
    ACTIVELABEL    _CurLabel[MAX_KEY_NUM];
    HWND           _hOwner;
    CSoftkbdUIWnd *_pSoftkbdUIWnd;
    int            _xReal;
    int            _yReal;
    int            _widthReal;
    int            _heightReal;
    IXMLDOMDocument *_pDoc;

    COLORREF       _color[Max_color_Type];
    INT            _iShow;
    LOGFONTW       *_plfTextFont;

    WORD           _TitleButtonWidth;
    RECT           _TitleBarRect;
    TITLEBAR_TYPE  _TitleBar_Type;

    ISoftKbdWindowEventSink  *_pskbdwndes;

    HRESULT _CreateStandardSoftKbdLayout(DWORD  dwStdSoftKbdID, WCHAR  *wszStdResStr );
    HRESULT _GenerateRealKbdLayout( );
    HRESULT _SetStandardLabelText(LPBYTE pKeyState, KBDLAYOUT *realKbdLayut,
    									KEYMAP  *lpKeyMapList, int  iState);
    HRESULT _GenerateUSStandardLabel(  );
    HRESULT _GenerateUSEnhanceLabel(  );
    HRESULT _GenerateEuroStandardLabel(  );
    HRESULT _GenerateEuroEnhanceLabel(  );
    HRESULT _GenerateJpnStandardLabel(  );
    HRESULT _GenerateJpnEnhanceLabel(  );

    HRESULT _GenerateCurModiState(WORD *ModifierStatus, DWORD *CurModiState);

    HRESULT _GenerateMapDesFromSKD(BYTE *pMapTable, KEYMAP *lpKeyMapList);
    HRESULT _GenerateKeyboardLayoutFromSKD(BYTE  *lpszKeyboardDes, DWORD dwKbdLayoutID, KBDLAYOUTDES **lppKbdLayout);

    HRESULT _LoadDocumentSync(BSTR pBURL, BOOL   fFileName);
    HRESULT _ParseKeyboardLayout(BOOL   fFileName, WCHAR  *lpszKeyboardDesFile, DWORD dwKbdLayoutID, KBDLAYOUTDES **lppKbdLayout);
    HRESULT _ParseLayoutDescription(IXMLDOMNode *pLayoutChild,  KBDLAYOUT *pLayout);
    HRESULT _ParseMappingDescription(IXMLDOMNode *pLabelChild, KEYMAP *lpKeyMapList);
    HRESULT _GetXMLNodeValueWORD(IXMLDOMNode *pNode,  WORD  *lpWord);
    HRESULT _ParseOneKeyInLayout(IXMLDOMNode *pNode, KEYDES  *lpKeyDes);
    HRESULT _ParseOneKeyInLabel(IXMLDOMNode *pNode, KEYLABELS  *lpKeyLabels);

    DWORD   _UnicodeToUtf8(PWCHAR pwUnicode, DWORD cchUnicode, PCHAR  pchResult, DWORD  cchResult);
    DWORD   _Utf8ToUnicode(PCHAR  pchUtf8,   DWORD cchUtf8,    PWCHAR pwResult,  DWORD  cwResult);
};


// 
// Following are the definition for some XML node and attribute names.
//

#define   xSOFTKBDDES    L"softKbdDes"  

#define   xSOFTKBDTYPE   L"softkbdtype"
#define   xTCUSTOMIZED   L"customized"
#define   xTSTANDARD     L"standard"

#define   xWIDTH         L"width"
#define   xHEIGHT        L"height"
#define   xMARGIN_WIDTH  L"margin_width"
#define   xMARGIN_HEIGHT L"margin_height"
#define   xKEYNUMBER     L"keynumber"
#define   xKEY           L"key"

#define   xMODIFIER      L"modifier"
#define   xNONE          L"none"
#define   xCAPSLOCK      L"CapsLock"
#define   xSHIFT         L"Shift"
#define   xCTRL          L"Ctrl"
#define   xATL           L"Alt"
#define   xKANA          L"Kana"
#define   xALTGR         L"AltGr"
#define   xNUMLOCK       L"NumLock"

#define   xKEYID         L"keyid"
#define   xLEFT          L"left"
#define   xTOP           L"top"


#define   xVALIDSTATES   L"validstates"
#define   xKEYLABEL      L"keylabel"
#define   xLABELTEXT     L"labeltext"
#define   xLABELTYPE     L"labeltype"
#define   xTEXT          L"text"

#define   xLABELDISP     L"labeldisp"
#define   xGRAY          L"gray"
#define   xRESOURCEFILE  L"resourcefile"


//
//  Macros to simplify UTF8 conversions
//

#define UTF8_1ST_OF_2     0xc0      //  110x xxxx
#define UTF8_1ST_OF_3     0xe0      //  1110 xxxx
#define UTF8_1ST_OF_4     0xf0      //  1111 xxxx
#define UTF8_TRAIL        0x80      //  10xx xxxx

#define UTF8_2_MAX        0x07ff    //  max unicode character representable in
                                    //  in two byte UTF8

#define BIT7(ch)        ((ch) & 0x80)
#define BIT6(ch)        ((ch) & 0x40)
#define BIT5(ch)        ((ch) & 0x20)
#define BIT4(ch)        ((ch) & 0x10)
#define BIT3(ch)        ((ch) & 0x08)

#define LOW6BITS(ch)    ((ch) & 0x3f)
#define LOW5BITS(ch)    ((ch) & 0x1f)
#define LOW4BITS(ch)    ((ch) & 0x0f)


//
//  Surrogate pair support
//  Two unicode characters may be linked to form a surrogate pair.
//  And for some totally unknown reason, some person thought they
//  should travel in UTF8 as four bytes instead of six.
//  No one has any idea why this is true other than to complicate
//  the code.
//

#define HIGH_SURROGATE_START  0xd800
#define HIGH_SURROGATE_END    0xdbff
#define LOW_SURROGATE_START   0xdc00
#define LOW_SURROGATE_END     0xdfff



#endif //__SOFTKBDC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\softkbd\softkbdimx.h ===
/**************************************************************************\
* Module Name: softkbdimx.cpp
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
* Declaration of Soft Keyboard Input TIP class. 
*
* History:
*         28-March-2000  weibz     Created
\**************************************************************************/


#ifndef SOFTKBDIMX_H
#define SOFTKBDIMX_H

#include "private.h"
#include "globals.h"
#include "dap.h"
#include "computil.h"
#include "resource.h"
#include "softkbd.h"
#include "nui.h"
#include "immxutil.h"

class CCommandEventSink;
class CEditSession;
class CThreadMgrEventSink;
class CSoftKeyboardEventSink;
class CSoftKbdWindowEventSink;
class CFunctionProvider;
class CActiveLanguageProfileNotifySink;
class CLanguageProfileNotifySink;

#define ESCB_KEYLABEL                   10

#define NON_LAYOUT                      0

#define  KBDTYPE_NONE                   0
#define  KBDTYPE_STANDARD               1
#define  KBDTYPE_SYMBOL                 2 

typedef  struct tagSoftLayout
{
    DWORD   dwSoftKbdLayout;
    BOOL    fStandard;
    DWORD   dwNumLabels;  // Number of Label status. 
    DWORD   dwCurLabel;
    CSoftKeyboardEventSink  *pskbdes;
    DWORD   dwSkbdESCookie;
} SOFTLAYOUT;

class CSoftkbdIMX :
                   public CComObjectRoot_CreateInstance<CSoftkbdIMX>, 
                   public ITfTextInputProcessor,
                   public ITfThreadFocusSink,
                   public CDisplayAttributeProvider
{
public:
    CSoftkbdIMX();
    ~CSoftkbdIMX();

BEGIN_COM_MAP_IMMX(CSoftkbdIMX)
    COM_INTERFACE_ENTRY(ITfTextInputProcessor)
    COM_INTERFACE_ENTRY(ITfThreadFocusSink)
    COM_INTERFACE_ENTRY(ITfDisplayAttributeProvider)
END_COM_MAP_IMMX()

public:
    // ITfX methods
    STDMETHODIMP Activate(ITfThreadMgr *ptim, TfClientId tid);
    STDMETHODIMP Deactivate();

    // ITfThreadFocusSink
    STDMETHODIMP OnSetThreadFocus();
    STDMETHODIMP OnKillThreadFocus();

    static LRESULT CALLBACK _OwnerWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
           return DefWindowProc(hWnd, uMsg, wParam, lParam);
    }

    void _OnOffToggle( );
    ITfContext *GetIC();
    HWND GetOwnerWnd() {return _hOwnerWnd;}

    HRESULT  Initialize( );

    BOOL     _fOnOffSave;

    BOOL GetSoftKBDOnOff(  )
    {

       DWORD dw;

       if (  _tim == NULL )
    	   return FALSE;

       GetCompartmentDWORD(_tim, GUID_COMPARTMENT_HANDWRITING_OPENCLOSE , &dw, FALSE);
       return dw ? TRUE : FALSE;

    }

    void SetSoftKBDOnOff( BOOL fOn )
    {

    	// check to see if the _SoftKbd and soft keyboard related members are initialized.
    	if ( _fInitialized == FALSE )
    	{
    		Initialize( );
    	}

    	if ( (_SoftKbd == NULL) || ( _tim == NULL) )
    		return;

    	if ( fOn == GetSoftKBDOnOff( ) )
           return;

    	SetCompartmentDWORD(_tid, _tim, GUID_COMPARTMENT_HANDWRITING_OPENCLOSE ,fOn ? 0x01 : 0x00 , FALSE);

  
    }

    DWORD  GetSoftKBDLayout( )
    {

       DWORD dw;

    	if ( (_SoftKbd == NULL) || ( _tim == NULL) )
    	   return NON_LAYOUT;

       GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SOFTKBD_KBDLAYOUT, &dw, FALSE);

       return dw;

    }

    void  SetSoftKBDLayout(DWORD  dwKbdLayout)
    {
    	// check to see if the _SoftKbd and soft keyboard related members are initialized.
    	if ( _fInitialized == FALSE )
    	{
    		Initialize( );
    	}

    	if ( (_SoftKbd == NULL) || ( _tim == NULL) )
    		return;

        SetCompartmentDWORD(_tid, _tim, GUID_COMPARTMENT_SOFTKBD_KBDLAYOUT, dwKbdLayout , FALSE);

    }

    HRESULT GetSoftKBDPosition(int *xWnd, int *yWnd)
    {
        DWORD    dwPos;
        HRESULT  hr = S_OK;

    	if ( (_SoftKbd == NULL) || ( _tim == NULL) )
    		return E_FAIL;

        if ( !xWnd  || !yWnd )
            return E_FAIL;

       hr = GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SOFTKBD_WNDPOSITION, &dwPos, TRUE);

       if ( hr == S_OK )
       {
            *xWnd = dwPos & 0x0000ffff;
            *yWnd = (dwPos >> 16) & 0x0000ffff;
            hr = S_OK;
       }
       else
       {
           *xWnd = 0;
           *yWnd = 0;
           hr = E_FAIL;
       }

       return hr;
    }

    void SetSoftKBDPosition(int  xWnd, int yWnd )
    {
        DWORD  dwPos;
        DWORD  left, top;

    	if ( (_SoftKbd == NULL) || ( _tim == NULL) )
    		return;

        if ( xWnd < 0 )
            left = 0;
        else
            left = (WORD)xWnd;

        if ( yWnd < 0 )
            top = 0;
        else
            top = (WORD)yWnd;

        dwPos = ((DWORD)top << 16) + left;

        SetCompartmentDWORD(_tid, _tim, GUID_COMPARTMENT_SOFTKBD_WNDPOSITION, dwPos, TRUE);

    }

    static HRESULT _EditSessionCallback(TfEditCookie ec, CEditSession *pes);

    ITfThreadMgr *_tim;

    TfClientId _GetId() { return _tid; }

    LANGID     _GetLangId( ) { return _langid; }

    ISoftKbd   *_SoftKbd;
    SOFTLAYOUT _KbdStandard;
    SOFTLAYOUT _KbdSymbol;
    DWORD      _CurLayout;
    DWORD      _CurKbdType;
    TfClientId _tid;
    ITfDocumentMgr *_dim;
    LANGID _langid;

    ITfInputProcessorProfiles  *_pProfile;

    void _InitLangID()
    {
  
    	ITfInputProcessorProfiles  *pProfile;

        _langid = 0x409;

    	if ( _pProfile == NULL )
    	{
           CoCreateInstance(CLSID_TF_InputProcessorProfiles,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_ITfInputProcessorProfiles,
                            (void **) &_pProfile);
    	}

    	if ( _pProfile != NULL )
    	{
    		GUID guid;

    		pProfile = _pProfile;
    		pProfile->AddRef( );
              
            pProfile->GetActiveLanguageProfile(CLSID_SoftkbdIMX,
                                               &_langid,
                                               &guid);

    		pProfile->Release( );
          
    	} 
    	
    }

private:

    HRESULT _InputKeyLabel(TfEditCookie ec, ITfContext *pic, WCHAR  *lpszLabel, UINT  nLabLen);

    void _UpdateUI();

    HRESULT _MySetSelectionSimple(TfEditCookie ec, ITfContext *pic, ITfRange *range);

    HRESULT _ShowSoftKBDWindow( BOOL  fShow );
 
    
    HWND       _hOwnerWnd;
    CFunctionProvider *_pFuncPrv;

    static HRESULT _CompEventSinkCallback(void *pv, REFGUID rguid);

    // compartment (storage) event sink
    CCompartmentEventSink   *_pCes;
    
    UINT_PTR _uCurrentEditCookie;

    DWORD _dwThreadFocusCookie;

    static HRESULT _AlsCallback(REFCLSID clsid, REFGUID guidProfile, BOOL fActivated, void *pv);
    static HRESULT _LsCallback(BOOL fChanged, LANGID langid, BOOL *pfAccept, void *pv);

    CActiveLanguageProfileNotifySink  *_timActiveLangSink;
    CLanguageProfileNotifySink        *_timLangSink;

    CSoftKbdWindowEventSink            *_psftkbdwndes;
    DWORD                              _dwsftkbdwndesCookie;

    CLBarItem *_plbi;
     

    BOOL              _fInitialized;

    LIBTHREAD   _libTLS; // tls for the helper library. Since this object is apt threaded,
                         // all members are accessed in a single thread
                         // also, cicero will only create a single instance of this obj per thread
};

inline void SetThis(HWND hWnd, LPARAM lParam)
{
    SetWindowLongPtr(hWnd, GWLP_USERDATA, (UINT_PTR)((CREATESTRUCT *)lParam)->lpCreateParams);
}

inline CSoftkbdIMX *GetThis(HWND hWnd)
{
    CSoftkbdIMX *pIMX = (CSoftkbdIMX *)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    Assert(pIMX != NULL);

    return pIMX;
}

 
class CSoftkbdRegistry :
                   public CComObjectRoot_CreateInstance<CSoftkbdRegistry>, 
                   public ITfSoftKbdRegistry
{
public:
    CSoftkbdRegistry();
    ~CSoftkbdRegistry();

BEGIN_COM_MAP_IMMX(CSoftkbdRegistry)
    COM_INTERFACE_ENTRY(ITfSoftKbdRegistry)
END_COM_MAP_IMMX()

public:
    // ITfSoftKbdRegistry
    STDMETHODIMP EnableSoftkbd(LANGID  langid );
    STDMETHODIMP DisableSoftkbd(LANGID langid );

private:

    HRESULT _SetSoftkbdTIP(LANGID langid,  BOOL  fEnable );
    HRESULT _GenerateCurrentLangProfileList( );

    BOOL    m_fInitialized;
    CComPtr<ITfInputProcessorProfilesEx> m_cpInputProcessorProfiles;
    CStructArray<LANGID>   m_rgLang;

    WCHAR   m_pwszStandard[128];
    WCHAR   m_pwszSymbol[128];
    WCHAR   m_pwszIconFile[MAX_PATH];
};

#endif // SOFTKBDIMX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\softkbd\softkbdimx.cpp ===
/**************************************************************************\
* Module Name: softkbdimx.cpp
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
* Implement TIP interface for Soft Keyboard Input. 
*
* History:
*         28-March-2000  weibz     Created
\**************************************************************************/

#include "private.h"
#include "softkbdimx.h"
#include "globals.h"
#include "immxutil.h"
#include "proputil.h"
#include "funcprv.h"
#include "helpers.h"
#include "editcb.h"
#include "dispattr.h"
#include "computil.h"
#include "timsink.h"
#include "ats.h"
#include "lpns.h"
#include "regsvr.h"

#include "softkbdes.h"

#include "mui.h"
#include "regimx.h"
#include "xstring.h"
#include "cregkey.h"

extern REGTIPLANGPROFILE c_rgProf[];

// Implementation of CSoftkbdRegistry.
//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------
CSoftkbdRegistry::CSoftkbdRegistry()
{
   extern void DllAddRef(void);

   m_fInitialized = FALSE;

   DllAddRef( );
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CSoftkbdRegistry::~CSoftkbdRegistry()
{
    extern void DllRelease(void);

    if (m_rgLang.Count())
        m_rgLang.Clear();

    DllRelease();
}

// Generate the Current Lang Profile List from registry.

HRESULT CSoftkbdRegistry::_GenerateCurrentLangProfileList( )
{
    HRESULT hr = S_OK;
    CComPtr<IEnumTfLanguageProfiles>  cpEnumTfLangProf;

    if ( m_fInitialized == FALSE)
    {
        hr = CoCreateInstance(CLSID_TF_InputProcessorProfiles, NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_ITfInputProcessorProfilesEx, (void**)&m_cpInputProcessorProfiles);

        // Load profile name from resource.
        LoadStringWrapW(g_hInst, IDS_SFTKBD_STANDARD_PROFILE, m_pwszStandard, 128);
        LoadStringWrapW(g_hInst, IDS_SFTKBD_SYMBOL_PROFILE, m_pwszSymbol, 128);

        char szFilePath[MAX_PATH];
        GetModuleFileName(g_hInst, szFilePath, ARRAYSIZE(szFilePath));
        StringCchCopyW(m_pwszIconFile, ARRAYSIZE(m_pwszIconFile), AtoW(szFilePath));

       if ( hr == S_OK )
            m_fInitialized = TRUE;
    }

    if (hr == S_OK)
    {
        LONG      lret = ERROR_SUCCESS;
        CMyRegKey regkey;

        if (m_rgLang.Count())
            m_rgLang.Clear();

        // Get the Language profile list for all languages.

        char  szSoftkbdLangProfKey[MAX_PATH];
        char  szClsidStr[64];

        StringCchCopyA(szSoftkbdLangProfKey, ARRAYSIZE(szSoftkbdLangProfKey), c_szCTFTIPKey);
        CLSIDToStringA(CLSID_SoftkbdIMX, szClsidStr);
        StringCchCatA(szSoftkbdLangProfKey, ARRAYSIZE(szSoftkbdLangProfKey), szClsidStr);
        StringCchCatA(szSoftkbdLangProfKey, ARRAYSIZE(szSoftkbdLangProfKey), "\\");
        StringCchCatA(szSoftkbdLangProfKey, ARRAYSIZE(szSoftkbdLangProfKey), c_szLanguageProfileKey);

		lret = regkey.Open(HKEY_LOCAL_MACHINE,
                           szSoftkbdLangProfKey,
                           KEY_READ);

        if ( ERROR_SUCCESS == lret )
        {
            char      szProfileName[MAX_PATH];
            char      szLangIdName[MAX_PATH];
            DWORD     dwIndex = 0;
            LANGID    langid;
            BOOL      fStandExist = FALSE;
            BOOL      fSymExist = FALSE;
            TCHAR     achClsidStd[CLSID_STRLEN+1];
            TCHAR     achClsidSym[CLSID_STRLEN+1];
            CMyRegKey  regLangKey;
            ULONG     ulCount = 0;

            CLSIDToStringA(c_guidProfile, achClsidStd);
            CLSIDToStringA(c_guidProfileSym, achClsidSym);

            // Enum the subkey for langid.

            while ( ERROR_SUCCESS == regkey.EnumKey(dwIndex, szLangIdName, ARRAYSIZE(szLangIdName)))
            {

        		lret = regLangKey.Open(regkey.m_hKey,
                                    szLangIdName,
                                    KEY_READ);

                if ( ERROR_SUCCESS == lret )
                {
                    char  *pLangStr;
                    int   iLangLen;
                    DWORD dwProfIndex;

                    pLangStr = szLangIdName;

		            if ( (tolower(pLangStr[0]) == '0')  && (tolower(pLangStr[1]) == 'x'))
			             pLangStr += 2;

		            iLangLen = strlen(pLangStr);
		            langid = 0;
		            for ( int i=0; i<iLangLen; i++)
		            {
			            WORD  wVchar;
                        char  cLower;

                        cLower = (char)tolower(pLangStr[i]);

            		    wVchar = 0;
            		    if ((cLower <= '9') && (cLower >= '0'))
				            wVchar = cLower - '0';

            	        if ((cLower <= 'f') && (cLower >= 'a' ))
				            wVchar = cLower - 'a' + 10;

			            langid = langid * 16 + wVchar;
		            }

                    fStandExist = fSymExist = FALSE;

                    dwProfIndex = 0;

                    while (!(fStandExist && fSymExist)
                        && ERROR_SUCCESS == regLangKey.EnumKey(dwProfIndex, szProfileName, ARRAYSIZE(szProfileName)))
                    {
                        
                        if ( !_stricmp(szProfileName, achClsidStd) )
                            fStandExist = TRUE;
                        else if ( !_stricmp(szProfileName, achClsidSym) )
                            fSymExist = TRUE;

                        dwProfIndex++;
                    }

                    if ( fStandExist && fSymExist )
                    {
                        LANGID  *pLang;
                        m_rgLang.Append(1);

                        pLang = m_rgLang.GetPtr(ulCount);
                        if ( pLang )
                        {   
                            ulCount ++;
                            *pLang = langid;
                        }
                    }
                    regLangKey.Close( );
                }
                dwIndex ++;
            }
        }
    }
    return hr;
}


// Add or Remove Language profile
HRESULT CSoftkbdRegistry::_SetSoftkbdTIP(LANGID  langid,  BOOL fEnable )
{
    HRESULT  hr = S_OK;
    ULONG    ulCount;
    BOOL     fAllLangExist = FALSE;
    BOOL     fLangExist = FALSE;
    LANGID  *pLangId = NULL;
    
    hr = _GenerateCurrentLangProfileList( );
    if ( hr != S_OK ) return hr;

    ulCount = m_rgLang.Count();
   
    if ( langid == 0  || langid == (LANGID)0xffff )
    {
        // Remove all the Profiles first.
        for (ULONG i=0; i<ulCount; i++)
        {
            pLangId = m_rgLang.GetPtr(i);
            if ( pLangId )           
            {
                hr = m_cpInputProcessorProfiles->RemoveLanguageProfile(CLSID_SoftkbdIMX,
                                                                  *pLangId,
                                                                  c_guidProfile);

                if (S_OK == hr)
                    hr = m_cpInputProcessorProfiles->RemoveLanguageProfile(CLSID_SoftkbdIMX,
                                                                    *pLangId,
                                                                    c_guidProfileSym);
            }
        }

        if ( fEnable  && hr == S_OK)  // Add this profile for all languages.
        {
                hr = m_cpInputProcessorProfiles->AddLanguageProfile(CLSID_SoftkbdIMX,
                                                               (LANGID)0xffff,
                                                               c_guidProfile,
                                                               m_pwszStandard,
                                                               wcslen(m_pwszStandard),
                                                               m_pwszIconFile,
                                                               wcslen(m_pwszIconFile),
                                                               0);

                if ( hr == S_OK )
                {
                   // Set DisplayName for MUI supporting
                   hr = m_cpInputProcessorProfiles->SetLanguageProfileDisplayName(CLSID_SoftkbdIMX,
                                                              (LANGID)0xffff,
                                                              c_guidProfile,
                                                              m_pwszIconFile,
                                                              wcslen(m_pwszIconFile),
                                                              IDS_SFTKBD_STANDARD_PROFILE );
                }
                                                               

                if ( hr == S_OK )
                {
                     hr = m_cpInputProcessorProfiles->AddLanguageProfile(CLSID_SoftkbdIMX,
                                                                (LANGID)0xffff,
                                                                c_guidProfileSym,
                                                                m_pwszSymbol,
                                                                wcslen(m_pwszSymbol),
                                                                m_pwszIconFile,
                                                                wcslen(m_pwszIconFile),
                                                                1);
                }

                if ( hr == S_OK )
                {
                   // Set DisplayName for MUI supporting
                   hr = m_cpInputProcessorProfiles->SetLanguageProfileDisplayName(CLSID_SoftkbdIMX,
                                                              (LANGID)0xffff,
                                                              c_guidProfileSym,
                                                              m_pwszIconFile,
                                                              wcslen(m_pwszIconFile),
                                                              IDS_SFTKBD_SYMBOL_PROFILE );
                }

         }

        return hr;
    }

    // Check to see if this profile is already there
    for (ULONG i=0; i<ulCount; i++)
    {
        if ( fAllLangExist && fLangExist )
            break;

        pLangId = m_rgLang.GetPtr(i);
        if ( pLangId )           
        {
            if ( *pLangId == (LANGID)0xffff)
                fAllLangExist = TRUE;

            if ( *pLangId == langid )
                fLangExist = TRUE;
        }
    }

    if ( fEnable )
    {
        if ( !fAllLangExist &&  !fLangExist )
        {
            hr = m_cpInputProcessorProfiles->AddLanguageProfile(CLSID_SoftkbdIMX,
                                                               langid,
                                                               c_guidProfile,
                                                               m_pwszStandard,
                                                               wcslen(m_pwszStandard),
                                                               m_pwszIconFile,
                                                               wcslen(m_pwszIconFile),
                                                               0);
            if ( hr == S_OK )
            {
               // Set DisplayName for MUI supporting
               hr = m_cpInputProcessorProfiles->SetLanguageProfileDisplayName(CLSID_SoftkbdIMX,
                                                          langid,
                                                          c_guidProfile,
                                                          m_pwszIconFile,
                                                          wcslen(m_pwszIconFile),
                                                          IDS_SFTKBD_STANDARD_PROFILE );
            }

            if ( hr == S_OK )
            {
                hr = m_cpInputProcessorProfiles->AddLanguageProfile(CLSID_SoftkbdIMX,
                                                               langid,
                                                               c_guidProfileSym,
                                                               m_pwszSymbol,
                                                               wcslen(m_pwszSymbol),
                                                               m_pwszIconFile,
                                                               wcslen(m_pwszIconFile),
                                                               1);
            }

            if ( hr == S_OK )
            {
               // Set DisplayName for MUI supporting
               hr = m_cpInputProcessorProfiles->SetLanguageProfileDisplayName(CLSID_SoftkbdIMX,
                                                          langid,
                                                          c_guidProfileSym,
                                                          m_pwszIconFile,
                                                          wcslen(m_pwszIconFile),
                                                          IDS_SFTKBD_SYMBOL_PROFILE );
            }

        }
    }
    else
    {
        // Remove  the specified or all Profiles.
        for (ULONG i=0; i<ulCount; i++)
        {
            pLangId = m_rgLang.GetPtr(i);
            if ( pLangId )           
            {
                if ( fAllLangExist )
                {
                    hr = m_cpInputProcessorProfiles->RemoveLanguageProfile(CLSID_SoftkbdIMX,
                                                                            *pLangId,
                                                                            c_guidProfile);

                    if ( S_OK == hr )
                        hr = m_cpInputProcessorProfiles->RemoveLanguageProfile(CLSID_SoftkbdIMX,
                                                                            *pLangId,
                                                                            c_guidProfileSym);
                }
                else if (  fLangExist )
                {
                    if ( *pLangId == langid )
                    {

                        hr = m_cpInputProcessorProfiles->RemoveLanguageProfile(CLSID_SoftkbdIMX,
                                                                                langid,
                                                                                c_guidProfile);
                        if ( S_OK == hr )
                            hr = m_cpInputProcessorProfiles->RemoveLanguageProfile(CLSID_SoftkbdIMX,
                                                                                langid,
                                                                                c_guidProfileSym);

                    }
                }
            }
        }
    }

    return hr;
}


HRESULT CSoftkbdRegistry::EnableSoftkbd(LANGID  langid )
{
    return _SetSoftkbdTIP(langid, TRUE);

}

HRESULT CSoftkbdRegistry::DisableSoftkbd(LANGID  langid )
{
    return _SetSoftkbdTIP(langid, FALSE);
}


//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CSoftkbdIMX::CSoftkbdIMX()
{
    extern void DllAddRef(void);

    _fInitialized = FALSE;
    _SoftKbd = NULL;

    _CurKbdType = KBDTYPE_NONE;
    _CurLayout = NON_LAYOUT;

    _tim = NULL;
    _dim = NULL;

    _pCes = NULL;

    DllAddRef();
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CSoftkbdIMX::~CSoftkbdIMX()
{
    extern void DllRelease(void);

    if ( _SoftKbd != NULL )
    {

       _SoftKbd->DestroySoftKeyboardWindow( );
    }

    if ( _hOwnerWnd != NULL )
       DestroyWindow(_hOwnerWnd);

    _fInitialized = FALSE;

    if ( _SoftKbd != NULL )
    {
    	if ( _KbdSymbol.pskbdes != NULL )
    	{

    		_SoftKbd->UnadviseSoftKeyboardEventSink(_KbdSymbol.dwSkbdESCookie);
    		_SoftKbd->UnadviseSoftKeyboardEventSink(_dwsftkbdwndesCookie);

    		delete _psftkbdwndes;

    		delete _KbdSymbol.pskbdes;

    	}

    }

    if ( _pCes != NULL )
    {
    	_fOnOffSave = FALSE;

        _pCes->_Unadvise();
        SafeReleaseClear(_pCes);
    }

    SafeRelease(_SoftKbd);
    SafeRelease(_pFuncPrv);

    DllRelease();
}


//
// Only when GUID_COMPARTMENT_HANDWRITING_OPENCLOSE is set TRUE at the first
// time, this Initiliaze( ) could be called by the compartment event sink.
//

HRESULT  CSoftkbdIMX::Initialize( )
{

    HRESULT     hr;
    WCHAR       *lpSymXMLResStr = L"IDSKD_SYMLAYOUT";
    WCHAR       wszModuleFile[MAX_PATH];
    CHAR        szModuleFile[MAX_PATH];
    DWORD       dwFileLen;
    WNDCLASSEX  wndclass;
    INT         wScreenWidth, wScreenHeight;
    INT         left, top, width, height;  
    RECT        rcWork;


    hr = S_OK;

    if ( _fInitialized == TRUE )
    {
    	// Initialization is already done.

    	return hr;
    }


    if ( GetClassInfoEx( g_hInst, c_szIMXOwnerWndClass, &wndclass) == 0 )
    {
        memset(&wndclass, 0, sizeof(wndclass));
        wndclass.cbSize        = sizeof(wndclass);
        wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
        wndclass.hInstance     = g_hInst;
        wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);

        wndclass.lpfnWndProc   = _OwnerWndProc;
        wndclass.lpszClassName = c_szIMXOwnerWndClass;
        RegisterClassEx(&wndclass);
    }

     _hOwnerWnd = CreateWindowEx(0, c_szIMXOwnerWndClass, TEXT(""), WS_DISABLED, 0, 0, 0, 0, NULL, 0, g_hInst, 0);

    	// PerfConsider: use a static ctor instead of ole32/class factory/etc.
    hr=CoCreateInstance(CLSID_SoftKbd, NULL, CLSCTX_INPROC_SERVER, IID_ISoftKbd, (void**)&_SoftKbd);


    if (FAILED(hr) )
    {
        // assert(0);
        return hr;
    }

    _SoftKbd->Initialize( );

    // initialize Standard soft layout and Symbol Soft Layout.

    _KbdStandard.dwSoftKbdLayout = SOFTKBD_US_STANDARD;
    _KbdStandard.fStandard       = TRUE;
    _KbdStandard.dwNumLabels     = 0;   // for standard, this field is not really used.
    _KbdStandard.dwCurLabel      = 0;
    _KbdStandard.pskbdes         = NULL; // standard layout doesn't supply sftkbd event sink.
    _KbdStandard.dwSkbdESCookie  = 0;

    _KbdSymbol.fStandard = FALSE;
    _KbdSymbol.dwNumLabels = 2;
    _KbdSymbol.dwCurLabel = 0;

    dwFileLen = GetModuleFileNameA(g_hInst, szModuleFile, MAX_PATH);
    
    if ( dwFileLen == 0 )
    {  
    	hr = E_FAIL;
    	goto CleanUp;
    } 

    MultiByteToWideChar(CP_ACP, 0, szModuleFile, -1,
    	                wszModuleFile, MAX_PATH);
    
    hr = _SoftKbd->CreateSoftKeyboardLayoutFromResource(wszModuleFile, L"SKDFILE", lpSymXMLResStr, 
                                                        &(_KbdSymbol.dwSoftKbdLayout) );

    CHECKHR(hr);


    _KbdSymbol.pskbdes = new  CSoftKeyboardEventSink(this, _KbdSymbol.dwSoftKbdLayout);

    if ( _KbdSymbol.pskbdes == NULL )
    {

    	hr = E_FAIL;
    	goto CleanUp;
    }

    hr = _SoftKbd->AdviseSoftKeyboardEventSink(_KbdSymbol.dwSoftKbdLayout,
                                          IID_ISoftKeyboardEventSink,
                                          _KbdSymbol.pskbdes,
                                          &(_KbdSymbol.dwSkbdESCookie) );


    CHECKHR(hr);

    _psftkbdwndes = new CSoftKbdWindowEventSink(this);

    if ( _psftkbdwndes == NULL )
    {

    	hr=E_FAIL;
    	goto CleanUp;
    }

    CHECKHR(_SoftKbd->AdviseSoftKeyboardEventSink(0,IID_ISoftKbdWindowEventSink,_psftkbdwndes, &(_dwsftkbdwndesCookie)) );

    _CurLayout = _KbdStandard.dwSoftKbdLayout;

    width = 400;
    height = 172;

    if ( S_OK != GetSoftKBDPosition( &left, &top ) )
    {
        // the compartment is not initialize.
        SystemParametersInfo(SPI_GETWORKAREA, 0, &rcWork, 0 );
        wScreenWidth = (INT)(rcWork.right - rcWork.left + 1);
        wScreenHeight = (INT)(rcWork.bottom - rcWork.top + 1);
        left = wScreenWidth - width -2;
        top = wScreenHeight - height - 1;
    }
 
    CHECKHR(_SoftKbd->CreateSoftKeyboardWindow(_hOwnerWnd,TITLEBAR_GRIPPER_BUTTON, left,top,width,height));

    SetSoftKBDPosition(left, top );

    if ( hr == S_OK ) 
    {
        LOGFONTW  lfTextFont;
        int iDpi;
        int iPoint;

        iDpi = 96;
        iPoint = 9;
        HDC hdc;
    
        hdc = CreateIC("DISPLAY", NULL, NULL, NULL);

        if (hdc)
        {
            iDpi = GetDeviceCaps(hdc, LOGPIXELSY);
            DeleteDC(hdc);

            memset(&lfTextFont, 0, sizeof(LOGFONTW) );
            lfTextFont.lfHeight = -iPoint * iDpi / 72;

            lfTextFont.lfWeight = 400;
            lfTextFont.lfOutPrecision = OUT_TT_ONLY_PRECIS;

            wcsncpy(lfTextFont.lfFaceName, L"Arial", ARRAYSIZE(lfTextFont.lfFaceName));
            lfTextFont.lfCharSet = 0;

            hr = _SoftKbd->SetSoftKeyboardTextFont(&lfTextFont);
        }
    }

    _fInitialized = TRUE;

    // or get the current layout from previous saved one.

CleanUp:

    return hr;

}


//+---------------------------------------------------------------------------
//
// OnSetThreadFocus
//
//----------------------------------------------------------------------------

STDAPI CSoftkbdIMX::OnSetThreadFocus()
{

    // Restore the ON/OFF status before KillThreadFocus( )

    if ( _SoftKbd != NULL )
    {

    	if ( _fOnOffSave ) 
        {
            // adjust the window position.
            int     xWnd, yWnd;
            WORD    width=0, height=0;
            POINT   OldPoint;
            HRESULT hr;

            _SoftKbd->GetSoftKeyboardPosSize(&OldPoint, &width, &height);
            hr = GetSoftKBDPosition(&xWnd, &yWnd);

            if ( hr == S_OK )
            {
                if ( (xWnd != OldPoint.x) || (yWnd != OldPoint.y) )
                {
                    POINT  NewPoint;

                    NewPoint.x = xWnd;
                    NewPoint.y = yWnd;
                    _SoftKbd->SetSoftKeyboardPosSize(NewPoint, width, height);
                }
            }

            _ShowSoftKBDWindow(TRUE);
        }
    	else
    		_SoftKbd->ShowSoftKeyboard(FALSE);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnKillThreadFocus
//
//----------------------------------------------------------------------------

STDAPI CSoftkbdIMX::OnKillThreadFocus()
{


    // keep the ON/OFF status so that OnSetThreadFocus( ) can restore it later

    _fOnOffSave = GetSoftKBDOnOff( );

    if ( _SoftKbd != NULL )
    {
    	_SoftKbd->ShowSoftKeyboard( FALSE );
    }

    // release all the modifier keys  except lock keys.  that is , Shift, Alt, Ctrl, 
    keybd_event((BYTE)VK_SHIFT, (BYTE)KID_LSHFT, (DWORD)KEYEVENTF_KEYUP, 0);
    keybd_event((BYTE)VK_MENU,  (BYTE)KID_ALT, (DWORD)KEYEVENTF_KEYUP, 0);
    keybd_event((BYTE)VK_LMENU, (BYTE)KID_ALT, (DWORD)KEYEVENTF_KEYUP, 0);
    keybd_event((BYTE)VK_RMENU, (BYTE)KID_RALT, (DWORD)KEYEVENTF_KEYUP, 0);
    keybd_event((BYTE)VK_CONTROL, (BYTE)KID_CTRL, (DWORD)KEYEVENTF_KEYUP, 0);
        
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Activate
//
//----------------------------------------------------------------------------

STDAPI CSoftkbdIMX::Activate(ITfThreadMgr *ptim, TfClientId tid)
{
    ITfSource *source;
    ITfLangBarItemMgr *plbim = NULL;
    HRESULT hr;

    Assert(_tim == NULL);
    _tim = ptim;
    _tim->AddRef();

    _tid = tid;


    _pProfile = NULL;

    if (_tim->QueryInterface(IID_ITfSource, (void **)&source) == S_OK)
    {
        source->AdviseSink(IID_ITfThreadFocusSink, (ITfThreadFocusSink *)this, &_dwThreadFocusCookie);
        source->Release();
    }

    //
    // Add SoftKeyboard activate button into LangBarItemMgr.
    //
    if (FAILED(hr = GetService(_tim, IID_ITfLangBarItemMgr, (IUnknown **)&plbim)))
    {
        hr = E_FAIL;
        goto CleanUp;
    }

    if (!(_plbi = new CLBarItem(this)))
    {
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }

    plbim->AddItem(_plbi);


    //
    // get language ID.
    //
    _InitLangID();

    if ( (_timActiveLangSink = new CActiveLanguageProfileNotifySink(_AlsCallback, this)) == NULL )
    {
        Assert(0); 
        hr = E_FAIL;
        goto CleanUp;
    }

    _timActiveLangSink->_Advise(_tim);

    if ( (_timLangSink = new CLanguageProfileNotifySink(_LsCallback, this)) == NULL )
    {
        Assert(0); 
        hr = E_FAIL;
        goto CleanUp;
    }

    _timLangSink->_Advise(_pProfile);

    _pFuncPrv = new CFunctionProvider(this);

    if ( _pFuncPrv != NULL)
        _pFuncPrv->_Advise(_tim);


    // defaultly, hide the soft keyboard window.

    _fOnOffSave = FALSE;

    if (!(_pCes = new CCompartmentEventSink(_CompEventSinkCallback, this)))
    {
        hr = E_OUTOFMEMORY;
        CHECKHR(hr);
    }

    CHECKHR(_pCes->_Advise(_tim, GUID_COMPARTMENT_HANDWRITING_OPENCLOSE, FALSE));
    CHECKHR(_pCes->_Advise(_tim, GUID_COMPARTMENT_SOFTKBD_KBDLAYOUT, FALSE));

#if 0
    
    if (_tim->IsThreadFocus(&fThreadFocus) == S_OK && fThreadFocus)
    {
        // init any UI
        OnSetThreadFocus();
    }

#endif

    hr = S_OK;

CleanUp:
    SafeRelease(plbim);

    return hr;
}

//+---------------------------------------------------------------------------
//
// Deactivate
//
//----------------------------------------------------------------------------

STDAPI CSoftkbdIMX::Deactivate()
{
    ITfSource *source;
    ITfLangBarItemMgr *plbim = NULL;
//    BOOL fThreadFocus;
    HRESULT hr;


     if (_tim->QueryInterface(IID_ITfSource, (void **)&source) == S_OK)
    {
        source->UnadviseSink(_dwThreadFocusCookie);
        source->Release();
    }

    //
    // Clean up SoftKeyboard activate button into LangBarItemMgr.
    //
    if (SUCCEEDED(hr = GetService(_tim, IID_ITfLangBarItemMgr, (IUnknown **)&plbim)))
    {
        plbim->RemoveItem(_plbi);
        SafeReleaseClear(_plbi);
        SafeReleaseClear(plbim);
    }



    if ( _timActiveLangSink != NULL )
    {
        _timActiveLangSink->_Unadvise( );
        SafeReleaseClear(_timActiveLangSink);
    }

    if ( _timLangSink != NULL )
    {
        _timLangSink->_Unadvise( );
        SafeReleaseClear(_timLangSink);
    }
 
    if ( _pFuncPrv != NULL )
    {
       _pFuncPrv->_Unadvise(_tim);
       SafeReleaseClear(_pFuncPrv);
    }

    if ( _pCes != NULL )
    {

    	if ( _SoftKbd != NULL )
    		_SoftKbd->ShowSoftKeyboard(FALSE);
    	_fOnOffSave = FALSE;
    	_pCes->_Unadvise();
    	SafeReleaseClear(_pCes);
    }

    SafeReleaseClear(_pProfile);
    
    SafeReleaseClear(_tim);

    TFUninitLib_Thread(&_libTLS);

    hr = S_OK;


    return hr;
}


//+---------------------------------------------------------------------------
//
// GetIC
//
//----------------------------------------------------------------------------

ITfContext *CSoftkbdIMX::GetIC()
{
    ITfContext *pic = NULL;

    if (!_tim)
    {
       Assert(0);
       return NULL;
    }

    ITfDocumentMgr *pdim;
    if (SUCCEEDED(_tim->GetFocus(&pdim)) && pdim)
    {
        // otherwise grab the top of the stack
        pdim->GetTop(&pic);
        pdim->Release();
    }

    return pic;
}

//+---------------------------------------------------------------------------
//
// _OnOffToggle
//
//----------------------------------------------------------------------------

void CSoftkbdIMX::_OnOffToggle( )
{

    BOOL  fOn = GetSoftKBDOnOff( );

    SetSoftKBDOnOff(!fOn);

    _UpdateUI();
}


//+---------------------------------------------------------------------------
//
// _EditSessionCallback
//
//----------------------------------------------------------------------------

HRESULT CSoftkbdIMX::_InputKeyLabel(TfEditCookie ec, ITfContext *pic, WCHAR  *lpszLabel, UINT  nLabLen)
{
    HRESULT  hr = S_OK;
    ITfRange *pRange, *pSelection;

    if ( pic )
    {
       TF_STATUS ts;
       hr = pic->GetStatus(&ts);
       if ( (S_OK == hr) && (TF_SD_READONLY & ts.dwDynamicFlags) )
       {
           // Readonly Doc, just return here!
           return hr;
       }

       if (GetSelectionSimple(ec, pic, &pSelection) == S_OK)
       {
          if (SUCCEEDED(pSelection->Clone(&pRange)))
          {
              BOOL fInsertOk = FALSE;
              hr = pRange->AdjustForInsert(ec, nLabLen, &fInsertOk);
              if (S_OK == hr && fInsertOk)
              {
                  SetTextAndProperty(&_libTLS, ec, pic, pRange, lpszLabel, nLabLen, _langid, NULL);

                  _MySetSelectionSimple(ec, pic, pRange);
              }

              pRange->Release();
          }

          pSelection->Release();
       }
    }

    return hr;
}


HRESULT CSoftkbdIMX::_EditSessionCallback(TfEditCookie ec, CEditSession *pes)
{
    CSoftkbdIMX *_this;
    HRESULT      hr;


    hr = S_OK;

    switch (pes->_state.u)
    {

     	case ESCB_KEYLABEL :

    		{
    			WCHAR  *lpszLabel;
    			UINT   nLabLen;
    		
                lpszLabel = (WCHAR *)(pes->_state.lParam);

                if ( lpszLabel == NULL )
                {
                   hr = E_FAIL;
                   return hr;
                }

                nLabLen = wcslen(lpszLabel);

                _this = (CSoftkbdIMX *)pes->_state.pv;
                hr = _this->_InputKeyLabel(ec,
    		                          pes->_state.pic,
    				  		          lpszLabel,
    							      nLabLen);

               SafeFreePointer(lpszLabel);

    	       break;
    		}

    	default :
    		   break;
    
    }

    return hr;
}

//
// Show or Hide the soft keyboard window based on current setting.
//

HRESULT  CSoftkbdIMX::_ShowSoftKBDWindow( BOOL  fShow )
{

    HRESULT  hr;

    hr = S_OK;


    if ( fShow && ( _fInitialized == FALSE ) )
    	// call the initialize function 
    	// to get the ISoftKbd.
    {
    	Initialize( );

    }

    if ( _SoftKbd == NULL )
    {
    	hr = E_FAIL;
    	return hr;
    }

    if ( fShow ) {

    	DWORD   dwSoftLayout;

    	if ( _CurKbdType  == KBDTYPE_STANDARD ) 
    	{
    		// Standard soft kbd was selected.
            WORD   prmlangid;

            prmlangid = PRIMARYLANGID(_langid);

            switch ( prmlangid ) {

            case LANG_JAPANESE  :
    			// Lang JPN is activated.
    			// select the standard layout to J 106-k.
    			_KbdStandard.dwSoftKbdLayout = SOFTKBD_JPN_STANDARD;
                break;

            case LANG_AZERI   :
            case LANG_BELARUSIAN :
            case LANG_CHINESE :
            case LANG_KOREAN  :
            case LANG_RUSSIAN :
            case LANG_THAI    :
            case LANG_URDU    :
            case LANG_UZBEK   :
                _KbdStandard.dwSoftKbdLayout = SOFTKBD_US_STANDARD;
                break;

            case LANG_ENGLISH :
                if ( SUBLANGID(_langid) != SUBLANG_ENGLISH_US )
                    _KbdStandard.dwSoftKbdLayout = SOFTKBD_EURO_STANDARD;
                else
                    _KbdStandard.dwSoftKbdLayout = SOFTKBD_US_STANDARD;
                break;

            default           :
                _KbdStandard.dwSoftKbdLayout = SOFTKBD_EURO_STANDARD;
                break;
            }

    		// the current layout is standard layout.
    		// we need to set the correct standard layout id based on current lang profile.

    		dwSoftLayout = _KbdStandard.dwSoftKbdLayout;
    		_CurLayout = dwSoftLayout;

    		CHECKHR(_SoftKbd->SelectSoftKeyboard(dwSoftLayout));
    		CHECKHR(_SoftKbd->SetKeyboardLabelText(GetKeyboardLayout(0)));
    	}
    	else if ( _CurKbdType  == KBDTYPE_SYMBOL)
    	{
    		// This is symbol soft keyboard layout
    		//
    		DWORD   dwCurLabel;
    		dwSoftLayout = _KbdSymbol.dwSoftKbdLayout;
    		dwCurLabel = _KbdSymbol.dwCurLabel;
    		CHECKHR(_SoftKbd->SelectSoftKeyboard(dwSoftLayout));
    		CHECKHR(_SoftKbd->SetKeyboardLabelTextCombination(dwCurLabel));

    	}

    	// TIP is ON, so we need to show soft keyboard.
    	CHECKHR(_SoftKbd->ShowSoftKeyboard(TRUE));
    }
    else
    {
    	// TIP is going to close.
    	// close the soft keyboard window also.
    	CHECKHR(_SoftKbd->ShowSoftKeyboard(FALSE));
    }

CleanUp:

    return  hr;

}


//+---------------------------------------------------------------------------
//
// _CompEventSinkCallback
//
//----------------------------------------------------------------------------

HRESULT CSoftkbdIMX::_CompEventSinkCallback(void *pv, REFGUID rguid)
{
    CSoftkbdIMX *_this = (CSoftkbdIMX *)pv;
    BOOL        fOn;
    HRESULT     hr;


    hr = S_OK;

    if ( IsEqualGUID(rguid, GUID_COMPARTMENT_HANDWRITING_OPENCLOSE)  )
    {

    	fOn = _this->GetSoftKBDOnOff( );
        
    	CHECKHR(_this->_ShowSoftKBDWindow(fOn));

        //
        // Open/Close status was updated, we need to update Langbar button's
        // toggle state.
        //
    	_this->_plbi->UpdateToggle();

    }

    else if ( IsEqualGUID(rguid, GUID_COMPARTMENT_SOFTKBD_KBDLAYOUT) )
    {

    	DWORD   dwSoftLayout;

    	if ( _this->_SoftKbd == NULL )
    	{
    		hr = E_FAIL;
    		return hr;
    	}

    	dwSoftLayout = _this->GetSoftKBDLayout( );


    	_this->_CurLayout = dwSoftLayout;

    	if ( dwSoftLayout == (_this->_KbdStandard).dwSoftKbdLayout )
    	{
    		// this is standard layout.    
    		
    		_this->_CurKbdType  = KBDTYPE_STANDARD;

    		CHECKHR(_this->_SoftKbd->SelectSoftKeyboard(dwSoftLayout));

            CHECKHR(_this->_SoftKbd->SetKeyboardLabelText(GetKeyboardLayout(0)));

    	}
    	else if ( dwSoftLayout == (_this->_KbdSymbol).dwSoftKbdLayout )
    	{
    		// this is symbol layout.

    		DWORD   dwCurLabel;

    		_this->_CurKbdType  = KBDTYPE_SYMBOL;

    		dwCurLabel = (_this->_KbdSymbol).dwCurLabel;
           
    		CHECKHR(_this->_SoftKbd->SelectSoftKeyboard(dwSoftLayout));

    		CHECKHR(_this->_SoftKbd->SetKeyboardLabelTextCombination(dwCurLabel));

    	}

    	if ( _this->GetSoftKBDOnOff( ) ) 
    		CHECKHR(_this->_SoftKbd->ShowSoftKeyboard(TRUE));


    }

    _this->_UpdateUI();

CleanUp:
    return hr;
}

//+---------------------------------------------------------------------------
//
// _UpdateUI
//
//----------------------------------------------------------------------------

void CSoftkbdIMX::_UpdateUI()
{

}


//+---------------------------------------------------------------------------
//
// _MySetSelectionSimple
//
//----------------------------------------------------------------------------

HRESULT CSoftkbdIMX::_MySetSelectionSimple(TfEditCookie ec, ITfContext *pic, ITfRange *range)
{
    TF_SELECTION sel;

    sel.range = range;
    sel.style.ase = TF_AE_NONE;
    sel.style.fInterimChar = FALSE;

    range->Collapse(ec, TF_ANCHOR_END);

    return pic->SetSelection(ec, 1, &sel);
}

HRESULT CSoftkbdIMX::_LsCallback(BOOL fChanged, LANGID langid, BOOL *pfAccept, void *pv)
{
    HRESULT hr = S_OK;
    GUID   guidProfile;
    LANGID lang;

    TraceMsg(TF_GENERAL, "CSoftkbdIMX::_LsCallback is called, langid=%x fChanged=%d", langid, fChanged);

    CSoftkbdIMX *_this = (CSoftkbdIMX *)pv;

    if (!fChanged)
    {
        if ( pfAccept )
            *pfAccept = TRUE;
        return hr;
    }
  
    hr = _this->_pProfile->GetActiveLanguageProfile(CLSID_SoftkbdIMX, &lang, &guidProfile);

    if ( hr == S_OK )
    {
        _this->_langid = lang;

        if ( IsEqualGUID(guidProfile, c_guidProfile) ) 
        {
            // Standard soft kbd is selected.
            TraceMsg(TF_GENERAL, "Standard Softkbd is selected");
            _this->_CurKbdType  = KBDTYPE_STANDARD;
        }
        else if ( IsEqualGUID(guidProfile, c_guidProfileSym) )
        {
            // This is symbol soft keyboard layout
            //
            TraceMsg(TF_GENERAL, "Symbol Softkbd is selected");
            _this->_CurKbdType  = KBDTYPE_SYMBOL;
        }

        if ( (_this->GetSoftKBDOnOff( ) == TRUE) )
            _this->_ShowSoftKBDWindow(TRUE);   
    }

    return hr;
}


HRESULT CSoftkbdIMX::_AlsCallback(REFCLSID clsid, REFGUID guidProfile, BOOL fActivated, void *pv)
{

    HRESULT   hr;
    ITfInputProcessorProfiles  *pProfile = NULL;

    hr = S_OK;

    CSoftkbdIMX *_this = (CSoftkbdIMX *)pv;


    // if this is not for SoftKbdIMX  TIP,
    // we just ignore it.

    if (IsEqualGUID(clsid, CLSID_SoftkbdIMX))
    {
        // if this is not for our registered profile guid, just ignore it.
    
        if ( !IsEqualGUID(guidProfile, c_guidProfile) && !IsEqualGUID(guidProfile, c_guidProfileSym) )
            return hr;

        TraceMsg(TF_GENERAL, "CSoftkbdIMX::_AlsCallback is called for this tip fActivated=%d", fActivated);

        if ( fActivated == FALSE ) 
        {
            if ( _this->GetSoftKBDOnOff( ) )
            {
    	        if ( _this->_SoftKbd != NULL )
    		        (_this->_SoftKbd)->ShowSoftKeyboard(FALSE);
            }
            return hr;
        }

        if ( IsEqualGUID(guidProfile, c_guidProfile) ) 
        {
    	    // Standard soft kbd is selected.

            TraceMsg(TF_GENERAL, "Standard Softkbd is selected");

    	    _this->_CurKbdType  = KBDTYPE_STANDARD;

        }

        else if ( IsEqualGUID(guidProfile, c_guidProfileSym) )
        {
    	    // This is symbol soft keyboard layout
    	    //

            TraceMsg(TF_GENERAL, "Symbol Softkbd is selected");
    	    _this->_CurKbdType  = KBDTYPE_SYMBOL;

        }

        if ( (_this->GetSoftKBDOnOff( ) == TRUE) )
    	    _this->_ShowSoftKBDWindow(TRUE);   
    }
    else  if (IsEqualGUID(clsid, GUID_NULL))
    {
        // This is keyboard layout change without language change.
        if ( _this->GetSoftKBDOnOff( ) && fActivated)
        {
  	        _this->_ShowSoftKBDWindow(fActivated);
        }
    }
  
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\softkbd\softkbdc.cpp ===
/**************************************************************************\
* Module Name: softkbdc.cpp
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
* Implementation of interface ISoftKbd 
*
* History:
*         28-March-2000  weibz     Created
\**************************************************************************/

#include "private.h"
#include "globals.h"
#include "SoftKbdc.h"

#include "softkbdui.h"

#define   MAX_LABEL_LEN  20

/*******************************************************************************
 *
 * WstrToInt(  )                                        
 *
 * A utility function to convert a string to integer.
 *
/********************************************************************************/

WORD  WstrToInt(WCHAR  *wszStr)
{

   int  ret, i;

   if ( wszStr == NULL )
       return 0;

   ret = 0;
   i = 0;

   while ( wszStr[i] != L'\0' ) 
   {

       if ( (wszStr[i] < L'0') || (wszStr[i] > L'9') )
       {
    	   // this is not a legal string.
    	   // just return back 0.

    	   return 0;

       }
   
       ret = ret * 10 + (wszStr[i] - L'0');
       i++;
   }

   return (WORD)ret;
}

/*******************************************************************************
 *
 * Constructor function:                                         
 *
 * Initialize necessary data fields.
 *
/********************************************************************************/

CSoftKbd::CSoftKbd(  )
{

    
     _lpCurKbdLayout = NULL;
    _lpKbdLayoutDesList = NULL;
    _wCurKbdLayoutID = NON_KEYBOARD;

    _pSoftkbdUIWnd = NULL;
    _hOwner = NULL;

    _xReal = _yReal = _widthReal = _heightReal = 0;

    _pDoc = NULL;

    _pskbdwndes = NULL;
    _TitleBar_Type = TITLEBAR_NONE;

    _plfTextFont = NULL;
}

/*******************************************************************************
 *
 * Destructor                                        
 *
 * Free all allocated memories.
 *
/********************************************************************************/

CSoftKbd::~CSoftKbd( )
{
    KBDLAYOUTDES  *lpKbdLayoutDes;
    KBDLAYOUTDES  *lpLayoutDesTmp;
    KEYMAP        *lpKeyMapList;
    int            i, iState;

    SafeRelease(_pDoc);

    //
    //
    // Free Memory for soft keyboard layouts , and Label Text Mapping List
    //
    //

    lpKbdLayoutDes = _lpKbdLayoutDesList;

    while ( lpKbdLayoutDes != NULL ) 
    {

       KEYMAP        *lpKeyMapListTmp;

       lpKeyMapList = lpKbdLayoutDes->lpKeyMapList;

       while ( lpKeyMapList != NULL ) 
       {

          for ( i=0; i<(int)(lpKeyMapList->wNumOfKeys); i++) 
          {

    	     // free lppLabelText string for each state.
    	     for ( iState=0; iState < lpKeyMapList->lpKeyLabels[i].wNumModComb; iState++)
    	     {
                if (lpKeyMapList->lpKeyLabels[i].lppLabelText[iState])
                  SysFreeString(lpKeyMapList->lpKeyLabels[i].lppLabelText[iState]);
    	     }

    	     SafeFreePointer(lpKeyMapList->lpKeyLabels[i].lppLabelText);

    	     SafeFreePointer(lpKeyMapList->lpKeyLabels[i].lpLabelType);

             SafeFreePointer(lpKeyMapList->lpKeyLabels[i].lpLabelDisp);

          }
   
          lpKeyMapListTmp = lpKeyMapList;

          lpKeyMapList = lpKeyMapList->pNext;

          SafeFreePointer(lpKeyMapListTmp);
       }
 
       lpLayoutDesTmp = lpKbdLayoutDes; 

       lpKbdLayoutDes = lpKbdLayoutDes->pNext;
   
       SafeFreePointer(lpLayoutDesTmp);
       
    }

    if ( _plfTextFont )
        SafeFreePointer(_plfTextFont);

    // Destroy the window if the window is still active.

    if ( _pSoftkbdUIWnd != NULL )
    {

    	DestroySoftKeyboardWindow( );
    	_pSoftkbdUIWnd = NULL;
    }
}


/*******************************************************************************
 *
 * Method function:  _LoadDocumentSync(  )                                        
 *
 * Load an XML Document from the specified file or URL synchronously.
 *
 *
 *   fFileName is TRUE, means pBURL contains XML file path.
 *   fFilename is FALSE, means pBURL contains real XML content 
 *
/********************************************************************************/

HRESULT CSoftKbd::_LoadDocumentSync(BSTR pBURL, BOOL fFileName)
{
    IXMLDOMParseError  *pXMLError = NULL;
    LONG            errorCode = E_FAIL;
    VARIANT         vURL;
    VARIANT_BOOL    vb;
    HRESULT         hr;


    if ( _pDoc == NULL ) {

    	return E_FAIL;
    }


    CHECKHR(_pDoc->put_async(VARIANT_FALSE));

    // Load xml document from the given URL or file path
    vURL.vt = VT_BSTR;
    V_BSTR(&vURL) = pBURL;

    if ( fFileName == TRUE )
    {
       CHECKHR(_pDoc->load(vURL, &vb));
    }
    else
    {
       CHECKHR(_pDoc->loadXML(pBURL, &vb) );
    }

    CHECKHR(_pDoc->get_parseError(&pXMLError));
    CHECKHR(pXMLError->get_errorCode(&errorCode));

    if (errorCode != 0)
    {

        hr = E_FAIL;
    }
                    
CleanUp:
    SafeReleaseClear(pXMLError);
   
    return hr;
}

/*******************************************************************************
 *
 * Method function:  Initialize(  )                                        
 *
 * Initialize all necessary field for this class object.
 * Generate Standard soft keyboard layouts.
 *
/********************************************************************************/

STDMETHODIMP CSoftKbd::Initialize()
{

    // initialize standard layouts

    HRESULT             hr = S_OK;
    COLORTYPE           crType;

    // Initialize the different types of colors.
    // Following types of colors are supported.

    // bkcolor = 0 , for the window's back ground color
    // UnSelForeColor = 1, 
    // UnSelTextColor = 2,
    // SelForeColor =   3,
    // SelTextColor =   4

    crType = bkcolor;
    _color[crType] = GetSysColor(COLOR_MENU);

    crType = UnSelForeColor;
     _color[crType] = GetSysColor(COLOR_MENU);

    crType = UnSelTextColor;
    _color[crType] = GetSysColor(COLOR_WINDOWTEXT);

    crType = SelForeColor;
    _color[crType] = GetSysColor(COLOR_MENU);

    crType = SelTextColor;
    _color[crType] = GetSysColor(COLOR_WINDOWTEXT);

    CHECKHR(_CreateStandardSoftKbdLayout(SOFTKBD_US_STANDARD, L"IDSKD_STDUS101"));
    CHECKHR(_CreateStandardSoftKbdLayout(SOFTKBD_EURO_STANDARD, L"IDSKD_STDEURO102"));
    CHECKHR(_CreateStandardSoftKbdLayout(SOFTKBD_JPN_STANDARD, L"IDSKD_STDJPN106"));

CleanUp:

    return hr;
}


/*******************************************************************************
 *
 * Method function:  _CreateStandardSoftKbdLayout(  )                                        
 *
 * Create standard soft keyboard layout.
 *
 *    dwStdSoftKbdID,  predefined Standard soft keyboard layout ID.
 *
 *    wszStdResStr :   Resource ID string for the created standard soft keyboard.
 *
/********************************************************************************/

HRESULT CSoftKbd::_CreateStandardSoftKbdLayout(DWORD  dwStdSoftKbdID, WCHAR  *wszStdResStr )
{

    KBDLAYOUTDES        *pKbdLayout;
    BYTE                *lpszKeyboardDes;
    WCHAR               wszModuleFile[MAX_PATH];
    CHAR                szModuleFile[MAX_PATH];
    CHAR                szStdResStr[MAX_PATH];  // Ansi name of the Res Str ID
    WCHAR               wszInternalDesFileName[MAX_PATH];
    HRESULT             hr = S_OK;

    HGLOBAL             hResData = NULL;
    HRSRC               hRsRc = NULL;

    DWORD               dwFileLen;
    DWORD               dwResLen;

    dwFileLen = GetModuleFileNameA(g_hInst, szModuleFile, MAX_PATH);

    if ( dwFileLen == 0 )
    {
       hr = E_FAIL;
       return hr;
    } 

    MultiByteToWideChar(CP_ACP, 0, szModuleFile, -1,
    	                wszModuleFile, MAX_PATH);

    WideCharToMultiByte(CP_ACP, 0, wszStdResStr, -1, 
    	                szStdResStr, MAX_PATH, NULL, NULL );

    hRsRc = FindResourceA(g_hInst,szStdResStr, "SKDFILE" );

    if ( hRsRc == NULL )  return E_FAIL;

    dwResLen = SizeofResource(g_hInst, hRsRc);
    hResData =  LoadResource(g_hInst, hRsRc);

    if ( hResData == NULL ) return E_FAIL;

    lpszKeyboardDes = (BYTE  *)LockResource(hResData);

    if ( lpszKeyboardDes == NULL ) return E_FAIL;

    CHECKHR(_GenerateKeyboardLayoutFromSKD(lpszKeyboardDes, dwStdSoftKbdID, &pKbdLayout));

    // Change the internal DesFile name as following format:
    //
    //  SKDFILE: ResFileName : KBDResString to identify this layout's des file.
    //
    StringCchCopyW( wszInternalDesFileName, ARRAYSIZE(wszInternalDesFileName), L"SKDFILE:");
    StringCchCatW( wszInternalDesFileName, ARRAYSIZE(wszInternalDesFileName), wszModuleFile);
    StringCchCatW( wszInternalDesFileName, ARRAYSIZE(wszInternalDesFileName), L":");
    StringCchCatW( wszInternalDesFileName, ARRAYSIZE(wszInternalDesFileName), wszStdResStr );

    StringCchCopyW(pKbdLayout->KbdLayoutDesFile, ARRAYSIZE(pKbdLayout->KbdLayoutDesFile), wszInternalDesFileName);

    // link this new layout to the list.
    if ( _lpKbdLayoutDesList == NULL ) {

    	_lpKbdLayoutDesList = pKbdLayout;
    	pKbdLayout->pNext = NULL;

    }
    else
    {
    	pKbdLayout->pNext  = _lpKbdLayoutDesList;
    	_lpKbdLayoutDesList = pKbdLayout;
    }

CleanUp:

    return hr;
}

/*******************************************************************************
 *
 * Method function:  EnumSoftKeyBoard(  )                                        
 *
 * Enumerate all possible soft keybaord layouts.
 *
/********************************************************************************/


STDMETHODIMP CSoftKbd::EnumSoftKeyBoard(LANGID langid, DWORD *lpdwKeyboard)
{
    

/*    The return value could be  one of following:

      SOFTKBD_US_STANDARD
      SOFTKBD_US_ENHANCE
      SOFTKBD_EURO_STANDARD
      SOFTKBD_EURO_ENHANCE
      SOFTKBD_JPN_STANDARD
      SOFTKBD_JPN_ENHANCE

      Any customized soft keyboard layout

      SOFTKBD_NO_MORE.

*/


    return S_OK;
}

/*******************************************************************************
 *
 * Method function:  _GetXMLNodeValueWORD(  )                                        
 *
 * Get the WORD value for the specified Node.
 *
 *
/********************************************************************************/

HRESULT  CSoftKbd::_GetXMLNodeValueWORD(IXMLDOMNode *pNode,  WORD  *lpWord)
{

    HRESULT      hr = S_OK;
    IXMLDOMNode  *pValueChild = NULL;
    VARIANT      value;

    if ( (pNode == NULL) || (lpWord == NULL) )
    {
    	hr = E_FAIL;
    	return hr;
    }


    CHECKHR(pNode->get_firstChild(&pValueChild));
    CHECKHR(pValueChild->get_nodeValue(&value));
    *lpWord = (WORD)WstrToInt(V_BSTR(&value));
    VariantClear(&value);

CleanUp:
    SafeRelease(pValueChild);
    return hr;

}


/*******************************************************************************
 *
 * Method function:  _ParseOneKeyInLayout(  )                                        
 *
 * Parse One Key in Layout Description, fill the data structure for
 * the specified key.
 *
 *
/********************************************************************************/

HRESULT  CSoftKbd::_ParseOneKeyInLayout(IXMLDOMNode *pNode, KEYDES  *lpKeyDes)
{


    HRESULT             hr;
    IXMLDOMNode         *pAttrChild = NULL, *pKey = NULL, *pKeyNext = NULL;
    BSTR                nodeName=NULL;
    IXMLDOMNamedNodeMap *pattrs=NULL;
    BSTR                name=NULL;
    VARIANT             value;
    IXMLDOMNode         *pValueChild=NULL;


    hr = S_OK;

    if ( (lpKeyDes == NULL)  || (pNode == NULL) )
    {
    	hr = E_FAIL;
    	return hr;
    }

              
    if (SUCCEEDED(pNode->get_attributes(&pattrs)) && pattrs != NULL)
    {
        CHECKHR(pattrs->nextNode(&pAttrChild));

        while (pAttrChild)
    	{

          CHECKHR(pAttrChild->get_nodeName(&name));
          if ( wcscmp(name, xMODIFIER ) == 0 )
    	  {

    		CHECKHR(pAttrChild->get_nodeValue(&value));
            if (value.vt == VT_BSTR)
    		{
               if ( wcscmp(V_BSTR(&value), xNONE) == 0 )
                  lpKeyDes->tModifier = none;
    		   else if ( wcscmp(V_BSTR(&value), xCAPSLOCK) == 0 )
                  lpKeyDes->tModifier = CapsLock;
    		   else if ( wcscmp(V_BSTR(&value), xSHIFT) == 0 )
                  lpKeyDes->tModifier = Shift;
    		   else if ( wcscmp(V_BSTR(&value),xCTRL ) == 0 )
                  lpKeyDes->tModifier = Ctrl;
    		   else if ( wcscmp(V_BSTR(&value), xATL) == 0 )
                  lpKeyDes->tModifier = Alt;
               else if ( wcscmp(V_BSTR(&value), xALTGR) == 0 )
                  lpKeyDes->tModifier = AltGr;
    		   else if ( wcscmp(V_BSTR(&value), xKANA) == 0 )
                  lpKeyDes->tModifier = Kana;
    		   else if ( wcscmp(V_BSTR(&value), xNUMLOCK) == 0 )
                  lpKeyDes->tModifier = NumLock;
    		   else 
    		      lpKeyDes->tModifier = none;

    		}

            VariantClear(&value);
    	  }

    	  if ( name != NULL)
             SysFreeString(name);
          SafeReleaseClear(pAttrChild);
          CHECKHR(pattrs->nextNode(&pAttrChild));
    	}
        SafeReleaseClear(pattrs);
    }

    CHECKHR(pNode->get_firstChild(&pKey));

    while ( pKey ) 
    {
      CHECKHR(pKey->get_nodeName(&nodeName));
      CHECKHR(pKey->get_firstChild(&pValueChild));
      CHECKHR(pValueChild->get_nodeValue(&value));
      if ( wcscmp(nodeName, xKEYID ) == 0 )
      {
         lpKeyDes->keyId = WstrToInt(V_BSTR(&value));
      }
      else if ( wcscmp(nodeName,xLEFT ) == 0 )
      {
    	 lpKeyDes->wLeft = (WORD)WstrToInt(V_BSTR(&value));
      }
      else if ( wcscmp(nodeName, xTOP) == 0 )
      {
         lpKeyDes->wTop = WstrToInt(V_BSTR(&value));
      }
      else if ( wcscmp(nodeName, xWIDTH) == 0 ) 
      {
         lpKeyDes->wWidth = WstrToInt(V_BSTR(&value));
      }
      else if ( wcscmp(nodeName, xHEIGHT) == 0 ) 
      {
         lpKeyDes->wHeight = WstrToInt(V_BSTR(&value));
      }

      VariantClear(&value);
      SafeReleaseClear(pValueChild);
    		
      if ( nodeName != NULL )   
      {
        SysFreeString(nodeName);
    	nodeName = NULL;
      }

      CHECKHR(pKey->get_nextSibling(&pKeyNext));
      SafeReleaseClear(pKey);
      pKey = pKeyNext;
    }


CleanUp:

    if ( FAILED(hr) )
    {
    	if ( nodeName != NULL )
    	{
    		SysFreeString(nodeName);
    		nodeName = NULL;
    	}

    	if ( pValueChild )
    		SafeReleaseClear(pValueChild);

    	if ( pKey )
    		SafeReleaseClear(pKey);
    }

    return hr;

}



/*******************************************************************************
 *
 * Method function:  _ParseLayoutDescription(  )                                        
 *
 * Parse Layout description part in the XML file, and fill the internal
 * Layout data structure.
 *
/********************************************************************************/

HRESULT  CSoftKbd::_ParseLayoutDescription(IXMLDOMNode *pLayoutChild,  KBDLAYOUT *pLayout)
{

    HRESULT   hr = S_OK;

    IXMLDOMNode         *pNode = NULL;
    IXMLDOMNode         *pChild = NULL, *pNext = NULL, *pAttrChild=NULL;

    BSTR                nodeName=NULL;
    IXMLDOMNamedNodeMap *pattrs=NULL;

    BSTR                name=NULL;
    VARIANT             value;
    int                 iKey;
    BSTR                pBURL = NULL;

    if ( (pLayoutChild == NULL) || (pLayout == NULL ) )
    {
    	hr = E_FAIL;
    	return hr;
    }

    iKey = 0;

    // Parse layout part.

    if (SUCCEEDED(pLayoutChild->get_attributes(&pattrs)) && pattrs != NULL)
    {
        //
    	//  Get the softkbe type attribute
    	//
        CHECKHR(pattrs->nextNode(&pAttrChild));
        while (pAttrChild)
    	{

          CHECKHR(pAttrChild->get_nodeName(&name));
          if ( wcscmp(name, xSOFTKBDTYPE)  ) 
    	  {
    		// this is not the right attribute.
    		  if ( name != NULL)
    		  {
                 SysFreeString(name);
    			 name = NULL;
    		  }

              SafeReleaseClear(pAttrChild);
              CHECKHR(pattrs->nextNode(&pAttrChild));
    		  continue;
    	  }

    	  if ( name != NULL)
    	  {
    	     SysFreeString(name);
    		 name = NULL;
    	  }

          CHECKHR(pAttrChild->get_nodeValue(&value));
          if (value.vt == VT_BSTR)
    	  {
             if ( wcscmp(V_BSTR(&value), xTCUSTOMIZED) == 0 )
                 pLayout->fStandard = FALSE;
    		 else
    			 pLayout->fStandard = TRUE;
    	  }

          VariantClear(&value);
    	  break;

    	}
        SafeReleaseClear(pattrs);
    }

    CHECKHR(pLayoutChild->get_firstChild(&pChild));

    pLayout->wLeft = 0;
    pLayout->wTop = 0;

    while ( pChild ) 
    {


       CHECKHR(pChild->get_nodeName(&nodeName));

       if ( wcscmp(nodeName, xWIDTH) == 0 )
       {

    	   CHECKHR(_GetXMLNodeValueWORD(pChild, &(pLayout->wWidth) ));

       }
       else if ( wcscmp(nodeName, xHEIGHT) == 0 )
       {
    	   CHECKHR(_GetXMLNodeValueWORD(pChild, &(pLayout->wHeight) ));

       }
       else if ( wcscmp(nodeName, xMARGIN_WIDTH) == 0 )
       {
    	   CHECKHR(_GetXMLNodeValueWORD(pChild, &(pLayout->wMarginWidth )));
       }
       else if ( wcscmp(nodeName, xMARGIN_HEIGHT) == 0 ) 
       {

    	   CHECKHR(_GetXMLNodeValueWORD(pChild, &(pLayout->wMarginHeight) ));

       }
       else if ( wcscmp(nodeName, xKEYNUMBER) == 0 )
       {
    	   CHECKHR(_GetXMLNodeValueWORD(pChild, &(pLayout->wNumberOfKeys) ));

       }
       else if ( wcscmp(nodeName, xKEY) == 0 )
       {
    	   KEYDES   *pKeyDes;

    	   pKeyDes = &(pLayout->lpKeyDes[iKey]);
           CHECKHR(_ParseOneKeyInLayout(pChild, pKeyDes) );
    	   iKey++;
       }

       if (nodeName != NULL)
       {
          SysFreeString(nodeName);
    	  nodeName = NULL;
       }

    	CHECKHR(pChild->get_nextSibling(&pNext));
        SafeReleaseClear(pChild);
        pChild = pNext;
    }


CleanUp:

    if ( FAILED(hr) )
    {
    	if (nodeName != NULL )
    	{
    		SysFreeString(nodeName);
    		nodeName = NULL;
    	}

    	if ( pChild )
    		SafeReleaseClear(pChild);
    }

    return hr;

}


/*******************************************************************************
 *
 * Method function:  _ParseOneKeyInLabel(  )                                        
 *
 * Parse One Key in Label Description, fill the data structure for
 * the specified key
 *
 *
/********************************************************************************/

HRESULT  CSoftKbd::_ParseOneKeyInLabel(IXMLDOMNode *pNode, KEYLABELS  *lpKeyLabels)
{

  IXMLDOMNode         *pValueChild = NULL;
  HRESULT             hr = S_OK;
  IXMLDOMNode         *pAttrChild = NULL, *pKey=NULL, *pKeyNext=NULL;
  BSTR                nodeName=NULL;
  IXMLDOMNamedNodeMap *pattrs=NULL;

  BSTR                name=NULL;
  VARIANT             value;
  
  int  iState;
  iState = 0;

  if ( (pNode == NULL) || (lpKeyLabels == NULL) )
  {
      hr = E_FAIL;
      return hr;
  }

  CHECKHR(pNode->get_firstChild(&pKey));

  while ( pKey ) 
  {
      CHECKHR(pKey->get_nodeName(&nodeName));
      CHECKHR(pKey->get_firstChild(&pValueChild));
      CHECKHR(pValueChild->get_nodeValue(&value));

      if ( wcscmp(nodeName, xKEYID) == 0 )
      {
         lpKeyLabels->keyId = WstrToInt(V_BSTR(&value));
      }
      else if ( wcscmp(nodeName, xVALIDSTATES) == 0 )
      {
    	 lpKeyLabels->wNumModComb = WstrToInt(V_BSTR(&value));
     	 lpKeyLabels->lppLabelText = (BSTR *)cicMemAllocClear( 
    		                          lpKeyLabels->wNumModComb * sizeof(BSTR) );


    	 if ( lpKeyLabels->lppLabelText == NULL )
    	 {
    		 // Not enough memory.
             // release all allocated memory.
    		 
    		 hr = E_OUTOFMEMORY;
    		 goto CleanUp;
    	 }
    				 

    	 lpKeyLabels->lpLabelType = (WORD *)cicMemAllocClear(
    		              lpKeyLabels->wNumModComb * sizeof(WORD) );

    	 if ( lpKeyLabels->lpLabelType == NULL )
    	 {
    		 // Not enough memory.
             // release all allocated memory.
     	     
    		 hr = E_OUTOFMEMORY;
    		 goto CleanUp;

    	 }

    	 lpKeyLabels->lpLabelDisp = (WORD *)cicMemAllocClear(
    		              lpKeyLabels->wNumModComb * sizeof(WORD) );

    	 if ( lpKeyLabels->lpLabelDisp == NULL )
    	 {
    		 // Not enough memory.
             // release all allocated memory.
     	     
    		 hr = E_OUTOFMEMORY;
    		 goto CleanUp;

    	 }


      }
      else if ( wcscmp(nodeName, xLABELTEXT) == 0 ) 
      {
    	  if ( iState < lpKeyLabels->wNumModComb )
    	  {
    	     lpKeyLabels->lppLabelText[iState]=SysAllocString(V_BSTR(&value));

             // set the default value for label type and label disp attribute.

             lpKeyLabels->lpLabelType[iState] = LABEL_TEXT;
             lpKeyLabels->lpLabelDisp[iState] = LABEL_DISP_ACTIVE;

    		 // Get the label type:  Text or Picture.
    		 // if it is picture, the above string stands for path of bitmap file.

    		 if (SUCCEEDED(pKey->get_attributes(&pattrs)) && pattrs != NULL)
    		 {
                CHECKHR(pattrs->nextNode(&pAttrChild));
                while (pAttrChild)
    			{

                   CHECKHR(pAttrChild->get_nodeName(&name));
                   if ( wcscmp(name, xLABELTYPE) == 0 ) 
    			   {

                       CHECKHR(pAttrChild->get_nodeValue(&value));
                      if (value.vt == VT_BSTR)
                      {
                         if ( wcscmp(V_BSTR(&value),xTEXT ) == 0 )
                            lpKeyLabels->lpLabelType[iState] = LABEL_TEXT;
                         else
    	                    lpKeyLabels->lpLabelType[iState] = LABEL_PICTURE;
                      }

    			      VariantClear(&value);
    	              
                   }
                   else if ( wcscmp(name, xLABELDISP) == 0 ) 
    			   {

                      CHECKHR(pAttrChild->get_nodeValue(&value));
                      if (value.vt == VT_BSTR)
                      {
                         if ( wcscmp(V_BSTR(&value),xGRAY ) == 0 )
                            lpKeyLabels->lpLabelDisp[iState] = LABEL_DISP_GRAY;
                         else
    	                    lpKeyLabels->lpLabelDisp[iState] = LABEL_DISP_ACTIVE;
                      }

    			      VariantClear(&value);
    	              
                   }

                   if ( name != NULL)
    			   {
                      SysFreeString(name);
    			      name = NULL;
    			   }

                   SafeReleaseClear(pAttrChild);
                   CHECKHR(pattrs->nextNode(&pAttrChild));

    			}
                SafeReleaseClear(pattrs);
    		}

    	  }

    	  iState++;

    	
      }

      VariantClear(&value);
      SafeReleaseClear(pValueChild);
    			             
      if ( nodeName != NULL)
      {
         SysFreeString(nodeName);
    	 nodeName = NULL;
      }

      CHECKHR(pKey->get_nextSibling(&pKeyNext));
      SafeRelease(pKey);
      pKey = pKeyNext;
  }

CleanUp:

  if ( FAILED(hr) )
  {

      if ( pKey )
    	  SafeReleaseClear(pKey);

      if ( name != NULL)
      {
         SysFreeString(name);
    	 name = NULL;
      }

      if ( pAttrChild )
    	  SafeReleaseClear(pAttrChild);

      if ( pValueChild )
    	  SafeReleaseClear(pValueChild);

      if ( lpKeyLabels->lppLabelText != NULL )
      {

          while ( iState >= 0 )
    	  {

    		  if ( lpKeyLabels->lppLabelText[iState] )
    		  {
    			  SysFreeString(lpKeyLabels->lppLabelText[iState]);
                  lpKeyLabels->lppLabelText[iState] = NULL;
    		  }

    		  iState --;

    	  }

    	  SafeFreePointer(lpKeyLabels->lppLabelText);
      }


      if ( lpKeyLabels->lpLabelType != NULL )
      {
    	  SafeFreePointer(lpKeyLabels->lpLabelType);
      }

      if ( lpKeyLabels->lpLabelDisp != NULL )
      {
    	  SafeFreePointer(lpKeyLabels->lpLabelDisp);
      }


  }

  return hr;

}


/*******************************************************************************
 *
 * Method function:  _ParseMappingDescription(  )                                        
 *
 * Parse Mapping description part in the XML file, and fill the internal
 * Mapping Table structure.
 *
/********************************************************************************/

HRESULT CSoftKbd::_ParseMappingDescription( IXMLDOMNode *pLabelChild, KEYMAP *lpKeyMapList )
{

    HRESULT             hr = S_OK;
    IXMLDOMNode         *pChild=NULL, *pNext=NULL;
    BSTR                nodeName=NULL;
    int                 iKey;
    BSTR                pBURL = NULL;


    // Parse for customized layout

    if ( (pLabelChild == NULL) || (lpKeyMapList == NULL) )
    {
    	hr = E_FAIL;
    	return hr;
    }
    	
    iKey = 0;

    CHECKHR(pLabelChild->get_firstChild(&pChild));

    while ( pChild ) 
    {

      CHECKHR(pChild->get_nodeName(&nodeName));

      if ( wcscmp(nodeName, xVALIDSTATES) == 0 )
      {
         CHECKHR(_GetXMLNodeValueWORD(pChild, &(lpKeyMapList->wNumModComb) ));
      }
      else if ( wcscmp(nodeName, xKEYNUMBER) == 0 )
      {

          CHECKHR(_GetXMLNodeValueWORD(pChild, &(lpKeyMapList->wNumOfKeys) ));

      }
      else if ( wcscmp(nodeName, xRESOURCEFILE) == 0 )
      {

            IXMLDOMNode  *pValueChild;
          VARIANT      value;

          CHECKHR(pChild->get_firstChild(&pValueChild));
          if ( FAILED((pValueChild->get_nodeValue(&value))))
    	  {
    		  SafeRelease(pValueChild);
    		  goto CleanUp;
    	  }

          StringCchCopyW(lpKeyMapList->wszResource, ARRAYSIZE(lpKeyMapList->wszResource), V_BSTR(&value) );
          VariantClear(&value);

          SafeRelease(pValueChild);

      }
      else if ( wcscmp(nodeName, xKEYLABEL) == 0 )
      {

    	  KEYLABELS  *lpKeyLabels;

    	  lpKeyLabels = &(lpKeyMapList->lpKeyLabels[iKey]);

    	  CHECKHR(_ParseOneKeyInLabel(pChild, lpKeyLabels));

    	  iKey++;
      }

      if ( nodeName != NULL)
      {
         SysFreeString(nodeName);
    	 nodeName = NULL;
      }

      pChild->get_nextSibling(&pNext);
      SafeReleaseClear(pChild);
      pChild = pNext;
    }



CleanUp:

    if ( FAILED(hr) )
    {

      if ( nodeName != NULL)
      {
         SysFreeString(nodeName);
    	 nodeName = NULL;
      }
      
      if ( pChild != NULL )
    	  SafeReleaseClear(pChild);

      if ( lpKeyMapList ) {

    	  int i, iState;

          for ( i=0; i<(int)(lpKeyMapList->wNumOfKeys); i++) 
    	  {

    	    // free lppLabelText string for each state.
    	    for ( iState=0; iState < lpKeyMapList->lpKeyLabels[i].wNumModComb; iState++)
    		{
               if (lpKeyMapList->lpKeyLabels[i].lppLabelText[iState])
                  SysFreeString(lpKeyMapList->lpKeyLabels[i].lppLabelText[iState]);
    		}

    	    SafeFreePointer(lpKeyMapList->lpKeyLabels[i].lppLabelText);

    	    SafeFreePointer(lpKeyMapList->lpKeyLabels[i].lpLabelType);

    	    SafeFreePointer(lpKeyMapList->lpKeyLabels[i].lpLabelDisp);

    	  }

      }


    }

    return hr;

}


/*******************************************************************************
 *
 * Method function:  _GenerateMapDesFromSKD(  )                                        
 *
 * Generate Mapping description part in the KBD file, and fill the internal
 * Mapping Table structure.
 *
/********************************************************************************/

HRESULT CSoftKbd::_GenerateMapDesFromSKD(BYTE *pMapTable, KEYMAP *lpKeyMapList)
{
    HRESULT    hr = S_OK;
    int        iKey;
	WORD       wNumModComb;
	WORD       wNumOfKeys;
	WORD       *pMapPtr;


    // Parse for customized layout
	// Customized layout doesn't care about HKL, so there will be only one KeyMapList per layout.

    if ( (pMapTable == NULL) || (lpKeyMapList == NULL) )  return E_FAIL;

	pMapPtr = (WORD *)pMapTable;

	wNumModComb = pMapPtr[0];
	wNumOfKeys =  pMapPtr[1];

	pMapPtr += 2;
	lpKeyMapList->wNumModComb = wNumModComb;
	lpKeyMapList->wNumOfKeys = wNumOfKeys;

	StringCchCopyW(lpKeyMapList->wszResource, ARRAYSIZE(lpKeyMapList->wszResource), (WCHAR *)pMapPtr);

	pMapPtr += wcslen((WCHAR *)pMapPtr) + 1;  // Plus NULL terminator

	// Now strat to fill every Keylabel.

	for ( iKey=0; iKey<wNumOfKeys; iKey++)
	{

		KEYLABELS  *lpKeyLabel;
		WORD        wNumModInKey;
		int         jMod;

		lpKeyLabel = &(lpKeyMapList->lpKeyLabels[iKey]);

		lpKeyLabel->keyId = *pMapPtr;
		pMapPtr += sizeof(KEYID)/sizeof(WORD);

		wNumModInKey = *pMapPtr;
		pMapPtr++;
		lpKeyLabel->wNumModComb = wNumModInKey;

     	lpKeyLabel->lppLabelText=(BSTR *)cicMemAllocClear(lpKeyLabel->wNumModComb * sizeof(BSTR) );
    	if ( lpKeyLabel->lppLabelText == NULL )
    	{
   			// Not enough memory.
            // release all allocated memory.
    	
	   		 hr = E_OUTOFMEMORY;
			 goto CleanUp;
    	}
    				 
    	lpKeyLabel->lpLabelType = (WORD *)cicMemAllocClear(lpKeyLabel->wNumModComb * sizeof(WORD) );
	  	if ( lpKeyLabel->lpLabelType == NULL )
    	{
    		// Not enough memory.
            // release all allocated memory.
     	    
    		hr = E_OUTOFMEMORY;
    		goto CleanUp;
    	}
    	lpKeyLabel->lpLabelDisp = (WORD *)cicMemAllocClear(lpKeyLabel->wNumModComb * sizeof(WORD));
  		if ( lpKeyLabel->lpLabelDisp == NULL )
    	{
    		// Not enough memory.
            // release all allocated memory.
     	    
    		hr = E_OUTOFMEMORY;
    		goto CleanUp;
    	}

		for ( jMod=0; jMod < wNumModInKey; jMod++)
		{
			lpKeyLabel->lppLabelText[jMod] = SysAllocString( pMapPtr );
			pMapPtr += wcslen(pMapPtr) + 1;
		}

		CopyMemory(lpKeyLabel->lpLabelType, pMapPtr, wNumModInKey * sizeof(WORD) );
		pMapPtr += wNumModInKey;

		CopyMemory(lpKeyLabel->lpLabelDisp, pMapPtr, wNumModInKey * sizeof(WORD) );
		pMapPtr += wNumModInKey;
	}

CleanUp:
    if ( FAILED(hr) )
    {
	  // Release all allocated memory in this function.

   	  int i;

      for (i=0; i<=iKey; i++) 
  	  {
		KEYLABELS  *lpKeyLabel;
		int         jMod;

		if (lpKeyLabel = &(lpKeyMapList->lpKeyLabels[i]))
        {

   	       // free lppLabelText string for each state.
   	       for ( jMod=0; jMod<lpKeyLabel->wNumModComb; jMod++)
   		   {
              if (lpKeyLabel->lppLabelText && lpKeyLabel->lppLabelText[jMod])
                 SysFreeString(lpKeyLabel->lppLabelText[jMod]);
   		   }

   	       SafeFreePointer(lpKeyLabel->lppLabelText);
   	       SafeFreePointer(lpKeyLabel->lpLabelType);
 	       SafeFreePointer(lpKeyLabel->lpLabelDisp);
        }
   	  }
    }

    return hr;

}


/*******************************************************************************
 *
 * Method function:  ParseKeyboardLayout(  )                                        
 *
 * Parse Keyboard Layout description XML file, and fill the internal
 * Layout and Mapping Table structure.
 *
 *   if fFileName is TRUE, means lpszKeyboardDesFile stands for a file name
 *   if it is FALSE, lpszKeyboardDesFile points to the real memory block which 
 *                   contains XML content.
/********************************************************************************/

HRESULT CSoftKbd::_ParseKeyboardLayout(BOOL   fFileName, WCHAR  *lpszKeyboardDesFile, DWORD dwKbdLayoutID, KBDLAYOUTDES **lppKbdLayout )
{

    KBDLAYOUTDES        *pKbdLayout = NULL;
    KBDLAYOUT           *pLayout = NULL;
    IXMLDOMNode         *pNode = NULL;
    IXMLDOMNode         *pLayoutChild =NULL, *pLabelChild = NULL, *pNext = NULL, *pRoot=NULL ;
    BSTR                nodeName=NULL;
    KEYMAP              *lpKeyMapList = NULL;
    BSTR                pBURL = NULL;
    HRESULT             hr = S_OK;



    if ( (lpszKeyboardDesFile == NULL) || ( lppKbdLayout == NULL) )
    {
    	// 
    	// this is not appropriate parameter.
    	//

    	hr = E_FAIL;
    	return hr;
    }

    if ( _pDoc == NULL )
    {
    	// the first time this method is called.
       hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER,
                        IID_IXMLDOMDocument, (void**)&_pDoc);

       if ( FAILED(hr) )
    	   return hr;
    }

    pKbdLayout = (KBDLAYOUTDES *)cicMemAllocClear(sizeof(KBDLAYOUTDES) );

    if ( pKbdLayout == NULL )
    {
    	hr = E_OUTOFMEMORY;
    	return hr;
    }

    pKbdLayout->wKbdLayoutID = dwKbdLayoutID;
    pKbdLayout->ModifierStatus = 0;
    pKbdLayout->CurModiState = 0;
    pKbdLayout->lpKeyMapList = NULL;
    if ( fFileName == TRUE )
       StringCchCopyW(pKbdLayout->KbdLayoutDesFile, ARRAYSIZE(pKbdLayout->KbdLayoutDesFile), lpszKeyboardDesFile );
    else
    {
    	//
    	// we just set "_string" at this moment,
    	// after this function returns, the caller needs to set the real 
    	// file path + resource ID as its new desfilepath.
    	//
       wcscpy(pKbdLayout->KbdLayoutDesFile, L"_String");
    }

    pLayout = &(pKbdLayout->kbdLayout);

    if ( fFileName == TRUE )
        pBURL = SysAllocString(lpszKeyboardDesFile);
    else
    	pBURL = lpszKeyboardDesFile;

    CHECKHR(_LoadDocumentSync(pBURL, fFileName));

    CHECKHR(_pDoc->QueryInterface(IID_IXMLDOMNode,(void**)&pNode));

    CHECKHR(pNode->get_firstChild(&pRoot));

    CHECKHR(pRoot->get_nodeName(&nodeName));

    // Get the Root node

    while ( wcscmp(nodeName, xSOFTKBDDES) ) {

         pRoot->get_nextSibling(&pNext);
         pRoot->Release();
         pRoot = pNext;
    	 if ( nodeName != NULL )
            SysFreeString(nodeName);
         pRoot->get_nodeName(&nodeName);

    }

    if ( nodeName != NULL )
       SysFreeString(nodeName);

    // Get the layout child and label child,

    pLayoutChild = pLabelChild = NULL;

    pRoot->get_firstChild(&pLayoutChild);

    if ( pLayoutChild != NULL )
       pLayoutChild->get_nextSibling(&pLabelChild);

    CHECKHR(_ParseLayoutDescription(pLayoutChild, pLayout) );

    // Handle Label part.

    if ( pLayout->fStandard == TRUE )
    {
    	// 
    	// Generate mapping table for standard layout
    	//

    	// Mapping table is generated by SetKeyboardLabelText( ) method.
 
    
    	goto  CleanUp;
    }

    if ( pLabelChild == NULL )
    {
    	// the XML file is not complete.

    	hr = E_FAIL;
    	goto CleanUp;
    }

    lpKeyMapList = (KEYMAP  *)cicMemAllocClear(sizeof(KEYMAP) );

    if ( lpKeyMapList == NULL )
    {
    	SafeFreePointer(pKbdLayout);
    	hr = E_OUTOFMEMORY;

    	goto CleanUp;
    }

    CHECKHR(_ParseMappingDescription(pLabelChild, lpKeyMapList));

    pKbdLayout->lpKeyMapList = lpKeyMapList;

CleanUp:

    SafeReleaseClear(pLayoutChild);

    if ( pLabelChild != NULL )
       pLabelChild->Release( );

    SafeReleaseClear(pRoot);

    SafeReleaseClear(pNode);

    if ( fFileName == TRUE )
       SysFreeString(pBURL);

    if ( FAILED(hr) )
    {
    	if  ( pKbdLayout != NULL )
    		SafeFreePointer(pKbdLayout);

    	if ( lpKeyMapList != NULL )
    		SafeFreePointer( lpKeyMapList );

    }
    else
    {
       if ( lppKbdLayout != NULL )
            *lppKbdLayout = pKbdLayout;
       
    }

    return hr;

}

/*******************************************************************************
 *
 * Method function:  _GenerateKeyboardLayoutFromSKD(  )                                        
 *
 * KBD file is a precompiled xml file, it is binary format, This KBD has been put 
 * into the resource section of DLL, the resource type is SKDFILE.
 *
 * This method function will read the resource content and try to fill the internal
 * Layout and Mapping Table structure.
 *
 ********************************************************************************/

HRESULT CSoftKbd::_GenerateKeyboardLayoutFromSKD(BYTE  *lpszKeyboardDes, DWORD dwKbdLayoutID, KBDLAYOUTDES **lppKbdLayout)
{

    KBDLAYOUTDES        *pKbdLayout = NULL;
    KBDLAYOUT           *pLayout = NULL;
	BYTE                *pMapTable = NULL;
    KEYMAP              *lpKeyMapList = NULL;
    WORD                wNumberOfKeys, wLenLayout;
    HRESULT             hr = S_OK;

    if ( (lpszKeyboardDes == NULL) || ( lppKbdLayout == NULL) )
    {
    	// 
    	// this is not appropriate parameter.
    	//
		return E_FAIL;
    }

    pKbdLayout = (KBDLAYOUTDES *)cicMemAllocClear(sizeof(KBDLAYOUTDES) );

    if ( pKbdLayout == NULL )
    {
    	hr = E_OUTOFMEMORY;
    	return hr;
    }

    pKbdLayout->wKbdLayoutID = dwKbdLayoutID;
    pKbdLayout->ModifierStatus = 0;
    pKbdLayout->CurModiState = 0;
    pKbdLayout->lpKeyMapList = NULL;
  	//
   	// we just set "_string" at this moment,
   	// after this function returns, the caller needs to set the real 
   	// file path + resource ID as its new desfilepath.
   	//
    wcscpy(pKbdLayout->KbdLayoutDesFile, L"_String");

    pLayout = &(pKbdLayout->kbdLayout);

    // Fill the layout internal structure from lpszKeyboardDes.

    wNumberOfKeys = *(lpszKeyboardDes + sizeof(WORD) * 6 + sizeof(BOOL));
    wLenLayout = sizeof(WORD) * 7 + sizeof(BOOL) + wNumberOfKeys * sizeof(KEYDES);
	CopyMemory(pLayout, lpszKeyboardDes, wLenLayout);
    
    // Handle Label part.
    if ( pLayout->fStandard == TRUE )
    {
    	// Mapping table is generated later by SetKeyboardLabelText( ) method.
 	   	goto  CleanUp;
    }

    lpKeyMapList=(KEYMAP *)cicMemAllocClear(sizeof(KEYMAP));

    if ( lpKeyMapList == NULL )
    {
    	SafeFreePointer(pKbdLayout);
    	hr = E_OUTOFMEMORY;
    	goto CleanUp;
    }

	//Get the start position of Mapping Table content.

	pMapTable = lpszKeyboardDes + wLenLayout;

    CHECKHR(_GenerateMapDesFromSKD(pMapTable, lpKeyMapList));

    pKbdLayout->lpKeyMapList = lpKeyMapList;

CleanUp:

    if ( FAILED(hr) )
    {
    	if  ( pKbdLayout != NULL )
    		SafeFreePointer(pKbdLayout);

    	if ( lpKeyMapList != NULL )
    		SafeFreePointer( lpKeyMapList );
    }
    else
    {
       if ( lppKbdLayout != NULL )
            *lppKbdLayout = pKbdLayout;
       
    }
    return hr;
}


/*******************************************************************************
 *
 * Method function:  CreateSoftKeyboardLayoutFromXMLFile(  )                                        
 *
 * Create the real Soft Keyboard layout based on specified description XML file.
 *
/********************************************************************************/


STDMETHODIMP CSoftKbd::CreateSoftKeyboardLayoutFromXMLFile(WCHAR  *lpszKeyboardDesFile,INT  szFileStrLen, DWORD *pdwLayoutCookie)
{

    DWORD               dwCurKbdLayoutID;
    KBDLAYOUTDES        *pKbdLayout=NULL;
    HRESULT             hr = S_OK;


    dwCurKbdLayoutID = SOFTKBD_CUSTOMIZE_BEGIN;

    if ( _lpKbdLayoutDesList != NULL ) 
    {

       // check if this des file is alreay parsed.

    	pKbdLayout = _lpKbdLayoutDesList;

    	while ( pKbdLayout != NULL ) {

    		if ( pKbdLayout->wKbdLayoutID > dwCurKbdLayoutID )
    			dwCurKbdLayoutID = pKbdLayout->wKbdLayoutID;

    		if ( wcscmp(pKbdLayout->KbdLayoutDesFile, lpszKeyboardDesFile) == 0 )
    		{

    			// find it.

    			*pdwLayoutCookie = pKbdLayout->wKbdLayoutID;

    			hr = S_OK;

    			return hr;
    		}


    		pKbdLayout = pKbdLayout->pNext;

    	}

    }


    // this is a new des file

    dwCurKbdLayoutID ++;

    CHECKHR(_ParseKeyboardLayout(TRUE, lpszKeyboardDesFile, dwCurKbdLayoutID, &pKbdLayout));

    // link this new layout to the list.

    pKbdLayout->CurModiState = 0;  // use state 0 as initialization

    if ( _lpKbdLayoutDesList == NULL ) {

    	_lpKbdLayoutDesList = pKbdLayout;
    	pKbdLayout->pNext = NULL;

    }
    else
    {
    	pKbdLayout->pNext  = _lpKbdLayoutDesList;
    	_lpKbdLayoutDesList = pKbdLayout;
    }

    *pdwLayoutCookie = pKbdLayout->wKbdLayoutID;

CleanUp:

    return hr;
}


/*******************************************************************************
 *
 * Method function:  CreateSoftKeyboardLayoutFromResource(  )                                        
 *
 * Create the real Soft Keyboard layout based on XML content in resource section
 * There will be two kinds of resouces, XMLFILE, and SKDFILE,  SKDFILE is a 
 * Precomipled XML binary file.
 *
 *  lpszResFile :   path of file which contains XML content in its resource.
 *  lpszResString : resource string identifier for the XML or KBD resource.
 *
 *    the resource Type could be either "XMLFILE" or "SKDFILE"
 *
 *  lpdwLayoutCookie: receive the returned layout id.
 *
/********************************************************************************/


HRESULT CSoftKbd::CreateSoftKeyboardLayoutFromResource(WCHAR *lpszResFile, WCHAR  *lpszResType, WCHAR *lpszResString, DWORD *lpdwLayoutCookie)
{
    DWORD               dwCurKbdLayoutID;
    KBDLAYOUTDES        *pKbdLayout=NULL;
    WCHAR               *lpszKeyboardDesFile=NULL;
    WCHAR               wszInternalDesFileName[MAX_PATH];
    CHAR                lpszAnsiResString[MAX_PATH];
    CHAR                lpszAnsiResFile[MAX_PATH];
    CHAR                lpszAnsiResType[MAX_PATH];
    HMODULE             hResFile = NULL;
    HRSRC               hRsRc = NULL;
    HGLOBAL             hResData = NULL;
    HRESULT             hr = S_OK;
    BOOL                fXMLUnicode=TRUE;
    DWORD               dwResLen;


    if ( (lpszResFile == NULL) || (lpszResString == NULL) || (lpszResType == NULL) || ( lpdwLayoutCookie == NULL) )
    {
    	hr = E_FAIL;
    	return hr;
    }

    //
    // Generate internal DesFile Name
    //
    StringCchCopyW(wszInternalDesFileName, ARRAYSIZE(wszInternalDesFileName), lpszResType);
    StringCchCatW( wszInternalDesFileName, ARRAYSIZE(wszInternalDesFileName), L":");
    StringCchCatW( wszInternalDesFileName, ARRAYSIZE(wszInternalDesFileName), lpszResFile );
    StringCchCatW( wszInternalDesFileName, ARRAYSIZE(wszInternalDesFileName), L":");
    StringCchCatW( wszInternalDesFileName, ARRAYSIZE(wszInternalDesFileName), lpszResString );


    dwCurKbdLayoutID = SOFTKBD_CUSTOMIZE_BEGIN;

    if ( _lpKbdLayoutDesList != NULL ) 
    {

       // check if this des file is alreay parsed.

    	pKbdLayout = _lpKbdLayoutDesList;

    	while ( pKbdLayout != NULL ) {

    		if ( pKbdLayout->wKbdLayoutID > dwCurKbdLayoutID )
    			dwCurKbdLayoutID = pKbdLayout->wKbdLayoutID;

    		if ( wcscmp(pKbdLayout->KbdLayoutDesFile, wszInternalDesFileName) == 0 )
    		{
    			// find it.
    			*lpdwLayoutCookie = pKbdLayout->wKbdLayoutID;

    			hr = S_OK;
    			return hr;
    		}
    		pKbdLayout = pKbdLayout->pNext;
    	}

    }

    // this is a new des file
    dwCurKbdLayoutID ++;
    WideCharToMultiByte(CP_ACP, 0, lpszResFile, -1, 
    	                lpszAnsiResFile, MAX_PATH, NULL, NULL );

    hResFile = LoadLibraryA(lpszAnsiResFile);
    if ( hResFile == NULL )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    WideCharToMultiByte(CP_ACP, 0, lpszResString, -1, 
    	                lpszAnsiResString, MAX_PATH, NULL, NULL );

    WideCharToMultiByte(CP_ACP, 0, lpszResType, -1, 
    	                lpszAnsiResType, MAX_PATH, NULL, NULL );

    hRsRc = FindResourceA(hResFile, lpszAnsiResString, lpszAnsiResType );

    if ( hRsRc == NULL )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    dwResLen = SizeofResource(hResFile, hRsRc);

    hResData =  LoadResource(hResFile, hRsRc );

    if ( hResData == NULL )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    lpszKeyboardDesFile = (WCHAR  *)LockResource(hResData);

    if ( lpszKeyboardDesFile == NULL )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    if ( wcscmp(lpszResType, L"SKDFILE") == 0 )
    {
        CHECKHR(_GenerateKeyboardLayoutFromSKD((BYTE *)lpszKeyboardDesFile, dwCurKbdLayoutID, &pKbdLayout));
    }
    else if ( wcscmp(lpszResType, L"XMLFILE") == 0 )
    {
        // This is XMLFILE resource
        //
        // we assume the XML content in resource is in Unicode format.
        //

        if ( lpszKeyboardDesFile[0] == 0xFEFF )
        {
    	    fXMLUnicode = TRUE;
            lpszKeyboardDesFile = lpszKeyboardDesFile + 1;
        }
        else
        {
    	    // if the content is  UTF-8, we need to translate the string to Unicode
    	    //

    	    char      *lpszXMLContentUtf8;
    	    int       iSize;

    	    lpszXMLContentUtf8 = (char *)lpszKeyboardDesFile;
    	    lpszKeyboardDesFile = NULL;

    	    iSize = _Utf8ToUnicode(lpszXMLContentUtf8, dwResLen ,NULL, 0 );

    	    if ( iSize == 0 )
        	{
        		hr = E_FAIL;
    	    	goto CleanUp;
    	    }

    	    fXMLUnicode = FALSE;

            lpszKeyboardDesFile = (WCHAR *) cicMemAllocClear( (iSize+1) * sizeof(WCHAR) );

    	    if ( lpszKeyboardDesFile == NULL )
    	    {
    		    hr = E_FAIL;
    		    goto CleanUp;
    	    }

    	    iSize = _Utf8ToUnicode(lpszXMLContentUtf8, dwResLen,lpszKeyboardDesFile, iSize+1 );

    	    if ( iSize == 0 )
        	{
        		hr = E_FAIL;
    	    	goto CleanUp;
    	    }

    	    lpszKeyboardDesFile[iSize] = L'\0';
        }

        CHECKHR(_ParseKeyboardLayout(FALSE, lpszKeyboardDesFile, dwCurKbdLayoutID, &pKbdLayout));
    }
    else
    {
        // This resource type is not supported.
        hr = E_FAIL;
        goto CleanUp;
    }

    // Change the internal DesFile name as following format:
    //
    //  XMLRES: ResFileName : XMLResString  to identify this layout's des file.
    // Or 
    //  KBDRES: ResFileName : KBDResString  
    //

    wcscpy(pKbdLayout->KbdLayoutDesFile, wszInternalDesFileName);

    // link this new layout to the list.

    pKbdLayout->CurModiState = 0;  // use state 0 as initialization

    if ( _lpKbdLayoutDesList == NULL ) {

    	_lpKbdLayoutDesList = pKbdLayout;
    	pKbdLayout->pNext = NULL;

    }
    else
    {
    	pKbdLayout->pNext  = _lpKbdLayoutDesList;
    	_lpKbdLayoutDesList = pKbdLayout;
    }

    *lpdwLayoutCookie = pKbdLayout->wKbdLayoutID;

CleanUp:

    if ( hResFile != NULL )
    	FreeLibrary(hResFile);

    if ( (fXMLUnicode == FALSE) && ( lpszKeyboardDesFile != NULL ) )
    	SafeFreePointer(lpszKeyboardDesFile);

    return hr;
}


HRESULT  CSoftKbd::_GenerateRealKbdLayout(  ) 
{
    float         fWidRat, fHigRat;
    INT           i;
    KBDLAYOUT     *realKbdLayout;
    HRESULT       hr;

    WORD          skbd_x, skbd_y, skbd_width, skbd_height;
    BOOL          fNewTitleSize = FALSE;


    hr = S_OK;

    if ( (_xReal == 0) &&
    	 (_yReal == 0 ) &&
    	 (_widthReal == 0) &&
    	 (_heightReal == 0) )
    {
    	// 
    	// means CreateSoftKeyboardWindow( ) has not been called yet
    	// we don't do more things.
    	//

    	return hr;
    }


    //
    // The soft keyboard window has already been created, and the window size is set,
    // generate realKbdLayout by extending or shrinking the key size from the size 
    // specified in the des file.
    //

    // check if there is SoftKeyboard Layout is set.
    //

    if ( _wCurKbdLayoutID == NON_KEYBOARD || _lpCurKbdLayout == NULL )
    {
    	//
    	// No layout is selected.
    	//

    	return hr;
    }

    // Generate the titlebar rect size, and button panel rectangle size.

    // Keep the relative postion. ( window client coordinate )

    switch ( _TitleBar_Type )
    {
    case TITLEBAR_NONE :

        _TitleBarRect.left = 0;
        _TitleBarRect.top =  0;
        _TitleBarRect.right = 0;
        _TitleBarRect.bottom = 0;

        break;

    case TITLEBAR_GRIPPER_HORIZ_ONLY :

        _TitleBarRect.left = 0;
        _TitleBarRect.top  = 0;
        _TitleBarRect.right = _TitleBarRect.left + _widthReal - 1;
        _TitleBarRect.bottom = _TitleBarRect.top + 6;
        break;

    case TITLEBAR_GRIPPER_VERTI_ONLY :

        _TitleBarRect.left = 0;
        _TitleBarRect.top  = 0;
        _TitleBarRect.right = _TitleBarRect.left + 6;
        _TitleBarRect.bottom = _TitleBarRect.top + _heightReal - 1;

        break;

    case TITLEBAR_GRIPPER_BUTTON :
        // assume to use horizontal title bar.
        _TitleBarRect.left = 0;
        _TitleBarRect.top  = 0;
        _TitleBarRect.right = _TitleBarRect.left + _widthReal - 1;
        _TitleBarRect.bottom = _TitleBarRect.top + 16;

        fNewTitleSize = TRUE;

        break;
    }

    if ( (_TitleBarRect.right - _TitleBarRect.left + 1) == _widthReal )
    {
        // This is a horizontal titlebar

        skbd_x = 0;
        skbd_y = (WORD)_TitleBarRect.bottom + 1;
        skbd_width = (WORD)_widthReal;
        skbd_height = (WORD)_heightReal - (WORD)(_TitleBarRect.bottom - _TitleBarRect.top + 1 );

    }
    else if ((_TitleBarRect.bottom - _TitleBarRect.top + 1) == _heightReal )
    {

        // This is a vertical titlebar.

        skbd_y = 0;
        skbd_x = (WORD)_TitleBarRect.right + 1;
        skbd_height = (WORD)_heightReal;
        skbd_width = (WORD)_widthReal - (WORD)(_TitleBarRect.right - _TitleBarRect.left + 1 );

    }
    else
    {
        // there is no titlebar
        skbd_x = 0;
        skbd_y = 0;
        skbd_height = (WORD)_heightReal;
        skbd_width = (WORD) _widthReal;
    }

    realKbdLayout = &( _lpCurKbdLayout->kbdLayout );

    if ( (realKbdLayout->wWidth == skbd_width) && (realKbdLayout->wHeight == skbd_height) )
    {
    	// this keyboard layout has been already adjusted.
    	//
    	hr = S_OK;
    	return hr;
    }

    if ( (realKbdLayout->wWidth == 0) || ( realKbdLayout->wHeight==0) )
    {
    	Assert(0);
    	hr = E_FAIL;
    	return hr;
    }

    fWidRat = (float)skbd_width / (float)realKbdLayout->wWidth;

    fHigRat = (float)(skbd_height) / (float) realKbdLayout->wHeight;


    // Adjust every key's size

    realKbdLayout->wMarginWidth = (WORD)((float)realKbdLayout->wMarginWidth * fWidRat);
    realKbdLayout->wMarginHeight = (WORD)((float)realKbdLayout->wMarginHeight * fHigRat);

    for ( i=0; i< realKbdLayout->wNumberOfKeys; i++ )
    {

       WORD     wLeft;  
       WORD     wTop;
       WORD     wWidth;
       WORD     wHeight;

       wLeft = (WORD)((float)(realKbdLayout->lpKeyDes[i].wLeft - realKbdLayout->wLeft ) * fWidRat);
       wTop  = (WORD)((float)(realKbdLayout->lpKeyDes[i].wTop - realKbdLayout->wTop) * fHigRat);
       wWidth = (WORD)((float)realKbdLayout->lpKeyDes[i].wWidth * fWidRat);
       wHeight = (WORD)((float)realKbdLayout->lpKeyDes[i].wHeight * fHigRat);

       realKbdLayout->lpKeyDes[i].wLeft = wLeft + skbd_x;
       realKbdLayout->lpKeyDes[i].wTop = wTop + skbd_y;
       realKbdLayout->lpKeyDes[i].wWidth = wWidth;
       realKbdLayout->lpKeyDes[i].wHeight = wHeight;
    }

    realKbdLayout->wLeft = (WORD)skbd_x;
    realKbdLayout->wTop = (WORD)skbd_y;
    realKbdLayout->wWidth = (WORD)skbd_width;
    realKbdLayout->wHeight = (WORD)skbd_height;

    if ( fNewTitleSize )
    {
        _TitleBarRect.left = realKbdLayout->lpKeyDes[0].wLeft;
        _TitleBarRect.right = realKbdLayout->lpKeyDes[realKbdLayout->wNumberOfKeys-1].wLeft + 
                              realKbdLayout->lpKeyDes[realKbdLayout->wNumberOfKeys-1].wWidth - 1;
    }

    return hr;
}

/*******************************************************************************
 *
 * Method function:  SelectSoftKeyboard(  )                                        
 *
 * Select current Active soft keyboard layout.
 *
/********************************************************************************/

STDMETHODIMP CSoftKbd::SelectSoftKeyboard(DWORD dwKeyboardId)
{

    HRESULT       hr;
    KBDLAYOUTDES  *pKbdLayout;

    hr = S_OK;

     if ( _wCurKbdLayoutID == dwKeyboardId )
    	return hr;

    pKbdLayout = _lpKbdLayoutDesList;

    while ( pKbdLayout != NULL ) {

    	if ( pKbdLayout->wKbdLayoutID == dwKeyboardId )
    		break;

    	pKbdLayout = pKbdLayout->pNext;

    }

    
    if ( pKbdLayout == NULL ) 
    {
    	// 
    	// Cannot find this keyboard layout
    	//
    	hr = E_FAIL;
    	return hr;
    }


    _lpCurKbdLayout = pKbdLayout;

    _wCurKbdLayoutID = dwKeyboardId;

    // initialize realKbdLayout

    hr = _GenerateRealKbdLayout( );

    if ( _pSoftkbdUIWnd )
    {
       hr=_pSoftkbdUIWnd->_GenerateWindowLayout( );
    }

    return hr;
}

/*******************************************************************************
 *
 * Method function:  _SetStandardLabelText(  )                                        
 *
 * Generate mapping table in a certain modifier status for a standard soft
 * keyboard.
 *
/********************************************************************************/

HRESULT CSoftKbd::_SetStandardLabelText(LPBYTE  pKeyState, KBDLAYOUT *realKbdLayout,
    									KEYMAP  *lpKeyMapList, int  iState)
{
    UINT      i, j, nKeyNum;
    UINT      uVirtkey, uScanCode;
    HRESULT   hr;


    hr = S_OK;

    nKeyNum = (UINT)(realKbdLayout->wNumberOfKeys);

    // fill _CurLabel

    for ( i=0; i<nKeyNum; i++) {

    	// Assume the KEYID is scancode.

        WCHAR    szLabel[MAX_LABEL_LEN];
    	int      iRet, jIndex;
    	KEYID    keyId;

    	BOOL     fPitcureKey;
        PICTUREKEY  *pPictureKeys;

    	switch ( _wCurKbdLayoutID ) {

    	case SOFTKBD_JPN_STANDARD :
    	case SOFTKBD_JPN_ENHANCE  :
           	   pPictureKeys = gJpnPictureKeys;
    		   break;

    	case SOFTKBD_US_STANDARD   :
    	case SOFTKBD_US_ENHANCE    :
    	case SOFTKBD_EURO_STANDARD :
    	case SOFTKBD_EURO_ENHANCE  : 

                pPictureKeys = gPictureKeys;
    		   break;
    	}

        keyId = lpKeyMapList->lpKeyLabels[i].keyId = realKbdLayout->lpKeyDes[i].keyId;

    	fPitcureKey = FALSE;

    	for ( j=0; j<NUM_PICTURE_KEYS; j++)
    	{

    		if ( pPictureKeys[j].uScanCode == keyId )
    		{
    			// this is a picture key.
    			fPitcureKey = TRUE;
    			jIndex = j;

    			break;
    		}

    		if ( pPictureKeys[j].uScanCode == 0 )
    		{
    			// This is the last item in pPictureKeys.
    			break;
    		}

    	}


    	if ( fPitcureKey )
    	{

    	    lpKeyMapList->lpKeyLabels[i].lpLabelType[iState]  = LABEL_PICTURE;
            lpKeyMapList->lpKeyLabels[i].lpLabelDisp[iState]  = LABEL_DISP_ACTIVE;
            lpKeyMapList->lpKeyLabels[i].lppLabelText[iState] = SysAllocString(pPictureKeys[jIndex].PictBitmap);


    	}
    	else
    	{

    
            // All others are text labels. and have different strings for 
    		// different modifier combination statets.
    		//

            UINT   uScanSpace = 0x39;
            int    iLabelSize;
            BOOL   fFunctKey;

    	    uScanCode = realKbdLayout->lpKeyDes[i].keyId;
    	    uVirtkey = MapVirtualKeyEx(uScanCode, 1, _lpCurKbdLayout->CurhKl);

            fFunctKey = FALSE;

    	    // For the Function keys, we just use the hard code string to set
    	    // them as F1, F2, F3, ..... F12.

    	    WCHAR  wszFuncKey[MAX_LABEL_LEN];

    	    wszFuncKey[0] = L'F';

    	    switch (uScanCode) {

    	    case KID_F1  :
    	    case KID_F2  :
    	    case KID_F3  :
    	    case KID_F4  :
    	    case KID_F5  :
    	    case KID_F6  :
    	    case KID_F7  :
    	    case KID_F8  :
     	    case KID_F9  :
    		                wszFuncKey[1] = L'0' + uScanCode - KID_F1 + 1;
    				    	wszFuncKey[2] = L'\0';
    			    		wcscpy(szLabel, wszFuncKey);
                            fFunctKey = TRUE;
    		    			break;
    	    case KID_F10 :
    		                wcscpy(szLabel, L"F10");
                            fFunctKey = TRUE;
    		    			break;
    	    case KID_F11 :
    	                    wcscpy(szLabel, L"F11");
                            fFunctKey = TRUE;
    		    			break;
    	    case KID_F12 :					            
    			    		wcscpy(szLabel, L"F12");
                            fFunctKey = TRUE;
    		    			break;
    	    default :
    				            
    				        break;
    	    }

            if ( fFunctKey == TRUE )
            {

   	            lpKeyMapList->lpKeyLabels[i].lppLabelText[iState] = SysAllocString(szLabel);
   	            lpKeyMapList->lpKeyLabels[i].lpLabelType[iState]  = LABEL_TEXT;
                lpKeyMapList->lpKeyLabels[i].lpLabelDisp[iState]  = LABEL_DISP_ACTIVE;
                continue;
            }

    		if ( IsOnNT( ) )
            {

    	       iRet = ToUnicodeEx(uVirtkey, uScanCode | 0x80, pKeyState, szLabel, (int)(sizeof(szLabel)/sizeof(WCHAR)), 0, _lpCurKbdLayout->CurhKl);
               if ( iRet == 2 )
               {
                   // it is possible to have previous dead key, flush again.
                   iRet = ToUnicodeEx(uVirtkey, uScanCode | 0x80, pKeyState, szLabel, (int)(sizeof(szLabel)/sizeof(WCHAR)), 0, _lpCurKbdLayout->CurhKl);
               }

               iLabelSize = iRet;
            }
    		else
    		{
    			// Win9x doesn't support ToUnicodeEx, we just use alternative ToAsciiEx.

    			char  szLabelAnsi[MAX_LABEL_LEN];

    			iRet = ToAsciiEx(uVirtkey, uScanCode | 0x80, pKeyState, (LPWORD)szLabelAnsi, 0, _lpCurKbdLayout->CurhKl);

                if ( iRet == 2 )
                {
                    // it is possible to have previous dead key, flush again.
                    iRet = ToAsciiEx(uVirtkey, uScanCode | 0x80, pKeyState, (LPWORD)szLabelAnsi, 0, _lpCurKbdLayout->CurhKl);
                }

    			if ( iRet != 0 )
    			{
    				//
    				// Translate the ANSI label to Unicode based on ACP ... or other? 
    				//
                    if ( iRet == -1 )   // dead key, one character is written to szLabelAnsi buffer.
                        szLabelAnsi[1] = '\0';
                    else
        				szLabelAnsi[iRet] = '\0';

    				iLabelSize = MultiByteToWideChar(CP_ACP, 0, szLabelAnsi, -1, szLabel, MAX_LABEL_LEN );
    			}
    		}

            if ( iRet <= 0 )
            {
                iLabelSize = 1;
                if ( iRet == 0 )
                {
                    // Means no translation for this key at this shift state.
                    // We will display empty label, or space on the button.

                    szLabel[0] = 0x20;
                }
            }
          
            szLabel[iLabelSize] = L'\0';

    	    lpKeyMapList->lpKeyLabels[i].lppLabelText[iState] = SysAllocString(szLabel);
    	    lpKeyMapList->lpKeyLabels[i].lpLabelType[iState]  = LABEL_TEXT;
            lpKeyMapList->lpKeyLabels[i].lpLabelDisp[iState]  = LABEL_DISP_ACTIVE;

    	}

    }

    return hr;

}


/*******************************************************************************
 *
 * Method function:  _GenerateUSStandardLabel(  )                                        
 *
 * Generate all mapping labels in different modifier status for US standard
 * soft keyboard.
 *
/********************************************************************************/

HRESULT CSoftKbd::_GenerateUSStandardLabel(  )
{

    //
    //  there are 4 different states for keyboard labels.
    //
    //    state  0  :   no any modifier key pressed
    //    state  1  :   Caps On.
    //    state  2  :   Shift pressed. Caps Off
    //    state  3  :   Shift Pressed, Caps On
    //

    // check to see if this soft keyboard support specified HKL.
    //
    //  ???
    //
    
    KEYMAP    *lpKeyMapList;
    HRESULT   hr;
    WORD      wNumModComb, wNumOfKeys;
    int       i, j;
    int       iState;
    BYTE      lpKeyState[256], lpCurKeyState[256];
    KBDLAYOUT *realKbdLayut;
    

    hr = S_OK;

    if ( _lpCurKbdLayout->lpKeyMapList != NULL ) 
    {

    	// If the mapping table for the specified HKL has already been created,
    	// Just return it.

    	HKL   CurhKl;

    	CurhKl = _lpCurKbdLayout->CurhKl;

    	lpKeyMapList = _lpCurKbdLayout->lpKeyMapList;

    	while ( lpKeyMapList != NULL )
    	{

    		if ( lpKeyMapList->hKl ==  CurhKl )
    		{
    			// The mapping table is already created,

    			return hr;
    		}

    		lpKeyMapList = lpKeyMapList->pNext;
    	}

    }

    realKbdLayut = &(_lpCurKbdLayout->kbdLayout);

    lpKeyMapList = (KEYMAP  *)cicMemAllocClear(sizeof(KEYMAP) );

    if ( lpKeyMapList == NULL )
    {
    	// there is not enough memory.
    	hr = E_OUTOFMEMORY;
    	return hr;
    }


    // we have four different states.

    wNumModComb = 4;
    wNumOfKeys = _lpCurKbdLayout->kbdLayout.wNumberOfKeys;

    lpKeyMapList->wNumModComb = wNumModComb;
    lpKeyMapList->wNumOfKeys = wNumOfKeys;
    lpKeyMapList->hKl = _lpCurKbdLayout->CurhKl;

    for ( i=0; i<wNumOfKeys; i++ )
    {
       BSTR      *lppLabelText;
       WORD      *lpLabelType;
       WORD      *lpLabelDisp;


       lppLabelText = (BSTR *)cicMemAllocClear(wNumModComb * sizeof(BSTR) );

       if ( lppLabelText == NULL ) {
    	   // 
    	   // there is not enough memory.
    	   //

    	   // release allocated memory and return

    	   for ( j=0; j<i; j++ )
    	   {

    		   SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lppLabelText);
    		   SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lpLabelType);
               SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lpLabelDisp);
    	   }

    	   SafeFreePointer(lpKeyMapList);

    	   hr = E_OUTOFMEMORY;

    	   return hr;
       }

       lpLabelType = (WORD *)cicMemAllocClear(wNumModComb * sizeof(WORD) );

       if ( lpLabelType == NULL ) {
    	   // 
    	   // there is not enough memory.
    	   //

    	   // release allocated memory and return


    	   for ( j=0; j<i; j++ )
    	   {

    		   SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lppLabelText);
    		   SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lpLabelType);
               SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lpLabelDisp);
    	   }

    	   SafeFreePointer(lppLabelText);

    	   SafeFreePointer(lpKeyMapList);

    	   hr = E_OUTOFMEMORY;
    	   return hr;
       }
 
       lpLabelDisp = (WORD *)cicMemAllocClear(wNumModComb * sizeof(WORD) );

       if ( lpLabelDisp == NULL ) {
    	   // 
    	   // there is not enough memory.
    	   //

    	   // release allocated memory and return


    	   for ( j=0; j<i; j++ )
    	   {

    		   SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lppLabelText);
    		   SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lpLabelType);
               SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lpLabelDisp);
    	   }

    	   SafeFreePointer(lppLabelText);

           SafeFreePointer(lpLabelType);

    	   SafeFreePointer(lpKeyMapList);

    	   hr = E_OUTOFMEMORY;
    	   return hr;
       }
       
       lpKeyMapList->lpKeyLabels[i].lppLabelText = lppLabelText;
       lpKeyMapList->lpKeyLabels[i].lpLabelType = lpLabelType;
       lpKeyMapList->lpKeyLabels[i].lpLabelDisp = lpLabelDisp;
       lpKeyMapList->lpKeyLabels[i].wNumModComb = wNumModComb;
       
    }


    // Keep the current keyboard states on Win9x

    if ( !IsOnNT( ) )
    {
       if ( 0 == GetKeyboardState(lpCurKeyState) )
          return E_FAIL;
    }

    iState = 0;

    memset(lpKeyState, 0, 256);

    CHECKHR(_SetStandardLabelText(lpKeyState, realKbdLayut,lpKeyMapList,iState));

    iState = 1;  // Caps On

    memset(lpKeyState, 0, 256);

    lpKeyState[VK_CAPITAL] = 0x01;

    CHECKHR(_SetStandardLabelText(lpKeyState, realKbdLayut,lpKeyMapList,iState));

    iState = 2;  // Shift Down, Caps Off.

    memset(lpKeyState, 0, 256);

    lpKeyState[VK_SHIFT]   = 0x80;

    CHECKHR(_SetStandardLabelText(lpKeyState, realKbdLayut,lpKeyMapList,iState));

    
    iState = 3;  // Shift Down, Caps On

    memset(lpKeyState, 0, 256);
    lpKeyState[VK_CAPITAL] = 0x01;
    lpKeyState[VK_SHIFT]   = 0x80;
    CHECKHR(_SetStandardLabelText(lpKeyState, realKbdLayut,lpKeyMapList,iState));

    // Add the newly created KeyMapList to the head of the mapping table link.

    lpKeyMapList->pNext = _lpCurKbdLayout->lpKeyMapList;
  
    _lpCurKbdLayout->lpKeyMapList = lpKeyMapList;

CleanUp:

    // Restore the current keyboard states on Win9x

    if ( !IsOnNT( ) )
        SetKeyboardState(lpCurKeyState);

    return hr;

}

/*******************************************************************************
 *
 * Method function:  _GenerateUSEnhanceLabel(  )                                        
 *
 * Generate all mapping labels in different modifier status for US enhanced
 * soft keyboard.
 *
/********************************************************************************/


HRESULT CSoftKbd::_GenerateUSEnhanceLabel(  )
{

    HRESULT hr;

    hr = E_NOTIMPL;

    // not yet implemented.

    return hr;

}

/*******************************************************************************
 *
 * Method function:  _GenerateEuroStandardLabel(  )                                        
 *
 * Generate all mapping labels in different modifier status for Euro standard
 * soft keyboard. ( 102-key keyboard)
 *
/********************************************************************************/

HRESULT CSoftKbd::_GenerateEuroStandardLabel(  )
{

    //
    //  there are 8 different states for keyboard labels.
    //
    //          AltGr  Shift  Caps.
    //  Bit       2     1      0
    //
    //    state  0  :   no any modifier key pressed
    //    state  1  :   Caps On.
    //    state  2  :   Shift pressed. Caps Off
    //    state  3  :   Shift Pressed, Caps On
    //
    //     .........

   
    KEYMAP    *lpKeyMapList;
    HRESULT   hr;
    WORD      wNumModComb, wNumOfKeys;
    int       i, j;
    int       iState;
    BYTE      lpKeyState[256], lpCurKeyState[256];
    KBDLAYOUT *realKbdLayut;
    WORD      BCaps, BShift, BAltGr;
    
    BCaps    = 1;
    BShift   = 2;
    BAltGr   = 4;

    hr = S_OK;
    if ( _lpCurKbdLayout->lpKeyMapList != NULL ) 
    {
    	// If the mapping table for the specified HKL has already been created,
    	// Just return it.

    	HKL   CurhKl;

    	CurhKl = _lpCurKbdLayout->CurhKl;

    	lpKeyMapList = _lpCurKbdLayout->lpKeyMapList;

    	while ( lpKeyMapList != NULL )
    	{

    		if ( lpKeyMapList->hKl ==  CurhKl )
    		{
    			// The mapping table is already created,

    			return hr;
    		}

    		lpKeyMapList = lpKeyMapList->pNext;
    	}

    }
    
    realKbdLayut = &(_lpCurKbdLayout->kbdLayout);
    lpKeyMapList = (KEYMAP  *)cicMemAllocClear(sizeof(KEYMAP) );
    if ( lpKeyMapList == NULL )
    {
    	// there is not enough memory.
    	hr = E_OUTOFMEMORY;
    	return hr;
    }

    // we have 8 different states.
    wNumModComb = 8;
    wNumOfKeys = _lpCurKbdLayout->kbdLayout.wNumberOfKeys;

    lpKeyMapList->wNumModComb = wNumModComb;
    lpKeyMapList->wNumOfKeys = wNumOfKeys;
    lpKeyMapList->pNext = NULL;
    lpKeyMapList->hKl = _lpCurKbdLayout->CurhKl;

    for ( i=0; i<wNumOfKeys; i++ )
    {
       BSTR      *lppLabelText=NULL;
       WORD      *lpLabelType=NULL;
       WORD      *lpLabelDisp=NULL;

       lppLabelText = (BSTR *)cicMemAllocClear(wNumModComb * sizeof(BSTR) );
       lpLabelType = (WORD *)cicMemAllocClear(wNumModComb * sizeof(WORD) );
       lpLabelDisp = (WORD *)cicMemAllocClear(wNumModComb * sizeof(WORD) );
       
       if ( (lpLabelDisp == NULL) || (lpLabelType== NULL) || (lppLabelText == NULL) ) {
    	   // 
    	   // there is not enough memory.
    	   //
    	   // release allocated memory and return
    	   for ( j=0; j<i; j++ )
    	   {
    		   SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lppLabelText);
    		   SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lpLabelType);
               SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lpLabelDisp);
    	   }

    	   SafeFreePointer(lppLabelText);
           SafeFreePointer(lpLabelType);
    	   SafeFreePointer(lpKeyMapList);
    	   hr = E_OUTOFMEMORY;
    	   return hr;
       }
              
       lpKeyMapList->lpKeyLabels[i].lppLabelText = lppLabelText;
       lpKeyMapList->lpKeyLabels[i].lpLabelType = lpLabelType;
       lpKeyMapList->lpKeyLabels[i].lpLabelDisp = lpLabelDisp;
       lpKeyMapList->lpKeyLabels[i].wNumModComb = wNumModComb;
       
    }

    // Keep the current keyboard states on Win9x.
    if ( !IsOnNT( ) )
    {
        if ( 0 == GetKeyboardState(lpCurKeyState) )
           return E_FAIL;
    }

    for (iState = 0; iState < wNumModComb; iState ++ )
    {
        memset(lpKeyState, 0, 256);
    	if ( iState & BCaps )
    		 lpKeyState[VK_CAPITAL]=0x01;

        if ( iState & BShift )
             lpKeyState[VK_SHIFT] = 0x80;

        if ( iState & BAltGr )
        {
    	    lpKeyState[VK_MENU] = 0x80;
            lpKeyState[VK_CONTROL] = 0x80;
        }
        CHECKHR(_SetStandardLabelText(lpKeyState, realKbdLayut,lpKeyMapList,iState));
    }
  
    _lpCurKbdLayout->lpKeyMapList = lpKeyMapList;

CleanUp:

    // Restore the current keyboard states on Win9x.

    if ( ! IsOnNT( ) )
        SetKeyboardState(lpCurKeyState);

    return hr;

}

/*******************************************************************************
 *
 * Method function:  _GenerateEuroEnhanceLabel(  )                                        
 *
 * Generate all mapping labels in different modifier status for Euro Enhanced
 * soft keyboard. ( 102-key +  NumPad )
 *
/********************************************************************************/

HRESULT CSoftKbd::_GenerateEuroEnhanceLabel(  )
{

    HRESULT hr;

    hr = E_NOTIMPL;

    // not yet implemented.

    return hr;

}

/*******************************************************************************
 *
 * Method function:  _GenerateJpnStandardLabel(  )                                        
 *
 * Generate all mapping labels in different modifier status for JPN standard
 * soft keyboard. ( 106-key)
 *
/********************************************************************************/

HRESULT CSoftKbd::_GenerateJpnStandardLabel(  )
{

    //
    //  there are 16 different states for keyboard labels.
    //
    //       Kana   Alt  Shift  Caps.
    //  Bit    3     2     1      0
    //
    //    state  0  :   no any modifier key pressed
    //    state  1  :   Caps On.
    //    state  2  :   Shift pressed. Caps Off
    //    state  3  :   Shift Pressed, Caps On
    //

   
    KEYMAP    *lpKeyMapList;
    HRESULT   hr;
    WORD      wNumModComb, wNumOfKeys;
    int       i, j;
    int       iState;
    BYTE      lpKeyState[256], lpCurKeyState[256];
    KBDLAYOUT *realKbdLayut;


    WORD      BCaps, BShift, BAlt, BKana;
    
    BCaps    = 1;
    BShift   = 2;
    BAlt     = 4;
    BKana    = 8;

    hr = S_OK;

    if ( _lpCurKbdLayout->lpKeyMapList != NULL ) 
    {

        return hr;

    }


    realKbdLayut = &(_lpCurKbdLayout->kbdLayout);

    lpKeyMapList = (KEYMAP  *)cicMemAllocClear(sizeof(KEYMAP) );

    if ( lpKeyMapList == NULL )
    {
    	// there is not enough memory.
    	hr = E_OUTOFMEMORY;
    	return hr;
    }


    // we have four different states.

    wNumModComb = 16;
    wNumOfKeys = _lpCurKbdLayout->kbdLayout.wNumberOfKeys;

    lpKeyMapList->wNumModComb = wNumModComb;
    lpKeyMapList->wNumOfKeys = wNumOfKeys;
    lpKeyMapList->pNext = NULL;
    lpKeyMapList->hKl = _lpCurKbdLayout->CurhKl;

    for ( i=0; i<wNumOfKeys; i++ )
    {
       BSTR      *lppLabelText;
       WORD      *lpLabelType;
       WORD      *lpLabelDisp;


       lppLabelText = (BSTR *)cicMemAllocClear(wNumModComb * sizeof(BSTR) );

       if ( lppLabelText == NULL ) {
    	   // 
    	   // there is not enough memory.
    	   //

    	   // release allocated memory and return

    	   for ( j=0; j<i; j++ )
    	   {

    		   SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lppLabelText);
    		   SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lpLabelType);
               SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lpLabelDisp);
    	   }

    	   SafeFreePointer(lpKeyMapList);

    	   hr = E_OUTOFMEMORY;

    	   return hr;
       }

       lpLabelType = (WORD *)cicMemAllocClear(wNumModComb * sizeof(WORD) );

       if ( lpLabelType == NULL ) {
    	   // 
    	   // there is not enough memory.
    	   //

    	   // release allocated memory and return


    	   for ( j=0; j<i; j++ )
    	   {

    		   SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lppLabelText);
    		   SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lpLabelType);
               SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lpLabelDisp);
    	   }

    	   SafeFreePointer(lppLabelText);

    	   SafeFreePointer(lpKeyMapList);

    	   hr = E_OUTOFMEMORY;
    	   return hr;
       }
 
       lpLabelDisp = (WORD *)cicMemAllocClear(wNumModComb * sizeof(WORD) );

       if ( lpLabelDisp == NULL ) {
    	   // 
    	   // there is not enough memory.
    	   //

    	   // release allocated memory and return


    	   for ( j=0; j<i; j++ )
    	   {

    		   SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lppLabelText);
    		   SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lpLabelType);
               SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lpLabelDisp);
    	   }

    	   SafeFreePointer(lppLabelText);

           SafeFreePointer(lpLabelType);

    	   SafeFreePointer(lpKeyMapList);

    	   hr = E_OUTOFMEMORY;
    	   return hr;
       }
              
       lpKeyMapList->lpKeyLabels[i].lppLabelText = lppLabelText;
       lpKeyMapList->lpKeyLabels[i].lpLabelType = lpLabelType;
       lpKeyMapList->lpKeyLabels[i].lpLabelDisp = lpLabelDisp;
       lpKeyMapList->lpKeyLabels[i].wNumModComb = wNumModComb;
       
    }

    // Keep the current keyboard states on Win9x.

    if ( !IsOnNT( ) )
    {
        if ( 0 == GetKeyboardState(lpCurKeyState) )
            return E_FAIL;
    }

    for (iState = 0; iState < wNumModComb; iState ++ )
    {

         memset(lpKeyState, 0, 256);

    	if ( iState & BCaps )
    			lpKeyState[VK_CAPITAL] = 0x01;
       
    	if ( iState & BShift )
           lpKeyState[VK_SHIFT] = 0x80;

    	if ( iState & BAlt )
    	    lpKeyState[VK_MENU] = 0x80;

    	if ( iState & BKana )
    		lpKeyState[VK_KANA] = 0x01;

        CHECKHR(_SetStandardLabelText(lpKeyState, realKbdLayut,lpKeyMapList,iState));

    }
  
    _lpCurKbdLayout->lpKeyMapList = lpKeyMapList;

CleanUp:

    // Restore the current keyboard states on Win9x.

    if ( ! IsOnNT( ) )
        SetKeyboardState(lpCurKeyState);

    return hr;

}

/*******************************************************************************
 *
 * Method function:  _GenerateJpnEnhanceLabel(  )                                        
 *
 * Generate all mapping labels in different modifier status for JPN enhanced
 * soft keyboard. (106-key + NumPad )
 *
/********************************************************************************/

HRESULT CSoftKbd::_GenerateJpnEnhanceLabel(  )
{

    HRESULT hr;

    hr = E_NOTIMPL;

    // not yet implemented.

    return hr;
}

/*******************************************************************************
 *
 * Method function:  SetKeyboardLabelText(  )                                        
 *
 * Set the mapping label texts based on specified HKL.
 *
/********************************************************************************/

STDMETHODIMP CSoftKbd::SetKeyboardLabelText(HKL hKl)
{

    KBDLAYOUT   *realKbdLayout;
    HRESULT     hr;
    DWORD       iModiCombState;
    WORD        iModifierStatus;

    realKbdLayout = &(_lpCurKbdLayout->kbdLayout);

    hr = S_OK;

    if ( realKbdLayout->fStandard == FALSE ) {
    	//
    	// customized layout cannot accept HKL to change its keys' labels.
    	//
    	_lpCurKbdLayout->CurhKl = 0;
    	hr = E_FAIL;
    	return hr;
    }



    if ( ! IsOnNT( ) )
    {

    	// We have to handle IME hkl specially on Win9x.
    	// For some reason, Win9x cannot receive IME HKL as parameter in MapVirtualKeyEx and ToAsciiEx.

        INT_PTR iHkl;

    	iHkl = (INT_PTR)hKl;

    	if ( (iHkl & 0xF0000000) == 0xE0000000 )
    	{
    		// this is FE IME HKL.

    		iHkl = iHkl & 0x0000ffff;

    		hKl = (HKL) iHkl;
    	}

    }


    _lpCurKbdLayout->CurhKl = (HKL)hKl;


    //
    // check to see if current standard keyboard supports this HKL
    //

    switch ( _wCurKbdLayoutID ) {

       case  SOFTKBD_US_STANDARD :
    	     
    	      CHECKHR(_GenerateUSStandardLabel( ));

    		  break;

       case SOFTKBD_US_ENHANCE :

    	      CHECKHR(_GenerateUSEnhanceLabel( ));
    		  break;

       case SOFTKBD_EURO_STANDARD :

    	      CHECKHR(_GenerateEuroStandardLabel(  ));
    		  break;

       case SOFTKBD_EURO_ENHANCE :

    	      CHECKHR(_GenerateEuroEnhanceLabel( ));
    		  break;

       case SOFTKBD_JPN_STANDARD :

    	      CHECKHR(_GenerateJpnStandardLabel( ));
    		  break;

       case SOFTKBD_JPN_ENHANCE :

    	      CHECKHR(_GenerateJpnEnhanceLabel( ));
    		  break;
    }

    // set current Active mapping labels.

    // Generate CurModiState based on current keyboard state
    
     _GenerateCurModiState(&iModifierStatus, &iModiCombState);
     _lpCurKbdLayout->ModifierStatus = iModifierStatus;
     hr = SetKeyboardLabelTextCombination(iModiCombState);

CleanUp:
    return hr;
}

/*******************************************************************************
 *
 * Method function:  _SetKeyboardLabelTextCombination(  )                                        
 *
 * Set current effective modifier combination status, so that the correct
 * mapping labels will be shown up.
 *
/********************************************************************************/

STDMETHODIMP CSoftKbd::SetKeyboardLabelTextCombination(DWORD iModiCombState)
{

    WORD      wNumberOfKeys, i;
    KEYMAP    *lpKeyMapList;
    HRESULT    hr;

    
    hr = S_OK;
    if ( _lpCurKbdLayout == NULL )
    {
    	hr = E_FAIL;
    	return hr;
    }

    if ( _lpCurKbdLayout->lpKeyMapList == NULL )
    {
    	hr = E_FAIL;
    	return hr;
    }

    if ( (_lpCurKbdLayout->kbdLayout).fStandard )
    {
    	// This is a standard keyboard layout, we need to
    	// find out the correct mapping table for the current
    	// specified HKL.

    	// Every mapping table is associated with a HKL.
    	// the current specified HKL is stored in _lpCurKbdLayout->CurhKl.

    	HKL   CurhKl;

    	CurhKl = _lpCurKbdLayout->CurhKl;

    	lpKeyMapList = _lpCurKbdLayout->lpKeyMapList;

    	while ( lpKeyMapList->hKl !=  CurhKl )
    	{
    		lpKeyMapList = lpKeyMapList->pNext;

    		if ( lpKeyMapList == NULL )
    		{
    			// No mapping table is associated with the specified HKL.
    			// return error.

    			hr = E_FAIL;
    			return hr;
    		}
    	}

    }
    else
        lpKeyMapList = _lpCurKbdLayout->lpKeyMapList;

    if ( iModiCombState >= lpKeyMapList->wNumModComb)
    {
    	hr = E_FAIL;
    	return hr;
    }

    _lpCurKbdLayout->CurModiState = iModiCombState;

    // Now fill _CurLabel,  Current Active label for every key.

    wNumberOfKeys = (_lpCurKbdLayout->kbdLayout).wNumberOfKeys;

    for ( i=0; i<wNumberOfKeys; i++)
    {
      int  iState;

      _CurLabel[i].keyId = lpKeyMapList->lpKeyLabels[i].keyId;

      iState = iModiCombState;

      
      if ( iModiCombState >= lpKeyMapList->lpKeyLabels[i].wNumModComb )
      {
    	  // there is not enough different states for this key
    	  // just use state 0.
    	  iState = 0;
      }

      _CurLabel[i].lpLabelText = lpKeyMapList->lpKeyLabels[i].lppLabelText[iState];
      _CurLabel[i].LabelType   = lpKeyMapList->lpKeyLabels[i].lpLabelType[iState];
      _CurLabel[i].LabelDisp   = lpKeyMapList->lpKeyLabels[i].lpLabelDisp[iState];

    }

    if ( _pSoftkbdUIWnd )
    {
        _pSoftkbdUIWnd->_SetKeyLabel( );
    }
    
    return hr;
}

/*******************************************************************************
 *
 * Method function:  _GenerateCurModiState(  )                                        
 *
 * Generate Softkbd recognized ModifierStatus and CurModiState based on 
 * current keyboard states.
 * 
 /********************************************************************************/
HRESULT  CSoftKbd::_GenerateCurModiState(WORD *ModifierStatus, DWORD *CurModiState )
{
   DWORD    iModiCombState;
   WORD     iModifierStatus;
   DWORD    iTmp;
   HRESULT  hr = S_OK;

   if ( !ModifierStatus  || !CurModiState )
       return E_FAIL;

   if ( (_lpCurKbdLayout->kbdLayout).fStandard == FALSE )
       return E_FAIL;

   iModifierStatus = 0;
   if ( GetKeyState(VK_CAPITAL) & 0x01 )
   {
       // Caps key is Toggled.
        iModifierStatus |= MODIFIER_CAPSLOCK ;
   }

   if ( GetKeyState(VK_SHIFT) & 0x80 )
   {
       // Shift key is pressed.
        iModifierStatus |= MODIFIER_SHIFT;
   }

   if ( GetKeyState(VK_CONTROL) & 0x80 )
   {
       // Ctrl key is pressed.
        iModifierStatus |= MODIFIER_CTRL;
   }

   if ( GetKeyState(VK_LMENU) & 0x80 )
   {
       // Left Alt key is pressed.
        iModifierStatus |= MODIFIER_ALT;
   }

   if ( GetKeyState(VK_RMENU) & 0x80 )
   {
       // Right Alt key is pressed.
        iModifierStatus |= MODIFIER_ALTGR;
   }

   if ( GetKeyState(VK_KANA) & 0x01 )
   {
       // KANA key is Toggled.
        iModifierStatus |= MODIFIER_KANA;
   }


   *ModifierStatus = iModifierStatus;

   switch ( _wCurKbdLayoutID )  {

   case SOFTKBD_US_STANDARD   :
   case SOFTKBD_US_ENHANCE    :
        // this is for US Standard keyboard.
        // others may need to handle separately.

        iModiCombState = (iModifierStatus) & (MODIFIER_CAPSLOCK | MODIFIER_SHIFT);
        iModiCombState = iModiCombState >> 1;

        // bit1 for Caps.
        // bit2 for Shift
        break;

   case SOFTKBD_EURO_STANDARD :
   case SOFTKBD_EURO_ENHANCE  :
        // this is for Euro 102 standard keyboard.
	    // How to map ModifierStatus -> CurModiState.
        
        // bit 1 for Caps, bit2 for Shift, bit3 for AltGr.

        iModiCombState = (iModifierStatus) & ( MODIFIER_CAPSLOCK | MODIFIER_SHIFT );
        iModiCombState = iModiCombState >> 1;

	    iTmp = (iModifierStatus) & MODIFIER_ALTGR;
	    iTmp = iTmp >> 4;

	    iModiCombState += iTmp;

	    break;
 
   case SOFTKBD_JPN_STANDARD  :
   case SOFTKBD_JPN_ENHANCE   :

	   // How to map ModifierStatus -> CurModiState.

       iModiCombState = (iModifierStatus) & ( MODIFIER_CAPSLOCK | MODIFIER_SHIFT );
       iModiCombState = iModiCombState >> 1;

	   iTmp = (iModifierStatus) & (MODIFIER_ALT | MODIFIER_KANA);
	   iTmp = iTmp >> 2;

	   iModiCombState += iTmp;

	   break;
   }

   *CurModiState = iModiCombState;

   return hr;
 
}

/*******************************************************************************
 *
 * Method function:  ShowSoftKeyboard(  )                                        
 *
 * Show or Hide the soft keyboard window based on the specified parameter.
 * 
 *
/********************************************************************************/

STDMETHODIMP CSoftKbd::ShowSoftKeyboard(INT iShow)
{

    HRESULT  hr;

    hr = S_OK;

    if (!_pSoftkbdUIWnd) {
    	 
        hr = E_FAIL;
    	return hr;
    }

    // if client doesn't specify which layout is selected,
    // we just select a default standard soft keyboard layout
    // based on current thread keyboard layout.

    // if current thread keyboard layout is JPN, use 106 key.
    // others, use 101key.

    // run SelectSoftKeyboard( SelectedID );
    //

    if ( _wCurKbdLayoutID == NON_KEYBOARD )
    {
       HKL     hKl;
       DWORD   dwLayoutId;
       LANGID  langId;

       hKl = GetKeyboardLayout(0);

       langId = LOWORD( (DWORD)(UINT_PTR)hKl);

       if ( langId == 0x0411 )  // Japanese keyboard
       {
            dwLayoutId = SOFTKBD_JPN_STANDARD;
       }
       else
            dwLayoutId = SOFTKBD_US_STANDARD; 
           
       CHECKHR(SelectSoftKeyboard(dwLayoutId) );
       CHECKHR(SetKeyboardLabelText(hKl));

    }

    _pSoftkbdUIWnd->Show(iShow);

    _iShow = iShow;

CleanUp:

    return hr;
}


/*******************************************************************************
 *
 * Method function:  CreateSoftKeyboardWindow(  )                                        
 *
 * Create a real soft keyboard popup window.
 *
/********************************************************************************/


STDMETHODIMP CSoftKbd::CreateSoftKeyboardWindow(HWND hOwner, TITLEBAR_TYPE Titlebar_type, INT xPos, INT yPos, INT width, INT height)
{
    // TODO: Add your implementation code here

    HRESULT  hr;

    hr = S_OK;
    _hOwner = hOwner;

    _xReal = xPos;
    _yReal = yPos;
    _widthReal = width;
    _heightReal= height;

    _TitleBar_Type = Titlebar_type;  // temporal solution.
    //
    // generate realKbdLayout
    //
    CHECKHR(_GenerateRealKbdLayout( ));


    if ( _pSoftkbdUIWnd != NULL )
        delete _pSoftkbdUIWnd;


    _pSoftkbdUIWnd = new CSoftkbdUIWnd(this, g_hInst, UIWINDOW_TOPMOST | UIWINDOW_WSDLGFRAME | UIWINDOW_HABITATINSCREEN);

    if ( _pSoftkbdUIWnd != NULL )
    {
        _pSoftkbdUIWnd->Initialize( );
        _pSoftkbdUIWnd->_CreateSoftkbdWindow(hOwner, Titlebar_type, xPos, yPos, width, height);
        
    }

    _iShow = 0;

CleanUp:
    return hr;
}

/*******************************************************************************
 *
 * Method function:  DestroySoftKeyboardWindow(  )                                        
 *
 * Destroy the soft keyboard window
 * 
 *
/********************************************************************************/

STDMETHODIMP CSoftKbd::DestroySoftKeyboardWindow()
{

    if ( _pSoftkbdUIWnd != NULL )
    {
        delete _pSoftkbdUIWnd;
        _pSoftkbdUIWnd = NULL;
    }

    return S_OK;
}

/*******************************************************************************
 *
 * Method function:  GetSoftKeyboardPosSize(  )                                        
 *
 * Return current soft keyboard window size and scrren position
 *
/********************************************************************************/

STDMETHODIMP CSoftKbd::GetSoftKeyboardPosSize(POINT *lpStartPoint, WORD *lpwidth, WORD *lpheight)
{

    HRESULT   hr;

    hr = S_OK;

    if ( _pSoftkbdUIWnd == NULL )
    {
    	hr = E_FAIL;
    	return hr;
    }

    if ( (lpStartPoint == NULL ) || ( lpwidth == NULL) || ( lpheight == NULL) )
    {
    	hr = E_FAIL;
    	return hr;
    }

    lpStartPoint->x = _xReal;
    lpStartPoint->y = _yReal;

    *lpwidth = (WORD)_widthReal;
    *lpheight = (WORD)_heightReal;

    return hr;
}

/*******************************************************************************
 *
 * Method function:  GetSoftKeyboardColors(  )                                        
 *
 * Return all different kinds of soft keyboard window colors.
 *
/********************************************************************************/

STDMETHODIMP CSoftKbd::GetSoftKeyboardColors(COLORTYPE colorType, COLORREF *lpColor)
{

    HRESULT   hr;

    hr = S_OK;

    if ( _pSoftkbdUIWnd == NULL )
    {
    	hr = E_FAIL;
    	return hr;
    }

    if ( lpColor == NULL )
    {
    	hr = E_FAIL;
    	return hr;
    }

    *lpColor = _color[colorType];

    return hr;
}

/*******************************************************************************
 *
 * Method function:  GetSoftKeyboardTypeMode(  )                                        
 *
 * Return current Soft keyboard 's typing mode.
 * this is for On Screen Keyboard.
 * 
 *
/********************************************************************************/

STDMETHODIMP CSoftKbd::GetSoftKeyboardTypeMode(TYPEMODE *lpTypeMode)
{
    HRESULT   hr;

    hr = S_OK;

    if ( _pSoftkbdUIWnd == NULL )
    {
    	hr = E_FAIL;
    	return hr;
    }

    if ( lpTypeMode == NULL )
    {
    	hr = E_FAIL;
    	return hr;
    }

    // 
    //

    return hr;
}

/*******************************************************************************
 *
 * Method function:  GetSoftKeyboardTextFont(  )                                        
 *
 * Return current soft keyboard label font data.
 * 
 *
/********************************************************************************/

STDMETHODIMP CSoftKbd::GetSoftKeyboardTextFont(LOGFONTW  *pLogFont)
{

    HRESULT   hr;

    hr = S_OK;

    if ( _pSoftkbdUIWnd == NULL )
    {
    	hr = E_FAIL;
    	return hr;
    }


    if ( pLogFont == NULL )
    {
    	hr = E_FAIL;
    	return hr;
    }

    if ( _plfTextFont )
    {
        CopyMemory(pLogFont, _plfTextFont, sizeof(LOGFONTW) );
    }
    else
        hr = S_FALSE;

    return hr;
}

STDMETHODIMP CSoftKbd::SetSoftKeyboardPosSize(POINT StartPoint, WORD width, WORD height)
{
    HRESULT   hr;

    hr = S_OK;

    if ( _pSoftkbdUIWnd == NULL )
    {
    	hr = E_FAIL;
    	return hr;
    }

    _xReal = StartPoint.x;
    _yReal = StartPoint.y;

    if ( width > 0 ) 
       _widthReal = width;

    if ( height > 0 )
       _heightReal = height;

    //
    // generate realKbdLayout
    //
    CHECKHR(_GenerateRealKbdLayout( ));

    _pSoftkbdUIWnd->Move(_xReal, _yReal, _widthReal, _heightReal);

    if ( _iShow & SOFTKBD_SHOW )
    {
         CHECKHR(ShowSoftKeyboard(_iShow));
    }

CleanUp:

    return hr;
}

STDMETHODIMP CSoftKbd::SetSoftKeyboardColors(COLORTYPE colorType, COLORREF Color)
{
    HRESULT   hr;

    hr = S_OK;

    if ( _pSoftkbdUIWnd == NULL )
    {
    	hr = E_FAIL;
    	return hr;
    }

    _color[colorType] = Color;

    if ( _iShow & SOFTKBD_SHOW )
    {
         CHECKHR(ShowSoftKeyboard(_iShow));
    }

CleanUp:

    return hr;
}

STDMETHODIMP CSoftKbd::SetSoftKeyboardTypeMode(TYPEMODE TypeMode)
{
    HRESULT   hr;

    hr = S_OK;

    if ( _pSoftkbdUIWnd == NULL )
    {
    	hr = E_FAIL;
    	return hr;
    }


    //
    //  Set type mode 
    //

    if ( _iShow & SOFTKBD_SHOW )
    {
         CHECKHR(ShowSoftKeyboard(_iShow));
    }

CleanUp:

    return hr;
}

STDMETHODIMP CSoftKbd::SetSoftKeyboardTextFont(LOGFONTW  *pLogFont)
{
    HRESULT   hr;

    hr = S_OK;

    if ( _pSoftkbdUIWnd == NULL )
    {
    	hr = E_FAIL;
    	return hr;
    }

    if ( pLogFont == NULL )
        return E_INVALIDARG;

    //
    // set font data
    //

    if ( _plfTextFont == NULL )
        _plfTextFont = (LOGFONTW  *)cicMemAllocClear( sizeof(LOGFONTW) );

    if ( _plfTextFont )
    {
        CopyMemory( _plfTextFont, pLogFont, sizeof(LOGFONTW) );

        _pSoftkbdUIWnd->UpdateFont( _plfTextFont );

        if ( _iShow & SOFTKBD_SHOW )
        {
            _pSoftkbdUIWnd->CallOnPaint( );
        }
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

STDMETHODIMP CSoftKbd::ShowKeysForKeyScanMode(KEYID *lpKeyID, INT iKeyNum, BOOL fHighL)
{
    HRESULT   hr;

    hr = S_OK;

    if ( _pSoftkbdUIWnd == NULL )
    {
    	hr = E_FAIL;
    	return hr;
    }



    return hr;
}

/*******************************************************************************
 *
 * Method function:  UnadviseSoftKeyboardEventSink(  )                                        
 *
 * Unadvise the previously advised soft keyboard event sink interface.
 *
/********************************************************************************/

STDMETHODIMP CSoftKbd::UnadviseSoftKeyboardEventSink(/*[in] */DWORD dwCookie)
{

    HRESULT         hr;
    KBDLAYOUTDES    *pKbdLayout;


    hr = S_OK;

    // we assume dwCookie stands for the real soft keyboard Id.

    if ( dwCookie == 0 )
    {
    	hr = E_FAIL;
    	return hr;
    }

    if ( dwCookie == DWCOOKIE_SFTKBDWNDES )
    {
         SafeReleaseClear( _pskbdwndes );
    	 return hr;
    }

    // Try to find the soft keyboard layout.

    pKbdLayout = _lpKbdLayoutDesList;

    while ( pKbdLayout != NULL ) {

    	if ( pKbdLayout->wKbdLayoutID == dwCookie )
    		break;

    	pKbdLayout = pKbdLayout->pNext;

    }

    
    if ( pKbdLayout == NULL ) 
    {
    	// 
    	// Cannot find this keyboard layout
    	//
    	hr = E_FAIL;
    	return hr;
    }


    if ( pKbdLayout->pskbes == NULL ) 
    {
    	// this event sink has not be registered.

    	hr = E_FAIL;

    	return hr;
    }

    SafeReleaseClear(pKbdLayout->pskbes);
    

    return hr;

}

/*******************************************************************************
 *
 * Method function:  AdviseSoftKeyboardEventSink(  )                                        
 *
 * Register soft keyboard event sink interface for the client of this component
 * 
 *
/********************************************************************************/

STDMETHODIMP CSoftKbd::AdviseSoftKeyboardEventSink(/*[in] */DWORD dwKeyboardId, /*[in]*/ REFIID riid, IUnknown *punk, /*[out] */DWORD *pdwCookie)
{

    HRESULT         hr;
    KBDLAYOUTDES    *pKbdLayout;

    *pdwCookie = 0;

    if ( ! IsEqualIID(riid, IID_ISoftKeyboardEventSink) && ! IsEqualIID(riid, IID_ISoftKbdWindowEventSink) )
    	return E_UNEXPECTED;


    if  ( IsEqualIID(riid, IID_ISoftKbdWindowEventSink) )
    {

        if ( _pskbdwndes != NULL )
    		return E_FAIL;

        CHECKHR(punk->QueryInterface(riid, (void **)&_pskbdwndes) );

    	if ( pdwCookie != NULL )
    		*pdwCookie = DWCOOKIE_SFTKBDWNDES;

    	return hr;
    }

    // check to see if specified soft keyboard layout is already generated.  

    pKbdLayout = _lpKbdLayoutDesList;

    while ( pKbdLayout != NULL ) {

    	if ( pKbdLayout->wKbdLayoutID == dwKeyboardId )
    		break;

    	pKbdLayout = pKbdLayout->pNext;

    }

    
    if ( pKbdLayout == NULL ) 
    {
    	// 
    	// Cannot find this keyboard layout
    	//
    	hr = E_FAIL;
    	return hr;
    }


    CHECKHR(punk->QueryInterface(riid, (void **)&(pKbdLayout->pskbes)) );

    if ( pdwCookie != NULL )
      *pdwCookie = dwKeyboardId;

CleanUp:
    return hr == S_OK ? S_OK : E_UNEXPECTED;

    
}

HRESULT CSoftKbd::_HandleTitleBarEvent( DWORD  dwId )
{

    HRESULT   hr = S_OK;

    // dwId stands for IconId or CloseId.

    // So far, we handle close button event only.

    if (dwId == KID_CLOSE)
    {
        if  (_pskbdwndes != NULL)
    		hr = _pskbdwndes->OnWindowClose( );
    }

    return hr;
}

HRESULT CSoftKbd::_HandleKeySelection(KEYID keyId)
{
    HRESULT        hr = S_OK;
    int            uKeyIndex, i;
    KBDLAYOUT     *realKbdLayout=NULL;
    KBDLAYOUTDES  *lpCurKbdLayout=NULL;
    ACTIVELABEL   *CurLabel=NULL;
    BOOL           fModifierSpecial = FALSE;
    
    lpCurKbdLayout = _lpCurKbdLayout;

    if ( lpCurKbdLayout == NULL ) return hr;

    // Get the KeyIndex in the current layout's key description

    realKbdLayout = &(lpCurKbdLayout->kbdLayout);

    if ( realKbdLayout == NULL ) return hr;

    CurLabel = _CurLabel;

    uKeyIndex = -1;

    for ( i=0; i<realKbdLayout->wNumberOfKeys; i++) {

        if ( keyId == realKbdLayout->lpKeyDes[i].keyId )
        {
            uKeyIndex = i;
            break;
        }
    }


    if ( uKeyIndex ==  -1 )
    {
        // It is not a legal key, it is impossible, we just stop here.
        return E_FAIL;
    }

    // set the modifier status

    MODIFYTYPE  tModifier;

    tModifier = realKbdLayout->lpKeyDes[uKeyIndex].tModifier;

    if ( tModifier != none ) 
    {
           lpCurKbdLayout->ModifierStatus ^= (1 << tModifier);
    }

    if (lpCurKbdLayout->pskbes != NULL )
    {

      int    j;
      WCHAR  *lpszLabel;
      WORD   wNumOfKeys;

      wNumOfKeys = realKbdLayout->wNumberOfKeys;


      // Try to get the label text for this key.

      for ( j=0; j< wNumOfKeys; j++ ) 
      {

          if ( CurLabel[j].keyId == keyId )
          {

             lpszLabel = CurLabel[j].lpLabelText;
             break;
          }

      }

      // Notify the client of key event.

      (lpCurKbdLayout->pskbes)->OnKeySelection(keyId, lpszLabel);

    }
    else 
    {
       // there is no event sink registered for this keyboard layout.
       // this must be a standard keyboard layout.

       // we will just simuate key stroke event for this key.

       if ( realKbdLayout->fStandard == TRUE )
       {

   	      BYTE        bVk, bScan;
   		  int         j, jIndex;
   		  BOOL        fExtendKey, fPictureKey;
          PICTUREKEY  *pPictureKeys;

   	      switch ( _wCurKbdLayoutID ) {

   	      case SOFTKBD_JPN_STANDARD :
   	      case SOFTKBD_JPN_ENHANCE  :
       	         pPictureKeys = gJpnPictureKeys;
   		         break;

   	      case SOFTKBD_US_STANDARD   :
   	      case SOFTKBD_US_ENHANCE    :
   	      case SOFTKBD_EURO_STANDARD :
   	      case SOFTKBD_EURO_ENHANCE  : 

                  pPictureKeys = gPictureKeys;
   		         break;
   		  }

   		  fPictureKey = FALSE;

   		  for ( j=0; j<NUM_PICTURE_KEYS; j++)
   		  {

   			  if ( pPictureKeys[j].uScanCode == keyId )
   			  {
   				  // This is a picture key.
   				  // it may be a extended key.

   				  jIndex = j;

   				  fPictureKey = TRUE;

   				  break;
   			  }

   		      if ( pPictureKeys[j].uScanCode == 0 )
   			  {
   			      // This is the last item in pPictureKeys.
   			      break;
   			  }

   		  }


   		  fExtendKey = FALSE;

   		  if ( fPictureKey )
   		  {
   			  if ( (keyId & 0xFF00) == 0xE000 )
   			  {
   				  fExtendKey = TRUE;
                  bScan = (BYTE)(keyId & 0x000000ff);
   			  }
              else
              {
                  fExtendKey = FALSE;
                  bScan = (BYTE)(keyId);
              }

   			  bVk = (BYTE)(pPictureKeys[jIndex].uVkey);

   			  if ( bVk == 0 )
   	             bVk = (BYTE)MapVirtualKeyEx((UINT)bScan, 1, lpCurKbdLayout->CurhKl);
    			 
   		  }
   		  else
   		  {

   		     bScan = (BYTE)keyId;
   	         bVk = (BYTE)MapVirtualKeyEx((UINT)bScan, 1, lpCurKbdLayout->CurhKl);
   		  }

   		  if ( tModifier == none ) 
   		  {

   			  if ( fExtendKey )
   			  {
   				  keybd_event(bVk, bScan, (DWORD)KEYEVENTF_EXTENDEDKEY, 0);
   				  keybd_event(bVk, bScan, (DWORD)(KEYEVENTF_EXTENDEDKEY | KEYEVENTF_KEYUP), 0);
   			  }
   			  else
   			  {
                  keybd_event(bVk, bScan, 0, 0);
  		          keybd_event(bVk, bScan, (DWORD)KEYEVENTF_KEYUP, 0);
   			  }

   			  // if the Shift Key is pressed, we need to release this key.
                
   			  if ( lpCurKbdLayout->ModifierStatus & MODIFIER_SHIFT)
   			  {
   			  	  fModifierSpecial = TRUE;
   				  lpCurKbdLayout->ModifierStatus &= ~((WORD)MODIFIER_SHIFT);
   				  // simulate the SHIFT-UP key event.

   				  keybd_event((BYTE)VK_SHIFT, (BYTE)KID_LSHFT, (DWORD)KEYEVENTF_KEYUP, 0);

   			  }

   			  // if the Ctrl Key is pressed, we need to release this key.
                
   			  if ( lpCurKbdLayout->ModifierStatus & MODIFIER_CTRL)
   			  {
   			  	  fModifierSpecial = TRUE;
   				  lpCurKbdLayout->ModifierStatus &= ~((WORD)MODIFIER_CTRL);
   				  // simulate the SHIFT-UP key event.

   				  keybd_event((BYTE)VK_CONTROL, (BYTE)KID_CTRL, (DWORD)KEYEVENTF_KEYUP, 0);

   			  }

   			  // if the Shift Key is pressed, we need to release this key.
            
   			  if ( lpCurKbdLayout->ModifierStatus & MODIFIER_ALT)
   			  {
   			  	  fModifierSpecial = TRUE;
   				  lpCurKbdLayout->ModifierStatus &= ~((WORD)MODIFIER_ALT);
   				  // simulate the SHIFT-UP key event.

   				  keybd_event((BYTE)VK_MENU, (BYTE)KID_ALT, (DWORD)KEYEVENTF_KEYUP, 0);

   			  }
   			  // if the Right Alt Key is pressed, we need to release this key.
            
   			  if ( lpCurKbdLayout->ModifierStatus & MODIFIER_ALTGR)
   			  {
   			  	  fModifierSpecial = TRUE;
   				  lpCurKbdLayout->ModifierStatus &= ~((WORD)MODIFIER_ALTGR);
   				  // simulate the SHIFT-UP key event.

   				  keybd_event((BYTE)VK_RMENU, (BYTE)KID_RALT, (DWORD)KEYEVENTF_KEYUP, 0);
   			  }

   		  }
   		  else
   		  {
   			  // specially handle Caps Lock
   			  if ( keyId == KID_CAPS ) 
   			  {
   				  // this is a togglable key
                  keybd_event(bVk, bScan, 0, 0);
                  keybd_event(bVk, bScan, (DWORD)KEYEVENTF_KEYUP, 0);
   			  }
              else if  (keyId == KID_KANA) 
              {
                  BYTE  pKeyState[256];

                  memset(pKeyState, 0, sizeof(pKeyState) );

                  if ( lpCurKbdLayout->ModifierStatus & (1 << tModifier) )
                      pKeyState[VK_KANA] = 0x01;
                  SetKeyboardState(pKeyState);
              }
   			  else
   			  {

   				  if ( lpCurKbdLayout->ModifierStatus & (1 << tModifier) ) {
   				     // This key is pressed now
   					  keybd_event(bVk, bScan, 0, 0);
                         
   				  }
   			      else
   				  {
   				  // This key is released now

                      keybd_event(bVk, bScan, (DWORD)KEYEVENTF_KEYUP, 0);
   				  }
   			  }
   		  }
   	   }
    }
    	  

    if ( (realKbdLayout->lpKeyDes[uKeyIndex].tModifier != none) || fModifierSpecial )
    {
       if ( realKbdLayout->fStandard == TRUE ) 
       {

           DWORD iModiCombState;
           DWORD iTmp;

           switch ( _wCurKbdLayoutID )  {

           case SOFTKBD_US_STANDARD   :
           case SOFTKBD_US_ENHANCE    :
                // this is for US Standard keyboard.
                // others may need to handle separately.

                iModiCombState = (lpCurKbdLayout->ModifierStatus) & (MODIFIER_CAPSLOCK | MODIFIER_SHIFT);
                iModiCombState = iModiCombState >> 1;

                // bit1 for Caps.
                // bit2 for Shift
                break;

           case SOFTKBD_EURO_STANDARD :
           case SOFTKBD_EURO_ENHANCE  :
                // this is for Euro 102 standard keyboard.
	            // How to map ModifierStatus -> CurModiState.
        
                // bit 1 for Caps, bit2 for Shift, bit3 for AltGr.

                iModiCombState = (lpCurKbdLayout->ModifierStatus) & ( MODIFIER_CAPSLOCK | MODIFIER_SHIFT );
                iModiCombState = iModiCombState >> 1;

	            iTmp = (lpCurKbdLayout->ModifierStatus) & MODIFIER_ALTGR;
	            iTmp = iTmp >> 4;

	            iModiCombState += iTmp;

	            break;
 
           case SOFTKBD_JPN_STANDARD  :
           case SOFTKBD_JPN_ENHANCE   :

	            // How to map ModifierStatus -> CurModiState.

                iModiCombState = (lpCurKbdLayout->ModifierStatus) & ( MODIFIER_CAPSLOCK | MODIFIER_SHIFT );
                iModiCombState = iModiCombState >> 1;

	            iTmp = (lpCurKbdLayout->ModifierStatus) & (MODIFIER_ALT | MODIFIER_KANA);
	            iTmp = iTmp >> 2;

	            iModiCombState += iTmp;

	            break;
           }


           SetKeyboardLabelTextCombination(iModiCombState);
           ShowSoftKeyboard(TRUE);

       }

    }

    return hr;

}

/*******************************************************************************
 *
 *  Method function: _UnicodeToUtf8( )
 *
 *  Convert unicode characters to UTF8.
 *
 *  Result is NULL terminated if sufficient space in result
 *   buffer is available.
 * 
 * Arguments:
 *
 *   pwUnicode   -- ptr to start of unicode buffer
 *   cchUnicode  -- length of unicode buffer
 *   pchResult   -- ptr to start of result buffer for UTF8 chars
 *   cchResult   -- length of result buffer
 *
 * Return Value:
 *
 *   Count of UTF8 characters in result, if successful.
 *   0 on error.  GetLastError() has error code.
 * 
 *
/********************************************************************************/

DWORD   CSoftKbd::_UnicodeToUtf8(PWCHAR pwUnicode, DWORD cchUnicode, PCHAR  pchResult, DWORD  cchResult)
{

    WCHAR   wch;                // current unicode character being converted
    DWORD   lengthUtf8 = 0;     // length of UTF8 result string
    WORD    lowSurrogate;
    DWORD   surrogateDword;


    //
    //  loop converting unicode chars until run out or error
    //

    Assert( cchUnicode > 0 );

    while ( cchUnicode-- )
    {
        wch = *pwUnicode++;

        //
        //  ASCII character (7 bits or less) -- converts to directly
        //

        if ( wch < 0x80 )
        {
            lengthUtf8++;

            if ( pchResult )
            {
                if ( lengthUtf8 >= cchResult )
                {
                    goto OutOfBuffer;
                }
                *pchResult++ = (CHAR)wch;
            }
            continue;
        }

        //
        //  wide character less than 0x07ff (11bits) converts to two bytes
        //      - upper 5 bits in first byte
        //      - lower 6 bits in secondar byte
        //

        else if ( wch <= UTF8_2_MAX )
        {
            lengthUtf8 += 2;

            if ( pchResult )
            {
                if ( lengthUtf8 >= cchResult )
                {
                    goto OutOfBuffer;
                }
                *pchResult++ = UTF8_1ST_OF_2 | wch >> 6;
                *pchResult++ = UTF8_TRAIL    | LOW6BITS( (UCHAR)wch );
            }
            continue;
        }

        //
        //  surrogate pair
        //      - if have high surrogate followed by low surrogate then
        //          process as surrogate pair
        //      - otherwise treat character as ordinary unicode "three-byte"
        //          character, by falling through to below
        //

        else if ( wch >= HIGH_SURROGATE_START &&
                  wch <= HIGH_SURROGATE_END &&
                  cchUnicode &&
                  (lowSurrogate = *pwUnicode) &&
                  lowSurrogate >= LOW_SURROGATE_START &&
                  lowSurrogate <= LOW_SURROGATE_END )
        {
            //  have a surrogate pair
            //      - pull up next unicode character (low surrogate of pair)
            //      - make full DWORD surrogate pair
            //      - then lay out four UTF8 bytes
            //          1st of four, then three trail bytes
            //              0x1111xxxx
            //              0x10xxxxxx
            //              0x10xxxxxx
            //              0x10xxxxxx

            pwUnicode++;
            cchUnicode--;
            lengthUtf8 += 4;

            if ( pchResult )
            {
                if ( lengthUtf8 >= cchResult )
                {
                    goto OutOfBuffer;
                }
                surrogateDword = (((wch-0xD800) << 10) + (lowSurrogate - 0xDC00) + 0x10000);

                *pchResult++ = UTF8_1ST_OF_4 | (UCHAR) (surrogateDword >> 18);
                *pchResult++ = UTF8_TRAIL    | (UCHAR) LOW6BITS(surrogateDword >> 12);
                *pchResult++ = UTF8_TRAIL    | (UCHAR) LOW6BITS(surrogateDword >> 6);
                *pchResult++ = UTF8_TRAIL    | (UCHAR) LOW6BITS(surrogateDword);

            }
        }

        //
        //  wide character (non-zero in top 5 bits) converts to three bytes
        //      - top 4 bits in first byte
        //      - middle 6 bits in second byte
        //      - low 6 bits in third byte
        //

        else
        {
            lengthUtf8 += 3;

            if ( pchResult )
            {
                if ( lengthUtf8 >= cchResult )
                {
                    goto OutOfBuffer;
                }
                *pchResult++ = UTF8_1ST_OF_3 | (wch >> 12);
                *pchResult++ = UTF8_TRAIL    | LOW6BITS( wch >> 6 );
                *pchResult++ = UTF8_TRAIL    | LOW6BITS( wch );
            }
        }
    }

    //
    //  NULL terminate buffer
    //  return UTF8 character count
    //

    if ( pchResult && lengthUtf8 < cchResult )
    {
        *pchResult = 0;
    }
    return( lengthUtf8 );

OutOfBuffer:

    SetLastError( ERROR_INSUFFICIENT_BUFFER );
    return( 0 );

}

/*******************************************************************************
 *
 * Method function _Utf8ToUnicode( ) 
 *
 * Convert UTF8 characters to unicode.
 *
 *   Result is NULL terminated if sufficient space in result
 *   buffer is available.
 * Arguments:
 *
 *   pwResult    -- ptr to start of result buffer for unicode chars
 *   cwResult    -- length of result buffer in WCHAR
 *   pwUtf8      -- ptr to start of UTF8 buffer
 *   cchUtf8     -- length of UTF8 buffer
 *
 * Return Value:
 *   Count of unicode characters in result, if successful.
 *   0 on error.  GetLastError() has error code.
 *
 *******************************************************************************/

DWORD   CSoftKbd::_Utf8ToUnicode(PCHAR  pchUtf8,   DWORD cchUtf8,    PWCHAR pwResult,  DWORD  cwResult)
{
    CHAR    ch;                     // current UTF8 character
    WCHAR   wch;                    // current unicode character
    DWORD   trailCount = 0;         // count of UTF8 trail bytes to follow
    DWORD   lengthUnicode = 0;      // length of unicode result string
    BOOL    bsurrogatePair = FALSE;
    DWORD   surrogateDword;


    //
    //  loop converting UTF8 chars until run out or error
    //

    Assert( cchUtf8 > 0 );

    while ( cchUtf8-- )
    {
        ch = *pchUtf8++;


        //
        //  ASCII character -- just copy
        //

        if ( BIT7(ch) == 0 )
        {
            lengthUnicode++;
            if ( pwResult )
            {
                if ( lengthUnicode >= cwResult )
                {
                   goto OutOfBuffer;
                }
                *pwResult++ = (WCHAR)ch;
            }
            continue;
        }

        //
        //  UTF8 trail byte
        //      - if not expected, error
        //      - otherwise shift unicode character 6 bits and
        //          copy in lower six bits of UTF8
        //      - if last UTF8 byte, copy result to unicode string
        //

        else if ( BIT6(ch) == 0 )
        {
            if ( trailCount == 0 )
            {
                goto InvalidUtf8;
            }

            if ( !bsurrogatePair )
            {
                wch <<= 6;
                wch |= LOW6BITS( ch );

                if ( --trailCount == 0 )
                {
                    lengthUnicode++;
                    if ( pwResult )
                    {
                        if ( lengthUnicode >= cwResult )
                        {
                            goto OutOfBuffer;
                        }
                        *pwResult++ = wch;
                    }
                }
                continue;
            }

            //  surrogate pair
            //      - same as above EXCEPT build two unicode chars
            //      from surrogateDword

            else
            {
                surrogateDword <<= 6;
                surrogateDword |= LOW6BITS( ch );

                if ( --trailCount == 0 )
                {
                    lengthUnicode += 2;

                    if ( pwResult )
                    {
                        if ( lengthUnicode >= cwResult )
                        {
                            goto OutOfBuffer;
                        }
                        surrogateDword -= 0x10000;
                        *pwResult++ = (WCHAR) ((surrogateDword >> 10) + HIGH_SURROGATE_START);
                        *pwResult++ = (WCHAR) ((surrogateDword & 0x3ff) + LOW_SURROGATE_START);
                    }
                    bsurrogatePair = FALSE;
                }
            }

        }

        //
        //  UTF8 lead byte
        //      - if currently in extension, error

        else
        {
            if ( trailCount != 0 )
            {
                goto InvalidUtf8;
            }

            //  first of two byte character (110xxxxx)

            if ( BIT5(ch) == 0 )
            {
                trailCount = 1;
                wch = LOW5BITS(ch);
                continue;
            }

            //  first of three byte character (1110xxxx)

            else if ( BIT4(ch) == 0 )
            {
                trailCount = 2;
                wch = LOW4BITS(ch);
                continue;
            }

            //  first of four byte surrogate pair (11110xxx)

            else if ( BIT3(ch) == 0 )
            {
                trailCount = 3;
                surrogateDword = LOW4BITS(ch);
                bsurrogatePair = TRUE;
            }

            else
            {
                goto InvalidUtf8;
            }
        }
    }

    //  catch if hit end in the middle of UTF8 multi-byte character

    if ( trailCount )
    {
        goto InvalidUtf8;
    }

    //
    //  NULL terminate buffer
    //  return the number of Unicode characters written.
    //

    if ( pwResult  &&  lengthUnicode < cwResult )
    {
        *pwResult = 0;
    }
    return( lengthUnicode );

OutOfBuffer:

    SetLastError( ERROR_INSUFFICIENT_BUFFER );
    return( 0 );

InvalidUtf8:

    SetLastError( ERROR_INVALID_DATA );
    return( 0 );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\softkbd\softkbdui.h ===
//
// This is the header file of softkbd window ui.
//


#ifndef SOFTKBDUI_H
#define SOFTKBDUI_H

#include "private.h"
#include "globals.h"

#include "Softkbdc.h"

#include "cuiwnd.h"

class CSoftkbdUIWnd;

class CTitleUIGripper : public CUIFGripper
{
public:
    CTitleUIGripper( CUIFObject *pParent, const RECT *prc ) : CUIFGripper(pParent,prc) {};
    virtual void OnPaint(HDC hDC);
    virtual void OnLButtonUp( POINT pt );
};

class CSoftkbdButton : public CUIFButton2
{
public:
    CSoftkbdButton(CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle, KEYID keyId);
    virtual ~CSoftkbdButton( void );

    HRESULT  SetSoftkbdBtnBitmap(HINSTANCE hResDll, WCHAR  * wszBitmapStr );
    KEYID    GetKeyId( )  {  return m_keyId; }
    HRESULT  ReleaseButtonResouce( );

private:
    KEYID    m_keyId;
};

class CStaticBitmap : public CUIFObject
{

public:
    CStaticBitmap(CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle);
    virtual  ~CStaticBitmap( void );

    HRESULT   SetStaticBitmap(HINSTANCE hResDll, WCHAR  * wszBitmapStr );
    virtual void OnPaint( HDC hDC );

private:
    HBITMAP m_hBmp;
    HBITMAP m_hBmpMask;
};

class CTitleBarUIObj : public CUIFObject
{
public:
    CTitleBarUIObj(CUIFObject *pWndFrame, const RECT *prc, TITLEBAR_TYPE TitleBar_Type);
    virtual ~CTitleBarUIObj();

    HRESULT _Init(WORD  wIconId,  WORD  wCloseId);

private:
    CStaticBitmap    *m_pIconButton;
    CSoftkbdButton   *m_pCloseButton;
    TITLEBAR_TYPE     m_TitlebarType;
    
};

class CSoftkbdUIWnd : public CUIFWindow
{

public:
   
    CSoftkbdUIWnd(CSoftKbd *pSoftKbd, HINSTANCE hInst,UINT uiWindowStyle=UIWINDOW_TOPMOST | UIWINDOW_TOOLWINDOW | UIWINDOW_WSDLGFRAME);
    ~CSoftkbdUIWnd( );

    void Show( INT iShow );

    LPCTSTR GetClassName( void ) {
            return c_szSoftKbdUIWndClassName;
    }

    LRESULT OnObjectNotify(CUIFObject * pUIObj, DWORD dwCode, LPARAM lParam);
    HWND _CreateSoftkbdWindow(HWND hOwner,  TITLEBAR_TYPE Titlebar_type, INT xPos, INT yPos,  INT width, INT height);
    HRESULT _GenerateWindowLayout( );
    HRESULT _SetKeyLabel( );

    INT     _GetAlphaSetFromReg( );

    HRESULT _OnWindowMove( );

    void SetAlpha(INT bAlpha);
    void HandleMouseMsg( UINT uMsg, POINT pt );
    void OnMouseOutFromWindow( POINT pt );
    void UpdateFont( LOGFONTW  *plfFont );

    virtual CUIFObject *Initialize( void );

private:

    CSoftKbd        *m_pSoftKbd;
    CTitleBarUIObj  *m_TitleBar;

    HFONT           m_hUserTextFont;    // text font set by user.  
                                        // if user doesn't set text font, this member should be NULL, and DEFAULT_GUI_FONT
                                        // will be used.

    TITLEBAR_TYPE   m_Titlebar_Type;
    INT             m_bAlpha;
    BOOL            m_fShowAlphaBlend;
    INT             m_bAlphaSet;
};


#endif /* SOFTKBDUI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\softkbd\softkbdui.cpp ===
// 
// This is implementation of softkbd window UI.
//

#include "private.h"
#include "globals.h"

#include  "softkbdui.h"
#include  "maskbmp.h"
#include  "commctrl.h"
#include  "cuiutil.h"
#include  "immxutil.h"
#include  "cregkey.h"


HBITMAP MyLoadImage(HINSTANCE hInst, LPCSTR pResStr)
{
    HBITMAP hBmpRes;

    hBmpRes = (HBITMAP)LoadBitmap(hInst, pResStr);
    return hBmpRes;
}


/*   C O N V E R T  L O G  F O N T  W T O  A   */
/*------------------------------------------------------------------------------

    Convert LOGFONTW to LOGFONTA

------------------------------------------------------------------------------*/
void ConvertLogFontWtoA( CONST LOGFONTW *plfW, LOGFONTA *plfA )
{
    UINT cpg;

    plfA->lfHeight         = plfW->lfHeight;
    plfA->lfWidth          = plfW->lfWidth;
    plfA->lfEscapement     = plfW->lfEscapement;
    plfA->lfOrientation    = plfW->lfOrientation;
    plfA->lfWeight         = plfW->lfWeight;
    plfA->lfItalic         = plfW->lfItalic;
    plfA->lfUnderline      = plfW->lfUnderline;
    plfA->lfStrikeOut      = plfW->lfStrikeOut;
    plfA->lfCharSet        = plfW->lfCharSet;
    plfA->lfOutPrecision   = plfW->lfOutPrecision;
    plfA->lfClipPrecision  = plfW->lfClipPrecision;
    plfA->lfQuality        = plfW->lfQuality;
    plfA->lfPitchAndFamily = plfW->lfPitchAndFamily;

    DWORD dwChs = plfW->lfCharSet;
    CHARSETINFO ChsInfo = {0};

    if (dwChs != SYMBOL_CHARSET && TranslateCharsetInfo( &dwChs, &ChsInfo, TCI_SRCCHARSET )) 
    {
        cpg = ChsInfo.ciACP;
    }
    else
        cpg  = GetACP();

    WideCharToMultiByte( cpg, 
                         0, 
                         plfW->lfFaceName, 
                         -1, 
                         plfA->lfFaceName, 
                         ARRAYSIZE(plfA->lfFaceName),
                         NULL, 
                         NULL );

}



///////////////////////////////////////////////////////////////////////////////
//
//class CSoftkbdButton
//
///////////////////////////////////////////////////////////////////////////////

CSoftkbdButton::CSoftkbdButton(CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle, KEYID keyId) : CUIFButton2 (pParent, dwID, prc, dwStyle)
{
    m_keyId = keyId;

    CUIFWindow *pUIWnd;
    pUIWnd = pParent->GetUIWnd( );

    m_hFont = pUIWnd->GetFont( );
}


CSoftkbdButton::~CSoftkbdButton( void )
{
    if ( m_hBmp )
    {
        ::DeleteObject( (HGDIOBJ) m_hBmp );
        m_hBmp = NULL;
    }

    if ( m_hBmpMask )
    {
        ::DeleteObject( (HGDIOBJ)m_hBmpMask );
        m_hBmpMask = NULL;
    }

    if ( m_hIcon )
    {
        ::DestroyIcon(m_hIcon);
        m_hIcon = NULL;
    }

}


HRESULT CSoftkbdButton::SetSoftkbdBtnBitmap(HINSTANCE hResDll, WCHAR  * wszBitmapStr)
{
    HRESULT    hr = S_OK;
    char       pBitmapAnsiName[MAX_PATH];
    HBITMAP    hBitMap;

    WideCharToMultiByte(CP_ACP, 0, wszBitmapStr, -1, pBitmapAnsiName, MAX_PATH, NULL, NULL);

    hBitMap = (HBITMAP) MyLoadImage(hResDll,  pBitmapAnsiName);

    if ( hBitMap == NULL )
    {

        if ( hResDll != g_hInst )
        {

           // cannot load it from client-supplied resource dll,
           // try our softkbd.dll to see if there is one internal bitmap for this label.

           hBitMap = (HBITMAP) MyLoadImage(g_hInst,  pBitmapAnsiName);

        }
    }

    if ( hBitMap == NULL )
    {
         hr = E_FAIL;
         return hr;
    }

    CMaskBitmap maskBmp(hBitMap);
            
    maskBmp.Init(GetSysColor(COLOR_BTNTEXT));
    SetBitmap( maskBmp.GetBmp() );
    SetBitmapMask( maskBmp.GetBmpMask() );

    ::DeleteObject(hBitMap);

    return hr;

};

HRESULT  CSoftkbdButton::ReleaseButtonResouce( )
{

    HRESULT  hr = S_OK;

    if ( m_hBmp )
    {
        ::DeleteObject( (HGDIOBJ) m_hBmp );
        m_hBmp = NULL;
    }

    if ( m_hBmpMask )
    {
        ::DeleteObject( (HGDIOBJ)m_hBmpMask );
        m_hBmpMask = NULL;
    }

    if ( m_hIcon )
    {
        ::DestroyIcon(m_hIcon);
        m_hIcon = NULL;
    }

    if (m_pwchText != NULL) {
        delete m_pwchText;
        m_pwchText = NULL;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CStaticBitmap
//
//////////////////////////////////////////////////////////////////////////////


CStaticBitmap::CStaticBitmap(CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle) : CUIFObject(pParent, dwID, prc, dwStyle )
{
    m_hBmp = NULL;
    m_hBmpMask = NULL;
}

CStaticBitmap::~CStaticBitmap( void )
{

    if ( m_hBmp )
    {
        ::DeleteObject(m_hBmp);
        m_hBmp = NULL;
    }

    if ( m_hBmpMask )
    {
        ::DeleteObject(m_hBmpMask);
        m_hBmpMask = NULL;
    }

}

HRESULT  CStaticBitmap::SetStaticBitmap(HINSTANCE hResDll, WCHAR  * wszBitmapStr )
{
    HRESULT    hr = S_OK;
    char       pBitmapAnsiName[MAX_PATH];
    HBITMAP    hBitMap;

    WideCharToMultiByte(CP_ACP, 0, wszBitmapStr, -1, pBitmapAnsiName, MAX_PATH, NULL, NULL);

    hBitMap = (HBITMAP) MyLoadImage(hResDll, pBitmapAnsiName);

    if ( hBitMap == NULL )
    {

        if ( hResDll != g_hInst )
        {

           // cannot load it from client-supplied resource dll,
           // try our softkbd.dll to see if there is one internal bitmap for this label.

           hBitMap = (HBITMAP) MyLoadImage(g_hInst, pBitmapAnsiName);

        }
    }

    if ( hBitMap == NULL )
    {
         hr = E_FAIL;
         return hr;
    }

    CMaskBitmap maskBmp(hBitMap);
            
    maskBmp.Init(GetSysColor(COLOR_BTNTEXT));
    m_hBmp = maskBmp.GetBmp();
    m_hBmpMask = maskBmp.GetBmpMask();

    ::DeleteObject(hBitMap);

    return hr;
}

void CStaticBitmap::OnPaint( HDC hDC )
{

    if ( !hDC || !m_hBmp ||!m_hBmpMask )
        return;

    const RECT *prc = &GetRectRef();
    const int nWidth = prc->right - prc->left;
    const int nHeight= prc->bottom - prc->top;


    HBITMAP hBmp = CreateMaskBmp(&GetRectRef(),
                                 m_hBmp,
                                 m_hBmpMask,
                                 (HBRUSH)(COLOR_3DFACE + 1) , 0, 0);

    DrawState(hDC,
              NULL,
              NULL,
              (LPARAM)hBmp,
              0,
              prc->left,
              prc->top,
              nWidth,
              nHeight,
              DST_BITMAP);
 
    DeleteObject(hBmp);

}

//////////////////////////////////////////////////////////////////////////////
//
//  CTitleUIGripper
//
//////////////////////////////////////////////////////////////////////////////

void CTitleUIGripper::OnPaint(HDC hDC) {

    RECT rc ;

    if (GetRectRef().right-GetRectRef().left <= GetRectRef().bottom-GetRectRef().top) {

        ::SetRect(&rc, GetRectRef().left + 1, 
                       GetRectRef().top, 
                       GetRectRef().left + 4, 
                       GetRectRef().bottom);
    } else {
        ::SetRect(&rc, GetRectRef().left, 
                       GetRectRef().top + 1, 
                       GetRectRef().right, 
                       GetRectRef().top+4);
    }

    DrawEdge(hDC, &rc, BDR_RAISEDINNER, BF_RECT);
}


void CTitleUIGripper::OnLButtonUp( POINT pt )
{
    CSoftkbdUIWnd *pUIWnd;

    // call base class's member function first.
    CUIFGripper::OnLButtonUp(pt);

    pUIWnd = (CSoftkbdUIWnd *)GetUIWnd( );

    if ( pUIWnd != NULL )
    {
        // Notify the Window position move.
        pUIWnd->_OnWindowMove( );
    }

    return;
}

//////////////////////////////////////////////////////////////////////////////
//
// CTitleBarUIObj
//
//////////////////////////////////////////////////////////////////////////////

CTitleBarUIObj::CTitleBarUIObj(CUIFObject *pWndFrame, const RECT *prc, TITLEBAR_TYPE TitleBar_Type)
                           : CUIFObject(pWndFrame, 0, prc, 0)
{
    m_TitlebarType = TitleBar_Type;
    m_pCloseButton = NULL;
    m_pIconButton = NULL;

}


CTitleBarUIObj::~CTitleBarUIObj(void)
{
    HBITMAP  hBitmap;
    HBITMAP  hBitmapMask;

    if ( m_pCloseButton )
    {
        if (hBitmap=m_pCloseButton->GetBitmap()) {
            m_pCloseButton->SetBitmap((HBITMAP) NULL);
            ::DeleteObject(hBitmap);
        }

        if (hBitmapMask=m_pCloseButton->GetBitmapMask()) {
            m_pCloseButton->SetBitmapMask((HBITMAP) NULL);
            ::DeleteObject(hBitmapMask);
        }

    }
}

//----------------------------------------------------------------------------
HRESULT CTitleBarUIObj::_Init(WORD  wIconId,  WORD  wCloseId)
{
    
    HRESULT   hr = S_OK;
   
    RECT rectObj = {0,0,0,0};
    RECT rectGripper;

    if ( m_TitlebarType == TITLEBAR_NONE )
        return hr;

    GetRect(&rectGripper);
    rectObj = rectGripper;

    long lIconWidth=rectObj.bottom-rectObj.top + 1;

    this->m_pointPreferredSize.y=lIconWidth;

    if ( m_TitlebarType == TITLEBAR_GRIPPER_VERTI_ONLY )
    {

        // This is a vertical gripper only title bar.

        rectGripper.left += 2;
        rectGripper.right-= 2;

        rectGripper.top += 2;
        rectGripper.bottom -= 2;

        CUIFObject *pUIFObject=new CTitleUIGripper(this,&rectGripper);

        if ( !pUIFObject )
            return E_OUTOFMEMORY;

        pUIFObject->Initialize();
        this->AddUIObj(pUIFObject);

        return hr;
    }



    if ( m_TitlebarType == TITLEBAR_GRIPPER_HORIZ_ONLY )
    {

        // This is a Horizontal gripper only title bar.

        rectGripper.left  += 2;
        rectGripper.right -= 2;

        rectGripper.top += 2;
        rectGripper.bottom -= 2;

        CUIFObject *pUIFObject=new CTitleUIGripper(this,&rectGripper);
       
        if ( !pUIFObject )
            return E_OUTOFMEMORY;

        pUIFObject->Initialize();
        this->AddUIObj(pUIFObject);

        return hr;
    }

    if ( wIconId != 0 )
    {

        rectObj.right=rectObj.left+lIconWidth;
        m_pIconButton=new CStaticBitmap(this,wIconId,&rectObj,0);
        if (m_pIconButton)
        {
            m_pIconButton->Initialize();
            m_pIconButton->SetStaticBitmap(g_hInst, L"IDB_ICON");
            m_pIconButton->m_pointPreferredSize.x=lIconWidth;
            this->AddUIObj(m_pIconButton);
        }

        rectGripper.left = rectObj.right + 4;
    }

    if ( wCloseId != 0 )
    {

        rectObj.left=rectGripper.right - lIconWidth -1;
        rectObj.right=rectGripper.right;
        m_pCloseButton=new CSoftkbdButton(this,wCloseId,&rectObj,UIBUTTON_SUNKENONMOUSEDOWN | UIBUTTON_CENTER | UIBUTTON_VCENTER, 0);
        if (m_pCloseButton)
        {
            m_pCloseButton->Initialize();
            m_pCloseButton->SetSoftkbdBtnBitmap(g_hInst, L"IDB_CLOSE");
            m_pCloseButton->m_pointPreferredSize.x=lIconWidth;
            this->AddUIObj(m_pCloseButton);
        }

        rectGripper.right = rectObj.left - 4;

    }

    rectGripper.top += 3;

    CUIFObject *pUIFObject=new CTitleUIGripper(this,&rectGripper);
    if ( !pUIFObject )
       return E_OUTOFMEMORY;

    pUIFObject->Initialize();
    this->AddUIObj(pUIFObject);
   

    return hr;

}

///////////////////////////////////////////////////////////////////////////
//
// CSoftkbdUIWnd
//
///////////////////////////////////////////////////////////////////////////

CSoftkbdUIWnd::CSoftkbdUIWnd(CSoftKbd *pSoftKbd, HINSTANCE hInst,UINT uiWindowStyle) : CUIFWindow(hInst, uiWindowStyle)
{                  

    m_pSoftKbd = pSoftKbd;
    m_TitleBar = NULL;
    m_Titlebar_Type = TITLEBAR_NONE;
    m_bAlpha = 0;
    m_fShowAlphaBlend =TRUE; 
    m_hUserTextFont = NULL;

}


CSoftkbdUIWnd::~CSoftkbdUIWnd( )
{

    // if there is hwnd, detroy it and all the children objects.

    if ( m_hWnd  && IsWindow(m_hWnd) )
    {
        ::DestroyWindow( m_hWnd );
        m_hWnd = NULL;
    }

    if ( m_hUserTextFont )
    {
        SetFont((HFONT)NULL);
        DeleteObject(m_hUserTextFont);
        m_hUserTextFont = NULL;
    }
}

const TCHAR c_szCTFLangBar[] = TEXT("Software\\Microsoft\\CTF\\LangBar");
const TCHAR c_szTransparency[] = TEXT("Transparency");

// Get the Alpha Blending set value from registry:
//
//  HKCU\Software\Microsoft\CTF\LangBar:  Transparency : REG_DWORD
//
INT    CSoftkbdUIWnd::_GetAlphaSetFromReg( )
{
    LONG      lret = ERROR_SUCCESS;
    CMyRegKey regkey;
    DWORD     dw = 255;

    lret = regkey.Open(HKEY_CURRENT_USER,
                       c_szCTFLangBar,
                       KEY_READ);

    if (ERROR_SUCCESS == lret)
    {
        lret = regkey.QueryValue(dw, c_szTransparency);
        regkey.Close();
    }

    return (INT)dw;
}


LRESULT CSoftkbdUIWnd::OnObjectNotify(CUIFObject * pUIObj, DWORD dwCode, LPARAM lParam)
{

    KEYID  keyId;
    DWORD  dwObjId;

    UNREFERENCED_PARAMETER(dwCode);
    UNREFERENCED_PARAMETER(lParam);

    if ( m_pSoftKbd == NULL )
        return 0;

    dwObjId = pUIObj->GetID();

    if ( dwObjId != 0 )
    {
        // This is button object, not gripper object.
        CSoftkbdButton   *pButton;

        if ( dwCode == UIBUTTON_PRESSED )
        {

            pButton = (CSoftkbdButton * )pUIObj;

            if ( dwObjId <= MAX_KEY_NUM )
            {
                // regular keys in the keyboard layout.
                keyId = pButton->GetKeyId( );
                m_pSoftKbd->_HandleKeySelection(keyId); 
            }
            else
            {
                // Titlebar buttons
                m_pSoftKbd->_HandleTitleBarEvent(dwObjId);
            }
        }
    }

    return 0;
}

CUIFObject *CSoftkbdUIWnd::Initialize( void )
{
    //
    // Get the current active keyboard layout and register window class
    // not to send VK_PROCESSKEY by mouse down/up in Korean SoftKbd.
    // Related bug#472946 #495890
    //
    LANGID langId = LOWORD(HandleToUlong(GetKeyboardLayout(0)));

    if (PRIMARYLANGID(langId) == LANG_KOREAN)
    {
        //
        // Here register candidate window class.
        //
        WNDCLASSEX WndClass;
        LPCTSTR pszClassName = GetClassName();

        memset(&WndClass, 0, sizeof(WndClass));

        WndClass.cbSize = sizeof(WndClass);
        // Added CS_IME style not to send VK_PROCESSKEY for mouse down/up.
        WndClass.style         = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS | CS_IME;
    
        WndClass.lpfnWndProc   = WindowProcedure;
        WndClass.cbClsExtra    = 0;
        WndClass.cbWndExtra    = 8;
        WndClass.hInstance     = g_hInst;
        WndClass.hIcon         = NULL;
        WndClass.hCursor       = LoadCursor(NULL, IDC_ARROW);
        WndClass.hbrBackground = NULL;
        WndClass.lpszMenuName  = NULL;
        WndClass.lpszClassName = pszClassName;
        WndClass.hIconSm       = NULL;

        RegisterClassEx(&WndClass);
    }

    CUIFObject  *pUIObjRet;
	
    // call CUIFWindow::Initialize() to create tooltip window

    pUIObjRet = CUIFWindow::Initialize();

    return pUIObjRet;
}


HWND CSoftkbdUIWnd::_CreateSoftkbdWindow(HWND hOwner,  TITLEBAR_TYPE Titlebar_type, INT xPos, INT yPos,  INT width, INT height)
{

    HWND  hWnd;

    hWnd = CreateWnd(hOwner);

    Move(xPos, yPos, width, height);

    m_Titlebar_Type = Titlebar_type;

    return hWnd;

}


HRESULT CSoftkbdUIWnd::_GenerateWindowLayout( )
{

    HRESULT         hr=S_OK;
    int             i;
    KBDLAYOUT       *realKbdLayout=NULL;
    KBDLAYOUTDES    *lpCurKbdLayout=NULL;
    CSoftkbdButton  *pButton = NULL;
    int             nChild;


    if ( m_pSoftKbd ==  NULL )
        return E_FAIL;


    if ( (m_TitleBar == NULL) && ( m_Titlebar_Type != TITLEBAR_NONE) )
    {

        RECT   *prc;

        // Get the titlebar rect.

        prc = m_pSoftKbd->_GetTitleBarRect( );

        m_TitleBar = (CTitleBarUIObj  *) new CTitleBarUIObj(this, prc, m_Titlebar_Type);

        if ( m_TitleBar == NULL )
            return E_FAIL;

        m_TitleBar->Initialize( );

        m_TitleBar->_Init(KID_ICON, KID_CLOSE);
        AddUIObj(m_TitleBar);

    }

    // If there is any existing object in this window object, just delete all of them, except for Titlebar object

    nChild = m_ChildList.GetCount();
    for (i=nChild; i>0; i--) {

        CUIFObject  *pUIObj = m_ChildList.Get(i-1);

        if ( pUIObj->GetID( ) != 0 )
        {
            // This is not Gripper

            m_ChildList.Remove(pUIObj);
        
            delete pUIObj;
        }
    }

    // Add all the keys contained in current layout to this window object as its children objects.
    // every key should have already been calculated the correct position and size.

    lpCurKbdLayout = m_pSoftKbd->_GetCurKbdLayout( );

    if ( lpCurKbdLayout == NULL )
        return E_FAIL;

    realKbdLayout = &(lpCurKbdLayout->kbdLayout);

    if ( realKbdLayout == NULL ) return E_FAIL;

    for ( i=0; i<realKbdLayout->wNumberOfKeys; i++) {

        KEYID       keyId;
        RECT        keyRect={0,0,0,0};
        

        keyId = realKbdLayout->lpKeyDes[i].keyId; 

        keyRect.left   = realKbdLayout->lpKeyDes[i].wLeft;
        keyRect.top    = realKbdLayout->lpKeyDes[i].wTop;
        keyRect.right  = realKbdLayout->lpKeyDes[i].wWidth + keyRect.left - 1;
        keyRect.bottom = realKbdLayout->lpKeyDes[i].wHeight + keyRect.top - 1;

        if ( realKbdLayout->lpKeyDes[i].tModifier == none )
        {
            // This is a normal key
            pButton = new CSoftkbdButton(this, i+1, &keyRect, UIBUTTON_SUNKENONMOUSEDOWN | UIBUTTON_CENTER | UIBUTTON_VCENTER, keyId);
        }
        else
        {
            // This is toggle key,  Modifier key.
            pButton = new CSoftkbdButton(this, i+1, &keyRect, UIBUTTON_SUNKENONMOUSEDOWN | UIBUTTON_CENTER | UIBUTTON_VCENTER | UIBUTTON_TOGGLE, keyId);

        }

        Assert(pButton);

        if ( !pButton || !pButton->Initialize() )
        {

            // may need to release all created buttons.
            return E_FAIL;
        }

        // add this button to this window container.
        // button lable ( text or bitmap, or Icon ) will be set later when user selects modification status.

        AddUIObj(pButton);

    }

    return hr;
}


HRESULT CSoftkbdUIWnd::_SetKeyLabel( )
{

    HRESULT         hr=S_OK;
    CSoftkbdButton *pButton; 
    int             i, iIndex;
    ACTIVELABEL    *pCurLabel;
    KEYID           keyId;
    HINSTANCE       hResDll;
    KBDLAYOUTDES   *lpCurKbdLayout=NULL;
    KBDLAYOUT      *realKbdLayout=NULL;
    int            nChild;
    int            nCur;

    if ( m_pSoftKbd ==  NULL )
        return E_FAIL;

    lpCurKbdLayout = m_pSoftKbd->_GetCurKbdLayout( );

    if ( lpCurKbdLayout == NULL )
        return E_FAIL;

    realKbdLayout = &(lpCurKbdLayout->kbdLayout);

    if ( realKbdLayout == NULL ) return E_FAIL;

    if ( (lpCurKbdLayout->lpKeyMapList)->wszResource[0] == L'\0' )
    {
    	// 
    	// There is no separate dll to keep picture key.
    	// probably, it is a standard soft keyboard layout.
    	// so just use internal resource kept in this dll.
        //

    	hResDll = g_hInst;
    }
    else
    {
    	// There is a separate DLL to keep the bitmap resource.

    	CHAR  lpszAnsiResFile[MAX_PATH];

    	WideCharToMultiByte(CP_ACP, 0, (lpCurKbdLayout->lpKeyMapList)->wszResource, -1,
    		                lpszAnsiResFile, MAX_PATH, NULL, NULL );

    	hResDll = (HINSTANCE) LoadLibraryA( lpszAnsiResFile );

    	if ( hResDll == NULL )
    	{

    		Assert(hResDll!=NULL);
    		return E_FAIL;
    	}
    }

    // All the keys are already added to this window container.
    // we need to set the label ( text or picture) based on current m_pSoftKbd setting.

    pCurLabel = m_pSoftKbd->_GetCurLabel( );

    nChild = m_ChildList.GetCount();
    for (nCur = 0; nCur < nChild; nCur++) {

        DWORD  dwObjId;

        pButton = (CSoftkbdButton *)(m_ChildList.Get(nCur));
            
        dwObjId = pButton->GetID( );

        if ( dwObjId == 0 )
        {
            continue;
        }

        // Get the keyindex in CurLabel array.

        keyId = pButton->GetKeyId( );
        iIndex = -1;

        for ( i=0; i<MAX_KEY_NUM; i++ )
        {
            if ( pCurLabel[i].keyId == keyId )
            {
                iIndex = i;
                break;
            }
        }

        if ( iIndex == -1 )
        {
            // Cannot find this key,
            // return error.

            hr = E_FAIL;
            goto CleanUp;
        }


        // Found it, set the label
        //
        // if it is text key, call pButton->SetText( )
        // if it is picture key, call pButton->SetBitmap( )

        // Before we set the lable, we need to release all the previous resources
        // for this key button, so that we will not cause resource leak.

        pButton->ReleaseButtonResouce( );

        if ( pCurLabel[iIndex].LabelType == LABEL_TEXT )
            pButton->SetText( pCurLabel[iIndex].lpLabelText);
        else
        {
            pButton->SetSoftkbdBtnBitmap(hResDll, pCurLabel[iIndex].lpLabelText);
        }

        // if it is Disp_Active, call pButton->Enable(TRUE)
        // if it is gray key,  call pButton->Enable(FALSE)

        if ( pCurLabel[iIndex].LabelDisp == LABEL_DISP_ACTIVE )
        {
            pButton->Enable(TRUE);
        }
        else
        {
            pButton->Enable(FALSE);
        }

    	if ( realKbdLayout->lpKeyDes[dwObjId-1].tModifier != none )
    	{
    		// this is a modifier key ( Toggle key )
    		// check to see if this key is pressed.
    		MODIFYTYPE tModifier;

    		tModifier = realKbdLayout->lpKeyDes[dwObjId-1].tModifier;

    		if ( lpCurKbdLayout->ModifierStatus & (1 << tModifier) )
    		{
    			// this modifier key has been pressed.

                pButton->SetToggleState(TRUE);
    		}
            else
                pButton->SetToggleState(FALSE);
    	}
            
    }

CleanUp:
    //	Release the resource DLL if there is a separate one.

    if ( (lpCurKbdLayout->lpKeyMapList)->wszResource[0] != L'\0' )
    {

    	// There is a separate DLL to keep the bitmap resource.

    	FreeLibrary(hResDll);

    }

    return hr;
}


void CSoftkbdUIWnd::Show( INT  iShow )
{

    KBDLAYOUTDES   *lpCurKbdLayout=NULL;
    KBDLAYOUT      *realKbdLayout=NULL;
    int nChild;
    int i;

    if ( m_pSoftKbd ==  NULL )
        return;

    lpCurKbdLayout = m_pSoftKbd->_GetCurKbdLayout( );

    if ( lpCurKbdLayout == NULL )
        return;

    realKbdLayout = &(lpCurKbdLayout->kbdLayout);
    if ( realKbdLayout == NULL ) return;

    if ( !(iShow & SOFTKBD_SHOW)  || (iShow & SOFTKBD_DONT_SHOW_ALPHA_BLEND) )
       m_fShowAlphaBlend = FALSE;
    else
       m_fShowAlphaBlend = TRUE;
       

    m_bAlphaSet = _GetAlphaSetFromReg( );

    if ( iShow )
    {
        // check the togglable key's state.
        CSoftkbdButton *pButton; 

        nChild = m_ChildList.GetCount();
        for (i = 0; i < nChild; i++) {

            DWORD  dwObjId;
            pButton = (CSoftkbdButton *)m_ChildList.Get(i);
            dwObjId = pButton->GetID( );
            if ( dwObjId == 0 )
            {
                continue;
            }

    	    if ( realKbdLayout->lpKeyDes[dwObjId-1].tModifier != none )
    	    {
    		    // this is a modifier key ( Toggle key )
    		    // check to see if this key is pressed.
    		    MODIFYTYPE tModifier;
    
        		tModifier = realKbdLayout->lpKeyDes[dwObjId-1].tModifier;
    	    	if ( lpCurKbdLayout->ModifierStatus & (1 << tModifier) )
    		    {
    			    // this modifier key has been pressed.
                    pButton->SetToggleState(TRUE);
    		    }
                else
                    pButton->SetToggleState(FALSE);
    	    }
        }
    }

    CUIFWindow::Show((iShow & SOFTKBD_SHOW) ? TRUE : FALSE);

    POINT ptScrn;
   
    GetCursorPos(&ptScrn);
    if (WindowFromPoint(ptScrn) == GetWnd())
        SetAlpha(255);
    else
        SetAlpha(m_bAlphaSet);

    return;

}

void CSoftkbdUIWnd::UpdateFont( LOGFONTW  *plfFont )
{
    if ( !plfFont )
        return;

    HFONT    hNewFont;

    if ( IsOnNT( ) )
        hNewFont = CreateFontIndirectW( plfFont );
    else
    {
        LOGFONTA  lfTextFontA;
        ConvertLogFontWtoA(plfFont, &lfTextFontA);
        hNewFont = CreateFontIndirectA( &lfTextFontA );
    }

    if ( hNewFont )
    {
        SetFont(hNewFont);
        if ( m_hUserTextFont )
            DeleteObject( m_hUserTextFont );

        m_hUserTextFont = hNewFont;
    }
}


HRESULT CSoftkbdUIWnd::_OnWindowMove( )
{
    HRESULT   hr = S_OK;
    ISoftKbdWindowEventSink  *pskbdwndes;

    if ( m_pSoftKbd ==  NULL )
        return E_FAIL;

    pskbdwndes = m_pSoftKbd->_GetSoftKbdWndES( );

    if ( pskbdwndes != NULL )
    {
        pskbdwndes->AddRef( );
        hr = pskbdwndes->OnWindowMove(_xWnd, _yWnd, _nWidth, _nHeight);
        pskbdwndes->Release( );
    }

    return hr;
}


typedef BOOL (WINAPI * SETLAYERWINDOWATTRIBUTE)(HWND, COLORREF, BYTE, DWORD);
void CSoftkbdUIWnd::SetAlpha(INT bAlpha)
{
    if ( !m_fShowAlphaBlend )
       return;

    if ( m_bAlpha == bAlpha )
        return;

    if ( IsOnNT5() )
    {
        HINSTANCE hUser32;

        DWORD dwExStyle = GetWindowLong(GetWnd(), GWL_EXSTYLE);

        SetWindowLong(GetWnd(), GWL_EXSTYLE, dwExStyle | WS_EX_LAYERED);
        hUser32 = GetSystemModuleHandle(TEXT("user32.dll"));
        SETLAYERWINDOWATTRIBUTE  pfnSetLayeredWindowAttributes;
        if (pfnSetLayeredWindowAttributes = (SETLAYERWINDOWATTRIBUTE)GetProcAddress(hUser32, TEXT("SetLayeredWindowAttributes")))
            pfnSetLayeredWindowAttributes(GetWnd(), 0, (BYTE)bAlpha, LWA_ALPHA);

        m_bAlpha = bAlpha;
    }
    return;
}

void CSoftkbdUIWnd::HandleMouseMsg( UINT uMsg, POINT pt )
{
    POINT ptScrn = pt;
    ClientToScreen(GetWnd(), &ptScrn);
    if (WindowFromPoint(ptScrn) == GetWnd())
        SetAlpha(255);
    else
        SetAlpha(m_bAlphaSet);

    CUIFWindow::HandleMouseMsg(uMsg, pt);
}

void CSoftkbdUIWnd::OnMouseOutFromWindow( POINT pt )
{
    UNREFERENCED_PARAMETER(pt);
    SetAlpha(m_bAlphaSet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\acp2anch.cpp ===
//
// acp2anch.cpp
//

#include "private.h"
#include "acp2anch.h"
#include "ic.h"
#include "normal.h"
#include "ic.h"
#include "range.h"
#include "anchoref.h"
#include "txtcache.h"

/* 4eb058b0-34ae-11d3-a745-0050040ab407 */
const IID IID_PRIV_ACPWRAP = { 0x4eb058b0, 0x34ae, 0x11d3, {0xa7, 0x45, 0x00, 0x50, 0x04, 0x0a, 0xb4, 0x07} };

DBG_ID_INSTANCE(CLoaderACPWrap);
DBG_ID_INSTANCE(CACPWrap);

void NormalizeAnchor(CAnchorRef *par)
{
    CACPWrap *paw;
    CAnchor *pa;

    paw = par->_GetWrap();
    pa = par->_GetAnchor();

    if (!pa->IsNormalized())
    {
        paw->_NormalizeAnchor(pa);
    }
}

void NormalizeAnchor(IAnchor *pa)
{
    CAnchorRef *par;

    if ((par = GetCAnchorRef_NA(pa)) == NULL)
    {
        Assert(0); // should never get here
        return;
    }

    NormalizeAnchor(par);
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLoaderACPWrap::CLoaderACPWrap(ITfPersistentPropertyLoaderACP *loader)
{
    Dbg_MemSetThisNameIDCounter(TEXT("CLoaderACPWrap"), PERF_LOADERACP_COUNTER);

    _loader = loader;
    _loader->AddRef();
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLoaderACPWrap::~CLoaderACPWrap()
{
    _loader->Release();
}

//+---------------------------------------------------------------------------
//
// LoadProperty
//
//----------------------------------------------------------------------------

STDAPI CLoaderACPWrap::LoadProperty(const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr, IStream **ppStream)
{
    TF_PERSISTENT_PROPERTY_HEADER_ACP phacp;

    // always normalize before unserializing
    NormalizeAnchor(pHdr->paStart);
    NormalizeAnchor(pHdr->paEnd);

    if (!CACPWrap::_AnchorHdrToACP(pHdr, &phacp))
        return E_FAIL;

    return _loader->LoadProperty(&phacp, ppStream);
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CACPWrap::CACPWrap(ITextStoreACP *ptsi)
{
    Dbg_MemSetThisNameIDCounter(TEXT("CACPWrap"), PERF_ACPWRAP_COUNTER);

    _ptsi = ptsi;
    ptsi->AddRef();
    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CACPWrap::~CACPWrap()
{
    Assert(_ptsi == NULL); // cleared in Release
    Assert(_rgAnchors.Count() == 0); // all anchors should be removed
}

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITextStoreAnchor))
    {
        *ppvObj = SAFECAST(this, ITextStoreAnchor *);
    }
    else if (IsEqualIID(riid, IID_ITextStoreACPSink))
    {
        *ppvObj = SAFECAST(this, ITextStoreACPSink *);
    }
    else if (IsEqualIID(riid, IID_ITextStoreACPServices))
    {
        *ppvObj = SAFECAST(this, ITextStoreACPServices *);
    }
    else if (IsEqualIID(riid, IID_PRIV_ACPWRAP))
    {
        *ppvObj = SAFECAST(this, CACPWrap *);
    }
    else if (IsEqualIID(riid, IID_ITfMouseTrackerACP))
    {
        *ppvObj = SAFECAST(this, ITfMouseTrackerACP *);
    }
    else if (IsEqualIID(riid, IID_IServiceProvider))
    {
        *ppvObj = SAFECAST(this, IServiceProvider *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CACPWrap::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CACPWrap::Release()
{
    _cRef--;
    Assert(_cRef >= 0);

    // nb: this obj has 2 ref counters:
    // _cRef -> external clients
    // _GetAnchorRef -> CAnchorRef's.
    // we won't delete until both reach 0
    if (_cRef == 0)
    {
        // clear out text cache before releasing _ptsi
        // the memory may be reallocated (this happened!) for a different text store
        CProcessTextCache::Invalidate(_ptsi);

        // disconnect the ITextStoreACP
        SafeReleaseClear(_ptsi);

        if (_GetAnchorRef() == 0) // internal ref count
        {
            delete this;
        }
        return 0;
    }

    return _cRef;
}

//+---------------------------------------------------------------------------
//
// OnTextChange
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::OnTextChange(DWORD dwFlags, const TS_TEXTCHANGE *pChange)
{
    IAnchor *paStart = NULL;
    IAnchor *paEnd = NULL;
    HRESULT hr;
    HRESULT hr2;

    if (pChange == NULL)
        return E_INVALIDARG;

    if (_pic->_IsInEditSession())
    {
        Assert(0); // someone other than cicero is editing the doc while cicero holds a lock
        return TS_E_NOLOCK;
    }

#ifdef DEBUG
    _Dbg_fAppHasLock = TRUE;
#endif

    // we never call this internally, so the caller must be the app.
    // nb: we aren't normalizing the anchors here!  They can't be
    // normalized until the app releases its lock in OnLockReleased.
    // Not a bad thing for perf though!  We will merge spans before
    // normalizing...

    // Issue: we aren't handling the case like:
    // "----<a1>ABC<a2>" -> "XX<a1><a2>", where "-" is formatting and <a1> has backwards gravity, <a2> forwards
    // in this case we'd like to see "<a1>XX<a2>" as the final result

    if (pChange->acpStart == pChange->acpOldEnd &&
        pChange->acpOldEnd == pChange->acpNewEnd)
    {
        // nothing happened
        return S_OK;
    }

    hr = E_OUTOFMEMORY;

    if ((paStart = _CreateAnchorACP(pChange->acpStart, TS_GR_BACKWARD)) == NULL)
        goto Exit;
    if ((paEnd = _CreateAnchorACP(pChange->acpOldEnd, TS_GR_FORWARD)) == NULL)
    {
        paStart->Release();
        goto Exit;
    }

    _fInOnTextChange = TRUE; // this flag stops us from trying to normalize anchors

    // do the alist update
    _Update(pChange);

    hr = _pic->_OnTextChangeInternal(dwFlags, paStart, paEnd, OWN_ANCHORS);

    _fInOnTextChange = FALSE;

    // get a lock eventually so we can deal with the changes
    _ptsi->RequestLock(TS_LF_READ, &hr2);

Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
// OnSelectionChange
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::OnSelectionChange()
{
    // we never call this internally, so the caller must be the app.
    return _ptss->OnSelectionChange();
}

//+---------------------------------------------------------------------------
//
// OnLockGranted
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::OnLockGranted(DWORD dwLockFlags)
{
    int i;
    SPAN *pSpan;
    int cSpans;
    CAnchorRef *parStart;
    CAnchorRef *parEnd;
    CSpanSet *pSpanSet;

#ifdef DEBUG
    _Dbg_fAppHasLock = FALSE;
#endif

    // 
    // After IC is popped, we may be granted the lock...
    // 
    if (!_pic || !_pic->_GetEditRecord())
        return E_UNEXPECTED;

    // generally the pic's er can contain app or tip changes
    // BUT, it will never hold both at the same time.  And it will
    // only hold app changes (if any) when OnLockGranted is called
    pSpanSet = _pic->_GetEditRecord()->_GetTextSpanSet();

    // empty out our change cache
    if ((cSpans = pSpanSet->GetCount()) > 0)
    {
        // clean up the anchorlist!
        pSpan = pSpanSet->GetSpans();
        for (i=0; i<cSpans; i++)
        {
            parStart = GetCAnchorRef_NA(pSpan->paStart);
            parEnd = GetCAnchorRef_NA(pSpan->paEnd);

            _Renormalize(parStart->_GetACP(), parEnd->_GetACP());

            pSpan++;
        }
    }

    // then pass along the release to the uim
    return _ptss->OnLockGranted(dwLockFlags);
}

//+---------------------------------------------------------------------------
//
// OnLayoutChange
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::OnLayoutChange(TsLayoutCode lcode, TsViewCookie vcView)
{
    return _ptss->OnLayoutChange(lcode, vcView);
}

//+---------------------------------------------------------------------------
//
// OnStatusChange
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::OnStatusChange(DWORD dwFlags)
{
    return _ptss->OnStatusChange(dwFlags);
}

//+---------------------------------------------------------------------------
//
// OnStatusChange
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::OnAttrsChange(LONG acpStart, LONG acpEnd, ULONG cAttrs, const TS_ATTRID *paAttrs)
{
    IAnchor *paStart = NULL;
    IAnchor *paEnd = NULL;
    HRESULT hr;

    hr = E_OUTOFMEMORY;

    if ((paStart = _CreateAnchorACP(acpStart, TS_GR_BACKWARD)) == NULL)
        goto Exit;
    if ((paEnd = _CreateAnchorACP(acpEnd, TS_GR_FORWARD)) == NULL)
        goto Exit;

    hr = _ptss->OnAttrsChange(paStart, paEnd, cAttrs, paAttrs);

Exit:
    SafeRelease(paStart);
    SafeRelease(paEnd);
    
    return hr;
}

//+---------------------------------------------------------------------------
//
// OnStartEditTransaction
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::OnStartEditTransaction()
{
    return _ptss->OnStartEditTransaction();
}

//+---------------------------------------------------------------------------
//
// OnEndEditTransaction
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::OnEndEditTransaction()
{
    return _ptss->OnEndEditTransaction();
}

//+---------------------------------------------------------------------------
//
// AdviseSink
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::AdviseSink(REFIID riid, IUnknown *punk, DWORD dwMask)
{
    IServiceProvider *psp;
    HRESULT hr;

    Assert(_ptss == NULL);
    Assert(_pic == NULL);

    if (punk->QueryInterface(IID_ITextStoreAnchorSink, (void **)&_ptss) != S_OK)
        return E_FAIL;

    // use QueryService to get the ic since msaa may be wrapping it
    if (punk->QueryInterface(IID_IServiceProvider, (void **)&psp) != S_OK)
    {
        hr = E_FAIL;
        goto ErrorExit;
    }

    hr = psp->QueryService(GUID_SERVICE_TF, IID_PRIV_CINPUTCONTEXT, (void **)&_pic);

    psp->Release();

    if (hr != S_OK)
    {
        hr = E_FAIL;
        goto ErrorExit;
    }

    // advise our wrapped acp
    if ((hr = _ptsi->AdviseSink(IID_ITextStoreACPSink, SAFECAST(this, ITextStoreACPSink *), dwMask)) != S_OK)
        goto ErrorExit;

    return S_OK;

ErrorExit:
    SafeReleaseClear(_ptss);
    SafeReleaseClear(_pic);
    return hr;
}

//+---------------------------------------------------------------------------
//
// UnadviseSink
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::UnadviseSink(IUnknown *punk)
{
    Assert(_ptss == punk); // we're dealing with cicero, this should always hold

    _ptsi->UnadviseSink(SAFECAST(this, ITextStoreACPSink *));

    SafeReleaseClear(_ptss);
    SafeReleaseClear(_pic);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// RequestLock
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::RequestLock(DWORD dwLockFlags, HRESULT *phrSession)
{
    return _ptsi->RequestLock(dwLockFlags, phrSession);
}

//+---------------------------------------------------------------------------
//
// GetSelection
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::GetSelection(ULONG ulIndex, ULONG ulCount, TS_SELECTION_ANCHOR *pSelection, ULONG *pcFetched)
{
    TS_SELECTION_ACP *pSelACP;
    HRESULT hr;
    ULONG i;
    TS_SELECTION_ACP sel;

    Assert(pcFetched != NULL); // caller should have caught this

    *pcFetched = 0;

    if (ulCount == 1)
    {
        pSelACP = &sel;
    }
    else if ((pSelACP = (TS_SELECTION_ACP *)cicMemAlloc(ulCount*sizeof(TS_SELECTION_ACP))) == NULL)
            return E_OUTOFMEMORY;

    hr = _ptsi->GetSelection(ulIndex, ulCount, pSelACP, pcFetched);

    if (hr != S_OK)
        goto Exit;

    _Dbg_AssertNoAppLock();

    for (i=0; i<*pcFetched; i++)
    {
        if ((pSelection[i].paStart = _CreateAnchorACP(pSelACP[i].acpStart, TS_GR_FORWARD)) == NULL ||
            (pSelection[i].paEnd = _CreateAnchorACP(pSelACP[i].acpEnd, TS_GR_BACKWARD)) == NULL)
        {
            SafeRelease(pSelection[i].paStart);
            while (i>0)
            {
                i--;
                pSelection[i].paStart->Release();
                pSelection[i].paEnd->Release();
            }
            hr = E_FAIL;
            goto Exit;
        }

        pSelection[i].style = pSelACP[i].style;
    }

Exit:
    if (pSelACP != &sel)
    {
        cicMemFree(pSelACP);
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// SetSelection
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::SetSelection(ULONG ulCount, const TS_SELECTION_ANCHOR *pSelection)
{
    CAnchorRef *par;
    TS_SELECTION_ACP *pSelACP;
    ULONG i;
    HRESULT hr;
    TS_SELECTION_ACP sel;

    _Dbg_AssertNoAppLock();

    if (ulCount == 1)
    {
        pSelACP = &sel;
    }
    else if ((pSelACP = (TS_SELECTION_ACP *)cicMemAlloc(ulCount*sizeof(TS_SELECTION_ACP))) == NULL)
        return E_OUTOFMEMORY;

    hr = E_FAIL;

    for (i=0; i<ulCount; i++)
    {
        if ((par = GetCAnchorRef_NA(pSelection[i].paStart)) == NULL)
            goto Exit;
        pSelACP[i].acpStart = par->_GetACP();

        if (pSelection[i].paEnd == NULL)
        {
            // implies paEnd is same as paStart
            pSelACP[i].acpEnd = pSelACP[i].acpStart;
        }
        else
        {
            if ((par = GetCAnchorRef_NA(pSelection[i].paEnd)) == NULL)
                goto Exit;
            pSelACP[i].acpEnd = par->_GetACP();
        }

        pSelACP[i].style = pSelection[i].style;
    }

    hr = _ptsi->SetSelection(ulCount, pSelACP);

Exit:
    if (pSelACP != &sel)
    {
        cicMemFree(pSelACP);
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// GetText
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::GetText(DWORD dwFlags, IAnchor *paStart, IAnchor *paEnd, WCHAR *pchText, ULONG cchReq, ULONG *pcch, BOOL fUpdateAnchor)
{
    CAnchorRef *parStart;
    CAnchorRef *parEnd;
    LONG acpStart;
    LONG acpEnd;
    LONG acpNext;
    ULONG cchTotal;
    ULONG cchAdjust;
    ULONG ulRunInfoOut;
    HRESULT hr;
    ULONG i;
    WCHAR ch;
    WCHAR *pchSrc;
    WCHAR *pchDst;
    TS_RUNINFO rgRunInfo[16];

    _Dbg_AssertNoAppLock();

    Perf_IncCounter(PERF_ACPWRAP_GETTEXT);

    // this upfront check for a nop saves us from
    //   1) copying non-existant text based on non-zero run-info
    //   2) repositioning the start anchor based on non-zero run-info
    if (cchReq == 0)
    {       
        *pcch = 0;
        return S_OK;
    }

    if ((parStart = GetCAnchorRef_NA(paStart)) == NULL)
        return E_FAIL;
    acpStart = parStart->_GetACP();

    acpEnd = -1;
    if (paEnd != NULL)
    {
        if ((parEnd = GetCAnchorRef_NA(paEnd)) == NULL)
        {
            hr = E_FAIL;
            goto Exit;
        }
        acpEnd = parEnd->_GetACP();
    }

    cchTotal = 0;

    while (TRUE)
    {
        Perf_IncCounter(PERF_ACPWRAP_GETTEXT_LOOP);
        hr = CProcessTextCache::GetText(_ptsi, acpStart, acpEnd, pchText, cchReq, pcch, rgRunInfo, ARRAYSIZE(rgRunInfo), &ulRunInfoOut, &acpNext);

        if (hr != S_OK)
            goto Exit;

        if (ulRunInfoOut == 0) // prevent a loop at eod
            break;

        // prune out any hidden text
        pchSrc = pchText;
        pchDst = pchText;

        for (i=0; i<ulRunInfoOut; i++)
        {
            switch (rgRunInfo[i].type)
            {
                case TS_RT_PLAIN:
                    Assert(pchDst != NULL);
                    if (pchSrc != pchDst)
                    {
                        memmove(pchDst, pchSrc, rgRunInfo[i].uCount*sizeof(WCHAR));
                    }
                    pchSrc += rgRunInfo[i].uCount;
                    pchDst += rgRunInfo[i].uCount;
                    break;

                case TS_RT_HIDDEN:
                    pchSrc += rgRunInfo[i].uCount;
                    *pcch -= rgRunInfo[i].uCount;
                    Assert((int)(*pcch) >= 0); // app bug if this is less than zero
                    break;

                case TS_RT_OPAQUE:
                    break;
            }
        }

        // prune out any TS_CHAR_REGIONs
        pchSrc = pchText;
        pchDst = pchText;

        for (i=0; i<*pcch; i++)
        {
            ch = *pchSrc;

            if (ch != TS_CHAR_REGION)
            {
                if (pchSrc != pchDst)
                {
                    *pchDst = ch;
                }
                pchDst++;
            }
            pchSrc++;        
        }

        // dec the count by the number of TS_CHAR_REGIONs we removed
        cchAdjust = *pcch - (ULONG)(pchSrc - pchDst);
        cchTotal += cchAdjust;

        // done?
        cchReq -= cchAdjust;
        if (cchReq <= 0)
            break;

        acpStart = acpNext;
        
        if (acpEnd >= 0 && acpStart >= acpEnd)
            break;

        pchText += cchAdjust;
    }

    *pcch = cchTotal;

    if (fUpdateAnchor)
    {
        parStart->_SetACP(acpNext);
    }

Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
// _PostInsertUpdate
//
//----------------------------------------------------------------------------

void CACPWrap::_PostInsertUpdate(LONG acpStart, LONG acpEnd, ULONG cch, const TS_TEXTCHANGE *ptsTextChange)
{
    Assert(ptsTextChange->acpStart <= acpStart); // bogus output from app?

    if (ptsTextChange->acpStart < acpStart &&
        cch > 0 &&
        acpStart != acpEnd)
    {
        // this is unusual.  The original text was like:
        //      ----ABC     "-" is formatting, we replace with "XX"
        //
        // the new text is like:
        //      XX          problem!
        // or possibly
        //      ----XX      no problem
        //
        // if "----ABC" -> "XX", then paStart will be placed after the ABC
        // because it was normalized to start with:
        //
        //      "----<paStart>ABC<paEnd>" -> "XX<paStart><paEnd>"
        //
        // We need to fix this up.
        _DragAnchors(acpStart, ptsTextChange->acpStart);
    }

    _Update(ptsTextChange);   
    _Renormalize(ptsTextChange->acpStart, ptsTextChange->acpNewEnd);
}

//+---------------------------------------------------------------------------
//
// SetText
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::SetText(DWORD dwFlags, IAnchor *paStart, IAnchor *paEnd, const WCHAR *pchText, ULONG cch)
{
    CAnchorRef *parStart;
    CAnchorRef *parEnd;
    LONG acpStart;
    LONG acpEnd;
    TS_TEXTCHANGE dctc;
    HRESULT hr;

    _Dbg_AssertNoAppLock();

    if ((parStart = GetCAnchorRef_NA(paStart)) == NULL)
        return E_FAIL;
    acpStart = parStart->_GetACP();

    if ((parEnd = GetCAnchorRef_NA(paEnd)) == NULL)
        return E_FAIL;
    acpEnd = parEnd->_GetACP();

    // for perf, filter out the nop
    if (acpStart == acpEnd && cch == 0)
        return S_OK;

    // do the work
    hr = _ptsi->SetText(dwFlags, acpStart, acpEnd, pchText, cch, &dctc);

    // we'll handle the anchor updates -- the app won't give us an OnTextChange callback for our
    // own changes
    if (hr == S_OK)
    {
        _PostInsertUpdate(acpStart, acpEnd, cch, &dctc);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// GetFormattedText
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::GetFormattedText(IAnchor *paStart, IAnchor *paEnd, IDataObject **ppDataObject)
{
    CAnchorRef *par;
    LONG acpStart;
    LONG acpEnd;

    Assert(*ppDataObject == NULL);

    _Dbg_AssertNoAppLock();

    if ((par = GetCAnchorRef_NA(paStart)) == NULL)
        return E_FAIL;
    acpStart = par->_GetACP();

    if ((par = GetCAnchorRef_NA(paEnd)) == NULL)
        return E_FAIL;
    acpEnd = par->_GetACP();

    // do the work
    return _ptsi->GetFormattedText(acpStart, acpEnd, ppDataObject);
}

//+---------------------------------------------------------------------------
//
// GetEmbedded
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::GetEmbedded(DWORD dwFlags, IAnchor *paPos, REFGUID rguidService, REFIID riid, IUnknown **ppunk)
{
    CAnchorRef *par;
    LONG acpPos;

    if (ppunk == NULL)
        return E_INVALIDARG;

    *ppunk = NULL;

    if (paPos == NULL)
        return E_INVALIDARG;

    if ((par = GetCAnchorRef_NA(paPos)) == NULL)
        return E_FAIL;

    if (!par->_GetAnchor()->IsNormalized())
    {
        // we need to be positioned just before the next char
        _NormalizeAnchor(par->_GetAnchor());
    }

    acpPos = par->_GetACP();

    if (!(dwFlags & TS_GEA_HIDDEN))
    {
        // skip past any hidden text
        acpPos = Normalize(_ptsi, acpPos, NORM_SKIP_HIDDEN);
    }

    return _ptsi->GetEmbedded(acpPos, rguidService, riid, ppunk);
}

//+---------------------------------------------------------------------------
//
// QueryInsertEmbedded
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::QueryInsertEmbedded(const GUID *pguidService, const FORMATETC *pFormatEtc, BOOL *pfInsertable)
{
    return _ptsi->QueryInsertEmbedded(pguidService, pFormatEtc, pfInsertable);
}

//+---------------------------------------------------------------------------
//
// InsertEmbedded
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::InsertEmbedded(DWORD dwFlags, IAnchor *paStart, IAnchor *paEnd, IDataObject *pDataObject)
{
    CAnchorRef *par;
    LONG acpStart;
    LONG acpEnd;
    TS_TEXTCHANGE dctc;
    HRESULT hr;

    if (paStart == NULL || paEnd == NULL || pDataObject == NULL)
        return E_INVALIDARG;

    if ((par = GetCAnchorRef_NA(paStart)) == NULL)
        return E_FAIL;
    acpStart = par->_GetACP();

    if ((par = GetCAnchorRef_NA(paEnd)) == NULL)
        return E_FAIL;
    acpEnd = par->_GetACP();

    hr =  _ptsi->InsertEmbedded(dwFlags, acpStart, acpEnd, pDataObject, &dctc);

    // we'll handle the anchor updates -- the app won't give us an OnTextChange callback for our
    // own changes
    if (hr == S_OK)
    {
        _PostInsertUpdate(acpStart, acpEnd, 1 /* cch */, &dctc);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// GetStart
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::GetStart(IAnchor **ppaStart)
{
    _Dbg_AssertNoAppLock();

    if (ppaStart == NULL)
        return E_INVALIDARG;

    *ppaStart = NULL;

    return (*ppaStart = _CreateAnchorACP(0, TS_GR_FORWARD)) ? S_OK : E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
// GetEnd
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::GetEnd(IAnchor **ppaEnd)
{
    LONG acpEnd;
    HRESULT hr;

    _Dbg_AssertNoAppLock();

    if (ppaEnd == NULL)
        return E_INVALIDARG;

    *ppaEnd = NULL;

    if (FAILED(hr = _ptsi->GetEndACP(&acpEnd)))
        return hr;

    return (*ppaEnd = _CreateAnchorACP(acpEnd, TS_GR_FORWARD)) ? S_OK : E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
// GetStatus
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::GetStatus(TS_STATUS *pdcs)
{
    return _ptsi->GetStatus(pdcs);
}

//+---------------------------------------------------------------------------
//
// QueryInsert
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::QueryInsert(IAnchor *paTestStart, IAnchor *paTestEnd, ULONG cch, IAnchor **ppaResultStart, IAnchor **ppaResultEnd)
{
    LONG acpTestStart;
    LONG acpTestEnd;
    LONG acpResultStart;
    LONG acpResultEnd;
    CAnchorRef *par;
    HRESULT hr;

    if (ppaResultStart != NULL)
    {
        *ppaResultStart = NULL;
    }
    if (ppaResultEnd != NULL)
    {
        *ppaResultEnd = NULL;
    }
    if (ppaResultStart == NULL || ppaResultEnd == NULL)
        return E_INVALIDARG;

    if ((par = GetCAnchorRef_NA(paTestStart)) == NULL)
        return E_INVALIDARG;
    acpTestStart = par->_GetACP();

    if ((par = GetCAnchorRef_NA(paTestEnd)) == NULL)
        return E_INVALIDARG;
    acpTestEnd = par->_GetACP();

    hr = _ptsi->QueryInsert(acpTestStart, acpTestEnd, cch, &acpResultStart, &acpResultEnd);

    if (hr != S_OK)
        return E_FAIL;

    if (acpResultStart < 0)
    {
        *ppaResultStart = NULL;
    }
    else if ((*ppaResultStart = _CreateAnchorACP(acpResultStart, TS_GR_BACKWARD)) == NULL)
        return E_OUTOFMEMORY;

    if (acpResultEnd < 0)
    {
        *ppaResultEnd = NULL;
    }
    else if ((*ppaResultEnd = _CreateAnchorACP(acpResultEnd, TS_GR_FORWARD)) == NULL)
    {
        SafeRelease(*ppaResultStart);
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetAnchorFromPoint
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::GetAnchorFromPoint(TsViewCookie vcView, const POINT *pt, DWORD dwFlags, IAnchor **ppaSite)
{
    LONG acp;

    if (ppaSite != NULL)
    {
        *ppaSite = NULL;
    }
    if (pt == NULL || ppaSite == NULL)
        return E_INVALIDARG;

    if (dwFlags & ~(GXFPF_ROUND_NEAREST | GXFPF_NEAREST))
        return E_INVALIDARG;

    if (FAILED(_ptsi->GetACPFromPoint(vcView, pt, dwFlags, &acp)))
        return E_FAIL;

    _Dbg_AssertNoAppLock();

    return (*ppaSite = _CreateAnchorACP(acp, TS_GR_FORWARD)) ? S_OK : E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
// GetTextExt
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::GetTextExt(TsViewCookie vcView, IAnchor *paStart, IAnchor *paEnd, RECT *prc, BOOL *pfClipped)
{
    CAnchorRef *par;
    LONG acpStart;
    LONG acpEnd;

    _Dbg_AssertNoAppLock();

    if (prc != NULL)
    {
        memset(prc, 0, sizeof(*prc));
    }
    if (pfClipped != NULL)
    {
        *pfClipped = FALSE;
    }
    if (paStart == NULL || paEnd == NULL || prc == NULL || pfClipped == NULL)
        return E_INVALIDARG;

    if ((par = GetCAnchorRef_NA(paStart)) == NULL)
        return E_FAIL;
    acpStart = par->_GetACP();

    if ((par = GetCAnchorRef_NA(paEnd)) == NULL)
        return E_FAIL;
    acpEnd = par->_GetACP();

    return _ptsi->GetTextExt(vcView, acpStart, acpEnd, prc, pfClipped);
}

//+---------------------------------------------------------------------------
//
// GetScreenExt
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::GetScreenExt(TsViewCookie vcView, RECT *prc)
{
    if (prc == NULL)
        return E_INVALIDARG;

    return _ptsi->GetScreenExt(vcView, prc);
}

//+---------------------------------------------------------------------------
//
// GetWnd
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::GetWnd(TsViewCookie vcView, HWND *phwnd)
{
    if (phwnd == NULL)
        return E_INVALIDARG;

    return _ptsi->GetWnd(vcView, phwnd);
}

//+---------------------------------------------------------------------------
//
// Serialize
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::Serialize(ITfProperty *pProp, ITfRange *pRange, TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr, IStream *pStream)
{
#ifdef LATER
    // word won't grant us a sync lock here even though we need one
    SERIALIZE_ACP_PARAMS params;
    HRESULT hr;

    params.pWrap = this;
    params.pProp = pProp;
    params.pRange = pRange;
    params.pHdr = pHdr;
    params.pStream = pStream;

    // need a sync read lock to do our work
    if (_pic->_DoPseudoSyncEditSession(TF_ES_READ, PSEUDO_ESCB_SERIALIZE_ACP, &params, &hr) != S_OK)
    {
        Assert(0); // app won't give us a sync read lock
        return E_FAIL;
    }

    return hr;
#else
    return _Serialize(pProp, pRange, pHdr, pStream);
#endif
}

//+---------------------------------------------------------------------------
//
// _Serialize
//
//----------------------------------------------------------------------------

HRESULT CACPWrap::_Serialize(ITfProperty *pProp, ITfRange *pRange, TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr, IStream *pStream)
{
    TF_PERSISTENT_PROPERTY_HEADER_ANCHOR phanch;
    CProperty *pPropP = NULL;
    CRange *pRangeP;
    HRESULT hr = E_FAIL;

    if ((pPropP = GetCProperty(pProp)) == NULL)
        goto Exit;

    if ((pRangeP = GetCRange_NA(pRange)) == NULL)
        goto Exit;

    if (!VerifySameContext(_pic, pRangeP))
        goto Exit;

    hr = pPropP->_Serialize(pRangeP, &phanch, pStream);

    if (hr == S_OK)
    {
        if (!_AnchorHdrToACP(&phanch, pHdr))
        { 
            memset(pHdr, 0, sizeof(TF_PERSISTENT_PROPERTY_HEADER_ACP));
            hr = E_FAIL;
            Assert(0);
        }
    }
    else
    {
        memset(pHdr, 0, sizeof(TF_PERSISTENT_PROPERTY_HEADER_ACP));
    }

    Assert(pHdr->ichStart >= 0);
    Assert(pHdr->cch >= 0);

    SafeRelease(phanch.paStart);
    SafeRelease(phanch.paEnd);

Exit:
    SafeRelease(pPropP);

    return hr;
}

//+---------------------------------------------------------------------------
//
// Unserialize
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::Unserialize(ITfProperty *pProp, const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr, IStream *pStream, ITfPersistentPropertyLoaderACP *pLoaderACP)
{
    UNSERIALIZE_ACP_PARAMS params;
    HRESULT hr;

    params.pWrap = this;
    params.pProp = pProp;
    params.pHdr = pHdr;
    params.pStream = pStream;
    params.pLoaderACP = pLoaderACP;

    // need a sync read lock to do our work
    if (_pic->_DoPseudoSyncEditSession(TF_ES_READ, PSEUDO_ESCB_UNSERIALIZE_ACP, &params, &hr) != S_OK)
    {
        Assert(0); // app won't give us a sync read lock
        return E_FAIL;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// _Unserialize
//
//----------------------------------------------------------------------------

HRESULT CACPWrap::_Unserialize(ITfProperty *pProp, const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr, IStream *pStream, ITfPersistentPropertyLoaderACP *pLoaderACP)
{
    TF_PERSISTENT_PROPERTY_HEADER_ANCHOR hdrAnchor;
    CProperty *pPropP = NULL;
    CLoaderACPWrap *pLoader;
    HRESULT hr = E_FAIL;

    Assert(pHdr->ichStart >= 0);
    Assert(pHdr->cch > 0);

    hdrAnchor.paStart = NULL;
    hdrAnchor.paEnd = NULL;

    if (pHdr->ichStart < 0)
        goto Exit;

    if (pHdr->cch <= 0)
        goto Exit;

    if (_ACPHdrToAnchor(pHdr, &hdrAnchor) != S_OK)
    {
        Assert(0);
        goto Exit;
    }

    if ((pPropP = GetCProperty(pProp)) == NULL)
        goto Exit;

    pLoader = NULL;

    if (pLoaderACP != NULL &&
        (pLoader = new CLoaderACPWrap(pLoaderACP)) == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = pPropP->_Unserialize(&hdrAnchor, pStream, pLoader);

    SafeRelease(pLoader);

Exit:
    SafeRelease(pPropP);
    SafeRelease(hdrAnchor.paStart);
    SafeRelease(hdrAnchor.paEnd);

    return hr;
}

//+---------------------------------------------------------------------------
//
// ForceLoadProperty
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::ForceLoadProperty(ITfProperty *pProp)
{
    CProperty *pPropP;
    HRESULT hr;

    if ((pPropP = GetCProperty(pProp)) == NULL)
        return E_FAIL;

    hr = pPropP->ForceLoad();

    pPropP->Release();

    return hr;
}

//+---------------------------------------------------------------------------
//
// CreateRange
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::CreateRange(LONG acpStart, LONG acpEnd, ITfRangeACP **ppRange)
{
    ITfRangeAnchor *rangeAnchor;
    CAnchorRef *paStart;
    CAnchorRef *paEnd;
    HRESULT hr;
    ITextStoreAnchorServices *pserv;

    if (ppRange == NULL)
        return E_INVALIDARG;

    *ppRange = NULL;
    hr = E_FAIL;
    paEnd = NULL;

    Perf_IncCounter(PERF_CREATERANGE_ACP);

    if ((paStart = _CreateAnchorACP(acpStart, TS_GR_BACKWARD)) == NULL)
        goto Exit;
    if ((paEnd = _CreateAnchorACP(acpEnd, TS_GR_BACKWARD)) == NULL)
        goto Exit;

    if ((hr = _ptss->QueryInterface(IID_ITextStoreAnchorServices, (void **)&pserv)) == S_OK)
    {
        hr = pserv->CreateRange(paStart, paEnd, &rangeAnchor);
        pserv->Release();
    }

    if (hr == S_OK)
    {
        *ppRange = (ITfRangeACP *)(CRange *)rangeAnchor;
    }

Exit:
    SafeRelease(paStart);
    SafeRelease(paEnd);

    return hr;
}

//+---------------------------------------------------------------------------
//
// _CreateAnchorACP
//
//----------------------------------------------------------------------------

CAnchorRef *CACPWrap::_CreateAnchorACP(LONG acp, TsGravity gravity)
{
    CAnchorRef *pa;

    if ((pa = new CAnchorRef) == NULL)
        return NULL;

    if (!pa->_Init(this, acp, gravity))
    {
        pa->Release();
        return NULL;
    }

    return pa;
}

//+---------------------------------------------------------------------------
//
// _CreateAnchorACP
//
//----------------------------------------------------------------------------

CAnchorRef *CACPWrap::_CreateAnchorAnchor(CAnchor *paAnchor, TsGravity gravity)
{
    CAnchorRef *pa;

    if ((pa = new CAnchorRef) == NULL)
        return NULL;

    if (!pa->_Init(this, paAnchor, gravity))
    {
        pa->Release();
        return NULL;
    }

    return pa;
}

//+---------------------------------------------------------------------------
//
// _ACPHdrToAnchor
//
//----------------------------------------------------------------------------

HRESULT CACPWrap::_ACPHdrToAnchor(const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr, TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *phanch)
{
    phanch->paStart = NULL;

    if ((phanch->paStart = _CreateAnchorACP(pHdr->ichStart, TS_GR_FORWARD)) == NULL)
        goto ExitError;
    if ((phanch->paEnd = _CreateAnchorACP(pHdr->ichStart + pHdr->cch, TS_GR_BACKWARD)) == NULL)
        goto ExitError;

    phanch->guidType = pHdr->guidType;
    phanch->cb = pHdr->cb;
    phanch->dwPrivate = pHdr->dwPrivate;
    phanch->clsidTIP = pHdr->clsidTIP;

    return S_OK;

ExitError:
    SafeRelease(phanch->paStart);
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
// _AnchorHdrToACP
//
//----------------------------------------------------------------------------

/* static */
BOOL CACPWrap::_AnchorHdrToACP(const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *phanch, TF_PERSISTENT_PROPERTY_HEADER_ACP *phacp)
{
    CAnchorRef *par;

    if ((par = GetCAnchorRef_NA(phanch->paStart)) == NULL)
        return FALSE;
    NormalizeAnchor(par);
    phacp->ichStart = par->_GetACP();

    if ((par = GetCAnchorRef_NA(phanch->paEnd)) == NULL)
        return FALSE;
    NormalizeAnchor(par);
    phacp->cch = par->_GetACP() - phacp->ichStart;

    phacp->guidType = phanch->guidType;
    phacp->cb = phanch->cb;
    phacp->dwPrivate = phanch->dwPrivate;
    phacp->clsidTIP = phanch->clsidTIP;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// RequestSupportedAttrs 
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::RequestSupportedAttrs(DWORD dwFlags, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs)
{
    return _ptsi->RequestSupportedAttrs(dwFlags, cFilterAttrs, paFilterAttrs);
}

//+---------------------------------------------------------------------------
//
// RequestAttrsAtPosition
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::RequestAttrsAtPosition(IAnchor *paPos, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs, DWORD dwFlags)
{
    CAnchorRef *par;
    LONG acpPos;

    if ((par = GetCAnchorRef_NA(paPos)) == NULL)
        return E_INVALIDARG;
    acpPos = par->_GetACP();

    return _ptsi->RequestAttrsAtPosition(acpPos, cFilterAttrs, paFilterAttrs, dwFlags);
}

//+---------------------------------------------------------------------------
//
// RequestAttrsTransitioningAtPosition
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::RequestAttrsTransitioningAtPosition(IAnchor *paPos, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs, DWORD dwFlags)
{
    CAnchorRef *par;
    LONG acpPos;

    if ((par = GetCAnchorRef_NA(paPos)) == NULL)
        return E_INVALIDARG;
    acpPos = par->_GetACP();

    return _ptsi->RequestAttrsTransitioningAtPosition(acpPos, cFilterAttrs, paFilterAttrs, dwFlags);
}

//+---------------------------------------------------------------------------
//
// FindNextAttrTransition
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::FindNextAttrTransition(IAnchor *paStart, IAnchor *paHalt, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs, DWORD dwFlags, BOOL *pfFound, LONG *plFoundOffset)
{
    CAnchorRef *parStart;
    CAnchorRef *parHalt;
    LONG acpStart;
    LONG acpHalt;
    LONG acpNext;
    HRESULT hr;

    if ((parStart = GetCAnchorRef_NA(paStart)) == NULL)
        return E_INVALIDARG;
    acpStart = parStart->_GetACP();

    acpHalt = -1;
    if (paHalt != NULL)
    {
        hr = E_INVALIDARG;
        if ((parHalt = GetCAnchorRef_NA(paHalt)) == NULL)
            goto Exit;
        acpHalt = parHalt->_GetACP();
    }

    hr = _ptsi->FindNextAttrTransition(acpStart, acpHalt, cFilterAttrs, paFilterAttrs, dwFlags, &acpNext, pfFound, plFoundOffset);

    if (hr == S_OK &&
        (dwFlags & TS_ATTR_FIND_UPDATESTART))
    {
        parStart->_SetACP(acpNext);
    }

Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
// RetrieveRequestedAttrs
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::RetrieveRequestedAttrs(ULONG ulCount, TS_ATTRVAL *paAttrVals, ULONG *pcFetched)
{
    return _ptsi->RetrieveRequestedAttrs(ulCount, paAttrVals, pcFetched);
}

//+---------------------------------------------------------------------------
//
// AdviseMouseSink
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::AdviseMouseSink(ITfRangeACP *range, ITfMouseSink *pSink, DWORD *pdwCookie)
{
    ITfMouseTrackerACP *pTrackerACP;
    HRESULT hr;

    if (pdwCookie == NULL)
        return E_INVALIDARG;

    *pdwCookie = 0;

    if (_ptsi->QueryInterface(IID_ITfMouseTrackerACP, (void **)&pTrackerACP) != S_OK)
        return E_NOTIMPL;

    hr = pTrackerACP->AdviseMouseSink(range, pSink, pdwCookie);

    pTrackerACP->Release();
    return hr;
}

//+---------------------------------------------------------------------------
//
// UnadviseMouseSink
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::UnadviseMouseSink(DWORD dwCookie)
{
    ITfMouseTrackerACP *pTrackerACP;
    HRESULT hr;

    if (_ptsi->QueryInterface(IID_ITfMouseTrackerACP, (void **)&pTrackerACP) != S_OK)
        return E_NOTIMPL;

    hr = pTrackerACP->UnadviseMouseSink(dwCookie);

    pTrackerACP->Release();
    return hr;
}

//+---------------------------------------------------------------------------
//
// QueryService
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    IServiceProvider *psp;
    HRESULT hr;

    if (ppv == NULL)
        return E_INVALIDARG;

    *ppv = NULL;

    // SVC_E_NOSERVICE is proper return code for wrong service....
    // but it's not defined anywhere.  So use E_NOINTERFACE for both
    // cases as trident is rumored to do
    hr =  E_NOINTERFACE;

    if (IsEqualGUID(guidService, GUID_SERVICE_TF) &&
        IsEqualIID(riid, IID_PRIV_ACPWRAP))
    {
        *ppv = this;
        AddRef();
        hr = S_OK;
    }
    else if (_ptsi->QueryInterface(IID_IServiceProvider, (void **)&psp) == S_OK)
    {
        // we just pass the request along to the wrapped obj
        hr = psp->QueryService(guidService, riid, ppv);
        psp->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// GetActiveView
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::GetActiveView(TsViewCookie *pvcView)
{
    if (pvcView == NULL)
        return E_INVALIDARG;

    return _ptsi->GetActiveView(pvcView);
}

//+---------------------------------------------------------------------------
//
// InsertTextAtSelection
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::InsertTextAtSelection(DWORD dwFlags, const WCHAR *pchText, ULONG cch, IAnchor **ppaStart, IAnchor **ppaEnd)
{
    LONG acpStart;
    LONG acpEnd;
    TS_TEXTCHANGE dctc;
    HRESULT hr;

    _Dbg_AssertNoAppLock();

    Assert(ppaStart != NULL && ppaEnd != NULL);
    Assert((dwFlags & TS_IAS_QUERYONLY) || pchText != NULL); // caller should have already caught this
    Assert((dwFlags & TS_IAS_QUERYONLY) || cch > 0); // caller should have already caught this
    Assert((dwFlags & (TS_IAS_NOQUERY | TS_IAS_QUERYONLY)) != (TS_IAS_NOQUERY | TS_IAS_QUERYONLY));

    *ppaStart = NULL;
    *ppaEnd = NULL;

    hr = _ptsi->InsertTextAtSelection(dwFlags, pchText, cch, &acpStart, &acpEnd, &dctc);

    // we'll handle the anchor updates -- the app won't give us an OnTextChange callback for our
    // own changes
    if (hr != S_OK)
        return hr;

    if (!(dwFlags & TF_IAS_QUERYONLY))
    {
        _PostInsertUpdate(acpStart, acpEnd, cch, &dctc);
    }

    if (!(dwFlags & TF_IAS_NOQUERY))
    {
        if ((*ppaStart = _CreateAnchorACP(acpStart, TS_GR_BACKWARD)) == NULL)
            goto ExitError;
        if ((*ppaEnd = _CreateAnchorACP(acpEnd, TS_GR_FORWARD)) == NULL)
            goto ExitError;
    }

    return S_OK;

ExitError:
    SafeReleaseClear(*ppaStart);
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
// InsertEmbeddedAtSelection
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::InsertEmbeddedAtSelection(DWORD dwFlags, IDataObject *pDataObject, IAnchor **ppaStart, IAnchor **ppaEnd)
{
    LONG acpStart;
    LONG acpEnd;
    TS_TEXTCHANGE dctc;
    HRESULT hr;

    _Dbg_AssertNoAppLock();

    Assert(ppaStart != NULL && ppaEnd != NULL);
    Assert((dwFlags & (TS_IAS_NOQUERY | TS_IAS_QUERYONLY)) != (TS_IAS_NOQUERY | TS_IAS_QUERYONLY));
    Assert((dwFlags & TS_IAS_QUERYONLY) || pDataObject == NULL);

    *ppaStart = NULL;
    *ppaEnd = NULL;

    hr = _ptsi->InsertEmbeddedAtSelection(dwFlags, pDataObject, &acpStart, &acpEnd, &dctc);

    // we'll handle the anchor updates -- the app won't give us an OnTextChange callback for our
    // own changes
    if (hr != S_OK)
        return hr;

    if (!(dwFlags & TF_IAS_QUERYONLY))
    {
        _PostInsertUpdate(acpStart, acpEnd, 1 /* cch */, &dctc);
    }

    if (!(dwFlags & TF_IAS_NOQUERY))
    {
        if ((*ppaStart = _CreateAnchorACP(acpStart, TS_GR_BACKWARD)) == NULL)
            goto ExitError;
        if ((*ppaEnd = _CreateAnchorACP(acpEnd, TS_GR_FORWARD)) == NULL)
            goto ExitError;
    }

    return S_OK;

ExitError:
    SafeReleaseClear(*ppaStart);
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\anchor.cpp ===
//
// anchor.cpp
//
// CACPWrap
//

#include "private.h"
#include "anchor.h"
#include "globals.h"
#include "normal.h"
#include "anchoref.h"
#include "txtcache.h"

DBG_ID_INSTANCE(CAnchor);

//+---------------------------------------------------------------------------
//
// _NormalizeAnchor
//
//----------------------------------------------------------------------------

void CACPWrap::_NormalizeAnchor(CAnchor *pa)
{
    int iNew;
    int iCurrent;
    LONG acpNew;
    CAnchor *paInto;

    AssertPrivate(!pa->_fNormalized); // perf: we shouldn't normalize more than once

    Perf_IncCounter(PERF_LAZY_NORM);

    acpNew = Normalize(_ptsi, pa->GetIch());

    pa->_fNormalized = TRUE;

    if (acpNew == pa->GetIch())
        return;

    _Find(pa->GetIch(), &iCurrent);
    paInto = _Find(acpNew, &iNew);
    _Update(pa, acpNew, iCurrent, paInto, iNew);

    if (paInto == NULL)
    {
        // the target anchor didn't get merged, pretend it did
        paInto = pa;
    }
    else
    {
        // the target anchor got merged
        // need to set the norm bit for the anchor it got merged into
        paInto->_fNormalized = TRUE;
    }

    // we may have just skipped over anchors to the right of this one
    // handle those guys now
    while ((pa = _rgAnchors.Get(iCurrent)) != paInto)
    {
        Assert(pa->GetIch() < acpNew);

        _Merge(paInto, pa);
    }    

    _Dbg_AssertAnchors();
}

//+---------------------------------------------------------------------------
//
// _DragAnchors
//
//----------------------------------------------------------------------------

void CACPWrap::_DragAnchors(LONG acpFrom, LONG acpTo)
{
    CAnchor *paFrom;
    CAnchor *paTo;
    int iFrom;
    int iTo;
    int i;

    Assert(acpFrom > acpTo); // this method only handles dragging to the left

    _Find(acpFrom, &iFrom);
    if (iFrom < 0)
        return; // nothing to drag

    if (!_Find(acpTo, &iTo))
    {
        // if acpTo isn't occupied, drag to the next highest anchor
        iTo++;
    }

    if (iTo > iFrom)
        return; // nothing to drag, iTo and iFrom ref anchors to the left of acpTo

    // merge all the anchors into the left most
    paTo = _rgAnchors.Get(iTo);

    for (i=iFrom; i>iTo; i--)
    {
        paFrom = _rgAnchors.Get(i);
        Assert(paFrom->GetIch() > paTo->GetIch());

        _Merge(paTo, paFrom);
    }

    // if the left most anchor isn't already positioned, do that now
    paTo->SetACP(acpTo);

    _Dbg_AssertAnchors();
}

//+---------------------------------------------------------------------------
//
// _Insert
//
//----------------------------------------------------------------------------

HRESULT CACPWrap::_Insert(CAnchorRef *par, LONG ich)
{
    int i;
    CAnchor *pa;

    if ((pa = _Find(ich, &i)) == NULL)
    {
        // this ich isn't in the array, allocate a new anchor
        if ((pa = new CAnchor) == NULL)
            return E_OUTOFMEMORY;

        // and insert it into the array
        if (!_rgAnchors.Insert(i+1, 1))
        {
            delete pa;
            return E_FAIL;
        }

        // update _lPendingDeltaIndex
        if (i+1 <= _lPendingDeltaIndex)
        {
            _lPendingDeltaIndex++;
        }
        else
        {
            // new anchor is covered by a pending delta, so account for it
            ich -= _lPendingDelta;
        }

        pa->_paw = this;
        pa->_ich = ich;

        _rgAnchors.Set(i+1, pa);
    }

    return _Insert(par, pa);
}

//+---------------------------------------------------------------------------
//
// _Insert
//
//----------------------------------------------------------------------------

HRESULT CACPWrap::_Insert(CAnchorRef *par, CAnchor *pa)
{
    par->_pa = pa;
    par->_prev = NULL;
    par->_next = pa->_parFirst;
    if (pa->_parFirst)
    {
        Assert(pa->_parFirst->_prev == NULL);
        pa->_parFirst->_prev = par;
    }
    pa->_parFirst = par;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Remove
//
//----------------------------------------------------------------------------

void CACPWrap::_Remove(CAnchorRef *parIn)
{
    CAnchor *pa = parIn->_pa;

    if (parIn->_prev != NULL)
    {
        // make the previous guy point past parIn
        parIn->_prev->_next = parIn->_next;
    }
    else
    {
        // this par is at the head of the list
        pa->_parFirst = parIn->_next;
    }
    if (parIn->_next != NULL)
    {
        parIn->_next->_prev = parIn->_prev;
    }

    if (pa->_parFirst == NULL)
    {
        // no more refs, delete the anchor
        _Delete(pa);
    }
}

//+---------------------------------------------------------------------------
//
// Remove
//
//----------------------------------------------------------------------------

void CACPWrap::_Delete(CAnchor *pa)
{
    int i;

    if (_Find(pa->GetIch(), &i) == pa)
    {
        _rgAnchors.Remove(i, 1);

        // update _lPendingDeltaIndex
        if (i < _lPendingDeltaIndex)
        {
            _lPendingDeltaIndex--;
        }
    }

    delete pa;
}

//+---------------------------------------------------------------------------
//
// Update
//
// Normalization is handled by the caller who needs to use Renormalize after
// calling this method.
//----------------------------------------------------------------------------

void CACPWrap::_Update(const TS_TEXTCHANGE *pdctc)
{
    int iStart;
    int ichEndOrg;
    int iEndOrg;
    int iEndNew;
    CAnchorRef *par;
    CAnchorRef **ppar;
    CAnchor *paStart;
    CAnchor *paEnd;
    CAnchor *paInto;
    BOOL fExactEndMatch;
    int dSize;
    int iDeltaStart;
    int ichStart = pdctc->acpStart;
    int ichEndOld = pdctc->acpOldEnd;
    int ichEndNew = pdctc->acpNewEnd;

    // always invalidate our text cache
    CProcessTextCache::Invalidate(_ptsi);

    Assert(ichStart >= 0);
    Assert(ichEndOld >= ichStart);
    Assert(ichEndNew >= ichStart);

    if (_rgAnchors.Count() == 0) // any anchors?
        return;

    dSize = ichEndNew - ichEndOld;

    if (dSize == 0)
        return;

    paStart = _Find(ichStart, &iStart);
    if (paStart == NULL)
    {
        iStart++; // return value was anchor closest to but less than ichStart

        if (iStart >= _rgAnchors.Count())
        {
            // there aren't any anchors >= iStart, so bail, nothing to do
            return;
        }

        paStart = _rgAnchors.Get(iStart);
        
        if (iStart == 0 && paStart->GetIch() > ichEndOld)
        {
            // the delta is to the left of all the ranges
            _AdjustIchs(0, dSize);
            _Dbg_AssertAnchors();
            return;
        }
    }
    paEnd = _Find(ichEndOld, &iEndOrg);
    if (paEnd == NULL)
    {
        Assert(iEndOrg >= 0); // there should be at least one anchor <= ichEndOld
                              // if we made it this far
        fExactEndMatch = FALSE;
        paEnd = _rgAnchors.Get(iEndOrg);
    }
    else
    {
        fExactEndMatch = TRUE;
    }

    if (dSize < 0)
    {
        // if dSize < 0, then gotta merge all the anchors between old, new pos
        if (paEnd->GetIch() > ichEndNew) // are there any anchors between old, new pos?
        {
            // track change history

            // drag the paEnd to its new position
            ichEndOrg = paEnd->GetIch();
            paInto = _Find(ichEndNew, &iEndNew);

            _TrackDelHistory(iEndOrg, fExactEndMatch, iEndNew, paInto != NULL);

            iEndNew = _Update(paEnd, ichEndNew, iEndOrg, paInto, iEndNew);
            _Find(ichEndOrg, &iEndOrg); // might be a prev anchor if paEnd got deleted in Update!

            while (iEndOrg > iEndNew)
            {
                // don't try to cache pointers, _rgAnchors might get realloc'd
                // during the _Merge!
                _Merge(_rgAnchors.Get(iEndNew), _rgAnchors.Get(iEndOrg));
                iEndOrg--;
            }

            iEndOrg = iEndNew; // for below
        }
        // iEndOrg was updated so let's start from next.
        iDeltaStart = iEndOrg + 1;
    }
    else // dSize > 0
    {
        // iEndOrg will be < iStart when the delta fits entirely between two existing anchors
        Assert(iEndOrg >= iStart || (iEndOrg == iStart - 1));
        iDeltaStart = (iEndOrg <= iStart) ? iEndOrg + 1 : iEndOrg;
    }

    // update all the following anchors
    _AdjustIchs(iDeltaStart, dSize);

    if (dSize > 0 && paStart == paEnd)
    {
        // Need to account for gravity in the case of an insert to a single anchor pos.
        // In practice, this means that we have to handle the anchor refs at the insertion
        // anchor individually -- some will want to shift left, others right.

        ppar = &paStart->_parFirst;
        while (par = *ppar)
        {
            if (par->_fForwardGravity)
            {
                // remove the ref from this anchor
                *ppar = par->_next;
                if (par->_next != NULL)
                {
                    par->_next->_prev = par->_prev;
                }

                // shove the ref over, it needs to be moved.  Insert adds to the head of the list
                // so this call is fast and in constant time.
                _Insert(par, paStart->GetIch() + dSize);
            }
            else
            {
                ppar = &par->_next;
            }
        }

        if (paStart->_parFirst == NULL)
        {
            // we cleaned this guy out!
            Assert(_rgAnchors.Get(iEndOrg) == paStart);
            _rgAnchors.Remove(iEndOrg, 1);
            delete paStart;
            // update _lPendingDeltaIndex
            if (iEndOrg < _lPendingDeltaIndex)
            {
                _lPendingDeltaIndex--;
            }
        }
    }

    _Dbg_AssertAnchors();
}

//+---------------------------------------------------------------------------
//
// _TrackDelHistory
//
//----------------------------------------------------------------------------

void CACPWrap::_TrackDelHistory(int iEndOrg, BOOL fExactEndOrgMatch, int iEndNew, BOOL fExactEndNewMatch)
{
    CAnchorRef *par;
    int i;

    Assert(iEndOrg >= iEndNew);

    if (fExactEndOrgMatch)
    {
        // all the anchoref's at iEndOrg get a preceding del
        for (par = _rgAnchors.Get(iEndOrg)->_parFirst; par != NULL; par = par->_next)
        {
            par->_dwHistory |= TS_CH_PRECEDING_DEL;
        }

        // if iEndOrg == iEndNew on entry, that's everything
        if (iEndOrg == iEndNew)
            return;

        iEndOrg--; // exclude this anchor from loop below
    }

    if (fExactEndNewMatch)
    {
        // all the anchoref's at iEndNew get a following del
        for (par = _rgAnchors.Get(iEndNew)->_parFirst; par != NULL; par = par->_next)
        {
            par->_dwHistory |= TS_CH_FOLLOWING_DEL;
        }
    }
    // exclude leftmost anchor from loop below
    // either we just handled it in the loop above or !fExactEndNewMatch
    // in which case it lies to the left of the affected anchors
    iEndNew++; 

    // the the anchoref's in between get both dels
    for (i=iEndNew; i<=iEndOrg; i++)
    {
        for (par = _rgAnchors.Get(i)->_parFirst; par != NULL; par = par->_next)
        {
            par->_dwHistory = (TS_CH_PRECEDING_DEL | TS_CH_FOLLOWING_DEL);
        }
    }
}

//+---------------------------------------------------------------------------
//
// _Update
//
// piInto gets loaded with the index of the anchor after the update.  If the
// index changed, pa is now bogus and a new pointer should be grabbed using
// the index.
//----------------------------------------------------------------------------

int CACPWrap::_Update(CAnchor *pa, int ichNew, int iOrg, CAnchor *paInto, int iInto)
{
    int i;

    Assert(pa->GetIch() != ichNew); // we are so hosed if this happens

    i = iInto;

    if (paInto != NULL)
    {
        // gotta do a merge
        _Merge(paInto, pa);
    }
    else
    {
        if (iInto != iOrg)
        {
            // move the entry in the array to the new position
            i = _rgAnchors.Move(iInto+1, iOrg);
        }

        // did we cross _lPendingDeltaIndex?
        if (i > _lPendingDeltaIndex)
        {
            // new position is in the pending range, adjust ich
            ichNew -= _lPendingDelta;
        }
        else if (iOrg >= _lPendingDeltaIndex && i <= _lPendingDeltaIndex) // shifting an anchor out of the pending range
        {
            // one less anchor in the pending range
            _lPendingDeltaIndex++;
        }

        // change the ich 
        _rgAnchors.Get(i)->_ich = ichNew;
    }

    _Dbg_AssertAnchors();

    return i;
}

//+---------------------------------------------------------------------------
//
// Renormalize
//
//----------------------------------------------------------------------------

void CACPWrap::_Renormalize(int ichStart, int ichEnd)
{
    CAnchor *pa;
    int iCurrent;
    int iEnd;
    BOOL fExactEndMatch;

    Perf_IncCounter(PERF_RENORMALIZE_COUNTER);

    if (_rgAnchors.Count() == 0)
        return;

    fExactEndMatch = (_Find(ichEnd, &iEnd) != NULL);
    if (iEnd < 0)
        return;

    if (ichStart == ichEnd)
    {
        if (!fExactEndMatch)
            return;
        // this can happen on deletions
        iCurrent = iEnd;
    }
    else if (_Find(ichStart, &iCurrent) == NULL)
    {
        iCurrent++; // we don't care about anchors < ichStart
    }
    Assert(iCurrent >= 0);

    for (;iCurrent <= iEnd; iCurrent++)
    {
        pa = _rgAnchors.Get(iCurrent);

        Assert(pa->GetIch() >= 0);
        Assert(pa->GetIch() >= ichStart);
        Assert(pa->GetIch() <= ichEnd);

        // we'll do the real work only when we have too...
        pa->_fNormalized = FALSE;
    }

    _Dbg_AssertAnchors();
}

//+---------------------------------------------------------------------------
//
// _Find
//
// If piOut != NULL then it is set to the index where ich was found, or the
// index of the next lower ich if ich isn't in the array.
// If there is no element in the array with a lower ich, returns offset -1.
//----------------------------------------------------------------------------

CAnchor *CACPWrap::_Find(int ich, int *piOut)
{
    CAnchor *paMatch;
    int iMin;
    int iMax;
    int iMid;
    LONG lPendingDeltaIch;

    iMin = 0;
    iMax = _rgAnchors.Count();

    // adjust search for pending delta range
    // values aren't consistent across the range boundary
    if (_lPendingDelta != 0 && _lPendingDeltaIndex < _rgAnchors.Count())
    {
        lPendingDeltaIch = _rgAnchors.Get(_lPendingDeltaIndex)->_ich;

        if (ich < lPendingDeltaIch + _lPendingDelta)
        {
            iMax = _lPendingDeltaIndex;
        }
        else if (ich > lPendingDeltaIch + _lPendingDelta)
        {
            iMin = _lPendingDeltaIndex+1;
            ich -= _lPendingDelta; // make the search below work
        }
        else
        {
            iMid = _lPendingDeltaIndex;
            paMatch = _rgAnchors.Get(_lPendingDeltaIndex);
            goto Exit;
        }
    }

    paMatch = _FindInnerLoop(ich, iMin, iMax, &iMid);

Exit:
    if (piOut != NULL)
    {
        if (paMatch == NULL && iMid >= 0)
        {
            // couldn't find a match, return the next lowest ich
            Assert(iMid == 0 || iMid == _lPendingDeltaIndex || _rgAnchors.Get(iMid-1)->_ich < ich);
            if (_rgAnchors.Get(iMid)->_ich > ich)
            {
                iMid--;
            }
        }
        *piOut = iMid;
    }

    return paMatch;
}

//+---------------------------------------------------------------------------
//
// _FindInnerLoop
//
//----------------------------------------------------------------------------

CAnchor *CACPWrap::_FindInnerLoop(LONG acp, int iMin, int iMax, int *piIndex)
{
    CAnchor *pa;
    CAnchor *paMatch;
    int iMid;

    paMatch = NULL;
    iMid = iMin - 1;

    while (iMin < iMax)
    {
        iMid = (iMin + iMax) / 2;
        pa = _rgAnchors.Get(iMid);
        Assert(pa != NULL);

        if (acp < pa->_ich)
        {
            iMax = iMid;
        }
        else if (acp > pa->_ich)
        {
            iMin = iMid + 1;
        }
        else // acp == pa->_ich
        {
            paMatch = pa;
            break;
        }
    }

    *piIndex = iMid;

    return paMatch;
}

//+---------------------------------------------------------------------------
//
// _Merge
//
//----------------------------------------------------------------------------

void CACPWrap::_Merge(CAnchor *paInto, CAnchor *paFrom)
{
    CAnchorRef *par;

    Assert(paInto != paFrom); // very bad!
    Assert(paInto->_parFirst != NULL); // should never have an anchor w/o any refs

    if (par = paFrom->_parFirst)
    {
        // update the anchor for the paFrom refs

        while (TRUE)
        {
            par->_pa = paInto;

            if (par->_next == NULL)
                break;

            par = par->_next;
        }

        // now par is the last ref in paFrom
        // shove all the refs in paFrom into paInto

        if (par != NULL)
        {
            Assert(par->_next == NULL);
            par->_next = paInto->_parFirst;
            Assert(paInto->_parFirst->_prev == NULL);
            paInto->_parFirst->_prev = par;
            paInto->_parFirst = paFrom->_parFirst;
        }
    }

    // and free the parFrom
    _Delete(paFrom);
}

//+---------------------------------------------------------------------------
//
// _Dbg_AssertAnchors
//
//----------------------------------------------------------------------------

#ifdef DEBUG

void CACPWrap::_Dbg_AssertAnchors()
{
    int i;
    int ichLast;
    CAnchor *pa;

    ichLast = -1;

    // assert that the anchor array has ascending ich's
    for (i=0; i<_rgAnchors.Count(); i++)
    {
        pa = _rgAnchors.Get(i);
        Assert(ichLast < pa->GetIch());
        ichLast = pa->GetIch();
    }
}

#endif // DEBUG

//+---------------------------------------------------------------------------
//
// _AdjustIchs
//
//----------------------------------------------------------------------------

void CACPWrap::_AdjustIchs(int iFirst, int dSize)
{
    CAnchor **ppaFirst;
    CAnchor **ppaLast;
    LONG dSizeAdjust;
    int iLastAnchor;

    Assert(dSize != 0);

    iLastAnchor = _rgAnchors.Count()-1;

    if (iFirst > iLastAnchor)
        return;

    if (_lPendingDelta == 0 ||             // no delta pending
        _lPendingDeltaIndex > iLastAnchor) // old pending anchors got deleted before update
    {
        // no pending delta, start a new one
        _lPendingDeltaIndex = iFirst;
        _lPendingDelta = dSize;
        return;
    }

    if (max(iFirst, _lPendingDeltaIndex) - min(iFirst, _lPendingDeltaIndex)
        > iLastAnchor / 2)
    {
        // adjust points are far apart, update the tail of the range
        if (iFirst > _lPendingDeltaIndex)
        {
            ppaFirst = _rgAnchors.GetPtr(iFirst);
            dSizeAdjust = dSize;
        }
        else
        {
            ppaFirst = _rgAnchors.GetPtr(_lPendingDeltaIndex);
            _lPendingDeltaIndex = iFirst;
            dSizeAdjust = _lPendingDelta;
            _lPendingDelta = dSize;
        }
        ppaLast = _rgAnchors.GetPtr(iLastAnchor);
    }
    else
    {
        // adjust points are close, update the head of the range
        if (iFirst > _lPendingDeltaIndex)
        {
            ppaFirst = _rgAnchors.GetPtr(_lPendingDeltaIndex);
            _lPendingDeltaIndex = iFirst;
            ppaLast = _rgAnchors.GetPtr(iFirst - 1);
            dSizeAdjust = _lPendingDelta;
        }
        else
        {
            ppaFirst = _rgAnchors.GetPtr(iFirst);
            ppaLast = _rgAnchors.GetPtr(_lPendingDeltaIndex-1);
            dSizeAdjust = dSize;
        }
        _lPendingDelta += dSize;
    }

    // do the real work
    while (ppaFirst <= ppaLast)
    {
        (*ppaFirst++)->_ich += dSizeAdjust;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\acp2anch.h ===
//
// acp2anch.h
//

#ifndef ACP2ANCH_H
#define ACP2ANCH_H

#include "private.h"
#include "strary.h"
#include "ptrary.h"

class CInputContext;
class CAnchorRef;
class CAnchor;
class CACPWrap;

extern const IID IID_PRIV_ACPWRAP;

// PSEUDO_ESCB_SERIALIZE_ACP params
typedef struct _SERIALIZE_ACP_PARAMS
{
    CACPWrap *pWrap;
    ITfProperty *pProp;
    ITfRange *pRange;
    TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr;
    IStream *pStream;
} SERIALIZE_ACP_PARAMS;

// PSEUDO_ESCB_UNSERIALIZE_ACP params
typedef struct _UNSERIALIZE_ACP_PARAMS
{
    CACPWrap *pWrap;
    ITfProperty *pProp;
    const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr;
    IStream *pStream;
    ITfPersistentPropertyLoaderACP *pLoaderACP;
} UNSERIALIZE_ACP_PARAMS;

//////////////////////////////////////////////////////////////////////////////
//
// CLoaderACPWrap
//
//////////////////////////////////////////////////////////////////////////////

class CLoaderACPWrap : public ITfPersistentPropertyLoaderAnchor,
                       public CComObjectRootImmx
{
public:
    CLoaderACPWrap(ITfPersistentPropertyLoaderACP *loader);
    ~CLoaderACPWrap();

    BEGIN_COM_MAP_IMMX(CLoaderACPWrap)
        COM_INTERFACE_ENTRY(ITfPersistentPropertyLoaderAnchor)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    // ITfPersistentPropertyLoaderACP
    STDMETHODIMP LoadProperty(const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr, IStream **ppStream);

private:
    ITfPersistentPropertyLoaderACP *_loader;
    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CACPWrap
//
//////////////////////////////////////////////////////////////////////////////

class CACPWrap : public ITextStoreAnchor,
                 public ITextStoreACPSink,
                 public ITextStoreACPServices,
                 public ITfMouseTrackerACP,
                 public IServiceProvider
{
public:
    CACPWrap(ITextStoreACP *ptsi);
    ~CACPWrap();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ITextStoreACPSink
    STDMETHODIMP OnTextChange(DWORD dwFlags, const TS_TEXTCHANGE *pChange);
    STDMETHODIMP OnSelectionChange();
    STDMETHODIMP OnLayoutChange(TsLayoutCode lcode, TsViewCookie vcView);
    STDMETHODIMP OnStatusChange(DWORD dwFlags);
    STDMETHODIMP OnAttrsChange(LONG acpStart, LONG acpEnd, ULONG cAttrs, const TS_ATTRID *paAttrs);
    STDMETHODIMP OnLockGranted(DWORD dwLockFlags);
    STDMETHODIMP OnStartEditTransaction();
    STDMETHODIMP OnEndEditTransaction();

    // ITextStoreACPServices
    STDMETHODIMP Serialize(ITfProperty *pProp, ITfRange *pRange, TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr, IStream *pStream);
    STDMETHODIMP ForceLoadProperty(ITfProperty *pProp);
    STDMETHODIMP Unserialize(ITfProperty *pProp, const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr, IStream *pStream, ITfPersistentPropertyLoaderACP *pLoader);
    STDMETHODIMP CreateRange(LONG acpStart, LONG acpEnd, ITfRangeACP **ppRange);

    // ITextStoreAnchor
    STDMETHODIMP AdviseSink(REFIID riid, IUnknown *punk, DWORD dwMask);
    STDMETHODIMP UnadviseSink(IUnknown *punk);
    STDMETHODIMP RequestLock(DWORD dwLockFlags, HRESULT *phrSession);
    STDMETHODIMP GetStatus(TS_STATUS *pdcs);
    STDMETHODIMP QueryInsert(IAnchor *paTestStart, IAnchor *paTestEnd, ULONG cch, IAnchor **ppaResultStart, IAnchor **ppaResultEnd);
    STDMETHODIMP GetSelection(ULONG ulIndex, ULONG ulCount, TS_SELECTION_ANCHOR *pSelection, ULONG *pcFetched);
    STDMETHODIMP SetSelection(ULONG ulCount, const TS_SELECTION_ANCHOR *pSelection);
    STDMETHODIMP GetText(DWORD dwFlags, IAnchor *paStart, IAnchor *paEnd, WCHAR *pchText, ULONG cchReq, ULONG *pcch, BOOL fUpdateAnchor);
    STDMETHODIMP SetText(DWORD dwFlags, IAnchor *paStart, IAnchor *paEnd, const WCHAR *pchText, ULONG cch);
    STDMETHODIMP GetFormattedText(IAnchor *paStart, IAnchor *paEnd, IDataObject **ppDataObject);
    STDMETHODIMP GetEmbedded(DWORD dwFlags, IAnchor *paPos, REFGUID rguidService, REFIID riid, IUnknown **ppunk);
    STDMETHODIMP QueryInsertEmbedded(const GUID *pguidService, const FORMATETC *pFormatEtc, BOOL *pfInsertable);
    STDMETHODIMP InsertEmbedded(DWORD dwFlags, IAnchor *paStart, IAnchor *paEnd, IDataObject *pDataObject);
    STDMETHODIMP RequestSupportedAttrs (DWORD dwFlags, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs);
    STDMETHODIMP RequestAttrsAtPosition(IAnchor *paPos, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs, DWORD dwFlags);
    STDMETHODIMP RequestAttrsTransitioningAtPosition(IAnchor *paPos, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs, DWORD dwFlags);
    STDMETHODIMP FindNextAttrTransition(IAnchor *paStart, IAnchor *paHalt, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs, DWORD dwFlags, BOOL *pfFound, LONG *plFoundOffset);
    STDMETHODIMP RetrieveRequestedAttrs(ULONG ulCount, TS_ATTRVAL *paAttrVals, ULONG *pcFetched);
    STDMETHODIMP GetStart(IAnchor **ppaStart);
    STDMETHODIMP GetEnd(IAnchor **ppaEnd);
    STDMETHODIMP GetActiveView(TsViewCookie *pvcView);
    STDMETHODIMP GetAnchorFromPoint(TsViewCookie vcView, const POINT *pt, DWORD dwFlags, IAnchor **ppaSite);
    STDMETHODIMP GetTextExt(TsViewCookie vcView, IAnchor *paStart, IAnchor *paEnd, RECT *prc, BOOL *pfClipped);
    STDMETHODIMP GetScreenExt(TsViewCookie vcView, RECT *prc);
    STDMETHODIMP GetWnd(TsViewCookie vcView, HWND *phwnd);
    STDMETHODIMP InsertTextAtSelection(DWORD dwFlags, const WCHAR *pchText, ULONG cch, IAnchor **ppaStart, IAnchor **ppaEnd);
    STDMETHODIMP InsertEmbeddedAtSelection(DWORD dwFlags, IDataObject *pDataObject, IAnchor **ppaStart, IAnchor **ppaEnd);

    // ITfMouseTrackerACP
    STDMETHODIMP AdviseMouseSink(ITfRangeACP *range, ITfMouseSink *pSink, DWORD *pdwCookie);
    STDMETHODIMP UnadviseMouseSink(DWORD dwCookie);

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

    HRESULT _Serialize(ITfProperty *pProp, ITfRange *pRange, TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr, IStream *pStream);
    HRESULT _Unserialize(ITfProperty *pProp, const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr, IStream *pStream, ITfPersistentPropertyLoaderACP *pLoader);

    void _OnLockReleased();

    CAnchorRef *_CreateAnchorACP(LONG acp, TsGravity gravity);
    CAnchorRef *_CreateAnchorAnchor(CAnchor *pa, TsGravity gravity);

    ITextStoreACP *_GetTSI() { return _ptsi; }

    void _Dbg_AssertNoAppLock()
    {
#ifdef DEBUG
        Assert(!_Dbg_fAppHasLock); // if we get here, it means the app has called OnTextChange
                                   // and someone (prob. the app) is trying to use a range object before calling
                                   // OnLockGranted (cicero will have asked for a lock inside OnTextChange).
#endif
    }

    HRESULT _ACPHdrToAnchor(const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr, TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *phanch);

    void _OnAnchorRelease()
    {
        if (_cRef == 0 && _GetAnchorRef() == 0)
        {
            delete this;
        }
    }

    BOOL _IsDisconnected() { return (_ptsi == NULL); }

    CInputContext *_GetContext()
    {
        return _pic;
    }

    void _NormalizeAnchor(CAnchor *pa);

    BOOL _InOnTextChange()
    {
        return _fInOnTextChange;
    }

private:
    friend CLoaderACPWrap;
    friend CAnchor;
    friend CAnchorRef;

    void _PostInsertUpdate(LONG acpStart, LONG acpEnd, ULONG cch, const TS_TEXTCHANGE *ptsTextChange);

    static BOOL _AnchorHdrToACP(const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *phanch, TF_PERSISTENT_PROPERTY_HEADER_ACP *phacp);

    LONG _GetAnchorRef() { return _GetCount(); }

    CAnchor *_FindWithinPendingRange(LONG acp)
    {
        int iIndex;

        Assert(_lPendingDelta != 0);
        Assert(_lPendingDeltaIndex < _rgAnchors.Count());
        return _FindInnerLoop(acp, _lPendingDeltaIndex+1, _rgAnchors.Count(), &iIndex);
    }
    HRESULT _Insert(CAnchorRef *par, LONG ich);
    HRESULT _Insert(CAnchorRef *par, CAnchor *pa);
    void _Remove(CAnchorRef *par);
    void _Update(const TS_TEXTCHANGE *pdctc);
    void _Renormalize(int ichStart, int ichEnd);
    LONG _GetCount() { return _rgAnchors.Count(); }
    void _DragAnchors(LONG acpFrom, LONG acpTo);
    LONG _GetPendingDelta()
    {
        return _lPendingDelta;
    }
    LONG _GetPendingDeltaIndex()
    {
        return _lPendingDeltaIndex;
    }
    CAnchor *_GetPendingDeltaAnchor()
    {
        return _rgAnchors.Get(_lPendingDeltaIndex);
    }
    BOOL _IsPendingDelta()
    {
        return _lPendingDelta != 0 && _lPendingDeltaIndex < _rgAnchors.Count();
    }
    CAnchor *_Find(int ich, int *piOut = NULL);
    CAnchor *_FindInnerLoop(LONG acp, int iMin, int iMax, int *piIndex);
    int _Update(CAnchor *pa, int ichNew, int iOrg, CAnchor *paInto, int iInto);
    void _Merge(CAnchor *paInto, CAnchor *paFrom);
    void _Delete(CAnchor *pa);
    void _AdjustIchs(int iFirst, int dSize);
    void _TrackDelHistory(int iEndOrg, BOOL fExactEndOrgMatch, int iEndNew, BOOL fExactEndNewMatch);
#ifdef DEBUG
    void _Dbg_AssertAnchors();
#else
    void _Dbg_AssertAnchors() {}
#endif

    BOOL _fInOnTextChange : 1; // TRUE if we're inside OnTextChange

    CPtrArray<CAnchor> _rgAnchors;
    LONG _lPendingDeltaIndex;
    LONG _lPendingDelta;

    ITextStoreACP *_ptsi;
    ITextStoreAnchorSink *_ptss;
    CInputContext *_pic;
    LONG _cRef;

#ifdef DEBUG
    BOOL _Dbg_fAppHasLock;
#endif

    DBG_ID_DECLARE;
};

#endif // ACP2ANCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\anchor.h ===
//
// anchor.h
//
// CAnchor
//

#ifndef ANCHOR_H
#define ANCHOR_H

#include "private.h"
#include "acp2anch.h"

class CAnchorRef;
class CACPWrap;

class CAnchor
{
public:
    CAnchor()
    { 
        Dbg_MemSetThisNameIDCounter(TEXT("CAnchor"), PERF_ANCHOR_COUNTER);
        Assert(_fNormalized == FALSE);
    }

    CACPWrap *_GetWrap()
    { 
        return _paw;   
    }

    BOOL _InsidePendingRange()
    {
        LONG ichDeltaStart;

        // if there's no pending delta range, we're not inside one
        if (!_paw->_IsPendingDelta())
            return FALSE;

        ichDeltaStart = _paw->_GetPendingDeltaAnchor()->_ich;

        // if the pending delta is negative, all anchor ich's are ascending
        if (_paw->_GetPendingDelta() < 0)
            return (_ich >= ichDeltaStart);

        // otherwise, there maybe overlapping anchor ichs like
        //    1, 3, 6 (delta start) 1, 3, 6, 10, ..
        //
        // so we can't always just test vs. ichDeltaStart.

        // we know the delta is positive, so an _ich less then the start ich
        // must not be in the pending range
        if (_ich < ichDeltaStart)
            return FALSE;

        // similarly, an ich >= ichDeltaStart + delta must be inside the range
        if (_ich >= ichDeltaStart + _paw->_GetPendingDelta())
            return TRUE;

        // if the ich matches the start of the pending delta, we can test vs.
        // the delta start anchor
        if (_ich == ichDeltaStart)
            return _paw->_GetPendingDeltaAnchor() == this;

        // if we get here, there's no way to tell just looking at this anchor
        // whether or not it's in the pending range -- its ich is legal
        // either way.  We have to bite the bullet and find its index in the
        // anchor array.
        return (_paw->_FindWithinPendingRange(_ich) == this);
    }

    int GetIch()
    { 
        return (_InsidePendingRange() ?  _ich + _paw->_GetPendingDelta() : _ich);
    }

    void SetACP(int ich) // careful, this method is very dangerous
    {
        Assert(ich >= 0);
        if (_InsidePendingRange())
        {
            _ich = ich - _paw->_GetPendingDelta();
        }
        else
        {
            _ich = ich;
        }
    }

    BOOL IsNormalized()
    {
        return _fNormalized;
    }

private:
    friend CACPWrap;

    CACPWrap *_paw;
    int _ich;               // offset of this anchor in the text stream, dangerous to change directly!
    CAnchorRef *_parFirst;  // list of ranges referencing this anchor
    BOOL _fNormalized : 1;
    DBG_ID_DECLARE;
};


#endif // ANCHOR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\anchoref.h ===
//
// anchoref.h
//
// CAnchorRef
//

#ifndef ANCHOREF_H
#define ANCHOREF_H

#include "private.h"
#include "memcache.h"
#include "acp2anch.h"
#include "anchor.h"

class CAnchorList;

extern const IID IID_PRIV_CANCHORREF;

// work around for new #define in mem.h
#undef new

class CAnchorRef : public IAnchor
{
public:
    DECLARE_CACHED_NEW;

    CAnchorRef()
    {
        Dbg_MemSetThisNameIDCounter(TEXT("CAnchorRef"), PERF_ANCHORREF_COUNTER);

        _cRef = 1;
        Assert(_dwHistory == 0);
        Assert(_pa == NULL);
    }
    ~CAnchorRef()
    {
        CACPWrap *paw;

        if (_pa != NULL) // NULL means something went wrong in _Init
        {
            paw = _pa->_GetWrap(); // we must cache this because _pa could be deleted in Remove
            paw->_Remove(this);
            paw->_OnAnchorRelease();
        }
    }

    BOOL _Init(CACPWrap *paw, LONG ich, TsGravity gravity)
    {
        _fForwardGravity = (gravity == TS_GR_FORWARD ? 1 : 0);

        return (paw->_Insert(this, ich) == S_OK);
    }
    BOOL _Init(CACPWrap *paw, CAnchor *pa, TsGravity gravity)
    {
        _fForwardGravity = (gravity == TS_GR_FORWARD ? 1 : 0);

        return (paw->_Insert(this, pa) == S_OK);
    }

    static void _InitClass();
    static void _UninitClass();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IAnchor
    //
    STDMETHODIMP SetGravity(TsGravity gravity);
    STDMETHODIMP GetGravity(TsGravity *pgravity);
    STDMETHODIMP IsEqual(IAnchor *paWith, BOOL *pfEqual);
    STDMETHODIMP Compare(IAnchor *paWith, LONG *plResult);
    STDMETHODIMP Shift(DWORD dwFlags, LONG cchReq, LONG *pcch, IAnchor *paHaltAnchor);
    STDMETHODIMP ShiftTo(IAnchor *paSite);
    STDMETHODIMP ShiftRegion(DWORD dwFlags, TsShiftDir dir, BOOL *pfNoRegion);
    STDMETHODIMP SetChangeHistoryMask(DWORD dwMask);
    STDMETHODIMP GetChangeHistory(DWORD *pdwHistory);
    STDMETHODIMP ClearChangeHistory();
    STDMETHODIMP Clone(IAnchor **ppaClone);

    LONG _GetACP()
    {
        _pa->_GetWrap()->_Dbg_AssertNoAppLock();
        return _pa->GetIch();
    }
    BOOL _SetACP(LONG acp);

    CAnchor *_GetAnchor()
    { 
        return _pa;
    }

    CACPWrap *_GetWrap()
    { 
        return _pa->_GetWrap();
    }

private:
    friend CACPWrap;

    CAnchor *_pa;
    CAnchorRef *_prev;
    CAnchorRef *_next;
    LONG _cRef;

    DWORD _fForwardGravity : 1;
    DWORD _dwHistory : 2;

    DBG_ID_DECLARE;
};

// retore mem.h trick
#ifdef DEBUG
#define new new(TEXT(__FILE__), __LINE__)
#endif // DEBUG

// this call doesn't AddRef the object!
inline CAnchorRef *GetCAnchorRef_NA(IAnchor *pa)
{
    CAnchorRef *par;

    pa->QueryInterface(IID_PRIV_CANCHORREF, (void **)&par);

    return par;
}

#endif // ANCHOREF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\anchoref.cpp ===
//
// anchoref.cpp
//
// CAnchorRef
//

#include "private.h"
#include "anchoref.h"
#include "anchor.h"
#include "acp2anch.h"
#include "globals.h"
#include "normal.h"
#include "memcache.h"
#include "ic.h"
#include "txtcache.h"

/* 9135f8f0-38e6-11d3-a745-0050040ab407 */
const IID IID_PRIV_CANCHORREF = { 0x9135f8f0, 0x38e6, 0x11d3, {0xa7, 0x45, 0x00, 0x50, 0x04, 0x0a, 0xb4, 0x07} };

DBG_ID_INSTANCE(CAnchorRef);

MEMCACHE *CAnchorRef::_s_pMemCache = NULL;

//+---------------------------------------------------------------------------
//
// _InitClass
//
//----------------------------------------------------------------------------

/* static */
void CAnchorRef::_InitClass()
{
    _s_pMemCache = MemCache_New(128);
}

//+---------------------------------------------------------------------------
//
// _UninitClass
//
//----------------------------------------------------------------------------

/* static */
void CAnchorRef::_UninitClass()
{
    if (_s_pMemCache == NULL)
        return;

    MemCache_Delete(_s_pMemCache);
    _s_pMemCache = NULL;
}

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CAnchorRef::QueryInterface(REFIID riid, void **ppvObj)
{
    if (&riid == &IID_PRIV_CANCHORREF ||
        IsEqualIID(riid, IID_PRIV_CANCHORREF))
    {
        *ppvObj = SAFECAST(this, CAnchorRef *);
        return S_OK; // No AddRef for IID_PRIV_CANCHORREF!  this is a private IID....
    }

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IAnchor))
    {
        *ppvObj = SAFECAST(this, IAnchor *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CAnchorRef::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CAnchorRef::Release()
{
    _cRef--;
    Assert(_cRef >= 0);

    if (_cRef == 0)
    {
        delete this;
        return 0;
    }

    return _cRef;
}

//+---------------------------------------------------------------------------
//
// SetGravity
//
//----------------------------------------------------------------------------

STDAPI CAnchorRef::SetGravity(TsGravity gravity)
{
    _fForwardGravity = (gravity == TS_GR_FORWARD ? 1 : 0);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetGravity
//
//----------------------------------------------------------------------------

STDAPI CAnchorRef::GetGravity(TsGravity *pgravity)
{
    if (pgravity == NULL)
        return E_INVALIDARG;

    *pgravity = _fForwardGravity ? TS_GR_FORWARD : TS_GR_BACKWARD;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// IsEqual
//
//----------------------------------------------------------------------------

STDAPI CAnchorRef::IsEqual(IAnchor *paWith, BOOL *pfEqual)
{
    LONG lResult;
    HRESULT hr;
    
    if (pfEqual == NULL)
        return E_INVALIDARG;

    *pfEqual = FALSE;

    // in our implementation, Compare is no less efficient, so just use that
    if ((hr = Compare(paWith, &lResult)) == S_OK)
    {
        *pfEqual = (lResult == 0);
    }

    return hr;    
}

//+---------------------------------------------------------------------------
//
// Compare
//
//----------------------------------------------------------------------------

STDAPI CAnchorRef::Compare(IAnchor *paWith, LONG *plResult)
{
    CAnchorRef *parWith;
    LONG acpThis;
    LONG acpWith;
    CACPWrap *paw;

    if (plResult == NULL)
        return E_INVALIDARG;

    //_paw->_Dbg_AssertNoAppLock(); // can't assert this because we use it legitimately while updating the span set

    *plResult = 0;

    if ((parWith = GetCAnchorRef_NA(paWith)) == NULL)
        return E_FAIL;

    // quick test for equality
    // we still need to check for equality again below because of normalization
    if (_pa == parWith->_pa)
    {
        Assert(*plResult == 0);
        return S_OK;
    }

    acpThis = _pa->GetIch();
    acpWith = parWith->_pa->GetIch();

    paw = _pa->_GetWrap();

    // we can't do a compare if either anchor is un-normalized
    // except when the app holds the lock (in which case we're being called from
    // a span set update which does not need to be normalized)
    if (!paw->_InOnTextChange())
    {
        // we only actually have to normalize the anchor to the left
        if (acpThis < acpWith)
        {
            if (!_pa->IsNormalized())
            {
                paw->_NormalizeAnchor(_pa);
                acpThis = _pa->GetIch();
                acpWith = parWith->_pa->GetIch();
            }
        }
        else if (acpThis > acpWith)
        {
            if (!parWith->_pa->IsNormalized())
            {
                paw->_NormalizeAnchor(parWith->_pa);
                acpThis = _pa->GetIch();
                acpWith = parWith->_pa->GetIch();
            }
        }
    }

    if (acpThis < acpWith)
    {
        *plResult = -1;
    }
    else if (acpThis > acpWith)
    {
        *plResult = +1;
    }
    else
    {
        Assert(*plResult == 0);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Shift
//
//----------------------------------------------------------------------------

STDAPI CAnchorRef::Shift(DWORD dwFlags, LONG cchReq, LONG *pcch, IAnchor *paHaltAnchor)
{
    CAnchorRef *parHaltAnchor;
    CACPWrap *paw;
    LONG acpHalt;
    LONG acpThis;
    LONG dacp;
    HRESULT hr;

    Perf_IncCounter(PERF_ANCHOR_SHIFT);

    if (dwFlags & ~(TS_SHIFT_COUNT_HIDDEN | TS_SHIFT_HALT_HIDDEN | TS_SHIFT_HALT_VISIBLE | TS_SHIFT_COUNT_ONLY))
        return E_INVALIDARG;

    if ((dwFlags & (TS_SHIFT_HALT_HIDDEN | TS_SHIFT_HALT_VISIBLE)) == (TS_SHIFT_HALT_HIDDEN | TS_SHIFT_HALT_VISIBLE))
        return E_INVALIDARG; // illegal to set both flags

    if (dwFlags & (TS_SHIFT_COUNT_HIDDEN | TS_SHIFT_HALT_HIDDEN | TS_SHIFT_HALT_VISIBLE))
        return E_NOTIMPL; // Issue: should support these

    if (pcch == NULL)
        return E_INVALIDARG;

    paw = _pa->_GetWrap();

    paw->_Dbg_AssertNoAppLock();

    if (paw->_IsDisconnected())
    {
        *pcch = 0;
        return TF_E_DISCONNECTED;
    }

    *pcch = cchReq; // assume success

    if (cchReq == 0)
        return S_OK;

    acpThis = _pa->GetIch();
    hr = E_FAIL;

    if (paHaltAnchor != NULL)
    {
        if ((parHaltAnchor = GetCAnchorRef_NA(paHaltAnchor)) == NULL)
            goto Exit;
        acpHalt = parHaltAnchor->_pa->GetIch();

        // return now if the halt is our base acp
        // (we treat acpHalt == acpThis as a nop below, anything
        // more ticky has problems with over/underflow)
        if (acpHalt == acpThis)
        {
            *pcch = 0;
            return S_OK;
        }
    }
    else
    {
        // nop the acpHalt
        acpHalt = acpThis;
    }

    // we can initially bound cchReq by pretending acpHalt
    // is plain text, an upper bound
    if (cchReq < 0 && acpHalt < acpThis)
    {
        cchReq = max(cchReq, acpHalt - acpThis);
    }
    else if (cchReq > 0 && acpHalt > acpThis)
    {
        cchReq = min(cchReq, acpHalt - acpThis);
    }

    // do the expensive work
    if (FAILED(hr = AppTextOffset(paw->_GetTSI(), acpThis, cchReq, &dacp, ATO_SKIP_HIDDEN)))
        goto Exit;

    // now we can clip percisely
    if (cchReq < 0 && acpHalt < acpThis)
    {
        dacp = max(dacp, acpHalt - acpThis);
        hr = S_FALSE;
    }
    else if (cchReq > 0 && acpHalt > acpThis)
    {
        dacp = min(dacp, acpHalt - acpThis);
        hr = S_FALSE;
    }

    if (hr == S_FALSE)
    {
        // nb: if we remembered whether or not we actually truncated cchReq above
        // before and/or after the AppTextOffset call, we could avoid always calling
        // PlainTextOffset when paHaltAnchor != NULL

        // request got clipped, need to find the plain count
        PlainTextOffset(paw->_GetTSI(), acpThis, dacp, pcch); // perf: we could get this info by modifying AppTextOffset
    }

    if (!(dwFlags & TS_SHIFT_COUNT_ONLY))
    {
        hr = _SetACP(acpThis + dacp) ? S_OK : E_FAIL;
    }
    else
    {
        // caller doesn't want the anchor updated, just wants a count
        hr = S_OK;
    }

Exit:
    if (FAILED(hr))
    {
        *pcch = 0;
    }

    // return value should never exceed what the caller requested!
    Assert((cchReq >= 0 && *pcch <= cchReq) || (cchReq < 0 && *pcch >= cchReq));

    return hr;
}

//+---------------------------------------------------------------------------
//
// ShiftTo
//
//----------------------------------------------------------------------------

STDAPI CAnchorRef::ShiftTo(IAnchor *paSite)
{
    CAnchorRef *parSite;
    LONG acpSite;

    if (paSite == NULL)
        return E_INVALIDARG;

    //_paw->_Dbg_AssertNoAppLock(); // can't assert this because we use it legitimately while updating the span set

    if ((parSite = GetCAnchorRef_NA(paSite)) == NULL)
        return E_FAIL;

    acpSite = parSite->_pa->GetIch();
    
    return _SetACP(acpSite) ? S_OK : E_FAIL;
}

//+---------------------------------------------------------------------------
//
// ShiftRegion
//
//----------------------------------------------------------------------------

STDAPI CAnchorRef::ShiftRegion(DWORD dwFlags, TsShiftDir dir, BOOL *pfNoRegion)
{
    LONG acp;
    ULONG cch;
    LONG i;
    ULONG ulRunInfoOut;
    LONG acpNext;
    ITextStoreACP *ptsi;
    CACPWrap *paw;
    WCHAR ch;
    DWORD dwATO;

    Perf_IncCounter(PERF_SHIFTREG_COUNTER);

    if (pfNoRegion == NULL)
        return E_INVALIDARG;

    *pfNoRegion = TRUE;

    if (dwFlags & ~(TS_SHIFT_COUNT_HIDDEN | TS_SHIFT_COUNT_ONLY))
        return E_INVALIDARG;

    paw = _pa->_GetWrap();

    if (paw->_IsDisconnected())
        return TF_E_DISCONNECTED;

    acp = _GetACP();
    ptsi = paw->_GetTSI();

    if (dir == TS_SD_BACKWARD)
    {
        // scan backwards for the preceding char
        dwATO = ATO_IGNORE_REGIONS | ((dwFlags & TS_SHIFT_COUNT_HIDDEN) ? 0 : ATO_SKIP_HIDDEN);
        if (FAILED(AppTextOffset(ptsi, acp, -1, &i, dwATO)))
            return E_FAIL;

        if (i == 0) // bod
            return S_OK;

        acp += i;
    }
    else
    {
        // normalize this guy so we can just test the next char
        if (!_pa->IsNormalized())
        {
            paw->_NormalizeAnchor(_pa);
            acp = _GetACP();
        }
        // skip past any hidden text
        if (!(dwFlags & TS_SHIFT_COUNT_HIDDEN))
        {
            acp = Normalize(paw->_GetTSI(), acp, NORM_SKIP_HIDDEN);
        }
    }

    // insure we're next to a TS_CHAR_REGION
    Perf_IncCounter(PERF_ANCHOR_REGION_GETTEXT);
    if (CProcessTextCache::GetText(ptsi, acp, -1, &ch, 1, &cch, NULL, 0, &ulRunInfoOut, &acpNext) != S_OK)
        return E_FAIL;

    if (cch == 0) // eod
        return S_OK;

    if (ch != TS_CHAR_REGION)
        return S_OK; // no region, so just report that in pfNoRegion

    if (!(dwFlags & TS_SHIFT_COUNT_ONLY)) // does caller want us to move the anchor?
    {
        if (dir == TS_SD_FORWARD)
        {
            // skip over the TS_CHAR_REGION
            acp += 1;
        }

        if (!_SetACP(acp))
            return E_FAIL;
    }

    *pfNoRegion = FALSE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// SetChangeHistoryMask
//
//----------------------------------------------------------------------------

STDAPI CAnchorRef::SetChangeHistoryMask(DWORD dwMask)
{
    Assert(0); // Issue: todo
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// GetChangeHistory
//
//----------------------------------------------------------------------------

STDAPI CAnchorRef::GetChangeHistory(DWORD *pdwHistory)
{
    if (pdwHistory == NULL)
        return E_INVALIDARG;

    *pdwHistory = _dwHistory;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// ClearChangeHistory
//
//----------------------------------------------------------------------------

STDAPI CAnchorRef::ClearChangeHistory()
{
    _dwHistory = 0;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

STDAPI CAnchorRef::Clone(IAnchor **ppaClone)
{
    if (ppaClone == NULL)
        return E_INVALIDARG;

    *ppaClone = _pa->_GetWrap()->_CreateAnchorAnchor(_pa, _fForwardGravity ? TS_GR_FORWARD : TS_GR_BACKWARD);

    return (*ppaClone != NULL) ? S_OK : E_FAIL;
}

//+---------------------------------------------------------------------------
//
// _SetACP
//
//----------------------------------------------------------------------------

BOOL CAnchorRef::_SetACP(LONG acp)
{
    CACPWrap *paw;

    if (_pa->GetIch() == acp)
        return TRUE; // already positioned here

    paw = _pa->_GetWrap();

    paw->_Remove(this);
    if (FAILED(paw->_Insert(this, acp)))
    {
        // Issue:
        // we need to add a method the CACPWrap
        // that swaps a CAnchorRef, preserving the old
        // value if a new one cannot be inserted (prob.
        // because memory is low).
        Assert(0); // we have no code to handle this!
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\api.cpp ===
//
// api.c
//

#include "private.h"
#include "tim.h"
#include "dim.h"
#include "dam.h"
#include "imelist.h"
#include "nuimgr.h"
#include "globals.h"
#include "assembly.h"
#include "timlist.h"
#include "catmgr.h"

extern "C" HRESULT WINAPI TF_GetThreadMgr(ITfThreadMgr **pptim)
{
    SYSTHREAD *psfn = GetSYSTHREAD();
    if (!psfn)
        return E_FAIL;

    if (pptim)
    {
        *pptim = psfn->ptim;
        if (*pptim)
            (*pptim)->AddRef(); 
    }
    return S_OK;
}

extern "C" HRESULT WINAPI TF_CreateThreadMgr(ITfThreadMgr **pptim)
{
    return CThreadInputMgr::CreateInstance(NULL, IID_ITfThreadMgr, (void **)pptim);
}

extern "C" HRESULT WINAPI TF_CreateDisplayAttributeMgr(ITfDisplayAttributeMgr **ppdam)
{
    return CDisplayAttributeMgr::CreateInstance(NULL, IID_ITfDisplayAttributeMgr, (void **)ppdam);
}

extern "C" HRESULT WINAPI TF_CreateLangBarMgr(ITfLangBarMgr **pplbm)
{
    return CLangBarMgr::CreateInstance(NULL, IID_ITfLangBarMgr, (void **)pplbm);
}

extern "C" HRESULT WINAPI TF_CreateInputProcessorProfiles(ITfInputProcessorProfiles **ppipp)
{
    return CInputProcessorProfiles::CreateInstance(NULL, IID_ITfInputProcessorProfiles, (void **)ppipp);
}

extern "C" HRESULT WINAPI TF_CreateLangBarItemMgr(ITfLangBarItemMgr **pplbim)
{
    return CLangBarItemMgr::CreateInstance(NULL, IID_ITfLangBarItemMgr, (void **)pplbim);
}

extern "C" HRESULT WINAPI TF_InvalidAssemblyListCache()
{
    if (!CAssemblyList::InvalidCache())
         return E_FAIL;

    SYSTHREAD *psfn = GetSYSTHREAD();
    if (!psfn)
        return E_FAIL;

    EnsureAssemblyList(psfn, TRUE);

    return S_OK;
}

extern "C" HRESULT WINAPI TF_InvalidAssemblyListCacheIfExist()
{
    // the only diff from TF_InvalidAssemblyListCache() is 
    // that we don't care if cache really exist
    //
    CAssemblyList::InvalidCache();

    SYSTHREAD *psfn = GetSYSTHREAD();
    if (!psfn)
        return E_FAIL;

    EnsureAssemblyList(psfn, TRUE);

    return S_OK;
}

extern "C" HRESULT WINAPI TF_PostAllThreadMsg(WPARAM wParam, DWORD dwFlags)
{
    ULONG ulNum;
    SYSTHREAD *psfn = GetSYSTHREAD();
    if (!psfn)
        return E_FAIL;

    EnsureTIMList(psfn);

    ulNum = g_timlist.GetNum();

    if (ulNum)
    {
        DWORD *pdw = new DWORD[ulNum + 1];
        if (pdw)
        {
            if (g_timlist.GetList(pdw,
                                  ulNum+1,
                                  &ulNum, 
                                  dwFlags,
                                  TLFlagFromTFPriv(wParam),
                                  TRUE))
            {
                ULONG ul;
                for (ul = 0; ul < ulNum; ul++)
                {
                    if (pdw[ul])
                        PostThreadMessage(pdw[ul], g_msgPrivate, wParam, 0);
                }
            }
            delete pdw;
        }
    }

    return S_OK;
}

extern "C" HRESULT WINAPI TF_CreateCategoryMgr(ITfCategoryMgr **ppCategoryMgr)
{
    return CCategoryMgr::CreateInstance(NULL, IID_ITfCategoryMgr, (void **)ppCategoryMgr);
}

extern "C" BOOL WINAPI TF_IsFullScreenWindowAcitvated()
{
    return GetSharedMemory()->fInFullScreen ? TRUE : FALSE;
}

extern "C" HRESULT WINAPI TF_GetGlobalCompartment(ITfCompartmentMgr **ppCompMgr)
{
    if (!ppCompMgr)
        return E_INVALIDARG;

    *ppCompMgr = NULL;

    SYSTHREAD *psfn = GetSYSTHREAD();

    EnsureGlobalCompartment(psfn);

    if (!psfn->_pGlobalCompMgr)
        return E_OUTOFMEMORY;

    if (EnsureTIMList(psfn))
        g_timlist.SetFlags(psfn->dwThreadId, TLF_GCOMPACTIVE);

    *ppCompMgr = psfn->_pGlobalCompMgr;
    psfn->_pGlobalCompMgr->AddRef();

    return S_OK;
}


extern "C" HRESULT WINAPI TF_CUASAppFix(LPCSTR lpCmdLine)
{
    if (!lpCmdLine)
        return E_INVALIDARG;

    if (!lstrcmpi(lpCmdLine, "DelayFirstActivateKeyboardLayout"))
    {
        g_dwAppCompatibility |= CIC_COMPAT_DELAYFIRSTACTIVATEKBDLAYOUT;
        return S_OK;
    }
    return E_INVALIDARG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\attr.h ===
//
// attr.h
//

#ifndef ATTR_H
#define ATTR_H

class CSharedAnchorArray;
class CRange;
class CInputContext;

CSharedAnchorArray *CalcCicPropertyTrackerAnchors(CInputContext *pic, IAnchor *paStart, IAnchor *paEnd, ULONG cGUIDATOMs, const TfGuidAtom *prgGUIDATOMs);
CSharedAnchorArray *CalcAppPropertyTrackerAnchors(ITextStoreAnchor *ptsi, ITfRange *rangeSuper, ULONG cGUIDs, const GUID *prgGUIDs);
HRESULT FillAppValueArray(ITextStoreAnchor *ptsi, CRange *pRange, TF_PROPERTYVAL *rgPropVal, ULONG cGUIDs, const GUID *prgGUIDs);

#endif// ATTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\assembly.h ===
//
// assembly.h
//

#ifndef ASSEMBLY_H
#define ASSEMBLY_H

#include "strary.h"
#include "ptrary.h"

class CAssemblyList;

#define MAX_LANGPROFILENAME      256

typedef struct tag_ASSEMBLYITEM 
{
    CLSID clsid;
    GUID  catid;
    GUID  guidProfile;
    CAlignWinHKL   hkl;
    CAlignWinHKL   hklSubstitute;
    BOOL  fActive : 1;
    BOOL  fActiveNoCic : 1;
    BOOL  fEnabled : 1;
    BOOL  fInitIconIndex : 1;
    BOOL  fSkipToActivate : 1;
    BOOL  fSkipToNotify : 1;
    BOOL  fDisabledOnTransitory : 1;
    ULONG uIconIndex;
    WCHAR szProfile[MAX_LANGPROFILENAME];

    void InitIconIndex()
    {
        uIconIndex = (ULONG)(-1);
        fInitIconIndex = FALSE;
    }

    BOOL IsEqual(tag_ASSEMBLYITEM *pItem)
    {
        return IsEqual(pItem->hkl, pItem->clsid, pItem->guidProfile);
    }

    BOOL IsEqual(HKL hklIn, REFCLSID rclsidIn, REFGUID rguidProfileIn)
    {
        if ((hkl == hklIn) &&
             IsEqualGUID(clsid, rclsidIn) &&
             IsEqualGUID(guidProfile, rguidProfileIn))
            return TRUE;

        return FALSE;
    }

    static size_t   GetAlignSize() { return Align(sizeof(struct tag_ASSEMBLYITEM)); }
} ASSEMBLYITEM;


//////////////////////////////////////////////////////////////////////////////
//
// CAssembly
//
//////////////////////////////////////////////////////////////////////////////

class CAssembly
{
public:
    CAssembly(const TCHAR *pszName);
    CAssembly(LANGID langid);
    ~CAssembly();

    BOOL IsEnabled(SYSTHREAD *psfn);
    BOOL IsNonCiceroItem();
    BOOL IsEnabledKeyboardItem(SYSTHREAD *psfn);
    WCHAR *GetLangName() {return _szLangName;}
    LANGID GetLangId() {return _langid;}
    int Count() {return _rgAsmItem.Count();}
    ASSEMBLYITEM *GetItem(int nId)
    {
         return _rgAsmItem.GetPtr(nId);
    }
    BOOL IsFEIMEActive();

    void RebuildSubstitutedHKLList();
    BOOL IsSubstitutedHKL(HKL hkl);
    void ClearSubstitutedHKLList()
    {
        _rghklSubstituted.Clear();
    }
    ASSEMBLYITEM *GetSubstituteItem(HKL hKL);
    ASSEMBLYITEM *FindActiveKeyboardItem();
    ASSEMBLYITEM *FindKeyboardLayoutItem(HKL hkl);

#ifdef CHECKFEIMESELECTED
    BOOL _fUnknownFEIMESelected;
#endif

private:
friend CAssemblyList;
    ASSEMBLYITEM *FindItemByCategory(REFGUID catid);
    ASSEMBLYITEM *FindPureKbdTipItem();
    BOOL IsEnabledItemByCategory(REFGUID catid);
    BOOL IsEnabledItem();

    int Find(ASSEMBLYITEM *pItem)
    {
         ASSEMBLYITEM *pItemTmp;
         int nCnt = _rgAsmItem.Count();
         int i;
         for (i = 0; i < nCnt; i++)
         {
             pItemTmp = _rgAsmItem.GetPtr(i);

             if (pItemTmp->IsEqual(pItem))
                 return i;
         }
         return -1;
    }
    void Add(ASSEMBLYITEM *pItem)
    {
         ASSEMBLYITEM *pItemTmp;
         if (Find(pItem) >= 0)
             return;

         pItemTmp = _rgAsmItem.Append(1);
         if (pItemTmp)
             *pItemTmp = *pItem;
    }

    void Remove(ASSEMBLYITEM *pItem)
    {
         int nId = Find(pItem);
         if (nId >= 0)
         {
             _rgAsmItem.Remove(nId, 1);
         }
    }

    LANGID _langid;
    WCHAR _szLangName[64];

    CStructArray<ASSEMBLYITEM> _rgAsmItem;
    CStructArray<HKL> _rghklSubstituted;
};

//////////////////////////////////////////////////////////////////////////////
//
// CAssemblyList
//
//////////////////////////////////////////////////////////////////////////////

class CAssemblyList
{
public:
    CAssemblyList();
    ~CAssemblyList();

    void ClearAsms();
    HRESULT Load();
    CAssembly *GetDefaultAssembly();
    void AttachOriginalAssembly(CPtrArray<CAssembly> *prgAsmOrg);

    int Count() {return _rgAsm.Count();}
    CAssembly *GetAssembly(int nId)
    {
         return _rgAsm.Get(nId);
    }

    CAssembly *FindAssemblyByLangId(LANGID langid)
    {
        return FindAssemblyByLangIdInArray(&_rgAsm, langid);
    }

    static CAssembly *FindAssemblyByLangIdInArray(CPtrArray<CAssembly> *rgAsm, LANGID langid)
    {
        int nCnt = rgAsm->Count();
        int i;
        for (i = 0; i < nCnt; i++)
        {
            CAssembly *pAsm = rgAsm->Get(i);
            if (pAsm->_langid == langid)
               return pAsm;
        }
        return NULL;
    }

    BOOL LoadFromCache();
    BOOL SetDefaultTIPInAssemblyInternal(CAssembly *pAsm, ASSEMBLYITEM *pItem, BOOL fChangeDefault);

    static BOOL SetDefaultTIPInAssemblyForCache(LANGID langid, REFGUID catid, REFCLSID clsid, HKL hKL, REFGUID guidProfile);
    static BOOL InvalidCache();

#ifdef PROFILE_UPDATE_REGISTRY  // old code for tip setup.
    static BOOL IsUpdated();
    static BOOL ClearUpdatedFlag();
#endif

    static BOOL GetDefaultTIPInAssembly(LANGID langid, REFGUID catid, CLSID *pclsid, HKL* phKL, GUID *pguidProfile);
    static BOOL SetDefaultTIPInAssembly(LANGID langid, REFGUID catid, REFCLSID clsid, HKL hKL, REFGUID guidProfile);
    static BOOL IsFEDummyKL(HKL hkl);
    static HKL GetProperHKL(LANGID langid, HKL *lphkl, BOOL *pfLoaded);
    static BOOL CheckLangSupport(REFCLSID rclsid, LANGID langid);

private:
    BOOL CreateCache();
    static BOOL GetTIPCategory(REFCLSID clsid, GUID *pcatid, IEnumGUID *pEnumCat);

    CPtrArray<CAssembly> _rgAsm;
    static CAssembly *FindAndCreateNewAssembly(CPtrArray<CAssembly> *prgAsm,  CPtrArray<CAssembly> *prgNutralAsm, LANGID langid);

};

inline BOOL IsIMEHKL(HKL hkl)
{
   return ((((DWORD)(LONG_PTR)hkl) & 0xf0000000) == 0xe0000000) ? TRUE : FALSE;
}

inline BOOL IsFELangId(LANGID langid)
{
    if ((langid == 0x411) ||
        (langid == 0x404) ||
        (langid == 0x412) ||
        (langid == 0x804))
    {
        return TRUE;
    }
    return FALSE;
}


inline BOOL IsPureIMEHKL(HKL hkl)
{
    if (!IsIMEHKL(hkl))
        return FALSE;

    return CAssemblyList::IsFEDummyKL(hkl) ? FALSE : TRUE;
}

BOOL EnsureAsmCacheFileMap();
BOOL UninitAsmCacheFileMap();
BOOL IsAsmCache();

#endif // ASSEMBLY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\attr.cpp ===
//
// attr.cpp
//

#include "private.h"
#include "attr.h"
#include "ic.h"
#include "saa.h"
#include "erfa.h"
#include "epval.h"
#include "immxutil.h"
#include "range.h"

//+---------------------------------------------------------------------------
//
// CalcAppPropertyTrackerAnchors
//
// NB: an empty range will result in a single anchor at the range pos.
//----------------------------------------------------------------------------

CSharedAnchorArray *CalcAppPropertyTrackerAnchors(ITextStoreAnchor *ptsi, ITfRange *rangeSuper, ULONG cGUIDs, const GUID *prgGUIDs)
{
    CSharedAnchorArray *prgAnchors;
    CRange *rangeScan;
    IAnchor *paPrevTrans;
    IAnchor **ppa;
    BOOL fRet;
    BOOL fFound;
    LONG lFoundOffset;
    HRESULT hr;

    if ((rangeScan = GetCRange_NA(rangeSuper)) == NULL)
        return NULL;

    if ((prgAnchors = new CSharedAnchorArray) == NULL)
        return NULL;

    fRet = FALSE;

    if (rangeScan->_GetStart()->Clone(&paPrevTrans) != S_OK)
    {
        paPrevTrans = NULL;
        goto Exit;
    }

    // now scan down the length of the range, building up a list
    while (TRUE)
    {
        // we've just found the end point of this run
        if (!prgAnchors->Append(1))
            goto Exit;
        ppa = prgAnchors->GetPtr(prgAnchors->Count()-1);
        if (paPrevTrans->Clone(ppa) != S_OK)
            goto Exit;

        if (cGUIDs == 0) // no transition for zero GUIDs, just do the end anchor Clone outside the loop
            break;

        hr = ptsi->FindNextAttrTransition(paPrevTrans, rangeScan->_GetEnd(), cGUIDs, prgGUIDs, TS_ATTR_FIND_UPDATESTART, &fFound, &lFoundOffset);

        if (hr != S_OK)
            goto Exit;

        // no more property spans?
        if (!fFound)
            break;

        // stop when we hit the end of the range
        if (IsEqualAnchor(paPrevTrans, rangeScan->_GetEnd()))
            break;
    }

    if (!IsEqualAnchor(rangeScan->_GetStart(), rangeScan->_GetEnd()))
    {
        // add a final anchor at the end of the range
        if (!prgAnchors->Append(1))
            goto Exit;
        ppa = prgAnchors->GetPtr(prgAnchors->Count()-1);
        if (rangeScan->_GetEnd()->Clone(ppa) != S_OK)
            goto Exit;
    }
    
    // shrink the array down to size, it won't be modified again
    prgAnchors->CompactSize();

    fRet = TRUE;

Exit:
    if (!fRet)
    {
        prgAnchors->_Release();
        prgAnchors = NULL;
    }
    else
    {
        Assert(prgAnchors != NULL);
    }
    SafeRelease(paPrevTrans);
    return prgAnchors;
}

//+---------------------------------------------------------------------------
//
// GetDefaultValue
//
//----------------------------------------------------------------------------

HRESULT GetDefaultValue(ITextStoreAnchor *ptsi, REFGUID guidType, VARIANT *pvarValue)
{
    TS_ATTRVAL av;
    ULONG cFetched;
    HRESULT hr;

    Assert(pvarValue != NULL);

    // VT_EMPTY for unsupported attrib/error
    QuickVariantInit(pvarValue);

    hr = ptsi->RequestSupportedAttrs(TS_ATTR_FIND_WANT_VALUE, 1, &guidType);
    if (hr != S_OK)
    {
        return (hr == E_NOTIMPL) ? E_NOTIMPL : E_FAIL;
    }

    if (ptsi->RetrieveRequestedAttrs(1, &av, &cFetched) == S_OK &&
           cFetched == 1)
    {
        Assert(IsEqualGUID(av.idAttr, guidType));
        *pvarValue = av.varValue; // caller owns it now
    }
    else
    {
        // the aimm layer will sometimes stop supporting an attribute
        // it has two sink callback points, the one for reconversion doesn't
        // handle attributes.
        // we'll just return VT_EMPTY
        Assert(pvarValue->vt == VT_EMPTY);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// FillAppValueArray
//
//----------------------------------------------------------------------------

HRESULT FillAppValueArray(ITextStoreAnchor *ptsi, CRange *range, TF_PROPERTYVAL *rgPropVal, ULONG cGUIDs, const GUID *prgGUIDs)
{
    ULONG i;
    ULONG j;
    ULONG iNext;
    ULONG cMissing;
    TS_ATTRVAL *prgVals;
    ULONG cFetched;
    HRESULT hr;

    if (cGUIDs == 0)
        return S_OK;

    if ((prgVals = (TS_ATTRVAL *)cicMemAlloc(cGUIDs*sizeof(TS_ATTRVAL))) == NULL)
        return E_OUTOFMEMORY;

    hr = ptsi->RequestAttrsAtPosition(range->_GetStart(), cGUIDs, prgGUIDs, 0);
    if (hr != S_OK)
        goto Exit;

    hr = ptsi->RetrieveRequestedAttrs(cGUIDs, prgVals, &cFetched);
    if (hr != S_OK)
        goto Exit;

    // copy over the values in prgVals
    for (i=0; i<cFetched; i++)
    {
        rgPropVal[i].guidId = prgVals[i].idAttr;
        rgPropVal[i].varValue = prgVals[i].varValue; // we take ownership, no VariantCopy
    }

    // figure out what was missing
    cMissing = cGUIDs - cFetched;

    if (cMissing == 0)
        goto Exit;

    iNext = cFetched; // index of first missing guid

    // perf: this is O(n^2), we could do a sort or something...
    for (i=0; i<cGUIDs; i++)
    {
        for (j=0; j<cFetched; j++)
        {
            if (IsEqualGUID(prgVals[j].idAttr, prgGUIDs[i]))
                break;
        }

        if (j < cFetched)
            continue;

        // found a missing GUID, need to get the default value
        hr = GetDefaultValue(ptsi, prgGUIDs[i], &rgPropVal[iNext].varValue);
        if (hr != S_OK)
        {
            Assert(0); // why did we fail?
            QuickVariantInit(&rgPropVal[iNext].varValue);
        }

        rgPropVal[iNext].guidId = prgGUIDs[i];

        if (--cMissing == 0) // anything left to look for?
            break;
        iNext++;
    }

Exit:
    cicMemFree(prgVals);
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// CEnumAppPropRanges
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

class CEnumAppPropRanges : public CEnumRangesFromAnchorsBase
{
public:
    CEnumAppPropRanges()
    { 
        Dbg_MemSetThisNameIDCounter(TEXT("CEnumAppPropRanges"), PERF_ENUMAPPPROP_COUNTER);
    }

    BOOL _Init(CInputContext *pic, ITfRange *rangeSuper, REFGUID rguid);

private:
    DBG_ID_DECLARE;
};

DBG_ID_INSTANCE(CEnumAppPropRanges);

//+---------------------------------------------------------------------------
//
// _Init
//
// Scan the superset range and build up a list of covered ranges.
//
//----------------------------------------------------------------------------

BOOL CEnumAppPropRanges::_Init(CInputContext *pic, ITfRange *rangeSuper, REFGUID rguid)
{
    Assert(_iCur == 0);
    Assert(_pic == NULL);
    Assert(_prgAnchors == NULL);

    _prgAnchors = CalcAppPropertyTrackerAnchors(pic->_GetTSI(), rangeSuper, 1, &rguid);

    if (_prgAnchors == NULL)
        return FALSE;

    _pic = pic;
    _pic->AddRef();

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// CAppProperty
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

class CAppProperty : public ITfReadOnlyProperty,
                     public CComObjectRootImmx
{
public:
    CAppProperty(CInputContext *pic, REFGUID guid);
    ~CAppProperty();

    BEGIN_COM_MAP_IMMX(CAppProperty)
        COM_INTERFACE_ENTRY(ITfReadOnlyProperty)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    // ITfReadOnlyProperty
    STDMETHODIMP GetType(GUID *pguid);
    STDMETHODIMP EnumRanges(TfEditCookie ec, IEnumTfRanges **ppEnum, ITfRange *pTargetRange);
    STDMETHODIMP GetValue(TfEditCookie ec, ITfRange *pRange, VARIANT *pvarValue);
    STDMETHODIMP GetContext(ITfContext **ppContext);

private:
    BOOL _IsValidEditCookie(TfEditCookie ec, DWORD dwFlags)
    {
        return _pic->_IsValidEditCookie(ec, dwFlags);
    }

    CInputContext *_pic;
    GUID _guid;
    DBG_ID_DECLARE;
};

DBG_ID_INSTANCE(CAppProperty);

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CAppProperty::CAppProperty(CInputContext *pic, REFGUID guid)
{
    Dbg_MemSetThisNameIDCounter(TEXT("CAppProperty"), PERF_APPPROP_COUNTER);

    _pic = pic;
    _pic->AddRef();
    _guid = guid;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CAppProperty::~CAppProperty()
{
    _pic->Release();
}

//+---------------------------------------------------------------------------
//
// GetType
//
//----------------------------------------------------------------------------

STDAPI CAppProperty::GetType(GUID *pguid)
{
    if (pguid == NULL)
        return E_INVALIDARG;

    *pguid = _guid;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// EnumRanges
//
//----------------------------------------------------------------------------

STDAPI CAppProperty::EnumRanges(TfEditCookie ec, IEnumTfRanges **ppEnum, ITfRange *pTargetRange)
{
    CEnumAppPropRanges *pEnum;

    if (ppEnum == NULL)
        return E_INVALIDARG;

    *ppEnum = NULL;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    // nb: unlike ITfProperty, ITfReadOnlyProperty does not accept pTargetRange == NULL!
    if (pTargetRange == NULL)
        return E_INVALIDARG;

    // make sure ic, range are in the same context
    if (!VerifySameContext(_pic, pTargetRange))
        return E_INVALIDARG;

    pEnum = new CEnumAppPropRanges;

    if (pEnum == NULL)
        return E_OUTOFMEMORY;

    if (!pEnum->_Init(_pic, pTargetRange, _guid))
    {
        pEnum->Release();
        return E_FAIL;
    }

    *ppEnum = pEnum;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetValue
//
//----------------------------------------------------------------------------

STDAPI CAppProperty::GetValue(TfEditCookie ec, ITfRange *pRange, VARIANT *pvarValue)
{
    TS_ATTRVAL av;
    HRESULT hr;
    CRange *range;
    ULONG cFetched;
    ITextStoreAnchor *ptsi;

    if (pvarValue == NULL)
        return E_INVALIDARG;

    QuickVariantInit(pvarValue);

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    if (pRange == NULL)
        return E_INVALIDARG; // supporting "whole doc" behavior too expensive!

    if ((range = GetCRange_NA(pRange)) == NULL)
        return E_INVALIDARG;

    if (!VerifySameContext(_pic, range))
        return E_INVALIDARG;

    ptsi = _pic->_GetTSI();

    // we always return the value at the start anchor
    hr = ptsi->RequestAttrsAtPosition(range->_GetStart(), 1, &_guid, 0);

    if (hr != S_OK)
        return E_FAIL;

    QuickVariantInit(&av.varValue);

    // just return the single VARIANT value directly
    if (ptsi->RetrieveRequestedAttrs(1, &av, &cFetched) != S_OK)
        return E_FAIL;

    if (cFetched == 0)
    {
        // default value
        return GetDefaultValue(_pic->_GetTSI(), _guid, pvarValue);
    }

    *pvarValue = av.varValue; // caller takes ownership

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetContext
//
//----------------------------------------------------------------------------

STDAPI CAppProperty::GetContext(ITfContext **ppContext)
{
    if (ppContext == NULL)
        return E_INVALIDARG;

    *ppContext = _pic;
    (*ppContext)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// CInputContext
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// GetAppProperty
//
//----------------------------------------------------------------------------

STDAPI CInputContext::GetAppProperty(REFGUID guidProp, ITfReadOnlyProperty **ppProp)
{
    CAppProperty *prop;
    TS_ATTRVAL av;
    ULONG cFetched;
    BOOL fUnsupported;
    HRESULT hr;

    if (ppProp == NULL)
        return E_INVALIDARG;

    *ppProp = NULL;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    //
    // if we have a mapping property, it will be returned.
    //
    APPPROPMAP *pMap = FindMapAppProperty(guidProp);
    if (pMap)
    {
        CProperty *pProp;
        if (SUCCEEDED(_GetProperty(pMap->guidProp, &pProp)))
        {
            *ppProp = (ITfReadOnlyProperty *)pProp;
            return S_OK;
        }
    }

    // does the app support this property?
    fUnsupported = TRUE;

    if ((hr = _ptsi->RequestSupportedAttrs(0, 1, &guidProp)) != S_OK)
    {
        return (hr == E_NOTIMPL) ? E_NOTIMPL : E_FAIL;
    }

    QuickVariantInit(&av.varValue);

    if (_ptsi->RetrieveRequestedAttrs(1, &av, &cFetched) == S_OK &&
        cFetched == 1)
    {
        if (IsEqualGUID(av.idAttr, guidProp)) // paranoia
        {
            fUnsupported = FALSE;
        }
        else
        {
            Assert(0); // bad out param!
        }
    }

    if (fUnsupported)
    {
        return S_FALSE;
    }

    if ((prop = new CAppProperty(this, guidProp)) == NULL)
        return E_OUTOFMEMORY;

    *ppProp = prop;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// MapAppProperty
//
//----------------------------------------------------------------------------

STDAPI CInputContext::MapAppProperty(REFGUID guidAppProp, REFGUID guidProp)
{
    APPPROPMAP *pMap;

    //
    // overwrite the mapping guidProp.
    //
    if (pMap = FindMapAppProperty(guidAppProp))
    {
        pMap->guidProp = guidProp;
        return S_OK;
    }
 
    pMap = _rgAppPropMap.Append(1);
    if (!pMap)
        return E_OUTOFMEMORY;

    pMap->guidAppProp = guidAppProp;
    pMap->guidProp = guidProp;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// FindMapProp
//
//----------------------------------------------------------------------------

CInputContext::APPPROPMAP *CInputContext::FindMapAppProperty(REFGUID guidAppProp)
{
    int i;
    for (i = 0; i < _rgAppPropMap.Count(); i++)
    {
        APPPROPMAP *pMap = _rgAppPropMap.GetPtr(i);
        if (IsEqualGUID(pMap->guidAppProp, guidAppProp))
            return pMap;
    }
    return NULL;
}

//+---------------------------------------------------------------------------
//
// GetMappedAppProperty
//
//----------------------------------------------------------------------------

HRESULT CInputContext::GetMappedAppProperty(REFGUID guidProp, CProperty **ppProp)
{
    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    //
    // if we have a mapping property, it will be returned.
    //
    APPPROPMAP *pMap = FindMapAppProperty(guidProp);
    if (pMap)
    {
        if (SUCCEEDED(_GetProperty(pMap->guidProp, ppProp)))
        {
            return S_OK;
        }
    }
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\assembly.cpp ===
#include "private.h"
#include "globals.h"
#include "regsvr.h"
#include "catutil.h"
#include "cregkey.h"
#include "assembly.h"
#include "immxutil.h"
#include "osver.h"
#include "internat.h"
#include "cicmutex.h"
#include "imelist.h"
#include "tim.h"

extern CCicMutex g_mutexAsm;
extern char g_szAsmListCache[];

extern HRESULT g_EnumItemsInCategory(REFGUID rcatid, IEnumGUID **ppEnum);


//+---------------------------------------------------------------------------
//
// TF_GetLangIcon
//
//+---------------------------------------------------------------------------

HICON WINAPI TF_GetLangIcon(WORD langid , WCHAR *psz, UINT cchMax)
{
    if (psz)
    {
        SYSTHREAD *psfn = GetSYSTHREAD();
        CAssemblyList *pAsmList;
        *psz = L'\0';

        if (psfn && (pAsmList = EnsureAssemblyList(psfn)))
        {
            CAssembly *pAsm = pAsmList->FindAssemblyByLangId(langid);
            if (pAsm)
            {
                StringCchCopyW(psz, cchMax, pAsm->GetLangName());
            }
        }
    
    }

    return InatCreateIcon(langid);
}


//----------------------------------------------------------------------------
//
// GetSubstituteHKLfromKey
//
//----------------------------------------------------------------------------

HKL GetSubstituteHKLfromKey(CMyRegKey *pkey, LANGID langid)
{
    char sz[16];

    if (pkey->QueryValueCch(sz, c_szSubstitutehKL, ARRAYSIZE(sz)) != S_OK)
        return NULL;

    HKL hkl = NULL;
    if ((sz[0] == '0') && ((sz[1] == 'X') || (sz[1] == 'x')))
    {
        hkl = (HKL)IntToPtr(AsciiToNum(&sz[2]));
        if (LOWORD(HandleToLong(hkl)) != langid)
        {
            //
            // bad substitution.
            //
            Assert(0);
            hkl = 0;
        }
    }
    return hkl;
}


//////////////////////////////////////////////////////////////////////////////
//
// CAssembly
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CAssembly::CAssembly(LANGID langid)
{
    _langid = langid;

    if (IsOnNT())
    {
        if (!GetLocaleInfoW(MAKELCID(langid, SORT_DEFAULT), 
                              LOCALE_SLANGUAGE, 
                              _szLangName, 
                              ARRAYSIZE(_szLangName)))
        {
            StringCchCopyW(_szLangName, ARRAYSIZE(_szLangName), L"Unknown Language");
        }
        else
        {
            _szLangName[ARRAYSIZE(_szLangName)-1] = 0; // in case GetLocaleInfoW truncates
        }
    }
    else
    {
        char szLangName[64];
        if (GetLocaleInfo(MAKELCID(langid, SORT_DEFAULT), 
                              LOCALE_SLANGUAGE, 
                              szLangName, 
                              sizeof(szLangName)))
        {
            szLangName[ARRAYSIZE(szLangName)-1] = 0; // in case GetLocaleInfoW truncates
            StringCchCopyW(_szLangName, ARRAYSIZE(_szLangName), AtoW(szLangName));
        }
        else
        {
            StringCchCopyW(_szLangName, ARRAYSIZE(_szLangName), L"Unknown Language");
        }
    }

}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CAssembly::~CAssembly()
{
}

//+---------------------------------------------------------------------------
//
// IsFEIMEActive()
//
//----------------------------------------------------------------------------

BOOL CAssembly::IsFEIMEActive()
{
    int i;
    if (IsFELangId(GetLangId()))
    {
        for (i = 0; i < Count(); i++)
        {
            ASSEMBLYITEM *pItem = GetItem(i);
            if (pItem->fActive && IsPureIMEHKL(pItem->hkl))
            {
                Assert(IsEqualGUID(pItem->clsid, GUID_NULL));
                return TRUE;
            }
        }
    }

#ifdef CHECKFEIMESELECTED
    if (_fUnknownFEIMESelected)
        return TRUE;
#endif CHECKFEIMESELECTED

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// FindItemByCategory
//
//----------------------------------------------------------------------------

ASSEMBLYITEM *CAssembly::FindItemByCategory(REFGUID catid)
{
     int nCnt = _rgAsmItem.Count();
     int i;
     if (IsEqualGUID(catid, GUID_NULL))
         return NULL;

     for (i = 0; i < nCnt; i++)
     {
         ASSEMBLYITEM *pItemTmp;
         pItemTmp = _rgAsmItem.GetPtr(i);

         if (IsEqualGUID(pItemTmp->catid, catid))
            return pItemTmp;
     }
     return NULL;
}

//+---------------------------------------------------------------------------
//
// FindActiveKeyboardItem
//
// Why do you call this if there is no FocusDIM? You should not do.
// fActive is not reliable if there is no FocusDIM. 
// Ser SetFocusDIMForAssembly(BOOL fSetFocus) in profiles.cpp. we don't
// change fActive but switch hKL when the focus moves to non DIM control.
//
//----------------------------------------------------------------------------

ASSEMBLYITEM *CAssembly::FindActiveKeyboardItem()
{
     int nCnt = _rgAsmItem.Count();
     int i;

     for (i = 0; i < nCnt; i++)
     {
         ASSEMBLYITEM *pItemTmp;
         pItemTmp = _rgAsmItem.GetPtr(i);

         if (!pItemTmp->fEnabled)
            continue;

         if (!pItemTmp->fActive)
            continue;

         if (IsEqualGUID(pItemTmp->catid, GUID_TFCAT_TIP_KEYBOARD))
            return pItemTmp;
     }
     return NULL;
}

//+---------------------------------------------------------------------------
//
// FindKeyboardLayoutItem
//
//----------------------------------------------------------------------------

ASSEMBLYITEM *CAssembly::FindKeyboardLayoutItem(HKL hkl)
{
     int nCnt = _rgAsmItem.Count();
     int i;

     for (i = 0; i < nCnt; i++)
     {
         ASSEMBLYITEM *pItemTmp;
         pItemTmp = _rgAsmItem.GetPtr(i);

         if (!IsEqualGUID(pItemTmp->clsid, GUID_NULL))
             continue;

         if (IsEqualGUID(pItemTmp->catid, GUID_TFCAT_TIP_KEYBOARD) &&
             (pItemTmp->hkl == hkl))
         {
             return pItemTmp;
         }
     }
     return NULL;
}

//+---------------------------------------------------------------------------
//
// FindItemByCategory2
//
//----------------------------------------------------------------------------

BOOL CAssembly::IsEnabledItemByCategory(REFGUID catid)
{
     int nCnt = _rgAsmItem.Count();
     int i;

     if (IsEqualGUID(catid, GUID_NULL))
         return FALSE;

     for (i = 0; i < nCnt; i++)
     {
         ASSEMBLYITEM *pItemTmp;
         pItemTmp = _rgAsmItem.GetPtr(i);

         if (!IsEqualGUID(pItemTmp->catid, catid) && pItemTmp->fEnabled)
            return TRUE;
     }
     return FALSE;
}

//+---------------------------------------------------------------------------
//
// IsEnabledItem
//
//----------------------------------------------------------------------------

BOOL CAssembly::IsEnabledItem()
{
     int nCnt = _rgAsmItem.Count();
     int i;

     for (i = 0; i < nCnt; i++)
     {
         ASSEMBLYITEM *pItemTmp;
         pItemTmp = _rgAsmItem.GetPtr(i);

         if (pItemTmp->fEnabled)
             return TRUE;
     }
     return FALSE;
}

//+---------------------------------------------------------------------------
//
// FindPureKbdTipItem
//
//----------------------------------------------------------------------------

ASSEMBLYITEM *CAssembly::FindPureKbdTipItem()
{
     int nCnt = _rgAsmItem.Count();
     int i;

     for (i = 0; i < nCnt; i++)
     {
         ASSEMBLYITEM *pItemTmp;
         pItemTmp = _rgAsmItem.GetPtr(i);

         if (IsEqualGUID(pItemTmp->catid, GUID_TFCAT_TIP_KEYBOARD) && !IsPureIMEHKL(pItemTmp->hkl))
            return pItemTmp;
     }
     return NULL;
}

//+---------------------------------------------------------------------------
//
// IsNonCiceroItem
//
//----------------------------------------------------------------------------

BOOL CAssembly::IsNonCiceroItem()
{
     int nCnt = _rgAsmItem.Count();
     int i;
     BOOL fFound = FALSE;

     for (i = 0; i < nCnt; i++)
     {
         ASSEMBLYITEM *pItemTmp;
         pItemTmp = _rgAsmItem.GetPtr(i);

         if (!pItemTmp->fEnabled)
             continue;

         if (!IsEqualGUID(pItemTmp->catid, GUID_TFCAT_TIP_KEYBOARD))
             continue;

         if (IsEqualGUID(pItemTmp->clsid, GUID_NULL))
         {
             if (IsFELangId(LOWORD((DWORD)(LONG_PTR)(HKL)pItemTmp->hkl)))
             {
                 if (!IsPureIMEHKL(pItemTmp->hkl))
                 {
                     // Assert(0);
                     continue;
                 }
             }

             return TRUE;
         }
     }
     return FALSE;
}

//+---------------------------------------------------------------------------
//
// IsEnabled
//
//----------------------------------------------------------------------------

BOOL CAssembly::IsEnabled(SYSTHREAD *psfn)
{
    CThreadInputMgr *ptim;
    ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn);

    if (!ptim || !ptim->_GetFocusDocInputMgr()) 
        return IsNonCiceroItem() ? TRUE : FALSE;

    return IsEnabledKeyboardItem(psfn);
}

//+---------------------------------------------------------------------------
//
// IsEnabledKeyboardItem
//
//----------------------------------------------------------------------------

BOOL CAssembly::IsEnabledKeyboardItem(SYSTHREAD *psfn)
{
    int nCnt = _rgAsmItem.Count();
    int i;
    BOOL fFound = FALSE;

    for (i = 0; i < nCnt; i++)
    {
        ASSEMBLYITEM *pItemTmp;
        pItemTmp = _rgAsmItem.GetPtr(i);

        if (!pItemTmp->fEnabled)
            continue;

        if (!IsEqualGUID(pItemTmp->catid, GUID_TFCAT_TIP_KEYBOARD))
            continue;

        fFound = TRUE;
        break;
    }

    return fFound;
}

//+---------------------------------------------------------------------------
//
// RebuildSubstitutedHKLList
//
//----------------------------------------------------------------------------

void CAssembly::RebuildSubstitutedHKLList()
{
    int i;
    _rghklSubstituted.Clear();

    for (i = 0; i < Count(); i++)
    {
        ASSEMBLYITEM *pItem = GetItem(i);

        if (!pItem->fEnabled)
            continue;

        if (!pItem->hklSubstitute)
            continue;

        if (IsEqualGUID(pItem->catid, GUID_TFCAT_TIP_KEYBOARD) &&
            !IsEqualGUID(pItem->clsid, GUID_NULL))
        {
            HKL *phkl = _rghklSubstituted.Append(1);
            if (phkl)
                *phkl = pItem->hklSubstitute;
        }
    }

}

//+---------------------------------------------------------------------------
//
// IsSubstitutedHKL
//
//----------------------------------------------------------------------------

BOOL CAssembly::IsSubstitutedHKL(HKL hkl)
{
    int nCnt = _rghklSubstituted.Count();
    int i;

    for (i = 0; i < nCnt; i++)
    {
        HKL *phkl = _rghklSubstituted.GetPtr(i);
        if (*phkl == hkl)
            return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// GetSubstituteItem
//
//----------------------------------------------------------------------------

ASSEMBLYITEM *CAssembly::GetSubstituteItem(HKL hKL)
{
    int i;
    BOOL fCheckActive = TRUE;

TryAgain:
    for (i = 0; i < Count(); i++)
    {
        ASSEMBLYITEM *pItem = GetItem(i);

        if (!pItem->fEnabled)
            continue;

        if (!pItem->hklSubstitute)
            continue;

        if (fCheckActive)
        {
            if (!pItem->fActive)
                continue;
        }

        if (IsEqualGUID(pItem->catid, GUID_TFCAT_TIP_KEYBOARD) &&
            !IsEqualGUID(pItem->clsid, GUID_NULL))
        {
            if (hKL == pItem->hklSubstitute)
            {
                return pItem;
            }
        }
    }

    if (fCheckActive)
    {
        fCheckActive = FALSE;
        goto TryAgain;
    }
    
    return NULL;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDefaultProfiles
//
// This class is a database for the default profiles and this database is
// created from HKCU\Software\Microsoft\CTF\TIP
//
// however we need to respect the system default hKL setting. If the keyboard
// tip's profile has a substitute hKL and this is not the system default hKL
// we use the system default hKL as a default profile.
//
//////////////////////////////////////////////////////////////////////////////

class CDefaultProfiles
{
public:
    CDefaultProfiles(LANGID langid) 
    {
        _langid = langid;
    }

    ~CDefaultProfiles()
    {
        _rgDefProfiles.Clear();
    }

    BOOL Init(HKL *phkl);
    BOOL FilterProfiles(CAssembly *pAsm);

    typedef struct tag_DEFAULTPROFILE 
    {
        GUID  catid;
        CLSID clsid;
        GUID  guidProfile;
        HKL   hkl;
    } DEFAULTPROFILE;


    BOOL GetDefaultProfile(GUID catid, GUID *pclsid, GUID *pguidProfile, HKL *phkl);

    BOOL Append(GUID catid, CLSID clsid, GUID guidProfile, HKL hkl)
    {
        DEFAULTPROFILE defpro;
        DEFAULTPROFILE *pdefpro;

        int i;
        for (i = 0; i < _rgDefProfiles.Count(); i++)
        {
            pdefpro = _rgDefProfiles.GetPtr(i);
            if (!pdefpro)
            {
                Assert(0);
                return FALSE;
            }

            if (IsEqualGUID(catid, pdefpro->catid))
                return FALSE;
        }

        defpro.catid = catid;
        defpro.clsid = clsid;
        defpro.guidProfile = guidProfile;
        defpro.hkl = hkl;

        pdefpro = _rgDefProfiles.Append(1);
        if (!pdefpro)
            return FALSE;

        memcpy(pdefpro, &defpro, sizeof(defpro));
        return TRUE;
    }

private:
    BOOL GetSubstitutedItem(HKL hklSub, DEFAULTPROFILE *pdefpro);
    LANGID _langid;
    CStructArray<DEFAULTPROFILE> _rgDefProfiles;
};


//+---------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

BOOL CDefaultProfiles::Init(HKL *phkl)
{
    CMyRegKey key;
    DWORD dw;
    char szKey[256];
    char szName[CLSID_STRLEN + 1];
    HKL hklDef = GetSystemDefaultHKL();
    BOOL fFoundKeyboardIteminDefLang = FALSE;
    DEFAULTPROFILE defpro;
    DEFAULTPROFILE *pdefpro;
    DWORD dwIndex;

    StringCopyArray(szKey, c_szAsmKey);
    StringCatArray(szKey, "\\");
    StringCchPrintf(szKey + lstrlen(szKey), ARRAYSIZE(szKey)-lstrlen(szKey), "0x%08x", _langid);

    if (key.Open(HKEY_CURRENT_USER, szKey, KEY_READ) != S_OK)
        goto Exit;

    dwIndex = 0;
    while (key.EnumKey(dwIndex, szKey, ARRAYSIZE(szKey)) == S_OK)
    {
        CMyRegKey subkey;

        if (subkey.Open(key, szKey, KEY_READ) != S_OK)
            goto Next;

        StringAToCLSID(szKey, &defpro.catid);

        //
        // retreive tip clsid.
        //
        if (subkey.QueryValueCch(szName, c_szDefault, ARRAYSIZE(szName)) != S_OK)
            goto Next;
        StringAToCLSID(szName, &defpro.clsid);

        //
        // retreive guid profile
        //
        if (subkey.QueryValueCch(szName, c_szProfile, ARRAYSIZE(szName)) != S_OK)
            goto Next;
        StringAToCLSID(szName, &defpro.guidProfile);

        if (subkey.QueryValue(dw, c_szKeyboardLayout) != S_OK)
            goto Next;

        //
        // check the hkl from registry is valid or not.
        //
        defpro.hkl = (HKL)IntToPtr(dw);
        if (defpro.hkl)
        {
            int i = 0;
            BOOL fFound = FALSE;
            while(phkl[i])
            {
                if (defpro.hkl == phkl[i])
                {
                    fFound = TRUE;
                    break;
                }
                i++;
            }
            if (!fFound)
                goto Next;
        }

        //
        // if the system default hKL does not matched with
        // the substite hKL of this profile, this profile can not be
        // default profile. Instead the system default hKL became a
        // default profile item.
        //
        if ((LOWORD(HandleToLong(hklDef)) == _langid) &&
            IsEqualGUID(defpro.catid, GUID_TFCAT_TIP_KEYBOARD))
        {
            char szTmp[256];
            HKL hklSubstitute = NULL;
            fFoundKeyboardIteminDefLang = TRUE;

            if (InitProfileRegKeyStr(szTmp,
                                     ARRAYSIZE(szTmp),
                                     defpro.clsid, 
                                     _langid, 
                                     defpro.guidProfile))
            {
                CMyRegKey keySubstitute;

                if (keySubstitute.Open(HKEY_LOCAL_MACHINE, szTmp, KEY_READ) == S_OK)
                {
                    hklSubstitute = GetSubstituteHKLfromKey(&keySubstitute, _langid);
                }
            }

            // Removed Chinese specific code for bug#427476
            if (IsEqualGUID(defpro.clsid, GUID_NULL) ||
                (hklSubstitute && (hklSubstitute != hklDef)))
            {
                defpro.clsid = CLSID_NULL;
                defpro.guidProfile = GUID_NULL;
                defpro.hkl = hklDef;
            }
        }

        pdefpro = _rgDefProfiles.Append(1);
        if (!pdefpro)
            return FALSE;

        memcpy(pdefpro, &defpro, sizeof(defpro));

#ifdef DEBUG
{
    char szDbgCatid[CLSID_STRLEN + 1];
    char szDbgClsid[CLSID_STRLEN + 1];
    char szDbgguidProfile[CLSID_STRLEN + 1];
    CLSIDToStringA(defpro.catid, szDbgCatid);
    CLSIDToStringA(defpro.clsid, szDbgClsid);
    CLSIDToStringA(defpro.guidProfile, szDbgguidProfile);
    TraceMsg(TF_GENERAL, "CDefaultProfiles:: langid %08x", _langid);
    TraceMsg(TF_GENERAL, "                   catid        %s", szDbgCatid);
    TraceMsg(TF_GENERAL, "                   clsid        %s", szDbgClsid);
    TraceMsg(TF_GENERAL, "                   guidProfile  %s", szDbgguidProfile);
    TraceMsg(TF_GENERAL, "                   hkl          %08x", (DWORD)HandleToLong(defpro.hkl));
}
#endif

Next:
        dwIndex++;
    }

Exit:
    if (LOWORD(HandleToLong(hklDef)) == _langid)
    {
        if (!fFoundKeyboardIteminDefLang)
        {
            //
            // Check if the default hkl is a substitute hKL of a TIP's 
            // profile.
            //
            if (!GetSubstitutedItem(hklDef, &defpro))
            {
                //
                // we could not find TIP profile. Use this hkl as a default 
                // item.
                //
                defpro.catid = GUID_TFCAT_TIP_KEYBOARD;
                defpro.clsid = CLSID_NULL;
                defpro.guidProfile = GUID_NULL;
                defpro.hkl = hklDef;
            }

            pdefpro = _rgDefProfiles.Append(1);
            if (!pdefpro)
                return FALSE;

            memcpy(pdefpro, &defpro, sizeof(defpro));
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// GetSubstitutedItem
//
// this function walks HKLM\Software\Microsoft\CTF\TIPs to find the 
// TIP profile that uses hklSub as its substitute hKL.
//
//----------------------------------------------------------------------------

BOOL CDefaultProfiles::GetSubstitutedItem(HKL hklSub, DEFAULTPROFILE *pdefpro)
{
    CMyRegKey key;
    DWORD dwIndex;
    
    TCHAR szKey[256];
    TCHAR szSubKey[256];
    TCHAR szLangKey[256];
    TCHAR szValue[256];

    StringCopyArray(szKey, c_szCTFTIPKey);
    if (key.Open(HKEY_LOCAL_MACHINE, szKey, KEY_READ) != S_OK)
    {
        return FALSE;
    }

    // get all profiles from LanguageProfile registry.
    //
    dwIndex = 0;
    while (key.EnumKey(dwIndex, szSubKey, ARRAYSIZE(szSubKey)) == S_OK)
    {
        CMyRegKey subkey;
        CLSID clsid;
        StringAToCLSID(szSubKey, &clsid);

        if (StringCchPrintf(szSubKey + lstrlen(szSubKey), ARRAYSIZE(szSubKey), "\\%s", c_szLanguageProfileKey) != S_OK)
            goto Next0;

        if (subkey.Open(key, szSubKey, KEY_READ) != S_OK)
            goto Next0;

        DWORD dwIndexLang = 0;
        while (subkey.EnumKey(dwIndexLang, szLangKey, ARRAYSIZE(szLangKey)) == S_OK)
        {
            CMyRegKey langkey;
            LANGID langid;

            if ((szLangKey[0] != '0') || 
                ((szLangKey[1] != 'X') && (szLangKey[1] != 'x')))
                goto Next1;

            langid = (LANGID)AsciiToNum(&szLangKey[2]);

            //
            // The language ID does not meet the given hklSub.
            //
            if (langid != LANGIDFROMHKL(hklSub))
                goto Next1;

            if (langkey.Open(subkey, szLangKey, KEY_READ) != S_OK)
                goto Next1;

            DWORD dwProfileIndex = 0; 
            while (langkey.EnumKey(dwProfileIndex, szValue, ARRAYSIZE(szValue)) == S_OK)
            {
                 GUID guidProfile;
                 CRegKeyMUI keyProfile;
               
                 if (!StringAToCLSID(szValue, &guidProfile))
                     goto Next2;

                 if (keyProfile.Open(langkey, szValue, KEY_READ) == S_OK)
                 { 
                      if (hklSub == GetSubstituteHKLfromKey(&keyProfile, langid))
                      {
                          //
                          // ok, we found it. Assume it is Keyboard category.
                          //
                          pdefpro->catid = GUID_TFCAT_TIP_KEYBOARD;
                          pdefpro->clsid = clsid;
                          pdefpro->guidProfile = guidProfile;
                          pdefpro->hkl = 0;

                          return TRUE;
                      }
                }

Next2:
                 dwProfileIndex++;
            }
Next1:
            dwIndexLang++;
        }

Next0:
        dwIndex++;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// FilterProfiles
//
//----------------------------------------------------------------------------

BOOL CDefaultProfiles::FilterProfiles(CAssembly *pAsm)
{
    int i;
    int j;
    Assert(_langid == pAsm->GetLangId());

    for (i = _rgDefProfiles.Count() - 1; i >= 0 ; i--)
    {
        DEFAULTPROFILE *pdefpro = _rgDefProfiles.GetPtr(i);
        if (!pdefpro)
        {
            Assert(0);
            return FALSE;
        }

        BOOL fFound = FALSE;

        for (j = 0; j < pAsm->Count(); j++)
        {
            ASSEMBLYITEM *pItem = pAsm->GetItem(j);

            if (IsEqualGUID(pItem->catid, pdefpro->catid) &&
                IsEqualGUID(pItem->clsid, pdefpro->clsid) &&
                IsEqualGUID(pItem->guidProfile, pdefpro->guidProfile))
            {
                fFound = pItem->fEnabled ? TRUE : FALSE;
                break;
            }

        }

        if (!fFound)
        {
            _rgDefProfiles.Remove(i, 1);
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// GetDefaultProfile
//
//----------------------------------------------------------------------------

BOOL CDefaultProfiles::GetDefaultProfile(GUID catid, GUID *pclsid, GUID *pguidProfile, HKL *phkl)
{
    int i;
    for (i = 0; i < _rgDefProfiles.Count(); i++)
    {
        DEFAULTPROFILE *pdefpro = _rgDefProfiles.GetPtr(i);
        if (!pdefpro)
        {
            Assert(0);
            return FALSE;
        }

        if (IsEqualGUID(catid, pdefpro->catid))
        {
            *pclsid = pdefpro->clsid;
            *pguidProfile = pdefpro->guidProfile;
            *phkl = pdefpro->hkl;
            return TRUE;
        }
    }

    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
//
// CAssemblyList
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CAssemblyList::CAssemblyList()
{
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CAssemblyList::~CAssemblyList()
{
    ClearAsms();
}

//+---------------------------------------------------------------------------
//
// ClearAsms
//
//----------------------------------------------------------------------------

void CAssemblyList::ClearAsms()
{
    int i = 0;
    while (i < _rgAsm.Count())
    {
        CAssembly *pAsm = _rgAsm.Get(i);
        delete pAsm;
        i++;
    }
    _rgAsm.Clear();
}


//+---------------------------------------------------------------------------
//
// FindAndCreateNewAssembly
//
//----------------------------------------------------------------------------

extern INATSYMBOL symInatSymbols[];

CAssembly *CAssemblyList::FindAndCreateNewAssembly(CPtrArray<CAssembly> *prgAsm,  CPtrArray<CAssembly> *prgNutralAsm, LANGID langid)
{
    CPtrArray<CAssembly> *prg;

    if (langid == 0xffff)
        prg = prgNutralAsm;
    else 
        prg = (langid & 0xfc00) ? prgAsm : prgNutralAsm;

    //
    // do we already have pAsm?
    //
    CAssembly *pAsm = FindAssemblyByLangIdInArray(prg, langid);
    if (pAsm == NULL)
    {
        pAsm = new CAssembly(langid);

        if (pAsm)
        {
            CAssembly **ppAsm;
            ppAsm = prg->Append(1);
            if (ppAsm)
            {
                *ppAsm = pAsm;
            }
            else
            {
                delete pAsm;
                pAsm = NULL;
            }
        }
    }
    return pAsm;
}

//+---------------------------------------------------------------------------
//
// AttachOriginalAssembly
//
//----------------------------------------------------------------------------

void CAssemblyList::AttachOriginalAssembly(CPtrArray<CAssembly> *prgAsmOrg)
{
    int i;
    int j;
    SYSTHREAD *psfn = GetSYSTHREAD();
    CAssembly *pAsm = FindAssemblyByLangId(GetCurrentAssemblyLangId(psfn));

    if (!pAsm)
        return;

    for (i = 0; i < prgAsmOrg->Count(); i++)
    {
        CAssembly *pAsmOrg = prgAsmOrg->Get(i);

        if (pAsm->GetLangId() == pAsmOrg->GetLangId())
        {
            for (j = 0; j < pAsm->Count(); j++)
            {
                int nId;
                ASSEMBLYITEM *pItem = pAsm->GetItem(j);

                if (!pItem)
                    continue;

                nId = pAsmOrg->Find(pItem);
                if (nId >= 0)
                {
                    ASSEMBLYITEM *pItemOrg;
                    pItemOrg = pAsmOrg->GetItem(nId);
                    BOOL fPrevActive = pItem->fActive;
                    if (pItemOrg && (pItemOrg->fActive))
                    {
                        pItem->fActive = pItemOrg->fActive;

                        //
                        // we need to deactivate all other item in the 
                        // category.
                        //
                        if (!fPrevActive && pItem->fActive)
                        {
                            for (int k = 0; k < pAsm->Count(); k++)
                            {
                                ASSEMBLYITEM *pItemTemp = pAsm->GetItem(k);
                                if (pItemTemp == pItem)
                                    continue;

                                if (IsEqualGUID(pItemTemp->catid, pItem->catid))
                                    pItemTemp->fActive = FALSE;
                            }
                        }
                    }
                }
            }

            break;
        }
    }
}

//+---------------------------------------------------------------------------
//
// Load
//
//----------------------------------------------------------------------------

extern INATSYMBOL symInatSymbols[];

HRESULT CAssemblyList::Load()
{
    CMyRegKey key;
    CMyRegKey key2;
    int nhkl;
    HKL *lphkl = NULL;
    HKL hklList[2];
    LANGID langid;
    int i;
    ASSEMBLYITEM ai;
    DWORD dwIndex;
    CAssembly *pAsm = NULL;
    BOOL fFoundActiveNoCic = FALSE;
    CPtrArray<CAssembly> *prgNutralAsm = NULL;
    IEnumGUID *pEnumCat = NULL;
    HRESULT hr;
    int nAsmCnt;
    CPtrArray<CAssembly> rgAsmOrg;
    
    TCHAR szKey[256];
    TCHAR szSubKey[256];
    TCHAR szLangKey[256];
    TCHAR szValue[256];

    //
    // backup original assembly in rgAsmOrg;
    //
    for (i = 0; i < _rgAsm.Count(); i++)
    {
        pAsm = _rgAsm.Get(i);
        if (pAsm)
        {
            CAssembly **ppAsm = rgAsmOrg.Append(1);
            if (ppAsm)
                *ppAsm = pAsm;
        }
    }
    _rgAsm.Clear();

#ifdef PROFILE_UPDATE_REGISTRY  // old code for tip setup.
    if (IsUpdated())
    {
        ClearUpdatedFlag();
    }
    else
#endif
    {
        if (LoadFromCache())
        {
            AttachOriginalAssembly(&rgAsmOrg);
            hr = S_OK;
            goto Exit;
        }
    }

    prgNutralAsm = new CPtrArray<CAssembly>;
    if (!prgNutralAsm)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    StringCopyArray(szKey, c_szCTFTIPKey);
    if (key.Open(HKEY_LOCAL_MACHINE, szKey, KEY_READ) != S_OK)
    {
        hr = E_FAIL;
        goto Exit;
    }

    nhkl = GetKeyboardLayoutList(0, NULL);
    if (nhkl)
    {
        lphkl = (HKL *)cicMemAllocClear(sizeof(HKL) * (nhkl + 1));
        GetKeyboardLayoutList(nhkl, lphkl);
    }
    else
    {
        hklList[0] = GetKeyboardLayout(NULL);
        hklList[1] = NULL;
        lphkl = hklList;
    }

    //
    //  clear Category cache
    //
    CCategoryMgr::FreeCatCache();

    hr = g_EnumItemsInCategory(GUID_TFCAT_CATEGORY_OF_TIP, &pEnumCat);
    if (FAILED(hr))
    {
        goto Exit;
    }

    //
    // Check all TIP CLSID under HKCU is valid TIP CLSIDs.
    //
    StringCopyArray(szKey, c_szCTFTIPKey);
    if (key2.Open(HKEY_CURRENT_USER, szKey, KEY_ALL_ACCESS) == S_OK)
    {
        dwIndex = 0;
        while (key2.EnumKey(dwIndex, szSubKey, ARRAYSIZE(szSubKey)) == S_OK)
        {
            CMyRegKey subkey;
            dwIndex++;

            //
            // if we could not open the subkey (CLSID key) in HKLM,
            // HKCU should not have the subkey.
            //
            if (subkey.Open(key, szSubKey, KEY_READ) != S_OK)
            {
                if (key2.RecurseDeleteKey(szSubKey) == S_OK)
                    dwIndex--;
            }
        }
    }

    //
    // get all profiles from LanguageProfile registry.
    //
    dwIndex = 0;
    while (key.EnumKey(dwIndex++, szSubKey, ARRAYSIZE(szSubKey)) == S_OK)
    {
        CMyRegKey subkey;
        CLSID clsid;
        StringAToCLSID(szSubKey, &clsid);

        if (StringCchPrintf(szSubKey + lstrlen(szSubKey), ARRAYSIZE(szSubKey), "\\%s", c_szLanguageProfileKey) != S_OK)
            continue;

        if (subkey.Open(key, szSubKey, KEY_READ) == S_OK)
        {
            DWORD dwIndexLang = 0;
            while (subkey.EnumKey(dwIndexLang, szLangKey, ARRAYSIZE(szLangKey)) == S_OK)
            {
                CMyRegKey langkey;

                if ((szLangKey[0] != '0') || 
                    ((szLangKey[1] != 'X') && (szLangKey[1] != 'x')))
                    goto Next;

                langid = (LANGID)AsciiToNum(&szLangKey[2]);

                //
                // do we already have pAsm?
                //
                pAsm = FindAndCreateNewAssembly(&_rgAsm,  prgNutralAsm, langid);
                if (pAsm == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto Exit;
                }

                if (langkey.Open(subkey, szLangKey, KEY_READ) == S_OK)
                {
                    DWORD dwProfileIndex = 0; 
                    while (langkey.EnumKey(dwProfileIndex, szValue, ARRAYSIZE(szValue)) == S_OK)
                    {
                         GUID guidProfile;
                         CRegKeyMUI keyProfile;
                       
                         if (!StringAToCLSID(szValue, &guidProfile))
                             goto NextKey;

                         memset(&ai, 0, ai.GetAlignSize());
                         ai.InitIconIndex();
                         ai.clsid = clsid;
                         ai.fActive = FALSE;
                         GetTIPCategory(clsid, &ai.catid, pEnumCat);
                         ai.guidProfile = guidProfile;
                         ai.fEnabled = FALSE;
 
                         // we will assign proper hKL later.
                         ai.hkl = NULL;


                         hr = keyProfile.Open(langkey, szValue, KEY_READ);
                         if (hr == S_OK)
                         { 
                              ai.hklSubstitute = GetSubstituteHKLfromKey(&keyProfile, langid);

                              hr = keyProfile.QueryMUIValueW(ai.szProfile,
                                                             c_szDescriptionW,
                                                             c_szMUIDescriptionW,
                                                             ARRAYSIZE(ai.szProfile));
                              
                              DWORD dw;
                              if ((keyProfile.QueryValue(dw, c_szDisabledOnTransitory) == S_OK) && dw)
                                  ai.fDisabledOnTransitory = TRUE;
                         }

                         if (hr == S_OK)
                             pAsm->Add(&ai);
NextKey:
                         dwProfileIndex++;
                    }
                }
Next:
                dwIndexLang++;
            }

        }
    }

    //
    // check all assembly has KEYBOARD category.
    // If not, we load keyboard layout for the assembly.
    //
    nAsmCnt = _rgAsm.Count();
    for (i = 0; i < nAsmCnt; i++)
    {
        BOOL bLoaded;
        int j;

        CAssembly *pAsmTmp = _rgAsm.Get(i);
        if (pAsmTmp->FindItemByCategory(GUID_TFCAT_TIP_KEYBOARD))
           continue;

        LANGID langidTmp = pAsmTmp->GetLangId();

        //
        // we can not use IsEnabledItem() here. We have not updated
        // the enbaled status of Items yet.
        //
        // if (!pAsmTmp->IsEnabledItem())
        //     continue;
        //
        BOOL fFound = FALSE;
        for (j = 0; j < pAsmTmp->Count(); j++)
        {
            ASSEMBLYITEM *pItem = pAsmTmp->GetItem(j);
            if (pItem->fEnabled ||
                IsEnabledLanguageProfileFromReg(pItem->clsid, 
                                                pAsmTmp->_langid, 
                                                pItem->guidProfile))
            {
                fFound = TRUE;
                break;
            }
        }

        if (!fFound)
            continue;

        //
        // Load a proper keyboard layout....
        //
        GetProperHKL(langidTmp, lphkl, &bLoaded);

        if (bLoaded)
        {
            //
            // re-create the keyboard layout list.
            //
            nhkl = GetKeyboardLayoutList(0, NULL);
            if (nhkl)
            {
                if (lphkl && (lphkl != hklList))
                    cicMemFree(lphkl);
                lphkl = (HKL *)cicMemAllocClear(sizeof(HKL) * (nhkl + 1));
                GetKeyboardLayoutList(nhkl, lphkl);
            }
            else
            {
                hklList[0] = GetKeyboardLayout(NULL);
                hklList[1] = NULL;
                lphkl = hklList;
            }
        }
    }

    //
    // get all hKLs.
    //
    if (lphkl)
    {
        HKL *lphklCur = lphkl;
        DWORD *pdwPreload = NULL;
        UINT uPreloadCnt;

        //
        // load preload layouts infomation.
        //
        uPreloadCnt = GetPreloadListForNT(NULL, 0);
        if (uPreloadCnt)
        {
            Assert(IsOnNT());
            pdwPreload = new DWORD[uPreloadCnt];
            if (pdwPreload)
                GetPreloadListForNT(pdwPreload, uPreloadCnt);
        }

        while (*lphklCur)
        {
            BOOL fIsDefaultHKLinPreload = FALSE;
            WORD wLayout = HIWORD((DWORD)(LONG_PTR)(*lphklCur));
            langid = (LANGID)((DWORD)(LONG_PTR)(*lphklCur) & 0x0000ffff);
    
            //
            // do we already have pAsm?
            //
            pAsm = FindAndCreateNewAssembly(&_rgAsm,  prgNutralAsm, langid);
            if (pAsm == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }

            //
            // See Preload to check if this default hKL is real dummy or not.
            // The default FE layout is not a dummy hKL if it is in Preload
            // list.
            //
            if (IsFELangId(langid))
            {
                if (wLayout == (WORD)langid)
                {
                    UINT uCur;
                    for (uCur = 0; uCur < uPreloadCnt; uCur++)
                    {
                        //
                        // check if we have 0x00000411 in preload.
                        //
                        if (pdwPreload[uCur] == (DWORD)(wLayout))
                        {
                            fIsDefaultHKLinPreload = TRUE;
                            break;
                        }
                    }
                }
                else if ((wLayout & 0xf000) != 0xe000)
                {
                    fIsDefaultHKLinPreload = TRUE;
                }
            }

            //
            // we skip dummy FE hKL.
            //
            if (!IsFELangId(langid) || 
                IsPureIMEHKL(*lphklCur) ||
                fIsDefaultHKLinPreload ||
                !pAsm->FindPureKbdTipItem())
            {
                TF_InitMlngInfo();
                MLNGINFO mlInfo;
                if (pAsm == NULL)
                    pAsm = new CAssembly(langid);
    
                memset(&ai, 0, ai.GetAlignSize());
                ai.InitIconIndex();
                ai.hkl = *lphklCur;
                ai.clsid = GUID_NULL;
                ai.catid = GUID_TFCAT_TIP_KEYBOARD;
                ai.fActive = FALSE;
                ai.fEnabled = TRUE;
                if (GetMlngInfoByhKL(ai.hkl, &mlInfo) == -1)
                   mlInfo.SetDesc(L"");
    
                ai.guidProfile = GUID_NULL;
                StringCopyArrayW(ai.szProfile, mlInfo.GetDesc());

                pAsm->Add(&ai);
            }
            lphklCur++;
        }
       
        if (pdwPreload)
            delete pdwPreload;
    }

    //
    // filter neutral langiage assembly
    //
    while (prgNutralAsm->Count())
    {
        pAsm = prgNutralAsm->Get(0);
        langid = pAsm->GetLangId();

        Assert((langid == 0xffff) || !(langid & 0xFC00));

        //
        // find valid langid ang merge there.
        //
        for (i = 0; i < _rgAsm.Count(); i++)
        {
            CAssembly *pAsmDst = _rgAsm.Get(i);
            LANGID langidDst = pAsmDst->GetLangId();
            Assert(langidDst & 0xFC00);

            //
            // we found a valid langid.
            //
            if ((langid == 0xffff) || 
                (PRIMARYLANGID(langid) == PRIMARYLANGID(langidDst)))
            {
                int j;
                for (j = 0; j < pAsm->Count(); j++)
                {
                    ASSEMBLYITEM *pItem = pAsm->GetItem(j);
                    pItem->fActive = FALSE;
                    pItem->fActiveNoCic = FALSE;

                    // we will assign proper hKL later.
                    pItem->hkl = NULL;

                    pAsmDst->Add(pItem);
                }
            }
        }

        //
        // we don't need a neutral lang assembly.
        //
        prgNutralAsm->Remove(0, 1);
        delete pAsm;
    }

    //
    // It is time to decide this profile should be activated by default.
    //
    for (i = 0; i < _rgAsm.Count(); i++)
    {
        int j;
        pAsm = _rgAsm.Get(i);

        CDefaultProfiles defProfiles(pAsm->_langid);
        defProfiles.Init(lphkl);

        //
        // update Enable status.
        //
        // this must be done before filtering the default profiles.
        // disabled item should not be the default proble.
        //
        for (j = 0; j < pAsm->Count(); j++)
        {
            ASSEMBLYITEM *pItem = pAsm->GetItem(j);
            if (!pItem->fEnabled)
                pItem->fEnabled = IsEnabledLanguageProfileFromReg(pItem->clsid, 
                                                                  pAsm->_langid, 
                                                                  pItem->guidProfile);
        }


        //
        // check if the default profile is enabled.
        //
        defProfiles.FilterProfiles(pAsm);

        for (j = 0; j < pAsm->Count(); j++)
        {
            ASSEMBLYITEM *pItem = pAsm->GetItem(j);
            CLSID clsid;
            GUID guidProfile;
            HKL  hkl;

            //
            // If the item is not categoried, we activate it.
            //
            if (IsEqualGUID(pItem->catid, GUID_NULL))
            {
                pItem->fActive = TRUE;
                continue;
            }

            //
            // if this item is enabled, load proper hkl.
            //
            if (pItem->fEnabled && 
                IsEqualGUID(pItem->catid, GUID_TFCAT_TIP_KEYBOARD) &&
                !pItem->hkl)
                pItem->hkl = GetProperHKL(pAsm->_langid, lphkl, NULL);

            //
            // init fActivate to false by default.
            //
            pItem->fActive = FALSE;

            if (pItem->fEnabled)
            {
                //
                // GetDefaultProfile() may return NULL in hkl if someone calls
                // ITfInputProcessorProfiles::SetDefaultLanguageProfile() method
                // from outside. We should not check hkl value then.
                //
                if (defProfiles.GetDefaultProfile(pItem->catid, 
                                                  &clsid, 
                                                  &guidProfile, 
                                                  &hkl))
                {

                    //
                    // ok this item is not default profile.
                    //
                    if (!IsEqualCLSID(pItem->clsid, clsid) ||
                        !IsEqualCLSID(pItem->guidProfile, guidProfile) ||
                        (hkl && (pItem->hkl != hkl)))
                        continue;

                    pItem->fActive = TRUE;
                }
                else if (defProfiles.Append(pItem->catid,
                                            pItem->clsid,
                                            pItem->guidProfile,
                                            pItem->hkl))
                {
                        pItem->fActive = TRUE;
                }
            }
        }

#ifdef DEBUG
        for (j = 0; j < pAsm->Count(); j++)
        {
            ASSEMBLYITEM *pItem = pAsm->GetItem(j);
            int k;
            if (!pItem->fActive)
            {
                UINT uCnt = 0;

                for (k = 0; k < pAsm->Count(); k++)
                {
                    ASSEMBLYITEM *pItemTemp = pAsm->GetItem(k);
                    if (IsEqualGUID(pItemTemp->catid, pItem->catid))
                        uCnt += (pItemTemp->fActive) ? 1 : 0;
                }
                Assert(uCnt <= 1);
            }
        }
#endif
    }

    //
    // we should create cache before attaching the original assembly active
    // status.
    // AttachOriginalAssembly() is just for the current thread.
    //
    if (IsAsmCache())
        CreateCache();

    if (rgAsmOrg.Count())
        AttachOriginalAssembly(&rgAsmOrg);

    hr = S_OK;

Exit:

    if (lphkl && (lphkl != hklList))
        cicMemFree(lphkl);

 
    if (prgNutralAsm)
    {
        Assert(!prgNutralAsm->Count())
        delete prgNutralAsm;
    }

    if (pEnumCat)
        pEnumCat->Release();

    //
    // clean up original assemblies.
    //
    for (i = 0; i < rgAsmOrg.Count(); i++)
    {
        pAsm = rgAsmOrg.Get(i);
        delete pAsm;
    }
    rgAsmOrg.Clear();

    return hr;
}

//+---------------------------------------------------------------------------
//
// GetDefaultAssembly
//
//----------------------------------------------------------------------------

CAssembly *CAssemblyList::GetDefaultAssembly()
{
    CAssembly *pAsm = NULL;
    int nAsmCnt = _rgAsm.Count();
    DWORD langid;

    if (!nAsmCnt)
        return NULL;

    langid = (LANGID)LOWORD(HandleToLong(GetSystemDefaultHKL()));
    if (!langid)
        return _rgAsm.Get(0);

    int nCurAsm = 0;

    while (nCurAsm < nAsmCnt)
    {
        CAssembly *pAsmTmp = _rgAsm.Get(nCurAsm);
        if (pAsmTmp->_langid == langid)
        {
            pAsm = pAsmTmp;
            break;
        }
        nCurAsm++;
    }

    if (!pAsm)
        pAsm = _rgAsm.Get(0);

    return pAsm;
}

//+---------------------------------------------------------------------------
//
// CreateCache
//
//----------------------------------------------------------------------------


typedef struct tag_ASSEMBLY_ROOT
{
    DWORD    dwAssemblyCount;
    // ASSEMBLYHDR[]

    static size_t   GetAlignSize() { return Align(sizeof(struct tag_ASSEMBLY_ROOT)); }
} ASSEMBLY_ROOT;

typedef struct tag_ASSEMBLYHDR 
{
    DWORD dwCnt;
    LANGID langid;
    // ASSEMBLYITEM[]

    static size_t   GetAlignSize() { return Align(sizeof(struct tag_ASSEMBLYHDR)); }
} ASSEMBLYHDR;

CCicFileMapping *g_pcfmAsmCache = NULL;

BOOL EnsureAsmCacheFileMap()
{
    if (!g_pcfmAsmCache)
        g_pcfmAsmCache = new CCicFileMapping();

    return g_pcfmAsmCache ? TRUE : FALSE;
}

BOOL UninitAsmCacheFileMap()
{
    if (g_pcfmAsmCache)
    {
        delete g_pcfmAsmCache;
        g_pcfmAsmCache = NULL;
    }
    return TRUE;
}

BOOL IsAsmCache()
{
    return g_pcfmAsmCache ? TRUE : FALSE;
}

//+---------------------------------------------------------------------------
//
// CreateCache
//
//----------------------------------------------------------------------------

BOOL CAssemblyList::CreateCache()
{
    int nAsmCnt = _rgAsm.Count();
    int nCurAsm = 0;
    HANDLE hfm = NULL;
    DWORD cbSize = 0;
    BYTE *pv;
    BOOL bRet = FALSE;
    CCicSecAttr sa;

    if (!g_pcfmAsmCache)
        return TRUE;

    if (!g_pcfmAsmCache->Enter())
        return FALSE;

    g_pcfmAsmCache->Close();

    g_pcfmAsmCache->Init(g_szAsmListCache, &g_mutexAsm);

    //
    // ASSEMBLY_ROOT, ASSEMBLYHDR and ASSEMBLYITEM
    //
    // When calc next data struc pointer, should not use sizeof()
    // because need adjust data alignment for 64/32bit on IA64.
    // Please use GetAlignSize() method instead of sizeof().
    //

    cbSize += ASSEMBLY_ROOT::GetAlignSize();
    while (nCurAsm < nAsmCnt)
    {
        CAssembly *pAsm = _rgAsm.Get(nCurAsm);
        cbSize += ASSEMBLYHDR::GetAlignSize();
        cbSize += (pAsm->Count() * ASSEMBLYITEM::GetAlignSize());
        nCurAsm++;
    }

    pv = (BYTE *)g_pcfmAsmCache->Create(sa, cbSize, NULL);
    if (!pv)
        goto Exit;

    ASSEMBLY_ROOT* pasm_root = (ASSEMBLY_ROOT*) pv;
    pasm_root->dwAssemblyCount = nAsmCnt;
    pv += ASSEMBLY_ROOT::GetAlignSize();

    nCurAsm = 0;
    while (nCurAsm < nAsmCnt)
    {
        ASSEMBLYHDR *pAsmHdr;
        CAssembly *pAsm = _rgAsm.Get(nCurAsm);

        pAsmHdr = (ASSEMBLYHDR *)pv;
        pAsmHdr->dwCnt = pAsm->Count();
        pAsmHdr->langid = pAsm->GetLangId();
    
        pv += ASSEMBLYHDR::GetAlignSize();

        int nItemCnt = pAsm->Count();
        int nCurItem = 0;

        while (nCurItem < nItemCnt)
        {
            ASSEMBLYITEM *pItem = pAsm->GetItem(nCurItem);

            memcpy(pv, pItem, ASSEMBLYITEM::GetAlignSize());
            pv += ASSEMBLYITEM::GetAlignSize();

            nCurItem++;
        }

        nCurAsm++;
    }

    bRet = TRUE;

Exit:

    g_pcfmAsmCache->Leave();
    return bRet;
}

//+---------------------------------------------------------------------------
//
// LoadFromCache
//
//----------------------------------------------------------------------------

BOOL CAssemblyList::LoadFromCache()
{
    HANDLE hfm = NULL;
    BYTE *pv;
    int nAsmCnt;
    int nCurAsm = 0;
    BOOL bRet = FALSE;

    CCicFileMapping cfm(g_szAsmListCache, &g_mutexAsm);

    if (!cfm.Enter())
        return FALSE;

    pv = (BYTE *)cfm.Open();
    if (!pv)
        goto Exit;

    //
    // ASSEMBLY_ROOT, ASSEMBLYHDR and ASSEMBLYITEM
    //
    // When calc next data struc pointer, should not use sizeof()
    // because need adjust data alignment for 64/32bit on IA64.
    // Please use GetAlignSize() method instead of sizeof().
    //

    cfm.Flush(ASSEMBLY_ROOT::GetAlignSize());

    ASSEMBLY_ROOT* pasm_root = (ASSEMBLY_ROOT*) pv;
    nAsmCnt = pasm_root->dwAssemblyCount;
    pv += ASSEMBLY_ROOT::GetAlignSize();

    if (!nAsmCnt)
        goto Exit;

    while (nCurAsm < nAsmCnt)
    {
        ASSEMBLYHDR *pAsmHdr;
        CAssembly *pAsm;
        int nItemCnt;
        int nCurItem = 0;

        pAsmHdr = (ASSEMBLYHDR *)pv;
        nItemCnt = pAsmHdr->dwCnt;
 
        pAsm = new CAssembly(pAsmHdr->langid);
        pv += ASSEMBLYHDR::GetAlignSize();

        while (nCurItem < nItemCnt)
        {
            ASSEMBLYITEM *pItem = (ASSEMBLYITEM *)pv;
            pItem->InitIconIndex();

            if (pAsm)
                pAsm->Add(pItem);

            pv += ASSEMBLYITEM::GetAlignSize();
            nCurItem++;
        }

        if (pAsm)
        {
            CAssembly **ppAsm;
            ppAsm = _rgAsm.Append(1);
            if (ppAsm)
            {
                *ppAsm = pAsm;
            }
            else
            {
                delete pAsm;
            }

        }

        nCurAsm++;
    }

    bRet = TRUE;
Exit:
    cfm.Leave();
    return bRet;
}

//+---------------------------------------------------------------------------
//
// InvalidCache
//
//----------------------------------------------------------------------------

BOOL CAssemblyList::InvalidCache()
{
    HANDLE hfm = NULL;
    DWORD *pv;
    BOOL bRet = FALSE;

    CCicFileMapping cfm(g_szAsmListCache, &g_mutexAsm);

    if (!cfm.Enter())
        return FALSE;

    pv = (DWORD *)cfm.Open();
    if (!pv)
        goto Exit;

    //
    // ASSEMBLY_ROOT, ASSEMBLYHDR and ASSEMBLYITEM
    //
    // When calc next data struc pointer, should not use sizeof()
    // because need adjust data alignment for 64/32bit on IA64.
    // Please use GetAlignSize() method instead of sizeof().
    //

    if (pv)
    {
        ASSEMBLY_ROOT* pasm_root = (ASSEMBLY_ROOT*) pv;
        pasm_root->dwAssemblyCount = 0;

        cfm.Flush(ASSEMBLY_ROOT::GetAlignSize());
        bRet = TRUE;
    }

Exit:
    cfm.Leave();
    return bRet;
}

//+---------------------------------------------------------------------------
//
// SetDefaultTIPInAssemblyForCache
//
//----------------------------------------------------------------------------

BOOL CAssemblyList::SetDefaultTIPInAssemblyForCache(LANGID langid, REFGUID catid, REFCLSID clsid, HKL hKL, REFGUID guidProfile)
{
    BYTE *pv;
    int nAsmCnt;
    int nCurAsm = 0;
    BOOL bRet = FALSE;

    CCicFileMapping cfm(g_szAsmListCache, &g_mutexAsm);

    if (!cfm.Enter())
        return FALSE;

    pv = (BYTE *)cfm.Open();
    if (!pv)
        goto Exit;

    //
    // ASSEMBLY_ROOT, ASSEMBLYHDR and ASSEMBLYITEM
    //
    // When calc next data struc pointer, should not use sizeof()
    // because need adjust data alignment for 64/32bit on IA64.
    // Please use GetAlignSize() method instead of sizeof().
    //

    ASSEMBLY_ROOT* pasm_root = (ASSEMBLY_ROOT*) pv;
    nAsmCnt = pasm_root->dwAssemblyCount;
    pv += ASSEMBLY_ROOT::GetAlignSize();

    if (!nAsmCnt)
        goto Exit;

    while (nCurAsm < nAsmCnt)
    {
        ASSEMBLYHDR *pAsmHdr;
        int nItemCnt;
        int nCurItem = 0;

        pAsmHdr = (ASSEMBLYHDR *)pv;
        BOOL fTargetLang = (pAsmHdr->langid == langid) ? TRUE : FALSE;

        nItemCnt = pAsmHdr->dwCnt;
        pv += ASSEMBLYHDR::GetAlignSize();

        while (nCurItem < nItemCnt)
        {
            if (fTargetLang)
            {
                ASSEMBLYITEM *pItem = (ASSEMBLYITEM *)pv;

                if (IsEqualGUID(pItem->catid, catid))
                {
                    if (IsEqualGUID(pItem->clsid, clsid) &&
                        IsEqualGUID(pItem->guidProfile, guidProfile) &&
                        (!hKL || (hKL == pItem->hkl)))
                    {
                        pItem->fActive = TRUE;
                    }
                    else
                    { 
                        pItem->fActive = FALSE;
                    }
                }
            }

            pv += ASSEMBLYITEM::GetAlignSize();
            nCurItem++;
        }

        if (fTargetLang)
            break;

        nCurAsm++;
    }

    bRet = TRUE;

Exit:
    cfm.Leave();
    return bRet;
}

#ifdef PROFILE_UPDATE_REGISTRY  // old code for tip setup.
//+---------------------------------------------------------------------------
//
// IsUpdated
//
//----------------------------------------------------------------------------

BOOL CAssemblyList::IsUpdated()
{
    CMyRegKey key;

    if (key.Open(HKEY_LOCAL_MACHINE, c_szCTFKey, KEY_READ) != S_OK)
        return FALSE;

    char szName[16];
    DWORD dwCnt = sizeof(szName);
    if (key.QueryValue(szName, c_szUpdateProfile, &dwCnt) != S_OK)
        return FALSE;

    return (szName[0] == '1') ? TRUE : FALSE;
}

//+---------------------------------------------------------------------------
//
// ClearUpdatedFlag
//
//----------------------------------------------------------------------------

BOOL CAssemblyList::ClearUpdatedFlag()
{
    CMyRegKey key;

    if (key.Open(HKEY_LOCAL_MACHINE, c_szCTFKey) != S_OK)
        return FALSE;

    if (key.DeleteValue(c_szUpdateProfile) != S_OK)
        return FALSE;

    return TRUE;
}
#endif

//+---------------------------------------------------------------------------
//
// CheckLangSupport
//
//----------------------------------------------------------------------------

BOOL CAssemblyList::CheckLangSupport(REFCLSID rclsid, LANGID langid)
{
    CMyRegKey key;
    TCHAR szKey[256];
    TCHAR szLang[256];
    int i = 0;


    StringCopyArray(szKey, c_szCTFTIPKey);
    CLSIDToStringA(rclsid, szKey + lstrlen(szKey));
    StringCatArray(szKey, "\\");
    StringCatArray(szKey, c_szLanguageProfileKey);

    if (key.Open(HKEY_LOCAL_MACHINE, szKey, KEY_READ) == S_OK)
    {
        CMyRegKey subkey;

        //
        // Check a valid language id.
        //
        StringCchPrintf(szLang, ARRAYSIZE(szLang), "0x%08x", LOWORD(langid));
        StringCopyArray(szKey, szLang);
        if (subkey.Open(key, szKey, KEY_READ) == S_OK)
            return TRUE;

        //
        // Check a primary language id.
        //
        StringCchPrintf(szLang, ARRAYSIZE(szLang), "0x%08x", LOWORD(PRIMARYLANGID(langid)));
        StringCopyArray(szKey, szLang);
        if (subkey.Open(key, szKey, KEY_READ) == S_OK)
            return TRUE;

        //
        // Check a neutral language id.
        //
        StringCchPrintf(szLang, ARRAYSIZE(szLang), "0x0000ffff");
        StringCopyArray(szKey, szLang);
        if (subkey.Open(key, szKey, KEY_READ) == S_OK)
            return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// GetTIPCategory
//
//----------------------------------------------------------------------------

BOOL CAssemblyList::GetTIPCategory(REFCLSID clsid, GUID *pcatid, IEnumGUID *pEnumCat)
{
    HRESULT hr;
    BOOL fFound = FALSE;

    *pcatid = GUID_NULL;
    hr = pEnumCat->Reset();

    if (SUCCEEDED(hr))
    {
        GUID guidCat;
        while (!fFound && (pEnumCat->Next(1, &guidCat, NULL) == S_OK))
        {
            IEnumGUID *pEnumTip;
            hr = g_EnumItemsInCategory(guidCat, &pEnumTip);
            if (SUCCEEDED(hr) && pEnumTip)
            {
                GUID guidTip;
                while (!fFound && (pEnumTip->Next(1, &guidTip, NULL) == S_OK))
                {
                    if (IsEqualGUID(clsid, guidTip))
                    {
                        *pcatid = guidCat;
                        fFound = TRUE;
                    }
                }
                pEnumTip->Release();
            }
        }
    
    }

    return fFound;
}

//+---------------------------------------------------------------------------
//
// GetDefaultTIPInAssembly
//
//----------------------------------------------------------------------------

BOOL CAssemblyList::GetDefaultTIPInAssembly(LANGID langid, REFGUID catid, CLSID *pclsid, HKL *phKL, GUID *pguidProfile)
{
    CMyRegKey key;
    DWORD dw;
    char szKey[256];
    char szName[CLSID_STRLEN + 1];


    StringCopyArray(szKey, c_szAsmKey);
    StringCatArray(szKey, "\\");
    StringCchPrintf(szKey + lstrlen(szKey), ARRAYSIZE(szKey) - lstrlen(szKey), "0x%08x", langid);
    StringCatArray(szKey, "\\");
    CLSIDToStringA(catid, szKey + lstrlen(szKey));

    *pclsid = GUID_NULL;

    if (key.Open(HKEY_CURRENT_USER, szKey, KEY_READ) != S_OK)
        return FALSE;

    if (key.QueryValueCch(szName, c_szDefault, ARRAYSIZE(szName)) != S_OK)
        return FALSE;

    StringAToCLSID(szName, pclsid);

    if (key.QueryValueCch(szName, c_szProfile, ARRAYSIZE(szName)) != S_OK)
        return FALSE;

    StringAToCLSID(szName, pguidProfile);

    if (phKL)
    {
        *phKL = NULL;

        if (key.QueryValue(dw, c_szKeyboardLayout) != S_OK)
            return FALSE;

        *phKL = (HKL)IntToPtr(dw);
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// SetDefaultTIPInAssemblyInternal
//
//----------------------------------------------------------------------------

BOOL CAssemblyList::SetDefaultTIPInAssemblyInternal(CAssembly *pAsm, ASSEMBLYITEM *pItem, BOOL fChangeDefault)
{
    ASSEMBLYITEM *pItemSub = NULL;
    BOOL bRet = FALSE;
    
    Assert(!pItem->hkl || (pAsm->GetLangId() == LOWORD((DWORD)(LONG_PTR)(HKL)pItem->hkl)));

    //
    // If given hKL is substituted hKL, we set the original TIP as a default.
    //
    if (IsEqualGUID(pItem->catid, GUID_TFCAT_TIP_KEYBOARD))
    {
#if 0
        //
        // Chienese platform special. We don't set the new default keyboard.
        //
        if (IsChinesePlatform())
        {
            return TRUE;
        }

        pItemSub = pAsm->GetSubstituteItem(pItem->hkl);

        if (fChangeDefault)
        {
            //
            // try to change the system default hKL.
            //
            // When TIP that has substitute HKL is selected.
            //   if the language of the system default hKL is same, 
            //   set the hKL.
            //
            // When IME is selected.
            //   if the language of the system default hKL is same, set it.
            //
            HKL hklNewDef = IsPureIMEHKL(pItem->hkl) ? pItem->hkl : (IsPureIMEHKL(pItem->hklSubstitute) ? pItem->hklSubstitute : pItem->hkl);
            if (!IsFELangId(LOWORD((WORD)(LONG_PTR)(HKL)pItem->hkl)) || hklNewDef)
            {
                HKL hklDef = GetSystemDefaultHKL();
                if ((hklDef != hklNewDef) && 
                    (LOWORD((WORD)(LONG_PTR)hklDef) == LOWORD((WORD)(LONG_PTR)hklNewDef)))
                {
                    SetSystemDefaultHKL(hklNewDef);
                }
            }
        }
#else
        HKL hklDef = GetSystemDefaultHKL();
        if (pAsm->GetLangId() == LANGIDFROMHKL(hklDef))
        {
            //
            // Now we can set the default layout directly from CPL instead of 
            // just set language(bug#353989)
            //
            return TRUE;
        }

        pItemSub = pAsm->GetSubstituteItem(pItem->hkl);
#endif

    }

    if (pItemSub)
    {
        bRet = SetDefaultTIPInAssembly(pAsm->GetLangId(), 
                                       pItemSub->catid, 
                                       pItemSub->clsid, 
                                       pItemSub->hkl, 
                                       pItemSub->guidProfile);
    }
    else
    {
        bRet = SetDefaultTIPInAssembly(pAsm->GetLangId(), 
                                       pItem->catid, 
                                       pItem->clsid, 
                                       pItem->hkl, 
                                       pItem->guidProfile);
    }


    return bRet;
}


//+---------------------------------------------------------------------------
//
// SetDefaultTIPInAssembly
//
//----------------------------------------------------------------------------

BOOL CAssemblyList::SetDefaultTIPInAssembly(LANGID langid, REFGUID catid, REFCLSID clsid, HKL hKL, REFGUID guidProfile)
{
    CMyRegKey key;
    char szKey[256];
    char szName[256];

    StringCopyArray(szKey, c_szAsmKey);
    StringCatArray(szKey, "\\");
    StringCchPrintf(szKey + lstrlen(szKey), ARRAYSIZE(szKey) - lstrlen(szKey), "0x%08x", langid);
    StringCatArray(szKey, "\\");
    CLSIDToStringA(catid, szKey + lstrlen(szKey));

    if (key.Create(HKEY_CURRENT_USER, szKey) != S_OK)
        return FALSE;

    CLSIDToStringA(clsid, szName);
    if (key.SetValue(szName, c_szDefault) != S_OK)
        return FALSE;

    CLSIDToStringA(guidProfile, szName);
    if (key.SetValue(szName, c_szProfile) != S_OK)
        return FALSE;

    if (key.SetValue((DWORD)(ULONG_PTR)hKL, c_szKeyboardLayout) != S_OK)
        return FALSE;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// IsFEDummyKL
//
//----------------------------------------------------------------------------

BOOL CAssemblyList::IsFEDummyKL(HKL hkl)
{
    char szProfile[256];
    char szDummyProfile[256];
    static HKL hkl411Dummy = 0;
    static HKL hkl404Dummy = 0;
    static HKL hkl412Dummy = 0;
    static HKL hkl804Dummy = 0;
    HKL *phklDummy = NULL;
    BOOL bRet = FALSE;

    //
    // we don't use DummyHKL under NT.
    //
    if (IsOnNT())
        return FALSE;

    switch (LANGIDFROMLCID(hkl))
    {
        case 0x411: phklDummy = &hkl411Dummy; break;
        case 0x412: phklDummy = &hkl412Dummy; break;
        case 0x404: phklDummy = &hkl404Dummy; break;
        case 0x804: phklDummy = &hkl804Dummy; break;
        default:
           return FALSE;
    }

    if (!ImmGetDescription(hkl, szProfile, ARRAYSIZE(szProfile)))
    {
        return FALSE;
    }

    CicEnterCriticalSection(g_cs);

    if (*phklDummy)
    {
        bRet = (*phklDummy == hkl) ? TRUE : FALSE;
    }
    else
    {
        StringCchPrintf(szDummyProfile, ARRAYSIZE(szDummyProfile), "hkl%04x", LOWORD((DWORD)(UINT_PTR)hkl));
        if (!lstrcmp(szDummyProfile, szProfile))
        {
            *phklDummy = hkl;
            bRet = TRUE;
        }
    }

    CicLeaveCriticalSection(g_cs);

    return bRet;
}

//+---------------------------------------------------------------------------
//
// CheckKeyboardLayoutReg
//
//
// Hack for IMM32 hard code for "kbdjp.kbd" for Japanese hKL.
// If ImmInstallIME() fails, we try it after patching registry key.
//
//----------------------------------------------------------------------------

HKL CheckKeyboardLayoutReg(LANGID langid)
{
    CMyRegKey key;
    DWORD dwIndex;
    TCHAR szValue[MAX_PATH];

    //
    // This is just for Win9x Kor,CHT,CHS
    //
    if (IsOnNT())
        return NULL;

    if ((g_uACP != 936) && (g_uACP != 949) && (g_uACP != 950))
        return NULL;

    //
    // This is for HKL0411 only.
    //
    if (langid != 0x0411)
        return NULL;

    if (key.Open(HKEY_LOCAL_MACHINE, c_szKeyboardLayoutKey, KEY_READ) != S_OK)
        return NULL;

    dwIndex = 0;
    while (key.EnumKey(dwIndex, szValue, ARRAYSIZE(szValue)) == S_OK)
    {
        CMyRegKey keyHKL;
        TCHAR szName[13];

        if (keyHKL.Open(key, szValue, KEY_ALL_ACCESS) != S_OK)
            goto Next;

        if (keyHKL.QueryValueCch(szName, c_szIMEFile, ARRAYSIZE(szName)) != S_OK)
            goto Next;

        if (!lstrcmpi(szName, "hkl0411.dll"))
        {
            //
            // patch LayoutFile to kbdus.kbd and load the keyboard layout.
            //

            if (keyHKL.SetValue(c_szKbdUSName, c_szLayoutFile) != S_OK)
                return NULL;
            
            return LoadKeyboardLayout(szValue, KLF_NOTELLSHELL);
        }
Next:
        dwIndex++;
    }

    return NULL;
}

//+---------------------------------------------------------------------------
//
// GetProperHKL
//
//----------------------------------------------------------------------------

HKL CAssemblyList::GetProperHKL(LANGID langid, HKL *lphkl, BOOL *pfLoaded)
{
    char szhkl[16];
    HKL hkl = NULL;
    BOOL fFELang = IsFELangId(langid) ? TRUE : FALSE;

    if (pfLoaded)
        *pfLoaded = FALSE;

    if (lphkl)
    {
        while (*lphkl)
        {
            if (langid == (LANGID)((DWORD)(UINT_PTR)(*lphkl) & 0x0000ffff))
            {
                //
                // Under FE language, we have a specialcase.
                //
                if (fFELang)
                {
                    //
                    // Dummy HKL should be used.
                    //
                    if (IsIMEHKL(*lphkl))
                    {
                        if (IsFEDummyKL(*lphkl))
                        {
                            hkl = *lphkl;
                            break;
                        }
                        goto Next;
                    }
    
                    //
                    // We strongly want to use a primary hKL for FE.
                    //
                    if ((HIWORD((DWORD)(UINT_PTR)*lphkl) != langid))
                        goto Next;
                }
    
                hkl = *lphkl;
                break;
            }
Next:
            lphkl++;
        }
    }

    //
    // if we could find any, return.
    //
    if (hkl)
       return hkl;

    if (!IsOnNT() && IsOnFE() && IsFELangId(langid))
    {
        char szSys[MAX_PATH];
        char szDll[MAX_PATH];
        char szLayout[16];
        
        GetSystemDirectory(szSys, sizeof(szSys));
        StringCchPrintf(szDll, ARRAYSIZE(szDll),"%s\\hkl%04x.dll", szSys, langid);
        StringCchPrintf(szLayout, ARRAYSIZE(szLayout),"hkl%04x", langid);

        hkl = ImmInstallIME(szDll, szLayout);
        if (!hkl)
        {
            hkl = CheckKeyboardLayoutReg(langid);
            if (hkl)
            {
#if 0
                RemoveFEDummyHKLFromPreloadReg(hkl);
#endif
                goto Exit;
            }

            //
            // error to load Dummy hKL. 
            // we just use a primary English language.
            //
            StringCchPrintf(szhkl, ARRAYSIZE(szhkl),"%08x", 0x0409);
            hkl = LoadKeyboardLayout(szhkl, KLF_NOTELLSHELL);
        }
#if 0
        else
        {
            //
            // check the dummy HKL from Preload section of registry and remove
            // it since ImmInstallIME automatically add hkl to Preload section.
            //
            RemoveFEDummyHKLFromPreloadReg(hkl);
        }
#endif

        goto Exit;
    }

    StringCchPrintf(szhkl, ARRAYSIZE(szhkl),"%08x", langid);
    hkl = LoadKeyboardLayout(szhkl, KLF_NOTELLSHELL);

    //
    // if we fail to create a hKL for langid, check this registry entry.
    //
    // HKLM\SYSTEM\CurrentControlSet\Control\Keyboard Layouts\[langid]
    // 
    // without the key, it fails to create a default keyboard layout.
    //
    Assert(LOWORD(hkl) == langid);

    //
    // if hkl has NULL value and the current langid is FE, then we try to add
    // the default keyboard layout in the system.
    //
    if (IsFELangId(langid) && ((LOWORD(hkl) != langid) || IsPureIMEHKL(hkl)))
    {
        char szKey[256];
        CMyRegKey key;

        if (IsOn98orNT5())
            StringCopyArray(szKey, c_szLocaleInfo);
        else
            StringCopyArray(szKey, c_szLocaleInfoNT4);

        //
        // see if the user has Administrative privileges by checking for
        // write permission to the registry key(NLS path).
        //
        if (key.Open(HKEY_LOCAL_MACHINE, szKey, KEY_WRITE) != S_OK)
            goto Exit;
        else
        {
           StringCopyArray(szKey, c_szKeyboardLayoutKey);

           StringCchPrintf(szhkl, ARRAYSIZE(szhkl), "%08x", langid);
           StringCatArray(szKey, szhkl);

           //
           // create new keyboard layout registry key and value.
           //
           if (key.Create(HKEY_LOCAL_MACHINE, szKey) == S_OK)
           {
               char szKbdName[256];

               if (IsOnNT())
                   StringCopyArray(szKbdName, c_szKbdUSNameNT);
               else
                   StringCopyArray(szKbdName, c_szKbdUSName);

               if (key.SetValue(szKbdName, c_szLayoutFile) == S_OK)
               {
                   //
                   // now try to reload keyboard layout again.
                   //
                   hkl = LoadKeyboardLayout(szhkl, KLF_NOTELLSHELL);
               }
           }
        }
    }

Exit:
    if (hkl && pfLoaded)
        *pfLoaded = TRUE;

    return hkl;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\catmgr.cpp ===
//
// catmgr.cpp
//

#include "private.h"
#include "globals.h"
#include "regsvr.h"
#include "xstring.h"
#include "cregkey.h"
#include "catmgr.h"

CCatGUIDTbl *CCategoryMgr::_pCatGUIDTbl = NULL;

const TCHAR c_szCategoryKey[] = TEXT("Category\\");
const TCHAR c_szDescription[] = TEXT("Description");
const WCHAR c_wszDescription[] = L"Description";
const TCHAR c_szCategory[] = TEXT("Category\\"); // Category to item mapping
const TCHAR c_szItem[] = TEXT("Item\\");         // Item to category mapping
const TCHAR c_szGuid[] = TEXT("Guid%d"); 
const TCHAR c_szDword[] = TEXT("Dword"); 
const TCHAR c_szNULL[] = TEXT(""); 

DBG_ID_INSTANCE(CCategoryMgr);
DBG_ID_INSTANCE(CEnumCategories);

inline BOOL GetCatKey(REFCLSID rclsid, REFGUID rcatid, LPSTR pszKey, int cchKey, LPCSTR pszItem)
{
    int cchFinal;
    int cchTipKey;
    int cchCatKey;
    int cchItem;

    cchTipKey = lstrlen(c_szCTFTIPKey);
    cchCatKey = lstrlen(c_szCategoryKey);
    cchItem = lstrlen(pszItem);

    cchFinal = cchTipKey +
               CLSID_STRLEN +             // rclsid
               1 +                        // '\\'
               cchCatKey +
               cchItem +
               CLSID_STRLEN +
               1;                         // '\0'

    if (cchFinal > cchKey)
    {
        if (cchKey > 0)
        {
            pszKey[0] = '\0';
        }
        return FALSE;
    }

    StringCchCopy(pszKey, cchKey, c_szCTFTIPKey);
    CLSIDToStringA(rclsid, pszKey + cchTipKey);
    StringCchPrintf(pszKey + cchTipKey + CLSID_STRLEN, cchKey - cchTipKey - CLSID_STRLEN, "\\%s%s", c_szCategoryKey, pszItem);
    CLSIDToStringA(rcatid, pszKey + cchTipKey + CLSID_STRLEN + 1 + cchCatKey + cchItem);

    return TRUE;
}

//
// for inatlib.
//
HRESULT g_EnumItemsInCategory(REFGUID rcatid, IEnumGUID **ppEnum)
{
    return CCategoryMgr::s_EnumItemsInCategory(rcatid, ppEnum);
}



//////////////////////////////////////////////////////////////////////////////
//
// CCatGUIDTbl
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// add
//
//----------------------------------------------------------------------------

TfGuidAtom CCatGUIDTbl::Add(REFGUID rguid)
{
    UINT uId = _HashFunc(rguid);
    UINT iCnt;
  
    if (!_prgCatGUID[uId])
    {
        _prgCatGUID[uId] = new CStructArray<CATGUIDITEM>;
        if (!_prgCatGUID[uId])
            return TF_INVALID_GUIDATOM;
    }

    iCnt = _prgCatGUID[uId]->Count();
    if (!ValidGUIDARRAYCount(iCnt))
    {
         Assert(0);
         return TF_INVALID_GUIDATOM;
    }

    if (!_prgCatGUID[uId]->Insert(iCnt, 1))
    {
         return TF_INVALID_GUIDATOM;
    }

    CATGUIDITEM *pItem = _prgCatGUID[uId]->GetPtr(iCnt);

    pItem->guid = rguid;
    pItem->rgGuidAry[CAT_FORWARD] = NULL;
    pItem->rgGuidAry[CAT_BACKWARD] = NULL;

    return MAKEGUIDATOM(iCnt, uId);
}

//+---------------------------------------------------------------------------
//
// FindGuid
//
//----------------------------------------------------------------------------

TfGuidAtom CCatGUIDTbl::FindGuid(REFGUID rguid)
{
    UINT uId = _HashFunc(rguid);
    int nCnt;
    int i;

    if (!_prgCatGUID[uId])
        return TF_INVALID_GUIDATOM;

    nCnt = _prgCatGUID[uId]->Count();

    if (!ValidGUIDARRAYCount(nCnt))
    {
        Assert(0);
        return TF_INVALID_GUIDATOM;
    }

    for (i = 0; i < nCnt; i++)
    {
        CATGUIDITEM *pItem = _prgCatGUID[uId]->GetPtr(i);
        if (IsEqualGUID(pItem->guid, rguid))
        {
            return MAKEGUIDATOM(i, uId);
        }
    }
    return TF_INVALID_GUIDATOM;
}

//+---------------------------------------------------------------------------
//
// GetGuid
//
//----------------------------------------------------------------------------

CATGUIDITEM *CCatGUIDTbl::GetGUID(TfGuidAtom atom)
{
    UINT uId = HASHIDFROMGUIDATOM(atom);
    int nCnt = IDFROMGUIDATOM(atom);

    if (!ValidGUIDHash(uId))
        return NULL;

    if ((!_prgCatGUID[uId]) || (nCnt >= _prgCatGUID[uId]->Count()))
        return NULL;

    return _prgCatGUID[uId]->GetPtr(nCnt);
}

//////////////////////////////////////////////////////////////////////////////
//
// CCategoryMgr
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CCategoryMgr::CCategoryMgr()
{
    Dbg_MemSetThisNameIDCounter(TEXT("CCategoryMgr"), PERF_CATMGR_COUNTER);
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CCategoryMgr::~CCategoryMgr()
{
}

//+---------------------------------------------------------------------------
//
// InitGlobal
//
//----------------------------------------------------------------------------

BOOL CCategoryMgr::InitGlobal()
{
    if (!_pCatGUIDTbl)
        _pCatGUIDTbl = new CCatGUIDTbl;

    return _pCatGUIDTbl ? TRUE : FALSE;
}

//----------------------------------------------------------------------------
//
// RegisterCategory
//
//----------------------------------------------------------------------------

STDAPI CCategoryMgr::RegisterCategory(REFCLSID rclsid, REFGUID rcatid, REFGUID rguid)
{
    return s_RegisterCategory(rclsid, rcatid, rguid);
}

HRESULT CCategoryMgr::s_RegisterCategory(REFCLSID rclsid, REFGUID rcatid, REFGUID rguid)
{
    HRESULT hr;

    //
    // create forward link from category to guids.
    //
    if (FAILED(hr = _InternalRegisterCategory(rclsid, rcatid, rguid, CAT_FORWARD)))
        return hr;

    //
    // create backward link from guid to categories.
    //
    if (FAILED(hr = _InternalRegisterCategory(rclsid, rguid, rcatid, CAT_BACKWARD)))
    {
        _InternalUnregisterCategory(rclsid, rcatid, rguid, CAT_FORWARD);
        return hr;
    }

    return S_OK;
}

//----------------------------------------------------------------------------
//
// UnregisterCategory
//
//----------------------------------------------------------------------------

STDAPI CCategoryMgr::UnregisterCategory(REFCLSID rclsid, REFGUID rcatid, REFGUID rguid)
{
    return s_UnregisterCategory(rclsid, rcatid, rguid);
}

HRESULT CCategoryMgr::s_UnregisterCategory(REFCLSID rclsid, REFGUID rcatid, REFGUID rguid)
{
    HRESULT hr;

    //
    // remove forward link from category to guids.
    //
    if (FAILED(hr = _InternalUnregisterCategory(rclsid, rcatid, rguid, CAT_FORWARD)))
        return hr;

    //
    // remove backward link from guid to categories.
    //
    if (FAILED(hr = _InternalUnregisterCategory(rclsid, rguid, rcatid, CAT_BACKWARD)))
    {
        _InternalRegisterCategory(rclsid, rcatid, rguid, CAT_FORWARD);
        return hr;
    }

    return S_OK;
}

//----------------------------------------------------------------------------
//
// EnumCategoriesInItem
//
//----------------------------------------------------------------------------

STDAPI CCategoryMgr::EnumCategoriesInItem(REFGUID rguid, IEnumGUID **ppEnum)
{
    return _InternalEnumCategories(rguid, ppEnum, CAT_BACKWARD);
}

HRESULT CCategoryMgr::s_EnumCategoriesInItem(REFGUID rguid, IEnumGUID **ppEnum)
{
    return _InternalEnumCategories(rguid, ppEnum, CAT_BACKWARD);
}

//----------------------------------------------------------------------------
//
// EnumItemsinCategory
//
//----------------------------------------------------------------------------

STDAPI CCategoryMgr::EnumItemsInCategory(REFGUID rcatid, IEnumGUID **ppEnum)
{
    return _InternalEnumCategories(rcatid, ppEnum, CAT_FORWARD);
}

HRESULT CCategoryMgr::s_EnumItemsInCategory(REFGUID rcatid, IEnumGUID **ppEnum)
{
    return _InternalEnumCategories(rcatid, ppEnum, CAT_FORWARD);
}

//----------------------------------------------------------------------------
//
// FindClosestCategory
//
//----------------------------------------------------------------------------

HRESULT CCategoryMgr::FindClosestCategory(REFGUID rguid, GUID *pcatid, const GUID **ppcatidList, ULONG ulCount)
{
    return s_FindClosestCategory(rguid, pcatid, ppcatidList, ulCount);
}

HRESULT CCategoryMgr::s_FindClosestCategory(REFGUID rguid, GUID *pcatid, const GUID **ppcatidList, ULONG ulCount)
{
//    GUID catid = GUID_NULL;

    if (!pcatid)
        return E_INVALIDARG;
    
    if (!ppcatidList || !ulCount)
    {
        return _GetFirstCategory(rguid, pcatid);
    }

    for (ULONG ul = 0; ul < ulCount; ul++)
    {
        if (!ppcatidList[ul])
            return E_INVALIDARG;
    }

    return _InternalFindClosestCategory(rguid, 
                                        rguid, 
                                        pcatid, 
                                        ppcatidList, 
                                        ulCount);
}

//----------------------------------------------------------------------------
//
// _GetFirstCategory
//
//----------------------------------------------------------------------------

HRESULT CCategoryMgr::_GetFirstCategory(REFGUID rguid, GUID *pcatid)
{
    HRESULT hr;
    IEnumGUID *pEnum;

    if (SUCCEEDED(hr = _InternalEnumCategories(rguid, &pEnum, CAT_BACKWARD)))
    {
        // we return S_FALSE if we can not find it and return GUID_NULL.
        hr = pEnum->Next(1, pcatid, NULL);
        if (hr != S_OK)
            *pcatid = GUID_NULL;

        pEnum->Release();
    }
    return hr;
}

//----------------------------------------------------------------------------
//
// _InternalFindClosestCategory
//
//----------------------------------------------------------------------------

HRESULT CCategoryMgr::_InternalFindClosestCategory(REFGUID rguidOrg, REFGUID rguid, GUID *pcatid, const GUID **ppcatidList, ULONG ulCount)
{
    HRESULT hr;
    ULONG ul;
    IEnumGUID *pEnum = NULL;
    GUID catid = GUID_NULL;

    Assert(ppcatidList);
    Assert(ulCount);

    *pcatid = GUID_NULL;

    for (ul = 0; ul < ulCount; ul++)
    {
        if (IsEqualGUID(*ppcatidList[ul], rguid))
        {
            *pcatid = rguid;
            hr = S_OK;
            goto Exit;
        }
    }

    //
    // we don't return error. We return success and GUID_NULL.
    //
    hr = _InternalEnumCategories(rguid, &pEnum, CAT_BACKWARD);
    if (hr != S_OK)
    {
        hr = S_OK;
        goto Exit;
    }

    while (pEnum->Next(1, &catid, NULL) == S_OK)
    {
        if (IsEqualGUID(rguidOrg, catid))
        {
            // finally the original guid is categorized by itself.
            // it may cause infinte loop so bail it out.
            hr = S_OK;
            goto Exit;
        }

        _InternalFindClosestCategory(rguidOrg, 
                                     catid, 
                                     pcatid, 
                                     ppcatidList, 
                                     ulCount);

        if (!IsEqualGUID(*pcatid, GUID_NULL))
        {
            hr = S_OK;
            goto Exit;
        }
    }

Exit:
    SafeRelease(pEnum);
    return hr;
}


//----------------------------------------------------------------------------
//
// RegisterGUIDDesription
//
//----------------------------------------------------------------------------

STDAPI CCategoryMgr::RegisterGUIDDescription(REFCLSID rclsid, REFGUID rguid, const WCHAR *pchDesc, ULONG cch)
{
    if (!pchDesc && cch)
        return E_INVALIDARG;
 
    return s_RegisterGUIDDescription(rclsid, rguid, WCHtoWSZ(pchDesc, cch));
}

HRESULT CCategoryMgr::s_RegisterGUIDDescription(REFCLSID rclsid, REFGUID rguid, WCHAR *pszDesc)
{
    TCHAR szKey[256];
    CMyRegKey key;
    
    if (!GetCatKey(rclsid, rguid, szKey, ARRAYSIZE(szKey), c_szItem))
        return E_FAIL;

    if (key.Create(HKEY_LOCAL_MACHINE, szKey) != S_OK)
        return E_FAIL;

    key.SetValueW(pszDesc, c_wszDescription);

    return S_OK;
}

//----------------------------------------------------------------------------
//
// UnregisterGUIDDesription
//
//----------------------------------------------------------------------------

STDAPI CCategoryMgr::UnregisterGUIDDescription(REFCLSID rclsid, REFGUID rguid)
{
    return s_UnregisterGUIDDescription(rclsid, rguid);
}

HRESULT CCategoryMgr::s_UnregisterGUIDDescription(REFCLSID rclsid, REFGUID rguid)
{
    TCHAR szKey[256];
    CMyRegKey key;
    
    if (!GetCatKey(rclsid, rguid, szKey, ARRAYSIZE(szKey), c_szItem))
        return E_FAIL;

    if (key.Open(HKEY_LOCAL_MACHINE, szKey, KEY_ALL_ACCESS) != S_OK)
        return E_FAIL;

    key.DeleteValueW(c_wszDescription);

    return S_OK;
}

//----------------------------------------------------------------------------
//
// GetGUIDDescription
//
//----------------------------------------------------------------------------

STDAPI CCategoryMgr::GetGUIDDescription(REFGUID rguid, BSTR *pbstrDesc)
{
    return s_GetGUIDDescription(rguid, pbstrDesc);
}

HRESULT CCategoryMgr::s_GetGUIDDescription(REFGUID rguid, BSTR *pbstrDesc)
{
    return s_GetGUIDValue(rguid, c_szDescriptionW, pbstrDesc);
}

HRESULT CCategoryMgr::s_GetGUIDValue(REFGUID rguid, const WCHAR* pszValue, BSTR *pbstrDesc)
{
    WCHAR *psz = NULL;
    CMyRegKey keyImx;
    HRESULT hr = E_FAIL;
    int cch;
    TCHAR szSubKey[256]; // nb: we can merge szSubKey and szTemp if we switch to a UNICODE build
    WCHAR szTemp[256];

    if (!pbstrDesc)
        return E_INVALIDARG;

    *pbstrDesc = NULL;
    
    if (keyImx.Open(HKEY_LOCAL_MACHINE, c_szCTFTIPKey, KEY_READ) != S_OK)
        return hr;

    DWORD dwIndex = 0;

    while (keyImx.EnumKey(dwIndex++, szSubKey, ARRAYSIZE(szSubKey)) == S_OK)
    {
        CMyRegKey key;

        if (StringCchPrintf(szSubKey + lstrlen(szSubKey), ARRAYSIZE(szSubKey), "\\%s%s", c_szCategoryKey, c_szItem) != S_OK)
            continue;

        cch = lstrlen(szSubKey);

        if (cch + CLSID_STRLEN + 1 > ARRAYSIZE(szSubKey))
            continue;

        CLSIDToStringA(rguid, szSubKey + cch);

        if (key.Open(keyImx, szSubKey, KEY_READ) != S_OK)
            continue;

        if (key.QueryValueCchW(szTemp, pszValue, ARRAYSIZE(szTemp)) == S_OK)
        {
            *pbstrDesc = SysAllocString(szTemp);
            hr = *pbstrDesc != NULL ? S_OK : E_OUTOFMEMORY;
        }

        // this was the matching key, so no point in continue successful query or not
        break;
    }

    return hr;
}


//----------------------------------------------------------------------------
//
// RegisterGUIDDesription
//
//----------------------------------------------------------------------------

STDAPI CCategoryMgr::RegisterGUIDDWORD(REFCLSID rclsid, REFGUID rguid, DWORD dw)
{
    return s_RegisterGUIDDWORD(rclsid, rguid, dw);
}

HRESULT CCategoryMgr::s_RegisterGUIDDWORD(REFCLSID rclsid, REFGUID rguid, DWORD dw)
{ 
    TCHAR szKey[256];
    CMyRegKey key;
    
    if (!GetCatKey(rclsid, rguid, szKey, ARRAYSIZE(szKey), c_szItem))
        return E_FAIL;

    if (key.Create(HKEY_LOCAL_MACHINE, szKey) != S_OK)
        return E_FAIL;

    key.SetValue(dw, c_szDword);
    return S_OK;
}

//----------------------------------------------------------------------------
//
// UnregisterGUIDDesription
//
//----------------------------------------------------------------------------

STDAPI CCategoryMgr::UnregisterGUIDDWORD(REFCLSID rclsid, REFGUID rguid)
{
    return s_UnregisterGUIDDWORD(rclsid, rguid);
}

HRESULT CCategoryMgr::s_UnregisterGUIDDWORD(REFCLSID rclsid, REFGUID rguid)
{ 
    TCHAR szKey[256];
    CMyRegKey key;
    
    if (!GetCatKey(rclsid, rguid, szKey, ARRAYSIZE(szKey), c_szItem))
        return E_FAIL;

    if (key.Open(HKEY_LOCAL_MACHINE, szKey, KEY_ALL_ACCESS) != S_OK)
        return E_FAIL;

    key.DeleteValue(c_szDword);
    return S_OK;
}

//----------------------------------------------------------------------------
//
// GetGUIDDWORD
//
//----------------------------------------------------------------------------

STDAPI CCategoryMgr::GetGUIDDWORD(REFGUID rguid, DWORD *pdw)
{
    return s_GetGUIDDWORD(rguid, pdw);
}

HRESULT CCategoryMgr::s_GetGUIDDWORD(REFGUID rguid, DWORD *pdw)
{
    CMyRegKey keyImx;
    int cch;
    HRESULT hr = E_FAIL;

    if (!pdw)
        return E_INVALIDARG;

    *pdw = 0;
    
    if (keyImx.Open(HKEY_LOCAL_MACHINE, c_szCTFTIPKey, KEY_READ) != S_OK)
        return hr;

    DWORD dwIndex = 0;
    TCHAR szSubKey[256];
    while (keyImx.EnumKey(dwIndex++, szSubKey, ARRAYSIZE(szSubKey)) == S_OK)
    {
        CMyRegKey key;

        if (StringCchPrintf(szSubKey + lstrlen(szSubKey), ARRAYSIZE(szSubKey), "\\%s%s", c_szCategoryKey, c_szItem) != S_OK)
            continue;

        cch = lstrlen(szSubKey);

        if (cch + CLSID_STRLEN + 1 > ARRAYSIZE(szSubKey))
            continue;

        CLSIDToStringA(rguid, szSubKey + cch);

        if (key.Open(keyImx, szSubKey, KEY_READ) != S_OK)
            continue;

        if (key.QueryValue(*pdw, c_szDword) == S_OK)
        {
            hr = S_OK;
            break;
        }
    }

    return hr;
}

//----------------------------------------------------------------------------
//
// RegisterProvider
//
//----------------------------------------------------------------------------

STDAPI CCategoryMgr::RegisterGUID(REFGUID rguid, TfGuidAtom *pguidatom)
{
    return s_RegisterGUID(rguid, pguidatom);
}

HRESULT CCategoryMgr::s_RegisterGUID(REFGUID rguid, TfGuidAtom *pguidatom)
{
    TfGuidAtom guidatom;
    HRESULT hr = E_FAIL;

    CicEnterCriticalSection(g_cs);

    if (InitGlobal())
    {
        if ((guidatom = _pCatGUIDTbl->FindGuid(rguid)) != TF_INVALID_GUIDATOM)
        {
            *pguidatom = guidatom;
            hr =  S_OK;
        }
        else if ((guidatom = _pCatGUIDTbl->Add(rguid)) != TF_INVALID_GUIDATOM)
        {
            *pguidatom = guidatom;
            hr =  S_OK;
        }
    }

    CicLeaveCriticalSection(g_cs);

    return hr;
}

//----------------------------------------------------------------------------
//
// GetGUID
//
//----------------------------------------------------------------------------

STDAPI CCategoryMgr::GetGUID(TfGuidAtom guidatom, GUID *pguid)
{
    return s_GetGUID(guidatom, pguid);
}

HRESULT CCategoryMgr::s_GetGUID(TfGuidAtom guidatom, GUID *pguid)
{
    CATGUIDITEM *pItem;
    HRESULT hr = E_FAIL;

    if (!pguid)
        return E_INVALIDARG;

    CicEnterCriticalSection(g_cs);

    if (InitGlobal())
    {
        pItem = _pCatGUIDTbl->GetGUID(guidatom);
        if (!pItem)
        {
            *pguid = GUID_NULL;
            goto Exit;
        }

        *pguid = pItem->guid;
        hr = S_OK;
    }

Exit:
    CicLeaveCriticalSection(g_cs);
  
    return hr;
}

//----------------------------------------------------------------------------
//
// IsEqualTfGuidAtom
//
//----------------------------------------------------------------------------

STDAPI CCategoryMgr::IsEqualTfGuidAtom(TfGuidAtom guidatom, REFGUID rguid, BOOL *pfEqual)
{
    return s_IsEqualTfGuidAtom(guidatom, rguid, pfEqual);
}

HRESULT CCategoryMgr::s_IsEqualTfGuidAtom(TfGuidAtom guidatom, REFGUID rguid, BOOL *pfEqual)
{
    HRESULT hr = E_FAIL;
    CATGUIDITEM *pItem;

    if (pfEqual == NULL)
        return E_INVALIDARG;

    *pfEqual = FALSE;

    CicEnterCriticalSection(g_cs);

    if (InitGlobal())
    {
        if (pItem = _pCatGUIDTbl->GetGUID(guidatom))
        {
            *pfEqual = IsEqualGUID(pItem->guid, rguid);
            hr = S_OK;
        }
    }

    CicLeaveCriticalSection(g_cs);
    return hr;
}

//----------------------------------------------------------------------------
//
// InternalRegisterCategory
//
//----------------------------------------------------------------------------

HRESULT CCategoryMgr::_InternalRegisterCategory(REFCLSID rclsid, REFGUID rcatid, REFGUID rguid, CATDIRECTION catdir)
{
    TCHAR szKey[256];
    CONST TCHAR *pszForward = (catdir == CAT_FORWARD) ? c_szCategory : c_szItem;
    CMyRegKey key;
    CMyRegKey keySub;
    
    if (!GetCatKey(rclsid, rcatid, szKey, ARRAYSIZE(szKey), pszForward))
        return E_FAIL;

    if (key.Create(HKEY_LOCAL_MACHINE, szKey) != S_OK)
        return E_FAIL;

    //
    // we add this guid and save it.
    //
    char szValue[CLSID_STRLEN + 1];
    CLSIDToStringA(rguid, szValue);
    keySub.Create(key, szValue);
    _FlushGuidArrayCache(rguid, catdir);

    return S_OK;
}

//----------------------------------------------------------------------------
//
// UnregisterCategory
//
//----------------------------------------------------------------------------

HRESULT CCategoryMgr::_InternalUnregisterCategory(REFCLSID rclsid, REFGUID rcatid, REFGUID rguid, CATDIRECTION catdir)
{
    TCHAR szKey[256];
    CONST TCHAR *pszForward = (catdir == CAT_FORWARD) ? c_szCategory : c_szItem;
    CMyRegKey key;
    
    if (!GetCatKey(rclsid, rcatid, szKey, ARRAYSIZE(szKey), pszForward))
        return E_FAIL;

    if (key.Open(HKEY_LOCAL_MACHINE, szKey, KEY_ALL_ACCESS) != S_OK)
        return E_FAIL;

    DWORD dwIndex = 0;
    char szValue[CLSID_STRLEN + 1];

    CLSIDToStringA(rguid, szValue);
    key.RecurseDeleteKey(szValue);
    _FlushGuidArrayCache(rguid, catdir);

    return S_OK;
}

//----------------------------------------------------------------------------
//
// _FlushGuidArrayCache
//
//----------------------------------------------------------------------------

void CCategoryMgr::_FlushGuidArrayCache(REFGUID rguid, CATDIRECTION catdir)
{
    TfGuidAtom guidatom;
    CATGUIDITEM *pItem;

    CicEnterCriticalSection(g_cs);

    if (!_pCatGUIDTbl)
        goto Exit;

    guidatom = _pCatGUIDTbl->FindGuid(rguid);
    if (guidatom == TF_INVALID_GUIDATOM)
        goto Exit;

    pItem = _pCatGUIDTbl->GetGUID(guidatom);
    if (!pItem)
    {
        Assert(0);
        goto Exit;
    }

    SGA_Release(pItem->rgGuidAry[catdir]);
    pItem->rgGuidAry[catdir] = NULL;

Exit:
    CicLeaveCriticalSection(g_cs);
}

//----------------------------------------------------------------------------
//
// _InternalEnumCategories
//
//----------------------------------------------------------------------------

HRESULT CCategoryMgr::_InternalEnumCategories(REFGUID rguid, IEnumGUID **ppEnum, CATDIRECTION catdir)
{
    CEnumCategories *pEnum;

    if (!ppEnum)
        return E_INVALIDARG;

    pEnum = new CEnumCategories();

    if (!pEnum)
        return E_OUTOFMEMORY;

    if (pEnum->_Init(rguid, catdir))
        *ppEnum = pEnum;
    else
        SafeReleaseClear(pEnum);

    return pEnum ? S_OK : E_FAIL;
}

//////////////////////////////////////////////////////////////////////////////
//
// CEnumCategories
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CEnumCategories::CEnumCategories()
{
    Dbg_MemSetThisNameIDCounter(TEXT("CEnumCategories"), PERF_ENUMCAT_COUNTER);
}

//+---------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

BOOL CEnumCategories::_Init(REFGUID rcatid, CATDIRECTION catdir)
{
    int cch;
    int nCnt = 0;
    BOOL bRet = FALSE;
    CMyRegKey keyImx;
    TfGuidAtom guidatom;
    CATGUIDITEM *pItem;
    CONST TCHAR *pszForward = (catdir == CAT_FORWARD) ? c_szCategory : c_szItem;
    DWORD dwIndex = 0;
    TCHAR szSubKey[256];
    ULONG cGuidMax = 64;
    ULONG cGuidCurrent = 0;

    CicEnterCriticalSection(g_cs);

    if (!CCategoryMgr::InitGlobal())
        goto LeaveCrtSec;

    guidatom = CCategoryMgr::_pCatGUIDTbl->FindGuid(rcatid);
    if (guidatom == TF_INVALID_GUIDATOM)
    {
        guidatom = CCategoryMgr::_pCatGUIDTbl->Add(rcatid);

        if (guidatom == TF_INVALID_GUIDATOM)
            goto LeaveCrtSec;
    }

    pItem = CCategoryMgr::_pCatGUIDTbl->GetGUID(guidatom);
    Assert(pItem);

    if (_pga = pItem->rgGuidAry[catdir])
    {
        // already have this GUID cached, just reference it
        SGA_AddRef(_pga);

        bRet = TRUE;
        goto LeaveCrtSec;
    }

    _pga = SGA_Alloc(cGuidMax);
    if (!_pga)
        goto LeaveCrtSec;

    _pga->cRef = 1;

    if (keyImx.Open(HKEY_LOCAL_MACHINE, c_szCTFTIPKey, KEY_READ) != S_OK)
        goto LeaveCrtSec;

    while (keyImx.EnumKey(dwIndex++, szSubKey, ARRAYSIZE(szSubKey)) == S_OK)
    {
        CMyRegKey key;

        if (StringCchPrintf(szSubKey + lstrlen(szSubKey), ARRAYSIZE(szSubKey), "\\%s%s", c_szCategoryKey, pszForward) != S_OK)
            continue;

        cch = lstrlen(szSubKey);

        if (cch + CLSID_STRLEN + 1 > ARRAYSIZE(szSubKey))
            continue;

        CLSIDToStringA(rcatid, szSubKey + cch);

        if (key.Open(keyImx, szSubKey, KEY_READ) != S_OK)
            continue;

        DWORD dwSize = 0;
        DWORD dwIndex2 = 0;
        char szValueName[CLSID_STRLEN + 1];
        while (key.EnumKey(dwIndex2++, szValueName, ARRAYSIZE(szValueName)) == S_OK)
        {
            if (lstrlen(szValueName) == CLSID_STRLEN)
            {
                if (cGuidCurrent >= cGuidMax)
                {
                    cGuidMax += 64;
                    if (!SGA_ReAlloc(&_pga, cGuidMax))
                        goto LeaveCrtSec;
                }
                StringAToCLSID(szValueName, &_pga->rgGuid[cGuidCurrent]);
                cGuidCurrent++;
            }
        }
    }

    // free up unused memory
    if (!SGA_ReAlloc(&_pga, cGuidCurrent))
        goto LeaveCrtSec;

    bRet = TRUE;
    _pga->cGuid = cGuidCurrent;

    // put this array in the cache
    pItem->rgGuidAry[catdir] = _pga;
    SGA_AddRef(pItem->rgGuidAry[catdir]);

LeaveCrtSec:
    CicLeaveCriticalSection(g_cs);

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\catmgr.h ===
//
// catmgr.h
//

#ifndef CATMGR_H
#define CATMGR_H

#include "private.h"
#include "strary.h"
#include "enumguid.h"

//////////////////////////////////////////////////////////////////////////////
//
// CCatGUIDTbl
//
//////////////////////////////////////////////////////////////////////////////

#define CATGUID_HASHSIZE 31
#define ValidGUIDHash(hashid)       (hashid < CATGUID_HASHSIZE)
#define ValidGUIDARRAYCount(cnt)    (cnt < 0x07ffffff)
#define MAKEGUIDATOM(cnt, hashid)   (cnt * 32 | (hashid + 1))
#define HASHIDFROMGUIDATOM(atom)    ((atom & 0x1f) - 1)
#define IDFROMGUIDATOM(atom)        (atom / 32)

typedef enum { CAT_FORWARD  = 0x0,
               CAT_BACKWARD = 0x1
             } CATDIRECTION;

typedef struct tag_CATGUIDITEM {
    GUID guid;
    SHARED_GUID_ARRAY *rgGuidAry[2];
} CATGUIDITEM;

class CCatGUIDTbl
{
public:
    CCatGUIDTbl() {}
    ~CCatGUIDTbl() 
    { 
        for (int i = 0; i < CATGUID_HASHSIZE; i++)
        {
            if (_prgCatGUID[i])
            {
                int nCnt = _prgCatGUID[i]->Count();
                for (int j = 0; j < nCnt; j++)
                {
                    CATGUIDITEM *pItem = _prgCatGUID[i]->GetPtr(j);
                    SGA_Release(pItem->rgGuidAry[CAT_FORWARD]);
                    SGA_Release(pItem->rgGuidAry[CAT_BACKWARD]);
                }
                delete _prgCatGUID[i];
            }
        }
    }

    void FreeCatCache()
    { 
        for (int i = 0; i < CATGUID_HASHSIZE; i++)
        {
            if (_prgCatGUID[i])
            {
                int nCnt = _prgCatGUID[i]->Count();
                for (int j = 0; j < nCnt; j++)
                {
                    CATGUIDITEM *pItem = _prgCatGUID[i]->GetPtr(j);
                    SGA_Release(pItem->rgGuidAry[CAT_FORWARD]);
                    SGA_Release(pItem->rgGuidAry[CAT_BACKWARD]);
                    pItem->rgGuidAry[CAT_FORWARD] = NULL;
                    pItem->rgGuidAry[CAT_BACKWARD] = NULL;
                }
            }
        }
    }

    TfGuidAtom Add(REFGUID rguid);
    TfGuidAtom FindGuid(REFGUID rguid);
    CATGUIDITEM *GetGUID(TfGuidAtom atom);

private:
    UINT _HashFunc(REFGUID rguid) 
    { 
        return (DWORD)rguid.Data1 % CATGUID_HASHSIZE;
    }

    CStructArray<CATGUIDITEM> *_prgCatGUID[CATGUID_HASHSIZE];
};

//////////////////////////////////////////////////////////////////////////////
//
// CCategoryMgr
//
//////////////////////////////////////////////////////////////////////////////

// perf: this class doesn't really need CComObjectRootImmx, it is stateless

class CCategoryMgr : 
      public ITfCategoryMgr,
      public CComObjectRoot_CreateInstance<CCategoryMgr>
{
public:
    CCategoryMgr();
    ~CCategoryMgr();

    BEGIN_COM_MAP_IMMX(CCategoryMgr)
        COM_INTERFACE_ENTRY(ITfCategoryMgr)
    END_COM_MAP_IMMX()

    //
    // ITfCategoryMgr
    //
    STDMETHODIMP RegisterCategory(REFCLSID rclsid, REFGUID rcatid, REFGUID rguid);
    STDMETHODIMP UnregisterCategory(REFCLSID rclsid, REFGUID rcatid, REFGUID rguid);
    STDMETHODIMP EnumCategoriesInItem(REFGUID rguid, IEnumGUID **ppEnum);
    STDMETHODIMP EnumItemsInCategory(REFGUID rcatid, IEnumGUID **ppEnum);
    STDMETHODIMP FindClosestCategory(REFGUID rguid, GUID *pcatid, const GUID **ppcatidList, ULONG ulCount);
    STDMETHODIMP RegisterGUIDDescription(REFCLSID rclsid, REFGUID rguid, const WCHAR *pchDesc, ULONG cch);
    STDMETHODIMP UnregisterGUIDDescription(REFCLSID rclsid, REFGUID rguid);
    STDMETHODIMP GetGUIDDescription(REFGUID rguid, BSTR *pbstrDesc);
    STDMETHODIMP RegisterGUIDDWORD(REFCLSID rclsid, REFGUID rguid, DWORD dw);
    STDMETHODIMP UnregisterGUIDDWORD(REFCLSID rclsid, REFGUID rguid);
    STDMETHODIMP GetGUIDDWORD(REFGUID rguid, DWORD *pdw);
    STDMETHODIMP RegisterGUID(REFGUID rguid, TfGuidAtom *pguidatom);
    STDMETHODIMP GetGUID(TfGuidAtom guidatom, GUID *pguid);
    STDMETHODIMP IsEqualTfGuidAtom(TfGuidAtom guidatom, REFGUID rguid, BOOL *pfEqual);

    static BOOL InitGlobal();
    static BOOL s_IsValidGUIDATOM(TfGuidAtom guidatom)
    {
        if (!_pCatGUIDTbl)
            return FALSE;

        return _pCatGUIDTbl->GetGUID(guidatom) ? TRUE : FALSE;
    }

    static void UninitGlobal()
    {
        if (_pCatGUIDTbl)
            delete _pCatGUIDTbl;
        _pCatGUIDTbl = NULL;
    }

    static void FreeCatCache()
    {
        CicEnterCriticalSection(g_cs);

        if (_pCatGUIDTbl)
            _pCatGUIDTbl->FreeCatCache();

        CicLeaveCriticalSection(g_cs);
    }

    static HRESULT s_RegisterCategory(REFCLSID rclsid, REFGUID rcatid, REFGUID rguid);
    static HRESULT s_UnregisterCategory(REFCLSID rclsid, REFGUID rcatid, REFGUID rguid);
    static HRESULT s_EnumCategoriesInItem(REFGUID rguid, IEnumGUID **ppEnum);
    static HRESULT s_EnumItemsInCategory(REFGUID rcatid, IEnumGUID **ppEnum);
    static HRESULT s_RegisterGUID(REFGUID rguid, TfGuidAtom *pguidatom);
    static HRESULT s_GetGUID(TfGuidAtom guidatom, GUID *pguid);
    static HRESULT s_IsEqualTfGuidAtom(TfGuidAtom guidatom, REFGUID rguid, BOOL *pfEqual);
    static HRESULT s_FindClosestCategory(REFGUID rguid, GUID *pcatid, const GUID **ppcatidList, ULONG ulCount);

    static HRESULT s_RegisterGUIDDescription(REFCLSID rclsid, REFGUID rguid, WCHAR *pszDesc);
    static HRESULT s_UnregisterGUIDDescription(REFCLSID rclsid, REFGUID rguid);
    static HRESULT s_GetGUIDDescription(REFGUID rguid, BSTR *pbstrDesc);
    static HRESULT s_GetGUIDValue(REFGUID rguid, const WCHAR* pszValue, BSTR *pbstrDesc);
    static HRESULT s_RegisterGUIDDWORD(REFCLSID rclsid, REFGUID rguid, DWORD dw);
    static HRESULT s_UnregisterGUIDDWORD(REFCLSID rclsid, REFGUID rguid);
    static HRESULT s_GetGUIDDWORD(REFGUID rguid, DWORD *pdw);

    static CCatGUIDTbl *_pCatGUIDTbl;
private:

    static HRESULT _InternalRegisterCategory(REFCLSID rclsid, REFGUID rcatid, REFGUID rguid, CATDIRECTION catdir);
    static HRESULT _InternalUnregisterCategory(REFCLSID rclsid, REFGUID rcatid, REFGUID rguid, CATDIRECTION catdir);
    static HRESULT _InternalEnumCategories(REFGUID rguid, IEnumGUID **ppEnum, CATDIRECTION catdir);

    static HRESULT _InternalFindClosestCategory(REFGUID rguidOrg, REFGUID rguid, GUID *pcatid, const GUID **ppcatidList, ULONG ulCount);
    static HRESULT _GetFirstCategory(REFGUID rguid, GUID *pcatid);

    static void _FlushGuidArrayCache(REFGUID rguid, CATDIRECTION catdir);

    DBG_ID_DECLARE;
};


//////////////////////////////////////////////////////////////////////////////
//
// CEnumCategories
//
//////////////////////////////////////////////////////////////////////////////

class CEnumCategories : public CEnumGuid
{
public:
    CEnumCategories();
    BOOL _Init(REFGUID rcatid, CATDIRECTION catdir);
    DBG_ID_DECLARE;
};


#endif // CATMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\crtfree.cpp ===
#include "private.h"

#define CPP_FUNCTIONS
#include "icrtfree.h" // Code to help free modules from the bondage and tyranny of CRT libraries
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\compart.cpp ===
//
// compart.cpp
//


#include "private.h"
#include "globals.h"
#include "regsvr.h"
#include "compart.h"
#include "helpers.h"
#include "thdutil.h"
#include "tim.h"
#include "cicmutex.h"
#include "timlist.h"
#include "cregkey.h"

/* e575186e-71a8-4ef4-90da-14ed705e7df2 */
extern const IID IID_PRIV_CCOMPARTMENTMGR = {
    0xe575186e,
    0x71a8,
    0x4ef4,
    {0x90, 0xda, 0x14, 0xed, 0x70, 0x5e, 0x7d, 0xf2}
  };

/* 8b05c1ad-adf0-4a78-a3e2-d38cae3e28be */
extern const IID IID_PRIV_CGLOBALCOMPARTMENT = {
    0x8b05c1ad,
    0xadf0,
    0x4a78,
    {0xa3, 0xe2, 0xd3, 0x8c, 0xae, 0x3e, 0x28, 0xbe}
  };


DBG_ID_INSTANCE(CCompartment);
DBG_ID_INSTANCE(CCompartmentMgr);
DBG_ID_INSTANCE(CEnumCompartment);
DBG_ID_INSTANCE(CGlobalCompartment);

extern CCicMutex g_mutexCompart;

//+---------------------------------------------------------------------------
//
// EnsureGlobalCompartment
//
//----------------------------------------------------------------------------

BOOL EnsureGlobalCompartment(SYSTHREAD *psfn)
{
    if (psfn->_pGlobalCompMgr)
        return TRUE;

    psfn->_pGlobalCompMgr = new CGlobalCompartmentMgr(g_gaApp);

    if (psfn->_pGlobalCompMgr)
    {
        if (g_gcomplist.Init(psfn))
            return TRUE;

        delete psfn->_pGlobalCompMgr;
        psfn->_pGlobalCompMgr = NULL;
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  GetCompartmentDWORD
//
//----------------------------------------------------------------------------

HRESULT MyGetCompartmentDWORD(CCompartmentMgr *pCompMgr, REFGUID rguid, DWORD *pdw)
{
    HRESULT hr;
    ITfCompartment *pComp;
    VARIANT var;

    if (!pCompMgr)
        return E_FAIL;

    *pdw = 0;
    if (SUCCEEDED(hr = pCompMgr->GetCompartment(rguid, &pComp)))
    {
        hr = pComp->GetValue(&var);
        if (hr == S_OK)
        {
            Assert(var.vt == VT_I4);
            *pdw = var.lVal;
            // no need to VariantClear because VT_I4
        }
        
        pComp->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  SetCompartmentDWORD
//
//----------------------------------------------------------------------------

HRESULT MySetCompartmentDWORD(TfClientId tid, CCompartmentMgr *pCompMgr, REFGUID rguid, DWORD dw)
{
    HRESULT hr;
    ITfCompartment *pComp;
    VARIANT var;

    if (!pCompMgr)
        return E_FAIL;

    if (SUCCEEDED(hr = pCompMgr->GetCompartment(rguid, &pComp)))
    {
        var.vt = VT_I4;
        var.lVal = dw;
        hr = pComp->SetValue(tid, &var);
        pComp->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  ToggleCompartmentDWORD
//
//  Toggle DWORD value between 0 and 1.
//
//----------------------------------------------------------------------------

HRESULT MyToggleCompartmentDWORD(TfClientId tid, CCompartmentMgr *pCompMgr, REFGUID rguid, DWORD *pdwOld)
{
    ITfCompartment *pComp;
    VARIANT var;
    DWORD dw = 0;
    HRESULT hr = E_FAIL;

    if (!pCompMgr)
        return E_FAIL;

    if (pCompMgr->GetCompartment(rguid, &pComp) == S_OK)
    {
        if (SUCCEEDED(pComp->GetValue(&var)))
        {
            if (var.vt == VT_EMPTY)
            {
                // compartment is uninitialized
                var.vt = VT_I4;
                var.lVal = 0;
            }
            else
            {
                Assert(var.vt == VT_I4);
            }

            var.lVal = (var.lVal == 0) ? 1 : 0;
            // no need to VariantClear because VT_I4

            if ((hr = pComp->SetValue(tid, &var)) == S_OK)
            {
                dw = var.lVal;
            }
        }

        pComp->Release();
    }

    if (pdwOld)
        *pdwOld = dw;

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CCompartmentMgr
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CCompartmentMgr::CCompartmentMgr(TfClientId tidOwner, COMPTYPE cType)
{
    Dbg_MemSetThisNameIDCounter(TEXT("CCompartmentMgr"), PERF_COMPARTMGR_COUNTER);

    _tidOwner = tidOwner;
    _cType = cType;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CCompartmentMgr::~CCompartmentMgr()
{
    CleanUp();
}

//+---------------------------------------------------------------------------
//
// CleanUp
//
//----------------------------------------------------------------------------

void CCompartmentMgr::CleanUp()
{
    int nCnt = _rgCompartment.Count();
    int i;

    for (i = 0; i < nCnt; i++)
    {
        CCompartmentBase *pComp = _rgCompartment.Get(i);
        pComp->Invalid();
        pComp->Release();
    }
    _rgCompartment.Clear();
}

//+---------------------------------------------------------------------------
//
// GetCompartment
//
//----------------------------------------------------------------------------

STDAPI CCompartmentMgr::GetCompartment(REFGUID rguid, ITfCompartment **ppcomp)
{
    CCompartmentBase *pComp;

    if (!ppcomp)
        return E_INVALIDARG;

    *ppcomp = NULL;

    pComp = _Get(rguid);
    if (!pComp)
        return E_OUTOFMEMORY;

    *ppcomp = pComp;
    pComp->AddRef();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// ClearCompartment
//
//----------------------------------------------------------------------------

STDAPI CCompartmentMgr::ClearCompartment(TfClientId tid, REFGUID rguid)
{
    TfGuidAtom guidatom;
    CCompartmentBase *pComp;
    int iInsert;
    HRESULT hr;

    if (FAILED(hr = MyRegisterGUID(rguid, &guidatom)))
        return hr;

    pComp = _Find(guidatom, &iInsert);

    if (!pComp)
        return CONNECT_E_NOCONNECTION;

    if (pComp->_GetAccess() & CA_ONLYOWNERSET)
    {
        if (_tidOwner != tid)
            return E_UNEXPECTED;
    }

    _rgCompartment.Remove(iInsert, 1);
    pComp->Invalid();
    pComp->Release();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// EnumCompartment
//
//----------------------------------------------------------------------------

STDAPI CCompartmentMgr::EnumCompartments(IEnumGUID **ppEnum)
{
    CEnumCompartment *pEnum;

    if (!ppEnum)
        return E_INVALIDARG;

    pEnum = new CEnumCompartment();

    if (!pEnum)
        return E_OUTOFMEMORY;

    if (pEnum->_Init(&_rgCompartment))
        *ppEnum = pEnum;
    else
        SafeReleaseClear(pEnum);

    return pEnum ? S_OK : E_FAIL;
}

//+---------------------------------------------------------------------------
//
// _Find
//
//----------------------------------------------------------------------------

CCompartmentBase *CCompartmentMgr::_Find(TfGuidAtom guidatom, int *piOut)
{
    CCompartmentBase *pComp;
    CCompartmentBase *pCompMatch;
    int iMin;
    int iMax;
    int iMid;

    pCompMatch = NULL;
    iMid = -1;
    iMin = 0;
    iMax = _rgCompartment.Count();

    while (iMin < iMax)
    {
        iMid = (iMin + iMax) / 2;
        pComp = _rgCompartment.Get(iMid);
        Assert(pComp != NULL);

        if (guidatom < pComp->GetGuidAtom())
        {
            iMax = iMid;
        }
        else if (guidatom > pComp->GetGuidAtom())
        {
            iMin = iMid + 1;
        }
        else // guidatom == pComp->GetGuidAtom().
        {
            pCompMatch = pComp;
            break;
        }
    }

    if (!pCompMatch)
    {
        if (iMid >= 0)
        {
            CCompartmentBase *pCompTmp = _rgCompartment.Get(iMid);
            if (pCompTmp->GetGuidAtom() < guidatom)
            {
                iMid++;
            }
        }
    }

    if (piOut)
        *piOut = iMid;

    return pCompMatch;
}

//+---------------------------------------------------------------------------
//
// _Get
//
//----------------------------------------------------------------------------

CCompartmentBase *CCompartmentMgr::_Get(REFGUID rguid)
{
    CCompartmentBase *pComp;
    int iInsert;
    TfGuidAtom guidatom;

    if (FAILED(MyRegisterGUID(rguid, &guidatom)))
        return NULL;

    pComp = _Find(guidatom, &iInsert);

    if (!pComp)
    {
        TfPropertyType proptype = TF_PT_NONE;

        //
        // system predefined compartments does not allow any other type.
        //
        if ((IsEqualGUID(rguid, GUID_COMPARTMENT_KEYBOARD_DISABLED)) ||
            (IsEqualGUID(rguid, GUID_COMPARTMENT_HANDWRITING_OPENCLOSE)) ||
            (IsEqualGUID(rguid, GUID_COMPARTMENT_SPEECH_OPENCLOSE)))
        {
            proptype = TF_PT_DWORD;
        }

        if (_cType == COMPTYPE_GLOBAL)
            pComp = new CGlobalCompartment(this, rguid, guidatom, proptype);
        else
            pComp = new CCompartment(this, guidatom, proptype);
       
        if (pComp)
        {
            if (iInsert < 0)
                iInsert = 0;

            if (_rgCompartment.Insert(iInsert, 1))
            {
               _rgCompartment.Set(iInsert, pComp);
            }
            else
            {
                delete pComp;
                pComp = NULL;
            }
        }
    }

    return pComp;
}

//+---------------------------------------------------------------------------
//
// NotifyGlobalCompartmentChange
//
//----------------------------------------------------------------------------

void CCompartmentMgr::NotifyGlobalCompartmentChange(DWORD dwId)
{
    Assert(_cType == COMPTYPE_GLOBAL);

    int nCnt = _rgCompartment.Count();

    for (int i = 0; i < nCnt; i++)
    {
        CCompartmentBase *pComp = _rgCompartment.Get(i);
        if (dwId == pComp->GetId())
        {
            pComp->MakeNotify();
            break;
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// CGlobalCompartmenMgr
//
//////////////////////////////////////////////////////////////////////////////

STDAPI CGlobalCompartmentMgr::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfCompartmentMgr))
    {
        *ppvObj = SAFECAST(this, ITfCompartmentMgr *);
    }

    if (*ppvObj)
    {
        return S_OK;
    }

    return E_NOINTERFACE;
    
}

ULONG CGlobalCompartmentMgr::AddRef(void)
{
    _cRef++;
    return _cRef;
}

ULONG CGlobalCompartmentMgr::Release(void)
{
    _cRef--;
    if (_cRef <= 0)
    {
        //
        // Calller may call Release() more than AddRef()..
        // We should not call TIM::Release() at this time.
        //
        Assert(0)

        return 0;
    }

    return _cRef;
}

//////////////////////////////////////////////////////////////////////////////
//
// CEnumCompartment
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CEnumCompartment::CEnumCompartment()
{
    Dbg_MemSetThisNameIDCounter(TEXT("CEnumCompartment"), PERF_ENUMCOMPART_COUNTER);
}

//+---------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

BOOL CEnumCompartment::_Init(CPtrArray<CCompartmentBase> *prgComp)
{
    int nCnt = prgComp->Count();
    int i;
    BOOL fRet = FALSE;

    CicEnterCriticalSection(g_cs);

    _pga = SGA_Init(nCnt, NULL);

    if (_pga == NULL)
        goto Exit;

    for (i = 0; i < nCnt; i++)
    {
        CCompartmentBase *pComp = prgComp->Get(i);

        if (FAILED((MyGetGUID(pComp->GetGuidAtom(), &_pga->rgGuid[i]))))
            goto Exit;
    }

    fRet = TRUE;

Exit:
    CicLeaveCriticalSection(g_cs);
    return fRet;
}

//////////////////////////////////////////////////////////////////////////////
//
// CCompartmentBase
//
//////////////////////////////////////////////////////////////////////////////

const COMPARTMENTACCESS CCompartmentBase::_c_ca[] = {
    {&GUID_COMPARTMENT_KEYBOARD_DISABLED,    CA_ONLYOWNERSET},
    {NULL, 0}
};
CCompartmentBase::CCompartmentBase(CCompartmentMgr *pCompMgr, TfGuidAtom guidatom, TfPropertyType proptype)
{
    Assert(!_fInvalid);

    _guidatom = guidatom;
    _proptype = proptype;
    _pCompMgr = pCompMgr;

    int n = 0;
    while (_c_ca[n].pguid)
    {
        if (MyIsEqualTfGuidAtom(guidatom,  *_c_ca[n].pguid))
        {
            _dwAccess =  _c_ca[n].dwAccess;
        }
        n++;
    }
}


//////////////////////////////////////////////////////////////////////////////
//
// CCompartment
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CCompartment::CCompartment(CCompartmentMgr *pCompMgr, TfGuidAtom guidatom, TfPropertyType proptype)
             :CCompartmentBase(pCompMgr, guidatom, proptype)
{
    Dbg_MemSetThisNameIDCounter(TEXT("CCompartment"), PERF_COMPART_COUNTER);
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CCompartment::~CCompartment()
{
    if (_prop.type == TF_PT_UNKNOWN)
    {
        //
        // #489905
        //
        // we can not call sink anymore after DLL_PROCESS_DETACH.
        //
        if (!DllShutdownInProgress())
            _prop.punk->Release();
    }
    else if (_prop.type == TF_PT_BSTR)
        SysFreeString(_prop.bstr);
}

//+---------------------------------------------------------------------------
//
// Advise
//
//----------------------------------------------------------------------------

HRESULT CCompartment::AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie)
{
    const IID *rgiid;

    rgiid = &IID_ITfCompartmentEventSink;

    return GenericAdviseSink(riid, 
                             punk, 
                             &rgiid, 
                             &_rgCompartmentSink, 
                             1, 
                             pdwCookie);
}

//+---------------------------------------------------------------------------
//
// Unadvise
//
//----------------------------------------------------------------------------

HRESULT CCompartment::UnadviseSink(DWORD dwCookie)
{
    return GenericUnadviseSink(&_rgCompartmentSink, 1, dwCookie);
}

//+---------------------------------------------------------------------------
//
// GetValue
//
//----------------------------------------------------------------------------

HRESULT CCompartment::GetValue(VARIANT *pvarValue)
{
    HRESULT hr;

    if (_fInvalid)
    {
        Assert(0);
        return E_UNEXPECTED;
    }

    if (pvarValue == NULL)
        return E_INVALIDARG;

    QuickVariantInit(pvarValue);

    hr = TfPropToVariant(pvarValue, &_prop, ADDREF);

    if (hr != S_OK)
        return hr;

    return (pvarValue->vt == VT_EMPTY) ? S_FALSE : S_OK;
}

//+---------------------------------------------------------------------------
//
// SetValue
//
//----------------------------------------------------------------------------

HRESULT CCompartment::SetValue(TfClientId tid, const VARIANT *pvarValue)
{
    HRESULT hr;

    if (_fInvalid)
    {
        Assert(0);
        return E_UNEXPECTED;
    }

    if (_fInSet)
        return E_UNEXPECTED;

    if (pvarValue == NULL)
        return E_INVALIDARG;

    if (!IsValidCiceroVarType(pvarValue->vt))
        return E_INVALIDARG;

    if (pvarValue->vt == VT_EMPTY)
        return E_INVALIDARG;

    if (_GetAccess() & CA_ONLYOWNERSET)
    {
        if (_GetMgr()->_GetTIPOwner() != tid)
            return E_UNEXPECTED;
    }

    hr = VariantToTfProp(&_prop, pvarValue, ADDREF, FALSE);

    if (hr != S_OK)
        return hr;

    int i;
    int nCnt = _rgCompartmentSink.Count(); 
    if (nCnt)
    {
        GUID guid;
        if (FAILED(MyGetGUID(_guidatom, &guid)))
        {
            return E_FAIL;
            Assert(0);
        }

        _fInSet = TRUE;
        for (i = 0; i < nCnt; i++)
        {
            ((ITfCompartmentEventSink *)_rgCompartmentSink.GetPtr(i)->pSink)->OnChange(guid);
        }
        _fInSet = FALSE;
    }

    return S_OK;     
}

//////////////////////////////////////////////////////////////////////////////
//
// CGlobalCompartment
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CGlobalCompartment::CGlobalCompartment(CCompartmentMgr *pCompMgr, REFGUID rguid, TfGuidAtom guidatom, TfPropertyType proptype)
                   :CCompartmentBase(pCompMgr, guidatom, proptype)
{
    Dbg_MemSetThisNameIDCounter(TEXT("CGlobalCompartment"), PERF_GLOBCOMPART_COUNTER);
    _dwId = (DWORD)(-1);
    _guidCompart = rguid;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CGlobalCompartment::~CGlobalCompartment()
{
}

//+---------------------------------------------------------------------------
//
// Advise
//
//----------------------------------------------------------------------------

HRESULT CGlobalCompartment::AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie)
{
    const IID *rgiid;

    if (_dwId == (DWORD)(-1))
    {
        _dwId = g_gcomplist.GetId(_guidCompart);
        if (_dwId == (DWORD)(-1))
        {
            TFPROPERTY prop;
            memset(&prop, 0, sizeof(prop));
            _dwId = g_gcomplist.SetProperty(_guidCompart, &prop);
            if (_dwId == (DWORD)(-1))
                return E_FAIL;
        }
    }

    rgiid = &IID_ITfCompartmentEventSink;

    return GenericAdviseSink(riid, 
                             punk, 
                             &rgiid, 
                             &_rgCompartmentSink, 
                             1, 
                             pdwCookie);
}

//+---------------------------------------------------------------------------
//
// Unadvise
//
//----------------------------------------------------------------------------

HRESULT CGlobalCompartment::UnadviseSink(DWORD dwCookie)
{
    return GenericUnadviseSink(&_rgCompartmentSink, 1, dwCookie);
}

//+---------------------------------------------------------------------------
//
// GetValue
//
//----------------------------------------------------------------------------

HRESULT CGlobalCompartment::GetValue(VARIANT *pvarValue)
{
    HRESULT hr;
    TFPROPERTY prop;

    if (_fInvalid)
    {
        Assert(0);
        return E_UNEXPECTED;
    }

    if (pvarValue == NULL)
        return E_INVALIDARG;

    QuickVariantInit(pvarValue);

    if (_dwId == (DWORD)(-1))
    {
        _dwId = g_gcomplist.GetId(_guidCompart);
    }

    memset(&prop, 0, sizeof(TFPROPERTY));
    if (_dwId != (DWORD)(-1))
        g_gcomplist.GetProperty(_guidCompart, &prop);
       

    Assert(prop.type != TF_PT_UNKNOWN);

    hr = TfPropToVariant(pvarValue, &prop, ADDREF);

    if (hr != S_OK)
        return hr;

    return (pvarValue->vt == VT_EMPTY) ? S_FALSE : S_OK;
}

//+---------------------------------------------------------------------------
//
// SetValue
//
//----------------------------------------------------------------------------

HRESULT CGlobalCompartment::SetValue(TfClientId tid, const VARIANT *pvarValue)
{
    HRESULT hr;
    TFPROPERTY prop;

    if (_fInvalid)
    {
        Assert(0);
        return E_UNEXPECTED;
    }

    if (_fInSet)
        return E_UNEXPECTED;

    if (pvarValue == NULL)
        return E_INVALIDARG;

    if (!IsValidCiceroVarType(pvarValue->vt))
        return E_INVALIDARG;

    if (_GetAccess() & CA_ONLYOWNERSET)
    {
        if (_GetMgr()->_GetTIPOwner() != tid)
            return E_UNEXPECTED;
    }

    if (pvarValue->vt == VT_UNKNOWN)
    {
        Assert(0);
        return E_INVALIDARG;
    }

    hr = VariantToTfProp(&prop, pvarValue, NO_ADDREF, FALSE);

    if (hr != S_OK)
        return hr;

    _dwId = g_gcomplist.SetProperty(_guidCompart, &prop);
    if (_dwId == (DWORD)(-1))
        return E_FAIL;

    hr = (prop.type != TF_PT_NONE) ? S_OK : E_FAIL;

    if (SUCCEEDED(hr))
    {
        //
        // make a notify to the sinks of the current thread.
        //
        if (!MakeNotify())
            return E_FAIL;
        PostTimListMessage(TLF_GCOMPACTIVE,
                           0, 
                           g_msgPrivate, 
                           TFPRIV_GLOBALCOMPARTMENTSYNC,
                           _dwId);

    }

    return hr;     
}

//+---------------------------------------------------------------------------
//
// EnumThreadProc
//
//----------------------------------------------------------------------------

BOOL CGlobalCompartment::EnumThreadProc(DWORD dwThreadId, DWORD dwProcessId, void *pv)
{
    if (dwThreadId != GetCurrentThreadId())
    {
        CGlobalCompartment *_this = (CGlobalCompartment *)pv;

        PostThreadMessage(dwThreadId, 
                          g_msgPrivate, 
                          TFPRIV_GLOBALCOMPARTMENTSYNC,
                          _this->_dwId);
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
// MakeNotify
//
//----------------------------------------------------------------------------

BOOL CGlobalCompartment::MakeNotify()
{
    int i;
    int nCnt = _rgCompartmentSink.Count(); 
    if (nCnt)
    {
        GUID guid;
        if (FAILED(MyGetGUID(_guidatom, &guid)))
        {
            Assert(0);
            return FALSE;
        }

        _fInSet = TRUE;
        for (i = 0; i < nCnt; i++)
        {
            ((ITfCompartmentEventSink *)_rgCompartmentSink.GetPtr(i)->pSink)->OnChange(guid);
        }
        _fInSet = FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\compart.h ===
//
// compart.h
//

#ifndef COMPART_H
#define COMPART_H

#include "globals.h"
#include "sink.h"
#include "enumguid.h"
#include "ptrary.h"
#include "strary.h"
#include "tfprop.h"
#include "memcache.h"
#include "gcompart.h"

extern const IID IID_PRIV_CCOMPARTMENTMGR;
extern const IID IID_PRIV_CGLOBALCOMPARTMENT;

class CThreadInputMgr;
class CCompartmentMgr;
class CCompartmentMgrOwner;
class CCompartmentBase;

typedef enum {
      COMPTYPE_GLOBAL = 0,
      COMPTYPE_TIM    = 1,
      COMPTYPE_DIM    = 2,
      COMPTYPE_IC     = 3,
} COMPTYPE;

typedef struct tag_COMPARTMENTACCESS {
    const GUID *pguid;
    DWORD dwAccess;
} COMPARTMENTACCESS;

#define CA_ONLYOWNERSET     0x0001

//////////////////////////////////////////////////////////////////////////////
//
// Helpers
//
//////////////////////////////////////////////////////////////////////////////

inline CCompartmentMgr *GetCCompartmentMgr(IUnknown *punk)
{
    CCompartmentMgr *compmgr;

    punk->QueryInterface(IID_PRIV_CCOMPARTMENTMGR, (void **)&compmgr);

    return compmgr;
}

BOOL EnsureGlobalCompartment(SYSTHREAD *psfn);
HRESULT MyToggleCompartmentDWORD(TfClientId tid, CCompartmentMgr *pCompMgr, REFGUID rguid, DWORD *pdwOld);
HRESULT MyGetCompartmentDWORD(CCompartmentMgr *pCompMgr, REFGUID rguid, DWORD *pdw);
HRESULT MySetCompartmentDWORD(TfClientId tid, CCompartmentMgr *pCompMgr, REFGUID rguid, DWORD dw);

//////////////////////////////////////////////////////////////////////////////
//
// CEnumCompartment
//
//////////////////////////////////////////////////////////////////////////////

class CEnumCompartment : public CEnumGuid
{
public:
    CEnumCompartment();
    BOOL _Init(CPtrArray<CCompartmentBase> *prgComp);
    DBG_ID_DECLARE;
};


//////////////////////////////////////////////////////////////////////////////
//
// CCompartmentBase
//
//////////////////////////////////////////////////////////////////////////////

class __declspec(novtable) CCompartmentBase : public ITfCompartment,
                                              public ITfSource
{
public:
    CCompartmentBase(CCompartmentMgr *pCompMgr, TfGuidAtom guidatom, TfPropertyType proptype);
    virtual ~CCompartmentBase() {}

    //
    // IUnknown methods
    //
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj) = 0;
    virtual STDMETHODIMP_(ULONG) AddRef(void) = 0;
    virtual STDMETHODIMP_(ULONG) Release(void) = 0;

    //
    // ITfCompartment
    //
    virtual STDMETHODIMP SetValue(TfClientId tid, const VARIANT *pvarValue) = 0;
    virtual STDMETHODIMP GetValue(VARIANT *pvarValue) = 0;

    //
    // ITfSource
    //
    virtual STDMETHODIMP AdviseSink(REFIID refiid, IUnknown *punk, DWORD *pdwCookie) = 0;
    virtual STDMETHODIMP UnadviseSink(DWORD dwCookie) = 0;

    TfGuidAtom GetGuidAtom() {return _guidatom;}
    TfPropertyType GetpropType() {return _proptype;}

    virtual DWORD GetId() {Assert(0); return 0;}
    virtual BOOL MakeNotify() {Assert(0); return FALSE;}

    BOOL IsValidType(TfPropertyType proptype)
    {
        if (_proptype == TF_PT_NONE)
            return TRUE;

        return _proptype == proptype;
    }

    CCompartmentMgr *_GetMgr() {return _pCompMgr;}
    DWORD _GetAccess() {return _dwAccess;}
    void Invalid() {_fInvalid = TRUE;};
    
protected:
    static const COMPARTMENTACCESS _c_ca[];
    DWORD _dwAccess;
    TfGuidAtom _guidatom;
    TfPropertyType _proptype;
    BOOL _fInvalid;
    CCompartmentMgr *_pCompMgr;
};

//////////////////////////////////////////////////////////////////////////////
//
// CCompartment
//
//////////////////////////////////////////////////////////////////////////////

class CCompartment :  public CCompartmentBase,
                      public CComObjectRootImmx
{
public:
    CCompartment(CCompartmentMgr *pCompMgr, TfGuidAtom guidatom, TfPropertyType proptype);
    ~CCompartment();

    BEGIN_COM_MAP_IMMX(CCompartment)
        COM_INTERFACE_ENTRY(ITfCompartment)
        COM_INTERFACE_ENTRY(ITfSource)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    // ITfCompartment
    STDMETHODIMP SetValue(TfClientId tid, const VARIANT *pvarValue);
    STDMETHODIMP GetValue(VARIANT *pvarValue);

    // ITfSource
    STDMETHODIMP AdviseSink(REFIID refiid, IUnknown *punk, DWORD *pdwCookie);
    STDMETHODIMP UnadviseSink(DWORD dwCookie);

    CStructArray<GENERICSINK> _rgCompartmentSink; 

private:
    TFPROPERTY _prop;
    BOOL _fInSet;
    DBG_ID_DECLARE;
};



//////////////////////////////////////////////////////////////////////////////
//
// CGlobalCompartment
//
//////////////////////////////////////////////////////////////////////////////

class CGlobalCompartment :  public CCompartmentBase,
                            public CComObjectRootImmx_InternalReference
{
public:
    CGlobalCompartment(CCompartmentMgr *pCompMgr, REFGUID rguid, TfGuidAtom guidatom, TfPropertyType proptype);
    ~CGlobalCompartment();

    BEGIN_COM_MAP_IMMX(CGlobalCompartment)
        COM_INTERFACE_ENTRY(ITfCompartment)
        COM_INTERFACE_ENTRY(ITfSource)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    // ITfCompartment
    STDMETHODIMP SetValue(TfClientId tid, const VARIANT *pvarValue);
    STDMETHODIMP GetValue(VARIANT *pvarValue);

    // ITfSource
    STDMETHODIMP AdviseSink(REFIID refiid, IUnknown *punk, DWORD *pdwCookie);
    STDMETHODIMP UnadviseSink(DWORD dwCookie);

    CStructArray<GENERICSINK> _rgCompartmentSink;
    BOOL MakeNotify();

    DWORD GetId() {return _dwId;}

private:
    static BOOL EnumThreadProc(DWORD dwThreadId, DWORD dwProcessId, void *pv);
    DWORD _dwId;
    BOOL _fInSet;
    GUID _guidCompart;
    DBG_ID_DECLARE;
};

inline CGlobalCompartment *GetCGlobalCompartment(IUnknown *punk)
{
    CGlobalCompartment *comp;

    punk->QueryInterface(IID_PRIV_CGLOBALCOMPARTMENT, (void **)&comp);

    return comp;
}

//////////////////////////////////////////////////////////////////////////////
//
// CCompartmentMgr
//
//////////////////////////////////////////////////////////////////////////////

class __declspec(novtable) CCompartmentMgr : public ITfCompartmentMgr
{
public:
    CCompartmentMgr(TfClientId tidOwner, COMPTYPE cType);
    virtual ~CCompartmentMgr();

    //
    // IUnknown methods
    //
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj) = 0;
    virtual STDMETHODIMP_(ULONG) AddRef(void) = 0;
    virtual STDMETHODIMP_(ULONG) Release(void) = 0;

    STDMETHODIMP GetCompartment(REFGUID rguid, ITfCompartment **ppcomp);
    STDMETHODIMP ClearCompartment(TfClientId tid, REFGUID rguid);
    STDMETHODIMP EnumCompartments(IEnumGUID **ppEnum);

    void NotifyGlobalCompartmentChange(DWORD dwId);
    void CleanUp();

    TfClientId _GetTIPOwner() { return _tidOwner; }

private:
    CCompartmentBase *_Find(TfGuidAtom guidatom, int *piOut);
    CCompartmentBase *_Get(REFGUID rguid);

    COMPTYPE _cType;
    CPtrArray<CCompartmentBase> _rgCompartment;
    TfClientId _tidOwner;

    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CGlobalCompartmentMgr
//
//////////////////////////////////////////////////////////////////////////////

class CGlobalCompartmentMgr :  public CCompartmentMgr
{
public:
    CGlobalCompartmentMgr(TfClientId tidOwner) : CCompartmentMgr(tidOwner, COMPTYPE_GLOBAL) 
    {
        _cRef = 1;
    }

    ~CGlobalCompartmentMgr() {}

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
private:
    int _cRef;
};


#endif COMPART_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\compose.cpp ===
//
// compose.cpp
//

#include "private.h"
#include "compose.h"
#include "ic.h"
#include "range.h"
#include "globals.h"
#include "immxutil.h"
#include "sunka.h"

//////////////////////////////////////////////////////////////////////////////
//
// CEnumCompositionView
//
//////////////////////////////////////////////////////////////////////////////

class CEnumCompositionView : public IEnumITfCompositionView,
                             public CEnumUnknown,
                             public CComObjectRootImmx
{
public:
    CEnumCompositionView()
    { 
        Dbg_MemSetThisNameID(TEXT("CEnumCompositionView"));
    }

    BOOL _Init(CComposition *pFirst, CComposition *pHalt);

    BEGIN_COM_MAP_IMMX(CEnumCompositionView)
        COM_INTERFACE_ENTRY(IEnumITfCompositionView)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    DECLARE_SUNKA_ENUM(IEnumITfCompositionView, CEnumCompositionView, ITfCompositionView)

private:
    DBG_ID_DECLARE;
};

DBG_ID_INSTANCE(CEnumCompositionView);

//+---------------------------------------------------------------------------
//
// _Init
//
//----------------------------------------------------------------------------

BOOL CEnumCompositionView::_Init(CComposition *pFirst, CComposition *pHalt)
{
    CComposition *pComposition;
    ULONG i;
    ULONG cViews;

    Assert(pFirst != NULL || pHalt == NULL);

    cViews = 0;

    // get count
    for (pComposition = pFirst; pComposition != pHalt; pComposition = pComposition->_GetNext())
    {
        cViews++;
    }

    if ((_prgUnk = SUA_Alloc(cViews)) == NULL)
        return FALSE;

    _iCur = 0;
    _prgUnk->cRef = 1;
    _prgUnk->cUnk = cViews;

    for (i=0, pComposition = pFirst; pComposition != pHalt; i++, pComposition = pComposition->_GetNext())
    {
        _prgUnk->rgUnk[i] = (ITfCompositionView *)pComposition;
        _prgUnk->rgUnk[i]->AddRef();
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
// CComposition
//
//////////////////////////////////////////////////////////////////////////////

/* 3ab2f54c-5357-4759-82c1-bbfe73f44dcc */
const IID IID_PRIV_CCOMPOSITION = { 0x3ab2f54c, 0x5357, 0x4759, {0x82, 0xc1, 0xbb, 0xfe, 0x73, 0xf4, 0x4d, 0xcc} };

inline CComposition *GetCComposition_NA(IUnknown *punk)
{
    CComposition *pComposition;

    if (punk->QueryInterface(IID_PRIV_CCOMPOSITION, (void **)&pComposition) != S_OK || pComposition == NULL)
        return NULL;

    pComposition->Release();

    return pComposition;
}

DBG_ID_INSTANCE(CComposition);

//+---------------------------------------------------------------------------
//
// _Init
//
//----------------------------------------------------------------------------

BOOL CComposition::_Init(TfClientId tid, CInputContext *pic, IAnchor *paStart, IAnchor *paEnd, ITfCompositionSink *pSink)
{
    Assert(_paStart == NULL);
    Assert(_paEnd == NULL);

    if (paStart->Clone(&_paStart) != S_OK || _paStart == NULL)
    {
        _paStart = NULL;
        goto ExitError;
    }
    if (paEnd->Clone(&_paEnd) != S_OK || _paEnd == NULL)
    {
        _paEnd = NULL;
        goto ExitError;
    }

    _tid = tid;

    _pic = pic;
    _pic->AddRef();

    _pSink = pSink;
    if (_pSink)
    {
        _pSink->AddRef();
    }

    return TRUE;

ExitError:
    SafeReleaseClear(_paStart);
    SafeReleaseClear(_paEnd);

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// _Uninit
//
//----------------------------------------------------------------------------

void CComposition::_Uninit()
{
    SafeReleaseClear(_pSink);
    SafeReleaseClear(_pic);
    SafeReleaseClear(_paStart);
    SafeReleaseClear(_paEnd);
}

//+---------------------------------------------------------------------------
//
// GetOwnerClsid
//
//----------------------------------------------------------------------------

STDAPI CComposition::GetOwnerClsid(CLSID *pclsid)
{
    if (pclsid == NULL)
        return E_INVALIDARG;

    if (_IsTerminated())
    {
        memset(pclsid, 0, sizeof(*pclsid));
        return E_UNEXPECTED;
    }

    return (MyGetGUID(_tid, pclsid) == S_OK ? S_OK : E_FAIL);
}

//+---------------------------------------------------------------------------
//
// GetRange
//
//----------------------------------------------------------------------------

STDAPI CComposition::GetRange(ITfRange **ppRange)
{
    CRange *range;

    if (ppRange == NULL)
        return E_INVALIDARG;

    *ppRange = NULL;

    if (_IsTerminated())
        return E_UNEXPECTED;

    if ((range = new CRange) == NULL)
        return E_OUTOFMEMORY;

    if (!range->_InitWithDefaultGravity(_pic, COPY_ANCHORS, _paStart, _paEnd))
    {
        range->Release();
        return E_FAIL;
    }

    *ppRange = (ITfRangeAnchor *)range;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// ShiftStart
//
//----------------------------------------------------------------------------

STDAPI CComposition::ShiftStart(TfEditCookie ec, ITfRange *pNewStart)
{
    CRange *rangeNewStart;
    CRange *range;
    IAnchor *paStartNew;
    IAnchor *paClearStart;
    IAnchor *paClearEnd;

    if (_IsTerminated())
        return E_UNEXPECTED;

    if (!_pic->_IsValidEditCookie(ec, TF_ES_READWRITE))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    if ((rangeNewStart = GetCRange_NA(pNewStart)) == NULL)
        return E_INVALIDARG;

    if (!VerifySameContext(_pic, rangeNewStart))
        return E_INVALIDARG;

    paStartNew = rangeNewStart->_GetStart();

    if (CompareAnchors(paStartNew, _paStart) <= 0)
    {
        paClearStart = paStartNew;
        paClearEnd = _paStart;

        // Set GUID_PROP_COMPOSING
        _SetComposing(ec, paClearStart, paClearEnd);
    }
    else
    {
        paClearStart = _paStart;
        paClearEnd = paStartNew;

        // check for crossed anchors
        if (CompareAnchors(_paEnd, paStartNew) < 0)
            return E_INVALIDARG;

        // clear GUID_PROP_COMPOSING
        _ClearComposing(ec, paClearStart, paClearEnd);
    }


    if (_pic->_GetOwnerCompositionSink() != NULL)
    {
        // notify the app
        if (range = new CRange)
        {
            // make sure the end anchor is positioned correctly
            if (range->_InitWithDefaultGravity(_pic, COPY_ANCHORS, paStartNew, _paEnd))
            {
                _pic->_GetOwnerCompositionSink()->OnUpdateComposition(this, (ITfRangeAnchor *)range);
            }
            range->Release();
        }
    }

    if (_paStart->ShiftTo(paStartNew) != S_OK)
        return E_FAIL;

    return S_OK;        
}

//+---------------------------------------------------------------------------
//
// ShiftEnd
//
//----------------------------------------------------------------------------

STDAPI CComposition::ShiftEnd(TfEditCookie ec, ITfRange *pNewEnd)
{
    CRange *rangeNewEnd;
    CRange *range;
    IAnchor *paEndNew;
    IAnchor *paClearStart;
    IAnchor *paClearEnd;

    if (_IsTerminated())
        return E_UNEXPECTED;

    if (!_pic->_IsValidEditCookie(ec, TF_ES_READWRITE))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    if ((rangeNewEnd = GetCRange_NA(pNewEnd)) == NULL)
        return E_INVALIDARG;

    if (!VerifySameContext(_pic, rangeNewEnd))
        return E_INVALIDARG;

    paEndNew = rangeNewEnd->_GetEnd();

    if (CompareAnchors(paEndNew, _paEnd) >= 0)
    {
        paClearStart = _paEnd;
        paClearEnd = paEndNew;

        // Set GUID_PROP_COMPOSING
        _SetComposing(ec, paClearStart, paClearEnd);
    }
    else
    {
        paClearStart = paEndNew;
        paClearEnd = _paEnd;

        // check for crossed anchors
        if (CompareAnchors(_paStart, paEndNew) > 0)
            return E_INVALIDARG;

        // clear GUID_PROP_COMPOSING
        _ClearComposing(ec, paClearStart, paClearEnd);

    }

    // notify the app
    if (_pic->_GetOwnerCompositionSink() != NULL)
    {
        if (range = new CRange)
        {
            // make sure the end anchor is positioned correctly
            if (range->_InitWithDefaultGravity(_pic, COPY_ANCHORS, _paStart, paEndNew))
            {
                _pic->_GetOwnerCompositionSink()->OnUpdateComposition(this, (ITfRangeAnchor *)range);
            }
            range->Release();
        }
    }

    if (_paEnd->ShiftTo(paEndNew) != S_OK)
        return E_FAIL;

    return S_OK;        
}

//+---------------------------------------------------------------------------
//
// EndComposition
//
// Called by the TIP.
//----------------------------------------------------------------------------

STDAPI CComposition::EndComposition(TfEditCookie ec)
{
    if (_IsTerminated())
        return E_UNEXPECTED;

    if (!_pic->_IsValidEditCookie(ec, TF_ES_READWRITE))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    if (_tid != _pic->_GetClientInEditSession(ec))
    {
        Assert(0); // caller doesn't own the composition
        return E_UNEXPECTED;
    }

    if (!_pic->_EnterCompositionOp())
        return E_UNEXPECTED; // reentrant with another write op

    // notify the app
    if (_pic->_GetOwnerCompositionSink() != NULL)
    {
        _pic->_GetOwnerCompositionSink()->OnEndComposition(this);
    }

    // take this guy off the list of compositions
    if (_RemoveFromCompositionList(_pic->_GetCompositionListPtr()))
    {
        // clear GUID_PROP_COMPOSING
        _ClearComposing(ec, _paStart, _paEnd);
    }
    else
    {
        Assert(0); // shouldn't get here
    }

    _pic->_LeaveCompositionOp();

    _Uninit();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _Terminate
//
// Called by Cicero or the app.  Caller should already have removed this
// composition from _pCompositionList to catch reentrancy during notifications.
//----------------------------------------------------------------------------

void CComposition::_Terminate(TfEditCookie ec)
{
    // notify the tip
    _SendOnTerminated(ec, _tid);

    // #507778 OnCompositionTerminated() clear _pic by CComposition::_Uninit().
    if (_pic)
    {
        // notify the app
        if (_pic->_GetOwnerCompositionSink() != NULL)
        {
            _pic->_GetOwnerCompositionSink()->OnEndComposition(this);
        }
    }

    // clear GUID_PROP_COMPOSING
    _ClearComposing(ec, _paStart, _paEnd);

    // kill this composition!
    _Uninit();
}


//+---------------------------------------------------------------------------
//
// _SendOnTerminated
//
//----------------------------------------------------------------------------

void CComposition::_SendOnTerminated(TfEditCookie ec, TfClientId tidForEditSession)
{
    TfClientId tidTmp;

    // _pSink is NULL for default SetText compositions
    if (_pSink == NULL)
        return;

    if (tidForEditSession == _pic->_GetClientInEditSession(ec))
    {
        // we can skip all the exceptional stuff if all the edits
        // will belong to the current lock holder
        // this happens when a tip calls StartComposition for a
        // second composition and cicero needs to term the first
        _pSink->OnCompositionTerminated(ec, this);
    }
    else
    {
        // let everyone know about changes so far
        // the tip we're about to call may need this info
        _pic->_NotifyEndEdit();

        // play some games: this is an exceptional case where we may be allowing a
        // reentrant edit sess.  Need to hack the ec to reflect the composition owner.
        tidTmp = _pic->_SetRawClientInEditSession(tidForEditSession);

        // notify the tip
        _pSink->OnCompositionTerminated(ec, this);
        // #507778 OnCompositionTerminated() clear _pic by CComposition::_Uninit().
        if (! _pic)
            return;

        // let everyone know about changes the terminator made
        _pic->_NotifyEndEdit();

        // put things back the way we found them
        _pic->_SetRawClientInEditSession(tidTmp);
    }
}

//+---------------------------------------------------------------------------
//
// _AddToCompositionList
//
//----------------------------------------------------------------------------

void CComposition::_AddToCompositionList(CComposition **ppCompositionList)
{
    _next = *ppCompositionList;
    *ppCompositionList = this;
    AddRef();
}

//+---------------------------------------------------------------------------
//
// _RemoveFromCompositionList
//
//----------------------------------------------------------------------------

BOOL CComposition::_RemoveFromCompositionList(CComposition **ppCompositionList)
{
    CComposition *pComposition;

    // I don't expect many compositions, so this method uses a simple
    // scan.  We could do something more elaborate for perf if necessary.
    while (pComposition = *ppCompositionList)
    {
        if (pComposition == this)
        {
            *ppCompositionList = _next;
            Release(); // safe because caller already holds ref
            return TRUE;
        }
        ppCompositionList = &pComposition->_next;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// _AddToCompositionList
//
//----------------------------------------------------------------------------

/* static */
IRC CComposition::_IsRangeCovered(CInputContext *pic, TfClientId tid,
                                  IAnchor *paStart, IAnchor *paEnd,
                                  CComposition **ppComposition /* not AddRef'd! */)
{
    CComposition *pComposition;
    IRC irc = IRC_NO_OWNEDCOMPOSITIONS;

    *ppComposition = NULL;

    for (pComposition = pic->_GetCompositionList(); pComposition != NULL; pComposition = pComposition->_next)
    {
        if (pComposition->_tid == tid)
        {
            irc = IRC_OUTSIDE;

            if (CompareAnchors(paStart, pComposition->_paStart) >= 0 &&
                CompareAnchors(paEnd, pComposition->_paEnd) <= 0)
            {
                *ppComposition = pComposition;
                irc = IRC_COVERED;
                break;
            }
        }
    }

    return irc;
}

//+---------------------------------------------------------------------------
//
// _ClearComposing
//
//----------------------------------------------------------------------------

void CComposition::_ClearComposing(TfEditCookie ec, IAnchor *paStart, IAnchor *paEnd)
{
    CProperty *property;

    Assert(!_IsTerminated());

    // #507778 OnCompositionTerminated() clear _pic by CComposition::_Uninit().
    if (! _pic)
        return;

    if (_pic->_GetProperty(GUID_PROP_COMPOSING, &property) != S_OK)
        return;

    property->_ClearInternal(ec, paStart, paEnd);

    property->Release();
}

//+---------------------------------------------------------------------------
//
// _SetComposing
//
//----------------------------------------------------------------------------

void CComposition::_SetComposing(TfEditCookie ec, IAnchor *paStart, IAnchor *paEnd)
{
    CProperty *property;

    if (IsEqualAnchor(paStart, paEnd))
        return;

    if (_pic->_GetProperty(GUID_PROP_COMPOSING, &property) == S_OK)
    {
        VARIANT var;
        var.vt = VT_I4;
        var.lVal = TRUE;

        property->_SetDataInternal(ec, paStart, paEnd, &var);

        property->Release();
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// CInputContext
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// StartComposition
//
//----------------------------------------------------------------------------

STDAPI CInputContext::StartComposition(TfEditCookie ec, ITfRange *pCompositionRange,
                                       ITfCompositionSink *pSink, ITfComposition **ppComposition)
{
    CRange *range;
    CComposition *pComposition;
    HRESULT hr;

    if (ppComposition == NULL)
        return E_INVALIDARG;

    *ppComposition = NULL;

    if (pCompositionRange == NULL || pSink == NULL)
        return E_INVALIDARG;

    if ((range = GetCRange_NA(pCompositionRange)) == NULL)
        return E_INVALIDARG;

    if (!VerifySameContext(this, range))
        return E_INVALIDARG;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    if (!_IsValidEditCookie(ec, TF_ES_READWRITE))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    hr = _StartComposition(ec, range->_GetStart(), range->_GetEnd(), pSink, &pComposition);

    *ppComposition = pComposition;

    return hr;
}

//+---------------------------------------------------------------------------
//
// _StartComposition
//
// Internal, allow pSink to be NULL, skips verification tests.
//----------------------------------------------------------------------------

HRESULT CInputContext::_StartComposition(TfEditCookie ec, IAnchor *paStart, IAnchor *paEnd,
                                         ITfCompositionSink *pSink, CComposition **ppComposition)
{
    BOOL fOk;
    CComposition *pComposition;
    CComposition *pCompositionRef;
    CProperty *property;
    VARIANT var;
    HRESULT hr;

    *ppComposition = NULL;

    if (!_EnterCompositionOp())
        return E_UNEXPECTED; // reentrant with another write op

    hr = S_OK;

    if ((pComposition = new CComposition) == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    if (!pComposition->_Init(_GetClientInEditSession(ec), this, paStart, paEnd, pSink))
    {
        hr = E_FAIL;
        goto Exit;
    }

    //
    // AIMM1.2 expect multiple compositon object. SetText() without creating 
    // its own composition object should not clear out TIP's composition.
    //
    // cicero 1.0 -------
    // all of our clients only allow a single composition.  Let's enforce this behavior
    // to protect cicero 1.0 tips in the future.
    // kill any existing composition before starting a new one:
    // if (_pCompositionList != NULL)
    // {
    //     pCompositionRef = _pCompositionList;
    //     pCompositionRef->AddRef();
    //     _TerminateCompositionWithLock(pCompositionRef, ec);
    //     pCompositionRef->Release();
    //     Assert(_pCompositionList == NULL);
    // }
    // cicero 1.0 -------
    //

    if (_pOwnerComposeSink == NULL) // app may not care about compositions
    {
        fOk = TRUE;
    }
    else
    {
        if (_pOwnerComposeSink->OnStartComposition(pComposition, &fOk) != S_OK)
        {
            hr = E_FAIL;
            goto Exit;
        }

        if (!fOk)
        {
            if (_pCompositionList == NULL)
                goto Exit; // no current compositions, nothing else to try

            // terminate current composition and try again
            pCompositionRef = _pCompositionList; // only ref might be in list, so protect the obj
            pCompositionRef->AddRef();

            _TerminateCompositionWithLock(pCompositionRef, ec);

            pCompositionRef->Release();

            if (_pOwnerComposeSink->OnStartComposition(pComposition, &fOk) != S_OK)
            {
                hr = E_FAIL;
                goto Exit;
            }
           
            if (!fOk)
                goto Exit; // we give up
        }
    }

    // set composition property over existing text
    if (!IsEqualAnchor(paStart, paEnd) &&
        _GetProperty(GUID_PROP_COMPOSING, &property) == S_OK)
    {
        var.vt = VT_I4;
        var.lVal = TRUE;

        property->_SetDataInternal(ec, paStart, paEnd, &var);

        property->Release();
    }

    pComposition->_AddToCompositionList(&_pCompositionList);

    *ppComposition = pComposition;

Exit:
    if (hr != S_OK || !fOk)
    {
        SafeRelease(pComposition);
    }

    _LeaveCompositionOp();

    return hr;
}

//+---------------------------------------------------------------------------
//
// EnumCompositions
//
//----------------------------------------------------------------------------

STDAPI CInputContext::EnumCompositions(IEnumITfCompositionView **ppEnum)
{
    CEnumCompositionView *pEnum;

    if (ppEnum == NULL)
        return E_INVALIDARG;

    *ppEnum = NULL;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    if ((pEnum = new CEnumCompositionView) == NULL)
        return E_OUTOFMEMORY;

    if (!pEnum->_Init(_pCompositionList, NULL))
    {
        pEnum->Release();
        return E_FAIL;
    }

    *ppEnum = pEnum;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// FindComposition
//
//----------------------------------------------------------------------------

STDAPI CInputContext::FindComposition(TfEditCookie ec, ITfRange *pTestRange,
                                      IEnumITfCompositionView **ppEnum)
{
    CComposition *pFirstComp;
    CComposition *pHaltComp;
    CRange *rangeTest;
    CEnumCompositionView *pEnum;

    if (ppEnum == NULL)
        return E_INVALIDARG;

    *ppEnum = NULL;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    if (pTestRange == NULL)
    {
        return EnumCompositions(ppEnum);
    }

    if ((rangeTest = GetCRange_NA(pTestRange)) == NULL)
        return E_INVALIDARG;

    if (!VerifySameContext(this, rangeTest))
        return E_INVALIDARG;

    // search thru the list, finding anything covered by the range
    pFirstComp = NULL;
    for (pHaltComp = _pCompositionList; pHaltComp != NULL; pHaltComp = pHaltComp->_GetNext())
    {
        if (CompareAnchors(rangeTest->_GetEnd(), pHaltComp->_GetStart()) < 0)
            break;

        if (pFirstComp == NULL)
        {
            if (CompareAnchors(rangeTest->_GetStart(), pHaltComp->_GetEnd()) <= 0)
            {
                pFirstComp = pHaltComp;
            }
        }
    }
    if (pFirstComp == NULL)
    {
        // the enum _Init assumes pFirstComp == NULL -> pHaltComp == NULL
        pHaltComp = NULL;
    }

    if ((pEnum = new CEnumCompositionView) == NULL)
        return E_OUTOFMEMORY;

    if (!pEnum->_Init(pFirstComp, pHaltComp))
    {
        pEnum->Release();
        return E_FAIL;
    }

    *ppEnum = pEnum;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// TakeOwnership
//
//----------------------------------------------------------------------------

STDAPI CInputContext::TakeOwnership(TfEditCookie ec, ITfCompositionView *pComposition,
                                    ITfCompositionSink *pSink, ITfComposition **ppComposition)
{
    if (ppComposition == NULL)
        return E_INVALIDARG;

    *ppComposition = NULL;

#ifndef UNTESTED_UNUSED

    Assert(0); // no one should be calling this
    return E_NOTIMPL;

#else

    CComposition *composition;
    TfClientId tidPrev;

    if (pComposition == NULL || pSink == NULL)
        return E_INVALIDARG;

    if ((composition = GetCComposition_NA(pComposition)) == NULL)
        return E_INVALIDARG;

    if (composition->_IsTerminated())
        return E_INVALIDARG; // it's dead!

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    if (!_IsValidEditCookie(ec, TF_ES_READWRITE))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    if (!_EnterCompositionOp())
        return E_UNEXPECTED; // reentrant with another write op

    // switch the owner
    tidPrev = composition->_SetOwner(_GetClientInEditSession(ec));

    // let the old owner know something happened
    composition->_SendOnTerminated(ec, tidPrev);

    // switch the sink
    composition->_SetSink(pSink);

    _LeaveCompositionOp();

    return S_OK;
#endif // UNTESTED_UNUSED
}

//+---------------------------------------------------------------------------
//
// TerminateComposition
//
//----------------------------------------------------------------------------

STDAPI CInputContext::TerminateComposition(ITfCompositionView *pComposition)
{
    HRESULT hr;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    // don't let this happen while we hold a lock
    // the usual scenario: word freaks out and tries to cancel the composition inside a SetText call
    // let's give them an error code to help debug
    if (_IsInEditSession() && _GetTIPOwner() != _tidInEditSession)
    {
        Assert(0); // someone's trying to abort a composition without a lock, or they don't own the ic
        return TF_E_NOLOCK; // meaning the caller doesn't hold the lock
    }

    if (pComposition == NULL && _pCompositionList == NULL)
        return S_OK; // no compositions to terminate, we check later, but check here so we don't fail on read-only docs and for perf

    if (!_EnterCompositionOp())
        return E_UNEXPECTED; // reentrant with another write op

    // need to ask for a lock (call originates with app)
    if (_DoPseudoSyncEditSession(TF_ES_READWRITE, PSEUDO_ESCB_TERMCOMPOSITION, pComposition, &hr) != S_OK || hr != S_OK)
    {
        Assert(0);
        hr = E_FAIL;
    }

    _LeaveCompositionOp();

    return hr;
}

//+---------------------------------------------------------------------------
//
// _TerminateCompositionWithLock
//
//----------------------------------------------------------------------------

HRESULT CInputContext::_TerminateCompositionWithLock(ITfCompositionView *pComposition, TfEditCookie ec)
{
    CComposition *composition;

    Assert(ec != TF_INVALID_EDIT_COOKIE);

    if (pComposition == NULL && _pCompositionList == NULL)
        return S_OK; // no compositions to terminate

    while (TRUE)
    {
        if (pComposition == NULL)
        {
            composition = _pCompositionList;
            composition->AddRef();
        }
        else
        {
            if ((composition = GetCComposition_NA(pComposition)) == NULL)
                return E_INVALIDARG;

            if (composition->_IsTerminated())
                return E_INVALIDARG;
        }

        composition->_Terminate(ec);

        if (!composition->_RemoveFromCompositionList(&_pCompositionList))
        {
            // how did this guy get off the list w/o termination?
            Assert(0); // should never get here
            return E_FAIL;
        }

        if (pComposition != NULL)
            break;

        composition->Release();

        if (_pCompositionList == NULL)
            break;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _AbortCompositions
//
// Called on an ic pop. TIPs do not get a notification because we cannot
// guarantee a lock.
//----------------------------------------------------------------------------

void CInputContext::_AbortCompositions()
{
    CComposition *pComposition;

    while (_pCompositionList != NULL)
    {
        // notify the app
        if (_GetOwnerCompositionSink() != NULL)
        {
            _GetOwnerCompositionSink()->OnEndComposition(_pCompositionList);
        }

        // we won't notify the tip because he can't get a lock here
        // but there's enough info later to cleanup any state in the ic pop notify
        
        _pCompositionList->_Die();

        pComposition = _pCompositionList->_GetNext();
        _pCompositionList->Release();
        _pCompositionList = pComposition;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\compose.h ===
//
// compose.h
//

#ifndef COMPOSE_H
#define COMPOSE_H

class CRange;
class CInputContext;

// return type for _IsRangeCovered method
typedef enum { IRC_COVERED, IRC_OUTSIDE, IRC_NO_OWNEDCOMPOSITIONS } IRC;

extern const IID IID_PRIV_CCOMPOSITION;

class CComposition : public ITfCompositionView,
                     public ITfComposition,
                     public CComObjectRootImmx
{
public:
    CComposition() { Dbg_MemSetThisNameID(TEXT("CComposition")); }
    ~CComposition() { _Uninit(); }

    BOOL _Init(TfClientId tid, CInputContext *pic, IAnchor *paStart, IAnchor *paEnd, ITfCompositionSink *pSink);

    BEGIN_COM_MAP_IMMX(CComposition)
        COM_INTERFACE_ENTRY_IID(IID_PRIV_CCOMPOSITION, CComposition)
        COM_INTERFACE_ENTRY(ITfCompositionView)
        COM_INTERFACE_ENTRY(ITfComposition)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    // ITfCompositionView
    STDMETHODIMP GetOwnerClsid(CLSID *pclsid);
    STDMETHODIMP GetRange(ITfRange **ppRange);

    // ITfComposition
    //STDMETHODIMP GetRange(ITfRange **ppRange);
    STDMETHODIMP ShiftStart(TfEditCookie ecWrite, ITfRange *pNewStart);
    STDMETHODIMP ShiftEnd(TfEditCookie ecWrite, ITfRange *pNewEnd);
    STDMETHODIMP EndComposition(TfEditCookie ecWrite);

    void _AddToCompositionList(CComposition **ppCompositionList);
    BOOL _RemoveFromCompositionList(CComposition **ppCompositionList);

    BOOL _IsTerminated() { return _pic == NULL; }

    void _Terminate(TfEditCookie ec);

    void _SendOnTerminated(TfEditCookie ec, TfClientId tidForEditSession);

    TfClientId _GetOwner() { return _tid; }

    TfClientId _SetOwner(TfClientId tid)
    {
        TfClientId tidTmp = _tid;
        _tid = tid;
        return tidTmp;
    }

    void _SetSink(ITfCompositionSink *pSink)
    {
        SafeRelease(_pSink);
        _pSink = pSink;
        _pSink->AddRef();
    }

    static IRC _IsRangeCovered(CInputContext *pic, TfClientId tid, IAnchor *paStart, IAnchor *paEnd, CComposition **ppComposition);

    IAnchor *_GetStart() { return _paStart; }
    IAnchor *_GetEnd() { return _paEnd; }

    CComposition *_GetNext() { return _next; }

    void _Die() { _Uninit(); }

private:
    
    void _ClearComposing(TfEditCookie ec, IAnchor *paStart, IAnchor *paEnd);
    void _SetComposing(TfEditCookie ec, IAnchor *paStart, IAnchor *paEnd);

    void _Uninit();

    TfClientId _tid;
    CInputContext *_pic;
    IAnchor *_paStart;
    IAnchor *_paEnd;
    ITfCompositionSink *_pSink;
    CComposition *_next;
    DBG_ID_DECLARE;
};

#endif // COMPOSE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\csecattr.h ===
//
// csecattr.h
//

#ifndef CSECATTR_H
#define CSECATTR_H

#include <Sddl.h>

BOOL CreateProperSecurityDescriptor(HANDLE hToken, PSECURITY_DESCRIPTOR *ppsdec);

class CCicSecAttr
{
public:
   CCicSecAttr()
   {
       memset(&_sa, 0, sizeof(_sa));
       _psdec = NULL;
       _fInit = FALSE;
   }

   ~CCicSecAttr()
   {
       if (_psdec)
       {
            LocalFree(_psdec);
            _psdec = NULL;
       }

       _fInit = FALSE;
   }

   operator PSECURITY_ATTRIBUTES()
   {
       if (_fInit)
           return &_sa;

       HANDLE hToken = NULL;
       OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken);

       if (hToken)
       {
           if (CreateProperSecurityDescriptor(hToken, &_psdec))
           {
               _sa.nLength = sizeof(_sa);
               _sa.lpSecurityDescriptor = _psdec;
               _fInit = TRUE;
           }

           CloseHandle(hToken);
       }

       if (!_fInit)
           return NULL;

       return &_sa;
   }

private:
   BOOL _fInit;
   SECURITY_ATTRIBUTES _sa;
   PSECURITY_DESCRIPTOR _psdec;
};

#endif // CSECATTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\uim\default.cpp ===
//
// default.cpp
//

#include "private.h"
#include "globals.h"
#include "imelist.h"
#include "tim.h"
#include "nuimgr.h"
#include "nuihkl.h"
#include "nuictrl.h"
#include "catmgr.h"
#include "imelist.h"
#include "ptrary.h"
#include "ic.h"
#include "assembly.h"
#include "profiles.h"
#include "imelist.h"
#include "ithdmshl.h"
#include "marshal.h"
#include "mstub.h"
#include "smblock.h"
#include "timlist.h"
#include "thdutil.h"
#include "utb.h"
#include "mui.h"
#include "hotkey.h"
#include "profiles.h"
#include "lbaddin.h"
#include "cregkey.h"

CPtrArray<SYSTHREAD> *g_rgSysThread = NULL;

BOOL IsConsoleWindow(HWND hWnd);
void InitThreadHook(DWORD dwThreadId);
void UninitThreadHooks(SYSTHREAD *psfn);
void DestroyMarshalWindow(SYSTHREAD* psfn, HWND hwnd);
UINT _CBTHook(int nCode, WPARAM wParam, LPARAM lParam);
UINT _ShellProc(int nCode, WPARAM wParam, LPARAM lParam);
UINT _GetMsgHook(WPARAM wParam, LPARAM lParam);
UINT _KeyboardHook(WPARAM wParam, LPARAM lParam);

// crazy workaround for a system bug
// sometimes our hook procs will be called after
// we are detached.  By this time we've unmapped
// our shared memory, so keep around a local copy.
static HHOOK s_hSysShellHook = 0;

static HHOOK s_hSysGetMsgHook = 0;
static HHOOK s_hSysCBTHook = 0;

// handling old input CPL
static BOOL g_fLoadedCPLName = FALSE;
static BOOL g_fCHWin9x = FALSE;
static BOOL g_fCHNT4 = FALSE;

TCHAR g_szKbdCPLName[128];
TCHAR g_szKbdCPLTitle[128];
TCHAR g_szWinCHCPLName[128];
TCHAR g_szWinCHCPLTitle[128];
TCHAR g_szNTCPLName[128];
TCHAR g_szNTCPLTitle[128];
TCHAR g_szOldCPLMsg[256];
TCHAR g_szCPLButton[128];
TCHAR g_szCPLGroupBox[128];
TCHAR g_szCHNT4CPLName[128];
TCHAR g_szCHNT4CPLTitle1[128];
TCHAR g_szCHNT4CPLTitle2[128];
TCHAR g_szCH9xKbdCPLTitle[128];

const CHAR c_szIntlCPLFetchClass[] = "IntlNewInputLocaleWndlClass";

// CPL window name and input locale tab title name RC ids
#define NTCPLNAMEID         1
#define NTCPLTITLEID        107
#define WINCPLNAMEID        102
//#define WINCPLTITLEID       42
#define WINCPLTITLEID       104
#define WINCPLCHNAMEID      112
#define WINCPLCHTITLEID     107
#define CHNT4CPLNAMEID      64
#define CHNT4CPLTITLEID1     1
#define CHNT4CPLTITLEID2     2

// CPL file names
#define MAINCPL             TEXT("main.cpl")
#define INTLCPL             TEXT("intl.cpl")
#define CHIMECPL            TEXT("cime.cpl")

inline int SafeGetWindowText(HWND hWnd, LPTSTR szString, int nMaxCount)
{
    int iRet;
    
    iRet = GetWindowText(hWnd, szString, nMaxCount);
    if (nMaxCount > 0)
    {
        // make sure the string is NULL terminated
        // we're not supposed to have to do this, but we're seeing a bug
        // where GetWindowText won't NULL terminate the string if it
        // occupies the whole buffer.
        if (iRet < nMaxCount && iRet >= 0)
        {
            szString[iRet] = 0;
        }
        else
        {
            szString[nMaxCount-1] = 0;
        }
    }

    return iRet;
}

//+---------------------------------------------------------------------------
//
// InitStaticHooks
//
//+---------------------------------------------------------------------------

void InitStaticHooks()
{
    Assert(GetSharedMemory() != NULL);

#if 1
    if (GetSharedMemory() == NULL && ! IsSharedMemoryCreated())
    {
        // Shared memory already closed.
        return;
    }
#endif

    s_hSysShellHook         = GetSharedMemory()->hSysShellHook.GetHandle(g_bOnWow64);

    s_hSysGetMsgHook   = GetSharedMemory()->hSysGetMsgHook.GetHandle(g_bOnWow64);
    s_hSysCBTHook  