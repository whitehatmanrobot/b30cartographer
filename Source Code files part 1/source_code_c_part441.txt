General_Info);

                    //we find a valid superseding template
                    if(fFound)
                        break;
                }

                //we find a valid superseding template
                if(fFound)
                    break;
            }
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------
//
//  AEDoOneEnrollment
//
//-----------------------------------------------------------------------
/*BOOL    AEDoOneEnrollment(HWND                  hwndParent,
                          BOOL                  fUIProcess,
                          BOOL                  fMachine,
                          LPWSTR                pwszMachineName,
                          AE_CERTTYPE_INFO      *pCertType, 
                          AE_CA_INFO            *pCAInfo,
                          DWORD                 *pdwStatus)
{
    BOOL                                fResult = FALSE;
    CRYPTUI_WIZ_CERT_REQUEST_INFO       CertRequestInfo;
    CRYPTUI_WIZ_CERT_TYPE               CertWizType;
    CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW    CertPvkNew;
    CRYPT_KEY_PROV_INFO                 KeyProvInfo;

    memset(&CertRequestInfo, 0, sizeof(CRYPTUI_WIZ_CERT_REQUEST_INFO));
    memset(&CertWizType, 0, sizeof(CRYPTUI_WIZ_CERT_TYPE));
    memset(&CertPvkNew, 0, sizeof(CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW));
    memset(&KeyProvInfo, 0, sizeof(CRYPT_KEY_PROV_INFO));

    CertRequestInfo.dwSize = sizeof(CRYPTUI_WIZ_CERT_REQUEST_INFO);

    //enroll or renewal
    if((pCertType->fRenewal) && (pCertType->pOldCert))
    {
        CertRequestInfo.dwPurpose = CRYPTUI_WIZ_CERT_RENEW;
        CertRequestInfo.pRenewCertContext = pCertType->pOldCert;
    }
    else
        CertRequestInfo.dwPurpose = CRYPTUI_WIZ_CERT_ENROLL;

    //machine name
    if(fMachine)
    {
        CertRequestInfo.pwszMachineName = pwszMachineName;
    }

    //private key information
    CertRequestInfo.dwPvkChoice = CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_NEW;
    CertRequestInfo.pPvkNew = &CertPvkNew;

    CertPvkNew.dwSize = sizeof(CertPvkNew);
    CertPvkNew.pKeyProvInfo = &KeyProvInfo;
    CertPvkNew.dwGenKeyFlags = 0;   //no need to specify the exportable flags

    //SILENT is always set for machine
    if(fMachine)
        KeyProvInfo.dwFlags = CRYPT_MACHINE_KEYSET | CRYPT_SILENT;
    else
    {
        if(fUIProcess)
            KeyProvInfo.dwFlags = 0;
        else
            KeyProvInfo.dwFlags = CRYPT_SILENT;
    }

    //CA information
    CertRequestInfo.pwszCALocation = pCAInfo->awszCADNS[0];
    CertRequestInfo.pwszCAName = pCAInfo->awszCAName[0];

    //enroll for the template
    CertRequestInfo.dwCertChoice = CRYPTUI_WIZ_CERT_REQUEST_CERT_TYPE;
    CertRequestInfo.pCertType = &CertWizType;

    CertWizType.dwSize = sizeof(CertWizType);
    CertWizType.cCertType = 1;
    CertWizType.rgwszCertType = &(pCertType->awszName[0]);

    //ISSUE: we need to call Duncanb's new no-DS look up API
    //for faster performance
    fResult = CryptUIWizCertRequest(CRYPTUI_WIZ_NO_UI_EXCEPT_CSP | CRYPTUI_WIZ_NO_INSTALL_ROOT,
                            hwndParent,
                            NULL,
                            &CertRequestInfo,
                            NULL,               //pCertContext
                            pdwStatus);
    return fResult;
} */

//-----------------------------------------------------------------------
//
//  AECreateEnrollmentRequest
//
//   
//-----------------------------------------------------------------------
BOOL    AECreateEnrollmentRequest(
                          HWND                  hwndParent,
                          BOOL                  fUIProcess,
                          BOOL                  fMachine,
                          LPWSTR                pwszMachineName,
                          AE_CERTTYPE_INFO      *pCertType,
                          AE_CA_INFO            *pCAInfo,
                          HANDLE                *phRequest,
                          DWORD                 *pdwLastError)
{
    BOOL                                    fResult = FALSE;
    CRYPTUI_WIZ_CREATE_CERT_REQUEST_INFO    CreateRequestInfo;
    CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW        CertPvkNew;
    CRYPT_KEY_PROV_INFO                     KeyProvInfo;
    DWORD                                   dwFlags=CRYPTUI_WIZ_NO_UI_EXCEPT_CSP | 
                                                    CRYPTUI_WIZ_NO_INSTALL_ROOT |
                                                    CRYPTUI_WIZ_ALLOW_ALL_TEMPLATES |
                                                    CRYPTUI_WIZ_ALLOW_ALL_CAS;
    DWORD                                   dwSize=0;
    DWORD                                   dwAcquireFlags=0;
    BOOL                                    fResetProv=FALSE;

    CRYPT_KEY_PROV_INFO                     *pKeyProvInfo=NULL;
    HANDLE                                  hRequest=NULL;

    memset(&CreateRequestInfo, 0, sizeof(CRYPTUI_WIZ_CREATE_CERT_REQUEST_INFO));
    memset(&CertPvkNew, 0, sizeof(CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW));
    memset(&KeyProvInfo, 0, sizeof(CRYPT_KEY_PROV_INFO));

    CreateRequestInfo.dwSize = sizeof(CreateRequestInfo);


    //enroll or renewal
    if((pCertType->fRenewal) && (pCertType->pOldCert))
    {
        CreateRequestInfo.dwPurpose = CRYPTUI_WIZ_CERT_RENEW;
        CreateRequestInfo.pRenewCertContext = pCertType->pOldCert;

        //we should not archive renewal certificate for cross template RA
        if((pCertType->fNeedRA) && (pCertType->fCrossRA))
            dwFlags |= CRYPTUI_WIZ_NO_ARCHIVE_RENEW_CERT;

        //we should disalbe UI for machine or non-UI enrollment renew/RA certificate
        if((TRUE == fMachine) || (FALSE == fUIProcess))
        {
            dwSize=0;
            if(!CertGetCertificateContextProperty(pCertType->pOldCert,
                                                CERT_KEY_PROV_INFO_PROP_ID,
                                                NULL,
                                                &dwSize))
                goto error;

            pKeyProvInfo=(CRYPT_KEY_PROV_INFO *)LocalAlloc(LPTR, dwSize);

            if(NULL == pKeyProvInfo)
                goto error;

            if(!CertGetCertificateContextProperty(pCertType->pOldCert,
                                                CERT_KEY_PROV_INFO_PROP_ID,
                                                pKeyProvInfo,
                                                &dwSize))
                goto error;

            dwAcquireFlags=pKeyProvInfo->dwFlags;

            pKeyProvInfo->dwFlags |= CRYPT_SILENT;

            //set the property
            if(!CertSetCertificateContextProperty(pCertType->pOldCert,
                                                 CERT_KEY_PROV_INFO_PROP_ID,
                                                 CERT_SET_PROPERTY_INHIBIT_PERSIST_FLAG,
                                                 pKeyProvInfo))
                goto error;

            fResetProv=TRUE;
        }
    }
    else
        CreateRequestInfo.dwPurpose = CRYPTUI_WIZ_CERT_ENROLL;

    //cert template information
    CreateRequestInfo.hCertType = pCertType->hCertType;

    //machine name
    if(fMachine)
    {
        CreateRequestInfo.fMachineContext = TRUE;
    }

    //private key information
    CreateRequestInfo.dwPvkChoice = CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_NEW;
    CreateRequestInfo.pPvkNew = &CertPvkNew;

    CertPvkNew.dwSize = sizeof(CertPvkNew);
    CertPvkNew.pKeyProvInfo = &KeyProvInfo;
    CertPvkNew.dwGenKeyFlags = 0;   //no need to specify the exportable flags

    //SILENT is always set for machine
    if(fMachine)
        KeyProvInfo.dwFlags = CRYPT_MACHINE_KEYSET | CRYPT_SILENT;
    else
    {
        if(fUIProcess)
            KeyProvInfo.dwFlags = 0;
        else
            KeyProvInfo.dwFlags = CRYPT_SILENT;
    }


    //CA information
    CreateRequestInfo.pwszCALocation = pCAInfo->awszCADNS[0];
    CreateRequestInfo.pwszCAName = pCAInfo->awszCAName[0];

    if(!CryptUIWizCreateCertRequestNoDS(
                            dwFlags,
                            hwndParent,
                            &CreateRequestInfo,
                            &hRequest))
        goto error;


    if(NULL==hRequest)
        goto error;

    *phRequest=hRequest;

    hRequest=NULL;


    fResult = TRUE;

error:

    //get the last error
    if(FALSE == fResult)
    {
        *pdwLastError=GetLastError();
    }

    //reset the property
    if(TRUE == fResetProv)
    {
        if((pKeyProvInfo) && (pCertType->pOldCert))
        {
            pKeyProvInfo->dwFlags = dwAcquireFlags;

            //set the property
            CertSetCertificateContextProperty(pCertType->pOldCert,
                                             CERT_KEY_PROV_INFO_PROP_ID,
                                             CERT_SET_PROPERTY_INHIBIT_PERSIST_FLAG,
                                             pKeyProvInfo);
        }
    }

    if(pKeyProvInfo)
        LocalFree(pKeyProvInfo);

    if(hRequest)
        CryptUIWizFreeCertRequestNoDS(hRequest);

    return fResult;
}

//-----------------------------------------------------------------------
//
//  AECancelled
//
//-----------------------------------------------------------------------
BOOL    AECancelled(HANDLE hCancelEvent)
{
    if(NULL==hCancelEvent)
        return FALSE;

    //test if the event is signalled
    if(WAIT_OBJECT_0 == WaitForSingleObject(hCancelEvent, 0))
        return TRUE;

    return FALSE;
}
//-----------------------------------------------------------------------
//
//  AEDoEnrollment
//
//  return TRUE is no need to do another renewal.   
//  *pdwStatus contain the real enrollment status.
//
//-----------------------------------------------------------------------
BOOL    AEDoEnrollment(HWND             hwndParent,
                       HANDLE           hCancelEvent,
                       BOOL             fUIProcess,
                       DWORD            dwLogLevel,
                       HANDLE           hToken,
                       BOOL             fMachine,
                       LPWSTR           pwszMachineName,
                       AE_CERTTYPE_INFO *pCertType, 
                       DWORD            dwCA,
                       AE_CA_INFO       *rgCAInfo,
                       DWORD            *pdwStatus)
{
    BOOL            fResult = FALSE;
    DWORD           dwIndex = 0;
    DWORD           dwCAIndex = 0;
    BOOL            fRenewal = FALSE;
    DWORD           dwEventID = 0;
    BOOL            fFoundCA = FALSE; 
    DWORD           idsSummary = 0;         //keep the last failure case
    DWORD           dwLastError = 0;

    CRYPTUI_WIZ_QUERY_CERT_REQUEST_INFO     QueryCertRequestInfo;

    HANDLE          hRequest=NULL;
    PCCERT_CONTEXT  pCertContext=NULL;


    //init the out parameter
    *pdwStatus = CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR;

    //detect if we are performing an enrollment or renewal
    if((pCertType->fRenewal) && (pCertType->pOldCert))
    {
        if((pCertType->fNeedRA) && (pCertType->fCrossRA))
            fRenewal=FALSE;
        else
            fRenewal=TRUE;
    }
    else
        fRenewal=FALSE;


    //loop through all the CAs
    for(dwIndex =0; dwIndex < dwCA; dwIndex++)
    {
        dwCAIndex =  (dwIndex + pCertType->dwRandomCAIndex) % dwCA;

        if(AECancelled(hCancelEvent))
        {
            //no need to renew any more
            fResult=TRUE;

            //log that autoenrollment is cancelled
            AELogAutoEnrollmentEvent(dwLogLevel,
                                    FALSE, 
                                    S_OK, 
                                    EVENT_AUTOENROLL_CANCELLED,
                                    fMachine, 
                                    hToken,
                                    0);

            break;
        }

        //make sure the CA supports the specific template
        if(!AEIsAnElement((pCertType->awszName)[0], 
                          rgCAInfo[dwCAIndex].awszCertificateTemplate))
            continue;

        //make sure the CA's validity period of more than the renewing certificate
        if(TRUE == fRenewal)
        {
            if(!AEIsCALonger(rgCAInfo[dwCAIndex].hCAInfo, pCertType->pOldCert))
                continue;
        }

        //enroll to the CA
        *pdwStatus = CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR;
        fFoundCA = TRUE;

        //create a certificate request
        if(NULL==hRequest)
        {
            if(!AECreateEnrollmentRequest(hwndParent, fUIProcess, fMachine, pwszMachineName, pCertType, &(rgCAInfo[dwCAIndex]), &hRequest, &dwLastError))
            {
                //check if user cancelled the enrollment.  If so, no 
                //need to try another CA.
                if((HRESULT_FROM_WIN32(ERROR_CANCELLED) == dwLastError) ||
                   (SCARD_W_CANCELLED_BY_USER == dwLastError))
                {
                    //no need to renewal anymore
                    fResult = TRUE;

                    //log that autoenrollment is cancelled
                    AELogAutoEnrollmentEvent(dwLogLevel,
                                            FALSE, 
                                            S_OK, 
                                            EVENT_AUTOENROLL_CANCELLED_TEMPLATE,
                                            fMachine, 
                                            hToken,
                                            1,
                                            pCertType->awszDisplay[0]);

                    break;

                }
                else
                {
                    idsSummary=IDS_SUMMARY_REQUEST;

                    if(CT_FLAG_REQUIRE_PRIVATE_KEY_ARCHIVAL & pCertType->dwPrivateKeyFlag)
                    {
                        //we have a chance of success with another CA
                        if(hRequest)
                        {
                            CryptUIWizFreeCertRequestNoDS(hRequest);
                            hRequest=NULL;
                        }

                        continue;

                    }
                    else
                    {
                        //we have no hope to create a request successfully
                        //mark dwIndex to the dwCA so that we will log an event at the end of the loop
                        dwIndex=dwCA;
                        break;
                    }
                }
            }
        }

        //check the cancel again because significant time can pass during 
        //request creation
        if(AECancelled(hCancelEvent))
        {
            //no need to renew any more
            fResult=TRUE;

            //log that autoenrollment is cancelled
            AELogAutoEnrollmentEvent(dwLogLevel,
                                    FALSE, 
                                    S_OK, 
                                    EVENT_AUTOENROLL_CANCELLED,
                                    fMachine, 
                                    hToken,
                                    0);

            break;
        }

        if(CryptUIWizSubmitCertRequestNoDS(
                    hRequest, 
                    hwndParent,
                    rgCAInfo[dwCAIndex].awszCAName[0], 
                    rgCAInfo[dwCAIndex].awszCADNS[0], 
                    pdwStatus, 
                    &pCertContext))
        {
            //no need to try another CA if the request is successful or pending
            if((CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED == (*pdwStatus)) ||
                (CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNDER_SUBMISSION == (*pdwStatus))
              )
            {
                //no need to renewal anymore
                fResult = TRUE;

                if(CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED == (*pdwStatus))
                {
                    //we copy the certificate to publishing
                    if(pCertContext)
                    {
                        CertAddCertificateContextToStore(pCertType->hIssuedStore,
                                                        pCertContext,
                                                        CERT_STORE_ADD_USE_EXISTING,
                                                        NULL);

                        CertFreeCertificateContext(pCertContext);
                        pCertContext=NULL;
                    }

                    dwEventID=fRenewal ? EVENT_RENEWAL_SUCCESS_ONCE : EVENT_ENROLL_SUCCESS_ONCE; 
                }
                else
                {
                    dwEventID=fRenewal ? EVENT_RENEWAL_PENDING_ONCE : EVENT_ENROLL_PENDING_ONCE; 
                }

                //log the enrollment sucess or pending event
                AELogAutoEnrollmentEvent(dwLogLevel,
                                        FALSE, 
                                        S_OK, 
                                        dwEventID,
                                        fMachine, 
                                        hToken,
                                        3,
                                        pCertType->awszDisplay[0],
                                        rgCAInfo[dwCAIndex].awszCADisplay[0],
                                        rgCAInfo[dwCAIndex].awszCADNS[0]);

                //log if the private key is re-used
                memset(&QueryCertRequestInfo, 0, sizeof(QueryCertRequestInfo));
                QueryCertRequestInfo.dwSize=sizeof(QueryCertRequestInfo);

                if(CryptUIWizQueryCertRequestNoDS(hRequest,
                                                  &QueryCertRequestInfo))
                {
                    if(CRYPTUI_WIZ_QUERY_CERT_REQUEST_STATUS_CREATE_REUSED_PRIVATE_KEY &
                        (QueryCertRequestInfo.dwStatus))
                    {
                        AELogAutoEnrollmentEvent(dwLogLevel,
                                                FALSE, 
                                                S_OK, 
                                                EVENT_PRIVATE_KEY_REUSED,
                                                fMachine, 
                                                hToken,
                                                1,
                                                pCertType->awszDisplay[0]);
                    }
                }


                break;
            }
        }

        //get the last error
        dwLastError=GetLastError();

        idsSummary=IDS_SUMMARY_CA;

        //log the one enrollment warning
        AELogAutoEnrollmentEvent(dwLogLevel,
                                TRUE, 
                                HRESULT_FROM_WIN32(dwLastError), 
                                fRenewal ? EVENT_RENEWAL_FAIL_ONCE : EVENT_ENROLL_FAIL_ONCE, 
                                fMachine, 
                                hToken,
                                3,
                                pCertType->awszDisplay[0],
                                rgCAInfo[dwCAIndex].awszCADisplay[0],
                                rgCAInfo[dwCAIndex].awszCADNS[0]);


        //we should recreate the request for key archival
        if(CT_FLAG_REQUIRE_PRIVATE_KEY_ARCHIVAL & pCertType->dwPrivateKeyFlag)
        {
            if(hRequest)
            {
                CryptUIWizFreeCertRequestNoDS(hRequest);
                hRequest=NULL;
            }
        }
   }

    //log all enrollments error
    //the loop will exit only if CANCEL, or SUCCEED, or we run out of CAs to try or
    //the request can not be created
    if(dwIndex == dwCA)
    {
        //we either run out of CAs to try or the request can not be created
        if(0 != idsSummary)
            pCertType->idsSummary=idsSummary;

        if(fFoundCA)
        {
            dwEventID = fRenewal ? EVENT_RENEWAL_FAIL : EVENT_ENROLL_FAIL; 
        }
        else
        {
            //if there is no CA, no need to try re-enrollment
            if(fRenewal)
                 pCertType->fRenewal=FALSE; 
           
            dwEventID = fRenewal ? EVENT_RENEWAL_NO_CA_FAIL : EVENT_ENROLL_NO_CA_FAIL;
        }

        AELogAutoEnrollmentEvent(dwLogLevel,
                                fFoundCA ? TRUE : FALSE, 
                                HRESULT_FROM_WIN32(dwLastError), 
                                dwEventID,
                                fMachine, 
                                hToken,
                                1,
                                pCertType->awszDisplay[0]);
    }

    if(hRequest)
        CryptUIWizFreeCertRequestNoDS(hRequest);

    return fResult;
}

//-----------------------------------------------------------------------
//
//  AEEnrollmentCertificates
//
//-----------------------------------------------------------------------
BOOL    AEEnrollmentCertificates(AE_GENERAL_INFO *pAE_General_Info, DWORD dwEnrollStatus)
{
    AE_CERTTYPE_INFO    *rgCertTypeInfo = NULL;
    DWORD               dwIndex =0 ;
    DWORD               dwStatus= 0;
    DWORD               dwRandom = 0;

    HCRYPTPROV          hProv = NULL;

    rgCertTypeInfo = pAE_General_Info->rgCertTypeInfo;

    if(NULL == rgCertTypeInfo)
        return FALSE;

    if((0 == pAE_General_Info->dwCA) || (NULL==pAE_General_Info->rgCAInfo))
        return FALSE;

    if(!CryptAcquireContextW(&hProv,
                NULL,
                MS_DEF_PROV_W,
                PROV_RSA_FULL,
                CRYPT_VERIFYCONTEXT))
        hProv=NULL;


    //going through all the active requests
    for(dwIndex=0; dwIndex < pAE_General_Info->dwCertType; dwIndex++)
    {
        //we enroll/renew for templates that are active
        if(dwEnrollStatus != rgCertTypeInfo[dwIndex].dwStatus)
            continue;

        if(pAE_General_Info->fUIProcess != rgCertTypeInfo[dwIndex].fUIActive)
            continue;
 
        //select a random CA index to balance the load
        if((hProv) && (CryptGenRandom(hProv, sizeof(dwRandom), (BYTE *)(&dwRandom))))
        {
            rgCertTypeInfo[dwIndex].dwRandomCAIndex = dwRandom % (pAE_General_Info->dwCA);
        }
        else
            rgCertTypeInfo[dwIndex].dwRandomCAIndex = 0;

        
        //enroll
        dwStatus=0;

        //report progress
        if(pAE_General_Info->fUIProcess)
        {
            //continue if user choose CANCEL in view RA dialogue
            if(!AEUIProgressReport(FALSE, &(rgCertTypeInfo[dwIndex]),pAE_General_Info->hwndDlg, pAE_General_Info->hCancelEvent))
            {
                AEUIProgressAdvance(pAE_General_Info);
                continue;
            }

        }

        if(AEDoEnrollment(  pAE_General_Info->hwndDlg ? pAE_General_Info->hwndDlg : pAE_General_Info->hwndParent,
                            pAE_General_Info->hCancelEvent,
                            pAE_General_Info->fUIProcess,
                            pAE_General_Info->dwLogLevel,
                            pAE_General_Info->hToken,
                            pAE_General_Info->fMachine,
                            pAE_General_Info->wszMachineName,
                            &(rgCertTypeInfo[dwIndex]), 
                            pAE_General_Info->dwCA,
                            pAE_General_Info->rgCAInfo,
                            &dwStatus))
        {
            //mark the status
            if(CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED == dwStatus)
                rgCertTypeInfo[dwIndex].dwStatus=CERT_REQUEST_STATUS_OBTAINED;
        }
        else
        {
            //if renewal failed, we try to re-enrollment if no RA is required
            if((rgCertTypeInfo[dwIndex].fRenewal) && (FALSE == (rgCertTypeInfo[dwIndex].fNeedRA)))
            {
                 rgCertTypeInfo[dwIndex].fRenewal=FALSE;  
                 dwStatus=0;

                 if(AEDoEnrollment( pAE_General_Info->hwndDlg ? pAE_General_Info->hwndDlg : pAE_General_Info->hwndParent,
                                    pAE_General_Info->hCancelEvent,
                                    pAE_General_Info->fUIProcess,
                                    pAE_General_Info->dwLogLevel,
                                    pAE_General_Info->hToken,
                                    pAE_General_Info->fMachine,
                                    pAE_General_Info->wszMachineName,
                                    &(rgCertTypeInfo[dwIndex]), 
                                    pAE_General_Info->dwCA,
                                    pAE_General_Info->rgCAInfo,
                                    &dwStatus))
                 {
                    //mark the status
                    if(CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED == dwStatus)
                        rgCertTypeInfo[dwIndex].dwStatus=CERT_REQUEST_STATUS_OBTAINED;
                 }
            }
        }

        //advance progress
        if(pAE_General_Info->fUIProcess)
        {
            AEUIProgressAdvance(pAE_General_Info);
        }

    }

    if(hProv)
        CryptReleaseContext(hProv, 0);

    return TRUE;
}


//-----------------------------------------------------------------------
//
//  AEIsDeletableCert
//      Decide if we should archive or delete the certificate
//
//-----------------------------------------------------------------------
BOOL AEIsDeletableCert(PCCERT_CONTEXT pCertContext, AE_GENERAL_INFO *pAE_General_Info)
{
    AE_CERTTYPE_INFO    *pCertType=NULL;
    BOOL                fDelete=FALSE;

    AE_TEMPLATE_INFO    AETemplateInfo;

    memset(&AETemplateInfo, 0, sizeof(AE_TEMPLATE_INFO));

    //only interested in certificate with template information
    if(!AERetrieveTemplateInfo(pCertContext, &AETemplateInfo))
        goto Ret;

    pCertType=AEFindTemplateInRequestTree(&AETemplateInfo, pAE_General_Info);

    if(NULL==pCertType)
        goto Ret;

    if(CT_FLAG_REMOVE_INVALID_CERTIFICATE_FROM_PERSONAL_STORE & (pCertType->dwEnrollmentFlag))
        fDelete=TRUE;
    else 
        fDelete=FALSE;
Ret:

    AEFreeTemplateInfo(&AETemplateInfo);

    return fDelete;
}

//-----------------------------------------------------------------------
//
//	AEIsSupersedeTemplate
//
//		Check if pArchiveCert is superseded by pCertType
//
//-----------------------------------------------------------------------
BOOL AEIsSupersedeTemplate(PCCERT_CONTEXT pArchiveCert, AE_CERTTYPE_INFO *pCertType,  AE_GENERAL_INFO *pAE_General_Info)
{
    BOOL                fSuperSede=FALSE;
    AE_TEMPLATE_INFO    AETemplateInfo;
    AE_CERTTYPE_INFO    *pArchiveCertType=NULL;

    LPWSTR              *awszSuperseding=NULL; 

    memset(&AETemplateInfo, 0, sizeof(AE_TEMPLATE_INFO));

    //only interested in certificate with template information
    if(!AERetrieveTemplateInfo(pArchiveCert, &AETemplateInfo))
        goto Ret;

    pArchiveCertType=AEFindTemplateInRequestTree(&AETemplateInfo, pAE_General_Info);

	if(NULL==pArchiveCertType)
		goto Ret;

    //clear the visited flag in AE_General_Info
    AEClearVistedFlag(pAE_General_Info);

    if(S_OK == CAGetCertTypePropertyEx(
                 pCertType->hCertType, 
                 CERTTYPE_PROP_SUPERSEDE,
                 &(awszSuperseding)))
    {
        if(awszSuperseding && awszSuperseding[0])
        {
            if(AEIfSupersede(pArchiveCertType->awszName[0], awszSuperseding, pAE_General_Info))
            {
				fSuperSede=TRUE;
            }

            //clear the visited flag in AE_General_Info
            AEClearVistedFlag(pAE_General_Info);
        }

        //free the property
        if(awszSuperseding)
            CAFreeCertTypeProperty(pCertType->hCertType, awszSuperseding);
    }

Ret:

    AEFreeTemplateInfo(&AETemplateInfo);

	return fSuperSede;
}

 
//-----------------------------------------------------------------------
//
//	AEIsSameTemplate
//
//		Check if the certificate is of the same template of pCertType
//
//-----------------------------------------------------------------------
BOOL	AEIsSameTemplate(PCCERT_CONTEXT pCertContext, AE_CERTTYPE_INFO *pCertType, BOOL fVersionCheck)
{
	BOOL				fSame=FALSE;

    AE_TEMPLATE_INFO    AETemplateInfo;

    memset(&AETemplateInfo, 0, sizeof(AE_TEMPLATE_INFO));

    if((NULL == pCertType) || (NULL == pCertContext))
        goto Ret;

    //get the template information for the certificate
    if(!AERetrieveTemplateInfo(pCertContext, &AETemplateInfo))
        goto Ret;

   if( (NULL == AETemplateInfo.pwszName) && (NULL == AETemplateInfo.pwszOid))
        goto Ret;

    if(AETemplateInfo.pwszOid)
    {
        //we are guaranteed to have an OID if the schema is greater than or equal to 2
        if(pCertType->dwSchemaVersion >= CERTTYPE_SCHEMA_VERSION_2)
        {
            if(0 == wcscmp(AETemplateInfo.pwszOid, (pCertType->awszOID)[0]))
            {
				if(fVersionCheck)
				{
					if(AETemplateInfo.dwVersion == pCertType->dwVersion)
					{
						fSame=TRUE;
					}
				}
				else
				{
					fSame=TRUE;
				}
            }
        }
    }
    else
    {
        //we are guaranteed to have a name
        if(0 == wcscmp(AETemplateInfo.pwszName, (pCertType->awszName)[0]))
        {
            fSame=TRUE;
        }
    }

Ret:

    AEFreeTemplateInfo(&AETemplateInfo);

	return fSame;
}

//-----------------------------------------------------------------------
//
//  AEArchiveObsoleteCertificates
//      archive old certificate after the enrollment/renewal
//
//      clean up the hUserDS store (delete the expired or revoked certificate)
//-----------------------------------------------------------------------
BOOL    AEArchiveObsoleteCertificates(AE_GENERAL_INFO *pAE_General_Info)
{
    AE_CERTTYPE_INFO    *rgCertTypeInfo = NULL;
    DWORD               dwIndex = 0;
    CRYPT_DATA_BLOB     Archived;
    BOOL                fArchived = FALSE;
	BOOL				fDSArchived = FALSE;
    AE_CERT_INFO        AECertInfo;
    BOOL                fRepublish=FALSE;
	BYTE				rgbHash[SHA1_HASH_LENGTH];
	CRYPT_HASH_BLOB		blobHash;
	BOOL				fHash=FALSE;
    DWORD               dwOpenStoreFlags = CERT_SYSTEM_STORE_CURRENT_USER;
	DWORD				dwProp=CERT_ARCHIVED_PROP_ID;
	BOOL				fSameDns=TRUE;

    HCERTSTORE          hUserDS = NULL;
	HCERTSTORE			hMyArchive = NULL;
    PCCERT_CONTEXT      pCertContext = NULL;
    PCCERT_CONTEXT      pMyContext = NULL;
    PCCERT_CONTEXT      pDSContext = NULL;
	PCCERT_CONTEXT		pIssuedContext = NULL;
	PCCERT_CONTEXT		pDnsContext = NULL;
	PCCERT_CONTEXT		pDnsOldContext = NULL;
	PCCERT_CONTEXT		pSelectedContext = NULL;
	PCCERT_CONTEXT		pMyDnsContext = NULL;
	PCCERT_CONTEXT		pMyArchiveCert = NULL;

    rgCertTypeInfo = pAE_General_Info->rgCertTypeInfo;

    if(NULL == rgCertTypeInfo)
        return FALSE;

    memset(&Archived, 0, sizeof(CRYPT_DATA_BLOB));
    memset(&AECertInfo, 0, sizeof(AE_CERT_INFO));

    //open the UserDS store
    if(!(pAE_General_Info->fMachine))
    {
    	hUserDS = AEOpenUserDSStore(pAE_General_Info, 0);
    }

	//verify the DNS name of issued certificate.  
	//mark the CERT_AUTO_ENROLL_RETRY_PROP_ID property
    if(pAE_General_Info->fMachine)
	{
		for(dwIndex=0; dwIndex < pAE_General_Info->dwCertType; dwIndex++)
		{
			if(CERT_REQUEST_STATUS_OBTAINED == rgCertTypeInfo[dwIndex].dwStatus)
			{
				if(rgCertTypeInfo[dwIndex].hIssuedStore)
				{
					if(pDnsContext = CertEnumCertificatesInStore(
										rgCertTypeInfo[dwIndex].hIssuedStore, NULL))
					{
						pMyDnsContext = FindCertificateInOtherStore(
											pAE_General_Info->hMyStore,
											pDnsContext);

						if(pMyDnsContext)
						{
							//detect if DSN name match
							if(AEVerifyDNSName(pAE_General_Info, pMyDnsContext))
							{
								//the DNS name match; 
								//clear the CERT_AUTO_ENROLL_RETRY_PROP_ID property
								CertSetCertificateContextProperty(
								  pMyDnsContext, 
								  CERT_AUTO_ENROLL_RETRY_PROP_ID, 
								  0, 
								  NULL);
							}
							else
							{
								fSameDns=TRUE;
								pDnsOldContext=NULL;
								pSelectedContext=NULL;

								while(pDnsOldContext = CertEnumCertificatesInStore(
										rgCertTypeInfo[dwIndex].hArchiveStore, pDnsOldContext))
								{
									//only consider same template scenario for retrial purpose
									//only consider certificates with same version
									if(AEIsSameTemplate(pDnsOldContext, &(rgCertTypeInfo[dwIndex]), TRUE))
									{
										if(!AEIsSameDNS(pMyDnsContext, pDnsOldContext))
										{
											fSameDns=FALSE;
											
											CertFreeCertificateContext(pDnsOldContext);
											pDnsOldContext=NULL;

											break;
										}
										else
										{
											if(NULL == pSelectedContext)
											{
												pSelectedContext=CertDuplicateCertificateContext(pDnsOldContext);
											}
											else
											{
												//we use the least retrial wait amoung all old DNS certificates
												//of the same certificate template
												if(!AEFasterRetrialSchedule(pSelectedContext, pDnsOldContext))
												{
													CertFreeCertificateContext(pSelectedContext);
													pSelectedContext = NULL;
													pSelectedContext=CertDuplicateCertificateContext(pDnsOldContext);
												}
											}
										}
									}
								}

								//start over again if the DNS from the new certificate is
								//different from existing ones or this is the 1st time
								//a mis-match DNS has occurred
								if((NULL == pSelectedContext) || (FALSE == fSameDns))
								{
									//clear the CERT_AUTO_ENROLL_RETRY_PROP_ID property
									CertSetCertificateContextProperty(
									  pMyDnsContext, 
									  CERT_AUTO_ENROLL_RETRY_PROP_ID, 
									  0, 
									  NULL);
								}
								else
								{
									AEUpdateRetryProperty(pAE_General_Info, (rgCertTypeInfo[dwIndex].awszDisplay)[0], pMyDnsContext, pSelectedContext);
								}

								if(pSelectedContext)
								{
									CertFreeCertificateContext(pSelectedContext);
									pSelectedContext = NULL;
								}
							}

							CertFreeCertificateContext(pMyDnsContext);
							pMyDnsContext = NULL;
						}

						CertFreeCertificateContext(pDnsContext);
						pDnsContext = NULL;
					}
				}
			}
		}
	}

	//archive certificates
    for(dwIndex=0; dwIndex < pAE_General_Info->dwCertType; dwIndex++)
    {
		fHash=FALSE;
		fRepublish=FALSE;

        if(CERT_REQUEST_STATUS_OBTAINED == rgCertTypeInfo[dwIndex].dwStatus)
        {
			//get the hash of newly enrolled certificate
			blobHash.cbData=SHA1_HASH_LENGTH;
			blobHash.pbData=rgbHash;

			if(rgCertTypeInfo[dwIndex].hIssuedStore)
			{
				if(pIssuedContext = CertEnumCertificatesInStore(
									rgCertTypeInfo[dwIndex].hIssuedStore, NULL))
				{
					if(CryptHashCertificate(
						NULL,             
						0,
						X509_ASN_ENCODING,
						pIssuedContext->pbCertEncoded,
						pIssuedContext->cbCertEncoded,
						blobHash.pbData,
						&(blobHash.cbData)))
					{
						fHash=TRUE;
					}
				}

				//free the cert context
				if(pIssuedContext)
				{
                    CertFreeCertificateContext(pIssuedContext);
                    pIssuedContext = NULL;
				}
			}

			pCertContext=NULL;

            while(pCertContext = CertEnumCertificatesInStore(
                    rgCertTypeInfo[dwIndex].hArchiveStore, pCertContext))
            {
                //archive or delete the certificate from my store
                pMyContext = FindCertificateInOtherStore(
                        pAE_General_Info->hMyStore,
                        pCertContext);


                if(pMyContext)
                {
					//set the Hash of the newly enrolled certificate
					if(fHash)
					{
						CertSetCertificateContextProperty(
											pMyContext,
											CERT_RENEWAL_PROP_ID,
											0,
											&blobHash);
					}

                    if(AEIsDeletableCert(pMyContext, pAE_General_Info))
                    {
                        CertDeleteCertificateFromStore(CertDuplicateCertificateContext(pMyContext));
                    }
                    else
                    {
                        // We force an archive on the old cert and close it.
                        CertSetCertificateContextProperty(pMyContext,
                                                          CERT_ARCHIVED_PROP_ID,
                                                          0,
                                                          &Archived);

                    }

					fArchived=TRUE;

                    CertFreeCertificateContext(pMyContext);
                    pMyContext = NULL;
                }

                //check the DS store. remove the certificates from DS store
                if(hUserDS)
                {
                    if(pMyContext = FindCertificateInOtherStore(
                            hUserDS,
                            pCertContext))
                    {
                        CertDeleteCertificateFromStore(pMyContext);
						fDSArchived=TRUE;
                        pMyContext = NULL;
                        fRepublish=TRUE;
                    }
                }
            }
        }
    }

	//we remove archived certificates from my store
	//open my store with CERT_STORE_ENUM_ARCHIVED_FLAG
    if(pAE_General_Info->fMachine)
        dwOpenStoreFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;

    //open my store
    hMyArchive= CertOpenStore(
                        CERT_STORE_PROV_SYSTEM_W, 
                        ENCODING_TYPE, 
                        NULL, 
                        dwOpenStoreFlags | CERT_STORE_ENUM_ARCHIVED_FLAG, 
                        MY_STORE);

	//loop through all templates
	if(hMyArchive)
	{
		for(dwIndex=0; dwIndex < pAE_General_Info->dwCertType; dwIndex++)
		{
			if(CERT_REQUEST_STATUS_OBTAINED == rgCertTypeInfo[dwIndex].dwStatus)
			{
				//loop through all archived certificates and remove certificates of same template
				//or certificates that are superseded
				pMyArchiveCert=NULL;
				while(pMyArchiveCert=CertFindCertificateInStore(
						hMyArchive, ENCODING_TYPE, 0, CERT_FIND_PROPERTY, &dwProp, pMyArchiveCert))
				{
					if(AEIsSameTemplate(pMyArchiveCert, &(rgCertTypeInfo[dwIndex]), FALSE))
					{
						if(CT_FLAG_REMOVE_INVALID_CERTIFICATE_FROM_PERSONAL_STORE & rgCertTypeInfo[dwIndex].dwEnrollmentFlag)
						{
							CertDeleteCertificateFromStore(CertDuplicateCertificateContext(pMyArchiveCert));
							fArchived=TRUE;
						}
					}
					else
					{
						if(AEIsDeletableCert(pMyArchiveCert, pAE_General_Info))
						{
							if(AEIsSupersedeTemplate(pMyArchiveCert, &(rgCertTypeInfo[dwIndex]), pAE_General_Info))
							{
								CertDeleteCertificateFromStore(CertDuplicateCertificateContext(pMyArchiveCert));
								fArchived=TRUE;
							}
						}
					}
				}
			}
		}
	}

    //now we are done with archiving, we clean up user DS store
   if(AUTO_ENROLLMENT_ENABLE_MY_STORE_MANAGEMENT & (pAE_General_Info->dwPolicy))
   {
    	if(hUserDS)
        {
			pDSContext=NULL;

            while(pDSContext = CertEnumCertificatesInStore(hUserDS, pDSContext))
            {
                AEValidateCertificateInfo(pAE_General_Info, 
                    NULL,                //do not evaluate soon to expire
                    FALSE,               //do not valid private key
                    pDSContext, 
                    &AECertInfo);

                if(FALSE == AECertInfo.fRenewal) 
                {
                    CertDeleteCertificateFromStore(CertDuplicateCertificateContext(pDSContext));
					fDSArchived=TRUE;
                    fRepublish=TRUE;
                }

                memset(&AECertInfo, 0, sizeof(AE_CERT_INFO));
            }
        }
   }

   //we have to republish the certificates as we have rewritten the user DS store
   //CA might has just published to the location
   if(fRepublish)
   {
       if(hUserDS)
       {
            for(dwIndex=0; dwIndex < pAE_General_Info->dwCertType; dwIndex++)
            {
                if(CERT_REQUEST_STATUS_OBTAINED == rgCertTypeInfo[dwIndex].dwStatus)
                {
                    if((rgCertTypeInfo[dwIndex].hIssuedStore) && 
                       (CT_FLAG_PUBLISH_TO_DS & rgCertTypeInfo[dwIndex].dwEnrollmentFlag)
                      )
                    {
                        pCertContext=NULL;
                        while(pCertContext = CertEnumCertificatesInStore(
                                rgCertTypeInfo[dwIndex].hIssuedStore, pCertContext))
                        {
                            CertAddCertificateContextToStore(hUserDS, 
                                                              pCertContext,
                                                              CERT_STORE_ADD_USE_EXISTING,
                                                              NULL);
                        }
                    }
                }
            }
       }
   }
   
   
   //report the event if archival has happened
    if(fArchived)
        AELogAutoEnrollmentEvent(pAE_General_Info->dwLogLevel, FALSE, S_OK, EVENT_ARCHIVE_CERT,                              
                 pAE_General_Info->fMachine, pAE_General_Info->hToken, 0);

	if(fDSArchived)
        AELogAutoEnrollmentEvent(pAE_General_Info->dwLogLevel, FALSE, S_OK, EVENT_ARCHIVE_DS_CERT,                              
                 pAE_General_Info->fMachine, pAE_General_Info->hToken, 0);

    if(hUserDS)
        CertCloseStore(hUserDS, 0);

	if(hMyArchive)
		CertCloseStore(hMyArchive, 0);

    return TRUE;
}

//-----------------------------------------------------------------------
//
//  AERemoveSupersedeActive
//      Remove supersedeActive flag after any successful the enrollment/renewal
//
//-----------------------------------------------------------------------
BOOL    AERemoveSupersedeActive(AE_GENERAL_INFO *pAE_General_Info)
{
    AE_CERTTYPE_INFO    *rgCertTypeInfo = NULL;
    DWORD               dwIndex = 0;
    DWORD               dwActiveIndex = 0;
    DWORD               dwMarkIndex = 0;


    rgCertTypeInfo = pAE_General_Info->rgCertTypeInfo;

    if(NULL == rgCertTypeInfo)
        return FALSE;

    for(dwIndex=0; dwIndex < pAE_General_Info->dwCertType; dwIndex++)
    {
        if(CERT_REQUEST_STATUS_OBTAINED == rgCertTypeInfo[dwIndex].dwStatus)
        {
             for(dwActiveIndex=0; dwActiveIndex < rgCertTypeInfo[dwIndex].dwActive; dwActiveIndex++)
             {
                dwMarkIndex = rgCertTypeInfo[dwIndex].prgActive[dwActiveIndex];
                rgCertTypeInfo[dwMarkIndex].dwStatus=CERT_REQUEST_STATUS_OBTAINED;
             }
        }
    }


    return TRUE;
}

//-----------------------------------------------------------------------
//
//  AEEnrollmentWalker
//
//      This functin performs enrollment tasks 
//
//
//-----------------------------------------------------------------------
BOOL    AEEnrollmentWalker(AE_GENERAL_INFO *pAE_General_Info)
{

    BOOL    fResult = FALSE;

    //we need to set the range for the progress bar in the 
    //UI case
    if((pAE_General_Info->fUIProcess) && (pAE_General_Info->hwndDlg))
    {
        //set the range
        if(0 != (pAE_General_Info->dwUIEnrollCount))
        {
            SendMessage(GetDlgItem(pAE_General_Info->hwndDlg, IDC_ENROLL_PROGRESS),
                        PBM_SETRANGE,
                        0,
                        MAKELPARAM(0, ((pAE_General_Info->dwUIEnrollCount) & (0xFFFF)))
                        );


            SendMessage(GetDlgItem(pAE_General_Info->hwndDlg, IDC_ENROLL_PROGRESS),
                        PBM_SETSTEP, 
                        (WPARAM)1, 
                        0);

            SendMessage(GetDlgItem(pAE_General_Info->hwndDlg, IDC_ENROLL_PROGRESS),
                        PBM_SETPOS, 
                        (WPARAM)0, 
                        0);
        }
    }

    //retrieve the pending request.  Mark the status to obtained if the
    //certificate is issued and of the correct version
    if(AUTO_ENROLLMENT_ENABLE_PENDING_FETCH & (pAE_General_Info->dwPolicy))
    {
        if(FALSE == pAE_General_Info->fUIProcess)
        {
            if(!AEProcessPendingRequest(pAE_General_Info))
                goto Ret;
        }
        else
        {
            if(!AEProcessUIPendingRequest(pAE_General_Info))
                goto Ret;
        }
    }

    //remove duplicated requests based on "Supersede" relationship
    //supress active templates that are superseded by other templates
    if(!AEManageSupersedeRequests(pAE_General_Info))
        goto Ret; 

    //do enrollment/renewal
    if(!AEEnrollmentCertificates(pAE_General_Info, CERT_REQUEST_STATUS_ACTIVE))
        goto Ret;

    
    //We try to get the superseded templates if supserseding templates failed.
    //Only for machine for the case of two V2 DC templates.
    /*if(TRUE == pAE_General_Info->fMachine)
    {
        //remove supersedeActive based on the obtained flag
        if(!AERemoveSupersedeActive(pAE_General_Info))
            goto Ret;

        //do enrollment/renewal again since we migh fail to get superseding templates
        if(!AEEnrollmentCertificates(pAE_General_Info, CERT_REQUEST_STATUS_SUPERSEDE_ACTIVE))
            goto Ret;
    }*/

    fResult = TRUE;

Ret:

    return fResult;
}

//-----------------------------------------------------------------------------
//
// AEUIProgressAdvance
//
//      Increase the progress bar by one step
//-----------------------------------------------------------------------------
BOOL   AEUIProgressAdvance(AE_GENERAL_INFO *pAE_General_Info)
{
    BOOL    fResult=FALSE;

    if(NULL==pAE_General_Info)
        goto Ret;

    if(NULL==(pAE_General_Info->hwndDlg))
        goto Ret;

    //check if CANCEL button is clicked
    if(AECancelled(pAE_General_Info->hCancelEvent))
    {
        fResult=TRUE;
        goto Ret;
    }

    //advance the progress bar
    SendMessage(GetDlgItem(pAE_General_Info->hwndDlg, IDC_ENROLL_PROGRESS),
        PBM_STEPIT,
        0,
        0);

    fResult=TRUE;

Ret:

    return fResult;
}

//-----------------------------------------------------------------------------
//
// AEUIGetNameFromCert
//
//      Retrieve a unique string to identify the certificate. 
//-----------------------------------------------------------------------------
BOOL    AEUIGetNameFromCert(PCCERT_CONTEXT pCertContext, LPWSTR *ppwszRACert)
{

    BOOL                fResult=FALSE;
    DWORD               dwChar=0;
    DWORD               cbOID=0;
    PCCRYPT_OID_INFO    pOIDInfo=NULL;

    LPWSTR              pwszRACert=NULL;
    AE_TEMPLATE_INFO    TemplateInfo;
    LPSTR               szOID=NULL;

    if((NULL==pCertContext) || (NULL==ppwszRACert))
        goto Ret;

    *ppwszRACert=NULL;
    
    memset(&TemplateInfo, 0, sizeof(TemplateInfo));

    //get the template name first
    if(!AERetrieveTemplateInfo(pCertContext, &TemplateInfo))
        goto Ret;
    
    if(TemplateInfo.pwszName)
    {
        pwszRACert=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (wcslen(TemplateInfo.pwszName) + 1));
        if(NULL == pwszRACert)
            goto Ret;

        wcscpy(pwszRACert, TemplateInfo.pwszName);
    }
    else
    {
        if(NULL==(TemplateInfo.pwszOid))
            goto Ret;

        //find the OID
        if(0 == (cbOID = WideCharToMultiByte(CP_ACP, 
                                  0,
                                  TemplateInfo.pwszOid,
                                  -1,
                                  NULL,
                                  0,
                                  NULL,
                                  NULL)))
            goto Ret;

        szOID=(LPSTR)LocalAlloc(LPTR, cbOID);

        if(NULL==szOID)
            goto Ret;

        if(0 == WideCharToMultiByte(CP_ACP, 
                                  0,
                                  TemplateInfo.pwszOid,
                                  -1,
                                  szOID,
                                  cbOID,
                                  NULL,
                                  NULL))
            goto Ret;
            
        pOIDInfo=CryptFindOIDInfo(
                    CRYPT_OID_INFO_OID_KEY,
                    szOID,
                    CRYPT_TEMPLATE_OID_GROUP_ID);


        if(pOIDInfo)
        {
            if(pOIDInfo->pwszName)
            {
                pwszRACert=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (wcslen(pOIDInfo->pwszName) + 1));
                if(NULL== pwszRACert)
                    goto Ret;

                wcscpy(pwszRACert, pOIDInfo->pwszName);
            }
        }

    }

    //if template name does not exist.  Get the subject name for now
  /*  if(NULL==pwszRACert)
    {
        if(0 == (dwChar=CertGetNameStringW(
                    pCertContext,
                    CERT_NAME_SIMPLE_DISPLAY_TYPE,
                    0,
                    NULL,
                    NULL,
                    0)))
            goto Ret;

        pwszRACert=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (dwChar));
        if(NULL== pwszRACert)
            goto Ret;

        if(0 == (dwChar=CertGetNameStringW(
                    pCertContext,
                    CERT_NAME_SIMPLE_DISPLAY_TYPE,
                    0,
                    NULL,
                    pwszRACert,
                    dwChar)))
            goto Ret;
    } */

    *ppwszRACert = pwszRACert;
    pwszRACert=NULL;

    fResult=TRUE;

Ret:

    if(pwszRACert)
        LocalFree(pwszRACert);

    if(szOID)
        LocalFree(szOID);

    AEFreeTemplateInfo(&TemplateInfo);


    return fResult;

}

//-----------------------------------------------------------------------------
//
//  AEGetRACertInfo
//
//-----------------------------------------------------------------------------
BOOL    AEGetRACertInfo(PCERT_CONTEXT   pRAContext,  
                        LPWSTR          pwszRATemplate,
                        LPWSTR          *ppwszRACertInfo)
{
    BOOL        fResult=FALSE;
    UINT        idsMessage=0;
    DWORD       dwSize=0;

    LPWSTR      pwszIssuer=NULL;

    if(NULL==pRAContext)
        goto Ret;

    if(pwszRATemplate)
        idsMessage=IDS_VIEW_RA_INFO;
    else
        idsMessage=IDS_VIEW_RA_INFO_GENERAL;

    //the cert has to have an issuer
    if(0 == (dwSize=CertNameToStrW(
            ENCODING_TYPE,
            &(pRAContext->pCertInfo->Issuer),
            CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
            NULL,
            0)))
        goto Ret;

    pwszIssuer=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * dwSize);
    if(NULL==pwszIssuer)
        goto Ret;

    if(0 == CertNameToStrW(
            ENCODING_TYPE,
            &(pRAContext->pCertInfo->Issuer),
            CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
            pwszIssuer,
            dwSize))
        goto Ret;


    if(!FormatMessageUnicode(
            ppwszRACertInfo, 
            idsMessage, 
            pwszIssuer,
            pwszRATemplate))
        goto Ret;

    fResult=TRUE;

Ret:

    if(pwszIssuer)
        LocalFree(pwszIssuer);

    return fResult;
}



//-----------------------------------------------------------------------------
//
//  WinProc for the view RA certificate dialogue
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK AEViewRADlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL                            fPropertyChanged = FALSE;
    AE_VIEW_RA_INFO                 *pAEViewRAInfo = NULL;
    CRYPTUI_VIEWCERTIFICATE_STRUCT  CertViewStruct;

    LPWSTR                          pwszRACertInfo=NULL;

    switch (msg) 
    {
        case WM_INITDIALOG:
                pAEViewRAInfo=(AE_VIEW_RA_INFO *)lParam;

                if(NULL==pAEViewRAInfo)
                    break;

                SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pAEViewRAInfo);

                //display the RA template and issuer dynamically
                if(AEGetRACertInfo(pAEViewRAInfo->pRAContext,  
                                    pAEViewRAInfo->pwszRATemplate,
                                    &pwszRACertInfo))
                {
                    SetDlgItemTextW(hwndDlg, IDC_EDIT3, pwszRACertInfo);

                    LocalFree((HLOCAL)pwszRACertInfo);

                }

                return TRUE;
            break;

         case WM_NOTIFY:
            break;

        case WM_CLOSE:
                EndDialog(hwndDlg, IDC_BUTTON3);
                return TRUE;
            break;

        case WM_COMMAND:
                switch (LOWORD(wParam))
                {
                    //view certificate
                    case IDC_BUTTON1:
                            if(NULL==(pAEViewRAInfo=(AE_VIEW_RA_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break; 
                            
                            if(NULL==pAEViewRAInfo->pRAContext)
                                break;

                            //show the certificate
                            memset(&CertViewStruct, 0, sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT));
                            CertViewStruct.dwSize=sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT);
                            CertViewStruct.hwndParent=hwndDlg;
                            CertViewStruct.dwFlags=CRYPTUI_DISABLE_EDITPROPERTIES;
                            CertViewStruct.pCertContext=pAEViewRAInfo->pRAContext;

                            fPropertyChanged=FALSE;

                            CryptUIDlgViewCertificate(&CertViewStruct, &fPropertyChanged);

                        return TRUE;

                    //OK
                    case IDC_BUTTON2:
                        EndDialog(hwndDlg, IDC_BUTTON2);
                        return TRUE;
                }
            break;

        default:
                return FALSE;
    }

    return FALSE;
}                             
//-----------------------------------------------------------------------------
//
// AEUIProgressReport
//
//      Report the current enrollment action.  Return FALSE if no progress status
// can be reported.
//-----------------------------------------------------------------------------
BOOL    AEUIProgressReport(BOOL fPending, AE_CERTTYPE_INFO *pCertType, HWND hwndDlg, HANDLE hCancelEvent)
{
    BOOL                fResult=FALSE;
    UINT                idsMessage=0;
    INT_PTR             ret=0;
    AE_VIEW_RA_INFO     AEViewRAInfo;

    LPWSTR              *awszFriendlyName=NULL;
    LPWSTR              pwszRACert=NULL;
    LPWSTR              pwszReport=NULL;

    memset(&AEViewRAInfo, 0, sizeof(AE_VIEW_RA_INFO));

    if((NULL==pCertType) || (NULL==hwndDlg))
        goto Ret;

    if(NULL==(pCertType->hCertType))
        goto Ret;

    if(AECancelled(hCancelEvent))
    {
        fResult=TRUE;
        goto Ret;
    }

    if(fPending)
        idsMessage=IDS_REPORT_PENDING;
    else
    {
        if((pCertType->fRenewal) && (pCertType->pOldCert))
        {
            if(pCertType->fNeedRA)
            {
                if(FALSE == (pCertType->fCrossRA))
                    idsMessage=IDS_REPORT_RENEW;
                else
                    idsMessage=IDS_REPORT_ENROLL_RA;
            }
            else
                idsMessage=IDS_REPORT_RENEW;
        }
        else
            idsMessage=IDS_REPORT_ENROLL;
    }

    //retrieve the template's friendly name
    if(S_OK != CAGetCertTypePropertyEx(
                  pCertType->hCertType, 
                  CERTTYPE_PROP_FRIENDLY_NAME,
                  &awszFriendlyName))
        goto Ret;

    if(NULL==awszFriendlyName)
        goto Ret;

    if(NULL==(awszFriendlyName[0]))
        goto Ret;


    //retrieve the RA certificate's template name
    if(IDS_REPORT_ENROLL_RA == idsMessage)
    {
        if(!AEUIGetNameFromCert(pCertType->pOldCert, &pwszRACert))
        {
            pwszRACert=NULL;
        }
    }

    if(!FormatMessageUnicode(&pwszReport, idsMessage, awszFriendlyName[0]))
        goto Ret;

    if(0 == SetDlgItemTextW(hwndDlg, IDC_EDIT2, pwszReport))
        goto Ret;

    //we will give user an opportunity to view the RA certificate before we go on
    //format the view message
    if(IDS_REPORT_ENROLL_RA != idsMessage)
    {
        //no need to do anything more
        fResult=TRUE;
        goto Ret;
    }

    AEViewRAInfo.pRAContext=pCertType->pOldCert;
    AEViewRAInfo.pwszRATemplate=pwszRACert;

    //ask user if he/she wants to view the RA certificate
    ret=DialogBoxParam(g_hmodThisDll, 
                 (LPCWSTR)MAKEINTRESOURCE(IDD_VIEW_RA_CERTIFICATE_DLG),
                 hwndDlg, 
                 AEViewRADlgProc,
                 (LPARAM)(&AEViewRAInfo));

    fResult=TRUE;

Ret:

    if(pwszRACert)
        LocalFree(pwszRACert);

    if(awszFriendlyName)
        CAFreeCertTypeProperty(pCertType->hCertType, awszFriendlyName);

    if(pwszReport)
        LocalFree((HLOCAL) pwszReport);
    
    return fResult;
}



//-----------------------------------------------------------------------------
//
//  the call back function to compare summary column
//
//-----------------------------------------------------------------------------
int CALLBACK CompareSummary(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    AE_CERTTYPE_INFO    *pCertTypeOne=NULL;
    AE_CERTTYPE_INFO    *pCertTypeTwo=NULL;
    DWORD               dwColumn=0;
    int                 iCompare=0;
    
    LPWSTR              pwszOne=NULL;
    LPWSTR              pwszTwo=NULL;

    pCertTypeOne=(AE_CERTTYPE_INFO *)lParam1;
    pCertTypeTwo=(AE_CERTTYPE_INFO *)lParam2;

    dwColumn=(DWORD)lParamSort;

    if((NULL==pCertTypeOne) || (NULL==pCertTypeTwo))
        goto Ret;

    switch(dwColumn & 0x0000FFFF)
    {
       case AE_SUMMARY_COLUMN_TYPE:
	            //we should use wcsicoll instead of wcsicmp since wcsicoll use the
	            //lexicographic order of current code page.
	            iCompare=CompareStringW(LOCALE_USER_DEFAULT,
						            NORM_IGNORECASE,
						            pCertTypeOne->awszDisplay[0],
						            -1,
						            pCertTypeTwo->awszDisplay[0],
						            -1);
            break;

       case AE_SUMMARY_COLUMN_REASON:
                pwszOne=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (MAX_DN_SIZE));
                pwszTwo=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (MAX_DN_SIZE));

                if((NULL==pwszOne) || (NULL==pwszTwo))
                    goto Ret;


                if(0 == LoadStringW(g_hmodThisDll, 
                                pCertTypeOne->idsSummary, 
                                pwszOne, 
                                MAX_DN_SIZE))
                    goto Ret;


                if(0 == LoadStringW(g_hmodThisDll, 
                                pCertTypeTwo->idsSummary, 
                                pwszTwo, 
                                MAX_DN_SIZE))
                    goto Ret;

	            //we should use wcsicoll instead of wcsicmp since wcsicoll use the
	            //lexicographic order of current code page.
	            iCompare=CompareStringW(LOCALE_USER_DEFAULT,
						            NORM_IGNORECASE,
						            pwszOne,
						            -1,
						            pwszTwo,
						            -1);
           
            
           break;
       default:
                goto Ret;
            break;
    }

    switch(iCompare)
    {
        case CSTR_LESS_THAN:

                iCompare=-1;
            break;
            
        case CSTR_EQUAL:

                iCompare=0;
            break;

        case CSTR_GREATER_THAN:

                iCompare=1;
            break;

        default:
                goto Ret;
            break;
    }

    if(dwColumn & SORT_COLUMN_DESCEND)
        iCompare = 0-iCompare;

Ret:

    if(pwszOne)
        LocalFree(pwszOne);

    if(pwszTwo)
        LocalFree(pwszTwo);

    return iCompare;
}


//-----------------------------------------------------------------------------
//
//  AEDisplaySummaryInfo
//
//-----------------------------------------------------------------------------
BOOL    AEDisplaySummaryInfo(HWND hWndListView, AE_GENERAL_INFO *pAE_General_Info)
{
    BOOL                fResult=FALSE;
    AE_CERTTYPE_INFO    *rgCertTypeInfo = NULL;
    DWORD               dwIndex =0;
    DWORD               dwItem=0;
    LV_ITEMW            lvItem;   
    WCHAR               wszReason[MAX_DN_SIZE];
    AE_CERTTYPE_INFO    *pCertType=NULL;

    if((NULL==hWndListView) || (NULL==pAE_General_Info))
        goto Ret;

    rgCertTypeInfo = pAE_General_Info->rgCertTypeInfo;

    if(NULL == rgCertTypeInfo)
        goto Ret;

     // set up the fields in the list view item struct that don't change from item to item
    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.state = 0;
    lvItem.stateMask = 0;
    lvItem.iItem=0;
    lvItem.iSubItem=0;
    lvItem.iImage = 0;
    lvItem.lParam = NULL;

    for(dwIndex=0; dwIndex < pAE_General_Info->dwCertType; dwIndex++)
    {
        if((TRUE == rgCertTypeInfo[dwIndex].fUIActive) && (0 != rgCertTypeInfo[dwIndex].idsSummary))
        {
            if(0 != LoadStringW(g_hmodThisDll, 
                                rgCertTypeInfo[dwIndex].idsSummary, 
                                wszReason, 
                                MAX_DN_SIZE))
            {
                lvItem.iItem=dwItem;
                lvItem.iSubItem=0;
                dwItem++;

                pCertType=&(rgCertTypeInfo[dwIndex]);

                lvItem.lParam = (LPARAM)(pCertType);

                //template name
                lvItem.pszText=rgCertTypeInfo[dwIndex].awszDisplay[0];

                ListView_InsertItem(hWndListView, &lvItem);

                //reason
                lvItem.iSubItem++;

                ListView_SetItemText(hWndListView, lvItem.iItem, lvItem.iSubItem, wszReason);
            }
        }
    }

    fResult=TRUE;

Ret:

    return fResult;
}

//-----------------------------------------------------------------------------
//
//  WinProc for the summary page
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK AESummaryDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{

    AE_GENERAL_INFO             *pAE_General_Info=NULL;
    HWND                        hWndListView=NULL;
    UINT                        rgIDS[]={IDS_COLUMN_TYPE,
                                        IDS_COLUMN_REASON};
    DWORD                       dwIndex=0;
    DWORD                       dwCount=0;
    LV_COLUMNW                  lvC;
    WCHAR                       wszText[AE_SUMMARY_COLUMN_SIZE];
    NM_LISTVIEW                 *pnmv=NULL;
    DWORD                       dwSortParam=0;
    static DWORD                rgdwSortParam[]=
                                    {AE_SUMMARY_COLUMN_TYPE | SORT_COLUMN_ASCEND,
                                    AE_SUMMARY_COLUMN_REASON | SORT_COLUMN_DESCEND};

    switch (msg) 
    {
        case WM_INITDIALOG:
                pAE_General_Info=(AE_GENERAL_INFO *)lParam;

                if(NULL==pAE_General_Info)
                    break;

                SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pAE_General_Info);

                //init the list view control
                //add the colums to the list view
                hWndListView = GetDlgItem(hwndDlg, IDC_LIST2);

                if(NULL==hWndListView)
                    break;

                dwCount=sizeof(rgIDS)/sizeof(rgIDS[0]);

                //set up the common info for the column
                memset(&lvC, 0, sizeof(LV_COLUMNW));

                lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
                lvC.fmt = LVCFMT_LEFT;      // Left-align the column.
                lvC.cx = 150;                // Width of the column, in pixels.
                lvC.iSubItem=0;
                lvC.pszText = wszText;      // The text for the column.

                //insert the column one at a time
                for(dwIndex=0; dwIndex < dwCount; dwIndex++)
                {
                    //get the column header
                    wszText[0]=L'\0';

                    if(0 != LoadStringW(g_hmodThisDll, rgIDS[dwIndex], wszText, AE_SUMMARY_COLUMN_SIZE))
                    {
                        ListView_InsertColumn(hWndListView, dwIndex, &lvC);
                    }
                }

                // set the style in the list view so that it highlights an entire line
                SendMessage(hWndListView, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);

                AEDisplaySummaryInfo(hWndListView, pAE_General_Info);

                //autosize the columns
                for(dwIndex=0; dwIndex < dwCount; dwIndex++)
                {
                    ListView_SetColumnWidth(hWndListView, dwIndex, LVSCW_AUTOSIZE);
                }

                //sort 1st column of the list view
                dwSortParam=rgdwSortParam[0];

                SendDlgItemMessage(hwndDlg,
                    IDC_LIST2,
                    LVM_SORTITEMS,
                    (WPARAM) (LPARAM) dwSortParam,
                    (LPARAM) (PFNLVCOMPARE)CompareSummary);

                return TRUE;
            break;

         case WM_NOTIFY:
                switch (((NMHDR FAR *) lParam)->code)
                {
                    //the column has been changed
                    case LVN_COLUMNCLICK:

                            pnmv = (NM_LISTVIEW *) lParam;

                            dwSortParam=0;

                            //get the column number
                            switch(pnmv->iSubItem)
                            {
                                case 0:
                                case 1:
                                        dwSortParam=rgdwSortParam[pnmv->iSubItem];
                                    break;
                                default:
                                        dwSortParam=0;
                                    break;
                            }

                            if(0!=dwSortParam)
                            {
                                //remember to flip the ascend ording
                                if(dwSortParam & SORT_COLUMN_ASCEND)
                                {
                                    dwSortParam &= 0x0000FFFF;
                                    dwSortParam |= SORT_COLUMN_DESCEND;
                                }
                                else
                                {
                                    if(dwSortParam & SORT_COLUMN_DESCEND)
                                    {
                                        dwSortParam &= 0x0000FFFF;
                                        dwSortParam |= SORT_COLUMN_ASCEND;
                                    }
                                }

                                //sort the column
                                SendDlgItemMessage(hwndDlg,
                                    IDC_LIST2,
                                    LVM_SORTITEMS,
                                    (WPARAM) (LPARAM) dwSortParam,
                                    (LPARAM) (PFNLVCOMPARE)CompareSummary);

                                rgdwSortParam[pnmv->iSubItem]=dwSortParam;
                            }

                        break;
                }
            break;

        case WM_CLOSE:
                EndDialog(hwndDlg, IDC_BUTTON1);
                return TRUE;
            break;

        case WM_COMMAND:
                switch (LOWORD(wParam))
                {
                    case IDC_BUTTON1:
                        EndDialog(hwndDlg, IDC_BUTTON1);
                        return TRUE;
                }
            break;

        default:
                return FALSE;
    }

    return FALSE;
}                             


//-----------------------------------------------------------------------------
//
//  AEDisplaySummaryPage
//         
//-----------------------------------------------------------------------------
BOOL    AEDisplaySummaryPage(AE_GENERAL_INFO *pAE_General_Info)
{
    BOOL                fResult=FALSE;
    DWORD               dwIndex=0;
    BOOL                fSummary=FALSE;
    AE_CERTTYPE_INFO    *rgCertTypeInfo=NULL;
    AE_CERTTYPE_INFO    *pCertType=NULL;

    //decide if there is need to show the summary page.  
    //Checking for idsSummary for each template
    if(NULL == pAE_General_Info)
        goto Ret;

    if(NULL == (rgCertTypeInfo=pAE_General_Info->rgCertTypeInfo))
        goto Ret;

    for(dwIndex=0; dwIndex < pAE_General_Info->dwCertType; dwIndex++)
    {
        if((TRUE == rgCertTypeInfo[dwIndex].fUIActive) && (0 != rgCertTypeInfo[dwIndex].idsSummary))
        {
            fSummary=TRUE;
            break;
        }
    }

    //show the summary dialogue
    if(TRUE == fSummary)
    {
        if(pAE_General_Info->hwndDlg)
        {
            DialogBoxParam(g_hmodThisDll, 
                     (LPCWSTR)MAKEINTRESOURCE(IDD_USER_SUMMARY_DLG),
                     pAE_General_Info->hwndDlg, 
                     AESummaryDlgProc,
                     (LPARAM)(pAE_General_Info));
        }
    }

    fResult=TRUE;

Ret:
    return fResult;
}



//-----------------------------------------------------------------------------
//  WinProc for the autoenrollment progress window
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK progressDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    AE_GENERAL_INFO         *pAE_General_Info = NULL;

    switch (msg) 
    {
        case WM_INITDIALOG:
                pAE_General_Info=(AE_GENERAL_INFO *)lParam;

                //copy the hwndDlg to the enrollment thread
                pAE_General_Info->hwndDlg=hwndDlg;

                //start the interacive enrollment thread
                if(1 != ResumeThread(pAE_General_Info->hThread))
                {   
                    pAE_General_Info->hwndDlg=NULL;

                    //we have to end the dialogue
                    EndDialog(hwndDlg, IDC_BUTTON1);
                    return TRUE;
                }

                SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pAE_General_Info);

                return TRUE;
            break;

        case WM_NOTIFY:
            break;

        case WM_CLOSE:

                if(NULL==(pAE_General_Info=(AE_GENERAL_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                    break;

                //disable the cancel button
                EnableWindow(GetDlgItem(hwndDlg,IDC_BUTTON1), FALSE);

                //signal the cancel event
                if(pAE_General_Info->hCancelEvent)
                    SetEvent(pAE_General_Info->hCancelEvent);

                //close the dialogue if the enrollment work is completed
                if(WAIT_OBJECT_0 == WaitForSingleObject(pAE_General_Info->hCompleteEvent, 0))
                {
                    EndDialog(hwndDlg, IDC_BUTTON1);
                }
               
                return TRUE;

            break;

        case WM_COMMAND:
                switch (LOWORD(wParam))
                {
                    case IDC_BUTTON1:
                            if(NULL==(pAE_General_Info=(AE_GENERAL_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            //disable the cancel button
                            EnableWindow(GetDlgItem(hwndDlg,IDC_BUTTON1), FALSE);

                            //signal the cancel event
                            if(pAE_General_Info->hCancelEvent)
                                SetEvent(pAE_General_Info->hCancelEvent);


                        return TRUE;
                }
            break;

        default:
                return FALSE;
    }

    return FALSE;
}                             


//-----------------------------------------------------------------------------
//  AEInteractiveThreadProc
//
//      The thread procedue to do interactive enrollment
//-----------------------------------------------------------------------------
DWORD WINAPI AEInteractiveThreadProc(LPVOID lpParameter)
{
    BOOL                    fResult=FALSE;
    AE_GENERAL_INFO         *pAE_General_Info = NULL;

    if(NULL==lpParameter)
        return FALSE;

    __try
    {

        pAE_General_Info=(AE_GENERAL_INFO *)lpParameter;

        pAE_General_Info->fUIProcess=TRUE;
    
        fResult = AEEnrollmentWalker(pAE_General_Info);

        //show the summary page if not canceled
        if(!AECancelled(pAE_General_Info->hCancelEvent))
        {
            AEDisplaySummaryPage(pAE_General_Info);
        }

        //signal that the process is completed
        SetEvent(pAE_General_Info->hCompleteEvent);
        
        //signal the progress window that we are done
        if(pAE_General_Info->hwndDlg)
        {
                //click the close button
                SendMessage(pAE_General_Info->hwndDlg,
                            WM_CLOSE, //WM_COMMAND,
                            0, //IDC_BUTTON1,
                            NULL);
        }
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
    }
    
    return fResult;
}


//-----------------------------------------------------------------------------
//  AEInteractiveEnrollment
//
//      We are doing interactive enrollment
//-----------------------------------------------------------------------------
BOOL    AEInteractiveEnrollment(AE_GENERAL_INFO *pAE_General_Info)
{
    DWORD                       dwThreadID=0;
    BOOL                        fResult=FALSE;
    

    //create a notification event for cancel process
    pAE_General_Info->hCancelEvent=CreateEvent(
                    NULL,
                    TRUE,      // bmanual reset type           
                    FALSE,     // initial state
                    NULL);

    if(NULL==(pAE_General_Info->hCancelEvent))
        goto ret;

    //create a notification event for complete process
    pAE_General_Info->hCompleteEvent=CreateEvent(
                    NULL,
                    TRUE,      // bmanual reset type           
                    FALSE,     // initial state
                    NULL);

    if(NULL==(pAE_General_Info->hCompleteEvent))
        goto ret;

    //spawn a thread
    pAE_General_Info->hThread = CreateThread(NULL,
                            0,
                            AEInteractiveThreadProc,
                            pAE_General_Info,
                            CREATE_SUSPENDED,   //suspend execution
                            &dwThreadID);
    
    if(NULL==(pAE_General_Info->hThread))
        goto ret;

    //create the dialogue
    DialogBoxParam(
            g_hmodThisDll,
            MAKEINTRESOURCE(IDD_USER_AUTOENROLL_GENERAL_DLG),
            pAE_General_Info->hwndParent,      
            progressDlgProc,
            (LPARAM)(pAE_General_Info));

    //wait for thread to finish
    if(WAIT_FAILED == WaitForSingleObject(pAE_General_Info->hThread, INFINITE))
        goto ret;

    fResult=TRUE;

ret:

    //log the event
    if(!fResult)
    {
         AELogAutoEnrollmentEvent(
            pAE_General_Info->dwLogLevel,
            TRUE, 
            HRESULT_FROM_WIN32(GetLastError()), 
            EVENT_FAIL_INTERACTIVE_START, 
            pAE_General_Info->fMachine, 
            pAE_General_Info->hToken, 
            0);
    }


    return fResult;
}

//-----------------------------------------------------------------------------
//
//  WinProc for the confirmation to start certificate autoenrollment
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK AEConfirmDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg) 
    {
        case WM_INITDIALOG:

                return TRUE;
            break;

        case WM_NOTIFY:
            break;

        case WM_CLOSE:
                EndDialog(hwndDlg, IDC_BUTTON2);
                return TRUE;
            break;

        case WM_COMMAND:
                switch (LOWORD(wParam))
                {
                    case IDC_BUTTON1:
                        EndDialog(hwndDlg, IDC_BUTTON1);
                        return TRUE;

                    case IDC_BUTTON2:
                        EndDialog(hwndDlg, IDC_BUTTON2);
                        return TRUE;
                }
            break;

        default:
                return FALSE;
    }

    return FALSE;
}                             

//-----------------------------------------------------------------------
//
//  AERegisterSysTrayApp 
//
//      This functin registers autoenrollment in the sys tray area
//  as an notification
//
//
//-----------------------------------------------------------------------
BOOL AERegisterSysTrayApp(HWND hwndParent)
{
    BOOL                        fResult=FALSE;
    BOOL                        fInit=FALSE;
    INT_PTR                     ret=0;
    DWORD                       dwError=0;

    CQueryContinue              *pCQueryContinue=NULL;


    if(FAILED(CoInitialize(NULL)))
	    goto Ret;

    fInit=TRUE;

    pCQueryContinue=new CQueryContinue();

    if(NULL==pCQueryContinue)
        goto Ret;

    if(S_OK != pCQueryContinue->DoBalloon())
        goto Ret;  

    //ask user if autoenrollment should be performed
    ret=DialogBox(g_hmodThisDll, 
                 (LPCWSTR)MAKEINTRESOURCE(IDD_USER_AUTOENROLL_INFO_DLG),
                 hwndParent, 
                 AEConfirmDlgProc);

    if(IDC_BUTTON1 != ret)
    {
        dwError=GetLastError();
        goto Ret;
    }
    
    fResult=TRUE;


Ret:

    if(pCQueryContinue)
    {
        delete pCQueryContinue;
    }

    if(fInit)
        CoUninitialize();

    return fResult;

}


//-----------------------------------------------------------------------
//
//  AEUIDisabled
//
//      Detect if the user notification balloon is disabled by user 
//  setting the autoenrollment registry key in current user
//
//
//-----------------------------------------------------------------------
BOOL    AEUIDisabled()
{
    BOOL    fResult=FALSE;
    
    HKEY    hKey=NULL;

    if(ERROR_SUCCESS == RegOpenKeyEx(
                HKEY_CURRENT_USER,                  // handle to open key
                AUTO_ENROLLMENT_DISABLE_KEY,        // subkey name
                0,                                  // reserved
                KEY_READ,                           // security access mask
                &hKey))                             // handle to open key
    {
        fResult=TRUE;
    }

    if(hKey)
        RegCloseKey(hKey);

    return fResult;
}

//-----------------------------------------------------------------------
//
//  AEUIRequired
//
//      Detect if the user notification balloon is needed
//
//
//-----------------------------------------------------------------------
BOOL    AEUIRequired(AE_GENERAL_INFO *pAE_General_Info)
{
    BOOL                fUI=FALSE;
    AE_CERTTYPE_INFO    *rgCertTypeInfo = NULL;
    DWORD               dwIndex = 0;

    if(NULL==pAE_General_Info)
        return FALSE;

    rgCertTypeInfo = pAE_General_Info->rgCertTypeInfo;

    pAE_General_Info->dwUIEnrollCount=0;

    if(NULL == rgCertTypeInfo)
        return FALSE;

    for(dwIndex=0; dwIndex < pAE_General_Info->dwCertType; dwIndex++)
    {
        if(rgCertTypeInfo[dwIndex].fUIActive)
        {
            if(CERT_REQUEST_STATUS_ACTIVE == rgCertTypeInfo[dwIndex].dwStatus)
            {
                fUI=TRUE;
                (pAE_General_Info->dwUIEnrollCount)++;
            }
        }
    }

    //add the pending count
    if(pAE_General_Info->dwUIPendCount)
    {
        fUI=TRUE;
        (pAE_General_Info->dwUIEnrollCount) +=(pAE_General_Info->dwUIPendCount); 
    }

    return fUI;  
}

                
//-----------------------------------------------------------------------
//
//  AEProcessEnrollment
//
//      This functin does the autoenrollment based on ACL and manage MY
//  store.
//
//
//-----------------------------------------------------------------------
BOOL  AEProcessEnrollment(HWND hwndParent, BOOL fMachine,   LDAP *pld, DWORD dwPolicy, DWORD dwLogLevel)
{
    BOOL                fResult=FALSE;

    AE_GENERAL_INFO     *pAE_General_Info=NULL;

    pAE_General_Info=(AE_GENERAL_INFO *)LocalAlloc(LPTR, sizeof(AE_GENERAL_INFO));

    if(NULL==pAE_General_Info)
        goto Ret;

    memset(pAE_General_Info, 0, sizeof(AE_GENERAL_INFO));

    if(NULL==pld)
        goto Ret;

    //we obtain all information needed for process enrollment
    pAE_General_Info->hwndParent = hwndParent;
    pAE_General_Info->pld = pld;
    pAE_General_Info->fMachine = fMachine;
    pAE_General_Info->dwPolicy = dwPolicy;
    pAE_General_Info->dwLogLevel = dwLogLevel;

    __try
    {

        if(!AERetrieveGeneralInfo(pAE_General_Info))
        {
            AELogAutoEnrollmentEvent(dwLogLevel,
                                TRUE, 
                                HRESULT_FROM_WIN32(GetLastError()), 
                                EVENT_FAIL_GENERAL_INFOMATION, 
                                fMachine, 
                                pAE_General_Info->hToken,
                                0);
            goto Ret;
        }

        if((0 == pAE_General_Info->dwCertType) || (NULL==pAE_General_Info->rgCertTypeInfo))
        {
            AELogAutoEnrollmentEvent(dwLogLevel, FALSE, S_OK, 
                EVENT_NO_CERT_TEMPLATE, fMachine, pAE_General_Info->hToken,0);

            AE_DEBUG((AE_WARNING, L"No CertType's available for auto-enrollment\n\r"));
            goto Ret;
        }

        //we build the auto-enrollment requests based on the ACL on the DS
        if(AUTO_ENROLLMENT_ENABLE_TEMPLATE_CHECK & (pAE_General_Info->dwPolicy))
        {
            if(!AEMarkAutoenrollment(pAE_General_Info))
                goto Ret;
        }

        //we build the auto-enrollment requests based on the ARCS store
        //this is enabled by default and can only be disabled if autoenrollment is 
        //completely disabled
        if(!AEMarkAEObject(pAE_General_Info))
            goto Ret;

        //manage MY store.  Check if we already have required certificates
        //we should always check my store with different behavior based on
        //AUTO_ENROLLMENT_ENABLE_MY_STORE_MANAGEMENT flag
        if(!AEManageAndMarkMyStore(pAE_General_Info))
                goto Ret;

        //manage UserDS store for user autoenrollment 
        if(!fMachine)
        {
            if(!AECheckUserDSStore(pAE_General_Info))
                goto Ret;
        }

        //manage pending request store.  Remove expired pending requests 
        if(AUTO_ENROLLMENT_ENABLE_PENDING_FETCH & (pAE_General_Info->dwPolicy))
        {
            if(!AECheckPendingRequests(pAE_General_Info))
                goto Ret;
        }

        //get CA information
        if(!AERetrieveCAInfo(pAE_General_Info->pld,
                             pAE_General_Info->fMachine,
                             pAE_General_Info->hToken,
                             &(pAE_General_Info->dwCA), 
                             &(pAE_General_Info->rgCAInfo)))
        {

            AELogAutoEnrollmentEvent(dwLogLevel, TRUE, HRESULT_FROM_WIN32(GetLastError()), 
                EVENT_FAIL_CA_INFORMATION, fMachine, pAE_General_Info->hToken, 0);


            AE_DEBUG((AE_ERROR, L"Unable to retrieve CA information (%lx)\n\r", GetLastError()));

            goto Ret;
        }

        if((0 == pAE_General_Info->dwCA) || (NULL==pAE_General_Info->rgCAInfo))
        {
            //we do not have any CAs on the domain.  All we need to do is to archive

            //archive old certificate after the enrollment/renewal
            AEArchiveObsoleteCertificates(pAE_General_Info);

            AELogAutoEnrollmentEvent(dwLogLevel, FALSE, S_OK, 
                EVENT_NO_CA, fMachine, pAE_General_Info->hToken, 0);

            AE_DEBUG((AE_WARNING, L"No CA's available for auto-enrollment\n\r"));

            goto Ret;
        }

        //we check if active templates do have a CA that we can enroll for
        if(!AEManageActiveTemplates(pAE_General_Info))
            goto Ret;

        //perform autoenrollment as the background 
        pAE_General_Info->fUIProcess=FALSE;
        if(!AEEnrollmentWalker(pAE_General_Info))
            goto Ret;

        //perform autoenrollment as a sys tray application for user only
        if(FALSE == fMachine)
        {
            //test if the notification balloon is disabled
            if(!AEUIDisabled())
            {
                //test if the notification balloon is needed
                if(AEUIRequired(pAE_General_Info))
                {
                    //register the sys tray application
                    if(AERegisterSysTrayApp(pAE_General_Info->hwndParent))
                    {
                        //perform autoenrollment in interactive mode
                        AEInteractiveEnrollment(pAE_General_Info);
                    }
                }
            }
        }

        //archive old certificate after the enrollment/renewal
        if(!AEArchiveObsoleteCertificates(pAE_General_Info))
            goto Ret;

    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        goto Ret;
    }

    fResult=TRUE;

Ret:

    //free memory only if no thread is created
    if(pAE_General_Info)
    {
        AEFreeGeneralInfo(pAE_General_Info);
        LocalFree(pAE_General_Info);
    }

    return fResult;
    
}

//-----------------------------------------------------------------------
//
//  AEExpress
//
//      Detect if the user autoenrollment has the express key set.  If the 
//  Express key is set, user autoenrollment will not wait for machine 
//  autoenrollment to complete on root certificates download
//
//
//-----------------------------------------------------------------------
BOOL    AEExpress()
{
    BOOL    fResult=FALSE;
    
    HKEY    hKey=NULL;

    if(ERROR_SUCCESS == RegOpenKeyEx(
                HKEY_CURRENT_USER,                  // handle to open key
                AUTO_ENROLLMENT_EXPRESS_KEY,        // subkey name
                0,                                  // reserved
                KEY_READ,                           // security access mask
                &hKey))                             // handle to open key
    {
        fResult=TRUE;
    }

    if(hKey)
        RegCloseKey(hKey);

    return fResult;
}

//-----------------------------------------------------------------------
//
//  AEMainThreadProc
//
//      The background thread for non-blocking autoenrollment background
//  processing.
//
//-----------------------------------------------------------------------
DWORD WINAPI AEMainThreadProc(LPVOID lpParameter)
{
    HRESULT         hr=S_OK;
    BOOL            fMachine=FALSE;
    DWORD           dwPolicy=0;
    DWORD           dwLogLevel=STATUS_SEVERITY_ERROR;
    HWND            hwndParent=0;
    DWORD           dwStatus=0;
    LARGE_INTEGER   ftPreTimeStamp;
    LARGE_INTEGER   ftPostTimeStamp;
    BOOL            fNeedToSetupTimer=FALSE;

    LDAP            *pld = NULL;

    //get the system time stamp
    GetSystemTimeAsFileTime((LPFILETIME)&ftPreTimeStamp);

    //the two input parameters are not yet used
    if(NULL==lpParameter)
        goto CommonReturn;

    hwndParent = ((AE_MAIN_THREAD_INFO *)lpParameter)->hwndParent;
    dwStatus = ((AE_MAIN_THREAD_INFO *)lpParameter)->dwStatus;

    AE_DEBUG((AE_INFO, L"Beginning CertAutoEnrollment(%s).\n", (CERT_AUTO_ENROLLMENT_START_UP==dwStatus?L"START_UP":L"WAKE_UP")));

    //no autoenrollment in the safe boot mode
    //no autoenrollment if we are not in a domain
    if(AEInSafeBoot() || !AEIsDomainMember())
        goto CommonReturn;

    //we need to set up the timer
    fNeedToSetupTimer=TRUE;

    //detect if we are running under user or machine context
    if(!AEIsLocalSystem(&fMachine))
        goto CommonReturn;
    AE_DEBUG((AE_INFO, L"CertAutoEnrollment running as %s.\n", (fMachine?L"machine":L"user")));

    AESetWakeUpFlag(fMachine, TRUE);   
    
    //we wait for 70 seconds for user case to give enough time for 
    //machine autoenrollment to complete, which will download certificates
    //from the directory
    if(!fMachine)
    {
        if(!AEExpress())
        {
            Sleep(USER_AUTOENROLL_DELAY_FOR_MACHINE * 1000);
        }
    }

   //get the autoenrollment log level
    if(!AERetrieveLogLevel(fMachine, &dwLogLevel))
        goto CommonReturn;

    //log the autoenrollment start event
    AELogAutoEnrollmentEvent(dwLogLevel, FALSE, S_OK, EVENT_AUTOENROLL_START, fMachine, NULL, 0);

   //get the autoenrollment policy flag
    if(!AEGetPolicyFlag(fMachine, &dwPolicy))
        goto CommonReturn;

    //no need to do anything if autoenrollment is completely disabled
    if(AUTO_ENROLLMENT_DISABLE_ALL & dwPolicy)
        goto CommonReturn;


    //download NTAuth And Enterprise root store for machine 
    if(fMachine)
    {    
        //bind to the DS
        if(S_OK != (hr=AERobustLdapBind(&pld)))
        {
            SetLastError(hr);
            AELogAutoEnrollmentEvent(dwLogLevel, TRUE, hr, EVENT_FAIL_BIND_TO_DS, fMachine, NULL, 0);
            goto CommonReturn;
        }

        AEDownloadStore(pld);
    }

    //if we are required to do a WIN2K style autoenrollment, and the machine/user's
    //ACRS store is empty, just return as we done.
    if(0 == dwPolicy)
    {
        if(IsACRSStoreEmpty(fMachine))
            goto CommonReturn;
    }

    if(NULL==pld)
    {
        //bind to the DS
        if(S_OK != (hr=AERobustLdapBind(&pld)))
        {
            SetLastError(hr);
            AELogAutoEnrollmentEvent(dwLogLevel, TRUE, hr, EVENT_FAIL_BIND_TO_DS, fMachine, NULL, 0);
            goto CommonReturn;
        }
    }

    AEProcessEnrollment(hwndParent, fMachine, pld, dwPolicy, dwLogLevel);

CommonReturn:

    //get the system time
    GetSystemTimeAsFileTime((LPFILETIME)&ftPostTimeStamp);

    //set up the timer for next time
    if(TRUE == fNeedToSetupTimer)
    {
        // we will need to do this again in a few hours.
        AESetWakeUpTimer(fMachine, &ftPreTimeStamp, &ftPostTimeStamp);
    }

    if(pld)
        ldap_unbind(pld);

    if(lpParameter)
        LocalFree((HLOCAL)lpParameter);

    AELogAutoEnrollmentEvent(dwLogLevel, FALSE, S_OK, EVENT_AUTOENROLL_COMPLETE, fMachine, NULL, 0);

    return TRUE;
}

//--------------------------------------------------------------------------
//
//  CertAutoEnrollment
//
//      Function to perform autoenrollment actions.  It creates a working
//      thread and return immediately so that it is non-blocking.
//     
//      Parameters:
//          IN  hwndParent:     The parent window 
//          IN  dwStatus:       The status under which the function is called.  
//                              It can be one of the following:
//                              CERT_AUTO_ENROLLMENT_START_UP
//                              CERT_AUTO_ENROLLMENT_WAKE_UP
//
//--------------------------------------------------------------------------
HANDLE 
WINAPI
CertAutoEnrollment(IN HWND     hwndParent,
                   IN DWORD    dwStatus)
{
    DWORD                       dwThreadID=0;
                                //memory will be freed in the main thread
    AE_MAIN_THREAD_INFO         *pAE_Main_Thread_Info=NULL;     
        
    HANDLE                      hThread=NULL;

    pAE_Main_Thread_Info=(AE_MAIN_THREAD_INFO *)LocalAlloc(LPTR, sizeof(AE_MAIN_THREAD_INFO));
    if(NULL==pAE_Main_Thread_Info)
        return NULL;

    memset(pAE_Main_Thread_Info, 0, sizeof(AE_MAIN_THREAD_INFO));
    pAE_Main_Thread_Info->hwndParent=hwndParent;
    pAE_Main_Thread_Info->dwStatus=dwStatus;

    hThread = CreateThread(NULL,
                            0,
                            AEMainThreadProc,
                            pAE_Main_Thread_Info,
                            0,          //execute immediately
                            &dwThreadID);  

    //set the thread priority to low so that we will not compete with the shell
    SetThreadPriority(hThread,  THREAD_PRIORITY_BELOW_NORMAL);

    return hThread;
}

//--------------------------------------------------------------------
//
//  AERetrieveClientToken
//
//--------------------------------------------------------------------
BOOL    AERetrieveClientToken(HANDLE  *phToken)
{
    HRESULT         hr = S_OK;

    HANDLE          hHandle = NULL;
    HANDLE          hClientToken = NULL;

    hHandle = GetCurrentThread();
    if (NULL == hHandle)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {

        if (!OpenThreadToken(hHandle,
                             TOKEN_QUERY,
                             TRUE,  // open as self
                             &hClientToken))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            CloseHandle(hHandle);
            hHandle = NULL;
        }
    }

    if(hr != S_OK)
    {
        hHandle = GetCurrentProcess();
        if (NULL == hHandle)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        else
        {
            HANDLE hProcessToken = NULL;
            hr = S_OK;


            if (!OpenProcessToken(hHandle,
                                 TOKEN_DUPLICATE,
                                 &hProcessToken))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                CloseHandle(hHandle);
                hHandle = NULL;
            }
            else
            {
                if(!DuplicateToken(hProcessToken,
                               SecurityImpersonation,
                               &hClientToken))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    CloseHandle(hHandle);
                    hHandle = NULL;
                }
                CloseHandle(hProcessToken);
            }
        }
    }


    if(S_OK == hr)
        *phToken = hClientToken;

    if(hHandle)
        CloseHandle(hHandle);

    return (S_OK == hr);
}


//--------------------------------------------------------------------------
//
//  AEGetComputerName
//
//
//--------------------------------------------------------------------------
LPWSTR	AEGetComputerName(COMPUTER_NAME_FORMAT	NameType)
{
	DWORD	dwSize=0;

	LPWSTR	pwszName=NULL;

	if(!GetComputerNameEx(NameType, NULL, &dwSize))
	{
		if(ERROR_MORE_DATA != GetLastError())
			goto Ret;
	}
	else
	{
		//this is to work around a bug in cluster code that it returns TRUE
		//to retrive the size
		dwSize++;
	}

	pwszName=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * dwSize);
	if(NULL == pwszName)
		goto Ret;

	if(!GetComputerNameEx(NameType, pwszName, &dwSize))
	{
		LocalFree(pwszName);
		pwszName=NULL;
		goto Ret;
	}

Ret:

	return pwszName;
}

//--------------------------------------------------------------------------
//
//  AERetrieveGeneralInfo
//
//
//--------------------------------------------------------------------------
BOOL    AERetrieveGeneralInfo(AE_GENERAL_INFO *pAE_General_Info)
{
    BOOL                fResult = FALSE;
    DWORD               dwOpenStoreFlags = CERT_SYSTEM_STORE_CURRENT_USER;
    DWORD               cMachineName = MAX_COMPUTERNAME_LENGTH + 2;
	LONG	            dwResult = 0;

	SCARDCONTEXT		hSCContext=NULL;

    //get the client token
    if(pAE_General_Info->fMachine)
    {   
        if(!AENetLogonUser(NULL, NULL, NULL, &(pAE_General_Info->hToken)))
        {
            AE_DEBUG((AE_ERROR, L"Obtain local system's token (%lx)\n\r", GetLastError()));
            goto Ret;
        }
    }
    else
    {
        if(!AERetrieveClientToken(&(pAE_General_Info->hToken)))
            goto Ret;
    }

    //get the machine name
    if (!GetComputerNameW(pAE_General_Info->wszMachineName,
                          &cMachineName))
        goto Ret;

    if(pAE_General_Info->fMachine)
        dwOpenStoreFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;

    //open my store
    if (NULL == (pAE_General_Info->hMyStore = CertOpenStore(
                        CERT_STORE_PROV_SYSTEM_W, 
                        ENCODING_TYPE, 
                        NULL, 
                        dwOpenStoreFlags, 
                        MY_STORE)))
    {
        AE_DEBUG((AE_ERROR, L"Unable to open MY store (%lx)\n\r", GetLastError()));
        goto Ret;
    }

    if(!CertControlStore(pAE_General_Info->hMyStore, 
                        0, 
                        CERT_STORE_CTRL_AUTO_RESYNC, 
                        NULL))
    {
        AE_DEBUG((AE_ERROR, L"Unable configure MY store for auto-resync(%lx)\n\r", GetLastError()));
        goto Ret;
    }

    //open request store
    if (NULL == (pAE_General_Info->hRequestStore = CertOpenStore(
                        CERT_STORE_PROV_SYSTEM_W, 
                        ENCODING_TYPE, 
                        NULL, 
                        dwOpenStoreFlags, 
                        REQUEST_STORE)))
    {
        AE_DEBUG((AE_ERROR, L"Unable to open Request store (%lx)\n\r", GetLastError()));
        goto Ret;
    }

    //get CertType information
    if(!AERetrieveCertTypeInfo( pAE_General_Info->pld, 
                                pAE_General_Info->fMachine,
                                &(pAE_General_Info->dwCertType), 
                                &(pAE_General_Info->rgCertTypeInfo)))
    {
        AE_DEBUG((AE_ERROR, L"Unable to retrieve CertType information (%lx)\n\r", GetLastError()));
        goto Ret;
    }

    //load xenroll module.  No need to check errors since this is not a fatal error
    pAE_General_Info->hXenroll = LoadLibrary(L"xenroll.dll");


    //detect if the smart card subsystem if running for users only
    if(FALSE == pAE_General_Info->fMachine)
    {
        dwResult = SCardEstablishContext(
                        SCARD_SCOPE_USER,
                        NULL,
                        NULL,
                        &hSCContext );

        if((0 == dwResult) && (NULL != hSCContext))
            pAE_General_Info->fSmartcardSystem=TRUE;
    }

	//get the NetBIOS name and the DNS name of the computer.  This is different from
	//wszMachineName, since it will be the physicalNetBIOS name
	//No need to check errors since this is not a fatal error

	pAE_General_Info->pwszDns=AEGetComputerName(ComputerNameDnsFullyQualified);

	pAE_General_Info->pwszNetBIOS=AEGetComputerName(ComputerNameNetBIOS);

    fResult = TRUE;

Ret:

    if(hSCContext)
        SCardReleaseContext(hSCContext);

    if(FALSE == fResult)
        AEFreeGeneralInfo(pAE_General_Info);

    return fResult;
}


//--------------------------------------------------------------------------
//
//  AEFreeGeneralInfo
//
//
//--------------------------------------------------------------------------
BOOL    AEFreeGeneralInfo(AE_GENERAL_INFO *pAE_General_Info)
{
    if(pAE_General_Info)
    {
        if(pAE_General_Info->hToken)
            CloseHandle(pAE_General_Info->hToken);

        if(pAE_General_Info->hMyStore)
            CertCloseStore(pAE_General_Info->hMyStore, 0);

        if(pAE_General_Info->hRequestStore)
            CertCloseStore(pAE_General_Info->hRequestStore, 0);

        //free CA information
        AEFreeCAInfo(pAE_General_Info->dwCA, pAE_General_Info->rgCAInfo);

        //free CertType information
        AEFreeCertTypeInfo(pAE_General_Info->dwCertType, pAE_General_Info->rgCertTypeInfo);

        if(pAE_General_Info->hXenroll)
            FreeLibrary(pAE_General_Info->hXenroll);

        if(pAE_General_Info->hCancelEvent)
            CloseHandle(pAE_General_Info->hCancelEvent);

        if(pAE_General_Info->hCompleteEvent)
            CloseHandle(pAE_General_Info->hCompleteEvent);

        if(pAE_General_Info->hThread)
            CloseHandle(pAE_General_Info->hThread);

		if(pAE_General_Info->pwszDns)
			LocalFree(pAE_General_Info->pwszDns);

		if(pAE_General_Info->pwszNetBIOS)
			LocalFree(pAE_General_Info->pwszNetBIOS);

        memset(pAE_General_Info, 0, sizeof(AE_GENERAL_INFO));

    }

    return TRUE;
}


//--------------------------------------------------------------------------
//
//  AERetrieveCertTypeInfo
//
//--------------------------------------------------------------------------
BOOL    AERetrieveCertTypeInfo(LDAP *pld, BOOL fMachine, DWORD *pdwCertType, AE_CERTTYPE_INFO **prgCertType)
{
    BOOL                fResult=FALSE;
    DWORD               dwCount=0;
    DWORD               dwCertType=0;
    DWORD               dwIndex=0;
    HRESULT             hr=E_FAIL;

    HCERTTYPE           hCTCurrent = NULL;
    HCERTTYPE           hCTNew = NULL;
    AE_CERTTYPE_INFO    *rgCertTypeInfo=NULL;

    *pdwCertType=0;
    *prgCertType=NULL;

    if(S_OK != (hr = CAEnumCertTypesEx(
                (LPCWSTR)pld,
                fMachine?CT_ENUM_MACHINE_TYPES | CT_FIND_LOCAL_SYSTEM | CT_FLAG_SCOPE_IS_LDAP_HANDLE: CT_ENUM_USER_TYPES | CT_FLAG_SCOPE_IS_LDAP_HANDLE, 
                &hCTCurrent)))
    {
        SetLastError(hr);
        goto Ret;
    }

    if((NULL == hCTCurrent) || (0 == (dwCount = CACountCertTypes(hCTCurrent))))
    {
        AE_DEBUG((AE_WARNING, L"No CT's available for auto-enrollment\n\r"));
        fResult=TRUE;
        goto Ret;
    }

    rgCertTypeInfo=(AE_CERTTYPE_INFO *)LocalAlloc(LPTR, sizeof(AE_CERTTYPE_INFO) * dwCount);
    if(NULL==rgCertTypeInfo)
    {
        SetLastError(E_OUTOFMEMORY);
        goto Ret;
    }

    memset(rgCertTypeInfo, 0, sizeof(AE_CERTTYPE_INFO) * dwCount);

    for(dwIndex = 0; dwIndex < dwCount; dwIndex++ )       
    {

        //check if we have a new certificate template
        if(dwIndex > 0)
        {
            hr = CAEnumNextCertType(hCTCurrent, &hCTNew);

            if((S_OK != hr) || (NULL == hCTNew))
            {
                // Clean up from previous calls
                if(dwCertType < dwCount)
                    AEFreeCertTypeStruct(&(rgCertTypeInfo[dwCertType]));

                break;
            }

            hCTCurrent = hCTNew; 
        }

        // Clean up from previous calls
        AEFreeCertTypeStruct(&(rgCertTypeInfo[dwCertType]));

        //copy the new CertType' data
        //hCertType
        rgCertTypeInfo[dwCertType].hCertType = hCTCurrent;

        //CTName
        hr = CAGetCertTypePropertyEx(
                             hCTCurrent, 
                             CERTTYPE_PROP_DN,
                             &(rgCertTypeInfo[dwCertType].awszName));

        if((S_OK != hr) ||
           (NULL == rgCertTypeInfo[dwCertType].awszName) || 
           (NULL == (rgCertTypeInfo[dwCertType].awszName)[0])
          )
        {
            AE_DEBUG((AE_INFO, L"No name property for CertType\n\r"));
            continue;
        }
    
        //FriendlyName
        hr = CAGetCertTypePropertyEx(
                             hCTCurrent, 
                             CERTTYPE_PROP_FRIENDLY_NAME,
                             &(rgCertTypeInfo[dwCertType].awszDisplay));
        if((S_OK != hr) ||
           (NULL == rgCertTypeInfo[dwCertType].awszDisplay) || 
           (NULL == (rgCertTypeInfo[dwCertType].awszDisplay)[0])
          )
        {
            AE_DEBUG((AE_INFO, L"No display property for CertType\n\r"));

            //get the DN as the display name
            hr = CAGetCertTypePropertyEx(
                                 hCTCurrent, 
                                 CERTTYPE_PROP_DN,
                                 &(rgCertTypeInfo[dwCertType].awszDisplay));
            if((S_OK != hr) ||
               (NULL == rgCertTypeInfo[dwCertType].awszDisplay) || 
               (NULL == (rgCertTypeInfo[dwCertType].awszDisplay)[0])
              )
            {
                AE_DEBUG((AE_INFO, L"No name property for CertType\n\r"));
                continue;
            }
        }

        //dwSchemaVersion
        hr = CAGetCertTypePropertyEx(
                             hCTCurrent, 
                             CERTTYPE_PROP_SCHEMA_VERSION,
                             &(rgCertTypeInfo[dwCertType].dwSchemaVersion));

        if(hr != S_OK)
        {
            AE_DEBUG((AE_INFO, L"No schema version for CT %ls\n\r", (rgCertTypeInfo[dwCertType].awszName)[0]));
            continue;
        }

        //dwVersion
        hr = CAGetCertTypePropertyEx(
                             hCTCurrent, 
                             CERTTYPE_PROP_REVISION,
                             &(rgCertTypeInfo[dwCertType].dwVersion));

        if(hr != S_OK)
        {
            AE_DEBUG((AE_INFO, L"No major version for CT %ls\n\r", (rgCertTypeInfo[dwCertType].awszName)[0]));
            continue;
        }

        //dwEnrollmentFlag
        hr = CAGetCertTypeFlagsEx(
                            hCTCurrent,
                            CERTTYPE_ENROLLMENT_FLAG,
                            &(rgCertTypeInfo[dwCertType].dwEnrollmentFlag));

        if(hr != S_OK)
        {
            AE_DEBUG((AE_INFO, L"No enrollment flag for CT %ls\n\r", (rgCertTypeInfo[dwCertType].awszName)[0]));
            continue;
        }

        //dwPrivatekeyFlag
        hr = CAGetCertTypeFlagsEx(
                            hCTCurrent,
                            CERTTYPE_PRIVATE_KEY_FLAG,
                            &(rgCertTypeInfo[dwCertType].dwPrivateKeyFlag));

        if(hr != S_OK)
        {
            AE_DEBUG((AE_INFO, L"No private key flag for CT %ls\n\r", (rgCertTypeInfo[dwCertType].awszName)[0]));
            continue;
        }

        //expiration offset
        hr = CAGetCertTypeExpiration(
                            hCTCurrent,
                            NULL,
                            (LPFILETIME)&(rgCertTypeInfo[dwCertType].ftExpirationOffset));

        //we might not get the expiration date
        if(hr != S_OK)
        {
            AE_DEBUG((AE_WARNING, L"Could not get cert type expirations: %ls\n\r", (rgCertTypeInfo[dwCertType].awszName)[0]));
        }

        //oid
        hr = CAGetCertTypePropertyEx(
                             hCTCurrent, 
                             CERTTYPE_PROP_OID,
                             &(rgCertTypeInfo[dwCertType].awszOID));

        //we might not get the oid property
        if(rgCertTypeInfo[dwCertType].dwSchemaVersion >= CERTTYPE_SCHEMA_VERSION_2)
        {
            if((S_OK != hr) ||
               (NULL == rgCertTypeInfo[dwCertType].awszOID) || 
               (NULL == (rgCertTypeInfo[dwCertType].awszOID)[0])
              )
            {
                AE_DEBUG((AE_INFO, L"No oid for CT %ls\n\r", (rgCertTypeInfo[dwCertType].awszName)[0]));
                continue;
            }
        }


        //supersede
        hr = CAGetCertTypePropertyEx(
                             hCTCurrent, 
                             CERTTYPE_PROP_SUPERSEDE,
                             &(rgCertTypeInfo[dwCertType].awszSupersede));

        //we might not get the supersede property
        if(hr != S_OK)
        {
            AE_DEBUG((AE_INFO, L"No supersede for CT %ls\n\r", (rgCertTypeInfo[dwCertType].awszName)[0]));
        }

        //hArchiveStore
        if(NULL == (rgCertTypeInfo[dwCertType].hArchiveStore=CertOpenStore(
                        CERT_STORE_PROV_MEMORY,
                        ENCODING_TYPE,
                        NULL,
                        0,
                        NULL)))

        {
            AE_DEBUG((AE_INFO, L"Unable to open archive cert store for CT %ls\n\r", (rgCertTypeInfo[dwCertType].awszName)[0]));
            continue;
        }

        //hObtainedStore
        if(NULL == (rgCertTypeInfo[dwCertType].hObtainedStore=CertOpenStore(
                        CERT_STORE_PROV_MEMORY,
                        ENCODING_TYPE,
                        NULL,
                        0,
                        NULL)))

        {
            AE_DEBUG((AE_INFO, L"Unable to open obtained cert store for CT %ls\n\r", (rgCertTypeInfo[dwCertType].awszName)[0]));
            continue;
        }

        //hIssuedStore
        if(NULL == (rgCertTypeInfo[dwCertType].hIssuedStore=CertOpenStore(
                        CERT_STORE_PROV_MEMORY,
                        ENCODING_TYPE,
                        NULL,
                        0,
                        NULL)))

        {
            AE_DEBUG((AE_INFO, L"Unable to open issued cert store for CT %ls\n\r", (rgCertTypeInfo[dwCertType].awszName)[0]));
            continue;
        }

        //allocate memory
        rgCertTypeInfo[dwCertType].prgActive=(DWORD *)LocalAlloc(LPTR, sizeof(DWORD) * dwCount);
        if(NULL == rgCertTypeInfo[dwCertType].prgActive)
        {
            AE_DEBUG((AE_INFO, L"Unable to allocate memory for CT %ls\n\r", (rgCertTypeInfo[dwCertType].awszName)[0]));
            continue;
        }

        memset(rgCertTypeInfo[dwCertType].prgActive, 0, sizeof(DWORD) * dwCount);

        dwCertType++;
    }

    *pdwCertType=dwCertType;
    *prgCertType=rgCertTypeInfo;

    fResult = TRUE;

Ret:

    return fResult;
}

//--------------------------------------------------------------------------
//
//  AEFreeCertTypeInfo
//
//
//--------------------------------------------------------------------------
BOOL    AEFreeCertTypeInfo(DWORD dwCertType, AE_CERTTYPE_INFO *rgCertTypeInfo)
{
    DWORD   dwIndex=0;
    
    if(rgCertTypeInfo)
    {
        for(dwIndex=0; dwIndex < dwCertType; dwIndex++)
            AEFreeCertTypeStruct(&(rgCertTypeInfo[dwIndex]));        

        LocalFree(rgCertTypeInfo);
    }
    
    return TRUE;
}


//--------------------------------------------------------------------------
//
//  AEFreeCertTypeStruct
//
//
//--------------------------------------------------------------------------
BOOL    AEFreeCertTypeStruct(AE_CERTTYPE_INFO *pCertTypeInfo)
{
    DWORD   dwIndex=0;

    if(pCertTypeInfo)
    {
        if(pCertTypeInfo->hCertType)
        {
            if(pCertTypeInfo->awszName)
                CAFreeCertTypeProperty(pCertTypeInfo->hCertType, pCertTypeInfo->awszName);

            if(pCertTypeInfo->awszDisplay)
                CAFreeCertTypeProperty(pCertTypeInfo->hCertType, pCertTypeInfo->awszDisplay);

            if(pCertTypeInfo->awszOID)
                CAFreeCertTypeProperty(pCertTypeInfo->hCertType, pCertTypeInfo->awszOID);
    
            if(pCertTypeInfo->awszSupersede)
                CAFreeCertTypeProperty(pCertTypeInfo->hCertType, pCertTypeInfo->awszSupersede);

            CACloseCertType(pCertTypeInfo->hCertType);
        }

        if(pCertTypeInfo->prgActive)
            LocalFree(pCertTypeInfo->prgActive);

        if(pCertTypeInfo->pOldCert)
            CertFreeCertificateContext(pCertTypeInfo->pOldCert);

        if(pCertTypeInfo->hArchiveStore)
            CertCloseStore(pCertTypeInfo->hArchiveStore, 0);

        if(pCertTypeInfo->hObtainedStore)
            CertCloseStore(pCertTypeInfo->hObtainedStore, 0);

        if(pCertTypeInfo->hIssuedStore)
            CertCloseStore(pCertTypeInfo->hIssuedStore, 0);

        if(pCertTypeInfo->dwPendCount)
        {
            if(pCertTypeInfo->rgPendInfo)
            {
                for(dwIndex=0; dwIndex < pCertTypeInfo->dwPendCount; dwIndex++)
                {
                    if((pCertTypeInfo->rgPendInfo[dwIndex]).blobPKCS7.pbData)
                        LocalFree((pCertTypeInfo->rgPendInfo[dwIndex]).blobPKCS7.pbData);

                    if((pCertTypeInfo->rgPendInfo[dwIndex]).blobHash.pbData)
                        LocalFree((pCertTypeInfo->rgPendInfo[dwIndex]).blobHash.pbData);
                }

                LocalFree(pCertTypeInfo->rgPendInfo);
            }
        }

        memset(pCertTypeInfo, 0, sizeof(AE_CERTTYPE_INFO));
    }

    return TRUE;
}

//--------------------------------------------------------------------------
//
//  AERetrieveCAInfo
//
//
//--------------------------------------------------------------------------
BOOL    AERetrieveCAInfo(LDAP *pld, BOOL fMachine, HANDLE hToken, DWORD *pdwCA, AE_CA_INFO **prgCAInfo)
{
    BOOL                fResult = FALSE;
    DWORD               dwCount=0;
    DWORD               dwCA=0;
    DWORD               dwIndex=0;
    HRESULT             hr=E_FAIL;

    HCAINFO             hCACurrent = NULL;
    HCAINFO             hCANew = NULL;
    AE_CA_INFO          *rgCAInfo=NULL;

    *pdwCA=0;
    *prgCAInfo=NULL;

    if(S_OK != (hr = CAEnumFirstCA(
                        (LPCWSTR)pld, 
                        CA_FLAG_SCOPE_IS_LDAP_HANDLE | (fMachine?CA_FIND_LOCAL_SYSTEM:0), 
                        &hCACurrent)))
    {
        SetLastError(hr);
        goto Ret;
    }

    if((NULL == hCACurrent) || (0 == (dwCount = CACountCAs(hCACurrent))))
    {
        AE_DEBUG((AE_WARNING, L"No CA's available for auto-enrollment\n\r"));
        fResult=TRUE;
        goto Ret;
    }

    rgCAInfo=(AE_CA_INFO *)LocalAlloc(LPTR, sizeof(AE_CA_INFO) * dwCount);
    if(NULL==rgCAInfo)
    {
        SetLastError(E_OUTOFMEMORY);
        goto Ret;
    }

    memset(rgCAInfo, 0, sizeof(AE_CA_INFO) * dwCount);

    for(dwIndex = 0; dwIndex < dwCount; dwIndex++ )       
    {

        //check if we have a new CA
        if(dwIndex > 0)
        {
            hr = CAEnumNextCA(hCACurrent, &hCANew);

            if((S_OK != hr) || (NULL == hCANew))
            {
                // Clean up from previous calls
                if(dwCA < dwCount)
                    AEFreeCAStruct(&(rgCAInfo[dwCA]));

                break;
            }

            hCACurrent = hCANew; 
        }

        // Clean up from previous calls
        AEFreeCAStruct(&(rgCAInfo[dwCA]));

        //copy the new CA' data
        //hCAInfo
        rgCAInfo[dwCA].hCAInfo = hCACurrent;

        //CAName
        hr = CAGetCAProperty(hCACurrent, 
                             CA_PROP_NAME,
                             &(rgCAInfo[dwCA].awszCAName));

        if((S_OK != hr) ||
           (NULL == rgCAInfo[dwCA].awszCAName) || 
           (NULL == (rgCAInfo[dwCA].awszCAName)[0])
          )
        {
            AE_DEBUG((AE_INFO, L"No name property for ca\n\r"));
            continue;
        }

        //access check
        if(S_OK != CAAccessCheckEx(rgCAInfo[dwCA].hCAInfo, hToken, CERTTYPE_ACCESS_CHECK_ENROLL | CERTTYPE_ACCESS_CHECK_NO_MAPPING))
        {
            AE_DEBUG((AE_INFO, L"No access for CA %ls\n\r", (rgCAInfo[dwCA].awszCAName)[0]));
            continue;
        }

        //CA Display
        hr = CAGetCAProperty(hCACurrent, 
                             CA_PROP_DISPLAY_NAME,
                             &(rgCAInfo[dwCA].awszCADisplay));

        if((S_OK != hr) ||
           (NULL == rgCAInfo[dwCA].awszCADisplay) || 
           (NULL == (rgCAInfo[dwCA].awszCADisplay)[0])
          )
        {
            AE_DEBUG((AE_INFO, L"No display name property for ca\n\r"));

            hr = CAGetCAProperty(hCACurrent, 
                                 CA_PROP_NAME,
                                 &(rgCAInfo[dwCA].awszCADisplay));

            if((S_OK != hr) ||
               (NULL == rgCAInfo[dwCA].awszCADisplay) || 
               (NULL == (rgCAInfo[dwCA].awszCADisplay)[0])
              )
            {
                AE_DEBUG((AE_INFO, L"No name property for ca\n\r"));
                continue;
            }
        }

        //CADNS
        hr = CAGetCAProperty(hCACurrent, 
                             CA_PROP_DNSNAME,
                             &(rgCAInfo[dwCA].awszCADNS));

        if((S_OK != hr) ||
           (NULL == rgCAInfo[dwCA].awszCADNS) || 
           (NULL == (rgCAInfo[dwCA].awszCADNS)[0])
          )
        {
            AE_DEBUG((AE_INFO, L"No DNS property for CA %ls\n\r", (rgCAInfo[dwCA].awszCAName)[0]));
            continue;
        }

        //CACertificateTemplate
        hr = CAGetCAProperty(hCACurrent, 
                             CA_PROP_CERT_TYPES,
                             &(rgCAInfo[dwCA].awszCertificateTemplate));

        if((S_OK != hr) ||
           (NULL == rgCAInfo[dwCA].awszCertificateTemplate) || 
           (NULL == (rgCAInfo[dwCA].awszCertificateTemplate)[0])
          )
        {
            AE_DEBUG((AE_INFO, L"No CertType property for CA %ls\n\r", (rgCAInfo[dwCA].awszCAName)[0]));
            continue;
        }

        dwCA++;
    }

    *pdwCA=dwCA;
    *prgCAInfo=rgCAInfo;

    fResult = TRUE;

Ret:

    return fResult;
}

//--------------------------------------------------------------------------
//
//  AEFreeCAInfo
//
//
//--------------------------------------------------------------------------
BOOL    AEFreeCAInfo(DWORD dwCA, AE_CA_INFO *rgCAInfo)
{
    DWORD   dwIndex=0;

    if(rgCAInfo)
    {
        for(dwIndex=0; dwIndex < dwCA; dwIndex++)
            AEFreeCAStruct(&(rgCAInfo[dwIndex]));

        LocalFree(rgCAInfo);
    }

    return TRUE;
}


//--------------------------------------------------------------------------
//
//  AEFreeCAStruct
//
//
//--------------------------------------------------------------------------
BOOL    AEFreeCAStruct(AE_CA_INFO *pCAInfo)
{
    if(pCAInfo)
    {
        if(pCAInfo->hCAInfo)
        {
            if(pCAInfo->awszCAName)
            {
                CAFreeCAProperty(pCAInfo->hCAInfo,pCAInfo->awszCAName);       
            }
            if(pCAInfo->awszCADisplay)
            {
                CAFreeCAProperty(pCAInfo->hCAInfo,pCAInfo->awszCADisplay);       
            }
            if(pCAInfo->awszCADNS)
            {
                CAFreeCAProperty(pCAInfo->hCAInfo, pCAInfo->awszCADNS);       
            }
            if(pCAInfo->awszCertificateTemplate)
            {
                CAFreeCAProperty(pCAInfo->hCAInfo,pCAInfo->awszCertificateTemplate);
            }

            CACloseCA(pCAInfo->hCAInfo);
        }

        memset(pCAInfo, 0, sizeof(AE_CA_INFO));
    }

    return TRUE;
}

//--------------------------------------------------------------------------
//
//  AEClearVistedFlag
//
//--------------------------------------------------------------------------
BOOL    AEClearVistedFlag(AE_GENERAL_INFO *pAE_General_Info)
{   
    DWORD       dwIndex=0;

    if(pAE_General_Info)
    {
       if(pAE_General_Info->rgCertTypeInfo)
       {
            for(dwIndex=0; dwIndex < pAE_General_Info->dwCertType; dwIndex++)
            {
                (pAE_General_Info->rgCertTypeInfo)[dwIndex].fSupersedeVisited=FALSE;
            }
       }
    }

    return TRUE;
}
//--------------------------------------------------------------------------
//
//  AEIfSupersede
//
//      Recursively find if pwsz is superseded by one of the template in awsz.
//      Notice that we should not loop in the superseding relationship.
//      Superseding tree should be one directional tree without duplicated nodes.
//
//--------------------------------------------------------------------------
BOOL  AEIfSupersede(LPWSTR  pwsz, LPWSTR *awsz, AE_GENERAL_INFO *pAE_General_Info)
{
    BOOL                    fResult = FALSE;
    LPWSTR                  *pwszArray = awsz;
    AE_TEMPLATE_INFO        AETemplateInfo;
    AE_CERTTYPE_INFO        *pCertType = NULL;

    LPWSTR                  *awszSupersede=NULL;

    if((NULL==pwsz) || (NULL==awsz))
        return FALSE;

    while(*pwszArray)
    {
        if(0 == wcscmp(pwsz, *pwszArray))
        {
            fResult = TRUE;
            break;
        }

        //find the template
        memset(&AETemplateInfo, 0, sizeof(AE_TEMPLATE_INFO));

        AETemplateInfo.pwszName=*pwszArray;

        pCertType = AEFindTemplateInRequestTree(
                        &AETemplateInfo,
                        pAE_General_Info);

        if(pCertType)
        {
            if(!(pCertType->fSupersedeVisited))
            {
                //mark that we have visited superseding relationship for this template
                pCertType->fSupersedeVisited=TRUE;

                if(S_OK == CAGetCertTypePropertyEx(
                             pCertType->hCertType, 
                             CERTTYPE_PROP_SUPERSEDE,
                             &(awszSupersede)))
                {
                    fResult = AEIfSupersede(pwsz, awszSupersede, pAE_General_Info);

                    if(awszSupersede)
                        CAFreeCertTypeProperty(
                            pCertType->hCertType,
                            awszSupersede);

                    awszSupersede=NULL;
                
                    if(TRUE == fResult)
                        break;
                }
            }
        }

        pwszArray++;
    }

    return fResult;
}

//--------------------------------------------------------------------------
//
//  AEIsAnElement
//
//
//--------------------------------------------------------------------------
BOOL    AEIsAnElement(LPWSTR   pwsz, LPWSTR *awsz)
{
    BOOL                    fResult = FALSE;
    LPWSTR                  *pwszArray = awsz;
    
    if((NULL==pwsz) || (NULL==awsz))
        return FALSE;

    while(*pwszArray)
    {
        if(0 == wcscmp(pwsz, *pwszArray))
        {
            fResult = TRUE;
            break;
        }
    
        pwszArray++;
    }

    return fResult;
}
                          
//--------------------------------------------------------------------------
//
//  AECopyCertStore
//
//
//--------------------------------------------------------------------------
BOOL AECopyCertStore(HCERTSTORE     hSrcStore,
                     HCERTSTORE     hDesStore)
{
    PCCERT_CONTEXT  pCertContext=NULL;

    if((NULL==hSrcStore) || (NULL==hDesStore))
        return FALSE;

    while(pCertContext = CertEnumCertificatesInStore(hSrcStore, pCertContext))
    {
        CertAddCertificateContextToStore(hDesStore,
                                     pCertContext,
                                     CERT_STORE_ADD_USE_EXISTING,
                                     NULL);
    }

    return TRUE;
}


//--------------------------------------------------------------------------
//
//  AEIsEmptyStore
//
//
//--------------------------------------------------------------------------
BOOL AEIsEmptyStore(HCERTSTORE     hCertStore)
{
    PCCERT_CONTEXT  pCertContext=NULL;

    if(NULL == hCertStore)
        return TRUE;

    if(pCertContext = CertEnumCertificatesInStore(hCertStore, pCertContext))
    {
		CertFreeCertificateContext(pCertContext);
		return FALSE;
    }

    return TRUE;
}


//--------------------------------------------------------------------------
//
//  AEGetConfigDN
//
//
//--------------------------------------------------------------------------
HRESULT 
AEGetConfigDN(
    IN  LDAP *pld,
    OUT LPWSTR *pwszConfigDn
    )
{

    HRESULT         hr;
    ULONG           LdapError;

    LDAPMessage  *SearchResult = NULL;
    LDAPMessage  *Entry = NULL;
    WCHAR        *Attr = NULL;
    BerElement   *BerElement;
    WCHAR        **Values = NULL;

    WCHAR  *AttrArray[3];
    struct l_timeval        timeout;

    WCHAR  *ConfigurationNamingContext = L"configurationNamingContext";
    WCHAR  *ObjectClassFilter          = L"objectCategory=*";

    //
    // Set the out parameters to null
    //
    if(pwszConfigDn)
    {
        *pwszConfigDn = NULL;
    }

    timeout.tv_sec = 300;
    timeout.tv_usec = 0;
    //
    // Query for the ldap server oerational attributes to obtain the default
    // naming context.
    //
    AttrArray[0] = ConfigurationNamingContext;
    AttrArray[1] = NULL;  // this is the sentinel

    LdapError = ldap_search_ext_s(pld,
                               NULL,
                               LDAP_SCOPE_BASE,
                               ObjectClassFilter,
                               AttrArray,
                               FALSE,
                               NULL,
                               NULL,
                               &timeout,
                               10000,
                               &SearchResult);

    hr = HRESULT_FROM_WIN32(LdapMapErrorToWin32(LdapError));

    if (S_OK == hr) 
    {

        Entry = ldap_first_entry(pld, SearchResult);

        if (Entry) 
        {

            Values = ldap_get_values(pld, 
                                        Entry, 
                                        ConfigurationNamingContext);

            if (Values && Values[0]) 
            {
                (*pwszConfigDn) = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(Values[0])+1));

                if(NULL==(*pwszConfigDn))
                    hr=E_OUTOFMEMORY;
                else
                    wcscpy((*pwszConfigDn), Values[0]);
            }

            ldap_value_free(Values);
        }

        if (pwszConfigDn && (!(*pwszConfigDn))) 
        {
            // We could not get the default domain or out of memory - bail out
            if(E_OUTOFMEMORY != hr)
                hr =  HRESULT_FROM_WIN32(ERROR_CANT_ACCESS_DOMAIN_INFO);
        }

        if(SearchResult)
        {
            ldap_msgfree(SearchResult);
        }
    }

    return hr;
}

//--------------------------------------------------------------------------
//
//  AERobustLdapBind
//
//--------------------------------------------------------------------------
HRESULT 
AERobustLdapBind(
    OUT LDAP ** ppldap)
{
    HRESULT             hr = S_OK;
    BOOL                fForceRediscovery = FALSE;
    DWORD               dwDSNameFlags= DS_RETURN_DNS_NAME | DS_BACKGROUND_ONLY;
    LDAP                *pld = NULL;
    ULONG               ulOptions = 0;
    ULONG               ldaperr=LDAP_SERVER_DOWN;

    do {

        if(fForceRediscovery)
        {
           dwDSNameFlags |= DS_FORCE_REDISCOVERY;
        }

        ldaperr = LDAP_SERVER_DOWN;

		if(NULL != pld)
		{
			ldap_unbind(pld);
			pld=NULL;
		}

        // bind to ds
        if((pld = ldap_initW(NULL, LDAP_PORT)) == NULL)
        {
            ldaperr = LdapGetLastError();
        }
        else
        {                         
			ldaperr = ldap_set_option(pld, LDAP_OPT_GETDSNAME_FLAGS, (VOID *)&dwDSNameFlags);

			if(LDAP_SUCCESS == ldaperr)
			{
				ldaperr = ldap_set_option(pld, LDAP_OPT_SIGN, LDAP_OPT_ON);

				if (LDAP_SUCCESS == ldaperr)
				{
					ldaperr = ldap_bind_sW(pld, NULL, NULL, LDAP_AUTH_NEGOTIATE);
				}
			}
        }

        hr = HRESULT_FROM_WIN32(LdapMapErrorToWin32(ldaperr));

        if(fForceRediscovery)
        {
            break;
        }

        fForceRediscovery = TRUE;

    } while(ldaperr == LDAP_SERVER_DOWN);


    if(S_OK != hr)
        goto error;

    *ppldap = pld;
    pld = NULL;

    hr=S_OK;

error:

    if(pld)
    {
        ldap_unbind(pld);
    }

    return hr;
}

//---------------------------------------------------------------------------
//
//  AEAllocAndCopy
//
//---------------------------------------------------------------------------
BOOL AEAllocAndCopy(LPWSTR    pwszSrc, LPWSTR    *ppwszDest)
{
    if((NULL==ppwszDest) || (NULL==pwszSrc))
    {
        SetLastError(E_INVALIDARG);
        return FALSE;
    }

    *ppwszDest=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (wcslen(pwszSrc) + 1));
    if(NULL==(*ppwszDest))
    {
        SetLastError(E_OUTOFMEMORY);
        return FALSE;
    }

    wcscpy(*ppwszDest, pwszSrc);

    return TRUE;
}


//--------------------------------------------------------------------------
// Name:    AELogAutoEnrollmentEvent
//
// Description: This function registers an event in the event log of the
//              local machine.  Takes an optional argument list.
//
//--------------------------------------------------------------------------
void AELogAutoEnrollmentEvent(IN DWORD    dwLogLevel,
                            IN BOOL     fError,
                            IN HRESULT  hr,
                            IN DWORD    dwEventId,
                            IN BOOL     fMachine,
                            IN HANDLE   hToken,
                            IN DWORD    dwParamCount,
                            ...
                            )
{
    BYTE        FastBuffer[MAX_DN_SIZE];
    DWORD       cbUser =0;
    BOOL        fAlloced = FALSE;
    PSID        pSID = NULL;
    WORD        dwEventType = 0;
    LPWSTR      awszStrings[PENDING_ALLOC_SIZE + 3];
    WORD        cStrings = 0;
    LPWSTR      wszString = NULL;
	WCHAR       wszMsg[MAX_DN_SIZE];
    WCHAR       wszUser[MAX_DN_SIZE];
    DWORD       dwIndex=0;
    DWORD       dwSize=0;

    HANDLE      hEventSource = NULL;  
    LPWSTR      wszHR=NULL;
    PTOKEN_USER ptgUser = NULL;


    va_list     ArgList;


    //check the log level; log errors and success by default
    if(((dwEventId >> 30) < dwLogLevel) && ((dwEventId >> 30) != STATUS_SEVERITY_SUCCESS))
        return;

    if(NULL==(hEventSource = RegisterEventSourceW(NULL, EVENT_AUTO_NAME)))
        return;

    //copy the user/machine string
    wszUser[0]=L'\0';

    //use the user name for user case
    if(FALSE == fMachine)
    {
        dwSize=MAX_DN_SIZE;

        if(!GetUserNameEx(
                NameSamCompatible,      // name format
                wszUser,                // name buffer
                &dwSize))               // size of name buffer
        {
            LoadStringW(g_hmodThisDll, IDS_USER, wszUser, MAX_DN_SIZE);
        }
    }
    else
    {
        LoadStringW(g_hmodThisDll, IDS_MACHINE, wszUser, MAX_DN_SIZE);
    }

    awszStrings[cStrings++] = wszUser;

    //copy the variable strings if present
    va_start(ArgList, dwParamCount);

    for(dwIndex=0; dwIndex < dwParamCount; dwIndex++)
    {
        wszString = va_arg(ArgList, LPWSTR);

        awszStrings[cStrings++] = wszString;

        if(cStrings >= PENDING_ALLOC_SIZE)
        {
            break;
        }
    }

    va_end(ArgList);

    //copy the hr error code
    if(fError)
    {
        
        if(S_OK == hr)
            hr=E_FAIL;

	wsprintfW(wszMsg, L"0x%lx", hr);        
        awszStrings[cStrings++] = wszMsg;


        if(0 != FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL,
                    hr,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                    (WCHAR *)&wszHR,
                    0,
                    NULL))
        {
            if(wszHR)
			{
                awszStrings[cStrings++] = wszHR;
			}
			else
			{
				awszStrings[cStrings++]=L" ";
			}
        }
		else
		{
			//provide an empty event log so that there will be no insertion strings
			awszStrings[cStrings++]=L" ";
		}
    }

    // check if the token is non zero is so then impersonating so get the SID
    if((FALSE == fMachine) && (hToken))
    {
        ptgUser = (PTOKEN_USER)FastBuffer; // try fast buffer first
        cbUser = MAX_DN_SIZE;

        if (!GetTokenInformation(
                        hToken,    // identifies access token
                        TokenUser, // TokenUser info type
                        ptgUser,   // retrieved info buffer
                        cbUser,  // size of buffer passed-in
                        &cbUser  // required buffer size
                        ))
        {
            if(GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                if (NULL != (ptgUser = (PTOKEN_USER)LocalAlloc(LPTR, cbUser)))
                {
                    fAlloced = TRUE;

                    // get the user info and assign the sid if able to
                    if (GetTokenInformation(
                                    hToken,    // identifies access token
                                    TokenUser, // TokenUser info type
                                    ptgUser,   // retrieved info buffer
                                    cbUser,  // size of buffer passed-in
                                    &cbUser  // required buffer size
                                    ))
                    {
                        pSID = ptgUser->User.Sid;
                    }
                }
            }

        }
        else
        {
            // assign the sid when fast buffer worked
            pSID = ptgUser->User.Sid;
        }
    }


    switch(dwEventId >> 30)
    {
        case 0:
            dwEventType = EVENTLOG_SUCCESS;
        break;

        case 1:
            dwEventType = EVENTLOG_INFORMATION_TYPE;
        break;

        case 2:
            dwEventType = EVENTLOG_WARNING_TYPE;
        break;

        case 3:
            dwEventType = EVENTLOG_ERROR_TYPE;
        break;
    }

    ReportEventW(hEventSource,          // handle of event source
                 dwEventType,           // event type
                 0,                     // event category
                 dwEventId,             // event ID
                 pSID,                  // current user's SID
                 cStrings,              // strings in lpszStrings
                 0,                     // no bytes of raw data
                 (LPCWSTR*)awszStrings, // array of error strings
                 NULL                   // no raw data
                 );

    if (hEventSource)
        DeregisterEventSource(hEventSource);  

    if(fAlloced)
    {   
        if(ptgUser)
            LocalFree(ptgUser);
    }

    if(wszHR)
        LocalFree(wszHR);

    return;
}

//--------------------------------------------------------------------------
//
//	  FormatMessageUnicode
//
//--------------------------------------------------------------------------
BOOL FormatMessageUnicode(LPWSTR * ppwszFormat, UINT ids, ...)
{
    // get format string from resources
    WCHAR		wszFormat[MAX_DN_SIZE];
	va_list		argList;
	DWORD		cbMsg=0;
	BOOL		fResult=FALSE;

    if(NULL == ppwszFormat)
        goto Ret;

    if(!LoadStringW(g_hmodThisDll, ids, wszFormat, sizeof(wszFormat) / sizeof(wszFormat[0])))
		goto Ret;

    // format message into requested buffer
    va_start(argList, ids);

    cbMsg = FormatMessageW(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        wszFormat,
        0,                  // dwMessageId
        0,                  // dwLanguageId
        (LPWSTR) (ppwszFormat),
        0,                  // minimum size to allocate
        &argList);

    va_end(argList);

	if(!cbMsg)
        goto Ret;

	fResult=TRUE;


Ret:
	return fResult;
}

//--------------------------------------------------------------------------
//
//	  AENetLogonUser
//
//Abstract:
//
//    This module implements the network logon type by interfacing
//    with the NT Lan Man Security Support Provider (NTLMSSP).
//
//    If the logon succeds via the provided credentials, we duplicate
//    the resultant Impersonation token to a Primary level token.
//    This allows the result to be used in a call to CreateProcessAsUser
//
//Author:
//
//    Scott Field (sfield)    09-Jun-96
//--------------------------------------------------------------------------
BOOL
AENetLogonUser(
    LPTSTR UserName,
    LPTSTR DomainName,
    LPTSTR Password,
    PHANDLE phToken
    )
{
    SECURITY_STATUS SecStatus;
    CredHandle CredentialHandle1;
    CredHandle CredentialHandle2;

    CtxtHandle ClientContextHandle;
    CtxtHandle ServerContextHandle;
    SecPkgCredentials_Names sNames;

    ULONG ContextAttributes;

    ULONG PackageCount;
    ULONG PackageIndex;
    PSecPkgInfo PackageInfo;
    DWORD cbMaxToken=0;

    TimeStamp Lifetime;
    SEC_WINNT_AUTH_IDENTITY AuthIdentity;

    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;

    SecBufferDesc ChallengeDesc;
    SecBuffer ChallengeBuffer;


    BOOL bSuccess = FALSE ; // assume this function will fail

    NegotiateBuffer.pvBuffer = NULL;
    ChallengeBuffer.pvBuffer = NULL;
    sNames.sUserName = NULL;
    ClientContextHandle.dwUpper = -1;
    ClientContextHandle.dwLower = -1;
    ServerContextHandle.dwUpper = -1;
    ServerContextHandle.dwLower = -1;
    CredentialHandle1.dwUpper = -1;
    CredentialHandle1.dwLower = -1;
    CredentialHandle2.dwUpper = -1;
    CredentialHandle2.dwLower = -1;


//
// << this section could be cached in a repeat caller scenario >>
//

    //
    // Get info about the security packages.
    //

    if(EnumerateSecurityPackages(
        &PackageCount,
        &PackageInfo
        ) != SEC_E_OK) return FALSE;

    //
    // loop through the packages looking for NTLM
    //

    for(PackageIndex = 0 ; PackageIndex < PackageCount ; PackageIndex++ ) {
        if(PackageInfo[PackageIndex].Name != NULL) {
            if(CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, PackageInfo[PackageIndex].Name, -1, MICROSOFT_KERBEROS_NAME, -1) == CSTR_EQUAL) {
                cbMaxToken = PackageInfo[PackageIndex].cbMaxToken;
                bSuccess = TRUE;
                break;
            }
        }
    }

    FreeContextBuffer( PackageInfo );

    if(!bSuccess) return FALSE;

    bSuccess = FALSE; // reset to assume failure

//
// << end of cached section >>
//

    //
    // Acquire a credential handle for the server side
    //

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    MICROSOFT_KERBEROS_NAME,    // Package Name
                    SECPKG_CRED_INBOUND,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &CredentialHandle1,
                    &Lifetime
                    );

    if ( SecStatus != SEC_E_OK ) {
        goto cleanup;
    }


    //
    // Acquire a credential handle for the client side
    //

    ZeroMemory( &AuthIdentity, sizeof(AuthIdentity) );

    if ( DomainName != NULL ) {
        AuthIdentity.Domain = DomainName;
        AuthIdentity.DomainLength = lstrlen(DomainName);
    }

    if ( UserName != NULL ) {
        AuthIdentity.User = UserName;
        AuthIdentity.UserLength = lstrlen(UserName);
    }

    if ( Password != NULL ) {
        AuthIdentity.Password = Password;
        AuthIdentity.PasswordLength = lstrlen(Password);
    }

    AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    MICROSOFT_KERBEROS_NAME,    // Package Name
                    SECPKG_CRED_OUTBOUND,
                    NULL,
                    (DomainName == NULL && UserName == NULL && Password == NULL) ?
                        NULL : &AuthIdentity,
                    NULL,
                    NULL,
                    &CredentialHandle2,
                    &Lifetime
                    );

    if ( SecStatus != SEC_E_OK ) {
        goto cleanup;
    }

    SecStatus =  QueryCredentialsAttributes(&CredentialHandle1, SECPKG_CRED_ATTR_NAMES, &sNames);
    if ( SecStatus != SEC_E_OK ) {
        goto cleanup;
    }
    //
    // Get the NegotiateMessage (ClientSide)
    //

    NegotiateDesc.ulVersion = 0;
    NegotiateDesc.cBuffers = 1;
    NegotiateDesc.pBuffers = &NegotiateBuffer;

    NegotiateBuffer.cbBuffer = cbMaxToken;
    NegotiateBuffer.BufferType = SECBUFFER_TOKEN;
    NegotiateBuffer.pvBuffer = LocalAlloc( LMEM_FIXED, NegotiateBuffer.cbBuffer );

    if ( NegotiateBuffer.pvBuffer == NULL ) {
        goto cleanup;
    }

    SecStatus = InitializeSecurityContext(
                    &CredentialHandle2,
                    NULL,                       // No Client context yet
                    sNames.sUserName,                       // target name
                    ISC_REQ_SEQUENCE_DETECT,
                    0,                          // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,                       // No initial input token
                    0,                          // Reserved 2
                    &ClientContextHandle,
                    &NegotiateDesc,
                    &ContextAttributes,
                    &Lifetime
                    );
    if(SecStatus != SEC_E_OK)
    {
        goto cleanup;
    }


    //
    // Get the ChallengeMessage (ServerSide)
    //

    NegotiateBuffer.BufferType |= SECBUFFER_READONLY;
    ChallengeDesc.ulVersion = 0;
    ChallengeDesc.cBuffers = 1;
    ChallengeDesc.pBuffers = &ChallengeBuffer;

    ChallengeBuffer.cbBuffer = cbMaxToken;
    ChallengeBuffer.BufferType = SECBUFFER_TOKEN;
    ChallengeBuffer.pvBuffer = LocalAlloc( LMEM_FIXED, ChallengeBuffer.cbBuffer );

    if ( ChallengeBuffer.pvBuffer == NULL ) {
        goto cleanup;
    }

    SecStatus = AcceptSecurityContext(
                    &CredentialHandle1,
                    NULL,               // No Server context yet
                    &NegotiateDesc,
                    ISC_REQ_SEQUENCE_DETECT,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    &ChallengeDesc,
                    &ContextAttributes,
                    &Lifetime
                    );
    if(SecStatus != SEC_E_OK)
    {
        goto cleanup;
    }


    if(QuerySecurityContextToken(&ServerContextHandle, phToken) != SEC_E_OK)
        goto cleanup;

    bSuccess = TRUE;

cleanup:

    //
    // Delete context
    //

    if((ClientContextHandle.dwUpper != -1) ||
        (ClientContextHandle.dwLower != -1))
    {
        DeleteSecurityContext( &ClientContextHandle );
    }
    if((ServerContextHandle.dwUpper != -1) ||
        (ServerContextHandle.dwLower != -1))
    {
        DeleteSecurityContext( &ServerContextHandle );
    }

    //
    // Free credential handles
    //
    if((CredentialHandle1.dwUpper != -1) ||
        (CredentialHandle1.dwLower != -1))
    {
        FreeCredentialsHandle( &CredentialHandle1 );
    }
    if((CredentialHandle2.dwUpper != -1) ||
        (CredentialHandle2.dwLower != -1))
    {
        FreeCredentialsHandle( &CredentialHandle2 );
    }

    if ( NegotiateBuffer.pvBuffer != NULL ) {

        //
        // NegotiateBuffer.cbBuffer may change on the error path --
        // use the original allocation size.
        //

        SecureZeroMemory( NegotiateBuffer.pvBuffer, cbMaxToken );
        LocalFree( NegotiateBuffer.pvBuffer );
    }

    if ( ChallengeBuffer.pvBuffer != NULL ) {

        //
        // ChallengeBuffer.cbBuffer may change on the error path --
        // use the original allocation size.
        //

        SecureZeroMemory( ChallengeBuffer.pvBuffer, cbMaxToken );
        LocalFree( ChallengeBuffer.pvBuffer );
    }

    if ( sNames.sUserName != NULL ) {
        FreeContextBuffer( sNames.sUserName );
    }

    return bSuccess;
}

//--------------------------------------------------------------------------
//
//  AEDebugLog
//
//--------------------------------------------------------------------------
#if DBG
void
AEDebugLog(long Mask,  LPCWSTR Format, ...)
{
    va_list ArgList;
    int     iOut;
    WCHAR    wszOutString[MAX_DEBUG_BUFFER];

    if (Mask & g_AutoenrollDebugLevel)
    {
        // Make the prefix first:  "Process.Thread> GINA-XXX"

        iOut=wsprintfW(wszOutString, L"%3u.%3u> AUTOENRL: ", GetCurrentProcessId(), GetCurrentThreadId());

		if((iOut > 0) && (iOut < MAX_DEBUG_BUFFER - 1))
		{
			va_start(ArgList, Format);
			_vsnwprintf(&wszOutString[iOut], MAX_DEBUG_BUFFER - iOut, Format, ArgList);

			//null terminating the string
			wszOutString[MAX_DEBUG_BUFFER - 1]=L'\0';

			va_end(ArgList);

			OutputDebugStringW(wszOutString);
		}
    }
}
#endif
//--------------------------------------------------------------------------
//
//	AERemoveRegKey
//
//		Remove the registry key for local system and all its sub keys.
//
//--------------------------------------------------------------------------
DWORD AERemoveRegKey(LPWSTR	pwszRegKey)
{
    DWORD           dwLastError=0;      //we should try to clean up as much as possible
	DWORD			dwIndex=0;
    DWORD           dwSubKey=0;
    DWORD           dwSubKeyLen=0;
    DWORD           dwData=0;
	
    HKEY            hDSKey=NULL;
    LPWSTR          pwszSubKey=NULL;

    //remove the optimization registry.  OK if the key does not exist 
    if(ERROR_SUCCESS != RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                pwszRegKey, 
                0,
                KEY_ALL_ACCESS,
                &hDSKey))
        goto Ret;

    //remove all subkeys of hDSKey
    if(ERROR_SUCCESS != (dwLastError = RegQueryInfoKey(
                      hDSKey,
                      NULL,
                      NULL,
                      NULL,
                      &dwSubKey,
                      &dwSubKeyLen,
                      NULL,
                      NULL,
                      NULL,
                      NULL,
                      NULL,
                      NULL)))
        goto Ret;

    //terminating NULL
    dwSubKeyLen++;

    pwszSubKey=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * dwSubKeyLen);
    
    if(NULL == pwszSubKey)
    {
        dwLastError=ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    for(dwIndex=0; dwIndex < dwSubKey; dwIndex++)
    {
        dwData = dwSubKeyLen; 

        if(ERROR_SUCCESS == (dwLastError = RegEnumKeyEx(
                           hDSKey,
                           0,           // As we delete, the index changes
                           pwszSubKey,
                           &dwData,
                           NULL,
                           NULL,
                           NULL,
                           NULL)))
        {
            RegDeleteKey(hDSKey, pwszSubKey);
        }
	}

	//remove the root registry key
	dwLastError=RegDeleteKey(HKEY_LOCAL_MACHINE, pwszRegKey);

Ret:

    if(pwszSubKey)
        LocalFree(pwszSubKey);

    if(hDSKey)
        RegCloseKey(hDSKey);

    return dwLastError;
}

//--------------------------------------------------------------------------
//
//  CertAutoRemove
//
//      Function to remove enterprise specific public key trust upon domain disjoin.
//      Should be called under local admin's context.
//
//      The function will:
//          remove autoenrollment directory cache registry;
//          remove certificates under root enterprise store;
//          remove certificates under NTAuth enterprise store;
//          remove certificates under CA enterprise store;
//
//     
//      Parameters:
//          IN  dwFlags:        
//                              CERT_AUTO_REMOVE_COMMIT
//                              CERT_AUTO_REMOVE_ROLL_BACK
//
//      Return Value:
//          BOOL:               TURE is upon success
//
//--------------------------------------------------------------------------
BOOL 
WINAPI
CertAutoRemove(IN DWORD    dwFlags)
{
	DWORD			dwError=0;
    DWORD           dwLastError=0;      //we should try to clean up as much as possible
    DWORD           dwIndex=0;
    PCCERT_CONTEXT  pContext=NULL;
    WCHAR           wszNameBuf[64];

    HANDLE          hEvent=NULL;
    HCERTSTORE      hLocalStore=NULL;

    if((CERT_AUTO_REMOVE_COMMIT != dwFlags)  &&
        (CERT_AUTO_REMOVE_ROLL_BACK != dwFlags))
    {
        dwLastError=ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    if(CERT_AUTO_REMOVE_ROLL_BACK == dwFlags)
    {
        //start machine autoenrollment
        wcscpy(wszNameBuf, L"Global\\");
        wcscat(wszNameBuf, MACHINE_AUTOENROLLMENT_TRIGGER_EVENT);

        hEvent=OpenEvent(EVENT_MODIFY_STATE, FALSE, wszNameBuf);
        if (NULL == hEvent) 
        {
            dwLastError=GetLastError();
            goto Ret;
        }

        if (!SetEvent(hEvent)) 
        {
            dwLastError=GetLastError();
            goto Ret;
        }
    }
    else
    {
        //remove all downloaded certificates
        for(dwIndex =0; dwIndex < g_dwStoreInfo; dwIndex++)
        {
            hLocalStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_REGISTRY_W, 
                                        0, 
                                        0, 
                                        CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE, 
                                        g_rgStoreInfo[dwIndex].pwszStoreName);

            if(hLocalStore)
            {
                while(pContext = CertEnumCertificatesInStore(hLocalStore, pContext))
                {
                    CertDeleteCertificateFromStore(CertDuplicateCertificateContext(pContext));
                }

                CertCloseStore(hLocalStore,0);
                hLocalStore=NULL;
            }
        }

		//remove the local machine's DC GUID cache
		dwLastError=AERemoveRegKey(AUTO_ENROLLMENT_DS_KEY);

		dwError=AERemoveRegKey(AUTO_ENROLLMENT_TEMPLATE_KEY);

		if(0 == dwLastError)
			dwLastError=dwError;
    }

Ret:

    if(hLocalStore)
        CertCloseStore(hLocalStore,0);

    if (hEvent) 
        CloseHandle(hEvent);


    if(0 != dwLastError)
    {
        SetLastError(dwLastError);
        return FALSE;
    }

    return TRUE;
}


//--------------------------------------------------------------------------
//
//  DLLMain
//
//
//--------------------------------------------------------------------------
extern "C"
BOOL WINAPI
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    BOOL                        fResult=TRUE;
    INITCOMMONCONTROLSEX        initcomm = {
        sizeof(initcomm), ICC_NATIVEFNTCTL_CLASS | ICC_LISTVIEW_CLASSES | ICC_PROGRESS_CLASS 
    };

    switch( dwReason )
    {
        case DLL_PROCESS_ATTACH:
                g_hmodThisDll=hInstance;
                DisableThreadLibraryCalls( hInstance );

                //Init common control for progress bar
                InitCommonControlsEx(&initcomm);

            break;

        case DLL_PROCESS_DETACH:
            break;
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\dssinc\context.h ===
/* context.h */

#ifndef DSSCSP_CONTEXT_H
#define DSSCSP_CONTEXT_H

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <crypt.h>
#include <windows.h>
#include <crtdbg.h>
#include <csp.h>
#include <randlib.h>
#include <des.h>
#include <sha.h>

#ifdef CSP_USE_MD5
#include "md5.h"
#endif
#ifdef CSP_USE_SHA1
#include "sha.h"
#endif

// definition for disabling encryption in France
#define CRYPT_DISABLE_CRYPT         0x1

/*********************************/
/* Definitions                   */
/*********************************/

#define     KEY_MAGIC   0xBADF

/* State definitions */
#define     KEY_INIT    0x0001

#define     MAX_BLOCKLEN     8

// types of key storage
#define PROTECTED_STORAGE_KEYS      1
#define PROTECTION_API_KEYS         2

#define     HASH_MAGIC      0xBADE

/* State Flags */
#define     HASH_INIT       0x0001
#define     HASH_DATA       0x0002
#define     HASH_FINISH     0x0004

#define     MAX_HASH_LEN    20

#define     CRYPT_BLKLEN    8

#define     HMAC_DEFAULT_STRING_LEN     64
#define     HMAC_STARTED    1
#define     HMAC_FINISHED   2


/*********************************/
/* Structure Definitions         */
/*********************************/

typedef struct _Key_t_ {
    int             magic;              // Magic number
    void            *pContext;
    int             state;              // State of object
    ALG_ID          algId;              // Algorithm Id
    DWORD           flags;              // General flags associated with key
    void            *algParams;         // Parameters for algorithm
    uchar           IV[MAX_BLOCKLEN];
    uchar           Temp_IV[MAX_BLOCKLEN];
    uchar           *pbKey;
    DWORD           cbKey;
    uchar           *pbSalt;
    DWORD           cbSalt;
    BYTE            *pbData;
    DWORD           cbData;
    DWORD           cbEffectiveKeyLen;
    int             mode;
    int             pad;
    int             mode_bits;
    BOOL            InProgress;         // if key is being used
    BOOL            fUIOnKey;           // flag to indicate if UI was to be set on the key
} Key_t;


// Packed version of Key_t. This is used when building opaque
// blobs, and is necessary to properly support WOW64 operation.
typedef struct _Packed_Key_t_ {
    // BLOBHEADER
    int             magic;              // Magic number
    int             state;              // State of object
    ALG_ID          algId;              // Algorithm Id
    DWORD           flags;              // General flags associated with key
    uchar           IV[MAX_BLOCKLEN];
    uchar           Temp_IV[MAX_BLOCKLEN];
    DWORD           cbKey;
    DWORD           cbData;
    DWORD           cbEffectiveKeyLen;
    int             mode;
    int             pad;
    int             mode_bits;
    BOOL            InProgress;         // if key is being used
    BOOL            fUIOnKey;           // flag to indicate if UI was to be set on the key
    // cbKey data bytes
    // cbData data bytes
} Packed_Key_t;


typedef struct {
    int             magic;                  // Magic number
    void            *pContext;              // associated context
    int             state;                  // State of hash object
    ALG_ID          algId;                  // Algorithm Id
    DWORD           size;                   // Size of hash
    void            *pMAC;                  // pointer to mac state
    BYTE            hashval[MAX_HASH_LEN];
    BYTE            *pbData;
    DWORD           cbData;
    Key_t           *pKey;
    BOOL            fInternalKey;
    ALG_ID          HMACAlgid;
    DWORD           HMACState;
    BYTE            *pbHMACInner;
    DWORD           cbHMACInner;
    BYTE            *pbHMACOuter;
    DWORD           cbHMACOuter;
    union {
#if _WIN64
        //
        // fake member to cause 8byte alignment.
        //
        ULONGLONG   Padding;
#endif
#ifdef CSP_USE_MD5
        MD5_CTX md5;
#endif // CSP_USE_MD5
#ifdef CSP_USE_SHA1
        A_SHA_CTX   sha;
#endif // CSP_USE_SHA1
    } algData;
} Hash_t;


/*********************************/
/* Definitions                   */
/*********************************/

#define CONTEXT_MAGIC           0xDEADBEEF
#define CONTEXT_RANDOM_LENGTH   20


typedef struct _PStore_Info
{
    HINSTANCE   hInst;
    void        *pProv;
    GUID        SigType;
    GUID        SigSubtype;
    GUID        ExchType;
    GUID        ExchSubtype;
    LPWSTR      szPrompt;
    DWORD       cbPrompt;
} PSTORE_INFO;


/*********************************/
/* Structure Definitions         */
/*********************************/

typedef struct {
    DWORD               magic;                  // Magic number
    DWORD               dwProvType;             // Type of provider being called as
    LPSTR               szProvName;             // Name of provider being called as
    BOOL                fMachineKeyset;         // TRUE if keyset is for machine
    DWORD               rights;                 // Privileges
    BOOL                fIsLocalSystem;         // check if running as local system
    KEY_CONTAINER_INFO  ContInfo;
    Key_t               *pSigKey;               // pointer to the DSS sig key
    Key_t               *pKExKey;               // pointer to the DH key exchange key
    HKEY                hKeys;                  // Handle to registry
    DWORD               dwEnumalgs;             // index for enumerating algorithms
    DWORD               dwEnumalgsEx;           // index for enumerating algorithms
    DWORD               dwiSubKey;              // index for enumerating containers
    DWORD               dwMaxSubKey;            // max number of containers
    void                *contextData;           // Context specific data
    CRITICAL_SECTION    CritSec;                // critical section for decrypting keys
    HWND                hWnd;                   // handle to window for UI
    PSTORE_INFO         *pPStore;               // pointer to PStore information
    LPWSTR              pwszPrompt;             // UI prompt to be used
    DWORD               dwOldKeyFlags;          // flags to tell how keys should be migrated
    DWORD               dwKeysetType;           // type of storage used
    HANDLE              hRNGDriver;             // handle to hardware RNG driver
    EXPO_OFFLOAD_STRUCT *pOffloadInfo;          // info for offloading modular expo
    DWORD               dwPolicyId;             // Index into policy keylengh arrays.
    BYTE                rgbSigEncryptedX [RTL_ENCRYPT_MEMORY_SIZE + (SHA_DWORDS * sizeof(DWORD))];
    BYTE                rgbKExEncryptedX [RTL_ENCRYPT_MEMORY_SIZE + (DSA_P_MAXDWORDS * sizeof(DWORD))];
} Context_t;


/*********************************/
/* Policy Definitions            */
/*********************************/

extern PROV_ENUMALGS_EX *g_AlgTables[];
// NOTE -- These definitions must match the order of entries in g_AlgTables.
#define POLICY_DSS_BASE       0 // Policy for MS_DEF_DSS_PROV
#define POLICY_DSSDH_BASE     1 // Policy for MS_DEF_DSS_DH_PROV
#define POLICY_DSSDH_ENHANCED 2 // Policy for MS_ENH_DSS_DH_PROV
#define POLICY_DSSDH_SCHANNEL 3 // Policy for MS_DEF_DH_SCHANNEL_PROV


/*********************************/
/* Function Definitions          */
/*********************************/

extern void
freeContext(
    Context_t *pContext);

extern Context_t *
checkContext(
    HCRYPTPROV hProv);

extern Context_t *
allocContext(
    void);

// Initialize a context
extern DWORD
initContext(
    IN OUT Context_t *pContext,
    IN DWORD dwFlags,
    IN DWORD dwProvType,
    IN LPCSTR szProvName,
    IN DWORD dwPolicyId);

extern HCRYPTPROV
AddContext(
    Context_t *pContext);

extern HCRYPTHASH
addContextHash(
    Context_t *pContext,
    Hash_t *pHash);

extern Hash_t *
checkContextHash(
    Context_t *pContext,
    HCRYPTHASH hHash);

// Add key to context
extern HCRYPTKEY
addContextKey(
    Context_t *pContext,
    Key_t *pKey);

// Check if key exists in context
extern Key_t *
checkContextKey(
    IN Context_t *pContext,
    IN HCRYPTKEY hKey);

// random number generation prototype
extern DWORD
FIPS186GenRandom(
    IN HANDLE hRNGDriver,
    IN BYTE **ppbContextSeed,
    IN DWORD *pcbContextSeed,
    IN OUT BYTE *pb,
    IN DWORD cb);

// Scrub sensitive data from memory
extern void
memnuke(
    volatile BYTE *pData,
    DWORD dwLen);

#include "dh_key.h"

extern void ScrubPrivateKeyInMemory(
    IN DHKey_t  *pDH,
    IN BOOL     fSigKey);

extern DWORD EncryptPrivateKeyInMemory(
    IN Context_t *pContext,
    IN DHKey_t  *pDH,
    IN ALG_ID   AlgId);

extern DWORD DecryptPrivateKeyInMemory(
    IN Context_t *pContext,
    IN DHKey_t  *pDH,
    IN ALG_ID   AlgId);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\contman\policy.c ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    policy

Abstract:

    This module provides common CSP Algorithm Limit policy control.

Author:

    Doug Barlow (dbarlow) 8/11/2000

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <wincrypt.h>
#include "policy.h"


/*++

LocateAlgorithm:

    This routine searches a PROV_ENUMALGS_EX array for the specified
    Algorithm.

Arguments:

    rgEnumAlgs supplies the array of PROV_ENUMALGS_EX structures to be
        searched.  The last entry in the array must be filled with zeroes.

    algId supplies the algorithm Id for which to search.

Return Value:

    The corresponding PROV_ENUMALGS_EX structure in the array, or NULL if no
    such algorithm entry exists.

Remarks:

Author:

    Doug Barlow (dbarlow) 8/16/2000

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("LocateAlgorithm")

CONST PROV_ENUMALGS_EX *
LocateAlgorithm(
    IN CONST PROV_ENUMALGS_EX *rgEnumAlgs,
    IN ALG_ID algId)
{
    CONST PROV_ENUMALGS_EX *pEnumAlg = rgEnumAlgs;


    //
    // Run through the list and try to find the given algorithm.
    //

    while (0 != pEnumAlg->aiAlgid)
    {
        if (pEnumAlg->aiAlgid == algId)
            return pEnumAlg;
        pEnumAlg += 1;
    }

    return NULL;
}


/*++

IsLegalAlgorithm:

    Given an array of allowed algorithms, is the given algorithm Id in the
    list?

Arguments:

    rgEnumAlgs supplies the array of PROV_ENUMALGS_EX structures identifying
        the policy to enforce.  The last entry in the array must be filled
        with zeroes.

    algId supplies the algorithm Id to be validated.

    ppEnumAlg, if supplied, receives the PROV_ENUMALGS_EX structure containing
        the policies associated with this algorithm Id.  This can be used in
        following routines to speed up access to policy information.

Return Value:

    TRUE -- That algorithm is supported.
    FALSE -- That algorithm is not supported.

Remarks:

Author:

    Doug Barlow (dbarlow) 8/16/2000

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("IsLegalAlgorithm")

BOOL
IsLegalAlgorithm(
    IN  CONST PROV_ENUMALGS_EX *rgEnumAlgs,
    IN  ALG_ID algId,
    OUT CONST PROV_ENUMALGS_EX **ppEnumAlg)
{
    CONST PROV_ENUMALGS_EX *pEnumAlg = LocateAlgorithm(rgEnumAlgs, algId);

    if (NULL != ppEnumAlg)
        *ppEnumAlg = pEnumAlg;
    return (NULL != pEnumAlg);
}


/*++

IsLegalLength:

    This routine determines if the requested key length is valid for the given
    algorithm, according to policy.

Arguments:

    rgEnumAlgs supplies the array of PROV_ENUMALGS_EX structures identifying
        the policy to enforce.  The last entry in the array must be filled
        with zeroes.

    algId supplies the algorithm Id to be validated.

    cBitLength supplies the length of the proposed key, in bits.

    pEnumAlg, if not NULL, supplies the PROV_ENUMALGS_EX structure containing
        the policies associated with this algorithm Id.  This can be obtained
        from the IsLegalAlgorithm call, above.  If this parameter is NULL,
        then the PROV_ENUMALGS_EX structure is located from the algId
        parameter.

Return Value:

    TRUE -- This key length is legal for this algorithm.
    FALSE -- This key length is not allowed for this algorithm.

Remarks:

    This routine only determines policy rules.  It does not address whether or
    not the exact keylength is supported by the algorithm.

Author:

    Doug Barlow (dbarlow) 8/16/2000

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("IsLegalLength")

BOOL
IsLegalLength(
    IN CONST PROV_ENUMALGS_EX *rgEnumAlgs,
    IN ALG_ID algId,
    IN DWORD cBitLength,
    IN CONST PROV_ENUMALGS_EX *pEnumAlg)
{

    //
    // Make sure we've got a PROV_ENUMALGS_EX structure to work with.
    //

    if (NULL == pEnumAlg)
    {
        pEnumAlg = LocateAlgorithm(rgEnumAlgs, algId);
        if (NULL == pEnumAlg)
            return FALSE;
    }


    //
    // Now check the length.
    //

    return ((pEnumAlg->dwMinLen <= cBitLength)
            && (pEnumAlg->dwMaxLen >= cBitLength));
}


/*++

GetDefaultLength:

    This routine determines the default length for a given algorithm, based on
    policy described in an array of PROV_ENUMALGS_EX structures.

Arguments:

    rgEnumAlgs supplies the array of PROV_ENUMALGS_EX structures identifying
        the policy to enforce.  The last entry in the array must be filled
        with zeroes.

    algId supplies the algorithm Id to be validated.

    pEnumAlg, if not NULL, supplies the PROV_ENUMALGS_EX structure containing
        the policies associated with this algorithm Id.  This can be obtained
        from the IsLegalAlgorithm call, above.  If this parameter is NULL,
        then the PROV_ENUMALGS_EX structure is located from the algId
        parameter.

    pcBitLength receives the default length of the proposed key, in bits.

Return Value:

    TRUE -- The algorithm is supported, and the value returned in pcBitLength
            is valid.
    FALSE -- The requested algorithm isn't supported.

Remarks:

Author:

    Doug Barlow (dbarlow) 8/16/2000

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("GetDefaultLength")

BOOL
GetDefaultLength(
    IN  CONST PROV_ENUMALGS_EX *rgEnumAlgs,
    IN  ALG_ID algId,
    IN  CONST PROV_ENUMALGS_EX *pEnumAlg,
    OUT LPDWORD pcBitLength)
{

    //
    // Clear the returned bit length, just in case.
    //

    *pcBitLength = 0;


    //
    // Make sure we've got a PROV_ENUMALGS_EX structure to work with.
    //

    if (NULL == pEnumAlg)
    {
        pEnumAlg = LocateAlgorithm(rgEnumAlgs, algId);
        if (NULL == pEnumAlg)
            return FALSE;
    }


    //
    // Now return the default length.
    //

    *pcBitLength = pEnumAlg->dwDefaultLen;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\contman\contman.c ===
/*++

Copyright (c) 1997, 1998, 1999  Microsoft Corporation

Module Name:

    keyman.cpp

Abstract:

    This module contains routines to read and write data (key containers) from
    and to files.


Author:

    16 Mar 98 jeffspel

--*/

// Don't whine about unnamed unions
#pragma warning (disable: 4201)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <crypt.h>
#include <windows.h>
#include <userenv.h>
#include <userenvp.h> // for GetUserAppDataPathW
#include <wincrypt.h>
#include <cspdk.h>
#include <rpc.h>
#include <shlobj.h>
#include <contman.h>
#include <md5.h>
#include <des.h>
#include <modes.h>
#include <csprc.h>
#include <crtdbg.h>
#include <mincrypt.h>

#ifdef USE_HW_RNG
#ifdef _M_IX86

#include <winioctl.h>

// INTEL h files for on chip RNG
#include "deftypes.h"   //ISD typedefs and constants
#include "ioctldef.h"   //ISD ioctl definitions

#endif // _M_IX86
#endif // USE_HW_RNG

static LPBYTE l_pbStringBlock = NULL;

CSP_STRINGS g_Strings = {
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL };

typedef struct _OLD_KEY_CONTAINER_LENS_
{
    DWORD   cbSigPub;
    DWORD   cbSigEncPriv;
    DWORD   cbExchPub;
    DWORD   cbExchEncPriv;
} OLD_KEY_CONTAINER_LENS, *POLD_KEY_CONTAINER_LENS;

#define OLD_KEY_CONTAINER_FILE_FORMAT_VER   1
#define FAST_BUF_SIZE           256
#define ContInfoAlloc(cb)       ContAlloc(cb)
#define ContInfoReAlloc(pb, cb) ContRealloc(pb, cb)
#define ContInfoFree(pb)        ContFree(pb)

#define MACHINE_KEYS_DIR        L"MachineKeys"

// Location of the keys in the registry (minus the logon name)
// Length of the full location (including the logon name)
#define RSA_REG_KEY_LOC         "Software\\Microsoft\\Cryptography\\UserKeys"
#define RSA_REG_KEY_LOC_LEN     sizeof(RSA_REG_KEY_LOC)
#define RSA_MACH_REG_KEY_LOC    "Software\\Microsoft\\Cryptography\\MachineKeys"
#define RSA_MACH_REG_KEY_LOC_LEN sizeof(RSA_MACH_REG_KEY_LOC)

#define DSS_REG_KEY_LOC         "Software\\Microsoft\\Cryptography\\DSSUserKeys"
#define DSS_REG_KEY_LOC_LEN     sizeof(DSS_REG_KEY_LOC)
#define DSS_MACH_REG_KEY_LOC    "Software\\Microsoft\\Cryptography\\DSSUserKeys"
#define DSS_MACH_REG_KEY_LOC_LEN sizeof(DSS_MACH_REG_KEY_LOC)

#define MAX_DPAPI_RETRY_COUNT   5


//
// Memory allocation support.
//

#ifndef ASSERT
#define ASSERT _ASSERTE
#endif

#ifdef _X86_
#define InterlockedAccess(pl) *(pl)
#define InterlockedPointerAccess(ppv) *(ppv)
#else
#define InterlockedAccess(pl) InterlockedExchangeAdd((pl), 0)
#define InterlockedPointerAccess(ppv) InterlockedExchangePointer((ppv), *(ppv))
#endif

#define CONT_HEAP_FLAGS (HEAP_ZERO_MEMORY)

// Scrub sensitive data from memory
extern void
memnuke(
    volatile BYTE *pData,
    DWORD dwLen);

extern unsigned int
RSA32API
NewGenRandom(
    IN  OUT unsigned char **, 
    IN      unsigned long *, 
    IN  OUT unsigned char *, 
    IN      unsigned long);

LPVOID
ContAlloc(
    ULONG cbLen)
{
    return HeapAlloc(GetProcessHeap(), CONT_HEAP_FLAGS, cbLen);
}

LPVOID
ContRealloc(
    LPVOID pvMem,
    ULONG cbLen)
{
    return HeapReAlloc(GetProcessHeap(), CONT_HEAP_FLAGS, pvMem, cbLen);
}

void
ContFree(
    LPVOID pvMem)
{
    if (NULL != pvMem)
        HeapFree(GetProcessHeap(), CONT_HEAP_FLAGS, pvMem);
}

//
// Determines the buffer size to use for encrypting/decrypting a private key
// using the EncryptMemory functions below.
//
//  cbKey should include the BSAFE_PRV_KEY struct size
//
#ifndef BSAFE_PRV_KEY
#include <rsa.h>
#endif

DWORD GetKeySizeForEncryptMemory(
    IN DWORD cbKey)
{
    cbKey -= sizeof(BSAFE_PRV_KEY);

    //
    // Only the private key will be encrypted, not the leading BSAFE_PRV_KEY
    // structure.  Therefore, make sure the private key buffer is a multiple
    // of the cipher block size in length.  Then add back the length of the
    // leading struct.
    //
    if (cbKey % MY_RTL_ENCRYPT_MEMORY_SIZE)
        cbKey += MY_RTL_ENCRYPT_MEMORY_SIZE - 
        (cbKey % MY_RTL_ENCRYPT_MEMORY_SIZE);

    return (cbKey + sizeof(BSAFE_PRV_KEY));
}

//
// Wrapper for RtlEncryptMemory, which returns an NTSTATUS.  The return
// value is translated to a winerror code.
//
DWORD MyRtlEncryptMemory(
    IN PVOID pvMem,
    IN DWORD cbMem)
{
    NTSTATUS status = RtlEncryptMemory(pvMem, cbMem, 0);

    return RtlNtStatusToDosError(status);
}

//
// Wrapper for RtlDecryptMemory, which returns an NTSTATUS.  The return value
// is translated to a winerror code.
//
DWORD MyRtlDecryptMemory(
    IN PVOID pvMem,
    IN DWORD cbMem)
{
    NTSTATUS status = RtlDecryptMemory(pvMem, cbMem, 0);

    return RtlNtStatusToDosError(status);
}

//
// Return TRUE if Force High Key Protection is set on this machine, return
// FALSE otherwise.
//
BOOL IsForceHighProtectionEnabled(
    IN PKEY_CONTAINER_INFO  pContInfo)
{
    return pContInfo->fForceHighKeyProtection;
}

//
// Retrieves the Force High Key Protection setting for this machine from the 
// registry.
//
DWORD InitializeForceHighProtection(
    IN OUT PKEY_CONTAINER_INFO  pContInfo)
{
    HKEY hKey = 0;
    DWORD dwSts = ERROR_SUCCESS;
    DWORD cbData = 0;
    DWORD dwValue = 0;

    pContInfo->fForceHighKeyProtection = FALSE;

    //
    // Open the Cryptography key
    //
    dwSts = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE, 
        szKEY_CRYPTOAPI_PRIVATE_KEY_OPTIONS,
        0, 
        KEY_READ | KEY_WOW64_64KEY, 
        &hKey);

    if (ERROR_FILE_NOT_FOUND == dwSts)
    {
        // Key doesn't exist.  Assume feature should remain off.
        dwSts = ERROR_SUCCESS;
        goto Ret;
    }

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    //
    // Find out if force high key protection is on
    //
    cbData = sizeof(DWORD);
    
    dwSts = RegQueryValueEx(
        hKey,
        szFORCE_KEY_PROTECTION,
        0, 
        NULL, 
        (PBYTE) &dwValue,
        &cbData);

    if (ERROR_SUCCESS == dwSts && dwFORCE_KEY_PROTECTION_HIGH == dwValue)
        pContInfo->fForceHighKeyProtection = TRUE;
    else if (ERROR_FILE_NOT_FOUND == dwSts)
        // If the value isn't present, assume Force High is turned off.
        dwSts = ERROR_SUCCESS;

Ret:
    if (hKey)
        RegCloseKey(hKey);

    return dwSts;
}

//
// Returns True if key caching w/ timeouts has been enabled.
//
BOOL IsPrivateKeyCachingEnabled(
    IN PKEY_CONTAINER_INFO  pContInfo)
{
    return pContInfo->fCachePrivateKeys;
}

// 
// Returns True is the cached private key of the indicated type
// is still valid.  
//
// Returns False if no cached key is available, or if the available
// cached key is stale.
//
BOOL IsCachedKeyValid(
    IN PKEY_CONTAINER_INFO  pContInfo,
    IN BOOL                 fSigKey) 
{
    DWORD *pdwPreviousTimestamp = NULL;
    
    // If the new caching behavior isn't enabled, let the
    // caller proceed as before.
    if (FALSE == pContInfo->fCachePrivateKeys)
        return TRUE;

    if (fSigKey)
        pdwPreviousTimestamp = &pContInfo->dwSigKeyTimestamp;
    else
        pdwPreviousTimestamp = &pContInfo->dwKeyXKeyTimestamp;

    if ((GetTickCount() - *pdwPreviousTimestamp) > 
             pContInfo->cMaxKeyLifetime)
    {
        // Cached key is stale
        *pdwPreviousTimestamp = 0;
        return FALSE;
    }

    return TRUE;
}

//
// Updates the cache counter for the key of the indicated type.  This
// is called immediately after the key is read from storage, to 
// restart the cached key lifetime "countdown."
//
DWORD SetCachedKeyTimestamp(
    IN PKEY_CONTAINER_INFO  pContInfo,
    IN BOOL                 fSigKey)
{
    if (FALSE == pContInfo->fCachePrivateKeys)
        return ERROR_SUCCESS;

    if (fSigKey)
        pContInfo->dwSigKeyTimestamp = GetTickCount();
    else
        pContInfo->dwKeyXKeyTimestamp = GetTickCount();

    return ERROR_SUCCESS;
}

//
// Reads the key cache initialization parameters from the registry.
//
DWORD InitializeKeyCacheInfo(
    IN OUT PKEY_CONTAINER_INFO pContInfo)
{
    HKEY hKey = 0;
    DWORD dwSts = ERROR_SUCCESS;
    DWORD cbData = 0;

    //
    // Open the Cryptography key
    //
    dwSts = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE, 
        szKEY_CRYPTOAPI_PRIVATE_KEY_OPTIONS,
        0, 
        KEY_READ | KEY_WOW64_64KEY, 
        &hKey);

    if (ERROR_FILE_NOT_FOUND == dwSts)
    {
        // Key doesn't exist.  Assume feature should remain off.
        dwSts = ERROR_SUCCESS;
        goto Ret;
    }

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    //
    // Find out if private key caching is turned on
    //
    cbData = sizeof(DWORD);

    dwSts = RegQueryValueEx(
        hKey,
        szKEY_CACHE_ENABLED,
        0, 
        NULL, 
        (PBYTE) &pContInfo->fCachePrivateKeys,
        &cbData);

    if (ERROR_FILE_NOT_FOUND == dwSts)
    {
        // Reg key enabling the new behavior isn't set, so we're done.
        dwSts = ERROR_SUCCESS;
        goto Ret;
    }
    else if (ERROR_SUCCESS != dwSts || FALSE == pContInfo->fCachePrivateKeys)
        goto Ret;

    //
    // Find out how long to cache private keys
    //
    cbData = sizeof(DWORD);

    dwSts = RegQueryValueEx(
        hKey,
        szKEY_CACHE_SECONDS,
        0,
        NULL,
        (PBYTE) &pContInfo->cMaxKeyLifetime,
        &cbData);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    // Cache lifetime value stored in registry is in seconds.  We'll remember
    // the value in milliseconds for easy comparison.

    pContInfo->cMaxKeyLifetime *= 1000;

Ret:
    if (hKey)
        RegCloseKey(hKey);

    return dwSts;
}

/*++

OpenCallerToken:

    This routine returns the caller's ID token.

Arguments:

    dwFlags supplies the flags to use when opening the token.

    phToken receives the token.  It must be closed via CloseHandle.

Return Value:

    A DWORD status code.

Remarks:

Author:

    Doug Barlow (dbarlow) 5/2/2000

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("OpenCallerToken")

/*static*/ DWORD
OpenCallerToken(
    IN  DWORD  dwFlags,
    OUT HANDLE *phToken)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    DWORD dwSts;
    BOOL fSts;
    HANDLE hToken = NULL;

    fSts = OpenThreadToken(GetCurrentThread(), dwFlags, TRUE, &hToken);
    if (!fSts)
    {
        dwSts = GetLastError();
        if (ERROR_NO_TOKEN != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        // For Jeff, fall back and get the process token
        fSts = OpenProcessToken(GetCurrentProcess(), dwFlags, &hToken);
        if (!fSts)
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }
    }

    *phToken = hToken;
    return ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


DWORD
MyCryptProtectData(
    IN          DATA_BLOB   *pDataIn,
    IN          LPCWSTR     szDataDescr,
    IN OPTIONAL DATA_BLOB   *pOptionalEntropy,
    IN          PVOID       pvReserved,
    IN OPTIONAL CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct,
    IN          DWORD       dwFlags,
    OUT         DATA_BLOB   *pDataOut)  // out encr blob
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    DWORD   dwRetryCount = 0;
    DWORD   dwMilliseconds = 10;
    DWORD   dwSts;

    for (;;)
    {
        if (CryptProtectData(pDataIn, szDataDescr, pOptionalEntropy,
                             pvReserved, pPromptStruct, dwFlags, pDataOut))
        {
            break;
        }

        dwSts = GetLastError();
        switch (dwSts)
        {
        case RPC_S_SERVER_TOO_BUSY:
            if (MAX_DPAPI_RETRY_COUNT <= dwRetryCount)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
            Sleep(dwMilliseconds);
            dwMilliseconds *= 2;
            dwRetryCount++;
            break;

        case RPC_S_UNKNOWN_IF:  // Make this error code more friendly.
            dwReturn = ERROR_SERVICE_NOT_ACTIVE;
            goto ErrorExit;
            break;

        default:
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}

DWORD
MyCryptUnprotectData(
    IN              DATA_BLOB   *pDataIn,             // in encr blob
    OUT OPTIONAL    LPWSTR      *ppszDataDescr,       // out
    IN OPTIONAL     DATA_BLOB   *pOptionalEntropy,
    IN              PVOID       pvReserved,
    IN OPTIONAL     CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct,
    IN              DWORD       dwFlags,
    OUT             DATA_BLOB   *pDataOut,
    OUT             LPDWORD     pdwReprotectFlags)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    DWORD   dwRetryCount = 0;
    DWORD   dwMilliseconds = 10;
    DWORD   dwSts;
    BOOL    fSts;

    if (NULL != pdwReprotectFlags)
    {
        *pdwReprotectFlags = 0;
        dwFlags |= (CRYPTPROTECT_VERIFY_PROTECTION
                    | CRYPTPROTECT_UI_FORBIDDEN);
    }

    for (;;)
    {
        fSts = CryptUnprotectData(pDataIn,             // in encr blob
                                  ppszDataDescr,       // out
                                  pOptionalEntropy,
                                  pvReserved,
                                  pPromptStruct,
                                  dwFlags,
                                  pDataOut);
        if (!fSts)
        {
            dwSts = GetLastError();
            if ((RPC_S_SERVER_TOO_BUSY == dwSts)
                && (MAX_DPAPI_RETRY_COUNT > dwRetryCount))
            {
                Sleep(dwMilliseconds);
                dwMilliseconds *= 2;
                dwRetryCount++;
            }
            else if ((ERROR_PASSWORD_RESTRICTION == dwSts)
                     && (NULL != pdwReprotectFlags))
            {
                *pdwReprotectFlags |= CRYPT_USER_PROTECTED;
                dwFlags &= ~CRYPTPROTECT_UI_FORBIDDEN;
            }
            else
            {
                dwReturn = dwSts;
                break;
            }
        }
        else
        {
            if (NULL != pdwReprotectFlags)
            {
                dwSts = GetLastError();
                if (CRYPT_I_NEW_PROTECTION_REQUIRED == dwSts)
                    *pdwReprotectFlags |= CRYPT_UPDATE_KEY;
            }
            dwReturn = ERROR_SUCCESS;
            break;
        }
    }
    return dwReturn;
}


void
FreeEnumOldMachKeyEntries(
    PKEY_CONTAINER_INFO pInfo)
{
    if (pInfo)
    {
        if (pInfo->pchEnumOldMachKeyEntries)
        {
            ContInfoFree(pInfo->pchEnumOldMachKeyEntries);
            pInfo->dwiOldMachKeyEntry = 0;
            pInfo->cMaxOldMachKeyEntry = 0;
            pInfo->cbOldMachKeyEntry = 0;
            pInfo->pchEnumOldMachKeyEntries = NULL;
        }
    }
}


void
FreeEnumRegEntries(
    PKEY_CONTAINER_INFO pInfo)
{
    if (pInfo)
    {
        if (pInfo->pchEnumRegEntries)
        {
            ContInfoFree(pInfo->pchEnumRegEntries);
            pInfo->dwiRegEntry = 0;
            pInfo->cMaxRegEntry = 0;
            pInfo->cbRegEntry = 0;
            pInfo->pchEnumRegEntries = NULL;
        }
    }
}

void
FreeContainerInfo(
    PKEY_CONTAINER_INFO pInfo)
{
    if (NULL != pInfo)
    {
        if (NULL != pInfo->pbSigPub)
        {
            ContInfoFree(pInfo->pbSigPub);
            pInfo->ContLens.cbSigPub = 0;
            pInfo->pbSigPub = NULL;
        }

        if (NULL != pInfo->pbSigEncPriv)
        {
            memnuke(pInfo->pbSigEncPriv, pInfo->ContLens.cbSigEncPriv);
            ContInfoFree(pInfo->pbSigEncPriv);
            pInfo->ContLens.cbSigEncPriv = 0;
            pInfo->pbSigEncPriv = NULL;
        }

        if (NULL != pInfo->pbExchPub)
        {
            ContInfoFree(pInfo->pbExchPub);
            pInfo->ContLens.cbExchPub = 0;
            pInfo->pbExchPub = NULL;
        }

        if (NULL != pInfo->pbExchEncPriv)
        {
            memnuke(pInfo->pbExchEncPriv, pInfo->ContLens.cbExchEncPriv);
            ContInfoFree(pInfo->pbExchEncPriv);
            pInfo->ContLens.cbExchEncPriv = 0;
            pInfo->pbExchEncPriv = NULL;
        }

        if (NULL != pInfo->pbRandom)
        {
            ContInfoFree(pInfo->pbRandom);
            pInfo->ContLens.cbRandom = 0;
            pInfo->pbRandom = NULL;
        }

        if (NULL != pInfo->pszUserName)
        {
            ContInfoFree(pInfo->pszUserName);
            pInfo->ContLens.cbName = 0;
            pInfo->pszUserName = NULL;
        }

        FreeEnumOldMachKeyEntries(pInfo);
        FreeEnumRegEntries(pInfo);
        if (NULL != pInfo->hFind)
            FindClose(pInfo->hFind);
    }
}

/*static*/ DWORD
GetHashOfContainer(
    LPCSTR pszContainer,
    LPWSTR pszHash)
{
    DWORD       dwReturn = ERROR_INTERNAL_ERROR;
    MD5_CTX     MD5;
    LPSTR       pszLowerContainer = NULL;
    DWORD       *pdw1;
    DWORD       *pdw2;
    DWORD       *pdw3;
    DWORD       *pdw4;

    pszLowerContainer = (LPSTR)ContInfoAlloc(
                                strlen(pszContainer) + sizeof(CHAR));
    if (NULL == pszLowerContainer)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    lstrcpy(pszLowerContainer, pszContainer);
    _strlwr(pszLowerContainer);

    MD5Init(&MD5);
    MD5Update(&MD5,
              (LPBYTE)pszLowerContainer,
              strlen(pszLowerContainer) + sizeof(CHAR));
    MD5Final(&MD5);

    pdw1 = (DWORD*)&MD5.digest[0];
    pdw2 = (DWORD*)&MD5.digest[4];
    pdw3 = (DWORD*)&MD5.digest[8];
    pdw4 = (DWORD*)&MD5.digest[12];
    wsprintfW(pszHash, L"%08hx%08hx%08hx%08hx", *pdw1, *pdw2, *pdw3, *pdw4);
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != pszLowerContainer)
        ContInfoFree(pszLowerContainer);
    return dwReturn;
}


/*static*/ DWORD
GetMachineGUID(
    LPWSTR *ppwszUuid)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    HKEY    hRegKey = 0;
    LPSTR   pszUuid = NULL;
    LPWSTR  pwszUuid = NULL;
    DWORD   cbUuid = sizeof(UUID);
    DWORD   cch = 0;
    DWORD   dwSts;

    *ppwszUuid = NULL;

    // read the GUID from the Local Machine portion of the registry
    dwSts = RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZLOCALMACHINECRYPTO,
                         0, KEY_READ | KEY_WOW64_64KEY, &hRegKey);
    if (ERROR_FILE_NOT_FOUND == dwSts)
    {
        dwReturn = ERROR_SUCCESS;
        goto ErrorExit;   // Return a success code, but a null GUID.
    }
    else if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;   // (DWORD)NTE_FAIL
        goto ErrorExit;
    }

    dwSts = RegQueryValueEx(hRegKey, SZCRYPTOMACHINEGUID,
                            0, NULL, NULL, &cbUuid);
    if (ERROR_FILE_NOT_FOUND == dwSts)
    {
        dwReturn = ERROR_SUCCESS;
        goto ErrorExit;   // Return a success code, but a null GUID.
    }
    else if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;   // (DWORD)NTE_FAIL
        goto ErrorExit;
    }

    pszUuid = (LPSTR)ContInfoAlloc(cbUuid);
    if (NULL == pszUuid)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    dwSts = RegQueryValueEx(hRegKey, SZCRYPTOMACHINEGUID,
                            0, NULL, (LPBYTE)pszUuid, &cbUuid);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;   // (DWORD)NTE_FAIL;
        goto ErrorExit;
    }

    // convert from ansi to unicode
    cch = MultiByteToWideChar(CP_ACP, MB_COMPOSITE, pszUuid, -1, NULL, cch);
    if (0 == cch)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    pwszUuid = ContInfoAlloc((cch + 1) * sizeof(WCHAR));
    if (NULL == pwszUuid)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    cch = MultiByteToWideChar(CP_ACP, MB_COMPOSITE, pszUuid, -1,
                              pwszUuid, cch);
    if (0 == cch)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    *ppwszUuid = pwszUuid;
    pwszUuid = NULL;
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != pwszUuid)
        ContInfoFree(pwszUuid);
    if (NULL != pszUuid)
        ContInfoFree(pszUuid);
    if (NULL != hRegKey)
        RegCloseKey(hRegKey);
    return dwReturn;
}


DWORD
SetMachineGUID(
    void)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    HKEY    hRegKey = 0;
    UUID    Uuid;
    LPSTR   pszUuid = NULL;
    DWORD   cbUuid;
    LPWSTR  pwszOldUuid = NULL;
    DWORD   dwSts;
    DWORD   dwResult;

    dwSts = GetMachineGUID(&pwszOldUuid);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    if (NULL != pwszOldUuid)
    {
        dwReturn = (DWORD)NTE_FAIL;
        goto ErrorExit;
    }

    dwSts = (DWORD) UuidCreate(&Uuid);
    if (RPC_S_OK != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwSts = (DWORD) UuidToStringA(&Uuid, &pszUuid);
    if (RPC_S_OK != dwSts)
    {
        dwReturn = dwSts;   // (DWORD)NTE_FAIL;
        goto ErrorExit;
    }

    // read the GUID from the Local Machine portion of the registry
    dwSts = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                           SZLOCALMACHINECRYPTO,
                           0, NULL, REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS | KEY_WOW64_64KEY, NULL, &hRegKey,
                           &dwResult);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;   // (DWORD)NTE_FAIL;
        goto ErrorExit;
    }

    dwSts = RegQueryValueEx(hRegKey, SZCRYPTOMACHINEGUID,
                            0, NULL, NULL,
                            &cbUuid);
    if (ERROR_FILE_NOT_FOUND != dwSts)
    {
        dwReturn = (DWORD)NTE_FAIL;
        goto ErrorExit;
    }

    dwSts = RegSetValueEx(hRegKey, SZCRYPTOMACHINEGUID,
                          0, REG_SZ, (BYTE*)pszUuid,
                          strlen(pszUuid) + 1);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;   // (DWORD)NTE_FAIL;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (pszUuid)
        RpcStringFreeA(&pszUuid);
    if (pwszOldUuid)
        ContInfoFree(pwszOldUuid);
    if (hRegKey)
        RegCloseKey(hRegKey);
    return dwReturn;
}


/*static*/ DWORD
AddMachineGuidToContainerName(
    LPSTR pszContainer,
    LPWSTR pwszNewContainer)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    WCHAR   rgwszHash[33];
    LPWSTR  pwszUuid = NULL;
    DWORD   dwSts;

    memset(rgwszHash, 0, sizeof(rgwszHash));

    // get the stringized hash of the container name
    dwSts = GetHashOfContainer(pszContainer, rgwszHash);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // get the GUID of the machine
    dwSts = GetMachineGUID(&pwszUuid);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }
    if (NULL == pwszUuid)
    {
        dwReturn = (DWORD)NTE_FAIL;
        goto ErrorExit;
    }

    wcscpy(pwszNewContainer, rgwszHash);
    wcscat(pwszNewContainer, L"_");
    wcscat(pwszNewContainer, pwszUuid);
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (pwszUuid)
        ContInfoFree(pwszUuid);
    return dwReturn;
}


//
//    Just tries to use DPAPI to make sure it works before creating a key
//    container.
//

DWORD
TryDPAPI(
    void)
{
    DWORD                       dwReturn = ERROR_INTERNAL_ERROR;
    CRYPTPROTECT_PROMPTSTRUCT   PromptStruct;
    CRYPT_DATA_BLOB             DataIn;
    CRYPT_DATA_BLOB             DataOut;
    CRYPT_DATA_BLOB             ExtraEntropy;
    DWORD                       dwJunk = 0;
    DWORD                       dwSts;

    memset(&PromptStruct, 0, sizeof(PromptStruct));
    memset(&DataIn, 0, sizeof(DataIn));
    memset(&DataOut, 0, sizeof(DataOut));

    PromptStruct.cbSize = sizeof(PromptStruct);

    DataIn.cbData = sizeof(DWORD);
    DataIn.pbData = (BYTE*)&dwJunk;
    ExtraEntropy.cbData = sizeof(STUFF_TO_GO_INTO_MIX);
    ExtraEntropy.pbData = (LPBYTE)STUFF_TO_GO_INTO_MIX;
    dwSts = MyCryptProtectData(&DataIn, L"Export Flag", &ExtraEntropy, NULL,
                               &PromptStruct, 0, &DataOut);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != DataOut.pbData)
        LocalFree(DataOut.pbData);
    return dwReturn;
}


/*static*/ DWORD
ProtectExportabilityFlag(
    IN BOOL fExportable,
    IN BOOL fMachineKeyset,
    OUT BYTE **ppbProtectedExportability,
    OUT DWORD *pcbProtectedExportability)
{
    DWORD                       dwReturn = ERROR_INTERNAL_ERROR;
    CRYPTPROTECT_PROMPTSTRUCT   PromptStruct;
    CRYPT_DATA_BLOB             DataIn;
    CRYPT_DATA_BLOB             DataOut;
    CRYPT_DATA_BLOB             ExtraEntropy;
    DWORD                       dwProtectFlags = 0;
    DWORD                       dwSts = 0;

    memset(&PromptStruct, 0, sizeof(PromptStruct));
    memset(&DataIn, 0, sizeof(DataIn));
    memset(&DataOut, 0, sizeof(DataOut));

    if (fMachineKeyset)
        dwProtectFlags = CRYPTPROTECT_LOCAL_MACHINE;

    PromptStruct.cbSize = sizeof(PromptStruct);

    DataIn.cbData = sizeof(BOOL);
    DataIn.pbData = (BYTE*)&fExportable;

    ExtraEntropy.cbData = sizeof(STUFF_TO_GO_INTO_MIX);
    ExtraEntropy.pbData = (LPBYTE)STUFF_TO_GO_INTO_MIX;

    dwSts = MyCryptProtectData(&DataIn, L"Export Flag", &ExtraEntropy, NULL,
                               &PromptStruct, dwProtectFlags, &DataOut);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    *ppbProtectedExportability = ContInfoAlloc(DataOut.cbData);
    if (NULL == *ppbProtectedExportability)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    *pcbProtectedExportability = DataOut.cbData;
    memcpy(*ppbProtectedExportability, DataOut.pbData, DataOut.cbData);
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != DataOut.pbData)
        LocalFree(DataOut.pbData);
    return dwReturn;
}

/*static*/ DWORD
UnprotectExportabilityFlag(
    IN BOOL fMachineKeyset,
    IN BYTE *pbProtectedExportability,
    IN DWORD cbProtectedExportability,
    IN BOOL *pfExportable)
{
    DWORD                       dwReturn = ERROR_INTERNAL_ERROR;
    CRYPTPROTECT_PROMPTSTRUCT   PromptStruct;
    CRYPT_DATA_BLOB             DataIn;
    CRYPT_DATA_BLOB             DataOut;
    CRYPT_DATA_BLOB             ExtraEntropy;
    DWORD                       dwProtectFlags = 0;
    DWORD                       dwSts = 0;

    memset(&PromptStruct, 0, sizeof(PromptStruct));
    memset(&DataIn, 0, sizeof(DataIn));
    memset(&DataOut, 0, sizeof(DataOut));
    memset(&ExtraEntropy, 0, sizeof(ExtraEntropy));

    if (fMachineKeyset)
        dwProtectFlags = CRYPTPROTECT_LOCAL_MACHINE;

    PromptStruct.cbSize = sizeof(PromptStruct);

    DataIn.cbData = cbProtectedExportability;
    DataIn.pbData = pbProtectedExportability;

    ExtraEntropy.cbData = sizeof(STUFF_TO_GO_INTO_MIX);
    ExtraEntropy.pbData = (LPBYTE)STUFF_TO_GO_INTO_MIX;

    dwSts = MyCryptUnprotectData(&DataIn, NULL, &ExtraEntropy, NULL,
                                 &PromptStruct, dwProtectFlags, &DataOut,
                                 NULL);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;   // NTE_BAD_KEYSET
        goto ErrorExit;
    }

    if (sizeof(BOOL) != DataOut.cbData)
    {
        dwReturn = (DWORD)NTE_BAD_KEYSET;
        goto ErrorExit;
    }

    *pfExportable = *((BOOL*)DataOut.pbData);
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    // free the DataOut struct if necessary
    if (NULL != DataOut.pbData)
        LocalFree(DataOut.pbData);
    return dwReturn;
}


/*++

    Creates a DACL for the MachineKeys directory for
    machine keysets so that Everyone may create machine keys.

--*/

/*static*/ DWORD
GetMachineKeysetDirDACL(
    IN OUT PACL *ppDacl)
{
    DWORD                       dwReturn = ERROR_INTERNAL_ERROR;
    SID_IDENTIFIER_AUTHORITY    siaWorld = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    siaNTAuth = SECURITY_NT_AUTHORITY;
    PSID                        pEveryoneSid = NULL;
    PSID                        pAdminsSid = NULL;
    DWORD                       dwAclSize;

    //
    // prepare Sids representing the world and admins
    //

    if (!AllocateAndInitializeSid(&siaWorld,
                                  1,
                                  SECURITY_WORLD_RID,
                                  0, 0, 0, 0, 0, 0, 0,
                                  &pEveryoneSid))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if (!AllocateAndInitializeSid(&siaNTAuth,
                                  2,
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS,
                                  0, 0, 0, 0, 0, 0,
                                  &pAdminsSid))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }


    //
    // compute size of new acl
    //

    dwAclSize = sizeof(ACL)
                + 2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD))
                + GetLengthSid(pEveryoneSid)
                + GetLengthSid(pAdminsSid);


    //
    // allocate storage for Acl
    //

    *ppDacl = (PACL)ContInfoAlloc(dwAclSize);
    if (NULL == *ppDacl)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    if (!InitializeAcl(*ppDacl, dwAclSize, ACL_REVISION))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if (!AddAccessAllowedAce(*ppDacl,
                             ACL_REVISION,
                             (FILE_GENERIC_WRITE | FILE_GENERIC_READ) & (~WRITE_DAC),
                             pEveryoneSid))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if (!AddAccessAllowedAce(*ppDacl,
                             ACL_REVISION,
                             FILE_ALL_ACCESS,
                             pAdminsSid))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != pEveryoneSid)
        FreeSid(pEveryoneSid);
    if (NULL != pAdminsSid)
        FreeSid(pAdminsSid);
    return dwReturn;
}


DWORD
CreateSystemDirectory(
    LPCWSTR lpPathName,
    SECURITY_ATTRIBUTES *pSecAttrib)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    RTL_RELATIVE_NAME_U RelativeName;
    PVOID FreeBuffer;

    if(!RtlDosPathNameToRelativeNtPathName_U( lpPathName,
                                              &FileName,
                                              NULL,
                                              &RelativeName))
    {
        dwReturn = ERROR_PATH_NOT_FOUND;
        goto ErrorExit;
    }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length )
    {
        FileName = RelativeName.RelativeName;
    }
    else
    {
        RelativeName.ContainingDirectory = NULL;
    }

    InitializeObjectAttributes( &Obja,
                                &FileName,
                                OBJ_CASE_INSENSITIVE,
                                RelativeName.ContainingDirectory,
                                (NULL != pSecAttrib)
                                    ? pSecAttrib->lpSecurityDescriptor
                                    : NULL);

    // Creating the directory with attribute FILE_ATTRIBUTE_SYSTEM to avoid inheriting encryption
    // property from parent directory

    Status = NtCreateFile( &Handle,
                           FILE_LIST_DIRECTORY | SYNCHRONIZE,
                           &Obja,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_SYSTEM,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_CREATE,
                           FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT,
                           NULL,
                           0L );

    RtlReleaseRelativeName(&RelativeName);
    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

    if(NT_SUCCESS(Status))
    {
        NtClose(Handle);
        dwReturn = ERROR_SUCCESS;
    }
    else
    {
        if (STATUS_TIMEOUT == Status)
            dwReturn = ERROR_TIMEOUT;
        else
            dwReturn = RtlNtStatusToDosError(Status);
    }

ErrorExit:
    return dwReturn;
}


/*++

    Create all subdirectories if they do not exists starting at
    szCreationStartPoint.

    szCreationStartPoint must point to a character within the null terminated
    buffer specified by the szFullPath parameter.

    Note that szCreationStartPoint should not point at the first character
    of a drive root, eg:

    d:\foo\bar\bilge\water
    \\server\share\foo\bar
    \\?\d:\big\path\bilge\water

    Instead, szCreationStartPoint should point beyond these components, eg:

    bar\bilge\water
    foo\bar
    big\path\bilge\water

    This function does not implement logic for adjusting to compensate for
    these inputs because the environment it was design to be used in causes
    the input szCreationStartPoint to point well into the szFullPath input
    buffer.

--*/

/*static*/ DWORD
CreateNestedDirectories(
    IN      LPWSTR wszFullPath,
    IN      LPWSTR wszCreationStartPoint, // must point in null-terminated range of szFullPath
    IN      BOOL fMachineKeyset)
{
    DWORD               dwReturn = ERROR_INTERNAL_ERROR;
    DWORD               i;
    DWORD               dwPrevious = 0;
    DWORD               cchRemaining;
    SECURITY_ATTRIBUTES SecAttrib;
    SECURITY_ATTRIBUTES *pSecAttrib;
    SECURITY_DESCRIPTOR sd;
    PACL                pDacl = NULL;
    DWORD               dwSts = ERROR_SUCCESS;
    BOOL                fSts;

    if (wszCreationStartPoint < wszFullPath ||
        wszCreationStartPoint  > (wcslen(wszFullPath) + wszFullPath))
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto ErrorExit;
    }

    cchRemaining = wcslen(wszCreationStartPoint);


    //
    // scan from left to right in the szCreationStartPoint string
    // looking for directory delimiter.
    //

    for (i = 0; i < cchRemaining; i++)
    {
        WCHAR charReplaced = wszCreationStartPoint[i];

        if (charReplaced == '\\' || charReplaced == '/')
        {
            wszCreationStartPoint[ i ] = '\0';

            pSecAttrib = NULL;
            if (fMachineKeyset)
            {
                memset(&SecAttrib, 0, sizeof(SecAttrib));
                SecAttrib.nLength = sizeof(SecAttrib);

                if (0 == wcscmp(MACHINE_KEYS_DIR,
                                &(wszCreationStartPoint[ dwPrevious ])))
                {
                    dwSts = GetMachineKeysetDirDACL(&pDacl);
                    if (ERROR_SUCCESS != dwSts)
                    {
                        dwReturn = dwSts;
                        goto ErrorExit;
                    }
                    fSts = InitializeSecurityDescriptor(&sd,
                                                        SECURITY_DESCRIPTOR_REVISION);
                    if (!fSts)
                    {
                        dwReturn = GetLastError();
                        goto ErrorExit;
                    }

                    fSts = SetSecurityDescriptorDacl(&sd, TRUE, pDacl, FALSE);
                    if (!fSts)
                    {
                        dwReturn = GetLastError();
                        goto ErrorExit;
                    }

                    SecAttrib.lpSecurityDescriptor = &sd;
                    pSecAttrib = &SecAttrib;
                }
            }

            dwSts = CreateSystemDirectory(wszFullPath, pSecAttrib);
            dwPrevious = i + 1;
            wszCreationStartPoint[ i ] = charReplaced;

            if (ERROR_SUCCESS != dwSts)
            {

                //
                // continue onwards, trying to create specified
                // subdirectories.  This is done to address the obscure
                // scenario where the Bypass Traverse Checking Privilege
                // allows the caller to create directories below an
                // existing path where one component denies the user
                // access.  We just keep trying and the last
                // CreateDirectory() result is returned to the caller.
                //

                continue;
            }
        }
    }

    if (ERROR_ALREADY_EXISTS == dwSts)
        dwSts = ERROR_SUCCESS;
    dwReturn = dwSts;

ErrorExit:
    if (NULL != pDacl)
        ContInfoFree(pDacl);
    return dwReturn;
}


#ifdef _M_IX86

BOOL WINAPI
FIsWinNT(
    void)
{

    static BOOL fIKnow = FALSE;
    static BOOL fIsWinNT = FALSE;

    OSVERSIONINFO osVer;

    if (fIKnow)
        return(fIsWinNT);

    memset(&osVer, 0, sizeof(OSVERSIONINFO));
    osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if (GetVersionEx(&osVer))
        fIsWinNT = (osVer.dwPlatformId == VER_PLATFORM_WIN32_NT);

    // even on an error, this is as good as it gets
    fIKnow = TRUE;

    return fIsWinNT;
}

#else   // other than _M_IX86

BOOL WINAPI
FIsWinNT(
    void)
{
    return TRUE;
}

#endif  // _M_IX86


/*++

    This function determines if the user associated with the
    specified token is the Local System account.

--*/

DWORD
IsLocalSystem(
    BOOL *pfIsLocalSystem)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    HANDLE  hToken = 0;
    HANDLE  hThreadToken = NULL;
    UCHAR InfoBuffer[1024];
    DWORD dwInfoBufferSize = sizeof(InfoBuffer);
    PTOKEN_USER SlowBuffer = NULL;
    PTOKEN_USER pTokenUser = (PTOKEN_USER)InfoBuffer;
    PSID psidLocalSystem = NULL;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    BOOL fSts;
    DWORD dwSts;

    *pfIsLocalSystem = FALSE;

    fSts = OpenThreadToken(GetCurrentThread(),
                           MAXIMUM_ALLOWED,
                           TRUE,
                           &hThreadToken);
    if (fSts)
    {
        // impersonation is going on need to save handle
        if (FALSE == RevertToSelf())
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }
    }

    fSts = OpenProcessToken(GetCurrentProcess(),
                            TOKEN_QUERY,
                            &hToken);

    if (!fSts)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if (NULL != hThreadToken)
    {
        // put the impersonation token back
        fSts = SetThreadToken(NULL, hThreadToken);
        if (!fSts)
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }
    }

    fSts = GetTokenInformation(hToken, TokenUser, pTokenUser,
                               dwInfoBufferSize, &dwInfoBufferSize);

    if (!fSts)
    {
        dwSts = GetLastError();
        if (ERROR_INSUFFICIENT_BUFFER == dwSts)
        {

            //
            // if fast buffer wasn't big enough, allocate enough storage
            // and try again.
            //

            SlowBuffer = (PTOKEN_USER)ContInfoAlloc(dwInfoBufferSize);
            if (NULL == SlowBuffer)
            {
                dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorExit;
            }

            pTokenUser = SlowBuffer;
            fSts = GetTokenInformation(hToken, TokenUser, pTokenUser,
                                       dwInfoBufferSize,
                                       &dwInfoBufferSize);
            if (!fSts)
            {
                dwReturn = GetLastError();
                goto ErrorExit;
            }
        }
        else
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    fSts = AllocateAndInitializeSid(&siaNtAuthority,
                                    1,
                                    SECURITY_LOCAL_SYSTEM_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &psidLocalSystem);
    if (!fSts)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if (EqualSid(psidLocalSystem, pTokenUser->User.Sid))
        *pfIsLocalSystem = TRUE;
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != SlowBuffer)
        ContInfoFree(SlowBuffer);
    if (NULL != psidLocalSystem)
        FreeSid(psidLocalSystem);
    if (NULL != hThreadToken)
        CloseHandle(hThreadToken);
    if (NULL != hToken)
        CloseHandle(hToken);
    return dwReturn;
}


/*++

    This function determines if the user associated with the
    specified token is the Local System account.

--*/

/*static*/ DWORD
IsThreadLocalSystem(
    BOOL *pfIsLocalSystem)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    BOOL fSts;
    DWORD dwSts;
    HANDLE  hToken = 0;
    UCHAR InfoBuffer[1024];
    DWORD dwInfoBufferSize = sizeof(InfoBuffer);
    PTOKEN_USER SlowBuffer = NULL;
    PTOKEN_USER pTokenUser = (PTOKEN_USER)InfoBuffer;
    PSID psidLocalSystem = NULL;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;

    *pfIsLocalSystem = FALSE;

    dwSts = OpenCallerToken(TOKEN_QUERY, &hToken);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    fSts = GetTokenInformation(hToken, TokenUser, pTokenUser,
                               dwInfoBufferSize, &dwInfoBufferSize);

    //
    // if fast buffer wasn't big enough, allocate enough storage
    // and try again.
    //

    if (!fSts)
    {
        dwSts = GetLastError();
        if (ERROR_INSUFFICIENT_BUFFER != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        SlowBuffer = (PTOKEN_USER)ContInfoAlloc(dwInfoBufferSize);
        if (NULL == SlowBuffer)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        pTokenUser = SlowBuffer;
        fSts = GetTokenInformation(hToken, TokenUser, pTokenUser,
                                   dwInfoBufferSize, &dwInfoBufferSize);
        if (!fSts)
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }
    }

    fSts = AllocateAndInitializeSid(&siaNtAuthority,
                                    1,
                                    SECURITY_LOCAL_SYSTEM_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &psidLocalSystem);
    if (!fSts)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if (EqualSid(psidLocalSystem, pTokenUser->User.Sid))
        *pfIsLocalSystem = TRUE;
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != SlowBuffer)
        ContInfoFree(SlowBuffer);
    if (NULL != psidLocalSystem)
        FreeSid(psidLocalSystem);
    if (NULL != hToken)
        CloseHandle(hToken);
    return dwReturn;
}


/*static*/ DWORD
GetTextualSidA(
    PSID pSid,              // binary Sid
    LPSTR TextualSid,       // buffer for Textual representaion of Sid
    LPDWORD dwBufferLen)    // required/provided TextualSid buffersize
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    BOOL fSts;
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwCounter;
    DWORD dwSidSize;


    fSts = IsValidSid(pSid);
    if (!fSts)
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto ErrorExit;
    }

    // obtain SidIdentifierAuthority
    psia = GetSidIdentifierAuthority(pSid);

    // obtain sidsubauthority count
    dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

    //
    // compute buffer length (conservative guess)
    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    dwSidSize = (15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(WCHAR);

    //
    // check provided buffer length.
    // If not large enough, indicate proper size and setlasterror
    if (*dwBufferLen < dwSidSize)
    {
        *dwBufferLen = dwSidSize;
        dwReturn = ERROR_INSUFFICIENT_BUFFER;
        goto ErrorExit;
    }

    //
    // prepare S-SID_REVISION-
    dwSidSize = wsprintfA(TextualSid, "S-%lu-", SID_REVISION );

    //
    // prepare SidIdentifierAuthority
    if ((psia->Value[0] != 0) || (psia->Value[1] != 0))
    {
        dwSidSize += wsprintfA(TextualSid + dwSidSize,
                               "0x%02hx%02hx%02hx%02hx%02hx%02hx",
                               (USHORT)psia->Value[0],
                               (USHORT)psia->Value[1],
                               (USHORT)psia->Value[2],
                               (USHORT)psia->Value[3],
                               (USHORT)psia->Value[4],
                               (USHORT)psia->Value[5]);
    }
    else
    {
        dwSidSize += wsprintfA(TextualSid + dwSidSize,
                               "%lu",
                               (ULONG)(psia->Value[5])
                               + (ULONG)(psia->Value[4] <<  8)
                               + (ULONG)(psia->Value[3] << 16)
                               + (ULONG)(psia->Value[2] << 24));
    }

    //
    // loop through SidSubAuthorities
    for (dwCounter = 0; dwCounter < dwSubAuthorities; dwCounter++)
    {
        dwSidSize += wsprintfA(TextualSid + dwSidSize,
                               "-%lu",
                               *GetSidSubAuthority(pSid, dwCounter));
    }

    *dwBufferLen = dwSidSize + 1; // tell caller how many chars (include NULL)
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


/*static*/ DWORD
GetTextualSidW(
    PSID pSid,              // binary Sid
    LPWSTR wszTextualSid,   // buffer for Textual representaion of Sid
    LPDWORD dwBufferLen)    // required/provided TextualSid buffersize
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    BOOL fSts;
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwCounter;
    DWORD dwSidSize;


    fSts = IsValidSid(pSid);
    if (!fSts)
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto ErrorExit;
    }

    // obtain SidIdentifierAuthority
    psia = GetSidIdentifierAuthority(pSid);

    // obtain sidsubauthority count
    dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

    //
    // compute buffer length (conservative guess)
    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    dwSidSize = (15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(WCHAR);

    //
    // check provided buffer length.
    // If not large enough, indicate proper size and setlasterror
    if (*dwBufferLen < dwSidSize)
    {
        *dwBufferLen = dwSidSize;
        dwReturn = ERROR_INSUFFICIENT_BUFFER;
        goto ErrorExit;
    }

    //
    // prepare S-SID_REVISION-
    dwSidSize = wsprintfW(wszTextualSid, L"S-%lu-", SID_REVISION);

    //
    // prepare SidIdentifierAuthority
    if ((psia->Value[0] != 0) || (psia->Value[1] != 0))
    {
        dwSidSize += wsprintfW(wszTextualSid + dwSidSize,
                               L"0x%02hx%02hx%02hx%02hx%02hx%02hx",
                               (USHORT)psia->Value[0],
                               (USHORT)psia->Value[1],
                               (USHORT)psia->Value[2],
                               (USHORT)psia->Value[3],
                               (USHORT)psia->Value[4],
                               (USHORT)psia->Value[5]);
    }
    else
    {
        dwSidSize += wsprintfW(wszTextualSid + dwSidSize,
                               L"%lu",
                               (ULONG)(psia->Value[5])
                               + (ULONG)(psia->Value[4] <<  8)
                               + (ULONG)(psia->Value[3] << 16)
                               + (ULONG)(psia->Value[2] << 24));
    }

    //
    // loop through SidSubAuthorities
    for (dwCounter = 0; dwCounter < dwSubAuthorities; dwCounter++)
    {
        dwSidSize += wsprintfW(wszTextualSid + dwSidSize,
                               L"-%lu",
                               *GetSidSubAuthority(pSid, dwCounter));
    }

    *dwBufferLen = dwSidSize + 1; // tell caller how many chars (include NULL)
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


/*static*/ DWORD
GetUserSid(
    PTOKEN_USER *pptgUser,
    DWORD *pcbUser,
    BOOL *pfAlloced)
{
    DWORD       dwReturn = ERROR_INTERNAL_ERROR;
    BOOL        fSts;
    DWORD       dwSts;
    HANDLE      hToken = 0;

    *pfAlloced = FALSE;

    dwSts = OpenCallerToken(TOKEN_QUERY, &hToken);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    fSts = GetTokenInformation(hToken,    // identifies access token
                               TokenUser, // TokenUser info type
                               *pptgUser, // retrieved info buffer
                               *pcbUser,  // size of buffer passed-in
                               pcbUser);  // required buffer size
    if (!fSts)
    {
        dwSts = GetLastError();
        if (ERROR_INSUFFICIENT_BUFFER != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        //
        // try again with the specified buffer size
        //

        *pptgUser = (PTOKEN_USER)ContInfoAlloc(*pcbUser);
        if (NULL == *pptgUser)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        *pfAlloced = TRUE;
        fSts = GetTokenInformation(hToken,    // identifies access token
                                   TokenUser, // TokenUser info type
                                   *pptgUser, // retrieved info buffer
                                   *pcbUser,  // size of buffer passed-in
                                   pcbUser);  // required buffer size
        if (!fSts)
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != hToken)
        CloseHandle(hToken);
    return dwReturn;
}


DWORD
GetUserTextualSidA(
    LPSTR lpBuffer,
    LPDWORD nSize)
{
    DWORD       dwReturn = ERROR_INTERNAL_ERROR;
    DWORD       dwSts;
    BYTE        FastBuffer[FAST_BUF_SIZE];
    PTOKEN_USER ptgUser;
    DWORD       cbUser;
    BOOL        fAlloced = FALSE;

    ptgUser = (PTOKEN_USER)FastBuffer; // try fast buffer first
    cbUser = FAST_BUF_SIZE;
    dwSts = GetUserSid(&ptgUser, &cbUser, &fAlloced);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }


    //
    // obtain the textual representaion of the Sid
    //

    dwSts = GetTextualSidA(ptgUser->User.Sid, // user binary Sid
                           lpBuffer,          // buffer for TextualSid
                           nSize);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (fAlloced)
    {
        if (NULL != ptgUser)
            ContInfoFree(ptgUser);
    }
    return dwReturn;
}

DWORD
GetUserTextualSidW(
    LPWSTR lpBuffer,
    LPDWORD nSize)
{
    DWORD       dwReturn = ERROR_INTERNAL_ERROR;
    DWORD       dwSts;
    BYTE        FastBuffer[FAST_BUF_SIZE];
    PTOKEN_USER ptgUser;
    DWORD       cbUser;
    BOOL        fAlloced = FALSE;

    ptgUser = (PTOKEN_USER)FastBuffer; // try fast buffer first
    cbUser = FAST_BUF_SIZE;
    dwSts = GetUserSid(&ptgUser, &cbUser, &fAlloced);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }


    //
    // obtain the textual representaion of the Sid
    //

    dwSts = GetTextualSidW(ptgUser->User.Sid, // user binary Sid
                           lpBuffer,          // buffer for TextualSid
                           nSize);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (fAlloced)
    {
        if (NULL != ptgUser)
            ContInfoFree(ptgUser);
    }
    return dwReturn;
}

/*static*/ DWORD
GetUserDirectory(
    IN BOOL fMachineKeyset,
    OUT LPWSTR pwszUser,
    OUT DWORD *pcbUser)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    DWORD dwSts;

    if (fMachineKeyset)
    {
        wcscpy(pwszUser, MACHINE_KEYS_DIR);
        *pcbUser = wcslen(pwszUser) + 1;
    }
    else
    {
        if (FIsWinNT())
        {
            dwSts = GetUserTextualSidW(pwszUser, pcbUser);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
        }
        else
        {
            dwReturn = (DWORD)NTE_FAIL;
            goto ErrorExit;
        }
    }
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


#define WSZRSAPRODUCTSTRING  L"\\Microsoft\\Crypto\\RSA\\"
#define WSZDSSPRODUCTSTRING  L"\\Microsoft\\Crypto\\DSS\\"
#define PRODUCTSTRINGLEN    sizeof(WSZRSAPRODUCTSTRING) - sizeof(WCHAR)

typedef HRESULT
(WINAPI *SHGETFOLDERPATHW)(
    HWND hwnd,
    int csidl,
    HANDLE hToken,
    DWORD dwFlags,
    LPWSTR pwszPath);

/*static*/ DWORD
GetUserStorageArea(
    IN  DWORD dwProvType,
    IN  BOOL fMachineKeyset,
    IN  BOOL fOldWin2KMachineKeyPath,
    OUT BOOL *pfIsLocalSystem,  // used if fMachineKeyset is FALSE, in this
                                // case TRUE is returned if running as Local
                                // System
    IN  OUT LPWSTR *ppwszUserStorageArea)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    WCHAR wszUserStorageRoot[MAX_PATH+1];
    DWORD cbUserStorageRoot;
    WCHAR *wszProductString = NULL;
    WCHAR wszUser[MAX_PATH];
    DWORD cbUser;
    DWORD cchUser = MAX_PATH;
    HANDLE hToken = NULL;
    DWORD dwTempProfileFlags = 0;
    DWORD dwSts;
    BOOL fSts;
    HMODULE hShell32 = NULL;
    PBYTE pbCurrent;

    *pfIsLocalSystem = FALSE;

    if ((PROV_RSA_SIG == dwProvType)
        || (PROV_RSA_FULL == dwProvType)
        || (PROV_RSA_SCHANNEL == dwProvType)
        || (PROV_RSA_AES == dwProvType))
    {
        wszProductString = WSZRSAPRODUCTSTRING;
    }
    else if ((PROV_DSS == dwProvType)
             || (PROV_DSS_DH == dwProvType)
             || (PROV_DH_SCHANNEL == dwProvType))
    {
        wszProductString = WSZDSSPRODUCTSTRING;
    }


    //
    // check if running in the LocalSystem context
    //

    if (!fMachineKeyset)
    {
        dwSts = IsThreadLocalSystem(pfIsLocalSystem);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }


    //
    // determine path to per-user storage area, based on whether this
    // is a local machine disposition call or a per-user disposition call.
    //

    if (fMachineKeyset || *pfIsLocalSystem)
    {
        if (!fOldWin2KMachineKeyPath)
        {
            // Should not call SHGetFolderPathW with a caller token for 
            // the local machine case.  The COMMON_APPDATA location is 
            // per-machine, not per-user, therefor we shouldn't be supplying
            // a user token.  The shell team should make their own change to ignore
            // this, though.
            /*
            dwSts = OpenCallerToken(TOKEN_QUERY | TOKEN_IMPERSONATE,
                                    &hToken);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
            */

            dwSts = (DWORD) SHGetFolderPathW(NULL,
                                             CSIDL_COMMON_APPDATA | CSIDL_FLAG_CREATE,
                                             0 /*hToken*/,
                                             0,
                                             wszUserStorageRoot);
            if (dwSts != ERROR_SUCCESS)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }

            /*
            CloseHandle(hToken);
            hToken = NULL;
            */

            cbUserStorageRoot = wcslen( wszUserStorageRoot ) * sizeof(WCHAR);
        }
        else
        {
            cbUserStorageRoot = GetSystemDirectoryW(wszUserStorageRoot,
                                                    MAX_PATH);
            cbUserStorageRoot *= sizeof(WCHAR);
        }
    }
    else
    {
        // check if the profile is temporary
        fSts = GetProfileType(&dwTempProfileFlags);
        if (!fSts)
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }

         if ((dwTempProfileFlags & PT_MANDATORY)
             || ((dwTempProfileFlags & PT_TEMPORARY)
                 && !(dwTempProfileFlags & PT_ROAMING)))
        {
            dwReturn = (DWORD)NTE_TEMPORARY_PROFILE;
            goto ErrorExit;
        }

        dwSts = OpenCallerToken(TOKEN_QUERY | TOKEN_IMPERSONATE,
                                &hToken);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        // Use new private shell entry point for finding user storage path
        if (ERROR_SUCCESS != 
            (dwSts = GetUserAppDataPathW(hToken, FALSE, wszUserStorageRoot)))
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        CloseHandle(hToken);
        hToken = NULL;
        cbUserStorageRoot = wcslen( wszUserStorageRoot ) * sizeof(WCHAR);
    }

    if (cbUserStorageRoot == 0)
    {
        dwReturn = (DWORD)NTE_FAIL;
        goto ErrorExit;
    }


    //
    // get the user name associated with the call.
    // Note: this is the textual Sid on NT, and will fail on Win95.
    //

    dwSts = GetUserDirectory(fMachineKeyset, wszUser, &cchUser);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    cbUser = (cchUser-1) * sizeof(WCHAR);
    *ppwszUserStorageArea = (LPWSTR)ContInfoAlloc(cbUserStorageRoot
                                                  + PRODUCTSTRINGLEN
                                                  + cbUser
                                                  + 2 * sizeof(WCHAR)); // trailing slash and NULL
    if (NULL == *ppwszUserStorageArea)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    pbCurrent = (PBYTE)*ppwszUserStorageArea;

    CopyMemory(pbCurrent, wszUserStorageRoot, cbUserStorageRoot);
    pbCurrent += cbUserStorageRoot;

    CopyMemory(pbCurrent, wszProductString, PRODUCTSTRINGLEN);
    pbCurrent += PRODUCTSTRINGLEN;

    CopyMemory(pbCurrent, wszUser, cbUser);
    pbCurrent += cbUser; // note: cbUser does not include terminal NULL

    ((LPSTR)pbCurrent)[0] = '\\';
    ((LPSTR)pbCurrent)[1] = '\0';


    dwSts = CreateNestedDirectories(*ppwszUserStorageArea,
                                    (LPWSTR)((LPBYTE)*ppwszUserStorageArea
                                                      + cbUserStorageRoot
                                                      + sizeof(WCHAR)),
                                    fMachineKeyset);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != hToken)
        CloseHandle(hToken);
    return dwReturn;
}


/*static*/ DWORD
GetFilePath(
    IN      LPCWSTR  pwszUserStorageArea,
    IN      LPCWSTR  pwszFileName,
    IN OUT  LPWSTR   *ppwszFilePath)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    DWORD cbUserStorageArea;
    DWORD cbFileName;

    cbUserStorageArea = wcslen(pwszUserStorageArea) * sizeof(WCHAR);
    cbFileName = wcslen(pwszFileName) * sizeof(WCHAR);
    *ppwszFilePath = (LPWSTR)ContInfoAlloc(cbUserStorageArea
                                           + cbFileName
                                           + sizeof(WCHAR));
    if (*ppwszFilePath == NULL)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    CopyMemory(*ppwszFilePath, pwszUserStorageArea, cbUserStorageArea);
    CopyMemory((LPBYTE)*ppwszFilePath+cbUserStorageArea, pwszFileName, cbFileName + sizeof(WCHAR));
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


static DWORD
    rgdwCreateFileRetryMilliseconds[] =
        { 1, 10, 100, 500, 1000, 5000 };

#define MAX_CREATE_FILE_RETRY_COUNT     \
            (sizeof(rgdwCreateFileRetryMilliseconds) \
             / sizeof(rgdwCreateFileRetryMilliseconds[0]))

/*static*/ DWORD
MyCreateFile(
    IN BOOL fMachineKeyset,         // indicates if this is a machine keyset
    IN LPCWSTR wszFilePath,         // pointer to name of the file
    IN DWORD dwDesiredAccess,       // access (read-write) mode
    IN DWORD dwShareMode,           // share mode
    IN DWORD dwCreationDisposition, // how to create
    IN DWORD dwAttribs,             // file attributes
    OUT HANDLE *phFile)             // Resultant handle
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    HANDLE          hToken = 0;
    BYTE            rgbPriv[sizeof(PRIVILEGE_SET) + sizeof(LUID_AND_ATTRIBUTES)];
    PRIVILEGE_SET   *pPriv = (PRIVILEGE_SET*)rgbPriv;
    BOOL            fPrivSet = FALSE;
    HANDLE          hFile = INVALID_HANDLE_VALUE;
    DWORD           dwSts, dwSavedSts;
    BOOL            fSts;

    hFile = CreateFileW(wszFilePath,
                        dwDesiredAccess,
                        dwShareMode,
                        NULL,
                        dwCreationDisposition,
                        dwAttribs,
                        NULL);
    if (INVALID_HANDLE_VALUE == hFile)
    {
        dwSts = GetLastError();

        // check if machine keyset
        if (fMachineKeyset)
        {
            dwSavedSts = dwSts;

            // open a token handle
            dwSts = OpenCallerToken(TOKEN_QUERY, &hToken);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }

            memset(rgbPriv, 0, sizeof(rgbPriv));
            pPriv->PrivilegeCount = 1;
            // reading file
            if (dwDesiredAccess & GENERIC_READ)
            {
                fSts = LookupPrivilegeValue(NULL, SE_BACKUP_NAME,
                                           &(pPriv->Privilege[0].Luid));
            }
            // writing
            else
            {
                fSts = LookupPrivilegeValue(NULL, SE_RESTORE_NAME,
                                            &(pPriv->Privilege[0].Luid));
            }
            if (!fSts)
            {
                dwReturn = GetLastError();
                goto ErrorExit;
            }

            // check if the BACKUP or RESTORE privileges are set
            pPriv->Privilege[0].Attributes = SE_PRIVILEGE_ENABLED;
            fSts = PrivilegeCheck(hToken, pPriv, &fPrivSet);
            if (!fSts)
            {
                dwReturn = GetLastError();
                goto ErrorExit;
            }

            if (fPrivSet)
            {
                hFile = CreateFileW(wszFilePath,
                                    dwDesiredAccess,
                                    dwShareMode,
                                    NULL,
                                    dwCreationDisposition,
                                    dwAttribs | FILE_FLAG_BACKUP_SEMANTICS,
                                    NULL);
                if (INVALID_HANDLE_VALUE == hFile)
                {
                    dwReturn = GetLastError();
                    goto ErrorExit;
                }
            }
            else
            {
                dwReturn = dwSavedSts;
                goto ErrorExit;
            }
        }
        else
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    *phFile = hFile;
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != hToken)
        CloseHandle(hToken);
    return dwReturn;
}


/*static*/ DWORD
OpenFileInStorageArea(
    IN      BOOL    fMachineKeyset,
    IN      DWORD   dwDesiredAccess,
    IN      LPCWSTR wszUserStorageArea,
    IN      LPCWSTR wszFileName,
    IN OUT  HANDLE  *phFile)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    LPWSTR wszFilePath = NULL;
    DWORD dwShareMode = 0;
    DWORD dwCreationDistribution = OPEN_EXISTING;
    DWORD dwRetryCount;
    DWORD dwAttribs = 0;
    DWORD dwSts;

    *phFile = INVALID_HANDLE_VALUE;

    if (dwDesiredAccess & GENERIC_READ)
    {
        dwShareMode |= FILE_SHARE_READ;
        dwCreationDistribution = OPEN_EXISTING;
    }

    if (dwDesiredAccess & GENERIC_WRITE)
    {
        dwShareMode = 0;
        dwCreationDistribution = OPEN_ALWAYS;
        dwAttribs = FILE_ATTRIBUTE_SYSTEM;
    }

    dwSts = GetFilePath(wszUserStorageArea, wszFileName, &wszFilePath);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwRetryCount = 0;
    for (;;)
    {
        dwSts = MyCreateFile(fMachineKeyset,
                             wszFilePath,
                             dwDesiredAccess,
                             dwShareMode,
                             dwCreationDistribution,
                             dwAttribs | FILE_FLAG_SEQUENTIAL_SCAN,
                             phFile);
        if (ERROR_SUCCESS == dwSts)
            break;

        if (((ERROR_SHARING_VIOLATION == dwSts)
             || (ERROR_ACCESS_DENIED == dwSts))
            && (MAX_CREATE_FILE_RETRY_COUNT > dwRetryCount))
        {
            Sleep(rgdwCreateFileRetryMilliseconds[dwRetryCount]);
            dwRetryCount++;
        }
        else
        {
            if (ERROR_FILE_NOT_FOUND == dwSts)
                dwReturn = (DWORD)NTE_BAD_KEYSET;
            else
                dwReturn = dwSts;
            goto ErrorExit;
        }
    }
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != wszFilePath)
        ContInfoFree(wszFilePath);
    return dwReturn;
}


/*static*/ DWORD
FindClosestFileInStorageArea(
    IN      LPCWSTR  pwszUserStorageArea,
    IN      LPCSTR   pszContainer,
    OUT     LPWSTR   pwszNewFileName,
    IN OUT  HANDLE  *phFile)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    LPWSTR pwszFilePath = NULL;
    WCHAR  rgwszNewFileName[35];
    DWORD dwShareMode = 0;
    DWORD dwCreationDistribution = OPEN_EXISTING;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW FindData;
    DWORD dwSts;

    memset(&FindData, 0, sizeof(FindData));
    memset(rgwszNewFileName, 0, sizeof(rgwszNewFileName));

    *phFile = INVALID_HANDLE_VALUE;

    dwShareMode |= FILE_SHARE_READ;
    dwCreationDistribution = OPEN_EXISTING;

    // get the stringized hash of the container name
    dwSts = GetHashOfContainer(pszContainer, rgwszNewFileName);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // ContInfoAlloc zeros memory so no need to set NULL terminator
    rgwszNewFileName[32] = '_';
    rgwszNewFileName[33] = '*';

    dwSts = GetFilePath(pwszUserStorageArea, rgwszNewFileName, &pwszFilePath);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    hFind = FindFirstFileExW(pwszFilePath,
                             FindExInfoStandard,
                             &FindData,
                             FindExSearchNameMatch,
                             NULL,
                             0);
    if (hFind == INVALID_HANDLE_VALUE)
    {
        dwSts = GetLastError();
        if (ERROR_FILE_NOT_FOUND == dwSts)
            dwReturn = (DWORD)NTE_BAD_KEYSET;
        else
            dwReturn = dwSts;
        goto ErrorExit;
    }

    ContInfoFree(pwszFilePath);
    pwszFilePath = NULL;

    dwSts = GetFilePath(pwszUserStorageArea, FindData.cFileName,
                        &pwszFilePath);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    *phFile = CreateFileW(pwszFilePath,
                          GENERIC_READ,
                          dwShareMode,
                          NULL,
                          dwCreationDistribution,
                          FILE_FLAG_SEQUENTIAL_SCAN,
                          NULL);
    if (*phFile == INVALID_HANDLE_VALUE)
    {
        dwSts = GetLastError();
        if (ERROR_FILE_NOT_FOUND == dwSts)
            dwReturn = (DWORD)NTE_BAD_KEYSET;
        else
            dwReturn = dwSts;
        goto ErrorExit;
    }

    // allocate and copy in the real file name to be returned
    wcscpy(pwszNewFileName, FindData.cFileName);
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != hFind)
        FindClose(hFind);
    if (NULL != pwszFilePath)
        ContInfoFree(pwszFilePath);
    return dwReturn;
}


//
//  This function gets the determines if the user associated with the
//  specified token is the Local System account.
//

/*static*/ DWORD
ZeroizeFile(
    IN LPCWSTR wszFilePath)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    BYTE    *pb = NULL;
    DWORD   cb;
    DWORD   dwBytesWritten = 0;
    DWORD   dwSts;
    BOOL    fSts;

    hFile = CreateFileW(wszFilePath,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_SYSTEM,
                        NULL);
    if (INVALID_HANDLE_VALUE == hFile)
    {
        dwSts = GetLastError();
        if (ERROR_FILE_NOT_FOUND == dwSts)
            dwReturn = (DWORD)NTE_BAD_KEYSET;
        else
            dwReturn = dwSts;
        goto ErrorExit;
    }

    cb = GetFileSize(hFile, NULL);
    if ((DWORD)(-1) == cb)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    pb = ContInfoAlloc(cb);
    if (NULL == pb)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    fSts = WriteFile(hFile, pb, cb, &dwBytesWritten, NULL);
    if (!fSts)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != pb)
        ContInfoFree(pb);
    if (INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);
    return dwReturn;
}


/*static*/ DWORD
DeleteFileInStorageArea(
    IN LPCWSTR wszUserStorageArea,
    IN LPCWSTR wszFileName)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    LPWSTR wszFilePath = NULL;
    DWORD cbUserStorageArea;
    DWORD cbFileName;
    DWORD dwSts;
    WCHAR rgwszTempFile[MAX_PATH];
    WCHAR rgwszTempPath[MAX_PATH];
    DWORD dwTempFileUnique = 0;

    cbUserStorageArea = wcslen(wszUserStorageArea) * sizeof(WCHAR);
    cbFileName = wcslen(wszFileName) * sizeof(WCHAR);

    wszFilePath = (LPWSTR)ContInfoAlloc((cbUserStorageArea + cbFileName + 1) * sizeof(WCHAR));
    if (wszFilePath == NULL)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    CopyMemory(wszFilePath, wszUserStorageArea, cbUserStorageArea);
    CopyMemory((LPBYTE)wszFilePath + cbUserStorageArea, wszFileName,
               cbFileName + sizeof(WCHAR));

    // write a file of the same size with all zeros first
    dwSts = ZeroizeFile(wszFilePath);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    if (!DeleteFileW(wszFilePath))
    {
        // DeleteFile failed, so the container is now corrupted since it's
        // been zeroized.  Attempt to recover by renaming the file to a temp,
        // so it won't subsequently collide with a valid container file name.

        dwReturn = GetLastError();

        // The target temp file will be in the %tmp% or %temp% directory,
        // since placing it in the container directory will affect other
        // container-related code (enumeration, etc.).

        if (0 == GetTempPathW(MAX_PATH, rgwszTempPath))
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }

        // We want to be as certain as possible that the temp file name is 
        // unique, but we don't want GetTempFileName to create the file for 
        // us.

        if (! NewGenRandom(
            NULL, NULL, 
            (PBYTE) &dwTempFileUnique, sizeof(dwTempFileUnique)))
        {
            dwReturn = ERROR_INTERNAL_ERROR;
            goto ErrorExit;
        }

        if (0 == GetTempFileNameW(
            rgwszTempPath, 
            L"csp", 
            dwTempFileUnique, 
            rgwszTempFile))
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }

        if (! MoveFileExW(wszFilePath, rgwszTempFile, MOVEFILE_REPLACE_EXISTING))
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }

        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != wszFilePath)
        ContInfoFree(wszFilePath);
    return dwReturn;
}


DWORD
SetContainerUserName(
    IN LPSTR pszUserName,
    IN PKEY_CONTAINER_INFO pContInfo)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;

    pContInfo->pszUserName = (LPSTR)ContInfoAlloc((strlen(pszUserName) + 1) * sizeof(CHAR));
    if (NULL == pContInfo->pszUserName)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    strcpy(pContInfo->pszUserName, pszUserName);
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


DWORD
ReadContainerInfo(
    IN DWORD dwProvType,
    IN LPSTR pszContainerName,
    IN BOOL fMachineKeyset,
    IN DWORD dwFlags,
    OUT PKEY_CONTAINER_INFO pContInfo)
{
    DWORD                   dwReturn = ERROR_INTERNAL_ERROR;
    //HANDLE                  hMap = NULL;
    BYTE                    *pbFile = NULL;
    DWORD                   cbFile;
    DWORD                   cb;
    HANDLE                  hFile = INVALID_HANDLE_VALUE;
    KEY_EXPORTABILITY_LENS  Exportability;
    LPWSTR                  pwszFileName = NULL;
    LPWSTR                  pwszFilePath = NULL;
    WCHAR                   rgwszOtherMachineFileName[84];
    BOOL                    fGetUserNameFromFile = FALSE;
    BOOL                    fIsLocalSystem = FALSE;
    BOOL                    fRetryWithHashedName = TRUE;
    DWORD                   cch = 0;
    DWORD                   dwSts;
    DWORD                   cbRead = 0;

    memset(&Exportability, 0, sizeof(Exportability));

    // get the correct storage area (directory)
    dwSts = GetUserStorageArea(dwProvType, fMachineKeyset, FALSE,
                               &fIsLocalSystem, &pwszFilePath);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // check if the length of the container name is the length of a new unique container,
    // then try with the container name which was passed in, if this fails
    // then try with the container name with the machine GUID appended
    if (69 == strlen(pszContainerName))
    {
        // convert to UNICODE pszContainerName -> pwszFileName
        cch = MultiByteToWideChar(CP_ACP, MB_COMPOSITE,
                                  pszContainerName,
                                  -1, NULL, cch);
        if (0 == cch)
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }

        pwszFileName = ContInfoAlloc((cch + 1) * sizeof(WCHAR));
        if (NULL == pwszFileName)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        cch = MultiByteToWideChar(CP_ACP, MB_COMPOSITE,
                                  pszContainerName,
                                  -1, pwszFileName, cch);
        if (0 == cch)
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }

        dwSts = OpenFileInStorageArea(fMachineKeyset, GENERIC_READ,
                                      pwszFilePath, pwszFileName, &hFile);
        if (ERROR_SUCCESS == dwSts)
        {
            wcscpy(pContInfo->rgwszFileName, pwszFileName);

            // set the flag so the name of the key container will be retrieved
            // from the file
            fGetUserNameFromFile = TRUE;
            fRetryWithHashedName = FALSE;
        }
    }

    if (fRetryWithHashedName)
    {
        dwSts = AddMachineGuidToContainerName(pszContainerName,
                                              pContInfo->rgwszFileName);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = OpenFileInStorageArea(fMachineKeyset, GENERIC_READ,
                                      pwszFilePath,
                                      pContInfo->rgwszFileName,
                                      &hFile);
        if (ERROR_SUCCESS != dwSts)
        {
            if ((ERROR_ACCESS_DENIED == dwSts) && (dwFlags & CRYPT_NEWKEYSET))
            {
                dwReturn = (DWORD)NTE_EXISTS;
                goto ErrorExit;
            }

            if (NTE_BAD_KEYSET == dwSts)
            {
                if (fMachineKeyset || fIsLocalSystem)
                {
                    dwReturn = dwSts;
                    goto ErrorExit;
                }
                else
                {
                    memset(rgwszOtherMachineFileName, 0,
                           sizeof(rgwszOtherMachineFileName));
                    // try to open any file from another machine with this
                    // container name
                    dwSts = FindClosestFileInStorageArea(pwszFilePath,
                                                         pszContainerName,
                                                         rgwszOtherMachineFileName,
                                                         &hFile);
                    if (ERROR_SUCCESS != dwSts)
                    {
                        dwReturn = dwSts;
                        goto ErrorExit;
                    }
                    wcscpy(pContInfo->rgwszFileName,
                           rgwszOtherMachineFileName);
                }
            }
        }
    }

    if (dwFlags & CRYPT_NEWKEYSET)
    {
        dwReturn = (DWORD)NTE_EXISTS;
        goto ErrorExit;
    }

    cbFile = GetFileSize(hFile, NULL);
    if ((DWORD)(-1) == cbFile)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if (sizeof(KEY_CONTAINER_LENS) > cbFile)
    {
        dwReturn = (DWORD)NTE_KEYSET_ENTRY_BAD;
        goto ErrorExit;
    }

    pbFile = ContInfoAlloc(cbFile);

    if (NULL == pbFile)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    if (FALSE == ReadFile(
        hFile,
        pbFile,
        cbFile,
        &cbRead,
        NULL))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if (cbFile != cbRead)
    {
        dwReturn = NTE_KEYSET_ENTRY_BAD;
        goto ErrorExit;
    }

    /*
    hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (NULL == hMap)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    pbFile = (BYTE*)MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
    if (NULL == pbFile)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }
    */

    // get the length information out of the file
    memcpy(&pContInfo->dwVersion, pbFile, sizeof(DWORD));
    cb = sizeof(DWORD);
    if (KEY_CONTAINER_FILE_FORMAT_VER != pContInfo->dwVersion)
    {
        dwSts = (DWORD)NTE_KEYSET_ENTRY_BAD;
        goto ErrorExit;
    }

    memcpy(&pContInfo->ContLens, pbFile + cb, sizeof(KEY_CONTAINER_LENS));
    cb += sizeof(KEY_CONTAINER_LENS);

    if (pContInfo->fCryptSilent && (0 != pContInfo->ContLens.dwUIOnKey))
    {
        dwReturn = (DWORD)NTE_SILENT_CONTEXT;
        goto ErrorExit;
    }

    // get the private key exportability stuff
    memcpy(&Exportability, pbFile + cb, sizeof(KEY_EXPORTABILITY_LENS));
    cb += sizeof(KEY_EXPORTABILITY_LENS);

    // get the user name
    pContInfo->pszUserName = ContInfoAlloc(pContInfo->ContLens.cbName);
    if (NULL == pContInfo->pszUserName)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    memcpy(pContInfo->pszUserName, pbFile + cb, pContInfo->ContLens.cbName);
    cb += pContInfo->ContLens.cbName;

    // get the random seed
    pContInfo->pbRandom = ContInfoAlloc(pContInfo->ContLens.cbRandom);
    if (NULL == pContInfo->pbRandom)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    memcpy(pContInfo->pbRandom, pbFile + cb, pContInfo->ContLens.cbRandom);
    cb += pContInfo->ContLens.cbRandom;

    // get the signature key info out of the file
    if (pContInfo->ContLens.cbSigPub && pContInfo->ContLens.cbSigEncPriv)
    {
        pContInfo->pbSigPub = ContInfoAlloc(pContInfo->ContLens.cbSigPub);
        if (NULL == pContInfo->pbSigPub)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        memcpy(pContInfo->pbSigPub, pbFile + cb, pContInfo->ContLens.cbSigPub);
        cb += pContInfo->ContLens.cbSigPub;

        pContInfo->pbSigEncPriv = ContInfoAlloc(pContInfo->ContLens.cbSigEncPriv);
        if (NULL == pContInfo->pbSigEncPriv)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        memcpy(pContInfo->pbSigEncPriv, pbFile + cb,
               pContInfo->ContLens.cbSigEncPriv);
        cb += pContInfo->ContLens.cbSigEncPriv;

        // get the exportability info for the sig key
        dwSts = UnprotectExportabilityFlag(fMachineKeyset, pbFile + cb,
                                           Exportability.cbSigExportability,
                                           &pContInfo->fSigExportable);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        cb += Exportability.cbSigExportability;
    }

    // get the signature key info out of the file
    if (pContInfo->ContLens.cbExchPub && pContInfo->ContLens.cbExchEncPriv)
    {
        pContInfo->pbExchPub = ContInfoAlloc(pContInfo->ContLens.cbExchPub);
        if (NULL == pContInfo->pbExchPub)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        memcpy(pContInfo->pbExchPub, pbFile + cb,
               pContInfo->ContLens.cbExchPub);
        cb += pContInfo->ContLens.cbExchPub;

        pContInfo->pbExchEncPriv = ContInfoAlloc(pContInfo->ContLens.cbExchEncPriv);
        if (NULL == pContInfo->pbExchEncPriv)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        memcpy(pContInfo->pbExchEncPriv, pbFile + cb,
               pContInfo->ContLens.cbExchEncPriv);
        cb += pContInfo->ContLens.cbExchEncPriv;

        // get the exportability info for the sig key
        dwSts = UnprotectExportabilityFlag(fMachineKeyset, pbFile + cb,
                                           Exportability.cbExchExportability,
                                           &pContInfo->fExchExportable);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        cb += Exportability.cbExchExportability;
    }

    pContInfo = NULL;
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != pwszFileName)
        ContInfoFree(pwszFileName);
    if (NULL != pContInfo)
        FreeContainerInfo(pContInfo);
    if (NULL != pwszFilePath)
        ContInfoFree(pwszFilePath);
    /*
    if (NULL != pbFile)
        UnmapViewOfFile(pbFile);
    if (NULL != hMap)
        CloseHandle(hMap);
        */
    if (pbFile)
        ContInfoFree(pbFile);
    if (INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);
    return dwReturn;
}


DWORD
WriteContainerInfo(
    IN DWORD dwProvType,
    IN LPWSTR pwszFileName,
    IN BOOL fMachineKeyset,
    IN PKEY_CONTAINER_INFO pContInfo)
{
    DWORD                   dwReturn = ERROR_INTERNAL_ERROR;
    BYTE                    *pbProtectedSigExportFlag = NULL;
    BYTE                    *pbProtectedExchExportFlag = NULL;
    KEY_EXPORTABILITY_LENS  ExportabilityLens;
    BYTE                    *pb = NULL;
    DWORD                   cb;
    LPWSTR                  pwszFilePath = NULL;
    HANDLE                  hFile = 0;
    DWORD                   dwBytesWritten;
    BOOL                    fIsLocalSystem = FALSE;
    DWORD                   dwSts;
    BOOL                    fSts;

    memset(&ExportabilityLens, 0, sizeof(ExportabilityLens));

    // protect the signature exportability flag if necessary
    if (pContInfo->ContLens.cbSigPub && pContInfo->ContLens.cbSigEncPriv)
    {
        dwSts = ProtectExportabilityFlag(pContInfo->fSigExportable,
                                         fMachineKeyset, &pbProtectedSigExportFlag,
                                         &ExportabilityLens.cbSigExportability);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    // protect the key exchange exportability flag if necessary
    if (pContInfo->ContLens.cbExchPub && pContInfo->ContLens.cbExchEncPriv)
    {
        dwSts = ProtectExportabilityFlag(pContInfo->fExchExportable,
                                         fMachineKeyset, &pbProtectedExchExportFlag,
                                         &ExportabilityLens.cbExchExportability);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    pContInfo->ContLens.cbName = strlen(pContInfo->pszUserName) + sizeof(CHAR);

    // calculate the buffer length required for the container info
    cb = pContInfo->ContLens.cbSigPub + pContInfo->ContLens.cbSigEncPriv +
         pContInfo->ContLens.cbExchPub + pContInfo->ContLens.cbExchEncPriv +
         ExportabilityLens.cbSigExportability +
         ExportabilityLens.cbExchExportability +
         pContInfo->ContLens.cbName +
         pContInfo->ContLens.cbRandom +
         sizeof(KEY_EXPORTABILITY_LENS) + sizeof(KEY_CONTAINER_INFO) +
         sizeof(DWORD);

    pb = (BYTE*)ContInfoAlloc(cb);
    if (NULL == pb)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    // copy the length information
    pContInfo->dwVersion = KEY_CONTAINER_FILE_FORMAT_VER;
    memcpy(pb, &pContInfo->dwVersion, sizeof(DWORD));
    cb = sizeof(DWORD);
    memcpy(pb + cb, &pContInfo->ContLens, sizeof(KEY_CONTAINER_LENS));
    cb += sizeof(KEY_CONTAINER_LENS);
    if (KEY_CONTAINER_FILE_FORMAT_VER != pContInfo->dwVersion)
    {
        dwReturn = (DWORD)NTE_KEYSET_ENTRY_BAD;
        goto ErrorExit;
    }

    memcpy(pb + cb, &ExportabilityLens, sizeof(KEY_EXPORTABILITY_LENS));
    cb += sizeof(KEY_EXPORTABILITY_LENS);

    // copy the name of the container to the file
    memcpy(pb + cb, pContInfo->pszUserName, pContInfo->ContLens.cbName);
    cb += pContInfo->ContLens.cbName;

    // copy the random seed to the file
    memcpy(pb + cb, pContInfo->pbRandom, pContInfo->ContLens.cbRandom);
    cb += pContInfo->ContLens.cbRandom;

    // copy the signature key info to the file
    if (pContInfo->ContLens.cbSigPub || pContInfo->ContLens.cbSigEncPriv)
    {
        memcpy(pb + cb, pContInfo->pbSigPub, pContInfo->ContLens.cbSigPub);
        cb += pContInfo->ContLens.cbSigPub;

        memcpy(pb + cb, pContInfo->pbSigEncPriv,
               pContInfo->ContLens.cbSigEncPriv);
        cb += pContInfo->ContLens.cbSigEncPriv;

        // write the exportability info for the sig key
        memcpy(pb + cb, pbProtectedSigExportFlag,
               ExportabilityLens.cbSigExportability);
        cb += ExportabilityLens.cbSigExportability;
    }

    // get the signature key info out of the file
    if (pContInfo->ContLens.cbExchPub || pContInfo->ContLens.cbExchEncPriv)
    {
        memcpy(pb + cb, pContInfo->pbExchPub, pContInfo->ContLens.cbExchPub);
        cb += pContInfo->ContLens.cbExchPub;

        memcpy(pb + cb, pContInfo->pbExchEncPriv,
               pContInfo->ContLens.cbExchEncPriv);
        cb += pContInfo->ContLens.cbExchEncPriv;

        // write the exportability info for the sig key
        memcpy(pb + cb, pbProtectedExchExportFlag,
               ExportabilityLens.cbExchExportability);
        cb += ExportabilityLens.cbExchExportability;
    }

    // get the correct storage area (directory)
    dwSts = GetUserStorageArea(dwProvType, fMachineKeyset, FALSE,
                               &fIsLocalSystem, &pwszFilePath);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // open the file to write the information to
    dwSts = OpenFileInStorageArea(fMachineKeyset, GENERIC_WRITE,
                                  pwszFilePath, pwszFileName,
                                  &hFile);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;   // NTE_FAIL
        goto ErrorExit;
    }

    fSts = WriteFile(hFile, pb, cb, &dwBytesWritten, NULL);
    if (!fSts)
    {
        dwReturn = GetLastError();  // NTE_FAIL
        goto ErrorExit;
    }
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != pwszFilePath)
        ContInfoFree(pwszFilePath);
    if (NULL != pbProtectedSigExportFlag)
        ContInfoFree(pbProtectedSigExportFlag);
    if (NULL != pbProtectedExchExportFlag)
        ContInfoFree(pbProtectedExchExportFlag);
    if (NULL != pb)
        ContInfoFree(pb);
    if (NULL != hFile)
        CloseHandle(hFile);
    return dwReturn;
}


/*static*/ DWORD
DeleteKeyContainer(
    IN LPWSTR pwszFilePath,
    IN LPSTR pszContainer)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    LPWSTR  pwszFileName = NULL;
    WCHAR   rgwchNewFileName[80];
    BOOL    fRetryWithHashedName = TRUE;
    DWORD   cch = 0;
    DWORD   dwSts;

    memset(rgwchNewFileName, 0, sizeof(rgwchNewFileName));

    // first try with the container name which was passed in, if this fails
    if (69 == strlen(pszContainer))
    {
        // convert to UNICODE pszContainer -> pwszFileName
        cch = MultiByteToWideChar(CP_ACP, MB_COMPOSITE,
                                  pszContainer,
                                  -1, NULL, cch);
        if (0 == cch)
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }

        pwszFileName = ContInfoAlloc((cch + 1) * sizeof(WCHAR));
        if (NULL == pwszFileName)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        cch = MultiByteToWideChar(CP_ACP, MB_COMPOSITE,
                                  pszContainer,
                                  -1, pwszFileName, cch);
        if (0 == cch)
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }

        dwSts = DeleteFileInStorageArea(pwszFilePath, pwszFileName);
        if (ERROR_SUCCESS == dwSts)
            fRetryWithHashedName = FALSE;
    }

    // then try with hash of container name and the machine GUID appended
    if (fRetryWithHashedName)
    {
        dwSts = AddMachineGuidToContainerName(pszContainer,
                                              rgwchNewFileName);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = DeleteFileInStorageArea(pwszFilePath, rgwchNewFileName);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != pwszFileName)
        ContInfoFree(pwszFileName);
    return dwReturn;
}


DWORD
DeleteContainerInfo(
    IN DWORD dwProvType,
    IN LPSTR pszContainer,
    IN BOOL fMachineKeyset)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    LPWSTR  pwszFilePath = NULL;
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    BOOL    fIsLocalSystem = FALSE;
    WCHAR   rgwchNewFileName[80];
    BOOL    fDeleted = FALSE;
    DWORD   dwSts;

    // get the correct storage area (directory)
    dwSts = GetUserStorageArea(dwProvType, fMachineKeyset, FALSE,
                               &fIsLocalSystem, &pwszFilePath);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwSts = DeleteKeyContainer(pwszFilePath, pszContainer);
    if (ERROR_SUCCESS != dwSts)
    {
        // for migration of machine keys from system to All Users\App Data
        if (fMachineKeyset)
        {
            ContInfoFree(pwszFilePath);
            pwszFilePath = NULL;

            dwSts = GetUserStorageArea(dwProvType, fMachineKeyset, TRUE,
                                       &fIsLocalSystem, &pwszFilePath);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }

            dwSts = DeleteKeyContainer(pwszFilePath, pszContainer);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
            else
            {
                fDeleted = TRUE;
            }
        }
    }
    else
    {
        fDeleted = TRUE;
    }

    // there may be other keys created with the same container name on
    // different machines and these also need to be deleted
    for (;;)
    {
        memset(rgwchNewFileName, 0, sizeof(rgwchNewFileName));

        dwSts = FindClosestFileInStorageArea(pwszFilePath, pszContainer,
                                             rgwchNewFileName, &hFile);
        if (ERROR_SUCCESS != dwSts)
            break;

        CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;

        dwSts = DeleteFileInStorageArea(pwszFilePath, rgwchNewFileName);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        else
            fDeleted = TRUE;
    }

    if (!fDeleted)
    {
        dwReturn = (DWORD)NTE_BAD_KEYSET;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);
    if (NULL != pwszFilePath)
        ContInfoFree(pwszFilePath);
    return dwReturn;
}


/*static*/ DWORD
ReadContainerNameFromFile(
    IN BOOL fMachineKeyset,
    IN LPWSTR pwszFileName,
    IN LPWSTR pwszFilePath,
    OUT LPSTR pszNextContainer,
    IN OUT DWORD *pcbNextContainer)
{
    DWORD               dwReturn = ERROR_INTERNAL_ERROR;
    HANDLE              hMap = NULL;
    BYTE                *pbFile = NULL;
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    DWORD               cbFile = 0;
    DWORD               *pdwVersion;
    PKEY_CONTAINER_LENS pContLens;
    DWORD               dwSts;

    // open the file
    dwSts = OpenFileInStorageArea(fMachineKeyset,
                                  GENERIC_READ,
                                  pwszFilePath,
                                  pwszFileName,
                                  &hFile);
    if (ERROR_SUCCESS != dwSts)
    {
        if (ERROR_FILE_NOT_FOUND == dwSts)
            dwReturn = (DWORD)NTE_BAD_KEYSET;
        else
            dwReturn = dwSts;
        goto ErrorExit;
    }

    cbFile = GetFileSize(hFile, NULL);
    if ((DWORD)(-1) == cbFile)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }
    if ((sizeof(DWORD) + sizeof(KEY_CONTAINER_LENS)) > cbFile)
    {
        dwReturn = (DWORD)NTE_KEYSET_ENTRY_BAD;
        goto ErrorExit;
    }

    hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY,
                             0, 0, NULL);
    if (NULL == hMap)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    pbFile = (BYTE*)MapViewOfFile(hMap, FILE_MAP_READ,
                                  0, 0, 0 );
    if (NULL == pbFile)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    // get the length information out of the file
    pdwVersion = (DWORD*)pbFile;
    if (KEY_CONTAINER_FILE_FORMAT_VER != *pdwVersion)
    {
        dwReturn = (DWORD)NTE_KEYSET_ENTRY_BAD;
        goto ErrorExit;
    }
    pContLens = (PKEY_CONTAINER_LENS)(pbFile + sizeof(DWORD));

    if (NULL == pszNextContainer)
    {
        *pcbNextContainer = MAX_PATH + 1;
        dwReturn = ERROR_SUCCESS;   // Just tell them the length.
        goto ErrorExit;
    }

    if (*pcbNextContainer < pContLens->cbName)
    {
        *pcbNextContainer = MAX_PATH + 1;
    }
    else if ((sizeof(DWORD) + sizeof(KEY_CONTAINER_LENS) +
             sizeof(KEY_EXPORTABILITY_LENS) + pContLens->cbName) > cbFile)
    {
        dwReturn = (DWORD)NTE_KEYSET_ENTRY_BAD;
        goto ErrorExit;
    }
    else
    {
        // get the container name
        memcpy(pszNextContainer,
            pbFile + sizeof(DWORD) + sizeof(KEY_CONTAINER_LENS) +
            sizeof(KEY_EXPORTABILITY_LENS), pContLens->cbName);
        // *pcbNextContainer = pContLens->cbName;
    }
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != pbFile)
        UnmapViewOfFile(pbFile);
    if (NULL != hMap)
        CloseHandle(hMap);
    if (INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);
    return dwReturn;
}


DWORD
GetUniqueContainerName(
    IN KEY_CONTAINER_INFO *pContInfo,
    OUT BYTE *pbData,
    OUT DWORD *pcbData)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    LPSTR   pszUniqueContainer = NULL;
    DWORD   cch;

    cch = WideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS,
                        pContInfo->rgwszFileName, -1,
                        NULL, 0, NULL, NULL);
    if (0 == cch)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    pszUniqueContainer = (LPSTR)ContInfoAlloc((cch + 1) * sizeof(WCHAR));
    if (NULL == pszUniqueContainer)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    cch = WideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS,
                              pContInfo->rgwszFileName, -1,
                              pszUniqueContainer, cch,
                              NULL, NULL);
    if (0 == cch)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if (pbData == NULL)
    {
        *pcbData = strlen(pszUniqueContainer) + 1;
    }
    else if (*pcbData < (strlen(pszUniqueContainer) + 1))
    {
        *pcbData = strlen(pszUniqueContainer) + 1;
        dwReturn = ERROR_MORE_DATA;
        goto ErrorExit;
    }
    else
    {
        *pcbData = strlen(pszUniqueContainer) + 1;
        strcpy((LPSTR)pbData, pszUniqueContainer);
    }
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != pszUniqueContainer)
        ContInfoFree(pszUniqueContainer);
    return dwReturn;
}


//
// Function : MachineGuidInFilename
//
// Description : Check if the given Machine GUID is in the given filename.
//               Returns TRUE if it is FALSE if it is not.
//

/*static*/ BOOL
MachineGuidInFilename(
    LPWSTR pwszFileName,
    LPWSTR pwszMachineGuid)
{
    DWORD   cbFileName;
    BOOL    fRet = FALSE;

    cbFileName = wcslen(pwszFileName);

    // make sure the length of the filename is longer than the GUID
    if (cbFileName >= (DWORD)wcslen(pwszMachineGuid))
    {
        // compare the GUID with the last 36 characters of the file name
        if (0 == memcmp(pwszMachineGuid, &(pwszFileName[cbFileName - 36]),
            36 * sizeof(WCHAR)))
            fRet = TRUE;
    }
    return fRet;
}


DWORD
GetNextContainer(
    IN      DWORD   dwProvType,
    IN      BOOL    fMachineKeyset,
    IN      DWORD   dwFlags,
    OUT     LPSTR   pszNextContainer,
    IN OUT  DWORD   *pcbNextContainer,
    IN OUT  HANDLE  *phFind)
{
    DWORD               dwReturn = ERROR_INTERNAL_ERROR;
    LPWSTR              pwszFilePath = NULL;
    LPWSTR              pwszEnumFilePath = NULL;
    WIN32_FIND_DATAW    FindData;
    BOOL                fIsLocalSystem = FALSE;
    LPWSTR              pwszMachineGuid = NULL;
    DWORD               dwSts;

    memset(&FindData, 0, sizeof(FindData));

    // get the correct storage area (directory)
    dwSts = GetUserStorageArea(dwProvType, fMachineKeyset, FALSE,
                               &fIsLocalSystem, &pwszFilePath);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    if (dwFlags & CRYPT_FIRST)
    {
        *phFind = INVALID_HANDLE_VALUE;

        pwszEnumFilePath = (LPWSTR)ContInfoAlloc((wcslen(pwszFilePath) + 2) * sizeof(WCHAR));
        if (NULL == pwszEnumFilePath)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        wcscpy(pwszEnumFilePath, pwszFilePath);
        pwszEnumFilePath[wcslen(pwszFilePath)] = '*';

        *phFind = FindFirstFileExW(
                                  pwszEnumFilePath,
                                  FindExInfoStandard,
                                  &FindData,
                                  FindExSearchNameMatch,
                                  NULL,
                                  0);
        if (INVALID_HANDLE_VALUE == *phFind)
        {
            dwReturn = ERROR_NO_MORE_ITEMS;
            goto ErrorExit;
        }

        // skip past . and ..
        if (!FindNextFileW(*phFind, &FindData))
        {
            dwSts = GetLastError();
            if (ERROR_NO_MORE_FILES == dwSts)
                dwReturn = ERROR_NO_MORE_ITEMS;
            else
                dwReturn = dwSts;
            goto ErrorExit;
        }

        if (!FindNextFileW(*phFind, &FindData))
        {
            dwSts = GetLastError();
            if (ERROR_NO_MORE_FILES == dwSts)
                dwReturn = ERROR_NO_MORE_ITEMS;
            else
                dwReturn = dwSts;
            goto ErrorExit;
        }
    }
    else
    {
GetNextFile:
        {
            if (!FindNextFileW(*phFind, &FindData))
            {
                dwSts = GetLastError();
                if (ERROR_NO_MORE_FILES == dwSts)
                    dwReturn = ERROR_NO_MORE_ITEMS;
                else
                    dwReturn = dwSts;
                goto ErrorExit;
            }
        }
    }

    // if this is a machine keyset or this is local system then we want to
    // ignore key containers not matching the current machine GUID
    if (fMachineKeyset || fIsLocalSystem)
    {
        // get the GUID of the machine
        dwSts = GetMachineGUID(&pwszMachineGuid);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        if (NULL == pwszMachineGuid)
        {
            dwReturn = (DWORD)NTE_FAIL;
            goto ErrorExit;
        }

        // check if the file name has the machine GUID
        while (!MachineGuidInFilename(FindData.cFileName, pwszMachineGuid))
        {
            if (!FindNextFileW(*phFind, &FindData))
            {
                dwSts = GetLastError();
                if (ERROR_NO_MORE_FILES == dwSts)
                    dwReturn = ERROR_NO_MORE_ITEMS;
                else
                    dwReturn = dwSts;
                goto ErrorExit;
            }
        }
    }

    // return the container name, in order to do that we need to open the
    // file and pull out the container name
    //
    // we try to get the next file if failure occurs in case the file was
    // deleted since the FindNextFile
    //
    dwSts = ReadContainerNameFromFile(fMachineKeyset,
                                      FindData.cFileName,
                                      pwszFilePath,
                                      pszNextContainer,
                                      pcbNextContainer);
    if (ERROR_SUCCESS != dwSts)
        goto GetNextFile;
    else if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != pwszMachineGuid)
        ContInfoFree(pwszMachineGuid);
    if (NULL != pwszFilePath)
        ContInfoFree(pwszFilePath);
    if (NULL != pwszEnumFilePath)
        ContInfoFree(pwszEnumFilePath);
    return dwReturn;
}


// Converts to UNICODE and uses RegOpenKeyExW
DWORD
MyRegOpenKeyEx(
    IN HKEY hRegKey,
    IN LPSTR pszKeyName,
    IN DWORD dwReserved,
    IN REGSAM SAMDesired,
    OUT HKEY *phNewRegKey)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    WCHAR   rgwchFastBuff[(MAX_PATH + 1) * 2];
    LPWSTR  pwsz = NULL;
    BOOL    fAlloced = FALSE;
    DWORD   cch;
    DWORD   dwSts;

    memset(rgwchFastBuff, 0, sizeof(rgwchFastBuff));

    // convert reg key name to unicode
    cch = MultiByteToWideChar(CP_ACP, MB_COMPOSITE,
                              pszKeyName, -1,
                              NULL, 0);
    if (0 == cch)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if ((cch + 1) > ((MAX_PATH + 1) * 2))
    {
        pwsz = ContInfoAlloc((cch + 1) * sizeof(WCHAR));
        if (NULL == pwsz)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }
        fAlloced = TRUE;
    }
    else
    {
        pwsz = rgwchFastBuff;
    }

    cch = MultiByteToWideChar(CP_ACP, MB_COMPOSITE,
                              pszKeyName, -1, pwsz, cch);
    if (0 == cch)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    dwSts = RegOpenKeyExW(hRegKey,
                          pwsz,
                          dwReserved,
                          SAMDesired,
                          phNewRegKey);
    if (ERROR_SUCCESS != dwSts)
    {
        if (ERROR_FILE_NOT_FOUND == dwSts)
            dwReturn = (DWORD)NTE_BAD_KEYSET;
        else
            dwReturn = dwSts;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (fAlloced && (NULL != pwsz))
        ContInfoFree(pwsz);
    return dwReturn;
}


// Converts to UNICODE and uses RegDeleteKeyW
DWORD
MyRegDeleteKey(
    IN HKEY hRegKey,
    IN LPSTR pszKeyName)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    WCHAR   rgwchFastBuff[(MAX_PATH + 1) * 2];
    LPWSTR  pwsz = NULL;
    BOOL    fAlloced = FALSE;
    DWORD   cch;
    DWORD   dwSts;

    memset(rgwchFastBuff, 0, sizeof(rgwchFastBuff));

    // convert reg key name to unicode
    cch = MultiByteToWideChar(CP_ACP, MB_COMPOSITE,
                              pszKeyName, -1,
                              NULL, 0);
    if (0 == cch)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if ((cch + 1) > ((MAX_PATH + 1) * 2))
    {
        pwsz = ContInfoAlloc((cch + 1) * sizeof(WCHAR));
        if (NULL == pwsz)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }
        fAlloced = TRUE;
    }
    else
    {
        pwsz = rgwchFastBuff;
    }

    cch = MultiByteToWideChar(CP_ACP, MB_COMPOSITE,
                              pszKeyName, -1,
                              pwsz, cch);
    if (0 == cch)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    dwSts = RegDeleteKeyW(hRegKey, pwsz);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (fAlloced && (NULL != pwsz))
        ContInfoFree(pwsz);
    return dwReturn;
}


DWORD
AllocAndSetLocationBuff(
    BOOL fMachineKeySet,
    DWORD dwProvType,
    CONST char *pszUserID,
    HKEY *phTopRegKey,
    TCHAR **ppszLocBuff,
    BOOL fUserKeys,
    BOOL *pfLeaveOldKeys,
    LPDWORD pcbBuff)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    DWORD   dwSts;
    CHAR    szSID[MAX_PATH];
    DWORD   cbSID = MAX_PATH;
    DWORD   cbLocBuff = 0;
    DWORD   cbTmp = 0;
    CHAR    *pszTmp;
    BOOL    fIsThreadLocalSystem = FALSE;

    if (fMachineKeySet)
    {
        *phTopRegKey = HKEY_LOCAL_MACHINE;
        if ((PROV_RSA_FULL == dwProvType) ||
            (PROV_RSA_SCHANNEL == dwProvType) ||
            (PROV_RSA_AES == dwProvType))
        {
            cbTmp = RSA_MACH_REG_KEY_LOC_LEN;
            pszTmp = RSA_MACH_REG_KEY_LOC;
        }
        else if ((PROV_DSS == dwProvType) ||
                 (PROV_DSS_DH == dwProvType) ||
                 (PROV_DH_SCHANNEL == dwProvType))
        {
            cbTmp = DSS_MACH_REG_KEY_LOC_LEN;
            pszTmp = DSS_MACH_REG_KEY_LOC;
        }
        else
        {
            dwReturn = (DWORD)NTE_FAIL;
            goto ErrorExit;
        }
    }
    else
    {
        if ((PROV_RSA_FULL == dwProvType) ||
            (PROV_RSA_SCHANNEL == dwProvType) ||
            (PROV_RSA_AES == dwProvType))
        {
            cbTmp = RSA_REG_KEY_LOC_LEN;
            pszTmp = RSA_REG_KEY_LOC;
        }
        else if ((PROV_DSS == dwProvType) ||
                 (PROV_DSS_DH == dwProvType) ||
                 (PROV_DH_SCHANNEL == dwProvType))
        {
            cbTmp = DSS_REG_KEY_LOC_LEN;
            pszTmp = DSS_REG_KEY_LOC;
        }
        else
        {
            dwReturn = (DWORD)NTE_FAIL;
            goto ErrorExit;
        }

        if (FIsWinNT())
        {
            dwSts = IsThreadLocalSystem(&fIsThreadLocalSystem);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }

            dwSts = GetUserTextualSidA(szSID, &cbSID);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;    // NTE_BAD_KEYSET
                goto ErrorExit;
            }

            // this checks to see if the key to the current user may be opened
            if (!fMachineKeySet)
            {
                dwSts = RegOpenKeyEx(HKEY_USERS,
                                     szSID,
                                     0,      // dwOptions
                                     KEY_READ,
                                     phTopRegKey);
                if (ERROR_SUCCESS != dwSts)
                {
                    //
                    // if that failed, try HKEY_USERS\.Default (for services on NT).
                    //
                    cbSID = strlen(".DEFAULT") + 1;
                    strcpy(szSID, ".DEFAULT");
                    dwSts = RegOpenKeyEx(HKEY_USERS,
                                         szSID,
                                         0,        // dwOptions
                                         KEY_READ,
                                         phTopRegKey);
                    if (ERROR_SUCCESS != dwSts)
                    {
                        dwReturn = dwSts;
                        goto ErrorExit;
                    }
                    *pfLeaveOldKeys = TRUE;
                }
            }
        }
        else
        {
            *phTopRegKey = HKEY_CURRENT_USER;
        }
    }

    if (!fUserKeys)
        cbLocBuff = strlen(pszUserID);
    cbLocBuff = cbLocBuff + cbTmp + 2;

    *ppszLocBuff = (CHAR*)ContInfoAlloc(cbLocBuff);
    if (NULL == *ppszLocBuff)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    // Copy the location of the key groups, append the userID to it
    memcpy(*ppszLocBuff, pszTmp, cbTmp);
    if (!fUserKeys)
    {
        (*ppszLocBuff)[cbTmp-1] = '\\';
        strcpy(&(*ppszLocBuff)[cbTmp], pszUserID);
    }

    if (NULL != pcbBuff)
        *pcbBuff = cbLocBuff;
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


//
// Enumerates the old machine keys in the file system
// keys were in this location in Beta 2 and Beta 3 of NT5/Win2K
//
DWORD
EnumOldMachineKeys(
    IN DWORD dwProvType,
    IN OUT PKEY_CONTAINER_INFO pContInfo)
{
    DWORD               dwReturn = ERROR_INTERNAL_ERROR;
    HANDLE              hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW    FindData;
    LPWSTR              pwszUserStorageArea = NULL;
    LPWSTR              pwszTmp = NULL;
    BOOL                fIsLocalSystem;
    DWORD               i;
    LPSTR               pszNextContainer;
    DWORD               cbNextContainer;
    LPSTR               pszTmpContainer;
    DWORD               dwSts;

    // first check if the enumeration table is already set up
    if (NULL != pContInfo->pchEnumOldMachKeyEntries)
    {
        dwReturn = ERROR_SUCCESS;   // Nothing to do!
        goto ErrorExit;
    }

    memset(&FindData, 0, sizeof(FindData));

    dwSts = GetUserStorageArea(dwProvType, TRUE, TRUE,
                               &fIsLocalSystem, &pwszUserStorageArea);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = ERROR_NO_MORE_ITEMS;
        goto ErrorExit;
    }

    // last character is backslash, so strip that off
    pwszTmp = (LPWSTR)ContInfoAlloc((wcslen(pwszUserStorageArea) + 3) * sizeof(WCHAR));
    if (NULL == pwszTmp)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    wcscpy(pwszTmp, pwszUserStorageArea);
    wcscat(pwszTmp, L"*");

    // figure out how many files are in the directroy

    hFind = FindFirstFileExW(pwszTmp,
                             FindExInfoStandard,
                             &FindData,
                             FindExSearchNameMatch,
                             NULL,
                             0);
    if (INVALID_HANDLE_VALUE == hFind)
    {
        dwSts = GetLastError();
        if (ERROR_FILE_NOT_FOUND == dwSts)
            dwReturn = ERROR_NO_MORE_ITEMS;
        else
            dwReturn = dwSts;
        goto ErrorExit;
    }

    // skip past . and ..
    if (!FindNextFileW(hFind, &FindData))
    {
        dwSts = GetLastError();
        if (ERROR_NO_MORE_FILES == dwSts)
            dwReturn = ERROR_NO_MORE_ITEMS;
        else
            dwReturn = dwSts;
        goto ErrorExit;
    }
    if (!FindNextFileW(hFind, &FindData))
    {
        dwSts = GetLastError();
        if (ERROR_NO_MORE_FILES == dwSts)
            dwReturn = ERROR_NO_MORE_ITEMS;
        else
            dwReturn = dwSts;
        goto ErrorExit;
    }

    for (i = 1; ; i++)
    {
        memset(&FindData, 0, sizeof(FindData));
        if (!FindNextFileW(hFind, &FindData))
        {
            dwSts = GetLastError();
            if (ERROR_NO_MORE_FILES == dwSts)
                break;
            else if (ERROR_ACCESS_DENIED != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
        }
    }

    FindClose(hFind);
    hFind = INVALID_HANDLE_VALUE;

    pContInfo->cbOldMachKeyEntry = MAX_PATH + 1;
    pContInfo->dwiOldMachKeyEntry = 0;
    pContInfo->cMaxOldMachKeyEntry = i;

    // allocate space for the file names
    pContInfo->pchEnumOldMachKeyEntries = ContInfoAlloc(i * (MAX_PATH + 1));
    if (NULL == pContInfo->pchEnumOldMachKeyEntries)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    // enumerate through getting file name from each
    memset(&FindData, 0, sizeof(FindData));
    hFind = FindFirstFileExW(pwszTmp,
                             FindExInfoStandard,
                             &FindData,
                             FindExSearchNameMatch,
                             NULL,
                             0);
    if (INVALID_HANDLE_VALUE == hFind)
    {
        dwSts = GetLastError();
        if (ERROR_FILE_NOT_FOUND == dwSts)
            dwReturn = ERROR_NO_MORE_ITEMS;
        else
            dwReturn = dwSts;
        goto ErrorExit;
    }

    // skip past . and ..
    if (!FindNextFileW(hFind, &FindData))
    {
        dwSts = GetLastError();
        if (ERROR_NO_MORE_FILES == dwSts)
            dwReturn = ERROR_NO_MORE_ITEMS;
        else
            dwReturn = dwSts;
        goto ErrorExit;
    }
    memset(&FindData, 0, sizeof(FindData));
    if (!FindNextFileW(hFind, &FindData))
    {
        dwSts = GetLastError();
        if (ERROR_NO_MORE_FILES == dwSts)
            dwReturn = ERROR_NO_MORE_ITEMS;
        else
            dwReturn = dwSts;
        goto ErrorExit;
    }

    pszNextContainer = pContInfo->pchEnumOldMachKeyEntries;

    for (i = 0; i < pContInfo->cMaxOldMachKeyEntry; i++)
    {
        cbNextContainer = MAX_PATH;

        // return the container name, in order to do that we need to open the
        // file and pull out the container name
        dwSts = ReadContainerNameFromFile(TRUE,
                                          FindData.cFileName,
                                          pwszUserStorageArea,
                                          pszNextContainer,
                                          &cbNextContainer);
        if (ERROR_SUCCESS != dwSts)
        {
            pszTmpContainer = pszNextContainer;
        }
        else
        {
            pszTmpContainer = pszNextContainer + MAX_PATH + 1;
        }

        memset(&FindData, 0, sizeof(FindData));
        if (!FindNextFileW(hFind, &FindData))
        {
            dwSts = GetLastError();
            if (ERROR_NO_MORE_FILES == dwSts)
                break;
            else if (ERROR_ACCESS_DENIED != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
        }
        pszNextContainer = pszTmpContainer;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != pwszTmp)
        ContInfoFree(pwszTmp);
    if (NULL != pwszUserStorageArea)
        ContInfoFree(pwszUserStorageArea);
    if (INVALID_HANDLE_VALUE != hFind)
        FindClose(hFind);
    return dwReturn;
}


DWORD
GetNextEnumedOldMachKeys(
    IN PKEY_CONTAINER_INFO pContInfo,
    IN BOOL fMachineKeyset,
    OUT BYTE *pbData,
    OUT DWORD *pcbData)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    CHAR    *psz;

    if (!fMachineKeyset)
    {
        dwReturn = ERROR_SUCCESS;   // Nothing to do!
        goto ErrorExit;
    }

    if ((NULL == pContInfo->pchEnumOldMachKeyEntries) ||
        (pContInfo->dwiOldMachKeyEntry >= pContInfo->cMaxOldMachKeyEntry))
    {
        dwReturn = ERROR_NO_MORE_ITEMS;
        goto ErrorExit;
    }

    if (NULL == pbData)
        *pcbData = pContInfo->cbRegEntry;
    else if (*pcbData < pContInfo->cbRegEntry)
    {
        *pcbData = pContInfo->cbRegEntry;
        dwReturn = ERROR_MORE_DATA;
        goto ErrorExit;
    }
    else
    {
        psz = pContInfo->pchEnumOldMachKeyEntries + (pContInfo->dwiOldMachKeyEntry *
            pContInfo->cbOldMachKeyEntry);
        memcpy(pbData, psz, strlen(psz) + 1);
        pContInfo->dwiOldMachKeyEntry++;
    }
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (fMachineKeyset)
        *pcbData = pContInfo->cbOldMachKeyEntry;
    return dwReturn;
}


//
// Enumerates the keys in the registry into a list of entries
//
DWORD
EnumRegKeys(
    IN OUT PKEY_CONTAINER_INFO pContInfo,
    IN BOOL fMachineKeySet,
    IN DWORD dwProvType,
    OUT BYTE *pbData,
    IN OUT DWORD *pcbData)
{
    DWORD       dwReturn = ERROR_INTERNAL_ERROR;
    HKEY        hTopRegKey = 0;
    LPSTR       pszBuff = NULL;
    DWORD       cbBuff;
    BOOL        fLeaveOldKeys = FALSE;
    HKEY        hKey = 0;
    DWORD       cSubKeys;
    DWORD       cchMaxSubkey;
    DWORD       cchMaxClass;
    DWORD       cValues;
    DWORD       cchMaxValueName;
    DWORD       cbMaxValueData;
    DWORD       cbSecurityDesriptor;
    FILETIME    ftLastWriteTime;
    CHAR        *psz;
    DWORD       i;
    DWORD       dwSts;

    // first check if the enumeration table is already set up
    if (NULL != pContInfo->pchEnumRegEntries)
    {
        dwReturn = ERROR_SUCCESS;   // Nothing to do!
        goto ErrorExit;
    }

    // get the path to the registry keys
    dwSts = AllocAndSetLocationBuff(fMachineKeySet,
                                    dwProvType,
                                    pContInfo->pszUserName,
                                    &hTopRegKey,
                                    &pszBuff,
                                    TRUE,
                                    &fLeaveOldKeys,
                                    &cbBuff);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // open the reg key
    dwSts = MyRegOpenKeyEx(hTopRegKey,
                           pszBuff,
                           0,
                           KEY_READ,
                           &hKey);
    if (ERROR_SUCCESS != dwSts)
    {
        if (NTE_BAD_KEYSET == dwSts)
            dwReturn = ERROR_NO_MORE_ITEMS;
        else
            dwReturn = dwSts;
        goto ErrorExit;
    }

    // find out info on old key containers
    dwSts = RegQueryInfoKey(hKey,
                            NULL,
                            NULL,
                            NULL,
                            &cSubKeys,
                            &cchMaxSubkey,
                            &cchMaxClass,
                            &cValues,
                            &cchMaxValueName,
                            &cbMaxValueData,
                            &cbSecurityDesriptor,
                            &ftLastWriteTime);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // if there are old keys then enumerate them into a table
    if (0 != cSubKeys)
    {
        pContInfo->cMaxRegEntry = cSubKeys;
        pContInfo->cbRegEntry = cchMaxSubkey + 1;

        pContInfo->pchEnumRegEntries =
            ContInfoAlloc(pContInfo->cMaxRegEntry
                          * pContInfo->cbRegEntry
                          * sizeof(CHAR));
        if (NULL == pContInfo->pchEnumRegEntries)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        for (i = 0; i < pContInfo->cMaxRegEntry; i++)
        {
            psz = pContInfo->pchEnumRegEntries + (i * pContInfo->cbRegEntry);
            dwSts = RegEnumKey(hKey,
                               i,
                               psz,
                               pContInfo->cbRegEntry);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
        }

        if (NULL == pbData)
            *pcbData = pContInfo->cbRegEntry;
        else if (*pcbData < pContInfo->cbRegEntry)
        {
            *pcbData = pContInfo->cbRegEntry;
            dwReturn = ERROR_MORE_DATA;
            goto ErrorExit;
        }
        else
        {
            *pcbData = pContInfo->cbRegEntry;
            // ?BUGBUG? What?
            // CopyMemory(pbData, pContInfo->pbRegEntry, pContInfo->cbRegEntry);
        }
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if ((NULL != hTopRegKey)
        && (HKEY_CURRENT_USER != hTopRegKey)
        && (HKEY_LOCAL_MACHINE != hTopRegKey))
    {
        RegCloseKey(hTopRegKey);
    }
    if (NULL != pszBuff)
        ContInfoFree(pszBuff);
    if (NULL != hKey)
        RegCloseKey(hKey);
    return dwReturn;
}


DWORD
GetNextEnumedRegKeys(
    IN PKEY_CONTAINER_INFO pContInfo,
    OUT BYTE *pbData,
    OUT DWORD *pcbData)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    CHAR    *psz;

    if ((NULL == pContInfo->pchEnumRegEntries) ||
        (pContInfo->dwiRegEntry >= pContInfo->cMaxRegEntry))
    {
        dwReturn = ERROR_NO_MORE_ITEMS;
        goto ErrorExit;
    }

    if (NULL == pbData)
        *pcbData = pContInfo->cbRegEntry;
    else if (*pcbData < pContInfo->cbRegEntry)
    {
        *pcbData = pContInfo->cbRegEntry;
        dwReturn = ERROR_MORE_DATA;
        goto ErrorExit;
    }
    else
    {
        psz = pContInfo->pchEnumRegEntries + (pContInfo->dwiRegEntry *
            pContInfo->cbRegEntry);
        memcpy(pbData, psz, pContInfo->cbRegEntry);
        pContInfo->dwiRegEntry++;
    }
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


//+ ===========================================================================
//
//      The function adjusts the token priviledges so that SACL information
//      may be gotten and then opens the indicated registry key.  If the token
//      priviledges may be set then the reg key is opened anyway but the
//      flags field will not have the PRIVILEDGE_FOR_SACL value set.
//
//- ============================================================================

DWORD
OpenRegKeyWithTokenPriviledges(
    IN HKEY hTopRegKey,
    IN LPSTR pszRegKey,
    OUT HKEY *phRegKey,
    OUT DWORD *pdwFlags)
{
    DWORD               dwReturn = ERROR_INTERNAL_ERROR;
    TOKEN_PRIVILEGES    tp;
    TOKEN_PRIVILEGES    tpPrevious;
    DWORD               cbPrevious = sizeof(TOKEN_PRIVILEGES);
    LUID                luid;
    HANDLE              hToken = 0;
    HKEY                hRegKey = 0;
    BOOL                fSts;
    BOOL                fImpersonating = FALSE;
    BOOL                fAdjusted = FALSE;
    DWORD               dwAccessFlags = 0;
    DWORD               dwSts;

    // check if there is a registry key to open
    dwSts = MyRegOpenKeyEx(hTopRegKey, pszRegKey, 0,
                           KEY_ALL_ACCESS, &hRegKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    RegCloseKey(hRegKey);
    hRegKey = 0;

    // check if there is a thread token
    fSts = OpenThreadToken(GetCurrentThread(),
                           MAXIMUM_ALLOWED, TRUE,
                           &hToken);
    if (!fSts)
    {
        if (!ImpersonateSelf(SecurityImpersonation))
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }

        fImpersonating = TRUE;
        // get the process token
        fSts = OpenThreadToken(GetCurrentThread(),
                               MAXIMUM_ALLOWED,
                               TRUE,
                               &hToken);
    }

    // set up the new priviledge state
    if (fSts)
    {
        memset(&tp, 0, sizeof(tp));
        memset(&tpPrevious, 0, sizeof(tpPrevious));

        fSts = LookupPrivilegeValueA(NULL, SE_SECURITY_NAME, &luid);
        if (fSts)
        {
            //
            // first pass.  get current privilege setting
            //
            tp.PrivilegeCount           = 1;
            tp.Privileges[0].Luid       = luid;
            tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            // adjust privilege
            fSts = AdjustTokenPrivileges(hToken,
                                         FALSE,
                                         &tp,
                                         sizeof(TOKEN_PRIVILEGES),
                                         &tpPrevious,
                                         &cbPrevious);
            if (fSts && (ERROR_SUCCESS == GetLastError()))
            {
                fAdjusted = TRUE;
                *pdwFlags |= PRIVILEDGE_FOR_SACL;
                dwAccessFlags = ACCESS_SYSTEM_SECURITY;
            }
        }
    }

    // open the registry key
    dwSts = MyRegOpenKeyEx(hTopRegKey,
                           pszRegKey,
                           0,
                           KEY_ALL_ACCESS | dwAccessFlags,
                           phRegKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    // now set the privilege back if necessary
    if (fAdjusted)
    {
        // adjust the priviledge and with the previous state
        fSts = AdjustTokenPrivileges(hToken,
                                     FALSE,
                                     &tpPrevious,
                                     sizeof(TOKEN_PRIVILEGES),
                                     NULL,
                                     NULL);
    }
    if (NULL != hToken)
        CloseHandle(hToken);
    if (fImpersonating)
    {
        if (FALSE == RevertToSelf())
            dwReturn = GetLastError();
    }

    return dwReturn;
}


//+ ===========================================================================
//
//      The function adjusts the token priviledges so that SACL information
//      may be set on a key container.  If the token priviledges may be set
//      indicated by the pUser->dwOldKeyFlags having the PRIVILEDGE_FOR_SACL value set.
//      value set then the token privilege is adjusted before the security
//      descriptor is set on the container.  This is needed for the key
//      migration case when keys are being migrated from the registry to files.
//- ============================================================================

DWORD
SetSecurityOnContainerWithTokenPriviledges(
    IN DWORD dwOldKeyFlags,
    IN LPCWSTR wszFileName,
    IN DWORD dwProvType,
    IN DWORD fMachineKeyset,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor)
{
    DWORD               dwReturn = ERROR_INTERNAL_ERROR;
    TOKEN_PRIVILEGES    tp;
    TOKEN_PRIVILEGES    tpPrevious;
    DWORD               cbPrevious = sizeof(TOKEN_PRIVILEGES);
    LUID                luid;
    HANDLE              hToken = 0;
    BOOL                fStatus;
    BOOL                fImpersonating = FALSE;
    BOOL                fAdjusted = FALSE;
    DWORD               dwSts;

    if (dwOldKeyFlags & PRIVILEDGE_FOR_SACL)
    {
        // check if there is a thread token
        fStatus = OpenThreadToken(GetCurrentThread(),
                                  MAXIMUM_ALLOWED, TRUE,
                                  &hToken);
        if (!fStatus)
        {
            if (!ImpersonateSelf(SecurityImpersonation))
            {
                dwReturn = GetLastError();
                goto ErrorExit;
            }

            fImpersonating = TRUE;
            // get the process token
            fStatus = OpenThreadToken(GetCurrentThread(),
                                      MAXIMUM_ALLOWED,
                                      TRUE,
                                      &hToken);
        }

        // set up the new priviledge state
        if (fStatus)
        {
            memset(&tp, 0, sizeof(tp));
            memset(&tpPrevious, 0, sizeof(tpPrevious));

            fStatus = LookupPrivilegeValueA(NULL,
                                            SE_SECURITY_NAME,
                                            &luid);
            if (fStatus)
            {
                //
                // first pass.  get current privilege setting
                //
                tp.PrivilegeCount           = 1;
                tp.Privileges[0].Luid       = luid;
                tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

                // adjust privilege
                fAdjusted = AdjustTokenPrivileges(hToken,
                                                  FALSE,
                                                  &tp,
                                                  sizeof(TOKEN_PRIVILEGES),
                                                  &tpPrevious,
                                                  &cbPrevious);
            }
        }
    }

    dwSts = SetSecurityOnContainer(wszFileName,
                                   dwProvType,
                                   fMachineKeyset,
                                   SecurityInformation,
                                   pSecurityDescriptor);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    // now set the privilege back if necessary
    // now set the privilege back if necessary
    if (dwOldKeyFlags & PRIVILEDGE_FOR_SACL)
    {
        if (fAdjusted)
        {
            // adjust the priviledge and with the previous state
            fStatus = AdjustTokenPrivileges(hToken,
                                            FALSE,
                                            &tpPrevious,
                                            sizeof(TOKEN_PRIVILEGES),
                                            NULL,
                                            NULL);
        }
    }
    if (NULL != hToken)
        CloseHandle(hToken);
    if (fImpersonating)
    {
        if (FALSE == RevertToSelf())
            dwReturn = GetLastError();
    }

    return dwReturn;
}


// Loops through the ACEs of an ACL and checks for special access bits
// for registry keys and converts the access mask so generic access
// bits are used

/*static*/ DWORD
CheckAndChangeAccessMasks(
    IN PACL pAcl)
{
    DWORD                   dwReturn = ERROR_INTERNAL_ERROR;
    ACL_SIZE_INFORMATION    AclSizeInfo;
    DWORD                   i;
    ACCESS_ALLOWED_ACE      *pAce;
    ACCESS_MASK             NewMask;

    memset(&AclSizeInfo, 0, sizeof(AclSizeInfo));

    // get the number of ACEs in the ACL
    if (!GetAclInformation(pAcl, &AclSizeInfo, sizeof(AclSizeInfo),
                           AclSizeInformation))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    // loop through the ACEs checking and changing the access bits
    for (i = 0; i < AclSizeInfo.AceCount; i++)
    {
        if (!GetAce(pAcl, i, &pAce))
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }

        NewMask = 0;

        // check if the specific access bits are set, if so convert to generic
        if ((pAce->Mask & KEY_QUERY_VALUE) || (pAce->Mask & GENERIC_READ))
            NewMask |= GENERIC_READ;

        if ((pAce->Mask & KEY_SET_VALUE) || (pAce->Mask & GENERIC_ALL) ||
            (pAce->Mask & GENERIC_WRITE))
        {
            NewMask |= GENERIC_ALL;
        }

        pAce->Mask = NewMask;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


// Converts a security descriptor from special access to generic access

/*static*/ DWORD
ConvertContainerSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR *ppNewSD,
    OUT DWORD *pcbNewSD)
{
    DWORD                       dwReturn = ERROR_INTERNAL_ERROR;
    DWORD                       cbSD;
    SECURITY_DESCRIPTOR_CONTROL Control;
    DWORD                       dwRevision;
    PACL                        pDacl;
    BOOL                        fDACLPresent;
    BOOL                        fDaclDefaulted;
    PACL                        pSacl;
    BOOL                        fSACLPresent;
    BOOL                        fSaclDefaulted;
    DWORD                       dwSts;

    // ge the control on the security descriptor to check if self relative
    if (!GetSecurityDescriptorControl(pSecurityDescriptor,
                                      &Control, &dwRevision))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    // get the length of the security descriptor and alloc space for a copy
    cbSD = GetSecurityDescriptorLength(pSecurityDescriptor);
    *ppNewSD =(PSECURITY_DESCRIPTOR)ContInfoAlloc(cbSD);
    if (NULL == *ppNewSD)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    if (SE_SELF_RELATIVE & Control)
    {
        // if the Security Descriptor is self relative then make a copy
        memcpy(*ppNewSD, pSecurityDescriptor, cbSD);
    }
    else
    {
        // if not self relative then make a self relative copy
        if (!MakeSelfRelativeSD(pSecurityDescriptor, *ppNewSD, &cbSD))
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }
    }

    // get the DACL out of the security descriptor
    if (!GetSecurityDescriptorDacl(*ppNewSD, &fDACLPresent, &pDacl,
                                   &fDaclDefaulted))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if (fDACLPresent && pDacl)
    {
        dwSts = CheckAndChangeAccessMasks(pDacl);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    // get the SACL out of the security descriptor
    if (!GetSecurityDescriptorSacl(*ppNewSD, &fSACLPresent, &pSacl,
                                   &fSaclDefaulted))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if (fSACLPresent && pSacl)
    {
        dwSts = CheckAndChangeAccessMasks(pSacl);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    *pcbNewSD = cbSD;
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


DWORD
SetSecurityOnContainer(
    IN LPCWSTR wszFileName,
    IN DWORD dwProvType,
    IN DWORD fMachineKeyset,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor)
{
    DWORD                   dwReturn = ERROR_INTERNAL_ERROR;
    PSECURITY_DESCRIPTOR    pSD = NULL;
    DWORD                   cbSD;
    LPWSTR                  wszFilePath = NULL;
    LPWSTR                  wszUserStorageArea = NULL;
    DWORD                   cbUserStorageArea;
    DWORD                   cbFileName;
    BOOL                    fIsLocalSystem = FALSE;
    DWORD                   dwSts;

    dwSts = ConvertContainerSecurityDescriptor(pSecurityDescriptor,
                                               &pSD, &cbSD);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // get the correct storage area (directory)
    dwSts = GetUserStorageArea(dwProvType, fMachineKeyset, FALSE,
                               &fIsLocalSystem, &wszUserStorageArea);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    cbUserStorageArea = wcslen( wszUserStorageArea ) * sizeof(WCHAR);
    cbFileName = wcslen( wszFileName ) * sizeof(WCHAR);

    wszFilePath = (LPWSTR)ContInfoAlloc(cbUserStorageArea
                                        + cbFileName
                                        + sizeof(WCHAR));
    if (wszFilePath == NULL)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    CopyMemory((BYTE*)wszFilePath, (BYTE*)wszUserStorageArea, cbUserStorageArea);
    CopyMemory((LPBYTE)wszFilePath+cbUserStorageArea, wszFileName, cbFileName + sizeof(WCHAR));

    if (!SetFileSecurityW(wszFilePath, SecurityInformation, pSD))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != pSD)
        ContInfoFree(pSD);
    if (NULL != wszUserStorageArea)
        ContInfoFree(wszUserStorageArea);
    if (NULL != wszFilePath)
        ContInfoFree(wszFilePath);
    return dwReturn;
}


DWORD
GetSecurityOnContainer(
    IN LPCWSTR wszFileName,
    IN DWORD dwProvType,
    IN DWORD fMachineKeyset,
    IN SECURITY_INFORMATION RequestedInformation,
    OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN OUT DWORD *pcbSecurityDescriptor)
{
    DWORD                   dwReturn = ERROR_INTERNAL_ERROR;
    LPWSTR                  wszFilePath = NULL;
    LPWSTR                  wszUserStorageArea = NULL;
    DWORD                   cbUserStorageArea;
    DWORD                   cbFileName;
    PSECURITY_DESCRIPTOR    pSD = NULL;
    DWORD                   cbSD;
    PSECURITY_DESCRIPTOR    pNewSD = NULL;
    DWORD                   cbNewSD;
    BOOL                    fIsLocalSystem = FALSE;
    DWORD                   dwSts;

    // get the correct storage area (directory)
    dwSts = GetUserStorageArea(dwProvType, fMachineKeyset, FALSE,
                               &fIsLocalSystem, &wszUserStorageArea);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    cbUserStorageArea = wcslen( wszUserStorageArea ) * sizeof(WCHAR);
    cbFileName = wcslen( wszFileName ) * sizeof(WCHAR);

    wszFilePath = (LPWSTR)ContInfoAlloc(cbUserStorageArea
                                        + cbFileName
                                        + sizeof(WCHAR));
    if (wszFilePath == NULL)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    CopyMemory(wszFilePath, wszUserStorageArea, cbUserStorageArea);
    CopyMemory((LPBYTE)wszFilePath+cbUserStorageArea, wszFileName, cbFileName + sizeof(WCHAR));

    // get the security descriptor on the file
    cbSD = sizeof(cbSD);
    pSD = &cbSD;
    if (!GetFileSecurityW(wszFilePath, RequestedInformation, pSD,
                          cbSD, &cbSD))
    {
        dwSts = GetLastError();
        if (ERROR_INSUFFICIENT_BUFFER != dwSts)
        {
            dwReturn = dwSts;
            pSD = NULL;
            goto ErrorExit;
        }
    }

    pSD = (PSECURITY_DESCRIPTOR)ContInfoAlloc(cbSD);
    if (NULL == pSD)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    if (!GetFileSecurityW(wszFilePath, RequestedInformation, pSD,
                          cbSD, &cbSD))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    // convert the security descriptor from specific to generic
    dwSts = ConvertContainerSecurityDescriptor(pSD, &pNewSD, &cbNewSD);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    if (NULL == pSecurityDescriptor)
        *pcbSecurityDescriptor = cbNewSD;
    else if (*pcbSecurityDescriptor < cbNewSD)
    {
        *pcbSecurityDescriptor = cbNewSD;
        dwReturn = ERROR_MORE_DATA;
        goto ErrorExit;
    }
    else
    {
        *pcbSecurityDescriptor = cbNewSD;
        memcpy(pSecurityDescriptor, pNewSD, *pcbSecurityDescriptor);
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != pNewSD)
        ContInfoFree(pNewSD);
    if (NULL != pSD)
        ContInfoFree(pSD);
    if (NULL != wszUserStorageArea)
        ContInfoFree(wszUserStorageArea);
    if (NULL != wszFilePath)
        ContInfoFree(wszFilePath);
    return dwReturn;
}


//
// Function : FreeOffloadInfo
//
// Description : The function takes a pointer to Offload Information as the
//               first parameter of the call.  The function frees the
//               information.
//

void
FreeOffloadInfo(
    IN OUT PEXPO_OFFLOAD_STRUCT pOffloadInfo)
{
    if (NULL != pOffloadInfo)
    {
        if (NULL != pOffloadInfo->hInst)
            FreeLibrary(pOffloadInfo->hInst);
        ContInfoFree(pOffloadInfo);
    }
}


//
// Function : InitExpOffloadInfo
//
// Description : The function takes a pointer to Offload Information as the
//               first parameter of the call.  The function checks in the
//               registry to see if an offload module has been registered.
//               If a module is registered then it loads the module
//               and gets the OffloadModExpo function pointer.
//

BOOL
InitExpOffloadInfo(
    IN OUT PEXPO_OFFLOAD_STRUCT *ppOffloadInfo)
{
    BYTE                    rgbModule[MAX_PATH + 1];
    BYTE                    *pbModule = NULL;
    DWORD                   cbModule;
    BOOL                    fAlloc = FALSE;
    PEXPO_OFFLOAD_STRUCT    pTmpOffloadInfo = NULL;
    HKEY                    hOffloadRegKey = 0;
    DWORD                   dwSts;
    BOOL                    fRet = FALSE;

    // wrap with try/except
    __try
    {
        // check for registration of an offload module
        dwSts = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                             "Software\\Microsoft\\Cryptography\\Offload",
                             0,        // dwOptions
                             KEY_READ,
                             &hOffloadRegKey);
        if (ERROR_SUCCESS != dwSts)
            goto ErrorExit;

        // get the name of the offload module
        cbModule = sizeof(rgbModule);
        dwSts = RegQueryValueEx(hOffloadRegKey,
                                EXPO_OFFLOAD_REG_VALUE,
                                0, NULL, rgbModule,
                                &cbModule);
        if (ERROR_SUCCESS != dwSts)
        {
            if (ERROR_MORE_DATA == dwSts)
            {
                pbModule = (BYTE*)ContInfoAlloc(cbModule);
                if (NULL == pbModule)
                    goto ErrorExit;

                fAlloc = TRUE;
                dwSts = RegQueryValueEx(HKEY_LOCAL_MACHINE,
                                        EXPO_OFFLOAD_REG_VALUE,
                                        0, NULL, pbModule,
                                        &cbModule);
                if (ERROR_SUCCESS != dwSts)
                    goto ErrorExit;
            }
            else
                goto ErrorExit;
        }
        else
            pbModule = rgbModule;

        // alloc space for the offload info
        pTmpOffloadInfo = (PEXPO_OFFLOAD_STRUCT)ContInfoAlloc(sizeof(EXPO_OFFLOAD_STRUCT));
        if (NULL == pTmpOffloadInfo)
            goto ErrorExit;

        pTmpOffloadInfo->dwVersion = sizeof(EXPO_OFFLOAD_STRUCT);

        // load the module and get the function pointer
        pTmpOffloadInfo->hInst = LoadLibraryEx((LPTSTR)pbModule, NULL, 0);
        if (NULL == pTmpOffloadInfo->hInst)
            goto ErrorExit;

        pTmpOffloadInfo->pExpoFunc = (PFN_OFFLOAD_MOD_EXPO) GetProcAddress(pTmpOffloadInfo->hInst,
                                                    EXPO_OFFLOAD_FUNC_NAME);
        if (NULL == pTmpOffloadInfo->pExpoFunc)
            goto ErrorExit;

        *ppOffloadInfo = pTmpOffloadInfo;
        fRet = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        goto ErrorExit;
    }

ErrorExit:
    if (NULL != hOffloadRegKey)
        RegCloseKey(hOffloadRegKey);
    if (fAlloc && (NULL != pbModule))
        ContInfoFree(pbModule);
    if (!fRet)
        FreeOffloadInfo(pTmpOffloadInfo);
    return fRet;
}


//
// Function : ModularExpOffload
//
// Description : This function does the offloading of modular exponentiation.
//               The function takes a pointer to Offload Information as the
//               first parameter of the call.  If this pointer is not NULL
//               then the function will use this module and call the function.
//               The exponentiation with MOD function will implement
//               Y^X MOD P  where Y is the buffer pbBase, X is the buffer
//               pbExpo and P is the buffer pbModulus.  The length of the
//               buffer pbExpo is cbExpo and the length of pbBase and
//               pbModulus is cbModulus.  The resulting value is output
//               in the pbResult buffer and has length cbModulus.
//               The pReserved and dwFlags parameters are currently ignored.
//               If any of these functions fail then the function fails and
//               returns FALSE.  If successful then the function returns
//               TRUE.  If the function fails then most likely the caller
//               should fall back to using hard linked modular exponentiation.
//

BOOL
ModularExpOffload(
    IN PEXPO_OFFLOAD_STRUCT pOffloadInfo,
    IN BYTE *pbBase,
    IN BYTE *pbExpo,
    IN DWORD cbExpo,
    IN BYTE *pbModulus,
    IN DWORD cbModulus,
    OUT BYTE *pbResult,
    IN VOID *pReserved,
    IN DWORD dwFlags)
{
    BOOL    fRet = FALSE;

    // wrap with try/except
    __try
    {
        if (NULL == pOffloadInfo)
            goto ErrorExit;

        // call the offload module
        if (!pOffloadInfo->pExpoFunc(pbBase, pbExpo, cbExpo, pbModulus,
                                     cbModulus, pbResult, pReserved, dwFlags))
        {
            goto ErrorExit;
        }

        fRet = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        goto ErrorExit;
    }

ErrorExit:
    return fRet;
}


//
// The following section of code is for the loading and unloading of
// unicode string resources from a resource DLL (csprc.dll).  This
// allows the resources to be localize even though the CSPs
// themselves are signed.
//

#define MAX_STRING_RSC_SIZE 512

#define GLOBAL_STRING_BUFFERSIZE_INC 1000
#define GLOBAL_STRING_BUFFERSIZE 20000


//
// Function : FetchString
//
// Description : This function gets the specified string resource from
//               the resource DLL, allocates memory for it and copies
//               the string into that memory.
//

/*static*/ DWORD
FetchString(
    HMODULE hModule,                // module to get string from
    DWORD dwResourceId,             // resource identifier
    LPWSTR *ppString,               // target buffer for string
    BYTE **ppStringBlock,           // string buffer block
    DWORD *pdwBufferSize,           // size of string buffer block
    DWORD *pdwRemainingBufferSize)  // remaining size of string buffer block
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    WCHAR   szMessage[MAX_STRING_RSC_SIZE];
    DWORD   cchMessage;
    DWORD   dwOldSize;
    DWORD   dwNewSize;
    LPWSTR  pNewStr;

    if (ppStringBlock == NULL || *ppStringBlock == NULL || ppString == NULL)
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto ErrorExit;
    }

    cchMessage = LoadStringW(hModule, dwResourceId, szMessage,
                             MAX_STRING_RSC_SIZE);
    if (0 == cchMessage)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if (*pdwRemainingBufferSize < ((cchMessage + 1) * sizeof(WCHAR)))
    {

        //
        // realloc buffer and update size
        //

        dwOldSize = *pdwBufferSize;
        dwNewSize = dwOldSize + max(GLOBAL_STRING_BUFFERSIZE_INC,
                                    (((cchMessage + 1) * sizeof(WCHAR)) - *pdwRemainingBufferSize));

        *ppStringBlock = (BYTE*)ContInfoReAlloc(*ppStringBlock, dwNewSize);
        if (NULL == *ppStringBlock)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        *pdwBufferSize = dwNewSize;
        *pdwRemainingBufferSize += dwNewSize - dwOldSize;
    }

    pNewStr = (LPWSTR)(*ppStringBlock + *pdwBufferSize -
                       *pdwRemainingBufferSize);

    // only store the offset just in case a realloc of the entire
    // string buffer needs to be performed at a later time.
    *ppString = (LPWSTR)((BYTE *)pNewStr - (BYTE *)*ppStringBlock);

    wcscpy(pNewStr, szMessage);
    *pdwRemainingBufferSize -= (cchMessage + 1) * sizeof(WCHAR);

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


DWORD
LoadStrings(
    void)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    HMODULE hMod = 0;
    DWORD   dwBufferSize;
    DWORD   dwRemainingBufferSize;
    DWORD   dwSts;

    if (NULL == l_pbStringBlock)
    {
        hMod = LoadLibraryEx("crypt32.dll", NULL, LOAD_LIBRARY_AS_DATAFILE);
        if (NULL == hMod)
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }

        //
        // get size of all string resources, and then allocate a single block
        // of memory to contain all the strings.  This way, we only have to
        // free one block and we benefit memory wise due to locality of reference.
        //

        dwBufferSize = dwRemainingBufferSize = GLOBAL_STRING_BUFFERSIZE;

        l_pbStringBlock = (BYTE*)ContInfoAlloc(dwBufferSize);
        if (NULL == l_pbStringBlock)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_RSA_SIG_DESCR, &g_Strings.pwszRSASigDescr,
                           &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_RSA_EXCH_DESCR, &g_Strings.pwszRSAExchDescr,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_IMPORT_SIMPLE, &g_Strings.pwszImportSimple,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_SIGNING_E, &g_Strings.pwszSignWExch,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_CREATE_RSA_SIG, &g_Strings.pwszCreateRSASig,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_CREATE_RSA_EXCH, &g_Strings.pwszCreateRSAExch,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_DSS_SIG_DESCR, &g_Strings.pwszDSSSigDescr,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_DSS_EXCH_DESCR, &g_Strings.pwszDHExchDescr,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_CREATE_DSS_SIG, &g_Strings.pwszCreateDSS,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_CREATE_DH_EXCH, &g_Strings.pwszCreateDH,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_IMPORT_E_PUB, &g_Strings.pwszImportDHPub,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_MIGR, &g_Strings.pwszMigrKeys,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_DELETE_SIG, &g_Strings.pwszDeleteSig,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_DELETE_KEYX, &g_Strings.pwszDeleteExch,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_DELETE_SIG_MIGR, &g_Strings.pwszDeleteMigrSig,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_DELETE_KEYX_MIGR, &g_Strings.pwszDeleteMigrExch,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_SIGNING_S, &g_Strings.pwszSigning,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_EXPORT_E_PRIV, &g_Strings.pwszExportPrivExch,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_EXPORT_S_PRIV, &g_Strings.pwszExportPrivSig,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_IMPORT_E_PRIV, &g_Strings.pwszImportPrivExch,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_IMPORT_S_PRIV, &g_Strings.pwszImportPrivSig,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_AUDIT_CAPI_KEY, &g_Strings.pwszAuditCapiKey,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        // Fix up all the strings to be real pointers rather than offsets.
        // the reason that offsets are originally stored is because we may
        // need to reallocate the buffer that all the strings are stored in.
        // So offsets are stored so that the pointers for those strings in
        // the buffers don't become invalid.
        g_Strings.pwszRSASigDescr    = (LPWSTR)(((ULONG_PTR) g_Strings.pwszRSASigDescr)    + l_pbStringBlock);
        g_Strings.pwszRSAExchDescr   = (LPWSTR)(((ULONG_PTR) g_Strings.pwszRSAExchDescr)   + l_pbStringBlock);
        g_Strings.pwszImportSimple   = (LPWSTR)(((ULONG_PTR) g_Strings.pwszImportSimple)   + l_pbStringBlock);
        g_Strings.pwszSignWExch      = (LPWSTR)(((ULONG_PTR) g_Strings.pwszSignWExch)      + l_pbStringBlock);
        g_Strings.pwszCreateRSASig   = (LPWSTR)(((ULONG_PTR) g_Strings.pwszCreateRSASig)   + l_pbStringBlock);
        g_Strings.pwszCreateRSAExch  = (LPWSTR)(((ULONG_PTR) g_Strings.pwszCreateRSAExch)  + l_pbStringBlock);
        g_Strings.pwszDSSSigDescr    = (LPWSTR)(((ULONG_PTR) g_Strings.pwszDSSSigDescr)    + l_pbStringBlock);
        g_Strings.pwszDHExchDescr    = (LPWSTR)(((ULONG_PTR) g_Strings.pwszDHExchDescr)    + l_pbStringBlock);
        g_Strings.pwszCreateDSS      = (LPWSTR)(((ULONG_PTR) g_Strings.pwszCreateDSS)      + l_pbStringBlock);
        g_Strings.pwszCreateDH       = (LPWSTR)(((ULONG_PTR) g_Strings.pwszCreateDH)       + l_pbStringBlock);
        g_Strings.pwszImportDHPub    = (LPWSTR)(((ULONG_PTR) g_Strings.pwszImportDHPub)    + l_pbStringBlock);
        g_Strings.pwszMigrKeys       = (LPWSTR)(((ULONG_PTR) g_Strings.pwszMigrKeys)       + l_pbStringBlock);
        g_Strings.pwszDeleteSig      = (LPWSTR)(((ULONG_PTR) g_Strings.pwszDeleteSig)      + l_pbStringBlock);
        g_Strings.pwszDeleteExch     = (LPWSTR)(((ULONG_PTR) g_Strings.pwszDeleteExch)     + l_pbStringBlock);
        g_Strings.pwszDeleteMigrSig  = (LPWSTR)(((ULONG_PTR) g_Strings.pwszDeleteMigrSig)  + l_pbStringBlock);
        g_Strings.pwszDeleteMigrExch = (LPWSTR)(((ULONG_PTR) g_Strings.pwszDeleteMigrExch) + l_pbStringBlock);
        g_Strings.pwszSigning        = (LPWSTR)(((ULONG_PTR) g_Strings.pwszSigning)        + l_pbStringBlock);
        g_Strings.pwszExportPrivExch = (LPWSTR)(((ULONG_PTR) g_Strings.pwszExportPrivExch) + l_pbStringBlock);
        g_Strings.pwszExportPrivSig  = (LPWSTR)(((ULONG_PTR) g_Strings.pwszExportPrivSig)  + l_pbStringBlock);
        g_Strings.pwszImportPrivExch = (LPWSTR)(((ULONG_PTR) g_Strings.pwszImportPrivExch) + l_pbStringBlock);
        g_Strings.pwszImportPrivSig  = (LPWSTR)(((ULONG_PTR) g_Strings.pwszImportPrivSig)  + l_pbStringBlock);
        g_Strings.pwszAuditCapiKey   = (LPWSTR)(((ULONG_PTR) g_Strings.pwszAuditCapiKey)   + l_pbStringBlock);

        FreeLibrary(hMod);
        hMod = NULL;
    }

    return ERROR_SUCCESS;

ErrorExit:
    if (NULL != l_pbStringBlock)
    {
        ContInfoFree(l_pbStringBlock);
        l_pbStringBlock = NULL;
    }
    if (hMod)
        FreeLibrary(hMod);
    return dwReturn;
}


void
UnloadStrings(
    void)
{
    if (NULL != l_pbStringBlock)
    {
        ContInfoFree(l_pbStringBlock);
        l_pbStringBlock = NULL;
        memset(&g_Strings, 0, sizeof(g_Strings));
    }
}


#ifdef USE_HW_RNG
#ifdef _M_IX86

// stuff for INTEL RNG usage

//
// Function : GetRNGDriverHandle
//
// Description : Gets the handle to the INTEL RNG driver if available, then
//               checks if the chipset supports the hardware RNG.  If so
//               the previous driver handle is closed if necessary and the
//               new handle is assigned to the passed in parameter.
//

DWORD
GetRNGDriverHandle(
    IN OUT HANDLE *phDriver)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    ISD_Capability  ISD_Cap;                //in/out for GetCapability
    DWORD           dwBytesReturned;
    char            szDeviceName[80] = "";  //Name of device
    HANDLE          hDriver = INVALID_HANDLE_VALUE; //Driver handle
    BOOL            fReturnCode;            //Return code from IOCTL call

    memset(&ISD_Cap, 0, sizeof(ISD_Cap));

    wsprintf(szDeviceName,"\\\\.\\"DRIVER_NAME);
    hDriver = CreateFileA(szDeviceName,
                          FILE_SHARE_READ | FILE_SHARE_WRITE
                          | GENERIC_READ | GENERIC_WRITE,
                          0, NULL,
                          OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE == hDriver)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    //Get RNG Enabled
    ISD_Cap.uiIndex = ISD_RNG_ENABLED;  //Set input member
    fReturnCode = DeviceIoControl(hDriver,
                                  IOCTL_ISD_GetCapability,
                                  &ISD_Cap, sizeof(ISD_Cap),
                                  &ISD_Cap, sizeof(ISD_Cap),
                                  &dwBytesReturned,
                                  NULL);
    if (fReturnCode == FALSE || ISD_Cap.iStatus != ISD_EOK)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    // close the previous handle if already there
    if (INVALID_HANDLE_VALUE != *phDriver)
        CloseHandle(*phDriver);

    *phDriver = hDriver;
    return ERROR_SUCCESS;

ErrorExit:
    if (INVALID_HANDLE_VALUE != hDriver)
        CloseHandle(hDriver);
    return dwReturn;
}


//
// Function : CheckIfRNGAvailable
//
// Description : Checks if the INTEL RNG driver is available, if so then
//               checks if the chipset supports the hardware RNG.
//

DWORD
CheckIfRNGAvailable(
    void)
{
    HANDLE  hDriver = INVALID_HANDLE_VALUE; //Driver handle
    DWORD   dwSts;

    dwSts = GetRNGDriverHandle(&hDriver);
    if (ERROR_SUCCESS == dwSts)
        CloseHandle(hDriver);
    return dwSts;
}


//
// Function : HWRNGGenRandom
//
// Description : Uses the passed in handle to the INTEL RNG driver
//               to fill the buffer with random bits.  Actually uses
//               XOR to fill the buffer so that the passed in buffer
//               is also mixed in.
//

DWORD
HWRNGGenRandom(
    IN HANDLE hRNGDriver,
    IN OUT BYTE *pbBuffer,
    IN DWORD dwLen)
{
    DWORD               dwReturn = ERROR_INTERNAL_ERROR;
    ISD_RandomNumber    ISD_Random;             //in/out for GetRandomNumber
    DWORD               dwBytesReturned = 0;
    DWORD               i;
    DWORD               *pdw;
    BYTE                *pb;
    BYTE                *pbRand;
    BOOL                fReturnCode;            //Return code from IOCTL call

    memset(&ISD_Random, 0, sizeof(ISD_Random));

    for (i = 0; i < (dwLen / sizeof(DWORD)); i++)
    {
        pdw = (DWORD*)(pbBuffer + i * sizeof(DWORD));

        //No input needed in the ISD_Random structure for this operation,
        //so just send it in as is.
        fReturnCode = DeviceIoControl(hRNGDriver,
                                      IOCTL_ISD_GetRandomNumber,
                                      &ISD_Random, sizeof(ISD_Random),
                                      &ISD_Random, sizeof(ISD_Random),
                                      &dwBytesReturned,
                                      NULL);
        if (fReturnCode == 0 || ISD_Random.iStatus != ISD_EOK)
        {
            //Error - ignore the data returned
            dwReturn = GetLastError();
            goto ErrorExit;
        }

        *pdw = *pdw ^ ISD_Random.uiRandomNum;
    }

    pb = pbBuffer + i * sizeof(DWORD);
    fReturnCode = DeviceIoControl(hRNGDriver,
                                  IOCTL_ISD_GetRandomNumber,
                                  &ISD_Random, sizeof(ISD_Random),
                                  &ISD_Random, sizeof(ISD_Random),
                                  &dwBytesReturned,
                                  NULL);
    if (fReturnCode == 0 || ISD_Random.iStatus != ISD_EOK)
    {
        //Error - ignore the data returned
        dwReturn = GetLastError();
        goto ErrorExit;
    }
    pbRand = (BYTE*)&ISD_Random.uiRandomNum;

    for (i = 0; i < (dwLen % sizeof(DWORD)); i++)
        pb[i] ^= pbRand[i];

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


#ifdef TEST_HW_RNG
//
// Function : SetupHWRNGIfRegistered
//
// Description : Checks if there is a registry setting indicating the HW RNG
//               is to be used.  If the registry entry is there then it attempts
//               to get the HW RNG driver handle.
//
DWORD
SetupHWRNGIfRegistered(
    OUT HANDLE *phRNGDriver)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    DWORD   dwSts;
    HKEY    hRegKey = NULL;

    // first check the registry entry to see if supposed to use HW RNG
    dwSts = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         "Software\\Microsoft\\Cryptography\\UseHWRNG",
                         0,        // dwOptions
                         KEY_READ,
                         &hRegKey);
    if (ERROR_SUCCESS == dwSts)
    {
        // get the driver handle
        dwSts = GetRNGDriverHandle(phRNGDriver);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != hRegKey)
        RegCloseKey(hRegKey);
    return dwReturn;
}
#endif // TEST_HW_RNG
#endif // _M_IX86
#endif // USE_HW_RNG

// **********************************************************************
// SelfMACCheck performs a DES MAC on the binary image of this DLL
// **********************************************************************

DWORD
SelfMACCheck(
    IN LPSTR pszImage)
{
    ANSI_STRING ansiImage;
    UNICODE_STRING unicodeImage;
    NTSTATUS status = STATUS_SUCCESS;
    DWORD dwError = ERROR_SUCCESS;

#ifndef VAULTSIGN
    return ERROR_SUCCESS;
#endif

    memset(&ansiImage, 0, sizeof(ansiImage));
    memset(&unicodeImage, 0, sizeof(unicodeImage));

    RtlInitAnsiString(
        &ansiImage,
        pszImage);

    status = RtlAnsiStringToUnicodeString(
        &unicodeImage,
        &ansiImage,
        TRUE);

    if (! NT_SUCCESS(status))
        return ERROR_NOT_ENOUGH_MEMORY;

    // 
    // Try new signature check.  Use "mincrypt" 
    // functionality.
    //
    // Look for valid embedded "signcode" signature
    // in the CSP.
    //
    dwError = MinCryptVerifySignedFile(
        MINCRYPT_FILE_NAME,
        (PVOID) unicodeImage.Buffer,
        0, NULL, NULL, NULL);

    RtlFreeUnicodeString(&unicodeImage);

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\dssinc\cryptdsa.h ===
#ifndef __CRYPTDSA_
#define __CRYPTDSA_

#ifdef __cplusplus
extern "C" {
#endif

#define SHA_BITS      160
                            // Number of bits output by SHA
#define SHA_DWORDS      5
                            // Number of DWORDS output by SHA
#define DSA_Q_MINDWORDS 5
                            // Minimum number of DWORDS in q
#define DSA_Q_MAXDWORDS 128
                            // Maximum number of DWORDS in q
#define DSA_P_MINDWORDS 16
                            // Minimum number of DWORDS in p
#define DSA_P_MAXDWORDS 128
                            // Maximum number of DWORDS in p

#define DSA_Q_MAXDIGITS DWORDS_TO_DIGITS(DSA_Q_MAXDWORDS)
#define DSA_P_MAXDIGITS DWORDS_TO_DIGITS(DSA_P_MAXDWORDS)


typedef struct {
        void             *pInfo;
        void             *pFuncRNG;
        } RNGINFO;

typedef struct {
                DWORD    nbitp;             // Number of significant bits in p.
                                            // (Multiple of 64,   512 <= nbitp <= 1024)
                DWORD    nbitq;             // Number of significant bits in q.
                                            // Must be exactly 160.
                DWORD    p[DSA_P_MAXDWORDS];// Public prime p, 512-1024 bits
                DWORD    q[DSA_Q_MAXDWORDS];// Public prime q (160 bits, divides p-1)
                DWORD    g[DSA_P_MAXDWORDS];// Public generator g of order q (mod p)
                DWORD    j[DSA_P_MAXDWORDS];// j = (p - 1) / q
                DWORD    y[DSA_P_MAXDWORDS];// Public value g^x (mod p), where x is private
                DWORD    S[SHA_DWORDS];     // 160-bit pattern used to construct q
                DWORD    C;                 // 12-bit value of C used to construct p
               } dsa_public_t;

typedef struct {
                digit_t        qdigit[DSA_Q_MAXDIGITS];
                DWORD          lngq_digits;           // Length of q in digits
                reciprocal_1_t qrecip;                // Information about 1/q
                digit_t        gmodular[DSA_P_MAXDIGITS];
                                                      // g as residue mod p
                digit_t        ymodular[DSA_P_MAXDIGITS];
                                                      // y as residue mod p
                mp_modulus_t   pmodulus;              // Constants mod p
               } dsa_precomputed_t;


typedef struct {
                dsa_public_t      pub;               // Public data
                DWORD             x[DSA_P_MAXDWORDS];// Private exponent x (mod q)
                dsa_precomputed_t precomputed;       // Precomputed public data
               } dsa_private_t;

typedef struct {
                DWORD r[SHA_DWORDS];            // (g^k mod p)       mod q
                DWORD s[SHA_DWORDS];            // (SHA(m) + x*r)/k  mod q
               } dsa_signature_t;

typedef struct {
                VOID *pOffload;            // pointer to expo offload info
                FARPROC pFuncExpoOffload;
                RNGINFO *pRNGInfo;            // pointer to RNG info
               } dsa_other_info;

typedef const dsa_precomputed_t dsa_precomputed_tc;
typedef const dsa_private_t     dsa_private_tc;
typedef const dsa_public_t      dsa_public_tc;
typedef const dsa_signature_t   dsa_signature_tc;

void DSA_gen_x(DWORDC cXDigits,                         // In
               DWORDC cXDwords,                         // In
               digit_t *pMod,                           // In
               dsa_other_info *pOtherInfo,              // In
               DWORD *pdwX,                             // Out
               digit_t *pXDigit);                       // Out

BOOL DSA_gen_x_and_y(BOOL fUseQ,                             // In
                     dsa_other_info *pOtherInfo,             // In
                     dsa_private_t *privkey);                // Out

BOOL DSA_check_g(DWORDC         lngp_digits,                   // In
                 digit_tc       *pGModular,                    // In
                 mp_modulus_t   *pPModulo,                     // In
                 DWORDC         lngq_digits,                   // In
                 digit_tc       *pQDigit);                     // In

BOOL DSA_key_generation(DWORDC         nbitp,                   // In
                        DWORDC         nbitq,                   // In
                        dsa_other_info *pOtherInfo,             // In
                        dsa_private_t  *privkey);               // Out

BOOL DSA_key_import_fillin(dsa_private_t *privkey);                             // In, Out

BOOL DSA_precompute_pgy(dsa_public_tc     *pubkey,               // In
                        dsa_precomputed_t *precomputed);         // Out

BOOL DSA_precompute(dsa_public_tc     *pubkey,                    // In
                    dsa_precomputed_t *precomputed,               // Out
                    const BOOL         checkSC);                  // In

BOOL DSA_sign(DWORDC           message_hash[SHA_DWORDS],   /* TBD */
              dsa_private_tc   *privkey,
              dsa_signature_t  *signature,
              dsa_other_info   *pOtherInfo);

BOOL DSA_signature_verification(DWORDC              message_hash[SHA_DWORDS],
                                dsa_public_tc       *pubkey,
                                dsa_precomputed_tc  *precomputed_argument,
                                dsa_signature_tc    *signature,
                                dsa_other_info      *pOtherInfo);

BOOL DSA_parameter_verification(
                                dsa_public_tc       *pPubkey,
                                dsa_precomputed_tc  *pPrecomputed
                                );

BOOL DSA_verify_j(
                  dsa_public_tc       *pPubkey,
                  dsa_precomputed_tc  *pPrecomputed
                  );

#ifdef __cplusplus
}
#endif

#endif __CRYPTDSA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\dssinc\crypto.h ===
/****************************************************************************
*
*
*	FILENAME:		crypto.h
*
*	PRODUCT NAME:	CRYPTOGRAPHIC TOOLKIT
*
*	FILE STATUS:
*
*	DESCRIPTION:	Cryptographic Toolkit File
*					Common Definitions
*		    
*
*	PUBLIC FUNCTIONS:
*
*
*	REVISION  HISTORY:
*
*
*		10 Feb 96	AK		Created
*
*
* Created for Cylink Corporation by Secant
*
****************************************************************************/


#ifndef CRYPTO_H
#define CRYPTO_H

/* For C++ */
#ifdef __cplusplus
extern "C" {
#endif

/*************************************
*
* Module Defines
*
*************************************/

#define	FALSE		0
#define	TRUE        1
#define	SUCCESS		0

/*-- ANSI-recommended NULL Pointer definition --*/
#ifndef	NULL
#define	NULL		(void *) 0
#endif


/*************************************
*
* Error Definitions
*
*************************************/
#define	ERR_ALLOC		-1



/*************************************
*
* Type Definitions
*
*************************************/
typedef unsigned char	uchar;
typedef unsigned short	ushort;
typedef unsigned long	ulong;
typedef	unsigned char	BYTE;
typedef	unsigned short	USHORT;
typedef	unsigned int	UINT;
typedef	unsigned long	ULONG;
typedef int		BOOL;


#ifdef ORD_16
typedef unsigned short ord;
typedef unsigned long dord;
#endif
#ifdef ORD_32
typedef unsigned long ord;
typedef unsigned long dord;
#endif


#ifdef __cplusplus
}
#endif


#endif     /* CRYPTO_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\dssinc\des_key.h ===
/* des_key.h */


/*********************************/
/* Definitions                   */
/*********************************/
#define		DES_MAGIC		0x44455331

/*********************************/
/* Function Definitions          */
/*********************************/

DWORD initKeyDES (Key_t *des);
DWORD getDESParams (Key_t *des, DWORD param, BYTE *data, DWORD *len);
DWORD setDESParams (Key_t *des, DWORD param, CONST BYTE *data);

// Get DES key length
DWORD desGetKeyLength (
                       IN ALG_ID Algid,
                       IN DWORD dwFlags,
                       OUT DWORD *pcbKey,
                       OUT DWORD *pcbData
                       );

// Derive a des key
DWORD desDeriveKey (
                   IN OUT Key_t *pKey,
                   IN CONST BYTE *pbData,
                   IN DWORD dwFlags
                   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\dssinc\dh_key.h ===
/* dh_key.h */

#ifdef __cplusplus
extern "C" {
#endif

#define DH_MAX_LENGTH           0x00000200     // in bytes, 512 bytes, 4096 bits
#define DH_KEYSIZE_INC          0x40

/*********************************/
/* Definitions                   */
/*********************************/
#define DH_PUBLIC_MAGIC         0x31484400
#define DH_PRIVATE_MAGIC        0x32484400
#define DH_PUBLIC_MAGIC_VER3    0x33484400
#define DH_PRIV_MAGIC_VER3      0x34484400

/*********************************/
/* Structure Definitions         */
/*********************************/

typedef dsa_private_t DHKey_t; // use a DSA key since X 9.42 requires key
                               // gen like DSA

/*
typedef struct {
    ALG_ID      Algid;          // algorithm type of the key (SF or EPHEM)
    DH_PRIV_KEY Priv;
} DHKey_t;
*/

/*********************************/
/* Function Definitions          */
/*********************************/

// Initialize DH key
DWORD
initKeyDH(
    IN Context_t *pContext,
    IN OUT DHKey_t *pDH,
    IN ALG_ID Algid,
    IN DWORD dwFlags,
    IN BOOL fAnyLength);

DHKey_t *allocDHKey ();
void freeKeyDH (DHKey_t *dh);

// Get the DH parameters
DWORD getDHParams (
                   IN DHKey_t *dh,
                   IN DWORD param,
                   OUT BYTE *data,
                   OUT DWORD *len
                   );

// Set the DH parameters
DWORD setDHParams (
                   IN OUT DHKey_t *pDH,
                   IN DWORD dwParam,
                   IN CONST BYTE *pbData,
                   IN OUT Context_t *pContext,
                   IN ALG_ID AlgId
                   );

// Generate a dh key
DWORD dhGenerateKey (
                     IN Context_t *pContext,
                     IN OUT DHKey_t *pDH,
                     IN ALG_ID AlgId);

DWORD dhDeriveKey (DHKey_t *dh, BYTE *data, DWORD len);

// Export the DH key in blob format
DWORD exportDHKey (
                   IN Context_t *pContext,
                   IN DHKey_t *pDH,
                   IN ALG_ID Algid,
                   IN DWORD dwFlags,
                   IN DWORD dwReserved,
                   IN DWORD dwBlobType,
                   OUT BYTE *pbData,
                   OUT DWORD *pcbData,
                   IN BOOL fInternal
                   );

DWORD DHPrivBlobToKey(
                      IN Context_t *pContext,
                      IN BLOBHEADER *pBlob,
                      IN DWORD cbBlob,
                      IN DWORD dwKeysetType,
                      OUT Key_t *pPrivKey
                      );

// Import the blob into DH key
DWORD importDHKey(
                  IN OUT Key_t *pPrivKey,
                  IN Context_t *pContext,
                  IN BYTE *pbBlob,
                  IN DWORD cbBlob,
                  OUT Key_t *pKey,
                  IN DWORD dwKeysetType,
                  IN BOOL fInternal
                  );

void copyDHPubKey(
                  IN DHKey_t *pDH1,
                  IN DHKey_t *pDH2
                  );

DWORD copyDHKey(
                IN DHKey_t *pDH1,
                IN DHKey_t *pDH2,
                IN ALG_ID Algid,
                IN Context_t *pContext
                );

//
// Function : UseDHKey
//
// Description : This function creates an ephemeral DH key and then generates
//               two agreed keys, thus simulating a DH exchange.  If the
//               agreed keys are not the same then the function fails.
//

DWORD UseDHKey(
               IN Context_t *pContext,
               IN PEXPO_OFFLOAD_STRUCT pOffloadInfo,
               IN DHKey_t *pDH
               );


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\dssinc\csp.h ===
/* csp.h */

#ifndef __DSSINC__CSP__H
#define __DSSINC__CSP__H

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windef.h>
#include <wtypes.h>
#include <wincrypt.h>
#include <cspdk.h>
#include <winerror.h>
#include <crypto.h>
#include <mem.h>
#include <contman.h>
#include <policy.h>
#include <fxupbn.h>
#include <delayimp.h>
#include <pstore.h>

#ifdef _WIN64
#define ALIGNMENT_BOUNDARY 7
#else
#define ALIGNMENT_BOUNDARY 3
#endif

#ifdef _DEBUG
#include <crtdbg.h>
// #define BreakPoint
#define BreakPoint _CrtDbgBreak();
#define EntryPoint
// #define EntryPoint BreakPoint
#ifndef ASSERT
#define ASSERT _ASSERTE
#endif
#else   // _DEBUG
#define BreakPoint
#define EntryPoint
#ifndef ASSERT
#define ASSERT
#endif
#endif  // _DEBUG

// Specify which algorithms are supported
#define CSP_USE_SHA1
#define CSP_USE_MD5
#define CSP_USE_RC4
#define CSP_USE_RC2
#define CSP_USE_MAC
#define CSP_USE_DES40
#define CSP_USE_DES
#define CSP_USE_3DES
#define CSP_USE_SSL3

// Special definitions
#define RC_MAXSALTSIZE          256
#define RC2_DEFEFFSIZE           40
#define RC2_MINEFFSIZE           40
#define RC2_BLOCKLEN              8
#define RC_DEFSALTSIZE           11

#define RC2_WEAK_MAXEFFSIZE      56
#define RC2_STRONG_MAXEFFSIZE   128


/*********************************/
/* Definitions                   */
/*********************************/

/*********************************/
/* Structure Definitions         */
/*********************************/

#define CALG_DES40  CALG_CYLINK_MEK

typedef struct _dhSharedNumber
{
    BYTE            *shared;
    DWORD           len;
} dhSharedNumber;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\dssinc\fxupbn.h ===
#include <bignum.h>
#include "cryptdsa.h"
#include <crtdbg.h>

inline void WINAPI BN_ResetError(void)
{
    SetMpErrno(MP_ERRNO_NO_ERROR);
}

inline DWORD WINAPI BN_MapError(BOOL fSts)
{
    DWORD dwRet = ERROR_INTERNAL_ERROR;

    if (MP_ERRNO_NO_MEMORY == GetMpErrno())
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
    else if (fSts)
        dwRet = ERROR_SUCCESS;
    else
        dwRet = (DWORD)NTE_FAIL;
    return dwRet;
}


// extern digit_t Stdcall86 sub_same(digit_tc a[], digit_tc b[], digit_t c[], DWORDC d);

inline DWORD
BN_DSA_verify_j(
    dsa_public_tc *pPubkey,
    dsa_precomputed_tc *pPrecomputed)
{
    BOOL fSts;
    BN_ResetError();
    fSts = DSA_verify_j(pPubkey, pPrecomputed);
    return BN_MapError(fSts);
}

inline DWORD
BN_DSA_check_g(
    DWORDC         lngp_digits, // In
    digit_tc       *pGModular,  // In
    mp_modulus_t   *pPModulo,   // In
    DWORDC         lngq_digits, // In
    digit_tc       *pQDigit)    // In
{
    BOOL fSts;
    BN_ResetError();
    fSts = DSA_check_g(lngp_digits, pGModular, pPModulo, lngq_digits, pQDigit);
    return BN_MapError(fSts);
}

inline DWORD
BN_DSA_parameter_verification(
    dsa_public_tc       *pPubkey,
    dsa_precomputed_tc  *pPrecomputed)
{
    BOOL fSts;
    BN_ResetError();
    fSts = DSA_parameter_verification(pPubkey, pPrecomputed);
    return BN_MapError(fSts);
}

inline DWORD
BN_DSA_precompute(
    dsa_public_tc     *pubkey,      // In
    dsa_precomputed_t *precomputed, // Out
    const BOOL         checkSC)     // In
{
    BOOL fSts;
    BN_ResetError();
    fSts = DSA_precompute(pubkey, precomputed, checkSC);
    return BN_MapError(fSts);
}

inline DWORD
BN_from_modular(
    digit_tc a[],
    digit_t b[],
    mp_modulus_tc *modulo)
{
    DWORD dwSts;
    BN_ResetError();
    dwSts = from_modular(a, b, modulo);
    if (ERROR_SUCCESS != BN_MapError(0 != dwSts))
        dwSts = 0;
    return dwSts;
}

inline DWORD
BN_mod_exp(
    digit_tc base[],
    digit_tc exponent[],
    DWORDC lngexpon,
    digit_t answer[],
    mp_modulus_tc *modulo)
{
    BN_ResetError();
    mod_exp(base, exponent, lngexpon, answer, modulo);
    return BN_MapError(TRUE);
}

inline DWORD
BN_to_modular(
    digit_tc a[],
    DWORDC lnga,
    digit_t b[],
    mp_modulus_tc *modulo)
{
    DWORD dwSts;
    BN_ResetError();
    dwSts = to_modular(a, lnga, b, modulo);
    if (ERROR_SUCCESS != BN_MapError(0 != dwSts))
        dwSts = 0;
    return dwSts;
}

inline DWORD
BN_DSA_gen_x_and_y(
    BOOL fUseQ,                 // In
    dsa_other_info *pOtherInfo, // In
    dsa_private_t *privkey)     // Out
{
    BOOL fSts;
    BN_ResetError();
    fSts = DSA_gen_x_and_y(fUseQ, pOtherInfo, privkey);
    return BN_MapError(fSts);
}

inline DWORD
BN_DSA_precompute_pgy(
    dsa_public_tc     *pubkey,      // In
    dsa_precomputed_t *precomputed) // Out
{
    BOOL fSts;
    BN_ResetError();
    fSts = DSA_precompute_pgy(pubkey, precomputed);
    return BN_MapError(fSts);
}

inline DWORD
BN_DSA_key_generation(
    DWORDC         nbitp,       // In
    DWORDC         nbitq,       // In
    dsa_other_info *pOtherInfo, // In
    dsa_private_t  *privkey)    // Out
{
    BOOL fSts;
    BN_ResetError();
    fSts = DSA_key_generation(nbitp, nbitq, pOtherInfo, privkey);
    return BN_MapError(fSts);
}

inline DWORD
BN_DSA_signature_verification(
    DWORDC              message_hash[SHA_DWORDS],
    dsa_public_tc       *pubkey,
    dsa_precomputed_tc  *precomputed_argument,
    dsa_signature_tc    *signature,
    dsa_other_info      *pOtherInfo)
{
    BOOL fSts;
    BN_ResetError();
    fSts = DSA_signature_verification(message_hash, pubkey,
                                      precomputed_argument,
                                      signature, pOtherInfo);
    return BN_MapError(fSts);
}

inline DWORD
BN_DSA_sign(
    DWORDC           message_hash[SHA_DWORDS],   /* TBD */
    dsa_private_tc   *privkey,
    dsa_signature_t  *signature,
    dsa_other_info   *pOtherInfo)
{
    BOOL fSts;
    BN_ResetError();
    fSts = DSA_sign(message_hash, privkey,  signature, pOtherInfo);
    return BN_MapError(fSts);
}

inline DWORD
BN_create_modulus(
    digit_tc a[],
    DWORDC lnga,
    reddir_tc reddir,
    mp_modulus_t *modulo)
{
    BOOL fSts;
    BN_ResetError();
    fSts = create_modulus(a, lnga, reddir, modulo);
    return BN_MapError(fSts);
}

inline DWORD
BN_DSA_key_import_fillin(
    dsa_private_t *privkey)
{
    BOOL fSts;
    BN_ResetError();
    fSts = DSA_key_import_fillin(privkey);
    return BN_MapError(fSts);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\dssinc\dss_key.h ===
#ifdef __cplusplus
extern "C" {
#endif

/* dss_key.h */

#define DSS_KEYSIZE_INC       64

/*********************************/
/* Definitions                   */
/*********************************/
#define DSS_MAGIC           0x31535344
#define DSS_PRIVATE_MAGIC   0x32535344
#define DSS_PUB_MAGIC_VER3  0x33535344
#define DSS_PRIV_MAGIC_VER3 0x34535344

/*********************************/
/* Structure Definitions         */
/*********************************/

typedef dsa_private_t DSSKey_t;

/*********************************/
/* Function Definitions          */
/*********************************/

extern DSSKey_t *
allocDSSKey(
    void);

extern void
freeKeyDSS(
    DSSKey_t *dss);

extern DWORD
initKeyDSS(
    IN Context_t *pContext,
    IN ALG_ID Algid,
    IN OUT DSSKey_t *pDss,
    IN DWORD dwBitLen);

// Generate the DSS keys
extern DWORD
genDSSKeys(
    IN Context_t *pContext,
    IN OUT DSSKey_t *pDss);

extern void
copyDSSPubKey(
    IN DSSKey_t *dss1,
    IN DSSKey_t *dss2);

extern void
copyDSSKey(
    IN DSSKey_t *dss1,
    IN DSSKey_t *dss2);

extern DWORD
getDSSParams(
    DSSKey_t *dss,
    DWORD param,
    BYTE *data,
    DWORD *len);

extern DWORD
setDSSParams(
    IN Context_t *pContext,
    IN OUT DSSKey_t *pDss,
    IN DWORD dwParam,
    IN CONST BYTE *pbData);

extern BOOL
DSSValueExists(
    IN DWORD *pdw,
    IN DWORD cdw,
    OUT DWORD *pcb);

extern DWORD
ExportDSSPrivBlob3(
    IN Context_t *pContext,
    IN DSSKey_t *pDSS,
    IN DWORD dwMagic,
    IN ALG_ID Algid,
    IN BOOL fInternalExport,
    IN BOOL fSigKey,
    OUT BYTE *pbKeyBlob,
    IN OUT DWORD *pcbKeyBlob);

extern DWORD
ImportDSSPrivBlob3(
    IN BOOL fInternalExport,
    IN CONST BYTE *pbKeyBlob,
    IN DWORD cbKeyBlob,
    OUT DSSKey_t *pDSS);

extern DWORD
ExportDSSPubBlob3(
    IN DSSKey_t *pDSS,
    IN DWORD dwMagic,
    IN ALG_ID Algid,
    OUT BYTE *pbKeyBlob,
    IN OUT DWORD *pcbKeyBlob);

extern DWORD
ImportDSSPubBlob3(
    IN CONST BYTE *pbKeyBlob,
    IN DWORD cbKeyBlob,
    IN BOOL fYIncluded,
    OUT DSSKey_t *pDSS);

// Export DSS key into blob format
extern DWORD
exportDSSKey(
    IN Context_t *pContext,
    IN DSSKey_t *pDSS,
    IN DWORD dwFlags,
    IN DWORD dwBlobType,
    IN BYTE *pbKeyBlob,
    IN DWORD *pcbKeyBlob,
    IN BOOL fInternalExport);

// Import the blob into DSS key
extern DWORD
importDSSKey(
    IN Context_t *pContext,
    IN Key_t *pKey,
    IN CONST BYTE *pbKeyBlob,
    IN DWORD cbKeyBlob,
    IN DWORD dwKeysetType,
    IN BOOL fInternal);

extern DWORD
dssGenerateSignature(
    Context_t *pContext,
    DSSKey_t *pDss,
    BYTE *pbHash,
    BYTE *pbSig,
    DWORD *pcbSig);

//
// Function : SignAndVerifyWithKey
//
// Description : This function creates a hash and then signs that hash with
//               the passed in key and verifies the signature.  The function
//               is used for FIPS 140-1 compliance to make sure that newly
//               generated/imported keys work and in the self test during
//               DLL initialization.
//

extern DWORD
SignAndVerifyWithKey(
    IN DSSKey_t *pDss,
    IN EXPO_OFFLOAD_STRUCT *pOffloadInfo,
    IN HANDLE hRNGDriver,
    IN BYTE *pbData,
    IN DWORD cbData);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\dssinc\hash.h ===
/* hash.h */

/*********************************/
/* Function Definitions          */
/*********************************/

#ifdef CSP_USE_MD5
//
// Function : TestMD5
//
// Description : This function hashes the passed in message with the MD5 hash
//               algorithm and returns the resulting hash value.
//
BOOL TestMD5(
             BYTE *pbMsg,
             DWORD cbMsg,
             BYTE *pbHash
             );
#endif // CSP_USE_MD5

#ifdef CSP_USE_SHA1
//
// Function : TestSHA1
//
// Description : This function hashes the passed in message with the SHA1 hash
//               algorithm and returns the resulting hash value.
//
BOOL TestSHA1(
              BYTE *pbMsg,
              DWORD cbMsg,
              BYTE *pbHash
              );
#endif // CSP_USE_SHA1

Hash_t *allocHash ();
void freeHash (Hash_t *hash);

DWORD feedHashData (Hash_t *hash, BYTE *data, DWORD len);
DWORD finishHash (Hash_t *hash, BYTE *pbData, DWORD *len);
DWORD getHashParams (Hash_t *hash, DWORD param, BYTE *pbData, DWORD *len);
DWORD setHashParams (Hash_t *hash, DWORD param, CONST BYTE *pbData);

DWORD DuplicateHash(
                    Hash_t *pHash,
                    Hash_t *pNewHash
                    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\dssinc\mem.h ===
/* mem.h */


  #define       DSSMalloc(a)       ContAlloc(a)
  #define       DSSFree(a)         if (NULL != (a)) ContFree(a)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\dssinc\key.h ===
/* key.h */

#ifdef __cplusplus
extern "C" {
#endif

// needs to be put into wincrypt.h or left open in wincrypt.h
#define     KP_Z                    30
#define     IPSEC_FLAG_CHECK        0xF42A19B6

static BYTE rgbSymmetricKeyWrapIV[8] = {0x4a, 0xdd, 0xa2, 0x2c, 0x79, 0xe8, 0x21, 0x05};

/*********************************/
/* Function Definitions          */
/*********************************/

extern void
UnpickleKey(
    ALG_ID Algid,
    BYTE *pbData,
    DWORD cbData,
    BOOL *pfExportable,
    Key_t *pKey);

extern Key_t *
allocKey(
    void);

// Delete a key
extern void
freeKey(
    IN OUT Key_t *key);

// Copy a public key
extern void
CopyPubKey(
    IN Key_t *pKeyIn,
    OUT Key_t *pKeyOut);

// Initialize a key
extern DWORD
initKey(
    IN OUT Key_t *key,
    IN Context_t *pContext,
    IN ALG_ID algId,
    IN DWORD dwFlags);

extern BOOL
checkKey(
    Key_t *key);

// Derive key
// if the pHash parameter is non zero and the key to be derived is a
// 3 Key triple DES key, then the data is expanded to the appropriate key size
extern DWORD
deriveKey(
    Key_t *pKey,
    Context_t *pContext,
    BYTE *pbData,
    DWORD cbData,
    DWORD dwFlags,
    Hash_t *pHash,
    BOOL fGenKey,
    BOOL fAnySizeRC2);

// generate a key
extern DWORD
generateKey(
    IN OUT Key_t *pKey,
    IN DWORD dwFlags,
    IN OUT uchar *pbRandom,
    IN DWORD cbRandom,
    IN Context_t *pContext);

// duplicate a key
extern DWORD
DuplicateKey(
    Context_t *pContext,
    Key_t *pKey,
    Key_t *pNewKey,
    BOOL fCopyContext);

// set the parameters on a key
extern DWORD
setKeyParams(
    IN OUT Key_t *pKey,
    IN DWORD dwParam,
    IN CONST BYTE *pbData,
    IN OUT Context_t *pContext,
    IN DWORD dwFlags);

extern DWORD
getKeyParams(
    IN Context_t *pContext,
    IN Key_t *key,
    IN DWORD param,
    IN DWORD dwFlags,
    OUT BYTE *data,
    OUT DWORD *len);

extern DWORD
ImportOpaqueBlob(
    Context_t *pContext,
    CONST BYTE *pbData,
    DWORD cbData,
    HCRYPTKEY *phKey);

// Export the requested key into blob format
extern DWORD
exportKey(
    IN Context_t *pContext,
    IN Key_t *pKey,
    IN Key_t *pEncKey,
    IN DWORD dwBlobType,
    IN DWORD dwFlags,
    OUT BYTE *pbBlob,
    OUT DWORD *pcbBlob,
    IN BOOL fInternalExport);

extern DWORD
feedPlainText(
    Key_t *pKey,
    BYTE *pbData,
    DWORD dwBufLen,
    DWORD *pdwDataLen,
    int final);

extern DWORD
feedCypherText(
    Key_t *pKey,
    BYTE *pbData,
    DWORD *pdwDataLen,
    int final);

extern DWORD
generateSignature(
    IN Context_t *pContext,
    IN Key_t *key,
    IN uchar *hashVal,
    OUT uchar *pbSignature,
    OUT DWORD *pdwSigLen);

// Verify signature
extern DWORD
verifySignature(
    IN Context_t *pContext,
    IN Key_t *pKey,
    IN uchar *pbHash,
    IN DWORD cbHash,
    IN uchar *pbSignature,
    IN DWORD cbSignature);

extern DWORD
BlockEncrypt(
    void EncFun(BYTE *In, BYTE *Out, void *key, int op),
    Key_t *pKey,
    int BlockLen,
    BOOL Final,
    BYTE  *pbData,
    DWORD *pdwDataLen,
    DWORD dwBufLen);

extern DWORD
BlockDecrypt(
    void DecFun(BYTE *In, BYTE *Out, void *key, int op),
    Key_t *pKey,
    int BlockLen,
    BOOL Final,
    BYTE  *pbData,
    DWORD *pdwDataLen);

//
// Function : TestSymmetricAlgorithm
//
// Description : This function expands the passed in key buffer for the appropriate algorithm,
//               encrypts the plaintext buffer with the same algorithm and key, and the
//               compares the passed in expected ciphertext with the calculated ciphertext
//               to make sure they are the same.  The function only uses ECB mode for
//               block ciphers and the plaintext buffer must be the same length as the
//               ciphertext buffer.  The length of the plaintext must be either the
//               the block length of the cipher if it is a block cipher or less
//               than MAX_BLOCKLEN if a stream cipher is being used.
//
extern DWORD
TestSymmetricAlgorithm(
    IN ALG_ID Algid,
    IN CONST BYTE *pbKey,
    IN DWORD cbKey,
    IN CONST BYTE *pbPlaintext,
    IN DWORD cbPlaintext,
    IN CONST BYTE *pbCiphertext,
    IN CONST BYTE *pbIV);

/*
 -  GetRC4KeyForSymWrap
 -
 *  Purpose:
 *            RC4 or more precisely stream ciphers are not supported by the CMS spec
 *            on symmetric key wrapping so we had to do something proprietary since
 *            we want to support RC4 for applications other than SMIME
 *
 *
 *  Parameters:
 *               IN  pContext   - Pointer to the context
 *               IN  pbSalt     - Pointer to the 8 byte salt buffer
 *               IN  pKey       - Pointer to the orignial key
 *               OUT ppNewKey   - Pointer to a pointer to the new key
 */
extern DWORD
GetRC4KeyForSymWrap(
    IN Context_t *pContext,
    IN BYTE *pbSalt,
    IN Key_t *pKey,
    OUT Key_t **ppNewKey);

/*
 -  GetSymmetricKeyChecksum
 -
 *  Purpose:
 *                Calculates the checksum for a symmetric key which is to be
 *                wrapped with another symmetric key.  This should meet the
 *                CMS specification
 *
 *
 *  Parameters:
 *               IN  pKey       - Pointer to the key
 *               OUT pbChecksum - Pointer to the 8 byte checksum
 */
extern void
GetSymmetricKeyChecksum(
    IN BYTE *pbKey,
    IN DWORD cbKey,
    OUT BYTE *pbChecksum);

// check for symmetric wrapping support
#define UnsupportedSymKey(pKey) ((CALG_RC4 != pKey->algId) && \
                                 (CALG_RC2 != pKey->algId) && \
                                 (CALG_DES != pKey->algId) && \
                                 (CALG_CYLINK_MEK != pKey->algId) && \
                                 (CALG_3DES != pKey->algId) && \
                                 (CALG_3DES_112 != pKey->algId))

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\dssinc\user.h ===
/* user.h */

/*********************************/
/* Definitions                   */
/*********************************/


/*********************************/
/* Structure Definitions         */
/*********************************/


/*********************************/
/* Function Definitions          */
/*********************************/

extern DWORD
logonUser(
    LPCSTR pszUserID,
    DWORD dwFlags,
    DWORD dwProvType,
    LPCSTR szProvName,
    HCRYPTPROV *phUID);

extern DWORD
logoffUser(
    Context_t *context);

// Read the user record
extern DWORD
readUserKeys(
    IN Context_t *pContext,
    IN DWORD dwKeysetType);

extern DWORD
writeUserKeys(
    Context_t *context);

//
// Routine : ProtectPrivKey
//
// Description : Encrypts the private key and persistently stores it.
//

extern DWORD
ProtectPrivKey(
    IN OUT Context_t *pContext,
    IN LPWSTR szPrompt,
    IN DWORD dwFlags,
    IN BOOL fSigKey);

//
// Routine : UnprotectPrivKey
//
// Description : Decrypts the private key.  If the fAlwaysDecrypt flag is set
//               then it checks if the private key is already in the buffer
//               and if so then it does not decrypt.
//

extern DWORD
UnprotectPrivKey(
    IN OUT Context_t *pContext,
    IN LPWSTR szPrompt,
    IN BOOL fSigKey,
    IN BOOL fAlwaysDecrypt);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\dssinc\schderiv.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : schderiv.h                                             //
//  DESCRIPTION   :                                                        //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Oct  9 1997 jeffspel  Create                                       //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef __SCHDERIV_H__
#define __SCHDERIV_H__

#ifdef __cplusplus
extern "C" {
#endif

#define     RC_KEYLEN            16
#define     MAX_PREMASTER_LEN   512  // DH key must be <= 4096 bits
#define     MAX_RANDOM_LEN      256

#define     TLS_MASTER_LEN       48
#define     SSL3_MASTER_LEN      48

// definition of a Secure Channel hash structure
typedef struct _SCH_KeyData
{
    BYTE        rgbPremaster[MAX_PREMASTER_LEN];
    DWORD       cbPremaster;
    BYTE        rgbClientRandom[MAX_RANDOM_LEN];
    DWORD       cbClientRandom;
    BYTE        rgbServerRandom[MAX_RANDOM_LEN];
    DWORD       cbServerRandom;
    ALG_ID      EncAlgid;
    ALG_ID      HashAlgid;
    DWORD       cbEnc;
    DWORD       cbEncMac;
    DWORD       cbHash;
    DWORD       cbIV;
    BOOL        fFinished;
    BOOL        dwFlags;
} SCH_KEY, *PSCH_KEY;

// definition of a Secure Channel hash structure
typedef struct _SCH_HashData
{
    ALG_ID      ProtocolAlgid;
    ALG_ID      EncAlgid;
    ALG_ID      HashAlgid;
    DWORD       cbEnc;
    DWORD       cbEncMac;
    DWORD       cbHash;
    DWORD       cbIV;
    BYTE        rgbClientRandom[MAX_RANDOM_LEN];
    DWORD       cbClientRandom;
    BYTE        rgbServerRandom[MAX_RANDOM_LEN];
    DWORD       cbServerRandom;
    BYTE        rgbFinal[MAX_RANDOM_LEN];
    DWORD       cbFinal;
    BOOL        dwFlags;
} SCH_HASH, *PSCH_HASH;

// definition of a TLS1 PRF hash structure
typedef struct _PRF_HashData
{
    BYTE        rgbLabel[MAX_RANDOM_LEN];
    DWORD       cbLabel;
    BYTE        rgbSeed[MAX_RANDOM_LEN];
    DWORD       cbSeed;
    BYTE        rgbMasterKey[TLS_MASTER_LEN];
} PRF_HASH;

extern DWORD
SCHSetKeyParam(
    IN Context_t *pContext,
    IN Key_t *pKey,
    IN DWORD dwParam,
    IN CONST BYTE *pbData);

extern BOOL
SCHGetKeyParam(
    Key_t *pKey,
    DWORD dwParam,
    PBYTE pbData);

extern DWORD
SChGenMasterKey(
    Key_t *pKey,
    PSCH_HASH pSChHash);

extern DWORD
SecureChannelDeriveKey(
    Hash_t *pHash,
    ALG_ID Algid,
    DWORD dwFlags,
    HCRYPTKEY *phKey);

extern DWORD
SetPRFHashParam(
    PRF_HASH *pPRFHash,
    DWORD dwParam,
    CONST BYTE *pbData);

extern DWORD
CalculatePRF(
    PRF_HASH *pPRFHash,
    BYTE *pbData,
    DWORD *pcbData);

#ifdef __cplusplus
}
#endif

#endif // __SCHDERIV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\dssinc\protstr.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : protstor.h                                             //
//  DESCRIPTION   :                                                        //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Dec  4 1996 jeffspel  Create                                       //
//      Apr 21 1997 jeffspel  Changes for NT 5 tree                        //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef __PROTSTOR_H__
#define __PROTSTOR_H__

#ifdef __cplusplus
extern "C" {
#endif

extern BOOL
CheckPStoreAvailability(
    PSTORE_INFO *pPStore);

extern DWORD
CreateNewPSKeyset(
    PSTORE_INFO *pPStore,
    DWORD dwFlags);

extern DWORD
GetKeysetTypeAndSubType(
    Context_t *pContext);

extern DWORD
SetKeyTypeSubtype(
    Context_t *pContext,
    PKEY_TYPE_SUBTYPE pTypeSubtype);

extern DWORD
RestoreKeysetFromProtectedStorage(
    Context_t *pContext,
    Key_t *pKey,
    LPWSTR szPrompt,
    BOOL fSigKey,
    BOOL *pfUIOnKey);

extern DWORD
SetKeysetTypeAndSubtype(
    Context_t *pContext);

extern DWORD
SetUIPrompt(
    Context_t *pContext,
    LPWSTR szPrompt);

extern DWORD
DeleteKeyFromProtectedStorage(
    Context_t *pContext,
    PCSP_STRINGS pStrings,
    DWORD dwKeySpec,
    BOOL fMigration);

extern DWORD
DeleteFromProtectedStorage(
    IN Context_t *pContext,
    PCSP_STRINGS pStrings,
    IN BOOL fMigration);

extern void
FreePSInfo(
    PSTORE_INFO *pPStore);

#ifdef __cplusplus
}
#endif

#endif // __PROTSTOR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\dssinc\reg.h ===
/* reg.h */

#ifdef __cplusplus
extern "C" {
#endif

/*********************************/
/* Definitions                   */
/*********************************/

/*********************************/
/* Structure Definitions         */
/*********************************/


/*********************************/
/* Function Definitions          */
/*********************************/

extern DWORD
OpenUserKeyGroup(
    Context_t *pContext,
    LPSTR szUserName,
    DWORD dwFlags);

extern DWORD
openKeyGroup(
    IN OUT Context_t *pContext);

extern DWORD
closeKeyGroup(
    IN Context_t *pContext);

// Delete the user group
extern DWORD
DeleteOldKeyGroup(
    IN Context_t *pContext,
    IN BOOL fMigration);

extern DWORD
DeleteKeyGroup(
IN Context_t *pContext);

extern DWORD
readKey(
    HKEY hLoc,
    char *pszName,
    BYTE **Data,
    DWORD *pcbLen);

extern DWORD
saveKey(
    HKEY hLoc,
    CONST char *pszName,
    void *Data,
    DWORD dwLen);

extern void
CheckKeySetType(
    Context_t *pContext);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\fips\selfmac.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : selfmac.c                                              //
//  DESCRIPTION   : Code to do self MACing                                 //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Nov 04 1999 jeffspel Added provider type checking                  //
//      Mar    2000 kschutz  Added stuff to make it work in kernel         //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <zwapi.h>
#include <windows.h>

#ifdef KERNEL_MODE
#include <ntosp.h>
#else
#include <imagehlp.h>
#endif // KERNEL_MODE

#include <des.h>
#include <modes.h>

// MAC in file
typedef struct _MAC_STRUCT
{
    ULONG   CoolMac[2];
    ULONG   dwMACStructOffset;
    UCHAR   rgbMac[DES_BLOCKLEN];
    ULONG   dwImageCheckSumOffset;
} MAC_STRUCT;

#define MAC_STRING      "COOL MAC            "

static LPSTR g_pszMAC = MAC_STRING;
static MAC_STRUCT *g_pMACStruct;

// The function MACs the given bytes.
VOID 
MACBytes(
    IN DESTable *pDESKeyTable,
    IN UCHAR *pbData,
    IN ULONG cbData,
    IN OUT UCHAR *pbTmp,
    IN OUT ULONG *pcbTmp,
    IN OUT UCHAR *pbMAC,
    IN BOOLEAN fFinal
    )
{
    ULONG   cb = cbData;
    ULONG   cbMACed = 0;

    while (cb)
    {
        if ((cb + *pcbTmp) < DES_BLOCKLEN)
        {
            memcpy(pbTmp + *pcbTmp, pbData + cbMACed, cb);
            *pcbTmp += cb;
            break;
        }
        else
        {
            memcpy(pbTmp + *pcbTmp, pbData + cbMACed, DES_BLOCKLEN - *pcbTmp);
            CBC(des, DES_BLOCKLEN, pbMAC, pbTmp, pDESKeyTable,
                ENCRYPT, pbMAC);
            cbMACed = cbMACed + (DES_BLOCKLEN - *pcbTmp);
            cb = cb - (DES_BLOCKLEN - *pcbTmp);
            *pcbTmp = 0;
        }
    }
}

#define CSP_TO_BE_MACED_CHUNK  512

// Given hFile, reads the specified number of bytes (cbToBeMACed) from the file
// and MACs these bytes.  The function does this in chunks.
NTSTATUS 
MACBytesOfFile(
    IN HANDLE hFile,
    IN ULONG cbToBeMACed,
    IN DESTable *pDESKeyTable,
    IN UCHAR *pbTmp,
    IN ULONG *pcbTmp,
    IN UCHAR *pbMAC,
    IN BOOLEAN fNoMacing,
    IN BOOLEAN fFinal
    )
{
    UCHAR           rgbChunk[CSP_TO_BE_MACED_CHUNK];
    ULONG           cbRemaining = cbToBeMACed, cbToRead, cbBytesRead;
    NTSTATUS        Status = STATUS_SUCCESS;
#ifdef KERNEL_MODE
    IO_STATUS_BLOCK IoStatusBlock;
#endif // END KERNEL/USER MODE CHECK

    //
    // loop over the file for the specified number of bytes
    // updating the hash as we go.
    //

    while (cbRemaining > 0)
    {
        if (cbRemaining < CSP_TO_BE_MACED_CHUNK)
            cbToRead = cbRemaining;
        else
            cbToRead = CSP_TO_BE_MACED_CHUNK;

#ifdef KERNEL_MODE
        Status = ZwReadFile(hFile,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            rgbChunk,
                            cbToRead,
                            NULL,
                            NULL);

        if (!NT_SUCCESS(Status))
        {
            goto Ret;
        }

        if (cbToRead != IoStatusBlock.Information)
        {
            Status = STATUS_UNSUCCESSFUL;
            goto Ret;
        }
        cbBytesRead = cbToRead;
#else // USER MODE
        if(!ReadFile(hFile,
                     rgbChunk,
                     cbToRead,
                     &cbBytesRead,
                     NULL))
        {
            Status = STATUS_UNSUCCESSFUL;
            goto Ret;
        }

        if (cbBytesRead != cbToRead)
        {
            Status = STATUS_UNSUCCESSFUL;
            goto Ret;
        }
#endif // END KERNEL/USER MODE CHECK

        if (!fNoMacing)
        {
            MACBytes(pDESKeyTable,
                     rgbChunk,
                     cbBytesRead,
                     pbTmp,
                     pcbTmp,
                     pbMAC,
                     fFinal);
        }

        cbRemaining -= cbToRead;
    }
Ret:
    return Status;
}

static UCHAR rgbMACDESKey[] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef};

NTSTATUS 
MACTheFile(
    LPCWSTR pszImage,
    ULONG cbImageCheckSumOffset,
    ULONG cbMACStructOffset,
    UCHAR *pbMAC
    )
{
    ULONG                       cbFileLen = 0,cbHighPart, cbBytesToMac;
    HANDLE                      hFile = INVALID_HANDLE_VALUE;
    DESTable                    DESKeyTable;
    BYTE                        rgbTmp[DES_BLOCKLEN];
    DWORD                       cbTmp = 0;
    MAC_STRUCT                  TmpMacStruct;
    NTSTATUS                    Status = STATUS_SUCCESS;

#ifdef KERNEL_MODE
    UNICODE_STRING              ObjectName;
    OBJECT_ATTRIBUTES           ObjectAttribs;
    IO_STATUS_BLOCK             IoStatusBlock;
    BOOLEAN                     fFileOpened = FALSE;
    FILE_STANDARD_INFORMATION   FileInformation;
#endif // END KERNEL/USER MODE CHECK

    RtlZeroMemory(pbMAC, DES_BLOCKLEN);
    RtlZeroMemory(rgbTmp, sizeof(rgbTmp));
    RtlZeroMemory(&TmpMacStruct, sizeof(TmpMacStruct));

#ifdef KERNEL_MODE
    //
    // get file length - kernel mode version
    //

    RtlZeroMemory(&ObjectAttribs, sizeof(ObjectAttribs));
    RtlInitUnicodeString( &ObjectName, pszImage );

    InitializeObjectAttributes(
        &ObjectAttribs,
        &ObjectName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = ZwCreateFile(
        &hFile,
        SYNCHRONIZE | FILE_READ_DATA,
        &ObjectAttribs,
        &IoStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ ,
        FILE_OPEN,
        FILE_SYNCHRONOUS_IO_NONALERT, 
        NULL,
        0
        );

    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }

    fFileOpened = TRUE;

    Status = ZwQueryInformationFile(
        hFile,
        &IoStatusBlock,
        &FileInformation,
        sizeof(FILE_STANDARD_INFORMATION),
        FileStandardInformation
        );

    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }

    cbFileLen = FileInformation.EndOfFile.LowPart;

#else // USER MODE

    // 
    // get file length - user mode version
    //

    if ((hFile = CreateFileW(
        pszImage,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL)) == INVALID_HANDLE_VALUE)
    {
        
        Status = STATUS_UNSUCCESSFUL;
        goto Ret;
    }

    cbFileLen = GetFileSize(hFile, &cbHighPart);

#endif // END KERNEL/USER MODE CHECK

    if (cbFileLen < sizeof(MAC_STRUCT))
    {
        Status = STATUS_UNSUCCESSFUL;
        goto Ret;
    }

    // init the key table
    deskey(&DESKeyTable, rgbMACDESKey);

    // MAC the file the following way:
    // - MAC from start to image check sum
    // - skip over the image check sum
    // - mac from after the image check sum to the mac struct
    // - skip over the mac struct
    // - mac the rest of the file

    // MAC from the start to the image check sum offset
    Status = MACBytesOfFile(
        hFile,
        cbImageCheckSumOffset,
        &DESKeyTable,
        rgbTmp,
        &cbTmp,
        pbMAC,
        FALSE,
        FALSE
        );

    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }

    // Skip over the image checksum
    Status = MACBytesOfFile(
        hFile,
        sizeof(DWORD),
        &DESKeyTable,
        rgbTmp,
        &cbTmp,
        pbMAC,
        TRUE,
        FALSE
        );

    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }

    // MAC from after the image checksum to the MAC struct offset
    cbBytesToMac = cbMACStructOffset - sizeof(DWORD) - cbImageCheckSumOffset;
    Status = MACBytesOfFile(
        hFile,
        cbBytesToMac,
        &DESKeyTable,
        rgbTmp,
        &cbTmp,
        pbMAC,
        FALSE,
        FALSE
        );

    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }

    // skip over the mac struct 
    Status = MACBytesOfFile(
        hFile,
        sizeof(MAC_STRUCT),
        &DESKeyTable,
        rgbTmp,
        &cbTmp,
        pbMAC,
        TRUE,
        FALSE
        );

    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }

    // MAC data after the MAC struct
    cbBytesToMac = cbFileLen - cbMACStructOffset - sizeof(MAC_STRUCT);
    Status = MACBytesOfFile(
        hFile,
        cbBytesToMac,
        &DESKeyTable,
        rgbTmp,
        &cbTmp,
        pbMAC,
        FALSE,
        TRUE
        );

    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }
Ret:

#ifdef KERNEL_MODE
    if (fFileOpened)
    {
        ZwClose(hFile);
    }
#else 
    if (INVALID_HANDLE_VALUE != hFile)
    {
        CloseHandle(hFile);
    }
#endif 

    return Status;
}

// **********************************************************************
// SelfMACCheck performs a DES MAC on the binary image of this DLL
// **********************************************************************
NTSTATUS 
SelfMACCheck(
    IN LPWSTR pszImage
    )
{
    UCHAR       rgbMac[DES_BLOCKLEN];
    NTSTATUS    Status = STATUS_SUCCESS;

    g_pMACStruct = (MAC_STRUCT*) g_pszMAC;

    Status = MACTheFile(
        pszImage,
        g_pMACStruct->dwImageCheckSumOffset,
        g_pMACStruct->dwMACStructOffset,
        rgbMac
        );

    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }

    if (RtlCompareMemory(
        rgbMac,
        g_pMACStruct->rgbMac,
        sizeof(rgbMac)) != sizeof(rgbMac))
    {
        Status = STATUS_IMAGE_CHECKSUM_MISMATCH;
        goto Ret;
    }

Ret:
    return Status;
}

#ifndef KERNEL_MODE

//
// Find the offset to the MAC structure
//
NTSTATUS 
FindTheMACStructOffset(
    LPWSTR pszImage,
    ULONG *pcbMACStructOffset
    )
{
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    ULONG       cbRemaining, cbBytesRead, cbHighPart, cbFileLen, cbCompare = 0;
    UCHAR       b;
    NTSTATUS    Status = STATUS_SUCCESS;

    *pcbMACStructOffset = 0;

    // Load the file
    if ((hFile = CreateFileW(
        pszImage,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL)) == INVALID_HANDLE_VALUE)
    {
        Status = STATUS_UNSUCCESSFUL;
        goto Ret;
    }

    cbFileLen = GetFileSize(hFile, &cbHighPart);
    cbRemaining = cbFileLen;

    // read file to the correct location
    while (cbRemaining > 0)
    {
        if(!ReadFile(hFile,
                     &b,
                     1,
                     &cbBytesRead,
                     NULL))
        {
            Status = STATUS_UNSUCCESSFUL;
            goto Ret;
        }

        if (cbBytesRead != 1)
        {
            Status = STATUS_UNSUCCESSFUL;
            goto Ret;
        }

        if (b == g_pszMAC[cbCompare])
        {
            cbCompare++;
            if (cbCompare == 8)
            {
                *pcbMACStructOffset =  (cbFileLen - (cbRemaining + 7)) ;
                break;
            }
        }
        else
        {
            cbCompare = 0;
        }

        cbRemaining--;
    }

    if (cbCompare != 8)
    {
        Status = STATUS_UNSUCCESSFUL;
        goto Ret;
    }
Ret:
    if (INVALID_HANDLE_VALUE != hFile)
    {
        CloseHandle(hFile);
    }

    return Status;
}

NTSTATUS 
GetImageCheckSumOffset(
    LPWSTR pszImage,
    ULONG *pcbImageCheckSumOffset
    )
{
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    HANDLE      hFileMap = INVALID_HANDLE_VALUE;
    ULONG       cbHighPart;
    ULONG       cbFileLen;
    PBYTE       pbFilePtr = NULL;
    NTSTATUS    Status = STATUS_UNSUCCESSFUL;
    PIMAGE_NT_HEADERS   pImageNTHdrs;
    DWORD       OldCheckSum;
    DWORD       NewCheckSum;

    if (INVALID_HANDLE_VALUE == (hFile = CreateFileW(
        pszImage,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL)))
    {
        goto Ret;
    }

    // make sure the file is larger than the indicated offset
    cbFileLen = GetFileSize(hFile, &cbHighPart);

    // map the file to memory
    if (NULL == (hFileMap = CreateFileMapping(
        hFile,
        NULL,
        PAGE_READONLY,
        0,
        0,
        NULL)))
    {
        goto Ret;
    }

    // get a memory view of the file
    if (NULL == (pbFilePtr = (PBYTE) MapViewOfFile(
        hFileMap,
        FILE_MAP_READ,
        0,
        0,
        0)))
    {
        goto Ret;
    }

    // get the pointer to the image checksum
    if (NULL == (pImageNTHdrs = CheckSumMappedFile(
        pbFilePtr, cbFileLen,
        &OldCheckSum, &NewCheckSum))) {

        goto Ret;
    }

    *pcbImageCheckSumOffset = 
        (ULONG) ((PBYTE) &pImageNTHdrs->OptionalHeader.CheckSum - pbFilePtr);

    Status = STATUS_SUCCESS;

Ret:
    if (pbFilePtr) {

        UnmapViewOfFile(pbFilePtr);
    }

    if (INVALID_HANDLE_VALUE != hFileMap) {

        CloseHandle(hFileMap);
    }

    if (INVALID_HANDLE_VALUE != hFile)
    {
        CloseHandle(hFile);
    }
    return Status;
}

// write the MAC information into the MAC struct in the file
NTSTATUS 
WriteMACToTheFile(
    LPWSTR pszImage,
    MAC_STRUCT *pMacStructOriginal,
    ULONG cbMACStructOffset,
    UCHAR *pbMac
    )
{
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    HANDLE      hFileMap = INVALID_HANDLE_VALUE;
    PBYTE       pbFilePtr = NULL;
    MAC_STRUCT  TmpMacStruct;
    ULONG       cbWritten = 0, cbRemaining = cbMACStructOffset;
    ULONG       cbToRead, cbBytesRead, cbHighPart,cbFileLen;
    UCHAR       rgbChunk[CSP_TO_BE_MACED_CHUNK];
    NTSTATUS    Status = STATUS_SUCCESS;
    DWORD       OldCheckSum, NewCheckSum;
    PIMAGE_NT_HEADERS   pImageNTHdrs;

    RtlCopyMemory(&TmpMacStruct, pMacStructOriginal, sizeof(TmpMacStruct));

    // Load the file
    if ((hFile = CreateFileW(
        pszImage,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL)) == INVALID_HANDLE_VALUE)
    {
        Status = STATUS_UNSUCCESSFUL;
        goto Ret;
    }

    // make sure the file is larger than the indicated offset
    cbFileLen = GetFileSize(hFile, &cbHighPart);

    if (cbFileLen < cbMACStructOffset)
    {
        Status = STATUS_UNSUCCESSFUL;
        goto Ret;
    }

    // map the file to memory
    if ((hFileMap = CreateFileMapping(
        hFile,
        NULL,
        PAGE_READWRITE,
        0,
        0,
        NULL)) == NULL)
    {
        Status = STATUS_UNSUCCESSFUL;
        goto Ret;
    }

    // get a memory view of the file
    if ((pbFilePtr = (PBYTE) MapViewOfFile(
        hFileMap,
        FILE_MAP_ALL_ACCESS,
        0,
        0,
        0)) == NULL)
    {
        Status = STATUS_UNSUCCESSFUL;
        goto Ret;
    }

    // get the pointer to the image checksum
    if (NULL == (pImageNTHdrs = CheckSumMappedFile(
        pbFilePtr, cbFileLen,
        &OldCheckSum, &NewCheckSum))) {

        Status = STATUS_UNSUCCESSFUL;
        goto Ret;
    }

    // set up and write the MAC struct
    TmpMacStruct.dwImageCheckSumOffset = 
        (ULONG) ((PBYTE) &pImageNTHdrs->OptionalHeader.CheckSum - pbFilePtr);
    TmpMacStruct.dwMACStructOffset = cbMACStructOffset;
    RtlCopyMemory(TmpMacStruct.rgbMac, pbMac, sizeof(TmpMacStruct.rgbMac));

    // now copy the new mac struct back to the view
    RtlCopyMemory(pbFilePtr + cbMACStructOffset, &TmpMacStruct, sizeof(TmpMacStruct));

    // compute a new checksum
    if (NULL == (pImageNTHdrs = CheckSumMappedFile(
        pbFilePtr, cbFileLen,
        &OldCheckSum, &NewCheckSum))) {

        Status = STATUS_UNSUCCESSFUL;
        goto Ret;
    }

    // and copy the new checksum back to the header
    CopyMemory(&pImageNTHdrs->OptionalHeader.CheckSum, &NewCheckSum, sizeof(DWORD));

Ret:
    if (pbFilePtr) {

        UnmapViewOfFile(pbFilePtr);
    }

    if (INVALID_HANDLE_VALUE != hFileMap) {

        CloseHandle(hFileMap);
    }
                                                     
    if (INVALID_HANDLE_VALUE != hFile)
    {
        CloseHandle(hFile);
    }

    return Status;
}


// **********************************************************************
// MACTheBinary performs a MAC on the binary and writes the value into
// the g_pMACStruct
// **********************************************************************
NTSTATUS 
MACTheBinary(
    IN LPWSTR pszImage
    )
{
    UCHAR       rgbMAC[DES_BLOCKLEN];
    ULONG       cbMACStructOffset = 0, cbImageCheckSumOffset = 0;
    NTSTATUS    Status = STATUS_SUCCESS;

    g_pMACStruct = (MAC_STRUCT*) g_pszMAC;

    // Find the offset to the MAC structure
    Status = FindTheMACStructOffset(
        pszImage,
        &cbMACStructOffset
        );

    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }

    // Get the offset of the image checksum
    Status = GetImageCheckSumOffset(
        pszImage,
        &cbImageCheckSumOffset
        );

    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }

    // MAC the file
    Status = MACTheFile(
        pszImage,
        cbImageCheckSumOffset,
        cbMACStructOffset,
        rgbMAC
        );

    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }

    // write the MAC information into the MAC struct in the file
    Status = WriteMACToTheFile(
        pszImage,
        g_pMACStruct,
        cbMACStructOffset,
        rgbMAC
        );

    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }

Ret:
    return Status;
}
#endif // NOT IN KERNEL_MODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\fips\driver\fipsapi.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : fipsdll.c                                              //
//  DESCRIPTION   :                                                        //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Nov 29 1999 jeffspel Created                                       //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include <ntddk.h>
#include <fipsapi.h>
#include <rsa_fast.h>
#include <rsa_math.h>
#include <randlib.h>

//
//     Fill in the DESTable struct with the decrypt and encrypt
//     key expansions.
//
//     Assumes that the second parameter points to DES_BLOCKLEN
//     bytes of key.
//
//

#pragma alloc_text(PAGER32C, FipsDesKey)
#pragma alloc_text(PAGER32C, FipsDes)
#pragma alloc_text(PAGER32C, Fips3Des3Key)
#pragma alloc_text(PAGER32C, Fips3Des)
#pragma alloc_text(PAGER32C, FipsSHAInit)
#pragma alloc_text(PAGER32C, FipsSHAUpdate)
#pragma alloc_text(PAGER32C, FipsSHAFinal)
#pragma alloc_text(PAGER32C, FipsCBC)
#pragma alloc_text(PAGER32C, FIPSGenRandom)
#pragma alloc_text(PAGER32C, FipsCBC)
#pragma alloc_text(PAGER32C, FIPSGenRandom)
#pragma alloc_text(PAGER32C, FipsBlockCBC)
#pragma alloc_text(PAGER32C, FipsHmacSHAInit)
#pragma alloc_text(PAGER32C, FipsHmacSHAUpdate)
#pragma alloc_text(PAGER32C, FipsHmacSHAFinal)
#pragma alloc_text(PAGER32C, HmacMD5Init)
#pragma alloc_text(PAGER32C, HmacMD5Update)
#pragma alloc_text(PAGER32C, HmacMD5Final)

void *
__stdcall
RSA32Alloc(
    unsigned long cb
    )
{
    return (void *)ExAllocatePool(PagedPool, cb);
}

void
__stdcall
RSA32Free(
    void *pv
    )
{
    ExFreePool( pv );
}

VOID FipsDesKey(DESTable *DesTable, UCHAR *pbKey)
{
    UCHAR rgbTmpKey[DES_KEYSIZE];

    RtlCopyMemory(rgbTmpKey, pbKey, DES_KEYSIZE);

    deskey(DesTable, rgbTmpKey);

    RtlZeroMemory(rgbTmpKey, DES_KEYSIZE);
}

//
//     Encrypt or decrypt with the key in DESTable
//
//

VOID FipsDes(UCHAR *pbOut, UCHAR *pbIn, void *pKey, int iOp)
{
    DESTable TmpDESTable;

    RtlCopyMemory(&TmpDESTable, pKey, sizeof(DESTable));

    des(pbOut, pbIn, &TmpDESTable, iOp);
    RtlZeroMemory(&TmpDESTable, sizeof(DESTable));
}

//
//   Fill in the DES3Table structs with the decrypt and encrypt
//   key expansions.
//
//   Assumes that the second parameter points to 3 * DES_BLOCKLEN
//   bytes of key.
//
//

VOID Fips3Des3Key(PDES3TABLE pDES3Table, UCHAR *pbKey)
{
    UCHAR rgbTmpKey[DES3_KEYSIZE];

    RtlCopyMemory(rgbTmpKey, pbKey, DES3_KEYSIZE);

    tripledes3key(pDES3Table, rgbTmpKey);
    RtlZeroMemory(rgbTmpKey, DES3_KEYSIZE);
}

//
//   Encrypt or decrypt with the key in pKey
//

VOID Fips3Des(UCHAR *pbIn, UCHAR *pbOut, void *pKey, int op)
{
    DES3TABLE Tmp3DESTable;

    RtlCopyMemory(&Tmp3DESTable, pKey, sizeof(DES3TABLE));

    tripledes(pbIn, pbOut, &Tmp3DESTable, op);
    RtlZeroMemory(&Tmp3DESTable, sizeof(DES3TABLE));
}

//
//   Initialize the SHA context.
//

VOID FipsSHAInit(A_SHA_CTX *pShaCtx)
{
    A_SHAInit(pShaCtx);
}

//
//   Hash data into the hash context.
//

VOID FipsSHAUpdate(A_SHA_CTX *pShaCtx, UCHAR *pb, unsigned int cb)
{
    A_SHAUpdate(pShaCtx, pb, cb);
}

//
//   Finish the SHA hash and copy the final hash value into the pbHash out param.
//

VOID FipsSHAFinal(A_SHA_CTX *pShaCtx, UCHAR *pbHash)
{
    A_SHAFinal(pShaCtx, pbHash);
}

typedef void (*FIPSCIPHER)(UCHAR*, UCHAR*, void*, int);

//
// FipsCBC (cipher block chaining) performs a XOR of the feedback register
// with the plain text before calling the block cipher
//
// NOTE - Currently this function assumes that the block length is
// DES_BLOCKLEN (8 bytes).
//
// Return: Failure if FALSE is returned, TRUE if it succeeded.
//

BOOL FipsCBC(
        ULONG  EncryptionAlg,
        PBYTE  pbOutput,
        PBYTE  pbInput,
        void   *pKeyTable,
        int    Operation,
        PBYTE  pbFeedback
        )
{
    UCHAR rgbTmpKeyTable[DES3_TABLESIZE]; // 3DES is the max table size
    ULONG cbKeyTable;
    FIPSCIPHER FipsCipher;
    BOOL fRet = TRUE;
    PBYTE pbOutputSave = NULL, pbInputSave = NULL, pbFeedbackSave = NULL;
    UINT64 OutputAlignedBuffer, InputAlignedBuffer, FeedbackAlignedBuffer;

#ifdef IA64
#define ALIGNMENT_BOUNDARY 7
#else
#define ALIGNMENT_BOUNDARY 3
#endif

    // align input buffer
    if ((ULONG_PTR) pbInput & ALIGNMENT_BOUNDARY) {

        InputAlignedBuffer = *(UINT64 UNALIGNED *) pbInput;
        pbInputSave = pbInput;

        if (pbOutput == pbInput) {

            pbOutput = (PBYTE) &InputAlignedBuffer;
        }

        pbInput = (PBYTE) &InputAlignedBuffer;
    } 

    // align output buffer
    if ((ULONG_PTR) pbOutput & ALIGNMENT_BOUNDARY) {

        OutputAlignedBuffer = *(UINT64 UNALIGNED *) pbOutput;
        pbOutputSave = pbOutput;
        pbOutput = (PBYTE) &OutputAlignedBuffer;
    } 

    if ((ULONG_PTR) pbFeedback & ALIGNMENT_BOUNDARY) {

        FeedbackAlignedBuffer = *(UINT64 UNALIGNED *) pbFeedback;
        pbFeedbackSave = pbFeedback;
        pbFeedback = (PBYTE) &FeedbackAlignedBuffer;
    } 
        
        

    //
    // determine the algorithm to use
    //
    switch(EncryptionAlg)
    {
        case FIPS_CBC_DES:
        {
            FipsCipher = des;
            cbKeyTable = DES_TABLESIZE;
            break;
        }
        case FIPS_CBC_3DES:
        {
            FipsCipher = tripledes;
            cbKeyTable = DES3_TABLESIZE;
            break;
        }
        default:
            fRet = FALSE;
            goto Ret;
    }

    RtlCopyMemory(rgbTmpKeyTable, (UCHAR*)pKeyTable, cbKeyTable);

    
    //
    // optimize very common codepath: 8 byte blocks
    //

    if (Operation == ENCRYPT)
    {
        ((PUINT64) pbOutput)[0] = 
            ((PUINT64) pbInput)[0] ^ ((PUINT64) pbFeedback)[0];

        FipsCipher(pbOutput, pbOutput, rgbTmpKeyTable, ENCRYPT);

        ((PUINT64) pbFeedback)[0] = ((PUINT64) pbOutput)[0];
    }
    else
    {

        //
        // two cases for output:
        // input and output are separate buffers
        // input and output are same buffers
        //

        if( pbOutput != pbInput )
        {

            FipsCipher(pbOutput, pbInput, rgbTmpKeyTable, DECRYPT);

            ((PUINT64) pbOutput)[0] ^= ((PUINT64) pbFeedback)[0];
            ((PUINT64) pbFeedback)[0] = ((PUINT64) pbInput)[0];

        } else {

            UINT64 inputTemp;

            inputTemp = ((PUINT64) pbInput)[0];

            FipsCipher(pbOutput, pbInput, rgbTmpKeyTable, DECRYPT);

            ((PUINT64) pbOutput)[0] ^= ((PUINT64) pbFeedback)[0];
            ((PUINT64) pbFeedback)[0] = inputTemp;
        }
    }   

    RtlZeroMemory(rgbTmpKeyTable, DES3_TABLESIZE);

    if (pbInputSave) {

        *(UINT64 UNALIGNED *) pbInputSave = InputAlignedBuffer;
    }

    if (pbOutputSave) {

        *(UINT64 UNALIGNED *) pbOutputSave = OutputAlignedBuffer;
    }

    if (pbFeedbackSave) {

        *(UINT64 UNALIGNED *) pbFeedbackSave = FeedbackAlignedBuffer;
    }   

Ret:
    return fRet;
}


//
// FipsBlockCBC (cipher block chaining) performs a XOR of the feedback register
// with the plain text before calling the block cipher
//
// NOTE - Currently this function assumes that the block length is
// DES_BLOCKLEN (8 bytes).
//
// Return: Failure if FALSE is returned, TRUE if it succeeded.
//

BOOL FipsBlockCBC(
        ULONG  EncryptionAlg,
        PBYTE  pbOutput,
        PBYTE  pbInput,
        ULONG  Length,
        void   *pKeyTable,
        int    Operation,
        PBYTE  pbFeedback
        )
{
    UCHAR rgbTmpKeyTable[DES3_TABLESIZE]; // 3DES is the max table size
    ULONG cbKeyTable;
    FIPSCIPHER FipsCipher;
    BOOL fRet = TRUE;


    ASSERT ((Length % DESX_BLOCKLEN == 0) && (Length > 0));
    if ((Length % DESX_BLOCKLEN != 0) || (Length == 0)) {
        return FALSE;
    }

    //
    // determine the algorithm to use
    //
    switch(EncryptionAlg)
    {
        case FIPS_CBC_DES:
        {
            FipsCipher = des;
            cbKeyTable = DES_TABLESIZE;
            break;
        }
        case FIPS_CBC_3DES:
        {
            FipsCipher = tripledes;
            cbKeyTable = DES3_TABLESIZE;
            break;
        }
        default:
            fRet = FALSE;
            goto Ret;
    }

    RtlCopyMemory(rgbTmpKeyTable, (UCHAR*)pKeyTable, cbKeyTable);

    //
    // optimize very common codepath: 8 byte blocks
    //

    if (Operation == ENCRYPT)
    {
        ULONGLONG tmpData; // Make sure the input buffer not touched more than once. Else EFS will break mysteriously.
        ULONGLONG chainBlock;

        chainBlock = *(ULONGLONG *)pbFeedback;
        while (Length > 0){

            tmpData = *(ULONGLONG *)pbInput;
            tmpData ^= chainBlock;

            FipsCipher(pbOutput, (PUCHAR)&tmpData, rgbTmpKeyTable, ENCRYPT);
            chainBlock = *(ULONGLONG *)pbOutput;

            Length -= DES_BLOCKLEN;
            pbInput += DES_BLOCKLEN;
            pbOutput += DES_BLOCKLEN;
    

        }
        ((PUINT64) pbFeedback)[0] = chainBlock;
    }
    else
    {

        PUCHAR  pBuffer;
        PUCHAR  pOutBuffer;
        ULONGLONG SaveFeedBack;

        //
        // two cases for output:
        // input and output are separate buffers
        // input and output are same buffers
        //

        pBuffer = pbInput + Length - DES_BLOCKLEN;
        pOutBuffer = pbOutput + Length - DES_BLOCKLEN;
        SaveFeedBack = *(ULONGLONG *)pBuffer;

        while (pBuffer > pbInput) {

            FipsCipher(pOutBuffer, pBuffer, rgbTmpKeyTable, DECRYPT);
            ((PUINT64) pOutBuffer)[0] ^= *(ULONGLONG *)( pBuffer - DES_BLOCKLEN );
    
            pBuffer -= DES_BLOCKLEN;
            pOutBuffer -= DES_BLOCKLEN;

        }

        FipsCipher(pOutBuffer, pBuffer, rgbTmpKeyTable, DECRYPT);
        ((PUINT64) pOutBuffer)[0] ^= *(ULONGLONG *)pbFeedback;
        ((PUINT64) pbFeedback)[0] = SaveFeedBack;

    }

    RtlZeroMemory(rgbTmpKeyTable, DES3_TABLESIZE);


Ret:
    return fRet;
}

//
// Function: FipsHmacSHAInit
//
// Description: Initialize a SHA-HMAC context 
//

VOID FipsHmacSHAInit(
    OUT A_SHA_CTX *pShaCtx,
    IN UCHAR *pKey,
    IN unsigned int cbKey)
{
    PUCHAR      key = pKey;
    ULONG       key_len = cbKey;
    UCHAR       k_ipad[MAX_LEN_PAD];    /* inner padding - key XORd with ipad */
    UCHAR       tk[A_SHA_DIGEST_LEN];
    ULONG       i;
    UCHAR       tmpKey[MAX_KEYLEN_SHA];

    //
    // if key is longer than 64 bytes reset it to key=A_SHA_(key) */
    //
    if (key_len > MAX_KEYLEN_SHA) {
        A_SHA_CTX      tctx;

        A_SHAInit(&tctx);
        A_SHAUpdate(&tctx, key, key_len);
        A_SHAFinal(&tctx, tk);

        key = tk;
        key_len = A_SHA_DIGEST_LEN;
    }

    // For FIPS compliance
    RtlCopyMemory(tmpKey, key, key_len);

    //
    // Zero out the scratch arrays
    //
    RtlZeroMemory(k_ipad, sizeof(k_ipad));

    RtlCopyMemory(k_ipad, tmpKey, key_len);

    //
    // XOR key with ipad and opad values
    //
    for (i = 0; i < MAX_KEYLEN_SHA/sizeof(unsigned __int64); i++) {
        ((unsigned __int64*)k_ipad)[i] ^= 0x3636363636363636;
    }

    //
    // Init the algorithm context
    //
    A_SHAInit(pShaCtx);

    //
    // Inner A_SHA_: start with inner pad
    //
    A_SHAUpdate(pShaCtx, k_ipad, MAX_KEYLEN_SHA);

    RtlZeroMemory(tmpKey, key_len);
}

//
// Function: FipsHmacSHAUpdate
//
// Description: Add more data to a SHA-HMAC context
//

VOID FipsHmacSHAUpdate(
    IN OUT A_SHA_CTX *pShaCtx,
    IN UCHAR *pb,
    IN unsigned int cb)
{
    A_SHAUpdate(pShaCtx, pb, cb);
}

//
// Function: FipsHmacSHAFinal
//
// Description: Return result of SHA-HMAC 
//

VOID FipsHmacSHAFinal(
    IN A_SHA_CTX *pShaCtx,
    IN UCHAR *pKey,
    IN unsigned int cbKey,
    OUT UCHAR *pHash)
{
    UCHAR       k_opad[MAX_LEN_PAD];    /* outer padding - key XORd with opad */
    UCHAR       tk[A_SHA_DIGEST_LEN];
    PUCHAR      key = pKey;
    ULONG       key_len = cbKey;
    ULONG       i;
    UCHAR       tmpKey[MAX_KEYLEN_SHA];

    A_SHAFinal(pShaCtx, pHash);

    //
    // if key is longer than 64 bytes reset it to key=A_SHA_(key) */
    //
    if (key_len > MAX_KEYLEN_SHA) {
        A_SHA_CTX      tctx;

        A_SHAInit(&tctx);
        A_SHAUpdate(&tctx, key, key_len);
        A_SHAFinal(&tctx, tk);

        key = tk;
        key_len = A_SHA_DIGEST_LEN;
    }

    // For FIPS Compliance
    RtlCopyMemory(tmpKey, key, key_len);

    RtlZeroMemory(k_opad, sizeof(k_opad));
    RtlCopyMemory(k_opad, tmpKey, key_len);

    //
    // XOR key with ipad and opad values
    //
    for (i = 0; i < MAX_KEYLEN_SHA/sizeof(unsigned __int64); i++) {
        ((unsigned __int64*)k_opad)[i] ^= 0x5c5c5c5c5c5c5c5c;
    }

    //
    // Now do outer A_SHA_
    //
    A_SHAInit(pShaCtx);

    //
    // start with outer pad
    //
    A_SHAUpdate(pShaCtx, k_opad, MAX_KEYLEN_SHA);

    //
    // then results of 1st hash
    //
    A_SHAUpdate(pShaCtx, pHash, A_SHA_DIGEST_LEN);

    A_SHAFinal(pShaCtx, pHash);

    RtlZeroMemory(tmpKey, key_len);
}

//
// Function: HmacMD5Init
//
// Description: Initialize a MD5-HMAC context 
//

VOID HmacMD5Init(
    OUT MD5_CTX *pMD5Ctx,
    IN UCHAR *pKey,
    IN unsigned int cbKey)
{
    PUCHAR      key = pKey;
    ULONG       key_len = cbKey;
    UCHAR       k_ipad[MAX_LEN_PAD];    /* inner padding - key XORd with ipad */
    UCHAR       tk[MD5DIGESTLEN];
    ULONG       i;

    //
    // if key is longer than 64 bytes reset it to key=MD5(key) */
    //
    if (key_len > MAX_KEYLEN_MD5) {
        MD5_CTX      tctx;

        MD5Init(&tctx);
        MD5Update(&tctx, key, key_len);
        MD5Final(&tctx);

        //
        // Copy out the partial hash
        //
        RtlCopyMemory (tk, tctx.digest, MD5DIGESTLEN);

        key = tk;
        key_len = MD5DIGESTLEN;
    }

    //
    // Zero out the scratch arrays
    //
    RtlZeroMemory(k_ipad, sizeof(k_ipad));

    RtlCopyMemory(k_ipad, key, key_len);

    //
    // XOR key with ipad and opad values
    //
    for (i = 0; i < MAX_KEYLEN_MD5/sizeof(unsigned __int64); i++) {
        ((unsigned __int64*)k_ipad)[i] ^= 0x3636363636363636;
    }

    //
    // Init the algorithm context
    //
    MD5Init(pMD5Ctx);

    //
    // Inner MD5: start with inner pad
    //
    MD5Update(pMD5Ctx, k_ipad, MAX_KEYLEN_MD5);
}

//
// Function: HmacMD5Update
//
// Description: Add more data to a MD5-HMAC context
//

VOID HmacMD5Update(
    IN OUT MD5_CTX *pMD5Ctx,
    IN UCHAR *pb,
    IN unsigned int cb)
{
    MD5Update(pMD5Ctx, pb, cb);
}

//
// Function: HmacMD5Final
//
// Description: Return result of MD5-HMAC 
//

VOID HmacMD5Final(
    IN MD5_CTX *pMD5Ctx,
    IN UCHAR *pKey,
    IN unsigned int cbKey,
    OUT UCHAR *pHash)
{
    UCHAR       k_opad[MAX_LEN_PAD];    /* outer padding - key XORd with opad */
    UCHAR       tk[MD5DIGESTLEN];
    PUCHAR      key = pKey;
    ULONG       key_len = cbKey;
    ULONG       i;

    MD5Final(pMD5Ctx);

    //
    // Copy out the partial hash
    //
    RtlCopyMemory (pHash, pMD5Ctx->digest, MD5DIGESTLEN);

    //
    // if key is longer than 64 bytes reset it to key=MD5(key) */
    //
    if (key_len > MAX_KEYLEN_MD5) {
        MD5_CTX      tctx;

        MD5Init(&tctx);
        MD5Update(&tctx, key, key_len);
        MD5Final(&tctx);

        //
        // Copy out the partial hash
        //
        RtlCopyMemory (tk, tctx.digest, MD5DIGESTLEN);

        key = tk;
        key_len = MD5DIGESTLEN;
    }

    RtlZeroMemory(k_opad, sizeof(k_opad));
    RtlCopyMemory(k_opad, key, key_len);

    //
    // XOR key with ipad and opad values
    //
    for (i = 0; i < MAX_KEYLEN_MD5/sizeof(unsigned __int64); i++) {
        ((unsigned __int64*)k_opad)[i] ^= 0x5c5c5c5c5c5c5c5c;
    }

    //
    // Now do outer MD5
    //
    MD5Init(pMD5Ctx);

    //
    // start with outer pad
    //
    MD5Update(pMD5Ctx, k_opad, MAX_KEYLEN_MD5);

    //
    // then results of 1st hash
    //
    MD5Update(pMD5Ctx, pHash, MD5DIGESTLEN);

    MD5Final(pMD5Ctx);

    RtlCopyMemory(pHash, pMD5Ctx->digest, MD5DIGESTLEN);
}

static UCHAR DSSPRIVATEKEYINIT[] =
{ 0x67, 0x45, 0x23, 0x01, 0xef, 0xcd, 0xab, 0x89,
  0x98, 0xba, 0xdc, 0xfe, 0x10, 0x32, 0x54, 0x76,
  0xc3, 0xd2, 0xe1, 0xf0};

static UCHAR MODULUS[] =
{ 0xf5, 0xc1, 0x56, 0xb1, 0xd5, 0x48, 0x42, 0x2e,
  0xbd, 0xa5, 0x44, 0x41, 0xc7, 0x1c, 0x24, 0x08,
  0x3f, 0x80, 0x3c, 0x90};


UCHAR g_rgbRNGState[A_SHA_DIGEST_LEN];

//
// Function : AddSeeds
//
// Description : This function adds the 160 bit seeds pointed to by pdwSeed1 and
//               pdwSeed2, it also adds 1 to this sum and mods the sum by
//               2^160.
//

VOID AddSeeds(
              IN ULONG *pdwSeed1,
              IN OUT ULONG *pdwSeed2
              )
{
    ULONG   dwTmp;
    ULONG   dwOverflow = 1;
    ULONG   i;

    for (i = 0; i < 5; i++)
    {
        dwTmp = dwOverflow + pdwSeed1[i];
        dwOverflow = (dwOverflow > dwTmp);
        pdwSeed2[i] = pdwSeed2[i] + dwTmp;
        dwOverflow = ((dwTmp > pdwSeed2[i]) || dwOverflow);
    }
}


void SHA_mod_q(
               IN UCHAR     *pbHash,
               IN UCHAR     *pbQ,
               OUT UCHAR     *pbNewHash
               )    
//
//      Given SHA(message), compute SHA(message) mod qdigit.
//      Output is in the interval [0, qdigit-1].
//      Although SHA(message) may exceed qdigit,
//      it cannot exceed 2*qdigit since the leftmost bit 
//      of qdigit is 1.
//

{
    UCHAR    rgbHash[A_SHA_DIGEST_LEN];

    if (-1 != Compare((DWORD*)rgbHash,  // hash is greater so subtract
                      (DWORD*)pbQ,
                      A_SHA_DIGEST_LEN / sizeof(ULONG)))  
    {
        Sub((DWORD*)pbNewHash,
            (DWORD*)rgbHash,
            (DWORD*)pbQ,
            A_SHA_DIGEST_LEN / sizeof(ULONG));
    }
    else
    {
        memcpy(pbNewHash, pbHash, A_SHA_DIGEST_LEN);
    }
} // SHA_mod_q 

//
// Function : RNG16BitStateCheck
//
// Description : This function compares each 160 bits of the buffer with
//               the next 160 bits and if they are the same the function
//               errors out.  The IN buffer is expected to be A_SHA_DIGEST_LEN
//               bytes long.  The function fails if the RNG is gets the same
//               input buffer of 160 bits twice in a row.
//

BOOL RNG16BitStateCheck(
                        IN OUT ULONG *pdwOut,
                        IN ULONG *pdwIn,
                        IN ULONG cbNeeded
                        )
{
    BOOL    fRet = FALSE;

    if (RtlEqualMemory(g_rgbRNGState, pdwIn, A_SHA_DIGEST_LEN))
    {
        RtlCopyMemory(g_rgbRNGState, (BYTE*)pdwIn, A_SHA_DIGEST_LEN);
        goto Ret;
    }

    RtlCopyMemory(g_rgbRNGState, (BYTE*)pdwIn, A_SHA_DIGEST_LEN);

    RtlCopyMemory((BYTE*)pdwOut, (BYTE*)pdwIn, cbNeeded);

    fRet = TRUE;
Ret:
    return fRet;
}

//
// Function : FIPSGenRandom
//
// Description : FIPS 186 RNG, the seed is generated by calling NewGenRandom.
//

BOOL FIPSGenRandom(
                   IN OUT UCHAR *pb,
                   IN ULONG cb
                   )
{
    ULONG           rgdwSeed[A_SHA_DIGEST_LEN/sizeof(ULONG)];    // 160 bits
    ULONG           rgdwNewSeed[A_SHA_DIGEST_LEN/sizeof(ULONG)]; // 160 bits
    A_SHA_CTX       SHACtxt;
    UCHAR           rgbBuf[A_SHA_DIGEST_LEN];
    ULONG           cbBuf;
    UCHAR           *pbTmp = pb;
    ULONG           cbTmp = cb;
    ULONG           i;
    BOOL            fRet = FALSE;

    while (cbTmp)
    {
        // get a 160 bit random seed
        if (! NewGenRandom(
            NULL, NULL, (BYTE*)rgdwNewSeed, sizeof(rgdwNewSeed)))
        {
            goto Ret;
        }

        for (i = 0; i < A_SHA_DIGEST_LEN/sizeof(ULONG); i++)
        {
            rgdwSeed[i] ^= rgdwNewSeed[i];
        }

        A_SHAInit (&SHACtxt);
        RtlCopyMemory(SHACtxt.state, DSSPRIVATEKEYINIT, A_SHA_DIGEST_LEN);

        // perform the one way function
        A_SHAUpdate(&SHACtxt, (BYTE*)rgdwSeed, sizeof(rgdwSeed));
        A_SHAFinal(&SHACtxt, rgbBuf);

        // continuous 16 bit state check
        if (A_SHA_DIGEST_LEN < cbTmp)
        {
            cbBuf = A_SHA_DIGEST_LEN;
        }
        else
        {
            cbBuf = cbTmp;
        }
        if (!RNG16BitStateCheck((ULONG*)pbTmp, (ULONG*)rgbBuf, cbBuf))
        {
            goto Ret;
        }
        pbTmp += cbBuf;
        cbTmp -= cbBuf;
        if (0 == cbTmp)
            break;

        // modular reduction with modulus Q
        SHA_mod_q(rgbBuf, MODULUS, (UCHAR*)rgdwNewSeed);

        // (1 + previous seed + new random) mod 2^160
        AddSeeds(rgdwNewSeed, rgdwSeed);
    }

    fRet = TRUE;
Ret:
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\fips\driver\algself.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : fipslib.c                                              //
//  DESCRIPTION   : FIPS 140 support code.                                 //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Oct 20 1999 jeffspel/ramas  Merge STT into default CSP             //
//                                                                         //
//  Copyright (C) 2000 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wincrypt.h>

#ifdef KERNEL_MODE
#if WINVER == 0x0500
#include <ntos.h>
#else
#include <ntosp.h>
#endif
#endif

#include <sha.h>
#include <des.h>
#include <tripldes.h>
#include <modes.h>

// known result of an SHA-1 hash on the above buffer
static UCHAR rgbKnownSHA1[] =
{
0xe8, 0x96, 0x82, 0x85, 0xeb, 0xae, 0x01, 0x14,
0x73, 0xf9, 0x08, 0x45, 0xc0, 0x6a, 0x6d, 0x3e,
0x69, 0x80, 0x6a, 0x0c
};

// IV for all block ciphers
UCHAR rgbIV[] = {0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF};

// known key, plaintext, and ciphertext for DES
UCHAR rgbDESKey[] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef};
UCHAR rgbDESKnownPlaintext[] = {0x4E, 0x6F, 0x77, 0x20, 0x69, 0x73, 0x20, 0x74};
UCHAR rgbDESKnownCiphertext[] = {0x3F, 0xA4, 0x0E, 0x8A, 0x98, 0x4D, 0x48, 0x15};
UCHAR rgbDESCBCCiphertext[] = {0xE5, 0xC7, 0xCD, 0xDE, 0x87, 0x2B, 0xF2, 0x7C};

// known key, plaintext, and ciphertext for 3 key 3DES
UCHAR rgb3DESKey[] =
{
0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23
};
UCHAR rgb3DESKnownPlaintext[] = {0x4E, 0x6F, 0x77, 0x20, 0x69, 0x73, 0x20, 0x74};
UCHAR rgb3DESKnownCiphertext[] = {0x31, 0x4F, 0x83, 0x27, 0xFA, 0x7A, 0x09, 0xA8};
UCHAR rgb3DESCBCCiphertext[] = {0xf3, 0xc0, 0xff, 0x02, 0x6c, 0x02, 0x30, 0x89};

// known key, plaintext, and ciphertext for 2 key 3DES
UCHAR rgb3DES112Key[] =
{
0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01
};
UCHAR rgb3DES112KnownPlaintext[] = {0x4E, 0x6F, 0x77, 0x20, 0x69, 0x73, 0x20, 0x74};
UCHAR rgb3DES112KnownCiphertext[] = {0xb7, 0x83, 0x57, 0x79, 0xee, 0x26, 0xac, 0xb7};
UCHAR rgb3DES112CBCCiphertext[] = {0x13, 0x4b, 0x98, 0xf8, 0xee, 0xb3, 0xf6, 0x07};

#define MAX_BLOCKLEN        8
#define MAXKEYSTRUCTSIZE    DES3_TABLESIZE // currently the max is a 3DES key structure

// Known answer test for SHA HMAC from Fips draft
UCHAR rgbHmacKey []         = {
    0x01, 0x02, 0x03, 0x04, 0x05,
    0x06, 0x07, 0x08, 0x09, 0x0a,
    0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
    0x10, 0x11, 0x12, 0x13, 0x14,
    0x15, 0x16, 0x17, 0x18, 0x19
};
UCHAR rgbHmacData [50];     // set bytes to 0xcd
UCHAR rgbHmac []            = {
    0x4c, 0x90, 0x07, 0xf4, 0x02,
    0x62, 0x50, 0xc6, 0xbc, 0x84,
    0x14, 0xf9, 0xbf, 0x50, 0xc8,
    0x6c, 0x2d, 0x72, 0x35, 0xda
};

extern VOID FipsHmacSHAInit(
    OUT A_SHA_CTX *pShaCtx,
    IN UCHAR *pKey,
    IN unsigned int cbKey
    );

extern VOID FipsHmacSHAUpdate(
    IN OUT A_SHA_CTX *pShaCtx,
    IN UCHAR *pb,
    IN unsigned int cb
    );

extern VOID FipsHmacSHAFinal(
    IN A_SHA_CTX *pShaCtx,
    IN UCHAR *pKey,
    IN unsigned int cbKey,
    OUT UCHAR *pHash
    ); 

//
// Function : TestSHA1
//
// Description : This function hashes the passed in message with the SHA1 hash
//               algorithm and returns the resulting hash value.
//
void TestSHA1(
              UCHAR *pbMsg,
              ULONG cbMsg,
              UCHAR *pbHash
              )
{
    A_SHA_CTX   HashContext;

    // Initialize SHA
    A_SHAInit(&HashContext);

    // Compute SHA 
    A_SHAUpdate(&HashContext, pbMsg, cbMsg);

    A_SHAFinal(&HashContext, pbHash);
}

//
// Function : TestEncDec
//
// Description : This function expands the passed in key buffer for the appropriate
//               algorithm, and then either encryption or decryption is performed.
//               A comparison is then made to see if the ciphertext or plaintext
//               matches the expected value.
//               The function only uses ECB mode for block ciphers and the plaintext
//               buffer must be the same length as the ciphertext buffer.  The length
//               of the plaintext must be either the block length of the cipher if it
//               is a block cipher or less than MAX_BLOCKLEN if a stream cipher is
//               being used.
//
NTSTATUS TestEncDec(
                IN ALG_ID Algid,
                IN UCHAR *pbKey,
                IN ULONG cbKey,
                IN UCHAR *pbPlaintext,
                IN ULONG cbPlaintext,
                IN UCHAR *pbCiphertext,
                IN UCHAR *pbIV,
                IN int iOperation
                )
{
    UCHAR    rgbExpandedKey[MAXKEYSTRUCTSIZE];
    UCHAR    rgbBuffIn[MAX_BLOCKLEN];
    UCHAR    rgbBuffOut[MAX_BLOCKLEN];
    ULONG    i;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    RtlZeroMemory(rgbExpandedKey, sizeof(rgbExpandedKey));
    RtlZeroMemory(rgbBuffIn, sizeof(rgbBuffIn));
    RtlZeroMemory(rgbBuffOut, sizeof(rgbBuffOut));

    // length of data to encrypt must be < MAX_BLOCKLEN 
    if (cbPlaintext > MAX_BLOCKLEN)
    {
        goto Ret;
    }

    // alloc for and expand the key
    switch(Algid)
    {
        case (CALG_DES):
        {
            desparityonkey(pbKey, cbKey);
            deskey((DESTable*)rgbExpandedKey, pbKey);
            break;
        }

        case (CALG_3DES):
        {
            desparityonkey(pbKey, cbKey);
            tripledes3key((PDES3TABLE)rgbExpandedKey, pbKey);
            break;
        }

        case (CALG_3DES_112):
        {
            desparityonkey(pbKey, cbKey);
            tripledes2key((PDES3TABLE)rgbExpandedKey, pbKey);
            break;
        }
    }

    // if encrypting and there is an IV then use it
    if (ENCRYPT == iOperation)
    {
        memcpy(rgbBuffIn, pbPlaintext, cbPlaintext);

        if (NULL != pbIV)
        {
            for(i = 0; i < cbPlaintext; i++)
            {
                rgbBuffIn[i] = rgbBuffIn[i] ^ pbIV[i];
            }
        }
    }

    // encrypt the plaintext
    switch(Algid)
    {
        case (CALG_DES):
        {
            if (ENCRYPT == iOperation)
            {
                des(rgbBuffOut, rgbBuffIn, rgbExpandedKey, ENCRYPT);
            }
            else
            {
                des(rgbBuffOut, pbCiphertext, rgbExpandedKey, DECRYPT);
            }
            break;
        }

        case (CALG_3DES):
        case (CALG_3DES_112):
        {
            if (ENCRYPT == iOperation)
            {
                tripledes(rgbBuffOut, rgbBuffIn, rgbExpandedKey, ENCRYPT);
            }
            else
            {
                tripledes(rgbBuffOut, pbCiphertext, rgbExpandedKey, DECRYPT);
            }
            break;
        }
    }

    // compare the encrypted plaintext with the passed in ciphertext
    if (ENCRYPT == iOperation)
    {
        if (memcmp(pbCiphertext, rgbBuffOut, cbPlaintext))
        {
            goto Ret;
        }
    }
    // compare the decrypted ciphertext with the passed in plaintext
    else
    {
        // if there is an IV then use it
        if (NULL != pbIV)
        {
            for(i = 0; i < cbPlaintext; i++)
            {
                rgbBuffOut[i] = rgbBuffOut[i] ^ pbIV[i];
            }
        }

        if (memcmp(pbPlaintext, rgbBuffOut, cbPlaintext))
        {
            goto Ret;
        }
    }

    Status = STATUS_SUCCESS;
Ret:
    return Status;
}

//
// Function : TestSymmetricAlgorithm
//
// Description : This function expands the passed in key buffer for the appropriate algorithm,
//               encrypts the plaintext buffer with the same algorithm and key, and the
//               compares the passed in expected ciphertext with the calculated ciphertext
//               to make sure they are the same.  The opposite is then done with decryption.
//               The function only uses ECB mode for block ciphers and the plaintext
//               buffer must be the same length as the ciphertext buffer.  The length
//               of the plaintext must be either the block length of the cipher if it
//               is a block cipher or less than MAX_BLOCKLEN if a stream cipher is
//               being used.
//
NTSTATUS TestSymmetricAlgorithm(
                            IN ALG_ID Algid,
                            IN UCHAR *pbKey,
                            IN ULONG cbKey,
                            IN UCHAR *pbPlaintext,
                            IN ULONG cbPlaintext,
                            IN UCHAR *pbCiphertext,
                            IN UCHAR *pbIV
                            )
{
    NTSTATUS  Status = STATUS_UNSUCCESSFUL;

    Status = TestEncDec(Algid, pbKey, cbKey, pbPlaintext, cbPlaintext,
                        pbCiphertext, pbIV, ENCRYPT);
    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }

    Status = TestEncDec(Algid, pbKey, cbKey, pbPlaintext, cbPlaintext,
                        pbCiphertext, pbIV, DECRYPT);
    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }
Ret:
    return Status;
}



// **********************************************************************
// AlgorithmCheck performs known answer tests using the algorithms
// supported by the provider.
// **********************************************************************
NTSTATUS AlgorithmCheck()
{
    UCHAR        rgbSHA1[A_SHA_DIGEST_LEN]; 
    NTSTATUS    Status = STATUS_UNSUCCESSFUL;
    A_SHA_CTX    ShaCtx;
    ULONG        ul;

    RtlZeroMemory(rgbSHA1, sizeof(rgbSHA1));

    // known answer test with SHA-1  (this function is found in hash.c)
    TestSHA1("HashThis", 8, rgbSHA1);
    if (!RtlEqualMemory(rgbSHA1, rgbKnownSHA1, sizeof(rgbSHA1)))
    {
        goto Ret;
    }

    // known answer test with DES - ECB
    Status = TestSymmetricAlgorithm(CALG_DES, rgbDESKey, sizeof(rgbDESKey),
                                rgbDESKnownPlaintext,
                                sizeof(rgbDESKnownPlaintext),
                                rgbDESKnownCiphertext,
                                NULL);
    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }
    // known answer test with DES - CBC
    Status = TestSymmetricAlgorithm(CALG_DES, rgbDESKey, sizeof(rgbDESKey),
                                    rgbDESKnownPlaintext,
                                    sizeof(rgbDESKnownPlaintext),
                                    rgbDESCBCCiphertext,
                                    rgbIV);
    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }

    // known answer test with 3DES - ECB
    Status = TestSymmetricAlgorithm(CALG_3DES, rgb3DESKey, sizeof(rgb3DESKey),
                                    rgb3DESKnownPlaintext,
                                    sizeof(rgb3DESKnownPlaintext),
                                    rgb3DESKnownCiphertext,
                                    NULL);
    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }

    // known answer test with 3DES - CBC
    Status = TestSymmetricAlgorithm(CALG_3DES, rgb3DESKey, sizeof(rgb3DESKey),
                                    rgb3DESKnownPlaintext,
                                    sizeof(rgb3DESKnownPlaintext),
                                    rgb3DESCBCCiphertext,
                                    rgbIV);
    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }

    // known answer test with 3DES 112 - ECB
    Status = TestSymmetricAlgorithm(CALG_3DES_112, rgb3DES112Key,
                                    sizeof(rgb3DES112Key),
                                    rgb3DES112KnownPlaintext,
                                    sizeof(rgb3DES112KnownPlaintext),
                                    rgb3DES112KnownCiphertext,
                                    NULL);
    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }

    Status = TestSymmetricAlgorithm(CALG_3DES_112, rgb3DES112Key,
                                    sizeof(rgb3DES112Key),
                                    rgb3DES112KnownPlaintext,
                                    sizeof(rgb3DES112KnownPlaintext),
                                    rgb3DES112CBCCiphertext,
                                    rgbIV);
    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }

    // Known answer test for SHA-HMAC
    RtlZeroMemory(rgbSHA1, sizeof(rgbSHA1));
    RtlZeroMemory(&ShaCtx, sizeof(ShaCtx));
    
    for (ul = 0; ul < sizeof(rgbHmacData); ul++)
        rgbHmacData[ul] = 0xcd;

    FipsHmacSHAInit(&ShaCtx, rgbHmacKey, sizeof(rgbHmacKey));
    FipsHmacSHAUpdate(&ShaCtx, rgbHmacData, sizeof(rgbHmacData));
    FipsHmacSHAFinal(&ShaCtx, rgbHmacKey, sizeof(rgbHmacKey), rgbSHA1);

    if (! RtlEqualMemory(rgbSHA1, rgbHmac, sizeof(rgbHmac)))
        goto Ret;

    Status = STATUS_SUCCESS;
Ret:
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\fips\driver\fipsapi.h ===
#ifndef __FIPSAPI_H__
#define __FIPSAPI_H__

#ifdef __cplusplus
extern "C" {
#endif

#include <windef.h>
#include <des.h>
#include <tripldes.h>
#include <sha.h>
#include <modes.h>
#include <md5.h>

#if DEBUG 
#define FipsDebug(LEVEL, STRING) \
        { \
          DbgPrint STRING; \
        }
#else
#define FipsDebug(LEVEL, STRING)
#endif

#define     FIPS_DEVICE_NAME            L"\\Device\\Fips"

#define FIPS_CTL_CODE(code)         CTL_CODE(FILE_DEVICE_FIPS, \
                                            (code), \
                                            METHOD_BUFFERED, \
                                            FILE_ANY_ACCESS)

#define IOCTL_FIPS_GET_FUNCTION_TABLE   FIPS_CTL_CODE( 1)

#define     FIPS_CBC_DES    0x1
#define     FIPS_CBC_3DES   0x2

//
// Defines for IPSEC HMAC use
//
#define     MAX_LEN_PAD     65
#define     MAX_KEYLEN_SHA  64
#define     MAX_KEYLEN_MD5  64   

//
//     Fill in the DESTable struct with the decrypt and encrypt
//     key expansions.
//
//     Assumes that the second parameter points to DES_BLOCKLEN
//     bytes of key.
//
//

VOID FipsDesKey(DESTable *DesTable, UCHAR *pbKey);

//
//     Encrypt or decrypt with the key in DESTable
//
//

VOID FipsDes(UCHAR *pbOut, UCHAR *pbIn, void *pKey, int iOp);

//
//   Fill in the DES3Table structs with the decrypt and encrypt
//   key expansions.
//
//   Assumes that the second parameter points to 2 * DES_BLOCKLEN
//   bytes of key.
//
//

VOID Fips3Des3Key(PDES3TABLE pDES3Table, UCHAR *pbKey);

//
//   Encrypt or decrypt with the key in pKey
//

VOID Fips3Des(UCHAR *pbIn, UCHAR *pbOut, void *pKey, int op);

//
//   Initialize the SHA context.
//

VOID FipsSHAInit(A_SHA_CTX *pShaCtx);

//
//   Hash data into the hash context.
//

VOID FipsSHAUpdate(A_SHA_CTX *pShaCtx, UCHAR *pb, unsigned int cb);

//
//   Finish the SHA hash and copy the final hash value into the pbHash out param.
//

VOID FipsSHAFinal(A_SHA_CTX *pShaCtx, UCHAR *pbHash);

//
// FipsCBC (cipher block chaining) performs a XOR of the feedback register
// with the plain text before calling the block cipher
//
// NOTE - Currently this function assumes that the block length is
// DES_BLOCKLEN (8 bytes).
//
// Return: Failure if FALSE is returned, TRUE if it succeeded.
//

BOOL FipsCBC(
    ULONG  EncryptionAlg,
    BYTE   *pbOutput,
    BYTE   *pbInput,
    void   *pKeyTable,
    int    Operation,
    BYTE   *pbFeedback
    );

//
// FipsBlockCBC (cipher block chaining) performs a XOR of the feedback register
// with the plain text before calling the block cipher
//
// NOTE - The Length must be multiple of DES_BLOCKLEN (8)
// All the input buffer must be aligned on LONGLONG for performane reason.
//
// Return: Failure if FALSE is returned, TRUE if it succeeded.
//

BOOL FipsBlockCBC(
    ULONG  EncryptionAlg,
    BYTE   *pbOutput,
    BYTE   *pbInput,
    ULONG  Length,
    void   *pKeyTable,
    int    Operation,
    BYTE   *pbFeedback
    );

//
// Function : FIPSGenRandom
//
// Description : FIPS 186 RNG, the seed is generated by calling NewGenRandom.
//

BOOL FIPSGenRandom(
    IN OUT UCHAR *pb,
    IN ULONG cb
    );

//
// Function: FipsHmacSHAInit
//
// Description: Initialize a SHA-HMAC context 
//

VOID FipsHmacSHAInit(
    OUT A_SHA_CTX *pShaCtx,
    IN UCHAR *pKey,
    IN unsigned int cbKey
    );

//
// Function: FipsHmacSHAUpdate
//
// Description: Add more data to a SHA-HMAC context
//

VOID FipsHmacSHAUpdate(
    IN OUT A_SHA_CTX *pShaCtx,
    IN UCHAR *pb,
    IN unsigned int cb
    );

//
// Function: FipsHmacSHAFinal
//
// Description: Return result of SHA-HMAC 
//

VOID FipsHmacSHAFinal(
    IN A_SHA_CTX *pShaCtx,
    IN UCHAR *pKey,
    IN unsigned int cbKey,
    OUT UCHAR *pHash
    );

//
// Function: HmacMD5Init
//
// Description: Initialize a MD5-HMAC context 
//

VOID HmacMD5Init(
    OUT MD5_CTX *pMD5Ctx,
    IN UCHAR *pKey,
    IN unsigned int cbKey
    );

//
// Function: HmacMD5Update
//
// Description: Add more data to a MD5-HMAC context
//

VOID HmacMD5Update(
    IN OUT MD5_CTX *pMD5Ctx,
    IN UCHAR *pb,
    IN unsigned int cb
    );

//
// Function: HmacMD5Final
//
// Description: Return result of MD5-HMAC 
//

VOID HmacMD5Final(
    IN MD5_CTX *pMD5Ctx,
    IN UCHAR *pKey,
    IN unsigned int cbKey,
    OUT UCHAR *pHash
    );

// 
// Current FIPS function table
// Includes HMAC entry points
//
typedef struct _FIPS_FUNCTION_TABLE {

    VOID (*FipsDesKey)(DESTable *DesTable, UCHAR *pbKey);
    VOID (*FipsDes)(UCHAR *pbOut, UCHAR *pbIn, void *pKey, int iOp);
    VOID (*Fips3Des3Key)(PDES3TABLE pDES3Table, UCHAR *pbKey);
    VOID (*Fips3Des)(UCHAR *pbIn, UCHAR *pbOut, void *pKey, int op);
    VOID (*FipsSHAInit)(A_SHA_CTX *pShaCtx);
    VOID (*FipsSHAUpdate)(A_SHA_CTX *pShaCtx, UCHAR *pb, unsigned int cb);
    VOID (*FipsSHAFinal)(A_SHA_CTX *pShaCtx, UCHAR *pbHash);
    BOOL (*FipsCBC)(
        ULONG  EncryptionAlg,
        BYTE   *pbOutput,
        BYTE   *pbInput,
        void   *pKeyTable,
        int    Operation,
        BYTE   *pbFeedback
        );
    BOOL (*FIPSGenRandom)(
        IN OUT UCHAR *pb,
        IN ULONG cb
        );
    BOOL (*FipsBlockCBC)(
        ULONG  EncryptionAlg,
        BYTE   *pbOutput,
        BYTE   *pbInput,
        ULONG  Length,
        void   *pKeyTable,
        int    Operation,
        BYTE   *pbFeedback
        );
    VOID (*FipsHmacSHAInit)(
        OUT A_SHA_CTX *pShaCtx,
        IN UCHAR *pKey,
        IN unsigned int cbKey
        );   
    VOID (*FipsHmacSHAUpdate)(
        IN OUT A_SHA_CTX *pShaCtx,
        IN UCHAR *pb,
        IN unsigned int cb
        );
    VOID (*FipsHmacSHAFinal)(
        IN A_SHA_CTX *pShaCtx,
        IN UCHAR *pKey,
        IN unsigned int cbKey,
        OUT UCHAR *pHash
        );
    VOID (*HmacMD5Init)(
        OUT MD5_CTX *pMD5Ctx,
        IN UCHAR *pKey,
        IN unsigned int cbKey
        );
    VOID (*HmacMD5Update)(
        IN OUT MD5_CTX *pMD5Ctx,
        IN UCHAR *pb,
        IN unsigned int cb
        );
    VOID (*HmacMD5Final)(
        IN MD5_CTX *pMD5Ctx,
        IN UCHAR *pKey,
        IN unsigned int cbKey,
        OUT UCHAR *pHash
        );

} FIPS_FUNCTION_TABLE, *PFIPS_FUNCTION_TABLE;

//
// Old FIPS function table - please don't use
//
typedef struct _FIPS_FUNCTION_TABLE_1 {

    VOID (*FipsDesKey)(DESTable *DesTable, UCHAR *pbKey);
    VOID (*FipsDes)(UCHAR *pbOut, UCHAR *pbIn, void *pKey, int iOp);
    VOID (*Fips3Des3Key)(PDES3TABLE pDES3Table, UCHAR *pbKey);
    VOID (*Fips3Des)(UCHAR *pbIn, UCHAR *pbOut, void *pKey, int op);
    VOID (*FipsSHAInit)(A_SHA_CTX *pShaCtx);
    VOID (*FipsSHAUpdate)(A_SHA_CTX *pShaCtx, UCHAR *pb, unsigned int cb);
    VOID (*FipsSHAFinal)(A_SHA_CTX *pShaCtx, UCHAR *pbHash);
    BOOL (*FipsCBC)(
        ULONG  EncryptionAlg,
        BYTE   *pbOutput,
        BYTE   *pbInput,
        void   *pKeyTable,
        int    Operation,
        BYTE   *pbFeedback
        );
    BOOL (*FIPSGenRandom)(
        IN OUT UCHAR *pb,
        IN ULONG cb
        );
    BOOL (*FipsBlockCBC)(
        ULONG  EncryptionAlg,
        BYTE   *pbOutput,
        BYTE   *pbInput,
        ULONG  Length,
        void   *pKeyTable,
        int    Operation,
        BYTE   *pbFeedback
        );

} FIPS_FUNCTION_TABLE_1, *PFIPS_FUNCTION_TABLE_1;


#ifdef __cplusplus
}
#endif

#endif // __FIPSAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\fips\macutil\macutil.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : client.cxx                                             //
//  DESCRIPTION   : Crypto API interface                                   //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Mar  8 1996 larrys  New                                            //
//                  dbarlow                                                //
//                                                                         //
//  Copyright (C) 1996 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <stddef.h>
#include <stdio.h>

NTSTATUS MACTheBinary(
                      IN LPWSTR pszImage
                      );

void ShowHelp()
{
    printf("Internal FIPS Module MACing Utility\n");
    printf("macutil <filename>\n");
}

void __cdecl main( int argc, char *argv[])
{
    LPWSTR      szInFile = NULL;
    ULONG       cch = 0;
    ULONG       dwErr;
    NTSTATUS    Status;
    DWORD       dwRet = 1;

    //
    // Parse the command line.
    //

    if (argc != 2)
    {
        ShowHelp();
        goto Ret;
    }

    //
    // convert to UNICODE file name
    //
    if (0 == (cch = MultiByteToWideChar(CP_ACP,
                                        MB_COMPOSITE,
                                        &argv[1][0],
                                        -1,
                                        NULL,
                                        cch)))
    {
        dwErr = GetLastError();
        goto Ret;
    }

    if (NULL == (szInFile = LocalAlloc(LMEM_ZEROINIT, (cch + 1) * sizeof(WCHAR))))
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    if (0 == (cch = MultiByteToWideChar(CP_ACP,
                                        MB_COMPOSITE,
                                        &argv[1][0],
                                        -1,
                                        szInFile,
                                        cch)))
    {
         dwErr = GetLastError();
         goto Ret;
    }

    // MAC the binary
    Status = MACTheBinary(szInFile);

    if (!NT_SUCCESS(Status))
    {
        ShowHelp();
        goto Ret;
    }

    //
    // Clean up and return.
    //

    dwRet = 0;
    printf("SUCCESS\n");

Ret:
    exit(dwRet);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\fips\driver\fipscryp.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1999
//
// File:        fipscryp.c
//
// Contents:    Base level stuff for the FIPS mode crypto device driver
//
//
// History:     04 JAN 00,  Jeffspel    Stolen from KSECDD
//                 FEB 00,  kschutz
//
//------------------------------------------------------------------------

#include <ntddk.h>
#include <fipsapi.h>
#include <fipslog.h>
#include <randlib.h>

#pragma hdrstop

NTSTATUS SelfMACCheck(IN LPWSTR pszImage);
NTSTATUS AlgorithmCheck(void);


/*
typedef struct _DEVICE_EXTENSION {

    ULONG   OpenCount;
    PVOID   CodeHandle;
    PVOID   DataHandle;
    
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;
*/

VOID
FipsLogError(
    IN  PVOID Object,
    IN  NTSTATUS ErrorCode,
    IN  PUNICODE_STRING Insertion,
    IN  ULONG DumpData
    )

/*++

Routine Description:

    This routine allocates an error log entry, copies the supplied data
    to it, and requests that it be written to the error log file.

Arguments:

    DeviceObject -  Supplies a pointer to the device object associated
                    with the device that had the error, early in
                    initialization, one may not yet exist.

    Insertion -     An insertion string that can be used to log
                    additional data. Note that the message file
                    needs %2 for this insertion, since %1
                    is the name of the driver

    ErrorCode -     Supplies the IO status for this particular error.

    DumpData -      One word to dump

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;

    errorLogEntry = IoAllocateErrorLogEntry(
        Object,
        (UCHAR) (
            sizeof(IO_ERROR_LOG_PACKET) + 
            (Insertion ? Insertion->Length + sizeof(WCHAR) : 0)
            )
        );

    ASSERT(errorLogEntry != NULL);

    if (errorLogEntry == NULL) {

        return;
    }

    errorLogEntry->ErrorCode = ErrorCode;
    errorLogEntry->SequenceNumber = 0;
    errorLogEntry->MajorFunctionCode = 0;
    errorLogEntry->RetryCount = 0;
    errorLogEntry->UniqueErrorValue = 0;
    errorLogEntry->FinalStatus = STATUS_SUCCESS;
    errorLogEntry->DumpDataSize = (DumpData ? sizeof(ULONG) : 0);
    errorLogEntry->DumpData[0] = DumpData;

    if (Insertion) {

        errorLogEntry->StringOffset = 
            sizeof(IO_ERROR_LOG_PACKET);

        errorLogEntry->NumberOfStrings = 1;

        RtlCopyMemory(
            ((PCHAR)(errorLogEntry) + errorLogEntry->StringOffset),
            Insertion->Buffer,
            Insertion->Length
            );
    } 

    IoWriteErrorLogEntry(errorLogEntry);
}

NTSTATUS
FipsCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    //PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    /*
    if (irpStack->MajorFunction == IRP_MJ_CREATE) {

        if (deviceExtension->OpenCount++ == 0) {

            extern DWORD Spbox[8][64];

            deviceExtension->CodeHandle = MmLockPagableCodeSection(A_SHAInit);
            MmLockPagableSectionByHandle(deviceExtension->CodeHandle);

            deviceExtension->DataHandle = MmLockPagableDataSection(Spbox);
            MmLockPagableSectionByHandle(deviceExtension->DataHandle);

        }
        
    } else {

        if (--deviceExtension->OpenCount == 0) {

            MmUnlockPagableImageSection(deviceExtension->CodeHandle);
            MmUnlockPagableImageSection(deviceExtension->DataHandle);

        }
    }
    */

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}

NTSTATUS
FipsDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION  ioStackLocation = IoGetCurrentIrpStackLocation(Irp);
    ULONG ioControlCode = ioStackLocation->Parameters.DeviceIoControl.IoControlCode;
    NTSTATUS status = STATUS_NOT_SUPPORTED;
    
    Irp->IoStatus.Information = 0;

    switch (ioControlCode) {
     
        FIPS_FUNCTION_TABLE FipsFuncs;
        FIPS_FUNCTION_TABLE_1 OldFipsFuncsV1;

        case IOCTL_FIPS_GET_FUNCTION_TABLE:

            if (ioStackLocation->Parameters.DeviceIoControl.OutputBufferLength >=
                sizeof(FipsFuncs)) {

                FipsFuncs.FipsDesKey = FipsDesKey;
                FipsFuncs.FipsDes = FipsDes;
                FipsFuncs.Fips3Des3Key = Fips3Des3Key;
                FipsFuncs.Fips3Des = Fips3Des;
                FipsFuncs.FipsSHAInit = FipsSHAInit;
                FipsFuncs.FipsSHAUpdate = FipsSHAUpdate;
                FipsFuncs.FipsSHAFinal = FipsSHAFinal;
                FipsFuncs.FipsCBC = FipsCBC;
                FipsFuncs.FIPSGenRandom = FIPSGenRandom;
                FipsFuncs.FipsBlockCBC = FipsBlockCBC;
                FipsFuncs.FipsHmacSHAInit = FipsHmacSHAInit;
                FipsFuncs.FipsHmacSHAUpdate = FipsHmacSHAUpdate;
                FipsFuncs.FipsHmacSHAFinal = FipsHmacSHAFinal;
                FipsFuncs.HmacMD5Init = HmacMD5Init;
                FipsFuncs.HmacMD5Update = HmacMD5Update;
                FipsFuncs.HmacMD5Final = HmacMD5Final;

                *((PFIPS_FUNCTION_TABLE) Irp->AssociatedIrp.SystemBuffer) = 
                    FipsFuncs;

                Irp->IoStatus.Information = sizeof(FipsFuncs);

                status = STATUS_SUCCESS;
            
            } else if (ioStackLocation->Parameters.DeviceIoControl.OutputBufferLength >=
                        sizeof(OldFipsFuncsV1)) {

                OldFipsFuncsV1.FipsDesKey = FipsDesKey;
                OldFipsFuncsV1.FipsDes = FipsDes;
                OldFipsFuncsV1.Fips3Des3Key = Fips3Des3Key;
                OldFipsFuncsV1.Fips3Des = Fips3Des;
                OldFipsFuncsV1.FipsSHAInit = FipsSHAInit;
                OldFipsFuncsV1.FipsSHAUpdate = FipsSHAUpdate;
                OldFipsFuncsV1.FipsSHAFinal = FipsSHAFinal;
                OldFipsFuncsV1.FipsCBC = FipsCBC;
                OldFipsFuncsV1.FIPSGenRandom = FIPSGenRandom;
                OldFipsFuncsV1.FipsBlockCBC = FipsBlockCBC;
                
                *((PFIPS_FUNCTION_TABLE_1) Irp->AssociatedIrp.SystemBuffer) = 
                    OldFipsFuncsV1;

                Irp->IoStatus.Information = sizeof(OldFipsFuncsV1);

                status = STATUS_SUCCESS;
                
            } else {

                status = STATUS_BUFFER_TOO_SMALL;            
            }

            break;
    }

    Irp->IoStatus.Status = status;

    IoCompleteRequest(
        Irp, 
        IO_NO_INCREMENT
        );

    return status;
}

VOID
FipsUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
    PDEVICE_OBJECT deviceObject = DriverObject->DeviceObject;

    ShutdownRNG(NULL);

    // Delete the device from the system 
    IoDeleteDevice(deviceObject);

    FipsDebug(
        DEBUG_TRACE,
        ("Fips driver unloaded\n")
        );
}

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the synchronous NULL device driver.
    This routine creates the device object for the NullS device and performs
    all other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    RTL_QUERY_REGISTRY_TABLE paramTable[2];
    UNICODE_STRING fileName, deviceName;
    PDEVICE_OBJECT deviceObject = NULL;
    NTSTATUS status;
    BOOL rngInitialized = FALSE;

    __try {

        //
        // Create the device object.
        //
        RtlInitUnicodeString( 
            &deviceName,
            FIPS_DEVICE_NAME 
            );

        status = IoCreateDevice( 
            DriverObject,
            0 /*sizeof(DEVICE_EXTENSION)*/,
            &deviceName,
            FILE_DEVICE_FIPS,
            0,
            FALSE,
            &deviceObject 
            );

        if (!NT_SUCCESS( status )) {

            __leave;
        }

        deviceObject->Flags |= DO_BUFFERED_IO;

        // initialize the device extension
        /*
        RtlZeroMemory(
            deviceObject->DeviceExtension,
            sizeof(PDEVICE_EXTENSION)
            );
        */

        // append the name of our driver to the system root path
        RtlInitUnicodeString(
            &fileName,
            L"\\SystemRoot\\System32\\Drivers\\fips.sys"
            );

        status = SelfMACCheck(fileName.Buffer); 

        if (!NT_SUCCESS(status)) {

            FipsLogError(
                DriverObject,
                FIPS_MAC_INCORRECT,
                NULL,
                status
                );  

            __leave;
        }

        InitializeRNG(NULL);
        rngInitialized = TRUE;

        status = AlgorithmCheck();

        if (!NT_SUCCESS(status)) {

            FipsLogError(
                DriverObject,
                FIPS_SELF_TEST_FAILURE,
                NULL,
                status
                );  

            __leave;
        }

        //
        // Initialize the driver object with this device driver's entry points.
        //
        DriverObject->DriverUnload = FipsUnload;
        DriverObject->MajorFunction[IRP_MJ_CREATE] = FipsCreateClose;
        DriverObject->MajorFunction[IRP_MJ_CLOSE]  = FipsCreateClose;
        DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = FipsDeviceControl ;
    }
    __finally {

        if (status != STATUS_SUCCESS) {

            if (rngInitialized) {

                ShutdownRNG(NULL);
            }

            if (deviceObject) {

                IoDeleteDevice(deviceObject);
            }

        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\inc\csprc.h ===
// 
// Used by resource.rc
//
#define IDS_RSA_SIG_DESCR       1
#define IDS_RSA_EXCH_DESCR      2
#define IDS_IMPORT_SIMPLE       3
#define IDS_SIGNING_E           4
#define IDS_CREATE_RSA_SIG      5
#define IDS_CREATE_RSA_EXCH     6
#define IDS_DSS_SIG_DESCR       7
#define IDS_DSS_EXCH_DESCR      8
#define IDS_CREATE_DSS_SIG      9
#define IDS_CREATE_DH_EXCH      10
#define IDS_IMPORT_E_PUB        11
#define IDS_MIGR                12
#define IDS_DELETE_SIG          13
#define IDS_DELETE_KEYX         14
#define IDS_DELETE_SIG_MIGR     15
#define IDS_DELETE_KEYX_MIGR    16
#define IDS_SIGNING_S           17
#define IDS_EXPORT_E_PRIV       18
#define IDS_EXPORT_S_PRIV       19
#define IDS_IMPORT_E_PRIV       20
#define IDS_IMPORT_S_PRIV       21

#define         IDS_CSP_RSA_SIG_DESCR               7501
#define         IDS_CSP_RSA_EXCH_DESCR              7502
#define         IDS_CSP_IMPORT_SIMPLE               7503
#define         IDS_CSP_SIGNING_E                   7504
#define         IDS_CSP_CREATE_RSA_SIG              7505
#define         IDS_CSP_CREATE_RSA_EXCH             7506
#define         IDS_CSP_DSS_SIG_DESCR               7507
#define         IDS_CSP_DSS_EXCH_DESCR              7508
#define         IDS_CSP_CREATE_DSS_SIG              7509
#define         IDS_CSP_CREATE_DH_EXCH              7510
#define         IDS_CSP_IMPORT_E_PUB                7511
#define         IDS_CSP_MIGR                        7512
#define         IDS_CSP_DELETE_SIG                  7513
#define         IDS_CSP_DELETE_KEYX                 7514
#define         IDS_CSP_DELETE_SIG_MIGR             7515
#define         IDS_CSP_DELETE_KEYX_MIGR            7516
#define         IDS_CSP_SIGNING_S                   7517
#define         IDS_CSP_EXPORT_E_PRIV               7518
#define         IDS_CSP_EXPORT_S_PRIV               7519
#define         IDS_CSP_IMPORT_E_PRIV               7520
#define         IDS_CSP_IMPORT_S_PRIV               7521
#define         IDS_CSP_AUDIT_CAPI_KEY              7522
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\inc\contman.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : contman.h                                              //
//  DESCRIPTION   : include file                                           //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Mar 16 1998 jeffspel Created                                       //
//                                                                         //
//  Copyright (C) 1998 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef __CONTMAN_H__
#define __CONTMAN_H__

#ifdef __cplusplus
extern "C" {
#endif

extern LPVOID ContAlloc(ULONG cbLen);
extern LPVOID ContRealloc(LPVOID pvMem, ULONG cbLen);
extern void ContFree(LPVOID pvMem);

// Display Strings
typedef struct _CSP_STRINGS_ {
    // RSA
    LPWSTR  pwszSignWExch;
    LPWSTR  pwszCreateRSASig;
    LPWSTR  pwszCreateRSAExch;
    LPWSTR  pwszRSASigDescr;
    LPWSTR  pwszRSAExchDescr;
    LPWSTR  pwszImportSimple;

    // DSS-DH
    LPWSTR  pwszCreateDSS;
    LPWSTR  pwszCreateDH;
    LPWSTR  pwszImportDHPub;
    LPWSTR  pwszDSSSigDescr;
    LPWSTR  pwszDHExchDescr;

    // BOTH
    LPWSTR  pwszSigning;
    LPWSTR  pwszMigrKeys;
    LPWSTR  pwszImportPrivSig;
    LPWSTR  pwszImportPrivExch;
    LPWSTR  pwszExportPrivSig;
    LPWSTR  pwszExportPrivExch;
    LPWSTR  pwszDeleteSig;
    LPWSTR  pwszDeleteMigrSig;
    LPWSTR  pwszDeleteExch;
    LPWSTR  pwszDeleteMigrExch;
    LPWSTR  pwszAuditCapiKey;
} CSP_STRINGS, *PCSP_STRINGS;

#define SZLOCALMACHINECRYPTO "Software\\Microsoft\\Cryptography"
#define SZCRYPTOMACHINEGUID "MachineGuid"

#define KEY_CONTAINER_FILE_FORMAT_VER   2

#define STUFF_TO_GO_INTO_MIX    "Hj1diQ6kpUx7VC4m"

typedef struct _KEY_EXPORTABILITY_LENS_ {
    DWORD                   cbSigExportability;
    DWORD                   cbExchExportability;
} KEY_EXPORTABILITY_LENS, *PKEY_EXPORTABILITY_LENS;

typedef struct _KEY_CONTAINER_LENS_ {
    DWORD                   dwUIOnKey;
    DWORD                   cbName;
    DWORD                   cbSigPub;
    DWORD                   cbSigEncPriv;
    DWORD                   cbExchPub;
    DWORD                   cbExchEncPriv;
    DWORD                   cbRandom;                       // length of Random number seed
} KEY_CONTAINER_LENS, *PKEY_CONTAINER_LENS;

typedef struct _KEY_CONTAINER_INFO_ {
    DWORD                   dwVersion;
    KEY_CONTAINER_LENS      ContLens;
    BOOL                    fCryptSilent;
    BYTE                    *pbSigPub;
    BYTE                    *pbSigEncPriv;
    BOOL                    fSigExportable;
    BYTE                    *pbExchPub;
    BYTE                    *pbExchEncPriv;
    BOOL                    fExchExportable;
    BYTE                    *pbRandom;
    LPSTR                   pszUserName;
    WCHAR                   rgwszFileName[80];
    HANDLE                  hFind;                  // for enuming containers
    DWORD                   dwiRegEntry;            // for enuming containers
    DWORD                   cMaxRegEntry;           // for enuming containers
    DWORD                   cbRegEntry;             // for enuming containers
    CHAR                    *pchEnumRegEntries;     // for enuming containers
    BOOL                    fCryptFirst;            // for enuming containers
    BOOL                    fNoMoreFiles;           // for enuming containers
    DWORD                   cbOldMachKeyEntry;      // for enuming containers
    DWORD                   dwiOldMachKeyEntry;     // for enuming containers
    DWORD                   cMaxOldMachKeyEntry;    // for enuming containers
    CHAR                    *pchEnumOldMachKeyEntries; // for enuming containers
    BOOL                    fForceHighKeyProtection;
    
    // Context items required for caching private keys
    BOOL                    fCachePrivateKeys;
    DWORD                   cMaxKeyLifetime; // in milliseconds
    DWORD                   dwSigKeyTimestamp;
    DWORD                   dwKeyXKeyTimestamp;
} KEY_CONTAINER_INFO, *PKEY_CONTAINER_INFO;

// define flag for leaving old keys in the registry if they are in the .Default
// hive but are user keys
#define LEAVE_OLD_KEYS          1
// define flag indicating that the thread cannot get the SACL info from the
// old registry key when migrating keys
#define PRIVILEDGE_FOR_SACL     2

#define MY_RTL_ENCRYPT_MEMORY_SIZE \
    (2 * RTL_ENCRYPT_MEMORY_SIZE)
    
DWORD GetKeySizeForEncryptMemory(
    IN DWORD cbKey);

DWORD MyRtlEncryptMemory(
    IN PVOID pvMem,
    IN DWORD cbMem);

DWORD MyRtlDecryptMemory(
    IN PVOID pvMem,
    IN DWORD cbMem);

//
//    Just tries to use DPAPI to make sure it works before creating a key
//    container.
//
DWORD TryDPAPI();

DWORD
MyCryptProtectData(
    IN              DATA_BLOB*      pDataIn,
    IN              LPCWSTR         szDataDescr,
    IN OPTIONAL     DATA_BLOB*      pOptionalEntropy,
    IN              PVOID           pvReserved,
    IN OPTIONAL     CRYPTPROTECT_PROMPTSTRUCT*  pPromptStruct,
    IN              DWORD           dwFlags,
    OUT             DATA_BLOB*      pDataOut            // out encr blob
    );

DWORD
MyCryptUnprotectData(
    IN              DATA_BLOB*      pDataIn,             // in encr blob
    OUT OPTIONAL    LPWSTR*         ppszDataDescr,       // out
    IN OPTIONAL     DATA_BLOB*      pOptionalEntropy,
    IN              PVOID           pvReserved,
    IN OPTIONAL     CRYPTPROTECT_PROMPTSTRUCT*  pPromptStruct,
    IN              DWORD           dwFlags,
    OUT             DATA_BLOB*      pDataOut,
    OUT             LPDWORD         pdwReprotectFlags);

void FreeEnumOldMachKeyEntries(
                               PKEY_CONTAINER_INFO pInfo
                               );

void FreeEnumRegEntries(
                       PKEY_CONTAINER_INFO pInfo
                       );

void FreeContainerInfo(
                       PKEY_CONTAINER_INFO pInfo
                       );

BOOL WINAPI FIsWinNT(void);

DWORD
IsLocalSystem(
              BOOL *pfIsLocalSystem
              );

DWORD
GetUserTextualSidA(
    LPSTR lpBuffer,
    LPDWORD nSize
    );

DWORD
GetUserTextualSidW(
    LPWSTR lpBuffer,
    LPDWORD nSize
    );

DWORD SetMachineGUID();

DWORD SetContainerUserName(
                           IN LPSTR pszUserName,
                           IN PKEY_CONTAINER_INFO pContInfo
                           );

DWORD ReadContainerInfo(
                        IN DWORD dwProvType,
                        IN LPSTR pszContainerName,
                        IN BOOL fMachineKeyset,
                        IN DWORD dwFlags,
                        OUT PKEY_CONTAINER_INFO pContInfo
                        );

DWORD WriteContainerInfo(
                         IN DWORD dwProvType,
                         IN LPWSTR pwszFileName,
                         IN BOOL fMachineKeyset,
                         IN PKEY_CONTAINER_INFO pContInfo
                         );

DWORD DeleteContainerInfo(
                          IN DWORD dwProvType,
                          IN LPSTR pszFileName,
                          IN BOOL fMachineKeyset
                          );

DWORD GetUniqueContainerName(
                             IN KEY_CONTAINER_INFO *pContInfo,
                             OUT BYTE *pbData,
                             OUT DWORD *pcbData
                             );

DWORD GetNextContainer(
    IN      DWORD   dwProvType,
    IN      BOOL    fMachineKeyset,
    IN      DWORD   dwFlags,
    OUT     LPSTR   pszNextContainer,
    IN OUT  DWORD   *pcbNextContainer,
    IN OUT  HANDLE  *phFind
    );

DWORD SetSecurityOnContainer(
                             IN LPCWSTR wszFileName,
                             IN DWORD dwProvType,
                             IN DWORD fMachineKeyset,
                             IN SECURITY_INFORMATION SecurityInformation,
                             IN PSECURITY_DESCRIPTOR pSecurityDescriptor
                             );

//+ ===========================================================================
//
//      The function adjusts the token priviledges so that SACL information
//      may be set on a key container.  If the token priviledges may be set
//      indicated by the pUser->dwOldKeyFlags having the PRIVILEDGE_FOR_SACL value set.
//      value set then the token privilege is adjusted before the security
//      descriptor is set on the container.  This is needed for the key
//      migration case when keys are being migrated from the registry to files.
//- ============================================================================
DWORD SetSecurityOnContainerWithTokenPriviledges(
                                          IN DWORD dwOldKeyFlags,
                                          IN LPCWSTR wszFileName,
                                          IN DWORD dwProvType,
                                          IN DWORD fMachineKeyset,
                                          IN SECURITY_INFORMATION SecurityInformation,
                                          IN PSECURITY_DESCRIPTOR pSecurityDescriptor
                                          );

DWORD GetSecurityOnContainer(
                             IN LPCWSTR wszFileName,
                             IN DWORD dwProvType,
                             IN DWORD fMachineKeyset,
                             IN SECURITY_INFORMATION RequestedInformation,
                             OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
                             IN OUT DWORD *pcbSecurityDescriptor
                             );

// Converts to UNICODE and uses RegOpenKeyExW
DWORD MyRegOpenKeyEx(IN HKEY hRegKey,
                     IN LPSTR pszKeyName,
                     IN DWORD dwReserved,
                     IN REGSAM SAMDesired,
                     OUT HKEY *phNewRegKey);

// Converts to UNICODE and uses RegDeleteKeyW
DWORD MyRegDeleteKey(IN HKEY hRegKey,
                     IN LPSTR pszKeyName);

DWORD AllocAndSetLocationBuff(
                              BOOL fMachineKeySet,
                              DWORD dwProvType,
                              CONST char *pszUserID,
                              HKEY *phTopRegKey,
                              TCHAR **ppszLocBuff,
                              BOOL fUserKeys,
                              BOOL *pfLeaveOldKeys,
                              LPDWORD pcbBuff);

//
// Enumerates the old machine keys in the file system
// keys were in this location in Beta 2 and Beta 3 of NT5/Win2K
//
DWORD EnumOldMachineKeys(
                         IN DWORD dwProvType,
                         IN OUT PKEY_CONTAINER_INFO pContInfo
                         );

DWORD GetNextEnumedOldMachKeys(
                              IN PKEY_CONTAINER_INFO pContInfo,
                              IN BOOL fMachineKeyset,
                              OUT BYTE *pbData,
                              OUT DWORD *pcbData
                              );

//
// Enumerates the keys in the registry into a list of entries
//
DWORD EnumRegKeys(
                  IN OUT PKEY_CONTAINER_INFO pContInfo,
                  IN BOOL fMachineKeySet,
                  IN DWORD dwProvType,
                  OUT BYTE *pbData,
                  IN OUT DWORD *pcbData
                  );

DWORD GetNextEnumedRegKeys(
                           IN PKEY_CONTAINER_INFO pContInfo,
                           OUT BYTE *pbData,
                           OUT DWORD *pcbData
                           );

//+ ===========================================================================
//
//      The function adjusts the token priviledges so that SACL information
//      may be gotten and then opens the indicated registry key.  If the token
//      priviledges may be set then the reg key is opened anyway but the
//      flags field will not have the PRIVILEDGE_FOR_SACL value set.
//
//- ============================================================================
DWORD OpenRegKeyWithTokenPriviledges(
                                     IN HKEY hTopRegKey,
                                     IN LPSTR pszRegKey,
                                     OUT HKEY *phRegKey,
                                     OUT DWORD *pdwFlags);

DWORD LoadStrings();

void UnloadStrings();

typedef struct _EXPO_OFFLOAD_STRUCT {
        DWORD       dwVersion;
        HMODULE     hInst;
        PFN_OFFLOAD_MOD_EXPO     pExpoFunc;
} EXPO_OFFLOAD_STRUCT, *PEXPO_OFFLOAD_STRUCT;

//
// Function : FreeOffloadInfo
//
// Description : The function takes a pointer to Offload Information as the
//               first parameter of the call.  The function frees the
//               information.
//
void FreeOffloadInfo(
                     IN OUT PEXPO_OFFLOAD_STRUCT pOffloadInfo
                     );

//
// Function : InitExpOffloadInfo
//
// Description : The function takes a pointer to Offload Information as the
//               first parameter of the call.  The function checks in the
//               registry to see if an offload module has been registered.
//               If a module is registered then it loads the module
//               and gets the OffloadModExpo function pointer.
//
BOOL InitExpOffloadInfo(
                        IN OUT PEXPO_OFFLOAD_STRUCT *ppExpoOffloadInfo
                        );

//
// Function : ModularExpOffload
//
// Description : This function does the offloading of modular exponentiation.
//               The function takes a pointer to Offload Information as the
//               first parameter of the call.  If this pointer is not NULL
//               then the function will use this module and call the function.
//               The exponentiation with MOD function will implement
//               Y^X MOD P  where Y is the buffer pbBase, X is the buffer
//               pbExpo and P is the buffer pbModulus.  The length of the
//               buffer pbExpo is cbExpo and the length of pbBase and
//               pbModulus is cbModulus.  The resulting value is output
//               in the pbResult buffer and has length cbModulus.
//               The pReserved and dwFlags parameters are currently ignored.
//               If any of these functions fail then the function fails and
//               returns FALSE.  If successful then the function returns
//               TRUE.  If the function fails then most likely the caller
//               should fall back to using hard linked modular exponentiation.
//
BOOL ModularExpOffload(
                       IN PEXPO_OFFLOAD_STRUCT pOffloadInfo,
                       IN BYTE *pbBase,
                       IN BYTE *pbExpo,
                       IN DWORD cbExpo,
                       IN BYTE *pbModulus,
                       IN DWORD cbModulus,
                       OUT BYTE *pbResult,
                       IN VOID *pReserved,
                       IN DWORD dwFlags
                       );

#ifdef USE_HW_RNG
#ifdef _M_IX86
// stuff for INTEL RNG usage

//
// Function : GetRNGDriverHandle
//
// Description : Gets the handle to the INTEL RNG driver if available, then
//               checks if the chipset supports the hardware RNG.  If so
//               the previous driver handle is closed if necessary and the
//               new handle is assigned to the passed in parameter.
//
extern DWORD
GetRNGDriverHandle(
    IN OUT HANDLE *phDriver);

//
// Function : CheckIfRNGAvailable
//
// Description : Checks if the INTEL RNG driver is available, if so then
//               checks if the chipset supports the hardware RNG.
//
extern DWORD
CheckIfRNGAvailable(
    void);

//
// Function : HWRNGGenRandom
//
// Description : Uses the passed in handle to the INTEL RNG driver
//               to fill the buffer with random bits.  Actually uses
//               XOR to fill the buffer so that the passed in buffer
//               is also mixed in.
//
DWORD
HWRNGGenRandom(
               IN HANDLE hRNGDriver,
               IN OUT BYTE *pbBuffer,
               IN DWORD dwLen);

#ifdef TEST_HW_RNG
//
// Function : SetupHWRNGIfRegistered
//
// Description : Checks if there is a registry setting indicating the HW RNG
//               is to be used.  If the registry entry is there then it attempts
//               to get the HW RNG driver handle.
//
extern DWORD
SetupHWRNGIfRegistered(
    OUT HANDLE *phRNGDriver);
#endif // TEST_HW_RNG

#endif // _M_IX86
#endif // USE_HW_RNG

//
// Function for managing Force High Key Protection
//

BOOL IsForceHighProtectionEnabled(
    IN PKEY_CONTAINER_INFO  pContInfo);

DWORD InitializeForceHighProtection(
    IN OUT PKEY_CONTAINER_INFO  pContInfo);

//
// Functions for managing cached private keys.
//

BOOL IsPrivateKeyCachingEnabled(
    IN PKEY_CONTAINER_INFO  pContInfo);

BOOL IsCachedKeyValid(
    IN PKEY_CONTAINER_INFO  pContInfo,
    IN BOOL                 fSigKey);

DWORD SetCachedKeyTimestamp(
    IN PKEY_CONTAINER_INFO  pContInfo,
    IN BOOL                 fSigKey);

DWORD InitializeKeyCacheInfo(
    IN OUT PKEY_CONTAINER_INFO pContInfo);

#ifdef __cplusplus
}
#endif

#endif // __CONTMAN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\inc\manage.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : manage.h                                               //
//  DESCRIPTION   :                                                        //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Apr 19 1995 larrys  Cleanup                                        //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef __MANAGE_H__
#define __MANAGE_H__

#ifdef __cplusplus
extern "C" {
#endif

DWORD NTLValidate(HCRYPTPROV hUID, HCRYPTKEY hKey, BYTE bTypeValue,
                  LPVOID *ppvRet);
DWORD NTLMakeItem(HCRYPTKEY *phKey, BYTE bTypeValue, void *NewData);
void *NTLCheckList(HNTAG hThisThing, BYTE bTypeValue);
void  NTLDelete(HNTAG hItem);

#define _nt_malloc(cb)  ContAlloc(cb)
#define _nt_free(pv, _cbSizeToZero_)    ContFree(pv)

#ifdef __cplusplus
}
#endif

#endif // __MANAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\inc\mac.h ===
// Message Authentication Code structures

#ifndef __CRYPTOAPI__MAC__H__
#define __CRYPTOAPI__MAC__H__

typedef struct _MACstate {
    DWORD dwBufLen;
    BYTE  Feedback[MAX_BLOCKLEN];
    BYTE  Buffer[MAX_BLOCKLEN];
    BOOL  FinishFlag;
} MACstate;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\inc\ntagimp1.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ntagimp1.h                                             //
//  DESCRIPTION   :                                                        //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Apr 19 1995 larrys  Cleanup                                        //
//      May  5 1995 larrys  Changed struct Hash_List_Defn                  //
//      May 10 1995 larrys  added private api calls                        //
//      Aug 15 1995 larrys  Moved CSP_USE_DES to sources file              //
//      Sep 12 1995 Jeffspel/ramas  Merged STT onto CSP                    //
//      Sep 25 1995 larrys  Changed MAXHASHLEN                             //
//      Oct 27 1995 rajeshk Added RandSeed stuff to UserList               //
//      Feb 29 1996 rajeshk Added HashFlags                                                //
//      Sep  4 1996 mattt       Changes to facilitate building STRONG algs         //
//      Sep 16 1996 mattt   Added Domestic naming                          //
//      Apr 29 1997 jeffspel Protstor support and EnumAlgsEx support       //
//      May 23 1997 jeffspel Added provider type checking                  //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef __NTAGIMP1_H__
#define __NTAGIMP1_H__

#include <windows.h>
#include <nt_rsa.h>
#include <sha2.h>
#include <aes.h>

#ifdef __cplusplus
extern "C" {
#endif

// define which algorithms to include
#define CSP_USE_SHA
#define CSP_USE_RC4
#define CSP_USE_MD2
#define CSP_USE_MD4
#define CSP_USE_MD5
#define CSP_USE_SHA1
#define CSP_USE_MAC
#define CSP_USE_RC2
#define CSP_USE_SSL3SHAMD5
#define CSP_USE_SSL3
#define CSP_USE_DES
#define CSP_USE_3DES
#define CSP_USE_AES
#define CSP_USE_NEW_SHA

// handle definition types
#define USER_HANDLE                             0x0
#define HASH_HANDLE                             0x1
#define KEY_HANDLE                              0x2
#define SIGPUBKEY_HANDLE                        0x3
#define EXCHPUBKEY_HANDLE                       0x4

#ifdef _WIN64
#define     HANDLE_MASK     0xE35A172CD96214A0
#define     ALIGNMENT_BOUNDARY 7
#else
#define     HANDLE_MASK     0xE35A172C
#define     ALIGNMENT_BOUNDARY 3
#endif // _WIN64

typedef ULONG_PTR HNTAG;

typedef struct _htbl {
        void                    *pItem;
        DWORD                   dwType;
} HTABLE;

#define HNTAG_TO_HTYPE(hntag)   (BYTE)(((HTABLE*)((HNTAG)hntag ^ HANDLE_MASK))->dwType)

// Stuff for weird SSL 3.0 signature format
#define SSL3_SHAMD5_LEN   (A_SHA_DIGEST_LEN + MD5DIGESTLEN)

#ifndef CSP_USE_NEW_SHA
#define MAX_HASH_SIZE           SSL3_SHAMD5_LEN    // Longest expected hash.
#else
#define MAX_HASH_SIZE           SHA512_DIGEST_LEN
#endif

#define PCT1_MASTER_KEYSIZE     16
#define SSL2_MASTER_KEYSIZE      5
#define SSL3_MASTER_KEYSIZE     48

#define RSA_KEYSIZE_INC          8

#define DEFAULT_WEAK_SALT_LENGTH   11   // salt length in bytes
#define DEFAULT_STRONG_SALT_LENGTH  0   // salt length in bytes

#define MAX_KEY_SIZE            48      // largest key size (SSL3 masterkey)

#define SSL2_MAX_MASTER_KEYSIZE 24

#define RC2_MAX_WEAK_EFFECTIVE_KEYLEN     56
#define RC2_MAX_STRONG_EFFECTIVE_KEYLEN 1024

// effective key length defines for RC2
#define RC2_DEFAULT_EFFECTIVE_KEYLEN    40
#define RC2_SCHANNEL_DEFAULT_EFFECTIVE_KEYLEN    128
#define RC2_MIN_EFFECTIVE_KEYLEN        1

// this is for the domestic provider which is backward compatible
// with the international provider
#define RC2_MAX_STRONG_EFFECTIVE_KEYLEN    1024
#define RC2_MAX_WEAK_EFFECTIVE_KEYLEN        56

// defines for SGC
#define SGC_RSA_MAX_EXCH_MODLEN     2048    // 16384 bit
#define SGC_RSA_DEF_EXCH_MODLEN     128

#define     STORAGE_RC4_KEYLEN      5   // keys always stored under 40-bit RC4 key
#define     STORAGE_RC4_TOTALLEN    16  // 0-value salt fills rest

// types of key storage
#define REG_KEYS                    0
#define PROTECTED_STORAGE_KEYS      1
#define PROTECTION_API_KEYS         2

// structure to hold protected storage info
typedef struct _PStore_Info
{
    HINSTANCE   hInst;
    void        *pProv;
    GUID        SigType;
    GUID        SigSubtype;
    GUID        ExchType;
    GUID        ExchSubtype;
    LPWSTR      szPrompt;
    DWORD       cbPrompt;
} PSTORE_INFO;

// definition of a user list
typedef struct _UserList
{
    DWORD                           Rights;
    DWORD                           dwProvType;
    DWORD                           hPrivuid;
    HCRYPTPROV                      hUID;
    BOOL                            fIsLocalSystem;
    DWORD                           dwEnumalgs;
    DWORD                           dwEnumalgsEx;
    KEY_CONTAINER_INFO              ContInfo;
    DWORD                           ExchPrivLen;
    BYTE                            *pExchPrivKey;
    DWORD                           SigPrivLen;
    BYTE                            *pSigPrivKey;
    HKEY                            hKeys;              // AT NTag only
    size_t                          UserLen;
    BYTE                            *pCachePW;
    BYTE                            *pUser;
    HANDLE                          hWnd;
    DWORD                           dwKeyStorageType;
    PSTORE_INFO                     *pPStore;
    LPWSTR                          pwszPrompt;
    DWORD                           dwOldKeyFlags;
#ifdef USE_SGC
    BOOL                            dwSGCFlags;
    BYTE                            *pbSGCKeyMod;
    DWORD                           cbSGCKeyMod;
    DWORD                           dwSGCKeyExpo;
#endif
    HANDLE                          hRNGDriver;
    CRITICAL_SECTION                CritSec;
    EXPO_OFFLOAD_STRUCT             *pOffloadInfo; // info for offloading modular expo
    DWORD                           dwCspTypeId;
    LPSTR                           szProviderName;
} NTAGUserList, *PNTAGUserList;


// UserList Rights flags (uses CRYPT_MACHINE_KEYSET and CRYPT_VERIFYCONTEXT)
#define CRYPT_DISABLE_CRYPT             0x1
#define CRYPT_DES_HASHKEY_BACKWARDS     0x4

#ifdef CSP_USE_AES
#define CRYPT_AES128_ROUNDS             10
#define CRYPT_AES192_ROUNDS             12
#define CRYPT_AES256_ROUNDS             14

#define CRYPT_AES128_BLKLEN             16
#define CRYPT_AES192_BLKLEN             16
#define CRYPT_AES256_BLKLEN             16
#endif

#define CRYPT_BLKLEN    8               // Bytes in a crypt block
#define MAX_SALT_LEN    24

#ifdef CSP_USE_AES
#define MAX_BLOCKLEN                    CRYPT_AES256_BLKLEN
#else
#define MAX_BLOCKLEN                    8
#endif

// definition of a key list
typedef struct _KeyList
{
    HCRYPTPROV      hUID;                   // must be first
    ALG_ID          Algid;
    DWORD           Rights;

    DWORD           cbKeyLen;
    BYTE            *pKeyValue;             // Actual Key
    BOOL            fSharedKeyAlloc;

    DWORD           cbDataLen;
    BYTE            *pData;                 // Inflated Key or Multi-phase
    BOOL            fSharedDataAlloc;
    
    BYTE            IV[MAX_BLOCKLEN];       // Initialization vector
    BYTE            FeedBack[MAX_BLOCKLEN]; // Feedback register
    DWORD           InProgress;             // Flag to indicate encryption
    DWORD           cbSaltLen;              // Salt length
    BYTE            rgbSalt[MAX_SALT_LEN];  // Salt value
    DWORD           Padding;                // Padding values
    DWORD           Mode;                   // Mode of cipher
    DWORD           ModeBits;               // Number of bits to feedback
    DWORD           Permissions;            // Key permissions
    DWORD           EffectiveKeyLen;        // used by RC2
    BYTE            *pbParams;              // may be used in OAEP
    DWORD           cbParams;               // length of pbParams
    DWORD           dwBlockLen;             // encryption block length; 
                                            // valid for block ciphers only
    DWORD           cbKeyListAlloc;
    BOOL            fInflatedKey;
#ifdef STT
    DWORD           cbInfo;
    BYTE            rgbInfo[MAXCCNLEN];
#endif
} NTAGKeyList, *PNTAGKeyList;


// Packed version of NTAGKeyList. This is used when building opaque
// blobs, and is necessary to properly support WOW64 operation.
typedef struct _PackedKeyList
{
    // BLOBHEADER
    ALG_ID          Algid;
    DWORD           Rights;
    DWORD           cbKeyLen;
    DWORD           cbDataLen;
    BYTE            IV[MAX_BLOCKLEN];       // Initialization vector
    BYTE            FeedBack[MAX_BLOCKLEN]; // Feedback register
    DWORD           InProgress;             // Flag to indicate encryption
    DWORD           cbSaltLen;              // Salt length
    BYTE            rgbSalt[MAX_SALT_LEN];  // Salt value
    DWORD           Padding;                // Padding values
    DWORD           Mode;                   // Mode of cipher
    DWORD           ModeBits;               // Number of bits to feedback
    DWORD           Permissions;            // Key permissions
    DWORD           EffectiveKeyLen;        // used by RC2
    DWORD           dwBlockLen;             // Block ciphers only
    // cbKeyLen data bytes
    // cbDataLen data bytes
} NTAGPackedKeyList, *PNTAGPackedKeyList;

// definition of a hash list
typedef struct Hash_List_Defn
{
    HCRYPTPROV      hUID;
    ALG_ID          Algid;
    DWORD           dwDataLen;
    BOOL            fSeparateHashDataAlloc;
    void            *pHashData;
    HCRYPTKEY       hKey;
    DWORD           HashFlags;
    ALG_ID          HMACAlgid;
    DWORD           HMACState;
    BYTE            *pbHMACInner;
    DWORD           cbHMACInner;
    BYTE            *pbHMACOuter;
    DWORD           cbHMACOuter;
    DWORD           dwHashState;
    DWORD           cbBlockLen;
    BOOL            fTempKey;
} NTAGHashList, *PNTAGHashList;

#define     HMAC_STARTED    1
#define     HMAC_FINISHED   2

#define     DATA_IN_HASH    1

// Values of the HashFlags

#define HF_VALUE_SET    1

// Hash algorithm's internal state
// -- Placed into PNTAGHashList->pHashData

// for MD4
// see md4.h for MD4_object

#include <mac.h>
#include <ssl3.h>

//
// Usage:
//      VOID
//      GetHashObjectSize(
//          ALG_ID HashAlg,
//          PDWORD HashSize);
//
__inline VOID GetHashObjectSize(ALG_ID HashAlg, PDWORD HashSize) 
{
    switch (HashAlg)
    {
        case CALG_MAC:          *HashSize = sizeof(MACstate);          break;   
        case CALG_SSL3_SHAMD5:  *HashSize = SSL3_SHAMD5_LEN;           break;  
        case CALG_SCHANNEL_MASTER_HASH: *HashSize = sizeof(SCH_HASH);  break; 
        case CALG_TLS1PRF:      *HashSize = sizeof(PRF_HASH);          break;
        case CALG_MD2:          *HashSize = sizeof(MD2_object);        break;
        case CALG_MD4:          *HashSize = sizeof(MD4_object);        break;   
        case CALG_MD5:          *HashSize = sizeof(MD5_object);        break;  
        case CALG_SHA:          *HashSize = sizeof(SHA_object);        break; 
        case CALG_SHA_256:      *HashSize = sizeof(SHA256_object);     break;   
        case CALG_SHA_384:      *HashSize = sizeof(SHA384_object);     break;  
        case CALG_SHA_512:      *HashSize = sizeof(SHA512_object);     break; 
        default:                *HashSize = 0;                               
    } 
}

#include <tripldes.h>

//
// Usage:
//      VOID
//      GetKeyObjectSize(
//          ALG_ID KeyAlg,
//          PDWORD KeySize);
//
__inline VOID GetKeyObjectSize(ALG_ID KeyAlg, PDWORD KeySize)
{                                    
    switch (KeyAlg) 
    {                                                          
        case CALG_RC2:          *KeySize = RC2_TABLESIZE;             break;  
        case CALG_RC4:          *KeySize = sizeof(RC4_KEYSTRUCT);     break; 
        case CALG_DES:          *KeySize = DES_TABLESIZE;             break;
        case CALG_3DES_112:                                                
        case CALG_3DES:         *KeySize = DES3_TABLESIZE;            break;
        case CALG_AES_128:                                                 
        case CALG_AES_192:                                                
        case CALG_AES_256:      *KeySize = AES_TABLESIZE;             break;   
        default:                *KeySize = 0;                                 
    }                                                                        
}

// prototypes
void memnuke(volatile BYTE *data, DWORD len);

extern DWORD
GetHashLength(
    IN ALG_ID Algid);

extern DWORD
LocalCreateHash(
    IN ALG_ID Algid,
    OUT BYTE **ppbHashData,
    OUT DWORD *pcbHashData);

extern DWORD
LocalHashData(
    IN ALG_ID Algid,
    IN OUT BYTE *pbHashData,
    IN BYTE *pbData,
    IN DWORD cbData);

extern DWORD
LocalEncrypt(
    IN HCRYPTPROV hUID,
    IN HCRYPTKEY hKey,
    IN HCRYPTHASH hHash,
    IN BOOL Final,
    IN DWORD dwFlags,
    IN OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen,
    IN DWORD dwBufSize,
    IN BOOL fIsExternal);

extern DWORD
LocalDecrypt(
    IN HCRYPTPROV hUID,
    IN HCRYPTKEY hKey,
    IN HCRYPTHASH hHash,
    IN BOOL Final,
    IN DWORD dwFlags,
    IN OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen,
    IN BOOL fIsExternal);

extern DWORD
FIPS186GenRandom(
    IN HANDLE *phRNGDriver,
    IN BYTE **ppbContextSeed,
    IN DWORD *pcbContextSeed,
    IN OUT BYTE *pb,
    IN DWORD cb);

//
// Function : TestSymmetricAlgorithm
//
// Description : This function expands the passed in key buffer for the appropriate algorithm,
//               encrypts the plaintext buffer with the same algorithm and key, and the
//               compares the passed in expected ciphertext with the calculated ciphertext
//               to make sure they are the same.  The opposite is then done with decryption.
//               The function only uses ECB mode for block ciphers and the plaintext
//               buffer must be the same length as the ciphertext buffer.  The length
//               of the plaintext must be either the block length of the cipher if it
//               is a block cipher or less than MAX_BLOCKLEN if a stream cipher is
//               being used.
//
extern DWORD
TestSymmetricAlgorithm(
    IN ALG_ID Algid,
    IN BYTE *pbKey,
    IN DWORD cbKey,
    IN BYTE *pbPlaintext,
    IN DWORD cbPlaintext,
    IN BYTE *pbCiphertext,
    IN BYTE *pbIV);

#ifdef CSP_USE_MD5
//
// Function : TestMD5
//
// Description : This function hashes the passed in message with the MD5 hash
//               algorithm and returns the resulting hash value.
//
BOOL TestMD5(
             BYTE *pbMsg,
             DWORD cbMsg,
             BYTE *pbHash
             );
#endif // CSP_USE_MD5

#ifdef CSP_USE_SHA1
//
// Function : TestSHA1
//
// Description : This function hashes the passed in message with the SHA1 hash
//               algorithm and returns the resulting hash value.
//
BOOL TestSHA1(
              BYTE *pbMsg,
              DWORD cbMsg,
              BYTE *pbHash
              );
#endif // CSP_USE_SHA1

// These may later be changed to set/use NT's [GS]etLastErrorEx
// so make it easy to switch over..
#ifdef MTS
__declspec(thread)
#endif

#ifdef __cplusplus
}
#endif

#endif // __NTAGIMP1_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\inc\nt_rsa.h ===
#ifndef __NT_RSA_H__
#define __NT_RSA_H__

#include "md2.h"
#include "md4.h"
#include "md5.h"
#include "sha.h"
#include "sha2.h"
#include "rc2.h"
#include "rc4.h"
#include "des.h"
#include "modes.h"

/* nt_rsa.h
 *
 *  Stuff local to NameTag, but necessary for the RSA library.
 */

#ifdef __cplusplus
extern "C" {
#endif

// This structure keeps state for MD4 hashing.
typedef struct MD4stuff
{
    MDstruct            MD;     // MD4's state
    BOOL                FinishFlag;
    DWORD               BufLen;
    BYTE                Buf[MD4BLOCKSIZE];// staging buffer
} MD4_object;

typedef struct MD2stuff
{
    MD2_CTX                         MD;     // MD2's state
    BOOL                FinishFlag;
} MD2_object;

#define MD2DIGESTLEN    16


typedef struct {
    A_SHA_CTX           SHACtx;
    BOOL                FinishFlag;
    BYTE                HashVal[A_SHA_DIGEST_LEN];
} SHA_object;

typedef struct {
    MD5_CTX             MD5Ctx;
    BOOL                FinishFlag;
} MD5_object;
                 
typedef struct {
    SHA256_CTX          SHA256Ctx;
    BOOL                FinishFlag;
    BYTE                HashVal[SHA256_DIGEST_LEN];
} SHA256_object;

typedef struct {
    SHA384_CTX          SHA384Ctx;
    BOOL                FinishFlag;
    BYTE                HashVal[SHA384_DIGEST_LEN];
} SHA384_object;

typedef struct {
    SHA512_CTX          SHA512Ctx;
    BOOL                FinishFlag;
    BYTE                HashVal[SHA512_DIGEST_LEN];
} SHA512_object;

#ifdef __cplusplus
}
#endif

#endif // __NT_RSA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\inc\ntagum.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ntagum.h                                               //
//  DESCRIPTION   : include file                                           //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Feb 16 1995 larrys  Fix problem for 944 build                      //
//      May 23 1997 jeffspel Added provider type checking                  //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////
#ifndef __NTAGUM_H__
#define __NTAGUM_H__

#ifdef __cplusplus
extern "C" {
#endif

// prototypes for the NameTag User Manager
extern BOOL WINAPI FIsWinNT(void);

extern DWORD
NTagLogonUser(
    LPCSTR pszUserID,
    DWORD dwFlags,
    void **UserInfo,
    HCRYPTPROV *phUID,
    DWORD dwProvType,
    LPSTR pszProvName);

extern void LogoffUser(void *UserInfo);

extern DWORD
ReadRegValue(
    HKEY hLoc,
    char *pszName,
    BYTE **ppbData,
    DWORD *pcbLen,
    BOOL fAlloc);

extern DWORD
ReadKey(
    HKEY hLoc,
    char *pszName,
    BYTE **ppbData,
    DWORD *pcbLen,
    PNTAGUserList pUser,
    HCRYPTKEY hKey,
    BOOL *pfPrivKey,
    BOOL fKeyExKey,
    BOOL fLastKey);

BOOL SaveKey(
             HKEY hRegKey,
             CONST char *pszName,
             void *pbData,
             DWORD dwLen,
             PNTAGUserList pUser,
             BOOL fPrivKey,
             DWORD dwFlags,
             BOOL fExportable
             );

extern DWORD
ProtectPrivKey(
    IN OUT PNTAGUserList pTmpUser,
    IN LPWSTR szPrompt,
    IN DWORD dwFlags,
    IN BOOL fSigKey);

extern DWORD
UnprotectPrivKey(
    IN OUT PNTAGUserList pTmpUser,
    IN LPWSTR szPrompt,
    IN BOOL fSigKey,
    IN BOOL fAlwaysDecrypt);

#if 0
extern DWORD
RemovePublicKeyExportability(
    IN PNTAGUserList pUser,
    IN BOOL fExchange);

extern DWORD
MakePublicKeyExportable(
    IN PNTAGUserList pUser,
    IN BOOL fExchange);

extern DWORD
CheckPublicKeyExportability(
    IN PNTAGUserList pUser,
    IN BOOL fExchange);
#endif

#ifdef __cplusplus
}
#endif


#endif // __NTAGUM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\inc\policy.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    policy

Abstract:

    This header file describes the services provided by the algorithm strength
    policy modules.

Author:

    Doug Barlow (dbarlow) 8/11/2000

Remarks:

    ?Remarks?

Notes:

    ?Notes?

--*/

#ifndef _POLICY_H_
#define _POLICY_H_
#ifdef __cplusplus
extern "C" {
#endif

extern BOOL
IsLegalAlgorithm(
    IN  CONST PROV_ENUMALGS_EX *rgEnumAlgs,
    IN  ALG_ID algId,
    OUT CONST PROV_ENUMALGS_EX **ppEnumAlg);

extern BOOL
IsLegalLength(
    IN CONST PROV_ENUMALGS_EX *rgEnumAlgs,
    IN ALG_ID algId,
    IN DWORD cBitLength,
    IN CONST PROV_ENUMALGS_EX *pEnumAlg);

extern BOOL
GetDefaultLength(
    IN  CONST PROV_ENUMALGS_EX *rgEnumAlgs,
    IN  ALG_ID algId,
    IN  CONST PROV_ENUMALGS_EX *pEnumAlg,
    OUT LPDWORD pcBitLength);

#ifdef __cplusplus
}
#endif
#endif // _POLICY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\inc\nt_blobs.h ===
#ifndef __NT_BLOBS_H__
#define __NT_BLOBS_H__

/* nt_blobs.h
 *
 *  Structure definitions for the NameTag keyblob formats.
 *
 *  Note: the code assumes that all structures begin with the
 *  STD_PRELUDE macro and end with the STD_POSTLUDE macro.
 *  This allows the "fill in the blanks" code to work more efficiently.
 *
 *  NTStdHeader is the data that goes before the encrypted portion of
 *  the key blob.
 *
 *  !!!!!!!!!!!!!!!ALERT!!!!!!!!!!!!!!!!!!!!!!!!!
 *  Since these structs define a net packet, we always
 *  assume Intel byte order on these structures!!!!!
 *
 */

#ifdef __cplusplus
extern "C" {
#endif

#include <sha2.h>

#define CUR_BLOB_VERSION    2
#define NT_HASH_BYTES       MAX_HASH_SIZE

typedef struct _SIMPLEBLOB {
    ALG_ID  aiEncAlg;
} NTSimpleBlob;

typedef struct _STKXB {
    DWORD   dwRights;
    DWORD   dwKeyLen;
    BYTE    abHashData[NT_HASH_BYTES];
} NTKeyXBlob ;

#ifdef __cplusplus
}
#endif

#endif // __NT_BLOBS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\inc\precomp.h ===
#undef UNICODE					// ## Not Yet
#include <windows.h>
#include <windef.h>
#include <wincrypt.h>
#include <cspdk.h>
#include <malloc.h>
#include <string.h>
#include <time.h>
#include <wtypes.h>

#ifndef WIN95
#include "assert.h"
#endif
#ifdef SECDBG					// ITV Security
#define	NTAGDEBUG				// Turn on internal debugging
#else	// SECDBG
#ifndef ASSERT
#define ASSERT(x)				// default to base
#endif
#endif	// SECDBG

#include "scp.h"
#include "rsa.h"
#include "contman.h"
#include "ntagimp1.h"
#include "manage.h"

#pragma	hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\inc\vectest.h ===
// CJ vector test constants
//

// GenKey flag to get vectors into key.
#define	VECTTEST	0x4000

BYTE VTRC2[/*RC2_KEYSIZE*/] = { 0x59, 0x45, 0x9a, 0xf9, 0x27 };
// 0x84, 0x74, 0xca };

BYTE VTRC4[/*RC4_KEYSIZE*/] = { 0x61, 0x8a, 0x63, 0xd2, 0xfb };

#define DES_TEST        0x2000

BYTE DESTEST[/*DES_KEYSIZE*/] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef};

#define DES3_TEST       0x1000

BYTE DES3TEST[/*DES3_KEYSIZE*/] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
                                  0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
                                  0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\inc\ssl3.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ssl3.h                                             //
//  DESCRIPTION   :                                                        //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Dec  2 1996 jeffspel  Create                                        //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef __SSL3_H__
#define __SSL3_H__

#ifdef __cplusplus
extern "C" {
#endif

#define     EXPORTABLE_KEYLEN   5
#define     EXPORTABLE_SALTLEN  11
#define     RC_KEYLEN           16
#define     MAX_PREMASTER_LEN   48
#define     MAX_RANDOM_LEN      256

#define     TLS_MASTER_LEN   48

// definition of a Secure Channel hash structure
typedef struct _SCH_KeyData
{
    BYTE        rgbPremaster[MAX_PREMASTER_LEN];
    DWORD       cbPremaster;
    BYTE        rgbClientRandom[MAX_RANDOM_LEN];
    DWORD       cbClientRandom;
    BYTE        rgbServerRandom[MAX_RANDOM_LEN];
    DWORD       cbServerRandom;
    BYTE        *pbCertData;
    DWORD       cbCertData;
    BYTE        rgbClearData[MAX_RANDOM_LEN];
    DWORD       cbClearData;
    ALG_ID      EncAlgid;
    ALG_ID      HashAlgid;
    DWORD       cbEnc;
    DWORD       cbEncMac;
    DWORD       cbHash;
    DWORD       cbIV;
    BOOL        fFinished;
    BOOL        dwFlags;
} SCH_KEY, *PSCH_KEY;

// definition of a Secure Channel hash structure
typedef struct _SCH_HashData
{
    ALG_ID      ProtocolAlgid;
    ALG_ID      EncAlgid;
    ALG_ID      HashAlgid;
    DWORD       cbEnc;
    DWORD       cbEncMac;
    DWORD       cbHash;
    DWORD       cbIV;
    BYTE        rgbClientRandom[MAX_RANDOM_LEN];
    DWORD       cbClientRandom;
    BYTE        rgbServerRandom[MAX_RANDOM_LEN];
    DWORD       cbServerRandom;
    BYTE        *pbCertData;
    DWORD       cbCertData;
    BYTE        rgbClearData[MAX_RANDOM_LEN];
    DWORD       cbClearData;
    BYTE        rgbFinal[MAX_RANDOM_LEN];
    DWORD       cbFinal;
    BOOL        dwFlags;
} SCH_HASH, *PSCH_HASH;

// definition of a TLS1 PRF hash structure
typedef struct _PRF_HashData
{
    BYTE        rgbLabel[MAX_RANDOM_LEN];
    DWORD       cbLabel;
    BYTE        rgbSeed[MAX_RANDOM_LEN];
    DWORD       cbSeed;
    BYTE        rgbMasterKey[TLS_MASTER_LEN];
} PRF_HASH;

// strings for deriving PCT1 keys
#define     PCT1_C_WRT          "cw"
#define     PCT1_C_WRT_LEN      2
#define     PCT1_S_WRT          "svw"
#define     PCT1_S_WRT_LEN      3
#define     PCT1_C_MAC          "cmac"
#define     PCT1_C_MAC_LEN      4
#define     PCT1_S_MAC          "svmac"
#define     PCT1_S_MAC_LEN      5

void FreeSChHash(
                 PSCH_HASH       pSChHash
                 );

void FreeSChKey(
                PSCH_KEY    pSChKey
                );

extern DWORD
SCHSetKeyParam(
    IN PNTAGUserList pTmpUser,
    IN OUT PNTAGKeyList pKey,
    IN DWORD dwParam,
    IN CONST BYTE *pbData);

extern DWORD
SChGenMasterKey(
    PNTAGKeyList pKey,
    PSCH_HASH pSChHash);

extern DWORD
SecureChannelDeriveKey(
    PNTAGUserList pTmpUser,
    PNTAGHashList pHash,
    ALG_ID Algid,
    DWORD dwFlags,
    HCRYPTKEY *phKey);

extern DWORD
SetPRFHashParam(
    PRF_HASH *pPRFHash,
    DWORD dwParam,
    CONST BYTE *pbData);

extern DWORD
CalculatePRF(
    PRF_HASH *pPRFHash,
    BYTE *pbData,
    DWORD *pcbData);

#ifdef __cplusplus
}
#endif

#endif // __SSL3_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\inc\protstor.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : protstor.h                                             //
//  DESCRIPTION   :                                                        //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Dec  4 1996 jeffspel  Create                                       //
//      Apr 21 1997 jeffspel  Changes for NT 5 tree                        //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef __PROTSTOR_H__
#define __PROTSTOR_H__

#ifdef __cplusplus
extern "C" {
#endif

extern BOOL
CheckPStoreAvailability(
    PSTORE_INFO *pPStore);

extern DWORD
CreateNewPSKeyset(
    PSTORE_INFO *pPStore,
    DWORD dwFlags);

extern DWORD
GetKeysetTypeAndSubType(
    PNTAGUserList pUser);

extern DWORD
RestoreKeysetFromProtectedStorage(
    PNTAGUserList pUser,
    LPWSTR szPrompt,
    BYTE **ppbKey,
    DWORD *pcbKey,
    BOOL fSigKey,
    BOOL fMachineKeySet,
    BOOL *pfUIOnKey);

void RemoveKeysetFromMemory(
                            PNTAGUserList pUser
                            );

extern DWORD
SetUIPrompt(
    PNTAGUserList pUser,
    LPWSTR szPrompt);

extern DWORD
SaveKeyToProtectedStorage(
    PNTAGUserList pUser,
    DWORD dwFlags,
    LPWSTR szPrompt,
    BOOL fSigKey,
    BOOL fMachineKeySet);

extern DWORD
DeleteKeyFromProtectedStorage(
    NTAGUserList *pUser,
    PCSP_STRINGS pStrings,
    DWORD dwKeySpec,
    BOOL fMachineKeySet,
    BOOL fMigration);

extern DWORD
DeleteFromProtectedStorage(
    CONST char *pszUserID,
    PCSP_STRINGS pStrings,
    HKEY hRegKey,
    BOOL fMachineKeySet);

void FreePSInfo(
                PSTORE_INFO *pPStore
                );

#ifdef __cplusplus
}
#endif

#endif // __PROTSTOR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\inc\swnt_pk.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : swnt_pk.h                                              //
//  DESCRIPTION   :                                                        //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Apr 19 1995 larrys  Cleanup                                        //
//      Oct 27 1995 rajeshk  RandSeed Stuff added hUID to PKCS2Encrypt     //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef __SWNT_PK_H__
#define __SWNT_PK_H__

#include <delayimp.h>
#include <pstore.h>
#include <alloca.h>

#ifdef __cplusplus
extern "C" {
#endif

#define GetNextAlignedValue(c, alignment)   ((c + alignment) & ~(alignment - 1))

#define GetPtrAlignedSize(cb) (GetNextAlignedValue(cb, sizeof(ULONG_PTR)))

#define NTPK_USE_SIG    0
#define NTPK_USE_EXCH   1


#define PKCS_BLOCKTYPE_1        1
#define PKCS_BLOCKTYPE_2        2

//
// Function : EncryptAndDecryptWithRSAKey
//
// Description : This function creates a buffer and then encrypts that with
//               the passed in private key and decrypts with the passed in
//               public key.  The function is used for FIPS 140-1 compliance
//               to make sure that newly generated/imported keys work and
//               in the self test during DLL initialization.
//

extern DWORD
EncryptAndDecryptWithRSAKey(
    IN BYTE *pbRSAPub,
    IN BYTE *pbRSAPriv,
    IN BOOL fSigKey,
    IN BOOL fEncryptCheck,
    IN BOOL fHardCodedKey);

extern DWORD
ReGenKey(
    HCRYPTPROV hUser,
    DWORD dwFlags,
    DWORD dwWhichKey,
    HCRYPTKEY *phKey,
    DWORD bits);

extern BOOL
CheckDataLenForRSAEncrypt(
    IN DWORD cbMod,     // length of the modulus
    IN DWORD cbData,    // length of the data
    IN DWORD dwFlags);  // flags

// do the modular exponentiation calculation M^PubKey mod N
extern DWORD
RSAPublicEncrypt(
    IN PEXPO_OFFLOAD_STRUCT pOffloadInfo,
    IN BSAFE_PUB_KEY *pBSPubKey,
    IN BYTE *pbInput,
    IN BYTE *pbOutput);

// do the modular exponentiation calculation M^PrivKey Exponent mod N
extern DWORD
RSAPrivateDecrypt(
    IN PEXPO_OFFLOAD_STRUCT pOffloadInfo,
    IN BSAFE_PRV_KEY *pBSPrivKey,
    IN BYTE *pbInput,
    IN BYTE *pbOutput);

/************************************************************************/
/* RSAEncrypt performs a RSA encryption.                                */
/************************************************************************/
extern DWORD
RSAEncrypt(
    IN PNTAGUserList pTmpUser,
    IN BSAFE_PUB_KEY *pBSPubKey,
    IN BYTE *pbPlaintext,
    IN DWORD cbPlaintext,
    IN BYTE *pbParams,
    IN DWORD cbParams,
    IN DWORD dwFlags,
    OUT BYTE *pbOut);

/************************************************************************/
/* RSADecrypt performs a RSA decryption.                                */
/************************************************************************/
extern DWORD
RSADecrypt(
    IN PNTAGUserList pTmpUser,
    IN BSAFE_PRV_KEY *pBSPrivKey,
    IN CONST BYTE *pbBlob,
    IN DWORD cbBlob,
    IN BYTE *pbParams,
    IN DWORD cbParams,
    IN DWORD dwFlags,
    OUT BYTE **ppbPlaintext,
    OUT DWORD *pcbPlaintext);

//
// Routine : DerivePublicFromPrivate
//
// Description : Derive the public RSA key from the private RSA key.  This is
//               done and the resulting public key is placed in the appropriate
//               place in the context pointer (pTmpUser).
//

extern DWORD
DerivePublicFromPrivate(
    IN PNTAGUserList pUser,
    IN BOOL fSigKey);

#ifdef __cplusplus
}
#endif

#endif // __SWNT_PK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\inc\scp.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : scp.h                                                  //
//  DESCRIPTION   : Crypto Provider prototypes                             //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Jan 25 1995 larrys  Changed from Nametag                           //
//      Apr  9 1995 larrys  Removed some APIs                              //
//      Apr 19 1995 larrys  Cleanup                                        //
//      May 10 1995 larrys  added private api calls                        //
//      May 16 1995 larrys  updated to spec                                //
//      Aug 30 1995 larrys  Changed a parameter to IN OUT                  //
//      Oct 06 1995 larrys  Added more APIs                                //
//      OCt 13 1995 larrys  Removed CryptGetHashValue                      //
//      Apr  7 2000 dbarlow Moved all the entry point definitions to       //
//                  the cspdk.h header file                                //
//                                                                         //
//  Copyright (C) 1993 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#include <time.h>
#include <wincrypt.h>
#include <policy.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _DEBUG
#include <crtdbg.h>
// #define BreakPoint
#define BreakPoint _CrtDbgBreak();
#define EntryPoint
// #define EntryPoint BreakPoint
#else   // _DEBUG
#define BreakPoint
#define EntryPoint
#endif  // _DEBUG

// type definition of a NameTag error
typedef unsigned int NTAG_ERROR;

#define NTF_FAILED              FALSE
#define NTF_SUCCEED             TRUE

#define NTAG_SUCCEEDED(ntag_error)  ((ntag_error) == NTF_SUCCEED)
#define NTAG_FAILED(ntag_error)     ((ntag_error) == NTF_FAILED)

#define NASCENT                 0x00000002

#define NTAG_MAXPADSIZE         8
#define MAXSIGLEN               64

// definitions max length of logon pszUserID parameter
#define MAXUIDLEN               64

// udp type flag
#define KEP_UDP                 1

// Flags for NTagGetPubKey
#define SIGPUBKEY               0x1000
#define EXCHPUBKEY              0x2000


//
// NOTE:    The following values must match the indicies in the g_AlgTables
//          array, defined below.
//

#define POLICY_MS_DEF       0   // Key length table for PROV_MS_DEF
#define POLICY_MS_STRONG    1   // Key length table for PROV_MS_STRONG
#define POLICY_MS_ENHANCED  2   // Key length table for PROV_MS_ENHANCED
#define POLICY_MS_SCHANNEL  3   // Key length table for PROV_MS_SCHANNEL
#define POLICY_MS_SIGONLY   4   // Key length table for undefined
                                // signature-only CSP.
#define POLICY_MS_RSAAES    5   // Key length table for MS_ENH_RSA_AES_PROV
extern PROV_ENUMALGS_EX *g_AlgTables[];

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\mincrypt\imagehack.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       imagehack.h
//
//  Contents:   "Hacked" version of the imagehlp APIs
//
//              Contains a "stripped" down subset of the imagehlp functionality
//              necessary to hash a PE file and to extract the 
//              PKCS #7 Signed Data message.
//
//  APIs:       imagehack_ImageGetDigestStream
//              imagehack_ImageGetCertificateData
//
//----------------------------------------------------------------------------

#ifndef __IMAGEHACK_H__
#define __IMAGEHACK_H__


#if defined (_MSC_VER)

#if ( _MSC_VER >= 800 )
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)    /* Nameless struct/union */
#endif

#if (_MSC_VER > 1020)
#pragma once
#endif

#endif


#include <wincrypt.h>
#include <imagehlp.h>
#include <wintrust.h>

#ifdef __cplusplus
extern "C" {
#endif


BOOL
WINAPI
imagehack_ImageGetDigestStream(
    IN      PCRYPT_DATA_BLOB pFileBlob,
    IN      DWORD   DigestLevel,                    // ignored
    IN      DIGEST_FUNCTION DigestFunction,
    IN      DIGEST_HANDLE   DigestHandle
    );

BOOL
WINAPI
imagehack_ImageGetCertificateData(
    IN      PCRYPT_DATA_BLOB pFileBlob,
    IN      DWORD   CertificateIndex,               // should be 0
    OUT     LPWIN_CERTIFICATE * Certificate
    );



#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#if defined (_MSC_VER)
#if ( _MSC_VER >= 800 )

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif

#endif
#endif

#endif // __IMAGEHACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\mincrypt\asn1parse.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       asn1parse.cpp
//
//  Contents:   Minimal ASN.1 parse functions.
//
//  Functions:  MinAsn1ParseCertificate
//              MinAsn1ParseAlgorithmIdentifier
//              MinAsn1ParsePublicKeyInfo
//              MinAsn1ParseRSAPublicKey
//              MinAsn1ParseExtensions
//              MinAsn1ParseSignedData
//              MinAsn1ParseSignedDataCertificates
//              MinAsn1ParseAttributes
//              MinAsn1ParseCTL
//              MinAsn1ParseCTLSubject
//              MinAsn1ParseIndirectData
//
//  History:    15-Jan-01    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"

const BYTE rgbSeqTag[] = {MINASN1_TAG_SEQ, 0};
const BYTE rgbSetTag[] = {MINASN1_TAG_SET, 0};
const BYTE rgbOIDTag[] = {MINASN1_TAG_OID, 0};
const BYTE rgbIntegerTag[] = {MINASN1_TAG_INTEGER, 0};
const BYTE rgbBooleanTag[] = {MINASN1_TAG_BOOLEAN, 0};
const BYTE rgbBitStringTag[] = {MINASN1_TAG_BITSTRING, 0};
const BYTE rgbOctetStringTag[] = {MINASN1_TAG_OCTETSTRING, 0};
const BYTE rgbConstructedContext0Tag[] =
    {MINASN1_TAG_CONSTRUCTED_CONTEXT_0, 0};
const BYTE rgbConstructedContext1Tag[] =
    {MINASN1_TAG_CONSTRUCTED_CONTEXT_1, 0};
const BYTE rgbConstructedContext3Tag[] =
    {MINASN1_TAG_CONSTRUCTED_CONTEXT_3, 0};
const BYTE rgbContext1Tag[] = {MINASN1_TAG_CONTEXT_1, 0};
const BYTE rgbContext2Tag[] = {MINASN1_TAG_CONTEXT_2, 0};
const BYTE rgbChoiceOfTimeTag[] =
    {MINASN1_TAG_UTC_TIME, MINASN1_TAG_GENERALIZED_TIME, 0};


const MINASN1_EXTRACT_VALUE_PARA rgParseCertPara[] = {
    // 0 - SignedContent ::= SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP, 
        MINASN1_CERT_ENCODED_IDX, rgbSeqTag,

    // 0.1 - toBeSigned ::== SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP,
        MINASN1_CERT_TO_BE_SIGNED_IDX, rgbSeqTag,

    // 0.1.0 - version                 [0] EXPLICIT CertificateVersion DEFAULT v1,
    MINASN1_OPTIONAL_STEP_INTO_VALUE_OP, 0, rgbConstructedContext0Tag,

    // 0.1.0.0 - version number (INTEGER)
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CERT_VERSION_IDX, rgbIntegerTag,
    // 0.1.0.1
    MINASN1_STEP_OUT_VALUE_OP, 0, NULL,

    // 0.1.1 - serialNumber            CertificateSerialNumber,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CERT_SERIAL_NUMBER_IDX, rgbIntegerTag,
    // 0.1.2 - signature               AlgorithmIdentifier,
    MINASN1_STEP_OVER_VALUE_OP, 0, rgbSeqTag,
    // 0.1.3 - issuer                  NOCOPYANY, -- really Name
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CERT_ISSUER_IDX, rgbSeqTag,
    // 0.1.4 - validity                Validity,
    MINASN1_STEP_INTO_VALUE_OP, 0, rgbSeqTag,

    // 0.1.4.0 - notBefore           ChoiceOfTime,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CERT_NOT_BEFORE_IDX, rgbChoiceOfTimeTag,
    // 0.1.4.1 - notAfter            ChoiceOfTime,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CERT_NOT_AFTER_IDX, rgbChoiceOfTimeTag,
    // 0.1.4.2
    MINASN1_STEP_OUT_VALUE_OP, 0, NULL,

    // 0.1.5 - subject                 NOCOPYANY, -- really Name
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CERT_SUBJECT_IDX, rgbSeqTag,
    // 0.1.6 - subjectPublicKeyInfo    SubjectPublicKeyInfo,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CERT_PUBKEY_INFO_IDX, rgbSeqTag,
    // 0.1.7 - issuerUniqueIdentifier  [1] IMPLICIT BITSTRING OPTIONAL,
    // Note, advanced past the unused bits octet
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_CERT_ISSUER_UNIQUE_ID_IDX, rgbContext1Tag,
    // 0.1.8 - subjectUniqueIdentifier [2] IMPLICIT BITSTRING OPTIONAL,
    // Note, advanced past the unused bits octet
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_CERT_SUBJECT_UNIQUE_ID_IDX, rgbContext2Tag,
    // 0.1.9 - extensions              [3] EXPLICIT Extensions OPTIONAL
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_CERT_EXTS_IDX, rgbConstructedContext3Tag,

    // 0.1.10
    MINASN1_STEP_OUT_VALUE_OP, 0, NULL,

    // 0.2 - signatureAlgorithm  AlgorithmIdentifier,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CERT_SIGN_ALGID_IDX, rgbSeqTag,
    // 0.3 - signature           BITSTRING
    // Note, advanced past the unused bits octet
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CERT_SIGNATURE_IDX, rgbBitStringTag,
};
#define PARSE_CERT_PARA_CNT         \
    (sizeof(rgParseCertPara) / sizeof(rgParseCertPara[0]))

//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseCertificate
//
//  Parses an ASN.1 encoded X.509 certificate.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded certificate
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  All BITSTRING fields have been advanced past the unused count octet.
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ParseCertificate(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT CRYPT_DER_BLOB rgCertBlob[MINASN1_CERT_BLOB_CNT]
    )
{

    LONG lSkipped;
    DWORD cValuePara = PARSE_CERT_PARA_CNT;

    lSkipped = MinAsn1ExtractValues(
        pbEncoded,
        cbEncoded,
        &cValuePara,
        rgParseCertPara,
        MINASN1_CERT_BLOB_CNT,
        rgCertBlob
        );

    if (0 < lSkipped) {
        lSkipped = rgCertBlob[MINASN1_CERT_ENCODED_IDX].cbData;

        // If present, fixup the ISSUER_UNIQUE_ID and SUBJECT_UNIQUE_ID bit
        // fields to advance past the first contents octet containing the
        // number of unused bits
        if (0 != rgCertBlob[MINASN1_CERT_ISSUER_UNIQUE_ID_IDX].cbData) {
            rgCertBlob[MINASN1_CERT_ISSUER_UNIQUE_ID_IDX].pbData += 1;
            rgCertBlob[MINASN1_CERT_ISSUER_UNIQUE_ID_IDX].cbData -= 1;
        }

        if (0 != rgCertBlob[MINASN1_CERT_SUBJECT_UNIQUE_ID_IDX].cbData) {
            rgCertBlob[MINASN1_CERT_SUBJECT_UNIQUE_ID_IDX].pbData += 1;
            rgCertBlob[MINASN1_CERT_SUBJECT_UNIQUE_ID_IDX].cbData -= 1;
        }
    }

    return lSkipped;
}

const MINASN1_EXTRACT_VALUE_PARA rgParseAlgIdPara[] = {
    // 0 - AlgorithmIdentifier    ::=    SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP, 
        MINASN1_ALGID_ENCODED_IDX, rgbSeqTag,

    // 0.0 - algorithm  ObjectID,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_ALGID_OID_IDX, rgbOIDTag,
    // 0.1 parameters ANY OPTIONAL
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_ALGID_PARA_IDX, NULL,
};
#define PARSE_ALGID_PARA_CNT        \
    (sizeof(rgParseAlgIdPara) / sizeof(rgParseAlgIdPara[0]))

//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseAlgorithmIdentifier
//
//  Parses an ASN.1 encoded Algorithm Identifier contained in numerous
//  other ASN.1 structures, such as, X.509 certificate and PKCS #7 Signed Data
//  message.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded algorithm
//                        identifier
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ParseAlgorithmIdentifier(
    IN PCRYPT_DER_BLOB pAlgIdValueBlob,
    OUT CRYPT_DER_BLOB rgAlgIdBlob[MINASN1_ALGID_BLOB_CNT]
    )
{

    LONG lSkipped;
    DWORD cValuePara = PARSE_ALGID_PARA_CNT;

    lSkipped = MinAsn1ExtractValues(
        pAlgIdValueBlob->pbData,
        pAlgIdValueBlob->cbData,
        &cValuePara,
        rgParseAlgIdPara,
        MINASN1_ALGID_BLOB_CNT,
        rgAlgIdBlob
        );

    if (0 < lSkipped)
        lSkipped = rgAlgIdBlob[MINASN1_ALGID_ENCODED_IDX].cbData;

    return lSkipped;
}



const MINASN1_EXTRACT_VALUE_PARA rgParsePubKeyInfoPara[] = {
    // 0 - PublicKeyInfo ::= SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP, 
        MINASN1_PUBKEY_INFO_ENCODED_IDX, rgbSeqTag,

    // 0.0 - algorithm  AlgorithmIdentifier,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_PUBKEY_INFO_ALGID_IDX, rgbSeqTag,

    // 0.1 - PublicKey  BITSTRING
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_PUBKEY_INFO_PUBKEY_IDX, rgbBitStringTag,
};
#define PARSE_PUBKEY_INFO_PARA_CNT      \
    (sizeof(rgParsePubKeyInfoPara) / sizeof(rgParsePubKeyInfoPara[0]))

//+-------------------------------------------------------------------------
//  Function: MinAsn1ParsePublicKeyInfo
//
//  Parses an ASN.1 encoded Public Key Info structure contained in an
//  X.509 certificate
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded public key
//                        info
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  All BITSTRING fields have been advanced past the unused count octet.
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ParsePublicKeyInfo(
    IN PCRYPT_DER_BLOB pPubKeyInfoValueBlob,
    CRYPT_DER_BLOB rgPubKeyInfoBlob[MINASN1_PUBKEY_INFO_BLOB_CNT]
    )
{

    LONG lSkipped;
    DWORD cValuePara = PARSE_PUBKEY_INFO_PARA_CNT;

    lSkipped = MinAsn1ExtractValues(
        pPubKeyInfoValueBlob->pbData,
        pPubKeyInfoValueBlob->cbData,
        &cValuePara,
        rgParsePubKeyInfoPara,
        MINASN1_PUBKEY_INFO_BLOB_CNT,
        rgPubKeyInfoBlob
        );

    if (0 < lSkipped)
        lSkipped = rgPubKeyInfoBlob[MINASN1_PUBKEY_INFO_ENCODED_IDX].cbData;

    return lSkipped;
}



const MINASN1_EXTRACT_VALUE_PARA rgParseRSAPubKeyPara[] = {
    // 0 - RSAPublicKey ::= SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP, 
        MINASN1_RSA_PUBKEY_ENCODED_IDX, rgbSeqTag,

    // 0.0 - modulus         HUGEINTEGER,    -- n
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_RSA_PUBKEY_MODULUS_IDX, rgbIntegerTag,
    // 0.1 - publicExponent  INTEGER (0..4294967295)         -- e
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_RSA_PUBKEY_EXPONENT_IDX, rgbIntegerTag,
};
#define PARSE_RSA_PUBKEY_PARA_CNT       \
    (sizeof(rgParseRSAPubKeyPara) / sizeof(rgParseRSAPubKeyPara[0]))

//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseRSAPublicKey
//
//  Parses an ASN.1 encoded RSA PKCS #1 Public Key contained in the contents of
//  Public Key BITSTRING in a X.509 certificate.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded RSA public key
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ParseRSAPublicKey(
    IN PCRYPT_DER_BLOB pPubKeyContentBlob,
    CRYPT_DER_BLOB rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_BLOB_CNT]
    )
{

    LONG lSkipped;
    DWORD cValuePara = PARSE_RSA_PUBKEY_PARA_CNT;

    lSkipped = MinAsn1ExtractValues(
        pPubKeyContentBlob->pbData,
        pPubKeyContentBlob->cbData,
        &cValuePara,
        rgParseRSAPubKeyPara,
        MINASN1_RSA_PUBKEY_BLOB_CNT,
        rgRSAPubKeyBlob
        );

    if (0 < lSkipped)
        lSkipped = rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_ENCODED_IDX].cbData;

    return lSkipped;
}


const MINASN1_EXTRACT_VALUE_PARA rgParseExtPara[] = {
    // 0 - Extension ::= SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP, 
        MINASN1_EXT_ENCODED_IDX, rgbSeqTag,

    // 0.0 - extnId              EncodedObjectID,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_EXT_OID_IDX, rgbOIDTag,
    // 0.1 - critical            BOOLEAN DEFAULT FALSE,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_EXT_CRITICAL_IDX, rgbBooleanTag,
    // 0.2 - extnValue           OCTETSTRING
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_EXT_VALUE_IDX, rgbOctetStringTag,
};

#define PARSE_EXT_PARA_CNT          \
    (sizeof(rgParseExtPara) / sizeof(rgParseExtPara[0]))

//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseExtensions
//
//  Parses an ASN.1 encoded sequence of extensions contained in 
//  other ASN.1 structures, such as, X.509 certificate and CTL.
//
//  Upon input, *pcExt contains the maximum number of parsed extensions
//  that can be returned. Updated with the number of extensions processed.
//
//  Returns:
//      success - >= 0 => bytes skipped, length of the encoded extensions
//                        processed. If all extensions were processed,
//                        bytes skipped = pExtsValueBlob->cbData.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ParseExtensions(
    IN PCRYPT_DER_BLOB pExtsValueBlob,  // Extensions ::= SEQUENCE OF Extension
    IN OUT DWORD *pcExt,
    OUT CRYPT_DER_BLOB rgrgExtBlob[][MINASN1_EXT_BLOB_CNT]
    )
{
    const BYTE *pbEncoded = (const BYTE *) pExtsValueBlob->pbData;
    DWORD cbEncoded = pExtsValueBlob->cbData;
    DWORD cExt = *pcExt;
    DWORD iExt = 0;
    LONG lAllExts = 0;

    const BYTE *pb;
    DWORD cb;

    if (0 == cbEncoded)
        // No extensions
        goto CommonReturn;

    // Step into the SEQUENCE
    if (0 >= MinAsn1ExtractContent(
            pbEncoded,
            cbEncoded,
            &cb,
            &pb
            )) {
        lAllExts = -1;
        goto CommonReturn;
    }

    for (iExt = 0; 0 < cb && iExt < cExt; iExt++) {
        LONG lExt;
        DWORD cbExt;
        DWORD cValuePara = PARSE_EXT_PARA_CNT;

        lExt = MinAsn1ExtractValues(
            pb,
            cb,
            &cValuePara,
            rgParseExtPara,
            MINASN1_EXT_BLOB_CNT,
            rgrgExtBlob[iExt]
            );

        if (0 >= lExt) {
            if (0 == lExt)
                lExt = -1;
            lAllExts = -((LONG)(pb - pbEncoded)) + lExt;
            goto CommonReturn;
        }

        cbExt = rgrgExtBlob[iExt][MINASN1_EXT_ENCODED_IDX].cbData;
        pb += cbExt;
        cb -= cbExt;
    }

    lAllExts = (LONG)(pb - pbEncoded);
    assert((DWORD) lAllExts <= cbEncoded);

CommonReturn:
    *pcExt = iExt;
    return lAllExts;
}


const MINASN1_EXTRACT_VALUE_PARA rgParseSignedDataPara[] = {
    // 0 - ContentInfo ::= SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP, 
        MINASN1_SIGNED_DATA_ENCODED_IDX, rgbSeqTag,

    // 0.0 - contentType ContentType,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_OUTER_OID_IDX, rgbOIDTag,
    // 0.1 - content  [0] EXPLICIT ANY -- OPTIONAL
    MINASN1_STEP_INTO_VALUE_OP, 0, rgbConstructedContext0Tag,

    // 0.1.0 - SignedData ::= SEQUENCE {
    MINASN1_STEP_INTO_VALUE_OP, 0, rgbSeqTag,

    // 0.1.0.0 - version             INTEGER,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_VERSION_IDX, rgbIntegerTag,
    // 0.1.0.1 - digestAlgorithms    DigestAlgorithmIdentifiers,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_DIGEST_ALGIDS_IDX, rgbSetTag,
    // 0.1.0.2 - ContentInfo ::= SEQUENCE {
    MINASN1_STEP_INTO_VALUE_OP, 0, rgbSeqTag,

    // 0.1.0.2.0 - contentType ContentType,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_CONTENT_OID_IDX, rgbOIDTag,
    // 0.1.0.2.1 - content  [0] EXPLICIT ANY -- OPTIONAL
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_CONTENT_DATA_IDX, rgbConstructedContext0Tag,
    // 0.1.0.2.2
    MINASN1_STEP_OUT_VALUE_OP, 0, NULL,

    // 0.1.0.3 - certificates        [0] IMPLICIT Certificates OPTIONAL,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_CERTS_IDX, rgbConstructedContext0Tag,
    // 0.1.0.4 - crls                [1] IMPLICIT CertificateRevocationLists OPTIONAL,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_CRLS_IDX, rgbConstructedContext1Tag,
    // 0.1.0.5 - signerInfos :: = SET OF
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP,
        MINASN1_SIGNED_DATA_SIGNER_INFOS_IDX, rgbSetTag,

    // 0.1.0.5.0 - SignerInfo ::= SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_INTO_VALUE_OP,
        MINASN1_SIGNED_DATA_SIGNER_INFO_ENCODED_IDX, rgbSeqTag,

    // 0.1.0.5.0.0 - version                     INTEGER,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_SIGNER_INFO_VERSION_IDX, rgbIntegerTag,
    // 0.1.0.5.0.1 - issuerAndSerialNumber       IssuerAndSerialNumber
    MINASN1_STEP_INTO_VALUE_OP, 0, rgbSeqTag,

    // 0.1.0.5.0.1.0 - issuer          ANY,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_SIGNER_INFO_ISSUER_IDX, rgbSeqTag,
    // 0.1.0.5.0.1.1 - serialNumber    INTEGER
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_SIGNER_INFO_SERIAL_NUMBER_IDX, rgbIntegerTag,
    // 0.1.0.5.0.1.2
    MINASN1_STEP_OUT_VALUE_OP, 0, NULL,

    // 0.1.0.5.0.2 - digestAlgorithm             DigestAlgorithmIdentifier,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_SIGNER_INFO_DIGEST_ALGID_IDX, rgbSeqTag,
    // 0.1.0.5.0.3 - authenticatedAttributes     [0] IMPLICIT Attributes OPTIONAL,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_SIGNER_INFO_AUTH_ATTRS_IDX, rgbConstructedContext0Tag,
    // 0.1.0.5.0.4 - digestEncryptionAlgorithm   DigestEncryptionAlgId,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_SIGNER_INFO_ENCRYPT_DIGEST_ALGID_IDX, rgbSeqTag,
    // 0.1.0.5.0.5 - encryptedDigest             EncryptedDigest,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_SIGNER_INFO_ENCYRPT_DIGEST_IDX, rgbOctetStringTag,
    // 0.1.0.5.0.6 - unauthenticatedAttributes   [1] IMPLICIT Attributes OPTIONAL
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_SIGNED_DATA_SIGNER_INFO_UNAUTH_ATTRS_IDX, rgbConstructedContext1Tag,
};
#define PARSE_SIGNED_DATA_PARA_CNT      \
    (sizeof(rgParseSignedDataPara) / sizeof(rgParseSignedDataPara[0]))


//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseSignedData
//
//  Parses an ASN.1 encoded PKCS #7 Signed Data Message. Assumes the
//  PKCS #7 message is definite length encoded. Assumes PKCS #7 version
//  1.5, ie, not the newer CMS version.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded message
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ParseSignedData(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT CRYPT_DER_BLOB rgSignedDataBlob[MINASN1_SIGNED_DATA_BLOB_CNT]
    )
{

    LONG lSkipped;
    DWORD cValuePara = PARSE_SIGNED_DATA_PARA_CNT;

    lSkipped = MinAsn1ExtractValues(
        pbEncoded,
        cbEncoded,
        &cValuePara,
        rgParseSignedDataPara,
        MINASN1_SIGNED_DATA_BLOB_CNT,
        rgSignedDataBlob
        );

    if (0 < lSkipped)
        lSkipped = rgSignedDataBlob[MINASN1_SIGNED_DATA_ENCODED_IDX].cbData;

    return lSkipped;
}


//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseSignedDataCertificates
//
//  Parses an ASN.1 encoded set of certificates contained in 
//  a Signed Data message.
//
//  Upon input, *pcCert contains the maximum number of parsed certificates
//  that can be returned. Updated with the number of certificates processed.
//
//  Returns:
//      success - >= 0 => bytes skipped, length of the encoded certificates
//                        processed. If all certificates were processed,
//                        bytes skipped = pCertsValueBlob->cbData.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgrgCertBlob[][] is updated with pointer to and length of the
//  fields in the encoded certificate. See MinAsn1ParseCertificate for the
//  field definitions.
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ParseSignedDataCertificates(
    IN PCRYPT_DER_BLOB pCertsValueBlob,
    IN OUT DWORD *pcCert,
    OUT CRYPT_DER_BLOB rgrgCertBlob[][MINASN1_CERT_BLOB_CNT]
    )
{
    const BYTE *pbEncoded = (const BYTE *) pCertsValueBlob->pbData;
    DWORD cbEncoded = pCertsValueBlob->cbData;
    DWORD cCert = *pcCert;
    DWORD iCert = 0;
    LONG lAllCerts = 0;

    const BYTE *pb;
    DWORD cb;

    if (0 == cbEncoded)
        // No certificates
        goto CommonReturn;

    // Skip outer tag and length
    if (0 >= MinAsn1ExtractContent(
            pbEncoded,
            cbEncoded,
            &cb,
            &pb
            )) {
        lAllCerts = -1;
        goto CommonReturn;
    }

    for (iCert = 0; 0 < cb && iCert < cCert; iCert++) {
        LONG lCert;

        lCert = MinAsn1ParseCertificate(
            pb,
            cb,
            rgrgCertBlob[iCert]
            );

        if (0 >= lCert) {
            if (0 == lCert)
                lCert = -1;
            lAllCerts = -((LONG)(pb - pbEncoded)) + lCert;
            goto CommonReturn;
        }

        pb += lCert;
        cb -= lCert;
    }

    lAllCerts = (LONG)(pb - pbEncoded);
    assert((DWORD) lAllCerts <= cbEncoded);

CommonReturn:
    *pcCert = iCert;
    return lAllCerts;
}


const MINASN1_EXTRACT_VALUE_PARA rgParseAttrPara[] = {
    // 0 - Attribute ::= SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP, 
        MINASN1_ATTR_ENCODED_IDX, rgbSeqTag,

    // 0.0 - attributeType       ObjectID,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_ATTR_OID_IDX, rgbOIDTag,
    // 0.1 - attributeValue      SET OF
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP,
        MINASN1_ATTR_VALUES_IDX, rgbSetTag,

    // 0.1.0 - Value        ANY -- OPTIONAL
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_ATTR_VALUE_IDX, NULL,
};
#define PARSE_ATTR_PARA_CNT         \
    (sizeof(rgParseAttrPara) / sizeof(rgParseAttrPara[0]))

//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseAttributes
//
//  Parses an ASN.1 encoded sequence of attributes contained in 
//  other ASN.1 structures, such as, Signer Info authenticated or
//  unauthenticated attributes.
//
//  The outer tag is ignored. It can be a SET, [0] IMPLICIT, or [1] IMPLICIT.
//
//  Upon input, *pcAttr contains the maximum number of parsed attributes
//  that can be returned. Updated with the number of attributes processed.
//
//  Returns:
//      success - >= 0 => bytes skipped, length of the encoded attributes
//                        processed. If all attributes were processed,
//                        bytes skipped = pAttrsValueBlob->cbData.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ParseAttributes(
    IN PCRYPT_DER_BLOB pAttrsValueBlob,
    IN OUT DWORD *pcAttr,
    OUT CRYPT_DER_BLOB rgrgAttrBlob[][MINASN1_ATTR_BLOB_CNT]
    )
{
    const BYTE *pbEncoded = (const BYTE *) pAttrsValueBlob->pbData;
    DWORD cbEncoded = pAttrsValueBlob->cbData;
    DWORD cAttr = *pcAttr;
    DWORD iAttr = 0;
    LONG lAllAttrs = 0;

    const BYTE *pb;
    DWORD cb;

    if (0 == cbEncoded)
        // No attributes
        goto CommonReturn;

    // Skip the outer tag and length
    if (0 >= MinAsn1ExtractContent(
            pbEncoded,
            cbEncoded,
            &cb,
            &pb
            )) {
        lAllAttrs = -1;
        goto CommonReturn;
    }

    for (iAttr = 0; 0 < cb && iAttr < cAttr; iAttr++) {
        LONG lAttr;
        DWORD cbAttr;
        DWORD cValuePara = PARSE_ATTR_PARA_CNT;

        lAttr = MinAsn1ExtractValues(
            pb,
            cb,
            &cValuePara,
            rgParseAttrPara,
            MINASN1_ATTR_BLOB_CNT,
            rgrgAttrBlob[iAttr]
            );

        if (0 >= lAttr) {
            if (0 == lAttr)
                lAttr = -1;
            lAllAttrs = -((LONG)(pb - pbEncoded)) + lAttr;
            goto CommonReturn;
        }

        cbAttr = rgrgAttrBlob[iAttr][MINASN1_ATTR_ENCODED_IDX].cbData;
        pb += cbAttr;
        cb -= cbAttr;
    }

    lAllAttrs = (LONG)(pb - pbEncoded);
    assert((DWORD) lAllAttrs <= cbEncoded);

CommonReturn:
    *pcAttr = iAttr;
    return lAllAttrs;
}



const MINASN1_EXTRACT_VALUE_PARA rgParseCTLPara[] = {
    // 0 - CertificateTrustList ::= SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP, 
        MINASN1_CTL_ENCODED_IDX, rgbSeqTag,

    // 0.0 - version                 CTLVersion DEFAULT v1,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_CTL_VERSION_IDX, rgbIntegerTag,
    // 0.1 - subjectUsage            SubjectUsage,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CTL_SUBJECT_USAGE_IDX, rgbSeqTag,
    // 0.2 - listIdentifier          ListIdentifier OPTIONAL,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_CTL_LIST_ID_IDX, rgbOctetStringTag,
    // 0.3 - sequenceNumber          HUGEINTEGER OPTIONAL,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_CTL_SEQUENCE_NUMBER_IDX, rgbIntegerTag,
    // 0.4 - ctlThisUpdate           ChoiceOfTime,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CTL_THIS_UPDATE_IDX, rgbChoiceOfTimeTag,
    // 0.5 - ctlNextUpdate           ChoiceOfTime OPTIONAL,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_CTL_NEXT_UPDATE_IDX, rgbChoiceOfTimeTag,
    // 0.6 - subjectAlgorithm        AlgorithmIdentifier,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CTL_SUBJECT_ALGID_IDX, rgbSeqTag,
    // 0.7 - trustedSubjects         TrustedSubjects OPTIONAL,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_CTL_SUBJECTS_IDX, rgbSeqTag,
    // 0.8 - ctlExtensions           [0] EXPLICIT Extensions OPTIONAL
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_CTL_EXTS_IDX, rgbConstructedContext0Tag,
};
#define PARSE_CTL_PARA_CNT          \
    (sizeof(rgParseCTLPara) / sizeof(rgParseCTLPara[0]))

//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseCTL
//
//  Parses an ASN.1 encoded Certificate Trust List (CTL). A CTL is always
//  contained as the inner content data in a PKCS #7 Signed Data. A CTL has
//  the following OID: "1.3.6.1.4.1.311.10.1".
//
//  A catalog file is formatted as a PKCS #7 Signed CTL.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded CTL
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ParseCTL(
    IN PCRYPT_DER_BLOB pEncodedContentBlob,
    OUT CRYPT_DER_BLOB rgCTLBlob[MINASN1_CTL_BLOB_CNT]
    )
{

    LONG lSkipped;
    DWORD cValuePara = PARSE_CTL_PARA_CNT;

    lSkipped = MinAsn1ExtractValues(
        pEncodedContentBlob->pbData,
        pEncodedContentBlob->cbData,
        &cValuePara,
        rgParseCTLPara,
        MINASN1_CTL_BLOB_CNT,
        rgCTLBlob
        );

    if (0 < lSkipped)
        lSkipped = rgCTLBlob[MINASN1_CTL_ENCODED_IDX].cbData;

    return lSkipped;
}


const MINASN1_EXTRACT_VALUE_PARA rgParseCTLSubjectPara[] = {
    // 0 - TrustedSubject ::= SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP, 
        MINASN1_CTL_SUBJECT_ENCODED_IDX, rgbSeqTag,

    // 0.0 - subjectIdentifier       SubjectIdentifier,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_CTL_SUBJECT_ID_IDX, rgbOctetStringTag,
    // 0.1 - subjectAttributes	    Attributes OPTIONAL
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_CTL_SUBJECT_ATTRS_IDX, rgbSetTag,
};
#define PARSE_CTL_SUBJECT_PARA_CNT      \
    (sizeof(rgParseCTLSubjectPara) / sizeof(rgParseCTLSubjectPara[0]))

//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseCTLSubject
//
//  Parses an ASN.1 encoded CTL Subject contained within a CTL's SEQUENCE OF
//  Subjects.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded subject.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ParseCTLSubject(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT CRYPT_DER_BLOB rgCTLSubjectBlob[MINASN1_CTL_SUBJECT_BLOB_CNT]
    )
{

    LONG lSkipped;
    DWORD cValuePara = PARSE_CTL_SUBJECT_PARA_CNT;

    lSkipped = MinAsn1ExtractValues(
        pbEncoded,
        cbEncoded,
        &cValuePara,
        rgParseCTLSubjectPara,
        MINASN1_CTL_SUBJECT_BLOB_CNT,
        rgCTLSubjectBlob
        );

    if (0 < lSkipped)
        lSkipped = rgCTLSubjectBlob[MINASN1_CTL_SUBJECT_ENCODED_IDX].cbData;

    return lSkipped;
}



const MINASN1_EXTRACT_VALUE_PARA rgParseIndirectDataPara[] = {
    // 0 - SpcIndirectDataContent ::= SEQUENCE {
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_INTO_VALUE_OP, 
        MINASN1_INDIRECT_DATA_ENCODED_IDX, rgbSeqTag,

    // 0.0 - data                    SpcAttributeTypeAndOptionalValue,
    MINASN1_STEP_INTO_VALUE_OP, 0, rgbSeqTag,

    // 0.0.0 - type                    ObjectID,
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_INDIRECT_DATA_ATTR_OID_IDX, rgbOIDTag,
    // 0.0.1 - value                   NOCOPYANY OPTIONAL
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_OPTIONAL_STEP_OVER_VALUE_OP,
        MINASN1_INDIRECT_DATA_ATTR_VALUE_IDX, NULL,
    // 0.0.2
    MINASN1_STEP_OUT_VALUE_OP, 0, NULL,

    // 0.1 - messageDigest           DigestInfo
    MINASN1_STEP_INTO_VALUE_OP, 0, rgbSeqTag,

    // 0.1.0 - digestAlgorithm     AlgorithmIdentifier,
    MINASN1_RETURN_VALUE_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_INDIRECT_DATA_DIGEST_ALGID_IDX, rgbSeqTag,
    // 0.1.1 - digest              OCTETSTRING
    MINASN1_RETURN_CONTENT_BLOB_FLAG | MINASN1_STEP_OVER_VALUE_OP,
        MINASN1_INDIRECT_DATA_DIGEST_IDX, rgbOctetStringTag,
};
#define PARSE_INDIRECT_DATA_PARA_CNT    \
    (sizeof(rgParseIndirectDataPara) / sizeof(rgParseIndirectDataPara[0]))

//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseIndirectData
//
//  Parses an ASN.1 encoded Indirect Data. Indirect Data is always
//  contained as the inner content data in a PKCS #7 Signed Data. It has
//  the following OID: "1.3.6.1.4.1.311.2.1.4"
//
//  An Authenticode signed file contains a PKCS #7 Signed Indirect Data.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded Indirect Data
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ParseIndirectData(
    IN PCRYPT_DER_BLOB pEncodedContentBlob,
    OUT CRYPT_DER_BLOB rgIndirectDataBlob[MINASN1_INDIRECT_DATA_BLOB_CNT]
    )
{

    LONG lSkipped;
    DWORD cValuePara = PARSE_INDIRECT_DATA_PARA_CNT;

    lSkipped = MinAsn1ExtractValues(
        pEncodedContentBlob->pbData,
        pEncodedContentBlob->cbData,
        &cValuePara,
        rgParseIndirectDataPara,
        MINASN1_INDIRECT_DATA_BLOB_CNT,
        rgIndirectDataBlob
        );

    if (0 < lSkipped)
        lSkipped = rgIndirectDataBlob[MINASN1_INDIRECT_DATA_ENCODED_IDX].cbData;

    return lSkipped;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\mincrypt\asn1util.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       asn1util.cpp
//
//  Contents:   Minimal ASN.1 utility helper functions.
//
//  Functions:  MinAsn1DecodeLength
//              MinAsn1ExtractContent
//              MinAsn1ExtractValues
//
//              MinAsn1FindExtension
//              MinAsn1FindAttribute
//              MinAsn1ExtractParsedCertificatesFromSignedData
//
//  History:    15-Jan-01    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"

//+-------------------------------------------------------------------------
//  Get the number of contents octets in a definite-length BER-encoding.
//
//  Parameters:
//          pcbContent - receives the number of contents octets
//          pbLength   - points to the first length octet
//          cbBER      - number of bytes remaining in the BER encoding
//
//  Returns:
//          success - the number of bytes in the length field, > 0
//          failure - < 0
//
//          One of the following failure values can be returned:
//              MINASN1_LENGTH_TOO_LARGE
//              MINASN1_INSUFFICIENT_DATA
//              MINASN1_UNSUPPORTED_INDEFINITE_LENGTH
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1DecodeLength(
    OUT DWORD   *pcbContent,
    IN const BYTE *pbLength,
    IN  DWORD   cbBER)
{
    long        i;
    BYTE        cbLength;
    const BYTE  *pb;

    if (cbBER < 1)
        goto TooLittleData;

    if (0x80 == *pbLength)
        goto IndefiniteLength;

    // determine the number of length octets and contents octets
    if ((cbLength = *pbLength) & 0x80) {
        cbLength &= ~0x80;         // low 7 bits have number of bytes
        if (cbLength > 4)
            goto LengthTooLargeError;
        if (cbLength >= cbBER)
            goto TooLittleData;
        *pcbContent = 0;
        for (i=cbLength, pb=pbLength+1; i>0; i--, pb++)
            *pcbContent = (*pcbContent << 8) + (const DWORD)*pb;
        i = cbLength + 1;
    } else {
        *pcbContent = (DWORD)cbLength;
        i = 1;
    }

CommonReturn:
    return i;   // how many bytes there were in the length field

LengthTooLargeError:
    i = MINASN1_LENGTH_TOO_LARGE;
    goto CommonReturn;

IndefiniteLength:
    i = MINASN1_UNSUPPORTED_INDEFINITE_LENGTH;
    goto CommonReturn;

TooLittleData:
    i = MINASN1_INSUFFICIENT_DATA;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  Point to the content octets in a definite-length BER-encoded blob.
//
//  Returns:
//          success - the number of bytes skipped, > 0
//          failure - < 0
//
//          One of the following failure values can be returned:
//              MINASN1_LENGTH_TOO_LARGE
//              MINASN1_INSUFFICIENT_DATA
//              MINASN1_UNSUPPORTED_INDEFINITE_LENGTH
//
// Assumption: pbData points to a definite-length BER-encoded blob.
//             If *pcbContent isn't within cbBER, MINASN1_INSUFFICIENT_DATA
//             is returned.
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ExtractContent(
    IN const BYTE *pbBER,
    IN DWORD cbBER,
    OUT DWORD *pcbContent,
    OUT const BYTE **ppbContent)
{
#define TAG_MASK 0x1f
    DWORD       cbIdentifier;
    DWORD       cbContent;
    LONG        cbLength;
    LONG        lHeader;
    const BYTE  *pb = pbBER;

    if (0 == cbBER--)
        goto TooLittleData;

    // Skip over the identifier octet(s)
    if (TAG_MASK == (*pb++ & TAG_MASK)) {
        // high-tag-number form
        cbIdentifier = 2;
        while (TRUE) {
            if (0 == cbBER--)
                goto TooLittleData;
            if (0 == (*pb++ & 0x80))
                break;
            cbIdentifier++;
        }
    } else {
        // low-tag-number form
        cbIdentifier = 1;
    }

    if (0 > (cbLength = MinAsn1DecodeLength( &cbContent, pb, cbBER))) {
        lHeader = cbLength;
        goto CommonReturn;
    }

    if (cbContent > (cbBER - cbLength))
        goto TooLittleData;

    pb += cbLength;

    *pcbContent = cbContent;
    *ppbContent = pb;

    lHeader = cbLength + cbIdentifier;
CommonReturn:
    return lHeader;

TooLittleData:
    lHeader = MINASN1_INSUFFICIENT_DATA;
    goto CommonReturn;
}


typedef struct _STEP_INTO_STACK_ENTRY {
    const BYTE      *pb;
    DWORD           cb;
    BOOL            fSkipIntoValues;
} STEP_INTO_STACK_ENTRY, *PSTEP_INTO_STACK_ENTRY;

#define MAX_STEP_INTO_DEPTH     8

//+-------------------------------------------------------------------------
//  Extract one or more tagged values from the ASN.1 encoded byte array.
//
//  Either steps into the value's content octets (MINASN1_STEP_INTO_VALUE_OP or
//  MINASN1_OPTIONAL_STEP_INTO_VALUE_OP) or steps over the value's tag,
//  length and content octets (MINASN1_STEP_OVER_VALUE_OP or
//  MINASN1_OPTIONAL_STEP_OVER_VALUE_OP).
//
//  You can step out of a stepped into sequence via MINASN1_STEP_OUT_VALUE_OP.
//
//  For tag matching, only supports single byte tags.
//
//  Only definite-length ASN.1 is supported.
//
//  *pcValue is updated with the number of values successfully extracted.
//
//  Returns:
//      success - >= 0 => length of all bytes consumed through the last value
//                        extracted. For STEP_INTO, only the tag and length
//                        octets.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  A non-NULL rgValueBlob[] is updated with the pointer to and length of the
//  tagged value or its content octets. The rgValuePara[].dwIndex is used to
//  index into rgValueBlob[].  For OPTIONAL_STEP_OVER or
//  OPTIONAL_STEP_INTO, if no more bytes in the outer SEQUENCE or if the tag
//  isn't found, pbData and cbData are set to 0. Additioanlly, for
//  OPTIONAL_STEP_INTO, all subsequent values are skipped and their
//  rgValueBlob[] entries zeroed until a STEP_OUT is encountered.
//
//  If MINASN1_RETURN_VALUE_BLOB_FLAG is set, pbData points to
//  the tag. cbData includes the tag, length and content octets.
//
//  If MINASN1_RETURN_CONTENT_BLOB_FLAG is set, pbData points to the content
//  octets. cbData includes only the content octets.
//
//  If neither BLOB_FLAG is set, rgValueBlob[] isn't updated.
//
//  For MINASN1_RETURN_CONTENT_BLOB_FLAG of a BITSTRING, pbData is
//  advanced past the first contents octet containing the number of
//  unused bits and cbData has been decremented by 1. If cbData > 0, then,
//  *(pbData - 1) will contain the number of unused bits.
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ExtractValues(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN OUT DWORD *pcValuePara,
    IN const MINASN1_EXTRACT_VALUE_PARA *rgValuePara,
    IN DWORD cValueBlob,
    OUT OPTIONAL PCRYPT_DER_BLOB rgValueBlob
    )
{
    DWORD cValue = *pcValuePara;
    const BYTE *pb = pbEncoded;
    DWORD cb = cbEncoded;
    BOOL fSkipIntoValues = FALSE;

    DWORD iValue;
    LONG lAllValues;

    STEP_INTO_STACK_ENTRY rgStepIntoStack[MAX_STEP_INTO_DEPTH];
    DWORD dwStepIntoDepth = 0;

    for (iValue = 0; iValue < cValue; iValue++) {
        DWORD dwParaFlags = rgValuePara[iValue].dwFlags;
        DWORD dwOp = dwParaFlags & MINASN1_MASK_VALUE_OP;
        const BYTE *pbParaTag = rgValuePara[iValue].rgbTag;
        DWORD dwIndex = rgValuePara[iValue].dwIndex;
        BOOL fValueBlob = (dwParaFlags & (MINASN1_RETURN_VALUE_BLOB_FLAG |
                MINASN1_RETURN_CONTENT_BLOB_FLAG)) && rgValueBlob &&
                (dwIndex < cValueBlob);
        BOOL fSkipValue = FALSE;

        LONG lTagLength;
        DWORD cbContent;
        const BYTE *pbContent;
        DWORD cbValue;

        if (MINASN1_STEP_OUT_VALUE_OP == dwOp) {
            // Unstack and advance past the last STEP_INTO

            if (0 == dwStepIntoDepth)
                goto InvalidStepOutOp;

            dwStepIntoDepth--;
            pb = rgStepIntoStack[dwStepIntoDepth].pb;
            cb = rgStepIntoStack[dwStepIntoDepth].cb;
            fSkipIntoValues = rgStepIntoStack[dwStepIntoDepth].fSkipIntoValues;

            continue;
        }

        if (fSkipIntoValues) {
            // For an omitted OPTIONAL_STEP_INTO, all of its included values
            // are also omitted.
            fSkipValue = TRUE;
        } else if (0 == cb) {
            if (!(MINASN1_OPTIONAL_STEP_INTO_VALUE_OP == dwOp ||
                    MINASN1_OPTIONAL_STEP_OVER_VALUE_OP == dwOp))
                goto TooLittleData;
            fSkipValue = TRUE;
        } else if (pbParaTag) {
            // Assumption: single byte tag for doing comparison

            // Check if the encoded tag matches one of the expected tags

            BYTE bEncodedTag;
            BYTE bParaTag;

            bEncodedTag = *pb;
            while ((bParaTag = *pbParaTag) && bParaTag != bEncodedTag)
                pbParaTag++;

            if (0 == bParaTag) {
                if (!(MINASN1_OPTIONAL_STEP_INTO_VALUE_OP == dwOp ||
                        MINASN1_OPTIONAL_STEP_OVER_VALUE_OP == dwOp))
                    goto InvalidTag;
                fSkipValue = TRUE;
            }
        }

        if (fSkipValue) {
            if (fValueBlob) {
                rgValueBlob[dwIndex].pbData = NULL;
                rgValueBlob[dwIndex].cbData = 0;
            }

            if (MINASN1_STEP_INTO_VALUE_OP == dwOp ||
                    MINASN1_OPTIONAL_STEP_INTO_VALUE_OP == dwOp) {
                // Stack this skipped STEP_INTO
                if (MAX_STEP_INTO_DEPTH <= dwStepIntoDepth)
                    goto ExceededStepIntoDepth;
                rgStepIntoStack[dwStepIntoDepth].pb = pb;
                rgStepIntoStack[dwStepIntoDepth].cb = cb;
                rgStepIntoStack[dwStepIntoDepth].fSkipIntoValues =
                    fSkipIntoValues;
                dwStepIntoDepth++;

                fSkipIntoValues = TRUE;
            }
            continue;
        }

        lTagLength = MinAsn1ExtractContent(
            pb,
            cb,
            &cbContent,
            &pbContent
            );
        if (0 >= lTagLength)
            goto InvalidTagOrLength;

        cbValue = cbContent + lTagLength;

        if (fValueBlob) {
            if (dwParaFlags & MINASN1_RETURN_CONTENT_BLOB_FLAG) {
                rgValueBlob[dwIndex].pbData = (BYTE *) pbContent;
                rgValueBlob[dwIndex].cbData = cbContent;

                if (MINASN1_TAG_BITSTRING == *pb) {
                    if (0 < cbContent) {
                        // Advance past the first contents octet containing
                        // the number of unused bits
                        rgValueBlob[dwIndex].pbData += 1;
                        rgValueBlob[dwIndex].cbData -= 1;
                    }
                }
            } else if (dwParaFlags & MINASN1_RETURN_VALUE_BLOB_FLAG) {
                rgValueBlob[dwIndex].pbData = (BYTE *) pb;
                rgValueBlob[dwIndex].cbData = cbValue;
            }
        }

        switch (dwOp) {
            case MINASN1_STEP_INTO_VALUE_OP:
            case MINASN1_OPTIONAL_STEP_INTO_VALUE_OP:
                // Stack this STEP_INTO
                if (MAX_STEP_INTO_DEPTH <= dwStepIntoDepth)
                    goto ExceededStepIntoDepth;
                rgStepIntoStack[dwStepIntoDepth].pb = pb + cbValue;
                rgStepIntoStack[dwStepIntoDepth].cb = cb - cbValue;
                assert(!fSkipIntoValues);
                rgStepIntoStack[dwStepIntoDepth].fSkipIntoValues = FALSE;
                dwStepIntoDepth++;
                pb = pbContent;
                cb = cbContent;
                break;
            case MINASN1_STEP_OVER_VALUE_OP:
            case MINASN1_OPTIONAL_STEP_OVER_VALUE_OP:
                pb += cbValue;
                cb -= cbValue;
                break;
            default:
                goto InvalidArg;
        }
    }

    lAllValues = (LONG)(pb - pbEncoded);
    assert((DWORD) lAllValues <= cbEncoded);

CommonReturn:
    *pcValuePara = iValue;
    return lAllValues;

InvalidStepOutOp:
TooLittleData:
InvalidTag:
ExceededStepIntoDepth:
InvalidTagOrLength:
InvalidArg:
    lAllValues = -((LONG)(pb - pbEncoded)) - 1;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  Find an extension identified by its Encoded Object Identifier.
//
//  Searches the list of parsed extensions returned by
//  MinAsn1ParseExtensions().
//
//  If found, returns pointer to the rgExtBlob[MINASN1_EXT_BLOB_CNT].
//  Otherwise, returns NULL.
//--------------------------------------------------------------------------
PCRYPT_DER_BLOB
WINAPI
MinAsn1FindExtension(
    IN PCRYPT_DER_BLOB pEncodedOIDBlob,
    IN DWORD cExt,
    IN CRYPT_DER_BLOB rgrgExtBlob[][MINASN1_EXT_BLOB_CNT]
    )
{
    DWORD i;
    DWORD cbOID = pEncodedOIDBlob->cbData;
    const BYTE *pbOID = pEncodedOIDBlob->pbData;

    for (i = 0; i < cExt; i++) {
        if (cbOID == rgrgExtBlob[i][MINASN1_EXT_OID_IDX].cbData
                            &&
                0 == memcmp(pbOID, rgrgExtBlob[i][MINASN1_EXT_OID_IDX].pbData,
                                cbOID))
            return rgrgExtBlob[i];
    }

    return NULL;
}


//+-------------------------------------------------------------------------
//  Find the first attribute identified by its Encoded Object Identifier.
//
//  Searches the list of parsed attributes returned by
//  MinAsn1ParseAttributes().
//
//  If found, returns pointer to the rgAttrBlob[MINASN1_ATTR_BLOB_CNT].
//  Otherwise, returns NULL.
//--------------------------------------------------------------------------
PCRYPT_DER_BLOB
WINAPI
MinAsn1FindAttribute(
    IN PCRYPT_DER_BLOB pEncodedOIDBlob,
    IN DWORD cAttr,
    IN CRYPT_DER_BLOB rgrgAttrBlob[][MINASN1_ATTR_BLOB_CNT]
    )
{
    DWORD i;
    DWORD cbOID = pEncodedOIDBlob->cbData;
    const BYTE *pbOID = pEncodedOIDBlob->pbData;

    for (i = 0; i < cAttr; i++) {
        if (cbOID == rgrgAttrBlob[i][MINASN1_ATTR_OID_IDX].cbData
                            &&
                0 == memcmp(pbOID, rgrgAttrBlob[i][MINASN1_ATTR_OID_IDX].pbData,
                                cbOID))
            return rgrgAttrBlob[i];
    }

    return NULL;
}

//+-------------------------------------------------------------------------
//  Parses an ASN.1 encoded PKCS #7 Signed Data Message to extract and
//  parse the X.509 certificates it contains.
//
//  Assumes the PKCS #7 message is definite length encoded.
//  Assumes PKCS #7 version 1.5, ie, not the newer CMS version.
//
//  Upon input, *pcCert contains the maximum number of parsed certificates
//  that can be returned. Updated with the number of certificates processed.
//
//  If the encoded message was successfully parsed, TRUE is returned
//  with *pcCert updated with the number of parsed certificates. Otherwise,
//  FALSE is returned for a parse error.
//  Returns:
//      success - >= 0 => bytes skipped, length of the encoded certificates
//                        processed.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//                        from beginning of message.
//
//  The rgrgCertBlob[][] is updated with pointer to and length of the
//  fields in the encoded certificate. See MinAsn1ParseCertificate for the
//  field definitions.
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ExtractParsedCertificatesFromSignedData(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN OUT DWORD *pcCert,
    OUT CRYPT_DER_BLOB rgrgCertBlob[][MINASN1_CERT_BLOB_CNT]
    )
{
    LONG lSkipped;
    CRYPT_DER_BLOB rgSignedDataBlob[MINASN1_SIGNED_DATA_BLOB_CNT];

    lSkipped = MinAsn1ParseSignedData(
        pbEncoded,
        cbEncoded,
        rgSignedDataBlob
        );
    if (0 >= lSkipped)
        goto ParseError;

    lSkipped = MinAsn1ParseSignedDataCertificates(
            &rgSignedDataBlob[MINASN1_SIGNED_DATA_CERTS_IDX],
            pcCert,
            rgrgCertBlob
            );

    if (0 > lSkipped) {
        assert(rgSignedDataBlob[MINASN1_SIGNED_DATA_CERTS_IDX].pbData >
            pbEncoded);
        // number of data bytes should be bounded, so this is a safe cast
        lSkipped -= (LONG) (rgSignedDataBlob[MINASN1_SIGNED_DATA_CERTS_IDX].pbData -
            pbEncoded);

        goto ParseError;
    }

CommonReturn:
    return lSkipped;

ParseError:
    *pcCert = 0;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\mincrypt\fileutil.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       fileutil.cpp
//
//  Contents:   File utility functions used by the minimal cryptographic
//              APIs.
//
//  Functions:  I_MinCryptMapFile
//
//  History:    21-Jan-01    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"

#define I_CreateFileU             CreateFileW

//+-------------------------------------------------------------------------
//  Maps the file into memory.
//
//  According to dwFileType, pvFile can be a pwszFilename, hFile or pFileBlob.
//  Only READ access is required.
//
//  dwFileType:
//      MINCRYPT_FILE_NAME      : pvFile - LPCWSTR pwszFilename
//      MINCRYPT_FILE_HANDLE    : pvFile - HANDLE hFile
//      MINCRYPT_FILE_BLOB      : pvFile - PCRYPT_DATA_BLOB pFileBlob
//
//  *pFileBlob is updated with pointer to and length of the mapped file. For
//  MINCRYPT_FILE_NAME and MINCRYPT_FILE_HANDLE, UnmapViewOfFile() must
//  be called to free pFileBlob->pbData.
//
//  All accesses to this mapped memory must be within __try / __except's.
//--------------------------------------------------------------------------
LONG
WINAPI
I_MinCryptMapFile(
    IN DWORD dwFileType,
    IN const VOID *pvFile,
    OUT PCRYPT_DATA_BLOB pFileBlob
    )
{
    LONG lErr = ERROR_SUCCESS;

    switch (dwFileType) {
        case MINCRYPT_FILE_NAME:
            {
                LPCWSTR pwszInFilename = (LPCWSTR) pvFile;
                HANDLE hFile;

                hFile = I_CreateFileU(
                    pwszInFilename,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,                   // lpsa
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL                    // hTemplateFile
                    );
                if (INVALID_HANDLE_VALUE == hFile)
                    goto CreateFileError;

                lErr = I_MinCryptMapFile(
                    MINCRYPT_FILE_HANDLE,
                    (const VOID *) hFile,
                    pFileBlob
                    );
                CloseHandle(hFile);
            }
            break;

        case MINCRYPT_FILE_HANDLE:
            {
                HANDLE hInFile = (HANDLE) pvFile;
                HANDLE hMappedFile;
                DWORD cbHighSize = 0;;
                DWORD cbLowSize;

                cbLowSize = GetFileSize(hInFile, &cbHighSize);
                if (INVALID_FILE_SIZE == cbLowSize)
                    goto GetFileSizeError;
                if (0 != cbHighSize)
                    goto Exceeded32BitFileSize;

                hMappedFile = CreateFileMappingA(
                    hInFile,
                    NULL,           // lpFileMappingAttributes,
                    PAGE_READONLY,
                    0,              // dwMaximumSizeHigh
                    0,              // dwMaximumSizeLow
                    NULL            // lpName
                    );
                if (NULL == hMappedFile)
                    goto CreateFileMappingError;

                pFileBlob->pbData = (BYTE *) MapViewOfFile(
                    hMappedFile,
                    FILE_MAP_READ,
                    0,              // dwFileOffsetHigh
                    0,              // dwFileOffsetLow
                    0               // dwNumberOfBytesToMap, 0 => entire file
                    );
                CloseHandle(hMappedFile);
                if (NULL == pFileBlob->pbData)
                    goto MapViewOfFileError;

                pFileBlob->cbData = cbLowSize;
            }
            break;

        case MINCRYPT_FILE_BLOB:
            {
                PCRYPT_DATA_BLOB pInFileBlob = (PCRYPT_DATA_BLOB) pvFile;
                *pFileBlob = *pInFileBlob;
            }
            break;

        default:
            goto InvalidParameter;
    }

CommonReturn:
    return lErr;

ErrorReturn:
    assert(ERROR_SUCCESS != lErr);
    pFileBlob->pbData = NULL;
    pFileBlob->cbData = 0;
    goto CommonReturn;

InvalidParameter:
    lErr = ERROR_INVALID_PARAMETER;
    goto ErrorReturn;

Exceeded32BitFileSize:
    lErr = ERROR_FILE_INVALID;
    goto ErrorReturn;

CreateFileError:
GetFileSizeError:
CreateFileMappingError:
MapViewOfFileError:
    lErr = GetLastError();
    if (ERROR_SUCCESS == lErr)
        lErr = ERROR_OPEN_FAILED;
    goto ErrorReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\mincrypt\fileutil.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       fileutil.h
//
//  Contents:   File utility functions used by the minimal cryptographic
//              APIs.
//
//  APIs: 
//              I_MinCryptMapFile
//
//----------------------------------------------------------------------------

#ifndef __MINCRYPT_FILEUTIL_H__
#define __MINCRYPT_FILEUTIL_H__


#if defined (_MSC_VER)

#if ( _MSC_VER >= 800 )
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)    /* Nameless struct/union */
#endif

#if (_MSC_VER > 1020)
#pragma once
#endif

#endif


#include <wincrypt.h>
#include <mincrypt.h>

#ifdef __cplusplus
extern "C" {
#endif


//+-------------------------------------------------------------------------
//  Maps the file into memory.
//
//  According to dwFileType, pvFile can be a pwszFilename, hFile or pFileBlob.
//  Only READ access is required.
//
//  dwFileType:
//      MINCRYPT_FILE_NAME      : pvFile - LPCWSTR pwszFilename
//      MINCRYPT_FILE_HANDLE    : pvFile - HANDLE hFile
//      MINCRYPT_FILE_BLOB      : pvFile - PCRYPT_DATA_BLOB pFileBlob
//
//  *pFileBlob is updated with pointer to and length of the mapped file. For
//  MINCRYPT_FILE_NAME and MINCRYPT_FILE_HANDLE, UnmapViewOfFile() must
//  be called to free pFileBlob->pbData.
//
//  All accesses to this mapped memory must be within __try / __except's.
//--------------------------------------------------------------------------
LONG
WINAPI
I_MinCryptMapFile(
    IN DWORD dwFileType,
    IN const VOID *pvFile,
    OUT PCRYPT_DATA_BLOB pFileBlob
    );




#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#if defined (_MSC_VER)
#if ( _MSC_VER >= 800 )

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif

#endif
#endif

#endif // __MINCRYPT_FILEUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\mincrypt\minasn1.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       minasn1.h
//
//  Contents:   Minimal ASN.1 Utility and Parsing API Prototypes
//              and Definitions
//
//              Contains functions to parse X.509 certificates, PKCS #7
//              Signed Data messages, Certificate Trusts Lists (CTLs),
//              hash catalogs, Authenticode Indirect Data and
//              RSA public keys.
//
//              These APIs are implemented to be self contained and to
//              allow for code obfuscation. These APIs will be included
//              in such applications as, DRM or licensing verification.
//
//              Additionally, since these APIs have been pared down
//              from their wincrypt.h and crypt32.dll counterparts they are
//              a good candidate for applications with minimal memory and CPU
//              resources.
//
//              These parsing functions don't depend on more heavy wait
//              ASN.1 runtimes, such as, msoss.dll or msasn1.dll.
//
//              These functions will only use stack memory. No heap
//              allocations. No calls to APIs in other DLLs.
//
//  APIs: 
//              MinAsn1DecodeLength
//              MinAsn1ExtractContent
//              MinAsn1ExtractValues
//
//              MinAsn1ParseCertificate
//              MinAsn1ParseAlgorithmIdentifier
//              MinAsn1ParsePublicKeyInfo
//              MinAsn1ParseRSAPublicKey
//              MinAsn1ParseExtensions
//              MinAsn1ParseSignedData
//              MinAsn1ParseSignedDataCertificates
//              MinAsn1ParseAttributes
//              MinAsn1ParseCTL
//              MinAsn1ParseCTLSubject
//              MinAsn1ParseIndirectData
//
//              MinAsn1FindExtension
//              MinAsn1FindAttribute
//              MinAsn1ExtractParsedCertificatesFromSignedData
//
//----------------------------------------------------------------------------

#ifndef __MINASN1_H__
#define __MINASN1_H__


#if defined (_MSC_VER)

#if ( _MSC_VER >= 800 )
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)    /* Nameless struct/union */
#endif

#if (_MSC_VER > 1020)
#pragma once
#endif

#endif


#include <wincrypt.h>

#ifdef __cplusplus
extern "C" {
#endif


//+-------------------------------------------------------------------------
//  ASN.1 Tag Defines
//--------------------------------------------------------------------------
#define MINASN1_TAG_NULL                    0x00
#define MINASN1_TAG_BOOLEAN                 0x01
#define MINASN1_TAG_INTEGER                 0x02
#define MINASN1_TAG_BITSTRING               0x03
#define MINASN1_TAG_OCTETSTRING             0x04
#define MINASN1_TAG_OID                     0x06
#define MINASN1_TAG_UTC_TIME                0x17
#define MINASN1_TAG_GENERALIZED_TIME        0x18
#define MINASN1_TAG_CONSTRUCTED             0x20
#define MINASN1_TAG_SEQ                     0x30
#define MINASN1_TAG_SET                     0x31
#define MINASN1_TAG_CONTEXT_0               0x80
#define MINASN1_TAG_CONTEXT_1               0x81
#define MINASN1_TAG_CONTEXT_2               0x82
#define MINASN1_TAG_CONTEXT_3               0x83

#define MINASN1_TAG_CONSTRUCTED_CONTEXT_0   \
                        (MINASN1_TAG_CONSTRUCTED | MINASN1_TAG_CONTEXT_0)
#define MINASN1_TAG_CONSTRUCTED_CONTEXT_1   \
                        (MINASN1_TAG_CONSTRUCTED | MINASN1_TAG_CONTEXT_1)
#define MINASN1_TAG_CONSTRUCTED_CONTEXT_3   \
                        (MINASN1_TAG_CONSTRUCTED | MINASN1_TAG_CONTEXT_3)

//+-------------------------------------------------------------------------
//  ASN.1 Length Defines for indefinite length encooding
//--------------------------------------------------------------------------
#define MINASN1_LENGTH_INDEFINITE               0x80
#define MINASN1_LENGTH_NULL                     0x00

#define MINASN1_LENGTH_TOO_LARGE                -1
#define MINASN1_INSUFFICIENT_DATA               -2
#define MINASN1_UNSUPPORTED_INDEFINITE_LENGTH   -3

//+-------------------------------------------------------------------------
//  Get the number of contents octets in a definite-length BER-encoding.
//
//  Parameters:
//          pcbContent - receives the number of contents octets
//          pbLength   - points to the first length octet
//          cbBER      - number of bytes remaining in the BER encoding
//
//  Returns:
//          success - the number of bytes in the length field, > 0
//          failure - < 0
//
//          One of the following failure values can be returned:
//              MINASN1_LENGTH_TOO_LARGE
//              MINASN1_INSUFFICIENT_DATA
//              MINASN1_UNSUPPORTED_INDEFINITE_LENGTH
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1DecodeLength(
    OUT DWORD *pcbContent,
    IN const BYTE *pbLength,
    IN  DWORD cbBER
    );

//+-------------------------------------------------------------------------
//  Point to the content octets in a definite-length BER-encoded blob.
//
//  Returns:
//          success - the number of bytes skipped, > 0
//          failure - < 0
//
//          One of the following failure values can be returned:
//              MINASN1_LENGTH_TOO_LARGE
//              MINASN1_INSUFFICIENT_DATA
//              MINASN1_UNSUPPORTED_INDEFINITE_LENGTH
//
// Assumption: pbData points to a definite-length BER-encoded blob.
//             If *pcbContent isn't within cbBER, MINASN1_INSUFFICIENT_DATA
//             is returned.
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ExtractContent(
    IN const BYTE *pbBER,
    IN DWORD cbBER,
    OUT DWORD *pcbContent,
    OUT const BYTE **ppbContent
    );


typedef struct _MINASN1_EXTRACT_VALUE_PARA {
    // See below for list of operations and optional return blobs.
    DWORD           dwFlags;

    // Index into rgValueBlob of the returned value. Ignored if none of
    // the ASN1_PARSE_RETURN_*_BLOB_FLAG's is set in the above dwFlags.
    DWORD           dwIndex;

    // The following 0 terminated array of tags is optional. If ommited, the
    // value may contain any tag.
    const BYTE      *rgbTag;
} MINASN1_EXTRACT_VALUE_PARA, *PMINASN1_EXTRACT_VALUE_PARA;

// The lower 8 bits of dwFlags is set to one of the following operations
#define MINASN1_MASK_VALUE_OP                   0xFF
#define MINASN1_STEP_OVER_VALUE_OP              1
#define MINASN1_OPTIONAL_STEP_OVER_VALUE_OP     2
#define MINASN1_STEP_INTO_VALUE_OP              3
#define MINASN1_OPTIONAL_STEP_INTO_VALUE_OP     4
#define MINASN1_STEP_OUT_VALUE_OP               5

#define MINASN1_RETURN_VALUE_BLOB_FLAG          0x80000000
#define MINASN1_RETURN_CONTENT_BLOB_FLAG        0x40000000


//+-------------------------------------------------------------------------
//  Extract one or more tagged values from the ASN.1 encoded byte array.
//
//  Either steps into the value's content octets (MINASN1_STEP_INTO_VALUE_OP or
//  MINASN1_OPTIONAL_STEP_INTO_VALUE_OP) or steps over the value's tag,
//  length and content octets (MINASN1_STEP_OVER_VALUE_OP or
//  MINASN1_OPTIONAL_STEP_OVER_VALUE_OP).
//
//  You can step out of a stepped into sequence via MINASN1_STEP_OUT_VALUE_OP.
//
//  For tag matching, only supports single byte tags.
//
//  Only definite-length ASN.1 is supported.
//
//  *pcValue is updated with the number of values successfully extracted.
//
//  Returns:
//      success - >= 0 => length of all bytes consumed through the last value
//                        extracted. For STEP_INTO, only the tag and length
//                        octets.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  A non-NULL rgValueBlob[] is updated with the pointer to and length of the
//  tagged value or its content octets. The rgValuePara[].dwIndex is used to
//  index into rgValueBlob[].  For OPTIONAL_STEP_OVER or
//  OPTIONAL_STEP_INTO, if no more bytes in the outer SEQUENCE or if the tag
//  isn't found, pbData and cbData are set to 0. Additioanlly, for
//  OPTIONAL_STEP_INTO, all subsequent values are skipped and their
//  rgValueBlob[] entries zeroed until a STEP_OUT is encountered.
//
//  If MINASN1_RETURN_VALUE_BLOB_FLAG is set, pbData points to
//  the tag. cbData includes the tag, length and content octets.
//
//  If MINASN1_RETURN_CONTENT_BLOB_FLAG is set, pbData points to the content
//  octets. cbData includes only the content octets.
//
//  If neither BLOB_FLAG is set, rgValueBlob[] isn't updated.
//
//  For MINASN1_RETURN_CONTENT_BLOB_FLAG of a BITSTRING, pbData is
//  advanced past the first contents octet containing the number of
//  unused bits and cbData has been decremented by 1. If cbData > 0, then,
//  *(pbData - 1) will contain the number of unused bits.
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ExtractValues(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN OUT DWORD *pcValuePara,
    IN const MINASN1_EXTRACT_VALUE_PARA *rgValuePara,
    IN DWORD cValueBlob,
    OUT OPTIONAL PCRYPT_DER_BLOB rgValueBlob
    );


//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseCertificate
//
//  Parses an ASN.1 encoded X.509 certificate.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded certificate
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgCertBlob[] is updated with pointer to and length of the following
//  fields in the encoded X.509 certificate.
//
//  All BITSTRING fields have been advanced past the unused count octet.
//--------------------------------------------------------------------------

// Encoded bytes including To Be Signed and Signature
#define MINASN1_CERT_ENCODED_IDX                1

// To Be Signed bytes
#define MINASN1_CERT_TO_BE_SIGNED_IDX           2

// Signature Algorithm value bytes (MinAsn1ParseAlgorithmIdentifier)
#define MINASN1_CERT_SIGN_ALGID_IDX             3

// Signature content bytes (BITSTRING)
#define MINASN1_CERT_SIGNATURE_IDX              4

// Version content bytes (OPTIONAL INTEGER)
#define MINASN1_CERT_VERSION_IDX                5

// Serial Number content bytes (INTEGER)
#define MINASN1_CERT_SERIAL_NUMBER_IDX          6

// Issuer Name value bytes (ANY)
#define MINASN1_CERT_ISSUER_IDX                 7

// Not Before value bytes (UTC_TIME or GENERALIZED_TIME)
#define MINASN1_CERT_NOT_BEFORE_IDX             8

// Not After value bytes (UTC_TIME or GENERALIZED_TIME)
#define MINASN1_CERT_NOT_AFTER_IDX              9

// Subject Name value bytes (ANY)
#define MINASN1_CERT_SUBJECT_IDX                10

// Public Key Info value bytes (MinAsn1ParsePublicKeyInfo)
#define MINASN1_CERT_PUBKEY_INFO_IDX            11

// Issuer Unique Id content bytes (OPTIONAL BITSTRING)
#define MINASN1_CERT_ISSUER_UNIQUE_ID_IDX       12

// Subject Unique Id content bytes (OPTIONAL BITSTRING)
#define MINASN1_CERT_SUBJECT_UNIQUE_ID_IDX      13

// Extensions value bytes skipping "[3] EXPLICIT" tag
// (OPTIONAL MinAsn1ParseExtensions)
#define MINASN1_CERT_EXTS_IDX                   14

#define MINASN1_CERT_BLOB_CNT                   15

LONG
WINAPI
MinAsn1ParseCertificate(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT CRYPT_DER_BLOB rgCertBlob[MINASN1_CERT_BLOB_CNT]
    );


//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseAlgorithmIdentifier
//
//  Parses an ASN.1 encoded Algorithm Identifier contained in numerous
//  other ASN.1 structures, such as, X.509 certificate and PKCS #7 Signed Data
//  message.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded algorithm
//                        identifier
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgAlgIdBlob[] is updated with pointer to and length of the following
//  fields in the encoded Algorithm Identifier
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_ALGID_ENCODED_IDX               1

// Object Identifier content bytes (OID)
#define MINASN1_ALGID_OID_IDX                   2

// Encoded parameters value bytes (OPTIONAL ANY)
#define MINASN1_ALGID_PARA_IDX                  3

#define MINASN1_ALGID_BLOB_CNT                  4


LONG
WINAPI
MinAsn1ParseAlgorithmIdentifier(
    IN PCRYPT_DER_BLOB pAlgIdValueBlob,
    OUT CRYPT_DER_BLOB rgAlgIdBlob[MINASN1_ALGID_BLOB_CNT]
    );



//+-------------------------------------------------------------------------
//  Function: MinAsn1ParsePublicKeyInfo
//
//  Parses an ASN.1 encoded Public Key Info structure contained in an
//  X.509 certificate
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded public key
//                        info
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgPubKeyInfoBlob[] is updated with pointer to and length of the
//  following fields in the encoded Public Key Info.
//
//  All BITSTRING fields have been advanced past the unused count octet.
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_PUBKEY_INFO_ENCODED_IDX         1

// Algorithm Identifier value bytes (MinAsn1ParseAlgorithmIdentifier)
#define MINASN1_PUBKEY_INFO_ALGID_IDX           2

// Public Key content bytes (BITSTRING, MinAsn1ParseRSAPublicKey)
#define MINASN1_PUBKEY_INFO_PUBKEY_IDX          3

#define MINASN1_PUBKEY_INFO_BLOB_CNT            4


LONG
WINAPI
MinAsn1ParsePublicKeyInfo(
    IN PCRYPT_DER_BLOB pPubKeyInfoValueBlob,
    CRYPT_DER_BLOB rgPubKeyInfoBlob[MINASN1_PUBKEY_INFO_BLOB_CNT]
    );


//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseRSAPublicKey
//
//  Parses an ASN.1 encoded RSA PKCS #1 Public Key contained in the contents of
//  Public Key BITSTRING in a X.509 certificate.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded RSA public key
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgRSAPubKeyBlob[] is updated with pointer to and length of the
//  following fields in the encoded RSA Public Key.
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_RSA_PUBKEY_ENCODED_IDX          1

// Modulus content bytes (INTEGER)
#define MINASN1_RSA_PUBKEY_MODULUS_IDX          2

// Exponent content bytes (INTEGER)
#define MINASN1_RSA_PUBKEY_EXPONENT_IDX         3

#define MINASN1_RSA_PUBKEY_BLOB_CNT             4

LONG
WINAPI
MinAsn1ParseRSAPublicKey(
    IN PCRYPT_DER_BLOB pPubKeyContentBlob,
    CRYPT_DER_BLOB rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_BLOB_CNT]
    );


//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseExtensions
//
//  Parses an ASN.1 encoded sequence of extensions contained in 
//  other ASN.1 structures, such as, X.509 certificate and CTL.
//
//  Upon input, *pcExt contains the maximum number of parsed extensions
//  that can be returned. Updated with the number of extensions processed.
//
//  Returns:
//      success - >= 0 => bytes skipped, length of the encoded extensions
//                        processed. If all extensions were processed,
//                        bytes skipped = pExtsValueBlob->cbData.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgrgExtBlob[][] is updated with pointer to and length of the
//  following fields in the encoded extension.
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_EXT_ENCODED_IDX                 1

// Object Identifier content bytes (OID)
#define MINASN1_EXT_OID_IDX                     2

// Critical content bytes (OPTIONAL BOOLEAN, DEFAULT FALSE)
#define MINASN1_EXT_CRITICAL_IDX                3

// Value content bytes (OCTETSTRING)
#define MINASN1_EXT_VALUE_IDX                   4

#define MINASN1_EXT_BLOB_CNT                    5

LONG
WINAPI
MinAsn1ParseExtensions(
    IN PCRYPT_DER_BLOB pExtsValueBlob,  // Extensions ::= SEQUENCE OF Extension
    IN OUT DWORD *pcExt,
    OUT CRYPT_DER_BLOB rgrgExtBlob[][MINASN1_EXT_BLOB_CNT]
    );



//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseSignedData
//
//  Parses an ASN.1 encoded PKCS #7 Signed Data Message. Assumes the
//  PKCS #7 message is definite length encoded. Assumes PKCS #7 version
//  1.5, ie, not the newer CMS version.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded message
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgSignedDataBlob[] is updated with pointer to and length of the
//  following fields in the encoded PKCS #7 message.
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_SIGNED_DATA_ENCODED_IDX                             1

// Outer Object Identfier content bytes (OID, should be "1.2.840.113549.1.7.2")
#define MINASN1_SIGNED_DATA_OUTER_OID_IDX                           2

// Version content bytes (INTEGER)
#define MINASN1_SIGNED_DATA_VERSION_IDX                             3

// Set of Digest Algorithms value bytes (SET OF)
#define MINASN1_SIGNED_DATA_DIGEST_ALGIDS_IDX                       4

// Inner Object Identifier content bytes (OID)
#define MINASN1_SIGNED_DATA_CONTENT_OID_IDX                         5

// Signed content data content bytes excluding "[0] EXPLICIT" tag
// (OPTIONAL ANY, MinAsn1ParseCTL, MinAsn1ParseIndirectData)
#define MINASN1_SIGNED_DATA_CONTENT_DATA_IDX                        6

// Certificates value bytes including "[1] IMPLICIT" tag
// (OPTIONAL, MinAsn1ParseSignedDataCertificates)
#define MINASN1_SIGNED_DATA_CERTS_IDX                               7

// CRL value bytes including "[2] IMPLICIT" tag (OPTIONAL)
#define MINASN1_SIGNED_DATA_CRLS_IDX                                8

// Encoded bytes including outer SET tag and length octets
#define MINASN1_SIGNED_DATA_SIGNER_INFOS_IDX                        9

// The following point to the first Signer Info fields (OPTIONAL)

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_SIGNED_DATA_SIGNER_INFO_ENCODED_IDX                 10

// Version content bytes (INTEGER)
#define MINASN1_SIGNED_DATA_SIGNER_INFO_VERSION_IDX                 11

// Issuer Name value bytes (ANY)
#define MINASN1_SIGNED_DATA_SIGNER_INFO_ISSUER_IDX                  12

// Serial Number content bytes (INTEGER)
#define MINASN1_SIGNED_DATA_SIGNER_INFO_SERIAL_NUMBER_IDX           13

// Digest Algorithm value bytes (MinAsn1ParseAlgorithmIdentifier)
#define MINASN1_SIGNED_DATA_SIGNER_INFO_DIGEST_ALGID_IDX            14

// Authenticated attributes value bytes including "[0] IMPLICIT" tag
// (OPTIONAL, MinAsn1ParseAttributes)
#define MINASN1_SIGNED_DATA_SIGNER_INFO_AUTH_ATTRS_IDX              15

// Encrypted Digest Algorithm value bytes (MinAsn1ParseAlgorithmIdentifier)
#define MINASN1_SIGNED_DATA_SIGNER_INFO_ENCRYPT_DIGEST_ALGID_IDX    16

// Encrypted digest content bytes (OCTET STRING)
#define MINASN1_SIGNED_DATA_SIGNER_INFO_ENCYRPT_DIGEST_IDX          17

// Unauthenticated attributes value bytes including "[1] IMPLICIT" tag
// (OPTIONAL, MinAsn1ParseAttributes)
#define MINASN1_SIGNED_DATA_SIGNER_INFO_UNAUTH_ATTRS_IDX            18

#define MINASN1_SIGNED_DATA_BLOB_CNT                                19

LONG
WINAPI
MinAsn1ParseSignedData(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT CRYPT_DER_BLOB rgSignedDataBlob[MINASN1_SIGNED_DATA_BLOB_CNT]
    );



//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseSignedDataCertificates
//
//  Parses an ASN.1 encoded set of certificates contained in 
//  a Signed Data message.
//
//  Upon input, *pcCert contains the maximum number of parsed certificates
//  that can be returned. Updated with the number of certificates processed.
//
//  Returns:
//      success - >= 0 => bytes skipped, length of the encoded certificates
//                        processed. If all certificates were processed,
//                        bytes skipped = pCertsValueBlob->cbData.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgrgCertBlob[][] is updated with pointer to and length of the
//  fields in the encoded certificate. See MinAsn1ParseCertificate for the
//  field definitions.
//--------------------------------------------------------------------------

LONG
WINAPI
MinAsn1ParseSignedDataCertificates(
    IN PCRYPT_DER_BLOB pCertsValueBlob,
    IN OUT DWORD *pcCert,
    OUT CRYPT_DER_BLOB rgrgCertBlob[][MINASN1_CERT_BLOB_CNT]
    );


//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseAttributes
//
//  Parses an ASN.1 encoded sequence of attributes contained in 
//  other ASN.1 structures, such as, Signer Info authenticated or
//  unauthenticated attributes.
//
//  The outer tag is ignored. It can be a SET, [0] IMPLICIT, or [1] IMPLICIT.
//
//  Upon input, *pcAttr contains the maximum number of parsed attributes
//  that can be returned. Updated with the number of attributes processed.
//
//  Returns:
//      success - >= 0 => bytes skipped, length of the encoded attributes
//                        processed. If all attributes were processed,
//                        bytes skipped = pAttrsValueBlob->cbData.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgrgAttrBlob[][] is updated with pointer to and length of the
//  following fields in the encoded attribute.
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_ATTR_ENCODED_IDX                1

// Object Identifier content bytes (OID)
#define MINASN1_ATTR_OID_IDX                    2

// Values value bytes (SET OF)
#define MINASN1_ATTR_VALUES_IDX                 3

// First Value's value bytes (OPTIONAL ANY)
#define MINASN1_ATTR_VALUE_IDX                  4

#define MINASN1_ATTR_BLOB_CNT                   5

LONG
WINAPI
MinAsn1ParseAttributes(
    IN PCRYPT_DER_BLOB pAttrsValueBlob,
    IN OUT DWORD *pcAttr,
    OUT CRYPT_DER_BLOB rgrgAttrBlob[][MINASN1_ATTR_BLOB_CNT]
    );




//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseCTL
//
//  Parses an ASN.1 encoded Certificate Trust List (CTL). A CTL is always
//  contained as the inner content data in a PKCS #7 Signed Data. A CTL has
//  the following OID: "1.3.6.1.4.1.311.10.1".
//
//  A catalog file is formatted as a PKCS #7 Signed CTL.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded CTL
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgCTLBlob[] is updated with pointer to and length of the following
//  fields in the encoded CTL.
//
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_CTL_ENCODED_IDX                 1

// Version content bytes (OPTIONAL INTEGER)
#define MINASN1_CTL_VERSION_IDX                 2

// Subject usage value bytes (SEQUENCE OF OID)
#define MINASN1_CTL_SUBJECT_USAGE_IDX           3

// List Identifier content bytes (OPTIONAL OCTETSTRING)
#define MINASN1_CTL_LIST_ID_IDX                 4

// Sequence number content bytes (OPTIONAL INTEGER)
#define MINASN1_CTL_SEQUENCE_NUMBER_IDX         5

// This Update value bytes (UTC_TIME or GENERALIZED_TIME)
#define MINASN1_CTL_THIS_UPDATE_IDX             6

// Next Update value bytes (OPTIONAL UTC_TIME or GENERALIZED_TIME)
#define MINASN1_CTL_NEXT_UPDATE_IDX             7

// Subject Algorithm Identifier value bytes (MinAsn1ParseAlgorithmIdentifier)
#define MINASN1_CTL_SUBJECT_ALGID_IDX           8

// Subjects value bytes (OPTIONAL, iterative MinAsn1ParseCTLSubject)
#define MINASN1_CTL_SUBJECTS_IDX                9

// Extensions value bytes skipping "[0] EXPLICIT" tag
// (OPTIONAL, MinAsn1ParseExtensions)
#define MINASN1_CTL_EXTS_IDX                    10

#define MINASN1_CTL_BLOB_CNT                    11

LONG
WINAPI
MinAsn1ParseCTL(
    IN PCRYPT_DER_BLOB pEncodedContentBlob,
    OUT CRYPT_DER_BLOB rgCTLBlob[MINASN1_CTL_BLOB_CNT]
    );



//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseCTLSubject
//
//  Parses an ASN.1 encoded CTL Subject contained within a CTL's SEQUENCE OF
//  Subjects.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded subject.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgCTLSubjectBlob[][] is updated with pointer to and length of the
//  following fields in the encoded subject.
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_CTL_SUBJECT_ENCODED_IDX         1

// Subject Identifier content bytes (OCTETSTRING)
#define MINASN1_CTL_SUBJECT_ID_IDX              2

// Attributes value bytes (OPTIONAL, MinAsn1ParseAttributes)
#define MINASN1_CTL_SUBJECT_ATTRS_IDX           3

#define MINASN1_CTL_SUBJECT_BLOB_CNT            4

LONG
WINAPI
MinAsn1ParseCTLSubject(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT CRYPT_DER_BLOB rgCTLSubjectBlob[MINASN1_CTL_SUBJECT_BLOB_CNT]
    );



//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseIndirectData
//
//  Parses an ASN.1 encoded Indirect Data. Indirect Data is always
//  contained as the inner content data in a PKCS #7 Signed Data. It has
//  the following OID: "1.3.6.1.4.1.311.2.1.4"
//
//  An Authenticode signed file contains a PKCS #7 Signed Indirect Data.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded Indirect Data
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgIndirectDataBlob[] is updated with pointer to and length of the
//  following fields in the encoded Indirect Data.
//
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_INDIRECT_DATA_ENCODED_IDX       1

// Attribute Object Identifier content bytes (OID)
#define MINASN1_INDIRECT_DATA_ATTR_OID_IDX      2

// Attribute value bytes (OPTIONAL ANY)
#define MINASN1_INDIRECT_DATA_ATTR_VALUE_IDX    3

// Digest Algorithm Identifier (MinAsn1ParseAlgorithmIdentifier)
#define MINASN1_INDIRECT_DATA_DIGEST_ALGID_IDX  4

// Digest content bytes (OCTETSTRING)
#define MINASN1_INDIRECT_DATA_DIGEST_IDX        5

#define MINASN1_INDIRECT_DATA_BLOB_CNT          6

LONG
WINAPI
MinAsn1ParseIndirectData(
    IN PCRYPT_DER_BLOB pEncodedContentBlob,
    OUT CRYPT_DER_BLOB rgIndirectDataBlob[MINASN1_INDIRECT_DATA_BLOB_CNT]
    );




//+-------------------------------------------------------------------------
//  Find an extension identified by its Encoded Object Identifier.
//
//  Searches the list of parsed extensions returned by
//  MinAsn1ParseExtensions().
//
//  If found, returns pointer to the rgExtBlob[MINASN1_EXT_BLOB_CNT].
//  Otherwise, returns NULL.
//--------------------------------------------------------------------------
PCRYPT_DER_BLOB
WINAPI
MinAsn1FindExtension(
    IN PCRYPT_DER_BLOB pEncodedOIDBlob,
    IN DWORD cExt,
    IN CRYPT_DER_BLOB rgrgExtBlob[][MINASN1_EXT_BLOB_CNT]
    );


//+-------------------------------------------------------------------------
//  Find the first attribute identified by its Encoded Object Identifier.
//
//  Searches the list of parsed attributes returned by
//  MinAsn1ParseAttributes().
//
//  If found, returns pointer to the rgAttrBlob[MINASN1_ATTR_BLOB_CNT].
//  Otherwise, returns NULL.
//--------------------------------------------------------------------------
PCRYPT_DER_BLOB
WINAPI
MinAsn1FindAttribute(
    IN PCRYPT_DER_BLOB pEncodedOIDBlob,
    IN DWORD cAttr,
    IN CRYPT_DER_BLOB rgrgAttrBlob[][MINASN1_ATTR_BLOB_CNT]
    );

//+-------------------------------------------------------------------------
//  Parses an ASN.1 encoded PKCS #7 Signed Data Message to extract and
//  parse the X.509 certificates it contains.
//
//  Assumes the PKCS #7 message is definite length encoded.
//  Assumes PKCS #7 version 1.5, ie, not the newer CMS version.
//
//  Upon input, *pcCert contains the maximum number of parsed certificates
//  that can be returned. Updated with the number of certificates processed.
//
//  If the encoded message was successfully parsed, TRUE is returned
//  with *pcCert updated with the number of parsed certificates. Otherwise,
//  FALSE is returned for a parse error.
//  Returns:
//      success - >= 0 => bytes skipped, length of the encoded certificates
//                        processed.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//                        from beginning of message.
//
//  The rgrgCertBlob[][] is updated with pointer to and length of the
//  fields in the encoded certificate. See MinAsn1ParseCertificate for the
//  field definitions.
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ExtractParsedCertificatesFromSignedData(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN OUT DWORD *pcCert,
    OUT CRYPT_DER_BLOB rgrgCertBlob[][MINASN1_CERT_BLOB_CNT]
    );



#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#if defined (_MSC_VER)
#if ( _MSC_VER >= 800 )

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif

#endif
#endif

#endif // __MINASN1_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\mincrypt\vercert.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       vercert.cpp
//
//  Contents:   Minimal Cryptographic functions to verify ASN.1 encoded
//              X.509 certificates
//
//
//  Functions:  MinCryptVerifyCertificate
//
//  History:    17-Jan-01    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"

#define MAX_CHAIN_DEPTH             10

//+=========================================================================
//  Microsoft Roots
//-=========================================================================

// Name:: <CN=Microsoft Authenticode(tm) Root Authority, O=MSFT, C=US>
const BYTE rgbMicrosoftRoot0_Name[] = {
    0x30, 0x50, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03,
    0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31,
    0x0D, 0x30, 0x0B, 0x06, 0x03, 0x55, 0x04, 0x0A,
    0x13, 0x04, 0x4D, 0x53, 0x46, 0x54, 0x31, 0x32,
    0x30, 0x30, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13,
    0x29, 0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F,
    0x66, 0x74, 0x20, 0x41, 0x75, 0x74, 0x68, 0x65,
    0x6E, 0x74, 0x69, 0x63, 0x6F, 0x64, 0x65, 0x28,
    0x74, 0x6D, 0x29, 0x20, 0x52, 0x6F, 0x6F, 0x74,
    0x20, 0x41, 0x75, 0x74, 0x68, 0x6F, 0x72, 0x69,
    0x74, 0x79
};
const BYTE rgbMicrosoftRoot0_PubKeyInfo[]= {
    0x30, 0x82, 0x01, 0x22, 0x30, 0x0D, 0x06, 0x09,
    0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01,
    0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0F, 0x00,
    0x30, 0x82, 0x01, 0x0A, 0x02, 0x82, 0x01, 0x01,
    0x00, 0xDF, 0x08, 0xBA, 0xE3, 0x3F, 0x6E, 0x64,
    0x9B, 0xF5, 0x89, 0xAF, 0x28, 0x96, 0x4A, 0x07,
    0x8F, 0x1B, 0x2E, 0x8B, 0x3E, 0x1D, 0xFC, 0xB8,
    0x80, 0x69, 0xA3, 0xA1, 0xCE, 0xDB, 0xDF, 0xB0,
    0x8E, 0x6C, 0x89, 0x76, 0x29, 0x4F, 0xCA, 0x60,
    0x35, 0x39, 0xAD, 0x72, 0x32, 0xE0, 0x0B, 0xAE,
    0x29, 0x3D, 0x4C, 0x16, 0xD9, 0x4B, 0x3C, 0x9D,
    0xDA, 0xC5, 0xD3, 0xD1, 0x09, 0xC9, 0x2C, 0x6F,
    0xA6, 0xC2, 0x60, 0x53, 0x45, 0xDD, 0x4B, 0xD1,
    0x55, 0xCD, 0x03, 0x1C, 0xD2, 0x59, 0x56, 0x24,
    0xF3, 0xE5, 0x78, 0xD8, 0x07, 0xCC, 0xD8, 0xB3,
    0x1F, 0x90, 0x3F, 0xC0, 0x1A, 0x71, 0x50, 0x1D,
    0x2D, 0xA7, 0x12, 0x08, 0x6D, 0x7C, 0xB0, 0x86,
    0x6C, 0xC7, 0xBA, 0x85, 0x32, 0x07, 0xE1, 0x61,
    0x6F, 0xAF, 0x03, 0xC5, 0x6D, 0xE5, 0xD6, 0xA1,
    0x8F, 0x36, 0xF6, 0xC1, 0x0B, 0xD1, 0x3E, 0x69,
    0x97, 0x48, 0x72, 0xC9, 0x7F, 0xA4, 0xC8, 0xC2,
    0x4A, 0x4C, 0x7E, 0xA1, 0xD1, 0x94, 0xA6, 0xD7,
    0xDC, 0xEB, 0x05, 0x46, 0x2E, 0xB8, 0x18, 0xB4,
    0x57, 0x1D, 0x86, 0x49, 0xDB, 0x69, 0x4A, 0x2C,
    0x21, 0xF5, 0x5E, 0x0F, 0x54, 0x2D, 0x5A, 0x43,
    0xA9, 0x7A, 0x7E, 0x6A, 0x8E, 0x50, 0x4D, 0x25,
    0x57, 0xA1, 0xBF, 0x1B, 0x15, 0x05, 0x43, 0x7B,
    0x2C, 0x05, 0x8D, 0xBD, 0x3D, 0x03, 0x8C, 0x93,
    0x22, 0x7D, 0x63, 0xEA, 0x0A, 0x57, 0x05, 0x06,
    0x0A, 0xDB, 0x61, 0x98, 0x65, 0x2D, 0x47, 0x49,
    0xA8, 0xE7, 0xE6, 0x56, 0x75, 0x5C, 0xB8, 0x64,
    0x08, 0x63, 0xA9, 0x30, 0x40, 0x66, 0xB2, 0xF9,
    0xB6, 0xE3, 0x34, 0xE8, 0x67, 0x30, 0xE1, 0x43,
    0x0B, 0x87, 0xFF, 0xC9, 0xBE, 0x72, 0x10, 0x5E,
    0x23, 0xF0, 0x9B, 0xA7, 0x48, 0x65, 0xBF, 0x09,
    0x88, 0x7B, 0xCD, 0x72, 0xBC, 0x2E, 0x79, 0x9B,
    0x7B, 0x02, 0x03, 0x01, 0x00, 0x01
};


// Name:: <CN=Microsoft Root Authority, OU=Microsoft Corporation,
//         OU=Copyright (c) 1997 Microsoft Corp.>
const BYTE rgbMicrosoftRoot1_Name[]= {
    0x30, 0x70, 0x31, 0x2B, 0x30, 0x29, 0x06, 0x03,
    0x55, 0x04, 0x0B, 0x13, 0x22, 0x43, 0x6F, 0x70,
    0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x28,
    0x63, 0x29, 0x20, 0x31, 0x39, 0x39, 0x37, 0x20,
    0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66,
    0x74, 0x20, 0x43, 0x6F, 0x72, 0x70, 0x2E, 0x31,
    0x1E, 0x30, 0x1C, 0x06, 0x03, 0x55, 0x04, 0x0B,
    0x13, 0x15, 0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73,
    0x6F, 0x66, 0x74, 0x20, 0x43, 0x6F, 0x72, 0x70,
    0x6F, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x31,
    0x21, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x04, 0x03,
    0x13, 0x18, 0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73,
    0x6F, 0x66, 0x74, 0x20, 0x52, 0x6F, 0x6F, 0x74,
    0x20, 0x41, 0x75, 0x74, 0x68, 0x6F, 0x72, 0x69,
    0x74, 0x79
};

const BYTE rgbMicrosoftRoot1_PubKeyInfo[]= {
    0x30, 0x82, 0x01, 0x22, 0x30, 0x0D, 0x06, 0x09,
    0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01,
    0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0F, 0x00,
    0x30, 0x82, 0x01, 0x0A, 0x02, 0x82, 0x01, 0x01,
    0x00, 0xA9, 0x02, 0xBD, 0xC1, 0x70, 0xE6, 0x3B,
    0xF2, 0x4E, 0x1B, 0x28, 0x9F, 0x97, 0x78, 0x5E,
    0x30, 0xEA, 0xA2, 0xA9, 0x8D, 0x25, 0x5F, 0xF8,
    0xFE, 0x95, 0x4C, 0xA3, 0xB7, 0xFE, 0x9D, 0xA2,
    0x20, 0x3E, 0x7C, 0x51, 0xA2, 0x9B, 0xA2, 0x8F,
    0x60, 0x32, 0x6B, 0xD1, 0x42, 0x64, 0x79, 0xEE,
    0xAC, 0x76, 0xC9, 0x54, 0xDA, 0xF2, 0xEB, 0x9C,
    0x86, 0x1C, 0x8F, 0x9F, 0x84, 0x66, 0xB3, 0xC5,
    0x6B, 0x7A, 0x62, 0x23, 0xD6, 0x1D, 0x3C, 0xDE,
    0x0F, 0x01, 0x92, 0xE8, 0x96, 0xC4, 0xBF, 0x2D,
    0x66, 0x9A, 0x9A, 0x68, 0x26, 0x99, 0xD0, 0x3A,
    0x2C, 0xBF, 0x0C, 0xB5, 0x58, 0x26, 0xC1, 0x46,
    0xE7, 0x0A, 0x3E, 0x38, 0x96, 0x2C, 0xA9, 0x28,
    0x39, 0xA8, 0xEC, 0x49, 0x83, 0x42, 0xE3, 0x84,
    0x0F, 0xBB, 0x9A, 0x6C, 0x55, 0x61, 0xAC, 0x82,
    0x7C, 0xA1, 0x60, 0x2D, 0x77, 0x4C, 0xE9, 0x99,
    0xB4, 0x64, 0x3B, 0x9A, 0x50, 0x1C, 0x31, 0x08,
    0x24, 0x14, 0x9F, 0xA9, 0xE7, 0x91, 0x2B, 0x18,
    0xE6, 0x3D, 0x98, 0x63, 0x14, 0x60, 0x58, 0x05,
    0x65, 0x9F, 0x1D, 0x37, 0x52, 0x87, 0xF7, 0xA7,
    0xEF, 0x94, 0x02, 0xC6, 0x1B, 0xD3, 0xBF, 0x55,
    0x45, 0xB3, 0x89, 0x80, 0xBF, 0x3A, 0xEC, 0x54,
    0x94, 0x4E, 0xAE, 0xFD, 0xA7, 0x7A, 0x6D, 0x74,
    0x4E, 0xAF, 0x18, 0xCC, 0x96, 0x09, 0x28, 0x21,
    0x00, 0x57, 0x90, 0x60, 0x69, 0x37, 0xBB, 0x4B,
    0x12, 0x07, 0x3C, 0x56, 0xFF, 0x5B, 0xFB, 0xA4,
    0x66, 0x0A, 0x08, 0xA6, 0xD2, 0x81, 0x56, 0x57,
    0xEF, 0xB6, 0x3B, 0x5E, 0x16, 0x81, 0x77, 0x04,
    0xDA, 0xF6, 0xBE, 0xAE, 0x80, 0x95, 0xFE, 0xB0,
    0xCD, 0x7F, 0xD6, 0xA7, 0x1A, 0x72, 0x5C, 0x3C,
    0xCA, 0xBC, 0xF0, 0x08, 0xA3, 0x22, 0x30, 0xB3,
    0x06, 0x85, 0xC9, 0xB3, 0x20, 0x77, 0x13, 0x85,
    0xDF, 0x02, 0x03, 0x01, 0x00, 0x01
};


// 4096 bit key generated in 2001
//
// Name:: <CN=Microsoft Root Certificate Authority, DC=microsoft, DC=com>
const BYTE rgbMicrosoftRoot2_Name[]= {
    0x30, 0x5F, 0x31, 0x13, 0x30, 0x11, 0x06, 0x0A,
    0x09, 0x92, 0x26, 0x89, 0x93, 0xF2, 0x2C, 0x64,
    0x01, 0x19, 0x16, 0x03, 0x63, 0x6F, 0x6D, 0x31,
    0x19, 0x30, 0x17, 0x06, 0x0A, 0x09, 0x92, 0x26,
    0x89, 0x93, 0xF2, 0x2C, 0x64, 0x01, 0x19, 0x16,
    0x09, 0x6D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F,
    0x66, 0x74, 0x31, 0x2D, 0x30, 0x2B, 0x06, 0x03,
    0x55, 0x04, 0x03, 0x13, 0x24, 0x4D, 0x69, 0x63,
    0x72, 0x6F, 0x73, 0x6F, 0x66, 0x74, 0x20, 0x52,
    0x6F, 0x6F, 0x74, 0x20, 0x43, 0x65, 0x72, 0x74,
    0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20,
    0x41, 0x75, 0x74, 0x68, 0x6F, 0x72, 0x69, 0x74,
    0x79
};
const BYTE rgbMicrosoftRoot2_PubKeyInfo[]= {
    0x30, 0x82, 0x02, 0x22, 0x30, 0x0D, 0x06, 0x09,
    0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01,
    0x01, 0x05, 0x00, 0x03, 0x82, 0x02, 0x0F, 0x00,
    0x30, 0x82, 0x02, 0x0A, 0x02, 0x82, 0x02, 0x01,
    0x00, 0xF3, 0x5D, 0xFA, 0x80, 0x67, 0xD4, 0x5A,
    0xA7, 0xA9, 0x0C, 0x2C, 0x90, 0x20, 0xD0, 0x35,
    0x08, 0x3C, 0x75, 0x84, 0xCD, 0xB7, 0x07, 0x89,
    0x9C, 0x89, 0xDA, 0xDE, 0xCE, 0xC3, 0x60, 0xFA,
    0x91, 0x68, 0x5A, 0x9E, 0x94, 0x71, 0x29, 0x18,
    0x76, 0x7C, 0xC2, 0xE0, 0xC8, 0x25, 0x76, 0x94,
    0x0E, 0x58, 0xFA, 0x04, 0x34, 0x36, 0xE6, 0xDF,
    0xAF, 0xF7, 0x80, 0xBA, 0xE9, 0x58, 0x0B, 0x2B,
    0x93, 0xE5, 0x9D, 0x05, 0xE3, 0x77, 0x22, 0x91,
    0xF7, 0x34, 0x64, 0x3C, 0x22, 0x91, 0x1D, 0x5E,
    0xE1, 0x09, 0x90, 0xBC, 0x14, 0xFE, 0xFC, 0x75,
    0x58, 0x19, 0xE1, 0x79, 0xB7, 0x07, 0x92, 0xA3,
    0xAE, 0x88, 0x59, 0x08, 0xD8, 0x9F, 0x07, 0xCA,
    0x03, 0x58, 0xFC, 0x68, 0x29, 0x6D, 0x32, 0xD7,
    0xD2, 0xA8, 0xCB, 0x4B, 0xFC, 0xE1, 0x0B, 0x48,
    0x32, 0x4F, 0xE6, 0xEB, 0xB8, 0xAD, 0x4F, 0xE4,
    0x5C, 0x6F, 0x13, 0x94, 0x99, 0xDB, 0x95, 0xD5,
    0x75, 0xDB, 0xA8, 0x1A, 0xB7, 0x94, 0x91, 0xB4,
    0x77, 0x5B, 0xF5, 0x48, 0x0C, 0x8F, 0x6A, 0x79,
    0x7D, 0x14, 0x70, 0x04, 0x7D, 0x6D, 0xAF, 0x90,
    0xF5, 0xDA, 0x70, 0xD8, 0x47, 0xB7, 0xBF, 0x9B,
    0x2F, 0x6C, 0xE7, 0x05, 0xB7, 0xE1, 0x11, 0x60,
    0xAC, 0x79, 0x91, 0x14, 0x7C, 0xC5, 0xD6, 0xA6,
    0xE4, 0xE1, 0x7E, 0xD5, 0xC3, 0x7E, 0xE5, 0x92,
    0xD2, 0x3C, 0x00, 0xB5, 0x36, 0x82, 0xDE, 0x79,
    0xE1, 0x6D, 0xF3, 0xB5, 0x6E, 0xF8, 0x9F, 0x33,
    0xC9, 0xCB, 0x52, 0x7D, 0x73, 0x98, 0x36, 0xDB,
    0x8B, 0xA1, 0x6B, 0xA2, 0x95, 0x97, 0x9B, 0xA3,
    0xDE, 0xC2, 0x4D, 0x26, 0xFF, 0x06, 0x96, 0x67,
    0x25, 0x06, 0xC8, 0xE7, 0xAC, 0xE4, 0xEE, 0x12,
    0x33, 0x95, 0x31, 0x99, 0xC8, 0x35, 0x08, 0x4E,
    0x34, 0xCA, 0x79, 0x53, 0xD5, 0xB5, 0xBE, 0x63,
    0x32, 0x59, 0x40, 0x36, 0xC0, 0xA5, 0x4E, 0x04,
    0x4D, 0x3D, 0xDB, 0x5B, 0x07, 0x33, 0xE4, 0x58,
    0xBF, 0xEF, 0x3F, 0x53, 0x64, 0xD8, 0x42, 0x59,
    0x35, 0x57, 0xFD, 0x0F, 0x45, 0x7C, 0x24, 0x04,
    0x4D, 0x9E, 0xD6, 0x38, 0x74, 0x11, 0x97, 0x22,
    0x90, 0xCE, 0x68, 0x44, 0x74, 0x92, 0x6F, 0xD5,
    0x4B, 0x6F, 0xB0, 0x86, 0xE3, 0xC7, 0x36, 0x42,
    0xA0, 0xD0, 0xFC, 0xC1, 0xC0, 0x5A, 0xF9, 0xA3,
    0x61, 0xB9, 0x30, 0x47, 0x71, 0x96, 0x0A, 0x16,
    0xB0, 0x91, 0xC0, 0x42, 0x95, 0xEF, 0x10, 0x7F,
    0x28, 0x6A, 0xE3, 0x2A, 0x1F, 0xB1, 0xE4, 0xCD,
    0x03, 0x3F, 0x77, 0x71, 0x04, 0xC7, 0x20, 0xFC,
    0x49, 0x0F, 0x1D, 0x45, 0x88, 0xA4, 0xD7, 0xCB,
    0x7E, 0x88, 0xAD, 0x8E, 0x2D, 0xEC, 0x45, 0xDB,
    0xC4, 0x51, 0x04, 0xC9, 0x2A, 0xFC, 0xEC, 0x86,
    0x9E, 0x9A, 0x11, 0x97, 0x5B, 0xDE, 0xCE, 0x53,
    0x88, 0xE6, 0xE2, 0xB7, 0xFD, 0xAC, 0x95, 0xC2,
    0x28, 0x40, 0xDB, 0xEF, 0x04, 0x90, 0xDF, 0x81,
    0x33, 0x39, 0xD9, 0xB2, 0x45, 0xA5, 0x23, 0x87,
    0x06, 0xA5, 0x55, 0x89, 0x31, 0xBB, 0x06, 0x2D,
    0x60, 0x0E, 0x41, 0x18, 0x7D, 0x1F, 0x2E, 0xB5,
    0x97, 0xCB, 0x11, 0xEB, 0x15, 0xD5, 0x24, 0xA5,
    0x94, 0xEF, 0x15, 0x14, 0x89, 0xFD, 0x4B, 0x73,
    0xFA, 0x32, 0x5B, 0xFC, 0xD1, 0x33, 0x00, 0xF9,
    0x59, 0x62, 0x70, 0x07, 0x32, 0xEA, 0x2E, 0xAB,
    0x40, 0x2D, 0x7B, 0xCA, 0xDD, 0x21, 0x67, 0x1B,
    0x30, 0x99, 0x8F, 0x16, 0xAA, 0x23, 0xA8, 0x41,
    0xD1, 0xB0, 0x6E, 0x11, 0x9B, 0x36, 0xC4, 0xDE,
    0x40, 0x74, 0x9C, 0xE1, 0x58, 0x65, 0xC1, 0x60,
    0x1E, 0x7A, 0x5B, 0x38, 0xC8, 0x8F, 0xBB, 0x04,
    0x26, 0x7C, 0xD4, 0x16, 0x40, 0xE5, 0xB6, 0x6B,
    0x6C, 0xAA, 0x86, 0xFD, 0x00, 0xBF, 0xCE, 0xC1,
    0x35, 0x02, 0x03, 0x01, 0x00, 0x01
};



//+=========================================================================
//  Test Roots
//-=========================================================================

// Name:: <CN=Microsoft Test Root Authority, OU=Microsoft Corporation, OU=Copyright (c) 1999 Microsoft Corp.>
const BYTE rgbTestRoot0_Name[] = {
    0x30, 0x75, 0x31, 0x2B, 0x30, 0x29, 0x06, 0x03,
    0x55, 0x04, 0x0B, 0x13, 0x22, 0x43, 0x6F, 0x70,
    0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x28,
    0x63, 0x29, 0x20, 0x31, 0x39, 0x39, 0x39, 0x20,
    0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66,
    0x74, 0x20, 0x43, 0x6F, 0x72, 0x70, 0x2E, 0x31,
    0x1E, 0x30, 0x1C, 0x06, 0x03, 0x55, 0x04, 0x0B,
    0x13, 0x15, 0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73,
    0x6F, 0x66, 0x74, 0x20, 0x43, 0x6F, 0x72, 0x70,
    0x6F, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x31,
    0x26, 0x30, 0x24, 0x06, 0x03, 0x55, 0x04, 0x03,
    0x13, 0x1D, 0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73,
    0x6F, 0x66, 0x74, 0x20, 0x54, 0x65, 0x73, 0x74,
    0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x41, 0x75,
    0x74, 0x68, 0x6F, 0x72, 0x69, 0x74, 0x79
};

const BYTE rgbTestRoot0_PubKeyInfo[]= {
    0x30, 0x81, 0xDF, 0x30, 0x0D, 0x06, 0x09, 0x2A,
    0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01,
    0x05, 0x00, 0x03, 0x81, 0xCD, 0x00, 0x30, 0x81,
    0xC9, 0x02, 0x81, 0xC1, 0x00, 0xA9, 0xAA, 0x83,
    0x58, 0x6D, 0xB5, 0xD3, 0x0C, 0x4B, 0x5B, 0x80,
    0x90, 0xE5, 0xC3, 0x0F, 0x28, 0x0C, 0x7E, 0x3D,
    0x3C, 0x24, 0xC5, 0x29, 0x56, 0x63, 0x8C, 0xEE,
    0xC7, 0x83, 0x4A, 0xD8, 0x8C, 0x25, 0xD3, 0x0E,
    0xD3, 0x12, 0xB7, 0xE1, 0x86, 0x72, 0x74, 0xA7,
    0x8B, 0xFB, 0x0F, 0x05, 0xE9, 0x65, 0xC1, 0x9B,
    0xD8, 0x56, 0xC2, 0x93, 0xF0, 0xFB, 0xE9, 0x5A,
    0x48, 0x85, 0x7D, 0x95, 0xAA, 0xDF, 0x01, 0x86,
    0xB7, 0x33, 0x33, 0x46, 0x56, 0xCB, 0x5B, 0x7A,
    0xC4, 0xAF, 0xA0, 0x96, 0x53, 0x3A, 0xE9, 0xFB,
    0x3B, 0x78, 0xC1, 0x43, 0x0C, 0xC7, 0x6E, 0x1C,
    0x2F, 0xD1, 0x55, 0xF1, 0x19, 0xB2, 0x3F, 0xF8,
    0xD6, 0xA0, 0xC7, 0x24, 0x95, 0x3B, 0xC8, 0x45,
    0x25, 0x6F, 0x45, 0x3A, 0x46, 0x4F, 0xD2, 0x27,
    0x8B, 0xC7, 0x50, 0x75, 0xC6, 0x80, 0x5E, 0x0D,
    0x99, 0x78, 0x61, 0x77, 0x39, 0xC1, 0xB3, 0x0F,
    0x9D, 0x12, 0x9C, 0xC4, 0xBB, 0x32, 0x7B, 0xB2,
    0x4B, 0x26, 0xAA, 0x4E, 0xC0, 0x32, 0xB0, 0x2A,
    0x13, 0x21, 0xBE, 0xED, 0x24, 0xF4, 0x7D, 0x0D,
    0xEA, 0xAA, 0x8A, 0x7A, 0xD2, 0x8B, 0x4D, 0x97,
    0xB5, 0x4D, 0x64, 0xBA, 0xFB, 0x46, 0xDD, 0x69,
    0x6F, 0x9A, 0x0E, 0xCC, 0x53, 0x77, 0xAA, 0x6E,
    0xAE, 0x20, 0xD6, 0x21, 0x98, 0x69, 0xD9, 0x46,
    0xB9, 0x64, 0x32, 0xD4, 0x17, 0x02, 0x03, 0x01,
    0x00, 0x01
};


typedef struct _ROOT_INFO {
    CRYPT_DER_BLOB  EncodedName;
    CRYPT_DER_BLOB  EncodedPubKeyInfo;
    BOOL fTestRoot;
} ROOT_INFO, *PROOT_INFO;

const ROOT_INFO RootTable[] = {
    sizeof(rgbMicrosoftRoot0_Name), (BYTE *) rgbMicrosoftRoot0_Name,
    sizeof(rgbMicrosoftRoot0_PubKeyInfo), (BYTE *) rgbMicrosoftRoot0_PubKeyInfo,
    FALSE,

    sizeof(rgbMicrosoftRoot1_Name), (BYTE *) rgbMicrosoftRoot1_Name,
    sizeof(rgbMicrosoftRoot1_PubKeyInfo), (BYTE *) rgbMicrosoftRoot1_PubKeyInfo,
    FALSE,

    sizeof(rgbMicrosoftRoot2_Name), (BYTE *) rgbMicrosoftRoot2_Name,
    sizeof(rgbMicrosoftRoot2_PubKeyInfo), (BYTE *) rgbMicrosoftRoot2_PubKeyInfo,
    FALSE,

    sizeof(rgbTestRoot0_Name), (BYTE *) rgbTestRoot0_Name,
    sizeof(rgbTestRoot0_PubKeyInfo), (BYTE *) rgbTestRoot0_PubKeyInfo,
    TRUE
};
#define ROOT_CNT (sizeof(RootTable) / sizeof(RootTable[0]))

#define wszSETUP_REG \
    L"System\\Setup"
#define wszSYSTEM_SETUP_REG_VALUE \
    L"SystemSetupInProgress"
#define wszTEST_ROOT_REG \
    L"SOFTWARE\\Microsoft\\SystemCertificates\\Root\\Certificates\\2BD63D28D7BCD0E251195AEB519243C13142EBC3"

// Check the CERT_STORE_PROV_SYSTEM_REGISTRY store for the Test Root.
//
// If the Test Root is found, return ERROR_SUCCESS.
// If the Test Root is not found but we're in NT GUI-mode setup,
// return ERROR_SUCCESS.  
// If the Test Root is not found and we're not in setup,
// return CERT_E_UNTRUSTEDROOT.
// For any other error, return the provided error code.
DWORD
WINAPI
I_CheckIsTestRootAllowed(void)
{
    DWORD dwReturn;
    HKEY hTestRootKey = 0;
    HKEY hSetupKey = 0;
    DWORD cb = 0;
    BOOL fSystemSetupInProgress = FALSE;

    dwReturn = RegOpenKeyExW(
        HKEY_LOCAL_MACHINE,
        wszTEST_ROOT_REG,
        0, KEY_READ, &hTestRootKey);

    if (ERROR_SUCCESS != dwReturn)
    {
        //
        // We've determined that the Test
        // Root isn't installed.  Check if we're in NT GUI-mode
        // setup right now.  
        //
        // If we're in setup, we need to allow the Test Root
        // (but *only* for an otherwise valid signature)
        // since we may have been called before 
        // setup has had a chance to install the Test Root.
        //

        dwReturn = RegOpenKeyExW(
            HKEY_LOCAL_MACHINE,
            wszSETUP_REG,
            0, KEY_READ, &hSetupKey);
    
        if (ERROR_SUCCESS != dwReturn)
            goto Ret;
    
        cb = sizeof(fSystemSetupInProgress);
        dwReturn = RegQueryValueExW(
            hSetupKey,
            wszSYSTEM_SETUP_REG_VALUE,
            NULL,
            NULL,
            (PBYTE) &fSystemSetupInProgress,
            &cb);
    
        if (ERROR_SUCCESS != dwReturn)
            goto Ret;
    
        if (FALSE == fSystemSetupInProgress)
            dwReturn = CERT_E_UNTRUSTEDROOT;
    }
    
Ret:
    if (hTestRootKey)
        RegCloseKey(hTestRootKey);
    if (hSetupKey)
        RegCloseKey(hSetupKey);

    return dwReturn;
}

// If found, returns ERROR_SUCCESS and sets *ppRootBlob to the PubKeyInfo blob. 
// Otherwise, returns appropriate error code and set *ppRootBlob to NULL.
DWORD
WINAPI
I_MinCryptFindRootByName(
    IN PCRYPT_DER_BLOB pIssuerNameValueBlob,
    OUT PCRYPT_DER_BLOB *ppRootBlob
    )
{
    DWORD i;
    DWORD dwStatus;
    BOOL fInGuiModeSetup = FALSE;

    *ppRootBlob = NULL;
    
    for (i = 0; i < ROOT_CNT; i++) {
        if (pIssuerNameValueBlob->cbData == RootTable[i].EncodedName.cbData &&
                0 == memcmp(pIssuerNameValueBlob->pbData,
                        RootTable[i].EncodedName.pbData,
                        pIssuerNameValueBlob->cbData))
        {
            if (RootTable[i].fTestRoot)
            {
                dwStatus = I_CheckIsTestRootAllowed();

                if (ERROR_SUCCESS != dwStatus)
                    return dwStatus;
            }
            
            *ppRootBlob  = (PCRYPT_DER_BLOB) &RootTable[i].EncodedPubKeyInfo;
            return ERROR_SUCCESS;
        }
    }

    return CERT_E_UNTRUSTEDROOT;
}

// If found, returns ERROR_SUCCESS and sets *ppRootBlob to the PubKeyInfo blob. 
// Otherwise, returns appropriate error code and set *ppRootBlob to NULL.
DWORD
WINAPI
I_MinCryptFindRootByKey(
    IN PCRYPT_DER_BLOB pSubjectPubKeyInfoBlob,
    OUT PCRYPT_DER_BLOB *ppRootBlob
    )
{
    DWORD i;
    DWORD dwStatus;

    *ppRootBlob = NULL;
    
    for (i = 0; i < ROOT_CNT; i++) {
        if (pSubjectPubKeyInfoBlob->cbData ==
                RootTable[i].EncodedPubKeyInfo.cbData
                                &&
                0 == memcmp(pSubjectPubKeyInfoBlob->pbData,
                        RootTable[i].EncodedPubKeyInfo.pbData,
                        pSubjectPubKeyInfoBlob->cbData))
        {
            if (RootTable[i].fTestRoot)
            {
                dwStatus = I_CheckIsTestRootAllowed();

                if (ERROR_SUCCESS != dwStatus)
                    return dwStatus;
            }
            
            *ppRootBlob  = (PCRYPT_DER_BLOB) &RootTable[i].EncodedPubKeyInfo;
            return ERROR_SUCCESS;
        }
    }

    return CERT_E_UNTRUSTEDROOT;
}



// If found, returns pointer to rgCertBlob[MINASN1_CERT_BLOB_CNT].
// Otherwise, returns NULL.
PCRYPT_DER_BLOB
WINAPI
I_MinCryptFindIssuerCertificateByName(
    IN PCRYPT_DER_BLOB pIssuerNameValueBlob,
    IN DWORD cCert,
    IN CRYPT_DER_BLOB rgrgCertBlob[][MINASN1_CERT_BLOB_CNT]
    )
{
    DWORD i;
    DWORD cbName = pIssuerNameValueBlob->cbData;
    const BYTE *pbName = pIssuerNameValueBlob->pbData;

    if (0 == cbName)
        return NULL;
    
    for (i = 0; i < cCert; i++) {
        if (cbName == rgrgCertBlob[i][MINASN1_CERT_SUBJECT_IDX].cbData &&
                0 == memcmp(pbName,
                        rgrgCertBlob[i][MINASN1_CERT_SUBJECT_IDX].pbData,
                        cbName))
            return rgrgCertBlob[i];
    }

    return NULL;
}


//+-------------------------------------------------------------------------
//  Verifies a previously parsed X.509 Certificate.
//
//  Assumes the ASN.1 encoded X.509 certificate was parsed via
//  MinAsn1ParseCertificate() and the set of potential issuer certificates
//  were parsed via one or more of:
//   - MinAsn1ParseCertificate()
//   - MinAsn1ParseSignedDataCertificates()
//   - MinAsn1ExtractParsedCertificatesFromSignedData()
//
//  Iteratively finds the issuer certificate via its encoded name. The
//  public key in the issuer certificate is used to verify the subject
//  certificate's signature. This is repeated until finding a self signed
//  certificate or a baked in root identified by its encoded name.
//  For a self signed certificate, compares against the baked in root
//  public keys.
//
//  If the certificate and its issuers were successfully verified to a
//  baked in root, ERROR_SUCCESS is returned.  Otherwise, a nonzero error
//  code is returned.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptVerifyCertificate(
    IN CRYPT_DER_BLOB rgSubjectCertBlob[MINASN1_CERT_BLOB_CNT],
    IN DWORD cIssuerCert,
    IN CRYPT_DER_BLOB rgrgIssuerCertBlob[][MINASN1_CERT_BLOB_CNT]
    )
{
    LONG lErr;
    DWORD dwChainDepth = 0;
    PCRYPT_DER_BLOB rgSubject;
    BOOL fRoot = FALSE;

    rgSubject = rgSubjectCertBlob;
    while (!fRoot) {
        ALG_ID HashAlgId;
        BYTE rgbHash[MINCRYPT_MAX_HASH_LEN];
        DWORD cbHash;

        PCRYPT_DER_BLOB rgIssuer = NULL;
        PCRYPT_DER_BLOB pIssuerPubKeyInfo = NULL;

        // Hash the Subject's ToBeSigned bytes
        HashAlgId = MinCryptDecodeHashAlgorithmIdentifier(
            &rgSubject[MINASN1_CERT_SIGN_ALGID_IDX]);
        if (0 == HashAlgId)
            goto UnknownHashAlgId;
        lErr = MinCryptHashMemory(
            HashAlgId,
            1,                  // cBlob,
            &rgSubject[MINASN1_CERT_TO_BE_SIGNED_IDX],
            rgbHash,
            &cbHash
            );
        if (ERROR_SUCCESS != lErr)
            goto ErrorReturn;

        // Get the public key to decrypt the signature

        // Check if SelfSigned
        if (rgSubject[MINASN1_CERT_ISSUER_IDX].cbData ==
                rgSubject[MINASN1_CERT_SUBJECT_IDX].cbData
                                &&
                0 == memcmp(rgSubject[MINASN1_CERT_ISSUER_IDX].pbData,
                        rgSubject[MINASN1_CERT_SUBJECT_IDX].pbData,
                        rgSubject[MINASN1_CERT_ISSUER_IDX].cbData)) {
            lErr = I_MinCryptFindRootByKey(
                &rgSubject[MINASN1_CERT_PUBKEY_INFO_IDX],
                &pIssuerPubKeyInfo);
            if (NULL == pIssuerPubKeyInfo)
                goto ErrorReturn;
            fRoot = TRUE;
        } else {
            // Check if the issuer is a root
            lErr = I_MinCryptFindRootByName(
                &rgSubject[MINASN1_CERT_ISSUER_IDX],
                &pIssuerPubKeyInfo);
            if (pIssuerPubKeyInfo)
                fRoot = TRUE;
            else {
                // If some other error code is set, then some
                // sort of unexpected system error occurred
                // and we should bail.
                if (CERT_E_UNTRUSTEDROOT != lErr)
                    goto ErrorReturn;
                
                // Try to find the issuer from the input set of
                // certificates
                rgIssuer = I_MinCryptFindIssuerCertificateByName(
                    &rgSubject[MINASN1_CERT_ISSUER_IDX],
                    cIssuerCert,
                    rgrgIssuerCertBlob
                    );
                if (NULL == rgIssuer)
                    goto PartialChain;

                pIssuerPubKeyInfo = &rgIssuer[MINASN1_CERT_PUBKEY_INFO_IDX];
            }
        }

        // Use the issuer or root's public key to decrypt and verify
        // the signature.
        lErr = MinCryptVerifySignedHash(
            HashAlgId,
            rgbHash,
            cbHash,
            &rgSubject[MINASN1_CERT_SIGNATURE_IDX],
            pIssuerPubKeyInfo
            );
        if (ERROR_SUCCESS != lErr)
            goto ErrorReturn;

        if (!fRoot) {
            assert(rgIssuer);
            dwChainDepth++;
            if (MAX_CHAIN_DEPTH < dwChainDepth)
                goto CyclicChain;
            rgSubject = rgIssuer;
        }
    }


    lErr = ERROR_SUCCESS;

ErrorReturn:
CommonReturn:
    return lErr;

UnknownHashAlgId:
    lErr = CRYPT_E_UNKNOWN_ALGO;
    goto CommonReturn;
CyclicChain:
PartialChain:
    lErr = CERT_E_CHAINING;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\mincrypt\mincrypt.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       mincrypt.h
//
//  Contents:   Minimal Cryptographic API Prototypes and Definitions
//
//              Contains cryptographic functions to verify PKCS #7 Signed Data
//              messages, X.509 certificate chains, Authenticode signed
//              files and file hashes in system catalogs.
//
//              These APIs rely on the APIs defined in minasn1.h for doing
//              the low level ASN.1 parsing.
//
//              These APIs are implemented to be self contained and to
//              allow for code obfuscation. These APIs will be included
//              in such applications as, DRM or licensing verification.
//
//              If the file name or file handle option is selected,
//              the following APIs will need to call the kernel32.dll APIs
//              to open, map and unmap files:
//                  MinCryptHashFile
//                  MinCryptVerifySignedFile
//              The following API will need to call kernel32.dll and
//              wintrust.dll APIs to find, open, map and unmap files:
//                  MinCryptVerifyHashInSystemCatalogs
//              Except for the calls in the above APIs,
//              no calls to APIs in other DLLs.
//
//              Additionally, since these APIs have been pared down
//              from their wincrypt.h and crypt32.dll counterparts they are
//              a good candidate for applications with minimal memory and CPU
//              resources.
//
//  APIs: 
//              MinCryptDecodeHashAlgorithmIdentifier
//              MinCryptHashMemory
//              MinCryptVerifySignedHash
//              MinCryptVerifyCertificate
//              MinCryptVerifySignedData
//              MinCryptHashFile
//              MinCryptVerifySignedFile
//              MinCryptVerifyHashInSystemCatalogs
//
//----------------------------------------------------------------------------

#ifndef __MINCRYPT_H__
#define __MINCRYPT_H__


#if defined (_MSC_VER)

#if ( _MSC_VER >= 800 )
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)    /* Nameless struct/union */
#endif

#if (_MSC_VER > 1020)
#pragma once
#endif

#endif


#include <wincrypt.h>
#include <minasn1.h>

#ifdef __cplusplus
extern "C" {
#endif



#define MINCRYPT_MAX_HASH_LEN               20
#define MINCRYPT_SHA1_HASH_LEN              20
#define MINCRYPT_MD5_HASH_LEN               16
#define MINCRYPT_MD2_HASH_LEN               16


//+-------------------------------------------------------------------------
//  Release any global resources consumed by the mincrypt
//  library.  This should be called during DLL_PROCESS_DETACH
//  since a critical section has possibly been created.
//
//  Currently, the global state (and its critical section) is 
//  initialized only on-demand for systems that make use of the
//  Microsoft Test Root Certificate.  
//--------------------------------------------------------------------------
/*
DWORD
WINAPI
MinCryptUninitialize(void);
*/


//+-------------------------------------------------------------------------
//  Decodes an ASN.1 encoded Algorithm Identifier and converts to
//  a CAPI Hash AlgID, such as, CALG_SHA1 or CALG_MD5.
//
//  Returns 0 if there isn't a CAPI AlgId corresponding to the Algorithm
//  Identifier.
//
//  Only CALG_SHA1, CALG_MD5 and CALG_MD2 are supported.
//--------------------------------------------------------------------------
ALG_ID
WINAPI
MinCryptDecodeHashAlgorithmIdentifier(
    IN PCRYPT_DER_BLOB pAlgIdValueBlob
    );

//+-------------------------------------------------------------------------
//  Hashes one or more memory blobs according to the Hash ALG_ID.
//
//  rgbHash is updated with the resultant hash. *pcbHash is updated with
//  the length associated with the hash algorithm.
//
//  If the function succeeds, the return value is ERROR_SUCCESS. Otherwise,
//  a nonzero error code is returned.
//
//  Only CALG_SHA1, CALG_MD5 and CALG_MD2 are supported.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptHashMemory(
    IN ALG_ID HashAlgId,
    IN DWORD cBlob,
    IN PCRYPT_DER_BLOB rgBlob,
    OUT BYTE rgbHash[MINCRYPT_MAX_HASH_LEN],
    OUT DWORD *pcbHash
    );


//+-------------------------------------------------------------------------
//  Verifies a signed hash.
//
//  The ASN.1 encoded Public Key Info is parsed and used to decrypt the
//  signed hash. The decrypted signed hash is compared with the input
//  hash.
//
//  If the signed hash was successfully verified, ERROR_SUCCESS is returned.
//  Otherwise, a nonzero error code is returned.
//
//  Only RSA signatures are supported.
//
//  Only MD2, MD5 and SHA1 hashes are supported.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptVerifySignedHash(
    IN ALG_ID HashAlgId,
    IN BYTE *pbHash,
    IN DWORD cbHash,
    IN PCRYPT_DER_BLOB pSignedHashContentBlob,
    IN PCRYPT_DER_BLOB pPubKeyInfoValueBlob
    );



//+-------------------------------------------------------------------------
//  Verifies a previously parsed X.509 Certificate.
//
//  Assumes the ASN.1 encoded X.509 certificate was parsed via
//  MinAsn1ParseCertificate() and the set of potential issuer certificates
//  were parsed via one or more of:
//   - MinAsn1ParseCertificate()
//   - MinAsn1ParseSignedDataCertificates()
//   - MinAsn1ExtractParsedCertificatesFromSignedData()
//
//  Iteratively finds the issuer certificate via its encoded name. The
//  public key in the issuer certificate is used to verify the subject
//  certificate's signature. This is repeated until finding a self signed
//  certificate or a baked in root identified by its encoded name.
//  For a self signed certificate, compares against the baked in root
//  public keys.
//
//  If the certificate and its issuers were successfully verified to a
//  baked in root, ERROR_SUCCESS is returned.  Otherwise, a nonzero error
//  code is returned.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptVerifyCertificate(
    IN CRYPT_DER_BLOB rgSubjectCertBlob[MINASN1_CERT_BLOB_CNT],
    IN DWORD cIssuerCert,
    IN CRYPT_DER_BLOB rgrgIssuerCertBlob[][MINASN1_CERT_BLOB_CNT]
    );



//+-------------------------------------------------------------------------
//  Function: MinCryptVerifySignedData
//
//  Verifies an ASN.1 encoded PKCS #7 Signed Data Message.
//
//  Assumes the PKCS #7 message is definite length encoded.
//  Assumes PKCS #7 version 1.5, ie, not the newer CMS version.
//  We only look at the first signer.
//
//  The Signed Data message is parsed. Its signature is verified. Its
//  signer certificate chain is verified to a baked in root public key.
//
//  If the Signed Data was successfully verified, ERROR_SUCCESS is returned.
//  Otherwise, a nonzero error code is returned.
//
//  Here are some interesting errors that can be returned:
//      CRYPT_E_BAD_MSG     - unable to ASN1 parse as a signed data message
//      ERROR_NO_DATA       - the content is empty
//      CRYPT_E_NO_SIGNER   - not signed or unable to find signer cert
//      CRYPT_E_UNKNOWN_ALGO- unknown MD5 or SHA1 ASN.1 algorithm identifier
//      CERT_E_UNTRUSTEDROOT- the signer chain's root wasn't baked in
//      CERT_E_CHAINING     - unable to build signer chain to a root
//      CRYPT_E_AUTH_ATTR_MISSING - missing digest authenticated attribute
//      CRYPT_E_HASH_VALUE  - content hash != authenticated digest attribute
//      NTE_BAD_ALGID       - unsupported hash or public key algorithm
//      NTE_BAD_PUBLIC_KEY  - not a valid RSA public key
//      NTE_BAD_SIGNATURE   - bad PKCS #7 or signer chain signature 
//
//  The rgVerSignedDataBlob[] is updated with pointer to and length of the
//  following fields in the encoded PKCS #7 message.
//--------------------------------------------------------------------------

// Content Object Identifier content bytes (OID)
#define MINCRYPT_VER_SIGNED_DATA_CONTENT_OID_IDX                    0

// Content data content bytes excluding "[0] EXPLICIT" tag
// (OPTIONAL MinAsn1ParseCTL, MinAsn1ParseIndirectData)
#define MINCRYPT_VER_SIGNED_DATA_CONTENT_DATA_IDX                   1

// Signer certificate's encoded bytes (MinAsn1ParseCertificate)
#define MINCRYPT_VER_SIGNED_DATA_SIGNER_CERT_IDX                    2

// Authenticated attributes value bytes including "[0] IMPLICIT" tag
// (OPTIONAL, MinAsn1ParseAttributes)
#define MINCRYPT_VER_SIGNED_DATA_AUTH_ATTRS_IDX                     3

// Unauthenticated attributes value bytes including "[1] IMPLICIT" tag
// (OPTIONAL, MinAsn1ParseAttributes)
#define MINCRYPT_VER_SIGNED_DATA_UNAUTH_ATTRS_IDX                   4

#define MINCRYPT_VER_SIGNED_DATA_BLOB_CNT                           5

LONG
WINAPI
MinCryptVerifySignedData(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT CRYPT_DER_BLOB rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_BLOB_CNT]
    );



//+-------------------------------------------------------------------------
//  File Type Definitions
//
//  Specifies the type of the "const VOID *pvFile" parameter
//--------------------------------------------------------------------------

// pvFile - LPCWSTR pwszFilename
#define MINCRYPT_FILE_NAME          1

// pvFile - HANDLE hFile
#define MINCRYPT_FILE_HANDLE        2

// pvFile - PCRYPT_DATA_BLOB pFileBlob
#define MINCRYPT_FILE_BLOB          3


//+-------------------------------------------------------------------------
//  Hashes the file according to the Hash ALG_ID.
//
//  According to dwFileType, pvFile can be a pwszFilename, hFile or pFileBlob.
//  Only requires READ access.
//
//  dwFileType:
//      MINCRYPT_FILE_NAME      : pvFile - LPCWSTR pwszFilename
//      MINCRYPT_FILE_HANDLE    : pvFile - HANDLE hFile
//      MINCRYPT_FILE_BLOB      : pvFile - PCRYPT_DATA_BLOB pFileBlob
//
//  rgbHash is updated with the resultant hash. *pcbHash is updated with
//  the length associated with the hash algorithm.
//
//  If the function succeeds, the return value is ERROR_SUCCESS. Otherwise,
//  a nonzero error code is returned.
//
//  Only CALG_SHA1 and CALG_MD5 are supported.
//
//  If a NT PE 32 bit file format, hashed according to imagehlp rules, ie, skip
//  section containing potential signature, ... . Otherwise, the entire file
//  is hashed.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptHashFile(
    IN DWORD dwFileType,
    IN const VOID *pvFile,
    IN ALG_ID HashAlgId,
    OUT BYTE rgbHash[MINCRYPT_MAX_HASH_LEN],
    OUT DWORD *pcbHash
    );


//+-------------------------------------------------------------------------
//  Verifies a previously signed file.
//
//  According to dwFileType, pvFile can be a pwszFilename, hFile or pFileBlob.
//  Only requires READ access.
//
//  dwFileType:
//      MINCRYPT_FILE_NAME      : pvFile - LPCWSTR pwszFilename
//      MINCRYPT_FILE_HANDLE    : pvFile - HANDLE hFile
//      MINCRYPT_FILE_BLOB      : pvFile - PCRYPT_DATA_BLOB pFileBlob
//
//  Checks if the file has an embedded PKCS #7 Signed Data message containing
//  Indirect Data. The PKCS #7 is verified via MinCryptVerifySignedData().
//  The Indirect Data is parsed via MinAsn1ParseIndirectData() to get the
//  HashAlgId and the file hash.  MinCryptHashFile() is called to hash the
//  file. The returned hash is compared against the Indirect Data's hash.
//
//  The caller can request one or more signer authenticated attribute values
//  to be returned. The still encoded values are returned in the
//  caller allocated memory. The beginning of this returned memory will
//  be set to an array of attribute value blobs pointing to these
//  encoded values (CRYPT_DER_BLOB rgAttrBlob[cAttrOID]).
//  For performance reasons, the caller should make every attempt to allow
//  for a single pass call. The necessary memory size is:
//      (cAttrOID * sizeof(CRYPT_DER_BLOB)) +
//          total length of encoded attribute values.
//
//  *pcbAttr will be updated with the number of bytes required to contain
//  the attribute blobs and values. If the input memory is insufficient,
//  ERROR_INSUFFICIENT_BUFFER will be returned if no other error.
//
//  For a multi-valued attribute, only the first value is returned.
//
//  If the function succeeds, the return value is ERROR_SUCCESS. Otherwise,
//  a nonzero error code is returned.
//
//  Only NT, PE 32 bit file formats are supported.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptVerifySignedFile(
    IN DWORD dwFileType,
    IN const VOID *pvFile,

    IN OPTIONAL DWORD cAttrOID,
    IN OPTIONAL CRYPT_DER_BLOB rgAttrEncodedOIDBlob[],
    // CRYPT_DER_BLOB rgAttrBlob[cAttrOID] header is at beginning
    // with the bytes pointed to immediately following
    OUT OPTIONAL CRYPT_DER_BLOB *rgAttrValueBlob,
    IN OUT OPTIONAL DWORD *pcbAttr
    );

//+-------------------------------------------------------------------------
//  Verifies the hashes in the system catalogs.
//
//  Iterates through the hashes and attempts to find the system catalog
//  containing it. If found, the system catalog file is verified as a
//  PKCS #7 Signed Data message with its signer cert verified up to a baked
//  in root.
//
//  The following mscat32.dll APIs are called to find the system catalog file:
//      CryptCATAdminAcquireContext
//      CryptCATAdminReleaseContext
//      CryptCATAdminEnumCatalogFromHash
//      CryptCATAdminReleaseCatalogContext
//      CryptCATCatalogInfoFromContext
//
//  If the hash was successfully verified, rglErr[] is set to ERROR_SUCCESS.
//  Otherwise, rglErr[] is set to a nonzero error code.
//
//  The caller can request one or more catalog subject attribute,
//  extension or signer authenticated attribute values to be returned for
//  each hash.  The still encoded values are returned in the
//  caller allocated memory. The beginning of this returned memory will
//  be set to a 2 dimensional array of attribute value blobs pointing to these
//  encoded values (CRYPT_DER_BLOB rgrgAttrValueBlob[cHash][cAttrOID]).
//  For performance reasons, the caller should make every attempt to allow
//  for a single pass call. The necessary memory size is:
//      (cHash * cAttrOID * sizeof(CRYPT_DER_BLOB)) +
//          total length of encoded attribute values.
//
//  *pcbAttr will be updated with the number of bytes required to contain
//  the attribute blobs and values. If the input memory is insufficient,
//  ERROR_INSUFFICIENT_BUFFER will be returned if no other error.
//
//  For a multi-valued attribute, only the first value is returned.
//
//  If the function succeeds, the return value is ERROR_SUCCESS. This may
//  be returned for unsuccessful rglErr[] values. Otherwise,
//  a nonzero error code is returned.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptVerifyHashInSystemCatalogs(
    IN ALG_ID HashAlgId,
    IN DWORD cHash,
    IN CRYPT_HASH_BLOB rgHashBlob[],
    OUT LONG rglErr[],

    IN OPTIONAL DWORD cAttrOID,
    IN OPTIONAL CRYPT_DER_BLOB rgAttrEncodedOIDBlob[],
    // CRYPT_DER_BLOB rgrgAttrValueBlob[cHash][cAttrOID] header is at beginning
    // with the bytes pointed to immediately following
    OUT OPTIONAL CRYPT_DER_BLOB *rgrgAttrValueBlob,
    IN OUT OPTIONAL DWORD *pcbAttr
    );
    



#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#if defined (_MSC_VER)
#if ( _MSC_VER >= 800 )

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif

#endif
#endif

#endif // __MINCRYPT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\mincrypt\imagehack.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       imagehack.cpp
//
//  Contents:   "Hacked" version of the imagehlp APIs
//
//              Contains a "stripped" down subset of the imagehlp functionality
//              necessary to hash a PE file and to extract the 
//              PKCS #7 Signed Data message.
//
//              Most of this file is derived from the following 2 files:
//                  \nt\ds\security\cryptoapi\pkitrust\mssip32\peimage2.cpp
//                  \nt\sdktools\debuggers\imagehlp\dice.cxx
//
//  Functions:  imagehack_ImageGetDigestStream
//              imagehack_ImageGetCertificateData
//
//  History:    20-Jan-01    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"

//+=========================================================================
//  The following was taken from the following file:
//      \nt\ds\security\cryptoapi\pkitrust\mssip32\peimage2.cpp
//-=========================================================================

__inline DWORD AlignIt (DWORD Value, DWORD Alignment) { return (Value + (Alignment - 1)) & ~(Alignment -1); }

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

BOOL
I_CalculateImagePtrs(
    PLOADED_IMAGE LoadedImage
    )
{
    PIMAGE_DOS_HEADER DosHeader;
    BOOL fRC = FALSE;

    // Everything is mapped. Now check the image and find nt image headers

    __try {
        DosHeader = (PIMAGE_DOS_HEADER)LoadedImage->MappedAddress;

        if ((DosHeader->e_magic != IMAGE_DOS_SIGNATURE) &&
            (DosHeader->e_magic != IMAGE_NT_SIGNATURE)) {
            __leave;
        }

        if (DosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
            if (DosHeader->e_lfanew == 0) {
                __leave;
            }
            LoadedImage->FileHeader = (PIMAGE_NT_HEADERS)((ULONG_PTR)DosHeader + DosHeader->e_lfanew);

            if (
                // If IMAGE_NT_HEADERS would extend past the end of file...
                (PBYTE)LoadedImage->FileHeader + sizeof(IMAGE_NT_HEADERS) >
                    (PBYTE)LoadedImage->MappedAddress + LoadedImage->SizeOfImage ||

                // ..or if it would begin in, or before the IMAGE_DOS_HEADER...
                (PBYTE)LoadedImage->FileHeader <
                    (PBYTE)LoadedImage->MappedAddress + sizeof(IMAGE_DOS_HEADER)  )
            {
                // ...then e_lfanew is not as expected.
                // (Several Win95 files are in this category.)
                __leave;
            }
        } else {

            // No DOS header indicates an image built w/o a dos stub

            LoadedImage->FileHeader = (PIMAGE_NT_HEADERS)DosHeader;
        }

        if ( LoadedImage->FileHeader->Signature != IMAGE_NT_SIGNATURE ) {
            __leave;
        } else {
            LoadedImage->fDOSImage = FALSE;
        }

        // No optional header indicates an object...

        if ( !LoadedImage->FileHeader->FileHeader.SizeOfOptionalHeader ) {
            __leave;
        }

        // Check for versions < 2.50

        if ( LoadedImage->FileHeader->OptionalHeader.MajorLinkerVersion < 3 &&
             LoadedImage->FileHeader->OptionalHeader.MinorLinkerVersion < 5 ) {
            __leave;
        }

        InitializeListHead( &LoadedImage->Links );
        LoadedImage->NumberOfSections = LoadedImage->FileHeader->FileHeader.NumberOfSections;
        LoadedImage->Sections = IMAGE_FIRST_SECTION(LoadedImage->FileHeader);
        fRC = TRUE;

    } __except ( EXCEPTION_EXECUTE_HANDLER ) { }

    return fRC;
}

BOOL
I_MapIt(
    PCRYPT_DATA_BLOB pFileBlob,
    PLOADED_IMAGE LoadedImage
    )
{

    LoadedImage->hFile = INVALID_HANDLE_VALUE;
    LoadedImage->MappedAddress = pFileBlob->pbData;
    LoadedImage->SizeOfImage = pFileBlob->cbData;

    if (!LoadedImage->MappedAddress) {
        return (FALSE);
    }

    if (!I_CalculateImagePtrs(LoadedImage)) {
        return(FALSE);
    }


    return(TRUE);
}

typedef struct _EXCLUDE_RANGE {
    PBYTE Offset;
    DWORD Size;
    struct _EXCLUDE_RANGE *Next;
} EXCLUDE_RANGE;

class EXCLUDE_LIST
{
    public:
        EXCLUDE_LIST() {
            m_Image = NULL;
            m_ExRange = (EXCLUDE_RANGE *)I_MemAlloc(sizeof(EXCLUDE_RANGE));

            if(m_ExRange)
                memset(m_ExRange, 0x00, sizeof(EXCLUDE_RANGE));
        }

        ~EXCLUDE_LIST() {
            EXCLUDE_RANGE *pTmp;
            pTmp = m_ExRange->Next;
            while (pTmp)
            {
                I_MemFree(m_ExRange);
                m_ExRange = pTmp;
                pTmp = m_ExRange->Next;
            }
            I_MemFree(m_ExRange);
        }

        void Init(LOADED_IMAGE * Image, DIGEST_FUNCTION pFunc, DIGEST_HANDLE dh) {
            m_Image = Image;
            m_ExRange->Offset = NULL;
            m_ExRange->Size = 0;
            m_pFunc = pFunc;
            m_dh = dh;
            return;
        }

        void Add(DWORD_PTR Offset, DWORD Size);

        BOOL Emit(PBYTE Offset, DWORD Size);

    private:
        LOADED_IMAGE  * m_Image;
        EXCLUDE_RANGE * m_ExRange;
        DIGEST_FUNCTION m_pFunc;
        DIGEST_HANDLE m_dh;
};

void
EXCLUDE_LIST::Add(
    DWORD_PTR Offset,
    DWORD Size
    )
{
    EXCLUDE_RANGE *pTmp, *pExRange;

    pExRange = m_ExRange;

    while (pExRange->Next && (pExRange->Next->Offset < (PBYTE)Offset)) {
        pExRange = pExRange->Next;
    }

    pTmp = (EXCLUDE_RANGE *) I_MemAlloc(sizeof(EXCLUDE_RANGE));

    if(pTmp)
    {
        pTmp->Next = pExRange->Next;
        pTmp->Offset = (PBYTE)Offset;
        pTmp->Size = Size;
        pExRange->Next = pTmp;
    }

    return;
}


BOOL
EXCLUDE_LIST::Emit(
    PBYTE Offset,
    DWORD Size
    )
{
    BOOL rc = FALSE;

    EXCLUDE_RANGE *pExRange;
    DWORD EmitSize, ExcludeSize;

    pExRange = m_ExRange->Next;

    while (pExRange && (Size > 0)) {
        if (pExRange->Offset >= Offset) {
            // Emit what's before the exclude list.
            EmitSize = min((DWORD)(pExRange->Offset - Offset), Size);
            if (EmitSize) {
                rc = (*m_pFunc)(m_dh, Offset, EmitSize);
                Size -= EmitSize;
                Offset += EmitSize;
            }
        }

        if (Size) {
            if (pExRange->Offset + pExRange->Size >= Offset) {
                // Skip over what's in the exclude list.
                ExcludeSize = min(Size, (DWORD)(pExRange->Offset + pExRange->Size - Offset));
                Size -= ExcludeSize;
                Offset += ExcludeSize;
            }
        }

        pExRange = pExRange->Next;
    }

    // Emit what's left.
    if (Size) {
        rc = (*m_pFunc)(m_dh, Offset, Size);
    }
    return rc;
}


#pragma warning (push)
// error C4509: nonstandard extension used: 'imagehack_ImageGetDigestStream'
//              uses SEH and 'ExList' has destructor
#pragma warning (disable: 4509)


BOOL
WINAPI
imagehack_ImageGetDigestStream(
    IN      PCRYPT_DATA_BLOB pFileBlob,
    IN      DWORD   DigestLevel,
    IN      DIGEST_FUNCTION DigestFunction,
    IN      DIGEST_HANDLE   DigestHandle
    )

/*++

Routine Description:
    Given an image, return the bytes necessary to construct a certificate.
    Only PE images are supported at this time.

Arguments:

    FileHandle  -   Handle to the file in question.  The file should be opened
                    with at least GENERIC_READ access.

    DigestLevel -   Indicates what data will be included in the returned buffer.
                    Valid values are:

                        CERT_PE_IMAGE_DIGEST_ALL_BUT_CERTS - Include data outside the PE image itself
                                                              (may include non-mapped debug symbolic)

    DigestFunction - User supplied routine that will process the data.

    DigestHandle -  User supplied handle to identify the digest.  Passed as the first
                    argument to the DigestFunction.

Return Value:

    TRUE         - Success.

    FALSE        - There was some error.  Call GetLastError for more information.  Possible
                   values are ERROR_INVALID_PARAMETER or ERROR_OPERATION_ABORTED.

--*/

{
    LOADED_IMAGE    LoadedImage;
    DWORD           ErrorCode;
    EXCLUDE_LIST    ExList;

    if (I_MapIt(pFileBlob, &LoadedImage) == FALSE) {
        // Unable to map the image or invalid digest level.
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    ErrorCode = ERROR_INVALID_PARAMETER;
    __try {
        PIMAGE_DATA_DIRECTORY CertDirectory;
        DWORD HeaderEndOffset = 0;

        if ((LoadedImage.FileHeader->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC) &&
            (LoadedImage.FileHeader->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC))
        {
            __leave;
        }

        ExList.Init(&LoadedImage, DigestFunction, DigestHandle);

        if (LoadedImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            PIMAGE_NT_HEADERS32 NtHeader32 = (PIMAGE_NT_HEADERS32)(LoadedImage.FileHeader);
            // Exclude the checksum.
            ExList.Add(((DWORD_PTR) &NtHeader32->OptionalHeader.CheckSum),
                       sizeof(NtHeader32->OptionalHeader.CheckSum));

            CertDirectory = &NtHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
            HeaderEndOffset = NtHeader32->OptionalHeader.SizeOfHeaders;
        } else {
            PIMAGE_NT_HEADERS64 NtHeader64 = (PIMAGE_NT_HEADERS64)(LoadedImage.FileHeader);
            // Exclude the checksum.
            ExList.Add(((DWORD_PTR) &NtHeader64->OptionalHeader.CheckSum),
                       sizeof(NtHeader64->OptionalHeader.CheckSum));

            CertDirectory = &NtHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
            HeaderEndOffset = NtHeader64->OptionalHeader.SizeOfHeaders;
        }

        DWORD CertFileOffset = CertDirectory->VirtualAddress;
        DWORD CertFileSize = CertDirectory->Size;

        if (CertFileOffset && CertFileSize) {
            DWORD i;

            if (CertFileOffset > LoadedImage.SizeOfImage) {
                __leave;    // Start of certs is past end of image
            }
            if ((CertFileOffset + CertFileSize) != LoadedImage.SizeOfImage) {
                __leave;    // Certs not at end of image
            }
            if ((CertFileOffset + CertFileSize) < CertFileOffset) {
                __leave;    // cert end is before cert start (start + size wraps)
            }
            if (CertFileOffset < HeaderEndOffset) {
                __leave;    // Certs are in the header space
            }

            // See if the certs are in the section data
            for (i = 0; i < LoadedImage.NumberOfSections; i++) {
                DWORD SectionFileOffsetStart = LoadedImage.Sections[i].PointerToRawData;
                DWORD SectionFileOffsetEnd = SectionFileOffsetStart + LoadedImage.Sections[i].SizeOfRawData;

                if (SectionFileOffsetStart && (CertFileOffset < SectionFileOffsetEnd)) {
                    __leave;    // CertData starts before this section - not allowed
                }
            }
        }

        // Exclude the Security directory.
        ExList.Add((DWORD_PTR) CertDirectory, sizeof(IMAGE_DATA_DIRECTORY));

        // Exclude the certs.
        ExList.Add((DWORD_PTR)CertFileOffset + (DWORD_PTR)LoadedImage.MappedAddress, CertFileSize);

        ExList.Emit((PBYTE) (LoadedImage.MappedAddress), LoadedImage.SizeOfImage);
        ErrorCode = ERROR_SUCCESS;

    } __except(EXCEPTION_EXECUTE_HANDLER) { }


    SetLastError(ErrorCode);

    return(ErrorCode == ERROR_SUCCESS ? TRUE : FALSE);
}

#pragma warning (pop)


//+=========================================================================
//  The following was taken from the following file:
//      \nt\sdktools\debuggers\imagehlp\dice.cxx
//-=========================================================================


BOOL
I_FindCertificate(
    IN PLOADED_IMAGE    LoadedImage,
    IN DWORD            Index,
    OUT LPWIN_CERTIFICATE * Certificate
    )
{
    PIMAGE_DATA_DIRECTORY pDataDir;
    DWORD_PTR CurrentCert = NULL;
    BOOL rc;

    if (LoadedImage->fDOSImage) {
        // No way this could have a certificate;
        return(FALSE);
    }

    rc = FALSE;

    __try {
        if (LoadedImage->FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            pDataDir = &((PIMAGE_NT_HEADERS32)(LoadedImage->FileHeader))->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
        } else if (LoadedImage->FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
            pDataDir = &((PIMAGE_NT_HEADERS64)(LoadedImage->FileHeader))->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
        } else {
            __leave;     // Not an interesting file type.
        }

        // Check if the cert pointer is at least reasonable.
        if (!pDataDir->VirtualAddress ||
            !pDataDir->Size ||
            (pDataDir->VirtualAddress + pDataDir->Size > LoadedImage->SizeOfImage))
        {
            __leave;
        }

        // We're not looking at an empty security slot or an invalid (past the image boundary) value.
        // Let's see if we can find it.

        DWORD CurrentIdx = 0;
        DWORD_PTR LastCert;

        CurrentCert = (DWORD_PTR)(LoadedImage->MappedAddress) + pDataDir->VirtualAddress;
        LastCert = CurrentCert + pDataDir->Size;

        while (CurrentCert < LastCert ) {
            if (CurrentIdx == Index) {
                rc = TRUE;
                __leave;
            }
            CurrentIdx++;
            CurrentCert += ((LPWIN_CERTIFICATE)CurrentCert)->dwLength;
            CurrentCert = (CurrentCert + 7) & ~7;   // align it.
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) { }

    if (rc == TRUE) {
        *Certificate = (LPWIN_CERTIFICATE)CurrentCert;
    }

    return(rc);
}

BOOL
WINAPI
imagehack_ImageGetCertificateData(
    IN      PCRYPT_DATA_BLOB pFileBlob,
    IN      DWORD   CertificateIndex,
    OUT     LPWIN_CERTIFICATE * Certificate
    )

/*++

Routine Description:

    Given a specific certificate index, retrieve the certificate data.

Arguments:

    FileHandle          -   Handle to the file in question.  The file should be opened
                            with at least GENERIC_READ access.

    CertificateIndex    -   Index to retrieve

    Certificate         -   Output buffer where the certificate is to be stored.

    RequiredLength      -   Size of the certificate buffer (input).  On return, is
                            set to the actual certificate length.  NULL can be used
                            to determine the size of a certificate.

Return Value:

    TRUE    - Successful

    FALSE   - There was some error.  Call GetLastError() for more information.

--*/

{
    LOADED_IMAGE LoadedImage;
    DWORD   ErrorCode;

    LPWIN_CERTIFICATE ImageCert;

    *Certificate = NULL;

    // if (I_MapIt(FileHandle, &LoadedImage, MAP_READONLY) == FALSE) {
    if (I_MapIt(pFileBlob, &LoadedImage) == FALSE) {
        // Unable to map the image.
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    ErrorCode = ERROR_INVALID_PARAMETER;
    __try {
        if (I_FindCertificate(&LoadedImage, CertificateIndex, &ImageCert) == FALSE) {
            __leave;
        }
        
        *Certificate = ImageCert;
        ErrorCode = ERROR_SUCCESS;
    } __except(EXCEPTION_EXECUTE_HANDLER) { }

    // I_UnMapIt(&LoadedImage);

    SetLastError(ErrorCode);
    return(ErrorCode == ERROR_SUCCESS ? TRUE: FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\mincrypt\verfile.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       verfile.cpp
//
//  Contents:   Minimal Cryptographic functions to hash files and verify
//              Authenticode signed files.
//              message
//
//  Functions:  MinCryptHashFile
//              MinCryptVerifySignedFile
//
//  History:    21-Jan-01    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <md5.h>
#include <sha.h>

#define PE_EXE_HEADER_TAG       "MZ"
#define MIN_PE_FILE_LEN         4

#define MAX_SIGNED_FILE_AUTH_ATTR_CNT   10

typedef struct _DIGEST_DATA {
    ALG_ID      AlgId;
    void        *pvSHA1orMD5Ctx;
} DIGEST_DATA, *PDIGEST_DATA;

// #define SPC_INDIRECT_DATA_OBJID "1.3.6.1.4.1.311.2.1.4"
const BYTE rgbSPC_INDIRECT_DATA_OBJID[] =
    {0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x04};

BOOL
WINAPI
I_DigestFunction(
    DIGEST_HANDLE refdata,
    PBYTE pbData,
    DWORD cbData
    )
{
    PDIGEST_DATA pDigestData = (PDIGEST_DATA) refdata;

    switch (pDigestData->AlgId)
    {
        case CALG_MD5:
            MD5Update((MD5_CTX *)pDigestData->pvSHA1orMD5Ctx, pbData, cbData);
            return(TRUE);

        case CALG_SHA1:
            A_SHAUpdate((A_SHA_CTX *)pDigestData->pvSHA1orMD5Ctx, pbData,
                cbData);
            return(TRUE);
    }
    return FALSE;
}

BOOL
WINAPI
I_IsNtPe32File(
    IN PCRYPT_DATA_BLOB pFileBlob
    )
{
    const BYTE *pbFile = pFileBlob->pbData;
    DWORD cbFile = pFileBlob->cbData;

    if (MIN_PE_FILE_LEN > cbFile)
        return FALSE;

    if (0 != memcmp(&pbFile[0], PE_EXE_HEADER_TAG, strlen(PE_EXE_HEADER_TAG)))
        return FALSE;

    //  Make sure it is a 32 bit PE
    if (sizeof(IMAGE_DOS_HEADER) > cbFile)
        return FALSE;
    else {
        IMAGE_DOS_HEADER *pDosHead = (IMAGE_DOS_HEADER *) pbFile;

        if (pDosHead->e_magic != IMAGE_DOS_SIGNATURE)
            return FALSE;

        if (cbFile < (sizeof(IMAGE_DOS_HEADER) + pDosHead->e_lfanew))
            return FALSE;
        else {
            IMAGE_NT_HEADERS *pNTHead =
                (IMAGE_NT_HEADERS *)((ULONG_PTR)pDosHead + pDosHead->e_lfanew);

            if (pNTHead->Signature != IMAGE_NT_SIGNATURE)
                return FALSE;
        }
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Hashes the file according to the Hash ALG_ID.
//
//  According to dwFileType, pvFile can be a pwszFilename, hFile or pFileBlob.
//  Only requires READ access.
//
//  dwFileType:
//      MINCRYPT_FILE_NAME      : pvFile - LPCWSTR pwszFilename
//      MINCRYPT_FILE_HANDLE    : pvFile - HANDLE hFile
//      MINCRYPT_FILE_BLOB      : pvFile - PCRYPT_DATA_BLOB pFileBlob
//
//  rgbHash is updated with the resultant hash. *pcbHash is updated with
//  the length associated with the hash algorithm.
//
//  If the function succeeds, the return value is ERROR_SUCCESS. Otherwise,
//  a nonzero error code is returned.
//
//  Only CALG_SHA1 and CALG_MD5 are supported.
//
//  If a NT PE 32 bit file format, hashed according to imagehlp rules, ie, skip
//  section containing potential signature, ... . Otherwise, the entire file
//  is hashed.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptHashFile(
    IN DWORD dwFileType,
    IN const VOID *pvFile,
    IN ALG_ID HashAlgId,
    OUT BYTE rgbHash[MINCRYPT_MAX_HASH_LEN],
    OUT DWORD *pcbHash
    )
{
    LONG lErr;
    CRYPT_DATA_BLOB FileBlob = {0, NULL};
    DIGEST_DATA DigestData;
    A_SHA_CTX ShaCtx;
    MD5_CTX Md5Ctx;

    __try {
        lErr = I_MinCryptMapFile(
            dwFileType,
            pvFile,
            &FileBlob
            );
        if (ERROR_SUCCESS != lErr)
            goto ErrorReturn;

        if (!I_IsNtPe32File(&FileBlob)) {
            // Hash the entire file
            lErr = MinCryptHashMemory(
                HashAlgId,
                1,              // cBlob
                &FileBlob,
                rgbHash,
                pcbHash
                );
            goto CommonReturn;
        }

        DigestData.AlgId = HashAlgId;
        switch (HashAlgId) {
            case CALG_MD5:
                DigestData.pvSHA1orMD5Ctx = &Md5Ctx;
                MD5Init(&Md5Ctx);
                break;

            case CALG_SHA1:
                DigestData.pvSHA1orMD5Ctx = &ShaCtx;
                A_SHAInit(&ShaCtx);
                break;

            default:
                goto InvalidHashAlgId;
        }

        if (!imagehack_ImageGetDigestStream(
                &FileBlob,
                0,                  // DigestLevel, ignored
                I_DigestFunction,
                &DigestData
                ))
            goto DigestStreamError;
        else {
            DWORD dwPadBeforeCerts;

            dwPadBeforeCerts = (FileBlob.cbData + 7) & ~7;
            dwPadBeforeCerts -= FileBlob.cbData;

            if (0 < dwPadBeforeCerts) {
                BYTE rgb[8];
                // imagehlp put nulls before the signature!
                memset(rgb, 0x00, dwPadBeforeCerts);

                if (!I_DigestFunction(&DigestData, rgb, dwPadBeforeCerts))
                    goto DigestFunctionError;
            }
        }

        switch (HashAlgId) {
            case CALG_MD5:
                MD5Final(&Md5Ctx);
                memcpy(rgbHash, Md5Ctx.digest, MD5DIGESTLEN);
                *pcbHash = MINCRYPT_MD5_HASH_LEN;
                break;

            case CALG_SHA1:
                A_SHAFinal(&ShaCtx, rgbHash);
                *pcbHash = MINCRYPT_SHA1_HASH_LEN;
                break;

            default:
                goto InvalidHashAlgId;
        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        lErr = GetExceptionCode();
        if (ERROR_SUCCESS == lErr)
            lErr = E_UNEXPECTED;
        goto ErrorReturn;
    }

    lErr = ERROR_SUCCESS;

CommonReturn:
    //**********************************************************************
    //  WARNING!!!!
    //
    //  UnmapViewOfFile is in another DLL, kernel32.dll.
    //  lErr and the return hash in rgbHash[] must be protected.
    //  
    //**********************************************************************
    if (MINCRYPT_FILE_BLOB != dwFileType && NULL != FileBlob.pbData)
        UnmapViewOfFile(FileBlob.pbData);
    return lErr;

ErrorReturn:
    *pcbHash = 0;
    goto CommonReturn;

InvalidHashAlgId:
    lErr = NTE_BAD_ALGID;
    goto ErrorReturn;

DigestStreamError:
DigestFunctionError:
    lErr = NTE_BAD_HASH;
    goto ErrorReturn;
}


// Only called when cAttrOID != 0
LONG
WINAPI
I_GetAuthAttributes(
    IN PCRYPT_DER_BLOB pAttrsValueBlob,
    IN DWORD cAttrOID,
    IN CRYPT_DER_BLOB rgAttrEncodedOIDBlob[],
    // CRYPT_DER_BLOB rgAttrBlob[cAttrOID] header is at beginning
    // with the bytes pointed to immediately following
    OUT OPTIONAL CRYPT_DER_BLOB *rgAttrValueBlob,
    IN OUT DWORD *pcbAttr
    )
{
    LONG lErr;
    DWORD i;
    LONG lRemainExtra;
    BYTE *pbExtra;
    DWORD cbAttr;

    CRYPT_DER_BLOB rgrgAttrBlob[MAX_SIGNED_FILE_AUTH_ATTR_CNT][MINASN1_ATTR_BLOB_CNT];
    DWORD cAttr;

    assert(0 != cAttrOID);

    if (rgAttrValueBlob)
        cbAttr = *pcbAttr;
    else
        cbAttr = 0;

    lRemainExtra = cbAttr - sizeof(CRYPT_DER_BLOB) * cAttrOID;
    if (0 <= lRemainExtra) {
        memset(rgAttrValueBlob, 0, sizeof(CRYPT_DER_BLOB) * cAttrOID);
        pbExtra = (BYTE *) &rgAttrValueBlob[cAttrOID];
    } else
        pbExtra = NULL;

    // Parse the authenticated attributes
    cAttr = MAX_SIGNED_FILE_AUTH_ATTR_CNT;
    if (0 >= MinAsn1ParseAttributes(
            pAttrsValueBlob,
            &cAttr,
            rgrgAttrBlob))
        cAttr = 0;

    for (i = 0; i < cAttrOID; i++) {
        PCRYPT_DER_BLOB rgFindAttrBlob;

        rgFindAttrBlob = MinAsn1FindAttribute(
            &rgAttrEncodedOIDBlob[i],
            cAttr,
            rgrgAttrBlob
            );
        if (rgFindAttrBlob) {
            PCRYPT_DER_BLOB pFindAttrValue =
                &rgFindAttrBlob[MINASN1_ATTR_VALUE_IDX];
            const BYTE *pbFindValue = pFindAttrValue->pbData;
            DWORD cbFindValue = pFindAttrValue->cbData;

            if (0 < cbFindValue) {
                lRemainExtra -= cbFindValue;
                if (0 <= lRemainExtra) {
                    rgAttrValueBlob[i].pbData = pbExtra;
                    rgAttrValueBlob[i].cbData = cbFindValue;

                    memcpy(pbExtra, pbFindValue, cbFindValue);
                    pbExtra += cbFindValue;
                }
            }
        }
    }

    if (0 <= lRemainExtra) {
        *pcbAttr = cbAttr - (DWORD) lRemainExtra;
        lErr = ERROR_SUCCESS;
    } else {
        *pcbAttr = cbAttr + (DWORD) -lRemainExtra;
        lErr = ERROR_INSUFFICIENT_BUFFER;
    }

    return lErr;
}

//+-------------------------------------------------------------------------
//  Verifies a previously signed file.
//
//  According to dwFileType, pvFile can be a pwszFilename, hFile or pFileBlob.
//  Only requires READ access.
//
//  dwFileType:
//      MINCRYPT_FILE_NAME      : pvFile - LPCWSTR pwszFilename
//      MINCRYPT_FILE_HANDLE    : pvFile - HANDLE hFile
//      MINCRYPT_FILE_BLOB      : pvFile - PCRYPT_DATA_BLOB pFileBlob
//
//  Checks if the file has an embedded PKCS #7 Signed Data message containing
//  Indirect Data. The PKCS #7 is verified via MinCryptVerifySignedData().
//  The Indirect Data is parsed via MinAsn1ParseIndirectData() to get the
//  HashAlgId and the file hash.  MinCryptHashFile() is called to hash the
//  file. The returned hash is compared against the Indirect Data's hash.
//
//  The caller can request one or more signer authenticated attribute values
//  to be returned. The still encoded values are returned in the
//  caller allocated memory. The beginning of this returned memory will
//  be set to an array of attribute value blobs pointing to these
//  encoded values. The caller should make every attempt to allow for a
//  single pass call. The necessary memory size is:
//      (cAttrOID * sizeof(CRYPT_DER_BLOB)) +
//          total length of encoded attribute values.
//
//  *pcbAttr will be updated with the number of bytes required to contain
//  the attribute blobs and values. If the input memory is insufficient,
//  ERROR_INSUFFICIENT_BUFFER will be returned if no other error.
//
//  For the multi-valued attributes, only the first value is returned.
//
//  If the function succeeds, the return value is ERROR_SUCCESS. Otherwise,
//  a nonzero error code is returned.
//
//  Only NT, PE 32 bit file formats are supported.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptVerifySignedFile(
    IN DWORD dwFileType,
    IN const VOID *pvFile,

    IN OPTIONAL DWORD cAttrOID,
    IN OPTIONAL CRYPT_DER_BLOB rgAttrEncodedOIDBlob[],
    // CRYPT_DER_BLOB rgAttrBlob[cAttrOID] header is at beginning
    // with the bytes pointed to immediately following
    OUT OPTIONAL CRYPT_DER_BLOB *rgAttrValueBlob,
    IN OUT OPTIONAL DWORD *pcbAttr
    )
{
    LONG lErr;
    CRYPT_DATA_BLOB FileBlob = {0, NULL};

    __try {
        LPWIN_CERTIFICATE pCertHdr = NULL;
        const BYTE *pbEncodedSignedData;
        DWORD cbEncodedSignedData;
        CRYPT_DER_BLOB rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_BLOB_CNT];
        CRYPT_DER_BLOB rgIndirectDataBlob[MINASN1_INDIRECT_DATA_BLOB_CNT];
        ALG_ID HashAlgId;
        BYTE rgbHash[MINCRYPT_MAX_HASH_LEN];
        DWORD cbHash;

        lErr = I_MinCryptMapFile(
            dwFileType,
            pvFile,
            &FileBlob
            );
        if (ERROR_SUCCESS != lErr)
            goto ErrorReturn;

        if (!I_IsNtPe32File(&FileBlob))
            goto NotNtPe32File;

        if (!imagehack_ImageGetCertificateData(
                &FileBlob,
                0,              // CertificateIndex
                &pCertHdr
                ))
            goto NoSignature;

        if (WIN_CERT_REVISION_2_0 != pCertHdr->wRevision ||
                WIN_CERT_TYPE_PKCS_SIGNED_DATA != pCertHdr->wCertificateType)
            goto UnsupportedSignature;

        if (offsetof(WIN_CERTIFICATE, bCertificate) > pCertHdr->dwLength)
            goto InvalidSignature;

        cbEncodedSignedData = pCertHdr->dwLength -
            offsetof(WIN_CERTIFICATE, bCertificate);
        pbEncodedSignedData = pCertHdr->bCertificate;

        lErr = MinCryptVerifySignedData(
            pbEncodedSignedData,
            cbEncodedSignedData,
            rgVerSignedDataBlob
            );
        if (ERROR_SUCCESS != lErr)
            goto ErrorReturn;

        // The data content should be Indirect Data
        if (sizeof(rgbSPC_INDIRECT_DATA_OBJID) !=
                rgVerSignedDataBlob[
                    MINCRYPT_VER_SIGNED_DATA_CONTENT_OID_IDX].cbData
                        ||
                0 != memcmp(rgbSPC_INDIRECT_DATA_OBJID,
                        rgVerSignedDataBlob[
                            MINCRYPT_VER_SIGNED_DATA_CONTENT_OID_IDX].pbData,
                        sizeof(rgbSPC_INDIRECT_DATA_OBJID)))
            goto NotIndirectDataOID;

        if (0 >= MinAsn1ParseIndirectData(
                &rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_CONTENT_DATA_IDX],
                rgIndirectDataBlob
                ))
            goto ParseIndirectDataError;

        HashAlgId = MinCryptDecodeHashAlgorithmIdentifier(
            &rgIndirectDataBlob[MINASN1_INDIRECT_DATA_DIGEST_ALGID_IDX]
            );
        if (0 == HashAlgId)
            goto UnknownHashAlgId;

        lErr = MinCryptHashFile(
            MINCRYPT_FILE_BLOB,
            (const VOID *) &FileBlob,
            HashAlgId,
            rgbHash,
            &cbHash
            );
        if (ERROR_SUCCESS != lErr)
            goto ErrorReturn;

        // Check that the hash in the indirect data matches the file hash
        if (cbHash !=
                rgIndirectDataBlob[MINASN1_INDIRECT_DATA_DIGEST_IDX].cbData
                        ||
                0 != memcmp(rgbHash,
                    rgIndirectDataBlob[MINASN1_INDIRECT_DATA_DIGEST_IDX].pbData,
                    cbHash))
            goto InvalidFileHash;

        if (cAttrOID)
            lErr = I_GetAuthAttributes(
                &rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_AUTH_ATTRS_IDX],
                cAttrOID,
                rgAttrEncodedOIDBlob,
                rgAttrValueBlob,
                pcbAttr
                );
        else
            lErr = ERROR_SUCCESS;

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        lErr = GetExceptionCode();
        if (ERROR_SUCCESS == lErr)
            lErr = E_UNEXPECTED;
        goto ErrorReturn;
    }

CommonReturn:
    //**********************************************************************
    //  WARNING!!!!
    //
    //  UnmapViewOfFile is in another DLL, kernel32.dll.
    //  lErr must be protected.
    //  
    //**********************************************************************
    if (MINCRYPT_FILE_BLOB != dwFileType && NULL != FileBlob.pbData)
        UnmapViewOfFile(FileBlob.pbData);
    return lErr;

ErrorReturn:
    assert(ERROR_SUCCESS != lErr);
    if (ERROR_INSUFFICIENT_BUFFER == lErr)
        // This error can only be set when we determine that the attribute
        // buffer isn't big enough.
        lErr = E_UNEXPECTED;
    goto CommonReturn;

NotNtPe32File:
    lErr = ERROR_NOT_SUPPORTED;
    goto ErrorReturn;

NoSignature:
UnsupportedSignature:
InvalidSignature:
    lErr = TRUST_E_NOSIGNATURE;
    goto ErrorReturn;

NotIndirectDataOID:
ParseIndirectDataError:
    lErr = CRYPT_E_BAD_MSG;
    goto ErrorReturn;

UnknownHashAlgId:
    lErr = CRYPT_E_UNKNOWN_ALGO;
    goto ErrorReturn;

InvalidFileHash:
    lErr = CRYPT_E_HASH_VALUE;
    goto ErrorReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\mincrypt\verhash.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       verhash.cpp
//
//  Contents:   Minimal Cryptographic functions to verify ASN.1 encoded
//              signed hashes. Signed hashes are used in X.509 certificates
//              and PKCS #7 signed data.
//
//              Also contains md5 or sha1 memory hash function.
//              
//
//  Functions:  MinCryptDecodeHashAlgorithmIdentifier
//              MinCryptHashMemory
//              MinCryptVerifySignedHash
//
//  History:    17-Jan-01    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <md5.h>
#include <sha.h>
#include <rsa.h>

#define MAX_RSA_PUB_KEY_BIT_LEN             4096
#define MAX_RSA_PUB_KEY_BYTE_LEN            (MAX_RSA_PUB_KEY_BIT_LEN / 8 )
#define MAX_BSAFE_PUB_KEY_MODULUS_BYTE_LEN  \
    (MAX_RSA_PUB_KEY_BYTE_LEN +  sizeof(DWORD) * 4)

typedef struct _BSAFE_PUB_KEY_CONTENT {
    BSAFE_PUB_KEY   Header;
    BYTE            rgbModulus[MAX_BSAFE_PUB_KEY_MODULUS_BYTE_LEN];
} BSAFE_PUB_KEY_CONTENT, *PBSAFE_PUB_KEY_CONTENT;


#ifndef RSA1
#define RSA1 ((DWORD)'R'+((DWORD)'S'<<8)+((DWORD)'A'<<16)+((DWORD)'1'<<24))
#endif

// from \nt\ds\win32\ntcrypto\scp\nt_sign.c

//
// Reverse ASN.1 Encodings of possible hash identifiers.  The leading byte is
// the length of the remaining byte string.
//

static const BYTE
    *md5Encodings[]
    = { (CONST BYTE *)"\x12\x10\x04\x00\x05\x05\x02\x0d\xf7\x86\x48\x86\x2a\x08\x06\x0c\x30\x20\x30",
        (CONST BYTE *)"\x10\x10\x04\x05\x02\x0d\xf7\x86\x48\x86\x2a\x08\x06\x0a\x30\x1e\x30",
        (CONST BYTE *)"\x00" },

    *shaEncodings[]
    = { (CONST BYTE *)"\x0f\x14\x04\x00\x05\x1a\x02\x03\x0e\x2b\x05\x06\x09\x30\x21\x30",
        (CONST BYTE *)"\x0d\x14\x04\x1a\x02\x03\x0e\x2b\x05\x06\x07\x30\x1f\x30",
        (CONST BYTE *)"\x00"};



typedef struct _ENCODED_OID_INFO {
    DWORD           cbEncodedOID;
    const BYTE      *pbEncodedOID;
    ALG_ID          AlgId;
} ENCODED_OID_INFO, *PENCODED_OID_INFO;

//
// SHA1/MD5 HASH OIDS
//

// #define szOID_OIWSEC_sha1       "1.3.14.3.2.26"
const BYTE rgbOIWSEC_sha1[] =
    {0x2B, 0x0E, 0x03, 0x02, 0x1A};

// #define szOID_OIWSEC_sha        "1.3.14.3.2.18"
const BYTE rgbOID_OIWSEC_sha[] =
    {0x2B, 0x0E, 0x03, 0x02, 0x12};

// #define szOID_RSA_MD5           "1.2.840.113549.2.5"
const BYTE rgbOID_RSA_MD5[] =
    {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x05};

//
// RSA SHA1/MD5 SIGNATURE OIDS
//

// #define szOID_RSA_SHA1RSA       "1.2.840.113549.1.1.5"
const BYTE rgbOID_RSA_SHA1RSA[] =
    {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05};

// #define szOID_RSA_MD5RSA        "1.2.840.113549.1.1.4"
const BYTE rgbOID_RSA_MD5RSA[] =
    {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x04};

// #define szOID_OIWSEC_sha1RSASign "1.3.14.3.2.29"
const BYTE rgbOID_OIWSEC_sha1RSASign[] =
    {0x2B, 0x0E, 0x03, 0x02, 0x1D};

// #define szOID_OIWSEC_shaRSA     "1.3.14.3.2.15"
const BYTE rgbOID_OIWSEC_shaRSA[] =
    {0x2B, 0x0E, 0x03, 0x02, 0x0F};

// #define szOID_OIWSEC_md5RSA     "1.3.14.3.2.3"
const BYTE rgbOID_OIWSEC_md5RSA[] =
    {0x2B, 0x0E, 0x03, 0x02, 0x03};

const ENCODED_OID_INFO HashAlgTable[] = {
    // Hash OIDs
    sizeof(rgbOIWSEC_sha1), rgbOIWSEC_sha1, CALG_SHA1,
    sizeof(rgbOID_OIWSEC_sha), rgbOID_OIWSEC_sha, CALG_SHA1,
    sizeof(rgbOID_RSA_MD5), rgbOID_RSA_MD5, CALG_MD5,

    // Signature OIDs
    sizeof(rgbOID_RSA_SHA1RSA), rgbOID_RSA_SHA1RSA, CALG_SHA1,
    sizeof(rgbOID_RSA_MD5RSA), rgbOID_RSA_MD5RSA, CALG_MD5,
    sizeof(rgbOID_OIWSEC_sha1RSASign), rgbOID_OIWSEC_sha1RSASign, CALG_SHA1,
    sizeof(rgbOID_OIWSEC_shaRSA), rgbOID_OIWSEC_shaRSA, CALG_SHA1,
    sizeof(rgbOID_OIWSEC_md5RSA), rgbOID_OIWSEC_md5RSA, CALG_MD5,
};
#define HASH_ALG_CNT (sizeof(HashAlgTable) / sizeof(HashAlgTable[0]))



//+-------------------------------------------------------------------------
//  Decodes an ASN.1 encoded Algorithm Identifier and converts to
//  a CAPI Hash AlgID, such as, CALG_SHA1 or CALG_MD5.
//
//  Returns 0 if there isn't a CAPI AlgId corresponding to the Algorithm
//  Identifier.
//
//  Only CALG_SHA1, CALG_MD5 are supported.
//--------------------------------------------------------------------------
ALG_ID
WINAPI
MinCryptDecodeHashAlgorithmIdentifier(
    IN PCRYPT_DER_BLOB pAlgIdValueBlob
    )
{
    ALG_ID HashAlgId = 0;
    LONG lSkipped;
    CRYPT_DER_BLOB rgAlgIdBlob[MINASN1_ALGID_BLOB_CNT];
    DWORD cbEncodedOID;
    const BYTE *pbEncodedOID;
    DWORD i;

    lSkipped = MinAsn1ParseAlgorithmIdentifier(
        pAlgIdValueBlob,
        rgAlgIdBlob
        );
    if (0 >= lSkipped)
        goto CommonReturn;

    cbEncodedOID = rgAlgIdBlob[MINASN1_ALGID_OID_IDX].cbData;
    pbEncodedOID = rgAlgIdBlob[MINASN1_ALGID_OID_IDX].pbData;

    for (i = 0; i < HASH_ALG_CNT; i++) {
        if (cbEncodedOID == HashAlgTable[i].cbEncodedOID &&
                0 == memcmp(pbEncodedOID, HashAlgTable[i].pbEncodedOID,
                                cbEncodedOID)) {
            HashAlgId = HashAlgTable[i].AlgId;
            break;
        }
    }

CommonReturn:
    return HashAlgId;
}


#pragma warning (push)
// local variable 'Md5Ctx' may be used without having been initialized
#pragma warning (disable: 4701)

//+-------------------------------------------------------------------------
//  Hashes one or more memory blobs according to the Hash ALG_ID.
//
//  rgbHash is updated with the resultant hash. *pcbHash is updated with
//  the length associated with the hash algorithm.
//
//  If the function succeeds, the return value is ERROR_SUCCESS. Otherwise,
//  a nonzero error code is returned.
//
//  Only CALG_SHA1, CALG_MD5 are supported.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptHashMemory(
    IN ALG_ID HashAlgId,
    IN DWORD cBlob,
    IN PCRYPT_DER_BLOB rgBlob,
    OUT BYTE rgbHash[MINCRYPT_MAX_HASH_LEN],
    OUT DWORD *pcbHash
    )
{
    A_SHA_CTX ShaCtx;
    MD5_CTX Md5Ctx;
    DWORD iBlob;

    switch (HashAlgId) {
        case CALG_MD5:
            MD5Init(&Md5Ctx);
            *pcbHash = MINCRYPT_MD5_HASH_LEN;
            break;

        case CALG_SHA1:
            A_SHAInit(&ShaCtx);
            *pcbHash = MINCRYPT_SHA1_HASH_LEN;
            break;

        default:
            *pcbHash = 0;
            return NTE_BAD_ALGID;
    }

    for (iBlob = 0; iBlob < cBlob; iBlob++) {
        BYTE *pb = rgBlob[iBlob].pbData;
        DWORD cb = rgBlob[iBlob].cbData;

        if (0 == cb)
            continue;

        switch (HashAlgId) {
            case CALG_MD5:
                MD5Update(&Md5Ctx, pb, cb);
                break;

            case CALG_SHA1:
                A_SHAUpdate(&ShaCtx, pb, cb);
                break;
        }

    }

    switch (HashAlgId) {
        case CALG_MD5:
            MD5Final(&Md5Ctx);
            assert(MD5DIGESTLEN == MINCRYPT_MD5_HASH_LEN);
            memcpy(rgbHash, Md5Ctx.digest, MD5DIGESTLEN);
            break;

        case CALG_SHA1:
            A_SHAFinal(&ShaCtx, rgbHash);
            break;
    }

    return ERROR_SUCCESS;

}

#pragma warning (pop)

//+=========================================================================
//  MinCryptVerifySignedHash Support Functions
//-=========================================================================

VOID
WINAPI
I_ReverseAndCopyBytes(
    OUT BYTE *pbDst,
    IN const BYTE *pbSrc,
    IN DWORD cb
    )
{
    if (0 == cb)
        return;
    for (pbDst += cb - 1; cb > 0; cb--)
        *pbDst-- = *pbSrc++;
}



//  The basis for much of the code in this function can be found in
//  \nt\ds\win32\ntcrypto\scp\nt_key.c
LONG
WINAPI
I_ConvertParsedRSAPubKeyToBSafePubKey(
    IN CRYPT_DER_BLOB rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_BLOB_CNT],
    OUT PBSAFE_PUB_KEY_CONTENT pBSafePubKeyContent
    )
{
    LONG lErr;
    DWORD cbModulus;
    const BYTE *pbAsn1Modulus;
    DWORD cbExp;
    const BYTE *pbAsn1Exp;
    DWORD cbTmpLen;
    LPBSAFE_PUB_KEY pBSafePubKey;

    // Get the ASN.1 public key modulus (BIG ENDIAN). The modulus length
    // is the public key byte length.
    cbModulus = rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_MODULUS_IDX].cbData;
    pbAsn1Modulus = rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_MODULUS_IDX].pbData;
    // Strip off a leading 0 byte. Its there in the decoded ASN
    // integer for an unsigned integer with the leading bit set.
    if (cbModulus > 1 && *pbAsn1Modulus == 0) {
        pbAsn1Modulus++;
        cbModulus--;
    }
    if (MAX_RSA_PUB_KEY_BYTE_LEN < cbModulus)
        goto ExceededMaxPubKeyModulusLen;

    // Get the ASN.1 public exponent (BIG ENDIAN).
    cbExp = rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_EXPONENT_IDX].cbData;
    pbAsn1Exp = rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_EXPONENT_IDX].pbData;
    // Strip off a leading 0 byte. Its there in the decoded ASN
    // integer for an unsigned integer with the leading bit set.
    if (cbExp > 1 && *pbAsn1Exp == 0) {
        pbAsn1Exp++;
        cbExp--;
    }
    if (sizeof(DWORD) < cbExp)
        goto ExceededMaxPubKeyExpLen;

    if (0 == cbModulus || 0 == cbExp)
        goto InvalidPubKey;

    // Update the BSAFE data structure from the parsed and length validated
    // ASN.1 public key modulus and exponent components.

    cbTmpLen = (sizeof(DWORD) * 2) - (cbModulus % (sizeof(DWORD) * 2));
    if ((sizeof(DWORD) * 2) != cbTmpLen)
        cbTmpLen += sizeof(DWORD) * 2;

    memset(pBSafePubKeyContent, 0, sizeof(*pBSafePubKeyContent));
    pBSafePubKey = &pBSafePubKeyContent->Header;
    pBSafePubKey->magic = RSA1;
    pBSafePubKey->keylen = cbModulus + cbTmpLen;
    pBSafePubKey->bitlen = cbModulus * 8;
    pBSafePubKey->datalen = cbModulus - 1;

    I_ReverseAndCopyBytes((BYTE *) &pBSafePubKey->pubexp, pbAsn1Exp, cbExp);
    I_ReverseAndCopyBytes(pBSafePubKeyContent->rgbModulus, pbAsn1Modulus,
        cbModulus);

    lErr = ERROR_SUCCESS;
CommonReturn:
    return lErr;

ExceededMaxPubKeyModulusLen:
ExceededMaxPubKeyExpLen:
InvalidPubKey:
    lErr = NTE_BAD_PUBLIC_KEY;
    goto CommonReturn;
}


//  The basis for much of the code in this function can be found in
//  \nt\ds\win32\ntcrypto\scp\nt_sign.c
LONG
WINAPI
I_VerifyPKCS1SigningFormat(
    IN BSAFE_PUB_KEY *pKey,
    IN ALG_ID HashAlgId,
    IN BYTE *pbHash,
    IN DWORD cbHash,
    IN BYTE *pbPKCS1Format
    )
{
    LONG lErr = ERROR_INTERNAL_ERROR;
    const BYTE **rgEncOptions;
    BYTE rgbTmpHash[MINCRYPT_MAX_HASH_LEN];
    DWORD i;
    DWORD cb;
    BYTE *pbStart;
    DWORD cbTmp;

    switch (HashAlgId)
    {
    case CALG_MD5:
        rgEncOptions = md5Encodings;
        break;

    case CALG_SHA:
        rgEncOptions = shaEncodings;
        break;

    default:
        goto UnsupportedHash;
    }

    // Reverse the hash to match the signature.
    for (i = 0; i < cbHash; i++)
        rgbTmpHash[i] = pbHash[cbHash - (i + 1)];

    // See if it matches.
    if (0 != memcmp(rgbTmpHash, pbPKCS1Format, cbHash))
    {
        goto BadSignature;
    }

    cb = cbHash;
    for (i = 0; 0 != *rgEncOptions[i]; i += 1)
    {
        pbStart = (LPBYTE)rgEncOptions[i];
        cbTmp = *pbStart++;
        if (0 == memcmp(&pbPKCS1Format[cb], pbStart, cbTmp))
        {
            cb += cbTmp;   // Adjust the end of the hash data.
            break;
        }
    }

    // check to make sure the rest of the PKCS #1 padding is correct
    if ((0x00 != pbPKCS1Format[cb])
        || (0x00 != pbPKCS1Format[pKey->datalen])
        || (0x1 != pbPKCS1Format[pKey->datalen - 1]))
    {
        goto BadSignature;
    }

    for (i = cb + 1; i < pKey->datalen - 1; i++)
    {
        if (0xff != pbPKCS1Format[i])
        {
            goto BadSignature;
        }
    }

    lErr = ERROR_SUCCESS;

CommonReturn:
    return lErr;

UnsupportedHash:
    lErr = NTE_BAD_ALGID;
    goto CommonReturn;

BadSignature:
    lErr = NTE_BAD_SIGNATURE;
    goto CommonReturn;
}
    

//+-------------------------------------------------------------------------
//  Verifies a signed hash.
//
//  The ASN.1 encoded Public Key Info is parsed and used to decrypt the
//  signed hash. The decrypted signed hash is compared with the input
//  hash.
//
//  If the signed hash was successfully verified, ERROR_SUCCESS is returned.
//  Otherwise, a nonzero error code is returned.
//
//  Only RSA signed hashes are supported.
//
//  Only MD5 and SHA1 hashes are supported.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptVerifySignedHash(
    IN ALG_ID HashAlgId,
    IN BYTE *pbHash,
    IN DWORD cbHash,
    IN PCRYPT_DER_BLOB pSignedHashContentBlob,
    IN PCRYPT_DER_BLOB pPubKeyInfoValueBlob
    )
{
    LONG lErr;
    LONG lSkipped;
    
    CRYPT_DER_BLOB rgPubKeyInfoBlob[MINASN1_PUBKEY_INFO_BLOB_CNT];
    CRYPT_DER_BLOB rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_BLOB_CNT];
    BSAFE_PUB_KEY_CONTENT BSafePubKeyContent;
    LPBSAFE_PUB_KEY pBSafePubKey;

    DWORD cbSignature;
    const BYTE *pbAsn1Signature;

    BYTE rgbBSafeIn[MAX_BSAFE_PUB_KEY_MODULUS_BYTE_LEN];
    BYTE rgbBSafeOut[MAX_BSAFE_PUB_KEY_MODULUS_BYTE_LEN];


    // Attempt to parse and convert the ASN.1 encoded public key into
    // an RSA BSAFE formatted key.
    lSkipped = MinAsn1ParsePublicKeyInfo(
        pPubKeyInfoValueBlob,
        rgPubKeyInfoBlob
        );
    if (0 >= lSkipped)
        goto ParsePubKeyInfoError;

    lSkipped = MinAsn1ParseRSAPublicKey(
        &rgPubKeyInfoBlob[MINASN1_PUBKEY_INFO_PUBKEY_IDX],
        rgRSAPubKeyBlob
        );
    if (0 >= lSkipped)
        goto ParseRSAPubKeyError;

    lErr = I_ConvertParsedRSAPubKeyToBSafePubKey(
        rgRSAPubKeyBlob,
        &BSafePubKeyContent
        );
    if (ERROR_SUCCESS != lErr)
        goto CommonReturn;

    pBSafePubKey = &BSafePubKeyContent.Header;
    
    // Get the ASN.1 signature (BIG ENDIAN).
    //
    // It must be the same length as the public key
    cbSignature = pSignedHashContentBlob->cbData;
    pbAsn1Signature = pSignedHashContentBlob->pbData;
    if (cbSignature != pBSafePubKey->bitlen / 8)
        goto InvalidSignatureLen;

    // Decrypt the signature (LITTLE ENDIAN)
    assert(sizeof(rgbBSafeIn) >= cbSignature);
    I_ReverseAndCopyBytes(rgbBSafeIn, pbAsn1Signature, cbSignature);
    memset(&rgbBSafeIn[cbSignature], 0, sizeof(rgbBSafeIn) - cbSignature);
    memset(rgbBSafeOut, 0, sizeof(rgbBSafeOut));

    if (!BSafeEncPublic(pBSafePubKey, rgbBSafeIn, rgbBSafeOut))
        goto BSafeEncPublicError;


    lErr = I_VerifyPKCS1SigningFormat(
        pBSafePubKey,
        HashAlgId,
        pbHash,
        cbHash,
        rgbBSafeOut
        );

CommonReturn:
    return lErr;

ParsePubKeyInfoError:
ParseRSAPubKeyError:
    lErr = NTE_BAD_PUBLIC_KEY;
    goto CommonReturn;

InvalidSignatureLen:
BSafeEncPublicError:
    lErr = NTE_BAD_SIGNATURE;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\mincrypt\verdata.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       verdata.cpp
//
//  Contents:   Minimal Cryptographic functions to verify PKCS #7 Signed Data
//              message
//
//
//  Functions:  MinCryptVerifySignedData
//
//  History:    19-Jan-01    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"

#define MAX_SIGNED_DATA_CERT_CNT        10
#define MAX_SIGNED_DATA_AUTH_ATTR_CNT   10

// #define szOID_RSA_signedData    "1.2.840.113549.1.7.2"
const BYTE rgbOID_RSA_signedData[] =
    {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x02};

// #define szOID_RSA_messageDigest "1.2.840.113549.1.9.4"
const BYTE rgbOID_RSA_messageDigest[] =
    {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x04};
const CRYPT_DER_BLOB RSA_messageDigestEncodedOIDBlob = {
        sizeof(rgbOID_RSA_messageDigest), 
        (BYTE *) rgbOID_RSA_messageDigest
};

PCRYPT_DER_BLOB
WINAPI
I_MinCryptFindSignerCertificateByIssuerAndSerialNumber(
    IN PCRYPT_DER_BLOB pIssuerNameValueBlob,
    IN PCRYPT_DER_BLOB pIssuerSerialNumberContentBlob,
    IN DWORD cCert,
    IN CRYPT_DER_BLOB rgrgCertBlob[][MINASN1_CERT_BLOB_CNT]
    )
{
    DWORD i;
    const BYTE *pbName = pIssuerNameValueBlob->pbData;
    DWORD cbName = pIssuerNameValueBlob->cbData;
    const BYTE *pbSerial = pIssuerSerialNumberContentBlob->pbData;
    DWORD cbSerial = pIssuerSerialNumberContentBlob->cbData;
    
    if (0 == cbName || 0 == cbSerial)
        return NULL;

    for (i = 0; i < cCert; i++) {
        PCRYPT_DER_BLOB rgCert = rgrgCertBlob[i];

        if (cbName == rgCert[MINASN1_CERT_ISSUER_IDX].cbData &&
                cbSerial == rgCert[MINASN1_CERT_SERIAL_NUMBER_IDX].cbData
                        &&
                0 == memcmp(pbSerial,
                        rgCert[MINASN1_CERT_SERIAL_NUMBER_IDX].pbData,
                        cbSerial)
                        &&
                0 == memcmp(pbName,
                        rgCert[MINASN1_CERT_ISSUER_IDX].pbData,
                        cbName))
            return rgCert;
    }

    return NULL;
}

//  Verifies that the input hash matches the
//  szOID_RSA_messageDigest ("1.2.840.113549.1.9.4") authenticated attribute.
//
//  Replaces the input hash with a hash of the authenticated attributes.
LONG
WINAPI
I_MinCryptVerifySignerAuthenticatedAttributes(
    IN ALG_ID HashAlgId,
    IN OUT BYTE rgbHash[MINCRYPT_MAX_HASH_LEN],
    IN OUT DWORD *pcbHash,
    IN PCRYPT_DER_BLOB pAttrsValueBlob
    )
{
    LONG lErr;
    DWORD cAttr;
    CRYPT_DER_BLOB rgrgAttrBlob[MAX_SIGNED_DATA_AUTH_ATTR_CNT][MINASN1_ATTR_BLOB_CNT];
    PCRYPT_DER_BLOB rgDigestAuthAttr;

    const BYTE *pbDigestAuthValue;
    DWORD cbDigestAuthValue;

    CRYPT_DER_BLOB rgAuthHashBlob[2];
    const BYTE bTagSet = MINASN1_TAG_SET;

    // Parse the authenticated attributes
    cAttr = MAX_SIGNED_DATA_AUTH_ATTR_CNT;
    if (0 >= MinAsn1ParseAttributes(
            pAttrsValueBlob,
            &cAttr,
            rgrgAttrBlob) || 0 == cAttr)
        goto MissingAuthAttrs;

    // Find the szOID_RSA_messageDigest ("1.2.840.113549.1.9.4")
    // attribute value
    rgDigestAuthAttr = MinAsn1FindAttribute(
        (PCRYPT_DER_BLOB) &RSA_messageDigestEncodedOIDBlob,
        cAttr,
        rgrgAttrBlob
        );
    if (NULL == rgDigestAuthAttr)
        goto MissingDigestAuthAttr;

    // Skip past the digest's outer OCTET tag and length octets
    if (0 >= MinAsn1ExtractContent(
            rgDigestAuthAttr[MINASN1_ATTR_VALUE_IDX].pbData,
            rgDigestAuthAttr[MINASN1_ATTR_VALUE_IDX].cbData,
            &cbDigestAuthValue,
            &pbDigestAuthValue
            ))
        goto InvalidDigestAuthAttr;

    // Check that the authenticated digest bytes match the input
    // content hash.
    if (*pcbHash != cbDigestAuthValue ||
            0 != memcmp(rgbHash, pbDigestAuthValue, cbDigestAuthValue))
        goto InvalidContentHash;

    // Hash the authenticated attributes. This hash will be compared against
    // the decrypted signature.

    // Note, the authenticated attributes "[0] Implicit" tag needs to be changed
    // to a "SET OF" tag before doing the hash.
    rgAuthHashBlob[0].pbData = (BYTE *) &bTagSet;
    rgAuthHashBlob[0].cbData = 1;
    assert(0 < pAttrsValueBlob->cbData);
    rgAuthHashBlob[1].pbData = pAttrsValueBlob->pbData + 1;
    rgAuthHashBlob[1].cbData = pAttrsValueBlob->cbData - 1;
    
    lErr = MinCryptHashMemory(
        HashAlgId,
        2,                      // cBlob
        rgAuthHashBlob,
        rgbHash,
        pcbHash
        );

CommonReturn:
    return lErr;

MissingAuthAttrs:
MissingDigestAuthAttr:
InvalidDigestAuthAttr:
    lErr = CRYPT_E_AUTH_ATTR_MISSING;
    goto CommonReturn;

InvalidContentHash:
    lErr = CRYPT_E_HASH_VALUE;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  Function: MinCryptVerifySignedData
//
//  Verifies an ASN.1 encoded PKCS #7 Signed Data Message.
//
//  Assumes the PKCS #7 message is definite length encoded.
//  Assumes PKCS #7 version 1.5, ie, not the newer CMS version.
//  We only look at the first signer.
//
//  The Signed Data message is parsed. Its signature is verified. Its
//  signer certificate chain is verified to a baked in root public key.
//
//  If the Signed Data was successfully verified, ERROR_SUCCESS is returned.
//  Otherwise, a nonzero error code is returned.
//
//  Here are some interesting errors that can be returned:
//      CRYPT_E_BAD_MSG     - unable to ASN1 parse as a signed data message
//      ERROR_NO_DATA       - the content is empty
//      CRYPT_E_NO_SIGNER   - not signed or unable to find signer cert
//      CRYPT_E_UNKNOWN_ALGO- unknown MD5 or SHA1 ASN.1 algorithm identifier
//      CERT_E_UNTRUSTEDROOT- the signer chain's root wasn't baked in
//      CERT_E_CHAINING     - unable to build signer chain to a root
//      CRYPT_E_AUTH_ATTR_MISSING - missing digest authenticated attribute
//      CRYPT_E_HASH_VALUE  - content hash != authenticated digest attribute
//      NTE_BAD_ALGID       - unsupported hash or public key algorithm
//      NTE_BAD_PUBLIC_KEY  - not a valid RSA public key
//      NTE_BAD_SIGNATURE   - bad PKCS #7 or signer chain signature 
//
//  The rgVerSignedDataBlob[] is updated with pointer to and length of the
//  following fields in the encoded PKCS #7 message.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptVerifySignedData(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT CRYPT_DER_BLOB rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_BLOB_CNT]
    )
{
    LONG lErr;
    CRYPT_DER_BLOB rgParseSignedDataBlob[MINASN1_SIGNED_DATA_BLOB_CNT];
    DWORD cCert;
    CRYPT_DER_BLOB rgrgCertBlob[MAX_SIGNED_DATA_CERT_CNT][MINASN1_CERT_BLOB_CNT];
    PCRYPT_DER_BLOB rgSignerCert;
    ALG_ID HashAlgId;
    BYTE rgbHash[MINCRYPT_MAX_HASH_LEN];
    DWORD cbHash;
    CRYPT_DER_BLOB ContentBlob;

    memset(rgVerSignedDataBlob, 0,
        sizeof(CRYPT_DER_BLOB) * MINCRYPT_VER_SIGNED_DATA_BLOB_CNT);

    // Parse the message and verify that it's ASN.1 PKCS #7 SignedData
    if (0 >= MinAsn1ParseSignedData(
            pbEncoded,
            cbEncoded,
            rgParseSignedDataBlob
            ))
        goto ParseSignedDataError;

    // Only support szOID_RSA_signedData - "1.2.840.113549.1.7.2"
    if (sizeof(rgbOID_RSA_signedData) !=
            rgParseSignedDataBlob[MINASN1_SIGNED_DATA_OUTER_OID_IDX].cbData
                        ||
            0 != memcmp(rgbOID_RSA_signedData,
                    rgParseSignedDataBlob[MINASN1_SIGNED_DATA_OUTER_OID_IDX].pbData,
                    sizeof(rgbOID_RSA_signedData)))
        goto NotSignedDataOID;

    // Verify this isn't an empty SignedData message
    if (0 == rgParseSignedDataBlob[MINASN1_SIGNED_DATA_CONTENT_OID_IDX].cbData
                        ||
            0 == rgParseSignedDataBlob[MINASN1_SIGNED_DATA_CONTENT_DATA_IDX].cbData)
        goto NoContent;

    rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_CONTENT_OID_IDX] =
        rgParseSignedDataBlob[MINASN1_SIGNED_DATA_CONTENT_OID_IDX];
    rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_CONTENT_DATA_IDX] =
        rgParseSignedDataBlob[MINASN1_SIGNED_DATA_CONTENT_DATA_IDX];

    // Check that the message has a signer
    if (0 == rgParseSignedDataBlob[MINASN1_SIGNED_DATA_SIGNER_INFO_ENCODED_IDX].cbData)
        goto NoSigner;

    // Get the message's bag of certs
    cCert = MAX_SIGNED_DATA_CERT_CNT;
    if (0 >= MinAsn1ParseSignedDataCertificates(
            &rgParseSignedDataBlob[MINASN1_SIGNED_DATA_CERTS_IDX],
            &cCert,
            rgrgCertBlob
            ) || 0 == cCert)
        goto NoCerts;

    // Get the signer certificate
    rgSignerCert = I_MinCryptFindSignerCertificateByIssuerAndSerialNumber(
        &rgParseSignedDataBlob[MINASN1_SIGNED_DATA_SIGNER_INFO_ISSUER_IDX],
        &rgParseSignedDataBlob[MINASN1_SIGNED_DATA_SIGNER_INFO_SERIAL_NUMBER_IDX],
        cCert,
        rgrgCertBlob
        );
    if (NULL == rgSignerCert)
        goto NoSignerCert;

    rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_SIGNER_CERT_IDX] =
        rgSignerCert[MINASN1_CERT_ENCODED_IDX];
    rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_AUTH_ATTRS_IDX] =
        rgParseSignedDataBlob[MINASN1_SIGNED_DATA_SIGNER_INFO_AUTH_ATTRS_IDX];
    rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_UNAUTH_ATTRS_IDX] =
        rgParseSignedDataBlob[MINASN1_SIGNED_DATA_SIGNER_INFO_UNAUTH_ATTRS_IDX];


    // Verify the signer certificate up to a baked in, trusted root
    lErr = MinCryptVerifyCertificate(
        rgSignerCert,
        cCert,
        rgrgCertBlob
        );
    if (ERROR_SUCCESS != lErr)
        goto ErrorReturn;


    // Hash the message's content octets according to the signer's hash
    // algorithm
    HashAlgId = MinCryptDecodeHashAlgorithmIdentifier(
        &rgParseSignedDataBlob[MINASN1_SIGNED_DATA_SIGNER_INFO_DIGEST_ALGID_IDX]
        );
    if (0 == HashAlgId)
        goto UnknownHashAlgId;

    // Note, the content's tag and length octets aren't included in the hash
    if (0 >= MinAsn1ExtractContent(
            rgParseSignedDataBlob[MINASN1_SIGNED_DATA_CONTENT_DATA_IDX].pbData,
            rgParseSignedDataBlob[MINASN1_SIGNED_DATA_CONTENT_DATA_IDX].cbData,
            &ContentBlob.cbData,
            (const BYTE **) &ContentBlob.pbData
            ))
        goto InvalidContent;

    lErr = MinCryptHashMemory(
        HashAlgId,
        1,                      // cBlob
        &ContentBlob,
        rgbHash,
        &cbHash
        );
    if (ERROR_SUCCESS != lErr)
        goto ErrorReturn;

    // If we have authenticated attributes, then, need to compare the
    // above hash with the szOID_RSA_messageDigest ("1.2.840.113549.1.9.4")
    // attribute value. After a successful comparison, the above hash
    // is replaced with a hash of the authenticated attributes.
    if (0 != rgParseSignedDataBlob[
            MINASN1_SIGNED_DATA_SIGNER_INFO_AUTH_ATTRS_IDX].cbData) {
        lErr = I_MinCryptVerifySignerAuthenticatedAttributes(
            HashAlgId,
            rgbHash,
            &cbHash,
            &rgParseSignedDataBlob[MINASN1_SIGNED_DATA_SIGNER_INFO_AUTH_ATTRS_IDX]
            );
        if (ERROR_SUCCESS != lErr)
            goto ErrorReturn;
    }

    // Verify the signature using either the authenticated attributes hash
    // or the content hash
    lErr = MinCryptVerifySignedHash(
        HashAlgId,
        rgbHash,
        cbHash,
        &rgParseSignedDataBlob[MINASN1_SIGNED_DATA_SIGNER_INFO_ENCYRPT_DIGEST_IDX],
        &rgSignerCert[MINASN1_CERT_PUBKEY_INFO_IDX]
        );


ErrorReturn:
CommonReturn:
    return lErr;

ParseSignedDataError:
NotSignedDataOID:
InvalidContent:
    lErr = CRYPT_E_BAD_MSG;
    goto CommonReturn;

NoContent:
    lErr = ERROR_NO_DATA;
    goto CommonReturn;

NoSigner:
NoCerts:
NoSignerCert:
    lErr = CRYPT_E_NO_SIGNER;
    goto CommonReturn;

UnknownHashAlgId:
    lErr = CRYPT_E_UNKNOWN_ALGO;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\programs\dssinstl\dssinstl.c ===
#undef UNICODE					// ## Not Yet
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <windows.h>
#include <wincrypt.h>

#define MS_DSS_TYPE     "DSS Signature"
#define MS_DH_TYPE      "DSS Signature with Diffie-Hellman Key Exachange"

#define PROVPATH        "SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider\\"
#define PROVPATH_LEN    sizeof(PROVPATH)

#define TYPEPATH        "SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider Types\\Type "
#define TYPEPATH_LEN    sizeof(TYPEPATH)

#define IMAGEPATH       "dssbase.dll"
#define IMAGEPATH_LEN    sizeof(IMAGEPATH)

BOOL SetCSPInfo(
                LPSTR pszProvider,
                LPSTR pszImagePath,
                BYTE *pbSig,
                DWORD cbSig,
                DWORD dwProvType,
                LPSTR pszTypeName
                )
{
    DWORD   dwIgn;
    HKEY    hKey = 0;
    HKEY    hTypeKey = 0;
    DWORD   cbProv;
    BYTE    *pszProv = NULL;
    CHAR    pszTypeString[32];
    DWORD   cbType;
    BYTE    *pszType = NULL;
    DWORD   err;
    BOOL    fRet = FALSE;

    cbProv = PROVPATH_LEN + strlen(pszProvider);
    if (NULL == (pszProv = (LPSTR)LocalAlloc(LMEM_ZEROINIT, cbProv)))
        goto Ret;

    strcpy(pszProv, PROVPATH);
    strcat(pszProv, pszProvider);

	//
	// Create or open in local machine for provider:
	// Microsoft Base Cryptographic Provider v1.0
	//
    if (ERROR_SUCCESS != (err = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                               (const char *)pszProv,
                                               0L, "", REG_OPTION_NON_VOLATILE,
                                               KEY_ALL_ACCESS, NULL, &hKey,
                                               &dwIgn)))
        goto Ret;

	//
	// Set Image path to: scp.dll
	//
    if (ERROR_SUCCESS != (err = RegSetValueEx(hKey, "Image Path", 0L, REG_SZ,
	                                          pszImagePath,
                                              strlen(pszImagePath) + 1)))
        goto Ret;

	//
	// Set Type to: Type 003
	//
    if (ERROR_SUCCESS != (err = RegSetValueEx(hKey, "Type", 0L, REG_DWORD,
                                              (LPTSTR)&dwProvType,
                                              sizeof(DWORD))))
        goto Ret;

	//
	// Place signature
	//
    if (ERROR_SUCCESS != (err = RegSetValueEx(hKey, "Signature", 0L,
                                              REG_BINARY, pbSig, cbSig)))
        goto Ret;

	//
	// Create or open in local machine for provider type:
	//

    memset(pszTypeString, 0, sizeof(pszTypeString));
    sprintf(pszTypeString, "%.3d", dwProvType);

    cbType = TYPEPATH_LEN + strlen(pszTypeString);
    if (NULL == (pszType = (LPSTR)LocalAlloc(LMEM_ZEROINIT, cbType)))
        goto Ret;

    strcpy(pszType, TYPEPATH);
    strcat(pszType, pszTypeString);

    if (ERROR_SUCCESS != (err = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                               (const char *) pszType,
                                               0L, "", REG_OPTION_NON_VOLATILE,
                                               KEY_ALL_ACCESS, NULL, &hTypeKey,
                                               &dwIgn)))
        goto Ret;

    if (ERROR_SUCCESS != (err = RegSetValueEx(hTypeKey, "Name", 0L,
                                              REG_SZ, pszProvider,
                                              strlen(pszProvider) + 1)))
        goto Ret;

    if (ERROR_SUCCESS != (err = RegSetValueEx(hTypeKey, "TypeName", 0L,
                                              REG_SZ, pszTypeName,
                                              strlen(pszTypeName) + 1)))
        goto Ret;

    fRet = TRUE;
Ret:
    if (hKey)
        RegCloseKey(hKey);
    if (hTypeKey)
        RegCloseKey(hTypeKey);
    if (pszProv)
        LocalFree(pszProv);
    if (pszType)
        LocalFree(pszType);
    return fRet;
}

int __cdecl main(int cArg, char *rgszArg[])
{
    DWORD   err;
    DWORD   dwValue;
    HANDLE  hFileSig = INVALID_HANDLE_VALUE;
    DWORD   NumBytesRead;
    DWORD   lpdwFileSizeHigh;
    LPVOID  lpvAddress = NULL;    
    DWORD   NumBytes;
    BOOL    fRet = FALSE;

    //
    // Just to open scp.dll signature file.  This file was created by
    // sign.exe.
    //
    if (INVALID_HANDLE_VALUE == (hFileSig = CreateFile("dssbase.sig",
                                                       GENERIC_READ, 0, NULL,
			                                           OPEN_EXISTING,
                                                       FILE_ATTRIBUTE_NORMAL,
			                                           0)))
    {
        printf("Install failed: Unable to open dssbase.sig: %x\n", GetLastError());
        goto Ret;
    }

    if ((NumBytes = GetFileSize((HANDLE) hFileSig, &lpdwFileSizeHigh)) ==
                                0xffffffff)
    {
        printf("Install failed: Getting size of file dssbase.sig: %x\n", GetLastError());
        goto Ret;
    }

    if ((lpvAddress = VirtualAlloc(NULL, NumBytes, MEM_RESERVE |
		                           MEM_COMMIT,
                                   PAGE_READWRITE)) == NULL)
    {
        printf("Install failed: Alloc to read dssbase.sig: %x\n", GetLastError());
        goto Ret;
    }

    if (!ReadFile((HANDLE) hFileSig, lpvAddress, NumBytes,
		  &NumBytesRead, 0))
    {

        printf("Install failed: Reading dssbase.sig: %x\n", GetLastError());
        goto Ret;
    }

    if (NumBytesRead != NumBytes)
    {
        printf("Install failed: Bytes read doesn't match file size\n");
        goto Ret;
    }

	//
	// install the default DSS provider
	// Type 003
	//
    if (!SetCSPInfo(MS_DEF_DSS_PROV,
                    IMAGEPATH,
                    lpvAddress,
                    NumBytesRead,
                    PROV_DSS,
                    MS_DSS_TYPE))
    {
        printf("Unable to install dssbase.dll");
        goto Ret;
    }

	//
	// install the default DSS/DH provider
	// Type 013
	//
    if (!SetCSPInfo(MS_DEF_DSS_DH_PROV,
                    IMAGEPATH,
                    lpvAddress,
                    NumBytesRead,
                    PROV_DSS_DH,
                    MS_DH_TYPE))
    {
        printf("Unable to install dssbase.dll");
        goto Ret;
    }

	printf("Installed: %s\n", IMAGEPATH);
    fRet = TRUE;
Ret:
    if (lpvAddress)
        VirtualFree(lpvAddress, 0, MEM_RELEASE);
    if (INVALID_HANDLE_VALUE != hFileSig)
        CloseHandle(hFileSig);
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\programs\init\init.c ===
#undef UNICODE					// ## Not Yet
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <windows.h>
#include <wincrypt.h>

CHAR			pszMyName[64];
HCRYPTKEY		hClientKey;
HCRYPTPROV		hMe;
HCRYPTKEY		hKey2;

BOOL Logon(int cArg);

int __cdecl main(int cArg, char *rgszArg[])
{

        // Logon to provider
	if (!Logon(cArg))
	    goto exit;

exit:
    return(0);

}

BOOL Logon(int cArg)
{
	HCRYPTKEY	hTestKey;

	pszMyName[0] = 0;

	if (RCRYPT_FAILED(CryptAcquireContext(&hMe, pszMyName, MS_DEF_PROV,
                          PROV_RSA_FULL, 0)))
	{
            if (cArg > 1)
		printf("\nUser doesn't exists, try to create it	");

	    if (RCRYPT_FAILED(CryptAcquireContext(&hMe, pszMyName,
                              MS_DEF_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET)))
            {
	        if (cArg > 1)
                    printf("FAIL Error = %x\n", GetLastError());
                return(FALSE);
	    }
	    else
	    {
	    if (cArg > 1)
                printf("SUCCEED\n");
            }
        }
	else
        {
            if (cArg > 1)
		printf("CryptAcquireContext for user: %s\n", pszMyName);
        }

	
	if (RCRYPT_FAILED(CryptGetUserKey(hMe, AT_SIGNATURE, &hTestKey)))
	{

            if (cArg > 1)
                printf("Create signature key for %s:	", pszMyName);
    
	    if (RCRYPT_FAILED(CryptGenKey(hMe, CALG_RSA_SIGN,
                                          CRYPT_EXPORTABLE, &hClientKey)))
	    {
	        if (cArg > 1)
                    printf("FAIL Error = %x\n", GetLastError());
	        return(FALSE);
	    }
	    if (cArg > 1)
                printf("SUCCEED\n");
        }
	else
		CryptDestroyKey(hTestKey);
		
	if (RCRYPT_FAILED(CryptGetUserKey(hMe, AT_KEYEXCHANGE, &hTestKey)))
	{
            if (cArg > 1 )
                printf("Create key exchange for %s:		", pszMyName);

	    if (RCRYPT_FAILED(CryptGenKey(hMe, CALG_RSA_KEYX,
                                          CRYPT_EXPORTABLE, &hKey2)))
	    {
	        if (cArg > 1)
                    printf("FAIL Error = %x\n", GetLastError());
	        return(FALSE);
	    }
            if (cArg > 1)
                printf("SUCCEED\n");
        }
	else
		CryptDestroyKey(hTestKey);

        if (cArg > 1)
            printf("Init completed\n");

	return(TRUE);
       
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\programs\keymigrt\keymigrt.c ===
//
//  keymigrt.c
//
//  Copyright (c) Microsoft Corp, 2000
//
//
#include <windows.h>
#include <winbase.h>
#include <stdio.h>
#include <stdlib.h>
#include <wincrypt.h>
#include <cspdk.h>
#include "dpapiprv.h"
#include "contman.h"


#define BEHAVIOR_FORCE_KEY  0x1
#define BEHAVIOR_VERBOSE    0x2
#define BEHAVIOR_ALLOW_UI   0x4
#define BEHAVIOR_MACHINE    0x8
#define BEHAVIOR_NO_CHANGE  0x10
#define BEHAVIOR_EXPORT     0x20
#define BEHAVIOR_FORCE_ENC  0x40

typedef struct _ALG_TO_STRING
{
    DWORD   AlgId;
    LPCWSTR  wszString;
} ALG_TO_STRING;


#define             MS_BASE_CRYPTPROTECT_VERSION    0x01

ALG_TO_STRING g_AlgToString[] =
{
    { CALG_MD2, L"MD2-%d " },
    { CALG_MD4, L"MD4-%d " },
    { CALG_MD5, L"MD5-%d " },
    { CALG_SHA1, L"SHA1-%d " },
    { CALG_DES, L"DES-%d " },
    { CALG_3DES_112, L"3DES-%d " },
    { CALG_3DES, L"3DES-%d " },
    { CALG_DESX, L"DESX-%d " },
    { CALG_RC2, L"RC2-%d " },
    { CALG_RC4, L"RC4-%d " },
    { CALG_SEAL, L"SEAL-%d " },
    { CALG_RSA_SIGN, L"RSA Signature-%d " },
    { CALG_RSA_KEYX, L"RSA Exchange-%d " },
    { CALG_DSS_SIGN, L"DSS-%d " },
    { CALG_DH_SF, L"DH-%d " },
    { CALG_DH_EPHEM, L"DH Ephemeral-%d " },
    { CALG_KEA_KEYX, L"KEA Exchange-%d " },
    { CALG_SKIPJACK, L"SKIPJACK-%d " },
    { CALG_TEK, L"TEK-%d " },
    { CALG_RC5, L"RC5-%d " },
    { CALG_HMAC, L"HMAC-%d " }
};

DWORD   g_cAlgToString = sizeof(g_AlgToString)/sizeof(g_AlgToString[0]);

ALG_TO_STRING g_ProviderToString[] =
{
    {PROV_RSA_FULL,     L"RSA Full"},
    {PROV_RSA_SIG ,     L"RSA Signature Only"},
    {PROV_DSS,          L"DSS"},
    {PROV_FORTEZZA,     L"Fortezza"},
    {PROV_MS_EXCHANGE,  L"Microsoft Exchange"},
    {PROV_SSL,          L"SSL"},
    {PROV_RSA_SCHANNEL, L"RSA SCHANNEL"},
    {PROV_DSS_DH,       L"DSS DH"},
    {PROV_DH_SCHANNEL,  L"DH SCHANNEL"},
    {PROV_SPYRUS_LYNKS, L"Spyrus LYNKS"},
    {PROV_INTEL_SEC,    L"Intel SEC"}

};

DWORD   g_cProviderToString = sizeof(g_ProviderToString)/sizeof(g_ProviderToString[0]);



DWORD        g_dwDefaultCryptProvType    = PROV_RSA_FULL;
DWORD        g_dwAlgID_Encr_Alg          = CALG_RC4;
DWORD        g_dwAlgID_Encr_Alg_KeySize  = 40;
DWORD        g_dwAlgID_MAC_Alg           = CALG_SHA1;
DWORD        g_dwAlgID_MAC_Alg_KeySize   = 160;



void Usage();
VOID PrintAlgID(DWORD dwAlgID, DWORD dwStrength);
BOOL FProviderSupportsAlg(
        HCRYPTPROV  hQueryProv,
        DWORD       dwAlgId,
        DWORD*      pdwKeySize);
DWORD UpdateRegistrySettings(DWORD dwBehavior, HCRYPTPROV hProv);

DWORD UpgradeDPAPIBlob(DWORD dwBehavior,
                 PBYTE *ppbData,
                 DWORD *pcbData,
                 BOOL  *pfModified);

DWORD UpgradeKeys(DWORD dwBehavior);


extern DWORD
GetLocalSystemToken(HANDLE* phRet);


int __cdecl main(int cArg, char *rgszArg[])
{

    DWORD dwBehavior = 0;
    DWORD dwError = ERROR_SUCCESS;
    HCRYPTPROV hProv = 0;
    HANDLE      hToken = NULL;
    int i;

    // Parse command line

    for(i=1; i < cArg; i++)
    {
        LPSTR szCurrentArg = rgszArg[i];

        if((*szCurrentArg != '-') &&
           (*szCurrentArg != '/'))
        {
            Usage();
            goto error;
        }
        szCurrentArg++;

        while(*szCurrentArg)
        {

            switch(*szCurrentArg++)
            {
                case 'f':
                case 'F':
                    dwBehavior |= BEHAVIOR_FORCE_KEY;
                    break;

                case 'e':
                case 'E':
                    dwBehavior |= BEHAVIOR_FORCE_ENC;
                    break;

                case 'v':
                case 'V':
                    dwBehavior |= BEHAVIOR_VERBOSE;
                    break;

                case 'u':
                case 'U':
                    dwBehavior |= BEHAVIOR_ALLOW_UI;
                    break;

                case 'm':
                case 'M':
                    dwBehavior |= BEHAVIOR_MACHINE;
                    break;

                case 's':
                case 'S':
                    dwBehavior |= BEHAVIOR_NO_CHANGE | BEHAVIOR_VERBOSE;
                    break;

                default:
                    Usage();
                    goto error;
            }


        }
    }

    if(!CryptAcquireContext(&hProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
    {
        if(!CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
        {
            dwError = GetLastError();
            printf("Could not acquire a crypt context:%lx\n", dwError);
            goto error;
        }
        dwBehavior |= BEHAVIOR_EXPORT;

    }

    dwError = UpdateRegistrySettings(dwBehavior, hProv);

    if(dwError != ERROR_SUCCESS)
    {
        goto error;
    }

    if(dwBehavior & BEHAVIOR_MACHINE)
    {
        dwError = GetLocalSystemToken(&hToken);

        if(ERROR_SUCCESS == dwError)
        {
            if(!ImpersonateLoggedOnUser(hToken))
            {
                dwError = GetLastError();
            }
        }

        if(ERROR_ACCESS_DENIED == dwError)
        {
            printf("You must be an administrator to upgrade machine keys\n");
            goto error;
        }
        if(ERROR_SUCCESS != dwError)
        {
            printf("Cannot impersonate local machine:%lx\n", dwError);
        }

    }

    dwError = UpgradeKeys(dwBehavior);

    if(dwError != ERROR_SUCCESS)
    {
        goto error;
    }

error:

    if(hProv)
    {
        CryptReleaseContext(hProv, 0);
    }
    if(hToken)
    {
        RevertToSelf();
        CloseHandle(hToken);
    }
    return (ERROR_SUCCESS == dwError)?0:-1;

}


void Usage()
{
    printf("Usage: keymigrt [-f] [-v] [-u] [-m] [-s]\n");
    printf("CAPI Key upgrade utility\n");
    printf("\t-f - Force key upgrade\n");
    printf("\t-e - Force Encryption Settings upgrade\n");
    printf("\t-v - Verbose\n");
    printf("\t-u - Allow upgrade of UI protected keys\n");
    printf("\t-m - Upgrade machine keys\n");
    printf("\t-s - Show current state, but make no modifications\n\n");
}



VOID PrintAlgID(DWORD dwAlgID, DWORD dwStrength)
{
    DWORD i;
    for(i=0; i < g_cAlgToString; i++)
    {
        if(dwAlgID == g_AlgToString[i].AlgId)
        {
             wprintf(g_AlgToString[i].wszString, dwStrength);
             break;
        }
    }

    if(i == g_cAlgToString)
    {
        wprintf(L"Unknown 0x%lx - %d", dwAlgID, dwStrength);
    }
};


VOID PrintProviderID(DWORD dwProviderID)
{
    DWORD i;
    for(i=0; i < g_cProviderToString; i++)
    {
        if(dwProviderID == g_ProviderToString[i].AlgId)
        {
             wprintf(g_ProviderToString[i].wszString);
             break;
        }
    }

    if(i == g_cProviderToString)
    {
        wprintf(L"Unknown 0x%lx ", dwProviderID);
    }
};

DWORD UpdateRegistrySettings(DWORD dwBehavior, HCRYPTPROV hProv)
{

    DWORD   dwReturn = ERROR_SUCCESS;
    HKEY    hKey = NULL;
    static const WCHAR szProviderKeyName[] = REG_CRYPTPROTECT_LOC L"\\" REG_CRYPTPROTECT_PROVIDERS_SUBKEYLOC L"\\" CRYPTPROTECT_DEFAULT_PROVIDER_GUIDSZ ;

    DWORD        dwDefaultCryptProvType    = 0;
    DWORD        dwAlgID_Encr_Alg          = 0;
    DWORD        dwAlgID_Encr_Alg_KeySize  = -1;
    DWORD        dwAlgID_MAC_Alg           = 0;
    DWORD        dwAlgID_MAC_Alg_KeySize   = -1;

    DWORD        cbParameter;
    DWORD        dwValueType;
    DWORD        dwParameterValue;
    DWORD        dwDisposition;
    BOOL         fUpgrade = FALSE;

    SC_HANDLE    hscManager = NULL;
    SC_HANDLE    hscProtectedStorage = NULL;
    SERVICE_STATUS sStatus;
    DWORD        dwWaitTime = 0;


    dwReturn = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                 szProviderKeyName,
                 0,
                 KEY_READ,
                 &hKey);

    if((ERROR_SUCCESS != dwReturn) &&
       (ERROR_FILE_NOT_FOUND != dwReturn))
    {
        printf("Could not open registry: %lx\n", dwReturn);
        goto error;
    }

    if(hKey)
    {
        cbParameter = sizeof(DWORD);
        dwReturn = RegQueryValueExW(
                        hKey,
                        CRYPTPROTECT_DEFAULT_PROVIDER_ENCR_ALG,
                        NULL,
                        &dwValueType,
                        (PBYTE)&dwParameterValue,
                        &cbParameter
                        );
        if( dwReturn == ERROR_SUCCESS && dwValueType == REG_DWORD ) {
            // if successful, commit
            dwAlgID_Encr_Alg = dwParameterValue;
        }

        cbParameter = sizeof(DWORD);
        dwReturn = RegQueryValueExW(
                        hKey,
                        CRYPTPROTECT_DEFAULT_PROVIDER_ENCR_ALG_KEYSIZE,
                        NULL,
                        &dwValueType,
                        (PBYTE)&dwParameterValue,
                        &cbParameter
                        );
        if( dwReturn == ERROR_SUCCESS && dwValueType == REG_DWORD ) {
            // if successful, commit
            dwAlgID_Encr_Alg_KeySize = dwParameterValue;
        }

        cbParameter = sizeof(DWORD);
        dwReturn = RegQueryValueExW(
                        hKey,
                        CRYPTPROTECT_DEFAULT_PROVIDER_MAC_ALG,
                        NULL,
                        &dwValueType,
                        (PBYTE)&dwParameterValue,
                        &cbParameter
                        );
        if( dwReturn == ERROR_SUCCESS && dwValueType == REG_DWORD ) {
            // if successful, commit
            dwAlgID_MAC_Alg = dwParameterValue;
        }

        cbParameter = sizeof(DWORD);
        dwReturn = RegQueryValueExW(
                        hKey,
                        CRYPTPROTECT_DEFAULT_PROVIDER_MAC_ALG_KEYSIZE,
                        NULL,
                        &dwValueType,
                        (PBYTE)&dwParameterValue,
                        &cbParameter
                        );
        if( dwReturn == ERROR_SUCCESS && dwValueType == REG_DWORD ) {
            // if successful, commit
            dwAlgID_MAC_Alg_KeySize = dwParameterValue;
        }

        cbParameter = sizeof(DWORD);
        dwReturn = RegQueryValueExW(
                        hKey,
                        CRYPTPROTECT_DEFAULT_PROVIDER_CRYPT_PROV_TYPE,
                        NULL,
                        &dwValueType,
                        (PBYTE)&dwParameterValue,
                        &cbParameter
                        );
        if( dwReturn == ERROR_SUCCESS && dwValueType == REG_DWORD ) {
            // if successful, commit
            dwDefaultCryptProvType = dwParameterValue;
        }
    }

    if(0 != dwAlgID_Encr_Alg)
    {
        g_dwAlgID_Encr_Alg = dwAlgID_Encr_Alg;
    }
    g_dwAlgID_Encr_Alg_KeySize = dwAlgID_Encr_Alg_KeySize;

    FProviderSupportsAlg(hProv, g_dwAlgID_Encr_Alg, &g_dwAlgID_Encr_Alg_KeySize);

    if(0 != dwAlgID_MAC_Alg)
    {
        g_dwAlgID_MAC_Alg = dwAlgID_MAC_Alg;
    }
    g_dwAlgID_MAC_Alg_KeySize = dwAlgID_MAC_Alg_KeySize;

    FProviderSupportsAlg(hProv, g_dwAlgID_MAC_Alg, &g_dwAlgID_MAC_Alg_KeySize);

    if(0 != dwDefaultCryptProvType)
    {
        g_dwDefaultCryptProvType = dwDefaultCryptProvType;
    }


    if(dwBehavior & BEHAVIOR_VERBOSE)
    {
        printf("System Encryption Settings\n");
        printf("Provider Type:\t");
        PrintProviderID(g_dwDefaultCryptProvType);
        if(0 == dwDefaultCryptProvType)
        {
            printf(" (default)");
        }
        printf("\n");

        printf("Encryption Alg:\t");
        PrintAlgID(g_dwAlgID_Encr_Alg, g_dwAlgID_Encr_Alg_KeySize);
        if(-1 == dwAlgID_Encr_Alg_KeySize)
        {
            printf(" (default)");
        }
        printf("\n");

        printf("MAC Alg:\t");
        PrintAlgID(g_dwAlgID_MAC_Alg, g_dwAlgID_MAC_Alg_KeySize);
        if(-1 == dwAlgID_MAC_Alg_KeySize)
        {
            printf(" (default)");
        }
        printf("\n\n");
    }


    if(dwBehavior & BEHAVIOR_NO_CHANGE)
    {
        goto error;
    }
    //
    // Ok, upgrade the settings
    //
    if(hKey)
    {
        RegCloseKey(hKey);
        hKey = NULL;
    }


    // upgrade the algorithms (but never downgrade)

    if(dwBehavior & BEHAVIOR_EXPORT)
    {
        DWORD dwDESKeySize = -1;
        FProviderSupportsAlg(hProv, CALG_DES, &dwDESKeySize);


        // upgrade to export strength
        if((BEHAVIOR_FORCE_ENC & dwBehavior) ||     // upgrade if forced
            (0 == dwAlgID_Encr_Alg) ||              // upgrade if no settings are present
            ( dwDESKeySize > g_dwAlgID_Encr_Alg_KeySize))   // upgrade if other is weak
        {
            dwAlgID_Encr_Alg = CALG_DES;
            dwAlgID_Encr_Alg_KeySize = dwDESKeySize;
            fUpgrade = TRUE;
        }
        else
        {
            dwAlgID_Encr_Alg = g_dwAlgID_Encr_Alg;
            dwAlgID_Encr_Alg_KeySize = g_dwAlgID_Encr_Alg_KeySize;
        }
    }
    else
    {
        DWORD dw3DESKeySize = -1;
        FProviderSupportsAlg(hProv, CALG_3DES, &dw3DESKeySize);

        // upgrade to domestic strength
        if((BEHAVIOR_FORCE_ENC & dwBehavior) ||     // upgrade if forced
            (0 == dwAlgID_Encr_Alg) ||              // upgrade if no settings
            (CALG_DES == dwAlgID_Encr_Alg) ||       // upgrade if previously DES
            ( dw3DESKeySize > g_dwAlgID_Encr_Alg_KeySize) ) // upgrade if weak
        {
            dwAlgID_Encr_Alg = CALG_3DES;
            dwAlgID_Encr_Alg_KeySize = dw3DESKeySize;
            fUpgrade = TRUE;
        }
        else
        {
            dwAlgID_Encr_Alg = g_dwAlgID_Encr_Alg;
            dwAlgID_Encr_Alg_KeySize = g_dwAlgID_Encr_Alg_KeySize;
        }

    }


    FProviderSupportsAlg(hProv, CALG_SHA1, &dwAlgID_MAC_Alg_KeySize);

    if((BEHAVIOR_FORCE_ENC & dwBehavior) ||
       (g_dwAlgID_MAC_Alg_KeySize < dwAlgID_MAC_Alg_KeySize))
    {

        dwAlgID_MAC_Alg = CALG_SHA1;
        fUpgrade = TRUE;
    }
    else
    {
        dwAlgID_MAC_Alg_KeySize = g_dwAlgID_MAC_Alg_KeySize;
        dwAlgID_MAC_Alg = g_dwAlgID_MAC_Alg;
    }

    if(!fUpgrade)
    {
        // no upgrade necessary

        if(dwBehavior & BEHAVIOR_VERBOSE)
        {
            printf("No system encryption settings upgrade is necessary\n");
        }
        goto error;
    }

    dwReturn = RegCreateKeyExW(
                HKEY_LOCAL_MACHINE,
                szProviderKeyName,
                0,
                NULL,
                0,
                KEY_ALL_ACCESS,
                NULL,
                &hKey,
                &dwDisposition
                );

    if(ERROR_ACCESS_DENIED == dwReturn)
    {
        printf("You must be administrator to upgrade system encryption settings.\n");
        dwReturn = ERROR_SUCCESS;
        goto error;
    }
    if(ERROR_SUCCESS != dwReturn)
    {
        printf("Could not open system's encryption settings for write:%lx\n", dwReturn);
        goto error;
    }


    dwReturn = RegSetValueExW(
                    hKey,
                    CRYPTPROTECT_DEFAULT_PROVIDER_ENCR_ALG,
                    0,
                    REG_DWORD,
                    (PBYTE)&dwAlgID_Encr_Alg,
                    sizeof(dwAlgID_Encr_Alg)
                    );
    if( dwReturn == ERROR_SUCCESS) {
        // if successful, commit
        g_dwAlgID_Encr_Alg = dwAlgID_Encr_Alg;
    }
    else
    {
        printf("Could not set encryption alg:%lx\n", dwReturn);
        goto error;
    }


    dwReturn = RegSetValueExW(
                    hKey,
                    CRYPTPROTECT_DEFAULT_PROVIDER_ENCR_ALG_KEYSIZE,
                    0,
                    REG_DWORD,
                    (PBYTE)&dwAlgID_Encr_Alg_KeySize,
                    sizeof(dwAlgID_Encr_Alg_KeySize)
                    );
    if( dwReturn == ERROR_SUCCESS ) {
        // if successful, commit
        g_dwAlgID_Encr_Alg_KeySize = dwAlgID_Encr_Alg_KeySize;
    }
    else
    {
        printf("Could not set encryption Key Size:%lx\n", dwReturn);
        goto error;
    }

    dwReturn = RegSetValueExW(
                    hKey,
                    CRYPTPROTECT_DEFAULT_PROVIDER_MAC_ALG,
                    0,
                    REG_DWORD,
                    (PBYTE)&dwAlgID_MAC_Alg,
                    sizeof(dwAlgID_MAC_Alg)
                    );
    if( dwReturn == ERROR_SUCCESS) {
        // if successful, commit
        g_dwAlgID_MAC_Alg = dwAlgID_MAC_Alg;
    }
    else
    {
        printf("Could not set MAC Alg:%lx\n", dwReturn);
        goto error;
    }

    dwReturn = RegSetValueExW(
                    hKey,
                    CRYPTPROTECT_DEFAULT_PROVIDER_MAC_ALG_KEYSIZE,
                    0,
                    REG_DWORD,
                    (PBYTE)&dwAlgID_MAC_Alg_KeySize,
                    sizeof(dwAlgID_MAC_Alg_KeySize)
                    );
    if( dwReturn == ERROR_SUCCESS && dwValueType == REG_DWORD ) {
        // if successful, commit
        g_dwAlgID_MAC_Alg_KeySize = dwAlgID_MAC_Alg_KeySize;
    }
    else
    {
        printf("Could not set MAC Key size:%lx\n", dwReturn);
        goto error;
    }

    dwReturn = RegSetValueExW(
                    hKey,
                    CRYPTPROTECT_DEFAULT_PROVIDER_CRYPT_PROV_TYPE,
                    0,
                    REG_DWORD,
                    (PBYTE)&dwDefaultCryptProvType,
                    sizeof(dwDefaultCryptProvType)
                    );
    if( dwReturn == ERROR_SUCCESS && dwValueType == REG_DWORD ) {
        // if successful, commit
        g_dwDefaultCryptProvType = dwDefaultCryptProvType;
    }
    else
    {
        printf("Could not set provider type:%lx\n", dwReturn);
        goto error;
    }
    if(dwBehavior & BEHAVIOR_VERBOSE)
    {
        printf("Upgrading system encryption settings\n");
        printf("System Encryption Settings\n");
        printf("Provider Type:\t");
        PrintProviderID(g_dwDefaultCryptProvType);
        if(0 == dwDefaultCryptProvType)
        {
            printf(" (default)");
        }
        printf("\n");

        printf("Encryption Alg:\t");
        PrintAlgID(g_dwAlgID_Encr_Alg, g_dwAlgID_Encr_Alg_KeySize);
        if(-1 == dwAlgID_Encr_Alg_KeySize)
        {
            printf(" (default)");
        }
        printf("\n");

        printf("MAC Alg:\t");
        PrintAlgID(g_dwAlgID_MAC_Alg, g_dwAlgID_MAC_Alg_KeySize);
        if(-1 == dwAlgID_MAC_Alg_KeySize)
        {
            printf(" (default)");
        }
        printf("\n\n");

        printf("Restarting ProtectedStorage Service...\n");
    }

    // Attempt to restart the protected storage service

    hscManager = OpenSCManager(NULL, NULL, GENERIC_EXECUTE);

    if(NULL == hscManager)
    {
        dwReturn = GetLastError();
        printf("Could not open service controller:%lx\n", dwReturn);
    }

    hscProtectedStorage = OpenServiceW(hscManager, L"ProtectedStorage", GENERIC_READ | GENERIC_EXECUTE);
    if(NULL == hscManager)
    {
        dwReturn = GetLastError();
        printf("Could not open ProtectedStorage service:%lx\n", dwReturn);
    }

    // Shut down pstore

    if(!QueryServiceStatus(hscProtectedStorage, &sStatus))
    {
        dwReturn = GetLastError();
        printf("Could not query ProtectedStorage service status:%lx\n", dwReturn);
        goto error;
    }

    while(SERVICE_STOPPED != sStatus.dwCurrentState)
    {
        DWORD dwLastStatus = sStatus.dwCurrentState;
        DWORD dwCheckpoint = sStatus.dwCheckPoint;

        switch(sStatus.dwCurrentState)
        {
        case SERVICE_RUNNING:
            if(!ControlService(hscProtectedStorage, SERVICE_CONTROL_STOP, &sStatus))
            {
                dwReturn = GetLastError();
                printf("Could not stop ProtectedStorage service:%lx\n", dwReturn);
                goto error;
            }
            break;
        case SERVICE_PAUSED:
            if(!ControlService(hscProtectedStorage, SERVICE_CONTROL_CONTINUE, &sStatus))
            {
                dwReturn = GetLastError();
                printf("Could not continue ProtectedStorage service:%lx\n", dwReturn);
                goto error;
            }
            break;
        default:

            if(!QueryServiceStatus(hscProtectedStorage, &sStatus))
            {
                dwReturn = GetLastError();
                printf("Could not query ProtectedStorage service status:%lx\n", dwReturn);
                goto error;
            }

            break;
        }

        Sleep(sStatus.dwWaitHint);

        if((sStatus.dwCheckPoint == dwCheckpoint) &&
           (sStatus.dwCurrentState == dwLastStatus))
        {
            dwWaitTime += sStatus.dwWaitHint;

            if(dwWaitTime > 120000) // 2 minutes
            {
                printf("Service is not responding\n");
                goto error;
            }
        }
        else
        {
            dwWaitTime = 0;
        }
    }

    if(!StartService(hscProtectedStorage, 0, NULL))
    {
        dwReturn = GetLastError();
        printf("Could not start ProtectedStorage service:%lx\n", dwReturn);
        goto error;
    }

error:

    if(hKey)
    {
        RegCloseKey(hKey);
    }

    return dwReturn;
}


BOOL FProviderSupportsAlg(
        HCRYPTPROV  hQueryProv,
        DWORD       dwAlgId,
        DWORD*      pdwKeySize)
{
    PROV_ENUMALGS       sSupportedAlgs;
    PROV_ENUMALGS_EX    sSupportedAlgsEx;
    DWORD       cbSupportedAlgs = sizeof(sSupportedAlgs);
    DWORD       cbSupportedAlgsEx = sizeof(sSupportedAlgsEx);
    int iAlgs;


    // now we have provider; enum the algorithms involved
    for(iAlgs=0; ; iAlgs++)
    {

        //
        // Attempt the EX alg enumeration
        if (CryptGetProvParam(
                hQueryProv,
                PP_ENUMALGS_EX,
                (PBYTE)&sSupportedAlgsEx,
                &cbSupportedAlgsEx,
                (iAlgs == 0) ? CRYPT_FIRST : 0  ))
        {
            if (sSupportedAlgsEx.aiAlgid == dwAlgId)
            {
                if(*pdwKeySize == -1)
                {
                    *pdwKeySize = sSupportedAlgsEx.dwMaxLen;
                }
                else
                {
                    if ((sSupportedAlgsEx.dwMinLen > *pdwKeySize) ||
                        (sSupportedAlgsEx.dwMaxLen < *pdwKeySize))
                        return FALSE;
                }

                return TRUE;

            }
        }
        else if (!CryptGetProvParam(
                hQueryProv,
                PP_ENUMALGS,
                (PBYTE)&sSupportedAlgs,
                &cbSupportedAlgs,
                (iAlgs == 0) ? CRYPT_FIRST : 0  ))
        {
            // trouble enumerating algs
            break;


            if (sSupportedAlgs.aiAlgid == dwAlgId)
            {
                // were we told to ignore size?
                if (*pdwKeySize != -1)
                {
                    // else, if defaults don't match
                    if (sSupportedAlgs.dwBitLen != *pdwKeySize)
                    {
                        return FALSE;
                    }
                }

                // report back size
                *pdwKeySize = sSupportedAlgs.dwBitLen;
                return TRUE;
            }
        }
        else
        {
            // trouble enumerating algs
            break;
        }
    }

    return FALSE;
}
    DWORD
GetUserStorageArea(
    IN      DWORD dwProvType,
    IN      BOOL fMachineKeyset,
    IN      BOOL fOldWin2KMachineKeyPath,
    OUT     BOOL *pfIsLocalSystem,      // used if fMachineKeyset is FALSE, in this
                                        // case TRUE is returned if running as Local System
    IN  OUT LPWSTR *ppwszUserStorageArea
    );



DWORD UpgradeKeys(DWORD dwBehavior)
{

    DWORD   aProvTypes[] = {PROV_RSA_FULL, PROV_DSS };
    DWORD   cProvTypes = sizeof(aProvTypes)/sizeof(aProvTypes[0]);
    DWORD   iProv;

    DWORD   dwLastError = ERROR_SUCCESS;
    HANDLE  hFind = INVALID_HANDLE_VALUE;
    CHAR   szContainerName[MAX_PATH+1];
    DWORD   cbContainerName = 0;
    BOOL    fModified;


    for(iProv = 0; iProv < cProvTypes; iProv++)
    {
        DWORD dwContainerFlags = CRYPT_FIRST;


        while(TRUE)
        {
            KEY_CONTAINER_INFO ContInfo;
            cbContainerName = MAX_PATH + 1;
            ZeroMemory(&ContInfo, sizeof(ContInfo));

            dwLastError = GetNextContainer(aProvTypes[iProv],
                               dwBehavior & BEHAVIOR_MACHINE,
                               dwContainerFlags,
                               szContainerName,
                               &cbContainerName,
                               &hFind);

            if(ERROR_NO_MORE_ITEMS == dwLastError)
            {
                hFind = INVALID_HANDLE_VALUE;
            }
            if(ERROR_SUCCESS != dwLastError)
            {
                break;
            }

            dwContainerFlags = 0;
            fModified = FALSE;

            dwLastError = ReadContainerInfo(
                                aProvTypes[iProv],
                                szContainerName,
                                dwBehavior & BEHAVIOR_MACHINE,
                                0,
                                &ContInfo
                                );

            if(ERROR_SUCCESS != dwLastError)
            {
                continue;
            }


            if(dwBehavior & BEHAVIOR_VERBOSE)
            {
                printf("========================================\n");
                printf("Key Container:\t\t%s\n\n",szContainerName);
            }

            if((ContInfo.ContLens.cbExchEncPriv) &&
               (ContInfo.pbExchEncPriv))
            {
                if(dwBehavior & BEHAVIOR_VERBOSE)
                {
                    printf(" Exchange Key\n");
                }

                dwLastError = UpgradeDPAPIBlob(dwBehavior,
                                               &ContInfo.pbExchEncPriv,
                                               &ContInfo.ContLens.cbExchEncPriv,
                                               &fModified);
                printf("\n");
            }

            if((ContInfo.ContLens.cbSigEncPriv) &&
               (ContInfo.pbSigEncPriv))
            {
                if(dwBehavior & BEHAVIOR_VERBOSE)
                {
                    printf(" Signature Key\n");
                }

                dwLastError = UpgradeDPAPIBlob(dwBehavior,
                                               &ContInfo.pbSigEncPriv,
                                               &ContInfo.ContLens.cbSigEncPriv,
                                               &fModified);
                printf("\n");
            }

            if(dwBehavior & BEHAVIOR_VERBOSE)
            {

                if(((0 == ContInfo.ContLens.cbExchEncPriv) ||
                    (NULL == ContInfo.pbExchEncPriv)) &&
                   ((0 == ContInfo.ContLens.cbSigEncPriv) ||
                    (NULL == ContInfo.pbSigEncPriv)))
                {
                    printf(" There are no keys in this container\n\n");
                }
            }

            if(((dwBehavior & BEHAVIOR_FORCE_ENC) || fModified) &&
                (0 == (dwBehavior & BEHAVIOR_NO_CHANGE)));
            {
                dwLastError = WriteContainerInfo(
                                    aProvTypes[iProv],
                                    ContInfo.rgwszFileName,
                                    dwBehavior & BEHAVIOR_MACHINE,
                                    &ContInfo
                                    );
            }
            FreeContainerInfo(&ContInfo);
        }
    }


    if(INVALID_HANDLE_VALUE != hFind)
    {
        CloseHandle(hFind);
    }
    return dwLastError;
}


typedef struct _DPAPI_BLOB_DATA
{
    DWORD dwVersion;
    DWORD dwFlags;
    LPWSTR wszDataDescription;
    DWORD cbDataDescription;
    DWORD EncrAlg;
    DWORD EncrAlgSize;
    DWORD MacAlg;
    DWORD MacAlgSize;
} DPAPI_BLOB_DATA, *PDPAPI_BLOB_DATA;





DWORD GetBlobData(PBYTE pbData, DWORD cbData, PDPAPI_BLOB_DATA BlobData)
{
    PBYTE pbCurrent = pbData;
    DWORD dwKeySize = 0;

    if(cbData < sizeof (DWORD) +
                sizeof(GUID) +
                sizeof(DWORD) +
                sizeof(GUID) +
                sizeof(DWORD) +
                sizeof(DWORD))
    {
        return ERROR_INVALID_DATA;
    }

    pbCurrent += sizeof(DWORD) + sizeof(GUID);

    BlobData->dwVersion = *(DWORD UNALIGNED *)pbCurrent;
    pbCurrent += sizeof(DWORD) + sizeof(GUID);

    BlobData->dwFlags = *(DWORD UNALIGNED *)pbCurrent;
    pbCurrent += sizeof(DWORD);

    BlobData->cbDataDescription = *(DWORD UNALIGNED *)pbCurrent;
    pbCurrent += sizeof(DWORD);

    if((DWORD)(pbCurrent - pbData) +
              BlobData->cbDataDescription +
              sizeof(DWORD) +
              sizeof(DWORD) +
              sizeof(DWORD)> cbData)
    {
        return ERROR_INVALID_DATA;
    }
    BlobData->wszDataDescription = (LPWSTR)pbCurrent;
    pbCurrent += BlobData->cbDataDescription;

    BlobData->EncrAlg = *(DWORD UNALIGNED *)pbCurrent;
    pbCurrent += sizeof(DWORD);

    BlobData->EncrAlgSize = *(DWORD UNALIGNED *)pbCurrent;
    pbCurrent += sizeof(DWORD);

    // skip past key
    dwKeySize = *(DWORD UNALIGNED *)pbCurrent;
    pbCurrent += sizeof(DWORD);

    if((DWORD)(pbCurrent - pbData) +
        dwKeySize +
        sizeof(DWORD) > cbData)
    {
        return ERROR_INVALID_DATA;
    }
    pbCurrent += dwKeySize;

    // skip past salt
    dwKeySize = *(DWORD UNALIGNED *)pbCurrent;
    pbCurrent += sizeof(DWORD);

    if((DWORD)(pbCurrent - pbData) +
        dwKeySize +
        sizeof(DWORD) +
        sizeof(DWORD)> cbData)
    {
        return ERROR_INVALID_DATA;
    }
    pbCurrent += dwKeySize;

    BlobData->MacAlg = *(DWORD UNALIGNED *)pbCurrent;
    pbCurrent += sizeof(DWORD);

    BlobData->MacAlgSize = *(DWORD UNALIGNED *)pbCurrent;
    pbCurrent += sizeof(DWORD);


    return ERROR_SUCCESS;
}

DWORD PrintBlobData(PDPAPI_BLOB_DATA BlobData)
{
    wprintf(L"  Description:\t\t%s\n", BlobData->wszDataDescription);
    wprintf(L"  Encryption Alg:\t");
    PrintAlgID(BlobData->EncrAlg, BlobData->EncrAlgSize);
    wprintf(L"\n");

    wprintf(L"  MAC Alg:\t\t");
    PrintAlgID(BlobData->MacAlg, BlobData->MacAlgSize);
    wprintf(L"\n\n");

    return ERROR_SUCCESS;
}


DWORD UpgradeDPAPIBlob(DWORD dwBehavior,
                 PBYTE *ppbData,
                 DWORD *pcbData,
                 BOOL  *pfModified)
{

    DPAPI_BLOB_DATA BlobData;
    DWORD           dwError = ERROR_SUCCESS;

    DATA_BLOB       DataIn;
    DATA_BLOB       DataOut;
    LPWSTR          wszDescription = NULL;
    CRYPTPROTECT_PROMPTSTRUCT Prompt;
    DWORD           dwFlags = 0;

    DataIn.pbData = NULL;
    DataIn.cbData = 0;
    DataOut.pbData = NULL;
    DataOut.cbData = 0;

    dwError = GetBlobData(*ppbData, *pcbData, &BlobData);

    if(ERROR_SUCCESS != dwError)
    {
        printf("Could not open key:%lx\n ", dwError);
        goto error;
    }

    if(MS_BASE_CRYPTPROTECT_VERSION != BlobData.dwVersion)
    {
        printf("Unknown data version\n");
        dwError = ERROR_INVALID_DATA;
        goto error;
    }
    if(dwBehavior & BEHAVIOR_VERBOSE)
    {
        dwError = PrintBlobData(&BlobData);
    }

    if(dwBehavior & BEHAVIOR_NO_CHANGE)
    {
        goto error;
    }

    // Check to see if upgrade is required
    if((BlobData.EncrAlgSize >= g_dwAlgID_Encr_Alg_KeySize) &&
       (0 == (dwBehavior & BEHAVIOR_FORCE_KEY)))
    {
        if(dwBehavior & BEHAVIOR_VERBOSE)
        {
            printf("  No upgrade necessary\n");
        }
        goto error;
    }
    if(((BlobData.dwFlags & CRYPTPROTECT_PROMPT_ON_UNPROTECT) ||
       (BlobData.dwFlags & CRYPTPROTECT_PROMPT_ON_PROTECT)) &&
       (0 == (dwBehavior & BEHAVIOR_ALLOW_UI)))
    {
        if(dwBehavior & BEHAVIOR_VERBOSE)
        {
            printf("  This key requires UI, and will not be upgraded\n");
        }
        goto error;
    }

    //
    // Upgrade the key
    //
    DataIn.pbData = *ppbData;
    DataIn.cbData = *pcbData;

    Prompt.cbSize = sizeof(Prompt);
    Prompt.dwPromptFlags = BlobData.dwFlags & (CRYPTPROTECT_PROMPT_ON_UNPROTECT | CRYPTPROTECT_PROMPT_ON_PROTECT);
    Prompt.hwndApp = NULL;
    Prompt.szPrompt = L"Key Upgrade Utility\n";

    if(0 == (dwBehavior & BEHAVIOR_ALLOW_UI))
    {
        dwFlags |= CRYPTPROTECT_UI_FORBIDDEN;
    }

    if(0 == (dwBehavior & BEHAVIOR_MACHINE))
    {
        dwFlags |= CRYPTPROTECT_LOCAL_MACHINE;
    }

    if(!CryptUnprotectData(&DataIn,
                       &wszDescription,
                       NULL,
                       NULL,
                       &Prompt,
                       dwFlags,
                       &DataOut))
    {
        dwError = GetLastError();
        printf("Could not unprotect key:%lx\n", dwError);
        goto error;
    }

    DataIn.pbData = NULL;
    DataIn.cbData = 0;
    if(!CryptProtectData(&DataOut,
                       wszDescription,
                       NULL,
                       NULL,
                       &Prompt,
                       dwFlags,
                       &DataIn))
    {
        dwError = GetLastError();
        printf("Could not protect key:%lx\n", dwError);
        goto error;
    }

    dwError = GetBlobData(DataIn.pbData, DataIn.cbData, &BlobData);

    if(ERROR_SUCCESS != dwError)
    {
        printf("Could not open key:%lx\n ", dwError);
        goto error;
    }

    if(MS_BASE_CRYPTPROTECT_VERSION != BlobData.dwVersion)
    {
        printf("Unknown data version\n");
        dwError = ERROR_INVALID_DATA;
        goto error;
    }
    if(dwBehavior & BEHAVIOR_VERBOSE)
    {
        printf("  Upgraded To\n");
        PrintBlobData(&BlobData);
    }


    LocalFree(*ppbData);

    *ppbData = DataIn.pbData;
    *pcbData = DataIn.cbData;


    *pfModified = TRUE;


error:

    if(DataOut.pbData)
    {
        ZeroMemory(DataOut.pbData, DataOut.cbData);
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\programs\maccsp\maccsp.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : client.cxx                                             //
//  DESCRIPTION   : Crypto API interface                                   //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Mar  8 1996 larrys  New                                            //
//                  dbarlow                                                //
//                                                                         //
//  Copyright (C) 1996 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <stdlib.h>
#include <stddef.h>
#include <stdio.h>
#include <imagehlp.h>
#include "des.h"
#include "modes.h"

// SIG in file
#define SIG_RESOURCE_NAME   "#666"
// MAC in file
#define MAC_RESOURCE_NAME   "#667"

static DWORD dwMACInFileVersion = 0x100;

BYTE rgbDESKey[] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef};

// The function MACs the given bytes.
void MACBytes(
              IN DESTable *pDESKeyTable,
              IN BYTE *pbData,
              IN DWORD cbData,
              IN OUT BYTE *pbTmp,
              IN OUT DWORD *pcbTmp,
              IN OUT BYTE *pbMAC,
              IN BOOL fFinal
              )
{
    DWORD   cb = cbData;
    DWORD   cbMACed = 0;

    while (cb)
    {
        if ((cb + *pcbTmp) < DES_BLOCKLEN)
        {
            memcpy(pbTmp + *pcbTmp, pbData + cbMACed, cb);
            *pcbTmp += cb;
            break;
        }
        else
        {
            memcpy(pbTmp + *pcbTmp, pbData + cbMACed, DES_BLOCKLEN - *pcbTmp);
            CBC(des, DES_BLOCKLEN, pbMAC, pbTmp, pDESKeyTable,
                ENCRYPT, pbMAC);
            cbMACed = cbMACed + (DES_BLOCKLEN - *pcbTmp);
            cb = cb - (DES_BLOCKLEN - *pcbTmp);
            *pcbTmp = 0;
        }
    }
}

/*
void QuickTest()
{
    BYTE        rgbTmp[DES_BLOCKLEN];
    DWORD       cbTmp = 0;
    BYTE        rgbMAC[DES_BLOCKLEN] =
    {
        0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef
    };
    DESTable    DESKeyTable;
    DWORD       i;
    BYTE        rgbData[] =
    {
        0x37, 0x36, 0x35, 0x34, 0x33, 0x32, 0x31, 0x20,
        0x4e, 0x6f, 0x77, 0x20, 0x69, 0x73, 0x20, 0x74,
        0x68, 0x65, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x20,
        0x66, 0x6f, 0x72, 0x20, 0x00, 0x00, 0x00, 0x00
    };

    memset(&DESKeyTable, 0, sizeof(DESKeyTable));
    memset(rgbTmp, 0, sizeof(rgbTmp));

    // init the key table
    deskey(&DESKeyTable, rgbDESKey);

    MACBytes(&DESKeyTable, rgbData, sizeof(rgbData), rgbTmp,
             &cbTmp, rgbMAC, TRUE);

    printf("MAC - ");
    for (i = 0; i < DES_BLOCKLEN; i++)
    {
        printf("%02X", rgbMAC[i]);
    }
    printf("\n");
}
*/

// Given hInst, allocs and returns pointers to MAC pulled from
// resource
BOOL GetResourcePtr(
                    IN HMODULE hInst,
                    IN LPSTR pszRsrcName,
                    OUT BYTE **ppbRsrcMAC,
                    OUT DWORD *pcbRsrcMAC
                    )
{
    HRSRC   hRsrc;
    BOOL    fRet = FALSE;

    // Nab resource handle for our signature
    if (NULL == (hRsrc = FindResourceA(hInst, pszRsrcName,
                                       RT_RCDATA)))
        goto Ret;

    // get a pointer to the actual signature data
    if (NULL == (*ppbRsrcMAC = (PBYTE)LoadResource(hInst, hRsrc)))
        goto Ret;

    // determine the size of the resource
    if (0 == (*pcbRsrcMAC = SizeofResource(hInst, hRsrc)))
        goto Ret;

    fRet = TRUE;
Ret:
    return fRet;
}

#define CSP_TO_BE_MACED_CHUNK  4096

// Given hFile, reads the specified number of bytes (cbToBeMACed) from the file
// and MACs these bytes.  The function does this in chunks.
BOOL MACBytesOfFile(
                     IN HANDLE hFile,
                     IN DWORD cbToBeMACed,
                     IN DESTable *pDESKeyTable,
                     IN BYTE *pbTmp,
                     IN DWORD *pcbTmp,
                     IN BYTE *pbMAC,
                     IN BYTE fFinal
                     )
{
    BYTE    rgbChunk[CSP_TO_BE_MACED_CHUNK];
    DWORD   cbRemaining = cbToBeMACed;
    DWORD   cbToRead;
    DWORD   dwBytesRead;
    BOOL    fRet = FALSE;

    //
    // loop over the file for the specified number of bytes
    // updating the hash as we go.
    //

    while (cbRemaining > 0)
    {
        if (cbRemaining < CSP_TO_BE_MACED_CHUNK)
            cbToRead = cbRemaining;
        else
            cbToRead = CSP_TO_BE_MACED_CHUNK;

        if(!ReadFile(hFile, rgbChunk, cbToRead, &dwBytesRead, NULL))
            goto Ret;
        if (dwBytesRead != cbToRead)
            goto Ret;

        MACBytes(pDESKeyTable, rgbChunk, dwBytesRead, pbTmp, pcbTmp,
                 pbMAC, fFinal);
        cbRemaining -= cbToRead;
    }

    fRet = TRUE;
Ret:
    return fRet;
}


BOOL MACTheFileNoSig(
                     IN LPCSTR pszImage,
                     IN DWORD cbImage,
                     IN DWORD dwMACVersion,
                     IN DWORD dwCRCOffset,
                     OUT BYTE *pbMAC
                     )
{
    HMODULE                     hInst = 0;
    MEMORY_BASIC_INFORMATION    MemInfo;
    BYTE                        *pbStart;
    BYTE                        rgbMAC[DES_BLOCKLEN];
    BYTE                        rgbZeroMAC[DES_BLOCKLEN + sizeof(DWORD) * 2];
    BYTE                        *pbPostCRC;   // pointer to just after CRC
    DWORD                       cbCRCToMAC;   // number of bytes from CRC to sig
    DWORD                       cbPostMAC;    // size - (already hashed + signature size)
    BYTE                        *pbPostMAC;
    DWORD                       dwZeroCRC = 0;
    DWORD                       dwBytesRead = 0;
    OFSTRUCT                    ImageInfoBuf;
    HFILE                       hFile = HFILE_ERROR;
    HANDLE                      hMapping = NULL;
    DESTable                    DESKeyTable;
    BYTE                        rgbTmp[DES_BLOCKLEN];
    DWORD                       cbTmp = 0;
    BYTE                        *pbRsrcMAC = NULL;
    DWORD                       cbRsrcMAC;
    BOOL                        fRet = FALSE;

    memset(&MemInfo, 0, sizeof(MemInfo));
    memset(rgbMAC, 0, sizeof(rgbMAC));
    memset(rgbTmp, 0, sizeof(rgbTmp));

    // Load the file
    if (HFILE_ERROR == (hFile = OpenFile(pszImage, &ImageInfoBuf,
                                         OF_READ)))
    {
        goto Ret;
    }

    hMapping = CreateFileMapping((HANDLE)IntToPtr(hFile),
                                  NULL,
                                  PAGE_READONLY,
                                  0,
                                  0,
                                  NULL);
    if(hMapping == NULL)
    {
        goto Ret;
    }

    hInst = MapViewOfFile(hMapping,
                          FILE_MAP_READ,
                          0,
                          0,
                          0);
    if(hInst == NULL)
    {
        goto Ret;
    }
    pbStart = (BYTE*)hInst;

    // Convert pointer to HMODULE, using the same scheme as
    // LoadLibrary (windows\base\client\module.c).
    *((ULONG_PTR*)&hInst) |= 0x00000001;

    // create a zero byte MAC
    memset(rgbZeroMAC, 0, sizeof(rgbZeroMAC));

    if (!GetResourcePtr(hInst, MAC_RESOURCE_NAME, &pbRsrcMAC, &cbRsrcMAC))
    {
        printf("Couldn't find MAC placeholder\n");
        goto Ret;
    }

    pbPostCRC = pbStart + dwCRCOffset + sizeof(DWORD);
    cbCRCToMAC = (DWORD)(pbRsrcMAC - pbPostCRC);
    pbPostMAC = pbRsrcMAC + (DES_BLOCKLEN + sizeof(DWORD) * 2);
    cbPostMAC = (cbImage - (DWORD)(pbPostMAC - pbStart));

    // copy the resource MAC
    if (DES_BLOCKLEN != (cbRsrcMAC - (sizeof(DWORD) * 2)))
    {
        goto Ret;
    }

    // init the key table
    deskey(&DESKeyTable, rgbDESKey);

    // MAC up to the CRC
    if (!MACBytesOfFile((HANDLE)IntToPtr(hFile), dwCRCOffset, &DESKeyTable, rgbTmp,
                        &cbTmp, rgbMAC, FALSE))
    {
        goto Ret;
    }

    // pretend CRC is zeroed
    MACBytes(&DESKeyTable, (BYTE*)&dwZeroCRC, sizeof(DWORD), rgbTmp, &cbTmp,
             rgbMAC, FALSE);
    if (!SetFilePointer((HANDLE)IntToPtr(hFile), sizeof(DWORD), NULL, FILE_CURRENT))
    {
        goto Ret;
    }

    // MAC from CRC to MAC resource
    if (!MACBytesOfFile((HANDLE)IntToPtr(hFile), cbCRCToMAC, &DESKeyTable, rgbTmp,
                        &cbTmp, rgbMAC, FALSE))
    {
        goto Ret;
    }

    // pretend image has zeroed MAC
    MACBytes(&DESKeyTable, (BYTE*)rgbZeroMAC, cbRsrcMAC, rgbTmp, &cbTmp,
             rgbMAC, FALSE);
    if (!SetFilePointer((HANDLE)IntToPtr(hFile), cbRsrcMAC, NULL, FILE_CURRENT))
    {
        goto Ret;
    }

    // MAC after the resource
    if (!MACBytesOfFile((HANDLE)IntToPtr(hFile), cbPostMAC, &DESKeyTable, rgbTmp, &cbTmp,
                        rgbMAC, TRUE))
    {
        goto Ret;
    }

    memcpy(pbMAC, rgbMAC, DES_BLOCKLEN);

    fRet = TRUE;
Ret:
    if (pbRsrcMAC)
        FreeResource(pbRsrcMAC);
    if(hInst)
        UnmapViewOfFile(hInst);
    if(hMapping)
        CloseHandle(hMapping);
    if (HFILE_ERROR != hFile)
        _lclose(hFile);

    return fRet;
}

BOOL MACTheFileWithSig(
                       LPCSTR pszImage,
                       DWORD cbImage,
                       IN DWORD dwMACVersion,
                       IN DWORD dwCRCOffset,
                       OUT BYTE *pbMAC
                       )
{
    HMODULE                     hInst = 0;
    MEMORY_BASIC_INFORMATION    MemInfo;
    BYTE                        *pbRsrcMAC = NULL;
    DWORD                       cbRsrcMAC;
    BYTE                        *pbRsrcSig = NULL;
    DWORD                       cbRsrcSig;
    BYTE                        *pbStart;
    BYTE                        rgbMAC[DES_BLOCKLEN];
    BYTE                        rgbZeroMAC[DES_BLOCKLEN + sizeof(DWORD) * 2];
    BYTE                        rgbZeroSig[144];
    BYTE                        *pbPostCRC;   // pointer to just after CRC
    DWORD                       cbCRCToRsrc1; // number of bytes from CRC to first rsrc
    DWORD                       cbRsrc1ToRsrc2; // number of bytes from first rsrc to second
    DWORD                       cbPostRsrc;    // size - (already hashed + signature size)
    BYTE                        *pbRsrc1ToRsrc2;
    BYTE                        *pbPostRsrc;
    BYTE                        *pbZeroRsrc1;
    BYTE                        *pbZeroRsrc2;
    DWORD                       cbZeroRsrc1;
    DWORD                       cbZeroRsrc2;
    DWORD                       dwZeroCRC = 0;
    DWORD                       dwBytesRead = 0;
    OFSTRUCT                    ImageInfoBuf;
    HFILE                       hFile = HFILE_ERROR;
    HANDLE                      hMapping = NULL;
    DESTable                    DESKeyTable;
    BYTE                        rgbTmp[DES_BLOCKLEN];
    DWORD                       cbTmp = 0;
    BOOL                        fRet = FALSE;

    memset(&MemInfo, 0, sizeof(MemInfo));
    memset(rgbMAC, 0, sizeof(rgbMAC));
    memset(rgbTmp, 0, sizeof(rgbTmp));

    // Load the file
    if (HFILE_ERROR == (hFile = OpenFile(pszImage, &ImageInfoBuf,
                                         OF_READ)))
    {
        goto Ret;
    }

    hMapping = CreateFileMapping((HANDLE)IntToPtr(hFile),
                                  NULL,
                                  PAGE_READONLY,
                                  0,
                                  0,
                                  NULL);
    if(hMapping == NULL)
    {
        goto Ret;
    }

    hInst = MapViewOfFile(hMapping,
                          FILE_MAP_READ,
                          0,
                          0,
                          0);
    if(hInst == NULL)
    {
        goto Ret;
    }
    pbStart = (BYTE*)hInst;

    // Convert pointer to HMODULE, using the same scheme as
    // LoadLibrary (windows\base\client\module.c).
    *((ULONG_PTR*)&hInst) |= 0x00000001;

    // the MAC resource
    if (!GetResourcePtr(hInst, MAC_RESOURCE_NAME, &pbRsrcMAC, &cbRsrcMAC))
        goto Ret;

    // the MAC resource
    if (!GetResourcePtr(hInst, SIG_RESOURCE_NAME, &pbRsrcSig, &cbRsrcSig))
        goto Ret;

    if (cbRsrcMAC < (sizeof(DWORD) * 2))
        goto Ret;

    // create a zero byte MAC
    memset(rgbZeroMAC, 0, sizeof(rgbZeroMAC));

    // create a zero byte Sig
    memset(rgbZeroSig, 0, sizeof(rgbZeroSig));

    // set up the pointers
    pbPostCRC = pbStart + dwCRCOffset + sizeof(DWORD);
    if (pbRsrcSig > pbRsrcMAC)    // MAC is first Rsrc
    {
        cbCRCToRsrc1 = (DWORD)(pbRsrcMAC - pbPostCRC);
        pbRsrc1ToRsrc2 = pbRsrcMAC + cbRsrcMAC;
        cbRsrc1ToRsrc2 = (DWORD)(pbRsrcSig - pbRsrc1ToRsrc2);
        pbPostRsrc = pbRsrcSig + cbRsrcSig;
        cbPostRsrc = (cbImage - (DWORD)(pbPostRsrc - pbStart));

        // zero pointers
        pbZeroRsrc1 = rgbZeroMAC;
        cbZeroRsrc1 = cbRsrcMAC;
        pbZeroRsrc2 = rgbZeroSig;
        cbZeroRsrc2 = cbRsrcSig;
    }
    else                        // Sig is first Rsrc
    {
        cbCRCToRsrc1 = (DWORD)(pbRsrcSig - pbPostCRC);
        pbRsrc1ToRsrc2 = pbRsrcSig + cbRsrcSig;
        cbRsrc1ToRsrc2 = (DWORD)(pbRsrcMAC - pbRsrc1ToRsrc2);
        pbPostRsrc = pbRsrcMAC + cbRsrcMAC;
        cbPostRsrc = (cbImage - (DWORD)(pbPostRsrc - pbStart));

        // zero pointers
        pbZeroRsrc1 = rgbZeroSig;
        cbZeroRsrc1 = cbRsrcSig;
        pbZeroRsrc2 = rgbZeroMAC;
        cbZeroRsrc2 = cbRsrcMAC;
    }

    // init the key table
    deskey(&DESKeyTable, rgbDESKey);

    // MAC up to the CRC
    if (!MACBytesOfFile((HANDLE)IntToPtr(hFile), dwCRCOffset, &DESKeyTable, rgbTmp,
                        &cbTmp, rgbMAC, FALSE))
    {
        goto Ret;
    }

    // pretend CRC is zeroed
    MACBytes(&DESKeyTable, (BYTE*)&dwZeroCRC, sizeof(DWORD), rgbTmp, &cbTmp,
             rgbMAC, FALSE);
    if (!SetFilePointer((HANDLE)IntToPtr(hFile), sizeof(DWORD), NULL, FILE_CURRENT))
    {
        goto Ret;
    }

    // MAC from CRC to first resource
    if (!MACBytesOfFile((HANDLE)IntToPtr(hFile), cbCRCToRsrc1, &DESKeyTable, rgbTmp,
                        &cbTmp, rgbMAC, FALSE))
    {
        goto Ret;
    }

    // pretend image has zeroed first resource
    MACBytes(&DESKeyTable, (BYTE*)pbZeroRsrc1, cbZeroRsrc1, rgbTmp, &cbTmp,
             rgbMAC, FALSE);
    if (!SetFilePointer((HANDLE)IntToPtr(hFile), cbZeroRsrc1, NULL, FILE_CURRENT))
    {
        goto Ret;
    }

    // MAC from first resource to second
    if (!MACBytesOfFile((HANDLE)IntToPtr(hFile), cbRsrc1ToRsrc2, &DESKeyTable, rgbTmp,
                        &cbTmp, rgbMAC, FALSE))
    {
        goto Ret;
    }

    // pretend image has zeroed second Resource
    MACBytes(&DESKeyTable, (BYTE*)pbZeroRsrc2, cbZeroRsrc2, rgbTmp, &cbTmp,
             rgbMAC, FALSE);
    if (!SetFilePointer((HANDLE)IntToPtr(hFile), cbZeroRsrc2, NULL, FILE_CURRENT))
    {
        goto Ret;
    }

    // MAC after the resource
    if (!MACBytesOfFile((HANDLE)IntToPtr(hFile), cbPostRsrc, &DESKeyTable, rgbTmp, &cbTmp,
                        rgbMAC, TRUE))
    {
        goto Ret;
    }

    memcpy(pbMAC, rgbMAC, DES_BLOCKLEN);

    fRet = TRUE;
Ret:
    if (pbRsrcMAC)
        FreeResource(pbRsrcMAC);
    if (pbRsrcSig)
        FreeResource(pbRsrcSig);
    if(hInst)
        UnmapViewOfFile(hInst);
    if(hMapping)
        CloseHandle(hMapping);
    if (HFILE_ERROR != hFile)
        _lclose(hFile);

    return fRet;
}

DWORD GetCRCOffset(
                   LPCSTR szFile,
                   DWORD cbImage,
                   DWORD *pdwCRCOffset
                   )
{
    DWORD               dwErr = 0x1;

    HANDLE              hFileProv = NULL;
    PBYTE               pbFilePtr = NULL;
    DWORD               OldCheckSum;
    DWORD               NewCheckSum;
    PIMAGE_NT_HEADERS   pImageNTHdrs;

    HANDLE              hFileMap = NULL;


    if (INVALID_HANDLE_VALUE == (hFileProv = CreateFile(szFile,
                                GENERIC_READ | GENERIC_WRITE,
                                0,  // don't share
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                0)))
    {
        printf("Couldn't CreateFile: 0x%x\n", GetLastError());
        goto Ret;
    }

    if (NULL == (hFileMap = CreateFileMapping(
                                hFileProv,
                                NULL,
                                PAGE_READWRITE,
                                0,
                                0,
                                NULL)))
    {
        printf("Couldn't map file\n");
        goto Ret;
    }

    if (NULL == (pbFilePtr = (PBYTE)MapViewOfFile(
                                hFileMap,
                                FILE_MAP_ALL_ACCESS,
                                0,
                                0,
                                0)))
    {
        printf("Couldn't create view\n");
        goto Ret;
    }

    // compute a new checksum
    if (NULL == (pImageNTHdrs = CheckSumMappedFile(pbFilePtr, cbImage,
                                                   &OldCheckSum, &NewCheckSum)))
        goto Ret;

    *pdwCRCOffset = (DWORD)((BYTE*)&pImageNTHdrs->OptionalHeader.CheckSum - pbFilePtr);
    dwErr = ERROR_SUCCESS;
Ret:
    if (pbFilePtr)
        UnmapViewOfFile(pbFilePtr);

    if (hFileMap)
        CloseHandle(hFileMap);

    if (hFileProv)
        CloseHandle(hFileProv);

    return dwErr;
}

// SetCryptMACResource
//
// slams MAC resource in file with the new MAC
//
DWORD SetCryptMACResource(
                          IN LPCSTR szFile,
                          IN DWORD dwMACVersion,
                          IN DWORD dwCRCOffset,
                          IN PBYTE pbNewMAC,
                          IN DWORD cbImage
                          )
{
    DWORD   dwErr = 0x1;

    HANDLE  hFileProv = NULL;
    HMODULE hInst = NULL;

    PBYTE   pbFilePtr = NULL;
    DWORD   cbMACOffset;

    PBYTE   pbMAC;
    DWORD   cbMAC;

    MEMORY_BASIC_INFORMATION    MemInfo;
    BYTE                        *pbStart;

    DWORD               OldCheckSum;
    DWORD               NewCheckSum;
    PIMAGE_NT_HEADERS   pImageNTHdrs;

    HANDLE  hFileMap = NULL;

    memset(&MemInfo, 0, sizeof(MemInfo));

    // Load the file as a datafile
    if (NULL == (hInst = LoadLibraryEx(szFile, NULL, LOAD_LIBRARY_AS_DATAFILE)))
    {
        printf("Couldn't load file\n");
        goto Ret;
    }
    if (!GetResourcePtr(hInst, MAC_RESOURCE_NAME, &pbMAC, &cbMAC))
    {
        printf("Couldn't find MAC placeholder\n");
        goto Ret;
    }

    // get image start address
    VirtualQuery(hInst, &MemInfo, sizeof(MemInfo));
    pbStart = (BYTE*)MemInfo.BaseAddress;

    FreeLibrary(hInst); hInst = NULL;

    cbMACOffset = (DWORD)(pbMAC - pbStart);

    if (cbMAC != (DES_BLOCKLEN + sizeof(DWORD) * 2))
    {
        printf("Attempt to replace %d zeros with new MAC!\n", cbMAC);
        goto Ret;
    }

    if (INVALID_HANDLE_VALUE == (hFileProv = CreateFile(szFile,
                                GENERIC_READ | GENERIC_WRITE,
                                0,  // don't share
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                0)))
    {
        printf("Couldn't CreateFile: 0x%x\n", GetLastError());
        goto Ret;
    }

    if (NULL == (hFileMap = CreateFileMapping(
                                hFileProv,
                                NULL,
                                PAGE_READWRITE,
                                0,
                                0,
                                NULL)))
    {
        printf("Couldn't map file\n");
        goto Ret;
    }

    if (NULL == (pbFilePtr = (PBYTE)MapViewOfFile(
                                hFileMap,
                                FILE_MAP_ALL_ACCESS,
                                0,
                                0,
                                0)))
    {
        printf("Couldn't create view\n");
        goto Ret;
    }

    // copy version, CRC offset and new sig
    CopyMemory(pbFilePtr+cbMACOffset, &dwMACVersion, sizeof(dwMACVersion));
    cbMACOffset += sizeof(dwMACVersion);
    CopyMemory(pbFilePtr+cbMACOffset, &dwCRCOffset, sizeof(dwCRCOffset));
    cbMACOffset += sizeof(dwCRCOffset);
    CopyMemory(pbFilePtr+cbMACOffset, pbNewMAC, DES_BLOCKLEN);

    // compute a new checksum
    if (NULL == (pImageNTHdrs = CheckSumMappedFile(pbFilePtr, cbImage,
                                                   &OldCheckSum, &NewCheckSum)))
        goto Ret;

    CopyMemory(&pImageNTHdrs->OptionalHeader.CheckSum, &NewCheckSum, sizeof(DWORD));

    if (NULL == (pImageNTHdrs = CheckSumMappedFile(pbFilePtr, cbImage,
                                                   &OldCheckSum, &NewCheckSum)))
        goto Ret;

    if (OldCheckSum != NewCheckSum)
        goto Ret;

    dwErr = ERROR_SUCCESS;
Ret:
    if (pbFilePtr)
        UnmapViewOfFile(pbFilePtr);

    if (hFileMap)
        CloseHandle(hFileMap);

    if (hInst)
        FreeLibrary(hInst);

    if (hFileProv)
        CloseHandle(hFileProv);

    return dwErr;
}

void ShowHelp()
{
    printf("CryptoAPI Internal CSP MACing Utility\n");
    printf("maccsp <option> <filename>\n");
    printf("    options\n");
    printf("        m     MAC with no sig resource\n");
    printf("        s     MAC with sig resource\n");
    printf("        ?     Show this message\n");
}

void __cdecl main( int argc, char *argv[])
{
    LPCSTR  szInFile = NULL;
    DWORD   cbImage;
    DWORD   dwCRCOffset;
    HANDLE  hFileProv = 0;
    BYTE    rgbMAC[DES_BLOCKLEN];
    BOOL    fSigInFile = FALSE;
    DWORD   dwRet = 1;

    memset(rgbMAC, 0, sizeof(rgbMAC));

    //
    // Parse the command line.
    //

    if ((argc != 3) || (argv[1][0] == '?'))
    {
        ShowHelp();
        goto Ret;
    }
    else if ('s' == argv[1][0])
    {
        fSigInFile = TRUE;
    }
    else if ('m' == argv[1][0])
    {
        fSigInFile = FALSE;
    }
    else
    {
        ShowHelp();
        goto Ret;
    }


    szInFile = &argv[2][0];

    //
    // Command consistency checks.
    //

    if (NULL == szInFile)
    {
        printf("No input file specified.\n");
        goto Ret;
    }


    // get the file size
    if ((hFileProv = CreateFile(szInFile,
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                0)) == INVALID_HANDLE_VALUE)
    {
        printf("CSP specified was not found!\n");
        goto Ret;
    }

    if (0xffffffff == (cbImage = GetFileSize(hFileProv, NULL)))
    {
        printf("CSP specified was not found!\n");
        goto Ret;
    }

    CloseHandle(hFileProv);
    hFileProv = NULL;

    if (0 != GetCRCOffset(szInFile, cbImage, &dwCRCOffset))
    {
        printf("Unable to get CRC!\n");
        goto Ret;
    }

    // calculate the MAC
    if (fSigInFile)
    {
        if (!MACTheFileWithSig(szInFile, cbImage, dwMACInFileVersion,
                               dwCRCOffset, rgbMAC))
        {
            printf("MAC failed!\n");
            goto Ret;
        }
    }
    else
    {
        if (!MACTheFileNoSig(szInFile, cbImage, dwMACInFileVersion,
                             dwCRCOffset, rgbMAC))
        {
            printf("MAC failed!\n");
            goto Ret;
        }
    }

    //
    // Place the MAC into the resource in the file
    //

    if (ERROR_SUCCESS != SetCryptMACResource(szInFile, dwMACInFileVersion,
                                             dwCRCOffset, rgbMAC, cbImage))
    {
        printf("Unable to set the MAC into the file resource!\n");
        goto Ret;
    }

    //
    // Clean up and return.
    //

    dwRet = 0;


Ret:
    exit(dwRet);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\programs\showsig\showsig.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : showsig.cpp                                             //
//  DESCRIPTION   : Crypto API interface                                   //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      May 4 1998 jeffspel                                                //
//                                                                         //
//  Copyright (C) 1998 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <stdlib.h>
#include <stddef.h>
#include <stdio.h>
#include <rsa.h>
#include <md5.h>
#include <rc4.h>
#include <des.h>
#include <modes.h>

#define MS_INTERNAL_KEY

#define RC4_KEYSIZE 5

#define KEYSIZE512 0x48
#define KEYSIZE1024 0x88
#define SIG_RESOURCE_NUM    1

// designatred resource for in file signatures
#define CRYPT_SIG_RESOURCE_NUMBER   "#666"

// MAC in file
#define MAC_RESOURCE_NUMBER   "#667"

typedef struct _SECONDTIER_SIG
{
    DWORD           dwMagic;
    DWORD           cbSig;
    BSAFE_PUB_KEY   Pub;
} SECOND_TIER_SIG, *PSECOND_TIER_SIG;

BOOL g_fUseTestKey = TRUE;

#ifdef TEST_BUILD_EXPONENT
#pragma message("WARNING: building showsig.exe with TESTKEY enabled!")
static struct _TESTKEY
{
    BSAFE_PUB_KEY PUB;
    unsigned char pubmodulus[KEYSIZE512];
} TESTKEY = {
    {
        0x66b8443b,
        0x6f5fc900,
        0xa12132fe,
        0xff1b06cf,
        0x2f4826eb,
    },
    {
        0x3e, 0x69, 0x4f, 0x45, 0x31, 0x95, 0x60, 0x6c,
        0x80, 0xa5, 0x41, 0x99, 0x3e, 0xfc, 0x92, 0x2c,
        0x93, 0xf9, 0x86, 0x23, 0x3d, 0x48, 0x35, 0x81,
        0x19, 0xb6, 0x7c, 0x04, 0x43, 0xe6, 0x3e, 0xd4,
        0xd5, 0x43, 0xaf, 0x52, 0xdd, 0x51, 0x20, 0xac,
        0xc3, 0xca, 0xee, 0x21, 0x9b, 0x4a, 0x2d, 0xf7,
        0xd8, 0x5f, 0x32, 0xeb, 0x49, 0x72, 0xb9, 0x8d,
        0x2e, 0x1a, 0x76, 0x7f, 0xde, 0xc6, 0x75, 0xab,
        0xaf, 0x67, 0xe0, 0xf0, 0x8b, 0x30, 0x20, 0x92,
    }
};
#endif

static struct _mskey
{
    BSAFE_PUB_KEY PUB;
    unsigned char pubmodulus[KEYSIZE1024];
} MSKEY = {
    {
        0x2bad85ae,
        0x883adacc,
        0xb32ebd68,
        0xa7ec8b06,
        0x58dbeb81,
    },
    {
        0x42, 0x34, 0xb7, 0xab, 0x45, 0x0f, 0x60, 0xcd,
        0x8f, 0x77, 0xb5, 0xd1, 0x79, 0x18, 0x34, 0xbe,
        0x66, 0xcb, 0x5c, 0x66, 0x4a, 0x9f, 0x03, 0x18,
        0x13, 0x36, 0x8e, 0x88, 0x21, 0x78, 0xb1, 0x94,
        0xa1, 0xd5, 0x8f, 0x8c, 0xa5, 0xd3, 0x9f, 0x86,
        0x43, 0x89, 0x05, 0xa0, 0xe3, 0xee, 0xe2, 0xd0,
        0xe5, 0x1d, 0x5f, 0xaf, 0xff, 0x85, 0x71, 0x7a,
        0x0a, 0xdb, 0x2e, 0xd8, 0xc3, 0x5f, 0x2f, 0xb1,
        0xf0, 0x53, 0x98, 0x3b, 0x44, 0xee, 0x7f, 0xc9,
        0x54, 0x26, 0xdb, 0xdd, 0xfe, 0x1f, 0xd0, 0xda,
        0x96, 0x89, 0xc8, 0x9e, 0x2b, 0x5d, 0x96, 0xd1,
        0xf7, 0x52, 0x14, 0x04, 0xfb, 0xf8, 0xee, 0x4d,
        0x92, 0xd1, 0xb6, 0x37, 0x6a, 0xe0, 0xaf, 0xde,
        0xc7, 0x41, 0x06, 0x7a, 0xe5, 0x6e, 0xb1, 0x8c,
        0x8f, 0x17, 0xf0, 0x63, 0x8d, 0xaf, 0x63, 0xfd,
        0x22, 0xc5, 0xad, 0x1a, 0xb1, 0xe4, 0x7a, 0x6b,
        0x1e, 0x0e, 0xea, 0x60, 0x56, 0xbd, 0x49, 0xd0,
    }
};

static struct _key
{
    BSAFE_PUB_KEY PUB;
    unsigned char pubmodulus[KEYSIZE1024];
} KEY = {
    {
        0x3fcbf1a9,
        0x08f597db,
        0xe4aecab4,
        0x75360f90,
        0x9d6c0f00,
    },
    {
        0x85, 0xdd, 0x9b, 0xf4, 0x4d, 0x0b, 0xc4, 0x96,
        0x3e, 0x79, 0x86, 0x30, 0x6d, 0x27, 0x31, 0xee,
        0x4a, 0x85, 0xf5, 0xff, 0xbb, 0xa9, 0xbd, 0x81,
        0x86, 0xf2, 0x4f, 0x87, 0x6c, 0x57, 0x55, 0x19,
        0xe4, 0xf4, 0x49, 0xa3, 0x19, 0x27, 0x08, 0x82,
        0x9e, 0xf9, 0x8a, 0x8e, 0x41, 0xd6, 0x91, 0x71,
        0x47, 0x48, 0xee, 0xd6, 0x24, 0x2d, 0xdd, 0x22,
        0x72, 0x08, 0xc6, 0xa7, 0x34, 0x6f, 0x93, 0xd2,
        0xe7, 0x72, 0x57, 0x78, 0x7a, 0x96, 0xc1, 0xe1,
        0x47, 0x38, 0x78, 0x43, 0x53, 0xea, 0xf3, 0x88,
        0x82, 0x66, 0x41, 0x43, 0xd4, 0x62, 0x44, 0x01,
        0x7d, 0xb2, 0x16, 0xb3, 0x50, 0x89, 0xdb, 0x0a,
        0x93, 0x17, 0x02, 0x02, 0x46, 0x49, 0x79, 0x76,
        0x59, 0xb6, 0xb1, 0x2b, 0xfc, 0xb0, 0x9a, 0x21,
        0xe6, 0xfa, 0x2d, 0x56, 0x07, 0x36, 0xbc, 0x13,
        0x7f, 0x1c, 0xde, 0x55, 0xfb, 0x0d, 0x67, 0x0f,
        0xc2, 0x17, 0x45, 0x8a, 0x14, 0x2b, 0xba, 0x55,
    }
};


static struct _key2
{
    BSAFE_PUB_KEY PUB;
    unsigned char pubmodulus[KEYSIZE1024];
} KEY2 =  {
    {
        0x685fc690,
        0x97d49b6b,
        0x1dccd9d2,
        0xa5ec9b52,
        0x64fd29d7,
    },
    {
        0x03, 0x8c, 0xa3, 0x9e, 0xfb, 0x93, 0xb6, 0x72,
        0x2a, 0xda, 0x6f, 0xa5, 0xec, 0x26, 0x39, 0x58,
        0x41, 0xcd, 0x3f, 0x49, 0x10, 0x4c, 0xcc, 0x7e,
        0x23, 0x94, 0xf9, 0x5d, 0x9b, 0x2b, 0xa3, 0x6b,
        0xe8, 0xec, 0x52, 0xd9, 0x56, 0x64, 0x74, 0x7c,
        0x44, 0x6f, 0x36, 0xb7, 0x14, 0x9d, 0x02, 0x3c,
        0x0e, 0x32, 0xb6, 0x38, 0x20, 0x25, 0xbd, 0x8c,
        0x9b, 0xd1, 0x46, 0xa7, 0xb3, 0x58, 0x4a, 0xb7,
        0xdd, 0x0e, 0x38, 0xb6, 0x16, 0x44, 0xbf, 0xc1,
        0xca, 0x4d, 0x6a, 0x9f, 0xcb, 0x6f, 0x3c, 0x5f,
        0x03, 0xab, 0x7a, 0xb8, 0x16, 0x70, 0xcf, 0x98,
        0xd0, 0xca, 0x8d, 0x25, 0x57, 0x3a, 0x22, 0x8b,
        0x44, 0x96, 0x37, 0x51, 0x30, 0x00, 0x92, 0x1b,
        0x03, 0xb9, 0xf9, 0x0d, 0xb3, 0x1a, 0xe2, 0xb4,
        0xc5, 0x7b, 0xc9, 0x4b, 0xe2, 0x42, 0x25, 0xfe,
        0x3d, 0x42, 0xfa, 0x45, 0xc6, 0x94, 0xc9, 0x8e,
        0x87, 0x7e, 0xf6, 0x68, 0x90, 0x30, 0x65, 0x10,
    }
};

void
EncryptKey(
    BYTE *pdata,
    DWORD size,
    BYTE val)
{
    RC4_KEYSTRUCT key;
    BYTE          RealKey[RC4_KEYSIZE] = {0xa2, 0x17, 0x9c, 0x98, 0xca};
    DWORD         index;

    for (index = 0; index < RC4_KEYSIZE; index++)
    {
        RealKey[index] = RealKey[index] ^ val;
    }

    rc4_key(&key, RC4_KEYSIZE, RealKey);

    rc4(&key, size, pdata);
}

void
MD5HashData(
    BYTE *pb,
    DWORD cb,
    BYTE *pbHash)
{
    MD5_CTX HashState;

    MD5Init(&HashState);

    MD5Update(&HashState, pb, cb);

    // Finish the hash
    MD5Final(&HashState);

    memcpy(pbHash, HashState.digest, 16);
}


BOOL
CheckSignature(
    BYTE *pbKey,
    DWORD cbKey,
    BYTE *pbSig,
    DWORD cbSig,
    BYTE *pbHash,
    BOOL fUnknownLen)
{
    BYTE                rgbResult[KEYSIZE1024];
    BYTE                rgbSig[KEYSIZE1024];
    BYTE                rgbKey[sizeof(BSAFE_PUB_KEY) + KEYSIZE1024];
    BYTE                rgbKeyHash[16];
    BYTE                *pbSecondKey;
    DWORD               cbSecondKey;
    BYTE                *pbKeySig;
    PSECOND_TIER_SIG    pSecondTierSig;
    LPBSAFE_PUB_KEY     pTmp;
    BOOL                fRet = FALSE;

    memset(rgbResult, 0, KEYSIZE1024);
    memset(rgbSig, 0, KEYSIZE1024);

    // just check the straight signature if version is 1
    pTmp = (LPBSAFE_PUB_KEY)pbKey;

    // check if sig length is the same as the key length
    if (fUnknownLen || (cbSig == pTmp->keylen))
    {
        memcpy(rgbSig, pbSig, pTmp->keylen);
        BSafeEncPublic(pTmp, rgbSig, rgbResult);

        if (RtlEqualMemory(pbHash, rgbResult, 16) &&
            rgbResult[cbKey-1] == 0 &&
            rgbResult[cbKey-2] == 1 &&
            rgbResult[16] == 0 &&
            rgbResult[17] == 0xFF)
        {
            fRet = TRUE;
            goto Ret;
        }
    }

    // check the the second tier signature if the magic equals 2
    pSecondTierSig = (PSECOND_TIER_SIG)pbSig;
    if (0x00000002 != pSecondTierSig->dwMagic)
        goto Ret;

    if (0x31415352 != pSecondTierSig->Pub.magic)
        goto Ret;

    // assign the pointers
    cbSecondKey = sizeof(BSAFE_PUB_KEY) + pSecondTierSig->Pub.keylen;
    pbSecondKey = pbSig + (sizeof(SECOND_TIER_SIG) - sizeof(BSAFE_PUB_KEY));
    pbKeySig = pbSecondKey + cbSecondKey;

    // hash the second tier key
    MD5HashData(pbSecondKey, cbSecondKey, rgbKeyHash);

    // Decrypt the signature data on the second tier key
    memset(rgbResult, 0, sizeof(rgbResult));
    memset(rgbSig, 0, sizeof(rgbSig));
    memcpy(rgbSig, pbKeySig, pSecondTierSig->cbSig);
    BSafeEncPublic(pTmp, rgbSig, rgbResult);

    if ((FALSE == RtlEqualMemory(rgbKeyHash, rgbResult, 16)) ||
        rgbResult[cbKey-1] != 0 ||
        rgbResult[cbKey-2] != 1 ||
        rgbResult[16] != 0 ||
        rgbResult[17] != 0)
    {
        goto Ret;
    }

    // Decrypt the signature data on the CSP
    memset(rgbResult, 0, sizeof(rgbResult));
    memset(rgbSig, 0, sizeof(rgbSig));
    memset(rgbKey, 0, sizeof(rgbKey));
    memcpy(rgbSig, pbKeySig + pSecondTierSig->cbSig, pSecondTierSig->cbSig);
    memcpy(rgbKey, pbSecondKey, cbSecondKey);
    pTmp = (LPBSAFE_PUB_KEY)rgbKey;
    BSafeEncPublic(pTmp, rgbSig, rgbResult);

    if (RtlEqualMemory(pbHash, rgbResult, 16) &&
        rgbResult[cbKey-1] == 0 &&
        rgbResult[cbKey-2] == 1 &&
        rgbResult[16] == 0)
    {
        fRet = TRUE;
        if (0xff != rgbResult[18])
        {
            DWORD dwI;

            printf("2nd Tier signature performed by ");
            for (dwI = 18; 0xff != rgbResult[dwI]; dwI += 1)
                printf("%c", rgbResult[dwI]);
            printf(".\n");
        }
    }

Ret:
    return fRet;
}

// Given hInst, allocs and returns pointers to SIG and MAC pulled from
// resource
BOOL
GetResourcePtr(
    IN HMODULE hInst,
    IN LPSTR pszRsrcName,
    OUT BYTE **ppbRsrcMAC,
    OUT DWORD *pcbRsrcMAC)
{
    HRSRC   hRsrc;
    BOOL    fRet = FALSE;

    // Nab resource handle for our signature
    if (NULL == (hRsrc = FindResourceA(hInst, pszRsrcName,
                                       RT_RCDATA)))
        goto Ret;

    // get a pointer to the actual signature data
    if (NULL == (*ppbRsrcMAC = (PBYTE)LoadResource(hInst, hRsrc)))
        goto Ret;

    // determine the size of the resource
    if (0 == (*pcbRsrcMAC = SizeofResource(hInst, hRsrc)))
        goto Ret;

    fRet = TRUE;

Ret:
    return fRet;
}


// GetCryptSignatureResource
//
DWORD
GetCryptSignatureResource(
    LPCSTR szFile,
    PBYTE *ppbNewSig,
    DWORD *pcbNewSig)
{
    DWORD   dwErr = 0x1;
    BYTE    *pbSig;

    HMODULE hInst = NULL;

    // Load the file as a datafile
    if (NULL == (hInst = LoadLibraryEx(szFile, NULL, LOAD_LIBRARY_AS_DATAFILE)))
    {
        printf("Couldn't load file\n");
        goto Ret;
    }
    if (!GetResourcePtr(hInst,
                        CRYPT_SIG_RESOURCE_NUMBER,
                        &pbSig,
                        pcbNewSig))
    {
        printf("Couldn't find signature placeholder\n");
        goto Ret;
    }

    if (NULL == (*ppbNewSig = (BYTE*)LocalAlloc(LMEM_ZEROINIT, *pcbNewSig)))
        goto Ret;

    memcpy(*ppbNewSig, pbSig, *pcbNewSig);

    dwErr = ERROR_SUCCESS;

Ret:
    if (hInst)
        FreeLibrary(hInst);
    return dwErr;
}

#define CSP_TO_BE_MACED_CHUNK  4096

// The function MACs the given bytes.
void
MACBytes(
    IN DESTable *pDESKeyTable,
    IN BYTE *pbData,
    IN DWORD cbData,
    IN OUT BYTE *pbTmp,
    IN OUT DWORD *pcbTmp,
    IN OUT BYTE *pbMAC,
    IN BOOL fFinal)
{
    DWORD   cb = cbData;
    DWORD   cbMACed = 0;

    while (cb)
    {
        if ((cb + *pcbTmp) < DES_BLOCKLEN)
        {
            memcpy(pbTmp + *pcbTmp, pbData + cbMACed, cb);
            *pcbTmp += cb;
            break;
        }
        else
        {
            memcpy(pbTmp + *pcbTmp, pbData + cbMACed, DES_BLOCKLEN - *pcbTmp);
            CBC(des, DES_BLOCKLEN, pbMAC, pbTmp, pDESKeyTable,
                ENCRYPT, pbMAC);
            cbMACed = cbMACed + (DES_BLOCKLEN - *pcbTmp);
            cb = cb - (DES_BLOCKLEN - *pcbTmp);
            *pcbTmp = 0;
        }
    }
}

// Given hFile, reads the specified number of bytes (cbToBeMACed) from the file
// and MACs these bytes.  The function does this in chunks.
BOOL
MACBytesOfFile(
    IN HANDLE hFile,
    IN DWORD cbToBeMACed,
    IN DESTable *pDESKeyTable,
    IN BYTE *pbTmp,
    IN DWORD *pcbTmp,
    IN BYTE *pbMAC,
    IN BYTE fFinal)
{
    BYTE    rgbChunk[CSP_TO_BE_MACED_CHUNK];
    DWORD   cbRemaining = cbToBeMACed;
    DWORD   cbToRead;
    DWORD   dwBytesRead;
    BOOL    fRet = FALSE;

    //
    // loop over the file for the specified number of bytes
    // updating the hash as we go.
    //

    while (cbRemaining > 0)
    {
        if (cbRemaining < CSP_TO_BE_MACED_CHUNK)
            cbToRead = cbRemaining;
        else
            cbToRead = CSP_TO_BE_MACED_CHUNK;

        if (!ReadFile(hFile, rgbChunk, cbToRead, &dwBytesRead, NULL))
            goto Ret;
        if (dwBytesRead != cbToRead)
            goto Ret;

        MACBytes(pDESKeyTable, rgbChunk, dwBytesRead, pbTmp, pcbTmp,
                 pbMAC, fFinal);
        cbRemaining -= cbToRead;
    }

    fRet = TRUE;

Ret:
    return fRet;
}

BYTE rgbMACDESKey[] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef};

BOOL
MACTheFile(
    LPCSTR pszImage,
    DWORD cbImage)
{
    HMODULE                     hInst = 0;
    MEMORY_BASIC_INFORMATION    MemInfo;
    BYTE                        *pbRsrcMAC;
    DWORD                       cbRsrcMAC;
    BYTE                        *pbRsrcSig;
    DWORD                       cbRsrcSig;
    BYTE                        *pbStart;
    BYTE                        rgbMAC[DES_BLOCKLEN];
    BYTE                        *pbZeroRsrc = NULL;
    BYTE                        *pbPostCRC;   // pointer to just after CRC
    DWORD                       cbCRCToRsrc1; // number of bytes from CRC to first rsrc
    DWORD                       cbRsrc1ToRsrc2; // number of bytes from first rsrc to second
    DWORD                       cbPostRsrc;    // size - (already hashed + signature size)
    BYTE                        *pbRsrc1ToRsrc2;
    BYTE                        *pbPostRsrc;
    BYTE                        *pbZeroRsrc1;
    BYTE                        *pbZeroRsrc2;
    DWORD                       cbZeroRsrc1;
    DWORD                       cbZeroRsrc2;
    DWORD                       *pdwMACInFileVer;
    DWORD                       *pdwCRCOffset;
    DWORD                       dwCRCOffset;
    DWORD                       dwZeroCRC = 0;
    DWORD                       dwBytesRead = 0;
    OFSTRUCT                    ImageInfoBuf;
    HFILE                       hFile = HFILE_ERROR;
    HANDLE                      hMapping = NULL;
    DESTable                    DESKeyTable;
    BYTE                        rgbTmp[DES_BLOCKLEN];
    DWORD                       cbTmp = 0;
    BOOL                        fRet = FALSE;
    DWORD                       i;

    memset(&MemInfo, 0, sizeof(MemInfo));
    memset(rgbMAC, 0, sizeof(rgbMAC));
    memset(rgbTmp, 0, sizeof(rgbTmp));

    // Load the file
    if (HFILE_ERROR == (hFile = OpenFile(pszImage, &ImageInfoBuf,
                                         OF_READ)))
    {
        goto Ret;
    }

    hMapping = CreateFileMapping((HANDLE)IntToPtr(hFile),
                                 NULL,
                                 PAGE_READONLY,
                                 0,
                                 0,
                                 NULL);
    if (hMapping == NULL)
    {
        goto Ret;
    }

    hInst = (HMODULE)MapViewOfFile(hMapping,
                                   FILE_MAP_READ,
                                   0,
                                   0,
                                   0);
    if (hInst == NULL)
    {
        goto Ret;
    }
    pbStart = (BYTE*)hInst;

    // Convert pointer to HMODULE, using the same scheme as
    // LoadLibrary (windows\base\client\module.c).
    *((ULONG_PTR*)&hInst) |= 0x00000001;

    // the MAC resource
    if (!GetResourcePtr(hInst, MAC_RESOURCE_NUMBER, &pbRsrcMAC, &cbRsrcMAC))
        goto Ret;

    // display the MAC
    printf("--- MAC Resource ---\n");
    for (i = 0; i < cbRsrcMAC; i++)
    {
        printf("0x%02X ", pbRsrcMAC[i]);
        if (((i + 1) % 8) == 0)
            printf("\n");
    }
    if (0 != (i % 8))
        printf("\n");


    // the Signature resource
    if (!GetResourcePtr(hInst, CRYPT_SIG_RESOURCE_NUMBER, &pbRsrcSig, &cbRsrcSig))
    {
        pbRsrcSig = NULL;
        cbRsrcSig = 0;
    }

    if (cbRsrcMAC < (sizeof(DWORD) * 2))
        goto Ret;

    // check the MAC in file version and get the CRC offset
    pdwMACInFileVer = (DWORD*)pbRsrcMAC;
    pdwCRCOffset = (DWORD*)(pbRsrcMAC + sizeof(DWORD));
    dwCRCOffset = *pdwCRCOffset;
    if ((0x00000100 != *pdwMACInFileVer) || (dwCRCOffset > cbImage))
        goto Ret;
    if (DES_BLOCKLEN != (cbRsrcMAC - (sizeof(DWORD) * 2)))
    {
        goto Ret;
    }

    // create a zero byte Sig
    pbZeroRsrc = (LPBYTE)LocalAlloc(LPTR, max(cbRsrcMAC, cbRsrcSig));

    // set up the pointers
    pbPostCRC = pbStart + *pdwCRCOffset + sizeof(DWORD);
    if (NULL == pbRsrcSig)  // No sig resource
    {
        cbCRCToRsrc1 = (DWORD)(pbRsrcMAC - pbPostCRC);
        pbRsrc1ToRsrc2 = pbRsrcMAC + cbRsrcMAC;
        cbRsrc1ToRsrc2 = 0;
        pbPostRsrc = pbRsrcMAC + cbRsrcMAC;
        cbPostRsrc = (cbImage - (DWORD)(pbPostRsrc - pbStart));

        // zero pointers
        pbZeroRsrc1 = pbZeroRsrc;
        cbZeroRsrc1 = cbRsrcMAC;
        pbZeroRsrc2 = pbZeroRsrc;
        cbZeroRsrc2 = 0;
    }
    else if (pbRsrcSig > pbRsrcMAC)    // MAC is first Rsrc
    {
        cbCRCToRsrc1 = (DWORD)(pbRsrcMAC - pbPostCRC);
        pbRsrc1ToRsrc2 = pbRsrcMAC + cbRsrcMAC;
        cbRsrc1ToRsrc2 = (DWORD)(pbRsrcSig - pbRsrc1ToRsrc2);
        pbPostRsrc = pbRsrcSig + cbRsrcSig;
        cbPostRsrc = (cbImage - (DWORD)(pbPostRsrc - pbStart));

        // zero pointers
        pbZeroRsrc1 = pbZeroRsrc;
        cbZeroRsrc1 = cbRsrcMAC;
        pbZeroRsrc2 = pbZeroRsrc;
        cbZeroRsrc2 = cbRsrcSig;
    }
    else                        // Sig is first Rsrc
    {
        cbCRCToRsrc1 = (DWORD)(pbRsrcSig - pbPostCRC);
        pbRsrc1ToRsrc2 = pbRsrcSig + cbRsrcSig;
        cbRsrc1ToRsrc2 = (DWORD)(pbRsrcMAC - pbRsrc1ToRsrc2);
        pbPostRsrc = pbRsrcMAC + cbRsrcMAC;
        cbPostRsrc = (cbImage - (DWORD)(pbPostRsrc - pbStart));

        // zero pointers
        pbZeroRsrc1 = pbZeroRsrc;
        cbZeroRsrc1 = cbRsrcSig;
        pbZeroRsrc2 = pbZeroRsrc;
        cbZeroRsrc2 = cbRsrcMAC;
    }

    // init the key table
    deskey(&DESKeyTable, rgbMACDESKey);

    // MAC up to the CRC
    if (!MACBytesOfFile((HANDLE)IntToPtr(hFile), dwCRCOffset, &DESKeyTable, rgbTmp,
                        &cbTmp, rgbMAC, FALSE))
    {
        goto Ret;
    }

    // pretend CRC is zeroed
    MACBytes(&DESKeyTable, (BYTE*)&dwZeroCRC, sizeof(DWORD), rgbTmp, &cbTmp,
             rgbMAC, FALSE);
    if (!SetFilePointer((HANDLE)IntToPtr(hFile), sizeof(DWORD), NULL, FILE_CURRENT))
    {
        goto Ret;
    }

    // MAC from CRC to first resource
    if (!MACBytesOfFile((HANDLE)IntToPtr(hFile), cbCRCToRsrc1, &DESKeyTable, rgbTmp,
                        &cbTmp, rgbMAC, FALSE))
    {
        goto Ret;
    }

    // pretend image has zeroed first resource
    MACBytes(&DESKeyTable, (BYTE*)pbZeroRsrc1, cbZeroRsrc1, rgbTmp, &cbTmp,
             rgbMAC, FALSE);
    if (!SetFilePointer((HANDLE)IntToPtr(hFile), cbZeroRsrc1, NULL, FILE_CURRENT))
    {
        goto Ret;
    }

    // MAC from first resource to second
    if (!MACBytesOfFile((HANDLE)IntToPtr(hFile), cbRsrc1ToRsrc2, &DESKeyTable, rgbTmp,
                        &cbTmp, rgbMAC, FALSE))
    {
        goto Ret;
    }

    // pretend image has zeroed second Resource
    MACBytes(&DESKeyTable, (BYTE*)pbZeroRsrc2, cbZeroRsrc2, rgbTmp, &cbTmp,
             rgbMAC, FALSE);
    if (!SetFilePointer((HANDLE)IntToPtr(hFile), cbZeroRsrc2, NULL, FILE_CURRENT))
    {
        goto Ret;
    }

    // MAC after the resource
    if (!MACBytesOfFile((HANDLE)IntToPtr(hFile), cbPostRsrc, &DESKeyTable, rgbTmp, &cbTmp,
                        rgbMAC, TRUE))
    {
        goto Ret;
    }

    if (0 != memcmp(rgbMAC, pbRsrcMAC + sizeof(DWORD) * 2, DES_BLOCKLEN))
        goto Ret;

    fRet = TRUE;

Ret:
    if (hInst)
        UnmapViewOfFile(hInst);
    if (hMapping)
        CloseHandle(hMapping);
    if (HFILE_ERROR != hFile)
        _lclose(hFile);
    if (NULL != pbZeroRsrc)
        LocalFree(pbZeroRsrc);
    return fRet;
}

// **********************************************************************
// SelfMACCheck performs a DES MAC on the binary image of this DLL
// **********************************************************************
BOOL
SelfMACCheck(
    IN LPCSTR pszImage)
{
    HFILE       hFileProv = HFILE_ERROR;
    DWORD       cbImage;
    OFSTRUCT    ImageInfoBuf;
    HMODULE     hInst = NULL;
    PBYTE       pbMAC;
    DWORD       cbMAC;
    BOOL        fRet = FALSE;

    // check if the MAC resource is in the CSP and exit if not
    // Load the file as a datafile
    if (NULL == (hInst = LoadLibraryEx(pszImage,
                                       NULL,
                                       LOAD_LIBRARY_AS_DATAFILE)))
    {
        fRet = TRUE;
        goto Ret;
    }
    if (!GetResourcePtr(hInst, MAC_RESOURCE_NUMBER, &pbMAC, &cbMAC))
    {
        fRet = TRUE;
        goto Ret;
    }
    FreeLibrary(hInst);
    hInst = NULL;

    // Check file size
    if (HFILE_ERROR == (hFileProv = OpenFile(pszImage, &ImageInfoBuf, OF_READ)))
    {
        printf("FAILURE - Unable to open the requested file\n");
        goto Ret;
    }

    if (0xffffffff == (cbImage = GetFileSize((HANDLE)IntToPtr(hFileProv), NULL)))
    {
        printf("FAILURE - Unable to open the requested file\n");
        goto Ret;
    }

    _lclose(hFileProv);
    hFileProv = HFILE_ERROR;

    if (!MACTheFile(pszImage, cbImage))
    {
        printf("FAILURE - The MAC resource does not verify!\n");
        goto Ret;
    }
    else
        printf("MAC Verifies.\n\n");

    fRet = TRUE;

Ret:
    if (hInst)
    {
        FreeLibrary(hInst);
    }

    if (HFILE_ERROR != hFileProv)
        _lclose(hFileProv);

    return fRet;
}

#define CSP_TO_BE_HASHED_CHUNK  4096

// Given hFile, reads the specified number of bytes (cbToBeHashed) from the file
// and hashes these bytes.  The function does this in chunks.
BOOL
HashBytesOfFile(
    IN HFILE hFile,
    IN DWORD cbToBeHashed,
    IN OUT MD5_CTX *pMD5Hash)
{
    BYTE    rgbChunk[CSP_TO_BE_HASHED_CHUNK];
    DWORD   cbRemaining = cbToBeHashed;
    DWORD   cbToRead;
    DWORD   dwBytesRead;
    BOOL    fRet = FALSE;

    //
    // loop over the file for the specified number of bytes
    // updating the hash as we go.
    //

    while (cbRemaining > 0)
    {
        if (cbRemaining < CSP_TO_BE_HASHED_CHUNK)
            cbToRead = cbRemaining;
        else
            cbToRead = CSP_TO_BE_HASHED_CHUNK;

        if (!ReadFile((HANDLE)IntToPtr(hFile), rgbChunk, cbToRead, &dwBytesRead, NULL))
            goto Ret;
        if (dwBytesRead != cbToRead)
            goto Ret;

        MD5Update(pMD5Hash, rgbChunk, dwBytesRead);
        cbRemaining -= cbToRead;
    }

    fRet = TRUE;

Ret:
    return fRet;
}

BOOL
HashTheFile(
    LPCSTR pszImage,
    DWORD cbImage,
    BYTE **ppbSig,
    DWORD *pcbSig,
    BYTE *pbHash)
{
    HMODULE                     hInst = 0;
    MEMORY_BASIC_INFORMATION    MemInfo;
    BYTE                        *pbRsrcSig;
    DWORD                       cbRsrcSig;
    BYTE                        *pbStart;
    BYTE                        *pbZeroRsrc = NULL;
    MD5_CTX                     MD5Hash;
    BYTE                        *pbPostCRC;   // pointer to just after CRC
    DWORD                       cbCRCToSig;   // number of bytes from CRC to sig
    DWORD                       cbPostSig;    // size - (already hashed + signature size)
    BYTE                        *pbPostSig;
    DWORD                       *pdwSigInFileVer;
    DWORD                       *pdwCRCOffset;
    DWORD                       dwCRCOffset;
    DWORD                       dwZeroCRC = 0;
    DWORD                       dwBytesRead = 0;
    OFSTRUCT                    ImageInfoBuf;
    HFILE                       hFile = HFILE_ERROR;
    BOOL                        fRet = FALSE;

    memset(&MD5Hash, 0, sizeof(MD5Hash));
    memset(&MemInfo, 0, sizeof(MemInfo));

    // Load the file as a datafile
    if (NULL == (hInst = LoadLibraryEx(pszImage, NULL, LOAD_LIBRARY_AS_DATAFILE)))
        goto Ret;

    // get image start address
    VirtualQuery(hInst, &MemInfo, sizeof(MemInfo));
    pbStart = (BYTE*)MemInfo.BaseAddress;

    // the resources signature
    if ((NULL == ppbSig) || !GetResourcePtr(hInst, CRYPT_SIG_RESOURCE_NUMBER, &pbRsrcSig, &cbRsrcSig))
    {
        dwCRCOffset = 0;
        pbPostCRC = NULL;
        cbCRCToSig = 0;
        pbPostSig = NULL;
        cbPostSig = cbImage;
        cbRsrcSig = 0;
        if (NULL != pcbSig)
            *pcbSig = 0;
    }
    else
    {
        if (cbRsrcSig < (sizeof(DWORD) * 2))
            goto Ret;

        // check the sig in file version and get the CRC offset
        pdwSigInFileVer = (DWORD*)pbRsrcSig;
        pdwCRCOffset = (DWORD*)(pbRsrcSig + sizeof(DWORD));
        dwCRCOffset = *pdwCRCOffset;
        if ((0x00000100 != *pdwSigInFileVer) || (dwCRCOffset > cbImage))
            goto Ret;

        // create a zero byte signature
        if (NULL == (pbZeroRsrc = (BYTE*)LocalAlloc(LMEM_ZEROINIT, cbRsrcSig)))
            goto Ret;
        memcpy(pbZeroRsrc, pbRsrcSig, sizeof(DWORD) * 2);

        pbPostCRC = pbStart + *pdwCRCOffset + sizeof(DWORD);
        cbCRCToSig = (DWORD)(pbRsrcSig - pbPostCRC);
        pbPostSig = pbRsrcSig + cbRsrcSig;
        cbPostSig = (cbImage - (DWORD)(pbPostSig - pbStart));

        // allocate the real signature and copy the resource sig into the real sig
        *pcbSig = cbRsrcSig - (sizeof(DWORD) * 2);
        if (NULL == (*ppbSig = (BYTE*)LocalAlloc(LMEM_ZEROINIT, *pcbSig)))
            goto Ret;

        memcpy(*ppbSig, pbRsrcSig + (sizeof(DWORD) * 2), *pcbSig);
    }

    FreeLibrary(hInst);
    hInst = 0;

    // hash over the relevant data
    {
        if (HFILE_ERROR == (hFile = OpenFile(pszImage, &ImageInfoBuf, OF_READ)))
        {
            goto Ret;
        }

        MD5Init(&MD5Hash);

        if (0 != dwCRCOffset)
        {
            // hash up to the CRC
            if (!HashBytesOfFile(hFile, dwCRCOffset, &MD5Hash))
                goto Ret;

            // pretend CRC is zeroed
            MD5Update(&MD5Hash, (BYTE*)&dwZeroCRC, sizeof(DWORD));
            if (!ReadFile((HANDLE)IntToPtr(hFile), (BYTE*)&dwZeroCRC, sizeof(DWORD),
                          &dwBytesRead, NULL))
            {
                goto Ret;
            }
        }

        if (0 != cbRsrcSig)
        {
            // hash from CRC to sig resource
            if (!HashBytesOfFile(hFile, cbCRCToSig, &MD5Hash))
                goto Ret;

            // pretend image has zeroed sig
            MD5Update(&MD5Hash, pbZeroRsrc, cbRsrcSig);
            if (!ReadFile((HANDLE)IntToPtr(hFile), (BYTE*)pbZeroRsrc, cbRsrcSig,
                          &dwBytesRead, NULL))
            {
                goto Ret;
            }
        }

        // hash after the sig resource
        if (!HashBytesOfFile(hFile, cbPostSig, &MD5Hash))
            goto Ret;

        // Finish the hash
        MD5Final(&MD5Hash);

        memcpy(pbHash, MD5Hash.digest, MD5DIGESTLEN);
    }

    fRet = TRUE;

Ret:
    if (pbZeroRsrc)
        LocalFree(pbZeroRsrc);
    if (hInst)
        FreeLibrary(hInst);
    if (HFILE_ERROR != hFile)
        _lclose(hFile);
    return fRet;
}

/*
 -      CheckAllSignatures
 -
 *      Purpose:
 *                Check signature against all keys
 *
 *
 *      Returns:
 *                BOOL
 */
BOOL
CheckAllSignatures(
    BYTE *pbSig,
    DWORD cbSig,
    BYTE *pbHash,
    BOOL fUnknownLen)
{
    BYTE        rgbKey[sizeof(BSAFE_PUB_KEY) + KEYSIZE1024];
    BYTE        rgbKey2[sizeof(BSAFE_PUB_KEY) + KEYSIZE1024];
    BYTE        rgbMSKey[sizeof(BSAFE_PUB_KEY) + KEYSIZE1024];
#ifdef TEST_BUILD_EXPONENT
    BYTE        rgbTestKey[sizeof(BSAFE_PUB_KEY) + KEYSIZE512];
    HMODULE     hMod;
    HRSRC       hRes;
    HGLOBAL     pRes;
    DWORD       dwSize;
#endif
    BOOL        fRet = FALSE;

    // decrypt the keys once for each process
#ifdef TEST_BUILD_EXPONENT
    hMod = GetModuleHandle("advapi32.dll");
    if (hRes = FindResource(hMod, (LPCTSTR) IDR_PUBKEY1, RT_RCDATA))
    {
        if (pRes = LoadResource(hMod, hRes))
        {
            dwSize = SizeofResource(hMod, hRes);
            memcpy(&TESTKEY, (CHAR *) pRes, dwSize);
        }
    }
#endif
    memcpy(rgbKey, (BYTE*)&KEY, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024);
    EncryptKey(rgbKey, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024, 0);

    memcpy(rgbMSKey, (BYTE*)&MSKEY, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024);
    EncryptKey(rgbMSKey, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024, 1);

    memcpy(rgbKey2, (BYTE*)&KEY2, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024);
    EncryptKey(rgbKey2, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024, 2);

#ifdef TEST_BUILD_EXPONENT
    memcpy(rgbTestKey, (BYTE*)&TESTKEY, sizeof(BSAFE_PUB_KEY) + KEYSIZE512);
    EncryptKey(rgbTestKey, sizeof(BSAFE_PUB_KEY) + KEYSIZE512, 3);
#ifdef WIN95
    TESTKEY.PUB.pubexp = TEST_BUILD_EXPONENT;
#else
    TESTKEY.PUB.pubexp = USER_SHARED_DATA->CryptoExponent;
#endif // WIN95
#endif // TEST_BUILD_EXPONENT

    if (TRUE == (fRet = CheckSignature(rgbKey, 128, pbSig,
                                       cbSig, pbHash, fUnknownLen)))
    {
        printf("Checked against the retail CSP key\n" );
        fRet = TRUE;
        goto Ret;
    }

    if (g_fUseTestKey)
    {
        if (TRUE == (fRet = CheckSignature(rgbMSKey, 128, pbSig,
                                           cbSig, pbHash, fUnknownLen)))
        {
            printf("Checked against the Internal Only \"Enigma\" Key\n" );
            fRet = TRUE;
            goto Ret;
        }
    }

    if (TRUE == (fRet = CheckSignature(rgbKey2, 128, pbSig,
                                       cbSig, pbHash, fUnknownLen)))
    {
        printf("Checked against retail Key2\n" );
        fRet = TRUE;
        goto Ret;
    }

#ifdef TEST_BUILD_EXPONENT
    if (TRUE == (fRet = CheckSignature(rgbTestKey, 64, pbSig,
                                       cbSig, pbHash, fUnknownLen)))
    {
        printf("Checked against Test key\n" );
        fRet = TRUE;
        goto Ret;
    }
#endif // TEST_BUILD_EXPONENT

Ret:
    return fRet;
}

/*
 -      CheckSignatureInFile
 -
 *      Purpose:
 *                Check signature which is in the resource in the file
 *
 *
 *      Parameters:
 *                IN pszImage       - address of file
 *
 *      Returns:
 *                BOOL
 */
BOOL
CheckSignatureInFile(
    LPCSTR pszImage)
{
    HFILE       hFileProv = HFILE_ERROR;
    DWORD       cbImage;
    BYTE        *pbSig = NULL;
    DWORD       cbSig;
    BYTE        rgbHash[MD5DIGESTLEN];
    OFSTRUCT    ImageInfoBuf;
    BOOL        fRet = FALSE;

    // Check file size
    {
        if (HFILE_ERROR == (hFileProv = OpenFile(pszImage, &ImageInfoBuf, OF_READ)))
        {
            SetLastError((DWORD) NTE_PROV_DLL_NOT_FOUND);
            goto Ret;
        }

        if (0xffffffff == (cbImage = GetFileSize((HANDLE)IntToPtr(hFileProv), NULL)))
            goto Ret;

        _lclose(hFileProv);
        hFileProv = HFILE_ERROR;
    }

    if (!HashTheFile(pszImage, cbImage, &pbSig, &cbSig, rgbHash))
        goto Ret;

    // check signature against all public keys
    if (!CheckAllSignatures(pbSig, cbSig, rgbHash, FALSE))
        goto Ret;

    fRet = TRUE;

Ret:
    if (HFILE_ERROR != hFileProv)
        _lclose(hFileProv);
    if (pbSig)
        LocalFree(pbSig);
    return fRet;
}


/*++

ShowHelp:

    This routine displays a short help message to the given output stream.

Arguments:

    ostr - The output stream to receive the help message.

Return Value:

    None

Author:

    Jeff Spelman

--*/

void
ShowHelp(
    void)
{
    printf("CryptoAPI Display Signature Utility\n");
    printf("   showsig <filename>\n");
    printf("or\n");
    printf("   showsig -s <rsrcfile> <filename>\n");
    printf("or\n");
    printf("   showsig -b <sigfile> <filename>\n");
    printf("Other options:\n");
    printf("   +t - Enable the use of the Enigma key\n");
    printf("        (On by default).\n");
    printf("   -t - Disable the use of the Enigma key\n");
}


/*++

main:

    This is the main entry point of the application.

Arguments:

    argc - Count of arguments
    argv - array of arguments

Return Value:

    0 - Success
    1 - Error

Author:

    Jeff Spelman

--*/
extern "C" void __cdecl
main(
    int argc,
    char *argv[])
{
    TCHAR   szFullPath[MAX_PATH];
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    HMODULE hResFile = NULL;
    DWORD exStatus = 1;
    LPCTSTR szInFile = NULL;
    LPCTSTR szResFile = NULL;
    LPCTSTR szSigFile = NULL;
    LPTSTR szTail;
    BOOL fOutput = FALSE;
    DWORD   i;
    HRSRC   hRes;
    DWORD   cbImage;
    BOOL    fFreeSignature = FALSE;
    BYTE    rgbHash[MD5DIGESTLEN];
    LPBYTE pbSignature = NULL;
    DWORD cbSignatureLen;


    //
    // Parse the command line.
    //

    for (i = 1; i < (DWORD)argc; i++)
    {
        if (0 == _stricmp("-h", argv[i]))
        {
            ShowHelp();
            exStatus = 1;
            goto ErrorExit;
        }
        else if (0 == _stricmp("-s", argv[i]))
        {
            i += 1;
            if ((NULL != szResFile) || (i >= (DWORD)argc))
            {
                ShowHelp();
                exStatus = 1;
                goto ErrorExit;
            }

            szResFile = argv[i];
        }
        else if (0 == _stricmp("-b", argv[i]))
        {
            i += 1;
            if ((NULL != szSigFile) || (i >= (DWORD)argc))
            {
                ShowHelp();
                exStatus = 1;
                goto ErrorExit;
            }

            szSigFile = argv[i];
        }
        else if (0 == _stricmp("-t", argv[i]))
        {
            g_fUseTestKey = FALSE;
        }
        else if (0 == _stricmp("+t", argv[i]))
        {
            g_fUseTestKey = TRUE;
        }
        else
        {
            if (NULL != szInFile)
            {
                ShowHelp();
                exStatus = 1;
                goto ErrorExit;
            }

            szInFile = argv[i];
        }
    }


    //
    // Command consistency checks.
    //

    if (NULL == szInFile)
    {
        printf("No input file specified.\n");
        ShowHelp();
        exStatus = 4 ;
        goto ErrorExit;
    }

    i = GetFullPathName(szInFile,
                        sizeof(szFullPath) / sizeof(TCHAR),
                        szFullPath,
                        &szTail);
    if (0 == i)
    {
        printf("Can't expand file name.\n");
        exStatus = 4;
        goto ErrorExit;
    }
    else if (sizeof(szFullPath) / sizeof(TCHAR) < i)
    {
        printf("File path too long.\n");
        exStatus = 4;
        goto ErrorExit;
    }
    szInFile = szFullPath;


    //
    // If the DLL has a FIPS 140-1 MAC resource then check it
    //
    if (!SelfMACCheck(szInFile))
        exStatus = 3 ;


    //
    // Where's our signature?
    //

    if (NULL != szSigFile)
    {

        //
        // This file has an accompanying binary signature file.
        // Verify the file, and get its length.
        //

        hFile = CreateFile(szInFile,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);
        if (INVALID_HANDLE_VALUE == hFile)
        {
            printf("Unable to open the CSP file!\n");
            exStatus = 2 ;
            goto ErrorExit;
        }

        cbImage = GetFileSize(hFile, NULL);
        if (0 == cbImage)
        {
            printf("Unable to get size of CSP file!\n");
            exStatus = 2 ;
            goto ErrorExit;
        }

        CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;

        //
        // Get the signature from the file.
        //

        hFile = CreateFile(szSigFile,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);
        if (INVALID_HANDLE_VALUE == hFile)
        {
            printf("Unable to open the Signature file!\n");
            exStatus = 2 ;
            goto ErrorExit;
        }

        cbSignatureLen = GetFileSize(hFile, NULL);
        if (0 == cbImage)
        {
            printf("Unable to get size of the Signature file!\n");
            exStatus = 2 ;
            goto ErrorExit;
        }

        pbSignature = (LPBYTE)LocalAlloc(LPTR, cbSignatureLen);
        if (NULL == pbSignature)
        {
            printf("No memory!\n");
            exStatus = 2;
            goto ErrorExit;
        }
        fFreeSignature = TRUE;

        if (!ReadFile(hFile,
                      pbSignature,
                      cbSignatureLen,
                      &cbSignatureLen,
                      NULL))
        {
            printf("Unable to read the Signature file!\n");
            exStatus = 2 ;
            goto ErrorExit;
        }

        CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;


        // display the signature
        printf("--- Signature ---\n");
        for (i = 0; i < cbSignatureLen; i++)
        {
            printf("0x%02X ", pbSignature[i]);
            if (((i + 1) % 8) == 0)
                printf("\n");
        }
        if (0 != (i % 8))
            printf("\n");

        if (!HashTheFile(szInFile, cbImage, NULL, NULL, rgbHash))
        {
            printf("Unable to hash the CSP file!\n");
            exStatus = 2 ;
            goto ErrorExit;
        }

        // check signature against all public keys
        if (!CheckAllSignatures(pbSignature, cbSignatureLen, rgbHash, FALSE))
        {
            printf("The signature on %s FAILED to verify!\n", szInFile);
            exStatus = 1 ;
        }
        else
        {
            printf("The signature on %s VERIFIED!\n", szInFile);
            exStatus = 0;
        }
    }
    else if (NULL != szResFile)
    {

        //
        // This file has an accompanying signature resource file.
        // Verify the file, and get its length.
        //

        hFile = CreateFile(szInFile,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);
        if (INVALID_HANDLE_VALUE == hFile)
        {
            printf("Unable to open the CSP file!\n");
            exStatus = 2 ;
            goto ErrorExit;
        }

        cbImage = GetFileSize(hFile, NULL);
        if (0 == cbImage)
        {
            printf("Unable to get size of CSP file!\n");
            exStatus = 2 ;
            goto ErrorExit;
        }

        CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;


        //
        // Load the resource from the associated resource file.
        //

        hResFile = LoadLibraryEx(szResFile, NULL, LOAD_LIBRARY_AS_DATAFILE);
        if (NULL == hResFile)
        {
            printf("Unable to load the resource file!\n");
            exStatus = 2 ;
            goto ErrorExit;
        }

        hRes = FindResource(hResFile, (LPCTSTR)SIG_RESOURCE_NUM, RT_RCDATA);
        if (NULL == hRes)
        {
            printf("Unable to find the signature in the resource file!\n");
            exStatus = 2 ;
            goto ErrorExit;
        }

        pbSignature = (LPBYTE)LoadResource(hResFile, hRes);
        if (NULL == pbSignature)
        {
            printf("Unable to find the signature in the resource file!\n");
            exStatus = 2 ;
            goto ErrorExit;
        }

        cbSignatureLen = SizeofResource(hResFile, hRes);

        // display the signature
        printf("--- Signature ---\n");
        for (i = 0; i < cbSignatureLen; i++)
        {
            printf("0x%02X ", pbSignature[i]);
            if (((i + 1) % 8) == 0)
                printf("\n");
        }
        if (0 != (i % 8))
            printf("\n");

        if (!HashTheFile(szInFile, cbImage, NULL, NULL, rgbHash))
        {
            printf("Unable to hash the CSP file!\n");
            exStatus = 2 ;
            goto ErrorExit;
        }

        // check signature against all public keys
        if (!CheckAllSignatures(pbSignature, cbSignatureLen, rgbHash, FALSE))
        {
            printf("The signature on %s FAILED to verify!\n", szInFile);
            exStatus = 1 ;
        }
        else
        {
            printf("The signature on %s VERIFIED!\n", szInFile);
            exStatus = 0;
        }
    }
    else
    {

        //
        // Get the signature from the resource in the file
        //

        if (ERROR_SUCCESS != GetCryptSignatureResource(szInFile,
                                                       &pbSignature,
                                                       &cbSignatureLen))
        {
            printf("Unable to get the signature from the file resource!\n");
            exStatus = 2 ;
            goto ErrorExit;
        }

        // display the signature
        printf("--- Signature ---\n");
        for (i = 0; i < cbSignatureLen; i++)
        {
            printf("0x%02X ", pbSignature[i]);
            if (((i + 1) % 8) == 0)
                printf("\n");
        }
        if (0 != (i % 8))
            printf("\n");


        //
        // check the signature against the file
        //

        if (CheckSignatureInFile(szInFile))
        {
            printf("The signature on %s VERIFIED!\n", szInFile);
            exStatus = 0;
        }
        else
        {
            printf("The signature on %s FAILED to verify!\n", szInFile);
            exStatus = 1 ;
        }
    }


    //
    // Clean up and return.
    //

ErrorExit:
    if (fFreeSignature && (NULL != pbSignature))
        LocalFree(pbSignature);
    if (INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);
    if (NULL != hResFile)
        FreeLibrary(hResFile);
    exit(exStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\programs\signcsp\mainrpc.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0102 */
/* at Fri Mar 08 11:33:02 1996
 */
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __mainrpc_h__
#define __mainrpc_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __hello_INTERFACE_DEFINED__
#define __hello_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: hello
 * at Fri Mar 08 11:33:02 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [implicit_handle][version][uuid] */ 


			/* size is 4 */
typedef unsigned long DWORD;

			/* size is 1 */
typedef unsigned char UCHAR;

			/* size is 1 */
boolean GenSignature( 
    /* [size_is][in] */ UCHAR __RPC_FAR *InData,
    /* [out][in] */ DWORD __RPC_FAR *cbSignatureLen,
    /* [size_is][out] */ UCHAR __RPC_FAR *pbSignature);


extern handle_t hello_IfHandle;


extern RPC_IF_HANDLE hello_v1_0_c_ifspec;
extern RPC_IF_HANDLE hello_v1_0_s_ifspec;
#endif /* __hello_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\programs\keymigrt\systok.cpp ===
//
//  chngpwd.cpp
//
//  Copyright (c) Microsoft Corp, 1998
//
//  This file contains source code for testing protected storage's key
//  backup and recovery capabilities under a real world scenario, by creating
//  a local user account, performing a data protection operation, and then
//  change the pwd, then performing data unprotect, and comparing the data.
//
//  History:
//
//  Todds       8/15/98     Created
//
#include <windows.h>
#include <winbase.h>
#include <stdio.h>
#include <stdlib.h>
#include <wincrypt.h>
#include <userenv.h>
#include <lm.h>
#include <psapi.h>

#define TERROR(msg)          LogError(__FILE__, __LINE__, msg)
#define TERRORVAL(msg, val)  LogErrorVal(__FILE__, __LINE__, msg, val)
#define TCOMMENT(msg)        LogComment(msg)
#define MyAlloc(cb)          HeapAlloc(GetProcessHeap(), 0, cb)
#define MyFree(pv)           HeapFree(GetProcessHeap(), 0, pv)
#define WSZ_BYTECOUNT(s)     (2 * wcslen(s) + 2)
#define CHECK_NULL(s)        if (s == NULL) \
                                LogError(__FILE__, __LINE__, L"## CHECK_NULL ##")

#define MAX_BLOBS           20
#define MAX_PROCESSES       200
#define MAX_SD              2048
#define BLOB_INCREMENT      0x4001 // 1 page + 1 byte...




//
//  Error Logging Functions  # defined as follows to include
//  Line and FILE macros:
//
//  TERROR       -   LogError()
//  TERRORVAL    -   LogErrorVal()
//
//

void
LogError(LPSTR szFile,
         int iLine,
         LPWSTR wszMsg)
{

    //
    //  Event log or testutil logging later...
    //

    WCHAR buffer[512];
    swprintf(buffer, L"ERROR Line: %i -> %s\n", iLine, wszMsg);
    OutputDebugStringW(buffer);
    wprintf(buffer);


}

void
LogErrorVal(LPSTR  szFile,
            int    iLine,
            LPWSTR wszMsg,
            DWORD  dwVal)
{

    WCHAR buffer[256]; // this should be adequate.
    swprintf(buffer, L"%s Error:: %x", wszMsg, dwVal);
    LogError(szFile, iLine, buffer);
}

void
LogComment(LPWSTR wszMsg)
{

    //
    //  Event log or testutil logging later...
    //

    WCHAR buffer[512];
    OutputDebugStringW(wszMsg);
    wprintf(wszMsg);
}



void 
DumpBin(CRYPT_DATA_BLOB hash)
{

    WCHAR buff[256], out[256];
    ULONG cb;

    swprintf(out, L"");
    while (hash.cbData > 0) {
        cb = min(4, hash.cbData);
        hash.cbData -= cb;
        for (; cb > 0; cb--, hash.pbData++) {
            swprintf(buff, L"%02X", *hash.pbData);
            wcscat(out, buff);
        }
        wcscat(out, L" ");
    }
    
    wcscat(out, L"\n");

    TCOMMENT(out);
}
//
//  SetSidOnAcl
//


BOOL
SetSidOnAcl(
    PSID pSid,
    PACL pAclSource,
    PACL *pAclDestination,
    DWORD AccessMask,
	BYTE AceFlags,
    BOOL bAddSid
    )
{
    ACL_SIZE_INFORMATION AclInfo;
    DWORD dwNewAclSize, dwErr = S_OK;
    LPVOID pAce;
    DWORD AceCounter;
    BOOL bSuccess=FALSE; // assume this function will fail

    //
    // If we were given a NULL Acl, just provide a NULL Acl
    //
    if(pAclSource == NULL) {
        *pAclDestination = NULL;
        return TRUE;
    }

    if(!IsValidSid(pSid)) return FALSE;

    if(!GetAclInformation(
        pAclSource,
        &AclInfo,
        sizeof(ACL_SIZE_INFORMATION),
        AclSizeInformation
        )) return FALSE;

    //
    // compute size for new Acl, based on addition or subtraction of Ace
    //
    if(bAddSid) {
        dwNewAclSize=AclInfo.AclBytesInUse  +
            sizeof(ACCESS_ALLOWED_ACE)  +
            GetLengthSid(pSid)          -
            sizeof(DWORD)               ;
    }
    else {
        dwNewAclSize=AclInfo.AclBytesInUse  -
            sizeof(ACCESS_ALLOWED_ACE)  -
            GetLengthSid(pSid)          +
            sizeof(DWORD)               ;
    }

    *pAclDestination = (PACL)MyAlloc(dwNewAclSize);

    if(*pAclDestination == NULL) 
    {
        TERRORVAL(L"Alloc failed!", E_OUTOFMEMORY);
        return FALSE;
    }

    
    //
    // initialize new Acl
    //
    if(!InitializeAcl(
            *pAclDestination, 
            dwNewAclSize, 
            ACL_REVISION
            )){
        dwErr = GetLastError();
        TERRORVAL(L"InitilizeAcl failed!", dwErr);
        goto ret;
    }

    //
    // if appropriate, add ace representing pSid
    //
    if(bAddSid) {
		PACCESS_ALLOWED_ACE pNewAce;

        if(!AddAccessAllowedAce(
            *pAclDestination,
            ACL_REVISION,
            AccessMask,
            pSid
            )) {
            dwErr = GetLastError();
            TERRORVAL(L"AddAccessAllowedAce failed!", dwErr);
            goto ret;
        }

		//
		// get pointer to ace we just added, so we can change the AceFlags
		//
		if(!GetAce(
			*pAclDestination,
			0, // this is the first ace in the Acl
			(void**) &pNewAce
			)){
        
            dwErr = GetLastError();
            TERRORVAL(L"GetAce failed!", dwErr);
            goto ret;
        }

		pNewAce->Header.AceFlags = AceFlags;	
    }

    //
    // copy existing aces to new Acl
    //
    for(AceCounter = 0 ; AceCounter < AclInfo.AceCount ; AceCounter++) {
        //
        // fetch existing ace
        //
        if(!GetAce(pAclSource, AceCounter, &pAce)){
            dwErr = GetLastError();
            TERRORVAL(L"GetAce failed!", dwErr);
            goto ret;
        }
        //
        // check to see if we are removing the Ace
        //
        if(!bAddSid) {
            //
            // we only care about ACCESS_ALLOWED aces
            //
            if((((PACE_HEADER)pAce)->AceType) == ACCESS_ALLOWED_ACE_TYPE) {
                PSID pTempSid=(PSID)&((PACCESS_ALLOWED_ACE)pAce)->SidStart;
                //
                // if the Sid matches, skip adding this Sid
                //
                if(EqualSid(pSid, pTempSid)) continue;
            }
        }

        //
        // append ace to Acl
        //
        if(!AddAce(
            *pAclDestination,
            ACL_REVISION,
            MAXDWORD,  // maintain Ace order
            pAce,
            ((PACE_HEADER)pAce)->AceSize
            )) {
         
            dwErr = GetLastError();
            TERRORVAL(L"AddAccessAllowedAce failed!", dwErr);
            goto ret;
        }
    }

    bSuccess=TRUE; // indicate success

    
ret:

    //
    // free memory if an error occurred
    //
    if(!bSuccess) {
        if(*pAclDestination != NULL)
            MyFree(*pAclDestination);
    }

    

    return bSuccess;
}
//
//  AddSIDToKernelObject()
//
//  This function takes a given SID and dwAccess and adds it to a given token.
//
//  **  Be sure to restore old kernel object
//  **  using call to GetKernelObjectSecurity()
//
BOOL
AddSIDToKernelObjectDacl(PSID                   pSid,
                         DWORD                  dwAccess,
                         HANDLE                 OriginalToken,
                         PSECURITY_DESCRIPTOR*  ppSDOld)
{

    PSECURITY_DESCRIPTOR    pSD = NULL;
    SECURITY_DESCRIPTOR     sdNew;
    DWORD                   cbByte = MAX_SD, cbNeeded = 0, dwErr = 0; 
    PACL                    pOldDacl = NULL, pNewDacl = NULL;
    BOOL                    fDaclPresent, fDaclDefaulted, fRet = FALSE;                    
   
    pSD = (PSECURITY_DESCRIPTOR) MyAlloc(cbByte);
    if (NULL == pSD) {
        TERRORVAL(L"Alloc failed!", E_OUTOFMEMORY);
        return FALSE;
    }

    if (!InitializeSecurityDescriptor(
                &sdNew, 
                SECURITY_DESCRIPTOR_REVISION
                )) {

        dwErr = GetLastError();
        TERRORVAL(L"InitializeSecurityDescriptor failed!", dwErr);
        goto ret;
    }

    if (!GetKernelObjectSecurity(
        OriginalToken,
        DACL_SECURITY_INFORMATION,
        pSD,
        cbByte,
        &cbNeeded
        )) {
        
        dwErr = GetLastError();
        if (cbNeeded > MAX_SD && dwErr == ERROR_MORE_DATA) { 
    
            MyFree(pSD);
            pSD = NULL;
            pSD = (PSECURITY_DESCRIPTOR) MyAlloc(cbNeeded);
            if (NULL == pSD) {
                TERRORVAL(L"Alloc failed!", E_OUTOFMEMORY);
                dwErr = E_OUTOFMEMORY;
                goto ret;
            }
            
            dwErr = S_OK;
            if (!GetKernelObjectSecurity(
                OriginalToken,
                DACL_SECURITY_INFORMATION,
                pSD,
                cbNeeded,
                &cbNeeded
                )) {
                dwErr = GetLastError();
            }
            
        }
        
        if (dwErr != S_OK) {
            TERRORVAL(L"GetKernelObjectSecurity failed!", dwErr);
            goto ret;
        }
    }
    
    if (!GetSecurityDescriptorDacl(
        pSD,
        &fDaclPresent,
        &pOldDacl,
        &fDaclDefaulted
        )) {
        dwErr = GetLastError();
        TERRORVAL(L"GetSecurityDescriptorDacl failed!", dwErr);
        goto ret;
    }
    
    if (!SetSidOnAcl(
        pSid,
        pOldDacl,
        &pNewDacl,
        dwAccess,
        0,
        TRUE
        )) {
        goto ret;
    }
    
    if (!SetSecurityDescriptorDacl(
        &sdNew,
        TRUE,
        pNewDacl,
        FALSE
        )) {
        dwErr = GetLastError();
        TERRORVAL(L"SetSecurityDescriptorDacl failed!", dwErr);
        goto ret;
    } 
    
    if (!SetKernelObjectSecurity(
        OriginalToken,
        DACL_SECURITY_INFORMATION,
        &sdNew
        )) {
        
        dwErr = GetLastError();
        TERRORVAL(L"SetKernelObjectSecurity failed!", dwErr);
        goto ret;
    }
    
    *ppSDOld = pSD;
    fRet = TRUE;

ret:

    if (NULL != pNewDacl) {
        MyFree(pNewDacl);
    }

    if (!fRet) {
        if (NULL != pSD) {
            MyFree(pSD);
            *ppSDOld = NULL;
        }

    }
       
    return fRet;
}


//
//  DataFree()
//
//  Utility for freeing array of DATA_BLOB structs
//
void
DataFree(DATA_BLOB* arDataBlob, 
         BOOL       fCryptAlloc)
{

    if (arDataBlob == NULL) return; // not alloc'd
    
    for (DWORD i = 0; i < MAX_BLOBS;i++) {

        if (arDataBlob[i].pbData != NULL) {
            
            if (!fCryptAlloc) { 
                MyFree(arDataBlob[i].pbData);
            } else { // Data member alloc'd by DataProtect call
                LocalFree(arDataBlob[i].pbData);
            }
        }
       
    }

    MyFree(arDataBlob);
}

    


BOOL
SetPrivilege(
    HANDLE hToken,          // token handle
    LPCTSTR Privilege,      // Privilege to enable/disable
    BOOL bEnablePrivilege   // to enable or disable privilege
    )
{
    TOKEN_PRIVILEGES tp;
    LUID luid;
    TOKEN_PRIVILEGES tpPrevious;
    DWORD cbPrevious=sizeof(TOKEN_PRIVILEGES);

    if(!LookupPrivilegeValue( NULL, Privilege, &luid )) return FALSE;

    //
    // first pass.  get current privilege setting
    //
    tp.PrivilegeCount           = 1;
    tp.Privileges[0].Luid       = luid;
    tp.Privileges[0].Attributes = 0;

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tp,
            sizeof(TOKEN_PRIVILEGES),
            &tpPrevious,
            &cbPrevious
            );

    if (GetLastError() != ERROR_SUCCESS) return FALSE;

    //
    // second pass.  set privilege based on previous setting
    //
    tpPrevious.PrivilegeCount       = 1;
    tpPrevious.Privileges[0].Luid   = luid;

    if(bEnablePrivilege) {
        tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
    }
    else {
        tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED &
            tpPrevious.Privileges[0].Attributes);
    }

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tpPrevious,
            cbPrevious,
            NULL,
            NULL
            );

    if (GetLastError() != ERROR_SUCCESS) return FALSE;

    return TRUE;
}

BOOL
SetCurrentPrivilege(
    LPCTSTR Privilege,      // Privilege to enable/disable
    BOOL bEnablePrivilege   // to enable or disable privilege
    )
{
    BOOL bSuccess=FALSE; // assume failure
    HANDLE hToken;

    if (!OpenThreadToken(
            GetCurrentThread(), 
            TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
            FALSE,
            &hToken)){       
                
        if(!OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
            &hToken
            )) return FALSE;
    }

    if(SetPrivilege(hToken, Privilege, bEnablePrivilege)) bSuccess=TRUE;
    CloseHandle(hToken);

    return bSuccess;
}


//
//  GetUserSid
//
//  This function takes a token, and returns the user SID from that token.
//
//  Note:   SID must be freed by MyFree()
//          hToken is optional...  NULL means we'll grab it.
//
BOOL
GetUserSid(HANDLE   hClientToken,
           PSID*    ppSid,
           DWORD*   lpcbSid)
{
    DWORD                       cbUserInfo = 0;
    PTOKEN_USER                 pUserInfo = NULL;
    PUCHAR                      pnSubAuthorityCount = 0;
    DWORD                       cbSid = 0;
    BOOL                        fRet = FALSE;
    HANDLE                      hToken = hClientToken;
    
    *ppSid = NULL;

    if (NULL == hClientToken) {
        
        if (!OpenThreadToken(   
            GetCurrentThread(),
            TOKEN_QUERY,
            FALSE,
            &hToken
            )) { 
            
            // not impersonating, use process token...
            if (!OpenProcessToken(
                GetCurrentProcess(),
                TOKEN_QUERY,
                &hToken
                )) {

                TERRORVAL(L"OpenProcessToken failed!", GetLastError());
                return FALSE;
            }
        }
    }
    
    // this will fail, usually w/ ERROR_INSUFFICIENT_BUFFER
    GetTokenInformation(
        hToken, 
        TokenUser, 
        NULL, 
        0, 
        &cbUserInfo
        );
    
    pUserInfo = (PTOKEN_USER) MyAlloc(cbUserInfo);
    if (NULL == pUserInfo) {
        TERRORVAL(L"ALLOC FAILURE!", E_OUTOFMEMORY);
        return FALSE;
    }
    
    if (!GetTokenInformation(
        hToken,
        TokenUser,
        pUserInfo,
        cbUserInfo,
        &cbUserInfo
        )) {
        
        TERRORVAL(L"GetTokenInformation failed!", GetLastError());
        goto ret;
    }
 
    //
    //  Now that we've got the SID AND ATTRIBUTES struct, get the SID lenght,
    //  alloc room, and return *just the SID*
    //
    if (!IsValidSid(pUserInfo->User.Sid)) goto ret;
    pnSubAuthorityCount = GetSidSubAuthorityCount(pUserInfo->User.Sid);
    cbSid = GetSidLengthRequired(*pnSubAuthorityCount);

    *ppSid = (PSID) MyAlloc(cbSid);
    if (NULL == *ppSid ) {
        TERRORVAL(L"Alloc failed!", E_OUTOFMEMORY);
        goto ret;
    }

    if (!CopySid(
            cbSid,
            *ppSid, 
            pUserInfo->User.Sid
            )) {
        
        TERRORVAL(L"CopySid failed!", GetLastError());
        goto copyerr;
    }

    *lpcbSid = cbSid; // may be useful later on...
    fRet = TRUE;

ret:
    if (NULL == hClientToken && NULL != hToken) { // supplied our own
        CloseHandle(hToken);
    }

    if (NULL != pUserInfo) {
        MyFree(pUserInfo);
    }

    return fRet;

copyerr:

    if (NULL != *ppSid) {
        MyFree(*ppSid);
        *ppSid = NULL;
    }

    goto ret;
}

//
//  IsLocalSystem()
//  This function makes the determination if the given process token
//  is running as local system.
//
BOOL
IsLocalSystem(HANDLE hToken) 
{


    PSID                        pLocalSid = NULL, pTokenSid = NULL;
    SID_IDENTIFIER_AUTHORITY    IDAuthorityNT      = SECURITY_NT_AUTHORITY;
    DWORD                       cbSid = 0;    
    BOOL                        fRet = FALSE;

    if (!GetUserSid(
            hToken,
            &pTokenSid,
            &cbSid
            )) {
        goto ret;
    }

    if (!AllocateAndInitializeSid(
                &IDAuthorityNT,
                1,
                SECURITY_LOCAL_SYSTEM_RID,
                0,0,0,0,0,0,0,
                &pLocalSid
                )) {

        TERRORVAL(L"AllocateAndInitializeSid failed!", GetLastError());
        goto ret;
    }

    if (EqualSid(pLocalSid, pTokenSid)) {
        fRet = TRUE; // got one!
    } 

ret:

    if (NULL != pTokenSid) {
        MyFree(pTokenSid);
    }

    if (NULL != pLocalSid) {
        FreeSid(pLocalSid);
    }

    return fRet;
}




//
//  GetLocalSystemToken()
//
//  This function grabs a process token from a LOCAL SYSTEM process and uses it
//  to run as local system for the duration of the test
//
extern "C" DWORD
GetLocalSystemToken(HANDLE* phRet)
{

    HANDLE  hProcess = NULL;
    HANDLE  hPToken = NULL, hPTokenNew = NULL, hPDupToken = NULL;

    DWORD   rgPIDs[MAX_PROCESSES], cbNeeded = 0, dwErr = S_OK, i = 0;
    DWORD   cbrgPIDs = sizeof(DWORD) * MAX_PROCESSES;

    PSECURITY_DESCRIPTOR    pSD = NULL;
    PSID                    pSid = NULL;
    DWORD                   cbSid = 0;
    BOOL                    fSet = FALSE;

    //  SLOW BUFFERs
    BYTE    rgByte[MAX_SD], rgByte2[MAX_SD];
    DWORD   cbByte = MAX_SD, cbByte2 = MAX_SD;
  
    *phRet = NULL;

    if(!SetCurrentPrivilege(SE_DEBUG_NAME, TRUE)) {
        TERROR(L"SetCurrentPrivilege (debug) failed!");
        return E_FAIL;
    }

    if(!SetCurrentPrivilege(SE_TAKE_OWNERSHIP_NAME, TRUE)) {
        TERROR(L"SetCurrentPrivilege (to) failed!");
        return E_FAIL;
    }

    if (!EnumProcesses(
                rgPIDs,
                cbrgPIDs,
                &cbNeeded
                )) {

        dwErr = GetLastError();
        TERRORVAL(L"EnumProcesses failed!", dwErr);
        goto ret;
    }

    //
    //  Get current user's sid for use in expanding SD.
    //
    if (!GetUserSid(
        NULL, 
        &pSid,
        &cbSid
        )) {
        goto ret;
    }

    //
    //  Walk processes until we find one that's running as
    //  local system
    //
    for (i = 1; i < (cbNeeded / sizeof(DWORD)); i++) {

        hProcess = OpenProcess(
                    PROCESS_ALL_ACCESS,
                    FALSE,
                    rgPIDs[i]
                    );
        
        if (NULL == hProcess) {
            dwErr = GetLastError();
            TERRORVAL(L"OpenProcess failed!", dwErr);
            goto ret;
        }

        if (!OpenProcessToken(
                    hProcess,
                    READ_CONTROL | WRITE_DAC,
                    &hPToken
                    )) {

            dwErr = GetLastError();
            TERRORVAL(L"OpenProcessToken failed!", dwErr);
            goto ret;
        }

        //
        //  We've got a token, but we can't use it for 
        //  TOKEN_DUPLICATE access.  So, instead, we'll go
        //  ahead and whack the DACL on the object to grant us
        //  this access, and get a new token.
        //  **** BE SURE TO RESTORE hProcess to Original SD!!! ****
        //
        if (!AddSIDToKernelObjectDacl(
                         pSid,
                         TOKEN_DUPLICATE,
                         hPToken,
                         &pSD
                         )) {
            goto ret;
        }
                       
        fSet = TRUE;
        
        if (!OpenProcessToken(
            hProcess,
            TOKEN_DUPLICATE,
            &hPTokenNew
            )) {
            
            dwErr = GetLastError();
            TERRORVAL(L"OpenProcessToken failed!", dwErr);
            goto ret;
        }
        
        //
        //  Duplicate the token
        //
        if (!DuplicateTokenEx(
                    hPTokenNew,
                    TOKEN_ALL_ACCESS,
                    NULL,
                    SecurityImpersonation,
                    TokenPrimary,
                    &hPDupToken
                    )) {

            dwErr = GetLastError();
            TERRORVAL(L"DuplicateToken failed!", dwErr);
            goto ret;
        }

        if (IsLocalSystem(hPDupToken)) {
            *phRet = hPDupToken;
            break; // found a local system token
        }

        //  Loop cleanup
        if (!SetKernelObjectSecurity(
            hPToken,
            DACL_SECURITY_INFORMATION,
            pSD
            )) {

            dwErr = GetLastError();
            TERRORVAL(L"SetKernelObjectSecurity failed!", dwErr);
            goto ret;
        } 
        
        fSet = FALSE;
        
        if (NULL != hPDupToken) {
            CloseHandle(hPDupToken);
            hPDupToken = NULL;
        }

        if (NULL != pSD) { 
            MyFree(pSD);
            pSD = NULL;
        }

        if (NULL != hPToken) {
            CloseHandle(hPToken);
            hPToken = NULL;
        }

        if (NULL != hProcess) {
            CloseHandle(hProcess);
            hProcess = NULL;
        }

    } // ** FOR ** 

ret:


    //***** REMEMBER TO RESTORE ORIGINAL SD TO OBJECT*****
    
    if (fSet) {
        
        if (!SetKernelObjectSecurity(
            hPToken,
            DACL_SECURITY_INFORMATION,
            pSD
            )) {
            
            dwErr = GetLastError();
            TERRORVAL(L"SetKernelObjectSecurity failed (cleanup)!", dwErr);
        } 
    }

    if (NULL != pSid) {
        MyFree(pSid);
    }

    if (NULL != hPToken) {
        CloseHandle(hPToken);
    }
    
    if (NULL != pSD) {
        MyFree(pSD);
    }

    if (NULL != hProcess) {
        CloseHandle(hProcess);
    }
    
    return dwErr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\programs\signcsp\signcsp.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : client.cxx                                             //
//  DESCRIPTION   : Crypto API interface                                   //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Mar  8 1996 larrys  New                                            //
//                  dbarlow                                                //
//                                                                         //
//  Copyright (C) 1996 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <stdlib.h>
#include <stddef.h>
#include <stdio.h>
#include "mainrpc.h"    // header file generated by the MIDL compiler
#include <imagehlp.h>
#include "des.h"
#include "modes.h"


#include "skrpc.h"
extern "C" {
#include "md5.h"
};

// designatred resource for in file signatures
#define CRYPT_SIG_RESOURCE_NUMBER   "#666"

// MAC in file
#define MAC_RESOURCE_NUMBER   "#667"

static DWORD dwMACInFileVersion = 0x100;

BYTE rgbDESKey[] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef};


BOOL HashTheFile(
                 LPCSTR pszFile,
                 DWORD dwCRCOffset,
                 BYTE *pbHash,
                 DWORD *pcbHash,
                 DWORD cbImage
                 );

DWORD GetCRCOffset(
                   LPCSTR szFile,
                   DWORD cbImage,
                   DWORD *pdwCRCOffset
                   );

static DWORD dwSigInFileVersion = 0x100;

DWORD SetCryptSignatureResource(
                                LPCSTR szFile,
                                DWORD dwSigVersion,
                                DWORD dwCRCOffset,
                                PBYTE pbNewSig,
                                DWORD cbNewSig,
                                DWORD cbImage
                                );

void ShowHelp();
BOOL DumpFile(LPCTSTR szFile, const BYTE *pb, UINT cb);
void CallServer(void);

BYTE pbSignature[256];
BYTE pbDigest[80];
DWORD cbDigestLen = sizeof(pbDigest);
DWORD cbSignatureLen = sizeof(pbSignature);

// The function MACs the given bytes.
void MACBytes(
              IN DESTable *pDESKeyTable,
              IN BYTE *pbData,
              IN DWORD cbData,
              IN OUT BYTE *pbTmp,
              IN OUT DWORD *pcbTmp,
              IN OUT BYTE *pbMAC,
              IN BOOL fFinal
              )
{
    DWORD   cb = cbData;
    DWORD   cbMACed = 0;

    while (cb)
    {
        if ((cb + *pcbTmp) < DES_BLOCKLEN)
        {
            memcpy(pbTmp + *pcbTmp, pbData + cbMACed, cb);
            *pcbTmp += cb;
            break;
        }
        else
        {
            memcpy(pbTmp + *pcbTmp, pbData + cbMACed, DES_BLOCKLEN - *pcbTmp);
            CBC(des, DES_BLOCKLEN, pbMAC, pbTmp, pDESKeyTable,
                ENCRYPT, pbMAC);
            cbMACed = cbMACed + (DES_BLOCKLEN - *pcbTmp);
            cb = cb - (DES_BLOCKLEN - *pcbTmp);
            *pcbTmp = 0;
        }
    }
}

// Given hInst, allocs and returns pointers to MAC pulled from
// resource
BOOL GetResourcePtr(
                    IN HMODULE hInst,
                    IN LPSTR pszRsrcName,
                    OUT BYTE **ppbRsrcMAC,
                    OUT DWORD *pcbRsrcMAC
                    )
{
    HRSRC   hRsrc;
    BOOL    fRet = FALSE;

    // Nab resource handle for our signature
    if (NULL == (hRsrc = FindResourceA(hInst, pszRsrcName,
                                       RT_RCDATA)))
        goto Ret;

    // get a pointer to the actual signature data
    if (NULL == (*ppbRsrcMAC = (PBYTE)LoadResource(hInst, hRsrc)))
        goto Ret;

    // determine the size of the resource
    if (0 == (*pcbRsrcMAC = SizeofResource(hInst, hRsrc)))
        goto Ret;

    fRet = TRUE;
Ret:
    return fRet;
}

#define CSP_TO_BE_MACED_CHUNK  4096

// Given hFile, reads the specified number of bytes (cbToBeMACed) from the file
// and MACs these bytes.  The function does this in chunks.
BOOL MACBytesOfFile(
                     IN HANDLE hFile,
                     IN DWORD cbToBeMACed,
                     IN DESTable *pDESKeyTable,
                     IN BYTE *pbTmp,
                     IN DWORD *pcbTmp,
                     IN BYTE *pbMAC,
                     IN BYTE fFinal
                     )
{
    BYTE    rgbChunk[CSP_TO_BE_MACED_CHUNK];
    DWORD   cbRemaining = cbToBeMACed;
    DWORD   cbToRead;
    DWORD   dwBytesRead;
    BOOL    fRet = FALSE;

    //
    // loop over the file for the specified number of bytes
    // updating the hash as we go.
    //

    while (cbRemaining > 0)
    {
        if (cbRemaining < CSP_TO_BE_MACED_CHUNK)
            cbToRead = cbRemaining;
        else
            cbToRead = CSP_TO_BE_MACED_CHUNK;

        if(!ReadFile(hFile, rgbChunk, cbToRead, &dwBytesRead, NULL))
            goto Ret;
        if (dwBytesRead != cbToRead)
            goto Ret;

        MACBytes(pDESKeyTable, rgbChunk, dwBytesRead, pbTmp, pcbTmp,
                 pbMAC, fFinal);
        cbRemaining -= cbToRead;
    }

    fRet = TRUE;
Ret:
    return fRet;
}


BOOL MACTheFileWithSig(
                       LPCSTR pszImage,
                       DWORD cbImage,
                       IN DWORD dwMACVersion,
                       IN DWORD dwCRCOffset,
                       OUT BYTE *pbMAC
                       )
{
    HMODULE                     hInst = 0;
    MEMORY_BASIC_INFORMATION    MemInfo;
    BYTE                        *pbRsrcMAC;
    DWORD                       cbRsrcMAC;
    BYTE                        *pbRsrcSig;
    DWORD                       cbRsrcSig;
    BYTE                        *pbStart;
    BYTE                        rgbMAC[DES_BLOCKLEN];
    BYTE                        rgbZeroMAC[DES_BLOCKLEN + sizeof(DWORD) * 2];
    BYTE                        rgbZeroSig[144];
    BYTE                        *pbPostCRC;   // pointer to just after CRC
    DWORD                       cbCRCToRsrc1; // number of bytes from CRC to first rsrc
    DWORD                       cbRsrc1ToRsrc2; // number of bytes from first rsrc to second
    DWORD                       cbPostRsrc;    // size - (already hashed + signature size)
    BYTE                        *pbRsrc1ToRsrc2;
    BYTE                        *pbPostRsrc;
    BYTE                        *pbZeroRsrc1;
    BYTE                        *pbZeroRsrc2;
    DWORD                       cbZeroRsrc1;
    DWORD                       cbZeroRsrc2;
    DWORD                       dwZeroCRC = 0;
    DWORD                       dwBytesRead = 0;
    OFSTRUCT                    ImageInfoBuf;
    HFILE                       hFile = HFILE_ERROR;
    HANDLE                      hMapping = NULL;
    DESTable                    DESKeyTable;
    BYTE                        rgbTmp[DES_BLOCKLEN];
    DWORD                       cbTmp = 0;
    BOOL                        fRet = FALSE;

    memset(&MemInfo, 0, sizeof(MemInfo));
    memset(rgbMAC, 0, sizeof(rgbMAC));
    memset(rgbTmp, 0, sizeof(rgbTmp));

    // Load the file
    if (HFILE_ERROR == (hFile = OpenFile(pszImage, &ImageInfoBuf,
                                         OF_READ)))
    {
        goto Ret;
    }

    hMapping = CreateFileMapping((HANDLE)IntToPtr(hFile),
                                  NULL,
                                  PAGE_READONLY,
                                  0,
                                  0,
                                  NULL);
    if(hMapping == NULL)
    {
        goto Ret;
    }

    hInst = (HMODULE)MapViewOfFile(hMapping,
                          FILE_MAP_READ,
                          0,
                          0,
                          0);
    if(hInst == NULL)
    {
        goto Ret;
    }
    pbStart = (BYTE*)hInst;

    // Convert pointer to HMODULE, using the same scheme as
    // LoadLibrary (windows\base\client\module.c).
    *((ULONG_PTR*)&hInst) |= 0x00000001;

    // the MAC resource
    if (!GetResourcePtr(hInst, MAC_RESOURCE_NUMBER, &pbRsrcMAC, &cbRsrcMAC))
        goto Ret;

    // the MAC resource
    if (!GetResourcePtr(hInst, CRYPT_SIG_RESOURCE_NUMBER, &pbRsrcSig, &cbRsrcSig))
        goto Ret;

    if (cbRsrcMAC < (sizeof(DWORD) * 2))
        goto Ret;

    // create a zero byte MAC
    memset(rgbZeroMAC, 0, sizeof(rgbZeroMAC));

    // create a zero byte Sig
    memset(rgbZeroSig, 0, sizeof(rgbZeroSig));

    // set up the pointers
    pbPostCRC = pbStart + dwCRCOffset + sizeof(DWORD);
    if (pbRsrcSig > pbRsrcMAC)    // MAC is first Rsrc
    {
        cbCRCToRsrc1 = (DWORD)(pbRsrcMAC - pbPostCRC);
        pbRsrc1ToRsrc2 = pbRsrcMAC + cbRsrcMAC;
        cbRsrc1ToRsrc2 = (DWORD)(pbRsrcSig - pbRsrc1ToRsrc2);
        pbPostRsrc = pbRsrcSig + cbRsrcSig;
        cbPostRsrc = (cbImage - (DWORD)(pbPostRsrc - pbStart));

        // zero pointers
        pbZeroRsrc1 = rgbZeroMAC;
        cbZeroRsrc1 = cbRsrcMAC;
        pbZeroRsrc2 = rgbZeroSig;
        cbZeroRsrc2 = cbRsrcSig;
    }
    else                        // Sig is first Rsrc
    {
        cbCRCToRsrc1 = (DWORD)(pbRsrcSig - pbPostCRC);
        pbRsrc1ToRsrc2 = pbRsrcSig + cbRsrcSig;
        cbRsrc1ToRsrc2 = (DWORD)(pbRsrcMAC - pbRsrc1ToRsrc2);
        pbPostRsrc = pbRsrcMAC + cbRsrcMAC;
        cbPostRsrc = (cbImage - (DWORD)(pbPostRsrc - pbStart));

        // zero pointers
        pbZeroRsrc1 = rgbZeroSig;
        cbZeroRsrc1 = cbRsrcSig;
        pbZeroRsrc2 = rgbZeroMAC;
        cbZeroRsrc2 = cbRsrcMAC;
    }

    // init the key table
    deskey(&DESKeyTable, rgbDESKey);

    // MAC up to the CRC
    if (!MACBytesOfFile((HANDLE)IntToPtr(hFile), dwCRCOffset, &DESKeyTable, rgbTmp,
                        &cbTmp, rgbMAC, FALSE))
    {
        goto Ret;
    }

    // pretend CRC is zeroed
    MACBytes(&DESKeyTable, (BYTE*)&dwZeroCRC, sizeof(DWORD), rgbTmp, &cbTmp,
             rgbMAC, FALSE);
    if (!SetFilePointer((HANDLE)IntToPtr(hFile), sizeof(DWORD), NULL, FILE_CURRENT))
    {
        goto Ret;
    }

    // MAC from CRC to first resource
    if (!MACBytesOfFile((HANDLE)IntToPtr(hFile), cbCRCToRsrc1, &DESKeyTable, rgbTmp,
                        &cbTmp, rgbMAC, FALSE))
    {
        goto Ret;
    }

    // pretend image has zeroed first resource
    MACBytes(&DESKeyTable, (BYTE*)pbZeroRsrc1, cbZeroRsrc1, rgbTmp, &cbTmp,
             rgbMAC, FALSE);
    if (!SetFilePointer((HANDLE)IntToPtr(hFile), cbZeroRsrc1, NULL, FILE_CURRENT))
    {
        goto Ret;
    }

    // MAC from first resource to second
    if (!MACBytesOfFile((HANDLE)IntToPtr(hFile), cbRsrc1ToRsrc2, &DESKeyTable, rgbTmp,
                        &cbTmp, rgbMAC, FALSE))
    {
        goto Ret;
    }

    // pretend image has zeroed second Resource
    MACBytes(&DESKeyTable, (BYTE*)pbZeroRsrc2, cbZeroRsrc2, rgbTmp, &cbTmp,
             rgbMAC, FALSE);
    if (!SetFilePointer((HANDLE)IntToPtr(hFile), cbZeroRsrc2, NULL, FILE_CURRENT))
    {
        goto Ret;
    }

    // MAC after the resource
    if (!MACBytesOfFile((HANDLE)IntToPtr(hFile), cbPostRsrc, &DESKeyTable, rgbTmp, &cbTmp,
                        rgbMAC, TRUE))
    {
        goto Ret;
    }

    memcpy(pbMAC, rgbMAC, DES_BLOCKLEN);

    fRet = TRUE;
Ret:
    if(hInst)
        UnmapViewOfFile(hInst);
    if(hMapping)
        CloseHandle(hMapping);
    if (HFILE_ERROR != hFile)
        _lclose(hFile);

    return fRet;
}

// SetCryptMACResource
//
// slams MAC resource in file with the new MAC
//
DWORD SetCryptMACResource(
                          IN LPCSTR szFile,
                          IN DWORD dwMACVersion,
                          IN DWORD dwCRCOffset,
                          IN PBYTE pbNewMAC,
                          IN DWORD cbImage
                          )
{
    DWORD   dwErr = 0x1;

    HANDLE  hFileProv = NULL;
    HMODULE hInst = NULL;

    PBYTE   pbFilePtr = NULL;
    DWORD   cbImageSize, cbMACOffset;

    PBYTE   pbMAC;
    DWORD   cbMAC;

    MEMORY_BASIC_INFORMATION    MemInfo;
    BYTE                        *pbStart;

    DWORD               OldCheckSum;
    DWORD               NewCheckSum;
    PIMAGE_NT_HEADERS   pImageNTHdrs;

    HANDLE  hFileMap = NULL;

    memset(&MemInfo, 0, sizeof(MemInfo));

    // Load the file as a datafile
    if (NULL == (hInst = LoadLibraryEx(szFile, NULL, LOAD_LIBRARY_AS_DATAFILE)))
    {
        printf("Couldn't load file\n");
        goto Ret;
    }
    if (!GetResourcePtr(hInst, MAC_RESOURCE_NUMBER, &pbMAC, &cbMAC))
    {
        printf("Couldn't find MAC placeholder\n");
        goto Ret;
    }

    // get image start address
    VirtualQuery(hInst, &MemInfo, sizeof(MemInfo));
    pbStart = (BYTE*)MemInfo.BaseAddress;

    FreeLibrary(hInst); hInst = NULL;

    cbMACOffset = (DWORD)(pbMAC - pbStart);

    if (cbMAC != (DES_BLOCKLEN + sizeof(DWORD) * 2))
    {
        printf("Attempt to replace %d zeros with new MAC!\n", cbMAC);
        goto Ret;
    }

    if (INVALID_HANDLE_VALUE == (hFileProv = CreateFile(szFile,
                                GENERIC_READ | GENERIC_WRITE,
                                0,  // don't share
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                0)))
    {
        printf("Couldn't CreateFile: 0x%x\n", GetLastError());
        goto Ret;
    }

    if (NULL == (hFileMap = CreateFileMapping(
                                hFileProv,
                                NULL,
                                PAGE_READWRITE,
                                0,
                                0,
                                NULL)))
    {
        printf("Couldn't map file\n");
        goto Ret;
    }

    if (NULL == (pbFilePtr = (PBYTE)MapViewOfFile(
                                hFileMap,
                                FILE_MAP_ALL_ACCESS,
                                0,
                                0,
                                0)))
    {
        printf("Couldn't create view\n");
        goto Ret;
    }

    // copy version, CRC offset and new sig
    CopyMemory(pbFilePtr+cbMACOffset, &dwMACVersion, sizeof(dwMACVersion));
    cbMACOffset += sizeof(dwMACVersion);
    CopyMemory(pbFilePtr+cbMACOffset, &dwCRCOffset, sizeof(dwCRCOffset));
    cbMACOffset += sizeof(dwCRCOffset);
    CopyMemory(pbFilePtr+cbMACOffset, pbNewMAC, DES_BLOCKLEN);

    // compute a new checksum
    if (NULL == (pImageNTHdrs = CheckSumMappedFile(pbFilePtr, cbImage,
                                                   &OldCheckSum, &NewCheckSum)))
        goto Ret;

    CopyMemory(&pImageNTHdrs->OptionalHeader.CheckSum, &NewCheckSum, sizeof(DWORD));

    if (NULL == (pImageNTHdrs = CheckSumMappedFile(pbFilePtr, cbImage,
                                                   &OldCheckSum, &NewCheckSum)))
        goto Ret;

    if (OldCheckSum != NewCheckSum)
        goto Ret;

    dwErr = ERROR_SUCCESS;
Ret:
    if (pbFilePtr)
        UnmapViewOfFile(pbFilePtr);

    if (hFileMap)
        CloseHandle(hFileMap);

    if (hInst)
        FreeLibrary(hInst);

    if (hFileProv)
        CloseHandle(hFileProv);

    return dwErr;
}

void MacCSP(
            LPCSTR pszInFile
            )
{
    DWORD   cbImage;
    DWORD   dwCRCOffset;
    HANDLE  hFileProv = INVALID_HANDLE_VALUE;
    BYTE    rgbMAC[DES_BLOCKLEN];
    HMODULE hInst = NULL;

    PBYTE   pbFilePtr = NULL;
    DWORD   cbImageSize, cbMACOffset;

    PBYTE   pbMAC;
    DWORD   cbMAC;

    memset(rgbMAC, 0, sizeof(rgbMAC));

    // check if the MAC resource is in the CSP and exit if not
    // Load the file as a datafile
    if (NULL == (hInst = LoadLibraryEx(pszInFile,
                                       NULL,
                                       LOAD_LIBRARY_AS_DATAFILE)))
    {
        printf("Couldn't load file\n");
        goto Ret;
    }
    if (!GetResourcePtr(hInst, MAC_RESOURCE_NUMBER, &pbMAC, &cbMAC))
    {
        goto Ret;
    }
    FreeLibrary(hInst);
    hInst = NULL;

    // get the file size
    if ((hFileProv = CreateFile(pszInFile,
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                0)) == INVALID_HANDLE_VALUE)
    {
        printf("CSP specified was not found!\n");
        goto Ret;
    }

    if (0xffffffff == (cbImage = GetFileSize(hFileProv, NULL)))
    {
        printf("CSP specified was not found!\n");
        goto Ret;
    }

    CloseHandle(hFileProv);
    hFileProv = NULL;

    if (0 != GetCRCOffset(pszInFile, cbImage, &dwCRCOffset))
    {
        printf("Unable to get CRC!\n");
        goto Ret;
    }

    // calculate the MAC
    if (!MACTheFileWithSig(pszInFile,
                           cbImage,
                           dwMACInFileVersion,
                           dwCRCOffset,
                           rgbMAC))
    {
        printf("MAC failed!\n");
        goto Ret;
    }

    //
    // Place the MAC into the resource in the file
    //

    if (ERROR_SUCCESS != SetCryptMACResource(pszInFile,
                                             dwMACInFileVersion,
                                             dwCRCOffset,
                                             rgbMAC,
                                             cbImage))
    {
        printf("Unable to set the MAC into the file resource!\n");
        goto Ret;
    }
Ret:
    if (hInst)
    {
        FreeLibrary(hInst);
    }

    if (INVALID_HANDLE_VALUE != hFileProv)
    {
        CloseHandle(hFileProv);
    }

    return;
}

/*++

main:

    This is the main entry point of the application.

Arguments:

    argc - Count of arguments
    argv - array of arguments

Return Value:

    0 - Success
    1 - Error

Author:

    Doug Barlow (dbarlow) 1/25/1996

--*/
extern "C" void __cdecl
main(
    int argc,
    char *argv[])
{
    DWORD exStatus = 1;
    DWORD index;
    LPCTSTR szBinFile = NULL;
    LPCTSTR szInFile = NULL;
    BOOL fOutput = FALSE;
    int status;
    DWORD ThreadId;
    HANDLE hThread;

    // RPC Specific variables.
    RPC_STATUS rpcStatus;
    unsigned char * pszUuid = NULL;
    char * pszProtocolSequence = "ncacn_np";
    unsigned char * pszNetworkAddress   = (LPBYTE)"\\\\enigma.ntdev.microsoft.com";
    char * pszEndpoint = "\\pipe\\sign";
    unsigned char * pszOptions      = NULL;
    unsigned char * pszStringBinding    = NULL;
    DWORD dwrt;
    DWORD i;
    DWORD cbImage;
    DWORD dwCRCOffset;
    HANDLE hFileProv = 0;

    //
    // Parse the command line.
    //

    if ((argc != 2) || (argv[1][0] == '?'))
    {
        ShowHelp();
        exStatus = 0;
        goto ErrorExit;
    }

    szInFile = &argv[1][0];

    //
    // Command consistency checks.
    //

    if (NULL == szInFile)
    {
        printf("No input file specified.\n");
        goto ErrorExit;
    }

    MacCSP(szInFile);

    // get the file size
    if ((hFileProv = CreateFile(szInFile,
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                0)) == INVALID_HANDLE_VALUE)
    {
        printf("CSP specified was not found!\n");
        goto ErrorExit;
    }

    if (0xffffffff == (cbImage = GetFileSize(hFileProv, NULL)))
    {
        printf("CSP specified was not found!\n");
        goto ErrorExit;
    }

    CloseHandle(hFileProv);
    hFileProv = NULL;

    if (ERROR_SUCCESS != GetCRCOffset(szInFile, cbImage, &dwCRCOffset))
    {
        printf("Unable to get the CRC offset on the file!\n");
        goto ErrorExit;
    }

    //
    // Compute the hash.
    //

    if (!HashTheFile(szInFile, dwCRCOffset, pbDigest, &cbDigestLen, cbImage))
    {
        printf("Unable to hash the file!\n");
        goto ErrorExit;
    }

    //
    // Get the signature.
    //

    // Try to make rpc connection
    rpcStatus = RpcStringBindingCompose(pszUuid,
                     (unsigned char *) pszProtocolSequence,
                     pszNetworkAddress,
                     (unsigned char *) pszEndpoint,
                     pszOptions,
                     &pszStringBinding);

#ifdef DEBUG
    printf("RpcStringBindingCompose returned 0x%x\n", rpcStatus);
    printf("pszStringBinding = %s\n", pszStringBinding);
#endif
    if (0 != rpcStatus)
    {
        printf("Failed to compose binding string for target RPC server.\n");
        goto ErrorExit;
    }

    /* Set the binding handle that will */
    /* be used to bind to the server  */
    rpcStatus = RpcBindingFromStringBinding(pszStringBinding,
                     &hello_IfHandle);

#ifdef DEBUG
    printf("RpcBindingFromStringBinding returned 0x%x\n", rpcStatus);
#endif
    if (0 != rpcStatus)
    {
        printf("Failed to bind to target RPC server.\n");
        goto ErrorExit;
    }

    if ((hThread = CreateThread(NULL,
                                0,
                                (LPTHREAD_START_ROUTINE) CallServer,
                                NULL,
                                0,
                                &ThreadId)) == NULL)
    {
        printf("Call to CreateThread failed\n");
        goto ErrorExit;
    }

    printf("Sending request to be signed, will wait 5 minutes\n");
    for (i = 0; i < 20; i++)
    {
        printf("Waited   %d  seconds\n", i*30);
        dwrt = WaitForSingleObject(hThread, 15000);
        if (dwrt == WAIT_OBJECT_0)
        {
            break;
        }
    }

    if (i == 20)
    {
        printf("Call to Server timed out\n");
        goto ErrorExit;
    }

    GetExitCodeThread(hThread, &dwrt);

    if (dwrt)
    {
        goto ErrorExit;
    }

    //
    // Place the signature into the resource in the file
    //

    if (ERROR_SUCCESS != SetCryptSignatureResource(szInFile, dwSigInFileVersion,
                                                   dwCRCOffset, pbSignature,
                                                   cbSignatureLen, cbImage))
    {
        printf("Unable to set the signature into the file resource!\n");
        goto ErrorExit;
    }

    //
    // Clean up and return.
    //

    exStatus = 0;


ErrorExit:
    exit(exStatus);

}

void CallServer(void)
{
    RpcTryExcept
    {
        cbSignatureLen = sizeof(pbSignature);
        if (GenSignature(pbDigest, &cbSignatureLen, pbSignature))
        {
            printf("GenSignature returned an error \n");
            ExitThread(TRUE);
        }
    }
    RpcExcept(1)
    {
        printf("RPC error -- exception code is  0x%X\n", RpcExceptionCode());
        ExitThread(RpcExceptionCode());
    }
    RpcEndExcept

    ExitThread(FALSE);

}

// Given hInst, allocs and returns pointers to signature pulled from
// resource
BOOL GetCryptSigResourcePtr(
                            HMODULE hInst,
                            BYTE **ppbRsrcSig,
                            DWORD *pcbRsrcSig
                            )
{
    HRSRC   hRsrc;
    BOOL    fRet = FALSE;

    // Nab resource handle for our signature
    if (NULL == (hRsrc = FindResource(hInst, CRYPT_SIG_RESOURCE_NUMBER,
                                      RT_RCDATA)))
        goto Ret;

    // get a pointer to the actual signature data
    if (NULL == (*ppbRsrcSig = (PBYTE)LoadResource(hInst, hRsrc)))
        goto Ret;

    // determine the size of the resource
    if (0 == (*pcbRsrcSig = SizeofResource(hInst, hRsrc)))
        goto Ret;

    fRet = TRUE;
Ret:
    return fRet;
}

// Given hInst, hashes over the file skipping, hashing zero bytes where the
// resource is
BOOL HashTheFile(
                 LPCSTR pszFile,
                 DWORD dwCRCOffset,
                 BYTE *pbHash,
                 DWORD *pcbHash,
                 DWORD cbImage
                 )
{
    MEMORY_BASIC_INFORMATION    MemInfo;
    BYTE                        *pbRsrcSig;
    DWORD                       cbRsrcSig;
    BYTE                        *pbStart;
    BYTE                        *pbZeroSig = NULL;
    MD5_CTX                     MD5Hash;
    DWORD                       dwZeroCRC = 0;
    DWORD                       cbPreCRC;     // start of CRC
    DWORD                       cbCRCToSig;   // end of CRC to start of sig
    BYTE                        *pbPostCRC;   // just after CRC
    DWORD                       cbPostSig;    // size - (already hashed + signature size)
    BYTE                        *pbPostSig;
    HMODULE                     hInst = 0;
    BOOL                        fRet = FALSE;

    memset(&MD5Hash, 0, sizeof(MD5Hash));
    memset(&MemInfo, 0, sizeof(MemInfo));

    // Load the file as a datafile
    if (NULL == (hInst = LoadLibraryEx(pszFile, NULL, LOAD_LIBRARY_AS_DATAFILE)))
        goto Ret;

    // get image start address
    VirtualQuery(hInst, &MemInfo, sizeof(MemInfo));
    pbStart = (BYTE*)MemInfo.BaseAddress;

    // the resources signature
    if (!GetCryptSigResourcePtr(hInst, &pbRsrcSig, &cbRsrcSig))
        goto Ret;

    // create a zero byte signature
    if (NULL == (pbZeroSig = (BYTE*)LocalAlloc(LMEM_ZEROINIT, cbRsrcSig)))
        goto Ret;

    // want to hash the version and the CRC offset
    CopyMemory(pbZeroSig, &dwSigInFileVersion, sizeof(dwSigInFileVersion));
    CopyMemory(pbZeroSig + sizeof(dwSigInFileVersion), &dwCRCOffset,
               sizeof(dwCRCOffset));

    // hash over the relevant data
    {
        pbPostCRC = pbStart + dwCRCOffset + sizeof(dwZeroCRC);
        cbCRCToSig = (DWORD)(pbRsrcSig - pbPostCRC);
        pbPostSig = pbRsrcSig + cbRsrcSig;
        cbPostSig = (cbImage - (DWORD)(pbPostSig - pbStart));

        MD5Init(&MD5Hash);

        MD5Update(&MD5Hash, pbStart, dwCRCOffset);

        // pretend CRC is zeroed
        MD5Update(&MD5Hash, (BYTE*)&dwZeroCRC, sizeof(dwZeroCRC));

        // pretend image has zeroed sig
        MD5Update(&MD5Hash, pbPostCRC, cbCRCToSig);

        // pretend image has zeroed sig
        MD5Update(&MD5Hash, pbZeroSig, cbRsrcSig);

        MD5Update(&MD5Hash, pbPostSig, cbPostSig);

        // Finish the hash
        MD5Final(&MD5Hash);

        *pcbHash = MD5DIGESTLEN;
        memcpy(pbHash, MD5Hash.digest, MD5DIGESTLEN);
    }

    fRet = TRUE;
Ret:
    if (hInst)
        FreeLibrary(hInst);
    if (pbZeroSig)
        LocalFree(pbZeroSig);
    return fRet;
}

DWORD GetCRCOffset(
                   LPCSTR szFile,
                   DWORD cbImage,
                   DWORD *pdwCRCOffset
                   )
{
    DWORD               dwErr = 0x1;

    HANDLE              hFileProv = NULL;
    PBYTE               pbFilePtr = NULL;
    DWORD               OldCheckSum;
    DWORD               NewCheckSum;
    PIMAGE_NT_HEADERS   pImageNTHdrs;

    HANDLE              hFileMap = NULL;


    if (INVALID_HANDLE_VALUE == (hFileProv = CreateFile(szFile,
                                GENERIC_READ | GENERIC_WRITE,
                                0,  // don't share
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                0)))
    {
        printf("Couldn't CreateFile: 0x%x\n", GetLastError());
        goto Ret;
    }

    if (NULL == (hFileMap = CreateFileMapping(
                                hFileProv,
                                NULL,
                                PAGE_READWRITE,
                                0,
                                0,
                                NULL)))
    {
        printf("Couldn't map file\n");
        goto Ret;
    }

    if (NULL == (pbFilePtr = (PBYTE)MapViewOfFile(
                                hFileMap,
                                FILE_MAP_ALL_ACCESS,
                                0,
                                0,
                                0)))
    {
        printf("Couldn't create view\n");
        goto Ret;
    }

    // compute a new checksum
    if (NULL == (pImageNTHdrs = CheckSumMappedFile(pbFilePtr, cbImage,
                                                   &OldCheckSum, &NewCheckSum)))
        goto Ret;

    *pdwCRCOffset = (DWORD)((BYTE*)&pImageNTHdrs->OptionalHeader.CheckSum - pbFilePtr);
    dwErr = ERROR_SUCCESS;
Ret:
    if (pbFilePtr)
        UnmapViewOfFile(pbFilePtr);

    if (hFileMap)
        CloseHandle(hFileMap);

    if (hFileProv)
        CloseHandle(hFileProv);

    return dwErr;
}

// SetCryptSignatureResource
//
// slams signature resource in file with the new signature
//
// szFile is file to modify
// pbNewSig is new signature
// cbNewSig is new signature length
DWORD SetCryptSignatureResource(
                                LPCSTR szFile,
                                DWORD dwSigVersion,
                                DWORD dwCRCOffset,
                                PBYTE pbNewSig,
                                DWORD cbNewSig,
                                DWORD cbImage
                                )
{
    DWORD   dwErr = 0x1;

    HANDLE  hFileProv = NULL;
    HMODULE hInst = NULL;

    PBYTE   pbFilePtr = NULL;
    DWORD   cbImageSize, cbSigOffset;

    PBYTE   pbSig;
    DWORD   cbSig;

    MEMORY_BASIC_INFORMATION    MemInfo;
    BYTE                        *pbStart;

    DWORD               OldCheckSum;
    DWORD               NewCheckSum;
    PIMAGE_NT_HEADERS   pImageNTHdrs;

    HANDLE  hFileMap = NULL;

    memset(&MemInfo, 0, sizeof(MemInfo));

    // Load the file as a datafile
    if (NULL == (hInst = LoadLibraryEx(szFile, NULL, LOAD_LIBRARY_AS_DATAFILE)))
    {
        printf("Couldn't load file\n");
        goto Ret;
    }
    if (!GetCryptSigResourcePtr(hInst,
                                &pbSig,
                                &cbSig))
    {
        printf("Couldn't find signature placeholder\n");
        goto Ret;
    }

    // get image start address
    VirtualQuery(hInst, &MemInfo, sizeof(MemInfo));
    pbStart = (BYTE*)MemInfo.BaseAddress;

    FreeLibrary(hInst); hInst = NULL;

    cbSigOffset = (DWORD)(pbSig - pbStart);

    if (cbSig < (cbNewSig + (sizeof(DWORD) * 2)))
    {
        printf("Attempt to replace %d zeros with %d byte signature!\n", cbSig, cbNewSig);
        goto Ret;
    }

    if (INVALID_HANDLE_VALUE == (hFileProv = CreateFile(szFile,
                                GENERIC_READ | GENERIC_WRITE,
                                0,  // don't share
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                0)))
    {
        printf("Couldn't CreateFile: 0x%x\n", GetLastError());
        goto Ret;
    }

    if (NULL == (hFileMap = CreateFileMapping(
                                hFileProv,
                                NULL,
                                PAGE_READWRITE,
                                0,
                                0,
                                NULL)))
    {
        printf("Couldn't map file\n");
        goto Ret;
    }

    if (NULL == (pbFilePtr = (PBYTE)MapViewOfFile(
                                hFileMap,
                                FILE_MAP_ALL_ACCESS,
                                0,
                                0,
                                0)))
    {
        printf("Couldn't create view\n");
        goto Ret;
    }

    // copy version, CRC offset and new sig
    CopyMemory(pbFilePtr+cbSigOffset, &dwSigVersion, sizeof(dwSigVersion));
    cbSigOffset += sizeof(dwSigVersion);
    CopyMemory(pbFilePtr+cbSigOffset, &dwCRCOffset, sizeof(dwCRCOffset));
    cbSigOffset += sizeof(dwCRCOffset);
    CopyMemory(pbFilePtr+cbSigOffset, pbNewSig, cbNewSig);
    if (cbSig > (cbNewSig + (sizeof(DWORD) * 2)))
    {
        ZeroMemory(pbFilePtr+cbSigOffset+cbNewSig,
                   cbSig - (cbNewSig + (sizeof(DWORD) * 2)));
    }

    // compute a new checksum
    if (NULL == (pImageNTHdrs = CheckSumMappedFile(pbFilePtr, cbImage,
                                                   &OldCheckSum, &NewCheckSum)))
        goto Ret;

    CopyMemory(&pImageNTHdrs->OptionalHeader.CheckSum, &NewCheckSum, sizeof(DWORD));

    if (NULL == (pImageNTHdrs = CheckSumMappedFile(pbFilePtr, cbImage,
                                                   &OldCheckSum, &NewCheckSum)))
        goto Ret;

    if (OldCheckSum != NewCheckSum)
        goto Ret;

    dwErr = ERROR_SUCCESS;
Ret:
    if (pbFilePtr)
        UnmapViewOfFile(pbFilePtr);

    if (hFileMap)
        CloseHandle(hFileMap);

    if (hInst)
        FreeLibrary(hInst);

    if (hFileProv)
        CloseHandle(hFileProv);

    return dwErr;
}


/*++

ShowHelp:

    This routine displays a short help message to the given output stream.

Arguments:

    ostr - The output stream to receive the help message.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 7/21/1995

--*/

void
ShowHelp()
{
    printf("CryptoAPI Internal CSP Signing Utility\n");
    printf("signcsp <filename>\n");
}

/* MIDL allocate and free */

void __RPC_FAR * __RPC_API midl_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_API midl_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\randlib\cpu.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    cpu.h

Abstract:

    Read CPU specifics performance counters.

Author:

    Scott Field (sfield)    24-Sep-98

--*/

#ifndef __CPU_H__
#define __CPU_H__

unsigned int
GatherCPUSpecificCounters(
    IN      unsigned char *pbCounterState,
    IN  OUT unsigned long *pcbCounterState
    );


#endif  // __CPU_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\randlib\circhash.h ===
// Circular Hash
//
// This code implements a circular hash algorithm, intended as a variable
// length hash function that is fast to update. (The hash function will be
// called many times.)  This is done by SHA-1'ing each of the inputs, then
// circularly XORing this value into a buffer.

#ifndef __CIRCHASH_H__
#define __CIRCHASH_H__

typedef struct {
    DWORD       dwCircHashVer;
    DWORD       dwCircSize;
    DWORD       dwMode;
    DWORD       dwCircInc;
    DWORD       dwCurCircPos;
    DWORD       dwAlgId;
    DWORD       dwPad1;
    DWORD       dwPad2;
    BYTE        CircBuf[ 256 ];
} CircularHash;


// mode flags
#define CH_MODE_FEEDBACK        0x01

// alg flags
#define CH_ALG_SHA1_NS          0       // SHA-1 without endian transform
#define CH_ALG_MD4              1       // RSA MD4

BOOL
InitCircularHash(
    IN      CircularHash *NewHash,
    IN      DWORD dwUpdateInc,
    IN      DWORD dwAlgId,
    IN      DWORD dwMode
    );

VOID
DestroyCircularHash(
    IN      CircularHash *OldHash
    );

BOOL
GetCircularHashValue(
    IN      CircularHash *CurrentHash,
        OUT BYTE **ppbHashValue,
        OUT DWORD *pcbHashValue
        );

BOOL
UpdateCircularHash(
    IN      CircularHash *CurrentHash,
    IN      VOID *pvData,
    IN      DWORD cbData
    );

#endif  // __CIRCHASH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\programs\stress\stress.c ===
#undef UNICODE					// ## Not Yet
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <windows.h>
#include <wincrypt.h>

#define NTAG_MULTIPHASE		0x80000000
#define DES_TEST                0x00000008

#define UTILITY_BUF_SIZE	1024
#define UTILITY_BUF_SIZE_2	1050
#define EXPORT_BUFFER_LEN	32768

#define MAXKEYLEN  128

HCRYPTPROV	hMe;
CHAR		pszMyName[64];
OFSTRUCT        ImageInfoBuf;
HFILE           hFile;
BYTE		buf[UTILITY_BUF_SIZE];
BYTE		buf2[UTILITY_BUF_SIZE];
DWORD		BLen, BLen2, i;
HCRYPTKEY	hKey = 0;
HCRYPTKEY	hKey2 = 0;
HCRYPTKEY	hMyPubKey;
HCRYPTKEY	hClientKey;
WORD            wRandomSize;
DWORD           dRandom;
BYTE            *pTmp;
DWORD           count;
BYTE            *bRanbuf;
BYTE            *bcryptbuf;
DWORD           i;
BYTE            pData[8];
BYTE            pHashData1[50];
DWORD           BHashLen1;
BYTE            pHashData2[50];
DWORD           BHashLen2;
BYTE            pHashSignData1[MAXKEYLEN];
DWORD           BHashSignLen1;
BYTE            pHashSignData2[MAXKEYLEN];
DWORD           BHashSignLen2;
HCRYPTHASH	hHash = 0;

BOOL Logon(int cArg);

BOOL TEncrypt(HCRYPTKEY hTKey, HCRYPTHASH hTHash, BOOL FinalFlag,
              DWORD dwFlags, BYTE *Tbuf, DWORD *pBLen, DWORD pdwBufLen,
              int cArg, CHAR *szAlgid, CHAR *szmode);
BOOL TDecrypt(HCRYPTKEY hTKey, HCRYPTHASH hTHash, BOOL FinalFlag,
              DWORD dwFlags, BYTE *Tbuf, DWORD *pBLen, int cArg,
              CHAR *szAlgid, CHAR *szmode);

BOOL TestRC2(int cArg, CHAR *bbuf, DWORD bsize);

BOOL TestRC4(int cArg, CHAR *bbuf, DWORD bsize);

#ifdef TEST_VERSION
BOOL TestDES(int cArg, CHAR *bbuf, DWORD bsize);
#endif

BOOL TestHash(int cArg, CHAR *bbuf, DWORD bsize);

BOOL TestExchange(int cArg, CHAR *bbuf, DWORD bsize);

BOOL Hash(int cArg, CHAR *bbuf, DWORD bsize, BYTE *pHashOut,
          DWORD *pHashLenOut,  BYTE *pSigData, DWORD *pdwSigLen, DWORD Algid);

int __cdecl main(int cArg, char *rgszArg[])
{

    // Make sure keys don't exist to start
    strcpy(pszMyName, "stress");
    CryptAcquireContext(&hMe, pszMyName, MS_DEF_PROV, PROV_RSA_FULL,
                        CRYPT_DELETEKEYSET);

    while (TRUE)
    {

        // Logon to provider
        if (Logon(cArg))
	    exit(0);

        pTmp = (BYTE *) &wRandomSize;

	while (1)
	{
            if (RCRYPT_FAILED(CryptGenRandom(hMe, 2, pTmp)))
            {
                if (cArg > 1)
	            printf("GenRandom failed = %x\n", GetLastError());
                else
                    printf("FAIL\n");
                return(TRUE);
	    }
	    if (wRandomSize != 0)
               break;
        }

	dRandom = (DWORD) (wRandomSize + (wRandomSize % 8));

	if ((bRanbuf = VirtualAlloc(0, dRandom, MEM_COMMIT |
                                      MEM_RESERVE, PAGE_READWRITE)) == 0)
        {
            if (cArg > 1)
	    {
	        printf("malloc failed = %x\n", GetLastError());
            }
	    else
                printf("malloc FAIL\n");
            return(TRUE);
        }

	if (RCRYPT_FAILED(CryptGenRandom(hMe, dRandom, bRanbuf)))
        {
            if (cArg > 1)
	        printf("GenRandom failed = %x\n", GetLastError());
	    else
                printf("FAIL\n");
            return(TRUE);
        }

	if ((bcryptbuf = VirtualAlloc(0, dRandom + 8, MEM_COMMIT |
                                      MEM_RESERVE, PAGE_READWRITE)) == 0)
	{
            if (cArg > 1)
	    {
	        printf("malloc failed = %x\n", GetLastError());
            }
	    else
                printf("malloc FAIL\n");
            return(TRUE);
        }

	if (cArg > 1)
        {
            printf("bytes generated			 %x\n", wRandomSize);
        }

        memcpy(bcryptbuf, bRanbuf, dRandom);

	if (TestRC2(cArg, bcryptbuf, dRandom))
            exit(0);

	if (TestRC4(cArg, bcryptbuf, dRandom))
            exit(0);

#ifdef TEST_VERSION
	if (TestDES(cArg, bcryptbuf, dRandom))
            exit(0);
#endif

	if (TestHash(cArg, bcryptbuf, dRandom))
            exit(0);

	if (TestExchange(cArg, bcryptbuf, dRandom))
		exit(0);

        if (VirtualFree(bRanbuf, 0, MEM_RELEASE) != TRUE)
        {
            if (cArg > 1)
	        printf("VirtulaFree failed: %x\n", GetLastError());
        }

	if (VirtualFree(bcryptbuf, 0, MEM_RELEASE) != TRUE)
        {
            if (cArg > 1)
	        printf("VirtulaFree failed: %x\n", GetLastError());
        }

        if (cArg > 1)
            printf("CryptReleaseContext		");

        if (RCRYPT_FAILED(CryptReleaseContext(hMe, 0)))
	{
	    printf("FAIL Error = %x\n", GetLastError());
            return(TRUE);
	}
	else
            if (cArg > 1)
                printf("SUCCEED\n");

        if (cArg > 1)
            printf("CryptAcquireContext Delete	");

        strcpy(pszMyName, "stress");
        if (RCRYPT_FAILED(CryptAcquireContext(&hMe, pszMyName,
                          MS_DEF_PROV, PROV_RSA_FULL, CRYPT_DELETEKEYSET)))
        {
	    if (cArg > 1)
                printf("FAIL Error = %x\n", GetLastError());
            return(FALSE);
	}
	else
	{
	    if (cArg > 1)
            {
               printf("SUCCEED\n");
               printf("\n");
            }
        }

    }

    exit(0);

}


BOOL TestExchange(int cArg, CHAR *bbuf, DWORD bsize)
{
	BYTE		ExpBuf[EXPORT_BUFFER_LEN];
	BYTE		SigBuf[UTILITY_BUF_SIZE];
	DWORD		ExpBufLen, SigBufLen;
	HCRYPTKEY	hKey2;
	HCRYPTHASH	hHash;
	PUBLICKEYSTRUC	*pPubKey;
	RSAPUBKEY	*pRSAKey;
	
//
// Generate a RC4 key
//
	
    if (RCRYPT_FAILED(CryptGenKey(hMe, CALG_RC4, CRYPT_EXPORTABLE, &hKey)))
    {
	if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else
	    printf("CryptGenKey FAIL\n");
	return(TRUE);
    }

//
// Look for our own exchange key
//

    if (RCRYPT_FAILED(CryptGetUserKey(hMe, AT_KEYEXCHANGE, &hKey2)))
    {
	    if (cArg > 1)
		    printf("cguk failed = %x", GetLastError());
	    else
		    printf("CryptGetUserKey FAIL\n");
	    return (TRUE);
    }

//
// Export it in PUBLICKEYBLOB form
//
    if (cArg > 1)
	    printf("CryptExportKey (PKB)		");

    ExpBufLen = EXPORT_BUFFER_LEN;
    if (RCRYPT_FAILED(CryptExportKey(hKey2, 0, PUBLICKEYBLOB, 0,
				     ExpBuf, &ExpBufLen)))
    {
	    if (cArg > 1)
		    printf("failed = %x", GetLastError());
	    else
		    printf("CryptExportKey FAIL\n");
	    return (TRUE);
    }

    
    if (cArg > 1)
	    printf("SUCCEED\n");

    CryptDestroyKey(hKey2);

    pPubKey = (PUBLICKEYSTRUC *)ExpBuf;
    pRSAKey = (RSAPUBKEY *)(ExpBuf + sizeof(PUBLICKEYSTRUC));

    if (pPubKey->aiKeyAlg != CALG_RSA_KEYX)
    {
	    printf("Pub key fails check\n");
	    return(TRUE);
    }
    
    if (pRSAKey->pubexp != 0x10001)
    {
	    printf("RSA key fails check\n");
	    return(TRUE);
    }
    
//
// Import it in PUBLICKEYBLOB form
//
    
    if (cArg > 1)
	    printf("CryptImportKey (PKB)		");

    if (RCRYPT_FAILED(CryptImportKey(hMe, ExpBuf, ExpBufLen, 0, 0, &hKey2)))
    {
	    if (cArg > 1)
		    printf("failed = %x", GetLastError());
	    else
		    printf("CryptImportKey FAIL\n");
	    return (TRUE);
    }

    if (cArg > 1)
	    printf("SUCCEED\n");

//
// Encrypt and Decrypt
//
    BLen = bsize;
    BLen2 = bsize + 8;
    if (TEncrypt(hKey, 0, TRUE, 0, bbuf, &BLen, BLen2, cArg, "RC4", ""))
    {
        return(TRUE);
    }

//
// Export the key in SIMPLEBLOB form
//
    
    if (cArg > 1)
	    printf("CryptExportKey			");

    ExpBufLen = EXPORT_BUFFER_LEN;
    
    if (RCRYPT_FAILED(CryptExportKey(hKey, hKey2, SIMPLEBLOB, 0,
				     ExpBuf, &ExpBufLen)))
    {
	    if (cArg > 1)
		    printf("failed = %x", GetLastError());
	    else
		    printf("CryptExportKey FAIL\n");
	    return (TRUE);
    }    

    if (cArg > 1)
	    printf("SUCCEED\n");

//
// Nuke the old key
//
    
    if (RCRYPT_FAILED(CryptDestroyKey(hKey)))
    {
        if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else 
	    printf("CryptDestroyKey FAIL\n");
        return(TRUE);
    }

    if (RCRYPT_FAILED(CryptDestroyKey(hKey2)))
    {
        if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else 
	    printf("CryptDestroyKey FAIL\n");
        return(TRUE);
    }

//
// Sign the blob with the key exchange key
//

    if (cArg > 1)
	    printf("CryptCreateHash			");
    
    if (RCRYPT_FAILED(CryptCreateHash(hMe, CALG_SHA, 0, 0, &hHash)))
    {
	    if (cArg > 1)
		    printf("failed = %x", GetLastError());
	    else
		    printf("CryptCreateHash FAIL\n");
	    return (TRUE);
    }

    if (cArg > 1)
	    printf("SUCCEED\n");

    if (cArg > 1)
	    printf("CryptHashData			");
    
    if (RCRYPT_FAILED(CryptHashData(hHash, ExpBuf, ExpBufLen, 0)))
    {
	    if (cArg > 1)
		    printf("failed = %x", GetLastError());
	    else
		    printf("CryptHashData FAIL\n");
	    return (TRUE);
    }    

    if (cArg > 1)
	    printf("SUCCEED\n");

    if (cArg > 1)
	    printf("CryptSignHash (KEYX)		");

    SigBufLen = UTILITY_BUF_SIZE;
    if (RCRYPT_FAILED(CryptSignHash(hHash, AT_KEYEXCHANGE, NULL, 0,
				    SigBuf, &SigBufLen)))
    {
	    if (cArg > 1)
		    printf("failed = %x", GetLastError());
	    else
		    printf("CryptSignHash FAIL\n");
	    return (TRUE);
    }

    if (cArg > 1)
	    printf("SUCCEED\n");


    if (RCRYPT_FAILED(CryptDestroyHash(hHash)))
    {
        if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else 
	    printf("CryptDestroyHash FAIL\n");
        return(TRUE);
    }

    if (cArg > 1)
	    printf("CryptCreateHash			");
    
    if (RCRYPT_FAILED(CryptCreateHash(hMe, CALG_SHA, 0, 0, &hHash)))
    {
	    if (cArg > 1)
		    printf("failed = %x", GetLastError());
	    else
		    printf("CryptCreateHash FAIL\n");
	    return (TRUE);
    }

    if (cArg > 1)
	    printf("SUCCEED\n");

    if (cArg > 1)
	    printf("CryptHashData			");
    
    if (RCRYPT_FAILED(CryptHashData(hHash, ExpBuf, ExpBufLen, 0)))
    {
	    if (cArg > 1)
		    printf("failed = %x", GetLastError());
	    else
		    printf("CryptHashData FAIL\n");
	    return (TRUE);
    }    

    if (cArg > 1)
	    printf("SUCCEED\n");

    if (RCRYPT_FAILED(CryptGetUserKey(hMe, AT_KEYEXCHANGE, &hKey2)))
    {
	    if (cArg > 1)
		    printf("cguk failed = %x", GetLastError());
	    else
		    printf("CryptGetUserKey FAIL\n");
	    return (TRUE);
    }

    if (cArg > 1)
	    printf("CryptVerifySignature (KEYX)	");
    
    if (RCRYPT_FAILED(CryptVerifySignature(hHash, SigBuf, SigBufLen, hKey2,
					   0, 0)))
    {
	    if (cArg > 1)
		    printf("failed = %x", GetLastError());
	    else
		    printf("CryptVerifySignature FAIL\n");
	    return (TRUE);
    }    

    if (cArg > 1)
	    printf("SUCCEED\n");

    if (RCRYPT_FAILED(CryptDestroyKey(hKey2)))
    {
        if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else 
	    printf("CryptDestroyKey FAIL\n");
        return(TRUE);
    }

    if (RCRYPT_FAILED(CryptDestroyHash(hHash)))
    {
        if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else 
	    printf("CryptDestroyHash FAIL\n");
        return(TRUE);
    }

    if (RCRYPT_FAILED(CryptGetUserKey(hMe, AT_KEYEXCHANGE, &hKey2)))
    {
	    if (cArg > 1)
		    printf("cguk failed = %x", GetLastError());
	    else
		    printf("CryptGetUserKey FAIL\n");
	    return (TRUE);
    }

    if (cArg > 1)
	    printf("CryptImportKey			");
    
    if (RCRYPT_FAILED(CryptImportKey(hMe, ExpBuf, ExpBufLen, 0, 0,
				     &hKey)))
    {
	    if (cArg > 1)
		    printf("failed = %x", GetLastError());
	    else
		    printf("CryptImportKey FAIL\n");
	    return (TRUE);
    }    

    if (cArg > 1)
	    printf("SUCCEED\n");

    if (RCRYPT_FAILED(CryptDestroyKey(hKey2)))
    {
        if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else 
	    printf("CryptDestroyKey FAIL\n");
        return(TRUE);
    }

    if (TDecrypt(hKey, 0, TRUE, 0, bbuf, &BLen, cArg, "RC4", ""))
    {
        return(TRUE);
    }

    if (cArg > 1)
        printf("Compare data			");
    if (memcmp(bbuf, bRanbuf, bsize) != 0)
    {
	printf("FAIL\n");
	return(TRUE);
    }
    if (cArg > 1)
	printf("SUCCEED\n");

    if (RCRYPT_FAILED(CryptDestroyKey(hKey)))
    {
        if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else 
	    printf("CryptDestroyKey FAIL\n");
        return(TRUE);
    }

    return(FALSE);

}

BOOL TestRC2(int cArg, CHAR *bbuf, DWORD bsize)
{

//
// Generate a RC2 key
//
    if (RCRYPT_FAILED(CryptGenKey(hMe, CALG_RC2, 0, &hKey)))
    {
	if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else
	    printf("CryptGenKey FAIL\n");
	return(TRUE);
    }

//
// Encrypt and Decrypt using CBC default mode
//
    BLen = bsize;
    BLen2 = bsize + 8;
    if (TEncrypt(hKey, 0, TRUE, 0, bbuf, &BLen, BLen2, cArg, "RC2", "CBC"))
    {
        return(TRUE);
    }

    if (TDecrypt(hKey, 0, TRUE, 0, bbuf, &BLen, cArg, "RC2", "CBC"))
    {
        return(TRUE);
    }

    if (cArg > 1)
        printf("Compare data			");
    if (memcmp(bbuf, bRanbuf, bsize) != 0)
    {
	printf("FAIL\n");
	return(TRUE);
    }
    if (cArg > 1)
	printf("SUCCEED\n");

//
// Change mode to ECB
//
    *pData = CRYPT_MODE_ECB;

    if (RCRYPT_FAILED(CryptSetKeyParam(hKey, KP_MODE, pData, 0)))
    {
        if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else
	    printf("CryptSetKeyParam FAIL\n");
        return(TRUE);
    }

    BLen = bsize;
    BLen2 = bsize + 8;
    if (TEncrypt(hKey, 0, TRUE, 0, bbuf, &BLen, BLen2, cArg, "RC2", "ECB"))
    {
        return(TRUE);
    }

    if (TDecrypt(hKey, 0, TRUE, 0, bbuf, &BLen, cArg, "RC2", "ECB"))
    {
        return(TRUE);
    }

    if (cArg > 1)
        printf("Compare data			");
    if (memcmp(bbuf, bRanbuf, bsize) != 0)
    {
	printf("FAIL\n");
	return(TRUE);
    }
    if (cArg > 1)
	printf("SUCCEED\n");

//
// Change mode to CFB
//
    *pData = CRYPT_MODE_CFB;

    if (RCRYPT_FAILED(CryptSetKeyParam(hKey, KP_MODE, pData, 0)))
    {
        if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else
	    printf("CryptSetKeyParam FAIL\n");
        return(TRUE);
    }

    BLen = bsize;
    BLen2 = bsize + 8;
    if (TEncrypt(hKey, 0, TRUE, 0, bbuf, &BLen, BLen2, cArg, "RC2", "CFB"))
    {
        return(TRUE);
    }

    if (TDecrypt(hKey, 0, TRUE, 0, bbuf, &BLen, cArg, "RC2", "CFB"))
    {
        return(TRUE);
    }

    if (cArg > 1)
        printf("Compare data			");
    if (memcmp(bbuf, bRanbuf, bsize) != 0)
    {
	printf("FAIL\n");
	return(TRUE);
    }
    if (cArg > 1)
	printf("SUCCEED\n");

    if (RCRYPT_FAILED(CryptDestroyKey(hKey)))
    {
        if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else 
	    printf("CryptDestroyKey FAIL\n");
        return(TRUE);
    }

    return(FALSE);

}


BOOL TestRC4(int cArg, CHAR *bbuf, DWORD bsize)
{

//
// Generate a RC4 key
//
	
    if (RCRYPT_FAILED(CryptGenKey(hMe, CALG_RC4, 0, &hKey)))
    {
	if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else
	    printf("CryptGenKey FAIL\n");
	return(TRUE);
    }

//
// Encrypt and Decrypt
//
    BLen = bsize;
    BLen2 = bsize + 8;
    if (TEncrypt(hKey, 0, TRUE, 0, bbuf, &BLen, BLen2, cArg, "RC4", ""))
    {
        return(TRUE);
    }

    if (TDecrypt(hKey, 0, TRUE, 0, bbuf, &BLen, cArg, "RC4", ""))
    {
        return(TRUE);
    }

    if (cArg > 1)
        printf("Compare data			");
    if (memcmp(bbuf, bRanbuf, bsize) != 0)
    {
	printf("FAIL\n");
	return(TRUE);
    }
    if (cArg > 1)
	printf("SUCCEED\n");

    if (RCRYPT_FAILED(CryptDestroyKey(hKey)))
    {
        if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else 
	    printf("CryptDestroyKey FAIL\n");
        return(TRUE);
    }

    return(FALSE);

}

#ifdef TEST_VERSION
BOOL TestDES(int cArg, CHAR *bbuf, DWORD bsize)
{

//
// Generate a DES key
//
    if (RCRYPT_FAILED(CryptGenKey(hMe, CALG_DES, 0, &hKey)))
    {
	if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else
	    printf("CryptGenKey FAIL\n");
	return(TRUE);
    }

//
// Encrypt and Decrypt using CBC default mode
//
    BLen = bsize;
    BLen2 = bsize + 8;
    if (TEncrypt(hKey, 0, TRUE, 0, bbuf, &BLen, BLen2, cArg, "DES", "CBC"))
    {
        return(TRUE);
    }

    if (TDecrypt(hKey, 0, TRUE, 0, bbuf, &BLen, cArg, "DES", "CBC"))
    {
        return(TRUE);
    }

    if (cArg > 1)
        printf("Compare data			");
    if (memcmp(bbuf, bRanbuf, bsize) != 0)
    {
	printf("FAIL\n");
	return(TRUE);
    }
    if (cArg > 1)
	printf("SUCCEED\n");

//
// Change mode to ECB
//
    *pData = CRYPT_MODE_ECB;

    if (RCRYPT_FAILED(CryptSetKeyParam(hKey, KP_MODE, pData, 0)))
    {
        if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else
	    printf("CryptSetKeyParam FAIL\n");
        return(TRUE);
    }

    BLen = bsize;
    BLen2 = bsize + 8;
    if (TEncrypt(hKey, 0, TRUE, 0, bbuf, &BLen, BLen2, cArg, "DES", "ECB"))
    {
        return(TRUE);
    }

    if (TDecrypt(hKey, 0, TRUE, 0, bbuf, &BLen, cArg, "DES", "ECB"))
    {
        return(TRUE);
    }

    if (cArg > 1)
        printf("Compare data			");
    if (memcmp(bbuf, bRanbuf, bsize) != 0)
    {
	printf("FAIL\n");
	return(TRUE);
    }
    if (cArg > 1)
	printf("SUCCEED\n");

//
// Change mode to CFB
//
    *pData = CRYPT_MODE_CFB;

    if (RCRYPT_FAILED(CryptSetKeyParam(hKey, KP_MODE, pData, 0)))
    {
        if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else
	    printf("CryptSetKeyParam FAIL\n");
        return(TRUE);
    }

    BLen = bsize;
    BLen2 = bsize + 8;
    if (TEncrypt(hKey, 0, TRUE, 0, bbuf, &BLen, BLen2, cArg, "DES", "CFB"))
    {
        return(TRUE);
    }

    if (TDecrypt(hKey, 0, TRUE, 0, bbuf, &BLen, cArg, "DES", "CFB"))
    {
        return(TRUE);
    }

    if (cArg > 1)
        printf("Compare data			");
    if (memcmp(bbuf, bRanbuf, bsize) != 0)
    {
	printf("FAIL\n");
	return(TRUE);
    }
    if (cArg > 1)
	printf("SUCCEED\n");

    if (RCRYPT_FAILED(CryptDestroyKey(hKey)))
    {
        if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else 
	    printf("CryptDestroyKey FAIL\n");
        return(TRUE);
    }

    return(FALSE);

}
#endif


BOOL TestHash(int cArg, CHAR *bbuf, DWORD bsize)
{

    if (cArg > 1)
        printf("Hash, compare with MD4 & MD5	");

    BHashLen1 = 50;
    BHashSignLen1 = MAXKEYLEN;
    if (Hash(cArg, bbuf, bsize, pHashData1, &BHashLen1, pHashSignData1,
             &BHashSignLen1, CALG_MD4))
    {
        return(TRUE);
    }

    if (memcmp(bbuf, bRanbuf, bsize) != 0)
    {
	printf("Data corrupted check 1 in Hash test\n");
	return(TRUE);
    }

    BHashLen2 = 50;
    BHashSignLen2 = MAXKEYLEN;
    if (Hash(cArg, bbuf, bsize, pHashData2, &BHashLen2, pHashSignData2,
             &BHashSignLen2, CALG_MD4))
    {
        return(TRUE);
    }

    if (memcmp(bbuf, bRanbuf, bsize) != 0)
    {
	printf("Data corrupted check 2 in Hash test\n");
	return(TRUE);
    }

    if (BHashLen1 != BHashLen2)
    {
	printf("Hash lengths don't match MD4 FAIL\n");
	return(TRUE);
    }

    if (memcmp(pHashData1, pHashData2, BHashLen1) != 0)
    {
	printf("Hash data doesn't compare MD4 FAIL\n");
	return(TRUE);
    }

    if (BHashSignLen1 != BHashSignLen2)
    {
	printf("Hash signatures lengths don't match MD4 FAIL\n");
	return(TRUE);
    }

    if (memcmp(pHashSignData1, pHashSignData2, BHashLen1) != 0)
    {
	printf("Hash signature data doesn't compare MD4 FAIL\n");
	return(TRUE);
    }

    BHashLen1 = 50;
    BHashSignLen1 = MAXKEYLEN;
    if (Hash(cArg, bbuf, bsize, pHashData1, &BHashLen1, pHashSignData1,
             &BHashSignLen1, CALG_MD5))
    {
        return(TRUE);
    }

    if (memcmp(bbuf, bRanbuf, bsize) != 0)
    {
	printf("Data corrupted check 3 in Hash test\n");
	return(TRUE);
    }

    BHashLen2 = 50;
    BHashSignLen2 = MAXKEYLEN;
    if (Hash(cArg, bbuf, bsize, pHashData2, &BHashLen2, pHashSignData2,
             &BHashSignLen2, CALG_MD5))
    {
        return(TRUE);
    }

    if (memcmp(bbuf, bRanbuf, bsize) != 0)
    {
	printf("Data corrupted check 4 in Hash test\n");
	return(TRUE);
    }

    if (BHashLen1 != BHashLen2)
    {
	printf("Hash lengths don't match MD5 FAIL\n");
	return(TRUE);
    }

    if (memcmp(pHashData1, pHashData2, BHashLen1) != 0)
    {
	printf("Hash data doesn't compare MD5 FAIL\n");
	return(TRUE);
    }

    if (BHashSignLen1 != BHashSignLen2)
    {
	printf("Hash signatures lengths don't match MD5 FAIL\n");
	return(TRUE);
    }

    if (memcmp(pHashSignData1, pHashSignData2, BHashSignLen1) != 0)
    {
	printf("Hash signature data doesn't compare MD5 FAIL\n");
	return(TRUE);
    }

    if (cArg > 1)
	printf("SUCCEED\n");

    return(FALSE);
    
}


BOOL Hash(int cArg, CHAR *bbuf, DWORD bsize, BYTE *pHashOut,
          DWORD *pHashLenOut, BYTE *pSigData, DWORD *pdwSigLen, DWORD Algid)
{

    if (RCRYPT_FAILED(CryptCreateHash(hMe, Algid, 0, 0, &hHash)))
    {
        if (cArg > 1)
	    printf("CryptCreateHash failed = %x\n", GetLastError());
	else 
	    printf("CryptCreateHash FAIL\n");
        return(TRUE);
    }

    if (RCRYPT_FAILED(CryptHashData(hHash, bbuf, bsize, 0)))
    {
        if (cArg > 1)
	    printf("CryptUpDataHash failed = %x\n", GetLastError());
	else 
	    printf("CryptHashData FAIL\n");
        return(TRUE);
    }

    if (RCRYPT_FAILED(CryptSignHash(hHash, AT_SIGNATURE, 0, 0, pSigData,
	              pdwSigLen)))
    {
        if (cArg > 1)
	    printf("CryptSignHash failed = %x\n", GetLastError());
	else 
	    printf("CryptSignHash FAIL\n");
        return(TRUE);
    }

    if (RCRYPT_FAILED(CryptDestroyHash(hHash)))
    {
        if (cArg > 1)
	    printf("CryptDestroyHash failed = %x\n", GetLastError());
	else 
	    printf("CryptDestroyHash FAIL\n");
        return(TRUE);
    }

    if (RCRYPT_FAILED(CryptCreateHash(hMe, Algid, 0, 0, &hHash)))
    {
        if (cArg > 1)
	    printf("CryptCreateHash failed = %x\n", GetLastError());
	else 
	    printf("CryptCreateHash FAIL\n");
        return(TRUE);
    }

    if (RCRYPT_FAILED(CryptHashData(hHash, bbuf, bsize, 0)))
    {
        if (cArg > 1)
	    printf("CryptUpDataHash failed = %x\n", GetLastError());
	else 
	    printf("CryptHashData FAIL\n");
        return(TRUE);
    }

    if (RCRYPT_FAILED(CryptGetUserKey(hMe, AT_SIGNATURE, &hKey2)))
    {
	    if (cArg > 1)
		    printf("cguk failed = %x", GetLastError());
	    else
		    printf("CryptGetUserKey FAIL\n");
	    return (TRUE);
    }

    if (RCRYPT_FAILED(CryptVerifySignature(hHash, pSigData, *pdwSigLen,
                                           hKey2, 0, 0)))
    {
        if (cArg > 1)
	    printf("CryptVerifySignature failed = %x\n", GetLastError());
	else 
	    printf("CryptVerifySignature FAIL\n");
        return(TRUE);
    }



    if (RCRYPT_FAILED(CryptDestroyKey(hKey2)))
    {
        if (cArg > 1)
	    printf("CryptDestroyKey failed = %x\n", GetLastError());
	else 
	    printf("CryptDestroyKey FAIL\n");
        return(TRUE);
    }

    if (RCRYPT_FAILED(CryptDestroyHash(hHash)))
    {
        if (cArg > 1)
	    printf("CryptDestroyHash failed = %x\n", GetLastError());
	else 
	    printf("CryptDestroyHash FAIL\n");
        return(TRUE);
    }

    if (RCRYPT_FAILED(CryptCreateHash(hMe, Algid, 0, 0, &hHash)))
    {
        if (cArg > 1)
	    printf("CryptCreateHash failed = %x\n", GetLastError());
	else 
	    printf("CryptCreateHash FAIL\n");
        return(TRUE);
    }

    if (RCRYPT_FAILED(CryptHashData(hHash, bbuf, bsize, 0)))
    {
        if (cArg > 1)
	    printf("CryptUpDataHash failed = %x\n", GetLastError());
	else 
	    printf("CryptHashData FAIL\n");
        return(TRUE);
    }

    if (RCRYPT_FAILED(CryptGetHashParam(hHash, HP_HASHVAL, pHashOut,
	              pHashLenOut, 0)))
    {
        if (cArg > 1)
	    printf("CryptGetHashParam failed = %x\n", GetLastError());
	else 
	    printf("CryptGetHashParam FAIL\n");
        return(TRUE);
    }

    if (RCRYPT_FAILED(CryptDestroyHash(hHash)))
    {
        if (cArg > 1)
	    printf("CryptDestroyHash failed = %x\n", GetLastError());
	else 
	    printf("CryptDestroyHash FAIL\n");
        return(TRUE);
    }

    return(FALSE);

}


BOOL Logon(int cArg)
{

	strcpy(pszMyName, "stress");

        if (cArg > 1)
            printf("CryptAcquireContext		");

        if (RCRYPT_FAILED(CryptAcquireContext(&hMe, pszMyName,
                          MS_DEF_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET)))
        {
	    if (cArg > 1)
                printf("FAIL Error = %x\n", GetLastError());
            return(TRUE);
	}
	else
	{
	if (cArg > 1)
           printf("SUCCEED\n");
        }

        if (cArg > 1)
            printf("CryptGenKeys			");

        if (RCRYPT_FAILED(CryptGenKey(hMe, CALG_RSA_SIGN,
                                          CRYPT_EXPORTABLE, &hClientKey)))
        {
	    if (cArg > 1)
                printf("FAIL Error = %x\n", GetLastError());
	    return(TRUE);
	}

        CryptDestroyKey(hClientKey);

        if (RCRYPT_FAILED(CryptGenKey(hMe, CALG_RSA_KEYX,
                                          CRYPT_EXPORTABLE, &hClientKey)))
        {
	    if (cArg > 1)
                printf("FAIL Error = %x\n", GetLastError());
	    return(TRUE);
	}
	if (cArg > 1)
            printf("SUCCEED\n");

        CryptDestroyKey(hClientKey);

	return(FALSE);

}



BOOL TEncrypt(HCRYPTKEY hTKey, HCRYPTHASH hTHash, BOOL FinalFlag,
              DWORD dwFlags, BYTE *Tbuf, DWORD *pBLen, DWORD pdwBufLen,
              int cArg, CHAR *szAlgid, CHAR *szmode)
{
        if (cArg > 1)
            printf("CryptEncrypt %s-%s		", szAlgid, szmode);
	if (RCRYPT_FAILED(CryptEncrypt(hTKey, hTHash, FinalFlag, dwFlags,
                                       Tbuf, pBLen, pdwBufLen)))
	{
            if (cArg > 1)
	        printf("failed = %x\n", GetLastError());
	    else 
	        printf("CryptEncrypt FAIL\n");
            return(TRUE);
	}
        if (cArg > 1)
	    printf("SUCCEED\n");

        return(FALSE);

}


BOOL TDecrypt(HCRYPTKEY hTKey, HCRYPTHASH hTHash, BOOL FinalFlag,
              DWORD dwFlags, BYTE *Tbuf, DWORD *pBLen, int cArg,
              CHAR *szAlgid, CHAR *szmode)
{

        if (cArg > 1)
            printf("CryptDecrypt %s-%s		", szAlgid, szmode);
	if (RCRYPT_FAILED(CryptDecrypt(hTKey, hTHash, FinalFlag, dwFlags,
                                       Tbuf, pBLen)))
	{
            if (cArg > 1)
	        printf("failed = %x\n", GetLastError());
	    else 
	        printf("CryptDecrypt FAIL\n");
            return(TRUE);
	}
        if (cArg > 1)
	    printf("SUCCEED\n");

        return(FALSE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\randlib\cpu.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    cpu.c

Abstract:

    Read CPU specifics performance counters.

Author:

    Scott Field (sfield)    24-Sep-98

--*/

#ifndef KMODE_RNG

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#else

#include <ntifs.h>
#include <windef.h>

#endif  // KMODE_RNG

#include "cpu.h"


unsigned int
GatherCPUSpecificCountersPrivileged(
    IN      unsigned char *pbCounterState,
    IN  OUT unsigned long *pcbCounterState
    );


#define X86_CAPS_RDTSC  0x01
#define X86_CAPS_RDMSR  0x02
#define X86_CAPS_RDPMC  0x04

VOID
X86_GetCapabilities(
    IN  OUT BYTE *pbCapabilities
    );

VOID
X86_ReadRDTSC(
    IN      PLARGE_INTEGER prdtsc   // RDTSC
    );

VOID
X86_ReadRDMSR(
    IN      PLARGE_INTEGER pc0,     // counter0
    IN      PLARGE_INTEGER pc1      // counter1
    );

VOID
X86_ReadRDPMC(
    IN      PLARGE_INTEGER pc0,     // counter0
    IN      PLARGE_INTEGER pc1      // counter1
    );


#ifdef KMODE_RNG

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, GatherCPUSpecificCounters)
#pragma alloc_text(PAGE, GatherCPUSpecificCountersPrivileged)

#ifdef _X86_
#pragma alloc_text(PAGE, X86_ReadRDTSC)
#pragma alloc_text(PAGE, X86_ReadRDMSR)
#pragma alloc_text(PAGE, X86_ReadRDPMC)
#pragma alloc_text(PAGE, X86_GetCapabilities)
#endif  // _X86_

#endif  // ALLOC_PRAGMA
#endif  // KMODE_RNG




unsigned int
GatherCPUSpecificCounters(
    IN      unsigned char *pbCounterState,
    IN  OUT unsigned long *pcbCounterState
    )
{

#ifndef KMODE_RNG

    //
    // NT5 doesn't set CR4.PCE by default, so don't bother trying for usermode.
    //

    return FALSE;

#else

    PAGED_CODE();

    //
    // kernel mode version of library: just call the privileged routine directly.
    // user mode version of library: try privileged routine first, if it fails, use
    // device driver provided interface.
    //

    if( pbCounterState == NULL || pcbCounterState == NULL )
        return FALSE;

    return GatherCPUSpecificCountersPrivileged( pbCounterState, pcbCounterState );

#endif

}

unsigned int
GatherCPUSpecificCountersPrivileged(
    IN      unsigned char *pbCounterState,
    IN  OUT unsigned long *pcbCounterState
    )
/*++

    we are at ring0 in kernel mode, so we can issue the privileges CPU
    instructions directly.  Note that this routine also serves as the
    core code which is executed by the ksecdd.sys device driver for user
    mode clients.
    This call can also be made directly in usermode by certain CPUs,
    or when certain CPUs are configured to allow such calls from ring3.

--*/
{

#ifdef _X86_
    PLARGE_INTEGER prdtsc;
    PLARGE_INTEGER pc0;
    PLARGE_INTEGER pc1;

    DWORD cbCounters;
    BYTE ProcessorCaps;
#endif  // _X86_


#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG

#ifdef _X86_



    cbCounters = 3 * sizeof( LARGE_INTEGER ) ;

    if( *pcbCounterState < cbCounters ) {
        *pcbCounterState = cbCounters;
        return FALSE;
    }

    cbCounters = 0;


    prdtsc = (PLARGE_INTEGER)pbCounterState;
    pc0 = prdtsc + 1;
    pc1 = pc0 + 1;


    //
    // make the initial determination about what the countertype is in this
    // system.
    // in theory, this could be cached, but things get a little complicated
    // in an SMP machine -- we'd have to track caps across all processors
    // to be correct.  Since we don't really care about perf, just check the
    // caps every time.
    //

    __try {
        X86_GetCapabilities( &ProcessorCaps );
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        ProcessorCaps = 0;
        ; // swallow exception
    }

    //
    // wrap the query in a try/except.  This is just paranoia.  Since we aren't
    // particularly interested in the values of the perf counters for the normal
    // (eg: perfmon) reasons, introducing the extra overhead of try/except is
    // of no relevance to us.
    // note that in the case of the p6, we could be calling this from usermode,
    // and CR4.PCE could be toggled which could cause subsequent AV(s).
    // In theory, the KMODE build could avoid the try/except, but there is a
    // remote possiblity the code above which makes the initial countertype
    // determination may not be supported on every installed processor in a
    // SMP machine.  The cost of try/except is well worth avoiding the possibility
    // of a access violation / bluescreen in usermode vs. kernel mode respectively.
    //

    if( ProcessorCaps & X86_CAPS_RDTSC ) {
        __try {
            X86_ReadRDTSC( prdtsc );
            cbCounters += sizeof( LARGE_INTEGER );
        } __except( EXCEPTION_EXECUTE_HANDLER ) {
            ; // swallow exception.
        }
    }

    if( ProcessorCaps & X86_CAPS_RDPMC ) {
        __try {
            X86_ReadRDPMC( pc0, pc1 );
            cbCounters += (2*sizeof( LARGE_INTEGER ));
        } __except( EXCEPTION_EXECUTE_HANDLER ) {
            ; // swallow exception.
        }
    }
#ifdef KMODE_RNG
    else if ( ProcessorCaps & X86_CAPS_RDMSR ) {
        __try {
            X86_ReadRDMSR( pc0, pc1 );
            cbCounters += (2*sizeof( LARGE_INTEGER ));
        } __except( EXCEPTION_EXECUTE_HANDLER ) {
            ; // swallow exception.
        }
    }
#endif  // KMODE_RNG

    *pcbCounterState = cbCounters;
    return TRUE;

#else   // _X86_


    //
    // no non-x86 counter handling code at this time.
    //

    return FALSE;

#endif

}

#ifdef _X86_

VOID
X86_ReadRDTSC(
    IN      PLARGE_INTEGER prdtsc   // RDTSC
    )
{
    DWORD prdtscLow ;
    DWORD prdtscHigh ;

#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG

    __asm {
        push    eax
        push    ecx
        push    edx

        // RDTSC

        _emit   0fh
        _emit   31h
        mov     prdtscLow, eax
        mov     prdtscHigh, edx

        pop     edx
        pop     ecx
        pop     eax
    }

    prdtsc->LowPart = prdtscLow;
    prdtsc->HighPart = prdtscHigh;

}

VOID
X86_ReadRDMSR(
    IN      PLARGE_INTEGER pc0,     // counter0
    IN      PLARGE_INTEGER pc1      // counter1
    )
{
    DWORD pc0Low ;
    DWORD pc0High ;
    DWORD pc1Low ;
    DWORD pc1High ;

#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG

    __asm {
        push    eax
        push    ecx
        push    edx

        // RDMSR counter0

        mov     ecx, 12h
        _emit   0fh
        _emit   32h
        mov     pc0Low, eax
        mov     pc0High, edx

        // RDMSR counter1

        mov     ecx, 13h
        _emit   0fh
        _emit   32h
        mov     pc1Low, eax
        mov     pc1High, edx

        pop     edx
        pop     ecx
        pop     eax
    }

    pc0->LowPart = pc0Low;
    pc0->HighPart = pc0High;
    pc1->LowPart = pc1Low;
    pc1->HighPart = pc1High;

}

VOID
X86_ReadRDPMC(
    IN      PLARGE_INTEGER pc0,     // counter0
    IN      PLARGE_INTEGER pc1      // counter1
    )
{
    DWORD pc0Low ;
    DWORD pc0High ;
    DWORD pc1Low ;
    DWORD pc1High ;

#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG

    __asm {
        push    eax
        push    ecx
        push    edx

        // RDPMC executes from ring3 if CR4.PCE is set, otherwise, runs from ring0 only.

        // RDPMC counter0

        xor     ecx, ecx
        _emit   0fh
        _emit   33h
        mov     pc0Low, eax
        mov     pc0High, edx

        // RDPMC counter1

        mov     ecx, 1
        _emit   0fh
        _emit   33h
        mov     pc1Low, eax
        mov     pc1High, edx

        pop     edx
        pop     ecx
        pop     eax
    }

    pc0->LowPart = pc0Low;
    pc0->HighPart = pc0High;
    pc1->LowPart = pc1Low;
    pc1->HighPart = pc1High;

}

#if _MSC_FULL_VER >= 13008827 && defined(_M_IX86)
#pragma warning(push)
#pragma warning(disable:4731)			// EBP modified with inline asm
#endif

VOID
X86_GetCapabilities(
    IN  OUT BYTE *pbCapabilities
    )
{
    DWORD dwLevels;
    DWORD dwStdFeatures;
    DWORD dwVersionInfo;
    DWORD Family;
    DWORD Model;

#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG

    *pbCapabilities = 0;

    __asm {

        push    eax
        push    ecx
        push    ebx
        push    edx
        push    edi
        push    esi
        push    ebp
        xor     eax, eax
        _emit   0x0f
        _emit   0xa2
        mov     dwLevels, eax
        pop     ebp
        pop     esi
        pop     edi
        pop     edx
        pop     ebx
        pop     ecx
        pop     eax
    }

    if( dwLevels == 0 )
        return;


    //
    // try CPUID at level1 to get standard features.
    //

    __asm {

        push    eax
        push    ecx
        push    ebx
        push    edx
        push    edi
        push    esi
        push    ebp
        mov     eax, 1
        _emit   0x0f
        _emit   0xa2
        mov     dwVersionInfo, eax
        mov     dwStdFeatures, edx
        pop     ebp
        pop     esi
        pop     edi
        pop     edx
        pop     ebx
        pop     ecx
        pop     eax
    }


    //
    // determine if RDTSC supported.
    //

    if( dwStdFeatures & 0x10 ) {
        *pbCapabilities |= X86_CAPS_RDTSC;
    }

    Model = (dwVersionInfo >> 4) & 0xf;
    Family = (dwVersionInfo >> 8) & 0xf;

// AMD K6-2 model 8 proved buggy and left interrupts disabled during RDMSR

#if 0

    //
    // determine if RDMSR supported.
    //

    if( dwStdFeatures & 0x20 && (Model == 1 || Model == 2) ) {
        *pbCapabilities |= X86_CAPS_RDMSR;
    }

    //
    // extract family, > pentium (family5) supports RDPMC
    //

    if( Family > 5 ) {
        *pbCapabilities |= X86_CAPS_RDPMC;
    }
#endif

}
#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif


#endif  // _X86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\randlib\circhash.c ===
// Circular hash code.
//
// This code implements a circular hash algorithm, intended as a variable
// length hash function that is fast to update. (The hash function will be
// called many times.)  This is done by SHA-1'ing each of the inputs, then
// circularly XORing this value into a buffer.

#ifndef KMODE_RNG

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#else

#include <ntifs.h>
#include <windef.h>

#endif  // KMODE_RNG

#include <sha.h>
#include <md4.h>

#include "circhash.h"


#ifdef KMODE_RNG
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, InitCircularHash)
#pragma alloc_text(PAGE, DestroyCircularHash)
#pragma alloc_text(PAGE, GetCircularHashValue)
#pragma alloc_text(PAGE, UpdateCircularHash)
#endif  // ALLOC_PRAGMA
#endif  // KMODE_RNG


//
// internal state flags
//

#define CH_INVALID_HASH_CTXT    0
#define CH_VALID_HASH_CTXT      0x1423

BOOL
InitCircularHash(
    IN      CircularHash *NewHash,
    IN      DWORD dwUpdateInc,
    IN      DWORD dwAlgId,
    IN      DWORD dwMode
    )
{

#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG

    if (NULL == NewHash)
        return FALSE;

    NewHash->dwCircHashVer = CH_VALID_HASH_CTXT;
    NewHash->dwCircSize = sizeof(NewHash->CircBuf);
    NewHash->dwMode = dwMode;
    NewHash->dwCircInc = dwUpdateInc;
    NewHash->dwCurCircPos = 0;
    NewHash->dwAlgId = dwAlgId;

    return TRUE;
}

VOID
DestroyCircularHash(
    IN      CircularHash *OldHash
    )
{
#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG

    if ((NULL == OldHash) || (CH_VALID_HASH_CTXT != OldHash->dwCircHashVer))
        return;

    RtlZeroMemory( OldHash, sizeof( *OldHash ) );
}

BOOL
GetCircularHashValue(
    IN      CircularHash *CurrentHash,
        OUT BYTE **ppbHashValue,
        OUT DWORD *pcbHashValue
        )
{
#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG

    if ((NULL == CurrentHash) || (CH_VALID_HASH_CTXT != CurrentHash->dwCircHashVer))
        return FALSE;

    *ppbHashValue = CurrentHash->CircBuf;
    *pcbHashValue = CurrentHash->dwCircSize;

    return TRUE;
}

BOOL
UpdateCircularHash(
    IN      CircularHash *CurrentHash,
    IN      VOID *pvData,
    IN      DWORD cbData
    )
{
    A_SHA_CTX   shaCtx;
    MD4_CTX     md4Ctx;
    BYTE        LocalResBuf[A_SHA_DIGEST_LEN];
    PBYTE       pHash;
    DWORD       dwHashSize;
    DWORD       i, j;

    PBYTE       pbCircularBuffer;
    DWORD       cbCircularBuffer;
    DWORD       cbCircularPosition;

#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG


    if ((NULL == CurrentHash) || (CH_VALID_HASH_CTXT != CurrentHash->dwCircHashVer))
        return FALSE;

    pbCircularBuffer = CurrentHash->CircBuf;
    cbCircularBuffer = CurrentHash->dwCircSize;
    cbCircularPosition = CurrentHash->dwCurCircPos;

    //
    // First, hash in the result
    //

    if( CurrentHash->dwAlgId == CH_ALG_MD4 ) {

        dwHashSize = MD4DIGESTLEN;

        MD4Init(&md4Ctx);
        MD4Update(&md4Ctx, (unsigned char*)pvData, cbData);

        if (CurrentHash->dwMode & CH_MODE_FEEDBACK)
        {
            MD4Update(&md4Ctx, pbCircularBuffer, cbCircularBuffer);
        }

        MD4Final(&md4Ctx);
        pHash = md4Ctx.digest;

    } else {

        dwHashSize = A_SHA_DIGEST_LEN;

        A_SHAInit(&shaCtx);
        A_SHAUpdateNS(&shaCtx, (unsigned char*)pvData, cbData);

        if (CurrentHash->dwMode & CH_MODE_FEEDBACK)
        {
            A_SHAUpdateNS(&shaCtx, pbCircularBuffer, cbCircularBuffer);
        }

        A_SHAFinalNS(&shaCtx, LocalResBuf);
        pHash = LocalResBuf;
    }

    //
    // Now, XOR this into the circular buffer
    //

    //
    // this is a slow way of doing this (byte at time, versus DWORD/DWORD64),
    // but it'll work for now...
    //    In most cases, we can assume we'll wrap once, but let's keep it general for now.
    //

    j = cbCircularPosition;

    for( i = 0 ; i < dwHashSize ; i++ )
    {
        if (j >= cbCircularBuffer)
            j = 0;

        pbCircularBuffer[j] ^= pHash[i];

        j++;
    }

    //
    // Update.  Since dwCircInc should be relatively prime to dwCircSize, this
    // should result in the pointer continually cycling through dwCircSize values.
    //

    CurrentHash->dwCurCircPos = (cbCircularPosition + CurrentHash->dwCircInc)
                                     % cbCircularBuffer;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\randlib\seed.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    seed.c

Abstract:

    Storage and retrieval of cryptographic RNG seed material.

Author:

    Scott Field (sfield)    24-Sep-98

--*/

#ifndef KMODE_RNG

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <zwapi.h>
#include <windows.h>

#else

#include <ntifs.h>
#include <windef.h>

#endif  // KMODE_RNG

#include "seed.h"
#include "umkm.h"

BOOL
AccessSeed(
    IN      ACCESS_MASK     DesiredAccess,
    IN  OUT PHKEY           phkResult
    );


BOOL
AdjustSeedSecurity(
    IN      HKEY            hKeySeed
    );

#ifdef KMODE_RNG

#define SEED_KEY_LOCATION   L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\Cryptography\\RNG"
#define SEED_VALUE_NAME     L"Seed"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ReadSeed)
#pragma alloc_text(PAGE, WriteSeed)
#pragma alloc_text(PAGE, AccessSeed)
#endif  // ALLOC_PRAGMA

#else

#define SEED_KEY_LOCATION   "SOFTWARE\\Microsoft\\Cryptography\\RNG"
#define SEED_VALUE_NAME     "Seed"

#endif  // KMODE_RNG


//
// globally cached registry handle to seed material.
// TODO: later.
//

///HKEY g_hKeySeed = NULL;



BOOL
ReadSeed(
    IN      PBYTE           pbSeed,
    IN      DWORD           cbSeed
    )
{
    HKEY hKeySeed;

#ifndef KMODE_RNG
    DWORD dwType;
    LONG lRet;
#else

    static const WCHAR wszValue[] = SEED_VALUE_NAME;
    BYTE FastBuffer[ 256 ];
    PKEY_VALUE_PARTIAL_INFORMATION pKeyInfo;
    DWORD cbKeyInfo;
    UNICODE_STRING ValueName;
    NTSTATUS Status;

    PAGED_CODE();
#endif  // KMODE_RNG


    //
    // open handle to RNG registry key.
    //

    if(!AccessSeed( KEY_QUERY_VALUE, &hKeySeed ))
        return FALSE;

#ifndef KMODE_RNG

    lRet = RegQueryValueExA(
                    hKeySeed,
                    SEED_VALUE_NAME,
                    NULL,
                    &dwType,
                    pbSeed,
                    &cbSeed
                    );

    REGCLOSEKEY( hKeySeed );

    if( lRet != ERROR_SUCCESS )
        return FALSE;

    return TRUE;

#else

    ValueName.Buffer = (LPWSTR)wszValue;
    ValueName.Length = sizeof(wszValue) - sizeof(WCHAR);
    ValueName.MaximumLength = sizeof(wszValue);


    pKeyInfo = (PKEY_VALUE_PARTIAL_INFORMATION)FastBuffer;
    cbKeyInfo = sizeof(FastBuffer);

    Status = ZwQueryValueKey(
                    hKeySeed,
                    &ValueName,
                    KeyValuePartialInformation,
                    pKeyInfo,
                    cbKeyInfo,
                    &cbKeyInfo
                    );

    REGCLOSEKEY( hKeySeed );

    if(!NT_SUCCESS(Status))
        return FALSE;

    if( pKeyInfo->DataLength > cbSeed )
        return FALSE;

    RtlCopyMemory( pbSeed, pKeyInfo->Data, pKeyInfo->DataLength );

    return TRUE;

#endif
}

BOOL
WriteSeed(
    IN      PBYTE           pbSeed,
    IN      DWORD           cbSeed
    )
{
    HKEY hKeySeed;

#ifndef KMODE_RNG
    LONG lRet;
#else
    static const WCHAR wszValue[] = SEED_VALUE_NAME;
    UNICODE_STRING ValueName;
    NTSTATUS Status;

    PAGED_CODE();
#endif  // KMODE_RNG


    //
    // open handle to RNG registry key.
    //

    if(!AccessSeed( KEY_SET_VALUE, &hKeySeed ))
        return FALSE;


#ifndef KMODE_RNG

    lRet = RegSetValueExA(
                    hKeySeed,
                    SEED_VALUE_NAME,
                    0,
                    REG_BINARY,
                    pbSeed,
                    cbSeed
                    );

    REGCLOSEKEY( hKeySeed );

    if( lRet != ERROR_SUCCESS )
        return FALSE;

    return TRUE;

#else

    ValueName.Buffer = (LPWSTR)wszValue;
    ValueName.Length = sizeof(wszValue) - sizeof(WCHAR);
    ValueName.MaximumLength = sizeof(wszValue);

    Status = ZwSetValueKey(
                    hKeySeed,
                    &ValueName,
                    0,
                    REG_BINARY,
                    pbSeed,
                    cbSeed
                    );

    REGCLOSEKEY( hKeySeed );

    if(!NT_SUCCESS(Status))
        return FALSE;

    return TRUE;

#endif

}

BOOL
AccessSeed(
    IN      ACCESS_MASK     DesiredAccess,
    IN  OUT PHKEY           phkResult
    )
{

#ifndef KMODE_RNG

    DWORD dwDisposition;
    LONG lRet;

    lRet = RegCreateKeyExA(
                HKEY_LOCAL_MACHINE,
                SEED_KEY_LOCATION,
                0,
                NULL,
                0,
                DesiredAccess,
                NULL,   // sa
                phkResult,
                &dwDisposition
                );


    if( lRet != ERROR_SUCCESS )
        return FALSE;

#if 0
    if( dwDisposition == REG_CREATED_NEW_KEY ) {

        //
        // if we just created the seed, make sure it's Acl'd appropriately.
        //

        AdjustSeedSecurity( *phkResult );
    }
#endif

    return TRUE;
#else

    NTSTATUS Status;

/// TODO at a later date: cache the registry key
///    *phkResult = g_hKeySeed;
///    if( *phkResult == NULL ) {

        UNICODE_STRING RegistryKeyName;
        static const WCHAR KeyLocation[] = SEED_KEY_LOCATION;
        ULONG Disposition;
        OBJECT_ATTRIBUTES ObjAttr;

///        HKEY hKeyPrevious;

        PAGED_CODE();

        RegistryKeyName.Buffer = (LPWSTR)KeyLocation;
        RegistryKeyName.Length = sizeof(KeyLocation) - sizeof(WCHAR);
        RegistryKeyName.MaximumLength = sizeof(KeyLocation);

        InitializeObjectAttributes(
                    &ObjAttr,
                    &RegistryKeyName,
                    OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                    0,
                    NULL
                    );

        Status = ZwCreateKey(
                    phkResult,
                    DesiredAccess,
                    &ObjAttr,
                    0,
                    NULL,
                    0,
                    &Disposition
                    );


        if(!NT_SUCCESS(Status))
            return FALSE;

///        hKeyPrevious = INTERLOCKEDCOMPAREEXCHANGEPOINTER( &g_hKeySeed, *phkResult, NULL );
///        if( hKeyPrevious ) {
///            REGCLOSEKEY( *phkResult );
///            *phkResult = hKeyPrevious;
///        }
///    }

    return TRUE;

#endif

}


#ifndef KMODE_RNG

//
// NOTE: this function should be removed if we can get the key into
// the setup hives with Acl applied appropriately.
//

#if 0

BOOL
AdjustSeedSecurity(
    IN      HKEY            hKeySeed
    )
{
    HKEY hKeySecurityAdjust = NULL;

    SID_IDENTIFIER_AUTHORITY siaWorldAuthority = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    SECURITY_DESCRIPTOR sd;
    BYTE FastBuffer[ 256 ];
    PACL pDacl;
    DWORD cbDacl;
    PSID psidAdministrators = NULL;
    PSID psidEveryone = NULL;

    LONG lRet;
    BOOL fSuccess = FALSE;

    //
    // re-open key with WRITE_DAC access and update security.
    // note: Wide version will fail on Win9x, which is fine, since
    // no security there...
    //

    lRet = RegOpenKeyExW(
                    hKeySeed,
                    NULL,
                    0,
                    WRITE_DAC,
                    &hKeySecurityAdjust
                    );


    if( lRet != ERROR_SUCCESS )
        goto cleanup;

    if(!InitializeSecurityDescriptor( &sd, SECURITY_DESCRIPTOR_REVISION ))
        goto cleanup;

    if(!AllocateAndInitializeSid(
        &siaWorldAuthority,
        1,
        SECURITY_WORLD_RID,
        0, 0, 0, 0, 0, 0, 0,
        &psidEveryone
        )) {
        goto cleanup;
    }


    if(!AllocateAndInitializeSid(
            &siaNtAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            &psidAdministrators
            )) {
        goto cleanup;
    }


    cbDacl = sizeof(ACL) +
            2 * ( sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) ) +
            GetLengthSid(psidEveryone) +
            GetLengthSid(psidAdministrators) ;


    if( cbDacl > sizeof( FastBuffer ) )
        goto cleanup;

    pDacl = (PACL)FastBuffer;


    if(!InitializeAcl( pDacl, cbDacl, ACL_REVISION ))
        goto cleanup;


    if(!AddAccessAllowedAce(
        pDacl,
        ACL_REVISION,
        KEY_QUERY_VALUE,
        psidEveryone
        )) {
        goto cleanup;
    }


    if(!AddAccessAllowedAce(
        pDacl,
        ACL_REVISION,
        KEY_ALL_ACCESS,
        psidAdministrators
        )) {
        goto cleanup;
    }

    if(!SetSecurityDescriptorDacl( &sd, TRUE, pDacl, FALSE ))
        goto cleanup;


    lRet = RegSetKeySecurity(
                    hKeySecurityAdjust,
                    DACL_SECURITY_INFORMATION,
                    &sd
                    );

    if( lRet != ERROR_SUCCESS)
        goto cleanup;


    fSuccess = TRUE;

cleanup:

    if( hKeySecurityAdjust )
        REGCLOSEKEY( hKeySecurityAdjust );

    if( psidAdministrators )
        FreeSid( psidAdministrators );

    if( psidEveryone )
        FreeSid( psidEveryone );

    return fSuccess;
}
#endif

#endif // !KMODE_RNG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\randlib\seed.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    seed.h

Abstract:

    Storage and retrieval of cryptographic RNG seed material.

Author:

    Scott Field (sfield)    24-Sep-98

--*/

#ifndef __SEED_H__
#define __SEED_H__

BOOL
ReadSeed(
    IN      PBYTE           pbSeed,
    IN      DWORD           cbSeed
    );

BOOL
WriteSeed(
    IN      PBYTE           pbSeed,
    IN      DWORD           cbSeed
    );

#endif  // __SEED_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\randlib\sources.inc ===
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES= $(DS_INC_PATH)\crypto;  \
          $(BASE_INC_PATH); \
	  $(IFSKIT_INC_PATH); \
          ..\..\inc

SOURCES= ..\randlib.c  \
         ..\vlhash.c   \
         ..\circhash.c \
         ..\cpu.c      \
         ..\seed.c     \
         ..\rc4safe.c  \
         ..\umkm.c

UMTYPE=console
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\randlib\rc4safe.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    rc4safe.c

Abstract:

    access rc4 key material in thread safe manner, without adversly affecting
    performance of multi-thread users.

Author:

    Scott Field (sfield)    02-Jul-99

--*/

#ifndef KMODE_RNG

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <zwapi.h>

#else

#include <ntosp.h>
#include <windef.h>

#endif  // KMODE_RNG


#include <rc4.h>
#include <randlib.h>

#include "umkm.h"




typedef struct {
    unsigned int    BytesUsed;  // bytes processed for key associated with this entry
    __LOCK_TYPE     lock;       // lock for serializing key entry
    RC4_KEYSTRUCT   rc4key;     // key material associated with this entry
} RC4_SAFE, *PRC4_SAFE, *LPRC4_SAFE;


typedef enum _MemoryMode {
    Paged = 1,
    NonPaged
} MemoryMode;


typedef struct {
    unsigned int    Entries;    // count of array entries.
    MemoryMode      Mode;       // allocation & behavior mode of SAFE_ARRAY
    RC4_SAFE        *Array[];   // array of pointers to RC4_SAFE entries.
} RC4_SAFE_ARRAY, *PRC4_SAFE_ARRAY, *LPRC4_SAFE_ARRAY;




//
// !!! RC4_SAFE_ENTRIES must be even multiple of 4 !!!
//

#ifndef KMODE_RNG
#define RC4_SAFE_ENTRIES    (8)
#else
//
// we don't expect as much traffic in kernel mode, so use less resources.
//
#define RC4_SAFE_ENTRIES    (4)
#endif





#ifdef KMODE_RNG

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, rc4_safe_select)
#pragma alloc_text(PAGE, rc4_safe)
#pragma alloc_text(PAGE, rc4_safe_key)
#pragma alloc_text(PAGE, rc4_safe_select)
#pragma alloc_text(PAGE, rc4_safe_startup)
#pragma alloc_text(PAGE, rc4_safe_shutdown)

#endif  // ALLOC_PRAGMA
#endif  // KMODE_RNG



void
rc4_safe_select(
    IN      void *pContext,
    OUT     unsigned int *pEntry,
    OUT     unsigned int *pBytesUsed
    )
/*++

Routine Description:

    key selector:  choose a thread safe key.
    outputs key identifier and bytes used with key.

--*/
{
    RC4_SAFE_ARRAY *pRC4SafeArray;
    RC4_SAFE *pRC4Safe;

    static unsigned int circular;
    unsigned int local;


#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG

    pRC4SafeArray = (RC4_SAFE_ARRAY*)pContext;


//
// there are 2 ways to increment the array selector:
// 1. Just increment the pointer.  On a multi-processor system,
//    with multiple threads calling rc4_safe_select simultaneously,
//    this can lead to several threads selecting the same array element.
//    This will lead to lock contention on the array element lock.
//    Currently, we've decided this scenario will be fairly rare, so the
//    penalty associated with option 2 is avoided.
// 2. Use InterlockedIncrement to determine the array element.  This would
//    yield no collision on an array element, hence no lock contention
//    on the embedded array lock.  This introduces additional bus traffic
//    on SMP machines due to the lock primitive.
//
//

#ifdef KMODE_RNG

    local = (unsigned int)InterlockedIncrement( (PLONG)&circular );

#else

    circular++;
    local = circular;

#endif  // KMODE_RNG


    //
    // array index will not wrap.
    //

    local &= ( pRC4SafeArray->Entries-1 );
    pRC4Safe = pRC4SafeArray->Array[local];

    *pEntry = local;
    *pBytesUsed = pRC4Safe->BytesUsed;
}


#ifdef KMODE_RNG

void
rc4_safe_select_np(
    IN      void *pContext,
    OUT     unsigned int *pEntry,
    OUT     unsigned int *pBytesUsed
    )
/*++

Routine Description:

    Non-paged, high-IRQL version of rc4_safe_select()

--*/
{
    RC4_SAFE_ARRAY *pRC4SafeArray;
    RC4_SAFE *pRC4Safe;
    unsigned int local;

    pRC4SafeArray = (RC4_SAFE_ARRAY*)pContext;

    if( *pEntry == 0 ) {

        if( pRC4SafeArray->Entries == 1 ) {
            local = 0;
        } else {
            static unsigned int circular;

            local = (unsigned int)InterlockedIncrement( (PLONG)&circular );

            //
            // array index will not wrap.
            //

            local = (local % pRC4SafeArray->Entries);
        }

    } else {

        local = KeGetCurrentProcessorNumber();
    }

    pRC4Safe = pRC4SafeArray->Array[local];
    *pEntry = local;
    *pBytesUsed = pRC4Safe->BytesUsed;
}


#endif  // KMODE_RNG



void
rc4_safe(
    IN      void *pContext,
    IN      unsigned int Entry,
    IN      unsigned int cb,
    IN      void *pv
    )
/*++

Routine Description:

    Initializes the rc4 key identified by the Entry index.

    Input key material is pv, of size cb.

--*/
{
    RC4_SAFE_ARRAY *pRC4SafeArray;
    RC4_SAFE *pRC4Safe;

#ifdef KMODE_RNG

    PAGED_CODE();
#endif  // KMODE_RNG

    pRC4SafeArray = (RC4_SAFE_ARRAY*)pContext;

    Entry &= ( pRC4SafeArray->Entries - 1 );
    pRC4Safe = pRC4SafeArray->Array[ Entry ];

    ENTER_LOCK( &(pRC4Safe->lock) );

    rc4( &(pRC4Safe->rc4key), cb, (unsigned char*) pv );
    pRC4Safe->BytesUsed += cb;

    LEAVE_LOCK( &(pRC4Safe->lock) );

}

#ifdef KMODE_RNG

void
rc4_safe_np(
    IN      void *pContext,
    IN      unsigned int Entry,
    IN      unsigned int cb,
    IN      void *pv
    )
/*++

Routine Description:

    Non-paged, high IRQL version of rc4_safe()

--*/
{
    RC4_SAFE_ARRAY *pRC4SafeArray;
    RC4_SAFE *pRC4Safe;

    pRC4SafeArray = (RC4_SAFE_ARRAY*)pContext;

    // NOTE:
    // we ignore the Entry parameter.
    // future consideration may be ignore only when Entry == 0xffffffff
    // but, this would only be perf penalty currently.
    //

    Entry = KeGetCurrentProcessorNumber();

    pRC4Safe = pRC4SafeArray->Array[ Entry ];

    rc4( &(pRC4Safe->rc4key), cb, (unsigned char*) pv );
    pRC4Safe->BytesUsed += cb;

}

#endif // KMODE_RNG

void
rc4_safe_key(
    IN      void *pContext,
    IN      unsigned int Entry,
    IN      unsigned int cb,
    IN      const void *pv
    )
/*++

Routine Description:

    Initializes the rc4 key identified by the Entry index.

    Input key material is pv, of size cb.

--*/
{
    RC4_SAFE_ARRAY *pRC4SafeArray;
    RC4_SAFE *pRC4Safe;

#ifdef KMODE_RNG

    PAGED_CODE();
#endif  // KMODE_RNG

    pRC4SafeArray = (RC4_SAFE_ARRAY*)pContext;


    Entry &= ( pRC4SafeArray->Entries - 1 );
    pRC4Safe = pRC4SafeArray->Array[ Entry ];

    ENTER_LOCK( &(pRC4Safe->lock) );

    rc4_key( &(pRC4Safe->rc4key), cb, (unsigned char*) pv );
    pRC4Safe->BytesUsed = 0;

    LEAVE_LOCK( &(pRC4Safe->lock) );

}

#ifdef KMODE_RNG

void
rc4_safe_key_np(
    IN      void *pContext,
    IN      unsigned int Entry,
    IN      unsigned int cb,
    IN      const void *pv
    )
/*++

Routine Description:

    Non-paged, high-IRQL version of rc4_safe_key()

--*/
{
    RC4_SAFE_ARRAY *pRC4SafeArray;
    RC4_SAFE *pRC4Safe;

    pRC4SafeArray = (RC4_SAFE_ARRAY*)pContext;

    if( Entry == 0xffffffff ) {
        Entry = KeGetCurrentProcessorNumber();
    }

    pRC4Safe = pRC4SafeArray->Array[ Entry ];

    rc4_key( &pRC4Safe->rc4key, cb, (unsigned char*) pv );
    pRC4Safe->BytesUsed = 0;

}

#endif // KMODE_RNG

unsigned int
rc4_safe_startup(
    IN OUT  void **ppContext
    )
/*++

Routine Description:

    key selector:  choose a thread safe key.
    outputs key identifier and bytes used with key.

--*/
{
    RC4_SAFE_ARRAY *pRC4SafeArray;
    RC4_SAFE *pRC4Safe;
    unsigned int Entries;
    unsigned int i;

#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG

    Entries = RC4_SAFE_ENTRIES;


    //
    //  LONGHORN: ALLOC may be used here.
    //  Why do we have to use Non-paged context in paged code? May be not.
    //

    pRC4SafeArray = (RC4_SAFE_ARRAY *)ALLOC_NP(
                                    sizeof(RC4_SAFE_ARRAY) +
                                    (Entries * sizeof(RC4_SAFE *)) +
                                    (Entries * sizeof(RC4_SAFE))
                                    );

    if( pRC4SafeArray == NULL ) {
        return FALSE;
    }

    pRC4SafeArray->Entries = Entries;
    pRC4SafeArray->Mode = Paged;

    pRC4Safe = (RC4_SAFE*) ((unsigned char*)pRC4SafeArray +
                                            sizeof(RC4_SAFE_ARRAY) +
                                            (Entries * sizeof(RC4_SAFE*))
                                            );

    for ( i = 0 ; i < Entries ; i++, pRC4Safe++ ) {

        pRC4SafeArray->Array[i] = pRC4Safe;

        if(!INIT_LOCK( &(pRC4Safe->lock) ))
        {
            pRC4SafeArray->Entries = i;
            rc4_safe_shutdown( pRC4SafeArray );

            return FALSE;
        }

        //
        // cause client to re-key for each initialized array entry.
        //

        pRC4Safe->BytesUsed = 0xffffffff;
    }

    *ppContext = pRC4SafeArray;

    return TRUE;
}


#ifdef KMODE_RNG

unsigned int
rc4_safe_startup_np(
    IN OUT  void **ppContext
    )
/*++

Routine Description:

    Non-Paged, high IRQL version of rc4_safe_startup()

--*/
{
    RC4_SAFE_ARRAY *pRC4SafeArray;
    RC4_SAFE *pRC4Safe;
    unsigned int Entries;
    unsigned int i;

    //
    // get installed processor count.
    //

    Entries = KeNumberProcessors;

    pRC4SafeArray = (RC4_SAFE_ARRAY *)ALLOC_NP(
                                    sizeof(RC4_SAFE_ARRAY) +
                                    (Entries * sizeof(RC4_SAFE *)) +
                                    (Entries * sizeof(RC4_SAFE))
                                    );

    if( pRC4SafeArray == NULL ) {
        return FALSE;
    }

    pRC4SafeArray->Entries = Entries;
    pRC4SafeArray->Mode = NonPaged;

    pRC4Safe = (RC4_SAFE*) ((unsigned char*)pRC4SafeArray +
                                            sizeof(RC4_SAFE_ARRAY) +
                                            (Entries * sizeof(RC4_SAFE*))
                                            );

    for ( i = 0 ; i < Entries ; i++, pRC4Safe++ ) {

        pRC4SafeArray->Array[i] = pRC4Safe;

        //
        // cause client to re-key for each initialized array entry.
        //

        pRC4Safe->BytesUsed = 0xffffffff;
    }

    *ppContext = pRC4SafeArray;

    return TRUE;
}

#endif


void
rc4_safe_shutdown(
    IN      void *pContext
    )
/*++

Routine Description:

    rc4_safe_shutdown called to free resources associated with internal structures.
    typically called during DLL_PROCESS_DETACH type shutdown code.

--*/
{

    RC4_SAFE_ARRAY *SafeArray;
    unsigned int SafeEntries;
    unsigned int i;

#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG


    SafeArray = (RC4_SAFE_ARRAY*)pContext;
    SafeEntries = SafeArray->Entries;

    for ( i = 0 ; i < SafeEntries ; i++ ) {
        RC4_SAFE *pRC4Safe = SafeArray->Array[i];

        DELETE_LOCK( &(pRC4Safe->lock) );
    }

    FREE( pContext );
}



#ifdef KMODE_RNG

void
rc4_safe_shutdown_np(
    IN      void *pContext
    )
/*++

Routine Description:

    Non-paged, high-IRQL version of rc4_safe_shutdown()

--*/
{
    FREE( pContext );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\randlib\randlib.c ===
/*++

Copyright (c) 1993, 1998  Microsoft Corporation

Module Name:

    randlib.c

Abstract:

    This module implements the core cryptographic random number generator
    for use by system components.

    The #define KMODE_RNG affects whether the file is built in a way
    suitable for kernel mode usage.  if KMODE_RNG is not defined, the file
    is built in a way suitable for user mode usage.

Author:

    Scott Field (sfield)    27-Nov-96
    Jeff Spelman (jeffspel) 14-Oct-96

--*/

#ifndef KMODE_RNG

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#else

#include <ntosp.h>
#include <windef.h>

#ifdef USE_HW_RNG
#ifdef _M_IX86
#include <io.h>
#include "deftypes.h"   //ISD typedefs and constants
#include "ioctldef.h"   //ISD ioctl definitions
#endif  // _M_IX86
#endif  // USE_HW_RNG

#endif  // KMODE_RNG

#include <zwapi.h>

#include <winioctl.h>
#include <lmcons.h>

#include <rc4.h>
#include <sha.h>
#include <md4.h>

#include <ntddksec.h>   // IOCTL_
#include <randlib.h>

#include "vlhash.h"
#include "circhash.h"
#include "cpu.h"
#include "seed.h"


#ifdef KMODE_RNG
//#include <ntos.h>
#ifdef USE_HW_RNG
#ifdef _M_IX86
static DWORD g_dwHWDriver = 0;
static PFILE_OBJECT   g_pFileObject = NULL;
static PDEVICE_OBJECT g_pDeviceObject = NULL;
#endif  // _M_IX86
#endif  // USE_HW_RNG
#endif  // KMODE_RNG


#include "umkm.h"

//
// note: RAND_CTXT_LEN dictates the maximum input quantity for re-seed entropy
// is.  We make this fairly large, so that we can take all the entropy generated
// during the GatherRandomBits().  Since the lifetime of the RandContext structure
// is very short, and it lives on the stack, this larger than necessary size
// is ok.  The last few items processed during GatherRandomBits() are of
// variable size, up to a maximum of of UNLEN for the username.
//

#define RAND_CTXT_LEN           (256)
#define RC4_REKEY_PARAM_NT      (16384) // rekey less often on NT

#ifndef KMODE_RNG
#define RC4_REKEY_PARAM_DEFAULT (512)   // rekey every 512 bytes by default
#else
#define RC4_REKEY_PARAM_DEFAULT RC4_REKEY_PARAM_NT
#endif


static unsigned int     g_dwRC4RekeyParam = RC4_REKEY_PARAM_DEFAULT;

static CircularHash     g_CircularHashCtx;

#ifndef WINNT_RNG
static BYTE             g_VeryLargeHash[A_SHA_DIGEST_LEN*4];
#endif

static void *           g_RC4SafeCtx;

#ifndef KMODE_RNG

typedef NTSYSAPI NTSTATUS (NTAPI *NTQUERYSYSTEMINFORMATION) (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

typedef NTSYSAPI NTSTATUS (NTAPI *NTOPENFILE) (
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
    );

typedef NTSYSAPI VOID (NTAPI *RTLINITUNICODESTRING) (
    PUNICODE_STRING DestinationString,
    PCWSTR SourceString
    );

typedef BOOL (WINAPI *GETCURSORPOS)(
    LPPOINT lpPoint
    );

typedef LONG (WINAPI *GETMESSAGETIME)(
    VOID
    );



GETCURSORPOS                ___GetCursorPosRNG = NULL;
GETMESSAGETIME              ___GetMessageTimeRNG = NULL;


#define _GetCursorPos               ___GetCursorPosRNG
#define _GetMessageTime             ___GetMessageTimeRNG


#ifndef WINNT_RNG

NTQUERYSYSTEMINFORMATION            ___NtQuerySystemInformationRNG = NULL;
NTOPENFILE                          ___NtOpenFileRNG = NULL;
RTLINITUNICODESTRING                ___RtlInitUnicodeStringRNG = NULL;

#define _NtQuerySystemInformation   ___NtQuerySystemInformationRNG
#define _NtOpenFile                 ___NtOpenFileRNG
#define _RtlInitUnicodeString       ___RtlInitUnicodeStringRNG

#else

#define _NtQuerySystemInformation   NtQuerySystemInformation
#define _NtOpenFile                 NtOpenFile
#define _RtlInitUnicodeString       RtlInitUnicodeString

#endif


#ifndef WINNT_RNG
HANDLE g_hKsecDD = NULL;
#else
extern HANDLE g_hKsecDD;
#endif

#else

#define _NtQuerySystemInformation ZwQuerySystemInformation

#endif // !KMODE_RNG

/// TODO: cache hKeySeed later.
///extern HKEY g_hKeySeed;



//
// private function prototypes.
//


BOOL
GenRandom (
    IN      PVOID           hUID,
        OUT BYTE            *pbBuffer,
    IN      size_t          dwLength
    );


BOOL
RandomFillBuffer(
        OUT BYTE            *pbBuffer,
    IN      DWORD           *pdwLength
    );

BOOL
GatherRandomKey(
    IN      BYTE            *pbUserSeed,
    IN      DWORD           cbUserSeed,
    IN  OUT BYTE            *pbRandomKey,
    IN  OUT DWORD           *pcbRandomKey
    );

BOOL
GatherRandomKeyFastUserMode(
    IN      BYTE            *pbUserSeed,
    IN      DWORD           cbUserSeed,
    IN  OUT BYTE            *pbRandomKey,
    IN  OUT DWORD           *pcbRandomKey
    );


BOOL
IsRNGWinNT(
    VOID
    );


#ifdef _M_IX86
unsigned int
QueryForHWRandomBits(
    IN      DWORD *pdwRandom,
    IN  OUT DWORD cdwRandom
    );
#endif //_M_IX86


#ifdef KMODE_RNG

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NewGenRandom)
#pragma alloc_text(PAGE, NewGenRandomEx)
#pragma alloc_text(PAGE, GenRandom)
#pragma alloc_text(PAGE, RandomFillBuffer)
#pragma alloc_text(PAGE, InitializeRNG)
#pragma alloc_text(PAGE, ShutdownRNG)
#ifdef _M_IX86
#pragma alloc_text(PAGE, QueryForHWRandomBits)
#endif //_M_IX86
#pragma alloc_text(PAGE, GatherRandomKey)

#endif  // ALLOC_PRAGMA
#endif  // KMODE_RNG



/************************************************************************/
/* NewGenRandom generates a specified number of random bytes and places */
/* them into the specified buffer.                                      */
/************************************************************************/
/*                                                                      */
/* Pseudocode logic flow:                                               */
/*                                                                      */
/* if (bits streamed >= threshold)                                      */
/* {                                                                    */
/*  Gather_Bits()                                                       */
/*  SHAMix_Bits(User, Gathered, Static -> Static)                       */
/*  RC4Key(Static -> newRC4Key)                                         */
/*  SaveToRegistry(Static)                                              */
/* }                                                                    */
/* else                                                                 */
/* {                                                                    */
/*  Mix_Bits(User, Static -> Static)                                    */
/* }                                                                    */
/*                                                                      */
/* RC4(newRC4Key -> outbuf)                                             */
/* bits streamed += sizeof(outbuf)                                      */
/*                                                                      */
/************************************************************************/


unsigned int
RSA32API
NewGenRandomEx(
    IN      RNG_CONTEXT *pRNGContext,
    IN  OUT unsigned char *pbRandBuffer,
    IN      unsigned long cbRandBuffer
    )
{
    unsigned char **ppbRandSeed;
    unsigned long *pcbRandSeed;
    unsigned int fRet;

#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG

    fRet = TRUE;

    if( pRNGContext->cbSize != sizeof( RNG_CONTEXT ) )
        return FALSE;

    if( pRNGContext->pbRandSeed && pRNGContext->cbRandSeed ) {

        ppbRandSeed = &pRNGContext->pbRandSeed;
        pcbRandSeed = &pRNGContext->cbRandSeed;

    } else {

        ppbRandSeed = NULL;
        pcbRandSeed = NULL;
    }

    if(!InitializeRNG( NULL ))
    {
        return FALSE;
    }

    InitRand( ppbRandSeed, pcbRandSeed );

    if( pRNGContext->Flags & RNG_FLAG_REKEY_ONLY ) {

        //
        // caller wants REKEY only.
        //

        fRet = GatherRandomKey( NULL, 0, pbRandBuffer, &cbRandBuffer );

    } else {

        //
        // standard RNG request.
        //

        fRet = GenRandom(0, pbRandBuffer, cbRandBuffer);
    }

    if( ppbRandSeed && pcbRandSeed ) {
        DeInitRand( *ppbRandSeed, *pcbRandSeed);
    }

    return fRet;
}

unsigned int
RSA32API
NewGenRandom (
    IN  OUT unsigned char **ppbRandSeed,
    IN      unsigned long *pcbRandSeed,
    IN  OUT unsigned char *pbBuffer,
    IN      unsigned long dwLength
    )
{
    RNG_CONTEXT RNGContext;

#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG


    RtlZeroMemory( &RNGContext, sizeof(RNGContext) );
    RNGContext.cbSize = sizeof(RNGContext);

    if( ppbRandSeed && pcbRandSeed ) {
        BOOL fRet;

        RNGContext.pbRandSeed = *ppbRandSeed;
        RNGContext.cbRandSeed = *pcbRandSeed;

        fRet = NewGenRandomEx( &RNGContext, pbBuffer, dwLength );
        *pcbRandSeed = RNGContext.cbRandSeed;

        return fRet;
    }

    return NewGenRandomEx( &RNGContext, pbBuffer, dwLength );
}

unsigned int
RSA32API
InitRand(
    IN  OUT unsigned char **ppbRandSeed,
    IN      unsigned long *pcbRandSeed
    )
{

    static BOOL fInitialized = FALSE;

#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG

    if( !fInitialized ) {

        InitCircularHash(
                    &g_CircularHashCtx,
                    7,
                    CH_ALG_MD4,
                    0   // CH_MODE_FEEDBACK
                    );

#ifndef WINNT_RNG
        //
        // get prior seed.
        //

        ReadSeed( g_VeryLargeHash, sizeof( g_VeryLargeHash ) );
#endif

        fInitialized = TRUE;
    }

    if( ppbRandSeed != NULL && pcbRandSeed != NULL && *pcbRandSeed != 0 )
        UpdateCircularHash( &g_CircularHashCtx, *ppbRandSeed, *pcbRandSeed );

    return TRUE;
}

unsigned int
RSA32API
DeInitRand(
    IN  OUT unsigned char *pbRandSeed,
    IN      unsigned long cbRandSeed
    )
{
    PBYTE       pbCircularHash;
    DWORD       cbCircularHash;

#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG

    if( pbRandSeed == NULL || cbRandSeed == 0 )
        return TRUE;

    if(GetCircularHashValue( &g_CircularHashCtx, &pbCircularHash, &cbCircularHash )) {

        unsigned long cbToCopy;

        if( cbRandSeed > cbCircularHash ) {
            cbToCopy = cbCircularHash;
        } else {
            cbToCopy = cbRandSeed;
        }

        memcpy(pbRandSeed, pbCircularHash, cbToCopy);
    }

    return TRUE;
}

unsigned int
RSA32API
InitializeRNG(
    VOID *pvReserved
    )
{
    void *pvCtx;
    void *pvOldCtx;

#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG

    if( g_RC4SafeCtx ) {
        return TRUE;
    }

    if(!rc4_safe_startup( &pvCtx )) {
        return FALSE;
    }

    pvOldCtx = INTERLOCKEDCOMPAREEXCHANGEPOINTER( &g_RC4SafeCtx, pvCtx, NULL );

    if( pvOldCtx ) {

        //
        // race condition occured during init.
        //

        rc4_safe_shutdown( pvCtx );
    }

    return TRUE;
}

void
RSA32API
ShutdownRNG(
    VOID *pvReserved
    )
{
    void *pvCtx;

#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG

    pvCtx = InterlockedExchangePointer( &g_RC4SafeCtx, NULL );

    if( pvCtx ) {
        rc4_safe_shutdown( pvCtx );
    }

#ifndef KMODE_RNG
#ifndef WINNT_RNG
{
    HANDLE hFile;
    hFile = InterlockedExchangePointer( &g_hKsecDD, NULL );

    if( hFile ) {
        CloseHandle( hFile );
    }
}
#endif
#endif

#if 0
    // TODO later: finish logic for caching registry key.
    hKey = InterlockedExchangePointer( &g_hKeySeed, NULL );

    if( hKey ) {
        REGCLOSEKEY( hKey );
    }
#endif

}

BOOL
GenRandom (
    IN      PVOID hUID,
        OUT BYTE *pbBuffer,
    IN      size_t dwLength
    )
{
    DWORD           dwBytesThisPass;
    DWORD           dwFilledBytes;

#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG

    dwFilledBytes = 0;

    // break request into chunks that we rekey between
    while(dwFilledBytes < dwLength)
    {
        dwBytesThisPass = dwLength - dwFilledBytes;

        if(!RandomFillBuffer(
                pbBuffer + dwFilledBytes,
                &dwBytesThisPass
                )) {

            return FALSE;
        }

        dwFilledBytes += dwBytesThisPass;
    }

    return TRUE;
}


BOOL
RandomFillBuffer(
        OUT BYTE *pbBuffer,
    IN      DWORD *pdwLength
    )
{
    unsigned int RC4BytesUsed;
    unsigned int KeyId;

#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG


    //
    // update circular hash with user supplied bits.
    //

    if(!UpdateCircularHash( &g_CircularHashCtx, pbBuffer, *pdwLength ))
        return FALSE;


    //
    // select key.
    //

    rc4_safe_select( g_RC4SafeCtx, &KeyId, &RC4BytesUsed );


    //
    // check if re-key required.
    //

    if ( RC4BytesUsed >= g_dwRC4RekeyParam )
    {
        PBYTE       pbCircularHash;
        DWORD       cbCircularHash;
        BYTE        pbRandomKey[ 256 ];
        DWORD       cbRandomKey = sizeof(pbRandomKey);

        RC4BytesUsed = g_dwRC4RekeyParam;

        if(!GetCircularHashValue(
                &g_CircularHashCtx,
                &pbCircularHash,
                &cbCircularHash
                )) {

            return FALSE;
        }

        if(!GatherRandomKey( pbCircularHash, cbCircularHash, pbRandomKey, &cbRandomKey ))
            return FALSE;

        //
        // Create RC4 key
        //

        rc4_safe_key(
                g_RC4SafeCtx,
                KeyId,
                cbRandomKey,
                pbRandomKey
                );

        RtlZeroMemory( pbRandomKey, sizeof(pbRandomKey) );
    }


    //
    // only use RC4_REKEY_PARAM bytes from each RC4 key
    //

    {
        DWORD dwMaxPossibleBytes = g_dwRC4RekeyParam - RC4BytesUsed;

        if (*pdwLength > dwMaxPossibleBytes)
            *pdwLength = dwMaxPossibleBytes;
    }

    rc4_safe( g_RC4SafeCtx, KeyId, *pdwLength, pbBuffer );

    return TRUE;
}


#ifdef KMODE_RNG
#ifdef USE_HW_RNG
#ifdef _M_IX86
#define NUM_HW_DWORDS_TO_GATHER     4
#define INTEL_DRIVER_NAME           L"\\Device\\ISECDRV"

unsigned int
QueryForHWRandomBits(
    IN      DWORD *pdwRandom,
    IN  OUT DWORD cdwRandom
    )
{
    UNICODE_STRING ObjectName;
    IO_STATUS_BLOCK StatusBlock;
    KEVENT Event;
    PIRP pIrp = NULL;
    ISD_Capability ISD_Cap;                //in/out for GetCapability
    ISD_RandomNumber ISD_Random;           //in/out for GetRandomNumber
    PDEVICE_OBJECT pDeviceObject = NULL;
    DWORD i = 0;
    unsigned int Status = ERROR_SUCCESS;

    PAGED_CODE();

    if (1 == g_dwHWDriver)
    {
        Status = STATUS_ACCESS_DENIED;
        goto Ret;
    }

    RtlZeroMemory( &ObjectName, sizeof(ObjectName) );
    RtlZeroMemory( &StatusBlock, sizeof(StatusBlock) );
    RtlZeroMemory(&ISD_Cap, sizeof(ISD_Cap));


    if (NULL == g_pDeviceObject)
    {
        ObjectName.Length = sizeof(INTEL_DRIVER_NAME) - sizeof(WCHAR);
        ObjectName.MaximumLength = sizeof(INTEL_DRIVER_NAME);
        ObjectName.Buffer = INTEL_DRIVER_NAME;
        Status = IoGetDeviceObjectPointer(&ObjectName,
                                          FILE_ALL_ACCESS,
                                          &g_pFileObject,
                                          &pDeviceObject);

        if ( !NT_SUCCESS(Status) )
        {
            g_dwHWDriver = 1;
            goto Ret;
        }

        if (NULL == g_pDeviceObject)
        {
            InterlockedExchangePointer(&g_pDeviceObject, pDeviceObject);
        }
    }

    //
    // If this fails then it is because there is no such device
    // which signals completion.
    //


    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    ISD_Cap.uiIndex = ISD_RNG_ENABLED;  //Set input member
    pIrp = IoBuildDeviceIoControlRequest(
        IOCTL_ISD_GetCapability,
        g_pDeviceObject,
        &ISD_Cap,
        sizeof(ISD_Cap),
        &ISD_Cap,
        sizeof(ISD_Cap),
        FALSE,
        &Event,
        &StatusBlock);

    if (pIrp == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Ret;
    }

    Status = IoCallDriver(g_pDeviceObject, pIrp);

    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
        Status = StatusBlock.Status;
    }

    if (ISD_Cap.iStatus != ISD_EOK) {
        Status = STATUS_NOT_IMPLEMENTED;
        goto Ret;
    }

    // now get the random bits
    for (i = 0; i < cdwRandom; i++) {
        RtlZeroMemory(&ISD_Random, sizeof(ISD_Random));
        KeInitializeEvent(&Event, NotificationEvent, FALSE);

        pIrp = IoBuildDeviceIoControlRequest(
            IOCTL_ISD_GetRandomNumber,
            g_pDeviceObject,
            &ISD_Random,
            sizeof(ISD_Random),
            &ISD_Random,
            sizeof(ISD_Random),
            FALSE,
            &Event,
            &StatusBlock);

        if (pIrp == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Ret;
        }

        Status = IoCallDriver(g_pDeviceObject, pIrp);

        if (Status == STATUS_PENDING) {
            KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
            Status = StatusBlock.Status;
        }

        if (ISD_Random.iStatus != ISD_EOK) {
            Status = STATUS_NOT_IMPLEMENTED;
            goto Ret;
        }

        pdwRandom[i] = pdwRandom[i] ^ ISD_Random.uiRandomNum;
    }
Ret:
    return Status;
}
#endif // _M_IX86
#endif // USE_HW_RNG
#endif // KMODE_RNG

BOOL
GatherRandomKey(
    IN      BYTE            *pbUserSeed,
    IN      DWORD           cbUserSeed,
    IN  OUT BYTE            *pbRandomKey,
    IN  OUT DWORD           *pcbRandomKey
    )
{

    LPBYTE  pbWorkingBuffer = NULL;
    DWORD   cbWorkingBuffer;
    DWORD   cbBufferRemaining;
    BYTE    *pbCurrentBuffer;
    DWORD   *pdwTmp;
    BOOL    fRet;

#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG




    //
    // in NT Usermode, try to re-seed by calling the Kernelmode RNG.
    //

#ifndef KMODE_RNG
#ifdef WINNT_RNG
    return GatherRandomKeyFastUserMode(
                    pbUserSeed,
                    cbUserSeed,
                    pbRandomKey,
                    pcbRandomKey
                    );
#else
    if(GatherRandomKeyFastUserMode(
                    pbUserSeed,
                    cbUserSeed,
                    pbRandomKey,
                    pcbRandomKey
                    ))
    {
        return TRUE;
    }
#endif
#endif


#ifndef WINNT_RNG

//
// verify current working buffer has space for candidate data.
//

#define VERIFY_BUFFER( size ) {                                         \
    if( cbBufferRemaining < size )                                      \
        goto finished;                                                  \
    }

//
// update working buffer and increment to next QWORD aligned boundary.
//

#define UPDATE_BUFFER( size ) {                                         \
    DWORD dwSizeRounded;                                                \
    dwSizeRounded = (size + sizeof(ULONG64)) & ~(sizeof(ULONG64)-1);    \
    if(dwSizeRounded > cbBufferRemaining)                               \
        goto finished;                                                  \
    pbCurrentBuffer += dwSizeRounded;                                   \
    cbBufferRemaining -= dwSizeRounded;                                 \
    }


    cbWorkingBuffer = 3584;
    pbWorkingBuffer = (PBYTE)ALLOC( cbWorkingBuffer );
    if( pbWorkingBuffer == NULL ) {
        return FALSE;
    }

    cbBufferRemaining = cbWorkingBuffer;
    pbCurrentBuffer = pbWorkingBuffer;

    //
    // pickup user supplied bits.
    //

    VERIFY_BUFFER( cbUserSeed );
    RtlCopyMemory( pbCurrentBuffer, pbUserSeed, cbUserSeed );
    UPDATE_BUFFER( cbUserSeed );

    //
    // ** indicates US DoD's specific recommendations for password generation
    //


    //
    // process id
    //


#ifndef KMODE_RNG
    pdwTmp = (PDWORD)pbCurrentBuffer;
    *pdwTmp = GetCurrentProcessId();
    UPDATE_BUFFER( sizeof(DWORD) );
#else
    {
    PHANDLE hTmp = (PHANDLE)pbCurrentBuffer;
    VERIFY_BUFFER( sizeof(HANDLE) );
    *hTmp = PsGetCurrentProcessId();
    UPDATE_BUFFER( sizeof(HANDLE) );
    }
#endif


    //
    // thread id
    //


#ifndef KMODE_RNG
    pdwTmp = (PDWORD)pbCurrentBuffer;
    *pdwTmp = GetCurrentThreadId();
    UPDATE_BUFFER( sizeof(DWORD) );
#else
    {
    PHANDLE hTmp = (PHANDLE)pbCurrentBuffer;
    VERIFY_BUFFER( sizeof(HANDLE) );
    *hTmp = PsGetCurrentThreadId();
    UPDATE_BUFFER( sizeof(HANDLE) );
    }
#endif



    //
    // ** ticks since boot (system clock)
    //


#ifndef KMODE_RNG
    pdwTmp = (PDWORD)pbCurrentBuffer;
    *pdwTmp = GetTickCount();
    UPDATE_BUFFER( sizeof(DWORD) );
#else
    {
    PLARGE_INTEGER Tick = (PLARGE_INTEGER)pbCurrentBuffer;

    VERIFY_BUFFER( sizeof(LARGE_INTEGER) );
    KeQueryTickCount( Tick );
    UPDATE_BUFFER( sizeof(LARGE_INTEGER) );
    }
#endif  // !KMODE_RNG



    //
    // ** system time, in ms, sec, min (date & time)
    //

#ifndef KMODE_RNG
    {
        PSYSTEMTIME psysTime = (PSYSTEMTIME)pbCurrentBuffer;

        VERIFY_BUFFER( sizeof( *psysTime ) );
        GetLocalTime(psysTime);
        UPDATE_BUFFER( sizeof( *psysTime ) );
    }
#else
    {

        PSYSTEM_TIMEOFDAY_INFORMATION pTimeOfDay;
        ULONG cbSystemInfo;

        pTimeOfDay = (PSYSTEM_TIMEOFDAY_INFORMATION)pbCurrentBuffer;

        VERIFY_BUFFER( sizeof(*pTimeOfDay) );

        _NtQuerySystemInformation(
                    SystemTimeOfDayInformation,
                    pTimeOfDay,
                    sizeof(*pTimeOfDay),
                    &cbSystemInfo
                    );

        UPDATE_BUFFER(  cbSystemInfo );
    }

#endif  // !KMODE_RNG

    //
    // ** hi-res performance counter (system counters)
    //

    {
        LARGE_INTEGER   *pliPerfCount = (PLARGE_INTEGER)pbCurrentBuffer;

        VERIFY_BUFFER( sizeof(*pliPerfCount) );
#ifndef KMODE_RNG
        QueryPerformanceCounter(pliPerfCount);
#else
///        ZwQueryPerformanceCounter(pliPerfCount, NULL);
//      Defined in zwapi.h, but not exported by ntoskrnl.exe ???
#endif  // !KMODE_RNG
        UPDATE_BUFFER( sizeof(*pliPerfCount) );
    }



#ifndef KMODE_RNG

    //
    // memory status
    //

    {
        MEMORYSTATUS *pmstMemStat = (MEMORYSTATUS *)pbCurrentBuffer;

        VERIFY_BUFFER( sizeof(*pmstMemStat) );

        pmstMemStat->dwLength = sizeof(MEMORYSTATUS);
        GlobalMemoryStatus( pmstMemStat );

        UPDATE_BUFFER( sizeof(*pmstMemStat) );
    }

#endif  // !KMODE_RNG


    //
    // free disk clusters
    //

#ifndef KMODE_RNG

    {
        PDWORD pdwDiskInfo = (PDWORD)pbCurrentBuffer;

        VERIFY_BUFFER( (sizeof(DWORD) * 4) );

        GetDiskFreeSpace(
                    NULL,
                    &pdwDiskInfo[0],    // sectors per cluster
                    &pdwDiskInfo[1],    // bytes per sector
                    &pdwDiskInfo[2],    // number of free clusters
                    &pdwDiskInfo[3]     // total number of clusters
                    );

        UPDATE_BUFFER( (sizeof(DWORD) * 4) );
    }
#endif  // !KMODE_RNG


#ifndef KMODE_RNG
    {

        //
        // hash the entire user environment block.
        // we do this instead of GetUserName & GetComputerName,
        // as the environment block contains these values, plus additional
        // values.
        //

        static BOOL fHashedEnv;
        static BYTE HashEnv[ MD4_LEN ];

        if( !fHashedEnv ) {

            LPVOID lpEnvBlock;
            BOOL fAnsi = FALSE;

            //
            // try the Unicode version first, as, on WinNT, this returns us
            // a pointer to the existing Unicode environment block, rather
            // than an allocated copy.  Fallback to ANSI if this fails (eg: Win9x)
            //

            lpEnvBlock = GetEnvironmentStringsW();
            if( lpEnvBlock == NULL )
            {
                lpEnvBlock = GetEnvironmentStringsA();
                fAnsi = TRUE;
            }


            if( lpEnvBlock != NULL ) {

                ULONG cbEntry;
                PBYTE pbEntry;
                MD4_CTX MD4Ctx;


                MD4Init( &MD4Ctx );

                pbEntry = (PBYTE)lpEnvBlock;
                cbEntry = 0;

                do {

                    if( !fAnsi ) {
                        pbEntry += (cbEntry + sizeof(WCHAR));
                        cbEntry = lstrlenW( (LPWSTR)pbEntry ) * sizeof(WCHAR);
                    } else {
                        pbEntry += (cbEntry + sizeof(CHAR));
                        cbEntry = lstrlenA( (LPSTR)pbEntry ) * sizeof(CHAR);
                    }

                    MD4Update(
                        &MD4Ctx,
                        (unsigned char *)pbEntry,
                        (unsigned int)cbEntry
                        );

                } while( cbEntry );


                MD4Final( &MD4Ctx );

                CopyMemory( HashEnv, MD4Ctx.digest, sizeof(HashEnv) );

                if( !fAnsi ) {
                    FreeEnvironmentStringsW( lpEnvBlock );
                } else {
                    FreeEnvironmentStringsA( lpEnvBlock );
                }
            }

            //
            // only try this once.  if it failed once, it will likely never
            // succeed.
            //

            fHashedEnv = TRUE;
        }

        VERIFY_BUFFER( (sizeof(HashEnv)) );
        CopyMemory( pbCurrentBuffer, HashEnv, sizeof(HashEnv) );
        UPDATE_BUFFER( (sizeof(HashEnv)) );
    }
#endif  // !KMODE_RNG

    //
    // this code path has been moved to the end so that our CombineRand()
    // operation on NT mixes in with everything slammed into the
    // rand context buffer.
    //

#ifndef KMODE_RNG
    if(!IsRNGWinNT()) {

        //
        // only user info if we are not running on NT.
        // this prevents deadlocks on WinNT when the RNG is called from CSRSS
        //

        POINT   *ppoint;
        LONG    *plTime;

        //
        // cursor position
        //

        ppoint = (POINT*)pbCurrentBuffer;

        VERIFY_BUFFER( sizeof(*ppoint) );
        _GetCursorPos(ppoint);
        UPDATE_BUFFER( sizeof(*ppoint) );

        //
        // last messages' timestamp
        //

        plTime = (LONG*)pbCurrentBuffer;

        VERIFY_BUFFER( sizeof(*plTime) );
        *plTime = _GetMessageTime();
        UPDATE_BUFFER( sizeof(*plTime) );


    } else
#endif  // !KMODE_RNG
    {
        unsigned char *pbCounterState = (unsigned char*)pbCurrentBuffer;
        unsigned long cbCounterState = 64;

        VERIFY_BUFFER(cbCounterState);

        if(GatherCPUSpecificCounters( pbCounterState, &cbCounterState )) {
            UPDATE_BUFFER( cbCounterState );
        }


        //
        // call NtQuerySystemInformation on NT if available.
        //

        if( (void*)_NtQuerySystemInformation ) {

            PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION pSystemProcessorPerformanceInfo;
            PSYSTEM_PERFORMANCE_INFORMATION pSystemPerformanceInfo;
            PSYSTEM_EXCEPTION_INFORMATION pSystemExceptionInfo;
            PSYSTEM_LOOKASIDE_INFORMATION pSystemLookasideInfo;
            PSYSTEM_INTERRUPT_INFORMATION pSystemInterruptInfo;
            PSYSTEM_PROCESS_INFORMATION pSystemProcessInfo;
            ULONG cbSystemInfo;
            NTSTATUS Status;

            //
            // fixed length system info calls.
            //

            pSystemProcessorPerformanceInfo = (PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION)pbCurrentBuffer;

            VERIFY_BUFFER( sizeof(*pSystemProcessorPerformanceInfo) );

            Status = _NtQuerySystemInformation(
                        SystemProcessorPerformanceInformation,
                        pSystemProcessorPerformanceInfo,
                        sizeof(*pSystemProcessorPerformanceInfo),
                        &cbSystemInfo
                        );

            if ( NT_SUCCESS(Status) ) {
                UPDATE_BUFFER( cbSystemInfo );
            }

            pSystemPerformanceInfo = (PSYSTEM_PERFORMANCE_INFORMATION)pbCurrentBuffer;

            VERIFY_BUFFER( sizeof(*pSystemPerformanceInfo) );

            Status = _NtQuerySystemInformation(
                        SystemPerformanceInformation,
                        pSystemPerformanceInfo,
                        sizeof(*pSystemPerformanceInfo),
                        &cbSystemInfo
                        );

            if ( NT_SUCCESS(Status) ) {
                UPDATE_BUFFER(  cbSystemInfo );
            }

            pSystemExceptionInfo = (PSYSTEM_EXCEPTION_INFORMATION)pbCurrentBuffer;

            VERIFY_BUFFER( sizeof(*pSystemExceptionInfo) );

            Status = _NtQuerySystemInformation(
                        SystemExceptionInformation,
                        pSystemExceptionInfo,
                        sizeof(*pSystemExceptionInfo),
                        &cbSystemInfo
                        );

            if ( NT_SUCCESS(Status) ) {
                UPDATE_BUFFER( cbSystemInfo );
            }

            pSystemLookasideInfo = (PSYSTEM_LOOKASIDE_INFORMATION)pbCurrentBuffer;

            VERIFY_BUFFER( sizeof(*pSystemLookasideInfo) );

            Status = _NtQuerySystemInformation(
                        SystemLookasideInformation,
                        pSystemLookasideInfo,
                        sizeof(*pSystemLookasideInfo),
                        &cbSystemInfo
                        );

            if ( NT_SUCCESS(Status) ) {
                UPDATE_BUFFER( cbSystemInfo );
            }

            //
            // variable length system info calls.
            //

            pSystemInterruptInfo = (PSYSTEM_INTERRUPT_INFORMATION)pbCurrentBuffer;
            cbSystemInfo = cbBufferRemaining;

            Status = _NtQuerySystemInformation(
                        SystemInterruptInformation,
                        pSystemInterruptInfo,
                        cbSystemInfo,
                        &cbSystemInfo
                        );

            if ( NT_SUCCESS(Status) ) {
                UPDATE_BUFFER( cbSystemInfo );
            }

            pSystemProcessInfo = (PSYSTEM_PROCESS_INFORMATION)pbCurrentBuffer;
            cbSystemInfo = cbBufferRemaining;

            Status = _NtQuerySystemInformation(
                        SystemProcessInformation,
                        pSystemProcessInfo,
                        cbSystemInfo,
                        &cbSystemInfo
                        );

            if ( NT_SUCCESS(Status) ) {
                UPDATE_BUFFER( cbSystemInfo );
            }

        } // _NtQuerySystemInformation
    }

#ifdef KMODE_RNG
#ifdef USE_HW_RNG
#ifdef _M_IX86
    // attempt to get bits from the INTEL HW RNG
    {
        DWORD rgdwHWRandom[NUM_HW_DWORDS_TO_GATHER];
        NTSTATUS Status;


        VERIFY_BUFFER( sizeof(rgdwHWRandom) );

        Status = QueryForHWRandomBits(
                    rgdwHWRandom,
                    NUM_HW_DWORDS_TO_GATHER
                    );

        if ( NT_SUCCESS(Status) ) {
            UPDATE_BUFFER( sizeof(rgdwHWRandom) );
        }

    }
#endif // _M_IX86
#endif // USE_HW_RNG
#endif // KMODE_RNG

finished:

    {
        RC4_KEYSTRUCT rc4Key;
        BYTE NewSeed[ sizeof(g_VeryLargeHash) ];
        BYTE LocalHash[ sizeof( g_VeryLargeHash ) ];
        DWORD cbBufferSize;

        RtlCopyMemory( LocalHash, g_VeryLargeHash, sizeof(g_VeryLargeHash) );

        rc4_key( &rc4Key, sizeof(LocalHash), LocalHash );

        cbBufferSize = cbWorkingBuffer - cbBufferRemaining;
        if( cbBufferSize > cbWorkingBuffer )
            cbBufferSize = cbWorkingBuffer;

        fRet = VeryLargeHashUpdate(
                    pbWorkingBuffer,                    // buffer to hash
                    cbBufferSize,
                    LocalHash
                    );

        RtlCopyMemory( NewSeed, LocalHash, sizeof(LocalHash) );
        RtlCopyMemory( g_VeryLargeHash, LocalHash, sizeof(LocalHash) );
        rc4( &rc4Key, sizeof( NewSeed ), NewSeed );

        //
        // write seed out.
        //

        WriteSeed( NewSeed, sizeof(NewSeed) );
        RtlZeroMemory( NewSeed, sizeof(NewSeed) );

        rc4_key( &rc4Key, sizeof(LocalHash), LocalHash );
        RtlZeroMemory( LocalHash, sizeof(LocalHash) );

        rc4( &rc4Key, *pcbRandomKey, pbRandomKey );
        RtlZeroMemory( &rc4Key, sizeof(rc4Key) );


        if( pbWorkingBuffer ) {
            FREE( pbWorkingBuffer );
        }
    }

    return fRet;

#endif // WINNT_RNG

}



#ifndef KMODE_RNG

BOOL
GatherRandomKeyFastUserMode(
    IN      BYTE            *pbUserSeed,
    IN      DWORD           cbUserSeed,
    IN  OUT BYTE            *pbRandomKey,
    IN  OUT DWORD           *pcbRandomKey
    )
/*++

    This routine attempts to gather RNG re-seed material for usermode callers
    from the Kernel mode version of the RNG.  This is accomplished by making
    a device IOCTL into the ksecdd.sys device driver.

--*/
{
    HANDLE hFile;
    NTSTATUS Status;

    if(!IsRNGWinNT())
        return FALSE;

    hFile = g_hKsecDD;

    if( hFile == NULL ) {

        UNICODE_STRING DriverName;
        OBJECT_ATTRIBUTES ObjA;
        IO_STATUS_BLOCK IOSB;
        HANDLE hPreviousValue;

        //
        // call via the ksecdd.sys device driver to get the random bits.
        //

        if( _NtOpenFile == NULL || _RtlInitUnicodeString == NULL ) {
            return FALSE;
        }

        //
        // have to use the Nt flavor of the file open call because it's a base
        // device not aliased to \DosDevices
        //

        _RtlInitUnicodeString( &DriverName, DD_KSEC_DEVICE_NAME_U );
        InitializeObjectAttributes(
                    &ObjA,
                    &DriverName,
                    OBJ_CASE_INSENSITIVE,
                    0,
                    0
                    );

        //
        // needs to be non-alertable, else, the DeviceIoControl may return
        // STATUS_USER_APC.
        //

        Status = _NtOpenFile(
                    &hFile,
                    SYNCHRONIZE | FILE_READ_DATA,
                    &ObjA,
                    &IOSB,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_SYNCHRONOUS_IO_NONALERT
                    );


        if( !NT_SUCCESS(Status) )
            return FALSE;

        hPreviousValue = INTERLOCKEDCOMPAREEXCHANGEPOINTER(
                                        &g_hKsecDD,
                                        hFile,
                                        NULL
                                        );

        if( hPreviousValue != NULL ) {

            //
            // race condition, set current value to previously initialized version.
            //

            CloseHandle( hFile );
            hFile = hPreviousValue;
        }
    }

    return DeviceIoControl(
                hFile,
                IOCTL_KSEC_RNG_REKEY,   // indicate a RNG rekey
                pbUserSeed,             // input buffer (existing material)
                cbUserSeed,             // input buffer size
                pbRandomKey,            // output buffer
                *pcbRandomKey,          // output buffer size
                pcbRandomKey,           // bytes written to output buffer
                NULL
                );
}


BOOL
IsRNGWinNT(
    VOID
    )
/*++

    This function determines if we are running on Windows NT and furthermore,
    if it is appropriate to make use of certain user operations where the
    code is running.

    If the function returns TRUE, the caller cannot make calls to user
    based function and should use an alternative approach such as
    NtQuerySystemInformation.

    If the function returns FALSE, the caller can safely call user based
    functions to gather random material.

--*/
{
    static BOOL fIKnow = FALSE;

    // we assume WinNT in case of error.
    static BOOL fIsWinNT = TRUE;

    OSVERSIONINFO osVer;

    if(fIKnow)
        return(fIsWinNT);

    RtlZeroMemory(&osVer, sizeof(osVer));
    osVer.dwOSVersionInfoSize = sizeof(osVer);

    if( GetVersionEx(&osVer) ) {
        fIsWinNT = (osVer.dwPlatformId == VER_PLATFORM_WIN32_NT);

        if( fIsWinNT ) {
#ifndef WINNT_RNG
            //
            // if we're on NT, collect entry point address.
            //
            HMODULE hNTDll = GetModuleHandleW( L"ntdll.dll" );

            if( hNTDll ) {
                _NtQuerySystemInformation = (NTQUERYSYSTEMINFORMATION)GetProcAddress(
                                hNTDll,
                                "NtQuerySystemInformation"
                                );

                //
                // On WinNT, adjust the rekey param to be a much larger value
                // because we have more entropy to key from.
                //

                if( _NtQuerySystemInformation )
                    g_dwRC4RekeyParam = RC4_REKEY_PARAM_NT;

                _NtOpenFile = (NTOPENFILE)GetProcAddress(
                                hNTDll,
                                "NtOpenFile"
                                );

                _RtlInitUnicodeString = (RTLINITUNICODESTRING)GetProcAddress(
                                hNTDll,
                                "RtlInitUnicodeString"
                                );
            }
#else
            g_dwRC4RekeyParam = RC4_REKEY_PARAM_NT;
#endif
        } else {
            //
            // collect entry point addresses for Win95
            //
            HMODULE hUser32 = LoadLibraryA("user32.dll");

            if( hUser32 ) {
                _GetCursorPos = (GETCURSORPOS)GetProcAddress(
                                hUser32,
                                "GetCursorPos"
                                );

                _GetMessageTime = (GETMESSAGETIME)GetProcAddress(
                                hUser32,
                                "GetMessageTime"
                                );
            }

        }
    }

    // even on an error, this is as good as it gets
    fIKnow = TRUE;

    return fIsWinNT;
}

#endif  // !KMODE_RNG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\randlib\umkm.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    umkm.c

Abstract:

    Macros to simplify usermode & kernelmode shared code.

Author:

    Scott Field (sfield)    19-Sep-99

--*/

#ifndef KMODE_RNG

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <zwapi.h>

#else

#include <ntosp.h>
#include <windef.h>

#endif  // KMODE_RNG

#include "umkm.h"


#ifdef WIN95_RNG

PVOID
InterlockedCompareExchangePointerWin95(
    PVOID *Destination,
    PVOID Exchange,
    PVOID Comperand
    )
/*++

    routine to allow Win95 to work.  Isn't atomic, but Win95 doesn't support
    multiple processors.  The worst case is we leak resources as a result,
    since we only use CompareExchange for initialization purposes.

--*/
{
    PVOID InitialValue;

    typedef PVOID INTERLOCKEDCOMPAREEXCHANGE(PVOID*, PVOID, PVOID);
    static BOOL fKnown;
    static INTERLOCKEDCOMPAREEXCHANGE *pilock;

    if( !fKnown ) {

        //
        // hacky code to bring in InterlockedCompareExchange, since
        // Win95 doesn't export it.
        //

        HMODULE hMod = LoadLibraryA( "kernel32.dll" );

        if( hMod  ) {
            pilock = (INTERLOCKEDCOMPAREEXCHANGE*)GetProcAddress( hMod, "InterlockedCompareExchange" );
        }

        fKnown = TRUE;
    }

    if( pilock != NULL ) {
        return pilock( Destination, Exchange, Comperand );
    }


    InitialValue = *Destination;

    if ( InitialValue == Comperand ) {
        *Destination = Exchange;
    }

    return InitialValue;
}

#endif  // WIN95_RNG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\randlib\umkm.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    umkm.h

Abstract:

    Macros to simplify usermode & kernelmode shared code.

Author:

    Scott Field (sfield)    19-Sep-99

--*/

#ifndef __UMKM_H__
#define __UMKM_H__



#ifndef KMODE_RNG



#define __LOCK_TYPE     CRITICAL_SECTION

#ifdef WINNT_RNG
#define INIT_LOCK(x)    NT_SUCCESS( RtlInitializeCriticalSection( x ) )
#else

BOOLEAN
__forceinline
INIT_LOCK(
    PCRITICAL_SECTION x
    )
{
    __try {
        InitializeCriticalSection(x);
        return TRUE;
    } __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return FALSE;
    }
}
#endif

//#define INIT_LOCK(x)    InitializeCriticalSectionAndSpinCount(x, 0x333)
#define DELETE_LOCK(x)  DeleteCriticalSection(x)
#define ENTER_LOCK(x)   EnterCriticalSection(x)
#define LEAVE_LOCK(x)   LeaveCriticalSection(x)
#define ALLOC(cb)       HeapAlloc(GetProcessHeap(), 0, cb)
#define ALLOC_NP(cb)    ALLOC(cb)
#define FREE(pv)        HeapFree(GetProcessHeap(), 0, pv)

#define REGCLOSEKEY(x)  RegCloseKey( x )

#ifdef WIN95_RNG

PVOID
InterlockedCompareExchangePointerWin95(
    PVOID *Destination,
    PVOID Exchange,
    PVOID Comperand
    );

#define INTERLOCKEDCOMPAREEXCHANGEPOINTER(x,y,z)    InterlockedCompareExchangePointerWin95(x,y,z)
#else
#define INTERLOCKEDCOMPAREEXCHANGEPOINTER(x,y,z)    InterlockedCompareExchangePointer(x,y,z)
#endif  // WIN95_RNG


#else

//#define __LOCK_TYPE     KSPIN_LOCK
#define __LOCK_TYPE     ERESOURCE

#define RNG_TAG 'cesK'

//#define INIT_LOCK(x)    KeInitializeSpinLock( x )
//#define DELETE_LOCK(x)
//#define ENTER_LOCK(x)   ExAcquireSpinLock( x, &OldIrql )
//#define LEAVE_LOCK(x)   ExReleaseSpinLock( x, OldIrql )
#define ALLOC(cb)       ExAllocatePoolWithTag(PagedPool, cb, RNG_TAG)
#define ALLOC_NP(cb)    ExAllocatePoolWithTag(NonPagedPool, cb, RNG_TAG)
#define FREE(pv)        ExFreePool(pv)


#define INIT_LOCK(x)    NT_SUCCESS( ExInitializeResourceLite( x ) )
#define DELETE_LOCK(x)  ExDeleteResourceLite( x )
#define ENTER_LOCK(x)   KeEnterCriticalRegion(); ExAcquireResourceExclusiveLite( x, TRUE )
#define LEAVE_LOCK(x)   ExReleaseResourceLite( x ); KeLeaveCriticalRegion()

#define REGCLOSEKEY(x)  ZwClose( x )

#define INTERLOCKEDCOMPAREEXCHANGEPOINTER(x,y,z)    InterlockedCompareExchangePointer(x,y,z)

#endif


#endif  // __UMKM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\randlib\vlhash.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Abstract:

    Build up a "Very Large Hash" based on arbitrary sized input data
    of size cbData specified by the pvData buffer.

    This implementation updates a 640bit hash, which is internally based on
    multiple invocations of a modified SHA-1 which doesn't implement endian
    conversion internally.

Author:

    Scott Field (sfield)    24-Sep-98

--*/

#ifndef KMODE_RNG

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#else

#include <ntifs.h>
#include <windef.h>

#endif  // KMODE_RNG

#include <sha.h>

#include "vlhash.h"

#ifdef KMODE_RNG
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, VeryLargeHashUpdate)
#endif  // ALLOC_PRAGMA
#endif  // KMODE_RNG


BOOL
VeryLargeHashUpdate(
    IN      VOID *pvData,   // data from perfcounters, user supplied, etc.
    IN      DWORD cbData,
    IN  OUT BYTE VeryLargeHash[A_SHA_DIGEST_LEN * 4]
    )
{
    //
    // pointers to 1/4 size chunks of seed pointed to by VeryLargeHash
    //

    DWORD cbSeedChunk;
    PBYTE pSeed1;
    PBYTE pSeed2;
    PBYTE pSeed3;
    PBYTE pSeed4;

    //
    // pointers to 1/4 size chunks of data pointed to by pData
    //

    DWORD cbDataChunk;
    PBYTE pData1;
    PBYTE pData2;
    PBYTE pData3;
    PBYTE pData4;

    //
    // pointers to individual intermediate hash within IntermediateHashes
    //

    PBYTE IHash1;
    PBYTE IHash2;
    PBYTE IHash3;
    PBYTE IHash4;
    BYTE IntermediateHashes[ A_SHA_DIGEST_LEN * 4 ];

    //
    // pointer to output hash within VeryLargeHash buffer.
    //

    PBYTE OutputHash;

    A_SHA_CTX shaContext;


#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG

    //
    // check parameters
    //


    if( VeryLargeHash == NULL || pvData == NULL )
        return FALSE;

    //
    // break up input blocks into 1/4 size chunks.
    //


    cbSeedChunk = A_SHA_DIGEST_LEN;
    cbDataChunk = cbData / 4;

    if( cbDataChunk == 0 )
        return FALSE;


    pSeed1 = VeryLargeHash;
    pSeed2 = pSeed1 + cbSeedChunk;

    pData1 = (PBYTE)pvData;
    pData2 = pData1 + cbDataChunk;

    IHash1 = IntermediateHashes;
    IHash2 = IHash1 + A_SHA_DIGEST_LEN;

    //
    // round 1
    //

    A_SHAInit( &shaContext );
    A_SHAUpdateNS( &shaContext, pSeed1, cbSeedChunk );
    A_SHAUpdateNS( &shaContext, pData1, cbDataChunk );
    A_SHAUpdateNS( &shaContext, pSeed2, cbSeedChunk );
    A_SHAUpdateNS( &shaContext, pData2, cbDataChunk );
    A_SHAFinalNS( &shaContext, IHash1 );

    //
    // round 2
    //

    A_SHAInit( &shaContext );
    A_SHAUpdateNS( &shaContext, pSeed2, cbSeedChunk );
    A_SHAUpdateNS( &shaContext, pData2, cbDataChunk );
    A_SHAUpdateNS( &shaContext, pSeed1, cbSeedChunk );
    A_SHAUpdateNS( &shaContext, pData1, cbDataChunk );
    A_SHAFinalNS( &shaContext, IHash2 );


    pSeed3 = pSeed2 + cbSeedChunk;
    pSeed4 = pSeed3 + cbSeedChunk;

    pData3 = pData2 + cbDataChunk;
    pData4 = pData3 + cbDataChunk;

    IHash3 = IHash2 + A_SHA_DIGEST_LEN;
    IHash4 = IHash3 + A_SHA_DIGEST_LEN;

    //
    // round 3
    //

    A_SHAInit( &shaContext );
    A_SHAUpdateNS( &shaContext, pSeed3, cbSeedChunk );
    A_SHAUpdateNS( &shaContext, pData3, cbDataChunk );
    A_SHAUpdateNS( &shaContext, pSeed4, cbSeedChunk );
    A_SHAUpdateNS( &shaContext, pData4, cbDataChunk );
    A_SHAFinalNS( &shaContext, IHash3 );

    //
    // round 4
    //

    A_SHAInit( &shaContext );
    A_SHAUpdateNS( &shaContext, pSeed4, cbSeedChunk );
    A_SHAUpdateNS( &shaContext, pData4, cbDataChunk );
    A_SHAUpdateNS( &shaContext, pSeed3, cbSeedChunk );
    A_SHAUpdateNS( &shaContext, pData3, cbDataChunk );
    A_SHAFinalNS( &shaContext, IHash4 );



    //
    // round 5
    //

    OutputHash = VeryLargeHash;

    A_SHAInit( &shaContext );
    A_SHAUpdateNS( &shaContext, IHash1, A_SHA_DIGEST_LEN );
    A_SHAUpdateNS( &shaContext, IHash3, A_SHA_DIGEST_LEN );
    A_SHAFinalNS( &shaContext, OutputHash );

    //
    // round 6
    //

    OutputHash += A_SHA_DIGEST_LEN;

    A_SHAInit( &shaContext );
    A_SHAUpdateNS( &shaContext, IHash2, A_SHA_DIGEST_LEN );
    A_SHAUpdateNS( &shaContext, IHash4, A_SHA_DIGEST_LEN );
    A_SHAFinalNS( &shaContext, OutputHash );

    //
    // round 7
    //

    OutputHash += A_SHA_DIGEST_LEN;

    A_SHAInit( &shaContext );
    A_SHAUpdateNS( &shaContext, IHash3, A_SHA_DIGEST_LEN );
    A_SHAUpdateNS( &shaContext, IHash1, A_SHA_DIGEST_LEN );
    A_SHAFinalNS( &shaContext, OutputHash );

    //
    // round 8
    //

    OutputHash += A_SHA_DIGEST_LEN;

    A_SHAInit( &shaContext );
    A_SHAUpdateNS( &shaContext, IHash4, A_SHA_DIGEST_LEN );
    A_SHAUpdateNS( &shaContext, IHash2, A_SHA_DIGEST_LEN );
    A_SHAFinalNS( &shaContext, OutputHash );


    RtlSecureZeroMemory( &shaContext, sizeof(shaContext) );
    RtlSecureZeroMemory( IntermediateHashes, sizeof(IntermediateHashes) );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\randlib\vlhash.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Abstract:

    Build up a "Very Large Hash" based on arbitrary sized input data
    of size cbData specified by the pvData buffer.

    This implementation updates a 640bit hash, which is internally based on
    multiple invocations of a modified SHA-1 which doesn't implement endian
    conversion internally.

Author:

    Scott Field (sfield)    24-Sep-98

--*/

#ifndef __VLHASH_H__
#define __VLHASH_H__

BOOL
VeryLargeHashUpdate(
    IN      VOID *pvData,   // data from perfcounters, user supplied, etc.
    IN      DWORD cbData,
    IN  OUT BYTE VeryLargeHash[A_SHA_DIGEST_LEN * 4]
    );

#endif  // __VLHASH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\test\offload\offload.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : csp.c                                                  //
//  DESCRIPTION   : Crypto API interface                                   //
//					Global Stuff for CSP
//  AUTHOR        : Amit Kapoor											   //
/////////////////////////////////////////////////////////////////////////////

#undef UNICODE
#include <windows.h>
#include <fxupbn.h>

#ifdef __cplusplus
extern "C" {
#endif


// Needed for DLL
BOOLEAN DllInitialize (IN PVOID hmod,IN ULONG Reason,IN PCONTEXT Context)
{
    LoadLibrary("offload.dll");
    return( TRUE );
}

BOOL WINAPI OffloadModExpo(
                           IN BYTE *pbBase,
                           IN BYTE *pbExpo,
                           IN DWORD cbExpo,
                           IN BYTE *pbMod,
                           IN DWORD cbMod,
                           IN BYTE *pbResult,
                           IN void *pReserved,
                           IN DWORD dwFlags
                           )
{
    mp_modulus_t    *pModularMod = NULL;
    digit_t         *pbModularBase = NULL;
    digit_t         *pbModularResult = NULL;
    DWORD           dwModularLen = (cbMod + (RADIX_BYTES - 1)) / RADIX_BYTES; // dwLen is length in bytes
    BYTE            *pbTmpExpo = NULL;
    BOOL            fAlloc = FALSE;
    BOOL            fRet = FALSE;

    if (cbExpo < cbMod)
    {
        if (NULL == (pbTmpExpo = (BYTE*)LocalAlloc(LMEM_ZEROINIT, dwModularLen * RADIX_BYTES)))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }
        fAlloc = TRUE;
        memcpy(pbTmpExpo, pbExpo, cbExpo);
    }
    else
    {
        pbTmpExpo = pbExpo;
    }

    if (NULL == (pModularMod = (mp_modulus_t*)LocalAlloc(LMEM_ZEROINIT,
                                                       sizeof(mp_modulus_t))))
    {
        goto Ret;
    }
    if (NULL == (pbModularBase = (digit_t*)LocalAlloc(LMEM_ZEROINIT,
                                                MP_LONGEST * sizeof(digit_t))))
    {
        goto Ret;
    }
    if (NULL == (pbModularResult = (digit_t*)LocalAlloc(LMEM_ZEROINIT,
                                                MP_LONGEST * sizeof(digit_t))))
    {
        goto Ret;
    }

    // change values into modular form
    create_modulus((digit_tc*)pbMod, dwModularLen, FROM_RIGHT, pModularMod);
    to_modular((digit_tc*)pbBase, dwModularLen, pbModularBase, pModularMod);
    mod_exp(pbModularBase, (digit_tc*)pbTmpExpo, dwModularLen,
            pbModularResult, pModularMod);
    from_modular(pbModularResult, (digit_t*)pbResult, pModularMod);

    fRet = TRUE;
Ret:
    if (pModularMod)
        LocalFree(pModularMod);
    if (pbModularBase)
        LocalFree(pbModularBase);
    if (pbModularResult)
        LocalFree(pbModularResult);
    if (fAlloc && pbTmpExpo)
        LocalFree(pbTmpExpo);

    return fRet;
}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\xpress\xdecode.c ===
/* ------------------------------------------------------------------------ */
/*                                                                          */
/*  Copyright (c) Microsoft Corporation, 2000-2002. All rights reserved.    */
/*  Copyright (c) Andrew Kadatch, 1991-2002. All rights reserved.           */
/*                                                                          */
/*  Microsoft Confidential -- do not redistribute.                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */


#include "xprs.h"

#define ALLOCATE_ON_STACK       1

#define MAGIC_DECODE 0x35DEC0DE

typedef struct
{
  struct
  {
    uchar *end, *beg, *careful, *stop, *last;
  } dst;
  struct
  {
    const uchar *end, *beg, *careful, *end_1, *end_tag, *end_bitmask2, *last;
  }
  src;
  int result;
  int eof;
  int magic;
#if CODING & (CODING_HUFF_LEN | CODING_HUFF_PTR | CODING_HUFF_ALL)
  uint16 table[(1 << DECODE_BITS) + (HUFF_SIZE << 1)];
#endif
} decode_info;

#if CODING == CODING_BY_BIT
static int bit_to_len_initialized = 0;
static uchar bit_to_len1[1 << (9 - MIN_MATCH)];
static uchar bit_to_len2[1 << (9 - MIN_MATCH)];
static void bit_to_len_init (void)
{
  int i, k;
  if (bit_to_len_initialized) return;
  bit_to_len1[0] = 0;
  bit_to_len2[0] = 9 - MIN_MATCH;
  for (k = 1, i = 1 << (8 - MIN_MATCH); i != 0; i >>= 1, ++k)
  {
    memset (bit_to_len1 + i, k, i);
    memset (bit_to_len2 + i, k - 1, i);
  }
  bit_to_len_initialized = 1;
}
#endif

#if CODING & (CODING_HUFF_LEN | CODING_HUFF_PTR | CODING_HUFF_ALL)


static int huffman_decode_create (uint16 *table, const uchar *length)
{
  xint i, j, k, last, freq[16], sum[16];

  /* calculate number of codewords                                      */
  memset (freq, 0, sizeof (freq));
  i = HUFF_SIZE >> 1;
  do
  {
    k = length[--i];
    ++freq[k & 0xf];
    ++freq[k >> 4];
  }
  while (i != 0);

  /* handle special case(s) -- 0 and 1 symbols in alphabet              */
  if (freq[0] == HUFF_SIZE)
    goto ok;
  if (freq[0] == HUFF_SIZE - 1)
    goto bad;
#if 0
  {

    if (freq[1] != 1)
      goto bad;
    i = -1; do ++i; while (length[i] == 0);
    k = i << 1;
    if (length[i] != 1) ++k;
    i = 1 << DECODE_BITS;
    do
      *table++ = (uint16) k;
    while (--i > 0);
    goto ok;
  }
#endif

  /* save frequences                    */
  memcpy (sum, freq, sizeof (sum));

  /* check code correctness             */
  k = 0;
  i = 15;
  do
  {
    if ((k += freq[i]) & 1)
      goto bad;
    k >>= 1;
  }
  while (--i != 0);
  if (k != 1)
    goto bad;

  /* sort symbols               */
  k = 0;
  for (i = 1; i < 16; ++i)
    freq[i] = (k += freq[i]);
  last = freq[15];      /* preserve number of symbols in alphabet       */
  i = HUFF_SIZE << 4;
  do
  {
    i -= 1 << 4;
    k = length[i >> 5] >> 4;
    if (k != 0)
      table[--freq[k]] = (uint16) (k | i);
    i -= 1 << 4;
    k = length[i >> 5] & 0xf;
    if (k != 0)
      table[--freq[k]] = (uint16) (k | i);
  }
  while (i != 0);

  /* now create decoding table  */
  k = i = (1 << DECODE_BITS) + (HUFF_SIZE << 1);

  {
    xint n;
    for (n = 15; n > DECODE_BITS; --n)
    {
      j = i;
      while (k > j)
        table[--i] = (uint16) ((k -= 2) | 0x8000);
      for (k = sum[n]; --k >= 0;)
        table[--i] = table[--last];
      k = j;
    }
  }

  j = i;
  i = 1 << DECODE_BITS;
  while (k > j)
    table[--i] = (uint16) ((k -= 2) | 0x8000);

  while (last > 0)
  {
    k = table[--last];
    j = i - ((1 << DECODE_BITS) >> (k & 15));
    do
      table[--i] = (uint16) k;
    while (i != j);
  }
  assert ((i | last) == 0);

ok:
  return (1);

bad:
  return (0);
}


#endif /* CODING */

#if DEBUG > 1
#define RET_OK do {printf ("OK @ %d\n", __LINE__); goto ret_ok;} while (0)
#define RET_ERR do {printf ("ERR @ %d\n", __LINE__); goto ret_err;} while (0)
#else
#define RET_OK goto ret_ok
#define RET_ERR goto ret_err
#endif


#define GET_UINT16(x,p) x = *(__unaligned uint16 *)(p); p += 2


#define COPY_8_BYTES(dst,src) \
  dst[0] = src[0]; dst[1] = src[1]; dst[2] = src[2]; dst[3] = src[3]; \
  dst[4] = src[4]; dst[5] = src[5]; dst[6] = src[6]; dst[7] = src[7]


/* do not use "memcpy" -- it does not work properly if "dst" and "src" are close (overlap) */
#define COPY_BLOCK_SLOW(dst,src,len) \
  if (len > 8) do \
  { \
    COPY_8_BYTES (dst, src); \
    len -= 8; dst += 8; src += 8; \
  } \
  while (len > 8); \
  do \
    *dst++ = *src++, --len; \
  while (len)


#ifndef i386
#define COPY_BLOCK_FAST_8(dst,src) \
  COPY_8_BYTES (dst, src)
#else
#if 0
#define COPY_BLOCK_FAST_8(dst,src) \
  ((__unaligned uint32 *) dst)[0] = ((__unaligned uint32 *) src)[0]; \
  ((__unaligned uint32 *) dst)[1] = ((__unaligned uint32 *) src)[1]
#else
#define COPY_BLOCK_FAST_8(dst,src) \
  ((__unaligned __int64 *) dst)[0] = ((__unaligned __int64 *) src)[0]
#endif
#endif /* i386 */


#define BIORD(bits) \
  (Mask >> (sizeof (Mask) * 8 - (bits)))

#define CONCAT2(x,y) x##y
#define CONCAT(x,y) CONCAT2(x,y)

#define bits_t signed char

#define BIORD_MORE0(bits)                       \
  if ((Bits = (bits_t) (Bits - (bits))) < 0)    \
  {                                             \
    CAREFUL_ERR_IF (src >= info->src.end_1);    \
    Mask += ((ubitmask4) *(__unaligned ubitmask2 *)src) << (-Bits); \
    src += sizeof (ubitmask2);                      \
    Bits += (bits_t) (sizeof (ubitmask2) * 8);      \
  }


#define BIORD_MORE(bits)                        \
  Mask <<= (bits_t)(bits);                      \
  BIORD_MORE0 (bits)


#define BIORD_WORD(result,bits)         \
  result = 1 << (bits);                 \
  if (bits)                             \
  {                                     \
    result += BIORD (bits);             \
    BIORD_MORE (bits);                  \
  }


#define BIORD_DECODE(result,table) {     \
  bits_t __bits;                         \
  result = ((int16 *)(table))[BIORD (DECODE_BITS)]; \
  if (result < 0)                        \
  {                                      \
    Mask <<= DECODE_BITS;                \
    do                                   \
    {                                    \
      result &= 0x7fff;                  \
      if ((bitmask4) Mask < 0) ++result; \
      result = ((int16 *)(table))[result];          \
      Mask <<= 1;                        \
    }                                    \
    while (result < 0);                  \
    __bits = (bits_t)(result & 15);      \
  }                                      \
  else                                   \
  {                                      \
    __bits = (bits_t)(result & 15);      \
    Mask <<= __bits;                     \
  }                                      \
  result >>= 4;                          \
  Bits = (bits_t) (Bits - __bits);       \
}                                        \
if (Bits < 0)                            \
{                                                         \
  CAREFUL_ERR_IF (src >= info->src.end_1);                \
  if (CODING == CODING_HUFF_ALL)                          \
    {CAREFUL_IF (src >= info->src.careful, rdmore);}      \
  Mask += ((ubitmask4) *(__unaligned ubitmask2 *)src) << (-Bits); \
  src += sizeof (ubitmask2);                              \
  Bits += (bits_t) (sizeof (ubitmask2) * 8);              \
}

#if defined (_MSC_VER) && !DEBUG
#ifdef _M_IX86
#pragma optimize ("aw", off)
#else
#pragma optimize ("w", off)
#endif /* _M_IX86 */
#endif /* _MSC_VER */

#define CAREFUL 0
#include "xdecode.i"
#define CAREFUL 1
#include "xdecode.i"

#if defined (_MSC_VER) && !DEBUG
#ifdef _M_IX86
#pragma optimize ("aw", on)
#else
#pragma optimize ("w", on)
#endif /* _M_IX86 */
#endif


XPRESS_EXPORT
int
XPRESS_CALL
XpressDecode
(
  XpressDecodeStream stream,
  void              *orig,
  int                orig_size,
  int                decode_size,
  const void        *comp,
  int                comp_size
)
{
  decode_info *info;
  const uchar *src;

#if ALLOCATE_ON_STACK
  decode_info stack_info;
  info = &stack_info;
  info->src.beg = (void *) stream;
#else
  if (stream == 0 || (info = (decode_info *) stream)->magic != MAGIC_DECODE || (uint) decode_size > (uint) orig_size)
    return (-1);
#endif

  if (comp_size == orig_size)
    return (decode_size);

  if (orig_size < comp_size
    || comp_size < 0
    || orig_size <= MIN_SIZE
    || comp_size < MIN_SIZE
  )
    return (-1);

  if (orig_size > BUFF_SIZE || decode_size <= 0)
    return (decode_size);

  src = comp;
  info->dst.beg = orig;
  info->dst.end = (uchar *) orig + orig_size;
  info->dst.stop = (uchar *) orig + decode_size;
  info->src.end = src + comp_size;
  info->src.end_1 = info->src.end - 1;
  info->src.end_tag = info->src.end - (sizeof (tag_t) - 1);
  info->src.end_bitmask2 = info->src.end - (sizeof (bitmask2) - 1);

  // check bounds when we read new mask (at most 8 * sizeof (tag_t)) pointers

  // we may write at most 8 bytes without checks
  #define RESERVE_DST ((8 * 8 + 2) * sizeof (tag_t))
  info->dst.careful = info->dst.beg;
  if (info->dst.stop - info->dst.beg > RESERVE_DST)
    info->dst.careful = info->dst.stop - RESERVE_DST;

  // we may read at most 7 bytes
  #define RESERVE_SRC ((7 * 8 + 2) * sizeof (tag_t))
  info->src.careful = info->src.beg;
  if (info->src.end - info->src.beg > RESERVE_SRC)
    info->src.careful = info->src.end - RESERVE_SRC;

#if CODING & (CODING_HUFF_LEN | CODING_HUFF_PTR | CODING_HUFF_ALL)
  if (!huffman_decode_create (info->table, src))
    return (-1);
  src += HUFF_SIZE >> 1;
#endif
#if CODING == CODING_BY_BIT
  bit_to_len_init ();
#endif

  info->src.beg = src;
  info->result = 0;
  info->eof = 0;

  do_decode (info);

  if (!info->result || info->dst.last > info->dst.stop || info->src.last > info->src.end
    || (info->dst.stop == info->dst.end && !info->eof)
  )
    return (-1);

  return (decode_size);
}

XPRESS_EXPORT
XpressDecodeStream
XPRESS_CALL
XpressDecodeCreate (
  void          *context,               // user-defined context info (will  be passed to AllocFn)
  XpressAllocFn *AllocFn                // memory allocation callback
)
{
#if ALLOCATE_ON_STACK
#ifdef _M_IX86
  return ((XpressDecodeStream) 1);
#else
  return ((XpressDecodeStream) (__int64) 1);
#endif
#else
  decode_info *info;
  if (AllocFn == 0 || (info = AllocFn (context, sizeof (*info))) == 0)
    return (0);
  info->magic = MAGIC_DECODE;
  return ((XpressDecodeStream) info);
#endif
}

XPRESS_EXPORT
void
XPRESS_CALL
XpressDecodeClose (
  XpressDecodeStream stream,	// encoder's workspace
  void              *context,   // user-defined context info (will  be passed to FreeFn)
  XpressFreeFn      *FreeFn     // callback that releases the memory
)
{
#if ALLOCATE_ON_STACK
  /* do nothing */
#else
  if (FreeFn != 0 && stream != 0 && ((decode_info *) stream)->magic == MAGIC_DECODE)
  {
    ((decode_info *) stream)->magic = 0;
    FreeFn (context, stream);
  }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\test\stress\strestst.h ===
#ifndef __STRESTST__H__
#define __STRESTST__H__

#include <windows.h>
#include <wincrypt.h>

#define APP_NAME                        "cspstres"
#define KEY_CONTAINER_NAME              "CspStressKey"
#define ERROR_CAPTION                   "ERROR : cspstres " 
#define STRESS_DEFAULT_THREAD_COUNT     8
#define MAX_THREADS                     MAXIMUM_WAIT_OBJECTS
#define PLAIN_BUFFER_SIZE               30000
#define HASH_DATA_SIZE                  14999
#define SIGN_DATA_SIZE                  999
#define PROV_PARAM_BUFFER_SIZE          256
#define RSA_AES_CSP                     "rsaaes.dll"

#define ENUMERATE_REGISTERED_CSP        -1

#define GENERIC_FAIL(X)                 { \
    sprintf(szErrorMsg, "%s error 0x%x\n", #X, GetLastError()); \
    MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR); \
    goto ErrorReturn ; \
}

#define ALLOC_FAIL(X)                   { \
    sprintf(szErrorMsg, "%s alloc error 0x%x\n", #X, GetLastError()); \
    MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR); \
    goto ErrorReturn; \
}

#define DW_INUSE                        0
#define DW_HASH_ALGID                   1
#define DW_END_CERT_INDEX               2

//
// Struct: ALGNODE
// Purpose: A linked list of CSP algorithms
//
typedef struct _ALGNODE
{
    struct _ALGNODE *pNext;
    PROV_ENUMALGS_EX EnumalgsEx;
} ALGNODE, *PALGNODE;

//
// Struct: THREAD_DATA
// Purpose: This is the data passed to the entry point
// shared by each of the worker/test threads.
//
typedef struct _THREAD_DATA
{
    DWORD rgdwThreadStatus[MAX_THREADS];
    DWORD dwThreadCount;
    DWORD dwProgramMins;
    PALGNODE pAlgList;
    CHAR rgszProvName[MAX_PATH];
    DWORD dwProvType;
    BOOL fEphemeralKeys;
    BOOL fUserProtectedKeys;
    HCRYPTPROV hProv;
    HCRYPTPROV hVerifyCtx;
    HCRYPTKEY hExchangeKey;
    HCRYPTKEY hSignatureKey;
    HANDLE hEndTestEvent;

    CRITICAL_SECTION CSThreadData;
    DWORD dwThreadID; // Not thread safe
    DWORD dwTestsToRun;

    BOOL fSkipPinAttackTest;
} THREAD_DATA, *PTHREAD_DATA;

// ************
// Stress Tests
// ************

#define RUN_THREAD_SIGNATURE_TEST                   0x00000001
#define RUN_STRESS_TEST_ALL_ENCRYPTION_ALGS         0x00000002
#define RUN_THREAD_HASHING_TEST                     0x00000004
#define RUN_THREAD_ACQUIRE_CONTEXT_TEST             0x00000008
#define RUN_ALL_TESTS                               0xffffffff

//
// Function: StressGetDefaultThreadCount
// Purpose: Return the default number of worker/test threads to be 
// created by a stress test.  This will be equal to the number
// of processors on the host system, unless there's only one, in
// which case the value returned will be STRESS_DEFAULT_THREAD_COUNT.
// 
DWORD StressGetDefaultThreadCount(void);

// *****************
// Memory management
// *****************

//
// Function: MyAlloc
// Purpose: Wrapper for calling thread-safe HeapAlloc 
// with default params.
//
LPVOID MyAlloc(SIZE_T);

//
// Function: MyFree
// Purpose: Wrapper for calling thread-safe HeapFree
// with default params.
//
BOOL MyFree(LPVOID);

//
// Function: PrintBytes
//
void PrintBytes(LPSTR pszHdr, BYTE *pb, DWORD cbSize);

// ***************
// Encryption Test
// ***************

//
// Struct: ENCRYPTION_TEST_DATA
// Purpose: Parameters for the StressEncryptionTest function.
//
typedef struct _ENCRYPTION_TEST_DATA
{
    ALG_ID aiEncryptionKey;

    ALG_ID aiHash;
    ALG_ID aiHashKey;
} ENCRYPTION_TEST_DATA, *PENCRYPTION_TEST_DATA;

// ****************
// Regression Tests
// ****************

typedef DWORD (*PREGRESSION_TEST)(PTHREAD_DATA);

typedef struct _REGRESS_TEST_TABLE_ENTRY
{
    PREGRESSION_TEST pfTest;
    DWORD dwExclude;
    LPSTR pszDescription;
} REGRESS_TEST_TABLE_ENTRY, *PREGRESS_TEST_TABLE_ENTRY;

DWORD KeyArchiveRegression(PTHREAD_DATA pThreadData);
DWORD PlaintextBlobRegression(PTHREAD_DATA pThreadData);
DWORD LoadAesCspRegression(PTHREAD_DATA pThreadData);
DWORD DesImportRegression(PTHREAD_DATA pThreadData);
DWORD KnownBlockCipherKeyRegression(PTHREAD_DATA pThreadData);
DWORD PinCacheRegression(PTHREAD_DATA pThreadData);
DWORD DesGetKeyParamRegression(PTHREAD_DATA pThreadData);
DWORD MacEncryptRegression(IN PTHREAD_DATA pThreadData);
DWORD HmacRegression(PTHREAD_DATA pThreadData);
DWORD UnalignedImportExportRegression(PTHREAD_DATA pThreadData);
DWORD CFBCipherModeRegression(PTHREAD_DATA pThreadData);
DWORD AESMonteCarloCBCRegression(PTHREAD_DATA pThreadData);
DWORD AesDeriveKeyRegression(PTHREAD_DATA pThreadData);
DWORD NewShaModesHmacRegression(PTHREAD_DATA pThreadData);
DWORD NewShaModesBasicRegression(PTHREAD_DATA pThreadData);
DWORD NewShaModesSigningRegression(PTHREAD_DATA pThreadData);
DWORD NewShaModesHashSessionKeyRegression(PTHREAD_DATA pThreadData);
DWORD NewShaModesDeriveKeyRegression(PTHREAD_DATA pThreadData);

static const REGRESS_TEST_TABLE_ENTRY g_rgRegressTests [] = {
    { KeyArchiveRegression,             0,  "KeyArchiveRegression for CRYPT_ARCHIVABLE flag" },
    { PlaintextBlobRegression,          0,  "PlaintextBlobRegression for PLAINTEXTKEYBLOB blob type" },
    { LoadAesCspRegression,             0,  "LoadAesCspRegression for DllInitialize" },
    { DesImportRegression,              0,  "DesImportRegression for parity and non-parity key sizes" },
    { KnownBlockCipherKeyRegression,    0,  "KnownBlockCipherKeyRegression for CSP compatibility"},
    { PinCacheRegression,               0,  "PinCacheRegression for smart-card pin caching lib"},
    { DesGetKeyParamRegression,         0,  "DesGetKeyParamRegression for des KP_KEYLEN and KP_EFFECTIVE_KEYLEN" },
    { MacEncryptRegression,             0,  "MacEncryptRegression for simultaneous encrypt/decrypt and MAC" },
    { HmacRegression,                   0,  "HmacRegression for CRYPT_IPSEC_HMAC_KEY processing" },
    { UnalignedImportExportRegression,  0,  "UnalignedImportExportRegression for key blob alignment" },
    { CFBCipherModeRegression,          0,  "CFBCipherModeRegression for cipher feedback mode" },
//    { AESMonteCarloCBCRegression,       0,  "AESMonteCarloCBCRegression for AES CBC mode cipher" },
    { AesDeriveKeyRegression,           0,  "AesDeriveKeyRegression for AES CryptDeriveKey" },
    { NewShaModesBasicRegression,       0,  "NewShaModesBasicRegression for new SHA mode vectors" },
    { NewShaModesHmacRegression,        0,  "NewShaModesHmacRegression for new SHA HMAC vectors" },
    { NewShaModesSigningRegression,     0,  "NewShaModesSigningRegression for new SHA mode RSA signing" },
    { NewShaModesHashSessionKeyRegression,
                                        0,  "NewShaModesHashSessionKeyRegression for new SHA modes with CryptHashSessionKey" },
    { NewShaModesDeriveKeyRegression,   0,  "NewShaModesDeriveKeyRegression for AES keys derived from new SHA mode hashes" }
};

static const unsigned g_cRegressTests = 
    sizeof(g_rgRegressTests) / sizeof(REGRESS_TEST_TABLE_ENTRY);
 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\xpress\xencode.c ===
/* ------------------------------------------------------------------------ */
/*                                                                          */
/*  Copyright (c) Microsoft Corporation, 2000-2002. All rights reserved.    */
/*  Copyright (c) Andrew Kadatch, 1991-2002. All rights reserved.           */
/*                                                                          */
/*  Microsoft Confidential -- do not redistribute.                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */

#include "xprs.h"

#define MAX_CHAIN       9

#define FILL_NULL	0	// fill q_hash buffer with NULLs or with &orig[0]


// Zobrist hashing
#define Z_HASH_SIZE_LOG    (BUFF_SIZE_LOG - 1)
#define Z_HASH_SIZE        (1 << Z_HASH_SIZE_LOG)
#define Z_HASH_SUM(b)      (z_hash_map[0][b[0]] ^ z_hash_map[1][b[1]] ^ z_hash_map[2][b[2]])

// quick hashing
#define Q_HASH_SH1      3
#define Q_HASH_SH2      (Q_HASH_SH1 >> 1)
#define Q_HASH_SUM3(c1,c2,c3) (((c1) << Q_HASH_SH1) + ((c2) << Q_HASH_SH2) + (c3))
#define Q_HASH_SUM(b)   Q_HASH_SUM3 (b[0], b[1], b[2])
#define Q_HASH_SIZE     (Q_HASH_SUM3 (255, 255, 255) + 1)

#define z_hash_t uint16
#define z_index_t uint16

#if CODING & (CODING_HUFF_LEN | CODING_HUFF_PTR | CODING_HUFF_ALL)
typedef struct huff_node_t huff_node;

struct huff_node_t
{
  huff_node *son[2];
  uxint freq;
  uint16 ch;
  uint16 bits;
};

typedef struct
{
  huff_node buff[2 * HUFF_SIZE], *head[256], **link[256];
} huff_info;
#endif

typedef struct
{
  struct
  {
#if CODING == CODING_BY_BIT
    xint bits;
    uchar *ptr;
#elif CODING & (CODING_DIRECT | CODING_DIRECT2)
    uchar *ptr;
#elif CODING & (CODING_HUFF_LEN | CODING_HUFF_PTR | CODING_HUFF_ALL)
    uxint freq[HUFF_SIZE];
    uxint mask[HUFF_SIZE];
    uchar bits[HUFF_SIZE];
    huff_info info;
    uxint pointers;
    uxint extra;
    uxint masks;
#endif /* CODING */
  } stat;
  xint chain;
  xint max_size;
  struct
  {
    uchar *beg;
    uchar *ptr;
  } comp;
  struct
  {
    uchar *beg;
    uchar *ptr;
    uchar *tag_ptr;
    tag_t  tag_mask;
    xint   chain;
  } temp;
  struct
  {
    xint len;
    xint pos;
  } match;
  struct
  {
    xint   pos;
    xint   size;
    xint   stop;
    xint   progress;
    const uchar *ptr;
    const uchar *end;
    const uchar *end_16;
    const uchar *end_3;
    const uchar *ptr_stop;
  } orig;
} context;


#define v p[-1].c

typedef struct
{
  union
  {
    z_index_t    z_hash[Z_HASH_SIZE];
    z_index_t    z_next[16];
    const uchar *q_last[16];
  } x;

  context c;
} prs;

#define MAGIC_ENCODE   0x53E7C0DE

typedef struct
{
  int      magic;
  void    *memory;
  prs     *p;
  uchar   *temp;
  unsigned max_size;
  int      chain;
  int      max_chain;
} xpress_info;


#if MAX_CHAIN >= 1
static z_hash_t z_hash_map[MIN_MATCH][256];
static int      z_hash_map_initialized = 0;

static void z_hash_map_init (void)
{
  long v1, v2;
  z_hash_t *m;

  if (z_hash_map_initialized)
    return;

  v1 = 0x13579bdfL; v2 = 0x87654321L;
  for (m = z_hash_map[0]; m < z_hash_map[0] + sizeof (z_hash_map) / sizeof (z_hash_map[0][0]); ++m)
  {
    long vv1 = v2, vv2 = v1, d = 0;
    xint i = 32;
    do
    {
      d += 0x9e3779b9L; vv1 += d; vv2 += d;
      v1 += ((v2<<3) + vv1) ^ (v2 + d) ^ ((v2>>5) + vv2);
      v2 += ((v1<<3) + vv2) ^ (v1 + d) ^ ((v1>>5) + vv1);
      --i;
    }
    while (i);
    *m = (z_hash_t) ((v1 += v2) & (Z_HASH_SIZE - 1));
  }

  z_hash_map_initialized = 1;
}

static void z_hash_insert (prs *p)
{
  const uchar *b, *e;
  xint n, h;

  e = v.orig.end - (MIN_MATCH-1);
  b = v.orig.ptr;
  n = 0;
  for (; b < e; ++b, ++n)
  {
    h = Z_HASH_SUM (b);
    p->x.z_next[n] = p[-1].x.z_hash[h];
    p[-1].x.z_hash[h] = (z_index_t) n;
  }
  e += MIN_MATCH-1;
  for (; b < e; ++b, ++n)
    p->x.z_next[n] = 0;
}
#endif

#if CODING != CODING_BY_BIT

static void tag_write_start (prs *p)
{
  v.temp.tag_ptr = v.temp.ptr;
  v.temp.ptr += sizeof (v.temp.tag_mask);
  v.temp.tag_mask = 1;
}

#if CODING == CODING_HUFF_ALL
#define INC_MASKS ++v.stat.masks
#else
#define INC_MASKS
#endif

#define tag_write(p,ptr,n)                       \
{                                                \
  tag_t __n = n | (v.temp.tag_mask << 1);        \
  if (v.temp.tag_mask < 0)                       \
  {                                              \
    *(__unaligned tag_t *) v.temp.tag_ptr = __n; \
    v.temp.tag_ptr = ptr;                        \
    ptr += sizeof (v.temp.tag_mask);             \
    INC_MASKS;                                   \
    __n = 1;                                     \
  }                                              \
  v.temp.tag_mask = __n;                         \
}

static void tag_write_finish (prs *p)
{
  uchar *ptr = v.temp.ptr;
  do
  {
    tag_write (p, ptr, 1);
  }
  while (ptr == v.temp.ptr);
}

#elif CODING == CODING_BY_BIT

static void tag_write_start (prs *p)
{
  v.temp.tag_ptr = (uchar *) &v.temp.tag_mask;
  v.temp.tag_mask = 0;
  v.stat.bits = 0;
}

#define tag_write(p,ptr,n) do { \
  if (--v.stat.bits < 0) \
  { \
    *(__unaligned tag_t *)v.temp.tag_ptr = v.temp.tag_mask; \
    v.temp.tag_mask = n; \
    v.stat.bits = 8 * sizeof (v.temp.tag_mask) - 1; \
    v.temp.tag_ptr = ptr; \
    ptr += sizeof (v.temp.tag_mask); \
  } \
  v.temp.tag_mask = (v.temp.tag_mask << 1) + (n); \
} while (0)

#define tag_write_mask(p,ptr,n,b) do { \
  if ((v.stat.bits -= (b)) < 0) \
  { \
    *(__unaligned tag_t *)v.temp.tag_ptr = (v.temp.tag_mask << ((b) + v.stat.bits)) \
      + ((n) >> (-v.stat.bits)); \
    v.stat.bits += 8 * sizeof (v.temp.tag_mask); \
    v.temp.tag_mask = (n); \
    v.temp.tag_ptr = ptr; \
    ptr += sizeof (v.temp.tag_mask); \
  } \
  else \
    v.temp.tag_mask = (v.temp.tag_mask << (b)) + (n); \
} while  (0);

static void tag_write_finish (prs *p)
{
  do
    tag_write (p, v.temp.ptr, 1);
  while (v.stat.bits != 0);
  *(__unaligned tag_t *)v.temp.tag_ptr = v.temp.tag_mask;
}

#define write_lit(p,ptr,ch) do {   \
  tag_write (p, ptr, 0);           \
  *ptr++ = (ch);                   \
} while (0)                      

INLINE uchar *write_ptr (prs *p, uchar *ptr, xint offset, xint length)
{
  uxint k;

  --offset;

  k = 2;
  if (offset > 255) k = 3;
  tag_write_mask (p, ptr, k, 2);
  *ptr++ = (uchar) offset;
  if (offset > 255) *ptr++ = (uchar) (offset >>= 8);

  if (length <= 8)
  {
    length -= MIN_MATCH - 1;
    tag_write_mask (p, ptr, 1, length);
  }
  else
  {
    tag_write_mask (p, ptr, 0, (9 - MIN_MATCH));
    if ((length -= 9) < 15)
    {
      if (v.stat.ptr == 0)
      {
        v.stat.ptr = ptr;
        *ptr++ = (uchar) length;
      }
      else
      {
        v.stat.ptr[0] |= length << 4;
        v.stat.ptr = 0;
      }
    }
    else
    {
      length -= 15;
      if (v.stat.ptr == 0)
      {
        v.stat.ptr = ptr;
        *ptr++ = 15;
      }
      else
      {
        v.stat.ptr[0] += 0xf0;
        v.stat.ptr = 0;
      }
      *ptr++ = (uchar) length;
      if (length >= 255)
      {
        ptr[-1] = 255;
        ptr[0] = (uchar) length;
        ptr[1] = (uchar) (length >>= 8);
        ptr += 2;
      }
    }
  }

  return (ptr);
}

#endif

#if CODING & (CODING_DIRECT | CODING_DIRECT2)

#define write_lit(p,ptr,ch) do {   \
  *ptr++ = (ch);                   \
  tag_write (p, ptr, 0);           \
} while (0)

#ifndef i386
INLINE uchar *write_ptr (prs *p, uchar *ptr, int offset, int length)
{
  length -= MIN_MATCH;
  --offset;

#if CODING == CODING_DIRECT2
  offset <<= DIRECT2_LEN_LOG;
  if (length < DIRECT2_MAX_LEN)
  {
    offset |= length;
    ptr[0] = (uchar) offset;
    ptr[1] = (uchar) (offset >>= 8);
    ptr += 2;
  }
  else
  {
    offset |= DIRECT2_MAX_LEN;
    length -= DIRECT2_MAX_LEN;
    ptr[0] = (uchar) offset;
    ptr[1] = (uchar) (offset >>= 8);
    ptr += 2;
    if (v.stat.ptr == 0)
    {
      v.stat.ptr = ptr;
      *ptr++ = (uchar) (length < 15 ? length : 15);
    }
    else
    {
      v.stat.ptr[0] |= (uchar) ((length < 15 ? length : 15) << 4);
      v.stat.ptr = 0;
    }
    if ((length -= 15) >= 0)
    {
      *ptr++ = (uchar) length;
      if (length >= 255)
      {
        ptr[-1] = 255;
        length += DIRECT2_MAX_LEN + 15;
        ptr[0] = (uchar) length;
        ptr[1] = (uchar) (length >>= 8);
        ptr += 2;
      }
    }
  }
#elif CODING == CODING_DIRECT
  if (v.stat.ptr == 0)
  {
    if (length < 7)
    {
      length <<= 5;
      v.stat.ptr = ptr;
    short_len:
      ptr[0] = (uchar) length;
      ptr[1] = (uchar) offset;
      ptr += 2;
      if (offset > 255)
      {
        ptr[0] = (uchar) (offset >>= 8);
        ptr[-2] = (uchar) (length += 16);
        ptr += 1;
      }
    }
    else if (length < 15 + 7)
    {
      length += (14 << 4) - 7;
      goto short_len;
    }
    else
    {
      if (offset > 255)
        ptr[0] = 0xff;
      else
        ptr[0] = 0xef;
    long_len:
      ptr[1] = (uchar) (length -= (7 + 15));
      ptr += 2;
      if (length >= 255)
      {
        length += 7 + 15;
        ptr[-1] = 255;
        ptr[0] = (uchar) (length);
        ptr[1] = (uchar) (length >>= 8);
        ptr += 2;
      }
      *ptr++ = (uchar) offset;
      if (offset > 255)
        *ptr++ = (uchar) (offset >>= 8);
    }
  }
  else
  {
    if (length < 7)
    {
      length |= v.stat.ptr[0];
      *ptr++ = (uchar) offset;
      if (offset > 255)
      {
        *ptr++ = (uchar) (offset >>= 8);
        length |= 8;
      }
      v.stat.ptr[0] = (uchar) length;
      v.stat.ptr = 0;
    }
    else if (length < 15 + 7)
    {
      length -= 7;
      ptr[1] = (uchar) offset;
      ptr[0] = (uchar) (length <<= 4);
      if (offset > 255)
      {
        v.stat.ptr[0] |= 15;
        v.stat.ptr = ptr;
        ptr[2] = (uchar) (offset >>= 8);
        ptr += 3;
      }
      else
      {
        v.stat.ptr[0] |= 7;
        v.stat.ptr = ptr;
        ptr += 2;
      }
    }
    else
    {
      if (offset > 255)
        v.stat.ptr[0] |= 15;
      else
        v.stat.ptr[0] |= 7;
      v.stat.ptr = ptr;
      ptr[0] = 15 << 4;
      goto long_len;
    }
  }
#endif /* CODING */

  tag_write (p, ptr, 1);

  return (ptr);
}
#endif /* i386 */


#elif CODING & (CODING_HUFF_LEN | CODING_HUFF_PTR | CODING_HUFF_ALL)

#if CODING == CODING_HUFF_ALL
#define write_lit(p,ptr,ch) do {    \
  ++v.stat.freq[*ptr++ = (ch)]; \
  tag_write (p, ptr, 0);            \
} while (0)
#else
#define write_lit(p,ptr,ch) do {   \
  *ptr++ = (ch);                   \
  tag_write (p, ptr, 0);           \
} while (0)
#endif

#define BIOWR(mask,bits) {                                      \
  assert (((mask) >> (bits)) == 0);                             \
  if ((Bits -= (bits)) < 0)                                     \
  {                                                             \
    *(__unaligned bitmask2 *)Ptr1 = (bitmask2) ((Mask << (Bits + (bits))) \
      + ((mask) >> (-Bits)));                                   \
    Mask = (mask);                                              \
    Bits += sizeof (ubitmask2) * 8;                             \
    Ptr1 = Ptr2;                                                \
    Ptr2 = (ubitmask2 *) ptr;                                   \
    ptr += sizeof (ubitmask2);                                  \
  }                                                             \
  else                                                          \
    Mask = (Mask << (bits)) + (mask);                           \
}


#if CODING == CODING_HUFF_LEN

INLINE uchar *write_ptr (prs *p, uchar *ptr, int offset, int length)
{
  xint k;

  ++v.stat.pointers;

  length -= MIN_MATCH;
  --offset;

  k = 0; if (offset > 255) k = 1;

  if (length < MAX_LENGTH - 1)
    ++v.stat.freq[*ptr++ = (uchar) (k |= length << 1)];
  else
  {
    length -= MAX_LENGTH - 1;
    ++v.stat.freq[ptr[0] = (uchar) (k |= (MAX_LENGTH - 1) << 1)];
    ptr[1] = (uchar) length;
    ptr += 2;
    if (length >= 255)
    {
      ptr[-1] = 255;
      length += MAX_LENGTH - 1;
      ptr[0] = (uchar) length;
      ptr[1] = (uchar) (length >>= 8);
      ptr += 2;
    }
  }

  *ptr++ = (uchar) offset;
  if (offset > 255)
    *ptr++ = (uchar) (offset >>= 8);

  tag_write (p, ptr, 1);

  return (ptr);
}

static void encode_pass2 (prs *p)
{
  xint Bits;
  ubitmask4 Mask;
  ubitmask2 *Ptr1, *Ptr2;
  tag_t bmask;
  uchar *src = v.temp.beg;
  uchar *ptr = v.comp.ptr;
  uxint k;

  Ptr1 = (ubitmask2 *) ptr; ptr += sizeof (ubitmask2);
  Ptr2 = (ubitmask2 *) ptr; ptr += sizeof (ubitmask2);
  Mask = 0;
  Bits = 8 * sizeof (ubitmask2);
  bmask = 0;
  goto start;

next:
  if (bmask >= 0)
  {
    bmask <<= 1;
  copy_byte:
    *ptr++ = *src++;
    goto next;
  }

  if ((bmask <<= 1) == 0)
  {
  start:
    *(__unaligned tag_t *)ptr = bmask = *(__unaligned tag_t *)src;
    src += sizeof (tag_t);
    ptr += sizeof (tag_t);
    if (bmask >= 0)
    {
      bmask = (bmask << 1) + 1;
      goto copy_byte;
    }
    bmask = (bmask << 1) + 1;
  }

  if (src >= v.temp.ptr)
    goto done;

  k = *src++;
  assert (k < HUFF_SIZE);
  BIOWR (v.stat.mask[k], v.stat.bits[k]);

  if (k >= ((MAX_LENGTH - 1) << 1))
  {
    if ((*ptr++ = *src++) == 255)
    {
      ptr[0] = src[0];
      ptr[1] = src[1];
      src += 2;
      ptr += 2;
    }
  }

  *ptr++ = *src++;
  if (k & 1) *ptr++ = *src++;
  goto next;

done:
  *Ptr1 = (ubitmask2) (Mask <<= Bits);
  *Ptr2 = 0;
  v.comp.ptr = ptr;
  assert (src == v.temp.ptr);
}

#elif CODING & (CODING_HUFF_PTR | CODING_HUFF_ALL)

#if CODING == CODING_HUFF_ALL
#define CODING_ADJUST(n) (256 + (n))
#else
#define CODING_ADJUST(n) (n)
#endif


#if !defined (i386) || CODING != CODING_HUFF_ALL

#define MAX_BITNO_LOG   8
#define MAX_BITNO       (1 << MAX_BITNO_LOG)

static uchar bitno_table[MAX_BITNO];
static int bitno_table_initialized = 0;

static void bitno_init (void)
{
  int i, k, n;
  if (bitno_table_initialized)
    return;
  bitno_table[0] = 255;
  for (i = 0; i < MAX_BITNO_LOG; ++i)
  {
    for (n = (k = 1<<i) << 1; k < n; ++k)
      bitno_table[k] = (uchar) i;
  }
  bitno_table_initialized = 1;
}

static int bitno (uxint n)
{
  assert (n != 0 && (n >> (MAX_BITNO_LOG*2)) == 0);
  if (n >= MAX_BITNO)
    return (bitno_table[n >> MAX_BITNO_LOG] + MAX_BITNO_LOG);
  return (bitno_table[n]);
}

INLINE uchar *write_ptr (prs *p, uchar *ptr, int offset, int length)
{
  xint k;

  k = bitno (offset);
  length -= MIN_MATCH;
  offset ^= 1 << k;

  v.stat.pointers += 2;
  v.stat.extra += k;

  k <<= MAX_LENGTH_LOG;
  if (length < MAX_LENGTH - 1)
  {
    k |= length;
    *ptr++ = (uchar) k;
    ++v.stat.freq[CODING_ADJUST (k)];
  }
  else
  {
    k |= MAX_LENGTH - 1;
    length -= MAX_LENGTH - 1;
    ptr[0] = (uchar) k;
    ++v.stat.freq[CODING_ADJUST (k)];
    ptr[1] = (uchar) length;
    ptr += 2;
    if (length >= 255)
    {
      length += MAX_LENGTH - 1;
      ptr[-1] = 255;
      ptr[0] = (uchar) length;
      ptr[1] = (uchar) (length >>= 8);
      ptr += 2;
    }
  }

  *ptr++ = (uchar) offset;
  if (k >= (9 << MAX_LENGTH_LOG))
  {
    v.stat.pointers += 1;
    *ptr++ = (uchar) (offset >>= 8);
  }

  tag_write (p, ptr, 1);

  return (ptr);
}

static void encode_pass2 (prs *p)
{
  xint Bits;
  uxint Mask;
  ubitmask2 *Ptr1, *Ptr2;
  tag_t bmask;
  uchar *src = v.temp.beg;
  uchar *ptr = v.comp.ptr;
  uxint k;

  Ptr1 = (ubitmask2 *) ptr; ptr += sizeof (ubitmask2);
  Ptr2 = (ubitmask2 *) ptr; ptr += sizeof (ubitmask2);
  Mask = 0;
  Bits = 8 * sizeof (ubitmask2);
  bmask = 0;
  goto start;

next:
  if (bmask >= 0)
  {
    bmask <<= 1;
  copy_byte:
#if CODING == CODING_HUFF_ALL
    k = *src++;
    BIOWR (v.stat.mask[k], v.stat.bits[k]);
#elif CODING == CODING_HUFF_PTR
    *ptr++ = *src++;
#endif
    goto next;
  }

  if ((bmask <<= 1) == 0)
  {
  start:
    bmask = *(__unaligned tag_t *)src;
    src += sizeof (tag_t);
#if CODING == CODING_HUFF_PTR
    *(__unaligned tag_t *)ptr = bmask;
    ptr += sizeof (tag_t);
#endif
    if (bmask >= 0)
    {
      bmask = (bmask << 1) + 1;
      goto copy_byte;
    }
    bmask = (bmask << 1) + 1;
  }

  if (src >= v.temp.ptr)
    goto done;

  k = *src++;
  assert (k < HUFF_SIZE);
  BIOWR (v.stat.mask[CODING_ADJUST (k)], v.stat.bits[CODING_ADJUST (k)]);

  if ((k & (MAX_LENGTH - 1)) == MAX_LENGTH - 1)
  {
    if ((*ptr++ = *src++) == 255)
    {
      ptr[0] = src[0];
      ptr[1] = src[1];
      src += 2;
      ptr += 2;
    }
  }

  k >>= MAX_LENGTH_LOG;
  {
    uxint m = *src++;
    if (k > 8)
      m += *src++ << 8;
    BIOWR (m, k);
  }
  goto next;

done:
#if CODING == CODING_HUFF_ALL
  BIOWR (v.stat.mask[CODING_ADJUST(0)], v.stat.bits[CODING_ADJUST(0)]);
#endif
  *(__unaligned bitmask2 *)Ptr1 = (ubitmask2) (Mask <<= Bits);
  *(__unaligned bitmask2 *)Ptr2 = 0;
  v.comp.ptr = ptr;
  assert (src == v.temp.ptr);
}

#else /* !defined (i386) || CODING != CODING_HUFF_ALL */

#define TEMP	eax
#define TEMPB	al

#define PRS	ebx
#define V       [PRS - SIZE prs] prs.c

#define TAG	edx
#define TAGW	dx
#define TAGB	dl

#define PTR1	edi
#define SRC	esi
#define MASK	ebp
#define MASKW	bp
#define PTR	esp
#define PTR2	esp + 4
#define TAGS	esp + 8


static void encode_pass2 (prs *PrsPtr)
{
    __asm
    {
	push	ebp
	sub	esp, 12

/*
  uchar *src = v.temp.beg;
  uchar *ptr = v.comp.ptr;
  Ptr1 = (ubitmask2 *) ptr; ptr += sizeof (ubitmask2);
  Ptr2 = (ubitmask2 *) ptr; ptr += sizeof (ubitmask2);
*/
	mov	PRS, PrsPtr
	mov	PTR1, V.comp.ptr
	mov	SRC, V.temp.beg
	lea	TEMP, [PTR1 + 2]
	mov	[PTR2], TEMP
	add	TEMP, 2
	mov	[PTR], TEMP

/*
  Mask = 0;
  Bits = 8 * sizeof (ubitmask2);
  bmask = 0;
*/
	xor	MASK, MASK
	mov	ch, 16
	xor	TAG, TAG
	jmp	ReloadTag

Literal:
/*
    k = *src++;
    BIOWR (v.stat.mask[k], v.stat.bits[k]);
*/
	mov	TEMP, V.stat.mask[TEMP*4]
	shl	MASK, cl
	inc	SRC
	add	MASK, TEMP
	sub	ch, cl
	jge	BiowrDone_Literal

	mov	cl, ch
	add	ch, 16
	mov	TEMP, [PTR]
	rol	MASK, cl		// attention! 286+ masks shift cound mod 32
	mov	[PTR1], MASKW
	mov	PTR1, [PTR2]
	ror	MASK, cl
	mov	[PTR2], TEMP
	add	TEMP, 2
	mov	[PTR], TEMP

BiowrDone_Literal:

	movzx	TEMP, byte ptr [SRC]
	add	TAG, TAG
	mov	cl, V.stat.bits[TEMP]
	jnc	Literal
	jz	ReloadTag

Pointer:
/*
  if (src >= v.temp.ptr)
    goto done;
*/
	mov	cl, V.stat.bits[TEMP + 256]
	mov	[TAGS], TAG

	cmp	SRC, V.temp.ptr
	jae	Done

/*
  k = *src++;
  assert (k < HUFF_SIZE);
  BIOWR (v.stat.mask[CODING_ADJUST (k)], v.stat.bits[CODING_ADJUST (k)]);
*/

	shl	MASK, cl
	mov	TAGB, TEMPB
	add	MASK, V.stat.mask[TEMP*4 + 256*4]
	mov	TEMP, [PTR]
	sub	ch, cl
	jge	BiowrDone_Pointer

	mov	cl, ch
	add	ch, 16
	rol	MASK, cl		// attention! 286+ masks shift cound mod 32
	mov	[PTR1], MASKW
	mov	PTR1, [PTR2]
	ror	MASK, cl
	mov	[PTR2], TEMP
	add	TEMP, 2

BiowrDone_Pointer:

	mov	cl, TAGB		// release TEMP for LongLength
	and	TAGB, MAX_LENGTH-1
	shr	cl, MAX_LENGTH_LOG

/*
  if ((k & (MAX_LENGTH - 1)) == MAX_LENGTH - 1)
  {
    if ((*ptr++ = *src++) == 255)
    {
      ptr[0] = src[0];
      ptr[1] = src[1];
      src += 2;
      ptr += 2;
    }
  }
*/
	cmp	TAGB, MAX_LENGTH-1
	je	LongLength
LengthWritten:

/*
  k >>= MAX_LENGTH_LOG;
  {
    uxint m = src[1];
    if (k > 8)
    {
      m += src[2] << 8;
      ++src;
    }
    BIOWR (m, k);
  }
  src += 2;
*/
	movzx	TAG, byte ptr [SRC + 1]
	shl	MASK, cl
	cmp	cl, 8
	jbe	GotOffset
	movzx	TAG, word ptr [SRC + 1]
	inc	SRC
GotOffset:

	add	MASK, TAG
	sub	ch, cl
	jge	BiowrDone_Offset

	mov	cl, ch
	add	ch, 16
	rol	MASK, cl		// attention! 286+ masks shift cound mod 32
	mov	[PTR1], MASKW
	mov	PTR1, [PTR2]
	ror	MASK, cl
	mov	[PTR2], TEMP
	add	TEMP, 2

BiowrDone_Offset:

	mov	TAG, [TAGS]
	add	SRC, 2
	mov	[PTR], TEMP

	movzx	TEMP, byte ptr [SRC]
	add	TAG, TAG
	mov	cl, V.stat.bits[TEMP]
	jnc	Literal
	jnz	Pointer
	jmp	ReloadTag

	align	16
ReloadTag:
	mov	TAG, [SRC]
	movzx	TEMP, byte ptr [SRC + 4]
	add	SRC, 4
	test	TAG, TAG
	mov	cl, V.stat.bits[TEMP]
	lea	TAG, [TAG*2 + 1]
	jge	Literal
	jmp	Pointer

/*
    if ((*ptr++ = *++src) == 255)
    {
      ptr[0] = src[1];
      ptr[1] = src[2];
      src += 2;
      ptr += 2;
    }
*/

#if _MSC_VER >= 1300
	align	16			// workaround bug in VC 6.0 back end (incorrect jump offset generation)
#endif /* _MSC_VER >= 1300 */

LongLength:
	mov	TAGB, [SRC + 1]
	inc	SRC
	mov	[TEMP], TAGB
	inc	TEMP
	cmp	TAGB, 255
	jne	LengthWritten
	mov	TAGW, [SRC + 1]
	add	TEMP, 2
	add	SRC, 2
	mov	[TEMP-2], TAGW
	jmp	LengthWritten


Done:
/*
  BIOWR (v.stat.mask[CODING_ADJUST(0)], v.stat.bits[CODING_ADJUST(0)]);
*/
	mov	cl, V.stat.bits[256]
	mov	TEMP, [PTR]
	shl	MASK, cl
	mov	TAG, [PTR2]
	add	MASK, V.stat.mask[256*4]
	sub	ch, cl
	jge	LastMaskWritten

	mov	cl, ch
	neg	cl
	add	ch, 16
	ror	MASK, cl
	mov	[PTR1], MASKW
	mov	PTR1, TAG
	rol	MASK, cl
	mov	TAG, TEMP
	add	TEMP, 2
/*
  *(__unaligned bitmask2 *)Ptr1 = (ubitmask2) (Mask <<= Bits);
  *(__unaligned bitmask2 *)Ptr2 = 0;
  v.comp.ptr = ptr;
*/
LastMaskWritten:
	mov	cl, ch
	shl	MASK, cl
	mov	word ptr [PTR1], MASKW
	mov	word ptr [TAG], 0
	mov	V.comp.ptr, TEMP

#if DEBUG
/*
  assert (src == v.temp.ptr);
*/
	cmp	V.temp.ptr, SRC
	je	RetOK
	int	3
RetOK:
#endif

	add	esp, 12
	pop	ebp
    } /* __asm */
}


#undef TEMP
#undef PRS
#undef V   
#undef TAG
#undef TAGW
#undef TAGB
#undef PTR1
#undef SRC
#undef MASK
#undef MASKW
#undef PTR
#undef PTR2
#undef TAGS

#endif /* !defined (i386) || CODING != CODING_HUFF_ALL */

#endif /* CODING & (CODING_HUFF_PTR | CODING_HUFF_ALL) */


/* ------------------ Create canonical Huffman code ------------------- */
/*                    -----------------------------                     */

#define MAX_ALPHABET HUFF_SIZE
static void huffman_create_codes (huff_info *info, uxint *freq, xint n, uxint *mask, uchar *length, uxint maxbits, uchar *encoded, uxint *total)
{
  huff_node
    *p, *q, *r,
    *first_sorted, *first_free;
  xint i, k;

  assert ((uxint) (n-1) <= (MAX_ALPHABET-1));

  /* honestly it is easy enough to create Huffman code in-place */
  /* but the use of explicit data structures makes code simpler */

  /* clean everything up                */
  memset (length, 0, sizeof (length[0]) * n);
  memset (encoded, 0, (n + 1) >> 1);

  if (mask != 0 && mask != freq)
    memset (mask, 0, sizeof (mask[0]) * n);

  /* store frequencies */
  p = info->buff;
  for (i = 0; i < n; ++i)
  {
    if ((p->freq = freq[i]) != 0)
    {
      p->son[0] = p+1; p->son[1] = 0;
      p->ch = (uint16) i;
      ++p;
    }
  }

  /* handle simple case         */
  *total = 0;
  if (p <= info->buff + 1)
  {
    if (p == info->buff)        /* if no symbols do nothing */
      return;
    i = p[-1].ch;               /* single symbol code */
    mask[i] = 0;
    encoded[i >> 1] = 0x11;     /* two symbols has 1-bit length */
    return;
  }

  first_free = p;       /* store location of first unused node  */

  p[-1].son[0] = 0;     /* terminate the list                   */
  /* radix sort the list by frequency */
  p = info->buff;             /* head of the list                     */
  /* initialize */
  for (n = 0; n < 256; ++n)
    *(info->link[n] = info->head + n) = 0;
  for (i = 0; i < (BUFF_SIZE_LOG <= 16 ? 16 : 32); i += 8)
  {
    /* link node to the end of respective bucket        */
    do
    {
      n = (p->freq >> i) & 0xff;
      info->link[n][0] = p; info->link[n] = p->son;
    }
    while ((p = p->son[0]) != 0);

    /* merge buckets into single list                   */
    n = 0;
    while (info->head[n] == 0) ++n;
    p = info->head[n]; info->head[k = n] = 0;
    while (++n < 256)
    {
      if (info->head[n] == 0) continue;
      info->link[k][0] = info->head[n]; info->link[k] = info->head + k; info->head[n] = 0;
      k = n;
    }
    info->link[k][0] = 0; info->link[k] = info->head + k;
  }
  first_sorted = p;      /* store head of sorted symbol's list   */

restart:
  assert (p == first_sorted);
  q = first_free;
  r = q - 1;
  while (p != 0 || q != r)
  {
    ++r;

    /* select left subtree      */
    assert (q <= r && (p != 0 || q != r));
    if (p == 0 || (q != r && p->freq > q->freq))
    {
      r->son[0] = q; r->freq = q->freq; ++q;
    }
    else
    {
      r->son[0] = p; r->freq = p->freq; p = p->son[0];
    }

    /* select right subtree     */
    assert (q <= r && (p != 0 || q != r));
    if (p == 0 || (q != r && p->freq > q->freq))
    {
      r->son[1] = q; r->freq += q->freq; ++q;
    }
    else
    {
      r->son[1] = p; r->freq += p->freq; p = p->son[0];
    }
  }

  /* evaluate codewords' length         */
  i = -1;       /* stack pointer        */
  n = 0;        /* current tree depth   */
  p = r;        /* current subtree root */
  for (;;)
  {
    while (p->son[1] != 0)
    {
      /* put right son into stack and set up its depth   */
      (info->head[++i] = p->son[1])->bits = (uint16) (++n);
      (p = p->son[0])->bits = (uint16) n;
    }
    length[p->ch] = (uchar) n;

    if (i < 0) break;   /* nothing's in stack                   */
    n = (p = info->head[i--])->bits;
  }

  p = first_sorted;
#if DEBUG
  for (q = p; (r = q->son[0]) != 0; q = r)
    assert (q->bits >= r->bits);
#endif
  if (p->bits > maxbits)
  {
    assert (p == first_sorted);
    q = p;
    do
      q->freq = (q->freq + 1) >> 1;
    while ((q = q->son[0]) != 0);
    goto restart;
  }

  /* now sort symbols in a stable way by increasing codeword length     */
  /* initialize */
  memset (info->head, 0, sizeof (info->head[0]) * 32);
  for (n = 0; n < 32; ++n)
    info->link[n] = info->head + n;

  /* link node to the end of respective bucket  */
  p = info->buff;
  do
  {
    n = p->bits;
    info->link[n][0] = p; info->link[n] = p->son;
  }
  while (++p != first_free);

  /* merge buckets into single list             */
  n = 0;
  while (info->head[n] == 0) ++n;
  p = info->head[n]; k = n;
  while (++n < 32)
  {
    if (info->head[n] == 0) continue;
    info->link[k][0] = info->head[n];
    k = n;
  }
  info->link[k][0] = 0;

#if DEBUG
  for (q = p; (r = q->son[0]) != 0; q = r)
    assert (r->bits > q->bits || (r->bits == q->bits && r->ch > q->ch));
#endif

  /* set up code masks          */
  if (mask == freq)
    memset (mask, 0, sizeof (mask[0]) * n);

  n = 0;        /* mask         */
  i = 1;        /* bit length   */
  k = 1;        /* first index  */
  do
  {
    /* sum a[i] * b[i] may be evaluated without multiplications */
    /* using O(B) memory and O(N+B) time if 0 <= b[i] < B       */
    *total += freq[p->ch] * p->bits;
    encoded[p->ch >> 1] |= p->bits << (p->ch & 1 ? 4 : 0);
    mask[p->ch] = (n <<= p->bits - i);
    i = p->bits;
    ++n;
  }
  while ((p = p->son[0]) != 0);
}

#endif /* CODING */

#define CHAIN 0
#define encode_pass1 encode0_pass1
#include "xencode.i"

#if MAX_CHAIN >= 1
#define CHAIN 1
#define encode_pass1 encode1_pass1
#define find_match find_match1
#include "xencode.i"
#endif

#if MAX_CHAIN >= 2
#define CHAIN 2
#define encode_pass1 encode2_pass1
#define find_match find_match2
#include "xencode.i"
#endif

#if MAX_CHAIN >= 3
#define CHAIN 3
#define encode_pass1 encodeN_pass1
#define find_match find_matchN
#include "xencode.i"
#endif

typedef void encode_pass1_proc (prs *p);

static void encode_pass1_progress (
  prs *p,
  encode_pass1_proc *encode_pass1,
  XpressProgressFn *ProgressFn,         // NULL or progress callback
  void *ProgressContext,                // user-defined context that will be passed to ProgressFn
  int ProgressSize                      // call ProgressFn each time ProgressSize bytes processed
)
{
  xint stop;

  if (ProgressFn == 0)
  {
    encode_pass1 (p);
    return;
  }

  stop = v.orig.stop;
  for (;;)
  {
    if (v.orig.pos - v.orig.progress >= ProgressSize)
    {
#if CODING & (CODING_HUFF_LEN | CODING_HUFF_PTR | CODING_HUFF_ALL)
      ProgressFn (ProgressContext, v.orig.pos);
#else
      ProgressFn (ProgressContext, (v.orig.pos * 15) >> 4);
#endif
      v.orig.progress = v.orig.pos;
    }

    v.orig.stop = stop;
    if (v.orig.pos >= stop)
      break;

    if (stop - v.orig.progress > ProgressSize)
      v.orig.stop = v.orig.progress + ProgressSize;
    assert (v.orig.stop > v.orig.pos);

    v.orig.ptr_stop = v.orig.stop + v.orig.ptr;
    encode_pass1 (p);
  }
}

#if !FILL_NULL
static
void
MemoryFillPtr (
  const void **p,
  const void  *d,
  int          n
)
{
  const void **e;
  while (n & 7)
  {
    *p++ = d;
    if (--n == 0)
      return;
  }
  e = p + n;
  do
  {
    p[0] = d;
    p[1] = d;
    p[2] = d;
    p[3] = d;
    p[4] = d;
    p[5] = d;
    p[6] = d;
    p[7] = d;
    p += 8;
  }
  while (p != e);
}
#endif /* !FILL_NULL */

XPRESS_EXPORT
int
XPRESS_CALL
XpressEncodeEx
(
  XpressEncodeStream stream,
  void              *comp,
  int                comp_size,
  const void        *orig,
  int                orig_size,
  XpressProgressFn  *ProgressFn,        // NULL or progress callback
  void              *ProgressContext,   // user-defined context that will be passed to ProgressFn
  int                ProgressSize,      // call ProgressFn each time ProgressSize bytes processed
  int                CompressionLevel
)
{
#if CODING & (CODING_HUFF_LEN | CODING_HUFF_PTR | CODING_HUFF_ALL)
  uchar huff_buff [HUFF_SIZE >> 1];
  uxint huff_total;
#endif
  uxint c_size;
  prs *p;
  xpress_info *info = (xpress_info *) stream;
  encode_pass1_proc *encode_pass1;

  if (info == 0 || info->magic != MAGIC_ENCODE)
    return (0);

  if ((unsigned) (orig_size-1) > info->max_size
    || orig_size <= MIN_SIZE
    || comp_size < MIN_SIZE
    || comp == 0
    || orig == 0)
  {
    return (orig_size);
  }

  p = info->p;
  memset (&v, 0, sizeof (v));

  if (CompressionLevel < 0)
    CompressionLevel = 0;
  else if (CompressionLevel > info->max_chain)
    CompressionLevel = info->max_chain;
  v.chain = CompressionLevel;

  v.orig.end = (v.orig.ptr = orig) + (v.orig.size = v.orig.stop = orig_size);
  v.orig.end_16 = v.orig.end - 16;
  v.orig.end_3 = v.orig.end - MIN_MATCH;
  v.comp.ptr = v.comp.beg = comp;
  v.orig.pos = 0;
  v.temp.beg = v.temp.ptr = info->temp;

#if CODING & (CODING_HUFF_PTR | CODING_HUFF_ALL) && !defined (i386)
  // check initialization of static tables (in case somebody messed up with DLLs)
  if (!bitno_table_initialized)
    bitno_init ();
#endif

  encode_pass1 = encode0_pass1;
  if (v.chain <= 0)
  {
#if FILL_NULL
    memset ((void *) (&p->x.q_last[0]), 0, Q_HASH_SIZE * sizeof (p->x.q_last[0]));
#else
    MemoryFillPtr ((const void **) (&p->x.q_last[0]), orig, Q_HASH_SIZE);
#endif /* FILL_NULL */
  }
#if MAX_CHAIN >= 1
  else
  {
    // check initialization of static tables (in case somebody messed up with DLLs)
    if (!z_hash_map_initialized)
      z_hash_map_init ();

    if (v.chain == 1)
    {
      encode_pass1 = encode1_pass1;
      memset ((void *) (&p->x.z_next[0]), 0, Z_HASH_SIZE * sizeof (p->x.z_next[0]));
    }
#if MAX_CHAIN >= 2
    else
    {
      encode_pass1 = encode2_pass1;
#if MAX_CHAIN >= 3
      if (v.chain >= 3)
        encode_pass1 = encodeN_pass1;
#endif /* MAX_CHAIN >= 3 */
      memset (p[-1].x.z_hash, 0, sizeof (p[-1].x.z_hash));
      z_hash_insert (p);

#if 0
      {
        int n = 0x1653;
        int i, k;
        i = 0; k = n;
        do
        {
          k = p->x.z_next[k];
          printf ("%2d: 0x%04x 0x%04x\n", i, k, n - k);
          ++i;
        }
        while (k != 0);
      }
#endif
    }
#endif /* MAX_CHAIN >= 2 */
  }
#endif /* MAX_CHAIN >= 1 */

  if (ProgressSize <= 0 || ProgressSize > orig_size)
    ProgressSize = orig_size;

  if (ProgressFn != 0)
    ProgressFn (ProgressContext, v.orig.progress = 0);

#if CODING & (CODING_DIRECT | CODING_DIRECT2 | CODING_BY_BIT)
  v.temp.beg = v.temp.ptr = v.comp.ptr;
  tag_write_start (p);
  for (;;)
  {
    xint rest = comp_size - (xint) (v.temp.ptr - v.comp.beg) - 2 * sizeof (tag_t);
    rest -= (rest + 7) >> 3;
    if (rest <= (xint) (2 * sizeof (tag_t) + 8))
      goto no_compression;
    if (v.orig.pos >= v.orig.size)
      break;
    v.orig.stop = v.orig.pos + rest;
    if (v.orig.stop > v.orig.size - 8)
    {
      v.orig.stop = v.orig.size - 8;
      if (v.orig.pos >= v.orig.stop)
        break;
    }
    encode_pass1_progress (p, encode_pass1, ProgressFn, ProgressContext, ProgressSize);
  }
#else
  v.orig.stop -= 7;
  tag_write_start (p);
  encode_pass1_progress (p, encode_pass1, ProgressFn, ProgressContext, ProgressSize);
#endif
  while (v.orig.pos < v.orig.size)
  {
    write_lit (p, v.temp.ptr, v.orig.ptr[v.orig.pos]);
    ++v.orig.pos;
  }
  tag_write_finish (p);

#if CODING & (CODING_DIRECT | CODING_DIRECT2 | CODING_BY_BIT)
  c_size = (xint) (v.temp.ptr - v.temp.beg);
#elif CODING & (CODING_HUFF_LEN | CODING_HUFF_PTR | CODING_HUFF_ALL)
  if (v.stat.pointers == 0)
    goto no_compression;
#if CODING == CODING_HUFF_ALL
    ++v.stat.freq[CODING_ADJUST(0)];
#endif
  huffman_create_codes (
    &v.stat.info,
    v.stat.freq, HUFF_SIZE,
    v.stat.mask, v.stat.bits, 15, huff_buff, &huff_total
  );

  c_size = huff_total;
#if CODING & (CODING_HUFF_PTR | CODING_HUFF_ALL)
  c_size += v.stat.extra;
#endif
  if (c_size == 0) c_size = 1;
  c_size = (((c_size - 1) & ~(sizeof (bitmask2) * 8 - 1)) >> 3);
  c_size += (int) (v.temp.ptr - v.temp.beg) - v.stat.pointers + 4 + sizeof (huff_buff);
#if CODING == CODING_HUFF_ALL
  for (huff_total = 0; huff_total < 256; ++huff_total)
    c_size -= v.stat.freq[huff_total];
  c_size -= v.stat.masks * sizeof (tag_t);
#endif
#endif /* CODING */

  if (c_size >= (uxint) comp_size)
  {
  no_compression:
    comp_size = orig_size;
  }
  else
  {
#if CODING & (CODING_HUFF_LEN | CODING_HUFF_PTR | CODING_HUFF_ALL)
    memcpy (v.comp.ptr, huff_buff, sizeof (huff_buff));
    v.comp.ptr += sizeof (huff_buff);

#if 0
printf ("c_size = %d, temp_size = %d\n", c_size, v.temp.ptr - v.temp.beg);
{
  FILE *fd = fopen (
#ifdef i386
   "a.bad"
#else
   "c.bad"
#endif
   , "wb");
  if (fd != 0)
  {
    fwrite (v.temp.beg, v.temp.ptr - v.temp.beg, 1, fd);
    fclose (fd);
  }
}
#endif

    encode_pass2 (p);
#elif CODING & (CODING_BY_BIT | CODING_DIRECT | CODING_DIRECT2)
    v.comp.ptr += c_size;
#else
#error Unknown CODING
#endif

    comp_size = (int) (v.comp.ptr - v.comp.beg);

#if DEBUG
    if (c_size != (uxint) comp_size)
      printf ("error: c_size = %d, comp_size = %d\n", c_size, comp_size);
#endif
  }

  if (ProgressFn != 0)
    ProgressFn (ProgressContext, orig_size);

  return (comp_size);
}



XPRESS_EXPORT
int
XPRESS_CALL
XpressEncode
(
  XpressEncodeStream stream,
  void              *comp,
  int                comp_size,
  const void        *orig,
  int                orig_size,
  XpressProgressFn  *ProgressFn,        // NULL or progress callback
  void              *ProgressContext,   // user-defined context that will be passed to ProgressFn
  int                ProgressSize       // call ProgressFn each time ProgressSize bytes processed
)
{
  xpress_info *info = (xpress_info *) stream;
  if (info == 0 || info->magic != MAGIC_ENCODE)
    return (0);
  return (XpressEncodeEx (
    stream,
    comp,
    comp_size,
    orig,
    orig_size,
    ProgressFn,
    ProgressContext,
    ProgressSize,
    info->chain
  ));
}


#define MEM_ALIGN   256

XPRESS_EXPORT
XpressEncodeStream
XPRESS_CALL
XpressEncodeCreate (
  int            max_orig_size,
  void          *context,
  XpressAllocFn *AllocFn,
  int            chain
)
{
  xpress_info *info;
  prs *p;
  uchar *b;
  int temp_size;
  int alloc_size;
  int max_chain;

  if (AllocFn == 0 || (unsigned) (max_orig_size-1) > (BUFF_SIZE-1))
    return (0);

#if CODING & (CODING_DIRECT | CODING_DIRECT2 | CODING_BY_BIT)
  temp_size = 0;
#else
  temp_size = max_orig_size + ((max_orig_size + 7) >> 3);
#endif

  alloc_size = sizeof (p->x.q_last[0]) * Q_HASH_SIZE;
#if MAX_CHAIN <= 0
  max_chain = chain = 0;
#else
  if (chain > MAX_CHAIN)
    chain = MAX_CHAIN;
  max_chain = chain;
  if (chain >= 1)
  {
    alloc_size = sizeof (p->x.z_next[0]) * Z_HASH_SIZE;
#if MAX_CHAIN >= 2
    if (chain >= 2)
    {
      // data structures for (chain >= 2) are the same, enable deeper search
      max_chain = MAX_CHAIN;
      alloc_size = sizeof (p->x.z_next[0]) * max_orig_size;
      if (temp_size < sizeof (p[-1].x.z_hash[0]) * Z_HASH_SIZE)
        temp_size = sizeof (p[-1].x.z_hash[0]) * Z_HASH_SIZE;
    }
#endif
  }
#endif

  temp_size = (temp_size + 256 + MEM_ALIGN-1 + sizeof (*p) - sizeof (p->x)) & ~(MEM_ALIGN-1);
  alloc_size += temp_size + sizeof (*info) + MEM_ALIGN;

  b = AllocFn (context, alloc_size);
  if (b == 0)
    return (0);

  info = (xpress_info *) b;
  info->max_size = max_orig_size - 1;
  info->max_chain = max_chain;
  info->chain = chain;
  info->magic = MAGIC_ENCODE;
  info->memory = b;

  b = (uchar *) (info + 1);
  b += MEM_ALIGN - (((__int64) b) & (MEM_ALIGN-1));
  info->p = p = ((prs *) (b + temp_size));
  info->temp = b;

#if MAX_CHAIN >= 1
  if (!z_hash_map_initialized)
    z_hash_map_init ();
#endif

#if CODING & (CODING_HUFF_PTR | CODING_HUFF_ALL) && !defined (i386)
  if (!bitno_table_initialized)
    bitno_init ();
#endif

  return ((XpressEncodeStream) info);
}

XPRESS_EXPORT
void
XPRESS_CALL
XpressEncodeClose (
  XpressEncodeStream stream,
  void              *context,
  XpressFreeFn      *FreeFn
)
{
  xpress_info *info = (xpress_info *) stream;
  if (info != 0 && FreeFn != 0 && info->magic == MAGIC_ENCODE)
  {
    info->magic = 0;
    FreeFn (context, info->memory);
  }
}

// returns MaxCompressionLevel or (-1) if stream was not initialized properly
XPRESS_EXPORT
int
XPRESS_CALL
XpressEncodeGetMaxCompressionLevel (
  XpressEncodeStream EncodeStream       // encoder's workspace
)
{
  xpress_info *info = (xpress_info *) EncodeStream;
  if (info != 0 && info->magic == MAGIC_ENCODE)
    return (info->max_chain);
  return (-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\xpress\xprs-crc.c ===
/* ------------------------------------------------------------------------ */
/*                                                                          */
/*  Copyright (c) Microsoft Corporation, 2000-2001. All rights reserved.    */
/*  Copyright (c) Andrew Kadatch, 1991-2001. All rights reserved.           */
/*                                                                          */
/*  Microsoft Confidential -- do not redistribute.                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */

#include "xpress.h"
#include "xprs.h"

/* ------------------------ CRC-32 ---------------------------- */
/*                          ------                              */

static uint32 crc32_table[256];
static int crc32_initialized = 0;

static void crc32_init (void)
{
  xint i, j;
  uint32 k, m = 0xedb88320L;
  if (crc32_initialized) return;
  for (i = 0; i < 256; ++i)
  {
    k = i;
    j = 8;
    do {
      if ((k&1) == 0)
        k >>= 1;
      else
      {
        k >>= 1;
        k ^= m;
      };
      --j;
    } while (j);
    crc32_table[i] = k;
  }
  crc32_initialized = 1;
}

static uint32 crc32 (const uchar *p, xint n, uint32 k)
{
  uint32 *table;

  if (n <= 0)
    return (k);

  k ^= (uint32) 0xffffffffL;
  table = crc32_table;

#define X(i) k = table[((uchar) k) ^ p[i]] ^ (k >> 8)
  if ((n -= 32) >= 0) do
  {
    X(000); X(001); X(002); X(003); X(004); X(005); X(006); X(007);
    X(010); X(011); X(012); X(013); X(014); X(015); X(016); X(017);
    X(020); X(021); X(022); X(023); X(024); X(025); X(026); X(027);
    X(030); X(031); X(032); X(033); X(034); X(035); X(036); X(037);
    p += 32;
  }
  while ((n -= 32) >= 0);
  if ((n += 32) > 0) do
  {
    X (0);
    ++p;
    --n;
  }
  while (n);
#undef X

  k ^= (uint32) 0xffffffffL;
  return (k);
}

int
XPRESS_CALL
  XpressCrc32
  (
    const void *data,           // beginning of data block
    int bytes,                  // number of bytes
    int crc                     // initial value
  )
{
  if (!crc32_initialized)
    crc32_init ();
  return (crc32 (data, bytes, crc));
}

#if 0
int main (void)
{
  int i = 0;
  crc32_init ();
  printf ("{\n");
  for (;;)
  {
    printf (" 0x%08lx", (unsigned long) crc32_table[i]);
    ++i;
    if (i & 3)
      printf (",");
    else if (i == 256)
      break;
    else printf (",\n");
  }
  printf ("\n}\n");
  return (0);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\xpress\xpress.h ===
#ifndef _XPRESS_H_
#define _XPRESS_H_

#ifdef _MSC_VER
#pragma once
#endif


/* ------------------------------------------------------------------------ */
/*                                                                          */
/*  Copyright (c) Microsoft Corporation, 2000-2002. All rights reserved.    */
/*  Copyright (c) Andrew Kadatch, 1991-2002. All rights reserved.           */
/*                                                                          */
/*  Microsoft Confidential -- do not redistribute.                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */


#ifdef __cplusplus
extern "C" {
#endif

/* ---------------------- Common declarations ------------------------- */
/*                        -------------------                           */

// max. size of input block
#define XPRESS_MAX_BLOCK_LOG    16
#define XPRESS_MAX_BLOCK        (1 << XPRESS_MAX_BLOCK_LOG)


// preferred data alignment to avoid misaligned accesses
#define XPRESS_ALIGNMENT        8

// declare default calling convention used in xpress
#if !defined (UNIX) && !defined (XPRESS_CALL)
#define XPRESS_CALL __stdcall
#endif

#if !defined (XPRESS_EXPORT)
#define XPRESS_EXPORT
#endif


// user-supplied callback function that allocates memory
// if there is no memory available it shall return NULL
typedef
void *
XPRESS_CALL
XpressAllocFn (
  void *Context,	// user-defined context (as passed to XpressEncodeCreate)
  int   AllocSize       // size of memory block to allocate (bytes)
);

// user-supplied callback function that releases memory
typedef
void
XPRESS_CALL
XpressFreeFn (
  void *Context,        // user-defined context (as passed to XpressEncodeClose)
  void *Address         // pointer to the block to be freed
);


/* ----------------------------- Encoder ------------------------------ */
/*                               -------                                */

// declare unique anonymous types for type safety
typedef struct {int XpressEncodeDummy;} *XpressEncodeStream;

// allocate and initialize encoder's data structures
// returns NULL if callback returned NULL (not enough memory)
XPRESS_EXPORT
XpressEncodeStream
XPRESS_CALL
XpressEncodeCreate (
  int            MaxOrigSize,           // max size of original data block (bytes)
  void          *Context,               // user-defined context info (will  be passed to AllocFn)
  XpressAllocFn *AllocFn,               // memory allocation callback
  int            CompressionLevel       // use 0 for speed, 9 for quality
);


// callback function called by XpressEncode to indicate compression progress
typedef
void
XPRESS_CALL
XpressProgressFn (
  void *Context,                        // user-defined context
  int   EncodedSize                     // size of processed original data (bytes)
);
    

// returns size of compressed data
// if compression failed then compressed buffer is left as is, and
// original data should be saved instead
XPRESS_EXPORT
int
XPRESS_CALL
XpressEncode (
  XpressEncodeStream EncodeStream,      // encoder's workspace
  void              *CompAdr,           // address of beggining of output memory region
  int                CompSize,          // size of output memory region (bytes)
  const void        *OrigAdr,           // address of beggining of input data block
  int                OrigSize,          // input data block size (bytes)
  XpressProgressFn  *ProgressFn,        // NULL or progress callback
  void              *ProgressContext,   // user-defined context that will be passed to ProgressFn
  int                ProgressSize       // call ProgressFn each time ProgressSize bytes processed
);

// returns size of compressed data
// if compression failed then compressed buffer is left as is, and
// original data should be saved instead
XPRESS_EXPORT
int
XPRESS_CALL
XpressEncodeEx (
  XpressEncodeStream EncodeStream,      // encoder's workspace
  void              *CompAdr,           // address of beggining of output memory region
  int                CompSize,          // size of output memory region (bytes)
  const void        *OrigAdr,           // address of beggining of input data block
  int                OrigSize,          // input data block size (bytes)
  XpressProgressFn  *ProgressFn,        // NULL or progress callback
  void              *ProgressContext,   // user-defined context that will be passed to ProgressFn
  int                ProgressSize,      // call ProgressFn each time ProgressSize bytes processed
  int                CompressionLevel	// CompressionLevel should not exceed MaxCompressionLevel
);

// returns MaxCompressionLevel or (-1) if stream was not initialized properly
XPRESS_EXPORT
int
XPRESS_CALL
XpressEncodeGetMaxCompressionLevel (
  XpressEncodeStream EncodeStream       // encoder's workspace
);


// invalidate encoding stream and release workspace memory
XPRESS_EXPORT
void
XPRESS_CALL
XpressEncodeClose (
  XpressEncodeStream EncodeStream,      // encoder's workspace
  void              *Context,           // user-defined context for FreeFn
  XpressFreeFn      *FreeFn             // memory release callback
);


/* ----------------------------- Decoder ------------------------------ */
/*                               -------                                */

// declare unique anonymous types for type safety
typedef struct {int XpressDecodeDummy;} *XpressDecodeStream;

// allocate memory for decoder. Returns NULL if not enough memory.
XPRESS_EXPORT
XpressDecodeStream
XPRESS_CALL
XpressDecodeCreate (
  void          *Context,               // user-defined context info (will  be passed to AllocFn)
  XpressAllocFn *AllocFn                // memory allocation callback
);

// decode compressed block. Returns # of decoded bytes or -1 otherwise
XPRESS_EXPORT
int
XPRESS_CALL
XpressDecode (
  XpressDecodeStream DecodeStream,      // decoder's workspace
  void              *OrigAdr,		// address of beginning out output memory region
  int                OrigSize,          // size of output memory region (bytes)
  int                DecodeSize,        // # of bytes to decode ( <= OrigSize)
  const void        *CompAdr,		// address of beginning of compressed data block
  int                CompSize           // size of compressed data block (bytes)
);

// invalidate decoding stream and release workspace memory
XPRESS_EXPORT
void
XPRESS_CALL
XpressDecodeClose (
  XpressDecodeStream DecodeStream,      // encoder's workspace
  void              *Context,           // user-defined context info (will  be passed to FreeFn)
  XpressFreeFn      *FreeFn             // callback that releases the memory
);


#ifdef __cplusplus
};
#endif

#endif /* _XPRESS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\test\stress\strestst.c ===
// *****************************************************************************
//
//  Purpose : Multithreaded stress test 
//              
//      Created : arunm 03/20/96
//      Modified: dangriff 11/6/00
// 
// *****************************************************************************

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <wincrypt.h>
#include "strestst.h"
#include <pincache.h>
#include <sha2.h>

//  ===========================================================================
int Usage(void)
{
    printf("%s -c <CSP Index> [options]\n", APP_NAME) ;
    printf(" -?:                         This message\n") ;
    printf(" -n <N>:                     # of threads to create (Def: %d)\n", StressGetDefaultThreadCount());
    printf(" -t <N>:                     End test in N minutes (Def: never end)\n");
    printf(" -e:                         Ephemeral keys\n");
    printf(" -u:                         User-protected keys (cannot be used with -e)\n");
    printf(" -r:                         Run regression tests\n");
    printf(" -s:                         Skip PinCache attack test\n");
    printf(" -d:                         Delete all key containers\n");
    printf(" -a<Flags> <Container>:      Call CryptAcquireContext with Flags\n");

    printf("\nCryptAcquireContext Flags:\n");
    printf(" v - CRYPT_VERIFYCONTEXT (don't specify <Container>)\n");
    printf(" n - CRYPT_NEWKEYSET\n");
    printf(" l - CRYPT_MACHINE_KEYSET\n");
    printf(" d - CRYPT_DELETEKEYSET\n");
    printf(" q - CRYPT_SILENT\n");
    printf(" x - create a Key Exchange keyset\n");
    printf(" s - create a Signature keyset\n");
    printf(" u - request keyset to be User Protected\n");
    printf(" e - request keyset to be Exportable\n");
    
    return 1;
}

//
// Function: StressGetDefaultThreadCount
// 
DWORD StressGetDefaultThreadCount(void)
{
    SYSTEM_INFO SystemInfo;

    ZeroMemory(&SystemInfo, sizeof(SystemInfo));
    GetSystemInfo(&SystemInfo);

    return 
        SystemInfo.dwNumberOfProcessors == 1 ? 
        STRESS_DEFAULT_THREAD_COUNT : 
        SystemInfo.dwNumberOfProcessors;
}

//
// Function: MyAlloc
//
LPVOID MyAlloc(SIZE_T dwBytes)
{
    return HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwBytes);
}

//
// Function: MyFree
//
BOOL MyFree(LPVOID lpMem)
{
    return HeapFree(GetProcessHeap(), 0, lpMem);
}

//
// Function: PrintBytes
//
#define CROW 8
void PrintBytes(LPSTR pszHdr, BYTE *pb, DWORD cbSize)
{
    ULONG cb, i;
    CHAR rgsz[1024];

    printf("\n  %s, %d bytes ::\n", pszHdr, cbSize);

    while (cbSize > 0)
    {
        // Start every row with an extra space
        printf(" ");

        cb = min(CROW, cbSize);
        cbSize -= cb;
        for (i = 0; i < cb; i++)
            printf(" %02x", pb[i]);
        for (i = cb; i < CROW; i++)
            printf("   ");
        printf("    '");
        for (i = 0; i < cb; i++)
        {
            if (pb[i] >= 0x20 && pb[i] <= 0x7f)
                printf("%c", pb[i]);
            else
                printf(".");
        }
        printf("\n");
        pb += cb;
    }
}

typedef struct {
    DWORD dwSignFlags;
    DWORD dwKeySize;
    ALG_ID aiHash;
    BOOL fExpectSuccess;
} SHA_SIGN_INFO, *PSHA_SIGN_INFO;

DWORD DoShaSigning(PTHREAD_DATA pThreadData, PSHA_SIGN_INFO pShaSignInfo)
{
    DWORD dwError = ERROR_SUCCESS;
    BOOL fSuccess = FALSE;
    HCRYPTKEY hKey = 0;
    HCRYPTHASH hHash = 0;
    CHAR rgHashData [] = "Hash This";
    DWORD cbHashData = sizeof(rgHashData);
    PBYTE pbSign = NULL;
    DWORD cbSign = 0;
    BOOL fPrint = pShaSignInfo->fExpectSuccess;

#define TPrint(X) { if (fPrint) { printf(X); } }
    
    if (! CryptCreateHash(
        pThreadData->hVerifyCtx, 
        pShaSignInfo->aiHash,
        0, 0, &hHash))
    {
        TPrint("CryptCreateHash ");
        goto Ret;
    }

    if (! CryptHashData(
        hHash, (PBYTE) rgHashData, cbHashData, 0))
    {
        TPrint("CryptHashData ");
        goto Ret;
    }

    if (! CryptGenKey(
        pThreadData->hVerifyCtx, AT_SIGNATURE, 
        pShaSignInfo->dwKeySize << 16, &hKey))
    {
        TPrint("CryptGenKey ");
        goto Ret;
    }

    if (! CryptSignHash(
        hHash, AT_SIGNATURE, NULL, 
        pShaSignInfo->dwSignFlags, NULL, &cbSign))
    {
        TPrint("CryptSignHash size ");
        goto Ret;
    }

    if (NULL == (pbSign = (PBYTE) MyAlloc(cbSign)))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }

    if (! CryptSignHash(
        hHash, AT_SIGNATURE, NULL,
        pShaSignInfo->dwSignFlags, pbSign, &cbSign))
    {
        TPrint("CryptSignHash ");
        goto Ret;
    }

    // 
    // No expected errors should occur from here on
    //
    pShaSignInfo->fExpectSuccess = TRUE;

    if (! CryptDestroyHash(hHash))
    {
        printf("CryptDestroyHash ");
        goto Ret;
    }
    hHash = 0;

    if (! CryptCreateHash(
        pThreadData->hVerifyCtx, 
        pShaSignInfo->aiHash,
        0, 0, &hHash))
    {
        printf("CryptCreateHash 2 ");
        goto Ret;
    }

    if (! CryptHashData(
        hHash, (PBYTE) rgHashData, cbHashData, 0))
    {
        printf("CryptHashData 2 ");
        goto Ret;
    }

    if (! CryptVerifySignature(
        hHash, pbSign, cbSign, hKey, 
        NULL, pShaSignInfo->dwSignFlags))
    {
        printf("CryptVerifySignature ");
        goto Ret;
    }

    fSuccess = TRUE;
Ret:
    
    if (! fSuccess)
    {
        dwError = GetLastError();

        if (0 == dwError)
            dwError = -1;
    }

    if (hHash)
        CryptDestroyHash(hHash);
    if (hKey)
        CryptDestroyKey(hKey);
    if (pbSign)
        MyFree(pbSign);
    
    return dwError;
}

#define cbSHA256_PKCS1_ENCODING                 0x13
#define cbSHA384_PKCS1_ENCODING                 0x13
#define cbSHA512_PKCS1_ENCODING                 0x13
#define cbPKCS1_PADDING                         0x3

#define cbSHA256_MIN_SIGNING_KEY_NOOID \
    SHA256_DIGEST_LEN + cbPKCS1_PADDING
#define cbSHA256_MIN_SIGNING_KEY \
    SHA256_DIGEST_LEN + cbSHA256_PKCS1_ENCODING + cbPKCS1_PADDING
       
#define cbSHA384_MIN_SIGNING_KEY_NOOID \
    SHA384_DIGEST_LEN + cbPKCS1_PADDING
#define cbSHA384_MIN_SIGNING_KEY \
    SHA384_DIGEST_LEN + cbSHA384_PKCS1_ENCODING + cbPKCS1_PADDING

#define cbSHA512_MIN_SIGNING_KEY_NOOID \
    SHA512_DIGEST_LEN + cbPKCS1_PADDING
#define cbSHA512_MIN_SIGNING_KEY \
    SHA512_DIGEST_LEN + cbSHA512_PKCS1_ENCODING + cbPKCS1_PADDING

//
// Function: NewShaModesSigningRegression
//
DWORD NewShaModesSigningRegression(PTHREAD_DATA pThreadData)
{
    DWORD dwError = ERROR_SUCCESS;
    BOOL fSuccess = FALSE;
    SHA_SIGN_INFO ShaSignInfo;
    DWORD dwMinSigKeySize = 0;
    PALGNODE pAlgNode = NULL;

    for (   pAlgNode = pThreadData->pAlgList;
            pAlgNode != NULL && CALG_RSA_KEYX != pAlgNode->EnumalgsEx.aiAlgid;
            pAlgNode = pAlgNode->pNext);

    if (NULL == pAlgNode)
    {
        printf("ERROR: Could not find CALG_RSA_KEYX alg info ");
        goto Ret;
    }

    dwMinSigKeySize = pAlgNode->EnumalgsEx.dwMinLen / 8;

    // 
    // Test 1A: 
    // SHA-256
    // Positive
    //
    ShaSignInfo.aiHash = CALG_SHA_256;
    ShaSignInfo.dwSignFlags = 0;
    ShaSignInfo.fExpectSuccess = TRUE;
    ShaSignInfo.dwKeySize = 
        8 * (max(dwMinSigKeySize, cbSHA256_MIN_SIGNING_KEY));

    dwError = ERROR_SUCCESS;
    dwError = DoShaSigning(pThreadData, &ShaSignInfo);

    if (ERROR_SUCCESS != dwError)
    {
        printf("ERROR: Test1A ");
        goto Ret;
    }

    //
    // Test 1B:
    // SHA-256
    // Negative
    //
    if (cbSHA256_MIN_SIGNING_KEY > dwMinSigKeySize)
    {
        ShaSignInfo.fExpectSuccess = FALSE;
        ShaSignInfo.dwKeySize = 8 * (cbSHA256_MIN_SIGNING_KEY - 1);

        dwError = ERROR_SUCCESS;
        dwError = DoShaSigning(pThreadData, &ShaSignInfo);

        if (NTE_BAD_LEN != dwError)
        {
            printf("ERROR: Test1B ");
            goto Ret;
        }
    }

    //
    // Test 1C:
    // SHA-256
    // NOHASHOID
    // Positive
    //
    ShaSignInfo.dwSignFlags = CRYPT_NOHASHOID;
    ShaSignInfo.fExpectSuccess = TRUE;
    ShaSignInfo.dwKeySize = 
        8 * (max(dwMinSigKeySize, cbSHA256_MIN_SIGNING_KEY_NOOID));

    dwError = ERROR_SUCCESS;
    dwError = DoShaSigning(pThreadData, &ShaSignInfo);

    if (ERROR_SUCCESS != dwError)
    {
        printf("ERROR: Test1C ");
        goto Ret;
    }

    //
    // Test 1D:
    // SHA-256
    // NOHASHOID
    // Negative
    //
    if (cbSHA256_MIN_SIGNING_KEY_NOOID > dwMinSigKeySize)
    {
        ShaSignInfo.fExpectSuccess = FALSE;
        ShaSignInfo.dwKeySize = 
            8 * (cbSHA256_MIN_SIGNING_KEY_NOOID - 1);

        dwError = ERROR_SUCCESS;
        dwError = DoShaSigning(pThreadData, &ShaSignInfo);

        if (NTE_BAD_LEN != dwError)
        {
            printf("ERROR: Test1D ");
            goto Ret;
        }
    }

    // 
    // Test 2A: 
    // SHA-384
    // Positive
    //
    ShaSignInfo.aiHash = CALG_SHA_384;
    ShaSignInfo.dwSignFlags = 0;
    ShaSignInfo.fExpectSuccess = TRUE;
    ShaSignInfo.dwKeySize = 
        8 * (max(dwMinSigKeySize, cbSHA384_MIN_SIGNING_KEY));

    dwError = ERROR_SUCCESS;
    dwError = DoShaSigning(pThreadData, &ShaSignInfo);

    if (ERROR_SUCCESS != dwError)
    {
        printf("ERROR: Test2A ");
        goto Ret;
    }

    //
    // Test 2B:
    // SHA-384
    // Negative
    //
    if (cbSHA384_MIN_SIGNING_KEY > dwMinSigKeySize)
    {
        ShaSignInfo.fExpectSuccess = FALSE;
        ShaSignInfo.dwKeySize = 8 * (cbSHA384_MIN_SIGNING_KEY - 1);

        dwError = ERROR_SUCCESS;
        dwError = DoShaSigning(pThreadData, &ShaSignInfo);

        if (NTE_BAD_LEN != dwError)
        {
            printf("ERROR: Test2B ");
            goto Ret;
        }
    }

    //
    // Test 2C:
    // SHA-384
    // NOHASHOID
    // Positive
    //
    ShaSignInfo.dwSignFlags = CRYPT_NOHASHOID;
    ShaSignInfo.fExpectSuccess = TRUE;
    ShaSignInfo.dwKeySize = 
        8 * (max(dwMinSigKeySize, cbSHA384_MIN_SIGNING_KEY_NOOID));

    dwError = ERROR_SUCCESS;
    dwError = DoShaSigning(pThreadData, &ShaSignInfo);

    if (ERROR_SUCCESS != dwError)
    {
        printf("ERROR: Test2C ");
        goto Ret;
    }

    //
    // Test 2D:
    // SHA-384
    // NOHASHOID
    // Negative
    //
    if (cbSHA384_MIN_SIGNING_KEY_NOOID > dwMinSigKeySize)
    {
        ShaSignInfo.fExpectSuccess = FALSE;
        ShaSignInfo.dwKeySize = 
            8 * (cbSHA384_MIN_SIGNING_KEY_NOOID - 1);

        dwError = ERROR_SUCCESS;
        dwError = DoShaSigning(pThreadData, &ShaSignInfo);

        if (NTE_BAD_LEN != dwError)
        {
            printf("ERROR: Test2D ");
            goto Ret;
        }
    }

    // 
    // Test 3A: 
    // SHA-512
    // Positive
    //
    ShaSignInfo.aiHash = CALG_SHA_512;
    ShaSignInfo.dwSignFlags = 0;
    ShaSignInfo.fExpectSuccess = TRUE;
    ShaSignInfo.dwKeySize = 
        8 * (max(dwMinSigKeySize, cbSHA512_MIN_SIGNING_KEY));

    dwError = ERROR_SUCCESS;
    dwError = DoShaSigning(pThreadData, &ShaSignInfo);

    if (ERROR_SUCCESS != dwError)
    {
        printf("ERROR: Test3A ");
        goto Ret;
    }

    //
    // Test 3B:
    // SHA-512
    // Negative
    //
    if (cbSHA512_MIN_SIGNING_KEY > dwMinSigKeySize)
    {
        ShaSignInfo.fExpectSuccess = FALSE;
        ShaSignInfo.dwKeySize = 8 * (cbSHA512_MIN_SIGNING_KEY - 1);

        dwError = ERROR_SUCCESS;
        dwError = DoShaSigning(pThreadData, &ShaSignInfo);

        if (NTE_BAD_LEN != dwError)
        {
            printf("ERROR: Test3B ");
            goto Ret;
        }
    }

    //
    // Test 3C:
    // SHA-512
    // NOHASHOID
    // Positive
    //
    ShaSignInfo.dwSignFlags = CRYPT_NOHASHOID;
    ShaSignInfo.fExpectSuccess = TRUE;
    ShaSignInfo.dwKeySize = 
        8 * (max(dwMinSigKeySize, cbSHA512_MIN_SIGNING_KEY_NOOID));

    dwError = ERROR_SUCCESS;
    dwError = DoShaSigning(pThreadData, &ShaSignInfo);

    if (ERROR_SUCCESS != dwError)
    {
        printf("ERROR: Test3C ");
        goto Ret;
    }

    //
    // Test 3D:
    // SHA-512
    // NOHASHOID
    // Negative
    //
    if (cbSHA512_MIN_SIGNING_KEY_NOOID > dwMinSigKeySize)
    {
        ShaSignInfo.fExpectSuccess = FALSE;
        ShaSignInfo.dwKeySize = 
            8 * (cbSHA512_MIN_SIGNING_KEY_NOOID - 1);

        dwError = ERROR_SUCCESS;
        dwError = DoShaSigning(pThreadData, &ShaSignInfo);

        if (NTE_BAD_LEN != dwError)
        {
            printf("ERROR: Test3D ");
            goto Ret;
        }
    }

    fSuccess = TRUE;
    dwError = ERROR_SUCCESS;

Ret:
    if (! fSuccess)
    {
        if (0 == dwError)
            dwError = -1;
    }
    
    return dwError;
}

//
// Function: NewShaModesHmacRegression
//
DWORD NewShaModesHmacRegression(PTHREAD_DATA pThreadData)
{
    BYTE rgbHmacKeyShaNew [20]; // set bytes to 0x0b
    BYTE rgbHmacDataShaNew [] = {
        0x48, 0x69, 0x20, 0x54, 
        0x68, 0x65, 0x72, 0x65
    };

    // Hmac SHA-256 Result
    BYTE rgbHmacSha256 [] = {
        0xb0, 0x34, 0x4c, 0x61, 
        0xd8, 0xdb, 0x38, 0x53, 
        0x5c, 0xa8, 0xaf, 0xce, 
        0xaf, 0x0b, 0xf1, 0x2b, 
        0x88, 0x1d, 0xc2, 0x00, 
        0xc9, 0x83, 0x3d, 0xa7, 
        0x26, 0xe9, 0x37, 0x6c, 
        0x2e, 0x32, 0xcf, 0xf7
    };

    // Hmac SHA-384 Result
    BYTE rgbHmacSha384 [] = {
        0xaf, 0xd0, 0x39, 0x44, 
        0xd8, 0x48, 0x95, 0x62, 
        0x6b, 0x08, 0x25, 0xf4, 
        0xab, 0x46, 0x90, 0x7f, 
        0x15, 0xf9, 0xda, 0xdb, 
        0xe4, 0x10, 0x1e, 0xc6, 
        0x82, 0xaa, 0x03, 0x4c, 
        0x7c, 0xeb, 0xc5, 0x9c, 
        0xfa, 0xea, 0x9e, 0xa9, 
        0x07, 0x6e, 0xde, 0x7f, 
        0x4a, 0xf1, 0x52, 0xe8, 
        0xb2, 0xfa, 0x9c, 0xb6
    };
        
    // Hmac SHA-512 Result
    BYTE rgbHmacSha512 [] = {
        0x87, 0xaa, 0x7c, 0xde, 
        0xa5, 0xef, 0x61, 0x9d, 
        0x4f, 0xf0, 0xb4, 0x24, 
        0x1a, 0x1d, 0x6c, 0xb0, 
        0x23, 0x79, 0xf4, 0xe2, 
        0xce, 0x4e, 0xc2, 0x78, 
        0x7a, 0xd0, 0xb3, 0x05, 
        0x45, 0xe1, 0x7c, 0xde, 
        0xda, 0xa8, 0x33, 0xb7, 
        0xd6, 0xb8, 0xa7, 0x02, 
        0x03, 0x8b, 0x27, 0x4e, 
        0xae, 0xa3, 0xf4, 0xe4, 
        0xbe, 0x9d, 0x91, 0x4e, 
        0xeb, 0x61, 0xf1, 0x70, 
        0x2e, 0x69, 0x6c, 0x20, 
        0x3a, 0x12, 0x68, 0x54
    };

    DWORD dwError = ERROR_SUCCESS;
    BOOL fSuccess = FALSE;
    HCRYPTKEY hKey = 0;
    HCRYPTHASH hHash = 0;
    BYTE rgbKey[1000];
    BYTE rgbResult[64];
    DWORD cb = 0;
    BLOBHEADER *pHeader = NULL;
    PDWORD pdw = NULL;
    PBYTE pb = NULL;
    HMAC_INFO HmacInfo;

    memset(&HmacInfo, 0, sizeof(HmacInfo));

    pHeader = (BLOBHEADER *) rgbKey;
    pdw = (PDWORD)(rgbKey + sizeof(BLOBHEADER));
    pb = rgbKey + sizeof(BLOBHEADER) + sizeof(DWORD);

    pHeader->aiKeyAlg = CALG_RC2;
    pHeader->bType = PLAINTEXTKEYBLOB;
    pHeader->bVersion = CUR_BLOB_VERSION;
    pHeader->reserved = 0x0000;
    
    *pdw = sizeof(rgbHmacKeyShaNew);

    memset(rgbHmacKeyShaNew, 0x0b, sizeof(rgbHmacKeyShaNew));
    memcpy(pb, rgbHmacKeyShaNew, sizeof(rgbHmacKeyShaNew));

    cb = sizeof(BLOBHEADER) + sizeof(DWORD) + sizeof(rgbHmacKeyShaNew);
    if (! CryptImportKey(
        pThreadData->hVerifyCtx, rgbKey, cb, 0, CRYPT_IPSEC_HMAC_KEY, &hKey))
    {
        printf("CryptImportKey ");
        goto Ret;
    }

    //
    // Hmac SHA-256 Tests
    //
    HmacInfo.HashAlgid = CALG_SHA_256;

    if (! CryptCreateHash(
        pThreadData->hVerifyCtx, CALG_HMAC, hKey, 0, &hHash))
    {
        printf("CryptCreateHash ");
        goto Ret;
    }

    if (! CryptSetHashParam(
        hHash, HP_HMAC_INFO, (PBYTE) &HmacInfo, 0))
    {
        printf("CryptSetHashParam ");
        goto Ret;
    }

    if (! CryptHashData(
        hHash, rgbHmacDataShaNew, sizeof(rgbHmacDataShaNew), 0))
    {
        printf("CryptHashData ");
        goto Ret;
    }

    cb = sizeof(rgbResult);
    if (! CryptGetHashParam(
        hHash, HP_HASHVAL, rgbResult, &cb, 0))
    {
        printf("CryptGetHashParam ");
        goto Ret;
    }

    if (memcmp(rgbResult, rgbHmacSha256, sizeof(rgbHmacSha256)))
    {
        printf("ERROR: Incorrect Hmac result for SHA 256 ");
        goto Ret;
    }

    if (! CryptDestroyHash(hHash))
    {
        printf("CryptDestroyHash ");
        goto Ret;
    }
    hHash = 0;

    //
    // Hmac SHA-384 Tests
    //
    HmacInfo.HashAlgid = CALG_SHA_384;

    if (! CryptCreateHash(
        pThreadData->hVerifyCtx, CALG_HMAC, hKey, 0, &hHash))
    {
        printf("CryptCreateHash ");
        goto Ret;
    }

    if (! CryptSetHashParam(
        hHash, HP_HMAC_INFO, (PBYTE) &HmacInfo, 0))
    {
        printf("CryptSetHashParam ");
        goto Ret;
    }

    if (! CryptHashData(
        hHash, rgbHmacDataShaNew, sizeof(rgbHmacDataShaNew), 0))
    {
        printf("CryptHashData ");
        goto Ret;
    }

    cb = sizeof(rgbResult);
    if (! CryptGetHashParam(
        hHash, HP_HASHVAL, rgbResult, &cb, 0))
    {
        printf("CryptGetHashParam ");
        goto Ret;
    }

    if (memcmp(rgbResult, rgbHmacSha384, sizeof(rgbHmacSha384)))
    {
        printf("ERROR: Incorrect Hmac result for SHA 384 ");
        goto Ret;
    }

    if (! CryptDestroyHash(hHash))
    {
        printf("CryptDestroyHash ");
        goto Ret;
    }
    hHash = 0;

    //
    // Hmac SHA-512 Tests
    //
    HmacInfo.HashAlgid = CALG_SHA_512;

    if (! CryptCreateHash(
        pThreadData->hVerifyCtx, CALG_HMAC, hKey, 0, &hHash))
    {
        printf("CryptCreateHash ");
        goto Ret;
    }

    if (! CryptSetHashParam(
        hHash, HP_HMAC_INFO, (PBYTE) &HmacInfo, 0))
    {
        printf("CryptSetHashParam ");
        goto Ret;
    }

    if (! CryptHashData(
        hHash, rgbHmacDataShaNew, sizeof(rgbHmacDataShaNew), 0))
    {
        printf("CryptHashData ");
        goto Ret;
    }

    cb = sizeof(rgbResult);
    if (! CryptGetHashParam(
        hHash, HP_HASHVAL, rgbResult, &cb, 0))
    {
        printf("CryptGetHashParam ");
        goto Ret;
    }

    if (memcmp(rgbResult, rgbHmacSha512, sizeof(rgbHmacSha512)))
    {
        printf("ERROR: Incorrect Hmac result for SHA 512 ");
        goto Ret;
    }

    fSuccess = TRUE;

Ret:
    if (! fSuccess)
    {
        dwError = GetLastError();

        if (0 == dwError)
            dwError = -1;
    }
    
    if (hHash)
        CryptDestroyHash(hHash);
    if (hKey)
        CryptDestroyKey(hKey);
    
    return dwError;
}

// SHA 256 Vectors
CHAR l_rgSha256Test1[]        = "abc";
DWORD l_cbSha256Test1         = sizeof(l_rgSha256Test1) - 1;
BYTE l_rgbSha256Result1[]     = {
    0xba, 0x78, 0x16, 0xbf, 0x8f, 0x01, 0xcf, 0xea, 
    0x41, 0x41, 0x40, 0xde, 0x5d, 0xae, 0x22, 0x23,
    0xb0, 0x03, 0x61, 0xa3, 0x96, 0x17, 0x7a, 0x9c, 
    0xb4, 0x10, 0xff, 0x61, 0xf2, 0x00, 0x15, 0xad
};

CHAR l_rgSha256Test2[]        = "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq";
DWORD l_cbSha256Test2         = sizeof(l_rgSha256Test2) - 1;
BYTE l_rgbSha256Result2[]     = {
    0x24, 0x8d, 0x6a, 0x61, 0xd2, 0x06, 0x38, 0xb8, 
    0xe5, 0xc0, 0x26, 0x93, 0x0c, 0x3e, 0x60, 0x39,
    0xa3, 0x3c, 0xe4, 0x59, 0x64, 0xff, 0x21, 0x67, 
    0xf6, 0xec, 0xed, 0xd4, 0x19, 0xdb, 0x06, 0xc1
};

// SHA 384 Vectors
BYTE l_rgSha384Test1[]        = "abc";
DWORD l_cbSha384Test1         = sizeof(l_rgSha384Test1) - 1;
BYTE l_rgbSha384Result1[]     = {
    0xcb, 0x00, 0x75, 0x3f, 0x45, 0xa3, 0x5e, 0x8b, 
    0xb5, 0xa0, 0x3d, 0x69, 0x9a, 0xc6, 0x50, 0x07,
    0x27, 0x2c, 0x32, 0xab, 0x0e, 0xde, 0xd1, 0x63, 
    0x1a, 0x8b, 0x60, 0x5a, 0x43, 0xff, 0x5b, 0xed,
    0x80, 0x86, 0x07, 0x2b, 0xa1, 0xe7, 0xcc, 0x23, 
    0x58, 0xba, 0xec, 0xa1, 0x34, 0xc8, 0x25, 0xa7
};

BYTE l_rgSha384Test2[]        = "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu";
DWORD l_cbSha384Test2         = sizeof(l_rgSha384Test2) - 1;
BYTE l_rgbSha384Result2[]     = {
    0x09, 0x33, 0x0c, 0x33, 0xf7, 0x11, 0x47, 0xe8, 
    0x3d, 0x19, 0x2f, 0xc7, 0x82, 0xcd, 0x1b, 0x47,
    0x53, 0x11, 0x1b, 0x17, 0x3b, 0x3b, 0x05, 0xd2, 
    0x2f, 0xa0, 0x80, 0x86, 0xe3, 0xb0, 0xf7, 0x12,
    0xfc, 0xc7, 0xc7, 0x1a, 0x55, 0x7e, 0x2d, 0xb9, 
    0x66, 0xc3, 0xe9, 0xfa, 0x91, 0x74, 0x60, 0x39
};

// SHA 512 Vectors
BYTE l_rgSha512Test1[]        = "abc";
DWORD l_cbSha512Test1         = sizeof(l_rgSha512Test1) - 1;
BYTE l_rgbSha512Result1[]     = {
    0xdd, 0xaf, 0x35, 0xa1, 0x93, 0x61, 0x7a, 0xba, 
    0xcc, 0x41, 0x73, 0x49, 0xae, 0x20, 0x41, 0x31,
    0x12, 0xe6, 0xfa, 0x4e, 0x89, 0xa9, 0x7e, 0xa2, 
    0x0a, 0x9e, 0xee, 0xe6, 0x4b, 0x55, 0xd3, 0x9a,
    0x21, 0x92, 0x99, 0x2a, 0x27, 0x4f, 0xc1, 0xa8, 
    0x36, 0xba, 0x3c, 0x23, 0xa3, 0xfe, 0xeb, 0xbd,
    0x45, 0x4d, 0x44, 0x23, 0x64, 0x3c, 0xe8, 0x0e, 
    0x2a, 0x9a, 0xc9, 0x4f, 0xa5, 0x4c, 0xa4, 0x9f
};

BYTE l_rgSha512Test2[]        = "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu";
DWORD l_cbSha512Test2         = sizeof(l_rgSha512Test2) - 1;
BYTE l_rgbSha512Result2[]     = {
    0x8e, 0x95, 0x9b, 0x75, 0xda, 0xe3, 0x13, 0xda, 
    0x8c, 0xf4, 0xf7, 0x28, 0x14, 0xfc, 0x14, 0x3f,
    0x8f, 0x77, 0x79, 0xc6, 0xeb, 0x9f, 0x7f, 0xa1, 
    0x72, 0x99, 0xae, 0xad, 0xb6, 0x88, 0x90, 0x18,
    0x50, 0x1d, 0x28, 0x9e, 0x49, 0x00, 0xf7, 0xe4, 
    0x33, 0x1b, 0x99, 0xde, 0xc4, 0xb5, 0x43, 0x3a,
    0xc7, 0xd3, 0x29, 0xee, 0xb6, 0xdd, 0x26, 0x54, 
    0x5e, 0x96, 0xe5, 0x5b, 0x87, 0x4b, 0xe9, 0x09
};

typedef struct {
    ALG_ID aiKey;
    ALG_ID aiHash;
    PBYTE pbBaseData;
    DWORD cbBaseData;
    PBYTE pbExpectedKeyData;
} DERIVE_KEY_INFO, *PDERIVE_KEY_INFO;

DWORD DoDeriveKey(
    PTHREAD_DATA pThreadData,
    PDERIVE_KEY_INFO pDeriveKeyInfo)
{
    BOOL fSuccess = FALSE;
    DWORD dwError = ERROR_SUCCESS;
    HCRYPTKEY hKey = 0;
    HCRYPTHASH hHash = 0;
    BYTE rgbKey [1000];
    DWORD cbKey = 0;
    DWORD cb = 0;

    if (! CryptCreateHash(
        pThreadData->hVerifyCtx, 
        pDeriveKeyInfo->aiHash,
        0, 0, &hHash))
    {
        printf("CryptCreateHash ");
        goto Ret;
    }

    if (! CryptHashData(
        hHash, 
        pDeriveKeyInfo->pbBaseData,
        pDeriveKeyInfo->cbBaseData,
        0))
    {
        printf("CryptHashData ");
        goto Ret;
    }

    if (! CryptDeriveKey(
        pThreadData->hVerifyCtx,
        pDeriveKeyInfo->aiKey,
        hHash, 
        CRYPT_EXPORTABLE, 
        &hKey))
    {
        printf("CryptDeriveKey ");
        goto Ret;
    }

    cbKey = sizeof(rgbKey);
    if (! CryptExportKey(
        hKey, 0, PLAINTEXTKEYBLOB,
        0, rgbKey, &cbKey))
    {
        printf("CryptExportKey ");
        goto Ret;
    }

    cb = sizeof(DWORD);
    if (! CryptGetKeyParam(
        hKey, KP_KEYLEN, (PBYTE) &cbKey,
        &cb, 0))
    {
        printf("CryptGetKeyParam ");
        goto Ret;
    }

    if (memcmp(
        pDeriveKeyInfo->pbExpectedKeyData,
        rgbKey + sizeof(BLOBHEADER) + sizeof(DWORD),
        cbKey / 8))
    {
        printf(
            "ERROR: Incorrect key data for key alg %x; hash alg %x ",
            pDeriveKeyInfo->aiKey,
            pDeriveKeyInfo->aiHash);
        goto Ret;
    }

    fSuccess = TRUE;
Ret:
    if (! fSuccess)
    {
        dwError = GetLastError();

        if (0 == dwError)
            dwError = -1;
    }
    
    if (hKey)
        CryptDestroyKey(hKey);
    if (hHash)
        CryptDestroyHash(hHash);
    
    return dwError;
}

//
// Function: NewShaModesDeriveKeyRegression
//
DWORD NewShaModesDeriveKeyRegression(PTHREAD_DATA pThreadData)
{
    DERIVE_KEY_INFO DeriveKeyInfo;
    BOOL fSuccess = FALSE;
    DWORD dwError = ERROR_SUCCESS;
    ALG_ID rgKeyAlgs [] = { 
        CALG_AES_128, CALG_AES_192, CALG_AES_256
    };
    DWORD dw;

    for (dw = 0; dw < (sizeof(rgKeyAlgs) / sizeof(ALG_ID)); dw++)
    {
        DeriveKeyInfo.aiKey = rgKeyAlgs[dw];

        //
        // SHA-256 Derive Key Test
        //
        DeriveKeyInfo.aiHash = CALG_SHA_256;
        DeriveKeyInfo.cbBaseData = l_cbSha256Test1;
        DeriveKeyInfo.pbBaseData = l_rgSha256Test1;
        DeriveKeyInfo.pbExpectedKeyData = l_rgbSha256Result1;

        dwError = DoDeriveKey(pThreadData, &DeriveKeyInfo);

        if (ERROR_SUCCESS != dwError)
            goto Ret;

        //
        // SHA-384 Derive Key Test
        //
        DeriveKeyInfo.aiHash = CALG_SHA_384;
        DeriveKeyInfo.cbBaseData = l_cbSha384Test1;
        DeriveKeyInfo.pbBaseData = l_rgSha384Test1;
        DeriveKeyInfo.pbExpectedKeyData = l_rgbSha384Result1;

        dwError = DoDeriveKey(pThreadData, &DeriveKeyInfo);

        if (ERROR_SUCCESS != dwError)
            goto Ret;

        //
        // SHA-512 Derive Key Test
        //
        DeriveKeyInfo.aiHash = CALG_SHA_512;
        DeriveKeyInfo.cbBaseData = l_cbSha512Test1;
        DeriveKeyInfo.pbBaseData = l_rgSha512Test1;
        DeriveKeyInfo.pbExpectedKeyData = l_rgbSha512Result1;

        dwError = DoDeriveKey(pThreadData, &DeriveKeyInfo);

        if (ERROR_SUCCESS != dwError)
            goto Ret;
    }

    fSuccess = TRUE;
Ret:
    if (! fSuccess)
    {
        if (0 == dwError)
            dwError = -1;
    }
    
    return dwError;
}

typedef struct {
    ALG_ID aiHash;
    PBYTE pbKeyData;
    DWORD cbKeyData;
    PBYTE pbExpectedHash;
} HASH_SESSION_KEY_INFO, *PHASH_SESSION_KEY_INFO;

DWORD DoHashSessionKey(
    PTHREAD_DATA pThreadData,
    PHASH_SESSION_KEY_INFO pHashSessionKeyInfo)
{
    DWORD dwError = ERROR_SUCCESS;
    BOOL fSuccess = FALSE;
    HCRYPTHASH hHash = 0;
    HCRYPTKEY hKey = 0;
    BYTE rgbHash [1000];
    DWORD cbHash = 0;
    BYTE rgbKey [1000];
    DWORD cbKey = 0;
    BLOBHEADER *pBlobHeader = (BLOBHEADER *) rgbKey;
    DWORD *pdw = (DWORD *)(rgbKey + sizeof(BLOBHEADER));

    pBlobHeader->aiKeyAlg = CALG_RC2;
    pBlobHeader->bType = PLAINTEXTKEYBLOB;
    pBlobHeader->bVersion = CUR_BLOB_VERSION;
    pBlobHeader->reserved = 0x0000;

    *pdw = pHashSessionKeyInfo->cbKeyData;

    memcpy(
        rgbKey + sizeof(BLOBHEADER) + sizeof(DWORD),
        pHashSessionKeyInfo->pbKeyData,
        pHashSessionKeyInfo->cbKeyData);

    if (! CryptImportKey(
        pThreadData->hVerifyCtx, 
        rgbKey,
        sizeof(BLOBHEADER) + sizeof(DWORD) + pHashSessionKeyInfo->cbKeyData,
        0, CRYPT_IPSEC_HMAC_KEY, &hKey))
    {
        printf("CryptImportKey ");
        goto Ret;
    }

    if (! CryptCreateHash(
        pThreadData->hVerifyCtx, 
        pHashSessionKeyInfo->aiHash,
        0, 0, &hHash))
    {
        printf("CryptCreateHash ");
        goto Ret;
    }

    if (! CryptHashSessionKey(
        hHash, hKey, CRYPT_LITTLE_ENDIAN))
    {
        printf("CryptHashSessionKey ");
        goto Ret;
    }

    cbHash = sizeof(rgbHash);
    if (! CryptGetHashParam(
        hHash, HP_HASHVAL,
        rgbHash, &cbHash, 0))
    {
        printf("CryptGetHashParam ");
        goto Ret;
    }

    if (0 == cbHash || memcmp(
        rgbHash,
        pHashSessionKeyInfo->pbExpectedHash,
        cbHash))
    {
        printf(
            "ERROR: Incorrect hash result for hash alg 0x%x ",
            pHashSessionKeyInfo->aiHash);
        goto Ret;
    }
                 
    fSuccess = TRUE;
Ret:
    if (! fSuccess)
    {
        dwError = GetLastError();

        if (0 == dwError)
            dwError = -1;
    }
    
    if (hHash)
        CryptDestroyHash(hHash);
    if (hKey)
        CryptDestroyKey(hKey);
    
    return dwError;
}

//
// Function: NewShaModesHashSessionKeyRegression
//
DWORD NewShaModesHashSessionKeyRegression(PTHREAD_DATA pThreadData)
{
    DWORD dwError = ERROR_SUCCESS;
    BOOL fSuccess = FALSE;
    HASH_SESSION_KEY_INFO HashSessionKeyInfo;

    //
    // SHA-256 CryptHashSessionKey Test
    //
    HashSessionKeyInfo.aiHash = CALG_SHA_256;
    HashSessionKeyInfo.pbKeyData = l_rgSha256Test2;
    HashSessionKeyInfo.cbKeyData = l_cbSha256Test2;
    HashSessionKeyInfo.pbExpectedHash = l_rgbSha256Result2;

    dwError = DoHashSessionKey(pThreadData, &HashSessionKeyInfo);

    if (ERROR_SUCCESS != dwError)
        goto Ret;

    //
    // SHA-384 CryptHashSessionKey Test
    //
    HashSessionKeyInfo.aiHash = CALG_SHA_384;
    HashSessionKeyInfo.pbKeyData = l_rgSha384Test2;
    HashSessionKeyInfo.cbKeyData = l_cbSha384Test2;
    HashSessionKeyInfo.pbExpectedHash = l_rgbSha384Result2;

    dwError = DoHashSessionKey(pThreadData, &HashSessionKeyInfo);

    if (ERROR_SUCCESS != dwError)
        goto Ret;
    //
    // SHA-512 CryptHashSessionKey Test
    //
    HashSessionKeyInfo.aiHash = CALG_SHA_512;
    HashSessionKeyInfo.pbKeyData = l_rgSha512Test2;
    HashSessionKeyInfo.cbKeyData = l_cbSha512Test2;
    HashSessionKeyInfo.pbExpectedHash = l_rgbSha512Result2;

    dwError = DoHashSessionKey(pThreadData, &HashSessionKeyInfo);

    if (ERROR_SUCCESS != dwError)
        goto Ret;

    fSuccess = TRUE;

Ret:
    if (! fSuccess)
    {
        if (0 == dwError)
            dwError = -1;
    }
    
    return dwError;
}

//
// Function: NewShaModesBasicRegression
//
DWORD NewShaModesBasicRegression(PTHREAD_DATA pThreadData)
{
    HCRYPTHASH hHash = 0;
    BYTE rgbResult[64];
    DWORD cbResult = 0;
    BOOL fSuccess = FALSE;
    DWORD dwError = ERROR_SUCCESS;

    //
    // SHA-256 Tests
    //

    // Test 1
    if (! CryptCreateHash(
        pThreadData->hVerifyCtx, CALG_SHA_256, 0, 0, &hHash))
    {
        printf("CryptCreateHash ");
        goto Ret;
    }

    if (! CryptHashData(
        hHash, l_rgSha256Test1, l_cbSha256Test1, 0))
    {
        printf("CryptHashData ");
        goto Ret;
    }

    cbResult = sizeof(rgbResult);
    if (! CryptGetHashParam(
        hHash, HP_HASHVAL, rgbResult, &cbResult, 0))
    {
        printf("CryptGetHashParam ");
        goto Ret;
    }

    if (memcmp(rgbResult, l_rgbSha256Result1, sizeof(l_rgbSha256Result1)))
    {
        printf("ERROR: Incorrect hash result for SHA-256 1 ");
        goto Ret;
    }

    if (! CryptDestroyHash(hHash))
    {
        printf("CryptDestroyHash ");
        goto Ret;
    }
    hHash = 0;

    // Test 2
    if (! CryptCreateHash(
        pThreadData->hVerifyCtx, CALG_SHA_256, 0, 0, &hHash))
    {
        printf("CryptCreateHash ");
        goto Ret;
    }

    if (! CryptHashData(
        hHash, l_rgSha256Test2, l_cbSha256Test2, 0))
    {
        printf("CryptHashData ");
        goto Ret;
    }

    cbResult = sizeof(rgbResult);
    if (! CryptGetHashParam(
        hHash, HP_HASHVAL, rgbResult, &cbResult, 0))
    {
        printf("CryptGetHashParam ");
        goto Ret;
    }

    if (memcmp(rgbResult, l_rgbSha256Result2, sizeof(l_rgbSha256Result2)))
    {
        printf("ERROR: Incorrect hash result for SHA-256 2 ");
        goto Ret;
    }

    if (! CryptDestroyHash(hHash))
    {
        printf("CryptDestroyHash ");
        goto Ret;
    }
    hHash = 0;

    //
    // SHA-384 Tests
    //

    // Test 1
    if (! CryptCreateHash(
        pThreadData->hVerifyCtx, CALG_SHA_384, 0, 0, &hHash))
    {
        printf("CryptCreateHash ");
        goto Ret;
    }

    if (! CryptHashData(
        hHash, l_rgSha384Test1, l_cbSha384Test1, 0))
    {
        printf("CryptHashData ");
        goto Ret;
    }

    cbResult = sizeof(rgbResult);
    if (! CryptGetHashParam(
        hHash, HP_HASHVAL, rgbResult, &cbResult, 0))
    {
        printf("CryptGetHashParam ");
        goto Ret;
    }

    if (memcmp(rgbResult, l_rgbSha384Result1, sizeof(l_rgbSha384Result1)))
    {
        printf("ERROR: Incorrect hash result for SHA-384 1 ");
        goto Ret;
    }

    if (! CryptDestroyHash(hHash))
    {
        printf("CryptDestroyHash ");
        goto Ret;
    }
    hHash = 0;

    // Test 2
    if (! CryptCreateHash(
        pThreadData->hVerifyCtx, CALG_SHA_384, 0, 0, &hHash))
    {
        printf("CryptCreateHash ");
        goto Ret;
    }

    if (! CryptHashData(
        hHash, l_rgSha384Test2, l_cbSha384Test2, 0))
    {
        printf("CryptHashData ");
        goto Ret;
    }

    cbResult = sizeof(rgbResult);
    if (! CryptGetHashParam(
        hHash, HP_HASHVAL, rgbResult, &cbResult, 0))
    {
        printf("CryptGetHashParam ");
        goto Ret;
    }

    if (memcmp(rgbResult, l_rgbSha384Result2, sizeof(l_rgbSha384Result2)))
    {
        printf("ERROR: Incorrect hash result for SHA-384 2 ");
        goto Ret;
    }

    if (! CryptDestroyHash(hHash))
    {
        printf("CryptDestroyHash ");
        goto Ret;
    }
    hHash = 0;

    //
    // SHA-512 Tests
    //

    // Test 1
    if (! CryptCreateHash(
        pThreadData->hVerifyCtx, CALG_SHA_512, 0, 0, &hHash))
    {
        printf("CryptCreateHash ");
        goto Ret;
    }

    if (! CryptHashData(
        hHash, l_rgSha512Test1, l_cbSha512Test1, 0))
    {
        printf("CryptHashData ");
        goto Ret;
    }

    cbResult = sizeof(rgbResult);
    if (! CryptGetHashParam(
        hHash, HP_HASHVAL, rgbResult, &cbResult, 0))
    {
        printf("CryptGetHashParam ");
        goto Ret;
    }

    if (memcmp(rgbResult, l_rgbSha512Result1, sizeof(l_rgbSha512Result1)))
    {
        printf("ERROR: Incorrect hash result for SHA-512 1 ");
        goto Ret;
    }

    if (! CryptDestroyHash(hHash))
    {
        printf("CryptDestroyHash ");
        goto Ret;
    }
    hHash = 0;

    // Test 2
    if (! CryptCreateHash(
        pThreadData->hVerifyCtx, CALG_SHA_512, 0, 0, &hHash))
    {
        printf("CryptCreateHash ");
        goto Ret;
    }

    if (! CryptHashData(
        hHash, l_rgSha512Test2, l_cbSha512Test2, 0))
    {
        printf("CryptHashData ");
        goto Ret;
    }

    cbResult = sizeof(rgbResult);
    if (! CryptGetHashParam(
        hHash, HP_HASHVAL, rgbResult, &cbResult, 0))
    {
        printf("CryptGetHashParam ");
        goto Ret;
    }

    if (memcmp(rgbResult, l_rgbSha512Result2, sizeof(l_rgbSha512Result2)))
    {
        printf("ERROR: Incorrect hash result for SHA-512 2 ");
        goto Ret;
    }

    fSuccess = TRUE;
Ret:
    if (! fSuccess)
    {
        dwError = GetLastError();

        if (0 == dwError)
            dwError = -1;
    }
    
    if (hHash)
        CryptDestroyHash(hHash);
    
    return dwError;
}

typedef struct _DERIVE_KEY_DATA
{
    ALG_ID aiKey;
    ALG_ID aiHash;
    PBYTE pbPassword;
    DWORD cbPassword;
    PBYTE pbPlaintext;
    DWORD cbPlaintext;
} DERIVE_KEY_DATA, *PDERIVE_KEY_DATA;

DWORD DeriveAndCompareAesKey(
    PTHREAD_DATA pThreadData,
    PDERIVE_KEY_DATA pDeriveKeyData)
{
    HCRYPTKEY hDeriveKey = 0;
    HCRYPTKEY hCompareKey = 0;
    HCRYPTHASH hDeriveHash = 0;
    HCRYPTHASH hCompareHash = 0;
    BYTE rgbStringA[64];
    BYTE rgbStringB[64];
    BYTE rgbKey[64];
    BYTE rgbHashA[20];
    BYTE rgbHashB[20];
    PBYTE pbDeriveCiphertext = NULL;
    DWORD cbDeriveCiphertext = 0;
    PBYTE pbCompareCiphertext = NULL;
    DWORD cbCompareCiphertext = 0;
    DWORD cbHash = 0;
    DWORD cb = 0;
    DWORD cbKey = 0;
    BOOL fSuccess = FALSE;
    DWORD dwError = ERROR_SUCCESS;
    unsigned int i;

    memset(rgbStringA, 0, sizeof(rgbStringA));
    memset(rgbStringB, 0, sizeof(rgbStringB));
    memset(rgbKey, 0, sizeof(rgbKey));
    memset(rgbHashA, 0, sizeof(rgbHashA));
    memset(rgbHashB, 0, sizeof(rgbHashB));

    //
    // Derive a key from hashed password and encrypt.
    //

    if (! CryptCreateHash(
        pThreadData->hVerifyCtx,
        pDeriveKeyData->aiHash,
        0, 0, &hDeriveHash))
    {
        printf("CryptCreateHash ");
        goto Ret;
    }

    if (! CryptHashData(
        hDeriveHash, 
        pDeriveKeyData->pbPassword,
        pDeriveKeyData->cbPassword,
        0))
    {
        printf("CryptHashData ");
        goto Ret;
    }

    if (! CryptDeriveKey(
        pThreadData->hVerifyCtx,
        pDeriveKeyData->aiKey,
        hDeriveHash,
        0, &hDeriveKey))
    {
        printf("CryptDeriveKey ");
        goto Ret;
    }

    cbDeriveCiphertext = pDeriveKeyData->cbPlaintext;
    if (! CryptEncrypt(
        hDeriveKey,
        0, TRUE, 0, NULL,
        &cbDeriveCiphertext, 0))
    {
        printf("CryptEncrypt size ");
        goto Ret;
    }

    if (NULL == (pbDeriveCiphertext = 
                 (PBYTE) MyAlloc(cbDeriveCiphertext)))
        return ERROR_NOT_ENOUGH_MEMORY;

    memcpy(
        pbDeriveCiphertext, 
        pDeriveKeyData->pbPlaintext,
        pDeriveKeyData->cbPlaintext);

    cb = pDeriveKeyData->cbPlaintext;
    if (! CryptEncrypt(
        hDeriveKey,
        0, TRUE, 0, 
        pbDeriveCiphertext,
        &cb,
        cbDeriveCiphertext))
    {
        printf("CryptEncrypt ");
        goto Ret;
    }

    //
    // Now do the derive "manually" and compare
    // the result.
    //

    if (! CryptCreateHash(
        pThreadData->hVerifyCtx,
        pDeriveKeyData->aiHash,
        0, 0, &hCompareHash))
    {
        printf("CryptCreateHash ");
        goto Ret;
    }

    if (! CryptHashData(
        hCompareHash,
        pDeriveKeyData->pbPassword,
        pDeriveKeyData->cbPassword,
        0))
    {
        printf("CryptHashData ");
        goto Ret;
    }

    cbHash = sizeof(rgbHashA);
    if (! CryptGetHashParam(
        hCompareHash,
        HP_HASHVAL,
        rgbHashA,
        &cbHash, 0))
    {
        printf("CryptGetHashParam ");
        goto Ret;
    }

    if (! CryptDestroyHash(hCompareHash))
    {
        printf("CryptDestroyHash ");
        goto Ret;
    }
    hCompareHash = 0;

    memset(rgbStringA, 0x36, sizeof(rgbStringA));
    memset(rgbStringB, 0x5c, sizeof(rgbStringB));

    for (i = 0; i < cbHash; i++)
    {
        rgbStringA[i] ^= rgbHashA[i];
        rgbStringB[i] ^= rgbHashA[i];
    }

    ((BLOBHEADER *) rgbKey)->aiKeyAlg = pDeriveKeyData->aiKey;
    ((BLOBHEADER *) rgbKey)->bType = PLAINTEXTKEYBLOB;
    ((BLOBHEADER *) rgbKey)->bVersion = CUR_BLOB_VERSION;
    
    switch (pDeriveKeyData->aiKey)
    {
    case CALG_AES_128:
        cbKey = 16;
        break;
    case CALG_AES_192:
        cbKey = 24;
        break;
    case CALG_AES_256:
        cbKey = 32;
        break;
    default:
        printf("Bad Key Alg ");
        goto Ret;
    }

    *(DWORD *)(rgbKey + sizeof(BLOBHEADER)) = cbKey;

    if (! CryptCreateHash(
        pThreadData->hVerifyCtx,
        pDeriveKeyData->aiHash,
        0, 0, &hCompareHash))
    {
        printf("CryptCreateHash compare ");
        goto Ret;
    }

    if (! CryptHashData(
        hCompareHash, rgbStringA, sizeof(rgbStringA), 0))
    {
        printf("CryptHashData compare ");
        goto Ret;
    }

    memset(rgbHashA, 0, sizeof(rgbHashA));
    cbHash = sizeof(rgbHashA);
    if (! CryptGetHashParam(
        hCompareHash, HP_HASHVAL,
        rgbHashA, 
        &cbHash, 0))
    {
        printf("CryptGetHashParam ");
        goto Ret;
    }

    if (! CryptDestroyHash(hCompareHash))
    {
        printf("CryptDestroyHash ");
        goto Ret;
    }
    hCompareHash = 0;

    if (! CryptCreateHash(
        pThreadData->hVerifyCtx,
        pDeriveKeyData->aiHash,
        0, 0, &hCompareHash))
    {
        printf("CryptCreateHash compare 2 ");
        goto Ret;
    }

    if (! CryptHashData(
        hCompareHash, rgbStringB, sizeof(rgbStringB), 0))
    {
        printf("CryptHashData compare 2 ");
        goto Ret;
    }

    cbHash = sizeof(rgbHashB);
    if (! CryptGetHashParam(
        hCompareHash, HP_HASHVAL,
        rgbHashB,
        &cbHash, 0))
    {
        printf("CryptGetHashParam 2 ");
        goto Ret;
    }

    cb = sizeof(BLOBHEADER) + sizeof(DWORD);
    memcpy(
        rgbKey + cb,
        rgbHashA,
        min(cbKey, cbHash));

    if (cbKey > cbHash)
    {
        cb += cbHash;
        memcpy(
            rgbKey + cb,
            rgbHashB,
            min(cbKey - cbHash, cbHash));
    }

    if (! CryptImportKey(
        pThreadData->hVerifyCtx,
        rgbKey, 
        sizeof(BLOBHEADER) + sizeof(DWORD) + cbKey,
        0, 0, &hCompareKey))
    {
        printf("CryptImportKey ");
        goto Ret;
    }

    cbCompareCiphertext = pDeriveKeyData->cbPlaintext;
    if (! CryptEncrypt(
        hCompareKey,
        0, TRUE, 0, NULL,
        &cbCompareCiphertext, 0))
    {
        printf("CryptEncrypt size compare ");
        goto Ret;
    }

    if (NULL == (pbCompareCiphertext = 
                 (PBYTE) MyAlloc(cbCompareCiphertext)))
        return ERROR_NOT_ENOUGH_MEMORY;

    memcpy(
        pbCompareCiphertext, 
        pDeriveKeyData->pbPlaintext,
        pDeriveKeyData->cbPlaintext);

    cb = pDeriveKeyData->cbPlaintext;
    if (! CryptEncrypt(
        hCompareKey,
        0, TRUE, 0, 
        pbCompareCiphertext,
        &cb,
        cbCompareCiphertext))
    {
        printf("CryptEncrypt compare ");
        goto Ret;
    }

    //
    // Now compare cipher results for the two methods.
    //

    if (cbCompareCiphertext != cbDeriveCiphertext ||
        0 != memcmp(
            pbCompareCiphertext, pbDeriveCiphertext, cbDeriveCiphertext))
    {
        printf(
            "Cipher result mismatch for KeyAlg %x ; HashAlg %x", 
            pDeriveKeyData->aiKey,
            pDeriveKeyData->aiHash);

        PrintBytes(
            "Derived ciphertext",
            pbDeriveCiphertext,
            cbDeriveCiphertext);

        PrintBytes(
            "Compare ciphertext",
            pbCompareCiphertext,
            cbCompareCiphertext);
    }

    //
    // Now decrypt with both keys and compare result.
    //

    if (! CryptDecrypt(
        hDeriveKey,
        0, TRUE, 0,
        pbDeriveCiphertext,
        &cbDeriveCiphertext))
    {
        printf("CryptDecrypt ");
        goto Ret;
    }

    if (! CryptDecrypt(
        hCompareKey,
        0, TRUE, 0,
        pbCompareCiphertext,
        &cbCompareCiphertext))
    {
        printf("CryptDecrypt compare ");
        goto Ret;
    }

    if (cbCompareCiphertext != cbDeriveCiphertext ||
        0 != memcmp(
            pbCompareCiphertext, pbDeriveCiphertext, cbDeriveCiphertext))
    {
        printf(
            "Decrypt result mismatch for KeyAlg %x ; HashAlg %x", 
            pDeriveKeyData->aiKey,
            pDeriveKeyData->aiHash);

        PrintBytes(
            "Derived plaintext",
            pbDeriveCiphertext,
            cbDeriveCiphertext);

        PrintBytes(
            "Compare plaintext",
            pbCompareCiphertext,
            cbCompareCiphertext);
    }

    fSuccess = TRUE;
Ret:
    if (! fSuccess)
    {
        dwError = GetLastError();

        if (0 == dwError)
            dwError = -1;
    }
    
    if (hDeriveKey)
        CryptDestroyKey(hDeriveKey);
    if (hCompareKey)
        CryptDestroyKey(hCompareKey);
    if (hDeriveHash)
        CryptDestroyHash(hDeriveHash);
    if (hCompareHash)
        CryptDestroyHash(hCompareHash);
    if (pbDeriveCiphertext)
        MyFree(pbDeriveCiphertext);
    if (pbCompareCiphertext)
        MyFree(pbCompareCiphertext);
    
    return dwError;
}

//
// Function: AesDeriveKeyRegression
//
DWORD AesDeriveKeyRegression(PTHREAD_DATA pThreadData)
{
    DWORD dwError               = ERROR_SUCCESS;
    BOOL fSuccess               = FALSE;
    DERIVE_KEY_DATA DeriveKeyData;
    BYTE rgbPlaintext[99];
    LPSTR pszPassword = "My Password";
    ALG_ID Hashes[] = { CALG_SHA, CALG_MD5 };
    DWORD cHashes = sizeof(Hashes) / sizeof(ALG_ID);
    ALG_ID Keys[] = { CALG_AES_128, CALG_AES_192, CALG_AES_256 };
    DWORD cKeys = sizeof(Keys) / sizeof(ALG_ID);
    unsigned int i, iHash, iKey;

    for (i = 0; i < sizeof(rgbPlaintext); i++)
        rgbPlaintext[i] = (BYTE) i;

    DeriveKeyData.pbPlaintext = rgbPlaintext;
    DeriveKeyData.cbPlaintext = sizeof(rgbPlaintext);
    DeriveKeyData.pbPassword = (PBYTE) pszPassword;
    DeriveKeyData.cbPassword = strlen(pszPassword);

    for (iHash = 0; iHash < cHashes; iHash++)
    {
        DeriveKeyData.aiHash = Hashes[iHash];

        for (iKey = 0; iKey < cKeys; iKey++)
        {
            DeriveKeyData.aiKey = Keys[iKey];

            if (ERROR_SUCCESS != 
                (dwError = DeriveAndCompareAesKey(
                            pThreadData, &DeriveKeyData)))
            {
                printf("DeriveAndCompareAesKey ");
                goto Ret;
            }
        }
    }

    fSuccess = TRUE;
Ret:
    if (! fSuccess)
    {
        printf("- error 0x%x\n", dwError);

        if (0 == dwError)
            dwError = -1;
    }

    return dwError;
}

//
// Function: UnalignedImportExportRegression
//
DWORD UnalignedImportExportRegression(PTHREAD_DATA pThreadData)
{
    DWORD dwError               = ERROR_SUCCESS;
    BYTE rgbKeyBuf[2000];
    DWORD cbKeyBuf              = sizeof(rgbKeyBuf);
    PBYTE pbKeyBuf              = NULL;
    HCRYPTKEY hKey              = 0;
    HCRYPTKEY hWrapKey          = 0;
    BOOL fSuccess               = FALSE;

    if (! CryptGenKey(
        pThreadData->hProv, CALG_RC2, 0, &hWrapKey))
    {
        printf("CryptGenKey CALG_RC2 ");
        goto Ret;
    }

    //
    // 1a) Exchange key pair PRIVATEKEYBLOB
    //

    // Unalign the output buffer
    pbKeyBuf = rgbKeyBuf + 1;
    cbKeyBuf = sizeof(rgbKeyBuf) - 1;

    if (! CryptExportKey(
        pThreadData->hExchangeKey, 0, PRIVATEKEYBLOB, 0, pbKeyBuf, &cbKeyBuf)) 
    {
        printf("CryptExportKey KeyEx PRIVATEKEYBLOB ");
        goto Ret;
    }

    if (! CryptImportKey(
        pThreadData->hProv, pbKeyBuf, cbKeyBuf, 0, CRYPT_EXPORTABLE, &hKey))
    {
        printf("CryptImportKey KeyEx PRIVATEKEYBLOB ");
        goto Ret;
    }

    if (! CryptDestroyKey(hKey)) 
    {
        printf("CryptDestroyKey KeyEx PRIVATEKEYBLOB ");
        goto Ret;
    }

    //
    // 1b) Exchange key pair PRIVATEKEYBLOB, encrypted
    //

    // Unalign the output buffer
    pbKeyBuf = rgbKeyBuf + 1;
    cbKeyBuf = sizeof(rgbKeyBuf) - 1;

    if (! CryptExportKey(
        pThreadData->hExchangeKey, 
        hWrapKey, 
        PRIVATEKEYBLOB, 
        0, 
        pbKeyBuf, 
        &cbKeyBuf)) 
    {
        printf("CryptExportKey KeyEx PRIVATEKEYBLOB b ");
        goto Ret;
    }

    if (! CryptImportKey(
        pThreadData->hProv, 
        pbKeyBuf, 
        cbKeyBuf, 
        hWrapKey, 
        CRYPT_EXPORTABLE, 
        &hKey))
    {
        printf("CryptImportKey KeyEx PRIVATEKEYBLOB b ");
        goto Ret;
    }

    if (! CryptDestroyKey(hKey)) 
    {
        printf("CryptDestroyKey KeyEx PRIVATEKEYBLOB b ");
        goto Ret;
    }

    //
    // 2) Exchange key pair PUBLICKEYBLOB
    //

    // Unalign the output buffer
    pbKeyBuf = rgbKeyBuf + 1;
    cbKeyBuf = sizeof(rgbKeyBuf) - 1;

    if (! CryptExportKey(
        pThreadData->hExchangeKey, 0, PUBLICKEYBLOB, 0, pbKeyBuf, &cbKeyBuf)) 
    {
        printf("CryptExportKey KeyEx PUBLICKEYBLOB ");
        goto Ret;
    }

    if (! CryptImportKey(
        pThreadData->hProv, 
        pbKeyBuf, 
        cbKeyBuf, 
        pThreadData->dwProvType == PROV_DSS_DH ? pThreadData->hExchangeKey : 0,
        0, 
        &hKey))
    {
        printf("CryptImportKey KeyEx PUBLICKEYBLOB ");
        goto Ret;
    }    

    if (! CryptDestroyKey(hKey)) 
    {
        printf("CryptDestroyKey KeyEx PUBLICKEYBLOB ");
        goto Ret;
    }

    //
    // 3a) Signature key pair PRIVATEKEYBLOB
    //

    // Unalign the output buffer
    pbKeyBuf = rgbKeyBuf + 1;
    cbKeyBuf = sizeof(rgbKeyBuf) - 1;

    if (! CryptExportKey(
        pThreadData->hSignatureKey, 0, PRIVATEKEYBLOB, 0, pbKeyBuf, &cbKeyBuf)) 
    {
        printf("CryptExportKey Sig PRIVATEKEYBLOB ");
        goto Ret;
    }

    if (! CryptImportKey(
        pThreadData->hProv, pbKeyBuf, cbKeyBuf, 0, CRYPT_EXPORTABLE, &hKey))
    {
        printf("CryptImportKey Sig PRIVATEKEYBLOB ");
        goto Ret;
    }

    if (! CryptDestroyKey(hKey)) 
    {
        printf("CryptDestroyKey Sig PRIVATEKEYBLOB ");
        goto Ret;
    }

    //
    // 3b) Signature key pair PRIVATEKEYBLOB, encrypted
    //

    // Unalign the output buffer
    pbKeyBuf = rgbKeyBuf + 1;
    cbKeyBuf = sizeof(rgbKeyBuf) - 1;

    if (! CryptExportKey(
        pThreadData->hSignatureKey, 
        hWrapKey, 
        PRIVATEKEYBLOB, 
        0, 
        pbKeyBuf, 
        &cbKeyBuf)) 
    {
        printf("CryptExportKey Sig PRIVATEKEYBLOB b ");
        goto Ret;
    }

    if (! CryptImportKey(
        pThreadData->hProv, 
        pbKeyBuf, 
        cbKeyBuf, 
        hWrapKey, 
        CRYPT_EXPORTABLE, 
        &hKey))
    {
        printf("CryptImportKey Sig PRIVATEKEYBLOB b ");
        goto Ret;
    }

    if (! CryptDestroyKey(hKey)) 
    {
        printf("CryptDestroyKey Sig PRIVATEKEYBLOB b ");
        goto Ret;
    }

    if (! CryptDestroyKey(hWrapKey))
    {
        printf("CryptDestroyKey CALG_RC2 ");
        goto Ret;
    }

    //
    // 4) Signature key pair PUBLICKEYBLOB
    //

    // Unalign the output buffer
    pbKeyBuf = rgbKeyBuf + 1;
    cbKeyBuf = sizeof(rgbKeyBuf) - 1;

    if (! CryptExportKey(
        pThreadData->hSignatureKey, 0, PUBLICKEYBLOB, 0, pbKeyBuf, &cbKeyBuf)) 
    {
        printf("CryptExportKey Sig PUBLICKEYBLOB ");
        goto Ret;
    }

    if (! CryptImportKey(
        pThreadData->hProv, pbKeyBuf, cbKeyBuf, 0, 0, &hKey))
    {
        printf("CryptImportKey Sig PUBLICKEYBLOB ");
        goto Ret;
    }

    if (! CryptDestroyKey(hKey)) 
    {
        printf("CryptDestroyKey Sig PUBLICKEYBLOB ");
        goto Ret;
    }

    //
    // 5) SIMPLEBLOB
    //

    if (pThreadData->dwProvType != PROV_DSS_DH &&
        pThreadData->dwProvType != PROV_DSS)
    {
        //
        // 5.1) Use PKCS2 padding.
        //

        if (! CryptGenKey(
            pThreadData->hProv, CALG_RC2, CRYPT_EXPORTABLE, &hKey))
        {
            printf("CryptGenKey CALG_RC2 SIMPLEBLOB ");
            goto Ret;
        }
    
        // Unalign the output buffer
        pbKeyBuf = rgbKeyBuf + 1;
        cbKeyBuf = sizeof(rgbKeyBuf) - 1;
    
        if (! CryptExportKey(
            hKey, pThreadData->hExchangeKey, SIMPLEBLOB, 0, pbKeyBuf, &cbKeyBuf)) 
        {
            printf("CryptExportKey SIMPLEBLOB ");
            goto Ret;
        }
    
        if (! CryptDestroyKey(hKey)) 
        {
            printf("CryptDestroyKey CALG_RC2 A SIMPLEBLOB ");
            goto Ret;
        }
    
        if (! CryptImportKey(
            pThreadData->hProv, pbKeyBuf, cbKeyBuf, pThreadData->hExchangeKey, 0, &hKey))
        {
            printf("CryptImportKey SIMPLEBLOB ");
            goto Ret;
        }
    
        if (! CryptDestroyKey(hKey)) 
        {
            printf("CryptDestroyKey CALG_RC2 B SIMPLEBLOB ");
            goto Ret;
        }
        
        //
        // 5.2) Use OAEP padding.
        //

        if (! CryptGenKey(
            pThreadData->hProv, CALG_RC2, CRYPT_EXPORTABLE, &hKey))
        {
            printf("CryptGenKey CALG_RC2 SIMPLEBLOB OAEP ");
            goto Ret;
        }
    
        // Unalign the output buffer
        pbKeyBuf = rgbKeyBuf + 1;
        cbKeyBuf = sizeof(rgbKeyBuf) - 1;
    
        if (! CryptExportKey(
            hKey, pThreadData->hExchangeKey, SIMPLEBLOB, CRYPT_OAEP, pbKeyBuf, &cbKeyBuf)) 
        {
            printf("CryptExportKey SIMPLEBLOB OAEP ");
            goto Ret;
        }
    
        if (! CryptDestroyKey(hKey)) 
        {
            printf("CryptDestroyKey CALG_RC2 A SIMPLEBLOB OAEP ");
            goto Ret;
        }
    
        if (! CryptImportKey(
            pThreadData->hProv, pbKeyBuf, cbKeyBuf, pThreadData->hExchangeKey, CRYPT_OAEP, &hKey))
        {
            printf("CryptImportKey SIMPLEBLOB OAEP ");
            goto Ret;
        }
    
        if (! CryptDestroyKey(hKey)) 
        {
            printf("CryptDestroyKey CALG_RC2 B SIMPLEBLOB OAEP ");
            goto Ret;
        }
    }

    //
    // 6) SYMMETRICWRAPKEYBLOB
    //

    if (! CryptGenKey(
        pThreadData->hProv, CALG_RC2, CRYPT_EXPORTABLE, &hKey))
    {
        printf("CryptGenKey CALG_RC2 SYMMETRICWRAPKEYBLOB A ");
        goto Ret;
    }

    if (! CryptGenKey(
        pThreadData->hProv, CALG_RC2, CRYPT_EXPORTABLE, &hWrapKey))
    {
        printf("CryptGenKey CALG_RC2 SYMMETRICWRAPKEYBLOB B ");
        goto Ret;
    }

    // Unalign the output buffer
    pbKeyBuf = rgbKeyBuf + 1;
    cbKeyBuf = sizeof(rgbKeyBuf) - 1;

    if (! CryptExportKey(
        hKey, hWrapKey, SYMMETRICWRAPKEYBLOB, 0, pbKeyBuf, &cbKeyBuf)) 
    {
        printf("CryptExportKey SYMMETRICWRAPKEYBLOB ");
        goto Ret;
    }

    if (! CryptDestroyKey(hKey)) 
    {
        printf("CryptDestroyKey CALG_RC2 A SYMMETRICWRAPKEYBLOB ");
        goto Ret;
    }

    if (! CryptImportKey(
        pThreadData->hProv, pbKeyBuf, cbKeyBuf, hWrapKey, 0, &hKey))
    {
        printf("CryptImportKey SYMMETRICWRAPKEYBLOB ");
        goto Ret;
    }

    if (! CryptDestroyKey(hKey)) 
    {
        printf("CryptDestroyKey CALG_RC2 B SYMMETRICWRAPKEYBLOB ");
        goto Ret;
    }

    if (! CryptDestroyKey(hWrapKey)) 
    {
        printf("CryptDestroyKey CALG_RC2 C SYMMETRICWRAPKEYBLOB ");
        goto Ret;
    }

    //
    // 7) PLAINTEXTKEYBLOB
    //

    if (! CryptGenKey(
        pThreadData->hProv, CALG_RC2, CRYPT_EXPORTABLE, &hKey))
    {
        printf("CryptGenKey CALG_RC2 PLAINTEXTKEYBLOB ");
        goto Ret;
    }

    // Unalign the output buffer
    pbKeyBuf = rgbKeyBuf + 1;
    cbKeyBuf = sizeof(rgbKeyBuf) - 1;

    if (! CryptExportKey(
        hKey, 0, PLAINTEXTKEYBLOB, 0, pbKeyBuf, &cbKeyBuf)) 
    {
        printf("CryptExportKey PLAINTEXTKEYBLOB ");
        goto Ret;
    }

    if (! CryptDestroyKey(hKey)) 
    {
        printf("CryptDestroyKey CALG_RC2 A PLAINTEXTKEYBLOB ");
        goto Ret;
    }

    if (! CryptImportKey(
        pThreadData->hProv, pbKeyBuf, cbKeyBuf, 0, 0, &hKey))
    {
        printf("CryptImportKey PLAINTEXTKEYBLOB ");
        goto Ret;
    }

    if (! CryptDestroyKey(hKey)) 
    {
        printf("CryptDestroyKey CALG_RC2 B PLAINTEXTKEYBLOB ");
        goto Ret;
    }

    fSuccess = TRUE;
Ret:
    if (! fSuccess)
        printf("- error 0x%x\n", dwError = GetLastError());
    
    return dwError;
}

static BYTE rgbPrivateKeyWithExponentOfOne[] =
{
   0x07, 0x02, 0x00, 0x00, 0x00, 0xA4, 0x00, 0x00,
   0x52, 0x53, 0x41, 0x32, 0x00, 0x02, 0x00, 0x00,
   0x01, 0x00, 0x00, 0x00, 0xAB, 0xEF, 0xFA, 0xC6,
   0x7D, 0xE8, 0xDE, 0xFB, 0x68, 0x38, 0x09, 0x92,
   0xD9, 0x42, 0x7E, 0x6B, 0x89, 0x9E, 0x21, 0xD7,
   0x52, 0x1C, 0x99, 0x3C, 0x17, 0x48, 0x4E, 0x3A,
   0x44, 0x02, 0xF2, 0xFA, 0x74, 0x57, 0xDA, 0xE4,
   0xD3, 0xC0, 0x35, 0x67, 0xFA, 0x6E, 0xDF, 0x78,
   0x4C, 0x75, 0x35, 0x1C, 0xA0, 0x74, 0x49, 0xE3,
   0x20, 0x13, 0x71, 0x35, 0x65, 0xDF, 0x12, 0x20,
   0xF5, 0xF5, 0xF5, 0xC1, 0xED, 0x5C, 0x91, 0x36,
   0x75, 0xB0, 0xA9, 0x9C, 0x04, 0xDB, 0x0C, 0x8C,
   0xBF, 0x99, 0x75, 0x13, 0x7E, 0x87, 0x80, 0x4B,
   0x71, 0x94, 0xB8, 0x00, 0xA0, 0x7D, 0xB7, 0x53,
   0xDD, 0x20, 0x63, 0xEE, 0xF7, 0x83, 0x41, 0xFE,
   0x16, 0xA7, 0x6E, 0xDF, 0x21, 0x7D, 0x76, 0xC0,
   0x85, 0xD5, 0x65, 0x7F, 0x00, 0x23, 0x57, 0x45,
   0x52, 0x02, 0x9D, 0xEA, 0x69, 0xAC, 0x1F, 0xFD,
   0x3F, 0x8C, 0x4A, 0xD0,

   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

   0x64, 0xD5, 0xAA, 0xB1,
   0xA6, 0x03, 0x18, 0x92, 0x03, 0xAA, 0x31, 0x2E,
   0x48, 0x4B, 0x65, 0x20, 0x99, 0xCD, 0xC6, 0x0C,
   0x15, 0x0C, 0xBF, 0x3E, 0xFF, 0x78, 0x95, 0x67,
   0xB1, 0x74, 0x5B, 0x60,

   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

// 
// 64-bit and 56-bit DES SIMPLEBLOB's exported with 
// above public key.  These keys are functionally
// equivalent on Windows 2000 due to a buffer overrun
// bug.
//
static BYTE g_rgbDes56BitKeyBlob[] = 
{
    0x01, 0x02, 0x00, 0x00, 0x01, 0x66, 0x00, 0x00,
    0x00, 0xa4, 0x00, 0x00, 0x29, 0x32, 0xc4, 0xd0,
    0x75, 0x25, 0xa4, 0x00, 0xa8, 0x6f, 0x02, 0x35,
    0x0e, 0x53, 0x75, 0xaa, 0xad, 0x8d, 0x21, 0x67,
    0xf6, 0x8a, 0x93, 0x78, 0x12, 0x27, 0x5c, 0xd1,
    0xa2, 0x13, 0x0f, 0xab, 0xe4, 0x68, 0x8e, 0x28,
    0xcc, 0x3e, 0xf1, 0xa5, 0x52, 0xe4, 0xf7, 0xa4,
    0x57, 0xaa, 0x86, 0x93, 0xc8, 0x73, 0xb1, 0x9f,
    0x77, 0xc8, 0x84, 0x97, 0xe4, 0xad, 0x63, 0xad,
    0x5d, 0x76, 0x02, 0x00
};
static BYTE g_rgbDes64BitKeyBlob[] = 
{
    0x01, 0x02, 0x00, 0x00, 0x01, 0x66, 0x00, 0x00,
    0x00, 0xa4, 0x00, 0x00, 0x00, 0x29, 0x32, 0xc4, 
    0xd0, 0x75, 0x25, 0xa4, 0x00, 0xa8, 0x6f, 0x02, 
    0x0e, 0x53, 0x75, 0xaa, 0xad, 0x8d, 0x21, 0x67,
    0xf6, 0x8a, 0x93, 0x78, 0x12, 0x27, 0x5c, 0xd1,
    0xa2, 0x13, 0x0f, 0xab, 0xe4, 0x68, 0x8e, 0x28,
    0xcc, 0x3e, 0xf1, 0xa5, 0x52, 0xe4, 0xf7, 0xa4,
    0x57, 0xaa, 0x86, 0x93, 0xc8, 0x73, 0xb1, 0x9f,
    0x77, 0xc8, 0x84, 0x97, 0xe4, 0xad, 0x63, 0xad,
    0x5d, 0x76, 0x02, 0x00
};
static BYTE g_rgbDesPlainText[] =
{
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07
};
static BYTE g_rgbDesCipherText[] =
{
    0x3b, 0xd9, 0x09, 0xfb, 0xd6, 0xa7, 0x9c, 0x37,
    0xf6, 0x5d, 0xe1, 0x50, 0x6d, 0x39, 0xb0, 0x0c
};

//
// 112 and 128 bit "equivalent" 3Des-2Key blobs
//
static BYTE g_rgbDes112BitKeyBlob[] = 
{
    0x01, 0x02, 0x00, 0x00, 0x09, 0x66, 0x00, 0x00,
    0x00, 0xa4, 0x00, 0x00, 0x29, 0x32, 0xc4, 0xd0,
    0x75, 0x25, 0xa4, 0x75, 0xa8, 0x6f, 0x02, 0x35,
    0x0e, 0x53, 0x00, 0xaa, 0xad, 0x8d, 0x21, 0x67,
    0xf6, 0x8a, 0x93, 0x78, 0x12, 0x27, 0x5c, 0xd1,
    0xa2, 0x13, 0x0f, 0xab, 0xe4, 0x68, 0x8e, 0x28,
    0xcc, 0x3e, 0xf1, 0xa5, 0x52, 0xe4, 0xf7, 0xa4,
    0x57, 0xaa, 0x86, 0x93, 0xc8, 0x73, 0xb1, 0x9f,
    0x77, 0xc8, 0x84, 0x97, 0xe4, 0xad, 0x63, 0xad,
    0x5d, 0x76, 0x02, 0x00
};
static BYTE g_rgbDes128BitKeyBlob[] = 
{
    0x01, 0x02, 0x00, 0x00, 0x09, 0x66, 0x00, 0x00,
    0x00, 0xa4, 0x00, 0x00, 0x00, 0x00, 0x29, 0x32, 
    0xc4, 0xd0, 0x75, 0x25, 0xa4, 0x75, 0xa8, 0x6f, 
    0x02, 0x35, 0x0e, 0x53, 0x00, 0xaa, 0xad, 0x8d, 
    0xf6, 0x8a, 0x93, 0x78, 0x12, 0x27, 0x5c, 0xd1,
    0xa2, 0x13, 0x0f, 0xab, 0xe4, 0x68, 0x8e, 0x28,
    0xcc, 0x3e, 0xf1, 0xa5, 0x52, 0xe4, 0xf7, 0xa4,
    0x57, 0xaa, 0x86, 0x93, 0xc8, 0x73, 0xb1, 0x9f,
    0x77, 0xc8, 0x84, 0x97, 0xe4, 0xad, 0x63, 0xad,
    0x5d, 0x76, 0x02, 0x00
};
static BYTE g_rgb2DesCipherText[] =
{
    0x56, 0x03, 0xdf, 0x55, 0xeb, 0xfb, 0x76, 0x1f,
    0x93, 0x38, 0xd7, 0xef, 0x8f, 0x38, 0x76, 0x49
};

//
// 168 and 192 bit "equivalent" 3Des blobs
//
static BYTE g_rgbDes168BitKeyBlob[] = 
{
    0x01, 0x02, 0x00, 0x00, 0x03, 0x66, 0x00, 0x00,
    0x00, 0xa4, 0x00, 0x00, 0x29, 0x32, 0xc4, 0xd0,
    0x75, 0x25, 0xa4, 0x8a, 0xa8, 0x6f, 0x02, 0x35,
    0x0e, 0x53, 0x75, 0xaa, 0xad, 0x8d, 0x21, 0x67,
    0xf6, 0x00, 0x93, 0x78, 0x12, 0x27, 0x5c, 0xd1,
    0xa2, 0x13, 0x0f, 0xab, 0xe4, 0x68, 0x8e, 0x28,
    0xcc, 0x3e, 0xf1, 0xa5, 0x52, 0xe4, 0xf7, 0xa4,
    0x57, 0xaa, 0x86, 0x93, 0xc8, 0x73, 0xb1, 0x9f,
    0x77, 0xc8, 0x84, 0x97, 0xe4, 0xad, 0x63, 0xad,
    0x5d, 0x76, 0x02, 0x00
};
static BYTE g_rgbDes192BitKeyBlob[] = 
{
    0x01, 0x02, 0x00, 0x00, 0x03, 0x66, 0x00, 0x00,
    0x00, 0xa4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 
    0x32, 0xc4, 0xd0, 0x75, 0x25, 0xa4, 0x8a, 0xa8, 
    0x6f, 0x02, 0x35, 0x0e, 0x53, 0x75, 0xaa, 0xad, 
    0x8d, 0x21, 0x67, 0xf6, 0x00, 0x93, 0x78, 0x12, 
    0xa2, 0x13, 0x0f, 0xab, 0xe4, 0x68, 0x8e, 0x28,
    0xcc, 0x3e, 0xf1, 0xa5, 0x52, 0xe4, 0xf7, 0xa4,
    0x57, 0xaa, 0x86, 0x93, 0xc8, 0x73, 0xb1, 0x9f,
    0x77, 0xc8, 0x84, 0x97, 0xe4, 0xad, 0x63, 0xad,
    0x5d, 0x76, 0x02, 0x00
};
static BYTE g_rgb3DesCipherText[] =
{
    0x25, 0x25, 0x14, 0x94, 0x6b, 0xe0, 0x69, 0x21,
    0xea, 0x3d, 0xb5, 0xa6, 0x5b, 0xaa, 0x6c, 0x87
};

// 
// Function: DesImportEquivalenceTest
// Purpose: Verify that the provided des key correctly 
// encrypts the above rgbDesPlainText.
// 
DWORD DesImportEquivalenceTest(
    PTHREAD_DATA pThreadData,
    PBYTE pbDesKey,
    DWORD cbDesKey,
    PBYTE pbDesShortKey,
    DWORD cbDesShortKey,
    PBYTE pbCipherText,
    DWORD cbCipherText)
{
    DWORD dwError = ERROR_SUCCESS;
    BOOL fSuccess = FALSE;
    HCRYPTKEY hPubKey = 0;
    HCRYPTKEY hDesKey = 0;
    PBYTE pb = NULL;
    DWORD cb = 0;
    BYTE rgbPlain[sizeof(g_rgbDesPlainText) * 2];
    DWORD cbPlain = sizeof(rgbPlain);
    BOOL fBlobError = FALSE;
    PBYTE p1 = NULL, p2 = NULL, p3 = NULL;

    if (! CryptImportKey(
        pThreadData->hVerifyCtx, rgbPrivateKeyWithExponentOfOne, 
        sizeof(rgbPrivateKeyWithExponentOfOne), 0, 0, &hPubKey))
    {
        printf("CryptImportKey privatekeywithexponentofone ");
        goto Ret;
    }

    // Try to import the short key; should fail
    if (CryptImportKey(
        pThreadData->hVerifyCtx, pbDesShortKey, cbDesShortKey,
        hPubKey, 0, &hDesKey))
    {
        printf("CryptImportKey ShortDesKey should've failed ");
        goto Ret;
    }

    PrintBytes("Testing this des key SIMPLEBLOB", pbDesKey, cbDesKey);

    if (! CryptImportKey(
        pThreadData->hVerifyCtx, pbDesKey, cbDesKey,
        hPubKey, CRYPT_EXPORTABLE, &hDesKey))
    {
        printf("CryptImportKey deskeyblob ");
        goto Ret;
    }

    cb = sizeof(g_rgbDesPlainText);
    memcpy(rgbPlain, g_rgbDesPlainText, cb);
    
    if (! CryptEncrypt(
        hDesKey, 0, TRUE, 0, rgbPlain, &cb, cbPlain))
    {
        printf("CryptEncrypt ");
        goto Ret;
    }

    if (0 != memcmp(rgbPlain, pbCipherText, cbCipherText))
    {
        printf("Cipher text doesn't match\n");
        PrintBytes("Expected cipher text", pbCipherText, cbCipherText);
        PrintBytes("Actual cipher text", rgbPlain, sizeof(rgbPlain));
        fBlobError = TRUE;
    }

    if (! CryptExportKey(
        hDesKey, hPubKey, SIMPLEBLOB, 0, NULL, &cb))
    {
        printf("CryptExportKey size ");
        goto Ret;
    }

    if (NULL == (pb = (PBYTE) MyAlloc(cb)))
        return ERROR_NOT_ENOUGH_MEMORY;

    if (! CryptExportKey(
        hDesKey, hPubKey, SIMPLEBLOB, 0, pb, &cb))
    {
        printf("CryptExportKey ");
        goto Ret;
    }

    if (0 != memcmp(
        pb, pbDesKey, 
        sizeof(SIMPLEBLOB) + sizeof(ALG_ID) + 8))
    {
        printf("Header + key portion of blob doesn't match\n");
        PrintBytes("Expected key blob", pbDesKey, cbDesKey);
        PrintBytes("Actual key blob", pb, cb);
        fBlobError = TRUE;
    }

    fSuccess = TRUE;
Ret:
    if (fBlobError)
        dwError = -1;
    if (! fSuccess)
        printf("- error 0x%x\n", dwError = GetLastError());
    if (hDesKey)
        CryptDestroyKey(hDesKey);
    if (hPubKey)
        CryptDestroyKey(hPubKey);
    if (pb)
        MyFree(pb);

    return dwError;
}

//
// Function: DesImportRegression
//
DWORD DesImportRegression(PTHREAD_DATA pThreadData)
{
    DWORD dwSts;
    DWORD dwError = ERROR_SUCCESS;

    if (ERROR_SUCCESS != (dwSts = 
        DesImportEquivalenceTest(
            pThreadData,
            g_rgbDes64BitKeyBlob,
            sizeof(g_rgbDes64BitKeyBlob),
            g_rgbDes56BitKeyBlob,
            sizeof(g_rgbDes56BitKeyBlob),
            g_rgbDesCipherText,
            sizeof(g_rgbDesCipherText))))
        dwError = dwSts;

    if (ERROR_SUCCESS != (dwSts = 
        DesImportEquivalenceTest(
            pThreadData,
            g_rgbDes128BitKeyBlob,
            sizeof(g_rgbDes128BitKeyBlob),
            g_rgbDes112BitKeyBlob,
            sizeof(g_rgbDes112BitKeyBlob),
            g_rgb2DesCipherText,
            sizeof(g_rgb2DesCipherText))))
        dwError = dwSts;

    if (ERROR_SUCCESS != (dwSts = 
        DesImportEquivalenceTest(
            pThreadData,
            g_rgbDes192BitKeyBlob,
            sizeof(g_rgbDes192BitKeyBlob),
            g_rgbDes168BitKeyBlob,
            sizeof(g_rgbDes168BitKeyBlob),
            g_rgb3DesCipherText,
            sizeof(g_rgb3DesCipherText))))
        dwError = dwSts;

    return dwError;
}

static BYTE rgbPlainText[] =
{
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
};
static BYTE rgbIV[] =
{
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
};

BYTE rgbRC2PlainTextKey [] = {
    0x08, 0x02, 0x00, 0x00, 0x02, 0x66, 0x00, 0x00, 
        0x10, 0x00, 0x00, 0x00, 0x10, 0x62, 0x0a, 0x8a, 
        0x6b, 0x0d, 0x60, 0xbe, 0xf3, 0x94, 0x99, 0x12, 
        0xef, 0x39, 0xbf, 0x4f
};

BYTE rgbRC2CipherText [] = {
    0xfd, 0x25, 0x3e, 0x7a, 0xff, 0xb5, 0xc2, 0x6e, 
        0x13, 0xcf, 0x52, 0xf1, 0xba, 0xa3, 0x9a, 0xef, 
        0x1c, 0xfb, 0x91, 0x88, 0x9d, 0xf7, 0xe5, 0x12 
};

BYTE rgbDESPlainTextKey [] = {
    0x08, 0x02, 0x00, 0x00, 0x01, 0x66, 0x00, 0x00, 
        0x08, 0x00, 0x00, 0x00, 0xef, 0x8f, 0x10, 0xec, 
        0xea, 0x7a, 0x2c, 0x01
};

BYTE rgbDESCipherText [] = {
    0x13, 0x68, 0x16, 0xc5, 0x15, 0x3d, 0x59, 0x1f, 
        0x8e, 0x9c, 0x9c, 0x4f, 0x03, 0x7b, 0xb2, 0x12, 
        0x24, 0xa7, 0x81, 0x5e, 0x68, 0xb1, 0x58, 0xaa
};

BYTE rgb3DES112PlainTextKey [] = {
    0x08, 0x02, 0x00, 0x00, 0x09, 0x66, 0x00, 0x00, 
        0x10, 0x00, 0x00, 0x00, 0x6d, 0x07, 0xcd, 0xe9, 
        0xa4, 0x23, 0xc7, 0x97, 0x4a, 0x4f, 0x5b, 0x2f, 
        0x34, 0x92, 0xb5, 0x92
};

BYTE rgb3DES112CipherText [] = {
    0xf4, 0xfd, 0xde, 0x15, 0xfd, 0x50, 0xaa, 0x3c, 
        0x02, 0xb1, 0x07, 0x3b, 0x0f, 0x0f, 0x93, 0x23, 
        0xc2, 0x23, 0xda, 0x1f, 0x65, 0x81, 0x59, 0x24
};

BYTE rgb3DESCipherText [] = {
    0xa6, 0xae, 0xa2, 0x97, 0xc4, 0x85, 0xda, 0xa7, 
        0x43, 0xc8, 0x5d, 0xf4, 0x97, 0xb4, 0xbc, 0x03, 
        0x96, 0xf9, 0xa2, 0x66, 0x9e, 0x18, 0x91, 0x4a
};

BYTE rgb3DESPlainTextKey [] = {
    0x08, 0x02, 0x00, 0x00, 0x03, 0x66, 0x00, 0x00, 
        0x18, 0x00, 0x00, 0x00, 0xdc, 0x0d, 0x20, 0xf2, 
        0xcb, 0xa8, 0xb6, 0x15, 0x3e, 0x23, 0x38, 0xb6, 
        0x31, 0x62, 0x4a, 0x16, 0xa4, 0x49, 0xe5, 0xe5, 
        0x61, 0x76, 0x75, 0x23
};

BYTE rgbAES128PlainTextKey [] = {
    0x08, 0x02, 0x00, 0x00, 0x0e, 0x66, 0x00, 0x00, 
    0x10, 0x00, 0x00, 0x00, 
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 
};

BYTE rgbAES128CipherText [] = {
    0xc6, 0xa1, 0x3b, 0x37, 0x87, 0x8f, 0x5b, 0x82,
    0x6f, 0x4f, 0x81, 0x62, 0xa1, 0xc8, 0xd8, 0x79,
    0xb1, 0xa2, 0x92, 0x73, 0xbe, 0x2c, 0x42, 0x07,
    0xa5, 0xac, 0xe3, 0x93, 0x39, 0x8c, 0xb6, 0xfb
};

BYTE rgbAES192PlainTextKey [] = {
    0x08, 0x02, 0x00, 0x00, 0x0f, 0x66, 0x00, 0x00, 
    0x18, 0x00, 0x00, 0x00, 
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 
};

BYTE rgbAES192CipherText [] = {
    0x91, 0x62, 0x51, 0x82, 0x1c, 0x73, 0xa5, 0x22,
    0xc3, 0x96, 0xd6, 0x27, 0x38, 0x01, 0x96, 0x07,
    0x5f, 0x9d, 0x65, 0x29, 0x74, 0x04, 0x30, 0x7e,
    0x94, 0x97, 0xf4, 0x56, 0x25, 0xd5, 0xfd, 0x48
};

BYTE rgbAES256PlainTextKey [] = {
    0x08, 0x02, 0x00, 0x00, 0x10, 0x66, 0x00, 0x00, 
    0x20, 0x00, 0x00, 0x00, 
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 
    0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F
};

BYTE rgbAES256CipherText [] = {
    0xf2, 0x90, 0x00, 0xb6, 0x2a, 0x49, 0x9f, 0xd0,
    0xa9, 0xf3, 0x9a, 0x6a, 0xdd, 0x2e, 0x77, 0x80,
    0x53, 0xc8, 0x74, 0x2d, 0x0e, 0xa2, 0x9b, 0x27,
    0x12, 0xf6, 0xc7, 0xaf, 0x40, 0x48, 0xf4, 0xb4
};

typedef struct _KnownBlockCipherResult {
    ALG_ID ai;
    BYTE *pbKey;
    DWORD cbKey;
    BYTE *pbCipherText;
    DWORD cbCipherText;
} KnownBlockCipherResult, *pKnownBlockCipherResult;

KnownBlockCipherResult g_rgKnownBlockCipherResults [] = {
    { CALG_RC2, rgbRC2PlainTextKey, sizeof(rgbRC2PlainTextKey),
        rgbRC2CipherText, sizeof(rgbRC2CipherText) },
    { CALG_DES, rgbDESPlainTextKey, sizeof(rgbDESPlainTextKey),
        rgbDESCipherText, sizeof(rgbDESCipherText) },
    { CALG_3DES_112, rgb3DES112PlainTextKey, sizeof(rgb3DES112PlainTextKey),
        rgb3DES112CipherText, sizeof(rgb3DES112CipherText) },
    { CALG_3DES, rgb3DESPlainTextKey, sizeof(rgb3DESPlainTextKey),
        rgb3DESCipherText, sizeof(rgb3DESCipherText) },
    { CALG_AES_128, rgbAES128PlainTextKey, sizeof(rgbAES128PlainTextKey),
        rgbAES128CipherText, sizeof(rgbAES128CipherText) },
    { CALG_AES_192, rgbAES192PlainTextKey, sizeof(rgbAES192PlainTextKey),
        rgbAES192CipherText, sizeof(rgbAES192CipherText) },
    { CALG_AES_256, rgbAES256PlainTextKey, sizeof(rgbAES256PlainTextKey),
        rgbAES256CipherText, sizeof(rgbAES256CipherText) }
};

static const unsigned g_cKnownBlockCipherResults = 
    sizeof(g_rgKnownBlockCipherResults) / sizeof(KnownBlockCipherResult);

//
// Function: KnownSymKeyRegression
//
DWORD KnownBlockCipherKeyRegression(PTHREAD_DATA pThreadData)
{
    DWORD dwError = ERROR_SUCCESS;
    BOOL fSuccess = FALSE;
    BOOL fBlobError = FALSE;
    HCRYPTKEY hPubKey = 0;
    HCRYPTKEY hSymKey = 0;
    PALGNODE pAlgNode = NULL;
    PBYTE pb = NULL;
    DWORD cb = 0;
    DWORD cbBuf = 0;
    DWORD dw = 0;
    CHAR rgsz[1024];
    unsigned u;

    for (   pAlgNode = pThreadData->pAlgList; 
            pAlgNode != NULL; 
            pAlgNode = pAlgNode->pNext)
    {
        if ((ALG_CLASS_DATA_ENCRYPT != GET_ALG_CLASS(pAlgNode->EnumalgsEx.aiAlgid)) 
            || (ALG_TYPE_BLOCK != GET_ALG_TYPE(pAlgNode->EnumalgsEx.aiAlgid)))
            continue;

        for (   u = 0; 
                u < g_cKnownBlockCipherResults && 
                    pAlgNode->EnumalgsEx.aiAlgid != g_rgKnownBlockCipherResults[u].ai;
                u++);

        // CYLINK_MEK is not supported with PLAINTEXTKEYBLOB's
        if (CALG_CYLINK_MEK == pAlgNode->EnumalgsEx.aiAlgid)
            continue;

        sprintf(
            rgsz, 
            "Importing 0x%x blob for CSP alg %s (0x%x)", 
            g_rgKnownBlockCipherResults[u].ai,
            pAlgNode->EnumalgsEx.szName,
            pAlgNode->EnumalgsEx.aiAlgid);

        PrintBytes(
            rgsz,
            g_rgKnownBlockCipherResults[u].pbKey,
            g_rgKnownBlockCipherResults[u].cbKey);

        if (! CryptImportKey(
            pThreadData->hProv, 
            g_rgKnownBlockCipherResults[u].pbKey,
            g_rgKnownBlockCipherResults[u].cbKey,
            0, 0, &hSymKey))
        {
            printf("CryptImportKey ");
            goto Ret;
        }

        if (! CryptSetKeyParam(hSymKey, KP_IV, rgbIV, 0))
        {
            printf("CryptSetKeyParam ");
            goto Ret;
        }

        dw = CRYPT_MODE_CBC;
        if (! CryptSetKeyParam(hSymKey, KP_MODE, (PBYTE) &dw, 0))
        {
            printf("CryptSetKeyParam ");
            goto Ret;
        }

        cb = sizeof(rgbPlainText);
        if (! CryptEncrypt(hSymKey, 0, TRUE, 0, NULL, &cb, 0))
        {
            printf("CryptEncrypt ");
            goto Ret;
        }

        if (NULL == (pb = (PBYTE) MyAlloc(cb)))
            return ERROR_NOT_ENOUGH_MEMORY;

        cbBuf = cb;
        cb = sizeof(rgbPlainText);
        memcpy(pb, rgbPlainText, cb);

        if (! CryptEncrypt(hSymKey, 0, TRUE, 0, pb, &cb, cbBuf))
        {
            printf("CryptEncrypt ");
            goto Ret;
        }

        if (0 != memcmp(pb, g_rgKnownBlockCipherResults[u].pbCipherText, cb)
            || 0 == cb)
        {
            printf(
                "\nCiphertext is wrong for alg %s\n", 
                pAlgNode->EnumalgsEx.szName);                
            PrintBytes(
                "Expected ciphertext", 
                g_rgKnownBlockCipherResults[u].pbCipherText,
                cb);
            PrintBytes(
                "Actual ciphertext", 
                pb, cb);
            fBlobError = TRUE;
        }

        // Verify decryption as well
        if (! CryptDecrypt(hSymKey, 0, TRUE, 0, pb, &cb)) 
        {
            printf("CryptDecrypt ");
            goto Ret;
        }

        if (0 != memcmp(pb, rgbPlainText, sizeof(rgbPlainText)))
        {
            printf(
                "\nPlaintext is wrong for alg %s\n", 
                pAlgNode->EnumalgsEx.szName);                
            PrintBytes(
                "Expected plaintext", 
                rgbPlainText,
                sizeof(rgbPlainText));
            PrintBytes(
                "Actual plaintext", 
                pb, cb);
            fBlobError = TRUE;
        }

        MyFree(pb);
        pb = NULL;
    }

    fSuccess = TRUE;
Ret:
    if (fBlobError)
        dwError = -1;
    if ((! fSuccess) && (! fBlobError))
        printf("- error 0x%x\n", dwError = GetLastError());

    return dwError;
}

#define MY_AES_BLOCKSIZE            16
#define MY_HALF_AES_BLOCKSIZE       8

//
// Function: AESMonteCarloCBCRegression
//
DWORD AESMonteCarloCBCRegression(PTHREAD_DATA pThreadData)
{
    DWORD dwError = ERROR_SUCCESS;
    BOOL fSuccess = FALSE;
    BYTE rgbAESPlainTextKey [] = {
        0x08, 0x02, 0x00, 0x00, 0x10, 0x66, 0x00, 0x00, 
        0x20, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    BLOBHEADER *pBlobHeader = NULL;
    DWORD cbKey = 0, cb = 0, dwParam = 0;
    BYTE rgbData [MY_AES_BLOCKSIZE * 2];
    unsigned il, ol;
    HCRYPTKEY hKey = 0;
    BOOL fError = FALSE;
    PBYTE pbPT = NULL, pbCV = NULL, pbCT = NULL;
    fpos_t fpos;

    BYTE rgbCBC_E_128_Result [] = {
        0x2F, 0x84, 0x4C, 0xBF, 0x78, 0xEB, 0xA7, 0x0D, 
        0xA7, 0xA4, 0x96, 0x01, 0x38, 0x8F, 0x1A, 0xB6
        //0x8A, 0x05, 0xFC, 0x5E, 0x09, 0x5A, 0xF4, 0x84, 
        //0x8A, 0x08, 0xD3, 0x28, 0xD3, 0x68, 0x8E, 0x3D
    };
    BYTE rgbCBC_E_192_Result [] = {
        //0xBA, 0x50, 0xC9, 0x44, 0x40, 0xC0, 0x4A, 0x8C, 
        //0x08, 0x99, 0xD4, 0x26, 0x58, 0xE2, 0x54, 0x37
        0x7B, 0xD9, 0x66, 0xD5, 0x3A, 0xD8, 0xC1, 0xBB, 
        0x85, 0xD2, 0xAD, 0xFA, 0xE8, 0x7B, 0xB1, 0x04
    };
    BYTE rgbCBC_E_256_Result [] = {
        //0xC0, 0xFE, 0xFF, 0xF0, 0x75, 0x06, 0xA0, 0xB4, 
        //0xCD, 0x7B, 0x8B, 0x0C, 0xF2, 0x5D, 0x36, 0x64
        0xFE, 0x3C, 0x53, 0x65, 0x3E, 0x2F, 0x45, 0xB5, 
        0x6F, 0xCD, 0x88, 0xB2, 0xCC, 0x89, 0x8F, 0xF0 
    };

    BYTE rgbCBC_D_128_Result [] = {
        //0x9B, 0x8F, 0xB7, 0x1E, 0x03, 0x5C, 0xEF, 0xF9, 
        //0xCB, 0xFA, 0x13, 0x46, 0xE5, 0xAC, 0xEF, 0xE0
        0xFA, 0xCA, 0x37, 0xE0, 0xB0, 0xC8, 0x53, 0x73, 
        0xDF, 0x70, 0x6E, 0x73, 0xF7, 0xC9, 0xAF, 0x86
    };
    BYTE rgbCBC_D_192_Result [] = {
        //0x63, 0x42, 0xBF, 0xDD, 0xD2, 0xF6, 0x61, 0x03, 
        //0x50, 0x45, 0x8B, 0x66, 0x95, 0x46, 0x34, 0x84
        0x5D, 0xF6, 0x78, 0xDD, 0x17, 0xBA, 0x4E, 0x75, 
        0xB6, 0x17, 0x68, 0xC6, 0xAD, 0xEF, 0x7C, 0x7B
    };
    BYTE rgbCBC_D_256_Result [] = {
        //0xCD, 0x64, 0x29, 0xCF, 0x3F, 0x81, 0xF8, 0xB4, 
        //0xF8, 0x2B, 0xC6, 0x27, 0xA8, 0x28, 0x30, 0x96
        0x48, 0x04, 0xE1, 0x81, 0x8F, 0xE6, 0x29, 0x75, 
        0x19, 0xA3, 0xE8, 0x8C, 0x57, 0x31, 0x04, 0x13
    };

    memset(rgbData, 0, sizeof(rgbData));

    pBlobHeader = (BLOBHEADER *) rgbAESPlainTextKey;
    pBlobHeader->aiKeyAlg = CALG_AES_128;
    cbKey = 16;
    *((PDWORD) (rgbAESPlainTextKey + sizeof(BLOBHEADER))) = cbKey;

    pbCV = rgbData;
    pbPT = rgbData;
    pbCT = rgbData;
    
    cb = MY_AES_BLOCKSIZE;

    printf("\n");

    for (ol = 0; ol < 400; ol++)
    {
        if (hKey)
        {
            if (! CryptDestroyKey(hKey))
            {                   
                printf("CryptDestroyKey ");
                goto Ret;
            }
            hKey = 0;
        }

        ((PUINT64) (rgbAESPlainTextKey + sizeof(BLOBHEADER) + sizeof(DWORD)))[0] ^= ((PUINT64) pbCT)[0];
        ((PUINT64) (rgbAESPlainTextKey + sizeof(BLOBHEADER) + sizeof(DWORD)))[1] ^= ((PUINT64) pbCT)[1];

        if (! CryptImportKey(
            pThreadData->hProv, rgbAESPlainTextKey, 
            sizeof(BLOBHEADER) + sizeof(DWORD) + cbKey, 0, 0, &hKey))
        {
            printf("CryptImportKey ");
            goto Ret;
        }
    
        dwParam = CRYPT_MODE_CBC;
        if (! CryptSetKeyParam(hKey, KP_MODE, (PBYTE) &dwParam, 0))
        {
            printf("CryptSetKeyParam ");
            goto Ret;
        }

        for (il = 0; il < 10000; il++)
        {
            ((PUINT64) pbPT)[0] ^= ((PUINT64) pbCV)[0];
            ((PUINT64) pbPT)[1] ^= ((PUINT64) pbCV)[1];
    
            if (! CryptEncrypt(hKey, 0, FALSE, 0, pbPT, &cb, sizeof(rgbData)))
            {
                printf("CryptEncrypt ");
                goto Ret;
            }
    
            pbCT = pbPT;
    
            if (0 == il && 0 == ol)
                pbPT += MY_AES_BLOCKSIZE;
            else
            {
                if (rgbData + MY_AES_BLOCKSIZE == pbPT)
                    pbPT = rgbData;
                else
                    pbPT += MY_AES_BLOCKSIZE;
    
                if (rgbData + MY_AES_BLOCKSIZE == pbCV)
                    pbCV = rgbData;
                else
                    pbCV += MY_AES_BLOCKSIZE;
            }
        }
    }

    if (0 != memcmp(pbCT, rgbCBC_E_128_Result, sizeof(rgbCBC_E_128_Result)))
    {                                                                        
        printf("\nCiphertext is wrong for CBC E 128\n");
        PrintBytes(
            "Expected",
            rgbCBC_E_128_Result,
            sizeof(rgbCBC_E_128_Result));
        PrintBytes(
            "Actual",
            pbCT, sizeof(rgbCBC_E_128_Result));
        fError = TRUE;
    }
    
    fSuccess = TRUE;
Ret:
    if (! fSuccess)
        dwError = GetLastError();
    if (fError && 0 == dwError)
        dwError = -1;
    if (hKey)
        CryptDestroyKey(hKey);
    
    return dwError;
}
//
// Function: CFBCipherModeRegression
//
DWORD CFBCipherModeRegression(PTHREAD_DATA pThreadData)
{
    DWORD dwError = ERROR_SUCCESS;
    BOOL fSuccess = FALSE;
    BOOL fBlobError = FALSE;
    HCRYPTKEY hSymKey = 0;
    PALGNODE pAlgNode = NULL;
    DWORD dw = 0;
    DWORD cb = 0;
    DWORD cbBuf = 0;
    PBYTE pb = NULL;
    CHAR rgsz[1024];
    unsigned u;
    BYTE rgbCFBPlainText[] = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
        0x10
    };

    for (   pAlgNode = pThreadData->pAlgList; 
            pAlgNode != NULL; 
            pAlgNode = pAlgNode->pNext)
    {
        if ((ALG_CLASS_DATA_ENCRYPT != GET_ALG_CLASS(pAlgNode->EnumalgsEx.aiAlgid)) 
            || (ALG_TYPE_BLOCK != GET_ALG_TYPE(pAlgNode->EnumalgsEx.aiAlgid)))
            continue;

        for (   u = 0; 
                u < g_cKnownBlockCipherResults && 
                    pAlgNode->EnumalgsEx.aiAlgid != g_rgKnownBlockCipherResults[u].ai;
                u++);

        // CYLINK_MEK is not supported with PLAINTEXTKEYBLOB's
        if (CALG_CYLINK_MEK == pAlgNode->EnumalgsEx.aiAlgid)
            continue;

        sprintf(
            rgsz, 
            "Importing 0x%x blob for CSP alg %s (0x%x)", 
            g_rgKnownBlockCipherResults[u].ai,
            pAlgNode->EnumalgsEx.szName,
            pAlgNode->EnumalgsEx.aiAlgid);

        PrintBytes(
            rgsz,
            g_rgKnownBlockCipherResults[u].pbKey,
            g_rgKnownBlockCipherResults[u].cbKey);

        if (! CryptImportKey(
            pThreadData->hProv, 
            g_rgKnownBlockCipherResults[u].pbKey,
            g_rgKnownBlockCipherResults[u].cbKey,
            0, 0, &hSymKey))
        {
            printf("CryptImportKey ");
            goto Ret;
        }

        if (! CryptSetKeyParam(hSymKey, KP_IV, rgbIV, 0))
        {
            printf("CryptSetKeyParam ");
            goto Ret;
        }

        dw = CRYPT_MODE_CFB;
        if (! CryptSetKeyParam(hSymKey, KP_MODE, (PBYTE) &dw, 0))
        {
            printf("CryptSetKeyParam ");
            goto Ret;
        }
        
        cb = sizeof(rgbPlainText);
        if (! CryptEncrypt(hSymKey, 0, TRUE, 0, NULL, &cb, 0))
        {
            printf("CryptEncrypt ");
            goto Ret;
        }

        if (NULL == (pb = (PBYTE) MyAlloc(cb)))
            return ERROR_NOT_ENOUGH_MEMORY;

        cbBuf = cb;
        cb = sizeof(rgbCFBPlainText);
        memcpy(pb, rgbCFBPlainText, cb);

        if (! CryptEncrypt(hSymKey, 0, TRUE, 0, pb, &cb, cbBuf))
        {
            printf("CryptEncrypt ");
            goto Ret;
        }

        if (0 == memcmp(pb, rgbCFBPlainText, sizeof(rgbCFBPlainText)))
        {
            printf("Ciphertext matches plaintext ");
            goto Ret;
        }
                
        // Verify decryption 
        if (! CryptDecrypt(hSymKey, 0, TRUE, 0, pb, &cb)) 
        {
            printf("CryptDecrypt ");
            goto Ret;
        }

        if (0 != memcmp(pb, rgbCFBPlainText, sizeof(rgbCFBPlainText)))
        {
            printf(
                "Plaintext is wrong for alg %s\n", 
                pAlgNode->EnumalgsEx.szName);                
            PrintBytes(
                "Expected plaintext", 
                rgbCFBPlainText,
                sizeof(rgbCFBPlainText));
            PrintBytes(
                "Actual plaintext", 
                pb, cb);
            fBlobError = TRUE;
        }

        MyFree(pb);
        pb = NULL;
    }
    
    fSuccess = TRUE;
Ret:
    if (fBlobError)
        dwError = -1;
    if ((! fSuccess) && (! fBlobError))
        printf("- error 0x%x\n", dwError = GetLastError());

    return dwError;
}

typedef struct _HMAC_TEST
{
    PBYTE pbKey;
    DWORD cbKey;
    PBYTE pbData;
    DWORD cbData;
    PBYTE pbData2;
    DWORD cbData2;
    PBYTE pbHmac;
    DWORD cbHmac;
    ALG_ID aiHash;
} HMAC_TEST, *PHMAC_TEST;

//
// Function: DoHmacTestCase
//
DWORD DoHmacTestCase(
    IN PTHREAD_DATA pThreadData,
    IN PHMAC_TEST pHmac)
{
    HCRYPTKEY hKey      = 0;
    HCRYPTHASH hHash    = 0;
    DWORD cb            = 0;
    BLOBHEADER *pHeader = NULL;
    BOOL fSuccess       = FALSE;
    DWORD dwError       = ERROR_SUCCESS;
    BYTE rgBuf[1024];
    HMAC_INFO HmacInfo;

    ZeroMemory(rgBuf, sizeof(rgBuf));
    ZeroMemory(&HmacInfo, sizeof(HmacInfo));

    pHeader = (BLOBHEADER *) rgBuf;
    pHeader->bType = PLAINTEXTKEYBLOB;
    pHeader->bVersion = CUR_BLOB_VERSION;
    pHeader->aiKeyAlg = CALG_RC2;

    *(DWORD*)(rgBuf + sizeof(BLOBHEADER)) = pHmac->cbKey;
    memcpy(
        rgBuf + sizeof(BLOBHEADER) + sizeof(DWORD), 
        pHmac->pbKey, pHmac->cbKey);

    if (! CryptImportKey(
            pThreadData->hProv, rgBuf,
            sizeof(BLOBHEADER) + sizeof(DWORD) + pHmac->cbKey,
            0, CRYPT_IPSEC_HMAC_KEY, &hKey))
    {
        printf("CryptImportKey");
        goto Ret;
    }

    if (! CryptCreateHash(
            pThreadData->hProv, CALG_HMAC, hKey, 0, &hHash))
    {
        printf("CryptCreateHash");
        goto Ret;
    }

    HmacInfo.HashAlgid = pHmac->aiHash;
    if (! CryptSetHashParam(
            hHash, HP_HMAC_INFO, (PBYTE) &HmacInfo, 0))
    {
        printf("CryptSetHashParam");
        goto Ret;
    }

    if (! CryptHashData(
            hHash, pHmac->pbData, pHmac->cbData, 0))
    {
        printf("CryptHashData");
        goto Ret;
    }

    if (pHmac->cbData2)
    {
        if (! CryptHashData(
                hHash, pHmac->pbData2, pHmac->cbData2, 0))
        {
            printf("CryptHashData 2");
            goto Ret;
        }
    }

    cb = sizeof(rgBuf);
    ZeroMemory(rgBuf, sizeof(rgBuf));
    if (! CryptGetHashParam(
            hHash, HP_HASHVAL, rgBuf, &cb, 0))
    {
        printf("CryptGetHashParam");
        goto Ret;
    }

    PrintBytes("Expected Hmac", pHmac->pbHmac, pHmac->cbHmac);
    PrintBytes("Actual Hmac", rgBuf, cb);

    if (    0 != memcmp(rgBuf, pHmac->pbHmac, cb) 
            || cb != pHmac->cbHmac)
        goto Ret;

    if (! CryptDestroyKey(hKey))
    {
        printf("CryptDestroyKey");
        goto Ret;
    }
    hKey = 0;

    if (! CryptDestroyHash(hHash))
    {
        printf("CryptDestroyHash");
        goto Ret;
    }
    hHash = 0;

    fSuccess = TRUE;
Ret:
    if (! fSuccess)
    {
        dwError = GetLastError();
        printf(" error - 0x%x\n", dwError);
        if (0 == dwError)
            dwError = -1;
    }

    if (hKey)
        CryptDestroyKey(hKey);
    if (hHash)
        CryptDestroyHash(hHash);
    
    return dwError;
}

//
// Function: HmacRegression
//
DWORD HmacRegression(PTHREAD_DATA pThreadData)
{
    BOOL fSuccess       = FALSE;
    DWORD dwError       = ERROR_SUCCESS;
    HMAC_TEST Hmac;
    
    // SHA Test case 1
    BYTE rgKey1 []      = {
        0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
        0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
        0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
        0x0b, 0x0b, 0x0b, 0x0b, 0x0b
    };
    LPSTR pszData1      = "Hi There";
    BYTE rgHmac1 []     = {
        0xb6, 0x17, 0x31, 0x86, 0x55, 
        0x05, 0x72, 0x64, 0xe2, 0x8b, 
        0xc0, 0xb6, 0xfb, 0x37, 0x8c,
        0x8e, 0xf1, 0x46, 0xbe, 0x00
    };

    // SHA Test case 2
    BYTE rgKey2 []      = {
        0x01, 0x02, 0x03, 0x04, 0x05,
        0x06, 0x07, 0x08, 0x09, 0x0a,
        0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
        0x10, 0x11, 0x12, 0x13, 0x14,
        0x15, 0x16, 0x17, 0x18, 0x19
    };
    BYTE rgData2 [50];
    BYTE rgHmac2 []     = {
        0x4c, 0x90, 0x07, 0xf4, 0x02,
        0x62, 0x50, 0xc6, 0xbc, 0x84,
        0x14, 0xf9, 0xbf, 0x50, 0xc8,
        0x6c, 0x2d, 0x72, 0x35, 0xda
    };

    // SHA Test case 3
    BYTE rgKey3 [80];
    LPSTR pszData3      = "Test Using Larger Than Block-Size Key - Hash Key First";
    BYTE rgHmac3 []     = {
        0xaa, 0x4a, 0xe5, 0xe1, 0x52,
        0x72, 0xd0, 0x0e, 0x95, 0x70,
        0x56, 0x37, 0xce, 0x8a, 0x3b,
        0x55, 0xed, 0x40, 0x21, 0x12
    };

    // MD5 Test case 1
    // use rgKey1 (16 bytes only) and pszData1
    BYTE rgHmacMD1 []   = {
        0x92, 0x94, 0x72, 0x7a, 
        0x36, 0x38, 0xbb, 0x1c, 
        0x13, 0xf4, 0x8e, 0xf8, 
        0x15, 0x8b, 0xfc, 0x9d
    };

    // MD5 Test case 2
    // use rgKey3 (full length) and pszData3
    BYTE rgHmacMD2 []   = {
        0x6b, 0x1a, 0xb7, 0xfe,
        0x4b, 0xd7, 0xbf, 0x8f,
        0x0b, 0x62, 0xe6, 0xce,
        0x61, 0xb9, 0xd0, 0xcd
    };

    // IPSec MD5 vectors
    BYTE rgKeyIpsec [] = {
         0x66, 0x6f, 0x6f
    };
    BYTE rgDataIpsecA [] = {
        0x38, 0x8e, 0x5e, 0x8a, 
        0xb0, 0x79, 0x16, 0x47,
        0x29, 0x1b, 0xf0, 0x02,
        0x78, 0x5e, 0x38, 0xe5,
        0x82, 0x3c, 0x17, 0x0d
    };
    BYTE rgDataIpsecB [] = {
        0x34, 0xdd, 0xdb, 0x22,
        0x9e, 0x21, 0x75, 0x28,
        0x5e, 0x4d, 0x7d, 0xdf,
        0xea, 0x35, 0xc5, 0xfc,
        0x44, 0xdb, 0x62, 0xad
    };
    BYTE rgHmacIpsec [] = {
        0x52, 0x07, 0x38, 0x15,
        0xef, 0xb0, 0x68, 0x43,
        0x89, 0x8e, 0x0b, 0xdc,
        0x58, 0xc0, 0x70, 0xc0      
    };

    memset(rgData2, 0xcd, sizeof(rgData2));
    memset(rgKey3, 0xaa, sizeof(rgKey3));

    // SHA 1
    ZeroMemory(&Hmac, sizeof(HMAC_TEST));
    Hmac.cbData = strlen(pszData1) * sizeof(CHAR);
    Hmac.pbData = (PBYTE) pszData1;
    Hmac.cbHmac = sizeof(rgHmac1);
    Hmac.pbHmac = rgHmac1;
    Hmac.cbKey = sizeof(rgKey1);
    Hmac.pbKey = rgKey1;
    Hmac.aiHash = CALG_SHA1;

    if (ERROR_SUCCESS != (dwError = DoHmacTestCase(pThreadData, &Hmac)))
    {
        printf("ERROR: DoHmacTestCase SHA 1\n");
        return dwError;      
    }

    // SHA 2
    ZeroMemory(&Hmac, sizeof(HMAC_TEST));
    Hmac.cbData = sizeof(rgData2);
    Hmac.pbData = rgData2;
    Hmac.cbHmac = sizeof(rgHmac2);
    Hmac.pbHmac = rgHmac2;
    Hmac.cbKey = sizeof(rgKey2);
    Hmac.pbKey = rgKey2;
    Hmac.aiHash = CALG_SHA1;

    if (ERROR_SUCCESS != (dwError = DoHmacTestCase(pThreadData, &Hmac)))
    {
        printf("ERROR: DoHmacTestCase SHA 2\n");
        return dwError;      
    }

    // SHA 3
    ZeroMemory(&Hmac, sizeof(HMAC_TEST));
    Hmac.cbData = strlen(pszData3) * sizeof(CHAR);
    Hmac.pbData = (PBYTE) pszData3;
    Hmac.cbHmac = sizeof(rgHmac3);
    Hmac.pbHmac = rgHmac3;
    Hmac.cbKey = sizeof(rgKey3);
    Hmac.pbKey = rgKey3;
    Hmac.aiHash = CALG_SHA1;

    if (ERROR_SUCCESS != (dwError = DoHmacTestCase(pThreadData, &Hmac)))
    {
        printf("ERROR: DoHmacTestCase SHA 3\n");
        return dwError;      
    }

    // MD5 1
    ZeroMemory(&Hmac, sizeof(HMAC_TEST));
    Hmac.cbData = strlen(pszData1) * sizeof(CHAR);
    Hmac.pbData = (PBYTE) pszData1;
    Hmac.cbHmac = sizeof(rgHmacMD1);
    Hmac.pbHmac = rgHmacMD1;
    Hmac.cbKey = 16; // only 16-byte key for this one
    Hmac.pbKey = rgKey1;
    Hmac.aiHash = CALG_MD5;

    if (ERROR_SUCCESS != (dwError = DoHmacTestCase(pThreadData, &Hmac)))
    {
        printf("ERROR: DoHmacTestCase MD5 1\n");
        return dwError;      
    }

    // MD5 2
    ZeroMemory(&Hmac, sizeof(HMAC_TEST));
    Hmac.cbData = strlen(pszData3) * sizeof(CHAR);
    Hmac.pbData = (PBYTE) pszData3;
    Hmac.cbHmac = sizeof(rgHmacMD2);
    Hmac.pbHmac = rgHmacMD2;
    Hmac.cbKey = sizeof(rgKey3);
    Hmac.pbKey = rgKey3;
    Hmac.aiHash = CALG_MD5;

    if (ERROR_SUCCESS != (dwError = DoHmacTestCase(pThreadData, &Hmac)))
    {
        printf("ERROR: DoHmacTestCase MD5 2\n");
        return dwError;      
    }

    // MD5 Ipsec vector
    ZeroMemory(&Hmac, sizeof(HMAC_TEST));
    Hmac.cbData = sizeof(rgDataIpsecA);
    Hmac.pbData = rgDataIpsecA;
    Hmac.cbData2 = sizeof(rgDataIpsecB);
    Hmac.pbData2 = rgDataIpsecB;
    Hmac.cbHmac = sizeof(rgHmacIpsec);
    Hmac.pbHmac = rgHmacIpsec;
    Hmac.cbKey = sizeof(rgKeyIpsec);
    Hmac.pbKey = rgKeyIpsec;
    Hmac.aiHash = CALG_MD5;

    if (ERROR_SUCCESS != (dwError = DoHmacTestCase(pThreadData, &Hmac)))
    {
        printf("ERROR: DoHmacTestCase MD5 Ipsec\n");
        return dwError;      
    }

    return ERROR_SUCCESS;
}

//
// Function: KeyArchiveRegression
//
// Not thread safe
//
DWORD KeyArchiveRegression(PTHREAD_DATA pThreadData)
{
    HCRYPTPROV hProv = 0;
    HCRYPTKEY hKey = 0;
    DWORD dwError = 0;
    LPSTR pszContainer = "KeyArchiveRegression";
    BYTE rgbKey[2048];
    DWORD cbKey;
    DWORD dwData;
    DWORD cbData;
    BOOL fSuccess = FALSE;

    CryptAcquireContext(
        &hProv, 
        pszContainer, 
        pThreadData->rgszProvName,
        pThreadData->dwProvType,
        CRYPT_DELETEKEYSET);

    if (! CryptAcquireContext(
        &hProv, 
        pszContainer, 
        pThreadData->rgszProvName,
        pThreadData->dwProvType,
        CRYPT_NEWKEYSET))
    {
        printf("CryptAcquireContext newkeyset ");
        goto Ret;
    }

    if (! CryptGenKey(
        hProv,
        AT_SIGNATURE,
        CRYPT_ARCHIVABLE,
        &hKey))
    {
        printf("CryptGenKey archivable ");
        goto Ret;
    }

    cbData = sizeof(dwData);
    if (! CryptGetKeyParam(
        hKey, KP_PERMISSIONS, (PBYTE) &dwData, &cbData, 0))
    {
        printf("CryptGetKeyParam ");
        goto Ret;
    }

    if (! ((CRYPT_ARCHIVE & dwData) && (! (CRYPT_EXPORT & dwData))))
    {
        printf("incorrect KP_PERMISSIONS ");
        goto Ret;
    }

    cbKey = sizeof(rgbKey);
    if (! CryptExportKey(
        hKey,
        0,
        PRIVATEKEYBLOB,
        0,
        rgbKey,
        &cbKey))
    {
        printf("CryptExportKey privatekeyblob ");
        goto Ret;
    }

    if (! CryptDestroyKey(hKey))
    {
        printf("CryptDestroyKey ");
        goto Ret;
    }

    if (! CryptReleaseContext(hProv, 0))
    {
        printf("CryptReleaseContext ");
        goto Ret;
    }

    if (! CryptAcquireContext(
        &hProv, 
        pszContainer, 
        pThreadData->rgszProvName,
        pThreadData->dwProvType,
        0))
    {
        printf("CryptAcquireContext ");
        goto Ret;
    }

    if (! CryptGetUserKey(hProv, AT_SIGNATURE, &hKey))
    {
        printf("CryptGetUserKey ");
        goto Ret;
    }

    // try to set the key export/archive perms; should fail
    cbData = sizeof(dwData);
    if (! CryptGetKeyParam(
        hKey, KP_PERMISSIONS, (PBYTE) &dwData, &cbData, 0))
    {
        printf("CryptGetKeyParam ");
        goto Ret;
    }

    dwData |= CRYPT_EXPORT | CRYPT_ARCHIVE;

    // should fail 
    if (CryptSetKeyParam(hKey, KP_PERMISSIONS, (PBYTE) &dwData, 0))
    {
        printf("CryptSetKeyParam should have failed ");
        goto Ret;
    }
    
    // should fail
    cbKey = sizeof(rgbKey);
    if (CryptExportKey(
        hKey,
        0,
        PRIVATEKEYBLOB,
        0,
        rgbKey, 
        &cbKey))
    {
        printf("CryptExportKey should have failed ");
        goto Ret;
    }

    fSuccess = TRUE;
Ret:
    if (! fSuccess)
        printf("- error 0x%x\n", dwError = GetLastError());
    if (hKey)
        CryptDestroyKey(hKey);
    if (hProv)
        CryptReleaseContext(hProv, 0);

    return dwError;
}

// 
// Function: PlaintextBlobRegression
//
DWORD PlaintextBlobRegression(PTHREAD_DATA pThreadData)
{
    HCRYPTKEY hKey = 0;
    DWORD cbKey = 0;
    PBYTE pbKey = NULL;
    PALGNODE pAlgNode = NULL;
    BLOBHEADER *header = NULL;
    PBYTE pbTemp = NULL;
    DWORD cbData, cb;
    BYTE rgbData[1024];
    BOOL fSuccess = FALSE;
    DWORD dwError = ERROR_SUCCESS;
    DWORD cbKeySize = 0;

    // try an invalid key type
    if (CryptExportKey(
        pThreadData->hSignatureKey,
        0,
        PLAINTEXTKEYBLOB,
        0,
        NULL,
        &cbKey))
    {
        printf("CryptExportKey plaintextkeyblob should have failed ");
        goto Ret;
    }

    // try all the valid key types
    for (pAlgNode = pThreadData->pAlgList; pAlgNode != NULL; pAlgNode = pAlgNode->pNext)
    {
        if (ALG_CLASS_DATA_ENCRYPT != GET_ALG_CLASS(pAlgNode->EnumalgsEx.aiAlgid) 
            || (ALG_TYPE_BLOCK != GET_ALG_TYPE(pAlgNode->EnumalgsEx.aiAlgid)
                && ALG_TYPE_STREAM != GET_ALG_TYPE(pAlgNode->EnumalgsEx.aiAlgid)))
            continue;

        // Plaintext import not supported for CYLINK_MEK
        if (CALG_CYLINK_MEK == pAlgNode->EnumalgsEx.aiAlgid)
            continue;

        /*
        if (PROV_DSS == pThreadData->dwProvType
            || PROV_DSS_DH == pThreadData->dwProvType)
        {
            cbKeySize = pAlgNode->EnumalgsEx.dwMaxLen / 8;
        }
        else
        {
        */
            switch (pAlgNode->EnumalgsEx.aiAlgid)
            {
            case CALG_DES:
                cbKeySize = pAlgNode->EnumalgsEx.dwMaxLen / 8 + 1;
                break;
            case CALG_3DES_112:
                cbKeySize = pAlgNode->EnumalgsEx.dwMaxLen / 8 + 2;
                break;
            case CALG_3DES:
                cbKeySize = pAlgNode->EnumalgsEx.dwMaxLen / 8 + 3;
                break;
            default:
                cbKeySize = pAlgNode->EnumalgsEx.dwMaxLen / 8;
            }
        /*
        }
        */

        printf(
            "Importing Alg: %xh (%s), Size: %d bits\n", 
            pAlgNode->EnumalgsEx.aiAlgid, 
            pAlgNode->EnumalgsEx.szName,
            cbKeySize * 8);

        cbKey = sizeof(BLOBHEADER) + sizeof(DWORD) + cbKeySize;
        if (NULL == (pbKey = (PBYTE) MyAlloc(cbKey)))
            return ERROR_NOT_ENOUGH_MEMORY;

        header = (BLOBHEADER *) pbKey;
        header->aiKeyAlg = pAlgNode->EnumalgsEx.aiAlgid;
        header->bType = PLAINTEXTKEYBLOB;
        header->bVersion = CUR_BLOB_VERSION;
        header->reserved = 0;

        pbTemp = pbKey + sizeof(BLOBHEADER);
        *((DWORD*)pbTemp) = cbKeySize;
        pbTemp += sizeof(DWORD);

        // create some key data
        if (! CryptGenRandom(
            pThreadData->hProv, 
            cbKeySize,
            pbTemp))
        {
            printf("CryptGenRandom ");
            goto Ret;
        }

        if (! CryptImportKey(
            pThreadData->hProv,
            pbKey, cbKey, 0, CRYPT_EXPORTABLE, &hKey))
        {
            printf("CryptImportKey ");
            goto Ret;
        }

        MyFree(pbKey);

        // create some data to encrypt
        if (! CryptGenRandom(
            pThreadData->hProv,
            sizeof(rgbData),
            rgbData))
        {
            printf("CryptGenRandom ");
            goto Ret;
        }

        cbData = sizeof(rgbData);
        cb = cbData / 2;
        if (! CryptEncrypt(
            hKey, 0, TRUE, 0, rgbData, &cb, cbData))
        {
            printf("CryptEncrypt ");
            goto Ret;
        }

        if (! CryptExportKey(
            hKey, 0, PLAINTEXTKEYBLOB, 0, NULL, &cbKey))
        {
            printf("CryptExportKey size ");
            goto Ret;
        }

        if (NULL == (pbKey = (PBYTE) MyAlloc(cbKey)))
            return ERROR_NOT_ENOUGH_MEMORY;

        if (! CryptExportKey(
            hKey, 0, PLAINTEXTKEYBLOB, 0, pbKey, &cbKey))
        {
            printf("CryptExportKey ");
            goto Ret;
        }

        // check the blob
        header = (BLOBHEADER *) pbKey;
        if (pAlgNode->EnumalgsEx.aiAlgid != header->aiKeyAlg)
        {
            printf("header->aiKeyAlg is wrong ");
            goto Ret;
        }
        if (CUR_BLOB_VERSION != header->bVersion)
        {
            printf("header->bVersion is wrong ");
            goto Ret;
        }
        if (0 != header->reserved)
        {
            printf("header->reserved is wrong ");
            goto Ret;
        }
        if (PLAINTEXTKEYBLOB != header->bType)
        {
            printf("header->bType is wrong ");
            goto Ret;
        }

        pbTemp = pbKey + sizeof(BLOBHEADER);
        if (cbKeySize != *((DWORD*)pbTemp))
        {
            printf(
                "blob key size is %d, but should be %d ",
                *((DWORD*)pbTemp),
                cbKeySize);
            goto Ret;
        }

        MyFree(pbKey);
        if (! CryptDestroyKey(hKey))
        {
            printf("CryptDestroyKey ");
            hKey = 0;
            goto Ret;
        }
        hKey = 0;
    }

    fSuccess = TRUE;
Ret:
    if (! fSuccess)
        printf("- error 0x%x\n", dwError = GetLastError());
    if (hKey)
        CryptDestroyKey(hKey);

    return dwError;
}

//
// Function: LoadAesCspRegression
//
DWORD LoadAesCspRegression(PTHREAD_DATA pThreadData)
{
    DWORD dwError = 0;
    BOOL fSuccess = FALSE;
    HMODULE hMod = NULL;

    if (NULL == (hMod = LoadLibraryEx(RSA_AES_CSP, NULL, 0)))
    {
        printf("LoadLibraryEx %s ", RSA_AES_CSP);
        goto Ret;
    }

    if (! FreeLibrary(hMod))
    {
        printf("FreeLibrary %s ", RSA_AES_CSP);
        goto Ret;
    }

    fSuccess = TRUE;
Ret:
    if (! fSuccess)
        printf("- error 0x%x\n", dwError = GetLastError());

    return dwError;
}

DWORD VerifyPinCallback(PPINCACHE_PINS pPins, PVOID pvData)
{
    DWORD dwReturn = *(DWORD*)pvData;

    PrintBytes(
        "VerifyPinCallback current pin", 
        pPins->pbCurrentPin, pPins->cbCurrentPin);
    
    PrintBytes(
        "VerifyPinCallback new pin",
        pPins->pbNewPin, pPins->cbNewPin);

    return dwReturn;
}

static USHORT l_uTestLogonID;

void SetLogonID(USHORT uLogon)
{
    l_uTestLogonID = uLogon;   
}

void GetLogonID(LUID *pLuid)
{
    memset(pLuid, l_uTestLogonID, sizeof(LUID));
}

BOOL MyGetTokenInformation(
    HANDLE TokenHandle,
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    LPVOID TokenInformation,
    DWORD TokenInformationLength,
    PDWORD ReturnLength)
{
    NTSTATUS status = NtQueryInformationToken(
                        TokenHandle, TokenInformationClass,
                        TokenInformation, TokenInformationLength,
                        ReturnLength);

    if (TokenStatistics == TokenInformationClass)
    {
        printf("MyGetTokenInformation: intercepted TokenStatistics call\n");
        GetLogonID(&((TOKEN_STATISTICS*) TokenInformation)->AuthenticationId);
    }

    return (S_OK == status);
}

//
// Function: PinCacheRegression
//
DWORD PinCacheRegression(PTHREAD_DATA pThreadData)
{
    DWORD dwError = 0;
    BOOL fSuccess = FALSE;
    PINCACHE_HANDLE hCache = NULL;
    BYTE rgPin[] = { 1, 2, 3, 4 };
    DWORD cbPin = sizeof(rgPin);
    BYTE rgPin2[] = { 5, 6, 7, 8, 9 };
    BYTE *pbPin = NULL;
    PFN_VERIFYPIN_CALLBACK pfnVerifyPin = VerifyPinCallback;
    DWORD dwCallbackReturn;
    PINCACHE_PINS Pins;
    int i;

    ZeroMemory(&Pins, sizeof(PINCACHE_PINS));

    Pins.cbCurrentPin = sizeof(rgPin);
    Pins.pbCurrentPin = rgPin;

    dwCallbackReturn = 0x7070;
    if (0x7070 != (dwError =
            PinCacheAdd(&hCache, &Pins,
                        pfnVerifyPin, (PVOID) &dwCallbackReturn)))
    {
        printf("PinCacheAdd with callback fail ");
        goto Ret;
    }

    //
    // (0)
    // Cache uninitialized
    //
    SetLogonID(1);
    dwCallbackReturn = ERROR_SUCCESS;
    if (ERROR_SUCCESS != (dwError = 
            PinCacheAdd(&hCache, &Pins,
                        pfnVerifyPin, (PVOID) &dwCallbackReturn)))
    {
        printf("PinCacheAdd ");
        goto Ret;
    }

    if (ERROR_SUCCESS != (dwError = PinCacheQuery(hCache, NULL, &cbPin)))
    {
        printf("PinCacheQuery NULL for size ");
        goto Ret;
    }

    if (NULL == (pbPin = (PBYTE) MyAlloc(cbPin)))
        return ERROR_NOT_ENOUGH_MEMORY;

    cbPin--;
    if (ERROR_SUCCESS == (dwError = PinCacheQuery(hCache, pbPin, &cbPin)))
    {
        printf("PinCacheQuery insufficient size succeeded ");
        goto Ret;      
    }

    if (ERROR_SUCCESS != (dwError = PinCacheQuery(hCache, pbPin, &cbPin)))
    {
        printf("PinCacheQuery ");
        goto Ret;
    }

    if (sizeof(rgPin) != RtlCompareMemory(pbPin, rgPin, cbPin))
    {
        PrintBytes("Actual cache", pbPin, cbPin);
        PrintBytes("Expected cache", rgPin, sizeof(rgPin));
        printf("Cache is incorrect ");
        goto Ret;
    }

    PinCacheFlush(&hCache);

    if (NULL != hCache)
    {
        printf("PinCacheFlush should set hCache=NULL ");
        goto Ret;
    }

    // Re-initialize to continue tests
    if (ERROR_SUCCESS != (dwError = 
            PinCacheAdd(&hCache, &Pins,
                        pfnVerifyPin, (PVOID) &dwCallbackReturn)))
    {
        printf("PinCacheAdd ");
        goto Ret;
    }

    //
    // (1)
    // Same LogonID, same Pin
    //
    if (ERROR_SUCCESS != (dwError = 
            PinCacheAdd(&hCache, &Pins, 
                        pfnVerifyPin, (PVOID) &dwCallbackReturn)))
    {
        printf("PinCacheAdd 1 ");
        goto Ret;
    }
    
    cbPin = sizeof(rgPin);
    if (ERROR_SUCCESS != (dwError = PinCacheQuery(hCache, pbPin, &cbPin)))
    {
        printf("PinCacheQuery 1 ");
        goto Ret;
    }

    if (sizeof(rgPin) != RtlCompareMemory(pbPin, rgPin, cbPin))
    {
        PrintBytes("Actual cache", pbPin, cbPin);
        PrintBytes("Expected cache", rgPin, sizeof(rgPin));
        printf("Cache is incorrect 1 ");
        goto Ret;
    }
    
    // Try a pin change 
    Pins.cbNewPin = sizeof(rgPin2);
    Pins.pbNewPin = rgPin2;

    if (ERROR_SUCCESS != (dwError = 
            PinCacheAdd(&hCache, &Pins, 
                        pfnVerifyPin, (PVOID) &dwCallbackReturn)))
    {
        printf("PinCacheAdd 1 change ");
        goto Ret;
    }
    
    if (ERROR_SUCCESS != (dwError = PinCacheQuery(hCache, NULL, &cbPin)))
    {
        printf("PinCacheQuery 1 change query ");
        goto Ret;
    }

    MyFree(pbPin);
    pbPin = NULL;
    if (NULL == (pbPin = (PBYTE) MyAlloc(cbPin)))
        return ERROR_NOT_ENOUGH_MEMORY;

    if (ERROR_SUCCESS != (dwError = PinCacheQuery(hCache, pbPin, &cbPin)))
    {
        printf("PinCacheQuery 1 change ");
        goto Ret;
    }

    if (sizeof(rgPin2) != RtlCompareMemory(pbPin, rgPin2, cbPin))
    {
        PrintBytes("Actual cache", pbPin, cbPin);
        PrintBytes("Expected cache", rgPin, sizeof(rgPin));
        printf("Cache is incorrect 1 change ");
        goto Ret;
    }

    // Try a failed pin change
    Pins.cbCurrentPin = sizeof(rgPin2);
    Pins.pbCurrentPin = rgPin2;
    Pins.cbNewPin = sizeof(rgPin);
    Pins.pbNewPin = rgPin;
    dwCallbackReturn = -1;

    if (-1 != (dwError = 
            PinCacheAdd(&hCache, &Pins, 
                        pfnVerifyPin, (PVOID) &dwCallbackReturn)))
    {
        printf("PinCacheAdd 1 change-fail ");
        goto Ret;
    }

    // Cache should have been preserved
    cbPin = sizeof(rgPin2);
    ZeroMemory(pbPin, sizeof(rgPin2));

    if (ERROR_SUCCESS != (dwError = PinCacheQuery(hCache, pbPin, &cbPin)))
    {
        printf("PinCacheQuery 1 change-fail ");
        goto Ret;
    }

    if (sizeof(rgPin2) != RtlCompareMemory(pbPin, rgPin2, cbPin))
    {
        PrintBytes("Actual cache", pbPin, cbPin);
        PrintBytes("Expected cache", rgPin2, sizeof(rgPin2));
        printf("Cache is incorrect 1 change-fail ");
        goto Ret;
    }

    //
    // (2)
    // Different LogonID, different Pin
    //
    SetLogonID(2);
    Pins.cbCurrentPin -= 1;
    Pins.cbNewPin = 0;
    Pins.pbNewPin = NULL;
    dwCallbackReturn = ERROR_SUCCESS;
    if (SCARD_W_WRONG_CHV != (dwError = 
            PinCacheAdd(&hCache, &Pins,
                        pfnVerifyPin, (PVOID) &dwCallbackReturn)))
    {
        printf("PinCacheAdd 2 ");
        goto Ret;
    }

    SetLogonID(1);
    cbPin = sizeof(rgPin2);
    if (ERROR_SUCCESS != (dwError = PinCacheQuery(hCache, pbPin, &cbPin)))
    {
        printf("PinCacheQuery 2 ");
        goto Ret;
    }

    if (sizeof(rgPin2) != RtlCompareMemory(pbPin, rgPin2, cbPin))
    {
        PrintBytes("Actual cache", pbPin, cbPin);
        PrintBytes("Expected cache", rgPin2, sizeof(rgPin2));
        printf("Cache is incorrect 2 ");
        goto Ret;
    }

    //
    // (3)
    // Different LogonID, same Pin
    //
    SetLogonID(2);
    Pins.cbCurrentPin = sizeof(rgPin2);
    if (ERROR_SUCCESS != (dwError = 
            PinCacheAdd(&hCache, &Pins, 
                        pfnVerifyPin, (PVOID) &dwCallbackReturn)))
    {
        printf("PinCacheAdd 3 ");
        goto Ret;
    }

    cbPin = sizeof(rgPin2);
    if (ERROR_SUCCESS != (dwError = PinCacheQuery(hCache, pbPin, &cbPin)))
    {
        printf("PinCacheQuery 3 ");
        goto Ret;
    }

    if (sizeof(rgPin2) != RtlCompareMemory(pbPin, rgPin2, cbPin))
    {
        PrintBytes("Actual cache", pbPin, cbPin);
        PrintBytes("Expected cache", rgPin2, sizeof(rgPin2));
        printf("Cache is incorrect 3 ");
        goto Ret;
    }

    SetLogonID(1);
    if (ERROR_SUCCESS != (dwError = PinCacheQuery(hCache, pbPin, &cbPin)))
    {
        printf("PinCacheQuery 3,1 ");
        goto Ret;
    }

    if (0 != cbPin)
    {
        printf("PinCacheQuery 3,1 should have returned NULL pin ");
        goto Ret;
    }

    //
    // (4)
    // Same LogonID, different Pin
    //
    SetLogonID(2);
    Pins.cbCurrentPin -= 1;
    if (SCARD_W_WRONG_CHV != (dwError = 
            PinCacheAdd(&hCache, &Pins, 
                        pfnVerifyPin, (PVOID) &dwCallbackReturn)))
    {
        printf("PinCacheAdd 4 ");
        goto Ret;
    }

    // cache should have been left intact
    cbPin = sizeof(rgPin2);
    if (ERROR_SUCCESS != (dwError = PinCacheQuery(hCache, pbPin, &cbPin)))
    {
        printf("PinCacheQuery 4 ");
        goto Ret;
    }

    if (sizeof(rgPin2) != RtlCompareMemory(pbPin, rgPin2, cbPin))
    {
        PrintBytes("Actual cache", pbPin, cbPin);
        PrintBytes("Expected cache", rgPin2, sizeof(rgPin2));
        printf("Cache is incorrect 4 ");
        goto Ret;
    }

    if (! pThreadData->fSkipPinAttackTest)
    {
        //
        // (5)
        // Pin discovery attack
        //
    
        SetLogonID(2);
        Pins.cbCurrentPin -= 1;
    
        for (i = 0; i < 6; i++)
        {
            printf("PinCacheAdd should not delay ...\n");
            if (SCARD_W_WRONG_CHV != (dwError = 
                    PinCacheAdd(&hCache, &Pins, 
                                pfnVerifyPin, (PVOID) &dwCallbackReturn)))
            {
                printf("PinCacheAdd 5 . %d ", i);
                goto Ret;
            }
        }
    
        SetLogonID(1);
        for (i = 0; i < 6; i++)
        {
            printf("PinCacheAdd should delay ...\n");
            if (SCARD_W_WRONG_CHV != (dwError = 
                    PinCacheAdd(&hCache, &Pins, 
                                pfnVerifyPin, (PVOID) &dwCallbackReturn)))
            {
                printf("PinCacheAdd 6 . %d ", i);
                goto Ret;
            }
        }
    
        // cache should have been left intact
        SetLogonID(2);                       
        Pins.cbCurrentPin += 1;
        cbPin = sizeof(rgPin2);
        if (ERROR_SUCCESS != (dwError = PinCacheQuery(hCache, pbPin, &cbPin)))
        {
            printf("PinCacheQuery 5 ");
            goto Ret;
        }
    
        if (sizeof(rgPin2) != RtlCompareMemory(pbPin, rgPin2, cbPin))
        {
            PrintBytes("Actual cache", pbPin, cbPin);
            PrintBytes("Expected cache", rgPin2, sizeof(rgPin2));
            printf("Cache is incorrect 5 ");
            goto Ret;
        }
    
        //
        // Test PinCachePresentPin
        //
        dwCallbackReturn = 0x7070;
        if (0x7070 != (dwError =
                PinCachePresentPin(hCache, pfnVerifyPin, (PVOID) &dwCallbackReturn)))
        {
            printf("PinCachePresentPin fail ");
            goto Ret;
        }
    
        SetLogonID(1);
        if (SCARD_W_CARD_NOT_AUTHENTICATED != (dwError =
                PinCachePresentPin(hCache, pfnVerifyPin, (PVOID) &dwCallbackReturn)))
        {
            printf("PinCachePresentPin wrong luid fail ");
            goto Ret;
        }
    }

    dwError = ERROR_SUCCESS;
    fSuccess = TRUE;
Ret:
    if (pbPin)
        MyFree(pbPin);
    if (hCache)
        PinCacheFlush(&hCache);

    if (! fSuccess)
    {
        printf("- error 0x%x\n", dwError);
        if (0 == dwError)
            return -1;
    }

    return dwError;
}

//
// Function: VerifyDesKeyParams
//
DWORD VerifyDesKeyParams(
    IN HCRYPTKEY hKey, 
    IN DWORD dwExpectedKeyLen,
    IN DWORD dwExpectedEffectiveKeyLen)
{
    DWORD dwError = 0;
    DWORD dwParam = 0;
    DWORD cb = sizeof(dwParam);
    BOOL fSuccess = FALSE;

    if (! CryptGetKeyParam(hKey, KP_KEYLEN, (PBYTE) &dwParam, &cb, 0))
    {
        dwError = GetLastError();
        printf("CryptGetKeyParam KP_KEYLEN ");
        goto Ret;
    }

    if (dwExpectedKeyLen != dwParam)
    {
        printf(
            "FAIL: VerifyDesKeyParams expected KP_KEYLEN=%d, actual=%d\n",
            dwExpectedKeyLen, dwParam);
        goto Ret;
    }

    if (! CryptGetKeyParam(hKey, KP_EFFECTIVE_KEYLEN, (PBYTE) &dwParam, &cb, 0))
    {
        dwError = GetLastError();
        printf("CryptGetKeyParam KP_EFFECTIVE_KEYLEN ");
        goto Ret;
    }

    if (dwExpectedEffectiveKeyLen != dwParam)
    {
        printf(
            "FAIL: VerifyDesKeyParams expected KP_EFFECTIVE_KEYLEN=%d, actual=%d\n",
            dwExpectedEffectiveKeyLen, dwParam);
        goto Ret;
    }

    fSuccess = TRUE;
Ret:
    if (! fSuccess)
    {
        printf(" - error 0x%x\n", dwError);
        if (0 == dwError)
            dwError = -1;
    }

    return dwError;
}

//
// Function: DesGetKeyParamRegression
//
DWORD DesGetKeyParamRegression(PTHREAD_DATA pThreadData)
{
    DWORD dwError                   = ERROR_SUCCESS;
    BOOL fSuccess                   = FALSE;
    HCRYPTKEY hKey                  = 0;

    if (! CryptGenKey(pThreadData->hProv, CALG_DES, 0, &hKey))
    {
        dwError = GetLastError();
        printf("CryptGenKey des ");
        goto Ret;
    }

    if (ERROR_SUCCESS != (dwError = VerifyDesKeyParams(hKey, 64, 56)))
    {
        printf("VerifyDesKeyParams des ");
        goto Ret;
    }

    if (! CryptDestroyKey(hKey))
    {
        dwError = GetLastError();
        printf("CryptDestroyKey des ");
        goto Ret;
    }
    hKey = 0;

    if (! CryptGenKey(pThreadData->hProv, CALG_3DES_112, 0, &hKey))
    {
        dwError = GetLastError();
        printf("CryptGenKey 3des_112 ");
        goto Ret;
    }

    if (ERROR_SUCCESS != (dwError =  VerifyDesKeyParams(hKey, 128, 112)))
    {
        printf("VerifyDesKeyParams 3des_112 ");
        goto Ret;
    }

    if (! CryptDestroyKey(hKey))
    {
        dwError = GetLastError();
        printf("CryptDestroyKey 3des_112 ");
        goto Ret;
    }
    hKey = 0;

    if (! CryptGenKey(pThreadData->hProv, CALG_3DES, 0, &hKey))
    {
        dwError = GetLastError();
        printf("CryptGenKey 3des ");
        goto Ret;
    }

    if (ERROR_SUCCESS != (dwError = VerifyDesKeyParams(hKey, 192, 168)))
    {
        printf("VerifyDesKeyParams 3des ");
        goto Ret;
    }

    if (! CryptDestroyKey(hKey))
    {
        dwError = GetLastError();
        printf("CryptDestroyKey 3des ");
        goto Ret;
    }

    fSuccess = TRUE;
Ret:
    if (! fSuccess)
    {
        printf("- error 0x%x\n", dwError);
        if (0 == dwError)
            return -1;
    }

    return dwError;
}

//
// Function: MacEncryptRegression
//
DWORD MacEncryptRegression(
    IN PTHREAD_DATA pThreadData)
{
    DWORD dwError                   = ERROR_SUCCESS;
    BOOL fSuccess                   = FALSE;
    HCRYPTKEY hSymKey               = 0;
    HCRYPTKEY hMacKey               = 0;
    HCRYPTKEY hMacKey2              = 0;
    HCRYPTHASH hMac                 = 0;
    BYTE rgPlaintext[31];
    DWORD cb                        = sizeof(rgPlaintext);
    DWORD cbBuf                     = 0;
    PBYTE pbMac                     = NULL;
    DWORD cbMac                     = 0;
    PBYTE pb                        = NULL;
    DWORD cbAlign                   = 0;

#define GetNextAlignedValue(c, alignment)   ((c + alignment) & ~(alignment - 1))

#define GetPtrAlignedSize(cb) (GetNextAlignedValue(cb, sizeof(ULONG_PTR)))

    cbAlign = GetNextAlignedValue(60, 4);
    cbAlign = GetPtrAlignedSize(60);

    if (! CryptGenKey(pThreadData->hProv, CALG_RC2, 0, &hSymKey))
    {
        printf("CryptGenKey rc2");
        goto Ret;
    }

    if (! CryptGenKey(pThreadData->hProv, CALG_RC2, 0, &hMacKey))
    {
        printf("CryptGenKey rc2 2");
        goto Ret;
    }

    if (! CryptDuplicateKey(hMacKey, NULL, 0, &hMacKey2))
    {
        printf("CryptDuplicateKey");
        goto Ret;
    }

    if (! CryptCreateHash(pThreadData->hProv, CALG_MAC, hMacKey, 0, &hMac))
    {
        printf("CryptCreateHash");
        goto Ret;
    }

    while (cb--)
        rgPlaintext[cb] = (BYTE) cb;

    cb = sizeof(rgPlaintext);
    if (! CryptEncrypt(hSymKey, 0, TRUE, 0, NULL, &cb, 0))
    {
        printf("CryptEncrypt size");
        goto Ret;
    }

    if (NULL == (pb = (PBYTE) MyAlloc(cb)))
        return ERROR_NOT_ENOUGH_MEMORY;

    cbBuf = cb;
    cb = sizeof(rgPlaintext);
    if (! CryptEncrypt(hSymKey, hMac, TRUE, 0, pb, &cb, cbBuf))
    {
        printf("CryptEncrypt");
        goto Ret;
    }

    if (! CryptGetHashParam(hMac, HP_HASHVAL, NULL, &cbMac, 0))
    {
        printf("CryptGetHashParam size");
        goto Ret;
    }

    if (NULL == (pbMac = (PBYTE) MyAlloc(cbMac)))
        return ERROR_NOT_ENOUGH_MEMORY;

    if (! CryptGetHashParam(hMac, HP_HASHVAL, pbMac, &cbMac, 0))
    {
        printf("CryptGetHashParam");
        goto Ret;
    }

    if (! CryptDestroyHash(hMac))
    {
        printf("CryptDestroyHash");
        goto Ret;
    }
    hMac = 0;

    if (! CryptCreateHash(pThreadData->hProv, CALG_MAC, hMacKey2, 0, &hMac))
    {
        printf("CryptCreateHash 2");
        goto Ret;
    }

    if (! CryptDecrypt(hSymKey, hMac, TRUE, 0, pb, &cb))
    {
        printf("CryptDecrypt");
        goto Ret;
    }

    MyFree(pb);
    pb = NULL;

    if (! CryptGetHashParam(hMac, HP_HASHVAL, NULL, &cb, 0))
    {
        printf("CryptGetHashParam size");
        goto Ret;
    }

    if (NULL == (pb = (PBYTE) MyAlloc(cb)))
        return ERROR_NOT_ENOUGH_MEMORY;

    if (! CryptGetHashParam(hMac, HP_HASHVAL, pb, &cb, 0))
    {
        printf("CryptGetHashParam");
        goto Ret;
    }

    PrintBytes("Expected Mac result", pbMac, cbMac);
    PrintBytes("Actual Mac result", pb, cb);

    if (0 != memcmp(pb, pbMac, cb) 
        || 0 == cb
        || cb != cbMac)
    {
        goto Ret;
    }

    fSuccess = TRUE;
Ret:
    if (! fSuccess)
    {
        dwError = GetLastError();
        printf(" - error 0x%x\n", dwError);
        if (0 == dwError)
            dwError = -1;
    }

    if (pb)
        MyFree(pb);
    if (pbMac)
        MyFree(pbMac);
    if (hSymKey)
        CryptDestroyKey(hSymKey);
    if (hMacKey)
        CryptDestroyKey(hMacKey);
    if (hMacKey2)
        CryptDestroyKey(hMacKey2);
    if (hMac)
        CryptDestroyHash(hMac);
    
    return dwError;
}

//
// Function: StressEncryptionTest
//
DWORD StressEncryptionTest(
    IN HCRYPTPROV hProv,
    IN PENCRYPTION_TEST_DATA pTestData)
{
    HCRYPTKEY hEncryptionKey        = 0;
    HCRYPTKEY hHashKey1             = 0;
    HCRYPTKEY hHashKey2             = 0;
    HCRYPTHASH hHash                = 0;
    PBYTE pbData                    = 0;
    DWORD dwData                    = 0;
    DWORD cbData                    = 0;
    DWORD cbPlainText               = 0;
    DWORD cbCipherText              = 0;
    DWORD cbProcessed               = 0;
    DWORD dwKeyAlg                  = 0;
    DWORD dwBlockLen                = 0;
    BOOL fFinal                     = FALSE;
    DWORD dwError                   = 0;
    BOOL fSuccess                   = FALSE;
    BYTE rgbHashVal1[200];
    BYTE rgbHashVal2[200];

    ZeroMemory(rgbHashVal1, 200);
    ZeroMemory(rgbHashVal2, 200);

    if (! CryptGenKey(
        hProv,
        pTestData->aiEncryptionKey,
        0,
        &hEncryptionKey))
    {
        goto Cleanup;
    }

    //
    // Check for requested simultaneous encryption/hashing
    //
    if (pTestData->aiHash)
    {
        // 
        // Is this a keyed hash?
        //
        if (pTestData->aiHashKey)
        {
            if (! CryptGenKey(
                hProv,
                pTestData->aiHashKey,
                0,
                &hHashKey1))
            {
                goto Cleanup;
            }

            //
            // To verify the result of hashing the same data in two 
            // separate keyed hashes, the key must first be duplicated,
            // since its state changes once it's used.
            //
            if (! CryptDuplicateKey(
                hHashKey1,
                NULL,
                0,
                &hHashKey2))
            {
                goto Cleanup;
            }
        }

        if (! CryptCreateHash(
            hProv,
            pTestData->aiHash,
            hHashKey1,
            0,
            &hHash))
        {
            goto Cleanup;
        }
    }

    //
    // Is this a block encryption alg?
    //
    if (ALG_TYPE_BLOCK & pTestData->aiEncryptionKey)
    {
        //
        // Get the block size of this encryption alg
        //
        cbData = sizeof(dwBlockLen);
        if (! CryptGetKeyParam(
            hEncryptionKey,
            KP_BLOCKLEN,
            (PBYTE) &dwBlockLen,
            &cbData,
            0))
        {
            goto Cleanup;
        }

        //
        // Choose an "interesting" plaintext length, based on the block length
        // of this alg.  
        //
        cbPlainText = 2 * dwBlockLen + 1;
    }
    else
    {
        // 
        // Plaintext length for a stream encryption alg
        //
        cbPlainText = 500;
    }

    cbCipherText = cbPlainText; 

    //
    // Determine size of ciphertext
    //
    if (! CryptEncrypt(
        hEncryptionKey,
        0,
        TRUE,
        0,
        NULL,
        &cbCipherText,
        0))
    {
        goto Cleanup;
    }

    if (NULL == (pbData = (PBYTE) MyAlloc(cbCipherText)))
    {
        goto Cleanup;
    }

    //
    // Initialize the plaintext
    //
    memset(pbData, 0xDA, cbPlainText);
    memset(pbData + cbPlainText, 0, cbCipherText - cbPlainText);

    // 
    // Encrypt
    //
    cbProcessed = 0;
    while (! fFinal)
    {
        if (0 == dwBlockLen)
        {
            cbData = cbPlainText;
            fFinal = TRUE;
        }
        else
        {           
            if (cbPlainText - cbProcessed > dwBlockLen)
            {
                cbData = dwBlockLen;
            }
            else
            {
                cbData = cbPlainText % dwBlockLen;
                fFinal = TRUE;
            }
        }

        if (! CryptEncrypt(
            hEncryptionKey,
            hHash,
            fFinal,
            0,
            pbData + cbProcessed,
            &cbData,
            cbCipherText))
        {
            goto Cleanup;
        }

        cbProcessed += cbData;
    }

    if (cbProcessed != cbCipherText)
    {
        goto Cleanup;
    }

    if (0 != hHash)
    {
        //
        // Get hash result from encryption
        //
        cbData = sizeof(rgbHashVal1);
        if (! CryptGetHashParam(
            hHash,
            HP_HASHVAL,
            rgbHashVal1,
            &cbData,
            0))
        {
            goto Cleanup;
        }

        if (! CryptDestroyHash(hHash))
        {
            goto Cleanup;
        }

        if (! CryptCreateHash(
            hProv,
            pTestData->aiHash,
            hHashKey2,
            0,
            &hHash))
        {
            goto Cleanup;
        }
    }

    //
    // Decrypt
    //
    cbProcessed = 0;
    fFinal = FALSE;
    while (! fFinal)
    {
        if (0 == dwBlockLen)
        {
            cbData = cbCipherText;
            fFinal = TRUE;
        }
        else
        {
            if (cbCipherText - cbProcessed > dwBlockLen)
            {
                cbData = dwBlockLen;
            }
            else
            {
                cbData = cbCipherText - cbProcessed;
                fFinal = TRUE;
            }
        }

        if (! CryptDecrypt(
            hEncryptionKey,
            hHash,
            fFinal,
            0,
            pbData + cbProcessed,
            &cbData))
        {
            goto Cleanup;
        }

        cbProcessed += cbData;
    }

    if (cbProcessed != cbPlainText)
    {
        goto Cleanup;
    }

    while (cbPlainText)
    {
        if (0xDA != pbData[cbPlainText - 1])
        {
            goto Cleanup;
        }
        cbPlainText--;
    }

    if (0 != hHash)
    {
        //
        // Get hash result from decryption
        //
        cbData = sizeof(rgbHashVal2);
        if (! CryptGetHashParam(
            hHash,
            HP_HASHVAL,
            rgbHashVal2,
            &cbData,
            0))
        {
            goto Cleanup;
        }

        if (0 != memcmp(rgbHashVal1, rgbHashVal2, cbData))
        {
            goto Cleanup;
        }
    }

    fSuccess = TRUE;
Cleanup:
    if (! fSuccess)
    {
        if (0 == (dwError = GetLastError()))
        {
            dwError = -1;
        }
    }
    if (hEncryptionKey)
    {
        CryptDestroyKey(hEncryptionKey);
    }
    if (hHashKey1)
    {
        CryptDestroyKey(hHashKey1);
    }
    if (hHashKey2)
    {
        CryptDestroyKey(hHashKey2);
    }
    if (hHash)
    {
        CryptDestroyHash(hHash);
    }
    if (pbData)
    {
        MyFree(pbData);
    }

    return dwError;
}

//
// Function: StressTestAllEncryptionAlgs
//
DWORD StressTestAllEncryptionAlgs(
    PTHREAD_DATA pThreadData,
    BOOL fContinueOnMacError,
    BOOL *pfMacErrorOccurred)
{
    DWORD dwError = 0;
    ENCRYPTION_TEST_DATA TestData;
    PALGNODE pEncryptionAlg, pHashAlg, pBlockEncryptionAlg;

    ZeroMemory(&TestData, sizeof(TestData));

    for (   pEncryptionAlg = pThreadData->pAlgList; 
            NULL != pEncryptionAlg;
            pEncryptionAlg = pEncryptionAlg->pNext)
    {
        if (! (pEncryptionAlg->EnumalgsEx.aiAlgid & ALG_CLASS_DATA_ENCRYPT))
            continue;

        TestData.aiEncryptionKey = pEncryptionAlg->EnumalgsEx.aiAlgid;

        for (   pHashAlg = pThreadData->pAlgList;
                NULL != pHashAlg;
                pHashAlg = pHashAlg->pNext)
        {
            if (    (! (pHashAlg->EnumalgsEx.aiAlgid & ALG_CLASS_HASH &&
                        pHashAlg->EnumalgsEx.aiAlgid & ALG_TYPE_ANY)) ||
                    CALG_SSL3_SHAMD5 == pHashAlg->EnumalgsEx.aiAlgid ||
                    CALG_TLS1PRF == pHashAlg->EnumalgsEx.aiAlgid)
                continue;

            TestData.aiHash = pHashAlg->EnumalgsEx.aiAlgid;

            if (CALG_MAC == pHashAlg->EnumalgsEx.aiAlgid)
            {
                for (   pBlockEncryptionAlg = pThreadData->pAlgList;
                        NULL != pBlockEncryptionAlg;
                        pBlockEncryptionAlg = pBlockEncryptionAlg->pNext)
                {
                    if (! ( pBlockEncryptionAlg->EnumalgsEx.aiAlgid & ALG_CLASS_DATA_ENCRYPT &&
                            pBlockEncryptionAlg->EnumalgsEx.aiAlgid & ALG_TYPE_BLOCK))
                        continue;

                    TestData.aiHashKey = pBlockEncryptionAlg->EnumalgsEx.aiAlgid;

                    if (ERROR_SUCCESS != (dwError = StressEncryptionTest(pThreadData->hProv, &TestData)))
                    {
                        if (fContinueOnMacError)
                            *pfMacErrorOccurred = TRUE;
                        else
                            return dwError;
                    }
                }
            }
            else
            {
                if (ERROR_SUCCESS != (dwError = StressEncryptionTest(pThreadData->hProv, &TestData)))
                    return dwError;
            }
        }
    }

    return dwError;
}

//+ ===========================================================================
//- ===========================================================================
void L_ErrorBox(LPSTR pszMsg, DWORD dwThreadNum)
{
    char szErrorMsg[256] ;
    sprintf(szErrorMsg, "Thread %d: %s in L_ErrorBox", dwThreadNum, pszMsg) ;
    MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
}


//+ ===========================================================================
//- ===========================================================================
void L_LastErrorBox(LPSTR pszMsg, DWORD dwThreadNum)
{
    char szErrorMsg[256] ;
    sprintf(szErrorMsg, "Thread %d: %s 0x%x in L_LastErrorBox", dwThreadNum, pszMsg, GetLastError()) ;
    MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
}



//+ =================================================================================
//
//  L_GetKeyAlg
//  Local function that given a key handle, returns the key Alg.
//  
//- =================================================================================
DWORD   L_GetKeyAlg(HCRYPTKEY hKey)
{
    DWORD   dwData = 0;
    DWORD   cbData=0 ;
    char szErrorMsg[256];

    cbData = sizeof(dwData) ;
    
    if (!CryptGetKeyParam(
        hKey,
        KP_ALGID,
        (PBYTE) &dwData,
        &cbData,
        0))
    {
        GENERIC_FAIL(CryptGetKeyParam) ;
    }

ErrorReturn:
    return dwData;
}



//+ =================================================================================
//
//  L_GetKeySize
//  Local function that given a key handle, returns the key length.
//  
//- =================================================================================
DWORD   L_GetKeySize(HCRYPTKEY hKey)
{
    DWORD   dwData = 0;
    DWORD   cbData=0 ;
    char szErrorMsg[256];
 
    cbData = sizeof(dwData) ;
 
    if (!CryptGetKeyParam(
        hKey,
        KP_KEYLEN,
        (PBYTE) &dwData,
        &cbData,
        0))
    {
        GENERIC_FAIL(CryptGetKeyParam) ;
    }

ErrorReturn:
    return dwData;
}

//+ ==============================================================================
//- ==============================================================================
DWORD   Hlp_GetKeyAlgId(HCRYPTKEY hKey)
{
    DWORD   dwRetVal=0 ;
    PBYTE   pbData=NULL ;
    DWORD   cbData=sizeof(DWORD) ;
    char    szErrorMsg[256] ; 
    DWORD   dwAlgId=0 ;

    if (!CryptGetKeyParam(
                    hKey,
                    KP_ALGID,
                    (PBYTE)&dwAlgId,
                    &cbData,
                    0))
        GENERIC_FAIL(CryptGetKeyParam) ;


    dwRetVal=dwAlgId ;
    
    ErrorReturn :
    return dwRetVal ;
}




//+ =================================================================================
//
//  L_GetKeyParam
//  Local function that given a key handle, retrieves the specified Key Param.
//  The Key param is not of too much interest in this case. In a multithread scenario,
//  we just care to see if the call succeeds. 
//  
//- =================================================================================
DWORD   L_GetKeyParam(HCRYPTKEY hKey, DWORD dwParam)
{
    DWORD   dwRetVal=0 ;
    PBYTE   pbData=NULL ;
    DWORD   cbData=0 ;
    char    szErrorMsg[256] ; 
    DWORD   dwAlgId=0 ;
    DWORD   dwError=0 ;

    if (!CryptGetKeyParam(  hKey,
                            dwParam,
                            NULL,
                            &cbData,
                            0))
        GENERIC_FAIL(CryptGetKeyParam) ;

    if (NULL == (pbData = (PBYTE) MyAlloc(cbData)))
        ALLOC_FAIL(pbData);

    if (!CryptGetKeyParam(  hKey,
                            dwParam,
                            pbData,
                            &cbData,
                            0))
        GENERIC_FAIL(CryptGetKeyParam) ;

    dwRetVal=1 ;
    
    ErrorReturn :
    MyFree(pbData) ;
    return dwRetVal ;
}




//+ ======================================================================================
//  ProgramInit
//  Acquire context
//  Generate Keys that will be used by all the threads. (AT_SIGNATURE and AT_KEYEXCHANGE)
//- ======================================================================================
DWORD ProgramInit(PTHREAD_DATA pThreadData)
{
    DWORD   dwRetVal                = 0;
    char    szErrorMsg[256];        //  defined for GENERIC_FAIL
    LPSTR   pszContainer            = NULL;
    DWORD   dwContextFlags          = 0;
    DWORD   dwKeyFlags              = CRYPT_EXPORTABLE;

    if (pThreadData->fEphemeralKeys)
    {
        dwContextFlags = CRYPT_VERIFYCONTEXT;
    }
    else
    {
        pszContainer = KEY_CONTAINER_NAME;
        dwContextFlags = CRYPT_NEWKEYSET;

        CryptAcquireContext(
            &pThreadData->hProv,
            pszContainer,
            pThreadData->rgszProvName,
            pThreadData->dwProvType,
            CRYPT_DELETEKEYSET);

        // Create a Verify Context for some of the sub-tests to use
        if (! CryptAcquireContext(
            &pThreadData->hVerifyCtx, 
            NULL, 
            pThreadData->rgszProvName, 
            pThreadData->dwProvType, 
            CRYPT_VERIFYCONTEXT))
        {
            pThreadData->hVerifyCtx = 0;
            GENERIC_FAIL(CryptAcquireContext_VERIFYCONTEXT);
        }
    }

    if (pThreadData->fUserProtectedKeys)
        dwKeyFlags |= CRYPT_USER_PROTECTED;
    
    if (!CryptAcquireContext(
        &pThreadData->hProv,
        pszContainer, 
        pThreadData->rgszProvName,
        pThreadData->dwProvType, 
        dwContextFlags))
    {
        pThreadData->hProv = 0;
        GENERIC_FAIL(CryptAcquireContext_Init);
    }
    
    //  Generate a sign and exchange key
    if (!CryptGenKey(
        pThreadData->hProv,
        AT_SIGNATURE, 
        dwKeyFlags, 
        &pThreadData->hSignatureKey))
    {
        GENERIC_FAIL(CryptGenKey_AT_SIGNATURE);
        CryptReleaseContext(pThreadData->hProv, 0);
        pThreadData->hProv = 0;
        pThreadData->hSignatureKey = 0;              
    }
    
    if (PROV_RSA_FULL == pThreadData->dwProvType ||
        PROV_RSA_AES == pThreadData->dwProvType ||
        PROV_DSS_DH == pThreadData->dwProvType)
    {
        if (!CryptGenKey(
            pThreadData->hProv,
            AT_KEYEXCHANGE, 
            dwKeyFlags, 
            &pThreadData->hExchangeKey))
        {
            GENERIC_FAIL(CryptGenKey_AT_KEYEXCHANGE);
            CryptReleaseContext(pThreadData->hProv, 0);
            pThreadData->hProv = 0;
            pThreadData->hExchangeKey = 0;                    
        }
    }

    dwRetVal=1;

ErrorReturn:
    return dwRetVal;
}

// ======================================================================================
//  Terminates all the threads after the specified amount of time has elapsed (-t option)
//  This thread sleeps for the specified amount of time and them then turns off the 
//  g_dwLoopSwitch.
// ======================================================================================
void WINAPI KillProgramTimer(LPVOID pvThreadData)
{
    DWORD   dwSleepTime=0;
    PTHREAD_DATA pThreadData = (PTHREAD_DATA) pvThreadData;
    
    if (pThreadData->dwProgramMins)
    {
        dwSleepTime = pThreadData->dwProgramMins * 60 * 1000;

        SleepEx(dwSleepTime, FALSE);

        if (! SetEvent(pThreadData->hEndTestEvent))
        {
            printf("SetEvent() failed, 0x%x\n", GetLastError());
            exit(1);
        }

        printf("All threads should be shutting down now....\n");
    }
}


// ======================================================================================
//  Prints the status of all the threads
//  The status is represented in iteration count in ThreadStatus[i][0]
// ======================================================================================
void WINAPI PrintThreadStatus(LPVOID pvThreadData)
{
    DWORD thread;
    PTHREAD_DATA pThreadData = (PTHREAD_DATA) pvThreadData;
    char rgStatus[256] ;

    printf("\n\n\n") ;
    while (WAIT_TIMEOUT == WaitForSingleObject(pThreadData->hEndTestEvent, 0))
    {
        Sleep(10000);
        ZeroMemory(rgStatus, sizeof(rgStatus));

        for (thread = 0; thread < pThreadData->dwThreadCount; thread++)
        {
            sprintf(
                rgStatus + strlen(rgStatus),
                " %4x",
                pThreadData->rgdwThreadStatus[thread]);
        }

        printf("%s\n", rgStatus);
    }
}

//+ ========================================================================
//
//      Function    :   L_GetAllKeyParams
//      Purpose     :   Gets all the key params and does nothing with it
//
//- ========================================================================
DWORD   L_GetAllKeyParams(HCRYPTKEY hKey, DWORD dwThreadNum) 
{
    char        szErrorMsg[256] ; 
    ALG_ID      AlgId=0 ;
    DWORD       dwRetVal=0 ;

    AlgId = (ALG_ID)Hlp_GetKeyAlgId(hKey) ;
    
    //  Get Keys Length
    if (!L_GetKeyParam(hKey, KP_KEYLEN))
    {
        sprintf(szErrorMsg, "Thread %d: L_GetKeyParam KP_KEYLEN error 0x%x", 
                            dwThreadNum, GetLastError()) ;
        MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
        goto ErrorReturn ;
    }

    //  Get ALGID
    if (!L_GetKeyParam(hKey, KP_ALGID))
    {
        sprintf(szErrorMsg, "Thread %d: L_GetKeyParam KP_ALGID  error 0x%x", 
                            dwThreadNum, GetLastError()) ;
        MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
        goto ErrorReturn ;
    }
    

    //  Get KP_BLOCKLEN
    //  Although this is meaningful only for block cipher keys, it will not fail 
    //  for RSA Keys. It'll just return 0 as the block len (which we don't care 
    //  about for multi tests.
    if (!L_GetKeyParam(hKey, KP_BLOCKLEN))
    {
        sprintf(szErrorMsg, "Thread %d: L_GetKeyParam KP_BLOCKLEN  error 0x%x", 
                            dwThreadNum, GetLastError()) ;
        MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
        goto ErrorReturn ;
    }

    /*
    if (! (ALG_CLASS_SIGNATURE == GET_ALG_CLASS(AlgId) 
            || ALG_CLASS_KEY_EXCHANGE == GET_ALG_CLASS(AlgId)))
    {
        if (!L_GetKeyParam(hKey, KP_SALT))
        {
            sprintf(szErrorMsg, "Thread %d: L_GetKeyParam KP_SALT error 0x%x", 
                                dwThreadNum, GetLastError()) ;
            MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
            goto ErrorReturn ;
        }
    }
    */

    //  Get KP_PERMISSIONS
    if (!L_GetKeyParam(hKey, KP_PERMISSIONS))
    {
        sprintf(szErrorMsg, "Thread %d: L_GetKeyParam KP_PERMISSION  error 0x%x", 
                            dwThreadNum, GetLastError()) ;
        MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
        goto ErrorReturn ;
    }



    //  Effective KeyLen can be queried only for RC2 key
    if (CALG_RC2 == AlgId)
    {
        //  Get KP_EFFECTIVE_KEYLEN
        if (!L_GetKeyParam(hKey, KP_EFFECTIVE_KEYLEN))
        {
            sprintf(szErrorMsg, "Thread %d: L_GetKeyParam KP_EFFECTIVE_KEYLEN  error 0x%x", 
                                dwThreadNum, GetLastError()) ;
            MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
            goto ErrorReturn ;
        }
    }


    //  These Key Params are good only for Block Cipher Keys
    if (ALG_TYPE_BLOCK == GET_ALG_TYPE(AlgId) 
        && ALG_CLASS_DATA_ENCRYPT == GET_ALG_CLASS(AlgId))
    {
        //  Get KP_IV
        if (!L_GetKeyParam(hKey, KP_IV))
        {
            sprintf(szErrorMsg, "Thread %d: L_GetKeyParam KP_IV  error 0x%x", 
                                dwThreadNum, GetLastError()) ;
            MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
            goto ErrorReturn ;
        }

        //  Get KP_PADDING
        if (!L_GetKeyParam(hKey, KP_PADDING))
        {
            sprintf(szErrorMsg, "Thread %d: L_GetKeyParam KP_PADDING  error 0x%x", 
                                dwThreadNum, GetLastError()) ;
            MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
            goto ErrorReturn ;
        }

        //  Get KP_MODE
        if (!L_GetKeyParam(hKey, KP_MODE))
        {
            sprintf(szErrorMsg, "Thread %d: L_GetKeyParam KP_MODE  error 0x%x", 
                                dwThreadNum, GetLastError()) ;
            MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
            goto ErrorReturn ;
        }

        //  Get KP_MODE_BITS
        if (!L_GetKeyParam(hKey, KP_MODE_BITS))
        {
            sprintf(szErrorMsg, "Thread %d: L_GetKeyParam KP_MODE_BITS  error 0x%x", 
                                dwThreadNum, GetLastError()) ;
            MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
            goto ErrorReturn ;
        }
    }

        
    dwRetVal=1 ;
    
    ErrorReturn :
    return dwRetVal ;
}


/*
    L_ProvParam2Text

    dangriff -- Modifying this function so that caller must free the psz 
            return value.
*/
char *L_ProvParam2Text(DWORD dwParam)
{
    LPSTR pszProvParamText = NULL;

    if (NULL == (pszProvParamText = (LPSTR) MyAlloc(PROV_PARAM_BUFFER_SIZE)))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    switch(dwParam)
    {
        case PP_ENUMALGS :
            strcpy(pszProvParamText, "PP_ENUMALGS") ;
        break ;
        case PP_ENUMCONTAINERS :
            strcpy(pszProvParamText, "PP_ENUMCONTAINERS") ;
        break ;
        case PP_IMPTYPE :
            strcpy(pszProvParamText, "PP_IMPTYPE") ;
        break ;
        case PP_NAME :
            strcpy(pszProvParamText, "PP_NAME") ;
        break ;
        case PP_VERSION :
            strcpy(pszProvParamText, "PP_VERSION") ;
        break ;
        case PP_CONTAINER :
            strcpy(pszProvParamText, "PP_CONTAINER") ;
        break ;
        case PP_CHANGE_PASSWORD :
            strcpy(pszProvParamText, "PP_CHANGE_PASSWORD") ;
        break ;
        case PP_KEYSET_SEC_DESCR :
            strcpy(pszProvParamText, "PP_KEYSET_SEC_DESCR") ;
        break ;
        case PP_CERTCHAIN :
            strcpy(pszProvParamText, "PP_CERTCHAIN") ;
        break ;
        case PP_KEY_TYPE_SUBTYPE :
            strcpy(pszProvParamText, "PP_KEY_TYPE_SUBTYPE") ;
        break ;
        case PP_PROVTYPE :
            strcpy(pszProvParamText, "PP_PROVTYPE") ;
        break ;
        case PP_KEYSTORAGE :
            strcpy(pszProvParamText, "PP_KEYSTORAGE") ;
        break ;
        case PP_APPLI_CERT :
            strcpy(pszProvParamText, "PP_APPLI_CERT") ;
        break ;
        case PP_SYM_KEYSIZE :
            strcpy(pszProvParamText, "PP_SYM_KEYSIZE") ;
        break ;
        case PP_SESSION_KEYSIZE :
            strcpy(pszProvParamText, "PP_SESSION_KEYSIZE") ;
        break ;
        case PP_UI_PROMPT :
            strcpy(pszProvParamText, "PP_UI_PROMPT") ;
        break ;
        case PP_ENUMALGS_EX :
            strcpy(pszProvParamText, "PP_ENUMALGS_EX") ;
        break ;
        case PP_ENUMMANDROOTS :
            strcpy(pszProvParamText, "PP_ENUMMANDROOTS") ;
        break ;
        case PP_ENUMELECTROOTS :
            strcpy(pszProvParamText, "PP_ENUMELECTROOTS") ;
        break ;
        case PP_KEYSET_TYPE :
            strcpy(pszProvParamText, "PP_KEYSET_TYPE") ;
        break ;
        case PP_ADMIN_PIN :
            strcpy(pszProvParamText, "PP_ADMIN_PIN") ;
        break ;
        case PP_KEYEXCHANGE_PIN :
            strcpy(pszProvParamText, "PP_KEYEXCHANGE_PIN") ;
        break ;
        case PP_SIGNATURE_PIN :
            strcpy(pszProvParamText, "PP_SIGNATURE_PIN") ;
        break ;
        case PP_SIG_KEYSIZE_INC :
            strcpy(pszProvParamText, "PP_SIG_KEYSIZE_INC") ;
        break ;
        case PP_KEYX_KEYSIZE_INC :
            strcpy(pszProvParamText, "PP_KEYX_KEYSIZE_INC") ;
        break ;
        case PP_UNIQUE_CONTAINER :
            strcpy(pszProvParamText, "PP_UNIQUE_CONTAINER") ;
        break ;
        case PP_SGC_INFO :
            strcpy(pszProvParamText, "PP_SGC_INFO") ;
        break ;
        case PP_USE_HARDWARE_RNG :
            strcpy(pszProvParamText, "PP_USE_HARDWARE_RNG") ;
        break ;
        case PP_KEYSPEC :
            strcpy(pszProvParamText, "PP_KEYSPEC") ;
        break ;
        case PP_ENUMEX_SIGNING_PROT :
            strcpy(pszProvParamText, "PP_ENUMEX_SIGNING_PROT") ;
        break ;
    }
    return pszProvParamText ;
}



//+ ==================================================================
//      
//      Function    :   L_GetProvParam
//      Purpose     :   Gets the requested Prov Param
//                      Does nothing with the ProvParam
//                      Has special logic for all enumeration params
//
//- ==================================================================
DWORD L_GetProvParam(HCRYPTPROV hProv, DWORD dwParam, DWORD dwThreadNum)
{
    PBYTE   pbProvData=NULL ;
    DWORD   cbProvData=0 ;
    DWORD   dwFlags=0 ;
    DWORD   dwEnumFlag=0 ;
    char    szErrorMsg[256] ;
    DWORD   dwRetVal=0 ;
    LPSTR pszProvParamText = NULL;
    DWORD   dwError = 0;

    if ((PP_ENUMALGS == dwParam) ||
        (PP_ENUMALGS_EX == dwParam) ||
        (PP_ENUMCONTAINERS == dwParam))
    {
        dwEnumFlag = 1 ;
        dwFlags = CRYPT_FIRST ;
    }


    //  dwFlags needs to be set in the case of PP_KEYSET_SECR_DECR
    if (PP_KEYSET_SEC_DESCR == dwParam)
    {
        dwFlags = SACL_SECURITY_INFORMATION ;
    }


    if (!CryptGetProvParam( hProv,
                            dwParam,
                            NULL,
                            &cbProvData,
                            dwFlags))
    {
        if ((ERROR_PRIVILEGE_NOT_HELD == (dwError = GetLastError())) &&
            (PP_KEYSET_SEC_DESCR == dwParam))
        {
            //  At this point the test has done it's job. The call is an expected failure call
            //  so we aren't going to try and make any more. 
            //  This call with fail with that expected LastError.
            dwRetVal=1 ;
            goto ErrorReturn ;
        }
        else
        {
            pszProvParamText = L_ProvParam2Text(dwParam);
            sprintf(szErrorMsg, "Thread %d: CryptGetProvParam 1 %s error 0x%x", 
                                dwThreadNum, pszProvParamText, dwError) ;
            MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
            MyFree(pszProvParamText);
            goto ErrorReturn ;
        }
    }

    if (NULL == (pbProvData = (PBYTE) MyAlloc(cbProvData)))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return 0;
    }
    
    //  If this is an enumeration, keep calling the function until 
    //  the enumeration reaches the end.
    do
    {
        if (!CryptGetProvParam( hProv,
                                dwParam,
                                pbProvData,
                                &cbProvData,
                                dwFlags))
        {
            //  Have we reached the end of the enumeration ? If yes, flag it.
            if (ERROR_NO_MORE_ITEMS == (dwError = GetLastError()))
            {
                dwEnumFlag=0 ;
            }
            else
            {
                pszProvParamText = L_ProvParam2Text(dwParam);
                sprintf(szErrorMsg, "Thread %d: CryptGetProvParam 2 %s error 0x%x", 
                                    dwThreadNum, pszProvParamText, dwError) ;
                MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
                MyFree(pszProvParamText);
                goto ErrorReturn ;
            }
        }
        dwFlags=0 ;
    } while (dwEnumFlag)  ;

    dwRetVal=1 ;
    ErrorReturn :
    MyFree(pbProvData) ;
    return dwRetVal ;
}


//+ =================================================================================
//- =================================================================================
/*
DWORD L_GetAllProvParams(HCRYPTPROV hProv, DWORD dwThreadNum)
{
    DWORD   dwRetVal=0 ;

    EnterCriticalSection(&g_CSEnumParam);

    if (!L_GetProvParam(hProv, PP_ENUMALGS, dwThreadNum))
    {
        LeaveCriticalSection(&g_CSEnumParam);
        goto ErrorReturn;
    }

    LeaveCriticalSection(&g_CSEnumParam);

    if (!L_CheckHeap(dwThreadNum, "after L_GetProvParam PP_ENUMALGS"))
            goto ErrorReturn ;

    EnterCriticalSection(&g_CSEnumParam);

    if (!L_GetProvParam(hProv, PP_ENUMALGS, dwThreadNum))
    {
        LeaveCriticalSection(&g_CSEnumParam);
        goto ErrorReturn ;
    }

    LeaveCriticalSection(&g_CSEnumParam);

    if (!L_CheckHeap(dwThreadNum, "after L_GetProvParam PP_ENUMALGS"))
        goto ErrorReturn ;

    EnterCriticalSection(&g_CSEnumParam);
    
    if (!L_GetProvParam(hProv, PP_ENUMCONTAINERS, dwThreadNum))
    {
        LeaveCriticalSection(&g_CSEnumParam);
        goto ErrorReturn ;
    }

    LeaveCriticalSection(&g_CSEnumParam);

    if (!L_GetProvParam(hProv, PP_NAME, dwThreadNum))
        goto ErrorReturn ;

    if (!L_CheckHeap(dwThreadNum, "after L_GetProvParam PP_NAME"))
            goto ErrorReturn ;

    if (!L_GetProvParam(hProv, PP_CONTAINER, dwThreadNum))
        goto ErrorReturn ;

    if (!L_CheckHeap(dwThreadNum, "after L_GetProvParam PP_CONTAINER"))
            goto ErrorReturn ;

    if (!L_GetProvParam(hProv, PP_IMPTYPE, dwThreadNum))
        goto ErrorReturn ;

    if (!L_CheckHeap(dwThreadNum, "after L_GetProvParam PP_IMPTYPE"))
            goto ErrorReturn ;

    if (!L_GetProvParam(hProv, PP_VERSION, dwThreadNum))
        goto ErrorReturn ;

    if (!L_CheckHeap(dwThreadNum, "after L_GetProvParam PP_VERSION"))
            goto ErrorReturn ;

    if (!L_GetProvParam(hProv, PP_KEYSET_SEC_DESCR, dwThreadNum))
        goto ErrorReturn ;
    
    if (!L_CheckHeap(dwThreadNum, "after L_GetProvParam PP_KEYSET_SEC_DESCR"))
            goto ErrorReturn ;

    if (!L_GetProvParam(hProv, PP_UNIQUE_CONTAINER, dwThreadNum))
        goto ErrorReturn ;

    if (!L_CheckHeap(dwThreadNum, "after L_GetProvParam PP_UNIQUE_CONTAINER"))
            goto ErrorReturn ;

    if (!L_GetProvParam(hProv, PP_PROVTYPE, dwThreadNum))
        goto ErrorReturn ;

    if (!L_CheckHeap(dwThreadNum, "after L_GetProvParam PP_PROVTYPE"))
            goto ErrorReturn ;

    if (!L_GetProvParam(hProv, PP_SIG_KEYSIZE_INC, dwThreadNum))
        goto ErrorReturn ;

    if (!L_CheckHeap(dwThreadNum, "after L_GetProvParam PP_SIG_KEYSIZE_INC"))
            goto ErrorReturn ;

    if (!L_GetProvParam(hProv, PP_KEYX_KEYSIZE_INC, dwThreadNum))
        goto ErrorReturn ;
        

    dwRetVal=1 ;
    ErrorReturn :
    return dwRetVal ;
}
*/


//+ ======================================================================
//- ======================================================================
DWORD L_ImportAndCheckSessionKeys(  HCRYPTPROV    hProv, 
                                    HCRYPTKEY     hKeyExch,
                                    PBYTE         pbRCx_KeyBlob,
                                    DWORD         cbRCx_KeyBlob,
                                    PBYTE         pbRCx_CipherText,
                                    DWORD         cbRCx_CipherText,
                                    PBYTE       pbPlainText,
                                    DWORD       cbPlainText,
                                    DWORD       dwThreadNum)
{
    DWORD  dwRetVal=0 ;
    HCRYPTKEY   hRCxKey=0 ;

    if (!CryptImportKey(hProv,
                        pbRCx_KeyBlob,
                        cbRCx_KeyBlob,
                        hKeyExch,
                        0,
                        &hRCxKey))
        L_LastErrorBox("Failed to import session Key", dwThreadNum) ;

    if (!CryptDecrypt(hRCxKey,
                        0,
                        TRUE,
                        0,
                        pbRCx_CipherText, 
                        &cbRCx_CipherText))
        L_LastErrorBox("Failed CryptDecrypt", dwThreadNum) ;

    if (memcmp(pbRCx_CipherText, pbPlainText, cbPlainText))
        L_ErrorBox("Ciphertext does not match plaintext after decrypting", dwThreadNum) ;

    //ErrorReturn :
    if (!CryptDestroyKey(hRCxKey))
        L_LastErrorBox("Failed CryptDestroyKey sessionKey", dwThreadNum) ;
        
    dwRetVal=1 ;
    return dwRetVal ;
}



//+ ======================================================================
//- ======================================================================
DWORD L_TestContextAddRef(HCRYPTPROV hProv, DWORD dwThreadNum)
{
    DWORD   dwRetVal=0 ;
    DWORD   i=0 ;
    DWORD   dwCount=50 ;

    for (i=0; i<dwCount ; i++)
    {
        if (!CryptContextAddRef(hProv, NULL, 0))
        {
            L_LastErrorBox("Failed CryptContextAddRef", dwThreadNum) ;
            goto ErrorReturn ;
        }
    }

    for (i=0; i<dwCount ; i++)
    {
        if (!CryptReleaseContext(hProv, 0))
        {
            L_LastErrorBox("Failed CryptReleaseContext (AddRef Test)", dwThreadNum) ;
            goto ErrorReturn ;
        }
    }

    dwRetVal=1 ;
    ErrorReturn :
    return dwRetVal ;
}




//+ ===========================================================================
//      L_ExportKey
//
//      Exports a session key, given the exchange key
//      Mem Allocated here needs to be freed by the calling funtion.
//- ===========================================================================
DWORD L_ExportKey(  HCRYPTKEY hRC_Key,
                            HCRYPTKEY hKeyExch,
                            DWORD dwType,
                            DWORD   dwMustBeZero,
                            PBYTE *ppbRC_KeyBlob,
                            DWORD *pcbRC_KeyBlob)
{
    DWORD   dwRetVal=0 ;
    char    szErrorMsg[256] ;

    if (!CryptExportKey(hRC_Key,
                        hKeyExch,
                        dwType,
                        0,
                        NULL,
                        pcbRC_KeyBlob))
        GENERIC_FAIL(CryptExportKey_RC) ;
        
    if (NULL == (*ppbRC_KeyBlob = (PBYTE) MyAlloc(*pcbRC_KeyBlob)))
        return 0;
    memset(*ppbRC_KeyBlob, 33, *pcbRC_KeyBlob) ;

    if (!CryptExportKey(hRC_Key,
                        hKeyExch,
                        SIMPLEBLOB,
                        0,
                        *ppbRC_KeyBlob,
                        pcbRC_KeyBlob))
        GENERIC_FAIL(CryptExportKey_RC) ;

    dwRetVal=1 ;
    ErrorReturn :
    return dwRetVal ;
}




//+ ==========================================================================
//  
//  
//- ==========================================================================
DWORD   L_GetHashParam(HCRYPTHASH hHash, DWORD dwParam)
{
    DWORD   dwRetVal=0 ;
    char    szErrorMsg[256] ;
    PBYTE   pbData=NULL ;
    DWORD   cbData=0 ;

    if (!CryptGetHashParam( hHash, 
                            dwParam,
                            NULL,
                            &cbData,
                            0))
        GENERIC_FAIL(CryptGetHashParam) ;

    if (NULL == (pbData = (PBYTE) MyAlloc(cbData)))
        return 0;

    if (!CryptGetHashParam( hHash, 
                            dwParam,
                            pbData,
                            &cbData,
                            0))
        GENERIC_FAIL(CryptGetHashParam) ;

    dwRetVal=1 ;
    ErrorReturn :
    MyFree(pbData) ;
    return dwRetVal ;
}




//+ ==========================================================================
//  
//  
//- ==========================================================================
DWORD   L_GetAllHashParams(HCRYPTHASH hHash, DWORD dwThreadNum)
{
    DWORD   dwRetVal=0 ;
    char szErrorMsg[256] ;

    if (!L_GetHashParam(hHash, HP_ALGID))
        goto ErrorReturn ;

    if (!L_GetHashParam(hHash, HP_HASHSIZE))
        goto ErrorReturn ;

    if (!L_GetHashParam(hHash, HP_HASHVAL))
        goto ErrorReturn ;

    dwRetVal=1 ;
    ErrorReturn :
    return dwRetVal ;
}

//
// Function: ThreadAcquireContextTest
//
DWORD ThreadAcquireContextTest(PTHREAD_DATA pThreadData, DWORD dwThreadNum)
{
    HCRYPTPROV hProv = 0;
    HCRYPTKEY hKey = 0;
    DWORD dwError = 0;
    CHAR rgsz[100];

    ZeroMemory(rgsz, sizeof(rgsz));
    sprintf(rgsz, "%s_%d", "ThreadContainer", dwThreadNum);

    if (! CryptAcquireContext(
            &hProv, rgsz, pThreadData->rgszProvName,
            pThreadData->dwProvType, 0))
    {
        dwError = GetLastError();
        printf("CryptAcquireContext: %s, %d, 0x%x\n", rgsz, dwThreadNum, dwError);

        if (NTE_BAD_KEYSET == dwError)
        {
            if (! CryptAcquireContext(
                    &hProv, rgsz, pThreadData->rgszProvName,
                    pThreadData->dwProvType, CRYPT_NEWKEYSET))
            {
                dwError = GetLastError();
                printf("CryptAcquireContext CRYPT_NEWKEYSET: %s, %d, 0x%x\n", rgsz, dwThreadNum, dwError);
                goto Ret;
            }
        }
        else
            goto Ret;
    }

    if (! CryptGetUserKey(hProv, AT_SIGNATURE, &hKey))
    {
        if (NTE_NO_KEY == (dwError = GetLastError()))
        {
            if (! CryptGenKey(hProv, AT_SIGNATURE, 0, &hKey))
            {
                dwError = GetLastError();
                goto Ret;
            }
        }
        else 
            goto Ret;
    }

    if (! CryptDestroyKey(hKey))
    {
        dwError = GetLastError();
        goto Ret;
    }

    if (! CryptReleaseContext(hProv, 0))
    {
        dwError = GetLastError();
        goto Ret;
    }

    dwError = 0;
Ret:
    return dwError;
}

//
// Function: ThreadHashingTest
//
DWORD ThreadHashingTest(PTHREAD_DATA pThreadData, PBYTE pbData, DWORD cbData)
{
    HCRYPTHASH hHash = 0;
    HCRYPTKEY hKey = 0;
    BYTE rgHash[100];
    DWORD cb = 0;
    DWORD dwError = 0;   
    PALGNODE pHashAlg;

    for (   pHashAlg = pThreadData->pAlgList;
            NULL != pHashAlg;
            pHashAlg = pHashAlg->pNext)
    {
        if (CALG_SHA1 != pHashAlg->EnumalgsEx.aiAlgid &&
            CALG_MD5 != pHashAlg->EnumalgsEx.aiAlgid)
            continue;

        if (! CryptCreateHash(pThreadData->hProv, pHashAlg->EnumalgsEx.aiAlgid, 0, 0, &hHash))
        {
            dwError = GetLastError();
            goto Ret;
        }

        if (! CryptHashData(hHash, pbData, cbData, 0))
        {
            dwError = GetLastError();
            goto Ret;
        }

        if (! CryptHashData(hHash, pbData, cbData, 0))
        {
            dwError = GetLastError();
            goto Ret;
        }

        cb = sizeof(rgHash);
        if (! CryptGetHashParam(hHash, HP_HASHVAL, rgHash, &cb, 0))
        {
            dwError = GetLastError();
            goto Ret;
        }

        if (! CryptDestroyHash(hHash))
        {
            dwError = GetLastError();
            goto Ret;
        }
        hHash = 0;
    }

    //dwError = HmacRegression(pThreadData);

Ret:
    return dwError;
}

//
// Function: ThreadSignatureTest
//
DWORD ThreadSignatureTest(PTHREAD_DATA pThreadData)
{
    HCRYPTHASH hHash = 0;
    PBYTE pbData = NULL;
    DWORD cbData = 0;
    PBYTE pbSignature = NULL;
    DWORD cbSignature = 0;
    DWORD dwError = 0;
    PALGNODE pHashAlg = NULL;
    
    //
    // CALG_SHA1 Test
    //

    if (! CryptCreateHash(
        pThreadData->hProv, CALG_SHA1, 0, 0, &hHash))
    {
        dwError = GetLastError();
        goto Ret;
    }
    
    cbData = SIGN_DATA_SIZE;
    if (NULL == (pbData = (PBYTE) MyAlloc(cbData)))
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }
    
    if (! CryptGenRandom(
        pThreadData->hProv, cbData, pbData))
    {
        dwError = GetLastError();
        goto Ret;
    }
    
    if (! CryptHashData(
        hHash, pbData, cbData, 0))
    {
        dwError = GetLastError();
        goto Ret;
    }
    
    if (! CryptSignHash(
        hHash, AT_SIGNATURE, NULL, 0, NULL, &cbSignature))
    {
        dwError = GetLastError();
        goto Ret;
    }
    
    if (NULL == (pbSignature = (PBYTE) MyAlloc(cbSignature)))
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }
    
    if (! CryptSignHash(
        hHash, AT_SIGNATURE, NULL, 0, pbSignature, &cbSignature))
    {
        dwError = GetLastError();
        goto Ret;
    }
    
    if (! CryptVerifySignature(
        hHash, pbSignature, cbSignature, 
        pThreadData->hSignatureKey, NULL, 0))
    {
        dwError = GetLastError();
        goto Ret;
    }
    
    if (! CryptDestroyHash(hHash))
    {
        dwError = GetLastError();
        goto Ret;
    }
    
    MyFree(pbData);
    pbData = NULL;
    MyFree(pbSignature);
    pbSignature = NULL;

    //
    // CALG_MD2 Test
    //

    if (! CryptCreateHash(
        pThreadData->hProv, CALG_MD2, 0, 0, &hHash))
    {
        dwError = GetLastError();
        goto Ret;
    }
    
    cbData = SIGN_DATA_SIZE;
    if (NULL == (pbData = (PBYTE) MyAlloc(cbData)))
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }
    
    if (! CryptGenRandom(
        pThreadData->hProv, cbData, pbData))
    {
        dwError = GetLastError();
        goto Ret;
    }
    
    if (! CryptHashData(
        hHash, pbData, cbData, 0))
    {
        dwError = GetLastError();
        goto Ret;
    }
    
    if (! CryptSignHash(
        hHash, AT_SIGNATURE, NULL, 0, NULL, &cbSignature))
    {
        dwError = GetLastError();
        goto Ret;
    }
    
    if (NULL == (pbSignature = (PBYTE) MyAlloc(cbSignature)))
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }
    
    if (! CryptSignHash(
        hHash, AT_SIGNATURE, NULL, 0, pbSignature, &cbSignature))
    {
        dwError = GetLastError();
        goto Ret;
    }
    
    if (! CryptVerifySignature(
        hHash, pbSignature, cbSignature, 
        pThreadData->hSignatureKey, NULL, 0))
    {
        dwError = GetLastError();
        goto Ret;
    }
    
    if (! CryptDestroyHash(hHash))
    {
        dwError = GetLastError();
        goto Ret;
    }
    
    MyFree(pbData);
    pbData = NULL;
    MyFree(pbSignature);
    pbSignature = NULL;

    //
    // CALG_MD4 Test
    //

    if (! CryptCreateHash(
        pThreadData->hProv, CALG_MD4, 0, 0, &hHash))
    {
        dwError = GetLastError();
        goto Ret;
    }
    
    cbData = SIGN_DATA_SIZE;
    if (NULL == (pbData = (PBYTE) MyAlloc(cbData)))
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }
    
    if (! CryptGenRandom(
        pThreadData->hProv, cbData, pbData))
    {
        dwError = GetLastError();
        goto Ret;
    }
    
    if (! CryptHashData(
        hHash, pbData, cbData, 0))
    {
        dwError = GetLastError();
        goto Ret;
    }
    
    if (! CryptSignHash(
        hHash, AT_SIGNATURE, NULL, 0, NULL, &cbSignature))
    {
        dwError = GetLastError();
        goto Ret;
    }
    
    if (NULL == (pbSignature = (PBYTE) MyAlloc(cbSignature)))
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }
    
    if (! CryptSignHash(
        hHash, AT_SIGNATURE, NULL, 0, pbSignature, &cbSignature))
    {
        dwError = GetLastError();
        goto Ret;
    }
    
    if (! CryptVerifySignature(
        hHash, pbSignature, cbSignature, 
        pThreadData->hSignatureKey, NULL, 0))
    {
        dwError = GetLastError();
        goto Ret;
    }
    
    if (! CryptDestroyHash(hHash))
    {
        dwError = GetLastError();
        goto Ret;
    }
    
    MyFree(pbData);
    pbData = NULL;
    MyFree(pbSignature);
    pbSignature = NULL;

Ret:

    if (pbData)
        MyFree(pbData);
    if (pbSignature)
        MyFree(pbSignature);
    
    return dwError;
}

// ======================================================================================
//  MULTITHREADED routine
// ======================================================================================
void WINAPI ThreadRoutine(LPVOID pvThreadData)
{
    DWORD       dwThreadNum = 0;
    DWORD       dwError = 0;
    BOOL        fMacErrorOccurred = FALSE;
    PTHREAD_DATA pThreadData = (PTHREAD_DATA) pvThreadData;
    CHAR        szErrorMsg[256];
    BYTE        rgbData[HASH_DATA_SIZE];
    
    // Get identifier for this thread
    EnterCriticalSection(&pThreadData->CSThreadData);
    dwThreadNum = pThreadData->dwThreadID;
    pThreadData->dwThreadID++;
    LeaveCriticalSection(&pThreadData->CSThreadData);

    if (! CryptGenRandom(pThreadData->hProv, sizeof(rgbData), rgbData))
    {
        dwError = GetLastError();
        goto ErrorReturn;
    }
    
    do 
    {
        if (RUN_THREAD_SIGNATURE_TEST & pThreadData->dwTestsToRun)
        {
            if (ERROR_SUCCESS != (dwError = ThreadSignatureTest(pThreadData)))
            {
                sprintf(
                    szErrorMsg, 
                    "Thread %d: ThreadSignatureTest error 0x%x", 
                    dwThreadNum, 
                    dwError);
                MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR);
                goto ErrorReturn;
            }
        }

        if (RUN_STRESS_TEST_ALL_ENCRYPTION_ALGS & pThreadData->dwTestsToRun)
        {
            //
            // Call new shared encryption stress tests
            //
            if (ERROR_SUCCESS != (dwError = 
                StressTestAllEncryptionAlgs(pThreadData, TRUE, &fMacErrorOccurred)))
            {
                sprintf(
                    szErrorMsg, 
                    "Thread %d: StressTestAllEncryptionAlgs error 0x%x", 
                    dwThreadNum, 
                    dwError);
                MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR);
                goto ErrorReturn;
            }
        }

        if (RUN_THREAD_HASHING_TEST & pThreadData->dwTestsToRun)
        {      
            if (ERROR_SUCCESS != (dwError = ThreadHashingTest(pThreadData, rgbData, sizeof(rgbData))))
            {
                sprintf(
                    szErrorMsg, 
                    "Thread %d: ThreadHashingTest error 0x%x", 
                    dwThreadNum, 
                    dwError);
                MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR);
                goto ErrorReturn;
            }         
        }

        if (RUN_THREAD_ACQUIRE_CONTEXT_TEST & pThreadData->dwTestsToRun)
        {
            if (ERROR_SUCCESS != (dwError = ThreadAcquireContextTest(pThreadData, dwThreadNum)))
            {
                sprintf(
                    szErrorMsg, 
                    "Thread %d: ThreadAcquireContextTest error 0x%x", 
                    dwThreadNum, 
                    dwError);
                MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR);
                goto ErrorReturn;
            }         
        }

        pThreadData->rgdwThreadStatus[dwThreadNum]++;
    }   
    while (WAIT_TIMEOUT == WaitForSingleObject(pThreadData->hEndTestEvent, 0));
    
ErrorReturn:

    if (fMacErrorOccurred)
    {
        printf("ERROR: Mac bug 189368 is not fixed!\n");
    }

    return;
}

//
// Function: GetNextRegisteredCSP
//
DWORD GetNextRegisteredCSP(
    LPSTR pszCsp,
    PDWORD pcbCsp,
    PDWORD pdwProvType,
    DWORD dwRequestedIndex)
{
    static DWORD dwNextEnumIndex    = 0;
    DWORD dwActualIndex             = 0;
    DWORD dwError                   = 0;

    dwActualIndex =
        (ENUMERATE_REGISTERED_CSP == dwRequestedIndex) ? 
        dwNextEnumIndex : 
        dwRequestedIndex;

    if (! CryptEnumProviders(
        dwActualIndex,
        NULL,
        0,
        pdwProvType,
        pszCsp,
        pcbCsp))
    {
        dwError = GetLastError();

        switch (dwError)
        {
        case ERROR_NO_MORE_ITEMS:
            dwNextEnumIndex = 0;
            break;
        }
    }
    else
    {
        if (ENUMERATE_REGISTERED_CSP == dwRequestedIndex)
        {
            dwNextEnumIndex++;
        }
    }

    return dwError;
}

//
// Function: InitializeAlgList
// Purpose: Create a list of algorithms supported by this CSP
//
DWORD InitializeAlgList(PTHREAD_DATA pThreadData)
{
    PALGNODE pAlgNode = NULL, pPrevNode = NULL;
    DWORD dwError = 0;
    DWORD cbData = sizeof(ALGNODE);
    DWORD dwFlags = CRYPT_FIRST;

    if (NULL == (pThreadData->pAlgList = (PALGNODE) MyAlloc(sizeof(ALGNODE))))
        return ERROR_NOT_ENOUGH_MEMORY;

    pAlgNode = pThreadData->pAlgList;

    while (CryptGetProvParam(
        pThreadData->hProv, 
        PP_ENUMALGS_EX, 
        (PBYTE) &pAlgNode->EnumalgsEx,
        &cbData,
        dwFlags))
    {
        dwFlags = 0;

        if (NULL == (pAlgNode->pNext = (PALGNODE) MyAlloc(sizeof(ALGNODE))))
            return ERROR_NOT_ENOUGH_MEMORY;

        pPrevNode = pAlgNode;
        pAlgNode = pAlgNode->pNext;
    }

    if (ERROR_NO_MORE_ITEMS != (dwError = GetLastError()))
        return dwError;
    
    MyFree(pAlgNode);
    pPrevNode->pNext = NULL;
    
    return ERROR_SUCCESS;
}

//
// Function: RunRegressionTests
//
BOOL RunRegressionTests(PTHREAD_DATA pThreadData)
{
    DWORD dwError = ERROR_SUCCESS;
    unsigned u;
    BOOL fAllPassed = TRUE;

    for (u = 0; u < g_cRegressTests; u++)
    {
        if (pThreadData->dwProvType & g_rgRegressTests[u].dwExclude)
        {
            printf(
                "Skipping %s\n\n", g_rgRegressTests[u].pszDescription);
            continue;
        }

        if (ERROR_SUCCESS != 
            (dwError = (g_rgRegressTests[u].pfTest)(pThreadData)))
        {
            printf(
                "FAIL: %s, 0x%x\n\n", 
                g_rgRegressTests[u].pszDescription,
                dwError);
            fAllPassed = FALSE;
        }
        else
            printf("PASS: %s\n\n", g_rgRegressTests[u].pszDescription);
    }

    return fAllPassed;
}

//
// Function: CallCryptAcquireContext
//
BOOL CallCryptAcquireContext(
    IN PTHREAD_DATA pThreadData,
    IN LPSTR pszOptions,
    IN LPSTR pszContainer)
{
    HCRYPTPROV hProv = 0;
    HCRYPTKEY hKey = 0;
    HCRYPTKEY hSigKey = 0;
    HCRYPTKEY hExchKey = 0;
    DWORD dwFlags = 0;
    unsigned uLen = strlen(pszOptions);
    ALG_ID ai = 0;
    DWORD dwKeyFlags = 0;
    BOOL fSuccess = TRUE;
    BYTE rgbKeyBlob[5000];
    DWORD cbKeyBlob = sizeof(rgbKeyBlob);
    DWORD dwErr = 0;
    CHAR rgszCtxFlags[MAX_PATH];
    CHAR rgszKeyFlags[MAX_PATH];

    memset(rgszCtxFlags, 0, sizeof(rgszCtxFlags));
    memset(rgszKeyFlags, 0, sizeof(rgszKeyFlags));

    printf(" pszContainer = %s\n", pszContainer);
    sprintf(rgszCtxFlags, " AcquireContext dwFlags =");
    sprintf(rgszKeyFlags, " GenKey dwFlags =");
    
    while (uLen)
    {
        switch (pszOptions[uLen - 1])
        {
        case 'l':
            dwFlags |= CRYPT_MACHINE_KEYSET;
            strcat(rgszCtxFlags, " CRYPT_MACHINE_KEYSET");
            break;
        case 'v':
            dwFlags |= CRYPT_VERIFYCONTEXT;
            strcat(rgszCtxFlags, " CRYPT_VERIFYCONTEXT");
            break;
        case 'n':
            dwFlags |= CRYPT_NEWKEYSET;
            strcat(rgszCtxFlags, " CRYPT_NEWKEYSET");
            break;
        case 'd':
            dwFlags |= CRYPT_DELETEKEYSET;
            strcat(rgszCtxFlags, " CRYPT_DELETEKEYSET");
            break;
        case 'q':
            dwFlags |= CRYPT_SILENT;
            strcat(rgszCtxFlags, " CRYPT_SILENT");
            break;
        case 'x':
            ai = AT_KEYEXCHANGE;
            break;
        case 's':
            ai = AT_SIGNATURE;
            break;
        case 'u':
            dwKeyFlags |= CRYPT_USER_PROTECTED;
            strcat(rgszKeyFlags, " CRYPT_USER_PROTECTED");
            break;
        case 'e':
            dwKeyFlags |= CRYPT_EXPORTABLE;
            strcat(rgszKeyFlags, " CRYPT_EXPORTABLE");
            break;
        default:
            printf(" Invalid!\n");
            return FALSE;
        }
        uLen--;
    }

    printf("%s\n", rgszCtxFlags);

    if (CryptAcquireContext(
            &hProv, pszContainer, pThreadData->rgszProvName,
            pThreadData->dwProvType, dwFlags))
    {
        printf("Success\n");

        // See if any keys are already in this container.
        // If they exist, cause the private key to be accessed.
        if (CryptGetUserKey(hProv, AT_SIGNATURE, &hSigKey))
        {
            printf(" Found AT_SIGNATURE key in this container\n");
            cbKeyBlob = sizeof(rgbKeyBlob);
            if (! CryptExportKey(
                hSigKey, 0, PRIVATEKEYBLOB, 0, rgbKeyBlob, &cbKeyBlob))
            {
                printf(" Signature key export failed - 0x%x\n", GetLastError());
                fSuccess = FALSE;
            }
            else
                printf(" Successfully exported existing AT_SIGNATURE key\n");

            if (! CryptDestroyKey(hSigKey))
            {
                printf("ERROR: CryptDestroyKey failed - 0x%x\n", GetLastError());
                fSuccess = FALSE;
            }
            hSigKey = 0;
        }
        else 
        {
            if (NTE_NO_KEY == (dwErr = GetLastError()))
                printf(" No AT_SIGNATURE key found in this container\n");
            else                 
            {
                printf("ERROR: CryptGetUserKey AT_SIGNATURE failed - 0x%x\n", dwErr);
                fSuccess = FALSE;
            }
        }

        if (CryptGetUserKey(hProv, AT_KEYEXCHANGE, &hExchKey))
        {
            printf(" Found AT_KEYEXCHANGE key in this container\n");
            cbKeyBlob = sizeof(rgbKeyBlob);
            if (! CryptExportKey(
                hExchKey, 0, PRIVATEKEYBLOB, 0, rgbKeyBlob, &cbKeyBlob))
            {
                printf(" Key Exchange key export failed - 0x%x\n", GetLastError());
                fSuccess = FALSE;
            }
            else
                printf(" Successfully exported existing AT_KEYEXCHANGE key\n");

            if (! CryptDestroyKey(hExchKey))
            {
                printf("ERROR: CryptDestroyKey failed - 0x%x\n", GetLastError());
                fSuccess = FALSE;
            }
            hExchKey = 0;
        }
        else 
        {
            if (NTE_NO_KEY == (dwErr = GetLastError()))
                printf(" No AT_KEYEXCHANGE key found in this container\n");
            else
            {
                printf("ERROR: CryptGetUserKey AT_KEYEXCHANGE failed - 0x%x\n", dwErr);
                fSuccess = FALSE;
            }
        }


        if (0 != ai)
        {
            printf("\nCalling CryptGenKey ...\n");
            if (AT_KEYEXCHANGE == ai)
                printf(" Algid = AT_KEYEXCHANGE\n");
            else
                printf(" Algid = AT_SIGNATURE\n");

            printf("%s\n", rgszKeyFlags);

            if (CryptGenKey(
                    hProv, ai, dwKeyFlags, &hKey))
            {
                printf("Success\n");

                if (PROV_DSS == pThreadData->dwProvType ||
                    PROV_DSS_DH == pThreadData->dwProvType)
                {
                    if (! CryptSetKeyParam(hKey, KP_X, NULL, 0))
                    {
                        printf("ERROR: CryptSetKeyParam KP_X failed - 0x%x\n", GetLastError());
                        fSuccess = FALSE;
                    }
                }

                if (dwKeyFlags & CRYPT_EXPORTABLE)
                {
                    cbKeyBlob = sizeof(rgbKeyBlob);
                    if (! CryptExportKey(
                        hKey, 0, PRIVATEKEYBLOB, 0, rgbKeyBlob, &cbKeyBlob))
                    {
                        printf("ERROR: CryptExportKey PRIVATEKEYBLOB failed - 0x%x\n", GetLastError());
                        fSuccess = FALSE;
                    }
                    else
                        printf(" Successfully exported new key\n");
                }
            }
            else
            {
                printf("ERROR: CryptGenKey failed - 0x%x\n", GetLastError());
                fSuccess = FALSE;
            }
        }
    }
    else
    {
        printf("ERROR: CryptAcquireContext failed - 0x%x\n", GetLastError());
        fSuccess = FALSE;
    }

    if (hKey)
    {
        if (! CryptDestroyKey(hKey))
        {
            printf("ERROR: CryptDestroyKey failed - 0x%x\n", GetLastError());
            fSuccess = FALSE;
        }
    }
    if (hProv)
    {
        if ((! dwFlags & CRYPT_DELETEKEYSET) && 
            FALSE == CryptReleaseContext(hProv, 0))
        {
            printf("ERROR: CryptReleaseContext failed - 0x%x\n", GetLastError());
            fSuccess = FALSE;
        }
    }

    return fSuccess;
}

//
// Function: DeleteAllContainers
//
BOOL DeleteAllContainers(THREAD_DATA *pThreadData)
{
    HCRYPTPROV hDefProv                 = 0;
    HCRYPTPROV hProv                    = 0;
    CHAR rgszContainer[MAX_PATH];
    CHAR rgszDefCont[MAX_PATH];
    DWORD cbContainer                   = MAX_PATH;
    DWORD dwFlags                       = CRYPT_FIRST;

    if (! CryptAcquireContext(
            &hDefProv, NULL, pThreadData->rgszProvName, 
            pThreadData->dwProvType, 0))
    {
        printf("CryptAcquireContext default keyset failed - 0x%x\n", GetLastError());
        return FALSE;
    }

    if (! CryptGetProvParam(
            hDefProv, PP_CONTAINER, (PBYTE) rgszDefCont,
            &cbContainer, 0))
    {
        printf("CryptGetProvParam PP_CONTAINER failed - 0x%x\n", GetLastError());
        return FALSE;
    }

    cbContainer = MAX_PATH;
    while (CryptGetProvParam(
        hDefProv, PP_ENUMCONTAINERS, (PBYTE) rgszContainer,
        &cbContainer, dwFlags))
    {
        if (dwFlags)
            dwFlags = 0;

        // If the enumerated container is the same as the default
        // container, skip it for now
        if (0 == strcmp(rgszContainer, rgszDefCont))
            continue;

        printf("\"%s\" - ", rgszContainer);
        
        if (! CryptAcquireContext(
                &hProv, rgszContainer, pThreadData->rgszProvName,
                pThreadData->dwProvType, CRYPT_DELETEKEYSET))
            printf("CryptAcquireContext CRYPT_DELETEKEYSET failed - 0x%x\n", GetLastError());
        else
            printf("Deleted\n");

        cbContainer = MAX_PATH;
    }  

    if (! CryptReleaseContext(hDefProv, 0))
    {
        printf("CryptReleaseContext failed - 0x%x\n", GetLastError());
        return FALSE;
    }

    // Now try to delete default keyset
    printf("\"%s\" - ", rgszDefCont);
    if (! CryptAcquireContext(
            &hProv, rgszDefCont, pThreadData->rgszProvName,
            pThreadData->dwProvType, CRYPT_DELETEKEYSET))
        printf("CryptAcquireContext CRYPT_DELETEKEYSET failed - 0x%x\n", GetLastError());
    else
        printf("Deleted\n");

    return TRUE;  
}

//*****************************************************
//
int _cdecl main(int argc, char * argv[])
{
    HANDLE              rghThread[MAX_THREADS];
    DWORD               rgdwThreadID[MAX_THREADS];
    DWORD               threadID=0;
    DWORD               thread_number=0;
    DWORD               dwErr=0;
    DWORD               dwArg = 0;
    DWORD               cbCspName = 0;
    DWORD               dwFreeHandle=0;
    DWORD               i = 0 ;
    DWORD               tick_StartTime=0;
    char                szErrorMsg[256] ;
    THREAD_DATA         ThreadData;
    BOOL                fInvalidArgs = FALSE;
    PALGNODE            pAlgNode = NULL;
    BOOL                fRunRegressions = FALSE;
    BOOL                fAcquireContext = FALSE;
    LPSTR               pszOptions = NULL;
    LPSTR               pszContainer = NULL;
    BOOL                fDeleteContainers = FALSE;

    // Set high-order bit on dwSpinCount param so that the event used
    // by EnterCriticalSection() will be pre-allocated by 
    // InitializeCriticalSectionAndSpinCount()
    DWORD               dwSpinCount = 0x8000;
    
    ZeroMemory(&ThreadData, sizeof(ThreadData));

    __try
    {
        InitializeCriticalSectionAndSpinCount(&ThreadData.CSThreadData, dwSpinCount);
    }
    __except (STATUS_NO_MEMORY == GetExceptionCode() ?
                EXCEPTION_EXECUTE_HANDLER :
                EXCEPTION_CONTINUE_SEARCH )
    {
        printf("InitializeCriticalSectionAndSpinCount failed: STATUS_NO_MEMORY exception\n");
        exit(1);    
    }

    // Setting all the defaults
    ThreadData.dwThreadCount = StressGetDefaultThreadCount();
    ThreadData.dwTestsToRun = RUN_ALL_TESTS;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'n':
                argv++; 
                argc--;
                if (0 == argc || 0 == (dwArg = atoi(argv[0])))
                {
                    fInvalidArgs = TRUE;
                    goto Ret;
                }
                ThreadData.dwThreadCount = dwArg;
                break;

            case 't':
                argv++; 
                argc--;
                if (0 == argc || 0 == (dwArg = atoi(argv[0])))
                {
                    fInvalidArgs = TRUE;
                    goto Ret;
                }
                ThreadData.dwProgramMins = dwArg;
                break;

            case 'c':
                argv++;
                argc--;
                if (0 == argc)
                {
                    fInvalidArgs = TRUE;
                    goto Ret;
                }

                cbCspName = MAX_PATH;
                dwErr = GetNextRegisteredCSP(
                    ThreadData.rgszProvName,
                    &cbCspName,
                    &ThreadData.dwProvType,
                    atoi(*argv));
                if (ERROR_SUCCESS != dwErr)
                {
                    fInvalidArgs = TRUE;
                    goto Ret;
                }
                break;
                
            case 'e':
                ThreadData.fEphemeralKeys = TRUE;
                break;

            case 'u':
                ThreadData.fUserProtectedKeys = TRUE;
                break;

            case 'r':
                fRunRegressions = TRUE;
                break;

            case 's':
                ThreadData.fSkipPinAttackTest = TRUE;
                break;

            case '?':
                fInvalidArgs = TRUE;
                goto Ret;

            case 'a':
                fAcquireContext = TRUE;
                pszOptions = argv[0] + 2;
                
                if (NULL == strchr(pszOptions, 'v'))
                {
                    argv++;
                    argc--;
                    pszContainer = *argv;
                }
                break;

            case 'd':
                fDeleteContainers = TRUE;
                break;

            case 'T':
                argv++; 
                argc--;
                if (0 == argc || 0 == (dwArg = atoi(argv[0])))
                {
                    fInvalidArgs = TRUE;
                    goto Ret;
                }
                ThreadData.dwTestsToRun = dwArg;
                break; 

            default:
                fInvalidArgs = TRUE;
                goto Ret;
            }
        }
    }

    //
    // Check arg validity
    //
    if (    0 != argc || 
            0 == ThreadData.dwProvType ||
            (ThreadData.fEphemeralKeys && ThreadData.fUserProtectedKeys) ||
            (fRunRegressions && fAcquireContext))
    {
        fInvalidArgs = TRUE;
        goto Ret;
    }

    printf("Provider: %s, Type: %d\n\n", ThreadData.rgszProvName, ThreadData.dwProvType);

    if (fDeleteContainers)
    {
        printf("Deleting all key containers ...\n");
        if (! DeleteAllContainers(&ThreadData))
            exit(1);
        goto Ret;
    }
    if (fAcquireContext)
    {
        printf("Calling CryptAcquireContext ...\n");
        if (! CallCryptAcquireContext(
                &ThreadData, pszOptions, pszContainer))
            exit(1);
        goto Ret;
    }

    if (!ProgramInit(&ThreadData))
    {
        printf("ProgramInit() failed\n");
        exit(1) ;
    }

    //
    // Initialize list of supported algorithms
    //
    if (ERROR_SUCCESS != (dwErr = InitializeAlgList(&ThreadData)))
    {
        printf("InitializeAlgList failed, 0x%x\n", dwErr);
        exit(1);
    }

    if (fRunRegressions)
    {
        printf("Running regression tests ...\n");
        if (! RunRegressionTests(&ThreadData))
            exit(1);
        goto Ret;
    }

    //
    // Summarize user options
    //
    printf("Number of threads: %d\n", ThreadData.dwThreadCount);
    if (ThreadData.dwProgramMins)
        printf(" - Timeout in %d minute(s)\n", ThreadData.dwProgramMins);
    if (ThreadData.fEphemeralKeys)
        printf(" - Using ephemeral keys\n");
    if (ThreadData.fUserProtectedKeys)
        printf(" - Using user-protected keys\n");

    // Create event that can be used by the timer thread to stop
    // the worker threads.
    if ((ThreadData.hEndTestEvent = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL)
    {
        printf("CreateEvent() failed, 0x%x\n", GetLastError());
        exit(1);
    }        

    // Create the threads
    tick_StartTime = GetTickCount() ;
    for (thread_number = 0; thread_number < ThreadData.dwThreadCount; thread_number++)
    {
        if ((rghThread[thread_number] = 
            CreateThread(
                NULL, 
                0, 
                (LPTHREAD_START_ROUTINE) ThreadRoutine, 
                &ThreadData, 
                0, 
                &threadID)) != NULL)
        {
            rgdwThreadID[thread_number] = threadID ;
        }
        else
        {
            sprintf(szErrorMsg, "\n\nERROR creating thread number 0x%x. Error 0x%x", 
                    thread_number, GetLastError()) ;
            MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
            exit(0) ;
        }
    }

    //  Spawn PrintThreadStatus
    rghThread[thread_number++] = CreateThread(
                        NULL, 0, 
                        (LPTHREAD_START_ROUTINE)PrintThreadStatus, 
                        &ThreadData, 
                        0, &threadID);
                    
    //  Spawn KillProgramTimer (This will shut down all the threads and kill the program)
    rghThread[thread_number++] = CreateThread(
                        NULL, 0, 
                        (LPTHREAD_START_ROUTINE)KillProgramTimer, 
                        &ThreadData, 
                        0, &threadID);

    // Done Creating all threads

    // End multithreading
    dwErr = WaitForMultipleObjects(thread_number, rghThread, TRUE, INFINITE) ;  
    if (dwErr == WAIT_FAILED)
        printf("WaitForMultipleObjects() failed, 0x%x\n", GetLastError());

    if (! CryptDestroyKey(ThreadData.hSignatureKey))
    {
        sprintf(szErrorMsg, "FAILED CryptDestroyKey SIG error 0x%x\n", GetLastError()) ;
        MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
    }
    if (ThreadData.hExchangeKey && (! CryptDestroyKey(ThreadData.hExchangeKey)))
    {
        sprintf(szErrorMsg, "FAILED CryptDestroyKey KEYX error 0x%x\n", GetLastError()) ;
        MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
    }
    if (! CryptReleaseContext(ThreadData.hVerifyCtx, 0))
    {
        sprintf(szErrorMsg, "FAILED CryptReleaseContext 1 error 0x%x\n", GetLastError());
        MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR);
    }
    if (! CryptReleaseContext(ThreadData.hProv, 0))
    {
        sprintf(szErrorMsg, "FAILED CryptReleaseContext 2 error 0x%x\n", GetLastError()) ;
        MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
    }
        
    DeleteCriticalSection(&ThreadData.CSThreadData);
    CloseHandle(ThreadData.hEndTestEvent);

    while (thread_number--)
        CloseHandle(rghThread[thread_number]);

Ret:
    while (ThreadData.pAlgList)
    {
        pAlgNode = ThreadData.pAlgList->pNext;
        MyFree(ThreadData.pAlgList);
        ThreadData.pAlgList = pAlgNode;
    }

    if (fInvalidArgs)
    {
        Usage();
        
        printf("\nRegistered CSP's:\n");
        
        cbCspName = MAX_PATH;
        for (   i = 0;
                ERROR_SUCCESS == GetNextRegisteredCSP(
                    ThreadData.rgszProvName,
                    &cbCspName,
                    &ThreadData.dwProvType,
                    ENUMERATE_REGISTERED_CSP);
                i++, cbCspName = MAX_PATH)
        {
            printf(" %d: %s, Type %d\n", i, ThreadData.rgszProvName, ThreadData.dwProvType);
        }
        
        exit(1);
    }

    return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\xpress\xprs.h ===
#ifndef _XPRS_H_
#define _XPRS_H_


/* ------------------------------------------------------------------------ */
/*                                                                          */
/*  Copyright (c) Microsoft Corporation, 2000-2002. All rights reserved.    */
/*  Copyright (c) Andrew Kadatch, 1991-2002. All rights reserved.           */
/*                                                                          */
/*  Microsoft Confidential -- do not redistribute.                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "xpress.h"

#ifdef _MSC_VER
#pragma code_seg ("PAGELK")
#if !DEBUG
#ifdef _M_IX86
#pragma optimize ("tgaw", on)
#else
#pragma optimize ("tgw", on)
#endif /* _M_IX86 */
#endif /* DEBUG */
#endif



/* ------------------------ Configuration ----------------------------- */
/*                          -------------                               */

#ifndef CODING_ALG
#define CODING_ALG      1
#endif

#define CODING_DIRECT2  (1 << 1)
#define CODING_DIRECT   (1 << 2)
#define CODING_BY_BIT   (1 << 3)
#define CODING_HUFF_LEN (1 << 4)
#define CODING_HUFF_PTR (1 << 5)
#define CODING_HUFF_ALL (1 << 6)

#define CODING          (1 << CODING_ALG)

#define SUPPORT_CRC     0

#define BUFF_SIZE_LOG    XPRESS_MAX_BLOCK_LOG
#define BUFF_SIZE        (1<<BUFF_SIZE_LOG)

#if 1
#define MAX_OFFSET      (BUFF_SIZE_LOG > 16 ? 16 : BUFF_SIZE_LOG)
#else
#define MAX_OFFSET      13
#endif

#if CODING == CODING_DIRECT2 && MAX_OFFSET > 13
#undef MAX_OFFSET
#define MAX_OFFSET 13
#define DIRECT2_LEN_LOG (16 - MAX_OFFSET)
#define DIRECT2_MAX_LEN ((1 << DIRECT2_LEN_LOG) - 1)
#endif

#if BUFF_SIZE < XPRESS_MAX_BLOCK
#error BUFF_SIZE should not be less than XPRESS_MAX_BLOCK
#endif

#if CODING == CODING_HUFF_LEN
#define MAX_LENGTH      32
#define HUFF_SIZE       (MAX_LENGTH * 2)
#elif CODING & (CODING_HUFF_PTR | CODING_HUFF_ALL)
#if (256 / MAX_OFFSET) >= 32
#define MAX_LENGTH_LOG  5
#else
#define MAX_LENGTH_LOG  4
#endif
#define MAX_LENGTH      (1 << MAX_LENGTH_LOG)
#if CODING == CODING_HUFF_PTR
#define HUFF_SIZE       ((MAX_LENGTH * MAX_OFFSET + 1) & ~1)
#elif CODING == CODING_HUFF_ALL
#define HUFF_SIZE       (256 + ((MAX_LENGTH * MAX_OFFSET + 1) & ~1))
#endif
#endif

#define MIN_MATCH       3       /* min acceptable match length  */

#if CODING == CODING_HUFF_LEN
#define DECODE_BITS     8
#elif CODING & (CODING_HUFF_PTR | CODING_HUFF_ALL)
#define DECODE_BITS     10
#endif


/* ---------------------- Useful types ------------------------ */
/*                        ------------                          */

#if defined (_M_IX86) && !defined (i386)
#define i386 1                  /* ifdef i386 asm code will be used for some encodings */
#endif

#if defined (i386) && defined (NOASM)
#undef i386
#endif

#define uchar unsigned char     /* useful types */
#define schar signed char

#ifdef _M_IX86
#define __unaligned             /* x86 does not have __unaligned keyword    */
#endif

#define int4  int               /* any long enough integral type            */
#define int2  short             /* assert (2*sizeof(int2) == sizeof (int4)) */
#define xint  int               /* any int type >= 32 bits && >= sizeof (bitmask4) */
#define int32 int               /* 32 bit type */
#define int16 short             /* 16 bit type */

#define tag_t    int32

#ifdef i386
#define bitmask4 int32  /* must be 32 bit for i386 */
#define bitmask2 int16
#else
#define bitmask4 int4   /* not important otherwise; shall not exceed xint */
#define bitmask2 int2	/* well, well... it's important for x86 compatibility */
#endif


#define uint4     unsigned int4
#define uint2     unsigned int2
#define uxint     unsigned xint
#define uint32    unsigned int32
#define uint16    unsigned int16
#define utag_t    unsigned tag_t
#define ubitmask4 unsigned bitmask4
#define ubitmask2 unsigned bitmask2

#ifdef _MSC_VER
#if _MSC_VER >= 1200
#define INLINE  __forceinline
#else
#define INLINE __inline
#endif
#pragma warning(disable:4127)   /* conditional expression is constant */
#pragma warning(disable:4711)   /* function XXX selected for automatic inline expansion */
#pragma warning(disable:4710)   /* function XXX not expanded */
#pragma warning(disable:4100)   /* unreferenced formal paramter */
#pragma warning(disable:4068)   /* bogus "unknown pragma" */
#endif

#ifndef DEBUG
#define DEBUG 0
#endif

#if !defined (INLINE) || DEBUG
#undef  INLINE
#define INLINE static
#endif

#if !DEBUG
#undef assert
#define assert(x)
#endif

#if CODING & (CODING_DIRECT | CODING_DIRECT2)
#define MIN_SIZE0       8
#elif CODING == CODING_BY_BIT
#define MIN_SIZE0       7
#elif CODING == CODING_HUFF_LEN
#define MIN_SIZE0       44
#elif CODING == CODING_HUFF_PTR
#define MIN_SIZE0       139
#elif CODING == CODING_HUFF_ALL
#define MIN_SIZE0       261
#else
#error wrong CODING
#endif

#define MIN_SIZE        (MIN_SIZE0 + CRC_STAMP_SIZE)


#define CRC32_FIRST     0
#if SUPPORT_CRC
#define CRC_STAMP_SIZE  sizeof (uint32)
#else
#define CRC_STAMP_SIZE  0
#endif

#if DEBUG
extern long xxx[];
#endif

#ifdef _MSC_VER
#pragma warning (disable: 4731) /* frame pointer register 'ebp' modified by inline assembly code */
#endif

#if CODING_ALG != 1 && CODING_ALG != 6
#error CODING_ALGs different from 1 and 6 are not supported anymore
#endif

#endif /* _XPRS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\asms\makefile.inc ===
run_the_batch_file:
!if "$(PASS0ONLY)"=="1"
 enduser_asms_build.bat
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\downlevelclients\makefile.inc ===
PropClientsToBinaries: \
    PropLanman \
    PropLanmanOS2 \
    PropMsCLient \
    PropRas \
    PropSrvTools \
    PropSupport \
    PropTcp32wfw \
    PropUpdateWfw \
    PropWin95

PropLanman:
!ifdef _NTTREE
    # xcopy lanman $(_NTTREE)\clients\lanman /s /d /y /i
    perl -S xcopy2binplace.pl lanman $(_NTTREE)\clients\lanman /s /d /y /i
!endif    

PropLanmanOS2:
!ifdef _NTTREE
    # xcopy lanman.os2 $(_NTTREE)\clients\lanman.os2 /s /d /y /i
    perl -S xcopy2binplace.pl lanman.os2 $(_NTTREE)\clients\lanman.os2 /s /d /y /i
!endif    

PropMsCLient:
!ifdef _NTTREE
    # xcopy msclient $(_NTTREE)\clients\msclient /s /d /y /i
    perl -S xcopy2binplace.pl msclient $(_NTTREE)\clients\msclient /s /d /y /i
!endif    

PropRas:
!ifdef _NTTREE
    # xcopy ras $(_NTTREE)\clients\ras /s /d /y /i
    perl -S xcopy2binplace.pl ras $(_NTTREE)\clients\ras /s /d /y /i
!endif    

PropSrvTools:
!ifdef _NTTREE
    # xcopy srvtools $(_NTTREE)\clients\srvtools /s /d /y /i
    perl -S xcopy2binplace.pl srvtools $(_NTTREE)\clients\srvtools /s /d /y /i
!endif    

PropSupport:
!ifdef _NTTREE
    # xcopy support $(_NTTREE)\clients\support /s /d /y /i
    perl -S xcopy2binplace.pl support $(_NTTREE)\clients\support /s /d /y /i
!endif    

PropTcp32wfw:
!ifdef _NTTREE
    # xcopy tcp32wfw $(_NTTREE)\clients\tcp32wfw /s /d /y	/i
    perl -S xcopy2binplace.pl tcp32wfw $(_NTTREE)\clients\tcp32wfw /s /d /y	/i
!endif    

PropUpdateWfw:
!ifdef _NTTREE
    # xcopy update.wfw $(_NTTREE)\clients\update.wfw /s /d /y /i
    perl -S xcopy2binplace.pl update.wfw $(_NTTREE)\clients\update.wfw /s /d /y /i
!endif    

PropWin95:
!ifdef _NTTREE
    # xcopy win95 $(_NTTREE)\clients\win95 /s /d /y /i
    perl -S xcopy2binplace.pl win95 $(_NTTREE)\clients\win95 /s /d /y /i
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\mapistub\fixmapi\fixmapi.c ===
/*
 *	FIXMAPI.C
 *	
 *	MAPI Repair Tool executable for NT5
 */


#include <windows.h>

#ifndef MB_SETFOREGROUND
#define MB_SETFOREGROUND 0
#endif

void	InstallAlert(LPTSTR szErr);

int WINAPI
ModuleEntry()
{
	HINSTANCE hinst;

	hinst = LoadLibrary("mapistub.dll");
	if (!hinst)
	{
		DWORD dw = GetLastError();
		TCHAR sz[MAX_PATH];

		wsprintf(sz, "LoadLibrary: GetLastError = %d", dw);
		InstallAlert(sz);
	}
	else
	{
		FARPROC pfn;

		pfn = GetProcAddress(hinst, "FixMAPI");
		if (!pfn)
		{
			DWORD dw = GetLastError();
			TCHAR sz[MAX_PATH];

			wsprintf(sz, "GetProcAddress: GetLastError = %d", dw);
			InstallAlert(sz);
		}
		else
		{
			(*pfn)();	// Call FixMAPI()
		}
	}
	
	ExitProcess(0);
}

void
InstallAlert(LPTSTR szErr)
{
	MessageBox(NULL, szErr, "MAPI Repair Tool", MB_OK | MB_ICONSTOP | MB_SETFOREGROUND);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\mapistub\mapistub\client.h ===
/*
 -  C L I E N T . H
 -
 *  Purpose:
 *      Header file for the sample mail client based on Simple MAPI.
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */



/* Resource IDs */

#define ICON_NOMAIL     200
#define ICON_Attach      201

/* Compose Note Control IDs */

#define IDC_SEND        101
#define IDC_RESOLVE     102
#define IDC_ATTACH      103
#define IDC_OPTIONS     104
#define IDC_ADDRBOOK    105
#define IDT_TO          106
#define IDC_TO          107
#define IDT_CC          108
#define IDC_CC          109
#define IDT_SUBJECT     110
#define IDC_SUBJECT     111
#define IDC_NOTE        112
#define IDC_CATTACHMENT	113
#define IDT_CATTACHMENT	114
#define IDC_LINE1       -1
#define IDC_LINE2       -1

#define ID_Frame			222
#define ID_Toolbar			223

#define ID_Font				224
#define ID_FontSize			225

#define ID_Bold				226
#define ID_Italic			227
#define ID_Underline		228

#define ID_Bullet			229
#define ID_Left				230
#define ID_Center			231
#define ID_Right			232
#define ID_Collapse			233
#define ID_Indent			234

#define ID_Color			250
#define ID_ColorAuto		251
#define ID_ColorBlack		252
#define ID_ColorMaroon		253
#define ID_ColorGreen		254
#define ID_ColorOlive		255
#define ID_ColorBlue		256
#define ID_ColorPurple		257
#define ID_ColorTeal		258
#define ID_ColorGray		259
#define ID_ColorSilver		260
#define ID_ColorRed			261
#define ID_ColorLime		262
#define ID_ColorYellow		263
#define ID_ColorNavy		264
#define ID_ColorFuchia		265
#define ID_ColorAqua		266
#define ID_ColorWhite		267

#define ID_SendUp			268
#define ID_SendDown			269

/* Send Properties IDs */

#define SendProperties		500
#define	IDI_SEND			501
#define IDC_CHANGED			502
#define IDC_DELIVERYREC		503
#define IDC_LOW				504
#define IDC_NORMAL			505
#define IDC_HIGH			506
#define IDC_LOCATION		507
#define IDC_READRECEIPT		508
#define IDC_SENDOPTS		509
#define IDC_SENSITIVITY		510
#define IDC_SENTMAIL		511
#define IDG_OPTIONS			512
#define IDC_MSGSIZE			513
#define IDC_TYPE			514
#define IDL_CHANGED			-1
#define IDL_IMPORTANCE		-1
#define IDL_LOCATION		-1
#define IDL_SENSITIVITY		-1
#define IDL_SIZE			-1
#define IDL_TYPE			-1

// Menu defines

#define IDM_SEND				1100
#define	IDM_PROPERTIES			1101
#define IDM_CLOSE				1102
#define IDM_UNDO				1103
#define IDM_CUT					1104
#define IDM_COPY				1105
#define IDM_PASTE				1106
#define IDM_PASTE_SPECIAL		1107
#define IDM_SELECT_ALL			1108
#define IDM_LINK				1109
#define IDM_EDIT_OBJECT			1110
#define IDM_FILE				1111
#define IDM_OBJECT				1112
#define IDM_FONT				1113
#define IDM_PARAGRAPH			1114
#define IDM_ADDRESSBOOK			1115
#define IDM_HELP				1116
#define IDM_ABOUT				1117
#define IDM_CHECKNAMES			1118

// Help.About dialog

#define BMP_AboutMail				800

#define DLG_ABOUT					1309

#define TXT_AboutTitleLine          101
#define TXT_AboutMailCopyright      102
#define TXT_AboutSoftArtSpell1      103
#define TXT_AboutSoftArtSpell2      104
#define TXT_AboutSoftArtSpell3      105
#define TXT_AboutLicenseTo          106
#define TXT_AboutLicenseFrame       107
#define TXT_AboutLicenseName        108
#define TXT_AboutLicenseOrg         109
#define TXT_AboutFrame              110
#define TXT_AboutBigWarning         111
#define PSB_AboutSystemInfo         112
#define STR_MsInfoCmdLine           113
#define TXT_AboutPID                114

// Help.About dialog
#define STR_AboutBigWarning			2519
#define STR_AboutBigWarning2		2520

// paragraph dialog

#define DLG_PARAGRAPH				1307

#define GRP_Alignment				101
#define RDB_Para_Left				102
#define RDB_Para_Center				103
#define RDB_Para_Right				104
#define CHK_Para_Bullet				105

#define cxBulletIndent				(1440 / 4) // $TBD joel's richedit stuff may already define this.

#define PSB_Help					9
#define PSB_OK						IDOK



// property sheet

#define STR_HeaderGeneral			2521
#define STR_HeaderRead				2522
#define STR_HeaderSend				2523
#define STR_HeaderColors			2524
#define STR_HeaderSpelling  		2525
#define STR_PrefPropSheetTitle		2526
#define STR_ServicesPropSheetTitle	2527

// copy disincentive stuff

#define RT_CDDATATYPE	106
#define RES_CDDATANAME	96



// Accelerator keys

#define AccMapiSendNote					2005

#define MNI_AccelFont					20271
#define MNI_AccelSize					20272
#define MNI_AccelSizePlus1				20273
#define MNI_AccelSizeMinus1				20274
#define MNI_AccelBold					20275
#define MNI_AccelItalic					20276
#define MNI_AccelUnderline				20277
#define MNI_AccelLeft					20278
#define MNI_AccelCenter					20279
#define MNI_AccelRight					20280
#define MNI_AccelBullets				20281
#define MNI_AccelDecreaseIndent			20282
#define MNI_AccelIncreaseIndent			20283
#define MNI_AccelColor					20284
#define MNI_AccelNoFormatting			20285

#define MNI_AccelUndo					20288
#define MNI_AccelCut					20289
#define MNI_AccelCopy					20290
#define MNI_AccelPaste					20291
#define MNI_AccelViewWritingMode		20292
#define MNI_EditSelectAll           	20046
#define MNI_ToolsAddressBook			20123
#define MNI_ToolsCheckNames         	20133
#define MNI_FileSend					20012
#define MNI_HelpPressF1					20163
#define MNI_FileProperties				20431
   

/* About Box Control IDs */

#define IDC_VERSION		101


/* String Table IDs */

#define MAPI_ERROR_MAX          5000

#define IDS_E_SEND_FAILURE				(MAPI_ERROR_MAX + 1)
#define IDS_E_NO_RECIPIENTS				(MAPI_ERROR_MAX + 2)
#define IDS_SAVEATTACHERROR				(MAPI_ERROR_MAX + 3)
#define IDS_READFAIL					(MAPI_ERROR_MAX + 4)
#define IDS_E_UNRESOLVED_RECIPS			(MAPI_ERROR_MAX + 5)
#define IDS_DIALOGACTIVE				(MAPI_ERROR_MAX + 6)

#define IDS_SIMPLE_MAPI_SEND			(IDS_DIALOGACTIVE + 1)
#define IDS_GENERAL						(IDS_SIMPLE_MAPI_SEND + 0)
#define IDS_NEW_MESSAGE					(IDS_SIMPLE_MAPI_SEND + 1)
#define IDS_SENSITIVITY_NORMAL			(IDS_SIMPLE_MAPI_SEND + 2)
#define IDS_SENSITIVITY_PERSONAL		(IDS_SIMPLE_MAPI_SEND + 3)
#define IDS_SENSITIVITY_PRIVATE			(IDS_SIMPLE_MAPI_SEND + 4)
#define IDS_SENSITIVITY_CONFIDENTIAL	(IDS_SIMPLE_MAPI_SEND + 5)
#define IDS_SIZE_IN_BYTES				(IDS_SIMPLE_MAPI_SEND + 6)
#define IDS_MESSAGE_OPTIONS_ERR			(IDS_SIMPLE_MAPI_SEND + 7)
#define IDS_EXCHANGE_HDR				(IDS_SIMPLE_MAPI_SEND + 8)

#define IDS_COLOR_AUTO					(IDS_SIMPLE_MAPI_SEND + 10)
#define IDS_COLOR_BLACK					(IDS_SIMPLE_MAPI_SEND + 11)
#define IDS_COLOR_MAROON				(IDS_SIMPLE_MAPI_SEND + 12)
#define IDS_COLOR_GREEN					(IDS_SIMPLE_MAPI_SEND + 13)
#define IDS_COLOR_OLIVE					(IDS_SIMPLE_MAPI_SEND + 14)
#define IDS_COLOR_NAVY					(IDS_SIMPLE_MAPI_SEND + 15)
#define IDS_COLOR_PURPLE				(IDS_SIMPLE_MAPI_SEND + 16)
#define IDS_COLOR_TEAL					(IDS_SIMPLE_MAPI_SEND + 17)
#define IDS_COLOR_GRAY					(IDS_SIMPLE_MAPI_SEND + 18)
#define IDS_COLOR_SILVER				(IDS_SIMPLE_MAPI_SEND + 19)
#define IDS_COLOR_RED					(IDS_SIMPLE_MAPI_SEND + 20)
#define IDS_COLOR_LIME					(IDS_SIMPLE_MAPI_SEND + 21)
#define IDS_COLOR_YELLOW				(IDS_SIMPLE_MAPI_SEND + 22)
#define IDS_COLOR_BLUE					(IDS_SIMPLE_MAPI_SEND + 23)
#define IDS_COLOR_FUCHSIA				(IDS_SIMPLE_MAPI_SEND + 24)
#define IDS_COLOR_AQUA					(IDS_SIMPLE_MAPI_SEND + 25)
#define IDS_COLOR_WHITE					(IDS_SIMPLE_MAPI_SEND + 26)

#define IDS_CM_CUT						(IDS_SIMPLE_MAPI_SEND + 27)
#define IDS_CM_COPY						(IDS_SIMPLE_MAPI_SEND + 28)
#define IDS_CM_PASTE					(IDS_SIMPLE_MAPI_SEND + 29)
#define IDS_CM_SELECT_ALL				(IDS_SIMPLE_MAPI_SEND + 30)
#define IDS_CM_FONT						(IDS_SIMPLE_MAPI_SEND + 31)
#define IDS_CM_PARAGRAPH				(IDS_SIMPLE_MAPI_SEND + 32)
			
#define IDS_DEFAULT_FONT				(IDS_SIMPLE_MAPI_SEND + 39)
			
#define IDS_E_WINHELP_FAILURE			(IDS_SIMPLE_MAPI_SEND + 40)	
#define IDS_E_NO_HELP					(IDS_SIMPLE_MAPI_SEND + 41)	
#define IDS_E_RICHED_UNDO				(IDS_SIMPLE_MAPI_SEND + 42)	
#define IDS_E_REALLY_QUIT				(IDS_SIMPLE_MAPI_SEND + 43)	
#define IDS_E_SAVE_CLIPBOARD			(IDS_SIMPLE_MAPI_SEND + 44)	
#define IDS_E_1_INSTANCE    			(IDS_SIMPLE_MAPI_SEND + 45)	

#define IDS_FILTER						(MAPI_ERROR_MAX + 60)


/* Manifest Constants */

#define ADDR_MAX            128
#define MAXUSERS            10
#define TO_EDIT_MAX         512
#define CC_EDIT_MAX         512
#define SUBJECT_EDIT_MAX    128
#define NOTE_LINE_MAX       1024
#define FILE_ATTACH_MAX     32


/* Virtual key code definitions for accelerators */

#define VK_OEM_LBRACKET				0xDB
#define VK_OEM_RBRACKET				0xDD


/* Message Box styles */

#define MBS_ERROR           (MB_ICONSTOP | MB_OK)
#define MBS_INFO            (MB_ICONINFORMATION | MB_OK)
#define MBS_OOPS            (MB_ICONEXCLAMATION | MB_OK)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\mapistub\mapistub\mapinls.h ===
/*
 *	M A P I N L S . H
 *
 *	Internationalization Support Utilities
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _MAPINLS_H_
#define _MAPINLS_H_

#if _MSC_VER > 1000
#pragma once
#endif

#if defined (WIN32) && !defined (_WIN32)
#define _WIN32
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* We don't want to include windows.h in case that conflicts with an */
/* earlier inclusion of compobj.h */

#if !defined(WINAPI)
	#if defined(_WIN32) && (_MSC_VER >= 800)
		#define WINAPI				__stdcall
	#elif defined(WIN16)
		#define WINAPI				_far _pascal
	#else
		#define WINAPI				_far _pascal
	#endif
#endif

#if defined(DOS) || defined(_MAC)
#include <string.h>
#endif

#ifndef FAR
#define FAR
#endif

typedef unsigned char				    BYTE;
typedef unsigned short      			WORD;
typedef unsigned long       			DWORD;
typedef unsigned int	 				UINT;
typedef int		 						BOOL;

#ifndef __CHAR_DEFINED__
typedef char							CHAR;
#endif

#ifdef UNICODE
typedef WCHAR							TCHAR;
#else
typedef char							TCHAR;
#endif

#if !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short WCHAR;
#endif

typedef WCHAR FAR *						LPWSTR;
typedef const WCHAR FAR *				LPCWSTR;
typedef CHAR FAR *						LPSTR;
typedef const CHAR FAR *				LPCSTR;
typedef TCHAR FAR *						LPTSTR;
typedef const TCHAR FAR *				LPCTSTR;
typedef DWORD 							LCID;
typedef const void FAR *				LPCVOID;

#ifndef _MAC
#ifndef LPOLESTR
#if !defined (_WIN32)

#define LPOLESTR        LPSTR
#define LPCOLESTR       LPCSTR
#define OLECHAR         char
#define OLESTR(str) 	str

#else  /* Win32 */

#define LPOLESTR        LPWSTR
#define LPCOLESTR       LPCWSTR
#define OLECHAR         WCHAR
#define OLESTR(str)     L##str

#endif /* !_WIN32 */
#endif /* LPOLESTR */
#endif /* _MAC */

#define NORM_IGNORECASE      			0x00000001     /* ignore case */
#define NORM_IGNORENONSPACE  			0x00000002     /* ignore diacritics */
#define NORM_IGNORESYMBOLS   			0x00000004     /* ignore symbols */

#if defined (_WIN32) /* from winnls.h */
#define NORM_IGNOREKANATYPE				0x00010000     /* ignore kanatype */
#define NORM_IGNOREWIDTH				0x00020000	   /* ignore width */
#elif defined (WIN16) /* from olenls.h */
#define NORM_IGNOREWIDTH				0x00000008		/* ignore width */
#define NORM_IGNOREKANATYPE				0x00000040		/* ignore kanatype */
#endif

#if defined(WIN16)

#define	lstrcpyA						lstrcpy
#define	lstrlenA						lstrlen
#define	lstrcmpA						lstrcmp
#define lstrcmpiA						lstrcmpi
#define	LoadStringA						LoadString
#define IsBadStringPtrA(a1, a2)			IsBadStringPtr(a1, a2)
#define	wvsprintfA						wvsprintf
#define	MessageBoxA						MessageBox
#define GetModuleHandleA				GetModuleHandle
#define CreateWindowA					CreateWindow
#define RegisterClassA					RegisterClass
#define	CharToOemBuff					AnsiToOemBuff
#define	CharToOem						AnsiToOem
#define	CharUpperBuff					AnsiUpperBuff
#define	CharUpper						AnsiUpper

#elif defined(DOS) || defined(_MAC)

#define	IsBadReadPtr(lp, cb)			(FALSE)
#define IsBadWritePtr(lp, cb)			(FALSE)
#define IsBadHugeReadPtr(lp, cb)		(FALSE)
#define IsBadHugeWritePtr(lp, cb)		(FALSE)
#define IsBadCodePtr(lpfn)				(FALSE)
#ifdef _MAC
#undef IsBadStringPtr
#endif
#define IsBadStringPtr(lpsz, cchMax)	(FALSE)
#define IsBadStringPtrA(lpsz, cchMax)	(FALSE)

#if defined(DOS)

#define	lstrcpyA						strcpy
#define	lstrlenA						strlen
#define	lstrcmpA						strcmp
#define lstrcmp							strcmp
#define lstrcmpi						strcmpi
#define lstrcpy							strcpy
#define lstrcat							strcat
#define lstrlen							strlen
#define wsprintf						sprintf

#endif
#endif

#if defined(DOS) || defined(WIN16)
/* Simulate effect of afx header */
#define __T(x)		x
#define _T(x)		__T(x)
#define TEXT		_T
#endif

#define CP_ACP		0		/* default to ANSI code page */
#define CP_OEMCP	1		/* default to OEM  code page */

LCID	WINAPI	MNLS_GetUserDefaultLCID(void);
UINT	WINAPI	MNLS_GetACP(void);
int		WINAPI	MNLS_CompareStringA(LCID Locale, DWORD dwCmpFlags,
					LPCSTR lpString1, int cchCount1, LPCSTR lpString2,
					int cchCount2);
int		WINAPI	MNLS_CompareStringW(LCID Locale, DWORD dwCmpFlags,
					LPCWSTR lpString1, int cchCount1, LPCWSTR lpString2,
					int cchCount2);
int		WINAPI	MNLS_MultiByteToWideChar(UINT uCodePage, DWORD dwFlags,
					LPCSTR lpMultiByteStr, int cchMultiByte,
					LPWSTR lpWideCharStr, int cchWideChar);
int		WINAPI	MNLS_WideCharToMultiByte(UINT uCodePage, DWORD dwFlags,
					LPCWSTR lpWideCharStr, int cchWideChar,
					LPSTR lpMultiByteStr, int cchMultiByte,
					LPCSTR lpDefaultChar, BOOL FAR *lpfUsedDefaultChar);
int		WINAPI	MNLS_lstrlenW(LPCWSTR lpString);
int		WINAPI	MNLS_lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2);
LPWSTR	WINAPI	MNLS_lstrcpyW(LPWSTR lpString1, LPCWSTR lpString2);
BOOL	WINAPI	MNLS_IsBadStringPtrW(LPCWSTR lpsz, UINT ucchMax);

#if defined(_WIN32) && !defined(_WINNT) && !defined(_WIN95) && !defined(_MAC)
#define _WINNT
#endif

#if !defined(_WINNT) && !defined(_WIN95)
#define GetUserDefaultLCID		MNLS_GetUserDefaultLCID
#define GetACP					MNLS_GetACP
#define MultiByteToWideChar		MNLS_MultiByteToWideChar
#define WideCharToMultiByte		MNLS_WideCharToMultiByte
#define CompareStringA			MNLS_CompareStringA
#endif

#if !defined(MAPI_NOWIDECHAR)

#define lstrlenW				MNLS_lstrlenW
#define lstrcmpW				MNLS_lstrcmpW
#define lstrcpyW				MNLS_lstrcpyW
#define CompareStringW			MNLS_CompareStringW

#if defined(WIN16) || defined(_WINNT) || defined(_WIN95)
#define IsBadStringPtrW			MNLS_IsBadStringPtrW
#elif defined(_MAC)
#define IsBadStringPtrW(lpsz, cchMax)			(FALSE)
#else
#define IsBadStringPtrW			(FALSE)
#endif

#endif	/* ! MAPI_NOWIDECHAR */

#ifdef __cplusplus
}
#endif

#endif /* _MAPINLS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\mapistub\mapistub\mapixrc.h ===
/*
 *
 * MAPIXRC.H
 *
 * Resource definitions for MAPI.DLL
 *
 * Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved.
 *
 */

#ifndef _MAPIXRC_H_
#define	_MAPIXRC_H_

// reordered according to XPPERF recommendations

#define cchCompMax							100

//-------------------------------------------------------------
// MAPI Non Error messages 
//-------------------------------------------------------------

#define IDS_STATUS_BASE						0

/* Component name for GetLastError */

#define IDS_COMPONENTNAME					(IDS_STATUS_BASE + 0)

/* Default Status Strings for Status Table */

#define IDS_STATUS_AVAILABLE				(IDS_STATUS_BASE + 1)
#define IDS_STATUS_OFFLINE					(IDS_STATUS_BASE + 2)
#define IDS_STATUS_FAILURE					(IDS_STATUS_BASE + 3)
#define IDS_STATUS_UNKNOWN					(IDS_STATUS_BASE + 4)
#define IDS_STATUS_XP_ONLINE				(IDS_STATUS_BASE + 5)
#define IDS_STATUS_XP_UPLOADING				(IDS_STATUS_BASE + 6)
#define IDS_STATUS_XP_DOWNLOADING			(IDS_STATUS_BASE + 7)
#define IDS_STATUS_XP_INFLUSHING			(IDS_STATUS_BASE + 8)
#define IDS_STATUS_XP_OUTFLUSHING			(IDS_STATUS_BASE + 9)

// Address Book Status Object Display Name

#define IDS_AB_STATUS_DISPLAY				(IDS_STATUS_BASE + 10)

// Spooler Status Object Display Name

#define IDS_SPOOLER_STATUS_DISPLAY			(IDS_STATUS_BASE + 11)

/* ipmtree.c */

#define IDS_IPMTREE_BASE					(IDS_STATUS_BASE + 12)

#define IDS_IPMSubtreeName					(IDS_IPMTREE_BASE + 0)
#define IDS_WastebasketName					(IDS_IPMTREE_BASE + 1)
#define IDS_WastebasketComment				(IDS_IPMTREE_BASE + 2)
#define IDS_InboxName						(IDS_IPMTREE_BASE + 3)
#define IDS_InboxComment					(IDS_IPMTREE_BASE + 4)
#define IDS_OutboxName						(IDS_IPMTREE_BASE + 5)
#define IDS_OutboxComment					(IDS_IPMTREE_BASE + 6)
#define IDS_SentmailName					(IDS_IPMTREE_BASE + 7)
#define IDS_SentmailComment					(IDS_IPMTREE_BASE + 8)
#define IDS_ViewsName						(IDS_IPMTREE_BASE + 9)
#define IDS_CommonViewsName					(IDS_IPMTREE_BASE + 10)
#define IDS_FindersName						(IDS_IPMTREE_BASE + 11)


/* Strings found in AB UI */

#define IDS_AB_BASE							(IDS_IPMTREE_BASE + 12)

#define IDS_GENERIC_RECIP_DN				(IDS_AB_BASE + 0)
#define IDS_MESSAGE_OPTIONS					(IDS_AB_BASE + 1)
#define IDS_RECIPIENT_OPTIONS				(IDS_AB_BASE + 2)

#define IDS_READ_NOTIFICATION				(IDS_AB_BASE + 3)
#define IDS_RN_SUBJECT_PREFIX				(IDS_AB_BASE + 4)
#define IDS_NONREAD_NOTIFICATION			(IDS_AB_BASE + 5)
#define IDS_NRN_SUBJECT_PREFIX				(IDS_AB_BASE + 6)
#define IDS_REPORT_PREFIX_DELIMITER			(IDS_AB_BASE + 7)

// xDRs

#define IDS_XDR_BASE						(IDS_AB_BASE + 8)

#define IDS_DR_REP_TEXT_GENERIC				(IDS_XDR_BASE + 0)
#define IDS_NDR_REP_TEXT_GENERIC			(IDS_XDR_BASE + 1)
#define IDS_DR_SUBJECT_PREFIX				(IDS_XDR_BASE + 2)
#define IDS_NDR_SUBJECT_PREFIX				(IDS_XDR_BASE + 3)
#define IDS_XDR_SYSTEM_ADMIN_NAME			(IDS_XDR_BASE + 4)
#define	IDS_NDR_LACK_OF_RESPOSIBILITY		(IDS_XDR_BASE + 5)

// Wizard non error strings

#define IDS_WIZ_BASE						(IDS_XDR_BASE + 6)

#define IDS_APP_TITLE						(IDS_WIZ_BASE + 0)
#define IDS_MS_EXCHANGE        				(IDS_WIZ_BASE + 1)
#define IDS_STARTUP_GROUP      	 			(IDS_WIZ_BASE + 2)
#define IDS_BROWSE_PST_TITLE				(IDS_WIZ_BASE + 3)
#define IDS_BROWSE_PAB_TITLE				(IDS_WIZ_BASE + 4)
#define IDS_BROWSE_PST_FILTER  				(IDS_WIZ_BASE + 5)
#define IDS_BROWSE_PAB_FILTER  				(IDS_WIZ_BASE + 6)
#define IDS_BROWSE_ALL_FILTER  				(IDS_WIZ_BASE + 7)
#define IDS_BROWSE_PST_FILES				(IDS_WIZ_BASE + 8)
#define IDS_BROWSE_PAB_FILES				(IDS_WIZ_BASE + 9)
#define IDS_BROWSE_ALL_FILES				(IDS_WIZ_BASE + 10)
#define IDS_DEF_PROFNAME					(IDS_WIZ_BASE + 11)
#define IDS_PAB								(IDS_WIZ_BASE + 12)
#define IDS_PST								(IDS_WIZ_BASE + 13)
#define IDS_INC_PROFNAME					(IDS_WIZ_BASE + 14)
#define IDS_PASSWORDCAPTION	  				(IDS_WIZ_BASE + 15)
#define IDS_CREATE_MESSAGING_SERVICE		(IDS_WIZ_BASE + 16)
#define IDS_LOGOFF_TO_CREATE  				(IDS_WIZ_BASE + 17)
#define IDS_DELETE_MESSAGING_SERVICE		(IDS_WIZ_BASE + 18)
#define IDS_LOGOFF_TO_DELETE  				(IDS_WIZ_BASE + 19)

#define IDS_NOERROR_BASE					(IDS_WIZ_BASE + 20)

/* blddt.c */

#define IDS_GeneralPage						(IDS_NOERROR_BASE + 0)

/*	Dialog Box Captions */

#define IDS_ERRCAPTION						(IDS_NOERROR_BASE + 1)

/* Simple MAPI */

#define IDS_ADDRESSBOOK			   			(IDS_NOERROR_BASE + 2)
#define IDS_ATTACHFILES						(IDS_NOERROR_BASE + 3)

/* Bob fixup strings */

#define IDS_PST_DISPLAY_NAME				(IDS_NOERROR_BASE + 4)
#define IDS_PST_BAD_DISPLAY_NAME			(IDS_NOERROR_BASE + 5)

//-------------------------------------------------------------
// MAPI Error messages 
//-------------------------------------------------------------

#define IDS_ERROR_BASE						(IDS_NOERROR_BASE + 6)

#define IDS_PROP_INTERFACE_NOT_SUPPORTED	(IDS_ERROR_BASE + 0)
#define IDS_NO_CONTENTS_TABLE				(IDS_ERROR_BASE + 1)
#define IDS_UNKNOWN_AB_ENTRYID				(IDS_ERROR_BASE + 2)
#define IDS_UNKNOWN_ENTRYID					(IDS_ERROR_BASE + 3)
#define IDS_NO_PAB							(IDS_ERROR_BASE + 4)
#define IDS_NO_DEFAULT_DIRECTORY			(IDS_ERROR_BASE + 5)
#define IDS_NO_SEARCH_PATH					(IDS_ERROR_BASE + 6)
#define IDS_NO_HIERARCHY					(IDS_ERROR_BASE + 7)
#define IDS_SET_SEARCH_PATH					(IDS_ERROR_BASE + 8)
#define IDS_NO_NAME_CONTAINERS				(IDS_ERROR_BASE + 9)
#define IDS_NO_HIERARCHY_TABLE				(IDS_ERROR_BASE + 10)
#define IDS_STORE_NOT_LISTED				(IDS_ERROR_BASE + 11)
#define IDS_CANT_INIT_PROVIDER				(IDS_ERROR_BASE + 12)
#define IDS_CANT_ADD_STORE					(IDS_ERROR_BASE + 13)
#define IDS_CANT_LOGON_STORE				(IDS_ERROR_BASE + 14)
#define IDS_NO_ABPROVIDERS					(IDS_ERROR_BASE + 15)
#define IDS_NO_XPPROVIDERS					(IDS_ERROR_BASE + 16)
#define IDS_UNKNOWN_PROVIDER				(IDS_ERROR_BASE + 17)
#define IDS_NO_PROVIDER_INFO				(IDS_ERROR_BASE + 18)
#define IDS_WRONG_PROVIDER_VERSION			(IDS_ERROR_BASE + 19)
#define IDS_NEED_EMT_EMA_DN			   		(IDS_ERROR_BASE + 20)

#define IDS_ERROR1_BASE						(IDS_ERROR_BASE + 21)
														   
#define IDS_CANT_GET_RECIP_INFO				(IDS_ERROR1_BASE + 0)
#define IDS_OPTIONS_DATA_ERROR				(IDS_ERROR1_BASE + 1)
#define IDS_CANT_INIT_COMMON_DLG			(IDS_ERROR1_BASE + 2)
#define IDS_NO_SERVICE_ENTRY				(IDS_ERROR1_BASE + 3)
#define IDS_NO_SUCH_SERVICE					(IDS_ERROR1_BASE + 4)
#define IDS_ITABLE_ERROR					(IDS_ERROR1_BASE + 5)
#define IDS_PROF_ACCESS_DENIED				(IDS_ERROR1_BASE + 6)
#define IDS_NO_CONNECTION					(IDS_ERROR1_BASE + 7)
#define IDS_COREMOTE_ERROR					(IDS_ERROR1_BASE + 8)
#define IDS_OPENSTAT_ERROR					(IDS_ERROR1_BASE + 9)
#define IDS_MAPI_NOT_INITIALIZED			(IDS_ERROR1_BASE + 10)
#define IDS_NO_SERVICE						(IDS_ERROR1_BASE + 11)
#define IDS_NO_NEW_DEF      				(IDS_ERROR1_BASE + 12)
#define IDS_CANT_FIX_OLD_DEF				(IDS_ERROR1_BASE + 13)
#define IDS_NO_DLL							(IDS_ERROR1_BASE + 14)
#define IDS_NO_SERVICE_DLL					(IDS_ERROR1_BASE + 15)
#define IDS_DEADSPOOLER						(IDS_ERROR1_BASE + 16)
#define IDS_FAILEDSPOOLER					(IDS_ERROR1_BASE + 17)
#define IDS_LOGONINTERNAL					(IDS_ERROR1_BASE + 18)
#define IDS_NO_RECIP_OPTIONS				(IDS_ERROR1_BASE + 19)
#define IDS_NODEFSTORESUPPORT				(IDS_ERROR1_BASE + 20)
#define IDS_SERVICEONEINSTANCE				(IDS_ERROR1_BASE + 21)
#define IDS_TRANSPORT_BUSY					(IDS_ERROR1_BASE + 22)
#define IDS_NO_REQUIRED_PROPS				(IDS_ERROR1_BASE + 23)
#define IDS_ISTREAM_ERROR					(IDS_ERROR1_BASE + 24)
#define IDS_ERRADDIPMTREE					(IDS_ERROR1_BASE + 25)
#define IDS_EXPANDRECIP_EMPTY_DLS			(IDS_ERROR1_BASE + 26)
#define IDS_LOGON_TIMED_OUT					(IDS_ERROR1_BASE + 27)
#define IDS_SERVICE_DLL_NOT_FOUND			(IDS_ERROR1_BASE + 28)
#define IDS_VALIDATESTATE_ERROR				(IDS_ERROR1_BASE + 29)
#define IDS_NO_MSG_OPTIONS					(IDS_ERROR1_BASE + 30)
#define IDS_NOREGFILE						(IDS_ERROR1_BASE + 31)
#define IDS_REGLOADFAIL						(IDS_ERROR1_BASE + 32)
#define IDS_NORESTOREPRIV					(IDS_ERROR1_BASE + 33)
#define	IDS_NTERROR							(IDS_ERROR1_BASE + 34)
//	Spooler wrapper error strings

#define IDS_SPL_BASE						(IDS_ERROR1_BASE + 35)

#define IDS_WRAPPED_RESTRICTION				(IDS_SPL_BASE + 0) 
#define	IDS_WRAPPED_ATTACHMENT_RESOLVE		(IDS_SPL_BASE + 1) 
#define	IDS_WRAPPED_NO_ACCESS				(IDS_SPL_BASE + 2) 
#define	IDS_WRAPPED_RECIP_TABLE				(IDS_SPL_BASE + 3) 
#define IDS_WRAPPED_SORT					(IDS_SPL_BASE + 4)

#define IDS_DEADSPOOLER_CAPTION				(IDS_SPL_BASE + 5)

/*
 *	Resource IDs for MAPI default profile provider.
 *

/* Error messages */

#define IDS_PROFILE_BASE					(IDS_SPL_BASE + 6)

#define IDS_GETPROPLISTFAIL					(IDS_PROFILE_BASE + 0)
#define IDS_NOPROPERTIES					(IDS_PROFILE_BASE + 1)
#define IDS_SECTIONOPENREADONLY				(IDS_PROFILE_BASE + 2)
#define IDS_GETPROPFAIL						(IDS_PROFILE_BASE + 3)
#define IDS_INVALIDNAME						(IDS_PROFILE_BASE + 4)
#define IDS_INVALIDPASSWORD					(IDS_PROFILE_BASE + 5)
#define IDS_DUPPROFILE						(IDS_PROFILE_BASE + 6) 
#define IDS_NOPROFILE						(IDS_PROFILE_BASE + 7) 
#define IDS_NOPROFILESATALL					(IDS_PROFILE_BASE + 8) 
#define IDS_INTERNALLOGONFAIL				(IDS_PROFILE_BASE + 9) 
#define IDS_NOSECTION						(IDS_PROFILE_BASE + 10) 
#define IDS_LOGONFAIL						(IDS_PROFILE_BASE + 11) 


//	Profile wizard resource IDs
//	Error message strings

#define IDS_WIZ1_BASE						(IDS_PROFILE_BASE + 12)

#define IDS_FATAL							(IDS_WIZ1_BASE + 0)
#define IDS_DLG_FLD							(IDS_WIZ1_BASE + 1)
#define IDS_INVLD_WM						(IDS_WIZ1_BASE + 2)
#define IDS_INVLD_PROFNAME					(IDS_WIZ1_BASE + 3)
#define IDS_APPLICATION_FAILED 				(IDS_WIZ1_BASE + 4)
#define IDS_CREATE_DEFSRV					(IDS_WIZ1_BASE + 5)
#define IDS_CONFIG_DEFSRV					(IDS_WIZ1_BASE + 6)
#define IDS_CONFIG_CFGPROF					(IDS_WIZ1_BASE + 7)
#define IDS_PROPSAVE_SVC					(IDS_WIZ1_BASE + 8)
#define IDS_SRV_FLD							(IDS_WIZ1_BASE + 9)
#define IDS_RESOURCE_FLD					(IDS_WIZ1_BASE + 10)
#define IDS_SRVDLL_FLD						(IDS_WIZ1_BASE + 11)
#define IDS_MAPILOGON_FLD					(IDS_WIZ1_BASE + 12)
#define IDS_CRPROF_FLD						(IDS_WIZ1_BASE + 13)
#define IDS_PASS_FLD						(IDS_WIZ1_BASE + 14)
#define IDS_MMF_TOOMANY						(IDS_WIZ1_BASE + 15)
#define IDS_MMF_FLD							(IDS_WIZ1_BASE + 16)
#define IDS_PROF_EXIST						(IDS_WIZ1_BASE + 17)
#define IDS_NO_MEM							(IDS_WIZ1_BASE + 18)
#define IDS_DEFDIR_FLD						(IDS_WIZ1_BASE + 19)
#define IDS_CREATEPAB_FLD					(IDS_WIZ1_BASE + 20)
#define IDS_CONFIGPAB_FLD					(IDS_WIZ1_BASE + 21)
#define IDS_CONFIGPAB_FLD_POPUP 			(IDS_WIZ1_BASE + 22)
#define IDS_CREATEPST_FLD					(IDS_WIZ1_BASE + 23)
#define IDS_CONFIGPST_FLD					(IDS_WIZ1_BASE + 24)
#define IDS_CONFIGPST_FLD_POPUP 			(IDS_WIZ1_BASE + 25)
#define IDS_CREATEPST_NOTFOUND  			(IDS_WIZ1_BASE + 26)
#define IDS_CANCEL_ENSURE					(IDS_WIZ1_BASE + 27)
#define IDS_INVALID_SVC_ENTRY  				(IDS_WIZ1_BASE + 28)
#define IDS_INF_MISSING        				(IDS_WIZ1_BASE + 29)
#define IDS_2INSTANCE          				(IDS_WIZ1_BASE + 30)
#define IDS_WELCOME_MESSAGE    				(IDS_WIZ1_BASE + 31)

#define IDS_MAPI_BASE						(IDS_WIZ1_BASE + 32)

/* ITableData */

#define	IDS_OUT_OF_BOOKMARKS				(IDS_MAPI_BASE + 0) 
#define	IDS_CANT_CATEGORIZE					(IDS_MAPI_BASE + 1) 

/* TNEF */

#define	IDS_TNEF_UNTITLED_ATTACH			(IDS_MAPI_BASE + 2)
#define	IDS_TNEF_EMBEDDED_MESSAGE			(IDS_MAPI_BASE + 3)
#define	IDS_TNEF_TAG_EMBEDDED				(IDS_MAPI_BASE + 4)
#define	IDS_TNEF_TAG_OLE					(IDS_MAPI_BASE + 5)
#define	IDS_TNEF_TAG_UNKNOWN				(IDS_MAPI_BASE + 6)
#define IDS_TNEF_EMBEDDED_STRM_NAME			(IDS_MAPI_BASE + 7)
#define IDS_TNEF_OLE2_LINK					(IDS_MAPI_BASE + 8)
#define IDS_TNEF_TAG_IN						(IDS_MAPI_BASE + 9)

/* Message-on-storage */

#define IDS_BASE_IMSG						(IDS_MAPI_BASE + 10)

#define IDS_SUCCESS_IMSG					(IDS_BASE_IMSG + 0)
#define IDS_NOT_ENOUGH_MEMORY				(IDS_BASE_IMSG + 1)
#define IDS_NO_ACCESS						(IDS_BASE_IMSG + 2)
#define IDS_INVALID_PARAMETER				(IDS_BASE_IMSG + 3)
#define IDS_INTERFACE_NOT_SUPPORTED			(IDS_BASE_IMSG + 4)
#define IDS_INVALID_ENTRYID					(IDS_BASE_IMSG + 5)
#define IDS_CALL_FAILED						(IDS_BASE_IMSG + 6)
#define IDS_ERRORS_RETURNED					(IDS_BASE_IMSG + 7)
#define IDS_NO_SUPPORT		 				(IDS_BASE_IMSG + 8)
#define IDS_NOT_IN_QUEUE					(IDS_BASE_IMSG + 9)
#define IDS_UNABLE_TO_ABORT					(IDS_BASE_IMSG + 10)
#define IDS_NOT_FOUND						(IDS_BASE_IMSG + 11)
#define IDS_LOGON_FAILED					(IDS_BASE_IMSG + 12)
#define IDS_CORRUPT_STORE					(IDS_BASE_IMSG + 13)
#define IDS_BAD_VALUE						(IDS_BASE_IMSG + 14)
#define IDS_INVALID_OBJECT					(IDS_BASE_IMSG + 15)
#define IDS_NOT_ENOUGH_DISK					(IDS_BASE_IMSG + 16)
#define IDS_DISK_ERROR						(IDS_BASE_IMSG + 17)
#define IDS_NOINTERFACE						(IDS_BASE_IMSG + 18)
#define IDS_INVALIDARG						(IDS_BASE_IMSG + 19)
#define IDS_UNKNOWN_FLAGS					(IDS_BASE_IMSG + 20)

#define IDS_BASE_SMTPOPT					(IDS_BASE_IMSG + 21)

#define IDS_ENCODING_TITLE					(IDS_BASE_SMTPOPT + 0)
#define IDS_MESSAGE_ENCODING_TAG			(IDS_BASE_SMTPOPT + 1)


#define IDS_NOT_SUPPORTED					IDS_NO_SUPPORT
#define IDS_STDINVALIDPARAMETER				IDS_INVALID_PARAMETER
#define IDS_STDNOTIMPLEMENTED				IDS_NO_SUPPORT
#define IDS_STDINSUFFICIENTMEMORY			IDS_NOT_ENOUGH_MEMORY
#define IDS_STDNOTSUPPORTED					IDS_NO_SUPPORT
#define IDS_STDINTERNALERROR				IDS_CALL_FAILED

//----------------------------------------------------------
// Non String Defines
//----------------------------------------------------------

/* TNEF */

#define rsidAttachIcon 						451

/* dialog defines */

#define	IDD_ONEOFF_GENERAL_PAGE				600

/* control ids	*/
#define	IDC_STATIC							0xffff
#define	IDC_DISPLAY_NAME					601
#define	IDC_EMAIL_ADDRESS					602
#define	IDC_ADDRTYPE						603
#define IDC_SEND_TNEF						604

#ifdef MSMAPI
#define IDC_SEND_TNEF						604
#endif

// Progress dialog testing

#define IDD_PROGRESS						700
#define IDC_PROGRESS_PERCENT				701
#define IDC_PROGRESS_COUNT					703
#define IDC_PROGRESS_MIN					704
#define IDC_PROGRESS_MAX					705
#define IDC_PROGRESS_FLAGS					706
#define IDC_PROGRESS_FRAME					707

#define	IDD_FQ								800
#define ICO_FQ_MSMAIL						801

#define IDD_FQ_ANIMATED						810
#define AVI_FQ_RSRC							811
#define AVI_FQ_LOCN							812

/* Dialog items */

#define DLG_ChooseProfile			5200			/* dialogs */
#define DLG_Password				5201
#define DLG_UIMutex					5202

#define BMP_MSLogo					5210			/* pictures */
#define EDT_Bitmap					5211
#define ICO_Profile					5212

#define LBL_Password				5220			/* controls */
#define EDT_Password				5221
#define LBL_Profile					5222
#define LBX_Profile					5223
#define CHK_DefProfile				5224
#define CHK_LogonAll				5225
#define CHK_SavePassword			5226
#define GRP_Options					5227
#define PSH_Help					5228
#define PSH_Options					5229
#define LBL_Suitcase				5230
#define LBL_CreateProfile			5231
#define PSH_NewProfile				5232


//Definitions of IDs for Dialog controls.....ids below 400 have been 
//reserved for the Profile Wizard

#define IDD_1					2345
#define IDD_2					2346
#define IDD_CANCEL				(IDCANCEL)
#define IDD_BACK				125
#define IDD_NEXT				126
#define IDD_BITMAP				127
#define GRAPHIC_BITMAP			128

#define IDD_MISC_STATIC_1		150
#define IDD_STATIC_P1_1			151
#define IDD_STATIC_P1_2			152
#define IDD_STATIC_P1_3			153 
#define IDD_P1_RADIOBUT_MSXCHG_YES  154
#define IDD_P1_RADIOBUT_MSXCHG_NO   155

#define IDD_STATIC_P2_1			201   
#define IDD_CTL_P2_1			202
#define IDD_CTL_P2_2			203
#define IDD_CTL_P2_3			204
#define IDD_STATIC_P2_2			205   
				   
#define IDD_STATIC_PPAB			230
#define IDD_EDIT_PPAB_NAME		231
#define IDD_BROWSE_PPAB			232

#define IDD_STATIC_PPST			233
#define IDD_EDIT_PPST_NAME		234
#define IDD_BROWSE_PPST			235

#define IDD_STATIC_STARTUP      236
#define IDD_RADIOBUT_STARTUP_YES  237
#define IDD_RADIOBUT_STARTUP_NO   238

#define IDD_STATIC_P3_1			301  
#define IDD_STATIC_P3_2			302  
#define IDD_CTL_P3_1			303

#define IDD_STATIC_PC_1			321
#define IDD_OK					322
#define IDD_CTL_PC_LB			323

#define IDD_STATIC_PMMF_1		325
#define IDD_STATIC_PMMF_2		326
#define IDD_CTL_PMMF_1			327
#define IDD_CTL_PMMF_NOCONVERT	328
#define IDD_CTL_PMMF_CONVERT	329
#define IDD_CTL_PMMF_PASS		330
#define IDD_STATIC_PMMF_PASS	331
#define IDD_STATIC_PE_1			332
#define IDD_STATIC_PE_2			333
#define IDD_STATIC_PE_3			334
#define IDD_FINISH				335
#define IDD_STATIC_PMMF_3		336
#define IDD_CTL_PMMF_DETAILS	337
#define IDB_GRAPHIC				350

#define IDD_STATIC_DETAILS_1	400
#define IDD_STATIC_DETAILS_2	401
#define IDD_STATIC_DETAILS_3	402

//
//  Per recipient options
//
#define IDD_SMTPOPT_ENCODING	425


#define IDD_SMTPOPT_CARE		426


#define IDD_SMTPOPT_MIME		427
#define IDD_SMTPOPT_NonMIME		428
   
//  If we're in MIME
#define IDD_SMTPOPT_Text		429
#define IDD_SMTPOPT_HTML		430
#define IDD_SMTPOPT_Both		431
   
//  If we're in NonMime
#define IDD_SMTPOPT_BinHex		432

#define IDD_SMTPOPT_Body		433
#define IDD_SMTPOPT_Attach		434

#ifdef MSMAPI
#define	NFS_EDIT				0x0001
#define	NFS_STATIC				0x0002
#define	NFS_LISTCOMBO			0x0004
#define	NFS_BUTTON				0x0008
#define	NFS_ALL					0x0010
#endif

#endif	/* _MAPIXRC_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\mapistub\mapistub\mapiperf.h ===
/*
 -	M A P I P E R F . H
 -
 *	Purpose:
 *		This is the place to define data structures, macros, and functions
 *		used to improve the performance of WMS components.
 *
 *	Copyright Microsoft Corporation, 1993-1994.
 *
 */

#ifndef __MAPIPERF_H__
#define __MAPIPERF_H__
 
/*
 -	SEGMENT()
 -
 *	Purpose:
 *		This macro allows us to control whether code_seg()s get defined
 *		in a source module or not.  Currently, these are only defined on
 *		the Win16 platform.  On Windows 95 and NT this macro expands out to
 *		a #pragma comment(). The usage in a source module is:
 *
 *			#pragma SEGMENT(segment_name)
 *
 *			For Lego, the code_seg should never be used - TF
 */

/* #if defined(WIN16) && !defined(DEBUG)
#define SEGMENT(seg)			code_seg(#seg)
#else */
#define SEGMENT(seg)			comment(user,#seg)
/* #endif */

#if defined(WIN32) && !defined(MAC)
#define SHARED_BEGIN			data_seg(".SHARED")
#define SHARED1_BEGIN			data_seg(".SHARED1")
#define SHARED_END				data_seg()
#define VTBL_BEGIN				data_seg(".VTABLE")
#define VTBL_END				data_seg()
#define DATA1_BEGIN				data_seg(".data1","DATA")
#define DATA2_BEGIN				data_seg(".data2","DATA")
#define DATA3_BEGIN				data_seg(".data3","DATA")
#define DATA_END				data_seg()
#else
#define SHARED_BEGIN			comment(user,".shared")
#define SHARED1_BEGIN			comment(user,".shared1")
#define SHARED_END				comment(user,".shared")
#define VTBL_BEGIN				comment(user,".vtable")
#define VTBL_END				comment(user,".vtable")
#define DATA1_BEGIN				comment(user,".data1")
#define DATA2_BEGIN				comment(user,".data2")
#define DATA3_BEGIN				comment(user,".data3")
#define DATA_END				comment(user,".data end")
#endif

// $MAC - Mac needs 16 bit style memory management

#if defined(WIN32) && !defined(MAC)
#define STACK_ALLOC(Size, Ptr)	( Ptr = _alloca((size_t) Size), Ptr ? S_OK : MAPI_E_NOT_ENOUGH_MEMORY )
#define STACK_FREE(Ptr)
#else
#define STACK_ALLOC(Size, Ptr)	MAPIAllocateBuffer(Size, &Ptr)
#define STACK_FREE(Ptr)			if (Ptr) MAPIFreeBuffer(Ptr)
#endif

#ifndef MPPC
#define FASTCALL	__fastcall
#else
#define FASTCALL
#endif

#define MAPISetBufferNameFn(pv) \
	(!(pv) || !(*((ULONG *)(pv) - 2) & 0x40000000)) ? 0 : \
		(**((int (__cdecl ***)(void *, ...))((ULONG *)(pv) - 3))) \
			((void *)*((ULONG *)pv - 3), (ULONG *)pv - 4,

#if defined(DEBUG) && !defined(DOS)
#define MAPISetBufferName(pv,psz)					MAPISetBufferNameFn(pv) psz)
#define MAPISetBufferName1(pv,psz,a1)				MAPISetBufferNameFn(pv) psz,a1)
#define MAPISetBufferName2(pv,psz,a1,a2)			MAPISetBufferNameFn(pv) psz,a1,a2)
#define MAPISetBufferName3(pv,psz,a1,a2,a3) 		MAPISetBufferNameFn(pv) psz,a1,a2,a3)
#define MAPISetBufferName4(pv,psz,a1,a2,a3,a4) 		MAPISetBufferNameFn(pv) psz,a1,a2,a3,a4)
#define MAPISetBufferName5(pv,psz,a1,a2,a3,a4,a5) 	MAPISetBufferNameFn(pv) psz,a1,a2,a3,a4,a5)
#else
#define MAPISetBufferName(pv,psz)
#define MAPISetBufferName1(pv,psz,a1)
#define MAPISetBufferName2(pv,psz,a1,a2)
#define MAPISetBufferName3(pv,psz,a1,a2,a3)
#define MAPISetBufferName4(pv,psz,a1,a2,a3,a4)
#define MAPISetBufferName5(pv,psz,a1,a2,a3,a4,a5)
#endif

#endif /* __MAPIPERF_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\mapistub\mapistub\mapidefs.h ===
/*
 *	M A P I D E F S . H
 *
 *	Definitions used by MAPI clients and service providers.
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef MAPIDEFS_H
#define MAPIDEFS_H

#if _MSC_VER > 1000
#pragma once
#endif

#if defined (WIN32) && !defined (_WIN32)
#define _WIN32
#endif

#if defined (_WIN32) /* Must include WINDOWS.H on Win32 */
#ifndef _WINDOWS_
#define INC_OLE2 /* Get the OLE2 stuff */
#define INC_RPC  /* harmless on Windows NT; Windows 95 needs it */
#define _INC_OLE /* Windows 95 will include OLE1 without this */
#include <windows.h>
#endif

#ifndef _OLEERROR_H_
#include <winerror.h>
#endif
#ifndef _OBJBASE_H_
#include <objbase.h>
#endif
#endif

#if defined (WIN16) || defined (DOS) || defined (DOS16)
#ifndef _COMPOBJ_H_
#include <compobj.h>
#endif
#endif

#ifndef _INC_STDDEF
#include <stddef.h>
#endif

/* Array dimension for structures with variable-sized arrays at the end. */

#ifndef MAPI_DIM
#define MAPI_DIM	1
#endif

/* Provider init type. Force to cdecl always */

#ifndef STDMAPIINITCALLTYPE
#if !defined (_MAC) && defined (_WIN32)
#define STDMAPIINITCALLTYPE		__cdecl
#else
#define STDMAPIINITCALLTYPE		STDMETHODCALLTYPE
#endif
#define	STDINITMETHODIMP		HRESULT STDMAPIINITCALLTYPE
#define STDINITMETHODIMP_(type)	type STDMAPIINITCALLTYPE
#endif


#define MAPI_NT_SERVICE     ((ULONG) 0x00010000)  /* Provider is being loaded in an NT service */


#ifdef	__cplusplus
extern "C" {
#endif

/* Simple data types */

#if !defined (MIDL_PASS) /* MIDL doesn't want to see these */

#if !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short      WCHAR;
#endif

#ifdef UNICODE
typedef WCHAR				TCHAR;
#else
typedef char				TCHAR;
#endif

typedef WCHAR FAR *			LPWSTR;
typedef const WCHAR FAR *	LPCWSTR;
typedef TCHAR FAR *			LPTSTR;
typedef const TCHAR FAR *	LPCTSTR;
typedef BYTE FAR *			LPBYTE;
#endif /* defined MIDL_PASS */

typedef ULONG FAR *			LPULONG;

#ifndef __LHANDLE
#define __LHANDLE
typedef ULONG_PTR	LHANDLE, FAR * LPLHANDLE;
#endif

#if !defined(_WINBASE_) && !defined(_FILETIME_)
#define _FILETIME_
typedef struct _FILETIME
{
	DWORD dwLowDateTime;
	DWORD dwHighDateTime;
} FILETIME, FAR * LPFILETIME;
#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

/*
 *	This flag is used in many different MAPI calls to signify that
 *	the object opened by the call should be modifiable (MAPI_MODIFY).
 *  If the flag MAPI_MAX_ACCESS is set, the object returned should be
 *  returned at the maximum access level allowed.  An additional
 *  property available on the object (PR_ACCESS_LEVEL) uses the same
 *  MAPI_MODIFY flag to say just what this new access level is.
 */

#define MAPI_MODIFY				((ULONG) 0x00000001)

/*
 *	The following flags are used to indicate to the client what access
 *	level is permissible in the object. They appear in PR_ACCESS in
 *	message and folder objects as well as in contents and associated
 *	contents tables
 */

#define	MAPI_ACCESS_MODIFY					((ULONG) 0x00000001)
#define	MAPI_ACCESS_READ					((ULONG) 0x00000002)
#define	MAPI_ACCESS_DELETE					((ULONG) 0x00000004)
#define	MAPI_ACCESS_CREATE_HIERARCHY		((ULONG) 0x00000008)
#define	MAPI_ACCESS_CREATE_CONTENTS			((ULONG) 0x00000010)
#define	MAPI_ACCESS_CREATE_ASSOCIATED		((ULONG) 0x00000020)

/*
 *	The MAPI_UNICODE flag is used in many different MAPI calls to signify
 *	that strings passed through the interface are in Unicode (a 16-bit
 *	character set). The default is an 8-bit character set.
 *
 *	The value fMapiUnicode can be used as the 'normal' value for
 *	that bit, given the application's default character set.
 */

#define MAPI_UNICODE			((ULONG) 0x80000000)

#ifdef UNICODE
#define fMapiUnicode			MAPI_UNICODE
#else
#define fMapiUnicode			0
#endif

/* successful HRESULT */
#define hrSuccess				0



/* Recipient types */
#ifndef MAPI_ORIG				/* also defined in mapi.h */
#define MAPI_ORIG   0           /* Recipient is message originator          */
#define MAPI_TO     1           /* Recipient is a primary recipient         */
#define MAPI_CC     2           /* Recipient is a copy recipient            */
#define MAPI_BCC    3           /* Recipient is blind copy recipient        */
#define MAPI_P1		0x10000000	/* Recipient is a P1 resend recipient       */
#define MAPI_SUBMITTED 0x80000000 /* Recipient is already processed         */
/* #define MAPI_AUTHORIZE 4		   recipient is a CMC authorizing user		*/
/*#define MAPI_DISCRETE 0x10000000 Recipient is a P1 resend recipient       */
#endif

/* Bit definitions for abFlags[0] of ENTRYID */
#define MAPI_SHORTTERM			0x80
#define MAPI_NOTRECIP			0x40
#define MAPI_THISSESSION		0x20
#define MAPI_NOW				0x10
#define MAPI_NOTRESERVED		0x08

/* Bit definitions for abFlags[1] of ENTRYID */
#define MAPI_COMPOUND			0x80

/* ENTRYID */
typedef struct
{
	BYTE	abFlags[4];
	BYTE	ab[MAPI_DIM];
} ENTRYID, FAR *LPENTRYID;

#define CbNewENTRYID(_cb)		(offsetof(ENTRYID,ab) + (_cb))
#define CbENTRYID(_cb)			(offsetof(ENTRYID,ab) + (_cb))
#define SizedENTRYID(_cb, _name) \
	struct _ENTRYID_ ## _name \
{ \
	BYTE	abFlags[4]; \
	BYTE	ab[_cb]; \
} _name

/* Byte-order-independent version of GUID (world-unique identifier) */
typedef struct _MAPIUID
{
	BYTE ab[16];
} MAPIUID, FAR * LPMAPIUID;

/* Note:  need to include C run-times (memory.h) to use this macro */

#define IsEqualMAPIUID(lpuid1, lpuid2)	(!memcmp(lpuid1, lpuid2, sizeof(MAPIUID)))

/*
 * Constants for one-off entry ID:
 * The MAPIUID that identifies the one-off provider;
 * the flag that defines whether the embedded strings are Unicode;
 * the flag that specifies whether the recipient gets TNEF or not.
 */

#define MAPI_ONE_OFF_UID { 0x81, 0x2b, 0x1f, 0xa4, 0xbe, 0xa3, 0x10, 0x19, \
						   0x9d, 0x6e, 0x00, 0xdd, 0x01, 0x0f, 0x54, 0x02 }
#define MAPI_ONE_OFF_UNICODE		0x8000
#define MAPI_ONE_OFF_NO_RICH_INFO	0x0001

/* Object type */

#define MAPI_STORE		((ULONG) 0x00000001)	/* Message Store */
#define MAPI_ADDRBOOK	((ULONG) 0x00000002)	/* Address Book */
#define MAPI_FOLDER		((ULONG) 0x00000003)	/* Folder */
#define MAPI_ABCONT		((ULONG) 0x00000004)	/* Address Book Container */
#define MAPI_MESSAGE	((ULONG) 0x00000005)	/* Message */
#define MAPI_MAILUSER	((ULONG) 0x00000006)	/* Individual Recipient */
#define MAPI_ATTACH		((ULONG) 0x00000007)	/* Attachment */
#define MAPI_DISTLIST	((ULONG) 0x00000008)	/* Distribution List Recipient */
#define MAPI_PROFSECT	((ULONG) 0x00000009)	/* Profile Section */
#define MAPI_STATUS		((ULONG) 0x0000000A)	/* Status Object */
#define MAPI_SESSION	((ULONG) 0x0000000B)	/* Session */
#define MAPI_FORMINFO	((ULONG) 0x0000000C)	/* Form Information */


/*
 *	Maximum length of profile names and passwords, not including
 *	the null termination character.
 */
#ifndef cchProfileNameMax
#define cchProfileNameMax	64
#define cchProfilePassMax	64
#endif


/* Property Types */

#define MV_FLAG			0x1000			/* Multi-value flag */

#define PT_UNSPECIFIED	((ULONG)  0)	/* (Reserved for interface use) type doesn't matter to caller */
#define PT_NULL			((ULONG)  1)	/* NULL property value */
#define	PT_I2			((ULONG)  2)	/* Signed 16-bit value */
#define PT_LONG			((ULONG)  3)	/* Signed 32-bit value */
#define	PT_R4			((ULONG)  4)	/* 4-byte floating point */
#define PT_DOUBLE		((ULONG)  5)	/* Floating point double */
#define PT_CURRENCY		((ULONG)  6)	/* Signed 64-bit int (decimal w/	4 digits right of decimal pt) */
#define	PT_APPTIME		((ULONG)  7)	/* Application time */
#define PT_ERROR		((ULONG) 10)	/* 32-bit error value */
#define PT_BOOLEAN		((ULONG) 11)	/* 16-bit boolean (non-zero true) */
#define PT_OBJECT		((ULONG) 13)	/* Embedded object in a property */
#define	PT_I8			((ULONG) 20)	/* 8-byte signed integer */
#define PT_STRING8		((ULONG) 30)	/* Null terminated 8-bit character string */
#define PT_UNICODE		((ULONG) 31)	/* Null terminated Unicode string */
#define PT_SYSTIME		((ULONG) 64)	/* FILETIME 64-bit int w/ number of 100ns periods since Jan 1,1601 */
#define	PT_CLSID		((ULONG) 72)	/* OLE GUID */
#define PT_BINARY		((ULONG) 258)	/* Uninterpreted (counted byte array) */
/* Changes are likely to these numbers, and to their structures. */

/* Alternate property type names for ease of use */
#define	PT_SHORT	PT_I2
#define	PT_I4		PT_LONG
#define	PT_FLOAT	PT_R4
#define	PT_R8		PT_DOUBLE
#define	PT_LONGLONG	PT_I8

/*
 *	The type of a MAPI-defined string property is indirected, so
 *	that it defaults to Unicode string on a Unicode platform and to
 *	String8 on an ANSI or DBCS platform.
 *
 *	Macros are defined here both for the property type, and for the
 *	field of the property value structure which should be
 *	dereferenced to obtain the string pointer.
 */

#ifdef	UNICODE
#define PT_TSTRING			PT_UNICODE
#define PT_MV_TSTRING		(MV_FLAG|PT_UNICODE)
#define LPSZ				lpszW
#define	LPPSZ				lppszW
#define MVSZ				MVszW
#else
#define PT_TSTRING			PT_STRING8
#define PT_MV_TSTRING		(MV_FLAG|PT_STRING8)
#define LPSZ				lpszA
#define	LPPSZ				lppszA
#define MVSZ				MVszA
#endif


/* Property Tags
 *
 * By convention, MAPI never uses 0 or FFFF as a property ID.
 * Use as null values, initializers, sentinels, or what have you.
 */

#define PROP_TYPE_MASK			((ULONG)0x0000FFFF)	/* Mask for Property type */
#define PROP_TYPE(ulPropTag)	(((ULONG)(ulPropTag))&PROP_TYPE_MASK)
#define PROP_ID(ulPropTag)		(((ULONG)(ulPropTag))>>16)
#define PROP_TAG(ulPropType,ulPropID)	((((ULONG)(ulPropID))<<16)|((ULONG)(ulPropType)))
#define PROP_ID_NULL			0
#define PROP_ID_INVALID			0xFFFF
#define PR_NULL					PROP_TAG( PT_NULL, PROP_ID_NULL)
#define CHANGE_PROP_TYPE(ulPropTag, ulPropType)	\
						(((ULONG)0xFFFF0000 & ulPropTag) | ulPropType)


/* Multi-valued Property Types */

#define	PT_MV_I2		(MV_FLAG|PT_I2)
#define PT_MV_LONG		(MV_FLAG|PT_LONG)
#define	PT_MV_R4		(MV_FLAG|PT_R4)
#define PT_MV_DOUBLE	(MV_FLAG|PT_DOUBLE)
#define PT_MV_CURRENCY	(MV_FLAG|PT_CURRENCY)
#define	PT_MV_APPTIME	(MV_FLAG|PT_APPTIME)
#define PT_MV_SYSTIME	(MV_FLAG|PT_SYSTIME)
#define PT_MV_STRING8	(MV_FLAG|PT_STRING8)
#define PT_MV_BINARY	(MV_FLAG|PT_BINARY)
#define PT_MV_UNICODE	(MV_FLAG|PT_UNICODE)
#define	PT_MV_CLSID		(MV_FLAG|PT_CLSID)
#define PT_MV_I8		(MV_FLAG|PT_I8)

/* Alternate property type names for ease of use */
#define	PT_MV_SHORT		PT_MV_I2
#define	PT_MV_I4		PT_MV_LONG
#define	PT_MV_FLOAT		PT_MV_R4
#define	PT_MV_R8		PT_MV_DOUBLE
#define	PT_MV_LONGLONG	PT_MV_I8

/*
 *	Property type reserved bits
 *
 *	MV_INSTANCE is used as a flag in table operations to request
 *	that a multi-valued property be presented as a single-valued
 *	property appearing in multiple rows.
 */

#define MV_INSTANCE		0x2000
#define MVI_FLAG		(MV_FLAG | MV_INSTANCE)
#define MVI_PROP(tag)	((tag) | MVI_FLAG)

/* --------------- */
/* Data Structures */
/* --------------- */

/* Property Tag Array */

typedef struct _SPropTagArray
{
	ULONG	cValues;
	ULONG	aulPropTag[MAPI_DIM];
} SPropTagArray, FAR * LPSPropTagArray;

#define CbNewSPropTagArray(_ctag) \
	(offsetof(SPropTagArray,aulPropTag) + (_ctag)*sizeof(ULONG))
#define CbSPropTagArray(_lparray) \
	(offsetof(SPropTagArray,aulPropTag) + \
	(UINT)((_lparray)->cValues)*sizeof(ULONG))
/*	SPropTagArray */
#define SizedSPropTagArray(_ctag, _name) \
struct _SPropTagArray_ ## _name \
{ \
	ULONG	cValues; \
	ULONG	aulPropTag[_ctag]; \
} _name

/* -------------- */
/* Property Value */
/* -------------- */

typedef struct _SPropValue	SPropValue;


/* 32-bit CURRENCY definition stolen from oaidl.h */
/* 16-bit CURRENCY definition stolen from variant.h */

#ifndef _tagCY_DEFINED
#define _tagCY_DEFINED
#define _CY_DEFINED
#if (defined (WIN16) || defined (DOS)) && !defined (_VARIANT_H_)
typedef struct FARSTRUCT tagCY {
#ifdef _MAC
        long      Hi;
        long Lo;
#else
        unsigned long Lo;
        long      Hi;
#endif
} CY;
#elif defined (_WIN32)
/* real definition that makes the C++ compiler happy */
typedef union tagCY {
    struct {
#ifdef _MAC
        long      Hi;
        long Lo;
#else
        unsigned long Lo;
        long      Hi;
#endif
    };
    LONGLONG int64;
} CY;
#endif /* 16-bit vs 32-bit definition */
#endif
			/* size is 8 */
typedef CY CURRENCY;

typedef struct _SBinary
{
	ULONG		cb;
	LPBYTE 		lpb;
} SBinary, FAR *LPSBinary;

typedef	struct _SShortArray
{
	ULONG		cValues;
	short int	FAR *lpi;
} SShortArray;

typedef struct _SGuidArray
{
	ULONG		cValues;
	GUID		FAR *lpguid;
} SGuidArray;

typedef	struct _SRealArray
{
	ULONG		cValues;
	float		FAR *lpflt;
} SRealArray;

typedef struct _SLongArray
{
	ULONG		cValues;
	LONG 		FAR *lpl;
} SLongArray;

typedef struct _SLargeIntegerArray
{
	ULONG		cValues;
	LARGE_INTEGER	FAR *lpli;
} SLargeIntegerArray;

typedef struct _SDateTimeArray
{
	ULONG		cValues;
	FILETIME	FAR *lpft;
} SDateTimeArray;

typedef struct _SAppTimeArray
{
	ULONG		cValues;
	double		FAR *lpat;
} SAppTimeArray;

typedef struct _SCurrencyArray
{
	ULONG		cValues;
	CURRENCY	FAR *lpcur;
} SCurrencyArray;

typedef struct _SBinaryArray
{
	ULONG		cValues;
	SBinary		FAR *lpbin;
} SBinaryArray;

typedef struct _SDoubleArray
{
	ULONG		cValues;
	double		FAR *lpdbl;
} SDoubleArray;

typedef struct _SWStringArray
{
	ULONG		cValues;
	LPWSTR		FAR *lppszW;
} SWStringArray;

typedef struct _SLPSTRArray
{
	ULONG		cValues;
	LPSTR		FAR *lppszA;
} SLPSTRArray;

typedef union _PV
{
	short int			i;			/* case PT_I2 */
	LONG				l;			/* case PT_LONG */
	ULONG				ul;			/* alias for PT_LONG */
	float				flt;		/* case PT_R4 */
	double				dbl;		/* case PT_DOUBLE */
	unsigned short int	b;			/* case PT_BOOLEAN */
	CURRENCY			cur;		/* case PT_CURRENCY */
	double				at;			/* case PT_APPTIME */
	FILETIME			ft;			/* case PT_SYSTIME */
	LPSTR				lpszA;		/* case PT_STRING8 */
	SBinary				bin;		/* case PT_BINARY */
	LPWSTR				lpszW;		/* case PT_UNICODE */
	LPGUID				lpguid;		/* case PT_CLSID */
	LARGE_INTEGER		li;			/* case PT_I8 */
	SShortArray			MVi;		/* case PT_MV_I2 */
	SLongArray			MVl;		/* case PT_MV_LONG */
	SRealArray			MVflt;		/* case PT_MV_R4 */
	SDoubleArray		MVdbl;		/* case PT_MV_DOUBLE */
	SCurrencyArray		MVcur;		/* case PT_MV_CURRENCY */
	SAppTimeArray		MVat;		/* case PT_MV_APPTIME */
	SDateTimeArray		MVft;		/* case PT_MV_SYSTIME */
	SBinaryArray		MVbin;		/* case PT_MV_BINARY */
	SLPSTRArray			MVszA;		/* case PT_MV_STRING8 */
	SWStringArray		MVszW;		/* case PT_MV_UNICODE */
	SGuidArray			MVguid;		/* case PT_MV_CLSID */
	SLargeIntegerArray	MVli;		/* case PT_MV_I8 */
	SCODE				err;		/* case PT_ERROR */
	LONG				x;			/* case PT_NULL, PT_OBJECT (no usable value) */
} __UPV;

typedef struct _SPropValue
{
	ULONG		ulPropTag;
	ULONG		dwAlignPad;
	union _PV	Value;
} SPropValue, FAR * LPSPropValue;


/* --------------------------------------------- */
/* Property Problem and Property Problem Arrays */
/* --------------------------------------------- */

typedef struct _SPropProblem
{
	ULONG	ulIndex;
	ULONG	ulPropTag;
	SCODE	scode;
} SPropProblem, FAR * LPSPropProblem;

typedef struct _SPropProblemArray
{
	ULONG			cProblem;
	SPropProblem	aProblem[MAPI_DIM];
} SPropProblemArray, FAR * LPSPropProblemArray;

#define CbNewSPropProblemArray(_cprob) \
	(offsetof(SPropProblemArray,aProblem) + (_cprob)*sizeof(SPropProblem))
#define CbSPropProblemArray(_lparray) \
	(offsetof(SPropProblemArray,aProblem) + \
	(UINT) ((_lparray)->cProblem*sizeof(SPropProblem)))
#define SizedSPropProblemArray(_cprob, _name) \
struct _SPropProblemArray_ ## _name \
{ \
	ULONG			cProblem; \
	SPropProblem	aProblem[_cprob]; \
} _name

/*
 *	ENTRYLIST
 */

typedef SBinaryArray ENTRYLIST, FAR *LPENTRYLIST;

/*
 *	FLATENTRYLIST
 *	MTSID
 *	FLATMTSIDLIST
 */

typedef struct {
	ULONG cb;
	BYTE abEntry[MAPI_DIM];
} FLATENTRY, FAR *LPFLATENTRY;

typedef struct {
	ULONG		cEntries;
	ULONG		cbEntries;
	BYTE		abEntries[MAPI_DIM];
} FLATENTRYLIST, FAR *LPFLATENTRYLIST;

typedef struct {
	ULONG		cb;
	BYTE		ab[MAPI_DIM];
} MTSID, FAR *LPMTSID;

typedef struct {
	ULONG		cMTSIDs;
	ULONG		cbMTSIDs;
	BYTE		abMTSIDs[MAPI_DIM];
} FLATMTSIDLIST, FAR *LPFLATMTSIDLIST;

#define CbNewFLATENTRY(_cb)		(offsetof(FLATENTRY,abEntry) + (_cb))
#define CbFLATENTRY(_lpentry)	(offsetof(FLATENTRY,abEntry) + (_lpentry)->cb)
#define CbNewFLATENTRYLIST(_cb)	(offsetof(FLATENTRYLIST,abEntries) + (_cb))
#define CbFLATENTRYLIST(_lplist) (offsetof(FLATENTRYLIST,abEntries) + (_lplist)->cbEntries)
#define CbNewMTSID(_cb)			(offsetof(MTSID,ab) + (_cb))
#define CbMTSID(_lpentry)		(offsetof(MTSID,ab) + (_lpentry)->cb)
#define CbNewFLATMTSIDLIST(_cb)	(offsetof(FLATMTSIDLIST,abMTSIDs) + (_cb))
#define CbFLATMTSIDLIST(_lplist) (offsetof(FLATMTSIDLIST,abMTSIDs) + (_lplist)->cbMTSIDs)
/* No SizedXXX macros for these types. */

/* ------------------------------ */
/* ADRENTRY, ADRLIST */

typedef struct _ADRENTRY
{
	ULONG			ulReserved1;	/* Never used */
	ULONG			cValues;
	LPSPropValue	rgPropVals;
} ADRENTRY, FAR * LPADRENTRY;

typedef struct _ADRLIST
{
	ULONG			cEntries;
	ADRENTRY		aEntries[MAPI_DIM];
} ADRLIST, FAR * LPADRLIST;

#define CbNewADRLIST(_centries) \
	(offsetof(ADRLIST,aEntries) + (_centries)*sizeof(ADRENTRY))
#define CbADRLIST(_lpadrlist) \
	(offsetof(ADRLIST,aEntries) + (UINT)(_lpadrlist)->cEntries*sizeof(ADRENTRY))
#define SizedADRLIST(_centries, _name) \
struct _ADRLIST_ ## _name \
{ \
	ULONG			cEntries; \
	ADRENTRY		aEntries[_centries]; \
} _name

/* ------------------------------ */
/* SRow, SRowSet */

typedef struct _SRow
{
	ULONG			ulAdrEntryPad;	/* Pad so SRow's can map to ADRENTRY's */
	ULONG			cValues;		/* Count of property values */
	LPSPropValue	lpProps;		/* Property value array */
} SRow, FAR * LPSRow;

typedef struct _SRowSet
{
	ULONG			cRows;			/* Count of rows */
	SRow			aRow[MAPI_DIM];	/* Array of rows */
} SRowSet, FAR * LPSRowSet;

#define CbNewSRowSet(_crow)		(offsetof(SRowSet,aRow) + (_crow)*sizeof(SRow))
#define CbSRowSet(_lprowset)	(offsetof(SRowSet,aRow) + \
									(UINT)((_lprowset)->cRows*sizeof(SRow)))
#define SizedSRowSet(_crow, _name) \
struct _SRowSet_ ## _name \
{ \
	ULONG			cRows; \
	SRow			aRow[_crow]; \
} _name

/* MAPI Allocation Routines ------------------------------------------------ */

typedef SCODE (STDMETHODCALLTYPE ALLOCATEBUFFER)(
	ULONG			cbSize,
	LPVOID FAR *	lppBuffer
);

typedef SCODE (STDMETHODCALLTYPE ALLOCATEMORE)(
	ULONG			cbSize,
	LPVOID			lpObject,
	LPVOID FAR *	lppBuffer
);

typedef ULONG (STDAPICALLTYPE FREEBUFFER)(
	LPVOID			lpBuffer
);

typedef ALLOCATEBUFFER FAR *LPALLOCATEBUFFER;
typedef ALLOCATEMORE FAR *	LPALLOCATEMORE;
typedef FREEBUFFER FAR *	LPFREEBUFFER;

/* MAPI Component Object Model Macros -------------------------------------- */

#if defined(MAPI_IF) && (!defined(__cplusplus) || defined(CINTERFACE))
#define DECLARE_MAPI_INTERFACE(iface)                                   \
		typedef struct iface##Vtbl iface##Vtbl, FAR * iface;			\
		struct iface##Vtbl
#define DECLARE_MAPI_INTERFACE_(iface, baseiface)                       \
		DECLARE_MAPI_INTERFACE(iface)
#define DECLARE_MAPI_INTERFACE_PTR(iface, piface)                       \
		typedef struct iface##Vtbl iface##Vtbl, FAR * iface, FAR * FAR * piface;
#else
#define DECLARE_MAPI_INTERFACE(iface)                                   \
		DECLARE_INTERFACE(iface)
#define DECLARE_MAPI_INTERFACE_(iface, baseiface)                       \
		DECLARE_INTERFACE_(iface, baseiface)
#ifdef __cplusplus
#define DECLARE_MAPI_INTERFACE_PTR(iface, piface)                       \
		interface iface; typedef iface FAR * piface
#else
#define DECLARE_MAPI_INTERFACE_PTR(iface, piface)                       \
		typedef interface iface iface, FAR * piface
#endif
#endif

#define MAPIMETHOD(method)				MAPIMETHOD_(HRESULT, method)
#define MAPIMETHOD_(type, method)		STDMETHOD_(type, method)
#define MAPIMETHOD_DECLARE(type, method, prefix) \
		STDMETHODIMP_(type) prefix##method
#define MAPIMETHOD_TYPEDEF(type, method, prefix) \
		typedef type (STDMETHODCALLTYPE prefix##method##_METHOD)

#define MAPI_IUNKNOWN_METHODS(IPURE)									\
	MAPIMETHOD(QueryInterface)											\
		(THIS_ REFIID riid, LPVOID FAR * ppvObj) IPURE;					\
	MAPIMETHOD_(ULONG,AddRef)  (THIS) IPURE;							\
	MAPIMETHOD_(ULONG,Release) (THIS) IPURE;							\

#undef	IMPL
#define IMPL

/* Pointers to MAPI Interfaces --------------------------------------------- */

typedef const IID FAR * LPCIID;

DECLARE_MAPI_INTERFACE_PTR(IMsgStore,		LPMDB);
DECLARE_MAPI_INTERFACE_PTR(IMAPIFolder,		LPMAPIFOLDER);
DECLARE_MAPI_INTERFACE_PTR(IMessage,		LPMESSAGE);
DECLARE_MAPI_INTERFACE_PTR(IAttach,			LPATTACH);
DECLARE_MAPI_INTERFACE_PTR(IAddrBook,		LPADRBOOK);
DECLARE_MAPI_INTERFACE_PTR(IABContainer,	LPABCONT);
DECLARE_MAPI_INTERFACE_PTR(IMailUser,		LPMAILUSER);
DECLARE_MAPI_INTERFACE_PTR(IDistList,		LPDISTLIST);
DECLARE_MAPI_INTERFACE_PTR(IMAPIStatus,		LPMAPISTATUS);
DECLARE_MAPI_INTERFACE_PTR(IMAPITable,		LPMAPITABLE);
DECLARE_MAPI_INTERFACE_PTR(IProfSect,		LPPROFSECT);
DECLARE_MAPI_INTERFACE_PTR(IMAPIProp,		LPMAPIPROP);
DECLARE_MAPI_INTERFACE_PTR(IMAPIContainer,	LPMAPICONTAINER);
DECLARE_MAPI_INTERFACE_PTR(IMAPIAdviseSink, LPMAPIADVISESINK);
DECLARE_MAPI_INTERFACE_PTR(IMAPIProgress,	LPMAPIPROGRESS);
DECLARE_MAPI_INTERFACE_PTR(IProviderAdmin,	LPPROVIDERADMIN);

/* Extended MAPI Error Information ----------------------------------------- */

typedef struct _MAPIERROR
{
	ULONG	ulVersion;
	LPTSTR	lpszError;
	LPTSTR	lpszComponent;
	ULONG	ulLowLevelError;
	ULONG	ulContext;

} MAPIERROR, FAR * LPMAPIERROR;


/* IMAPIAdviseSink Interface ----------------------------------------------- */

/*
 *	Notification event types. The event types can be combined in a bitmask
 *	for filtering. Each one has a parameter structure associated with it:
 *
 *		fnevCriticalError		ERROR_NOTIFICATION
 *		fnevNewMail				NEWMAIL_NOTIFICATION
 *		fnevObjectCreated		OBJECT_NOTIFICATION
 *		fnevObjectDeleted		OBJECT_NOTIFICATION
 *		fnevObjectModified		OBJECT_NOTIFICATION
 *		fnevObjectCopied		OBJECT_NOTIFICATION
 *		fnevSearchComplete		OBJECT_NOTIFICATION
 *		fnevTableModified		TABLE_NOTIFICATION
 *		fnevStatusObjectModified ?
 *
 *		fnevExtended			EXTENDED_NOTIFICATION
 */

#define fnevCriticalError			((ULONG) 0x00000001)
#define fnevNewMail					((ULONG) 0x00000002)
#define fnevObjectCreated			((ULONG) 0x00000004)
#define fnevObjectDeleted			((ULONG) 0x00000008)
#define fnevObjectModified			((ULONG) 0x00000010)
#define fnevObjectMoved				((ULONG) 0x00000020)
#define fnevObjectCopied			((ULONG) 0x00000040)
#define fnevSearchComplete			((ULONG) 0x00000080)
#define fnevTableModified			((ULONG) 0x00000100)
#define	fnevStatusObjectModified	((ULONG) 0x00000200)
#define	fnevReservedForMapi			((ULONG) 0x40000000)
#define fnevExtended				((ULONG) 0x80000000)

/* TABLE_NOTIFICATION event types passed in ulTableEvent */

#define TABLE_CHANGED		1
#define	TABLE_ERROR			2
#define	TABLE_ROW_ADDED		3
#define	TABLE_ROW_DELETED	4
#define	TABLE_ROW_MODIFIED	5
#define	TABLE_SORT_DONE		6
#define	TABLE_RESTRICT_DONE	7
#define	TABLE_SETCOL_DONE	8
#define TABLE_RELOAD		9

/* Event Structures */

typedef struct _ERROR_NOTIFICATION
{
	ULONG		cbEntryID;
	LPENTRYID	lpEntryID;
	SCODE		scode;
	ULONG		ulFlags;			/* 0 or MAPI_UNICODE */
	LPMAPIERROR	lpMAPIError;		/* Detailed error information */
} ERROR_NOTIFICATION;

typedef struct _NEWMAIL_NOTIFICATION
{
	ULONG		cbEntryID;
	LPENTRYID	lpEntryID;			/* identifies the new message */
	ULONG		cbParentID;
	LPENTRYID	lpParentID;			/* identifies the folder it lives in */
	ULONG		ulFlags;			/* 0 or MAPI_UNICODE */
	LPTSTR		lpszMessageClass;	/* message class (UNICODE or string8) */
	ULONG		ulMessageFlags;		/* copy of PR_MESSAGE_FLAGS */
} NEWMAIL_NOTIFICATION;

typedef struct _OBJECT_NOTIFICATION
{
	ULONG				cbEntryID;
	LPENTRYID			lpEntryID;		/* EntryID of object */
	ULONG				ulObjType;		/* Type of object */
	ULONG				cbParentID;
	LPENTRYID			lpParentID;		/* EntryID of parent object */
	ULONG				cbOldID;
	LPENTRYID			lpOldID;		/* EntryID of old object */
	ULONG				cbOldParentID;
	LPENTRYID			lpOldParentID;	/* EntryID of old parent */
	LPSPropTagArray		lpPropTagArray;
} OBJECT_NOTIFICATION;

typedef struct _TABLE_NOTIFICATION
{
	ULONG				ulTableEvent;	/* Identifies WHICH table event */
	HRESULT				hResult;		/* Value for TABLE_ERROR */
	SPropValue			propIndex;		/* This row's "index property" */
	SPropValue			propPrior;		/* Preceding row's "index property" */
	SRow				row;			/* New data of added/modified row */
	ULONG				ulPad;			/* Force to 8-byte boundary */
} TABLE_NOTIFICATION;

typedef struct _EXTENDED_NOTIFICATION
{
	ULONG		ulEvent;					/* extended event code */
	ULONG		cb;							/* size of event parameters */
	LPBYTE		pbEventParameters;			/* event parameters */
} EXTENDED_NOTIFICATION;

typedef struct
{
	ULONG			cbEntryID;
	LPENTRYID		lpEntryID;
	ULONG			cValues;
	LPSPropValue	lpPropVals;
} STATUS_OBJECT_NOTIFICATION;

typedef struct _NOTIFICATION
{
	ULONG	ulEventType;		/* notification type, i.e. fnevSomething */
	ULONG	ulAlignPad;			/* Force to 8-byte boundary */
	union
	{
		ERROR_NOTIFICATION			err;
		NEWMAIL_NOTIFICATION		newmail;
		OBJECT_NOTIFICATION			obj;
		TABLE_NOTIFICATION			tab;
		EXTENDED_NOTIFICATION		ext;
		STATUS_OBJECT_NOTIFICATION	statobj;
	} info;
} NOTIFICATION, FAR * LPNOTIFICATION;


/* Interface used for registering and issuing notification callbacks. */

#define MAPI_IMAPIADVISESINK_METHODS(IPURE)								\
	MAPIMETHOD_(ULONG, OnNotify)										\
		(THIS_	ULONG						cNotif,						\
				LPNOTIFICATION				lpNotifications) IPURE;		\

#undef		 INTERFACE
#define		 INTERFACE  IMAPIAdviseSink
DECLARE_MAPI_INTERFACE_(IMAPIAdviseSink, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIADVISESINK_METHODS(PURE)
};

/* Callback function type for MAPIAllocAdviseSink */

typedef long (STDAPICALLTYPE NOTIFCALLBACK) (
	LPVOID			lpvContext,
	ULONG			cNotification,
	LPNOTIFICATION	lpNotifications);
typedef NOTIFCALLBACK FAR * LPNOTIFCALLBACK;

/*
 *	Message name for the 16-bit MAPI notififcation engine.
 *	This can be used in 16-bit applications to force processing
 *	of notification callbacks.
 */

#define szMAPINotificationMsg "MAPI Notify window message"


/* IMAPIProgress Interface ------------------------------------------------- */

/* Flag values for the progress indicator */

#define MAPI_TOP_LEVEL		((ULONG) 0x00000001)

#define MAPI_IMAPIPROGRESS_METHODS(IPURE)								\
	MAPIMETHOD(Progress)												\
		(THIS_	ULONG						ulValue,					\
				ULONG						ulCount,					\
				ULONG						ulTotal) IPURE;				\
	MAPIMETHOD(GetFlags)												\
		(THIS_	ULONG FAR *					lpulFlags) IPURE;			\
	MAPIMETHOD(GetMax)													\
		(THIS_	ULONG FAR *					lpulMax) IPURE;				\
	MAPIMETHOD(GetMin)													\
		(THIS_	ULONG FAR *					lpulMin) IPURE;				\
	MAPIMETHOD(SetLimits)												\
		(THIS_	LPULONG						lpulMin,					\
				LPULONG						lpulMax,					\
				LPULONG						lpulFlags) IPURE;			\

#undef		INTERFACE
#define		INTERFACE	IMAPIProgress
DECLARE_MAPI_INTERFACE_(IMAPIProgress, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROGRESS_METHODS(PURE)
};


/* IMAPIProp Interface ----------------------------------------------------- */

/* GetLastError */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/*
 *  Version:
 */
#define MAPI_ERROR_VERSION		0x00000000L

/* GetPropList */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* GetProps */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* SaveChanges */

#define KEEP_OPEN_READONLY		((ULONG) 0x00000001)
#define KEEP_OPEN_READWRITE		((ULONG) 0x00000002)
#define FORCE_SAVE				((ULONG) 0x00000004)
/* define MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */

/* OpenProperty  - ulFlags */
/******	MAPI_MODIFY				((ULONG) 0x00000001) above */
#define	MAPI_CREATE				((ULONG) 0x00000002)
#define STREAM_APPEND			((ULONG) 0x00000004)
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */

/* OpenProperty  - ulInterfaceOptions, IID_IMAPITable */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* CopyTo, CopyProps */

#define MAPI_MOVE				((ULONG) 0x00000001)
#define MAPI_NOREPLACE			((ULONG) 0x00000002)
#define MAPI_DECLINE_OK			((ULONG) 0x00000004)

#ifndef MAPI_DIALOG				/* also defined in mapi.h */
#define MAPI_DIALOG				((ULONG) 0x00000008)
#endif

#ifndef MAPI_USE_DEFAULT		/* also defined in mapi.h */
#define MAPI_USE_DEFAULT		0x00000040	/* Use default profile in logon */
#endif

/* Flags used in GetIDsFromNames  */
/******	MAPI_CREATE				((ULONG) 0x00000002) above */

/* Flags used in GetNamesFromIDs  (bit fields) */
#define MAPI_NO_STRINGS			((ULONG) 0x00000001)
#define MAPI_NO_IDS				((ULONG) 0x00000002)

/*  Union discriminator  */
#define MNID_ID					0
#define MNID_STRING				1
typedef struct _MAPINAMEID
{
	LPGUID lpguid;
	ULONG ulKind;
	union {
		LONG lID;
		LPWSTR lpwstrName;
	} Kind;

} MAPINAMEID, FAR * LPMAPINAMEID;

#define MAPI_IMAPIPROP_METHODS(IPURE)									\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(SaveChanges)												\
		(THIS_ ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(GetProps)												\
		(THIS_	LPSPropTagArray				lpPropTagArray,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcValues,					\
				LPSPropValue FAR *			lppPropArray) IPURE;		\
	MAPIMETHOD(GetPropList)												\
		(THIS_	ULONG						ulFlags,					\
				LPSPropTagArray FAR *		lppPropTagArray) IPURE;		\
	MAPIMETHOD(OpenProperty)											\
		(THIS_	ULONG						ulPropTag,					\
				LPCIID						lpiid,						\
				ULONG						ulInterfaceOptions,			\
				ULONG						ulFlags,					\
				LPUNKNOWN FAR *				lppUnk) IPURE;				\
	MAPIMETHOD(SetProps)												\
		(THIS_	ULONG						cValues,					\
				LPSPropValue				lpPropArray,				\
				LPSPropProblemArray FAR *	lppProblems) IPURE;			\
	MAPIMETHOD(DeleteProps)												\
		(THIS_	LPSPropTagArray				lpPropTagArray,				\
				LPSPropProblemArray FAR *	lppProblems) IPURE;			\
	MAPIMETHOD(CopyTo)													\
		(THIS_	ULONG						ciidExclude,				\
				LPCIID						rgiidExclude,				\
				LPSPropTagArray				lpExcludeProps,				\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS 				lpProgress,					\
				LPCIID						lpInterface,				\
				LPVOID						lpDestObj,					\
				ULONG						ulFlags,					\
				LPSPropProblemArray FAR *	lppProblems) IPURE;			\
	MAPIMETHOD(CopyProps)												\
		(THIS_	LPSPropTagArray				lpIncludeProps,				\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS 				lpProgress,					\
				LPCIID						lpInterface,				\
				LPVOID						lpDestObj,					\
				ULONG						ulFlags,					\
				LPSPropProblemArray FAR *	lppProblems) IPURE;			\
	MAPIMETHOD(GetNamesFromIDs)											\
		(THIS_	LPSPropTagArray FAR *		lppPropTags,				\
				LPGUID						lpPropSetGuid,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcPropNames,				\
				LPMAPINAMEID FAR * FAR *	lpppPropNames) IPURE;		\
	MAPIMETHOD(GetIDsFromNames)											\
		(THIS_	ULONG						cPropNames,					\
				LPMAPINAMEID FAR *			lppPropNames,				\
				ULONG						ulFlags,					\
				LPSPropTagArray FAR *		lppPropTags) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE	IMAPIProp
DECLARE_MAPI_INTERFACE_(IMAPIProp, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
};

/* IMAPITable Interface ---------------------------------------------------- */

/* Table status */

#define TBLSTAT_COMPLETE			((ULONG) 0)
#define TBLSTAT_QCHANGED			((ULONG) 7)
#define TBLSTAT_SORTING				((ULONG) 9)
#define TBLSTAT_SORT_ERROR			((ULONG) 10)
#define TBLSTAT_SETTING_COLS		((ULONG) 11)
#define TBLSTAT_SETCOL_ERROR		((ULONG) 13)
#define TBLSTAT_RESTRICTING			((ULONG) 14)
#define TBLSTAT_RESTRICT_ERROR		((ULONG) 15)


/* Table Type */

#define TBLTYPE_SNAPSHOT			((ULONG) 0)
#define TBLTYPE_KEYSET				((ULONG) 1)
#define TBLTYPE_DYNAMIC				((ULONG) 2)


/* Sort order */

/* bit 0: set if descending, clear if ascending */

#define TABLE_SORT_ASCEND		((ULONG) 0x00000000)
#define TABLE_SORT_DESCEND		((ULONG) 0x00000001)
#define TABLE_SORT_COMBINE		((ULONG) 0x00000002)


/* Data structures */

typedef struct _SSortOrder
{
	ULONG	ulPropTag;			/* Column to sort on */
	ULONG	ulOrder;			/* Ascending, descending, combine to left */
} SSortOrder, FAR * LPSSortOrder;

typedef struct _SSortOrderSet
{
	ULONG	  		cSorts;		/* Number of sort columns in aSort below*/
	ULONG			cCategories;	/* 0 for non-categorized, up to cSorts */
	ULONG			cExpanded;		/* 0 if no categories start expanded, */
									/*		up to cExpanded */
	SSortOrder		aSort[MAPI_DIM];	/* The sort orders */
} SSortOrderSet, FAR * LPSSortOrderSet;

#define CbNewSSortOrderSet(_csort) \
	(offsetof(SSortOrderSet,aSort) + (_csort)*sizeof(SSortOrder))
#define CbSSortOrderSet(_lpset) \
	(offsetof(SSortOrderSet,aSort) + \
	(UINT)((_lpset)->cSorts*sizeof(SSortOrder)))
#define SizedSSortOrderSet(_csort, _name) \
struct _SSortOrderSet_ ## _name \
{ \
	ULONG	  		cSorts;			\
	ULONG			cCategories;	\
	ULONG			cExpanded;		\
	SSortOrder		aSort[_csort];	\
} _name

typedef ULONG 		BOOKMARK;

#define BOOKMARK_BEGINNING	((BOOKMARK) 0)		/* Before first row */
#define BOOKMARK_CURRENT	((BOOKMARK) 1)		/* Before current row */
#define BOOKMARK_END		((BOOKMARK) 2)		/* After last row */

/* Fuzzy Level */

#define FL_FULLSTRING		((ULONG) 0x00000000)
#define FL_SUBSTRING		((ULONG) 0x00000001)
#define FL_PREFIX			((ULONG) 0x00000002)

#define FL_IGNORECASE		((ULONG) 0x00010000)
#define FL_IGNORENONSPACE	((ULONG) 0x00020000)
#define FL_LOOSE			((ULONG) 0x00040000)

/* Restrictions */

typedef struct _SRestriction	FAR * LPSRestriction;

/* Restriction types */

#define RES_AND				((ULONG) 0x00000000)
#define RES_OR				((ULONG) 0x00000001)
#define RES_NOT				((ULONG) 0x00000002)
#define RES_CONTENT			((ULONG) 0x00000003)
#define RES_PROPERTY		((ULONG) 0x00000004)
#define RES_COMPAREPROPS	((ULONG) 0x00000005)
#define RES_BITMASK			((ULONG) 0x00000006)
#define RES_SIZE			((ULONG) 0x00000007)
#define RES_EXIST			((ULONG) 0x00000008)
#define RES_SUBRESTRICTION	((ULONG) 0x00000009)
#define RES_COMMENT			((ULONG) 0x0000000A)

/* Relational operators. These apply to all property comparison restrictions. */

#define RELOP_LT		((ULONG) 0)		/* <  */
#define RELOP_LE		((ULONG) 1)		/* <= */
#define RELOP_GT		((ULONG) 2)		/* >  */
#define RELOP_GE		((ULONG) 3)		/* >= */
#define RELOP_EQ		((ULONG) 4)		/* == */
#define RELOP_NE		((ULONG) 5)		/* != */
#define RELOP_RE		((ULONG) 6)		/* LIKE (Regular expression) */

/* Bitmask operators, for RES_BITMASK only. */

#define BMR_EQZ		((ULONG) 0)		/* ==0 */
#define BMR_NEZ		((ULONG) 1)		/* !=0 */

/* Subobject identifiers for RES_SUBRESTRICTION only. See MAPITAGS.H. */

/* #define PR_MESSAGE_RECIPIENTS  PROP_TAG(PT_OBJECT,0x0E12) */
/* #define PR_MESSAGE_ATTACHMENTS PROP_TAG(PT_OBJECT,0x0E13) */

typedef struct _SAndRestriction
{
	ULONG			cRes;
	LPSRestriction 	lpRes;
} SAndRestriction;

typedef struct _SOrRestriction
{
	ULONG			cRes;
	LPSRestriction 	lpRes;
} SOrRestriction;

typedef struct _SNotRestriction
{
	ULONG			ulReserved;
	LPSRestriction 	lpRes;
} SNotRestriction;

typedef struct _SContentRestriction
{
	ULONG			ulFuzzyLevel;
	ULONG			ulPropTag;
	LPSPropValue	lpProp;
} SContentRestriction;

typedef struct _SBitMaskRestriction
{
	ULONG			relBMR;
	ULONG			ulPropTag;
	ULONG			ulMask;
} SBitMaskRestriction;

typedef struct _SPropertyRestriction
{
	ULONG			relop;
	ULONG			ulPropTag;
	LPSPropValue	lpProp;
} SPropertyRestriction;

typedef struct _SComparePropsRestriction
{
	ULONG			relop;
	ULONG			ulPropTag1;
	ULONG			ulPropTag2;
} SComparePropsRestriction;

typedef struct _SSizeRestriction
{
	ULONG			relop;
	ULONG			ulPropTag;
	ULONG			cb;
} SSizeRestriction;

typedef struct _SExistRestriction
{
	ULONG			ulReserved1;
	ULONG			ulPropTag;
	ULONG			ulReserved2;
} SExistRestriction;

typedef struct _SSubRestriction
{
	ULONG			ulSubObject;
	LPSRestriction	lpRes;
} SSubRestriction;

typedef struct _SCommentRestriction
{
	ULONG			cValues; /* # of properties in lpProp */
	LPSRestriction	lpRes;
	LPSPropValue	lpProp;
} SCommentRestriction;

typedef struct _SRestriction
{
	ULONG	rt;			/* Restriction type */
	union
	{
		SComparePropsRestriction	resCompareProps;	/* first */
		SAndRestriction				resAnd;
		SOrRestriction				resOr;
		SNotRestriction				resNot;
		SContentRestriction			resContent;
		SPropertyRestriction		resProperty;
		SBitMaskRestriction			resBitMask;
		SSizeRestriction			resSize;
		SExistRestriction			resExist;
		SSubRestriction				resSub;
		SCommentRestriction			resComment;
	} res;
} SRestriction;

/* SComparePropsRestriction is first in the union so that */
/* static initializations of 3-value restriction work.    */

/* Flags of the methods of IMAPITable */

/* QueryColumn */

#define TBL_ALL_COLUMNS		((ULONG) 0x00000001)

/* QueryRows */
/* Possible values for PR_ROW_TYPE (for categorization) */

#define TBL_LEAF_ROW			((ULONG) 1)
#define TBL_EMPTY_CATEGORY		((ULONG) 2)
#define TBL_EXPANDED_CATEGORY	((ULONG) 3)
#define TBL_COLLAPSED_CATEGORY	((ULONG) 4)

/* Table wait flag */

#define TBL_NOWAIT			((ULONG) 0x00000001)
/* alternative name for TBL_NOWAIT */
#define TBL_ASYNC			((ULONG) 0x00000001)
#define TBL_BATCH			((ULONG) 0x00000002)

/* FindRow */

#define DIR_BACKWARD		((ULONG) 0x00000001)

/* Table cursor states */

#define TBL_NOADVANCE		((ULONG) 0x00000001)

#define MAPI_IMAPITABLE_METHODS(IPURE)									\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(Advise)													\
		(THIS_	ULONG						ulEventMask,				\
				LPMAPIADVISESINK			lpAdviseSink,				\
				ULONG FAR *					lpulConnection) IPURE;		\
	MAPIMETHOD(Unadvise)												\
		(THIS_	ULONG						ulConnection) IPURE;		\
	MAPIMETHOD(GetStatus)												\
		(THIS_	ULONG FAR *					lpulTableStatus,			\
				ULONG FAR *					lpulTableType) IPURE;		\
	MAPIMETHOD(SetColumns)												\
		(THIS_	LPSPropTagArray				lpPropTagArray,				\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(QueryColumns)											\
		(THIS_	ULONG						ulFlags,					\
				LPSPropTagArray FAR *		lpPropTagArray) IPURE;		\
	MAPIMETHOD(GetRowCount)												\
		(THIS_	ULONG						ulFlags,					\
				ULONG FAR *					lpulCount) IPURE;			\
	MAPIMETHOD(SeekRow)													\
		(THIS_	BOOKMARK					bkOrigin,					\
				LONG						lRowCount,					\
				LONG FAR *					lplRowsSought) IPURE;		\
	MAPIMETHOD(SeekRowApprox)											\
		(THIS_	ULONG						ulNumerator,				\
				ULONG						ulDenominator) IPURE;		\
	MAPIMETHOD(QueryPosition)											\
		(THIS_	ULONG FAR *					lpulRow,					\
				ULONG FAR *					lpulNumerator,				\
				ULONG FAR *					lpulDenominator) IPURE;		\
	MAPIMETHOD(FindRow)													\
		(THIS_	LPSRestriction				lpRestriction,				\
				BOOKMARK					bkOrigin,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(Restrict)												\
		(THIS_	LPSRestriction				lpRestriction,				\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(CreateBookmark)											\
		(THIS_	BOOKMARK FAR *				lpbkPosition) IPURE;		\
	MAPIMETHOD(FreeBookmark)											\
		(THIS_	BOOKMARK					bkPosition) IPURE;			\
	MAPIMETHOD(SortTable)												\
		(THIS_	LPSSortOrderSet				lpSortCriteria,				\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(QuerySortOrder)											\
		(THIS_	LPSSortOrderSet FAR *		lppSortCriteria) IPURE;		\
	MAPIMETHOD(QueryRows)												\
		(THIS_	LONG						lRowCount,					\
				ULONG						ulFlags,					\
				LPSRowSet FAR *				lppRows) IPURE;				\
	MAPIMETHOD(Abort) (THIS) IPURE;										\
	MAPIMETHOD(ExpandRow)												\
		(THIS_	ULONG						cbInstanceKey,				\
				LPBYTE						pbInstanceKey,				\
				ULONG						ulRowCount,					\
				ULONG						ulFlags,					\
				LPSRowSet FAR *				lppRows,					\
				ULONG FAR *					lpulMoreRows) IPURE;		\
	MAPIMETHOD(CollapseRow)												\
		(THIS_	ULONG						cbInstanceKey,				\
				LPBYTE						pbInstanceKey,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulRowCount) IPURE;		\
	MAPIMETHOD(WaitForCompletion)										\
		(THIS_	ULONG						ulFlags,					\
				ULONG						ulTimeout,					\
				ULONG FAR *					lpulTableStatus) IPURE;		\
	MAPIMETHOD(GetCollapseState)										\
		(THIS_	ULONG						ulFlags,					\
				ULONG						cbInstanceKey,				\
				LPBYTE						lpbInstanceKey,				\
				ULONG FAR *					lpcbCollapseState,			\
				LPBYTE FAR *				lppbCollapseState) IPURE;	\
	MAPIMETHOD(SetCollapseState)										\
		(THIS_	ULONG						ulFlags,					\
				ULONG						cbCollapseState,			\
				LPBYTE						pbCollapseState,			\
				BOOKMARK FAR *				lpbkLocation) IPURE;		\

#undef		 INTERFACE
#define		 INTERFACE  IMAPITable
DECLARE_MAPI_INTERFACE_(IMAPITable, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPITABLE_METHODS(PURE)
};

/* IProfSect Interface ----------------------------------------------------- */

/* Standard section for public profile properties */

#define PS_PROFILE_PROPERTIES_INIT \
{ 	0x98, 0x15, 0xAC, 0x08, 0xAA, 0xB0, 0x10, 0x1A, \
	0x8C, 0x93, 0x08, 0x00, 0x2B, 0x2A, 0x56, 0xC2  }


#define MAPI_IPROFSECT_METHODS(IPURE)

#undef		 INTERFACE
#define		 INTERFACE  IProfSect
DECLARE_MAPI_INTERFACE_(IProfSect, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IPROFSECT_METHODS(PURE)
};

/* IMAPIStatus Interface --------------------------------------------------- */

/* Values for PR_RESOURCE_TYPE, _METHODS, _FLAGS */

#define MAPI_STORE_PROVIDER		((ULONG) 33)	/* Message Store */
#define MAPI_AB					((ULONG) 34)	/* Address Book */
#define MAPI_AB_PROVIDER		((ULONG) 35)	/* Address Book Provider */
#define MAPI_TRANSPORT_PROVIDER	((ULONG) 36)	/* Transport Provider */
#define MAPI_SPOOLER			((ULONG) 37)	/* Message Spooler */
#define MAPI_PROFILE_PROVIDER	((ULONG) 38)	/* Profile Provider */
#define MAPI_SUBSYSTEM			((ULONG) 39)	/* Overall Subsystem Status */
#define MAPI_HOOK_PROVIDER		((ULONG) 40)	/* Spooler Hook */

#define STATUS_VALIDATE_STATE	((ULONG) 0x00000001)
#define STATUS_SETTINGS_DIALOG	((ULONG) 0x00000002)
#define STATUS_CHANGE_PASSWORD	((ULONG) 0x00000004)
#define STATUS_FLUSH_QUEUES		((ULONG) 0x00000008)

#define STATUS_DEFAULT_OUTBOUND	((ULONG) 0x00000001)
#define STATUS_DEFAULT_STORE	((ULONG) 0x00000002)
#define STATUS_PRIMARY_IDENTITY	((ULONG) 0x00000004)
#define STATUS_SIMPLE_STORE		((ULONG) 0x00000008)
#define STATUS_XP_PREFER_LAST	((ULONG) 0x00000010)
#define STATUS_NO_PRIMARY_IDENTITY ((ULONG) 0x00000020)
#define STATUS_NO_DEFAULT_STORE	((ULONG) 0x00000040)
#define STATUS_TEMP_SECTION		((ULONG) 0x00000080)
#define STATUS_OWN_STORE		((ULONG) 0x00000100)
/****** HOOK_INBOUND			((ULONG) 0x00000200) Defined in MAPIHOOK.H */
/****** HOOK_OUTBOUND			((ULONG) 0x00000400) Defined in MAPIHOOK.H */
#define STATUS_NEED_IPM_TREE	((ULONG) 0x00000800)
#define	STATUS_PRIMARY_STORE	((ULONG) 0x00001000)
#define	STATUS_SECONDARY_STORE	((ULONG) 0x00002000)


/*
 * PR_STATUS_CODE bit. Low 16 bits for common values; High 16 bits
 * for provider type-specific values. (DCR 304)
 */

#define	STATUS_AVAILABLE		((ULONG) 0x00000001)
#define STATUS_OFFLINE			((ULONG) 0x00000002)
#define STATUS_FAILURE			((ULONG) 0x00000004)

/* Transport values of PR_STATUS_CODE */

#define STATUS_INBOUND_ENABLED	((ULONG) 0x00010000)
#define STATUS_INBOUND_ACTIVE	((ULONG) 0x00020000)
#define STATUS_INBOUND_FLUSH	((ULONG) 0x00040000)
#define STATUS_OUTBOUND_ENABLED	((ULONG) 0x00100000)
#define STATUS_OUTBOUND_ACTIVE	((ULONG) 0x00200000)
#define STATUS_OUTBOUND_FLUSH	((ULONG) 0x00400000)
#define	STATUS_REMOTE_ACCESS	((ULONG) 0x00800000)

/* ValidateState flags */

#define SUPPRESS_UI					((ULONG) 0x00000001)
#define	REFRESH_XP_HEADER_CACHE		((ULONG) 0x00010000)
#define	PROCESS_XP_HEADER_CACHE 	((ULONG) 0x00020000)
#define	FORCE_XP_CONNECT			((ULONG) 0x00040000)
#define FORCE_XP_DISCONNECT			((ULONG) 0x00080000)
#define CONFIG_CHANGED				((ULONG) 0x00100000)
#define ABORT_XP_HEADER_OPERATION	((ULONG) 0x00200000)
#define SHOW_XP_SESSION_UI			((ULONG) 0x00400000)

/* SettingsDialog flags */

#define UI_READONLY		((ULONG) 0x00000001)

/* FlushQueues flags */

#define FLUSH_UPLOAD		((ULONG) 0x00000002)
#define FLUSH_DOWNLOAD		((ULONG) 0x00000004)
#define FLUSH_FORCE			((ULONG) 0x00000008)
#define FLUSH_NO_UI			((ULONG) 0x00000010)
#define FLUSH_ASYNC_OK		((ULONG) 0x00000020)

#define MAPI_IMAPISTATUS_METHODS(IPURE)									\
	MAPIMETHOD(ValidateState)											\
		(THIS_	ULONG						ulUIParam,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(SettingsDialog)											\
		(THIS_	ULONG						ulUIParam,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(ChangePassword)											\
		(THIS_	LPTSTR						lpOldPass,					\
				LPTSTR						lpNewPass,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(FlushQueues)												\
		(THIS_	ULONG						ulUIParam,					\
				ULONG						cbTargetTransport,			\
				LPENTRYID					lpTargetTransport,			\
				ULONG						ulFlags) IPURE;				\

#undef		 INTERFACE
#define		 INTERFACE  IMAPIStatus
DECLARE_MAPI_INTERFACE_(IMAPIStatus, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IMAPISTATUS_METHODS(PURE)
};

/* IMAPIContainer Interface ------------------------------------------------ */

/* Flags for OpenEntry() */

/****** MAPI_MODIFY				((ULONG) 0x00000001) above */
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */
#define MAPI_BEST_ACCESS		((ULONG) 0x00000010)

/* GetContentsTable() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */
/****** MAPI_ASSOCIATED			((ULONG) 0x00000040) below */

/* GetHierarchyTable() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */
#define CONVENIENT_DEPTH		((ULONG) 0x00000001)
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */

/* GetSearchCriteria */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */
#define SEARCH_RUNNING			((ULONG) 0x00000001)
#define SEARCH_REBUILD			((ULONG) 0x00000002)
#define SEARCH_RECURSIVE		((ULONG) 0x00000004)
#define SEARCH_FOREGROUND		((ULONG) 0x00000008)

/* SetSearchCriteria */
#define STOP_SEARCH				((ULONG) 0x00000001)
#define RESTART_SEARCH			((ULONG) 0x00000002)
#define RECURSIVE_SEARCH		((ULONG) 0x00000004)
#define SHALLOW_SEARCH			((ULONG) 0x00000008)
#define FOREGROUND_SEARCH		((ULONG) 0x00000010)
#define BACKGROUND_SEARCH		((ULONG) 0x00000020)

#define MAPI_IMAPICONTAINER_METHODS(IPURE)								\
	MAPIMETHOD(GetContentsTable)										\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(GetHierarchyTable)										\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(OpenEntry)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulObjType,				\
				LPUNKNOWN FAR *				lppUnk) IPURE;				\
	MAPIMETHOD(SetSearchCriteria)										\
		(THIS_	LPSRestriction				lpRestriction,				\
				LPENTRYLIST					lpContainerList,			\
				ULONG						ulSearchFlags) IPURE;		\
	MAPIMETHOD(GetSearchCriteria)										\
		(THIS_	ULONG						ulFlags,					\
				LPSRestriction FAR *		lppRestriction,				\
				LPENTRYLIST FAR *			lppContainerList,			\
				ULONG FAR *					lpulSearchState)IPURE;		\

#undef		 INTERFACE
#define		 INTERFACE  IMAPIContainer
DECLARE_MAPI_INTERFACE_(IMAPIContainer, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IMAPICONTAINER_METHODS(PURE)
};

/* IABContainer Interface -------------------------------------------------- */

/*
 *	IABContainer PR_CONTAINER_FLAGS values
 *	If AB_UNMODIFIABLE and AB_MODIFIABLE are both set, it means the container
 *	doesn't know if it's modifiable or not, and the client should
 *  try to modify the contents but we won't expect it to work.
 *	If the AB_RECIPIENTS flag is set and neither AB_MODIFIABLE or AB_UNMODIFIABLE
 *  bits are set, it is an error.
 */

typedef struct _flaglist
{
	ULONG cFlags;
	ULONG ulFlag[MAPI_DIM];
} FlagList, FAR * LPFlagList;


/*
 *  Container flags
 */
#define AB_RECIPIENTS			((ULONG) 0x00000001)
#define AB_SUBCONTAINERS		((ULONG) 0x00000002)
#define AB_MODIFIABLE			((ULONG) 0x00000004)
#define AB_UNMODIFIABLE			((ULONG) 0x00000008)
#define AB_FIND_ON_OPEN			((ULONG) 0x00000010)
#define AB_NOT_DEFAULT			((ULONG) 0x00000020)

/* CreateEntry() */

#define CREATE_CHECK_DUP_STRICT	((ULONG) 0x00000001)
#define CREATE_CHECK_DUP_LOOSE	((ULONG) 0x00000002)
#define CREATE_REPLACE			((ULONG) 0x00000004)

/* ResolveNames() - ulFlags */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* ResolveNames() - rgulFlags */
#define MAPI_UNRESOLVED			((ULONG) 0x00000000)
#define MAPI_AMBIGUOUS			((ULONG) 0x00000001)
#define MAPI_RESOLVED			((ULONG) 0x00000002)


#define MAPI_IABCONTAINER_METHODS(IPURE)								\
	MAPIMETHOD(CreateEntry)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulCreateFlags,				\
				LPMAPIPROP FAR	*			lppMAPIPropEntry) IPURE;	\
	MAPIMETHOD(CopyEntries)												\
		(THIS_	LPENTRYLIST					lpEntries,					\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(DeleteEntries)											\
		(THIS_	LPENTRYLIST					lpEntries,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(ResolveNames)											\
		(THIS_	LPSPropTagArray				lpPropTagArray,				\
				ULONG						ulFlags,					\
				LPADRLIST					lpAdrList,					\
				LPFlagList					lpFlagList) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE  IABContainer
DECLARE_MAPI_INTERFACE_(IABContainer, IMAPIContainer)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IMAPICONTAINER_METHODS(PURE)
	MAPI_IABCONTAINER_METHODS(PURE)
};

/* IMailUser Interface ----------------------------------------------------- */

/*  Any call which can create a one-off entryID (i.e. MAPISupport::CreateOneOff
    or IAdrBook::CreateOneOff) can encode the value for PR_SEND_RICH_INFO by
	passing in the following flag in the ulFlags parameter.  Setting this flag
	indicates that PR_SEND_RICH_INFO will be FALSE.
*/
#define MAPI_SEND_NO_RICH_INFO		((ULONG) 0x00010000)




/* Values of PR_NDR_DIAG_CODE */

#define MAPI_DIAG(_code)	((LONG) _code)

#define MAPI_DIAG_NO_DIAGNOSTIC						MAPI_DIAG( -1 )
#define MAPI_DIAG_OR_NAME_UNRECOGNIZED				MAPI_DIAG( 0 )
#define MAPI_DIAG_OR_NAME_AMBIGUOUS					MAPI_DIAG( 1 )
#define MAPI_DIAG_MTS_CONGESTED						MAPI_DIAG( 2 )
#define MAPI_DIAG_LOOP_DETECTED						MAPI_DIAG( 3 )
#define MAPI_DIAG_RECIPIENT_UNAVAILABLE				MAPI_DIAG( 4 )
#define MAPI_DIAG_MAXIMUM_TIME_EXPIRED				MAPI_DIAG( 5 )
#define MAPI_DIAG_EITS_UNSUPPORTED					MAPI_DIAG( 6 )
#define MAPI_DIAG_CONTENT_TOO_LONG					MAPI_DIAG( 7 )
#define MAPI_DIAG_IMPRACTICAL_TO_CONVERT			MAPI_DIAG( 8 )
#define MAPI_DIAG_PROHIBITED_TO_CONVERT				MAPI_DIAG( 9 )
#define MAPI_DIAG_CONVERSION_UNSUBSCRIBED			MAPI_DIAG( 10 )
#define MAPI_DIAG_PARAMETERS_INVALID				MAPI_DIAG( 11 )
#define MAPI_DIAG_CONTENT_SYNTAX_IN_ERROR			MAPI_DIAG( 12 )
#define MAPI_DIAG_LENGTH_CONSTRAINT_VIOLATD			MAPI_DIAG( 13 )
#define MAPI_DIAG_NUMBER_CONSTRAINT_VIOLATD			MAPI_DIAG( 14 )
#define MAPI_DIAG_CONTENT_TYPE_UNSUPPORTED			MAPI_DIAG( 15 )
#define MAPI_DIAG_TOO_MANY_RECIPIENTS				MAPI_DIAG( 16 )
#define MAPI_DIAG_NO_BILATERAL_AGREEMENT			MAPI_DIAG( 17 )
#define MAPI_DIAG_CRITICAL_FUNC_UNSUPPORTED			MAPI_DIAG( 18 )
#define MAPI_DIAG_CONVERSION_LOSS_PROHIB			MAPI_DIAG( 19 )
#define MAPI_DIAG_LINE_TOO_LONG						MAPI_DIAG( 20 )
#define MAPI_DIAG_PAGE_TOO_LONG						MAPI_DIAG( 21 )
#define MAPI_DIAG_PICTORIAL_SYMBOL_LOST				MAPI_DIAG( 22 )
#define MAPI_DIAG_PUNCTUATION_SYMBOL_LOST			MAPI_DIAG( 23 )
#define MAPI_DIAG_ALPHABETIC_CHARACTER_LOST			MAPI_DIAG( 24 )
#define MAPI_DIAG_MULTIPLE_INFO_LOSSES				MAPI_DIAG( 25 )
#define MAPI_DIAG_REASSIGNMENT_PROHIBITED			MAPI_DIAG( 26 )
#define MAPI_DIAG_REDIRECTION_LOOP_DETECTED			MAPI_DIAG( 27 )
#define MAPI_DIAG_EXPANSION_PROHIBITED				MAPI_DIAG( 28 )
#define MAPI_DIAG_SUBMISSION_PROHIBITED				MAPI_DIAG( 29 )
#define MAPI_DIAG_EXPANSION_FAILED					MAPI_DIAG( 30 )
#define MAPI_DIAG_RENDITION_UNSUPPORTED				MAPI_DIAG( 31 )
#define MAPI_DIAG_MAIL_ADDRESS_INCORRECT			MAPI_DIAG( 32 )
#define MAPI_DIAG_MAIL_OFFICE_INCOR_OR_INVD			MAPI_DIAG( 33 )
#define MAPI_DIAG_MAIL_ADDRESS_INCOMPLETE			MAPI_DIAG( 34 )
#define MAPI_DIAG_MAIL_RECIPIENT_UNKNOWN			MAPI_DIAG( 35 )
#define MAPI_DIAG_MAIL_RECIPIENT_DECEASED			MAPI_DIAG( 36 )
#define MAPI_DIAG_MAIL_ORGANIZATION_EXPIRED			MAPI_DIAG( 37 )
#define MAPI_DIAG_MAIL_REFUSED						MAPI_DIAG( 38 )
#define MAPI_DIAG_MAIL_UNCLAIMED					MAPI_DIAG( 39 )
#define MAPI_DIAG_MAIL_RECIPIENT_MOVED				MAPI_DIAG( 40 )
#define MAPI_DIAG_MAIL_RECIPIENT_TRAVELLING			MAPI_DIAG( 41 )
#define MAPI_DIAG_MAIL_RECIPIENT_DEPARTED			MAPI_DIAG( 42 )
#define MAPI_DIAG_MAIL_NEW_ADDRESS_UNKNOWN			MAPI_DIAG( 43 )
#define MAPI_DIAG_MAIL_FORWARDING_UNWANTED			MAPI_DIAG( 44 )
#define MAPI_DIAG_MAIL_FORWARDING_PROHIB			MAPI_DIAG( 45 )
#define MAPI_DIAG_SECURE_MESSAGING_ERROR			MAPI_DIAG( 46 )
#define MAPI_DIAG_DOWNGRADING_IMPOSSIBLE			MAPI_DIAG( 47 )

/* Values of PR_DELIVERY_POINT (MH_T_DELIVERY_POINT) */

#define MAPI_MH_DP_PUBLIC_UA						((ULONG) 0)
#define MAPI_MH_DP_PRIVATE_UA						((ULONG) 1)
#define MAPI_MH_DP_MS								((ULONG) 2)
#define MAPI_MH_DP_ML								((ULONG) 3)
#define MAPI_MH_DP_PDAU								((ULONG) 4)
#define MAPI_MH_DP_PDS_PATRON						((ULONG) 5)
#define MAPI_MH_DP_OTHER_AU							((ULONG) 6)


#define MAPI_IMAILUSER_METHODS(IPURE)

#undef		 INTERFACE
#define		 INTERFACE  IMailUser
DECLARE_MAPI_INTERFACE_(IMailUser, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IMAILUSER_METHODS(PURE)
};

/* IDistList Interface ----------------------------------------------------- */

#define MAPI_IDISTLIST_METHODS(IPURE)									\
	MAPIMETHOD(CreateEntry)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulCreateFlags,				\
				LPMAPIPROP FAR	*			lppMAPIPropEntry) IPURE;	\
	MAPIMETHOD(CopyEntries)												\
		(THIS_	LPENTRYLIST					lpEntries,					\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(DeleteEntries)											\
		(THIS_	LPENTRYLIST					lpEntries,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(ResolveNames)											\
		(THIS_	LPSPropTagArray				lpPropTagArray,				\
				ULONG						ulFlags,					\
				LPADRLIST					lpAdrList,					\
				LPFlagList					lpFlagList) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE  IDistList
DECLARE_MAPI_INTERFACE_(IDistList, IMAPIContainer)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IMAPICONTAINER_METHODS(PURE)
	MAPI_IDISTLIST_METHODS(PURE)
};

/* IMAPIFolder Interface --------------------------------------------------- */

/* IMAPIFolder folder type (enum) */

#define FOLDER_ROOT				((ULONG) 0x00000000)
#define FOLDER_GENERIC			((ULONG) 0x00000001)
#define FOLDER_SEARCH			((ULONG) 0x00000002)

/* CreateMessage */
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */
/****** MAPI_ASSOCIATED			((ULONG) 0x00000040) below */

/* CopyMessages */

#define MESSAGE_MOVE			((ULONG) 0x00000001)
#define MESSAGE_DIALOG			((ULONG) 0x00000002)
/****** MAPI_DECLINE_OK			((ULONG) 0x00000004) above */

/* CreateFolder */

#define OPEN_IF_EXISTS			((ULONG) 0x00000001)
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* DeleteFolder */

#define DEL_MESSAGES			((ULONG) 0x00000001)
#define FOLDER_DIALOG			((ULONG) 0x00000002)
#define DEL_FOLDERS				((ULONG) 0x00000004)

/* EmptyFolder */
#define DEL_ASSOCIATED			((ULONG) 0x00000008)

/* CopyFolder */

#define FOLDER_MOVE				((ULONG) 0x00000001)
/****** FOLDER_DIALOG			((ULONG) 0x00000002) above */
/****** MAPI_DECLINE_OK			((ULONG) 0x00000004) above */
#define COPY_SUBFOLDERS			((ULONG) 0x00000010)
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */


/* SetReadFlags */

/****** SUPPRESS_RECEIPT		((ULONG) 0x00000001) below */
/****** FOLDER_DIALOG			((ULONG) 0x00000002) above */
/****** CLEAR_READ_FLAG			((ULONG) 0x00000004) below */
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */
/******	GENERATE_RECEIPT_ONLY	((ULONG) 0x00000010) below */
/****** CLEAR_RN_PENDING		((ULONG) 0x00000020) below */
/****** CLEAR_NRN_PENDING		((ULONG) 0x00000040) below */


/* GetMessageStatus */

#define MSGSTATUS_HIGHLIGHTED	((ULONG) 0x00000001)
#define MSGSTATUS_TAGGED		((ULONG) 0x00000002)
#define MSGSTATUS_HIDDEN		((ULONG) 0x00000004)
#define MSGSTATUS_DELMARKED		((ULONG) 0x00000008)

/* Bits for remote message status */

#define	MSGSTATUS_REMOTE_DOWNLOAD	((ULONG) 0x00001000)
#define	MSGSTATUS_REMOTE_DELETE		((ULONG) 0x00002000)

/* SaveContentsSort */

#define RECURSIVE_SORT			((ULONG) 0x00000002)

/* PR_STATUS property */

#define FLDSTATUS_HIGHLIGHTED	((ULONG) 0x00000001)
#define FLDSTATUS_TAGGED		((ULONG) 0x00000002)
#define FLDSTATUS_HIDDEN		((ULONG) 0x00000004)
#define FLDSTATUS_DELMARKED		((ULONG) 0x00000008)

#define MAPI_IMAPIFOLDER_METHODS(IPURE)									\
	MAPIMETHOD(CreateMessage)											\
		(THIS_	LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				LPMESSAGE FAR *				lppMessage) IPURE;			\
	MAPIMETHOD(CopyMessages)											\
		(THIS_	LPENTRYLIST					lpMsgList,					\
			   	LPCIID						lpInterface,				\
				LPVOID						lpDestFolder,				\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(DeleteMessages)											\
		(THIS_	LPENTRYLIST					lpMsgList,					\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(CreateFolder)											\
		(THIS_	ULONG						ulFolderType,				\
				LPTSTR						lpszFolderName,				\
				LPTSTR						lpszFolderComment,			\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				LPMAPIFOLDER FAR *			lppFolder) IPURE;			\
	MAPIMETHOD(CopyFolder)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
			   	LPCIID						lpInterface,				\
				LPVOID						lpDestFolder,				\
				LPTSTR						lpszNewFolderName,			\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(DeleteFolder)											\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(SetReadFlags)											\
		(THIS_	LPENTRYLIST					lpMsgList,					\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(GetMessageStatus)										\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulMessageStatus) IPURE;	\
	MAPIMETHOD(SetMessageStatus)										\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulNewStatus,				\
				ULONG						ulNewStatusMask,			\
				ULONG FAR *					lpulOldStatus) IPURE;		\
	MAPIMETHOD(SaveContentsSort)										\
		(THIS_	LPSSortOrderSet				lpSortCriteria,				\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(EmptyFolder)												\
		(THIS_	ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\

#undef		 INTERFACE
#define		 INTERFACE  IMAPIFolder
DECLARE_MAPI_INTERFACE_(IMAPIFolder, IMAPIContainer)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IMAPICONTAINER_METHODS(PURE)
	MAPI_IMAPIFOLDER_METHODS(PURE)
};

/* IMsgStore Interface ----------------------------------------------------- */

/*  PR_STORE_SUPPORT_MASK bits */
#define STORE_ENTRYID_UNIQUE	((ULONG) 0x00000001)
#define STORE_READONLY			((ULONG) 0x00000002)
#define STORE_SEARCH_OK			((ULONG) 0x00000004)
#define STORE_MODIFY_OK			((ULONG) 0x00000008)
#define STORE_CREATE_OK			((ULONG) 0x00000010)
#define STORE_ATTACH_OK			((ULONG) 0x00000020)
#define STORE_OLE_OK			((ULONG) 0x00000040)
#define STORE_SUBMIT_OK			((ULONG) 0x00000080)
#define STORE_NOTIFY_OK			((ULONG) 0x00000100)
#define STORE_MV_PROPS_OK		((ULONG) 0x00000200)
#define STORE_CATEGORIZE_OK		((ULONG) 0x00000400)
#define STORE_RTF_OK			((ULONG) 0x00000800)
#define STORE_RESTRICTION_OK	((ULONG) 0x00001000)
#define STORE_SORT_OK			((ULONG) 0x00002000)
#define	STORE_PUBLIC_FOLDERS	((ULONG) 0x00004000)
#define	STORE_UNCOMPRESSED_RTF	((ULONG) 0x00008000)

/* PR_STORE_STATE bits, try not to collide with PR_STORE_SUPPORT_MASK */

#define STORE_HAS_SEARCHES		((ULONG) 0x01000000)


/* OpenEntry() */

/****** MAPI_MODIFY				((ULONG) 0x00000001) above */
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */
/****** MAPI_BEST_ACCESS		((ULONG) 0x00000010) above */

/* SetReceiveFolder() */

/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* GetReceiveFolder() */

/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* GetReceiveFolderTable() */

/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */

/* StoreLogoff() */

#define	LOGOFF_NO_WAIT			((ULONG) 0x00000001)
#define	LOGOFF_ORDERLY			((ULONG) 0x00000002)
#define	LOGOFF_PURGE			((ULONG) 0x00000004)
#define LOGOFF_ABORT			((ULONG) 0x00000008)
#define LOGOFF_QUIET			((ULONG) 0x00000010)

#define LOGOFF_COMPLETE			((ULONG) 0x00010000)
#define	LOGOFF_INBOUND			((ULONG) 0x00020000)
#define LOGOFF_OUTBOUND			((ULONG) 0x00040000)
#define LOGOFF_OUTBOUND_QUEUE	((ULONG) 0x00080000)

/* SetLockState() */

#define MSG_LOCKED				((ULONG) 0x00000001)
#define MSG_UNLOCKED			((ULONG) 0x00000000)

/* Flag bits for PR_VALID_FOLDER_MASK */

#define	FOLDER_IPM_SUBTREE_VALID		((ULONG) 0x00000001)
#define	FOLDER_IPM_INBOX_VALID			((ULONG) 0x00000002)
#define	FOLDER_IPM_OUTBOX_VALID			((ULONG) 0x00000004)
#define	FOLDER_IPM_WASTEBASKET_VALID	((ULONG) 0x00000008)
#define	FOLDER_IPM_SENTMAIL_VALID		((ULONG) 0x00000010)
#define	FOLDER_VIEWS_VALID				((ULONG) 0x00000020)
#define	FOLDER_COMMON_VIEWS_VALID		((ULONG) 0x00000040)
#define	FOLDER_FINDER_VALID				((ULONG) 0x00000080)

#define MAPI_IMSGSTORE_METHODS(IPURE)									\
	MAPIMETHOD(Advise)													\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulEventMask,				\
				LPMAPIADVISESINK			lpAdviseSink,				\
				ULONG FAR *					lpulConnection) IPURE;		\
	MAPIMETHOD(Unadvise)												\
		(THIS_	ULONG						ulConnection) IPURE;		\
	MAPIMETHOD(CompareEntryIDs)											\
		(THIS_	ULONG						cbEntryID1,					\
				LPENTRYID					lpEntryID1,					\
				ULONG						cbEntryID2,					\
				LPENTRYID					lpEntryID2,					\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulResult) IPURE;			\
	MAPIMETHOD(OpenEntry)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulObjType,				\
				LPUNKNOWN FAR *				lppUnk) IPURE;				\
	MAPIMETHOD(SetReceiveFolder)										\
		(THIS_	LPTSTR						lpszMessageClass,			\
				ULONG						ulFlags,					\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID) IPURE;			\
	MAPIMETHOD(GetReceiveFolder)										\
		(THIS_	LPTSTR						lpszMessageClass,			\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID,					\
				LPTSTR FAR *				lppszExplicitClass) IPURE;	\
	MAPIMETHOD(GetReceiveFolderTable)									\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(StoreLogoff)												\
		(THIS_	ULONG FAR *					lpulFlags) IPURE;			\
	MAPIMETHOD(AbortSubmit)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(GetOutgoingQueue)										\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(SetLockState)											\
		(THIS_	LPMESSAGE					lpMessage,					\
				ULONG						ulLockState) IPURE;			\
	MAPIMETHOD(FinishedMsg)												\
		(THIS_	ULONG						ulFlags,					\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID) IPURE;			\
	MAPIMETHOD(NotifyNewMail)											\
		(THIS_	LPNOTIFICATION				lpNotification) IPURE;		\

#undef		 INTERFACE
#define		 INTERFACE  IMsgStore
DECLARE_MAPI_INTERFACE_(IMsgStore, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IMSGSTORE_METHODS(PURE)
};

/* IMessage Interface ------------------------------------------------------ */

/* SubmitMessage */

#define FORCE_SUBMIT				((ULONG) 0x00000001)

/* Flags defined in PR_MESSAGE_FLAGS */

#define MSGFLAG_READ			((ULONG) 0x00000001)
#define MSGFLAG_UNMODIFIED		((ULONG) 0x00000002)
#define MSGFLAG_SUBMIT			((ULONG) 0x00000004)
#define MSGFLAG_UNSENT			((ULONG) 0x00000008)
#define MSGFLAG_HASATTACH		((ULONG) 0x00000010)
#define MSGFLAG_FROMME			((ULONG) 0x00000020)
#define MSGFLAG_ASSOCIATED		((ULONG) 0x00000040)
#define MSGFLAG_RESEND			((ULONG) 0x00000080)
#define MSGFLAG_RN_PENDING		((ULONG) 0x00000100)
#define MSGFLAG_NRN_PENDING		((ULONG) 0x00000200)

/* Flags defined in PR_SUBMIT_FLAGS */

#define SUBMITFLAG_LOCKED		((ULONG) 0x00000001)
#define SUBMITFLAG_PREPROCESS	((ULONG) 0x00000002)

/* GetAttachmentTable() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* GetRecipientTable() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* ModifyRecipients */

/* ((ULONG) 0x00000001 is not a valid flag on ModifyRecipients. */
#define MODRECIP_ADD			((ULONG) 0x00000002)
#define MODRECIP_MODIFY			((ULONG) 0x00000004)
#define MODRECIP_REMOVE			((ULONG) 0x00000008)

/* SetReadFlag */

#define SUPPRESS_RECEIPT		((ULONG) 0x00000001)
#define CLEAR_READ_FLAG			((ULONG) 0x00000004)
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */
#define	GENERATE_RECEIPT_ONLY	((ULONG) 0x00000010)
#define CLEAR_RN_PENDING		((ULONG) 0x00000020)
#define CLEAR_NRN_PENDING		((ULONG) 0x00000040)

/* DeleteAttach */

#define ATTACH_DIALOG			((ULONG) 0x00000001)

/* PR_SECURITY values */
#define SECURITY_SIGNED			((ULONG) 0x00000001)
#define SECURITY_ENCRYPTED		((ULONG) 0x00000002)

/* PR_PRIORITY values */
#define PRIO_URGENT				((long)  1)
#define PRIO_NORMAL				((long)  0)
#define PRIO_NONURGENT			((long) -1)

/* PR_SENSITIVITY values */
#define SENSITIVITY_NONE					((ULONG) 0x00000000)
#define SENSITIVITY_PERSONAL				((ULONG) 0x00000001)
#define SENSITIVITY_PRIVATE					((ULONG) 0x00000002)
#define SENSITIVITY_COMPANY_CONFIDENTIAL	((ULONG) 0x00000003)

/* PR_IMPORTANCE values */
#define IMPORTANCE_LOW			((long) 0)
#define IMPORTANCE_NORMAL		((long) 1)
#define IMPORTANCE_HIGH			((long) 2)

#define MAPI_IMESSAGE_METHODS(IPURE)									\
	MAPIMETHOD(GetAttachmentTable)										\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(OpenAttach)												\
		(THIS_	ULONG						ulAttachmentNum,			\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				LPATTACH FAR *				lppAttach) IPURE;			\
	MAPIMETHOD(CreateAttach)											\
		(THIS_	LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulAttachmentNum,			\
				LPATTACH FAR *				lppAttach) IPURE;			\
	MAPIMETHOD(DeleteAttach)											\
		(THIS_	ULONG						ulAttachmentNum,			\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(GetRecipientTable)										\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(ModifyRecipients)										\
		(THIS_	ULONG						ulFlags,					\
				LPADRLIST					lpMods) IPURE;				\
	MAPIMETHOD(SubmitMessage)											\
		(THIS_	ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(SetReadFlag)												\
		(THIS_	ULONG						ulFlags) IPURE;				\

#undef		 INTERFACE
#define		 INTERFACE  IMessage
DECLARE_MAPI_INTERFACE_(IMessage, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IMESSAGE_METHODS(PURE)
};

/* IAttach Interface ------------------------------------------------------- */

/* IAttach attachment methods: PR_ATTACH_METHOD values */

#define NO_ATTACHMENT			((ULONG) 0x00000000)
#define ATTACH_BY_VALUE			((ULONG) 0x00000001)
#define ATTACH_BY_REFERENCE		((ULONG) 0x00000002)
#define ATTACH_BY_REF_RESOLVE	((ULONG) 0x00000003)
#define ATTACH_BY_REF_ONLY		((ULONG) 0x00000004)
#define ATTACH_EMBEDDED_MSG		((ULONG) 0x00000005)
#define ATTACH_OLE				((ULONG) 0x00000006)

#define MAPI_IATTACH_METHODS(IPURE)

#undef		 INTERFACE
#define		 INTERFACE  IAttach
DECLARE_MAPI_INTERFACE_(IAttach, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IATTACH_METHODS(PURE)
};

/* --------------------------------- */
/* Address Book interface definition */

/* ADRPARM ulFlags - top 4 bits used for versioning */

#define GET_ADRPARM_VERSION(ulFlags)  (((ULONG)ulFlags) & 0xF0000000)
#define SET_ADRPARM_VERSION(ulFlags, ulVersion)  (((ULONG)ulVersion) | (((ULONG)ulFlags) & 0x0FFFFFFF))

/*  Current versions of ADRPARM  */
#define ADRPARM_HELP_CTX		((ULONG) 0x00000000)


/*  ulFlags   - bit fields */
#define DIALOG_MODAL			((ULONG) 0x00000001)
#define DIALOG_SDI				((ULONG) 0x00000002)
#define DIALOG_OPTIONS			((ULONG) 0x00000004)
#define ADDRESS_ONE				((ULONG) 0x00000008)
#define AB_SELECTONLY			((ULONG) 0x00000010)
#define AB_RESOLVE				((ULONG) 0x00000020)

/* --------------------------------- */
/*  PR_DISPLAY_TYPEs                 */
/*
 *  These standard display types are
 *  by default handled by MAPI.
 *  They have default icons associated
 *  with them.
 */

/*  For address book contents tables */
#define DT_MAILUSER			((ULONG) 0x00000000)
#define DT_DISTLIST			((ULONG) 0x00000001)
#define DT_FORUM			((ULONG) 0x00000002)
#define DT_AGENT			((ULONG) 0x00000003)
#define DT_ORGANIZATION		((ULONG) 0x00000004)
#define DT_PRIVATE_DISTLIST	((ULONG) 0x00000005)
#define DT_REMOTE_MAILUSER	((ULONG) 0x00000006)

/*  For address book hierarchy tables */
#define DT_MODIFIABLE		((ULONG) 0x00010000)
#define DT_GLOBAL			((ULONG) 0x00020000)
#define DT_LOCAL			((ULONG) 0x00030000)
#define DT_WAN				((ULONG) 0x00040000)
#define DT_NOT_SPECIFIC		((ULONG) 0x00050000)

/*  For folder hierarchy tables */
#define DT_FOLDER			((ULONG) 0x01000000)
#define DT_FOLDER_LINK		((ULONG) 0x02000000)
#define DT_FOLDER_SPECIAL	((ULONG) 0x04000000)

/*  Accelerator callback for DIALOG_SDI form of AB UI */
typedef BOOL (STDMETHODCALLTYPE ACCELERATEABSDI)(ULONG ulUIParam,
												LPVOID lpvmsg);
typedef ACCELERATEABSDI FAR * LPFNABSDI;

/*  Callback to application telling it that the DIALOG_SDI form of the */
/*  AB UI has been dismissed.  This is so that the above LPFNABSDI     */
/*  function doesn't keep being called.                                */
typedef void (STDMETHODCALLTYPE DISMISSMODELESS)(ULONG ulUIParam,
												LPVOID lpvContext);
typedef DISMISSMODELESS FAR * LPFNDISMISS;

/*
 * Prototype for the client function hooked to an optional button on
 * the address book dialog
 */

typedef SCODE (STDMETHODCALLTYPE FAR * LPFNBUTTON)(
	ULONG				ulUIParam,
	LPVOID				lpvContext,
	ULONG				cbEntryID,
	LPENTRYID			lpSelection,
	ULONG				ulFlags
);


/* Parameters for the address book dialog */
typedef struct _ADRPARM
{
	ULONG			cbABContEntryID;
	LPENTRYID		lpABContEntryID;
	ULONG			ulFlags;

	LPVOID			lpReserved;
	ULONG			ulHelpContext;
	LPTSTR			lpszHelpFileName;

	LPFNABSDI		lpfnABSDI;
	LPFNDISMISS		lpfnDismiss;
	LPVOID			lpvDismissContext;
	LPTSTR			lpszCaption;
	LPTSTR			lpszNewEntryTitle;
	LPTSTR			lpszDestWellsTitle;
	ULONG			cDestFields;
	ULONG			nDestFieldFocus;
	LPTSTR FAR *	lppszDestTitles;
	ULONG FAR *		lpulDestComps;
	LPSRestriction	lpContRestriction;
	LPSRestriction	lpHierRestriction;
} ADRPARM, FAR * LPADRPARM;


/* ------------ */
/* Random flags */

/* Flag for deferred error */
#define MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008)

/* Flag for creating and using Folder Associated Information Messages */
#define MAPI_ASSOCIATED			((ULONG) 0x00000040)

/* Flags for OpenMessageStore() */

#define MDB_NO_DIALOG			((ULONG) 0x00000001)
#define MDB_WRITE				((ULONG) 0x00000004)
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) above */
/****** MAPI_BEST_ACCESS		((ULONG) 0x00000010) above */
#define	MDB_TEMPORARY			((ULONG) 0x00000020)
#define MDB_NO_MAIL				((ULONG) 0x00000080)

/* Flags for OpenAddressBook */

#define AB_NO_DIALOG			((ULONG) 0x00000001)

/* IMAPIControl Interface -------------------------------------------------- */

/* Interface used in controls (particularly the button) defined by */
/* Display Tables. */

/*  Flags for GetState */

#define  MAPI_ENABLED		((ULONG) 0x00000000)
#define  MAPI_DISABLED		((ULONG) 0x00000001)

#define MAPI_IMAPICONTROL_METHODS(IPURE)								\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(Activate)												\
		(THIS_	ULONG						ulFlags,					\
				ULONG						ulUIParam) IPURE;			\
	MAPIMETHOD(GetState)												\
		(THIS_	ULONG						ulFlags,					\
				ULONG FAR *					lpulState) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE  IMAPIControl
DECLARE_MAPI_INTERFACE_(IMAPIControl, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPICONTROL_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IMAPIControl, LPMAPICONTROL);

/* Display Tables ---------------------------------------------------------- */

/* Flags used in display tables - that is, PR_CONTROL_FLAGS */

#define DT_MULTILINE		((ULONG) 0x00000001)
#define DT_EDITABLE			((ULONG) 0x00000002)
#define DT_REQUIRED			((ULONG) 0x00000004)
#define DT_SET_IMMEDIATE	((ULONG) 0x00000008)
#define DT_PASSWORD_EDIT	((ULONG) 0x00000010)
#define DT_ACCEPT_DBCS		((ULONG) 0x00000020)
#define DT_SET_SELECTION	((ULONG) 0x00000040)

/* Display Table structures */

#define DTCT_LABEL			((ULONG) 0x00000000)
#define DTCT_EDIT			((ULONG) 0x00000001)
#define DTCT_LBX			((ULONG) 0x00000002)
#define DTCT_COMBOBOX		((ULONG) 0x00000003)
#define DTCT_DDLBX			((ULONG) 0x00000004)
#define DTCT_CHECKBOX		((ULONG) 0x00000005)
#define DTCT_GROUPBOX		((ULONG) 0x00000006)
#define DTCT_BUTTON			((ULONG) 0x00000007)
#define DTCT_PAGE			((ULONG) 0x00000008)
#define DTCT_RADIOBUTTON	((ULONG) 0x00000009)
#define DTCT_MVLISTBOX		((ULONG) 0x0000000B)
#define DTCT_MVDDLBX		((ULONG) 0x0000000C)

/* Labels */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLLABEL
{
	ULONG ulbLpszLabelName;
	ULONG ulFlags;
} DTBLLABEL, FAR * LPDTBLLABEL;
#define SizedDtblLabel(n,u) \
struct _DTBLLABEL_ ## u \
{ \
	DTBLLABEL	dtbllabel; \
	TCHAR		lpszLabelName[n]; \
} u


/*  Simple Text Edits  */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLEDIT
{
	ULONG ulbLpszCharsAllowed;
	ULONG ulFlags;
	ULONG ulNumCharsAllowed;
	ULONG ulPropTag;
} DTBLEDIT, FAR * LPDTBLEDIT;
#define SizedDtblEdit(n,u) \
struct _DTBLEDIT_ ## u \
{ \
	DTBLEDIT	dtbledit; \
	TCHAR		lpszCharsAllowed[n]; \
} u

/*  List Box  */
/* Valid ulFlags:
 */
#define MAPI_NO_HBAR		((ULONG) 0x00000001)
#define MAPI_NO_VBAR		((ULONG) 0x00000002)

typedef struct _DTBLLBX
{
	ULONG ulFlags;
	ULONG ulPRSetProperty;
	ULONG ulPRTableName;
} DTBLLBX, FAR * LPDTBLLBX;


/*  Combo Box   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLCOMBOBOX
{
	ULONG ulbLpszCharsAllowed;
	ULONG ulFlags;
	ULONG ulNumCharsAllowed;
	ULONG ulPRPropertyName;
	ULONG ulPRTableName;
} DTBLCOMBOBOX, FAR * LPDTBLCOMBOBOX;
#define SizedDtblComboBox(n,u) \
struct _DTBLCOMBOBOX_ ## u \
{ \
	DTBLCOMBOBOX	dtblcombobox; \
	TCHAR			lpszCharsAllowed[n]; \
} u


/*  Drop Down   */
/* Valid ulFlags:
 *   none
 */
typedef struct _DTBLDDLBX
{
	ULONG ulFlags;
	ULONG ulPRDisplayProperty;
	ULONG ulPRSetProperty;
	ULONG ulPRTableName;
} DTBLDDLBX, FAR * LPDTBLDDLBX;


/*  Check Box   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLCHECKBOX
{
	ULONG ulbLpszLabel;
	ULONG ulFlags;
	ULONG ulPRPropertyName;
} DTBLCHECKBOX, FAR * LPDTBLCHECKBOX;
#define SizedDtblCheckBox(n,u) \
struct _DTBLCHECKBOX_ ## u \
{ \
	DTBLCHECKBOX	dtblcheckbox; \
	TCHAR		lpszLabel[n]; \
} u



/*  Group Box   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLGROUPBOX
{
	ULONG ulbLpszLabel;
	ULONG ulFlags;
} DTBLGROUPBOX, FAR * LPDTBLGROUPBOX;
#define SizedDtblGroupBox(n,u) \
struct _DTBLGROUPBOX_ ## u \
{ \
	DTBLGROUPBOX	dtblgroupbox; \
	TCHAR			lpszLabel[n]; \
} u

/*  Button control   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLBUTTON
{
	ULONG ulbLpszLabel;
	ULONG ulFlags;
	ULONG ulPRControl;
} DTBLBUTTON, FAR * LPDTBLBUTTON;
#define SizedDtblButton(n,u) \
struct _DTBLBUTTON_ ## u \
{ \
	DTBLBUTTON	dtblbutton; \
	TCHAR		lpszLabel[n]; \
} u

/*  Pages   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLPAGE
{
	ULONG ulbLpszLabel;
	ULONG ulFlags;
	ULONG ulbLpszComponent;
	ULONG ulContext;
} DTBLPAGE, FAR * LPDTBLPAGE;
#define SizedDtblPage(n,n1,u) \
struct _DTBLPAGE_ ## u \
{ \
	DTBLPAGE	dtblpage; \
	TCHAR		lpszLabel[n]; \
	TCHAR		lpszComponent[n1]; \
} u

/*  Radio button   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLRADIOBUTTON
{
	ULONG ulbLpszLabel;
	ULONG ulFlags;
	ULONG ulcButtons;
	ULONG ulPropTag;
	long lReturnValue;
} DTBLRADIOBUTTON, FAR * LPDTBLRADIOBUTTON;
#define SizedDtblRadioButton(n,u) \
struct _DTBLRADIOBUTTON_ ## u \
{ \
	DTBLRADIOBUTTON dtblradiobutton; \
	TCHAR			lpszLabel[n]; \
} u


/*  MultiValued listbox */
/* Valid ulFlags:
 *   none
 */
typedef struct _DTBLMVLISTBOX
{
	ULONG ulFlags;
	ULONG ulMVPropTag;
} DTBLMVLISTBOX, FAR * LPDTBLMVLISTBOX;


/*  MultiValued dropdown */
/* Valid ulFlags:
 *   none
 */
typedef struct _DTBLMVDDLBX
{
	ULONG ulFlags;
	ULONG ulMVPropTag;
} DTBLMVDDLBX, FAR * LPDTBLMVDDLBX;





/* IProviderAdmin Interface ---------------------------------------------- */

/* Flags for ConfigureMsgService */

#define UI_SERVICE					0x00000002
#define SERVICE_UI_ALWAYS  			0x00000002		/* Duplicate UI_SERVICE for consistency and compatibility */
#define SERVICE_UI_ALLOWED 			0x00000010
#define UI_CURRENT_PROVIDER_FIRST	0x00000004
/* MSG_SERVICE_UI_READ_ONLY 		0x00000008 - in MAPISPI.H */

/* GetProviderTable() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* Values for PR_RESOURCE_FLAGS in message service table */

#define MAPI_IPROVIDERADMIN_METHODS(IPURE)								\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(GetProviderTable)										\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(CreateProvider)											\
		(THIS_	LPTSTR						lpszProvider,				\
				ULONG						cValues,					\
				LPSPropValue				lpProps,					\
				ULONG						ulUIParam,					\
				ULONG						ulFlags,					\
				MAPIUID FAR *				lpUID) IPURE;				\
	MAPIMETHOD(DeleteProvider)											\
		(THIS_	LPMAPIUID					lpUID) IPURE;				\
	MAPIMETHOD(OpenProfileSection)										\
		(THIS_	LPMAPIUID					lpUID,						\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				LPPROFSECT FAR *			lppProfSect) IPURE;			\


#undef 		 INTERFACE
#define 	 INTERFACE	IProviderAdmin
DECLARE_MAPI_INTERFACE_(IProviderAdmin, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IPROVIDERADMIN_METHODS(PURE)
};



#ifdef	__cplusplus
}		/*	extern "C" */
#endif

#endif /* MAPIDEFS_H */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\mapistub\mapistub\mapi32.cpp ===
#pragma warning(disable: 4201)	// nameless struct/union
#pragma warning(disable: 4514)	// unreferenced inline function

#include <windows.h>
#include <winnls.h>
#include <winbase.h>

#include "mapi.h"
#include "mapix.h"
#include "_spooler.h"

extern "C"
{
#include "profspi.h"
}

#include "mapiform.h"
#include "mapidbg.h"
#include "_mapiu.h"
#include "tnef.h"

typedef void UNKOBJ_Vtbl;		// ???
#include "unkobj.h"

#include "mapival.h"
#include "imessage.h"
#include "_vbmapi.h"
#include "xcmc.h"

#include "msi.h"

#define OUTLOOKVERSION	0x80000402

#define ThunkLoadLibrary(dllName, bpNativeDll, bLoadAsX86, flags) ::LoadLibrary(dllName)

#define ThunkFreeLibrary(hModule, bNativeDll, bDetach)   ::FreeLibrary(hModule)

#define ThunkGetProcAddress(hModule, szFnName, bNativeDll, nParams) \
                ::GetProcAddress(hModule, szFnName)

#define ThunkGetModuleHandle(szLib)     GetModuleHandle(szLib)

struct FreeBufferBlocks		// fbb
{
	LPVOID pvBuffer;
	struct FreeBufferBlocks * pNext;
};

FreeBufferBlocks * g_pfbbHead = NULL;


// Copied from mapi.ortm\mapi\src\common\mapidbg.c (ericwong 06-18-98)

#if defined( _WINNT)

/*++

Routine Description:

    This routine returns if the service specified is running interactively
	(not invoked \by the service controller).

Arguments:

    None

Return Value:

    BOOL - TRUE if the service is an EXE.


Note:

--*/

BOOL WINAPI IsDBGServiceAnExe( VOID )
{
    HANDLE hProcessToken = NULL;
    DWORD groupLength = 50;

    PTOKEN_GROUPS groupInfo = (PTOKEN_GROUPS)LocalAlloc(0, groupLength);

    SID_IDENTIFIER_AUTHORITY siaNt = SECURITY_NT_AUTHORITY;
    PSID InteractiveSid = NULL;
    PSID ServiceSid = NULL;
    DWORD i;

	// Start with assumption that process is an EXE, not a Service.
	BOOL fExe = TRUE;


    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hProcessToken))
		goto ret;

    if (groupInfo == NULL)
		goto ret;

    if (!GetTokenInformation(hProcessToken, TokenGroups, groupInfo,
		groupLength, &groupLength))
	{
		if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
			goto ret;

		LocalFree(groupInfo);
		groupInfo = NULL;
	
		groupInfo = (PTOKEN_GROUPS)LocalAlloc(0, groupLength);
	
		if (groupInfo == NULL)
			goto ret;
	
		if (!GetTokenInformation(hProcessToken, TokenGroups, groupInfo,
			groupLength, &groupLength))
		{
			goto ret;
		}
    }

    //
    //	We now know the groups associated with this token.  We want to look to see if
    //  the interactive group is active in the token, and if so, we know that
    //  this is an interactive process.
    //
    //  We also look for the "service" SID, and if it's present, we know we're a service.
    //
    //	The service SID will be present iff the service is running in a
    //  user account (and was invoked by the service controller).
    //


    if (!AllocateAndInitializeSid(&siaNt, 1, SECURITY_INTERACTIVE_RID, 0, 0,
		0, 0, 0, 0, 0, &InteractiveSid))
	{
		goto ret;
    }

    if (!AllocateAndInitializeSid(&siaNt, 1, SECURITY_SERVICE_RID, 0, 0, 0,
		0, 0, 0, 0, &ServiceSid))
	{
		goto ret;
    }

    for (i = 0; i < groupInfo->GroupCount ; i += 1)
	{
		SID_AND_ATTRIBUTES sanda = groupInfo->Groups[i];
		PSID Sid = sanda.Sid;
	
		//
		//	Check to see if the group we're looking at is one of
		//	the 2 groups we're interested in.
		//
	
		if (EqualSid(Sid, InteractiveSid))
		{
			//
			//	This process has the Interactive SID in its
			//  token.  This means that the process is running as
			//  an EXE.
			//
			goto ret;
		}
		else if (EqualSid(Sid, ServiceSid))
		{
			//
			//	This process has the Service SID in its
			//  token.  This means that the process is running as
			//  a service running in a user account.
			//
			fExe = FALSE;
			goto ret;
		}
    }

    //
    //	Neither Interactive or Service was present in the current users token,
    //  This implies that the process is running as a service, most likely
    //  running as LocalSystem.
    //
	fExe = FALSE;

ret:

	if (InteractiveSid)
		FreeSid(InteractiveSid);		/*lint !e534*/

	if (ServiceSid)
		FreeSid(ServiceSid);			/*lint !e534*/

	if (groupInfo)
		LocalFree(groupInfo);

	if (hProcessToken)
		CloseHandle(hProcessToken);

    return(fExe);
}

#else
BOOL WINAPI IsDBGServiceAnExe( VOID )
{
	return TRUE;
}
#endif

DWORD	verWinNT();	// Forward declaration

typedef struct {
	char *		sz1;
	char *		sz2;
	UINT		rgf;
	int			iResult;
} MBContext;


DWORD WINAPI MessageBoxFnThreadMain(MBContext *pmbc)
{
	// Need extra flag for NT service
	if (verWinNT() && !IsDBGServiceAnExe())
		pmbc->rgf |= MB_SERVICE_NOTIFICATION;

	pmbc->iResult = MessageBoxA(NULL, pmbc->sz1, pmbc->sz2,
		pmbc->rgf | MB_SETFOREGROUND);

	return 0;
}

int MessageBoxFn(char *sz1, char *sz2, UINT rgf)
{
	HANDLE		hThread;
	DWORD		dwThreadId;
	MBContext	mbc;

	mbc.sz1		= sz1;
	mbc.sz2		= sz2;
	mbc.rgf		= rgf;
	mbc.iResult = IDRETRY;

	hThread = CreateThread(NULL, 0,
		(PTHREAD_START_ROUTINE)MessageBoxFnThreadMain, &mbc, 0, &dwThreadId);

	if (hThread != NULL) {
		WaitForSingleObject(hThread, INFINITE);
		CloseHandle(hThread);
	}

	return(mbc.iResult);
}

#ifdef DEBUG

TCHAR g_szProcessName[MAX_PATH];


static char szCR[] = "\r";

void DebugOutputFn(const char *psz)
{
	OutputDebugStringA(psz);
	OutputDebugStringA(szCR);
}

int __cdecl DebugTrapFn(int fFatal, char *pszFile, int iLine, char *pszFormat, ...)
{
	char	sz[512];
	va_list	vl;

	int		id;

	DebugOutputFn("++++ MAPI Stub Debug Trap\n");

	va_start(vl, pszFormat);
	wvsprintfA(sz, pszFormat, vl);
	va_end(vl);

	wsprintfA(sz + lstrlenA(sz), "\n[File %s, Line %d]\n\n", pszFile, iLine);

	DebugOutputFn(sz);

	/* Hold down control key to prevent MessageBox */
	if ( GetAsyncKeyState(VK_CONTROL) >= 0 )
	{
		UINT uiFlags = MB_ABORTRETRYIGNORE;

		if (fFatal)
			uiFlags |= MB_DEFBUTTON1;
		else
			uiFlags |= MB_DEFBUTTON3;

		uiFlags |= MB_ICONSTOP | MB_TASKMODAL;

		id = MessageBoxFn(sz, "MAPI Stub Debug Trap", uiFlags);

		if (id == IDABORT)
		{
			*((LPBYTE)NULL) = 0;		/*lint !e413*/
		}
		else if (id == IDRETRY)
			DebugBreak();
	}

	return 0;
}


#endif




inline void MyStrCopy(LPSTR szDest, LPCSTR szSrc)
{
	while ('\0' != (*szDest++ = *szSrc++))
	{
	}
}



inline SIZE_T MyStrLen(LPCSTR szSrc)
{
	LPCSTR szRunner = szSrc;

	while (*szRunner++)
	{
	}

	return szRunner - szSrc;
}



LPCSTR FindFileNameWithoutPath(LPCSTR szPathName)
{
	// Find the name of the file without the path.  Do this by finding
	// the last occurrence of the path separator.

	LPCSTR szFileNameWithoutPath = szPathName;
	LPCSTR szRunner = szPathName;

	while ('\0' != *szRunner)
	{
		if (*szRunner == '\\')
		{
			szFileNameWithoutPath = szRunner + 1;
		}

		szRunner = CharNext(szRunner);
	}

	return szFileNameWithoutPath;
}


inline LPSTR FindFileNameWithoutPath(LPSTR szPathName)
{
	return (LPSTR) FindFileNameWithoutPath((LPCSTR) szPathName);
}


// Windows NT seems to have a bug in ::LoadLibrary().  If somebody calls ::LoadLibrary()
// with a long file name in the path, the Dll will get loaded fine.  However, if someone
// subsequently calls ::LoadLibrary() with the same file name and path, only this time the
// path is in shortened form, the Dll will be loaded again.  There will be two instances
// of the same Dll loaded in the same process.
//
// This is an effort to solve the problem.  However, this function will probably not solve
// the problem if the long/shortened file name is the name of the Dll itself and not just
// a folder in the path.
//
// Also, if two legitimately different Dlls have the same file name (different path), this
// will only load the first one.
//
// Finally, this adds an effort to make the search path behavior work the same between
// Windows NT and Windows 95.  If a DLL calls ::LoadLibrary(), Windows NT will look for a
// library in the same folder as the calling library (before looking in the same folder as
// the calling process's executable).  Windows 95 won't.


HINSTANCE MyLoadLibrary(LPCSTR szLibraryName, HINSTANCE hinstCallingLibrary)
{

    char szModuleFileName[MAX_PATH + 1] = {0};

    Assert(NULL != szLibraryName);

    LPCSTR szLibraryNameWithoutPath = FindFileNameWithoutPath(szLibraryName);


    HINSTANCE hinst = (HINSTANCE) ThunkGetModuleHandle(szLibraryNameWithoutPath);

    if (NULL != hinst)
    {
        // Ah ha!  The library is already loaded!

        if (0 == ::GetModuleFileName(hinst, szModuleFileName, MAX_PATH))
        {
            // Wait a minute.  We know that the library was already loaded.  Why would
            // this fail?  We'll just return NULL, as if ::LoadLibrary() had failed, and
            // the caller can call ::GetLastError() to figure out what happened.

            szLibraryName = NULL;
            hinst = NULL;
        }
        else
        {
            szLibraryName = szModuleFileName;
        }
    }
    else if ((NULL != hinstCallingLibrary && szLibraryName == szLibraryNameWithoutPath))
    {

        // If the specified library (szLibraryName) does not have a path, we try
        // to load it from the same directory as hinstCallingLibrary

        // For WX86, we also fall into this case if szLibraryName has a path
        // and it is either the system directory or the x86 system directory.

        // This is to cover the case when people manually add a DllPath or
        // DllPathEx key in the registry - most commonly for native Exchange,
        // which does not add these keys - and enter the full path name

        // CAUTION: For Wx86, szLibraryName might not be the same as
        // szLibraryNameWithoutPath; do not assume szLibraryName ==
        // szLibraryNameWithoutPath



        if (0 != ::GetModuleFileName(hinstCallingLibrary, szModuleFileName, MAX_PATH))
        {
            // Note that we get to this case most commonly if we are trying to
            // to load mapi32x.dll. In all other cases we have either called
            // GetModuleHandle in GetProxyDll() (for the omi9/omint cases) or
            // we have got a dll name for the default mail client from the
            // registry. Hopefully, all apps that write the registry key will
            // put the full path name of the dll there. (We do in RegisterMail-
            // Client.)

            LPSTR szEndOfCallerPath = FindFileNameWithoutPath(szModuleFileName);

            Assert(szEndOfCallerPath != szModuleFileName);

            *szEndOfCallerPath = '\0';

            if (MyStrLen(szLibraryNameWithoutPath) +
                            szEndOfCallerPath - szModuleFileName < sizeof(szModuleFileName))
            {
                MyStrCopy(szEndOfCallerPath, szLibraryNameWithoutPath);


#if DEBUG
                DebugOutputFn(" +++ LoadLibrary(\"");
                DebugOutputFn(szModuleFileName);
                DebugOutputFn("\");\n");
#endif

                hinst = ThunkLoadLibrary(szModuleFileName, bpNativeDll, FALSE,
                                             LOAD_WITH_ALTERED_SEARCH_PATH);

                if (NULL != hinst)
                {
                    szLibraryName = NULL;
                }

                // Following comment for WX86 only:
                //
                // If this load failed, hInst = NULL, we may have
                // just loaded mapistub (above) and should unload it
                // Its simpler to just leave it laoded till this dll
                // is unloaded.
            }
        }
    }


    if (NULL != szLibraryName)
    {

#if DEBUG
        DebugOutputFn(" +++ LoadLibrary(\"");
        DebugOutputFn(szLibraryName);
        DebugOutputFn("\");\n");
#endif

        if (szLibraryName != szLibraryNameWithoutPath)
        {
            char szLibraryPath[MAX_PATH];
            LPSTR szPathFile;

            // Get library path
            lstrcpy(szLibraryPath, szLibraryName);
            szPathFile = FindFileNameWithoutPath(szLibraryPath);
                                        // szPathFile = Pointer to first char
                                        // following last \ in szLibraryPath
            *szPathFile = '\0';

            // Required by JPN mapi32x.dll
            SetCurrentDirectory(szLibraryPath);
        }

        hinst = ThunkLoadLibrary(szLibraryName, bpNativeDll, FALSE,
                                            LOAD_WITH_ALTERED_SEARCH_PATH);
                // We always have to do a ::LoadLibrary(), even if it's already loaded,
                // so we can bump the reference count on the instance handle.
    }


#ifdef DEBUG

    if (NULL == hinst)
    {
        DWORD dwError = ::GetLastError();

        if (dwError)
        {
            TCHAR szMsg[512];

            wsprintf(szMsg, TEXT("(%s): LoadLibrary(%s) failed.  Error %lu (0x%lX)"),
                            g_szProcessName, szLibraryName, dwError, dwError);

            AssertSz(FALSE, szMsg);
        }
    }

#endif

    return hinst;
}


HMODULE hmodExtendedMAPI = NULL;
HMODULE hmodSimpleMAPI = NULL;

HINSTANCE hinstSelf = NULL;

CRITICAL_SECTION csGetProcAddress;
CRITICAL_SECTION csLinkedList;

extern "C" BOOL WINAPI DllMain(HINSTANCE hinst, ULONG ulReason, LPVOID Context)
{
	if (DLL_PROCESS_ATTACH == ulReason)
	{
		hinstSelf = hinst;

		InitializeCriticalSection(&csGetProcAddress);
		InitializeCriticalSection(&csLinkedList);

#ifdef DEBUG

		::GetModuleFileName(NULL, g_szProcessName, sizeof(g_szProcessName) / sizeof(TCHAR));

		DebugOutputFn(" *** DllMain(mapi32.dll (stub), DLL_PROCESS_ATTACH);\n");
		DebugOutputFn("         (\"");
		DebugOutputFn(g_szProcessName);
		DebugOutputFn("\")\n");

#endif
		::DisableThreadLibraryCalls(hinst);
			//	Disable DLL_THREAD_ATTACH calls to reduce working set.
	}
	else if (DLL_PROCESS_DETACH == ulReason)
	{
		Assert(NULL == g_pfbbHead);

                // Note: If Context is not NULL, the process is exiting

		if (NULL != hmodSimpleMAPI)
		{

#if DEBUG
			DebugOutputFn(" --- FreeLibrary(hmodSimpleMAPI);\n");
#endif

			ThunkFreeLibrary(hmodSimpleMAPI, bNativeSimpleMAPIDll,
                                         Context? TRUE : FALSE);
		}

		if (NULL != hmodExtendedMAPI)
		{

#if DEBUG
			DebugOutputFn(" --- FreeLibrary(hmodExtendedMAPI);\n");
#endif

			ThunkFreeLibrary(hmodExtendedMAPI,
                                         bNativeExtendedMAPIDll,
                                         Context? TRUE : FALSE);
		}

		DeleteCriticalSection(&csGetProcAddress);
		DeleteCriticalSection(&csLinkedList);

#ifdef DEBUG

		DebugOutputFn(" *** DllMain(mapi32.dll (stub), DLL_PROCESS_DETACH);\n");
		DebugOutputFn("         (\"");
		DebugOutputFn(g_szProcessName);
		DebugOutputFn("\")\n");

#endif
	}

	return TRUE;
}


// Copied from o9\dev\win32\h\mailcli.h (ericwong 4/16/98)

/*----------------------------------------------------------------------------
	verWinNT()
	Find out if we are running on NT (otherwise Win9x)
 ----------------------------------------------------------------------------*/
DWORD	verWinNT()
{
	static DWORD verWinNT = 0;
	static fDone = FALSE;
	OSVERSIONINFO osv;

	if (!fDone)
	{
		osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
		// GetVersionEx can only fail if dwOSVersionInfoSize is not set correctly
		::GetVersionEx(&osv);
		verWinNT = (osv.dwPlatformId == VER_PLATFORM_WIN32_NT) ?
			osv.dwMajorVersion : 0;
		fDone = TRUE;
	}
	return verWinNT;
}


typedef UINT (WINAPI MSIPROVIDEQUALIFIEDCOMPONENTA)(
	LPCSTR  szCategory,   // component category ID
	LPCSTR  szQualifier,  // specifies which component to access
	DWORD   dwInstallMode,// either of type INSTALLMODE or a combination of the REINSTALLMODE flags
	LPSTR   lpPathBuf,    // returned path, NULL if not desired
	DWORD * pcchPathBuf); // in/out buffer character count
typedef MSIPROVIDEQUALIFIEDCOMPONENTA FAR * LPMSIPROVIDEQUALIFIEDCOMPONENTA;

static const TCHAR s_szLcid[] = "Software\\";
static const TCHAR s_szPolicy[] = "Software\\Policy\\";

BOOL FDemandInstall
	(HINSTANCE hinstMSI,
	LPCSTR szCategory,
	DWORD dwLcid,
	LPSTR szPath,
	DWORD * pcchPath,
	BOOL fInstall
        )
{
	UINT uiT;
	TCHAR szQualifier[16];	// "{lcid}\{NT|95}"

	LPMSIPROVIDEQUALIFIEDCOMPONENTA pfnMsiProvideQualifiedComponentA;

	Assert(hinstMSI);

	// Get MsiProvideQualifiedComponent()
	pfnMsiProvideQualifiedComponentA = (LPMSIPROVIDEQUALIFIEDCOMPONENTA)
		ThunkGetProcAddress(hinstMSI, "MsiProvideQualifiedComponentA",
                                    bNativeDll, 5);
	if (!pfnMsiProvideQualifiedComponentA)
		return FALSE;

	szPath[0] = 0;
	szQualifier[0] = 0;

	// 1. Try "dddd\{NT|95}" qualifier
	wsprintf(szQualifier, "%lu\\%s", dwLcid, verWinNT() ? "NT" : "95");	// STRING_OK

	uiT = pfnMsiProvideQualifiedComponentA(
		szCategory,
		szQualifier,
		(DWORD) INSTALLMODE_EXISTING,
		szPath,
		pcchPath);

	if (uiT != ERROR_FILE_NOT_FOUND && uiT != ERROR_INDEX_ABSENT)
		goto Done;

	if (fInstall && uiT == ERROR_FILE_NOT_FOUND)
	{
		uiT = pfnMsiProvideQualifiedComponentA(
			szCategory,
			szQualifier,
			INSTALLMODE_DEFAULT,
			szPath,
			pcchPath);

		goto Done;
	}

	// 2. Try "dddd" qualifier
	wsprintf(szQualifier, "%lu", dwLcid);	// STRING_OK

	uiT = pfnMsiProvideQualifiedComponentA(
		szCategory,
		szQualifier,
		(DWORD) INSTALLMODE_EXISTING,
		szPath,
		pcchPath);

	if (uiT != ERROR_FILE_NOT_FOUND && uiT != ERROR_INDEX_ABSENT)
		goto Done;

	if (fInstall && uiT == ERROR_FILE_NOT_FOUND)
	{
		uiT = pfnMsiProvideQualifiedComponentA(
			szCategory,
			szQualifier,
			INSTALLMODE_DEFAULT,
			szPath,
			pcchPath);

		goto Done;
	}

Done:

	return (uiT != ERROR_INDEX_ABSENT);
}

extern "C" BOOL STDAPICALLTYPE FGetComponentPath
	(LPSTR szComponent,
	LPSTR szQualifier,
	LPSTR szDllPath,
	DWORD cchBufferSize,
	BOOL fInstall)
{
	szDllPath[0] = '\0';

	HINSTANCE hinstMSI = NULL;

	DWORD cb;
	LPTSTR szLcid = NULL;
	HKEY hkeyLcid = NULL;
	LPTSTR szPolicy = NULL;
	HKEY hkeyPolicy = NULL;
	BOOL fDone = FALSE;
	LPTSTR szName;
	DWORD dwLcid;

	hinstMSI = ThunkLoadLibrary("MSI.DLL", &bNativeDll, FALSE,
                                            LOAD_WITH_ALTERED_SEARCH_PATH);
	if (!hinstMSI)
		goto Done;

	// Use defaults if no szQualifier
	if (szQualifier == NULL || szQualifier[0] == '\0')
	{
		fDone = TRUE;

		// Use default user LCID
		if (FDemandInstall(hinstMSI, szComponent, GetUserDefaultLCID(),
				szDllPath, &cchBufferSize, fInstall))
			goto Done;

		// Use default system LCID
		if (FDemandInstall(hinstMSI, szComponent, GetSystemDefaultLCID(),
				szDllPath, &cchBufferSize, fInstall))
			goto Done;

		// Use English as last resort
		if (FDemandInstall(hinstMSI, szComponent, 1033,
				szDllPath, &cchBufferSize, fInstall))
			goto Done;

		fDone = FALSE;

		goto Done;
	}

	// Open the Policy key
	cb = (lstrlen(s_szPolicy) + lstrlen(szQualifier) + 1) * sizeof(TCHAR);
	szPolicy = (LPTSTR) HeapAlloc(GetProcessHeap(), 0, cb);
	if (szPolicy)
	{
		lstrcpy(szPolicy, s_szPolicy);
		lstrcat(szPolicy, szQualifier);
		RegOpenKeyEx(HKEY_CURRENT_USER, szPolicy, 0, KEY_READ, &hkeyPolicy);
	}

	// Open the Lcid key
	cb = (lstrlen(s_szLcid) + lstrlen(szQualifier) + 1) * sizeof(TCHAR);
	szLcid = (LPTSTR) HeapAlloc(GetProcessHeap(), 0, cb);
	if (szLcid)
	{
		lstrcpy(szLcid, s_szLcid);
		lstrcat(szLcid, szQualifier);
		RegOpenKeyEx(HKEY_CURRENT_USER, szLcid, 0, KEY_READ, &hkeyLcid);
	}

	// Get first registry value name
	szName = &szQualifier[lstrlen(szQualifier) + 1];

	// Loop till component found or we're out of registry value names
	while (szName[0] != '\0' && !fDone)
	{
		DWORD dwType, dwSize;

		dwSize = sizeof(dwLcid);

		if ((hkeyPolicy &&	/* Check Policy first */
				RegQueryValueEx(hkeyPolicy, szName, 0, &dwType,
					(LPBYTE) &dwLcid, &dwSize) == ERROR_SUCCESS &&
				dwType == REG_DWORD) ||
			(hkeyLcid &&	/* Then Lcid */
				RegQueryValueEx(hkeyLcid, szName, 0, &dwType,
					(LPBYTE) &dwLcid, &dwSize) == ERROR_SUCCESS &&
				dwType == REG_DWORD))
			fDone = FDemandInstall(hinstMSI, szComponent, dwLcid,
				szDllPath, &cchBufferSize, fInstall);

		szName = &szName[lstrlen(szName) + 1];	// Next registry value name
	}

Done:

	if (hkeyPolicy)
		RegCloseKey(hkeyPolicy);

	if (szPolicy)
		HeapFree(GetProcessHeap(), 0, (LPVOID) szPolicy);

	if (hkeyLcid)
		RegCloseKey(hkeyLcid);

	if (szLcid)
		HeapFree(GetProcessHeap(), 0, (LPVOID) szLcid);

	if (hinstMSI)
		ThunkFreeLibrary(hinstMSI, bNativeDll, 0);

	return fDone;
}


BOOL FAlwaysNeedsMSMAPI(LPSTR szDllPath, DWORD cbBufferSize)
{
	BOOL fNeedsMSMAPI = FALSE;

	HKEY hkeyRoot = NULL;

	LONG lResult = ::RegOpenKeyEx(HKEY_LOCAL_MACHINE,
			TEXT("SOFTWARE\\Microsoft\\Windows Messaging Subsystem\\MSMapiApps"),
			0, KEY_READ, &hkeyRoot);

	if (ERROR_SUCCESS == lResult)
	{
		TCHAR szValueName[256];

		DWORD dwSize;
		DWORD dwIndex = 0;
		DWORD dwType;
		DWORD cbBuffer;

		do
		{
			dwSize = sizeof(szValueName) / sizeof(TCHAR);

			if (NULL == szDllPath)
			{
				// Office9 203539
				// Can be called just to check in-proc dlls
				lResult = ::RegEnumValue(hkeyRoot, dwIndex++,
								szValueName, &dwSize, NULL,
								&dwType, NULL, NULL);
			}
			else
			{
				// Reset buffer on each iteration
				szDllPath[0] = '\0';
				cbBuffer = cbBufferSize;

				lResult = ::RegEnumValue(hkeyRoot, dwIndex++,
								szValueName, &dwSize, NULL,
								&dwType, (LPBYTE) szDllPath, &cbBuffer);
			}

			if (ERROR_SUCCESS == lResult)
			{
				if (NULL != ThunkGetModuleHandle(szValueName))
				{
					fNeedsMSMAPI = TRUE;

					break;
				}
			}
		} while (ERROR_SUCCESS == lResult);

		::RegCloseKey(hkeyRoot);
	}

	return fNeedsMSMAPI;
}


// $NOTE (ericwong 7-15-98) Copied from mso9\office.cpp

/*---------------------------------------------------------------------------
	MsoSzFindSzInRegMultiSz
	
	Search a multi-string structure (matching the format used by REG_MULTI_SZ)
	for a string matching the provided string.
	
	ARGUMENTS
	
	cmszMultiSz		REG_MULTI_SZ string list
	cszSrchStr		String to search for
	lcidLocale		Locale to use when comparing strings
	
	RETURNS
	
	NULL on failure to find search string.
	Pointer to occurence of search string on success.
----------------------------------------------------------------- joeldow -*/
char* MsoSzFindSzInRegMultiSz(const char* cmszMultiSz, const char* cszSrchStr, LCID lcidLocale)
{
	DWORD 		dwMultiLen;								// Length of current member
	DWORD		dwSrchLen	= lstrlenA(cszSrchStr);	// Constant during search
//	const int	CSTR_EQUAL	= 2;						// per winnls.h
	
	while (*cmszMultiSz)							// Break on consecutive zero bytes
	{
		// Format is Str1[\0]Str2[\0]Str3[\0][\0]
		dwMultiLen = lstrlenA(cmszMultiSz);
		
		Assert(dwMultiLen > 0 /*, "String parsing logic problem" */);
		
		if (dwMultiLen == dwSrchLen &&
			CompareStringA(lcidLocale, 0, cmszMultiSz, dwMultiLen, cszSrchStr, dwSrchLen) == CSTR_EQUAL)
			return (char*)cmszMultiSz;
			
		cmszMultiSz += (dwMultiLen + 1);			// Modify index into constant, not constant...
	}
	
	return NULL;
}

/*---------------------------------------------------------------------------
	MsoFIsTerminalServer

	Are we running under Windows-Based Terminal Server (a.k.a. Hydra)?
	Hydra is a thin-client environment where low-end machines can run Win32
	apps.  All application logic runs on the server, and display bits and
	user input are transmitted through a LAN/dialup connection.

	Use this routine to fork behavior on animation/sound-intensive features
	(e.g., splashes) to minimize unnecessary bits forced across the network.
	
	Sermonette of the day:  If we do a good job supporting Office on $500
	WBTs, how many of our customers will choose NCs and second-rate
	productivity apps instead?
	
	NOTE:  This function does not use ORAPI because ORAPI doesn't currently
	support REG_MULTI_SZ's.  (It also has no need for policy or defaults.)
	Using ANSI registry calls because product information strings should be
	non-localized ANSI text.
----------------------------------------------------------------- joeldow -*/
// Activate this to allow testing of Hydra features on standard machine.
//#define TEST_EXCEPT
BOOL MsoFIsTerminalServerX(void)
{
	const char*		cszSrchStr		= "Terminal Server";	// STRING_OK
	const char*		cszKey			= "System\\CurrentControlSet\\Control\\ProductOptions";	// STRING_OK
	const char*		cszValue		= "ProductSuite";	// STRING_OK
	char*			pszSuiteList	= NULL;
#ifndef TEST_EXCEPT
	static BOOL		fIsHydra		= FALSE;	
	static BOOL		fHydraDetected	= FALSE;
#else
	static BOOL		fIsHydra		= TRUE;	
	static BOOL		fHydraDetected	= TRUE;
#endif	
	DWORD			dwSize			= 0;
	DWORD			dwSizeRead;
	HKEY			hkey			= NULL;
	DWORD			dwType;
	
	if (fHydraDetected)
		return fIsHydra;						// Get out cheap...
	
 	// On NTS5, the ProductSuite "Terminal Server" value will always be present.
	// Need to call NT5-specific API to get the right answer.
	if (verWinNT() > 4)
 	{
		OSVERSIONINFOEXA osVersionInfo = {0};
		DWORDLONG dwlConditionMask = 0;

		osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
		osVersionInfo.wSuiteMask = VER_SUITE_TERMINAL;

 	    VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_AND );

// 	    fIsHydra = MsoFVerifyVersionInfo(
 	    fIsHydra = VerifyVersionInfo(
			&osVersionInfo,
			VER_SUITENAME,
			dwlConditionMask);
 	}
	// If the value we want exists and has a non-zero size...
	else if (verWinNT() == 4 &&
		RegOpenKeyA(HKEY_LOCAL_MACHINE, cszKey, &hkey) == ERROR_SUCCESS &&
		RegQueryValueExA(hkey, cszValue, NULL, &dwType, NULL, &dwSize) == ERROR_SUCCESS && dwSize > 0)
	{
		Assert(dwType == REG_MULTI_SZ /*, "Unexpected ProductSuite type in registry!" */);
			
		pszSuiteList = (char*) HeapAlloc(GetProcessHeap(), 0, dwSize);
		if (dwType == REG_MULTI_SZ && pszSuiteList)
		{
			dwSizeRead = dwSize;				// Needed for proper release of memory on error.
				
			if (RegQueryValueExA(hkey, cszValue, NULL, &dwType, (BYTE*)pszSuiteList, &dwSizeRead) == ERROR_SUCCESS)
			{
				Assert(dwSizeRead == dwSize);
					
				fIsHydra = MsoSzFindSzInRegMultiSz(pszSuiteList, cszSrchStr, CP_ACP) != NULL;
			}
			
			HeapFree(GetProcessHeap(), 0, (LPVOID) pszSuiteList);
		}			
	}

	if (hkey)
        RegCloseKey(hkey);		
	
	fHydraDetected = TRUE;						// only bother with all this once...
	
	return fIsHydra;
}

BOOL FGetMapiDll(HKEY hkeyRoot, LPSTR szDllPath, DWORD cbBufferSize, BOOL fSimple)
{
	szDllPath[0] = '\0';

	DWORD cbBufferSizeT;
	DWORD dwType;

	HKEY hkey = NULL;
	LONG lResult;

	// Open the key to find out what the default mail program is.

	lResult = ::RegOpenKeyEx(hkeyRoot,
						"Software\\Clients\\Mail", 0, KEY_READ, &hkey);

	if (ERROR_SUCCESS == lResult)
	{
		char szMailKey[MAX_PATH + 1] = "";
		char szDefaultMail[MAX_PATH + 1];

		// Office9 195750
		// Let HKLM\Software\Microsoft\Windows Messaging Subsystem\MSMapiApps
		// DLL reg values indicate mail client to which MAPI calls get sent.
		if (FAlwaysNeedsMSMAPI(szMailKey, sizeof(szMailKey)))
		{
			if (szMailKey[0] != '\0')
			{
				// Mail client supplied
				lstrcpy(szDefaultMail, szMailKey);
				lResult = ERROR_SUCCESS;
			}
			else
			{
				// No mail client, use mapi32x.dll
				lResult = ERROR_PATH_NOT_FOUND;
			}
		}
		else
		{
			DWORD dwSize = sizeof(szDefaultMail);

			// Find out what the default mail program is.

			lResult = ::RegQueryValueEx(hkey, NULL,	NULL, NULL, (LPBYTE) szDefaultMail, &dwSize);
		}

		if (ERROR_SUCCESS == lResult)
		{
			HKEY hkeyDefaultMail = NULL;

			// Open the key for the default mail program to see where the dll is.

			lResult = ::RegOpenKeyEx(hkey, szDefaultMail, 0, KEY_READ, &hkeyDefaultMail);

			if (ERROR_SUCCESS == lResult)
			{
				TCHAR szComponent[39] = {0};	// strlen(GUID)

				DWORD dwMSIInstallOnWTS;
				LPTSTR szMSIOfficeLCID = NULL;
				LPTSTR szMSIApplicationLCID = NULL;

				// Get MSIInstallOnWTS, 0 means don't demand-install on Hydra
				cbBufferSizeT = sizeof(dwMSIInstallOnWTS);
				lResult = ::RegQueryValueEx(hkeyDefaultMail,
								"MSIInstallOnWTS",
								NULL, &dwType, (LPBYTE) &dwMSIInstallOnWTS, &cbBufferSizeT);
				
				if (ERROR_SUCCESS == lResult && REG_DWORD == dwType)
				{
					// Use what is returned
				}
				else
				{
					dwMSIInstallOnWTS = 1;	// Default is TRUE
				}

				// Get MSIApplicationLCID
				lResult = ::RegQueryValueEx(hkeyDefaultMail,
								"MSIApplicationLCID",
								NULL, &dwType, NULL, &cbBufferSizeT);

				if (ERROR_SUCCESS == lResult && REG_MULTI_SZ == dwType)
				{
					szMSIApplicationLCID = (LPTSTR)
						HeapAlloc(GetProcessHeap(), 0, cbBufferSizeT);

					if (szMSIApplicationLCID)
					{
						lResult = ::RegQueryValueEx(hkeyDefaultMail,
										"MSIApplicationLCID",
										NULL, &dwType,
										(LPBYTE) szMSIApplicationLCID,
										&cbBufferSizeT);
						Assert(ERROR_SUCCESS == lResult && REG_MULTI_SZ == dwType);
					}
				}

				// Get MSIOfficeLCID
				lResult = ::RegQueryValueEx(hkeyDefaultMail,
								"MSIOfficeLCID",
								NULL, &dwType, NULL, &cbBufferSizeT);
				
				if (ERROR_SUCCESS == lResult && REG_MULTI_SZ == dwType)
				{
					szMSIOfficeLCID = (LPTSTR)
						HeapAlloc(GetProcessHeap(), 0, cbBufferSizeT);

					if (szMSIOfficeLCID)
					{
						lResult = ::RegQueryValueEx(hkeyDefaultMail,
										"MSIOfficeLCID",
										NULL, &dwType,
										(LPBYTE) szMSIOfficeLCID,
										&cbBufferSizeT);
						Assert(ERROR_SUCCESS == lResult && REG_MULTI_SZ == dwType);
					}
				}

				// Find out what the component is.
				cbBufferSizeT = sizeof(szComponent);
				lResult = ::RegQueryValueEx(hkeyDefaultMail,
								"MSIComponentID",
								NULL, &dwType, (LPBYTE) szComponent, &cbBufferSizeT);
				
				if (ERROR_SUCCESS == lResult && REG_SZ == dwType)
				{
					BOOL fInstall;

					// Office 9 does not permit demand-install on Hydra
					fInstall = dwMSIInstallOnWTS || !MsoFIsTerminalServerX();

					// First try Application's LCID(s)
					if (szMSIApplicationLCID &&
						FGetComponentPath(szComponent, szMSIApplicationLCID,
							szDllPath, cbBufferSize, fInstall))
						goto CloseDefaultMail;

					// Then try Office's LCID(s)
					if (szMSIOfficeLCID &&
						FGetComponentPath(szComponent, szMSIOfficeLCID,
							szDllPath, cbBufferSize, fInstall))
						goto CloseDefaultMail;

					// Finally try the defaults
					if (FGetComponentPath(szComponent, NULL,
							szDllPath, cbBufferSize, fInstall))
						goto CloseDefaultMail;
				}

				// Find out what the dll is.
				cbBufferSizeT = cbBufferSize;
				lResult = ::RegQueryValueEx(hkeyDefaultMail,
								fSimple ? "DLLPath" : "DLLPathEx",
								NULL, &dwType, (LPBYTE) szDllPath, &cbBufferSizeT);
				if (ERROR_SUCCESS != lResult)
				{
					szDllPath[0] = '\0';
				}
				else
					if(REG_EXPAND_SZ == dwType)
					{
						char szExpandedPath[MAX_PATH];
						if(ExpandEnvironmentStrings(szDllPath, szExpandedPath, MAX_PATH) > 0)
							lstrcpy(szDllPath, szExpandedPath);
					}
						
CloseDefaultMail:

				if (szMSIApplicationLCID)
					HeapFree(GetProcessHeap(), 0, (LPVOID) szMSIApplicationLCID);

				if (szMSIOfficeLCID)
					HeapFree(GetProcessHeap(), 0, (LPVOID) szMSIOfficeLCID);

				::RegCloseKey(hkeyDefaultMail);
			}
		}

		::RegCloseKey(hkey);
	}

	return ('\0' != szDllPath[0]);
}

// How to find the MAPI Dll:
//
// Go to HKLM\Software\Clients\Mail\(Default) to get the name of the
// default mail client.  Then go to
//     HKLM\Software\Clients\Mail\(Name of default mail client)\DLLPath
// to get the name of the dll.
// If the regkey doesn't exist, just use mapi32x.dll

void GetMapiDll(LPSTR szDllPath, DWORD cbBufferSize, BOOL fSimple)
{
	szDllPath[0] = '\0';

	// Office9 ?
	// Allow app (namely Platinum Server) to take unhandled extended MAPI
	// calls rather than send them to mapi32x.dll (system MAPI)
	if (!fSimple && !FAlwaysNeedsMSMAPI(NULL, 0))
	{
		DWORD dwError;
		HKEY hkeyMail;

		OFSTRUCT ofs;

		// Get HKLM\Software\Clients\Mail registry key
		dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
			TEXT("Software\\Clients\\Mail"), 0, KEY_READ, &hkeyMail);
		if (dwError == ERROR_SUCCESS)
		{
			DWORD dwType;
			DWORD cbBufferSizeT = cbBufferSize;

			// Get DLLPathEx registry value
			dwError = RegQueryValueEx(hkeyMail, TEXT("DLLPathEx"), NULL,
				&dwType, (LPBYTE) szDllPath, &cbBufferSizeT);
			if (dwError == ERROR_SUCCESS)
			{
				if (dwType == REG_EXPAND_SZ)
				{
					char szExpandedPath[MAX_PATH];

					if (ExpandEnvironmentStrings
							(szDllPath, szExpandedPath, MAX_PATH) > 0)
						lstrcpy(szDllPath, szExpandedPath);
				}
				else if (dwType == REG_SZ)
				{
					// OK, do nothing
				}
				else
				{
					// Empty string
					szDllPath[0] = '\0';
				}
			}

			RegCloseKey(hkeyMail);
		}

		// Bail if DLLPathEx retrieved and file exists
		if (('\0' != szDllPath[0]) &&
			(OpenFile(szDllPath, &ofs, OF_EXIST) != HFILE_ERROR))
			return;
	}

	// Office9 120315
	// Get MAPI-substitute from HKCU or HKLM
	if (FGetMapiDll(HKEY_CURRENT_USER, szDllPath, cbBufferSize, fSimple) ||
		FGetMapiDll(HKEY_LOCAL_MACHINE, szDllPath, cbBufferSize, fSimple))
		return;


	if ('\0' == szDllPath[0])
	{
		Assert(cbBufferSize >= 13);

		MyStrCopy(szDllPath, "mapi32x.dll");
	}

	Assert('\0' != szDllPath[0]);

}


BOOL FShowPreFirstRunMessage()
{
	static BOOL fPreFirstRun = FALSE;

	DWORD cbBufferSizeT;
	DWORD dwType;

	HKEY hkey = NULL;
	LONG lResult;

	// Office9 98186, 104097
	// Display message if PreFirstRun registry value present
	if (!fPreFirstRun)
	{
		lResult = ::RegOpenKeyEx(HKEY_LOCAL_MACHINE,
							"Software\\Clients\\Mail", 0, KEY_READ, &hkey);

		if (ERROR_SUCCESS == lResult)
		{
			LPTSTR szPreFirstRun = NULL;
			LPTSTR szText;
			LPTSTR szCaption;
			TCHAR * pch;
			BOOL fNoMailClient = FALSE;

			// Get the required buffer size
			cbBufferSizeT = 0;
			lResult = ::RegQueryValueEx(hkey,
							"PreFirstRun",
							NULL, NULL, NULL, &cbBufferSizeT);

			if (ERROR_SUCCESS != lResult)
			{
				// Office9 161532
				// Display message if NoMailClient registry value present
				cbBufferSizeT = 0;
				lResult = ::RegQueryValueEx(hkey,
								"NoMailClient",
								NULL, NULL, NULL, &cbBufferSizeT);

				if (ERROR_SUCCESS != lResult)
					goto Done;

				fNoMailClient = TRUE;
			}

			// Allocate buffer
			szPreFirstRun = (LPTSTR) HeapAlloc(GetProcessHeap(), 0, cbBufferSizeT);
			if (!szPreFirstRun)
				goto Done;

			// Get PreFirstRun warning
			lResult = ::RegQueryValueEx(hkey,
							fNoMailClient ? "NoMailClient" : "PreFirstRun",
							NULL, &dwType, (LPBYTE) szPreFirstRun, &cbBufferSizeT);

			if (ERROR_SUCCESS != lResult ||
				REG_SZ != dwType ||
				'\0' == szPreFirstRun[0])
				goto Done;

			// szPreFirstRun = "<text>{*<caption>}"
			szText = szPreFirstRun;

			// Find end of <text> to get <caption>
			pch = szPreFirstRun;
			while (*pch && *pch != '*')
				pch = CharNext(pch);

			// Handle no <caption>
			if (!*pch)
			{
				szCaption = NULL;
			}
			else	// Got '*'
			{
				szCaption = CharNext(pch);
				if (!*szCaption)
					szCaption = NULL;
			}
			*pch = '\0';

			// Display PreFirstRun warning
			MessageBoxFn(szText, szCaption, MB_TASKMODAL);

			// Only show PreFirstRun warning once
			fPreFirstRun = TRUE;

Done:

			// Free buffer
			if (szPreFirstRun)
				HeapFree(GetProcessHeap(), 0, (LPVOID) szPreFirstRun);

			::RegCloseKey(hkey);
		}
	}

	return fPreFirstRun;
}


HMODULE GetProxyDll(BOOL fSimple)
{
    char szLibrary[MAX_PATH + 1] = "";

    HMODULE * phmod = fSimple ? &hmodSimpleMAPI : &hmodExtendedMAPI;

    if (NULL == *phmod)
    {
        // We have a few special cases here.  We know that the omi and
        // msmapi32 dlls are both Simple and Extended MAPI dlls.  If an
        // application (like outlook!) has already loaded one of them,
        // we should just keep using it instead of going to the registry
        // and possibly getting the wrong dll.

        // Notice that we still call MyLoadLibrary() so we can get the
        // right dll (see MyLoadLibrary() for descriptions of OS bugs)
        // and so that the dll will be properly ref-counted.

        // Legacy MAPI apps like Outlook 97/98, Exchange 4.x/5.x and
        // Schedule+ should get their calls redirected to the system
        // mapi32x.dll. They're checked in FAlwaysNeedsMSMAPI().

		// 1. Handle MAPI calls from Outlook extensions
        if (ThunkGetModuleHandle("omi9.dll"))
        {
            *phmod = MyLoadLibrary("omi9.dll", hinstSelf);
        }
        else if (ThunkGetModuleHandle("omint.dll"))
        {
            *phmod = MyLoadLibrary("omint.dll", hinstSelf);
        }
        else if (ThunkGetModuleHandle("msmapi32.dll"))
        {
            *phmod = MyLoadLibrary("msmapi32.dll", hinstSelf);
        }

		// 2. Look in mail client key
        else
        {
			OFSTRUCT ofs;

            GetMapiDll(szLibrary, sizeof(szLibrary), fSimple);

			// NOTE 1:
			// Outlook 9 sets DLLPath=mapi32.dll for IE mailto: forms.
			// If Outlook is set as the default mail client before
			// First Run is finished (and MSIComponentID written),
			// the stub will read DLLPath instead and end up in an
			// infinite loop loading mapi32.dll (itself).

			// NOTE 2:
			// Windows 95 ships with mapi32.dll that gets renamed
			// mapi32x.dll when the stub is installed. That means
			// an extended MAPI call will always get routed to
			// mapi32x.dll if the default mail client does not
			// handle it, which brings up the Profile wizard with
			// an error saying mapisvc.inf is missing. If we're
			// going to route an extended MAPI call to "mapi32x.dll",
			// there must also be "mapisvc.inf" present.

			// NOTE 3:
			// To fix Office9 161532, I'll have to remove the fSimple
			// so no MAPI calls go to the original mapi32.dll unless
			// mapisvc.inf is present, indicating another mail client.

			// NOTE 4:
			// If a special dll is making the MAPI call and it's being
			// routed to mapi32x.dll, it's ok to forgo the mapisvc.inf
			// check. (Office9 203539, caused by Office9 195750)

			if (lstrcmp(szLibrary, "mapi32.dll") != 0 /* NOTE 1 */ &&
				(/* NOTE 2 */ /* NOTE 3 fSimple || */
				lstrcmp(szLibrary, "mapi32x.dll") != 0 ||
				(OpenFile("mapisvc.inf", &ofs, OF_EXIST) != HFILE_ERROR) ||
				/* NOTE 4 */ FAlwaysNeedsMSMAPI(NULL, 0)))
				*phmod = MyLoadLibrary(szLibrary, hinstSelf);

			if (!*phmod)
				FShowPreFirstRunMessage();
        }
    }

    return *phmod;
}




extern "C" DWORD STDAPICALLTYPE GetOutlookVersion(void)
{
	return OUTLOOKVERSION;
}


/*
 *	M A P I   S t u b   R e p a i r   T o o l
 *
 */

enum MAPI
{
	mapiNone,		// No mapi32.dll in system directory
	mapiNewStub,	// mapi32.dll is current stub
	mapiOldMS,		// mapi32.dll from Win 95, NT 4, Exchange 4.x 5.x
	mapiEudora,		// mapi32.dll from Eudora
	mapiNetscape,	// mapi32.dll from Netscape
	mapiMapi32x,	// mapi32x.dll is original mapi32.dll
	mapiMapi32OE,	// mapi32.oe is original mapi32.dll from Outlook 98
	mapiMSMapi32,	// msmapi32.dll is original mapi32.dll from Outlook 9
};

#define MAPI_NONE     TEXT("")
#define MAPI_NEW_STUB TEXT("\\mapistub.dll")
#define MAPI_OLDMS    TEXT("\\mapi32.dll")
#define MAPI_EUDORA   TEXT("\\eumapi32.dll")
#define MAPI_NETSCAPE TEXT("\\nsmapi32.dll")
#define MAPI_MAPI32X  TEXT("\\mapi32x.dll")
#define MAPI_MAPI32OE TEXT("\\mapi32.oe")
#define MAPI_MSMAPI32 TEXT("\\msmapi32.dll")

// Keep in sync with enum table above
static LPTSTR rgszDLL[] =
{
	MAPI_NONE,
	MAPI_NEW_STUB,
	MAPI_OLDMS,
	MAPI_EUDORA,
	MAPI_NETSCAPE,
	MAPI_MAPI32X,
	MAPI_MAPI32OE,
	MAPI_MSMAPI32
};

/*
 *	RegisterMailClient
 *
 *	HKLM\Software\Clients\Mail\<pszMailClient>
 *	HKLM\Software\Clients\Mail\<pszMailClient>::"" = <pszMailClient>
 *	HKLM\Software\Clients\Mail\<pszMailClient>::"DLLPath" = <szMAPI32XDLL>
 *	HKLM\Software\Clients\Mail\<pszMailClient>::"DLLPathEx" = <szMAPI32XDLL>
 *	HKLM\Software\Clients\Mail::"" = <pszMailClient> (default mail client)
 */

DWORD RegisterMailClient
	(LPTSTR pszMailClient,
	BOOL fSimpleMAPI,
	BOOL fExtendedMAPI,
	LPTSTR szMAPI32XDLL)
{
	DWORD dwError = ERROR_SUCCESS;

	HKEY hkeyDefaultMail = NULL;
	HKEY hkeyMailClient = NULL;
	DWORD dwDisposition;

	AssertSz(pszMailClient, "No registry key name");

	// Get mail clients registry key
	dwError = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
		TEXT("Software\\Clients\\Mail"), 0, NULL, 0, KEY_ALL_ACCESS, NULL,
		&hkeyDefaultMail, NULL);
	if (dwError != ERROR_SUCCESS)
		goto Error;

	// Create new registry key, ok to overwrite existing key
	dwError = RegCreateKeyEx(hkeyDefaultMail, pszMailClient, 0, NULL, 0,
		KEY_ALL_ACCESS, NULL, &hkeyMailClient, &dwDisposition);
	if (dwError != ERROR_SUCCESS)
		goto Error;

	// Set mail client name if there isn't already one
	if (dwDisposition == REG_CREATED_NEW_KEY)
		RegSetValueEx(hkeyMailClient, TEXT(""), 0, REG_SZ,
			(LPBYTE) pszMailClient, lstrlen(pszMailClient));

	// Set DLLPath
	if (fSimpleMAPI)
		RegSetValueEx(hkeyMailClient, TEXT("DLLPath"), 0, REG_SZ,
			(LPBYTE) szMAPI32XDLL, lstrlen(szMAPI32XDLL));

	// Set DLLPathEx
	if (fExtendedMAPI)
		RegSetValueEx(hkeyMailClient, TEXT("DLLPathEx"), 0, REG_SZ,
			(LPBYTE) szMAPI32XDLL, lstrlen(szMAPI32XDLL));

	// Set default mail client
	RegSetValueEx(hkeyDefaultMail, TEXT(""), 0, REG_SZ,
		(LPBYTE) pszMailClient, lstrlen(pszMailClient));

	// $REVIEW 3-4-98 Should I copy the protocols to HKCR?

Error:

	if (hkeyMailClient)
		RegCloseKey(hkeyMailClient);

	if (hkeyDefaultMail)
		RegCloseKey(hkeyDefaultMail);

	return dwError;
}


extern "C" typedef UINT (* PFN_GETSYSTEMDIRECTORY)(LPTSTR, UINT);
STDAPICALLTYPE FixMAPIPrivate(PFN_GETSYSTEMDIRECTORY GetSystemDirectory,
                              LPCTSTR szMAPIStubDirectory);

extern "C" DWORD STDAPICALLTYPE FixMAPI(void)
{

    DWORD dwError;

    TCHAR szMAPIStubDLL[MAX_PATH];

    // Both mapistub.dll and wimapi32.dll reside in the system directory

    if (!GetSystemDirectory(szMAPIStubDLL, sizeof(szMAPIStubDLL)))
    {
        return GetLastError();
    }

    dwError = FixMAPIPrivate(GetSystemDirectory, szMAPIStubDLL);

    return dwError;
}

/*
 *	FExchangeServerInstalled
 *
 *	Exchange Server is installed if the Services registry value exists
 *	under HKLM\Software\Microsoft\Exchange\Setup registry key
 */

BOOL FExchangeServerInstalled()
{
	DWORD dwError;
	HKEY hkeyServices = NULL;

	// Get HKLM\Software\Microsoft\Exchange\Setup registry key
	dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		TEXT("Software\\Microsoft\\Exchange\\Setup"), 0, KEY_READ,
		&hkeyServices);
	if (dwError == ERROR_SUCCESS)
	{
		// Does Services registry value exist?
		dwError = RegQueryValueEx(hkeyServices,
			TEXT("Services"), NULL, NULL, NULL, NULL);
	}

	if (hkeyServices)
		RegCloseKey(hkeyServices);

	return (dwError == ERROR_SUCCESS);
}

/*
 *	FixMAPI
 *
 *	Part 1: Initialize paths to mapi files
 *	Part 2: Is mapi32.dll a mapiNone mapiNewStub mapiOldMS or ?
 *	Part 3: Move and copy various mapi files
 *	Part 4: Register mapi32x.dll and non-MS mapi32.dll
 *
 */

STDAPICALLTYPE FixMAPIPrivate(PFN_GETSYSTEMDIRECTORY pfGetSystemDirectory,
                              LPCTSTR szMAPIStubDirectory)
{
	DWORD dwError = ERROR_SUCCESS;

	TCHAR szSystemDir[MAX_PATH];	// Path to system directory
	TCHAR szMAPI32DLL[MAX_PATH];	// Path to mapi32.dll
	TCHAR szMAPIStubDLL[MAX_PATH];	// Path to mapistub.dll
	TCHAR szMAPI32OE[MAX_PATH];		// Path to mapi32.oe
	TCHAR szMSMAPI32DLL[MAX_PATH];	// Path to msmapi32.dll
	TCHAR szMAPI32XDLL[MAX_PATH];	// Path to mapi32x.dll
	TCHAR szNonMSDLL[MAX_PATH];		// Path to non-MS mapi32.dll

	MAPI mapi = mapiNone;

	HINSTANCE hinst;
	BOOL fSimpleMAPI = FALSE;
	BOOL fExtendedMAPI = FALSE;

	// Office9 119757, 120419
	// Don't install the stub if Exchange Server is installed
	if (FExchangeServerInstalled())
		goto Error;

	// *** PART 1: Initialize paths



	if (!(pfGetSystemDirectory(szSystemDir, sizeof(szSystemDir))))
    {
        dwError = GetLastError();
        goto Error;
    }

    lstrcpyn(szMAPI32DLL, 
             szSystemDir, 
             (sizeof(szMAPI32DLL)-sizeof(MAPI_OLDMS))/sizeof(szMAPI32DLL[0]));
    lstrcat(szMAPI32DLL, MAPI_OLDMS);

    lstrcpyn(szMAPIStubDLL, 
             szMAPIStubDirectory, 
             (sizeof(szMAPIStubDLL)-sizeof(MAPI_NEW_STUB))/sizeof(szMAPIStubDLL[0]));
    lstrcat(szMAPIStubDLL, MAPI_NEW_STUB);

    lstrcpyn(szMAPI32OE, 
             szSystemDir, 
             (sizeof(szMAPI32OE)-sizeof(MAPI_MAPI32OE))/sizeof(szMAPI32OE[0]));
    lstrcat(szMAPI32OE, MAPI_MAPI32OE);

    lstrcpyn(szMSMAPI32DLL, 
             szSystemDir, 
             (sizeof(szMSMAPI32DLL)-sizeof(MAPI_MSMAPI32))/sizeof(szMSMAPI32DLL[0]));
    lstrcat(szMSMAPI32DLL, MAPI_MSMAPI32);

    lstrcpyn(szMAPI32XDLL, 
             szSystemDir, 
             (sizeof(szMAPI32XDLL)-sizeof(MAPI_MAPI32X))/sizeof(szMAPI32XDLL[0]));
    lstrcat(szMAPI32XDLL, MAPI_MAPI32X);

    lstrcpyn(szNonMSDLL, 
             szSystemDir, 
             (sizeof(szNonMSDLL)-sizeof(MAPI_NETSCAPE))/sizeof(szNonMSDLL[0]));

	// *** PART 2: Determine mapi32.dll type

	AssertSz(mapi == mapiNone, "mapi is undefined");

	// Does it exist?  No, go to Part3
	if (GetFileAttributes(szMAPI32DLL) == 0xFFFFFFFF)
		goto Part3;

	// Is it the stub?

        // Note for WX86: If whmapi32 links to mapi32 instead of
        // linking to mapistub, the following is relevant. It is
        // no longer needed (and the 4th argument to ThunkLoadLibrary
        // is no longer needed - it could always be
        // LOAD_WITH_ALTERED_SEARCH_PATH), but leave it in just in case
        // we need this in the future. Note that it does not hurt to
        // not resolve dll references for this load because we are
        // just going to do a GetProcAddress.
        //
        // If whmapi32 is linked to mapi32:
        //
        // If the mapi32 in the x86 system directory is wimapi,
        // the WX86 loader will fail to load it. wimapi32 links
        // whmapi32 which links mapi32. The loader resolves the
        // link to mapi32 as sys32x86\mapi32 (= wimapi32).
        // Apparently this is by design. The load fails.
        //
        // To work around this, we use the
        // DONT_RESOLVE_DLL_REFERENCES flag. This will allow us
        // to check if mapi32 is wimapi32 by doing a
        // GetProcAddress.

	hinst = ThunkLoadLibrary(szMAPI32DLL, &bNativeDll, FALSE,
                                 DONT_RESOLVE_DLL_REFERENCES);
	if (hinst)
	{
		mapi = mapiOldMS;

		// Only the stub has "GetOutlookVersion"
		if (GetProcAddress(hinst, TEXT("GetOutlookVersion")))
			mapi = mapiNewStub;

		// Check for Eudora mapi32.dll
		if (GetProcAddress(hinst, TEXT("IsEudoraMapiDLL")))
			mapi = mapiEudora;

		// Check for Netscape mapi32.dll
		if (GetProcAddress(hinst, TEXT("MAPIGetNetscapeVersion")))
			mapi = mapiNetscape;

		// Check for Simple MAPI
		if (GetProcAddress(hinst, TEXT("MAPILogon")))
			fSimpleMAPI = TRUE;

		// Check for Extended MAPI
		if (GetProcAddress(hinst, TEXT("MAPILogonEx")))
			fExtendedMAPI = TRUE;

		ThunkFreeLibrary(hinst, bNativeDll, 0);
	}

Part3:

	// *** PART 3: Restore files

	// Rename non-MS mapi32.dll, ok to overwrite existing dll
	if (mapi == mapiEudora || mapi == mapiNetscape)
	{
		if (!(lstrcat(szNonMSDLL, rgszDLL[mapi]) &&
			CopyFile(szMAPI32DLL, szNonMSDLL, FALSE)))
		{
			dwError = GetLastError();
			goto Error;
		}
	}

	// Deal with missing mapi32x.dll (OE case on non-NT5)
	if (mapi == mapiOldMS)
	{
		// Copy old mapi32.dll to mapi32x.dll
		DeleteFile(szMAPI32XDLL);
		if (!MoveFile(szMAPI32DLL, szMAPI32XDLL))
		{
			dwError = GetLastError();
			goto Error;
		}

		// Get rid of old stubs so they don't replace mapi32x.dll
		// if FixMAPI() is called again
		DeleteFile(szMAPI32OE);
		DeleteFile(szMSMAPI32DLL);
	}
	else	// Clean up after old stubs
	{
		OFSTRUCT ofs;

		// X5 78382
		// Outlook 98 OMI stub renamed original mapi32.dll as mapi32.oe
		if (OpenFile(szMAPI32OE, &ofs, OF_EXIST) != HFILE_ERROR)
		{
			// Copy old mapi32.oe to mapi32x.dll
			DeleteFile(szMAPI32XDLL);
			if (!MoveFile(szMAPI32OE, szMAPI32XDLL))
			{
				dwError = GetLastError();
				goto Error;
			}
		}

		// Office9 214650
		// Copy Outlook 98 OMI mode backup mapi32.dll as mapi32x.dll
		{
			HKEY hkeyInstall;
			TCHAR szDllPath[MAX_PATH] = {0};

			// Get HKLM\Software\Microsoft\Active Setup\OutlookInstallInfo
			dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
				TEXT("Software\\Microsoft\\Active Setup\\OutlookInstallInfo"),
				0, KEY_READ, &hkeyInstall);
			if (dwError == ERROR_SUCCESS)
			{
				DWORD dwType;
				DWORD cbBufferSize = sizeof(szDllPath);

				// Get Install Dir registry value
				dwError = RegQueryValueEx(hkeyInstall, TEXT("Install Dir"),
					NULL, &dwType, (LPBYTE) szDllPath, &cbBufferSize);
				if (dwError == ERROR_SUCCESS && dwType == REG_SZ)
				{
					lstrcat(szDllPath, TEXT("\\office\\outlook\\backups"));
					lstrcat(szDllPath, verWinNT() ? TEXT("\\nt") : TEXT("\\windows"));
					lstrcat(szDllPath, TEXT("\\mapi32.dll"));
				}
				else
				{
					szDllPath[0] = '\0';
				}

				RegCloseKey(hkeyInstall);
			}

			// Outlook 98 OMI copied original mapi32.dll to backup directory
			if (('\0' != szDllPath[0]) &&
				(OpenFile(szDllPath, &ofs, OF_EXIST) != HFILE_ERROR))
			{
				BOOL fStub;

				// Office9 225191
				// Must check if the mapi32.dll backed up by Outlook 98
				// Internet-Only mode is a stub; don't copy as mapi32x.dll
				// if it is, otherwise the stub mapi32.dll will call the
				// STUB mapi32x.dll which calls itself over and over again.
				// (A stub can be present if you install Outlook 98 OMI mode
				// on W9x with IE5 or W98SP1/NT5 which include IE5.)
				hinst = ThunkLoadLibrary(szDllPath, &bNativeDll, FALSE,
					DONT_RESOLVE_DLL_REFERENCES);
				fStub = hinst && GetProcAddress(hinst, TEXT("GetOutlookVersion"));
				if (hinst)
					ThunkFreeLibrary(hinst, bNativeDll, 0);

				if (!fStub)
				{
					// Copy backup mapi32.dll to mapi32x.dll
					DeleteFile(szMAPI32XDLL);
					if (!MoveFile(szDllPath, szMAPI32XDLL))
					{
						dwError = GetLastError();
						goto Error;
					}
				}
			}
		}

		// Upgrade original mapi32.dll renamed by earlier mapistub.dll
		if (OpenFile(szMSMAPI32DLL, &ofs, OF_EXIST) != HFILE_ERROR)
		{
			// Copy old msmapi32.dll to mapi32x.dll
			DeleteFile(szMAPI32XDLL);
			if (!MoveFile(szMSMAPI32DLL, szMAPI32XDLL))
			{
				dwError = GetLastError();
				goto Error;
			}
		}
	}

	// Copy mapistub.dll to mapi32.dll even if mapi32.dll is the stub
	// (mapiNewStub) because we don't have the file version handy and
	// GetOutlookVersion() always returns 402 so it doesn't break
	// Outlook 98 Internet-only mode, which only works with version 402.
	if (!CopyFile(szMAPIStubDLL, szMAPI32DLL, FALSE))
	{
		dwError = GetLastError();
		goto Error;
	}

	// *** PART 4: Write registry settings

	// Register Eudora mapi32.dll
	if (mapi == mapiEudora)
		RegisterMailClient(TEXT("Eudora"),
			fSimpleMAPI, fExtendedMAPI, szNonMSDLL);

	// Register Netscape mapi32.dll
	if (mapi == mapiNetscape)
		RegisterMailClient(TEXT("Netscape Messenger"),
			fSimpleMAPI, fExtendedMAPI, szNonMSDLL);

Error:

	return dwError;
}



#define LINKAGE_EXTERN_C		extern "C"
#define LINKAGE_NO_EXTERN_C		/* */

#define ExtendedMAPI	FALSE
#define SimpleMAPI		TRUE

#if !defined (_X86_)

// Note: we continue to check for _ALPHA_ above so that if WX86 is nto defined,
// these #defines will be used

#define DEFINE_STUB_FUNCTION_V0(Simple, Linkage, Modifiers, FunctionName, Lookup)	\
																					\
	Linkage typedef void (Modifiers * FunctionName##FuncPtr)(void);					\
																					\
	Linkage void Modifiers FunctionName(void)										\
	{																				\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #FunctionName);	\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "										\
				"Entry point \"" #FunctionName "\" not found!");							\
		}																			\
		else																		\
		{																			\
			OMIStub##FunctionName();												\
		}																			\
	}


#define DEFINE_STUB_FUNCTION_0(Simple, Linkage, RetType, Modifiers,			\
		FunctionName, Lookup, Default)										\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(void);		\
																			\
	Linkage RetType Modifiers FunctionName(void)							\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #FunctionName);	\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #FunctionName "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName();									\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_V1(Simple, Linkage, Modifiers,					\
		FunctionName, Lookup, Param1Type)									\
																			\
	Linkage typedef void (Modifiers * FunctionName##FuncPtr)(Param1Type);	\
																			\
	Linkage void Modifiers FunctionName(Param1Type a)						\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #FunctionName);	\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #FunctionName "\" not found!");					\
		}																	\
		else																\
		{																	\
			OMIStub##FunctionName(a);										\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_1(Simple, Linkage, RetType,					\
		Modifiers, FunctionName, Lookup, Param1Type, Default)				\
																			\
	Linkage typedef RetType													\
			(Modifiers * FunctionName##FuncPtr)(Param1Type);				\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a)					\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #FunctionName);	\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #FunctionName "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a);								\
		}																	\
	}

#define DEFINE_STUB_FUNCTION_USE_LOOKUP_1(Simple, Linkage, RetType,					\
		Modifiers, FunctionName, Lookup, Param1Type, Default)				\
																			\
	Linkage typedef RetType													\
			(Modifiers * FunctionName##FuncPtr)(Param1Type);				\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a)					\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #Lookup "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a);								\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_V2(Simple, Linkage, Modifiers,					\
		FunctionName, Lookup, Param1Type, Param2Type)						\
																			\
	Linkage typedef void (Modifiers * FunctionName##FuncPtr)(				\
			Param1Type, Param2Type);										\
																			\
	Linkage void Modifiers FunctionName(Param1Type a, Param2Type b)			\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #FunctionName);	\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #FunctionName "\" not found!");					\
		}																	\
		else																\
		{																	\
			OMIStub##FunctionName(a, b);									\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_2(Simple, Linkage, RetType, Modifiers,			\
		FunctionName, Lookup, Param1Type, Param2Type, Default)				\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type);										\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a, Param2Type b)		\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #FunctionName);	\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #FunctionName "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b);								\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_V3(Simple, Linkage, Modifiers,					\
		FunctionName, Lookup, Param1Type, Param2Type, Param3Type)			\
																			\
	Linkage typedef void (Modifiers * FunctionName##FuncPtr)(				\
			Param1Type, Param2Type, Param3Type);							\
																			\
	Linkage void Modifiers FunctionName(									\
			Param1Type a, Param2Type b, Param3Type c)						\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #FunctionName);	\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #FunctionName "\" not found!");					\
		}																	\
		else																\
		{																	\
			OMIStub##FunctionName(a, b, c);									\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_3(Simple, Linkage, RetType, Modifiers,			\
		FunctionName, Lookup, Param1Type, Param2Type, Param3Type, Default)	\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type, Param3Type);							\
																			\
	Linkage RetType Modifiers FunctionName(									\
			Param1Type a, Param2Type b, Param3Type c)						\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #FunctionName);	\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #FunctionName "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b, c);							\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_4(Simple, Linkage,								\
		RetType, Modifiers, FunctionName, Lookup, Param1Type,				\
		Param2Type, Param3Type, Param4Type, Default)						\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type, Param3Type, Param4Type);				\
																			\
	Linkage RetType Modifiers FunctionName(									\
			Param1Type a, Param2Type b, Param3Type c, Param4Type d)			\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #FunctionName);	\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #FunctionName "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b, c, d);						\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_5(Simple, Linkage,								\
		RetType, Modifiers, FunctionName, Lookup,							\
		Param1Type, Param2Type, Param3Type,									\
		Param4Type, Param5Type, Default)									\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type, Param3Type, Param4Type, Param5Type);	\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a, Param2Type b,		\
			Param3Type c, Param4Type d, Param5Type e)						\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #FunctionName);	\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #FunctionName "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b, c, d, e);					\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_6(Simple, Linkage, RetType, Modifiers,			\
		FunctionName, Lookup, Param1Type, Param2Type,						\
		Param3Type, Param4Type, Param5Type, Param6Type, Default)			\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type, Param3Type,								\
			Param4Type, Param5Type, Param6Type);							\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a, Param2Type b,		\
			Param3Type c, Param4Type d, Param5Type e, Param6Type f)			\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #FunctionName);	\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #FunctionName "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b, c, d, e, f);					\
		}																	\
	}

#define DEFINE_STUB_FUNCTION_USE_LOOKUP_6(Simple, Linkage, RetType, Modifiers,			\
		FunctionName, Lookup, Param1Type, Param2Type,						\
		Param3Type, Param4Type, Param5Type, Param6Type, Default)			\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type, Param3Type,								\
			Param4Type, Param5Type, Param6Type);							\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a, Param2Type b,		\
			Param3Type c, Param4Type d, Param5Type e, Param6Type f)			\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #FunctionName "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b, c, d, e, f);					\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_V7(Simple, Linkage, Modifiers, FunctionName,	\
		Lookup, Param1Type, Param2Type, Param3Type, Param4Type,				\
		Param5Type, Param6Type, Param7Type)									\
																			\
	Linkage typedef void (Modifiers * FunctionName##FuncPtr)(				\
			Param1Type, Param2Type, Param3Type,								\
			Param4Type, Param5Type, Param6Type, Param7Type);				\
																			\
	Linkage void Modifiers FunctionName(Param1Type a,						\
			Param2Type b, Param3Type c, Param4Type d,						\
			Param5Type e, Param6Type f, Param7Type g)						\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #FunctionName);	\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #FunctionName "\" not found!");					\
		}																	\
		else																\
		{																	\
			OMIStub##FunctionName(a, b, c, d, e, f, g);						\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_7(Simple, Linkage, RetType, Modifiers,			\
		FunctionName, Lookup, Param1Type, Param2Type, Param3Type,			\
		Param4Type, Param5Type, Param6Type, Param7Type, Default)			\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type, Param3Type, Param4Type,					\
			Param5Type, Param6Type, Param7Type);							\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a, Param2Type b,		\
			Param3Type c, Param4Type d, Param5Type e,						\
			Param6Type f, Param7Type g)										\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #FunctionName);	\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #FunctionName "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b, c, d, e, f, g);				\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_8(Simple, Linkage, RetType, Modifiers,				\
		FunctionName, Lookup, Param1Type, Param2Type, Param3Type,				\
		Param4Type, Param5Type, Param6Type, Param7Type, Param8Type, Default)	\
																				\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(				\
			Param1Type, Param2Type, Param3Type, Param4Type,						\
			Param5Type, Param6Type, Param7Type, Param8Type);					\
																				\
	Linkage RetType Modifiers FunctionName(Param1Type a,						\
			Param2Type b, Param3Type c, Param4Type d, Param5Type e,				\
			Param6Type f, Param7Type g, Param8Type h)							\
	{																			\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #FunctionName);	\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "									\
				"Entry point \"" #FunctionName "\" not found!");						\
																				\
			return Default;														\
		}																		\
		else																	\
		{																		\
			return OMIStub##FunctionName(a, b, c, d, e, f, g, h);				\
		}																		\
	}


#define DEFINE_STUB_FUNCTION_9(Simple, Linkage, RetType,					\
		Modifiers, FunctionName, Lookup, Param1Type, Param2Type,			\
		Param3Type, Param4Type, Param5Type, Param6Type,						\
		Param7Type, Param8Type, Param9Type, Default)						\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type, Param3Type,								\
			Param4Type, Param5Type, Param6Type,								\
			Param7Type, Param8Type, Param9Type);							\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a, Param2Type b,		\
			Param3Type c, Param4Type d, Param5Type e,						\
			Param6Type f, Param7Type g, Param8Type h, Param9Type i)			\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #FunctionName);	\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #FunctionName "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b, c, d, e, f, g, h, i);		\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_10(Simple, Linkage, RetType, Modifiers,		\
		FunctionName, Lookup, Param1Type, Param2Type, Param3Type,			\
		Param4Type, Param5Type, Param6Type, Param7Type,						\
		Param8Type, Param9Type, Param10Type, Default)						\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type, Param3Type,								\
			Param4Type, Param5Type, Param6Type,								\
			Param7Type, Param8Type, Param9Type, Param10Type);				\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a, Param2Type b,		\
			Param3Type c, Param4Type d, Param5Type e, Param6Type f,			\
			Param7Type g, Param8Type h, Param9Type i, Param10Type j)		\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #FunctionName);	\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #FunctionName "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b, c, d, e, f, g, h, i, j);		\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_11(Simple, Linkage, RetType, Modifiers,		\
		FunctionName, Lookup, Param1Type, Param2Type, Param3Type,			\
		Param4Type, Param5Type, Param6Type, Param7Type, Param8Type,			\
		Param9Type, Param10Type, Param11Type, Default)						\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type, Param3Type, Param4Type,					\
			Param5Type, Param6Type, Param7Type, Param8Type,					\
			Param9Type, Param10Type, Param11Type);							\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a,					\
			Param2Type b, Param3Type c, Param4Type d,						\
			Param5Type e, Param6Type f, Param7Type g,						\
			Param8Type h, Param9Type i, Param10Type j, Param11Type k)		\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #FunctionName);	\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #FunctionName "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b, c, d, e, f, g, h, i, j, k);	\
		}																	\
	}

#else // Intel

#define DEFINE_STUB_FUNCTION_V0(Simple, Linkage, Modifiers, FunctionName, Lookup)	\
																					\
	Linkage typedef void (Modifiers * FunctionName##FuncPtr)(void);					\
																					\
	Linkage void Modifiers FunctionName(void)										\
	{																				\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "										\
				"Entry point \"" #Lookup "\" not found!");							\
		}																			\
		else																		\
		{																			\
			OMIStub##FunctionName();												\
		}																			\
	}


#define DEFINE_STUB_FUNCTION_0(Simple, Linkage, RetType, Modifiers,			\
		FunctionName, Lookup, Default)										\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(void);		\
																			\
	Linkage RetType Modifiers FunctionName(void)							\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #Lookup "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName();									\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_V1(Simple, Linkage, Modifiers,					\
		FunctionName, Lookup, Param1Type)									\
																			\
	Linkage typedef void (Modifiers * FunctionName##FuncPtr)(Param1Type);	\
																			\
	Linkage void Modifiers FunctionName(Param1Type a)						\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #Lookup "\" not found!");					\
		}																	\
		else																\
		{																	\
			OMIStub##FunctionName(a);										\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_1(Simple, Linkage, RetType,					\
		Modifiers, FunctionName, Lookup, Param1Type, Default)				\
																			\
	Linkage typedef RetType													\
			(Modifiers * FunctionName##FuncPtr)(Param1Type);				\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a)					\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #Lookup "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a);								\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_V2(Simple, Linkage, Modifiers,					\
		FunctionName, Lookup, Param1Type, Param2Type)						\
																			\
	Linkage typedef void (Modifiers * FunctionName##FuncPtr)(				\
			Param1Type, Param2Type);										\
																			\
	Linkage void Modifiers FunctionName(Param1Type a, Param2Type b)			\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #Lookup "\" not found!");					\
		}																	\
		else																\
		{																	\
			OMIStub##FunctionName(a, b);									\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_2(Simple, Linkage, RetType, Modifiers,			\
		FunctionName, Lookup, Param1Type, Param2Type, Default)				\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type);										\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a, Param2Type b)		\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #Lookup "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b);								\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_V3(Simple, Linkage, Modifiers,					\
		FunctionName, Lookup, Param1Type, Param2Type, Param3Type)			\
																			\
	Linkage typedef void (Modifiers * FunctionName##FuncPtr)(				\
			Param1Type, Param2Type, Param3Type);							\
																			\
	Linkage void Modifiers FunctionName(									\
			Param1Type a, Param2Type b, Param3Type c)						\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #Lookup "\" not found!");					\
		}																	\
		else																\
		{																	\
			OMIStub##FunctionName(a, b, c);									\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_3(Simple, Linkage, RetType, Modifiers,			\
		FunctionName, Lookup, Param1Type, Param2Type, Param3Type, Default)	\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type, Param3Type);							\
																			\
	Linkage RetType Modifiers FunctionName(									\
			Param1Type a, Param2Type b, Param3Type c)						\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #Lookup "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b, c);							\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_4(Simple, Linkage,								\
		RetType, Modifiers, FunctionName, Lookup, Param1Type,				\
		Param2Type, Param3Type, Param4Type, Default)						\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type, Param3Type, Param4Type);				\
																			\
	Linkage RetType Modifiers FunctionName(									\
			Param1Type a, Param2Type b, Param3Type c, Param4Type d)			\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #Lookup "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b, c, d);						\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_5(Simple, Linkage,								\
		RetType, Modifiers, FunctionName, Lookup,							\
		Param1Type, Param2Type, Param3Type,									\
		Param4Type, Param5Type, Default)									\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type, Param3Type, Param4Type, Param5Type);	\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a, Param2Type b,		\
			Param3Type c, Param4Type d, Param5Type e)						\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #Lookup "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b, c, d, e);					\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_6(Simple, Linkage, RetType, Modifiers,			\
		FunctionName, Lookup, Param1Type, Param2Type,						\
		Param3Type, Param4Type, Param5Type, Param6Type, Default)			\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type, Param3Type,								\
			Param4Type, Param5Type, Param6Type);							\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a, Param2Type b,		\
			Param3Type c, Param4Type d, Param5Type e, Param6Type f)			\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #Lookup "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b, c, d, e, f);					\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_V7(Simple, Linkage, Modifiers, FunctionName,	\
		Lookup, Param1Type, Param2Type, Param3Type, Param4Type,				\
		Param5Type, Param6Type, Param7Type)									\
																			\
	Linkage typedef void (Modifiers * FunctionName##FuncPtr)(				\
			Param1Type, Param2Type, Param3Type,								\
			Param4Type, Param5Type, Param6Type, Param7Type);				\
																			\
	Linkage void Modifiers FunctionName(Param1Type a,						\
			Param2Type b, Param3Type c, Param4Type d,						\
			Param5Type e, Param6Type f, Param7Type g)						\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #Lookup "\" not found!");					\
		}																	\
		else																\
		{																	\
			OMIStub##FunctionName(a, b, c, d, e, f, g);						\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_7(Simple, Linkage, RetType, Modifiers,			\
		FunctionName, Lookup, Param1Type, Param2Type, Param3Type,			\
		Param4Type, Param5Type, Param6Type, Param7Type, Default)			\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type, Param3Type, Param4Type,					\
			Param5Type, Param6Type, Param7Type);							\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a, Param2Type b,		\
			Param3Type c, Param4Type d, Param5Type e,						\
			Param6Type f, Param7Type g)										\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #Lookup "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b, c, d, e, f, g);				\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_8(Simple, Linkage, RetType, Modifiers,				\
		FunctionName, Lookup, Param1Type, Param2Type, Param3Type,				\
		Param4Type, Param5Type, Param6Type, Param7Type, Param8Type, Default)	\
																				\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(				\
			Param1Type, Param2Type, Param3Type, Param4Type,						\
			Param5Type, Param6Type, Param7Type, Param8Type);					\
																				\
	Linkage RetType Modifiers FunctionName(Param1Type a,						\
			Param2Type b, Param3Type c, Param4Type d, Param5Type e,				\
			Param6Type f, Param7Type g, Param8Type h)							\
	{																			\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "									\
				"Entry point \"" #Lookup "\" not found!");						\
																				\
			return Default;														\
		}																		\
		else																	\
		{																		\
			return OMIStub##FunctionName(a, b, c, d, e, f, g, h);				\
		}																		\
	}


#define DEFINE_STUB_FUNCTION_9(Simple, Linkage, RetType,					\
		Modifiers, FunctionName, Lookup, Param1Type, Param2Type,			\
		Param3Type, Param4Type, Param5Type, Param6Type,						\
		Param7Type, Param8Type, Param9Type, Default)						\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type, Param3Type,								\
			Param4Type, Param5Type, Param6Type,								\
			Param7Type, Param8Type, Param9Type);							\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a, Param2Type b,		\
			Param3Type c, Param4Type d, Param5Type e,						\
			Param6Type f, Param7Type g, Param8Type h, Param9Type i)			\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #Lookup "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b, c, d, e, f, g, h, i);		\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_10(Simple, Linkage, RetType, Modifiers,		\
		FunctionName, Lookup, Param1Type, Param2Type, Param3Type,			\
		Param4Type, Param5Type, Param6Type, Param7Type,						\
		Param8Type, Param9Type, Param10Type, Default)						\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type, Param3Type,								\
			Param4Type, Param5Type, Param6Type,								\
			Param7Type, Param8Type, Param9Type, Param10Type);				\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a, Param2Type b,		\
			Param3Type c, Param4Type d, Param5Type e, Param6Type f,			\
			Param7Type g, Param8Type h, Param9Type i, Param10Type j)		\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #Lookup "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b, c, d, e, f, g, h, i, j);		\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_11(Simple, Linkage, RetType, Modifiers,		\
		FunctionName, Lookup, Param1Type, Param2Type, Param3Type,			\
		Param4Type, Param5Type, Param6Type, Param7Type, Param8Type,			\
		Param9Type, Param10Type, Param11Type, Default)						\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type, Param3Type, Param4Type,					\
			Param5Type, Param6Type, Param7Type, Param8Type,					\
			Param9Type, Param10Type, Param11Type);							\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a,					\
			Param2Type b, Param3Type c, Param4Type d,						\
			Param5Type e, Param6Type f, Param7Type g,						\
			Param8Type h, Param9Type i, Param10Type j, Param11Type k)		\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #Lookup "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b, c, d, e, f, g, h, i, j, k);	\
		}																	\
	}


#endif





#if 1

LINKAGE_EXTERN_C typedef SCODE (STDMAPIINITCALLTYPE * ScSplEntryFuncPtr)(LPSPLDATA, LPVOID, ULONG, ULONG *);

LINKAGE_EXTERN_C SCODE STDMAPIINITCALLTYPE ScSplEntry(LPSPLDATA a, LPVOID b, ULONG c, ULONG * d)
{
	static ScSplEntryFuncPtr OMIStubScSplEntry = (ScSplEntryFuncPtr)
			::GetProcAddress(GetProxyDll(ExtendedMAPI), (LPCSTR) MAKEWORD(8, 0));

	if (NULL == OMIStubScSplEntry)
	{
		AssertSz(FALSE, "MAPI32 Stub:  "
			"Entry point \"ScSplEntry\" (ordinal #8) not found!");

		return MAPI_E_CALL_FAILED;
	}
	else
	{
		return OMIStubScSplEntry(a, b, c, d);
	}
}

#else

DEFINE_STUB_FUNCTION_4(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDMAPIINITCALLTYPE,
		ScSplEntry, ScSplEntry@16, LPSPLDATA, LPVOID, ULONG, ULONG *, MAPI_E_CALL_FAILED)

#endif


DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDMETHODCALLTYPE,
		HrGetOmiProvidersFlags, HrGetOmiProvidersFlags@8,
		LPMAPISESSION, ULONG *, MAPI_E_CALL_FAILED)


DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDMETHODCALLTYPE,
		HrSetOmiProvidersFlagsInvalid, HrSetOmiProvidersFlagsInvalid@4,
		LPMAPISESSION, MAPI_E_CALL_FAILED)


DEFINE_STUB_FUNCTION_5(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDMETHODCALLTYPE,
		MAPILogonEx, MAPILogonEx@20,
		ULONG_PTR, LPTSTR, LPTSTR, ULONG, LPMAPISESSION FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDMETHODCALLTYPE,
		MAPIAllocateBuffer, MAPIAllocateBuffer@8,
		ULONG, LPVOID FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDMETHODCALLTYPE,
		MAPIAllocateMore, MAPIAllocateMore@12,
		ULONG, LPVOID, LPVOID FAR *, (SCODE) MAPI_E_CALL_FAILED)


DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDMETHODCALLTYPE,
		MAPIAdminProfiles, MAPIAdminProfiles@8,
		ULONG, LPPROFADMIN FAR *, MAPI_E_CALL_FAILED)

// The LPVOID argument points to a MAPIINIT_0 struct ()declared in mapix.h)
// None of the members of the struct need thunking. The HANDLE member
// (hProfile) of the struct is NULL or the handle of a registry key; this is
// passed on to PrProviderInit as the last argument (see comments below just
// before PrProviderInit's defn) by ScInitMapiX which is called by
// MapiInitialize
//
// MapiInitialize also casts the LPVOID as an LPSPLINIT in certain cases;
// LPSPLINIT is declared in _spooler.h (a private header) and has MAPIINIT_0
// as its first member and a byt pointer as its only other member. So no
// issues here either.
//
// Aside: The call made to PrProviderInit from ScInitMapiX. If the mapi dll
// is the profile provider ScInitMapiX does the following:
//
//      hinstProfile = GetModuleHandle(szMAPIXDLL);
//      pfnInitProfile = PRProviderInit;
//      (*pfnInitProfile)(hinstProfile, ...);
//
// szMapiXDll is set to "MSMAPI32" if MSMAPI is defined, else to "MAPI32".
// MSMAPI is defined for builds in mapi\src\msmapi and is undefined for
// builds in mapi\src\mapi.
//
// If szMapiXDll is set to MSMAPI32, there are no issues. If it is set to
// "MAPI32" (which may be the case for older versions of the dll), there
// are potential problems because the PrProviderInit fn in the msmapi dll
// will be called directly but given the dll handle of the mapi32 (stub) dll
// and our thunk will not be called. As noted along with the comments for
// PrProviderInit, this could cause problems with the hook fns.
//

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		MAPIInitialize, MAPIInitialize@4,
		LPVOID, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_V0(ExtendedMAPI, LINKAGE_EXTERN_C, STDAPICALLTYPE,
		MAPIUninitialize, MAPIUninitialize@0)

DEFINE_STUB_FUNCTION_9(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDMAPIINITCALLTYPE,
		PRProviderInit, PRProviderInit,
		HINSTANCE, LPMALLOC, LPALLOCATEBUFFER, LPALLOCATEMORE,
		LPFREEBUFFER, ULONG, ULONG, ULONG FAR *, LPPRPROVIDER FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_5(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		LaunchWizard, LaunchWizard@20,
		HWND, ULONG, LPCTSTR FAR *, ULONG, LPTSTR, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, PASCAL,
		DllGetClassObject, DllGetClassObject, REFCLSID, REFIID, LPVOID FAR *, E_UNEXPECTED)

DEFINE_STUB_FUNCTION_0(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, PASCAL,
		DllCanUnloadNow, DllCanUnloadNow, S_FALSE)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		MAPIOpenFormMgr, MAPIOpenFormMgr@8,
		LPMAPISESSION, LPMAPIFORMMGR FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		MAPIOpenLocalFormContainer, MAPIOpenLocalFormContainer@4,
		LPMAPIFORMCONTAINER FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE,
		STDAPICALLTYPE, ScInitMapiUtil, ScInitMapiUtil@4, ULONG, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_V0(ExtendedMAPI, LINKAGE_EXTERN_C, STDAPICALLTYPE, DeinitMapiUtil, DeinitMapiUtil@0)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE,
		STDAPICALLTYPE, ScGenerateMuid, ScGenerateMuid@4, LPMAPIUID, MAPI_E_CALL_FAILED)

// LPVOID arg is passed back to the callback function
DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		HrAllocAdviseSink, HrAllocAdviseSink@12, LPNOTIFCALLBACK, LPVOID,
		LPMAPIADVISESINK FAR *, MAPI_E_CALL_FAILED)

// ScAddAdviseList is NOT exported; see mapi.des
// Note that the LPUNKNOWN argument must be thunked but as what?
// For example, its Unadvise() and UlRelease() methods are called
// in IAB_Unadvise() (src\mapi\iadrbook.c). UlRelease()
// is implemented in src\common\runt.c. ScAddAdviseList is in
// src\common\advise.c.
//
// Just as well this function is not exported!
//
DEFINE_STUB_FUNCTION_6(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		ScAddAdviseList, ScAddAdviseList@24, LPVOID, LPADVISELIST FAR *,
		LPMAPIADVISESINK, ULONG, ULONG, LPUNKNOWN, MAPI_E_CALL_FAILED)

// ScDelAdviseList is NOT exported; see mapi.des
DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		ScDelAdviseList, ScDelAdviseList@8, LPADVISELIST, ULONG, MAPI_E_CALL_FAILED)

// ScFindAdviseList is NOT exported; see mapi.des
DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		ScFindAdviseList, ScFindAdviseList@12, LPADVISELIST, ULONG, LPADVISEITEM FAR *, MAPI_E_CALL_FAILED)

// DestroyAdviseList is NOT exported; see mapi.des
DEFINE_STUB_FUNCTION_V1(ExtendedMAPI, LINKAGE_EXTERN_C, STDAPICALLTYPE,
		DestroyAdviseList, DestroyAdviseList@4, LPADVISELIST FAR *)

// This function merely returns MAPI_E_NO_SUPPORT and does not set the
//  LPMAPIPROGRESS FAR * argument to NULL. It is better not to thunk
// its arguments. See (src\common\advise.c for its implementation)
DEFINE_STUB_FUNCTION_5(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT,
		STDAPICALLTYPE, WrapProgress, WrapProgress@20, LPMAPIPROGRESS,
		ULONG, ULONG, ULONG, LPMAPIPROGRESS FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT,
		STDAPICALLTYPE, HrThisThreadAdviseSink, HrThisThreadAdviseSink@8,
		LPMAPIADVISESINK, LPMAPIADVISESINK FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		HrDispatchNotifications, HrDispatchNotifications@4, ULONG, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		ScBinFromHexBounded, ScBinFromHexBounded@12,
		LPTSTR, LPBYTE, ULONG, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, BOOL,
		STDAPICALLTYPE, FBinFromHex, FBinFromHex@8, LPTSTR, LPBYTE, FALSE)

DEFINE_STUB_FUNCTION_V3(ExtendedMAPI, LINKAGE_EXTERN_C, STDAPICALLTYPE,
		HexFromBin, HexFromBin@12, LPBYTE, int, LPTSTR)

DEFINE_STUB_FUNCTION_10(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		BuildDisplayTable, BuildDisplayTable@40,
		LPALLOCATEBUFFER, LPALLOCATEMORE, LPFREEBUFFER, LPMALLOC,
		HINSTANCE, UINT, LPDTPAGE, ULONG, LPMAPITABLE *, LPTABLEDATA *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_V2(ExtendedMAPI, LINKAGE_EXTERN_C, PASCAL, SwapPlong, SwapPlong@8, void *, int)

DEFINE_STUB_FUNCTION_V2(ExtendedMAPI, LINKAGE_EXTERN_C, PASCAL, SwapPword, SwapPword@8, void *, int)

// LPVOID arg should be 0, but is ignored anyway
DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT,
		STDAPICALLTYPE, MAPIInitIdle, MAPIInitIdle@4, LPVOID, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_V0(ExtendedMAPI, LINKAGE_EXTERN_C, STDAPICALLTYPE, MAPIDeinitIdle, MAPIDeinitIdle@0)

DEFINE_STUB_FUNCTION_V1(ExtendedMAPI, LINKAGE_EXTERN_C, STDAPICALLTYPE,
		InstallFilterHook, InstallFilterHook@4, BOOL)

// LPVOID arg is passed as argument to callback function
DEFINE_STUB_FUNCTION_5(ExtendedMAPI, LINKAGE_EXTERN_C, FTG, STDAPICALLTYPE,
		FtgRegisterIdleRoutine, FtgRegisterIdleRoutine@20,
		PFNIDLE, LPVOID, short, ULONG, USHORT, NULL)

DEFINE_STUB_FUNCTION_V2(ExtendedMAPI, LINKAGE_EXTERN_C, STDAPICALLTYPE,
		EnableIdleRoutine, EnableIdleRoutine@8, FTG, BOOL)

DEFINE_STUB_FUNCTION_V1(ExtendedMAPI, LINKAGE_EXTERN_C, STDAPICALLTYPE,
		DeregisterIdleRoutine, DeregisterIdleRoutine@4, FTG)

// LPVOID arg is passed as argument to callback function
DEFINE_STUB_FUNCTION_V7(ExtendedMAPI, LINKAGE_EXTERN_C, STDAPICALLTYPE,
		ChangeIdleRoutine, ChangeIdleRoutine@28,
		FTG, PFNIDLE, LPVOID, short, ULONG, USHORT, USHORT)

// FDoNextIdleTask is NOT exported; see mapi.des
DEFINE_STUB_FUNCTION_0(ExtendedMAPI, LINKAGE_EXTERN_C, BOOL,
		STDAPICALLTYPE, FDoNextIdleTask, FDoNextIdleTask@0, FALSE)

DEFINE_STUB_FUNCTION_0(ExtendedMAPI, LINKAGE_EXTERN_C, LPMALLOC,
		STDAPICALLTYPE, MAPIGetDefaultMalloc, MAPIGetDefaultMalloc@0, NULL)

DEFINE_STUB_FUNCTION_6(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		CreateIProp, CreateIProp@24,
		LPCIID, ALLOCATEBUFFER FAR *, ALLOCATEMORE FAR *,
		FREEBUFFER FAR *, LPVOID, LPPROPDATA FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_9(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		CreateTable, CreateTable@36,
		LPCIID, ALLOCATEBUFFER FAR *, ALLOCATEMORE FAR *,
		FREEBUFFER FAR *, LPVOID, ULONG, ULONG,
		LPSPropTagArray, LPTABLEDATA FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, int, WINAPI,
		MNLS_lstrlenW, MNLS_lstrlenW@4, LPCWSTR, 0)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, int, WINAPI,
		MNLS_lstrcmpW, MNLS_lstrcmpW@8, LPCWSTR, LPCWSTR, 0)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, LPWSTR,
		WINAPI, MNLS_lstrcpyW, MNLS_lstrcpyW@8, LPWSTR, LPCWSTR, NULL)

DEFINE_STUB_FUNCTION_6(ExtendedMAPI, LINKAGE_EXTERN_C, int, WINAPI,
		MNLS_CompareStringW, MNLS_CompareStringW@24,
		LCID, DWORD, LPCWSTR, int, LPCWSTR, int, 0)

DEFINE_STUB_FUNCTION_6(ExtendedMAPI, LINKAGE_EXTERN_C, int, WINAPI,
		MNLS_MultiByteToWideChar, MNLS_MultiByteToWideChar@24,
		UINT, DWORD, LPCSTR, int, LPWSTR, int, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_8(ExtendedMAPI, LINKAGE_EXTERN_C, int, WINAPI,
		MNLS_WideCharToMultiByte, MNLS_WideCharToMultiByte@32,
		UINT, DWORD, LPCWSTR, int, LPSTR, int, LPCSTR, BOOL FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, BOOL,
		WINAPI, MNLS_IsBadStringPtrW, MNLS_IsBadStringPtrW@8, LPCWSTR, UINT, TRUE)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, BOOL, STDAPICALLTYPE,
		FEqualNames, FEqualNames@8, LPMAPINAMEID, LPMAPINAMEID, FALSE)

DEFINE_STUB_FUNCTION_6(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		WrapStoreEntryID, WrapStoreEntryID@24,
		ULONG, LPTSTR, ULONG, LPENTRYID, ULONG *, LPENTRYID *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, BOOL, WINAPI,
		IsBadBoundedStringPtr, IsBadBoundedStringPtr@8,
		const void FAR *, UINT, FALSE)

DEFINE_STUB_FUNCTION_6(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		HrQueryAllRows, HrQueryAllRows@24, LPMAPITABLE, LPSPropTagArray,
		LPSRestriction, LPSSortOrderSet, LONG, LPSRowSet FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_4(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		ScCreateConversationIndex, ScCreateConversationIndex@16, ULONG, LPBYTE,
		ULONG FAR *, LPBYTE FAR *, MAPI_E_CALL_FAILED)

// The LPVOID arg is reallocated with the ALLOCATEMORE* arg, it is treated
// as a PVOID
DEFINE_STUB_FUNCTION_4(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		PropCopyMore, PropCopyMore@16,
		LPSPropValue, LPSPropValue, ALLOCATEMORE *, LPVOID, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG,
		STDAPICALLTYPE, UlPropSize, UlPropSize@4, LPSPropValue, 0)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, BOOL, STDAPICALLTYPE,
		FPropContainsProp, FPropContainsProp@12, LPSPropValue, LPSPropValue, ULONG, FALSE)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, BOOL, STDAPICALLTYPE,
		FPropCompareProp, FPropCompareProp@12, LPSPropValue, ULONG, LPSPropValue, FALSE)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, LONG, STDAPICALLTYPE,
		LPropCompareProp, LPropCompareProp@8, LPSPropValue, LPSPropValue, 0)

DEFINE_STUB_FUNCTION_4(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		HrAddColumns, HrAddColumns@16,
		LPMAPITABLE, LPSPropTagArray, LPALLOCATEBUFFER, LPFREEBUFFER, MAPI_E_CALL_FAILED)

typedef void (FAR * HrAddColumnsEx5ParamType)(LPSPropTagArray);

DEFINE_STUB_FUNCTION_5(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		HrAddColumnsEx, HrAddColumnsEx@20, LPMAPITABLE, LPSPropTagArray,
		LPALLOCATEBUFFER, LPFREEBUFFER, HrAddColumnsEx5ParamType, MAPI_E_CALL_FAILED)

const FILETIME ZERO_FILETIME = { 0, 0 };

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, FILETIME,
		STDAPICALLTYPE, FtMulDwDw, FtMulDwDw@8, DWORD, DWORD, ZERO_FILETIME)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, FILETIME,
		STDAPICALLTYPE, FtAddFt, FtAddFt@16, FILETIME, FILETIME, ZERO_FILETIME)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, FILETIME, STDAPICALLTYPE,
		FtAdcFt, FtAdcFt@20, FILETIME, FILETIME, WORD FAR *, ZERO_FILETIME)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, FILETIME,
		STDAPICALLTYPE, FtSubFt, FtSubFt@16, FILETIME, FILETIME, ZERO_FILETIME)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, FILETIME,
		STDAPICALLTYPE, FtMulDw, FtMulDw@12, DWORD, FILETIME, ZERO_FILETIME)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, FILETIME,
		STDAPICALLTYPE, FtNegFt, FtNegFt@8, FILETIME, ZERO_FILETIME)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, FILETIME, STDAPICALLTYPE,
		FtDivFtBogus, FtDivFtBogus@20, FILETIME, FILETIME, CHAR, ZERO_FILETIME)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG,
		STDAPICALLTYPE, UlAddRef, UlAddRef@4, LPVOID, 1)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG,
		STDAPICALLTYPE, UlRelease, UlRelease@4, LPVOID, 1)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, LPTSTR,
		STDAPICALLTYPE, SzFindCh, SzFindCh@8, LPCTSTR, USHORT, NULL)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, LPTSTR,
		STDAPICALLTYPE, SzFindLastCh, SzFindLastCh@8, LPCTSTR, USHORT, NULL)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, LPTSTR,
		STDAPICALLTYPE, SzFindSz, SzFindSz@8, LPCTSTR, LPCTSTR, NULL)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, unsigned int,
		STDAPICALLTYPE, UFromSz, UFromSz@4, LPCTSTR, 0)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		HrGetOneProp, HrGetOneProp@12,
		LPMAPIPROP, ULONG, LPSPropValue FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		HrSetOneProp, HrSetOneProp@8, LPMAPIPROP, LPSPropValue, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, BOOL,
		STDAPICALLTYPE, FPropExists, FPropExists@8, LPMAPIPROP, ULONG, FALSE)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, LPSPropValue, STDAPICALLTYPE,
		PpropFindProp, PpropFindProp@12, LPSPropValue, ULONG, ULONG, NULL)

DEFINE_STUB_FUNCTION_V1(ExtendedMAPI, LINKAGE_EXTERN_C, STDAPICALLTYPE,
		FreePadrlist, FreePadrlist@4, LPADRLIST)

DEFINE_STUB_FUNCTION_V1(ExtendedMAPI, LINKAGE_EXTERN_C, STDAPICALLTYPE,
		FreeProws, FreeProws@4, LPSRowSet)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		HrSzFromEntryID, HrSzFromEntryID@12, ULONG, LPENTRYID, LPTSTR FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		HrEntryIDFromSz, HrEntryIDFromSz@12,
		LPTSTR, ULONG FAR *, LPENTRYID FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_7(ExtendedMAPI, LINKAGE_NO_EXTERN_C, HRESULT, STDAPICALLTYPE,
		HrComposeEID, HrComposeEID@28, LPMAPISESSION, ULONG, LPBYTE,
		ULONG, LPENTRYID, ULONG FAR *, LPENTRYID FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_7(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		HrDecomposeEID, HrDecomposeEID@28, LPMAPISESSION, ULONG, LPENTRYID,
		ULONG FAR *, LPENTRYID FAR *, ULONG FAR *, LPENTRYID FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_6(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		HrComposeMsgID, HrComposeMsgID@24,
		LPMAPISESSION, ULONG, LPBYTE, ULONG, LPENTRYID, LPTSTR FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_6(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		HrDecomposeMsgID, HrDecomposeMsgID@24, LPMAPISESSION, LPTSTR,
		ULONG FAR *, LPENTRYID FAR *, ULONG FAR *, LPENTRYID FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_6(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT,
		STDMETHODCALLTYPE, OpenStreamOnFile, OpenStreamOnFile@24,
		LPALLOCATEBUFFER, LPFREEBUFFER, ULONG,
		LPTSTR, LPTSTR, LPSTREAM FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_7(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT,
		STDMETHODCALLTYPE, OpenTnefStream, OpenTnefStream@28, LPVOID, LPSTREAM,
		LPTSTR, ULONG, LPMESSAGE, WORD, LPITNEF FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_8(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDMETHODCALLTYPE,
		OpenTnefStreamEx, OpenTnefStreamEx@32, LPVOID, LPSTREAM, LPTSTR,
		ULONG, LPMESSAGE, WORD, LPADRBOOK, LPITNEF FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDMETHODCALLTYPE,
		GetTnefStreamCodepage, GetTnefStreamCodepage@12,
		LPSTREAM, ULONG FAR *, ULONG FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG,
		STDAPICALLTYPE, UlFromSzHex, UlFromSzHex@4, LPCTSTR, 0)

// The following UNKOBJ_* fns are not documented in the Jul 98 MSDN.
// LPUNKOBJ itself is declared in src\inc\unkobj.h (a private header file)
// These (and other) methods of UNKOBJ are in src\common\unkobj.c
//
// It appears that some MAPI interfaces are "derived" from UNKOBJ;
// for example, see CreateIProp() in src\mapi\iprop.c and CreateTable() in
// mapi\src\itable.c. The UNKOBJ_ScCO* functions do not use any methods of
// the LPUNKOBJ argument; the others use the Allocate, AllocateMore and Free
// functions that were sent in as arguments to CreateIProp() and CreateTable()
// (These function pointers are already thunked.)
//
// UNKOBJ_ScSzFromIdsAlloc loads a string resource from the mapi dll,
// allocating a buffer for the string
//
// All the functions below use data members in the UNKOBJ structure and so
// we cannot send a proxy in for the LPUNKOBJ argument. But we can't thunk
// it either because we do not know its IID.
//
// As a workaround, we call ResolveProxy. If the argument is a proxy,
// ResolveProxy will find the real interface pointer. If not, the argument
// must be a cross architecture interface pointer, i.e., the interface
// pointer must be the same architecture as the app (or else the app would
// have a proxy pointer) and the mapi dll must be of the opposite architecture
// (because we thunk only cross architecture calls). So we just fail the
// call in the thunk. (Note: the argument could also be an unthunked
// interface pointer of the same architecture as the mapi dll - and some
// other API failed to thunk the pointer when it was returned to the app.
// Hopefully, bugs of that nature will be caught during internal testing.)


DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		UNKOBJ_ScAllocate, UNKOBJ_ScAllocate@12,
		LPUNKOBJ, ULONG, LPVOID FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_4(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		UNKOBJ_ScAllocateMore, UNKOBJ_ScAllocateMore@16,
		LPUNKOBJ, ULONG, LPVOID, LPVOID FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_V2(ExtendedMAPI, LINKAGE_EXTERN_C, STDAPICALLTYPE,
		UNKOBJ_Free, UNKOBJ_Free@8, LPUNKOBJ, LPVOID)

DEFINE_STUB_FUNCTION_V2(ExtendedMAPI, LINKAGE_EXTERN_C, STDAPICALLTYPE,
		UNKOBJ_FreeRows, UNKOBJ_FreeRows@8, LPUNKOBJ, LPSRowSet)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		UNKOBJ_ScCOAllocate, UNKOBJ_ScCOAllocate@12,
		LPUNKOBJ, ULONG, LPVOID FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		UNKOBJ_ScCOReallocate, UNKOBJ_ScCOReallocate@12,
		LPUNKOBJ, ULONG, LPVOID FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_V2(ExtendedMAPI, LINKAGE_EXTERN_C, STDAPICALLTYPE,
		UNKOBJ_COFree, UNKOBJ_COFree@8, LPUNKOBJ, LPVOID)

DEFINE_STUB_FUNCTION_5(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE,
		STDAPICALLTYPE, UNKOBJ_ScSzFromIdsAlloc, UNKOBJ_ScSzFromIdsAlloc@20,
		LPUNKOBJ, IDS, ULONG, int, LPTSTR FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		ScCountNotifications, ScCountNotifications@12,
		int, LPNOTIFICATION, ULONG FAR *, MAPI_E_CALL_FAILED)

// LPVOID arg ok; is a pointer to a NOTIFICATION struct which is filled in
// by the fn
DEFINE_STUB_FUNCTION_4(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		ScCopyNotifications, ScCopyNotifications@16,
		int, LPNOTIFICATION, LPVOID, ULONG FAR *, MAPI_E_CALL_FAILED)

// LPVOID args ok, pointers to NOTIFICAATION structs
DEFINE_STUB_FUNCTION_5(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE,
		STDAPICALLTYPE, ScRelocNotifications, ScRelocNotifications@20, int,
		LPNOTIFICATION, LPVOID, LPVOID, ULONG FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		ScCountProps, ScCountProps@12,
		int, LPSPropValue, ULONG FAR *, MAPI_E_CALL_FAILED)

// LPVOID arg ok; is a pointer to a SPropValue struct which is filled in
// by the fn
DEFINE_STUB_FUNCTION_4(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		ScCopyProps, ScCopyProps@16,
		int, LPSPropValue, LPVOID, ULONG FAR *, MAPI_E_CALL_FAILED)

// LPVOID args ok, pointers to SPropValue structs
DEFINE_STUB_FUNCTION_5(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		ScRelocProps, ScRelocProps@20,
		int, LPSPropValue, LPVOID, LPVOID, ULONG FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, LPSPropValue, STDAPICALLTYPE,
		LpValFindProp, LpValFindProp@12, ULONG, ULONG, LPSPropValue, NULL)

DEFINE_STUB_FUNCTION_4(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		ScDupPropset, ScDupPropset@16,
		int, LPSPropValue, LPALLOCATEBUFFER, LPSPropValue FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, BOOL,
		STDAPICALLTYPE, FBadRglpszA, FBadRglpszA@8, LPSTR FAR *, ULONG, TRUE)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, BOOL,
		STDAPICALLTYPE, FBadRglpszW, FBadRglpszW@8, LPWSTR FAR *, ULONG, TRUE)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, BOOL,
		STDAPICALLTYPE, FBadRowSet, FBadRowSet@4, LPSRowSet, TRUE)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, BOOL, STDAPICALLTYPE,
		FBadRglpNameID, FBadRglpNameID@8, LPMAPINAMEID FAR *, ULONG, TRUE)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG,
		STDAPICALLTYPE, FBadPropTag, FBadPropTag@4, ULONG, TRUE)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG,
		STDAPICALLTYPE, FBadRow, FBadRow@4, LPSRow, TRUE)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG,
		STDAPICALLTYPE, FBadProp, FBadProp@4, LPSPropValue, TRUE)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG,
		STDAPICALLTYPE, FBadColumnSet, FBadColumnSet@4, LPSPropTagArray, TRUE)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		RTFSync, RTFSync@12, LPMESSAGE, ULONG, BOOL FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		WrapCompressedRTFStream, WrapCompressedRTFStream@12,
		LPSTREAM, ULONG, LPSTREAM FAR *, MAPI_E_CALL_FAILED)

#if defined(_X86_) || defined( WIN16 )

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		__ValidateParameters, __ValidateParameters@8,
		METHODS, void *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		__CPPValidateParameters, __CPPValidateParameters@8,
		METHODS, const LPVOID, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		HrValidateParameters, HrValidateParameters@8,
		METHODS, LPVOID FAR *, MAPI_E_CALL_FAILED)

#else

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		__ValidateParameters, __ValidateParameters@8,
		METHODS, void *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		__CPPValidateParameters, __CPPValidateParameters@8,
		METHODS, const LPVOID, MAPI_E_CALL_FAILED)

// STDAPIV HrValidateParametersValist( METHODS eMethod, va_list arglist )
DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C,
		HRESULT, STDAPIVCALLTYPE, HrValidateParametersValist,
		HrValidateParametersValist, METHODS, va_list, MAPI_E_CALL_FAILED)

// STDAPIV HrValidateParametersV( METHODS eMethod, ... )

LINKAGE_EXTERN_C HRESULT STDAPIVCALLTYPE HrValidateParametersV(METHODS eMethod, ...)
{
	va_list arg;

	va_start(arg, eMethod);

	HRESULT hr = HrValidateParametersValist(eMethod, arg);

	va_end(arg);

	return hr;
}

#endif // if defined(_X86_) || defined( WIN16 )

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG,
		STDAPICALLTYPE, FBadSortOrderSet, FBadSortOrderSet@4, LPSSortOrderSet, TRUE)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, BOOL,
		STDAPICALLTYPE, FBadEntryList, FBadEntryList@4, LPENTRYLIST, TRUE)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG,
		STDAPICALLTYPE, FBadRestriction, FBadRestriction@4, LPSRestriction, TRUE)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		ScUNCFromLocalPath, ScUNCFromLocalPath@12, LPSTR, LPSTR, UINT, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		ScLocalPathFromUNC, ScLocalPathFromUNC@12, LPSTR, LPSTR, UINT, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_4(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT,
		STDAPICALLTYPE, HrIStorageFromStream, HrIStorageFromStream@16,
		LPUNKNOWN, LPCIID, ULONG, LPSTORAGE FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_5(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT,
		STDAPICALLTYPE, HrValidateIPMSubtree, HrValidateIPMSubtree@20, LPMDB, ULONG,
		ULONG FAR *, LPSPropValue FAR *, LPMAPIERROR FAR *, MAPI_E_CALL_FAILED)

// Note on OpenIMsgSession(), CloseIMsgSession(), and OpenIMsgOnIStg()
// These three functions use LPMSGSESS. LPMSGSESS is typedef'd as
//    typedef struct _MSGSESS         FAR * LPMSGSESS;
// in imessage.h (a public header file), but struct _MSGSESS is declared
// only in a private header file, mapi\src\_imsg.h. LPMSGSESS is an
// interface pointer (see _imsg.h), but it appears to be opaque to clients
// of mapi32.dll. So we do not thunk it. Furthermore, although it is declared
// as an interface, it does not support IUnknown methods, see src\mapi\msgbase.c
// for the declaration of MS_Vtbl, which sets the fn pointers for QI,
// AddRef, etc to NULL.
//
// Note: we do not thunk the LPMSGSESS argument

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		OpenIMsgSession, OpenIMsgSession@12,
		LPMALLOC, ULONG, LPMSGSESS FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_V1(ExtendedMAPI, LINKAGE_EXTERN_C, STDAPICALLTYPE,
		CloseIMsgSession, CloseIMsgSession@4, LPMSGSESS)

DEFINE_STUB_FUNCTION_11(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE,
		STDAPICALLTYPE, OpenIMsgOnIStg, OpenIMsgOnIStg@44, LPMSGSESS, LPALLOCATEBUFFER,
		LPALLOCATEMORE, LPFREEBUFFER, LPMALLOC, LPVOID, LPSTORAGE,
		MSGCALLRELEASE FAR *, ULONG, ULONG, LPMESSAGE FAR *, MAPI_E_CALL_FAILED)

// Note on SetAttribIMsgOnIStg() and GetAttribIMsgOnIStg(). The first argument
// (LPVOID) is cast in these fns (see src\mapi\msgprop2.c) to PPROPOBJ which
// appears to be a private interface (declared in src\mapi\_imsg.h). The
// following are some ways the app gets one of these pointers - there may be
// others.
//
// src\mapi\msgbase.c creates these objects in PROPOBJ_Create; depending on
// an input argument, the object is one of an attachment, a recipient or a
// message. PROPOBJ_Create is called (indirectly, via ScOpenSubObject()) from
// IMessage::OpenAttach (Msg_OpenAttach() in msgmsg.c) which returns the
// PROPOBJ_Create'd object via its last argument - an LPATTACH *.
//
// PROPOBJ_Create is also called (again, indirectly, via ScOpenSubObject())
// from PROPOBJ_OpenProperty() (which is the implementation of
// IMAPIProp::OpenProperty and is in msgprop2.c) and the value it returns
// is returned to the caller as an IUnknown*. (PROPOBJ_Create is called only
// when ulPropTag is PT_OBJECT and the iid is IID_IMessage.)
//
// The issue is that these fns use data members in these objects (no methods
// though) and we should not pass in proxies. We have 3 alternatives:
//
//      - the app passes in proxies - we can get by with calling ResolveProxy
//        (Mapi creates the object and the app got it via an API that
//        thunked it.)
//
//      - the app passes in an unthunked pointer that it regards as opaque.
//        (which is possible because these interfaces are private) or an
//        unthunked poitner that it got from an API call that we've not
//        thunked (i.e., our bug). In this case we should pass the pointer
//        without any thunking.
//
//      - the app creates an interface and passes a pointer to it. This is
//        unlikely to work because these functions use data in the objects
//        that the app can't know about. (For this case, we have to thunk
//        the interface pointer and pass the proxy to mapi.)
//
// The Jul 98 MSDN's description of the arguments does not help in figuring
// out which of these cases are reasonable.
//
// We use the ResolveProxy workaround used for the UNKOBJ* fns above.
// Note: This ignores the second and third cases as possibilities.
//
// The other args to these fns do not require any thunking.

DEFINE_STUB_FUNCTION_4(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT,
		STDAPICALLTYPE, SetAttribIMsgOnIStg, SetAttribIMsgOnIStg@16, LPVOID, LPSPropTagArray,
		LPSPropAttrArray, LPSPropProblemArray FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT,
		STDAPICALLTYPE, GetAttribIMsgOnIStg, GetAttribIMsgOnIStg@12, LPVOID,
		LPSPropTagArray, LPSPropAttrArray FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE,
		STDAPICALLTYPE, MapStorageSCode, MapStorageSCode@4, SCODE, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_V3(ExtendedMAPI, LINKAGE_EXTERN_C, STDAPICALLTYPE,
		EncodeID, EncodeID@12, LPBYTE, ULONG, LPTSTR)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, BOOL, STDAPICALLTYPE,
		FDecodeID, FDecodeID@12, LPTSTR, LPBYTE, ULONG FAR *, 0)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG,
		STDAPICALLTYPE, CchOfEncoding, CchOfEncoding@4, ULONG, 0)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG,
		STDAPICALLTYPE, CbOfEncoded, CbOfEncoded@4, LPTSTR, 0)



#if 1

LINKAGE_EXTERN_C typedef SCODE (STDMETHODCALLTYPE * ScMAPIXFromSMAPIFuncPtr)(
			LHANDLE, ULONG, LPCIID, LPMAPISESSION FAR *);

LINKAGE_EXTERN_C SCODE STDMETHODCALLTYPE ScMAPIXFromSMAPI(
		LHANDLE a, ULONG b, LPCIID c, LPMAPISESSION FAR * d)
{
	if (hmodSimpleMAPI != NULL && GetProxyDll(ExtendedMAPI) == hmodSimpleMAPI)
	{
		static ScMAPIXFromSMAPIFuncPtr OMIStubScMAPIXFromSMAPI =
				(ScMAPIXFromSMAPIFuncPtr) ::GetProcAddress(
					hmodExtendedMAPI, "ScMAPIXFromSMAPI");

		if (NULL == OMIStubScMAPIXFromSMAPI)
		{
			AssertSz(FALSE, "MAPI32 Stub:  "
				"Entry point \"ScMAPIXFromSMAPI\" not found!");

			return MAPI_E_CALL_FAILED;
		}
		else
		{
			return OMIStubScMAPIXFromSMAPI(a, b, c, d);
		}
	}
	else
	{
		AssertSz(FALSE, "MAPI32 Stub:  "
			"Can't get entry point \"ScMAPIXFromSMAPI\" when SimpleMAPI != ExtendedMAPI");

		return MAPI_E_CALL_FAILED;
	}
}

DEFINE_STUB_FUNCTION_4(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE,
		STDMETHODCALLTYPE, ScMAPIXFromCMC, ScMAPIXFromCMC, LHANDLE,
		ULONG, LPCIID, LPMAPISESSION FAR *, MAPI_E_CALL_FAILED)

#else

DEFINE_STUB_FUNCTION_4(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE,
		STDMETHODCALLTYPE, ScMAPIXFromSMAPI, ScMAPIXFromSMAPI, LHANDLE,
		ULONG, LPCIID, LPMAPISESSION FAR *, MAPI_E_CALL_FAILED)

#endif



// The BMAPI functions are generally wrappers for Simple MAPI functions.
// The LPVB_* arguments are for recipients, files and messages, and
// are generally analogs of Simple MAPI structs w/ strings replaced by BSTR.
// The LPSAFEARRAYs are generally arrays of the file, recipients, etc, structs.
// The LHANDLE argument is a Simple MAPI session handle.
// See src\mapi\_vbmapi.h for typedefs and bmapi.c, vb2c.c for function
// implementations.
//
// So for WX86 none of the arguments of these functions needs to be thunked

DEFINE_STUB_FUNCTION_7(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL,
		BMAPISendMail, BMAPISendMail, LHANDLE, ULONG, LPVB_MESSAGE,
		LPSAFEARRAY *, LPSAFEARRAY *, ULONG, ULONG, (ULONG) MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_8(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL,
		BMAPISaveMail, BMAPISaveMail, LHANDLE, ULONG, LPVB_MESSAGE,
		LPSAFEARRAY *, LPSAFEARRAY *, ULONG, ULONG, BSTR *, (ULONG) MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_8(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL,
		BMAPIReadMail, BMAPIReadMail,
		LPULONG, LPULONG, LPULONG, LHANDLE, ULONG, BSTR *, ULONG, ULONG, (ULONG) MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_5(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL,
		BMAPIGetReadMail, BMAPIGetReadMail,
		ULONG, LPVB_MESSAGE, LPSAFEARRAY *, LPSAFEARRAY *, LPVB_RECIPIENT, (ULONG) MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_7(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL,
		BMAPIFindNext, BMAPIFindNext,
		LHANDLE, ULONG, BSTR *, BSTR *, ULONG, ULONG, BSTR *, (ULONG) MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_10(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL,
		BMAPIAddress, BMAPIAddress,
		LPULONG, LHANDLE, ULONG, BSTR *, ULONG, BSTR *,
		LPULONG, LPSAFEARRAY *, ULONG, ULONG, (ULONG) MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL,
		BMAPIGetAddress, BMAPIGetAddress, ULONG, ULONG, LPSAFEARRAY *, (ULONG) MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_5(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL, BMAPIDetails, BMAPIDetails,
		LHANDLE, ULONG, LPVB_RECIPIENT, ULONG, ULONG, (ULONG) MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_6(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL,
		BMAPIResolveName, BMAPIResolveName,
		LHANDLE, ULONG, BSTR, ULONG, ULONG, LPVB_RECIPIENT, (ULONG) MAPI_E_CALL_FAILED)

// The cmc_* types are all composed of simple scalar types, ses xcmc.h

DEFINE_STUB_FUNCTION_6(ExtendedMAPI, LINKAGE_EXTERN_C, CMC_return_code, FAR PASCAL,
		cmc_act_on, cmc_act_on, CMC_session_id, CMC_message_reference FAR *,
		CMC_enum, CMC_flags, CMC_ui_id, CMC_extension FAR *, CMC_E_FAILURE)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, CMC_return_code,
		FAR PASCAL, cmc_free, cmc_free, CMC_buffer, CMC_E_FAILURE)

DEFINE_STUB_FUNCTION_8(ExtendedMAPI, LINKAGE_EXTERN_C, CMC_return_code, FAR PASCAL,
		cmc_list, cmc_list, CMC_session_id, CMC_string, CMC_flags,
		CMC_message_reference FAR *, CMC_uint32 FAR *, CMC_ui_id,
		CMC_message_summary FAR * FAR *, CMC_extension FAR *, CMC_E_FAILURE)

DEFINE_STUB_FUNCTION_4(ExtendedMAPI, LINKAGE_EXTERN_C, CMC_return_code, FAR PASCAL,
		cmc_logoff, cmc_logoff,
		CMC_session_id, CMC_ui_id, CMC_flags, CMC_extension FAR *, CMC_E_FAILURE)

DEFINE_STUB_FUNCTION_9(ExtendedMAPI, LINKAGE_EXTERN_C, CMC_return_code, FAR PASCAL,
		cmc_logon, cmc_logon, CMC_string, CMC_string, CMC_string,
		CMC_object_identifier, CMC_ui_id, CMC_uint16, CMC_flags,
		CMC_session_id FAR *, CMC_extension FAR *, CMC_E_FAILURE)

DEFINE_STUB_FUNCTION_7(ExtendedMAPI, LINKAGE_EXTERN_C, CMC_return_code, FAR PASCAL,
		cmc_look_up, cmc_look_up, CMC_session_id, CMC_recipient FAR *,
		CMC_flags, CMC_ui_id, CMC_uint32 FAR *,
		CMC_recipient FAR * FAR *, CMC_extension FAR *, CMC_E_FAILURE)

DEFINE_STUB_FUNCTION_4(ExtendedMAPI, LINKAGE_EXTERN_C, CMC_return_code, FAR PASCAL,
		cmc_query_configuration, cmc_query_configuration, CMC_session_id,
		CMC_enum, CMC_buffer, CMC_extension FAR *, CMC_E_FAILURE)

DEFINE_STUB_FUNCTION_6(ExtendedMAPI, LINKAGE_EXTERN_C, CMC_return_code, FAR PASCAL,
		cmc_read, cmc_read, CMC_session_id, CMC_message_reference FAR *,
		CMC_flags, CMC_message FAR * FAR *, CMC_ui_id, CMC_extension FAR *, CMC_E_FAILURE)

DEFINE_STUB_FUNCTION_5(ExtendedMAPI, LINKAGE_EXTERN_C, CMC_return_code, FAR PASCAL,
		cmc_send, cmc_send, CMC_session_id, CMC_message FAR *,
		CMC_flags, CMC_ui_id, CMC_extension FAR *, CMC_E_FAILURE)

DEFINE_STUB_FUNCTION_8(ExtendedMAPI, LINKAGE_EXTERN_C, CMC_return_code, FAR PASCAL,
		cmc_send_documents, cmc_send_documents,
		CMC_string, CMC_string, CMC_string, CMC_flags,
		CMC_string, CMC_string, CMC_string, CMC_ui_id, CMC_E_FAILURE)




#if !defined (_X86_)

DEFINE_STUB_FUNCTION_USE_LOOKUP_1(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG, STDAPICALLTYPE,
		ExtendedMAPIFreeBuffer, MAPIFreeBuffer,
		LPVOID, (ULONG) MAPI_E_CALL_FAILED)

#else

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG, STDAPICALLTYPE,
		ExtendedMAPIFreeBuffer, MAPIFreeBuffer@4,
		LPVOID, (ULONG) MAPI_E_CALL_FAILED)

#endif

#if !defined (_X86_)

DEFINE_STUB_FUNCTION_USE_LOOKUP_1(SimpleMAPI, LINKAGE_EXTERN_C, ULONG, STDAPICALLTYPE,
		SimpleMAPIFreeBuffer, MAPIFreeBuffer,
		LPVOID, (ULONG) MAPI_E_CALL_FAILED)

#else

DEFINE_STUB_FUNCTION_1(SimpleMAPI, LINKAGE_EXTERN_C, ULONG, STDAPICALLTYPE,
		SimpleMAPIFreeBuffer, MAPIFreeBuffer,
		LPVOID, (ULONG) MAPI_E_CALL_FAILED)

#endif


LINKAGE_EXTERN_C ULONG STDAPICALLTYPE AmbiguousMAPIFreeBuffer(LPVOID lpvBuffer)
{
	if (NULL != lpvBuffer)		// NULL pointers allowed by Extended MAPI
	{
		EnterCriticalSection(&csLinkedList);

		FreeBufferBlocks ** ppfb = &g_pfbbHead;

		while (NULL != *ppfb)
		{
			if ((**ppfb).pvBuffer == lpvBuffer)
			{
				// It's a Simple MAPI allocation

				// Get it out of the linked list now.

				FreeBufferBlocks * pfbThis = *ppfb;

				*ppfb = pfbThis->pNext;

				::GlobalFree(pfbThis);

				LeaveCriticalSection(&csLinkedList);

				return ::SimpleMAPIFreeBuffer(lpvBuffer);
			}

			ppfb = &(**ppfb).pNext;
		}

		LeaveCriticalSection(&csLinkedList);

		// Didn't find it, it must be Extended MAPI

		return ::ExtendedMAPIFreeBuffer(lpvBuffer);
	}

	return SUCCESS_SUCCESS;
}



static HRESULT AddToFreeBufferBlocks(LPVOID lpvBuffer)
{
	FreeBufferBlocks * pfbNew = (FreeBufferBlocks *)
			::GlobalAlloc(GMEM_FIXED, sizeof(FreeBufferBlocks));

	if (NULL == pfbNew)
	{
		return MAPI_E_NOT_ENOUGH_MEMORY;
	}

	EnterCriticalSection(&csLinkedList);

	pfbNew->pvBuffer = lpvBuffer;
	pfbNew->pNext = g_pfbbHead;

	g_pfbbHead = pfbNew;

	LeaveCriticalSection(&csLinkedList);

	return SUCCESS_SUCCESS;
}




// Simple MAPI: none of these functions' arguments needs to be thunked for Wx86


LINKAGE_EXTERN_C typedef ULONG (FAR PASCAL * MAPIAddressFuncPtr)(
		LHANDLE, ULONG_PTR, LPSTR, ULONG, LPSTR, ULONG,
		lpMapiRecipDesc, FLAGS, ULONG, LPULONG, lpMapiRecipDesc FAR *);

LINKAGE_EXTERN_C ULONG FAR PASCAL MAPIAddress(LHANDLE a,
			ULONG_PTR b, LPSTR c, ULONG d, LPSTR e, ULONG f, lpMapiRecipDesc g,
			FLAGS h, ULONG i, LPULONG j, lpMapiRecipDesc FAR * ppNeedToFreeBuffer)
{
	static MAPIAddressFuncPtr OMIStubMAPIAddress = (MAPIAddressFuncPtr)
				::GetProcAddress(GetProxyDll(SimpleMAPI), "MAPIAddress");

	if (NULL == OMIStubMAPIAddress)
	{
		AssertSz(FALSE, "MAPI32 Stub:  Entry point \"MAPIAddress\" not found!");

		return (ULONG) MAPI_E_CALL_FAILED;
	}
	else
	{
		Assert(NULL != ppNeedToFreeBuffer);

		ULONG ulResult = OMIStubMAPIAddress(a, b, c, d, e, f, g, h, i, j, ppNeedToFreeBuffer);

		if (NULL != *ppNeedToFreeBuffer)
		{
			if (SUCCESS_SUCCESS != AddToFreeBufferBlocks(*ppNeedToFreeBuffer))
			{
				::SimpleMAPIFreeBuffer(*ppNeedToFreeBuffer);

				*ppNeedToFreeBuffer = NULL;

				return (ULONG) MAPI_E_NOT_ENOUGH_MEMORY;
			}
		}

		return ulResult;
	}
}



LINKAGE_EXTERN_C typedef ULONG (FAR PASCAL * MAPIReadMailFuncPtr)(
		LHANDLE, ULONG_PTR, LPSTR, FLAGS, ULONG, lpMapiMessage FAR *);

LINKAGE_EXTERN_C ULONG FAR PASCAL MAPIReadMail(LHANDLE a, ULONG_PTR b,
		LPSTR c, FLAGS d, ULONG e, lpMapiMessage FAR * ppNeedToFreeBuffer)
{
	static MAPIReadMailFuncPtr OMIStubMAPIReadMail = (MAPIReadMailFuncPtr)
				::GetProcAddress(GetProxyDll(SimpleMAPI), "MAPIReadMail");

	if (NULL == OMIStubMAPIReadMail)
	{
		AssertSz(FALSE, "MAPI32 Stub:  Entry point \"MAPIReadMail\" not found!");

		return (ULONG) MAPI_E_CALL_FAILED;
	}
	else
	{
		Assert(NULL != ppNeedToFreeBuffer);

		ULONG ulResult = OMIStubMAPIReadMail(a, b, c, d, e, ppNeedToFreeBuffer);

		if (NULL != *ppNeedToFreeBuffer)
		{
			if (SUCCESS_SUCCESS != AddToFreeBufferBlocks(*ppNeedToFreeBuffer))
			{
				::SimpleMAPIFreeBuffer(*ppNeedToFreeBuffer);

				*ppNeedToFreeBuffer = NULL;

				return (ULONG) MAPI_E_NOT_ENOUGH_MEMORY;
			}
		}

		return ulResult;
	}
}



LINKAGE_EXTERN_C typedef ULONG (FAR PASCAL * MAPIResolveNameFuncPtr)(
		LHANDLE, ULONG_PTR, LPSTR, FLAGS, ULONG, lpMapiRecipDesc FAR *);

LINKAGE_EXTERN_C ULONG FAR PASCAL MAPIResolveName(LHANDLE a, ULONG_PTR b,
		LPSTR c, FLAGS d, ULONG e, lpMapiRecipDesc FAR * ppNeedToFreeBuffer)
{
	static MAPIResolveNameFuncPtr OMIStubMAPIResolveName = (MAPIResolveNameFuncPtr)
				::GetProcAddress(GetProxyDll(SimpleMAPI), "MAPIResolveName");

	if (NULL == OMIStubMAPIResolveName)
	{
		AssertSz(FALSE, "MAPI32 Stub:  Entry point \"MAPIResolveName\" not found!");

		return (ULONG) MAPI_E_CALL_FAILED;
	}
	else
	{
		Assert(NULL != ppNeedToFreeBuffer);

		ULONG ulResult = OMIStubMAPIResolveName(a, b, c, d, e, ppNeedToFreeBuffer);

		if (NULL != *ppNeedToFreeBuffer)
		{
			if (SUCCESS_SUCCESS != AddToFreeBufferBlocks(*ppNeedToFreeBuffer))
			{
				::SimpleMAPIFreeBuffer(*ppNeedToFreeBuffer);

				*ppNeedToFreeBuffer = NULL;

				return (ULONG) MAPI_E_NOT_ENOUGH_MEMORY;
			}
		}

		return ulResult;
	}
}


DEFINE_STUB_FUNCTION_5(SimpleMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL,
		MAPISendDocuments, MAPISendDocuments,
		ULONG_PTR, LPSTR, LPSTR, LPSTR, ULONG, (ULONG) MAPI_E_CALL_FAILED)

#if !defined (_X86_)
DEFINE_STUB_FUNCTION_USE_LOOKUP_6(SimpleMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL,
		SimpleMAPILogon, MAPILogon,
		ULONG, LPSTR, LPSTR, FLAGS, ULONG, LPLHANDLE, (ULONG) MAPI_E_CALL_FAILED)
#else
DEFINE_STUB_FUNCTION_6(SimpleMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL,
		SimpleMAPILogon, MAPILogon,
		ULONG, LPSTR, LPSTR, FLAGS, ULONG, LPLHANDLE, (ULONG) MAPI_E_CALL_FAILED)
#endif

DEFINE_STUB_FUNCTION_4(SimpleMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL,
		MAPILogoff, MAPILogoff, LHANDLE, ULONG_PTR, FLAGS, ULONG, (ULONG) MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_5(SimpleMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL,
		MAPISendMail, MAPISendMail,
		LHANDLE, ULONG_PTR, lpMapiMessage, FLAGS, ULONG, (ULONG) MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_6(SimpleMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL,
		MAPISaveMail, MAPISaveMail, LHANDLE, ULONG_PTR, lpMapiMessage,
		FLAGS, ULONG, LPSTR, (ULONG) MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_7(SimpleMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL,
		MAPIFindNext, MAPIFindNext,
		LHANDLE, ULONG_PTR, LPSTR, LPSTR, FLAGS, ULONG, LPSTR, (ULONG) MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_5(SimpleMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL,
		MAPIDeleteMail, MAPIDeleteMail,
		LHANDLE, ULONG_PTR, LPSTR, FLAGS, ULONG, (ULONG) MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_5(SimpleMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL,
		MAPIDetails, MAPIDetails,
		LHANDLE, ULONG_PTR, lpMapiRecipDesc, FLAGS, ULONG, (ULONG) MAPI_E_CALL_FAILED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\mapistub\mapistub\msvalidp.h ===
/*
 *	MSVALIDP.H
 *
 *	Header file listing methods to be validated
 *
 *      This file is included by ..\mapistub\mapi32.cpp to thunk extended
 *      MAPI calls such as HrValidateParameters
 *
 *      NOTE: This file also defines a static function GetArguments for
 *      non-INTEL platforms. This function is required in mapistub and
 *      it is safer to maintain it in one place.
 *
 */

#ifndef _MSVALIDP_H
#define _MSVALIDP_H

#ifdef __cplusplus
extern "C" {
#endif

/* Data tables in code segments makes the ValidateParameters dispatch quicker
   in 16bit, and geting strings out of the data segment saves space in Debug */
#ifdef WIN16
#define BASED_CODE			__based(__segname("_CODE"))
#define BASED_STACK			__based(__segname("_STACK"))
#else
#define BASED_CODE
#define BASED_STACK
#endif

#define TABLE_SORT_OLD			0
#define TABLE_SORT_EXTENDED		1

#if defined(_X86_) || defined( WIN16 )
#define _INTEL_
#endif

#define VALIDATE_CALLTYPE		static int NEAR
typedef int (NEAR * ValidateProc)(void BASED_STACK *);


/* Structures to overlay on stack frame to give us access to the parameters */
/* Structure names MUST be in the form 'Method_Params' and 'LPMethod_Params' for the
   following macros to work correctly */

#include "structs.h"

#define MAX_ARG			16    // Max number of args of functions to be
                                      // validated

/* Copied from edkmdb.h */
#define SHOW_SOFT_DELETES		((ULONG) 0x00000002)

/* Function declarations ------------------------------------------------------------------------ */


#if !defined (WX86_MAPISTUB)

#define MAKE_VALIDATE_FUNCTION(Method, Interface)	VALIDATE_CALLTYPE	Interface##_##Method##_Validate(void BASED_STACK *)

/* Empty function for non-debug 'validation' */

#else

#define MAKE_VALIDATE_FUNCTION(Method, Interface)	

#endif // WX86_MAPISTUB

// #ifndef DEBUG
#if !defined (DEBUG) || defined (WX86_MAPISTUB)
VALIDATE_CALLTYPE	DoNothing_Validate(void BASED_STACK *);
#endif

/* IUnknown */
MAKE_VALIDATE_FUNCTION(QueryInterface, IUnknown);
MAKE_VALIDATE_FUNCTION(AddRef, IUnknown);		   /* For completness */
MAKE_VALIDATE_FUNCTION(Release, IUnknown);		   /* For completness */

/* IMAPIProp */
MAKE_VALIDATE_FUNCTION(GetLastError, IMAPIProp);
MAKE_VALIDATE_FUNCTION(SaveChanges, IMAPIProp);
MAKE_VALIDATE_FUNCTION(GetProps, IMAPIProp);
MAKE_VALIDATE_FUNCTION(GetPropList, IMAPIProp);
MAKE_VALIDATE_FUNCTION(OpenProperty, IMAPIProp);
MAKE_VALIDATE_FUNCTION(SetProps, IMAPIProp);
MAKE_VALIDATE_FUNCTION(DeleteProps, IMAPIProp);
MAKE_VALIDATE_FUNCTION(CopyTo, IMAPIProp);
MAKE_VALIDATE_FUNCTION(CopyProps, IMAPIProp);
MAKE_VALIDATE_FUNCTION(GetNamesFromIDs, IMAPIProp);
MAKE_VALIDATE_FUNCTION(GetIDsFromNames, IMAPIProp);

/* IMAPITable */
MAKE_VALIDATE_FUNCTION(GetLastError, IMAPITable);
MAKE_VALIDATE_FUNCTION(Advise, IMAPITable);
MAKE_VALIDATE_FUNCTION(Unadvise, IMAPITable);
MAKE_VALIDATE_FUNCTION(GetStatus, IMAPITable);
MAKE_VALIDATE_FUNCTION(SetColumns, IMAPITable);
MAKE_VALIDATE_FUNCTION(QueryColumns, IMAPITable);
MAKE_VALIDATE_FUNCTION(GetRowCount, IMAPITable);
MAKE_VALIDATE_FUNCTION(SeekRow, IMAPITable);
MAKE_VALIDATE_FUNCTION(SeekRowApprox, IMAPITable);
MAKE_VALIDATE_FUNCTION(QueryPosition, IMAPITable);
MAKE_VALIDATE_FUNCTION(FindRow, IMAPITable);
MAKE_VALIDATE_FUNCTION(Restrict, IMAPITable);
MAKE_VALIDATE_FUNCTION(CreateBookmark, IMAPITable);
MAKE_VALIDATE_FUNCTION(FreeBookmark, IMAPITable);
MAKE_VALIDATE_FUNCTION(SortTable, IMAPITable);
MAKE_VALIDATE_FUNCTION(QuerySortOrder, IMAPITable);
MAKE_VALIDATE_FUNCTION(QueryRows, IMAPITable);
MAKE_VALIDATE_FUNCTION(Abort, IMAPITable);
MAKE_VALIDATE_FUNCTION(ExpandRow, IMAPITable);
MAKE_VALIDATE_FUNCTION(CollapseRow, IMAPITable);
MAKE_VALIDATE_FUNCTION(WaitForCompletion, IMAPITable);
MAKE_VALIDATE_FUNCTION(GetCollapseState, IMAPITable);
MAKE_VALIDATE_FUNCTION(SetCollapseState, IMAPITable);

/* IMAPIStatus */
MAKE_VALIDATE_FUNCTION(ValidateState, IMAPIStatus);
MAKE_VALIDATE_FUNCTION(SettingsDialog, IMAPIStatus);
MAKE_VALIDATE_FUNCTION(ChangePassword, IMAPIStatus);
MAKE_VALIDATE_FUNCTION(FlushQueues, IMAPIStatus);

/* IMAPIContainer */
MAKE_VALIDATE_FUNCTION(GetContentsTable, IMAPIContainer);
MAKE_VALIDATE_FUNCTION(GetHierarchyTable, IMAPIContainer);
MAKE_VALIDATE_FUNCTION(OpenEntry, IMAPIContainer);
MAKE_VALIDATE_FUNCTION(SetSearchCriteria, IMAPIContainer);
MAKE_VALIDATE_FUNCTION(GetSearchCriteria, IMAPIContainer);

/* IABContainer */
MAKE_VALIDATE_FUNCTION(CreateEntry, IABContainer);
MAKE_VALIDATE_FUNCTION(CopyEntries, IABContainer);
MAKE_VALIDATE_FUNCTION(DeleteEntries, IABContainer);
MAKE_VALIDATE_FUNCTION(ResolveNames, IABContainer);

/* IDistList */
MAKE_VALIDATE_FUNCTION(CreateEntry, IDistList);
MAKE_VALIDATE_FUNCTION(CopyEntries, IDistList);
MAKE_VALIDATE_FUNCTION(DeleteEntries, IDistList);
MAKE_VALIDATE_FUNCTION(ResolveNames, IDistList);

/* IMAPIFolder */
MAKE_VALIDATE_FUNCTION(CreateMessage, IMAPIFolder);
MAKE_VALIDATE_FUNCTION(CopyMessages, IMAPIFolder);
MAKE_VALIDATE_FUNCTION(DeleteMessages, IMAPIFolder);
MAKE_VALIDATE_FUNCTION(CreateFolder, IMAPIFolder);
MAKE_VALIDATE_FUNCTION(CopyFolder, IMAPIFolder);
MAKE_VALIDATE_FUNCTION(DeleteFolder, IMAPIFolder);
MAKE_VALIDATE_FUNCTION(SetReadFlags, IMAPIFolder);
MAKE_VALIDATE_FUNCTION(GetMessageStatus, IMAPIFolder);
MAKE_VALIDATE_FUNCTION(SetMessageStatus, IMAPIFolder);
MAKE_VALIDATE_FUNCTION(SaveContentsSort, IMAPIFolder);
MAKE_VALIDATE_FUNCTION(EmptyFolder, IMAPIFolder);

/* IMsgStore */
MAKE_VALIDATE_FUNCTION(Advise, IMsgStore);
MAKE_VALIDATE_FUNCTION(Unadvise, IMsgStore);
MAKE_VALIDATE_FUNCTION(CompareEntryIDs, IMsgStore);
MAKE_VALIDATE_FUNCTION(OpenEntry, IMsgStore);
MAKE_VALIDATE_FUNCTION(SetReceiveFolder, IMsgStore);
MAKE_VALIDATE_FUNCTION(GetReceiveFolder, IMsgStore);
MAKE_VALIDATE_FUNCTION(GetReceiveFolderTable, IMsgStore);
MAKE_VALIDATE_FUNCTION(StoreLogoff, IMsgStore);
MAKE_VALIDATE_FUNCTION(AbortSubmit, IMsgStore);
MAKE_VALIDATE_FUNCTION(GetOutgoingQueue, IMsgStore);
MAKE_VALIDATE_FUNCTION(SetLockState, IMsgStore);
MAKE_VALIDATE_FUNCTION(FinishedMsg, IMsgStore);
MAKE_VALIDATE_FUNCTION(NotifyNewMail, IMsgStore);

/* IMessage */
MAKE_VALIDATE_FUNCTION(GetAttachmentTable, IMessage);
MAKE_VALIDATE_FUNCTION(OpenAttach, IMessage);
MAKE_VALIDATE_FUNCTION(CreateAttach, IMessage);
MAKE_VALIDATE_FUNCTION(DeleteAttach, IMessage);
MAKE_VALIDATE_FUNCTION(GetRecipientTable, IMessage);
MAKE_VALIDATE_FUNCTION(ModifyRecipients, IMessage);
MAKE_VALIDATE_FUNCTION(SubmitMessage, IMessage);
MAKE_VALIDATE_FUNCTION(SetReadFlag, IMessage);


/* IABProvider */
MAKE_VALIDATE_FUNCTION(Shutdown, IABProvider);
MAKE_VALIDATE_FUNCTION(Logon, IABProvider);

/* IABLogon */
MAKE_VALIDATE_FUNCTION(GetLastError, IABLogon);
MAKE_VALIDATE_FUNCTION(Logoff, IABLogon);
MAKE_VALIDATE_FUNCTION(OpenEntry, IABLogon);
MAKE_VALIDATE_FUNCTION(CompareEntryIDs, IABLogon);
MAKE_VALIDATE_FUNCTION(Advise, IABLogon);
MAKE_VALIDATE_FUNCTION(Unadvise, IABLogon);
MAKE_VALIDATE_FUNCTION(OpenStatusEntry, IABLogon);
MAKE_VALIDATE_FUNCTION(OpenTemplateID, IABLogon);
MAKE_VALIDATE_FUNCTION(GetOneOffTable, IABLogon);
MAKE_VALIDATE_FUNCTION(PrepareRecips, IABLogon);

/* IXPProvider */
MAKE_VALIDATE_FUNCTION(Shutdown, IXPProvider);
MAKE_VALIDATE_FUNCTION(TransportLogon, IXPProvider);

/* IXPLogon */
MAKE_VALIDATE_FUNCTION(AddressTypes, IXPLogon);
MAKE_VALIDATE_FUNCTION(RegisterOptions, IXPLogon);
MAKE_VALIDATE_FUNCTION(TransportNotify, IXPLogon);
MAKE_VALIDATE_FUNCTION(Idle, IXPLogon);
MAKE_VALIDATE_FUNCTION(TransportLogoff, IXPLogon);
MAKE_VALIDATE_FUNCTION(SubmitMessage, IXPLogon);
MAKE_VALIDATE_FUNCTION(EndMessage, IXPLogon);
MAKE_VALIDATE_FUNCTION(Poll, IXPLogon);
MAKE_VALIDATE_FUNCTION(StartMessage, IXPLogon);
MAKE_VALIDATE_FUNCTION(OpenStatusEntry, IXPLogon);
MAKE_VALIDATE_FUNCTION(ValidateState, IXPLogon);
MAKE_VALIDATE_FUNCTION(FlushQueues, IXPLogon);

/* IMSProvider */
MAKE_VALIDATE_FUNCTION(Shutdown, IMSProvider);
MAKE_VALIDATE_FUNCTION(Logon, IMSProvider);
MAKE_VALIDATE_FUNCTION(SpoolerLogon, IMSProvider);
MAKE_VALIDATE_FUNCTION(CompareStoreIDs, IMSProvider);

/* IMSLogon */
MAKE_VALIDATE_FUNCTION(GetLastError, IMSLogon);
MAKE_VALIDATE_FUNCTION(Logoff, IMSLogon);
MAKE_VALIDATE_FUNCTION(OpenEntry, IMSLogon);
MAKE_VALIDATE_FUNCTION(CompareEntryIDs, IMSLogon);
MAKE_VALIDATE_FUNCTION(Advise, IMSLogon);
MAKE_VALIDATE_FUNCTION(Unadvise, IMSLogon);
MAKE_VALIDATE_FUNCTION(OpenStatusEntry, IMSLogon);

/* IMAPIControl */
MAKE_VALIDATE_FUNCTION(GetLastError, IMAPIControl);
MAKE_VALIDATE_FUNCTION(Activate, IMAPIControl);
MAKE_VALIDATE_FUNCTION(GetState, IMAPIControl);

/* IStream */
MAKE_VALIDATE_FUNCTION(Read, IStream);
MAKE_VALIDATE_FUNCTION(Write, IStream);
MAKE_VALIDATE_FUNCTION(Seek, IStream);
MAKE_VALIDATE_FUNCTION(SetSize, IStream);
MAKE_VALIDATE_FUNCTION(CopyTo, IStream);
MAKE_VALIDATE_FUNCTION(Commit, IStream);
MAKE_VALIDATE_FUNCTION(Revert, IStream);
MAKE_VALIDATE_FUNCTION(LockRegion, IStream);
MAKE_VALIDATE_FUNCTION(UnlockRegion, IStream);
MAKE_VALIDATE_FUNCTION(Stat, IStream);
MAKE_VALIDATE_FUNCTION(Clone, IStream);

/* IMAPIAdviseSink */
MAKE_VALIDATE_FUNCTION(OnNotify, IMAPIAdviseSink);

/* IMAPITable */
MAKE_VALIDATE_FUNCTION(SortTableEx, IMAPITable);

/* Table of validation functions and Offsets of the This member of the Params structure --------- */
typedef struct _tagMethodEntry
{
	ValidateProc		pfnValidation;			// Validation function for this method
#if !defined(_INTEL_) || defined(DEBUG)
	UINT				cParameterSize;			// Expected size of parameters for stack validation
#endif
#if defined (WX86_MAPISTUB)
        Wx86MapiArgThunkInfo*  pThunk;
#endif
} METHODENTRY;


#if !defined(_INTEL_) || defined(DEBUG)

#if !defined (WX86_MAPISTUB)

#define MAKE_PERM_ENTRY(Method, Interface)	 { Interface##_##Method##_Validate, sizeof(Interface##_##Method##_Params) }

#else

#define MAKE_PERM_ENTRY(Method, Interface)	 { DoNothing_Validate, sizeof(Interface##_##Method##_Params), Interface##_##Method##_Thunk }

#endif // WX86_MAPISTUB

#else
#define MAKE_PERM_ENTRY(Method, Interface)	 { Interface##_##Method##_Validate }
#endif

#if defined(DEBUG) && !defined(WX86_MAPISTUB)
#define MAKE_TEMP_ENTRY(Method, Interface)	 { Interface##_##Method##_Validate, sizeof(Interface##_##Method##_Params) }
#else
#define MAKE_TEMP_ENTRY(Method, Interface)	 { DoNothing_Validate }
#endif


METHODENTRY BASED_CODE meMethodTable[] =
{
/* IUnknown */
	MAKE_PERM_ENTRY(QueryInterface, IUnknown),
	MAKE_PERM_ENTRY(AddRef, IUnknown),
	MAKE_PERM_ENTRY(Release, IUnknown),

/* IMAPIProp */
	MAKE_PERM_ENTRY(GetLastError, IMAPIProp),
	MAKE_PERM_ENTRY(SaveChanges, IMAPIProp),
	MAKE_PERM_ENTRY(GetProps, IMAPIProp),
	MAKE_PERM_ENTRY(GetPropList, IMAPIProp),
	MAKE_PERM_ENTRY(OpenProperty, IMAPIProp),
	MAKE_PERM_ENTRY(SetProps, IMAPIProp),
	MAKE_PERM_ENTRY(DeleteProps, IMAPIProp),
	MAKE_PERM_ENTRY(CopyTo, IMAPIProp),
	MAKE_PERM_ENTRY(CopyProps, IMAPIProp),
	MAKE_PERM_ENTRY(GetNamesFromIDs, IMAPIProp),
	MAKE_PERM_ENTRY(GetIDsFromNames, IMAPIProp),

/* IMAPITable */
	MAKE_PERM_ENTRY(GetLastError, IMAPITable),
	MAKE_PERM_ENTRY(Advise, IMAPITable),
	MAKE_PERM_ENTRY(Unadvise, IMAPITable),
	MAKE_PERM_ENTRY(GetStatus, IMAPITable),
	MAKE_PERM_ENTRY(SetColumns, IMAPITable),
	MAKE_PERM_ENTRY(QueryColumns, IMAPITable),
	MAKE_PERM_ENTRY(GetRowCount, IMAPITable),
	MAKE_PERM_ENTRY(SeekRow, IMAPITable),
	MAKE_PERM_ENTRY(SeekRowApprox, IMAPITable),
	MAKE_PERM_ENTRY(QueryPosition, IMAPITable),
	MAKE_PERM_ENTRY(FindRow, IMAPITable),
	MAKE_PERM_ENTRY(Restrict, IMAPITable),
	MAKE_PERM_ENTRY(CreateBookmark, IMAPITable),
	MAKE_PERM_ENTRY(FreeBookmark, IMAPITable),
	MAKE_PERM_ENTRY(SortTable, IMAPITable),
	MAKE_PERM_ENTRY(QuerySortOrder, IMAPITable),
	MAKE_PERM_ENTRY(QueryRows, IMAPITable),
	MAKE_PERM_ENTRY(Abort, IMAPITable),
	MAKE_PERM_ENTRY(ExpandRow, IMAPITable),
	MAKE_PERM_ENTRY(CollapseRow, IMAPITable),
	MAKE_PERM_ENTRY(WaitForCompletion, IMAPITable),
	MAKE_PERM_ENTRY(GetCollapseState, IMAPITable),
	MAKE_PERM_ENTRY(SetCollapseState, IMAPITable),

/* IMAPIContainer */
	MAKE_PERM_ENTRY(GetContentsTable, IMAPIContainer),
	MAKE_PERM_ENTRY(GetHierarchyTable, IMAPIContainer),
	MAKE_PERM_ENTRY(OpenEntry, IMAPIContainer),
	MAKE_PERM_ENTRY(SetSearchCriteria, IMAPIContainer),
	MAKE_PERM_ENTRY(GetSearchCriteria, IMAPIContainer),

/* IABContainer */
	MAKE_PERM_ENTRY(CreateEntry, IABContainer),
	MAKE_PERM_ENTRY(CopyEntries, IABContainer),
	MAKE_PERM_ENTRY(DeleteEntries, IABContainer),
	MAKE_PERM_ENTRY(ResolveNames, IABContainer),

/* IDistList same as IABContainer */
	MAKE_PERM_ENTRY(CreateEntry, IDistList),
	MAKE_PERM_ENTRY(CopyEntries, IDistList),
	MAKE_PERM_ENTRY(DeleteEntries, IDistList),
	MAKE_PERM_ENTRY(ResolveNames, IDistList),

/* IMAPIFolder */
	MAKE_PERM_ENTRY(CreateMessage, IMAPIFolder),
	MAKE_PERM_ENTRY(CopyMessages, IMAPIFolder),
	MAKE_PERM_ENTRY(DeleteMessages, IMAPIFolder),
	MAKE_PERM_ENTRY(CreateFolder, IMAPIFolder),
	MAKE_PERM_ENTRY(CopyFolder, IMAPIFolder),
	MAKE_PERM_ENTRY(DeleteFolder, IMAPIFolder),
	MAKE_PERM_ENTRY(SetReadFlags, IMAPIFolder),
	MAKE_PERM_ENTRY(GetMessageStatus, IMAPIFolder),
	MAKE_PERM_ENTRY(SetMessageStatus, IMAPIFolder),
	MAKE_PERM_ENTRY(SaveContentsSort, IMAPIFolder),
	MAKE_PERM_ENTRY(EmptyFolder, IMAPIFolder),

/* IMsgStore */
	MAKE_PERM_ENTRY(Advise, IMsgStore),
	MAKE_PERM_ENTRY(Unadvise, IMsgStore),
	MAKE_PERM_ENTRY(CompareEntryIDs, IMsgStore),
	MAKE_PERM_ENTRY(OpenEntry, IMsgStore),
	MAKE_PERM_ENTRY(SetReceiveFolder, IMsgStore),
	MAKE_PERM_ENTRY(GetReceiveFolder, IMsgStore),
	MAKE_PERM_ENTRY(GetReceiveFolderTable, IMsgStore),
	MAKE_PERM_ENTRY(StoreLogoff, IMsgStore),
	MAKE_PERM_ENTRY(AbortSubmit, IMsgStore),
	MAKE_PERM_ENTRY(GetOutgoingQueue, IMsgStore),
	MAKE_PERM_ENTRY(SetLockState, IMsgStore),
	MAKE_PERM_ENTRY(FinishedMsg, IMsgStore),
	MAKE_PERM_ENTRY(NotifyNewMail, IMsgStore),

/* IMessage */
	MAKE_PERM_ENTRY(GetAttachmentTable, IMessage),
	MAKE_PERM_ENTRY(OpenAttach, IMessage),
	MAKE_PERM_ENTRY(CreateAttach, IMessage),
	MAKE_PERM_ENTRY(DeleteAttach, IMessage),
	MAKE_PERM_ENTRY(GetRecipientTable, IMessage),
	MAKE_PERM_ENTRY(ModifyRecipients, IMessage),
	MAKE_PERM_ENTRY(SubmitMessage, IMessage),
	MAKE_PERM_ENTRY(SetReadFlag, IMessage),


/* IABProvider */
	MAKE_TEMP_ENTRY(Shutdown, IABProvider),
	MAKE_TEMP_ENTRY(Logon, IABProvider),

/* IABLogon */
	MAKE_TEMP_ENTRY(GetLastError, IABLogon),
	MAKE_TEMP_ENTRY(Logoff, IABLogon),
	MAKE_TEMP_ENTRY(OpenEntry, IABLogon),
	MAKE_TEMP_ENTRY(CompareEntryIDs, IABLogon),
	MAKE_TEMP_ENTRY(Advise, IABLogon),
	MAKE_TEMP_ENTRY(Unadvise, IABLogon),
	MAKE_TEMP_ENTRY(OpenStatusEntry, IABLogon),
	MAKE_TEMP_ENTRY(OpenTemplateID, IABLogon),
	MAKE_TEMP_ENTRY(GetOneOffTable, IABLogon),
	MAKE_TEMP_ENTRY(PrepareRecips, IABLogon),

/* IXPProvider */
	MAKE_TEMP_ENTRY(Shutdown, IXPProvider),
	MAKE_TEMP_ENTRY(TransportLogon, IXPProvider),

/* IXPLogon */
	MAKE_TEMP_ENTRY(AddressTypes, IXPLogon),
	MAKE_TEMP_ENTRY(RegisterOptions, IXPLogon),
	MAKE_TEMP_ENTRY(TransportNotify, IXPLogon),
	MAKE_TEMP_ENTRY(Idle, IXPLogon),
	MAKE_TEMP_ENTRY(TransportLogoff, IXPLogon),
	MAKE_TEMP_ENTRY(SubmitMessage, IXPLogon),
	MAKE_TEMP_ENTRY(EndMessage, IXPLogon),
	MAKE_TEMP_ENTRY(Poll, IXPLogon),
	MAKE_TEMP_ENTRY(StartMessage, IXPLogon),
	MAKE_TEMP_ENTRY(OpenStatusEntry, IXPLogon),
	MAKE_TEMP_ENTRY(ValidateState, IXPLogon),
	MAKE_TEMP_ENTRY(FlushQueues, IXPLogon),

/* IMSProvider */
	MAKE_TEMP_ENTRY(Shutdown, IMSProvider),
	MAKE_TEMP_ENTRY(Logon, IMSProvider),
	MAKE_TEMP_ENTRY(SpoolerLogon, IMSProvider),
	MAKE_TEMP_ENTRY(CompareStoreIDs, IMSProvider),

/* IMSLogon */
	MAKE_TEMP_ENTRY(GetLastError, IMSLogon),
	MAKE_TEMP_ENTRY(Logoff, IMSLogon),
	MAKE_TEMP_ENTRY(OpenEntry, IMSLogon),
	MAKE_TEMP_ENTRY(CompareEntryIDs, IMSLogon),
	MAKE_TEMP_ENTRY(Advise, IMSLogon),
	MAKE_TEMP_ENTRY(Unadvise, IMSLogon),
	MAKE_TEMP_ENTRY(OpenStatusEntry, IMSLogon),

/* IMAPIControl */
	MAKE_PERM_ENTRY(GetLastError, IMAPIControl),
	MAKE_PERM_ENTRY(Activate, IMAPIControl),
	MAKE_PERM_ENTRY(GetState, IMAPIControl),

/* IMAPIStatus */
	MAKE_PERM_ENTRY(ValidateState, IMAPIStatus),
	MAKE_PERM_ENTRY(SettingsDialog, IMAPIStatus),
	MAKE_PERM_ENTRY(ChangePassword, IMAPIStatus),
	MAKE_PERM_ENTRY(FlushQueues, IMAPIStatus),

/* IStream */
	MAKE_PERM_ENTRY(Read, IStream),
	MAKE_PERM_ENTRY(Write, IStream),
	MAKE_PERM_ENTRY(Seek, IStream),
	MAKE_PERM_ENTRY(SetSize, IStream),
	MAKE_PERM_ENTRY(CopyTo, IStream),
	MAKE_PERM_ENTRY(Commit, IStream),
	MAKE_PERM_ENTRY(Revert, IStream),
	MAKE_PERM_ENTRY(LockRegion, IStream),
	MAKE_PERM_ENTRY(UnlockRegion, IStream),
	MAKE_PERM_ENTRY(Stat, IStream),
	MAKE_PERM_ENTRY(Clone, IStream),

/* IMAPIAdviseSink */
	MAKE_PERM_ENTRY(OnNotify, IMAPIAdviseSink),

/* IMAPITable */	
	MAKE_PERM_ENTRY(SortTableEx, IMAPITable),

};

#if !defined(_INTEL_)

#define FSPECIALMETHOD(m)	(  m == IStream_Seek \
							|| m == IStream_SetSize \
							|| m == IStream_CopyTo \
							|| m == IStream_LockRegion \
							|| m == IStream_UnlockRegion \
							)

static void GetArguments(METHODS eMethod, va_list arglist, LPVOID *rgArg)
{
	// Handle methods whose arguments can be of a size other than that of
	// an LPVOID. Each argument is grabbed off of the list and laid out
	// into the validation structure for the method overlayed on top of
	// the argument buffer passed in.

	AssertSz(FIsAligned(rgArg), "GetArguments: Unaligned argument buffer passed in");

	switch( eMethod )
	{
		case IStream_Seek:
		{
			LPIStream_Seek_Params	p = (LPIStream_Seek_Params) rgArg;

			p->This 			= 	va_arg(arglist, LPVOID);
			p->dlibMove  		= 	va_arg(arglist, LARGE_INTEGER);
			p->dwOrigin 		= 	va_arg(arglist, DWORD);
			p->plibNewPosition 	= 	va_arg(arglist, ULARGE_INTEGER FAR *);

			AssertSz( (MAX_ARG * sizeof(LPVOID)) >= ( (p+1) - p ),
					  "Method being validated overflowed argument buffer");
			break;
		}

		case IStream_SetSize:
		{
			LPIStream_SetSize_Params	p = (LPIStream_SetSize_Params) rgArg;

			p->This 			= 	va_arg(arglist, LPVOID);
			p->libNewSize		= 	va_arg(arglist, ULARGE_INTEGER);

			AssertSz( (MAX_ARG * sizeof(LPVOID)) >= ( (p+1) - p ),
					  "Method being validated overflowed argument buffer");
			break;
		}

		case IStream_CopyTo:
		{
			LPIStream_CopyTo_Params	p = (LPIStream_CopyTo_Params) rgArg;

			p->This 			= 	va_arg(arglist, LPVOID);
			p->pstm 			= 	va_arg(arglist, IStream FAR *);
			p->cb 		 		= 	va_arg(arglist, ULARGE_INTEGER);
			p->pcbRead 			= 	va_arg(arglist, ULARGE_INTEGER FAR *);
			p->pcbWritten 		= 	va_arg(arglist, ULARGE_INTEGER FAR *);

			AssertSz( (MAX_ARG * sizeof(LPVOID)) >= ( (p+1) - p ),
					  "Method being validated overflowed argument buffer");
			break;
		}

		case IStream_LockRegion:
		{
			LPIStream_LockRegion_Params	p = (LPIStream_LockRegion_Params) rgArg;

			p->This 			= 	va_arg(arglist, LPVOID);
			p->libOffset  		= 	va_arg(arglist, ULARGE_INTEGER);
			p->cb 				= 	va_arg(arglist, ULARGE_INTEGER);
			p->dwLockType 		= 	va_arg(arglist, DWORD);

			AssertSz( (MAX_ARG * sizeof(LPVOID)) >= ( (p+1) - p ),
					  "Method being validated overflowed argument buffer");
			break;
		}

		case IStream_UnlockRegion:
		{
			LPIStream_UnlockRegion_Params	p = (LPIStream_UnlockRegion_Params) rgArg;

			p->This 			= 	va_arg(arglist, LPVOID);
			p->libOffset 	 	= 	va_arg(arglist, ULARGE_INTEGER);
			p->cb 				= 	va_arg(arglist, ULARGE_INTEGER);
			p->dwLockType 		= 	va_arg(arglist, DWORD);

			AssertSz( (MAX_ARG * sizeof(LPVOID)) >= ( (p+1) - p ),
					  "Method being validated overflowed argument buffer");
			break;
		}

		default:

			AssertSz(FALSE, "Custom argument handling for call being validated NYI");
			break;
	}
}

#if defined (WX86_MAPISTUB)

// Handle methods whose arguments can be of a size other than that of
// an LPVOID. This should be updated along with GetArguments

#define Wx86MapiCallHrValidateParametersV(eMethod, rgArg, hr) \
    switch( eMethod ) \
    { \
        case IStream_Seek: \
        { \
            hr = HrValidateParametersV(eMethod, rgArg[0],  \
                                       *((ULARGE_INTEGER *) &rgArg[1]), \
                                       rgArg[3], rgArg[4]); \
            break; \
        } \
 \
        case IStream_SetSize: \
        { \
            hr = HrValidateParametersV(eMethod, rgArg[0],  \
                                       *((ULARGE_INTEGER *) &rgArg[1])); \
            break; \
        } \
 \
        case IStream_CopyTo: \
        { \
            hr = HrValidateParametersV(eMethod, rgArg[0], rgArg[1], \
                                       *((ULARGE_INTEGER *) &rgArg[2]), \
                                       rgArg[4], rgArg[5]); \
            break; \
        } \
 \
        case IStream_LockRegion: \
        { \
            hr = HrValidateParametersV(eMethod, rgArg[0],  \
                                       *((ULARGE_INTEGER *) &rgArg[1]), \
                                       *((ULARGE_INTEGER *) &rgArg[3]), \
                                       rgArg[5]); \
            break; \
        } \
 \
        case IStream_UnlockRegion: \
        { \
            hr = HrValidateParametersV(eMethod, rgArg[0],  \
                                       *((ULARGE_INTEGER *) &rgArg[1]), \
                                       *((ULARGE_INTEGER *) &rgArg[3]), \
                                       rgArg[5]); \
            break; \
        } \
 \
        default: \
 \
            AssertSz(FALSE, \
                    "Custom parameter passing for call being validated NYI"); \
            break; \
    }
#endif // WX86_MAPISTUB

#endif // _INTEL_


#ifdef __cplusplus
}
#endif

#endif // _MSVALIDP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\mapistub\mapistub\profspi.h ===
/*
 *  P R O F S P I . H
 *	
 *	Service provider interface for MAPI Profile Providers.
 *	
 *  Copyright 1986-1996 Microsoft Corporation. All Rights Reserved.
 */

#ifndef PROFSPI_H
#define PROFSPI_H

#ifndef PROFILE_GUIDS_ONLY

#ifndef MAPISPI_H
#include <mapispi.h>
#endif


/* IMAPIProfile Interface -------------------------------------------------- */

#define MAPI_IMAPIPROFILE_METHODS(IPURE)								\
	MAPIMETHOD(OpenSection)												\
		(THIS_	LPMAPIUID					lpUID,						\
				ULONG						ulFlags,					\
				LPPROFSECT FAR *			lppProfSect) IPURE;			\
	MAPIMETHOD(DeleteSection)											\
		(THIS_	LPMAPIUID					lpUID) IPURE;				\

#undef		 INTERFACE
#define		 INTERFACE  IMAPIProfile
DECLARE_MAPI_INTERFACE_(IMAPIProfile, IUnknown)
{
	BEGIN_INTERFACE	
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROFILE_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IMAPIProfile, LPMAPIPROF);

/* IPRProvider Interface Definition ---------------------------------------- */

/* For all methods */

/*#define MAPI_UNICODE			((ULONG) 0x80000000) in mapidefs.h */

/* For OpenProfile */

/* #define MAPI_LOGON_UI           0x00000001  Display logon UI          */
/* #define MAPI_EXPLICIT_PROFILE   0x00000010  Don't use default profile */
/* #define MAPI_USE_DEFAULT        0x00000040  Use default profile       */
/* #define MAPI_SERVICE_UI_ALWAYS  0x00002000  Do logon UI in all providers */
/* #define MAPI_PASSWORD_UI        0x00020000  Display password UI only  */

/* For DeleteProfile */
#define MAPI_DEFER_DELETE		0x00000001


#define MAPI_IPRPROVIDER_METHODS(IPURE)									\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(Shutdown)												\
		(THIS_	ULONG FAR *					lpulFlags) IPURE;			\
	MAPIMETHOD(OpenProfile)												\
		(THIS_	LPMAPISUP					lpMAPISup,					\
				LPTSTR FAR *				lppszProfileName,			\
				LPTSTR						lpszPassword,				\
				ULONG						ulSelectFlags,				\
				ULONG						ulUIParam,					\
				ULONG FAR *					lpulpcbSecurity,			\
				LPBYTE FAR *				lppbSecurity,				\
				ULONG FAR *					lpulSessionFlags,			\
				LPMAPIPROF FAR *			lppMAPIProf) IPURE;			\
	MAPIMETHOD(CreateProfile)											\
		(THIS_	LPTSTR						lpszProfileName,			\
				LPTSTR						lpszPassword,				\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(DeleteProfile)											\
		(THIS_	LPTSTR						lpszProfileName,			\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(ChangeProfilePassword)									\
		(THIS_	LPTSTR						lpszProfileName,			\
				LPTSTR						lpszOldPassword,			\
				LPTSTR						lpszNewPassword,			\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(GetProfileTable)											\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(CopyProfile)												\
		(THIS_	LPTSTR						lpszOldProfileName,			\
				LPTSTR						lpszOldPassword,			\
				LPTSTR						lpszNewProfileName,			\
				ULONG						ulUIParam,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(RenameProfile)											\
		(THIS_	LPTSTR						lpszOldProfileName,			\
				LPTSTR						lpszOldPassword,			\
				LPTSTR						lpszNewProfileName,			\
				ULONG						ulUIParam,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(SetDefaultProfile)										\
		(THIS_	LPTSTR						lpszProfileName,			\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(ListDeferredDeletes)										\
		(THIS_	ULONG ulFlags,											\
				LPTSTR FAR *				lppszDeleted) IPURE;		\


#undef		 INTERFACE
#define		 INTERFACE  IPRProvider
DECLARE_MAPI_INTERFACE_(IPRProvider, IUnknown)
{
	BEGIN_INTERFACE	
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IPRPROVIDER_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IPRProvider, LPPRPROVIDER);

/* Profile Provider Entry Point */

/* #define MAPI_NT_SERVICE	0x00010000	/* Allow logon from an NT service */

typedef HRESULT (STDMAPIINITCALLTYPE PRPROVIDERINIT)(
	HINSTANCE				hInstance,
	LPMALLOC				lpMalloc,			/* AddRef() if you keep it */
	LPALLOCATEBUFFER		lpAllocateBuffer,	/* -> AllocateBuffer */
	LPALLOCATEMORE			lpAllocateMore, 	/* -> AllocateMore   */
	LPFREEBUFFER			lpFreeBuffer, 		/* -> FreeBuffer     */
	ULONG					ulFlags,
	ULONG					ulMAPIVer,
	ULONG FAR *				lpulProviderVer,
	LPPRPROVIDER FAR *		lppPRProvider
);

PRPROVIDERINIT PRProviderInit;
typedef PRPROVIDERINIT FAR *LPPRPROVIDERINIT;

#endif	/* PROFILE_GUIDS_ONLY */

#if !defined(INITGUID) || defined(USES_IID_IPRProvider)
DEFINE_OLEGUID(IID_IPRProvider,			0x000203F6L, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIProfile)
DEFINE_OLEGUID(IID_IMAPIProfile,		0x000203F7L, 0, 0);
#endif

#endif	/* PROFSPI_H */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\mapistub\mapistub\structs.h ===
/*
 *	STRUCTS.H
 *	
 *	Structures defining method parameters for validation sub-system
 */

#ifndef STRUCTS_H
#define STRUCTS_H

#if defined(_MIPS_) || defined(_PPC_) || defined(_ALPHA_) || defined(_MAC)
#define LARGE_INTEGER_ARG		LARGE_INTEGER
#define LARGE_INTEGER_ARG_2		LARGE_INTEGER
#define ULARGE_INTEGER_ARG		ULARGE_INTEGER
#define ULARGE_INTEGER_ARG_2	ULARGE_INTEGER
#else
#define LARGE_INTEGER_ARG		LPVOID	XXXX; LPVOID
#define LARGE_INTEGER_ARG_2		LPVOID	YYYY; LPVOID
#define ULARGE_INTEGER_ARG		LPVOID  XXXX; LPVOID
#define ULARGE_INTEGER_ARG_2	LPVOID  YYYY; LPVOID
#endif

/*
 * These structures represent the parameters for the appropriate functions as they
 * appear on the stack.  
 *
 * The WIN16 stack is laid out differently, and has the parameters in the reverse order.
 *
 * Our __ValidateParameters function decides passes a pointer to the stack at the start of 
 * the parameter list, and the type of the Validation routines parameter determines
 * what values it has to check.  These values do not change between platforms.
 *
 * If parameters to a method change, the structure must be updated to reflect the change.
 *
 * The names of the Typedefs are important as other things are generated based on these
 * names.
 *
 * Notes for WX86_MAPISTUB:
 *
 * The names of the *_Thunk variables are important too. See msvalidp.h for
 * their use. 
 *
 * We thunk only the IN arguments since the validation functions are intended
 * to be called at the start of the function; the output arguments have not 
 * yet been filled in. The validation functions are in msvalid.c; in general
 * they do not validate or refer to This, so we do not thunk it. See 
 * ..\mapistub\mapi32.cpp for details on thunking.
 *
 */

/* Keystroke Macros to convert method in MAPIDEFS.H to structure here 
 *
 * 1. Convert MAPIMETHOD(XXX) to typedef struct _tagXXX_Params (search for ')')
 * 2. For each line, find comma, replace with ; and delete to end of line
 * 3. Start on typedef line, read XXX, search for IPURE, replace preceding )
 *	  with ;, add new line, generate } XXX_params, FAR * LPXXXParams;
 * 4. Change (THIS_ to LPVOID This;, split line
 *
 */
 

/****************** IUnknown *********************/
typedef struct _tagIUnknown_QueryInterface_Params
{
				LPVOID						This;	
				REFIID						iidInterface;
				LPVOID						lppNewObject;
} IUnknown_QueryInterface_Params, FAR * LPIUnknown_QueryInterface_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IUnknown_QueryInterface_Thunk = NULL;

#endif

typedef struct _tagIUnknown_AddRef_Params
{
				LPVOID						This;	
} IUnknown_AddRef_Params, FAR * LPIUnknown_AddRef_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IUnknown_AddRef_Thunk = NULL;

#endif

typedef struct _tagIUnknown_Release_Params
{
				LPVOID						This;	
} IUnknown_Release_Params, FAR * LPIUnknown_Release_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IUnknown_Release_Thunk = NULL;

#endif


/* AddRef and Release take no parameters */ 
 
/***************** IMAPIProp *********************/

typedef struct _tagIMAPIProp_GetLastError_Params
{
				LPVOID						This;	
				HRESULT						hResult;
				ULONG						ulFlags;
				LPMAPIERROR FAR *			lppMAPIError;
} IMAPIProp_GetLastError_Params, FAR * LPIMAPIProp_GetLastError_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIProp_GetLastError_Thunk = NULL;

#endif

typedef struct _tagIMAPIProp_SaveChanges_Params
{
				LPVOID						This; 
				ULONG						ulFlags;
} IMAPIProp_SaveChanges_Params, FAR * LPIMAPIProp_SaveChanges_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIProp_SaveChanges_Thunk = NULL;

#endif


/* GetProps --------------------------------------------------------- */
typedef struct _tagIMAPIProp_GetProps_Params
{
	LPVOID				This;
	LPSPropTagArray		lpPropTagArray;
	ULONG				ulFlags;
	ULONG FAR *			lpcValues;
	LPSPropValue FAR *	lppPropArray;
} IMAPIProp_GetProps_Params, FAR * LPIMAPIProp_GetProps_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIProp_GetProps_Thunk = NULL;

#endif


typedef struct _tagIMAPIProp_GetPropList_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPSPropTagArray FAR *		lppPropTagArray;
} IMAPIProp_GetPropList_Params, FAR * LPIMAPIProp_GetPropList_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIProp_GetPropList_Thunk = NULL;

#endif
				
typedef struct _tagIMAPIProp_OpenProperty_Params
{
				LPVOID						This;	
				ULONG						ulPropTag;
				LPIID						lpiid;
				ULONG						ulInterfaceOptions;
				ULONG						ulFlags;
				LPUNKNOWN FAR *				lppUnk;
} IMAPIProp_OpenProperty_Params, FAR * LPIMAPIProp_OpenProperty_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIProp_OpenProperty_Thunk = NULL;

#endif

/* SetProps --------------------------------------------------------- */
typedef struct _tagIMAPIProp_SetProps_Params
{
	LPVOID				This;
	ULONG				cValues;
	LPSPropValue 		lpPropArray;
	LPSPropProblemArray FAR *	lppProblems;
} IMAPIProp_SetProps_Params, FAR * LPIMAPIProp_SetProps_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIProp_SetProps_Thunk = NULL;

#endif


typedef struct _tagIMAPIProp_DeleteProps_Params
{
				LPVOID						This;	
				LPSPropTagArray				lpPropTagArray;
				LPSPropProblemArray FAR *	lppProblems;
} IMAPIProp_DeleteProps_Params, FAR * LPIMAPIProp_DeleteProps_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIProp_DeleteProps_Thunk = NULL;

#endif
				
typedef struct _tagIMAPIProp_CopyTo_Params
{
				LPVOID						This;	
				ULONG						ciidExclude;
				LPIID						rgiidExclude;
				LPSPropTagArray				lpExcludeProps;
				ULONG						ulUIParam;
				LPMAPIPROGRESS 				lpProgress;
				LPIID						lpInterface;
				LPVOID						lpDestObj;
				ULONG						ulFlags;
				LPSPropProblemArray FAR *	lppProblems;
} IMAPIProp_CopyTo_Params, FAR * LPIMAPIProp_CopyTo_Params;

#if defined (WX86_MAPISTUB)

// @@@@ lpDestObj is an IN interface pointer?

Wx86MapiArgThunkInfo IMAPIProp_CopyTo_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 5, 0, &IID_IMAPIProgress},
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 7, 6, NULL},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IMAPIProp_CopyTo_Thunk = IMAPIProp_CopyTo_ThunkArgs;

#endif
				
typedef struct _tagIMAPIProp_CopyProps_Params
{
				LPVOID						This;	
				LPSPropTagArray				lpIncludeProps;
				ULONG						ulUIParam;
				LPMAPIPROGRESS 				lpProgress;
				LPIID						lpInterface;
				LPVOID						lpDestObj;
				ULONG						ulFlags;
				LPSPropProblemArray FAR *	lppProblems;
} IMAPIProp_CopyProps_Params, FAR * LPIMAPIProp_CopyProps_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IMAPIProp_CopyProps_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 3, 0, &IID_IMAPIProgress},
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 5, 4, NULL},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IMAPIProp_CopyProps_Thunk = IMAPIProp_CopyProps_ThunkArgs;

#endif
				
typedef struct _tagIMAPIProp_GetNamesFromIDs_Params
{
				LPVOID						This;	
				LPSPropTagArray FAR *		lppPropTags;
				LPGUID						lpPropSetGuid;
				ULONG						ulFlags;
				ULONG FAR *					lpcPropNames;
				LPMAPINAMEID FAR * FAR *	lpppPropNames;
} IMAPIProp_GetNamesFromIDs_Params, FAR * LPIMAPIProp_GetNamesFromIDs_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIProp_GetNamesFromIDs_Thunk = NULL;

#endif
				
typedef struct _tagIMAPIProp_GetIDsFromNames_Params
{
				LPVOID						This;	
				ULONG						cPropNames;
				LPMAPINAMEID FAR *			lppPropNames;
				ULONG						ulFlags;
				LPSPropTagArray FAR *		lppPropTags;
} IMAPIProp_GetIDsFromNames_Params, FAR * LPIMAPIProp_GetIDsFromNames_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIProp_GetIDsFromNames_Thunk = NULL;

#endif


/********************* IMAPITable **************************************/

typedef struct _tagIMAPITable_GetLastError_Params
{
				LPVOID						This;	
				HRESULT						hResult;
				ULONG						ulFlags;
				LPMAPIERROR FAR *			lppMAPIError;
} IMAPITable_GetLastError_Params, FAR * LPIMAPITable_GetLastError_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_GetLastError_Thunk = NULL;

#endif

typedef struct _tagIMAPITable_Advise_Params
{
				LPVOID						This;	
				ULONG						ulEventMask;
				LPMAPIADVISESINK			lpAdviseSink;
				ULONG FAR *					lpulConnection;
} IMAPITable_Advise_Params, FAR * LPIMAPITable_Advise_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IMAPITable_Advise_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 2, 0, &IID_IMAPIAdviseSink},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IMAPITable_Advise_Thunk = IMAPITable_Advise_ThunkArgs;

#endif


typedef struct _tagIMAPITable_Unadvise_Params
{
				LPVOID						This;	
				ULONG						ulConnection;
} IMAPITable_Unadvise_Params, FAR * LPIMAPITable_Unadvise_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_Unadvise_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_GetStatus_Params
{
				LPVOID						This;	
				ULONG FAR *					lpulTableStatus;
				ULONG FAR *					lpulTableType;
} IMAPITable_GetStatus_Params, FAR * LPIMAPITable_GetStatus_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_GetStatus_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_SetColumns_Params
{
				LPVOID						This;	
				LPSPropTagArray				lpPropTagArray;
				ULONG						ulFlags;
} IMAPITable_SetColumns_Params, FAR * LPIMAPITable_SetColumns_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_SetColumns_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_QueryColumns_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPSPropTagArray FAR *		lpPropTagArray;
} IMAPITable_QueryColumns_Params, FAR * LPIMAPITable_QueryColumns_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_QueryColumns_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_GetRowCount_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				ULONG FAR *					lpulCount;
} IMAPITable_GetRowCount_Params, FAR * LPIMAPITable_GetRowCount_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_GetRowCount_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_SeekRow_Params
{
				LPVOID						This;	
				BOOKMARK					bkOrigin;
				LONG						lRowCount;
				LONG FAR *					lplRowsSought;
} IMAPITable_SeekRow_Params, FAR * LPIMAPITable_SeekRow_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_SeekRow_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_SeekRowApprox_Params
{
				LPVOID						This;	
				ULONG						ulNumerator;
				ULONG						ulDenominator;
} IMAPITable_SeekRowApprox_Params, FAR * LPIMAPITable_SeekRowApprox_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_SeekRowApprox_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_QueryPosition_Params
{
				LPVOID						This;	
				ULONG FAR *					lpulRow;
				ULONG FAR *					lpulNumerator;
				ULONG FAR *					lpulDenominator;
} IMAPITable_QueryPosition_Params, FAR * LPIMAPITable_QueryPosition_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_QueryPosition_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_FindRow_Params
{
				LPVOID						This;	
				LPSRestriction				lpRestriction;
				BOOKMARK					bkOrigin;
				ULONG						ulFlags;
} IMAPITable_FindRow_Params, FAR * LPIMAPITable_FindRow_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_FindRow_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_Restrict_Params
{
				LPVOID						This;	
				LPSRestriction				lpRestriction;
				ULONG						ulFlags;
} IMAPITable_Restrict_Params, FAR * LPIMAPITable_Restrict_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_Restrict_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_CreateBookmark_Params
{
				LPVOID						This;	
				BOOKMARK FAR *				lpbkPosition;
} IMAPITable_CreateBookmark_Params, FAR * LPIMAPITable_CreateBookmark_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_CreateBookmark_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_FreeBookmark_Params
{
				LPVOID						This;	
				BOOKMARK					bkPosition;
} IMAPITable_FreeBookmark_Params, FAR * LPIMAPITable_FreeBookmark_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_FreeBookmark_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_SortTable_Params
{
				LPVOID						This;	
				LPSSortOrderSet				lpSortCriteria;
				ULONG						ulFlags;
} IMAPITable_SortTable_Params, FAR * LPIMAPITable_SortTable_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_SortTable_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_QuerySortOrder_Params
{
				LPVOID						This;	
				LPSSortOrderSet FAR *		lppSortCriteria;
} IMAPITable_QuerySortOrder_Params, FAR * LPIMAPITable_QuerySortOrder_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_QuerySortOrder_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_QueryRows_Params
{
				LPVOID						This;	
				LONG						lRowCount;
				ULONG						ulFlags;
				LPSRowSet FAR *				lppRows;
} IMAPITable_QueryRows_Params, FAR * LPIMAPITable_QueryRows_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_QueryRows_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_Abort_Params
{
				LPVOID						This;
} IMAPITable_Abort_Params, FAR * LPIMAPITable_Abort_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_Abort_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_ExpandRow_Params
{
				LPVOID						This;	
				ULONG						cbInstanceKey;
				LPBYTE						pbInstanceKey;
				ULONG						ulRowCount;
				ULONG						ulFlags;
				LPSRowSet FAR *				lppRows;
				ULONG FAR *					lpulMoreRows;
} IMAPITable_ExpandRow_Params, FAR * LPIMAPITable_ExpandRow_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_ExpandRow_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_CollapseRow_Params
{
				LPVOID						This;	
				ULONG						cbInstanceKey;
				LPBYTE						pbInstanceKey;
				ULONG						ulFlags;
				ULONG FAR *					lpulRowCount;
} IMAPITable_CollapseRow_Params, FAR * LPIMAPITable_CollapseRow_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_CollapseRow_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_WaitForCompletion_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				ULONG						ulTimeout;
				ULONG FAR *					lpulTableStatus;
} IMAPITable_WaitForCompletion_Params, FAR * LPIMAPITable_WaitForCompletion_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_WaitForCompletion_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_GetCollapseState_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				ULONG						cbInstanceKey;
				LPBYTE						lpbInstanceKey;
				ULONG FAR *					lpcbCollapseState;
				LPBYTE FAR *				lppbCollapseState;
} IMAPITable_GetCollapseState_Params, FAR * LPIMAPITable_GetCollapseState_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_GetCollapseState_Thunk = NULL;

#endif
				
typedef struct _tagIMAPITable_SetCollapseState_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				ULONG						cbCollapseState;
				LPBYTE						pbCollapseState;
				BOOKMARK FAR *				lpbkLocation;
} IMAPITable_SetCollapseState_Params, FAR * LPIMAPITable_SetCollapseState_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_SetCollapseState_Thunk = NULL;

#endif



/********************* IMAPIStatus *************************************/

typedef struct _tagIMAPIStatus_ValidateState_Params
{
				LPVOID						This;
				ULONG						ulUIParam;
				ULONG						ulFlags;
} IMAPIStatus_ValidateState_Params, FAR * LPIMAPIStatus_ValidateState_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIStatus_ValidateState_Thunk = NULL;

#endif
				
typedef struct _tagIMAPIStatus_SettingsDialog_Params
{
				LPVOID						This;
				ULONG						ulUIParam;
				ULONG						ulFlags;
} IMAPIStatus_SettingsDialog_Params, FAR * LPIMAPIStatus_SettingsDialog_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIStatus_SettingsDialog_Thunk = NULL;

#endif
				
typedef struct _tagIMAPIStatus_ChangePassword_Params
{
				LPVOID						This;
				LPTSTR						lpOldPass;
				LPTSTR						lpNewPass;
				ULONG						ulFlags;
} IMAPIStatus_ChangePassword_Params, FAR * LPIMAPIStatus_ChangePassword_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIStatus_ChangePassword_Thunk = NULL;

#endif
				
typedef struct _tagIMAPIStatus_FlushQueues_Params
{
				LPVOID						This;
				ULONG						ulUIParam;
				ULONG						cbTargetTransport;
				LPENTRYID					lpTargetTransport;
				ULONG						ulFlags;
} IMAPIStatus_FlushQueues_Params, FAR * LPIMAPIStatus_FlushQueues_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIStatus_FlushQueues_Thunk = NULL;

#endif


/******************** IMAPIContainer ***********************************/


typedef struct _tagIMAPIContainer_GetContentsTable_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPMAPITABLE FAR *			lppTable;
} IMAPIContainer_GetContentsTable_Params, FAR * LPIMAPIContainer_GetContentsTable_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIContainer_GetContentsTable_Thunk = NULL;

#endif


typedef struct _tagIMAPIContainer_GetHierarchyTable_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPMAPITABLE FAR *			lppTable;
} IMAPIContainer_GetHierarchyTable_Params, FAR * LPIMAPIContainer_GetHierarchyTable_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIContainer_GetHierarchyTable_Thunk = NULL;

#endif


typedef struct _tagIMAPIContainer_OpenEntry_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				LPIID						lpInterface;
				ULONG						ulFlags;
				ULONG FAR *					lpulObjType;
				LPUNKNOWN FAR *				lppUnk;
} IMAPIContainer_OpenEntry_Params, FAR * LPIMAPIContainer_OpenEntry_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIContainer_OpenEntry_Thunk = NULL;

#endif


typedef struct _tagIMAPIContainer_SetSearchCriteria_Params
{
				LPVOID						This;	
				LPSRestriction				lpRestriction;
				LPENTRYLIST					lpContainerList;
				ULONG						ulSearchFlags;
} IMAPIContainer_SetSearchCriteria_Params, FAR * LPIMAPIContainer_SetSearchCriteria_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIContainer_SetSearchCriteria_Thunk = NULL;

#endif


typedef struct _tagIMAPIContainer_GetSearchCriteria_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPSRestriction FAR *		lppRestriction;
				LPENTRYLIST FAR *			lppContainerList;
				ULONG FAR *					lpulSearchState;
} IMAPIContainer_GetSearchCriteria_Params, FAR * LPIMAPIContainer_GetSearchCriteria_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIContainer_GetSearchCriteria_Thunk = NULL;

#endif



/****************************** IABContainer *****************************/


typedef struct _tagIABContainer_CreateEntry_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulFlags;
				LPMAPIPROP FAR	*			lppMAPIPropEntry;
} IABContainer_CreateEntry_Params, FAR * LPIABContainer_CreateEntry_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IABContainer_CreateEntry_Thunk = NULL;

#endif


typedef struct _tagIABContainer_CopyEntries_Params
{
				LPVOID						This;	
				LPENTRYLIST					lpEntries;
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IABContainer_CopyEntries_Params, FAR * LPIABContainer_CopyEntries_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IABContainer_CopyEntries_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 3, 0, &IID_IMAPIProgress},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IABContainer_CopyEntries_Thunk = IABContainer_CopyEntries_ThunkArgs;

#endif


typedef struct _tagIABContainer_DeleteEntries_Params
{
				LPVOID						This;	
				LPENTRYLIST					lpEntries;
				ULONG						ulFlags;
} IABContainer_DeleteEntries_Params, FAR * LPIABContainer_DeleteEntries_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IABContainer_DeleteEntries_Thunk = NULL;

#endif

typedef struct _tagIABContainer_ResolveNames_Params
{
				LPVOID						This;
				LPSPropTagArray				lpPropTagArray;
				ULONG						ulFlags;
				LPADRLIST					lpMods;
				LPFlagList					lpFlagList;
} IABContainer_ResolveNames_Params, FAR * LPIABContainer_ResolveNames_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IABContainer_ResolveNames_Thunk = NULL;

#endif

/*************************** IDistList ***********************************/


typedef struct _tagIDistList_CreateEntry_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulCreateFlags;
				LPMAPIPROP FAR	*			lppMAPIPropEntry;
} IDistList_CreateEntry_Params, FAR * LPIDistList_CreateEntry_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IDistList_CreateEntry_Thunk = NULL;

#endif


typedef struct _tagIDistList_CopyEntries_Params
{
				LPVOID						This;	
				LPENTRYLIST					lpEntries;
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IDistList_CopyEntries_Params, FAR * LPIDistList_CopyEntries_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IDistList_CopyEntries_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 3, 0, &IID_IMAPIProgress},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IDistList_CopyEntries_Thunk = IDistList_CopyEntries_ThunkArgs;

#endif


typedef struct _tagIDistList_DeleteEntries_Params
{
				LPVOID						This;	
				LPENTRYLIST					lpEntries;
				ULONG						ulFlags;
} IDistList_DeleteEntries_Params, FAR * LPIDistList_DeleteEntries_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IDistList_DeleteEntries_Thunk = NULL;

#endif

typedef struct _tagIDistList_ResolveNames_Params
{
				LPVOID						This;
				LPSPropTagArray				lpPropTagArray;
				ULONG						ulFlags;
				LPADRLIST					lpMods;
				LPFlagList					lpFlagList;
} IDistList_ResolveNames_Params, FAR * LPIDistList_ResolveNames_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IDistList_ResolveNames_Thunk = NULL;

#endif

/**************************** IMAPIFolder *******************************/

typedef struct _tagIMAPIFolder_CreateMessage_Params
{
				LPVOID						This;	
				LPIID						lpInterface;
				ULONG						ulFlags;
				LPMESSAGE FAR *				lppMessage;
} IMAPIFolder_CreateMessage_Params, FAR * LPIMAPIFolder_CreateMessage_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIFolder_CreateMessage_Thunk = NULL;

#endif


typedef struct _tagIMAPIFolder_CopyMessages_Params
{
				LPVOID						This;	
				LPENTRYLIST					lpMsgList;
			   	LPIID						lpInterface;
				LPVOID						lpDestFolder;
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IMAPIFolder_CopyMessages_Params, FAR * LPIMAPIFolder_CopyMessages_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IMAPIFolder_CopyMessages_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 3, 2, &IID_IMAPIFolder},
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 5, 0, &IID_IMAPIProgress},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IMAPIFolder_CopyMessages_Thunk = IMAPIFolder_CopyMessages_ThunkArgs;

#endif


typedef struct _tagIMAPIFolder_DeleteMessages_Params
{
				LPVOID						This;	
				LPENTRYLIST					lpMsgList;
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IMAPIFolder_DeleteMessages_Params, FAR * LPIMAPIFolder_DeleteMessages_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IMAPIFolder_DeleteMessages_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 3, 0, &IID_IMAPIProgress},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IMAPIFolder_DeleteMessages_Thunk = IMAPIFolder_DeleteMessages_ThunkArgs;

#endif


typedef struct _tagIMAPIFolder_CreateFolder_Params
{
				LPVOID						This;	
				ULONG						ulFolderType;
				LPTSTR						lpszFolderName;
				LPTSTR						lpszFolderComment;
				LPIID						lpInterface;
				ULONG						ulFlags;
				LPMAPIFOLDER FAR *			lppFolder;
} IMAPIFolder_CreateFolder_Params, FAR * LPIMAPIFolder_CreateFolder_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIFolder_CreateFolder_Thunk = NULL;

#endif


typedef struct _tagIMAPIFolder_CopyFolder_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
			   	LPIID						lpInterface;
				LPVOID						lpDestFolder;
				LPTSTR						lpszNewFolderName;
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IMAPIFolder_CopyFolder_Params, FAR * LPIMAPIFolder_CopyFolder_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IMAPIFolder_CopyFolder_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 4, 3, &IID_IMAPIFolder},
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 7, 0, &IID_IMAPIProgress},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IMAPIFolder_CopyFolder_Thunk = IMAPIFolder_CopyFolder_ThunkArgs;

#endif


typedef struct _tagIMAPIFolder_DeleteFolder_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IMAPIFolder_DeleteFolder_Params, FAR * LPIMAPIFolder_DeleteFolder_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IMAPIFolder_DeleteFolder_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 4, 0, &IID_IMAPIProgress},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IMAPIFolder_DeleteFolder_Thunk = IMAPIFolder_DeleteFolder_ThunkArgs;

#endif


typedef struct _tagIMAPIFolder_SetReadFlags_Params
{
				LPVOID						This;	
				LPENTRYLIST					lpMsgList;
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IMAPIFolder_SetReadFlags_Params, FAR * LPIMAPIFolder_SetReadFlags_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IMAPIFolder_SetReadFlags_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 3, 0, &IID_IMAPIProgress},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IMAPIFolder_SetReadFlags_Thunk = IMAPIFolder_SetReadFlags_ThunkArgs;

#endif


typedef struct _tagIMAPIFolder_GetMessageStatus_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulFlags;
				ULONG FAR *					lpulMessageStatus;
} IMAPIFolder_GetMessageStatus_Params, FAR * LPIMAPIFolder_GetMessageStatus_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIFolder_GetMessageStatus_Thunk = NULL;

#endif


typedef struct _tagIMAPIFolder_SetMessageStatus_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulNewStatus;
				ULONG						ulNewStatusMask;
				ULONG FAR *					lpulOldStatus;
} IMAPIFolder_SetMessageStatus_Params, FAR * LPIMAPIFolder_SetMessageStatus_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIFolder_SetMessageStatus_Thunk = NULL;

#endif


typedef struct _tagIMAPIFolder_SaveContentsSort_Params
{
				LPVOID						This;	
				LPSSortOrderSet				lpSortCriteria;
				ULONG						ulFlags;
} IMAPIFolder_SaveContentsSort_Params, FAR * LPIMAPIFolder_SaveContentsSort_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIFolder_SaveContentsSort_Thunk = NULL;

#endif


typedef struct _tagIMAPIFolder_EmptyFolder_Params
{
				LPVOID						This;	
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IMAPIFolder_EmptyFolder_Params, FAR * LPIMAPIFolder_EmptyFolder_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IMAPIFolder_EmptyFolder_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 2, 0, &IID_IMAPIProgress},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IMAPIFolder_EmptyFolder_Thunk = IMAPIFolder_EmptyFolder_ThunkArgs;

#endif



/**************************** IMsgStore **********************************/

typedef struct _tagIMsgStore_Advise_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulEventMask;
				LPMAPIADVISESINK			lpAdviseSink;
				ULONG FAR *					lpulConnection;
} IMsgStore_Advise_Params, FAR * LPIMsgStore_Advise_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IMsgStore_Advise_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 4, 0, &IID_IMAPIAdviseSink},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IMsgStore_Advise_Thunk = IMsgStore_Advise_ThunkArgs;

#endif


typedef struct _tagIMsgStore_Unadvise_Params
{
				LPVOID						This;	
				ULONG						ulConnection;
} IMsgStore_Unadvise_Params, FAR * LPIMsgStore_Unadvise_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMsgStore_Unadvise_Thunk = NULL;

#endif


typedef struct _tagIMsgStore_CompareEntryIDs_Params
{
				LPVOID						This;	
				ULONG						cbEntryID1;
				LPENTRYID					lpEntryID1;
				ULONG						cbEntryID2;
				LPENTRYID					lpEntryID2;
				ULONG						ulFlags;
				ULONG FAR *					lpulResult;
} IMsgStore_CompareEntryIDs_Params, FAR * LPIMsgStore_CompareEntryIDs_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMsgStore_CompareEntryIDs_Thunk = NULL;

#endif

typedef struct _tagIMsgStore_OpenEntry_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				LPIID						lpInterface;
				ULONG						ulFlags;
				ULONG FAR *					lpulObjType;
				LPUNKNOWN FAR *				lppUnk;
} IMsgStore_OpenEntry_Params, FAR * LPIMsgStore_OpenEntry_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMsgStore_OpenEntry_Thunk = NULL;

#endif



typedef struct _tagIMsgStore_SetReceiveFolder_Params
{
				LPVOID						This;	
				LPTSTR						lpszMessageClass;
				ULONG						ulFlags;
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
} IMsgStore_SetReceiveFolder_Params, FAR * LPIMsgStore_SetReceiveFolder_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMsgStore_SetReceiveFolder_Thunk = NULL;

#endif


typedef struct _tagIMsgStore_GetReceiveFolder_Params
{
				LPVOID						This;	
				LPTSTR						lpszMessageClass;
				ULONG						ulFlags;
				ULONG FAR *					lpcbEntryID;
				LPENTRYID FAR *				lppEntryID;
				LPTSTR FAR *				lppszExplicitClass;
} IMsgStore_GetReceiveFolder_Params, FAR * LPIMsgStore_GetReceiveFolder_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMsgStore_GetReceiveFolder_Thunk = NULL;

#endif


typedef struct _tagIMsgStore_GetReceiveFolderTable_Params
{
				LPVOID						This;
				ULONG						ulFlags;
				LPMAPITABLE FAR *			lppTable;
} IMsgStore_GetReceiveFolderTable_Params, FAR * LPIMsgStore_GetReceiveFolderTable_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMsgStore_GetReceiveFolderTable_Thunk = NULL;

#endif


typedef struct _tagIMsgStore_StoreLogoff_Params
{
				LPVOID						This;	
				ULONG FAR *					lpulFlags;
} IMsgStore_StoreLogoff_Params, FAR * LPIMsgStore_StoreLogoff_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMsgStore_StoreLogoff_Thunk = NULL;

#endif


typedef struct _tagIMsgStore_AbortSubmit_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulFlags;
} IMsgStore_AbortSubmit_Params, FAR * LPIMsgStore_AbortSubmit_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMsgStore_AbortSubmit_Thunk = NULL;

#endif


typedef struct _tagIMsgStore_GetOutgoingQueue_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPMAPITABLE FAR *			lppTable;
} IMsgStore_GetOutgoingQueue_Params, FAR * LPIMsgStore_GetOutgoingQueue_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMsgStore_GetOutgoingQueue_Thunk = NULL;

#endif


typedef struct _tagIMsgStore_SetLockState_Params
{
				LPVOID						This;	
				LPMESSAGE					lpMessage;
				ULONG						ulLockState;
} IMsgStore_SetLockState_Params, FAR * LPIMsgStore_SetLockState_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IMsgStore_SetLockState_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 1, 0, &IID_IMessage},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IMsgStore_SetLockState_Thunk = IMsgStore_SetLockState_ThunkArgs;

#endif


typedef struct _tagIMsgStore_FinishedMsg_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
} IMsgStore_FinishedMsg_Params, FAR * LPIMsgStore_FinishedMsg_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMsgStore_FinishedMsg_Thunk = NULL;

#endif


typedef struct _tagIMsgStore_NotifyNewMail_Params
{
				LPVOID						This;	
				LPNOTIFICATION				lpNotification;
} IMsgStore_NotifyNewMail_Params, FAR * LPIMsgStore_NotifyNewMail_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMsgStore_NotifyNewMail_Thunk = NULL;

#endif



/*************************** IMessage ***********************************/

typedef struct _tagIMessage_GetAttachmentTable_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPMAPITABLE FAR *			lppTable;
} IMessage_GetAttachmentTable_Params, FAR * LPIMessage_GetAttachmentTable_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMessage_GetAttachmentTable_Thunk = NULL;

#endif


typedef struct _tagIMessage_OpenAttach_Params
{
				LPVOID						This;	
				ULONG						ulAttachmentNum;
				LPIID						lpInterface;
				ULONG						ulFlags;
				LPATTACH FAR *				lppAttach;
} IMessage_OpenAttach_Params, FAR * LPIMessage_OpenAttach_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMessage_OpenAttach_Thunk = NULL;

#endif


typedef struct _tagIMessage_CreateAttach_Params
{
				LPVOID						This;	
				LPIID						lpInterface;
				ULONG						ulFlags;
				ULONG FAR *					lpulAttachmentNum;
				LPATTACH FAR *				lppAttach;
} IMessage_CreateAttach_Params, FAR * LPIMessage_CreateAttach_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMessage_CreateAttach_Thunk = NULL;

#endif


typedef struct _tagIMessage_DeleteAttach_Params
{
				LPVOID						This;	
				ULONG						ulAttachmentNum;
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IMessage_DeleteAttach_Params, FAR * LPIMessage_DeleteAttach_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IMessage_DeleteAttach_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 3, 0, &IID_IMAPIProgress},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IMessage_DeleteAttach_Thunk = IMessage_DeleteAttach_ThunkArgs;

#endif


typedef struct _tagIMessage_GetRecipientTable_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPMAPITABLE FAR *			lppTable;
} IMessage_GetRecipientTable_Params, FAR * LPIMessage_GetRecipientTable_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMessage_GetRecipientTable_Thunk = NULL;

#endif


typedef struct _tagIMessage_ModifyRecipients_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPADRLIST					lpMods;
} IMessage_ModifyRecipients_Params, FAR * LPIMessage_ModifyRecipients_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMessage_ModifyRecipients_Thunk = NULL;

#endif


typedef struct _tagIMessage_SubmitMessage_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
} IMessage_SubmitMessage_Params, FAR * LPIMessage_SubmitMessage_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMessage_SubmitMessage_Thunk = NULL;

#endif


typedef struct _tagIMessage_SetReadFlag_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
} IMessage_SetReadFlag_Params, FAR * LPIMessage_SetReadFlag_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMessage_SetReadFlag_Thunk = NULL;

#endif


/************************ IABProvider ***********************************/

typedef struct _tagIABProvider_Shutdown_Params
{
				LPVOID						This;
				ULONG FAR *					lpulFlags;
} IABProvider_Shutdown_Params, FAR * LPIABProvider_Shutdown_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IABProvider_Shutdown_Thunk = NULL;

#endif

typedef struct _tagIABProvider_Logon_Params
{
        		LPVOID						This;
        		LPMAPISUP                   lpMAPISup;
                ULONG                       ulUIParam;
                LPTSTR                      lpszProfileName;
                ULONG                       ulFlags;
				ULONG FAR *					lpulpcbSecurity;
				LPBYTE FAR *				lppbSecurity;
                LPMAPIERROR FAR *			lppMapiError;
                LPABLOGON FAR *             lppABLogon;
} IABProvider_Logon_Params, FAR * LPIABProvider_Logon_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IABProvider_Logon_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 1, 0, &IID_IMAPISup},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IABProvider_Logon_Thunk = IABProvider_Logon_ThunkArgs;

#endif


/************************* IABLogon *************************************/

typedef struct _tagIABLogon_GetLastError_Params
{
				LPVOID						This;
				HRESULT						hResult;
				ULONG						ulFlags;
				LPMAPIERROR FAR *			lppMAPIError;
} IABLogon_GetLastError_Params, FAR * LPIABLogon_GetLastError_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IABLogon_GetLastError_Thunk = NULL;

#endif

typedef struct _tagIABLogon_Logoff_Params
{
				LPVOID						This;
				ULONG						ulFlags;
} IABLogon_Logoff_Params, FAR * LPIABLogon_Logoff_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IABLogon_Logoff_Thunk = NULL;

#endif

typedef struct _tagIABLogon_OpenEntry_Params
{
        		LPVOID						This;
        		ULONG                       cbEntryID;
                LPENTRYID                   lpEntryID;
                LPIID                       lpInterface;
                ULONG                       ulFlags;
                ULONG FAR *                 lpulObjType;
				LPUNKNOWN FAR *				lppUnk;
} IABLogon_OpenEntry_Params, FAR * LPIABLogon_OpenEntry_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IABLogon_OpenEntry_Thunk = NULL;

#endif

typedef struct _tagIABLogon_CompareEntryIDs_Params
{
        		LPVOID						This;
        		ULONG                       cbEntryID1;
                LPENTRYID                   lpEntryID1;
                ULONG                       cbEntryID2;
                LPENTRYID                   lpEntryID2;
                ULONG                       ulFlags;
                ULONG FAR *                 lpulResult;
} IABLogon_CompareEntryIDs_Params, FAR * LPIABLogon_CompareEntryIDs_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IABLogon_CompareEntryIDs_Thunk = NULL;

#endif

typedef struct _tagIABLogon_Advise_Params
{
        		LPVOID						This;
        		ULONG                       cbEntryID;
                LPENTRYID                   lpEntryID;
                ULONG                       ulEventMask;
				LPMAPIADVISESINK			lpAdviseSink;
				ULONG FAR *					lpulConnection;
} IABLogon_Advise_Params, FAR * LPIABLogon_Advise_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IABLogon_Advise_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 4, 0, &IID_IMAPIAdviseSink},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IABLogon_Advise_Thunk = IABLogon_Advise_ThunkArgs;

#endif

typedef struct _tagIABLogon_Unadvise_Params
{
				LPVOID						This;
				ULONG						ulConnection;
} IABLogon_Unadvise_Params, FAR * LPIABLogon_Unadvise_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IABLogon_Unadvise_Thunk = NULL;

#endif


typedef struct _tagIABLogon_OpenStatusEntry_Params
{
        		LPVOID						This;
        		LPIID                       lpInterface;
                ULONG                       ulFlags;
                ULONG FAR *                 lpulObjType;
                LPMAPISTATUS FAR *          lppEntry;
} IABLogon_OpenStatusEntry_Params, FAR * LPIABLogon_OpenStatusEntry_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IABLogon_OpenStatusEntry_Thunk = NULL;

#endif

typedef struct _tagIABLogon_OpenTemplateID_Params
{
        		LPVOID						This;
        		ULONG                       cbTemplateID;
                LPENTRYID                   lpTemplateID;
                ULONG                       ulTemplateFlags;
                LPMAPIPROP                  lpMAPIPropData;
                LPIID                       lpInterface;
                LPMAPIPROP FAR *            lppMAPIPropNew;
                LPMAPIPROP                  lpMAPIPropSibling;
} IABLogon_OpenTemplateID_Params, FAR * LPIABLogon_OpenTemplateID_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IABLogon_OpenTemplateID_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 4, 0, &IID_IMAPIProp},
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 7, 0, &IID_IMAPIProp},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IABLogon_OpenTemplateID_Thunk = IABLogon_OpenTemplateID_ThunkArgs;

#endif

typedef struct _tagIABLogon_GetOneOffTable_Params
{
        		LPVOID						This;
				ULONG						ulFlags;
        		LPMAPITABLE FAR *           lppTable;
} IABLogon_GetOneOffTable_Params, FAR * LPIABLogon_GetOneOffTable_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IABLogon_GetOneOffTable_Thunk = NULL;

#endif

typedef struct _tagIABLogon_PrepareRecips_Params
{
				LPVOID						This;
				ULONG						ulFlags;
				LPSPropTagArray				lpPropTagArray;
				LPADRLIST					lpRecipList;
} IABLogon_PrepareRecips_Params, FAR * LPIABLogon_PrepareRecips_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IABLogon_PrepareRecips_Thunk = NULL;

#endif


/*********************** IXPProvider ************************************/

typedef struct _tagIXPProvider_Shutdown_Params
{
				LPVOID						This;
				ULONG FAR *					lpulFlags;
} IXPProvider_Shutdown_Params, FAR * LPIXPProvider_Shutdown_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IXPProvider_Shutdown_Thunk = NULL;

#endif

typedef struct _tagIXPProvider_TransportLogon_Params
{
				LPVOID						This;
				LPMAPISUP					lpMAPISup;
				ULONG						ulUIParam;
				LPTSTR						lpszProfileName;
				ULONG FAR *					lpulFlags;
                LPMAPIERROR FAR *			lppMapiError;
				LPXPLOGON FAR *				lppXPLogon;
} IXPProvider_TransportLogon_Params, FAR * LPIXPProvider_TransportLogon_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IXPProvider_TransportLogon_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 1, 0, &IID_IMAPISup},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IXPProvider_TransportLogon_Thunk = IXPProvider_TransportLogon_ThunkArgs;

#endif


/************************ IXPLogon **************************************/

typedef struct _tagIXPLogon_AddressTypes_Params
{
				LPVOID						This;
				ULONG FAR *					lpulFlags;
				ULONG FAR *					lpcAdrType;
				LPTSTR FAR * FAR *			lpppAdrTypeArray;
				ULONG FAR *					lpcMAPIUID;
				LPMAPIUID FAR * FAR *		lpppUIDArray;
} IXPLogon_AddressTypes_Params, FAR * LPIXPLogon_AddressTypes_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IXPLogon_AddressTypes_Thunk = NULL;

#endif

typedef struct _tagIXPLogon_RegisterOptions_Params
{
				LPVOID						This;
				ULONG FAR *					lpulFlags;
				ULONG FAR *					lpcOptions;
				LPOPTIONDATA FAR *			lppOptions;
} IXPLogon_RegisterOptions_Params, FAR * LPIXPLogon_RegisterOptions_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IXPLogon_RegisterOptions_Thunk = NULL;

#endif

typedef struct _tagIXPLogon_TransportNotify_Params
{
				LPVOID						This;
				ULONG FAR *					lpulFlags;
				LPVOID FAR *				lppvData;
} IXPLogon_TransportNotify_Params, FAR * LPIXPLogon_TransportNotify_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IXPLogon_TransportNotify_Thunk = NULL;

#endif

typedef struct _tagIXPLogon_Idle_Params
{
				LPVOID						This;
				ULONG						ulFlags;
} IXPLogon_Idle_Params, FAR * LPIXPLogon_Idle_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IXPLogon_Idle_Thunk = NULL;

#endif

typedef struct _tagIXPLogon_TransportLogoff_Params
{
				LPVOID						This;
				ULONG						ulFlags;
} IXPLogon_TransportLogoff_Params, FAR * LPIXPLogon_TransportLogoff_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IXPLogon_TransportLogoff_Thunk = NULL;

#endif

typedef struct _tagIXPLogon_SubmitMessage_Params
{
				LPVOID						This;
				ULONG						ulFlags;
				LPMESSAGE					lpMessage;
				ULONG FAR *					lpulMsgRef;
				ULONG FAR *					lpulReturnParm;
} IXPLogon_SubmitMessage_Params, FAR * LPIXPLogon_SubmitMessage_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IXPLogon_SubmitMessage_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 2, 0, &IID_IMessage},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IXPLogon_SubmitMessage_Thunk = IXPLogon_SubmitMessage_ThunkArgs;

#endif

typedef struct _tagIXPLogon_EndMessage_Params
{
				LPVOID						This;
				ULONG						ulMsgRef;
				ULONG FAR *					lpulFlags;
} IXPLogon_EndMessage_Params, FAR * LPIXPLogon_EndMessage_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IXPLogon_EndMessage_Thunk = NULL;

#endif

typedef struct _tagIXPLogon_Poll_Params
{
				LPVOID						This;
				ULONG FAR *					lpulIncoming;
} IXPLogon_Poll_Params, FAR * LPIXPLogon_Poll_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IXPLogon_Poll_Thunk = NULL;

#endif

typedef struct _tagIXPLogon_StartMessage_Params
{
				LPVOID						This;
				ULONG						ulFlags;
				LPMESSAGE					lpMessage;
				ULONG FAR *					lpulMsgRef;
} IXPLogon_StartMessage_Params, FAR * LPIXPLogon_StartMessage_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IXPLogon_StartMessage_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 2, 0, &IID_IMessage},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IXPLogon_StartMessage_Thunk = IXPLogon_StartMessage_ThunkArgs;

#endif

typedef struct _tagIXPLogon_OpenStatusEntry_Params
{
        		LPVOID						This;
        		LPIID                       lpInterface;
                ULONG                       ulFlags;
                ULONG FAR *                 lpulObjType;
                LPMAPISTATUS FAR *          lppEntry;
} IXPLogon_OpenStatusEntry_Params, FAR * LPIXPLogon_OpenStatusEntry_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IXPLogon_OpenStatusEntry_Thunk = NULL;

#endif

typedef struct _tagIXPLogon_ValidateState_Params
{
				LPVOID						This;
				ULONG						ulUIParam;
				ULONG						ulFlags;
} IXPLogon_ValidateState_Params, FAR * LPIXPLogon_ValidateState_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IXPLogon_ValidateState_Thunk = NULL;

#endif

typedef struct _tagIXPLogon_FlushQueues_Params
{
				LPVOID						This;
				ULONG						ulUIParam;
				ULONG						cbTargetTransport;
				LPENTRYID					lpTargetTransport;
				ULONG						ulFlags;
} IXPLogon_FlushQueues_Params, FAR * LPIXPLogon_FlushQueues_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IXPLogon_FlushQueues_Thunk = NULL;

#endif


/*********************** IMSProvider ************************************/

typedef struct _tagIMSProvider_Shutdown_Params
{
				LPVOID						This;
				ULONG FAR *					lpulFlags;
} IMSProvider_Shutdown_Params, FAR * LPIMSProvider_Shutdown_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMSProvider_Shutdown_Thunk = NULL;

#endif
		
typedef struct _tagIMSProvider_Logon_Params
{
				LPVOID						This;
				LPMAPISUP					lpMAPISup;
				ULONG						ulUIParam;
				LPTSTR						lpszProfileName;
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulFlags;
				LPIID						lpInterface;
				ULONG FAR *					lpcbSpoolSecurity;
				LPBYTE FAR *				lppbSpoolSecurity;
                LPMAPIERROR FAR *			lppMapiError;
				LPMSLOGON FAR *				lppMSLogon;
				LPMDB FAR *					lppMDB;
} IMSProvider_Logon_Params, FAR * LPIMSProvider_Logon_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IMSProvider_Logon_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 1, 0, &IID_IMAPISup},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IMSProvider_Logon_Thunk = IMSProvider_Logon_ThunkArgs;

#endif
				
typedef struct _tagIMSProvider_SpoolerLogon_Params
{
				LPVOID						This;
				LPMAPISUP					lpMAPISup;
				ULONG						ulUIParam;
				LPTSTR						lpszProfileName;
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulFlags;
				LPIID						lpInterface;
				ULONG						cbSpoolSecurity;
				LPBYTE						lpbSpoolSecurity;
				LPMAPIERROR FAR *			lppMapiError;
				LPMSLOGON FAR *				lppMSLogon;
				LPMDB FAR *					lppMDB;
} IMSProvider_SpoolerLogon_Params, FAR * LPIMSProvider_SpoolerLogon_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IMSProvider_SpoolerLogon_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 1, 0, &IID_IMAPISup},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IMSProvider_SpoolerLogon_Thunk = IMSProvider_SpoolerLogon_ThunkArgs;

#endif
				
typedef struct _tagIMSProvider_CompareStoreIDs_Params
{
				LPVOID						This;
				ULONG						cbEntryID1;
				LPENTRYID					lpEntryID1;
				ULONG						cbEntryID2;
				LPENTRYID					lpEntryID2;
				ULONG						ulFlags;
				ULONG FAR *					lpulResult;
} IMSProvider_CompareStoreIDs_Params, FAR * LPIMSProvider_CompareStoreIDs_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMSProvider_CompareStoreIDs_Thunk = NULL;

#endif


/*************************** IMSLogon **********************************/

typedef struct _tagIMSLogon_GetLastError_Params
{
				LPVOID						This;
				HRESULT						hResult;
				ULONG						ulFlags;
				LPMAPIERROR FAR *			lppMAPIError;
} IMSLogon_GetLastError_Params, FAR * LPIMSLogon_GetLastError_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMSLogon_GetLastError_Thunk = NULL;

#endif

typedef struct _tagIMSLogon_Logoff_Params
{
				LPVOID						This;
				ULONG FAR *					lpulFlags;
} IMSLogon_Logoff_Params, FAR * LPIMSLogon_Logoff_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMSLogon_Logoff_Thunk = NULL;

#endif

typedef struct _tagIMSLogon_OpenEntry_Params
{
				LPVOID						This;
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				LPIID						lpInterface;
				ULONG						ulFlags;
				ULONG FAR *					lpulObjType;
				LPUNKNOWN FAR *				lppUnk;
} IMSLogon_OpenEntry_Params, FAR * LPIMSLogon_OpenEntry_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMSLogon_OpenEntry_Thunk = NULL;

#endif

typedef struct _tagIMSLogon_CompareEntryIDs_Params
{
				LPVOID						This;
				ULONG						cbEntryID1;
				LPENTRYID					lpEntryID1;
				ULONG						cbEntryID2;
				LPENTRYID					lpEntryID2;
				ULONG						ulFlags;
				ULONG FAR *					lpulResult;
} IMSLogon_CompareEntryIDs_Params, FAR * LPIMSLogon_CompareEntryIDs_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMSLogon_CompareEntryIDs_Thunk = NULL;

#endif

typedef struct _tagIMSLogon_Advise_Params
{
				LPVOID						This;
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulEventMask;
				LPMAPIADVISESINK			lpAdviseSink;
				ULONG FAR *					lpulConnection;
} IMSLogon_Advise_Params, FAR * LPIMSLogon_Advise_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IMSLogon_Advise_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 4, 0, &IID_IMAPIAdviseSink},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IMSLogon_Advise_Thunk = IMSLogon_Advise_ThunkArgs;

#endif

typedef struct _tagIMSLogon_Unadvise_Params
{
				LPVOID						This;
				ULONG						ulConnection;
} IMSLogon_Unadvise_Params, FAR * LPIMSLogon_Unadvise_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMSLogon_Unadvise_Thunk = NULL;

#endif

typedef struct _tagIMSLogon_OpenStatusEntry_Params
{
				LPVOID						This;
				LPIID						lpInterface;
				ULONG						ulFlags;
				ULONG FAR *					lpulObjType;
				LPVOID FAR *				lppEntry;
} IMSLogon_OpenStatusEntry_Params, FAR * LPIMSLogon_OpenStatusEntry_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMSLogon_OpenStatusEntry_Thunk = NULL;

#endif


/*************************** IMAPIControl ******************************/

typedef struct _tagIMAPIControl_GetLastError_Params
{
				LPVOID						This;
				HRESULT						hResult;
				ULONG						ulFlags;
				LPMAPIERROR FAR *			lppMAPIError;
} IMAPIControl_GetLastError_Params, FAR * LPIMAPIControl_GetLastError_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIControl_GetLastError_Thunk = NULL;

#endif
				
				
typedef struct _tagIMAPIControl_Activate_Params
{
				LPVOID						This;
				ULONG						ulFlags;
				ULONG						ulUIParam;
} IMAPIControl_Activate_Params, FAR * LPIMAPIControl_Activate_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIControl_Activate_Thunk = NULL;

#endif
				
				
typedef struct _tagIMAPIControl_GetState_Params
{
				LPVOID						This;
				ULONG						ulFlags;
				ULONG FAR *					lpulState;
} IMAPIControl_GetState_Params, FAR * LPIMAPIControl_GetState_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIControl_GetState_Thunk = NULL;

#endif


/**************************** IStream *********************************/


typedef struct _tagIStream_Read_Params
{
				LPVOID						This;
				VOID HUGEP *				pv;
				ULONG						cb;
				ULONG FAR *					pcbRead;
} IStream_Read_Params, FAR * LPIStream_Read_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IStream_Read_Thunk = NULL;

#endif

typedef struct _tagIStream_Write_Params
{
				LPVOID						This;
				VOID const HUGEP *			pv;
				ULONG						cb;
				ULONG FAR *					pcbWritten;
} IStream_Write_Params, FAR * LPIStream_Write_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IStream_Write_Thunk = NULL;

#endif

typedef struct _tagIStream_Seek_Params
{
				LPVOID						This;
				LARGE_INTEGER_ARG			dlibMove;
				DWORD						dwOrigin;
				ULARGE_INTEGER FAR *		plibNewPosition;
} IStream_Seek_Params, FAR * LPIStream_Seek_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IStream_Seek_Thunk = NULL;

#endif

typedef struct _tagIStream_SetSize_Params
{
				LPVOID						This;
				ULARGE_INTEGER_ARG			libNewSize;
} IStream_SetSize_Params, FAR * LPIStream_SetSize_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IStream_SetSize_Thunk = NULL;

#endif

typedef struct _tagIStream_CopyTo_Params
{
				LPVOID						This;
				IStream FAR *				pstm;
				ULARGE_INTEGER				cb;
				ULARGE_INTEGER FAR *		pcbRead;
				ULARGE_INTEGER FAR *		pcbWritten;
} IStream_CopyTo_Params, FAR * LPIStream_CopyTo_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IStream_CopyTo_Thunk = NULL;

#endif

typedef struct _tagIStream_Commit_Params
{
				LPVOID						This;
				DWORD						grfCommitFlags;
} IStream_Commit_Params, FAR * LPIStream_Commit_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IStream_Commit_Thunk = NULL;

#endif

typedef struct _tagIStream_Revert_Params
{
				LPVOID						This;
} IStream_Revert_Params, FAR * LPIStream_Revert_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IStream_Revert_Thunk = NULL;

#endif

typedef struct _tagIStream_LockRegion_Params
{
				LPVOID						This;
				ULARGE_INTEGER_ARG			libOffset;
				ULARGE_INTEGER_ARG_2		cb;
				DWORD						dwLockType;
} IStream_LockRegion_Params, FAR * LPIStream_LockRegion_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IStream_LockRegion_Thunk = NULL;

#endif

typedef struct _tagIStream_UnlockRegion_Params
{
				LPVOID						This;
				ULARGE_INTEGER_ARG			libOffset;
				ULARGE_INTEGER_ARG_2		cb;
				DWORD						dwLockType;
} IStream_UnlockRegion_Params, FAR * LPIStream_UnlockRegion_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IStream_UnlockRegion_Thunk = NULL;

#endif

typedef struct _tagIStream_Stat_Params
{
				LPVOID						This;
				STATSTG FAR *				pstatstg;
				DWORD						grfStatFlag;
} IStream_Stat_Params, FAR * LPIStream_Stat_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IStream_Stat_Thunk = NULL;

#endif

typedef struct _tagIStream_Clone_Params
{
				LPVOID						This;
				IStream FAR * FAR *			ppstm;
} IStream_Clone_Params, FAR * LPIStream_Clone_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IStream_Clone_Thunk = NULL;

#endif

/************************* IMAPIAdviseSink *****************************/

typedef struct _tagIMAPIAdviseSink_OnNotify_Params
{
				LPVOID						This;
				ULONG						cNotif;
				LPNOTIFICATION				lpNotifications;
} IMAPIAdviseSink_OnNotify_Params, FAR * LPIMAPIAdviseSink_OnNotify_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIAdviseSink_OnNotify_Thunk = NULL;

#endif

/************************* IMAPITable **********************************/
typedef struct _tagIMAPITable_SortTableEx_Params
{
				LPVOID						This;	
				LPSSortOrderSet				lpSortCriteria;
				ULONG						ulFlags;
} IMAPITable_SortTableEx_Params, FAR * LPIMAPITable_SortTableEx_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_SortTableEx_Thunk = NULL;

#endif

/************************** Provider INIT ******************************/

//
//typedef HRESULT (STDMAPIINITCALLTYPE MSPROVIDERINIT)(
//	HINSTANCE				hInstance,
//	LPMALLOC				lpMalloc,			/* AddRef() if you keep it */
//	LPALLOCATEBUFFER		lpAllocateBuffer,	/* -> AllocateBuffer */
//	LPALLOCATEMORE			lpAllocateMore, 	/* -> AllocateMore   */
//	LPFREEBUFFER			lpFreeBuffer, 		/* -> FreeBuffer     */
//	ULONG					ulFlags,
//	ULONG					ulMAPIVer,
//	ULONG FAR *				lpulProviderVer,
//	LPMSPROVIDER FAR *		lppMSProvider
//);
//
//typedef HRESULT (STDMAPIINITCALLTYPE XPPROVIDERINIT)(
//	HINSTANCE			hInstance,
//	LPMALLOC			lpMalloc,
//	LPALLOCATEBUFFER	lpAllocateBuffer,
//	LPALLOCATEMORE 		lpAllocateMore,
//	LPFREEBUFFER 		lpFreeBuffer,
//	ULONG				ulFlags,
//	ULONG				ulMAPIVer,
//	ULONG FAR *			lpulProviderVer,
//	LPXPPROVIDER FAR *	lppXPProvider);
//
//
//typedef HRESULT (STDMAPIINITCALLTYPE ABPROVIDERINIT)(
//	HINSTANCE			hInstance,
//	LPMALLOC			lpMalloc,
//	LPALLOCATEBUFFER	lpAllocateBuffer,
//	LPALLOCATEMORE 		lpAllocateMore,
//	LPFREEBUFFER 		lpFreeBuffer,
//    ULONG				ulFlags,
//    ULONG				ulMAPIVer,
//    ULONG FAR *			lpulProviderVer,
//    LPABPROVIDER FAR *	lppABProvider
//);


//typedef SCODE (STDMAPIINITCALLTYPE OPTIONCALLBACK)(
//			HINSTANCE		hInst,
//			LPMALLOC		lpMalloc,
//			ULONG			ulFlags,
//			ULONG			cbOptionData,
//			LPBYTE			lpbOptionData,
//			LPMAPISUP		lpMAPISup,
//			LPMAPIPROP		lpDataSource,
//			LPMAPIPROP FAR *lppWrappedSource,
//			LPTSTR FAR *	lppszErrorMsg,
//			LPTSTR FAR *	lppszErrorComponent,
//			ULONG FAR *		lpulErrorContext);



#endif /* STRUCTS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\mapistub\mapistub\unkobj.h ===
/*
 *	U N K O B J . H
 *
 * This is a generic definition of the IUnknown (plus GetLastError) part
 * of objects that are derived from IUnknown with GetLastError.
 *
 * Used in:
 * IPROP
 *
 */

#include <_glheap.h>


typedef struct _UNKOBJ FAR *	LPUNKOBJ;

/* The instance portion of UNKOBJ structure members.
 */
typedef struct _UNKINST
{
	LPALLOCATEBUFFER	lpfAllocateBuffer;
	LPALLOCATEMORE		lpfAllocateMore;
	LPFREEBUFFER		lpfFreeBuffer;
	LPMALLOC			lpmalloc;
	HINSTANCE			hinst;

} UNKINST, * PUNKINST;

typedef ULONG	IDS;

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif


/*============================================================================
 *
 *	UNKOBJ (IUnknown) Class
 */

#define	cchLastError	1024

#define MAPI_IMAPIUNKNOWN_METHODS(IPURE)								\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\

#undef	INTERFACE
#define	INTERFACE	struct _UNKOBJ

#undef	METHOD_PREFIX
#define	METHOD_PREFIX	UNKOBJ_

#undef	LPVTBL_ELEM
#define	LPVTBL_ELEM		lpvtbl

#undef	MAPIMETHOD_
#define	MAPIMETHOD_(type,method)	MAPIMETHOD_DECLARE(type,method,UNKOBJ_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIUNKNOWN_METHODS(IMPL)
#undef	MAPIMETHOD_
#define	MAPIMETHOD_(type,method)	STDMETHOD_(type,method)

DECLARE_MAPI_INTERFACE(UNKOBJ_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_IMAPIUNKNOWN_METHODS(IMPL)
};

#define	UNKOBJ_MEMBERS					\
	ULONG				ulcbVtbl;		\
	ULONG				ulcRef;			\
	LPIID FAR *			rgpiidList;		\
	ULONG				ulcIID;			\
	CRITICAL_SECTION	csid;			\
	UNKINST *			pinst;			\
	HRESULT				hrLastError;	\
	IDS					idsLastError;	\
	HLH					lhHeap

typedef struct _UNKOBJ
{
	UNKOBJ_Vtbl FAR *	lpvtbl;
	UNKOBJ_MEMBERS;

} UNKOBJ;



__inline VOID
UNKOBJ_EnterCriticalSection( LPUNKOBJ lpunkobj )
{
	EnterCriticalSection(&lpunkobj->csid);
}

__inline VOID
UNKOBJ_LeaveCriticalSection( LPUNKOBJ lpunkobj )
{
	LeaveCriticalSection(&lpunkobj->csid);
}

__inline HRESULT
UNKOBJ_HrSetLastResult( LPUNKOBJ	lpunkobj,
						HRESULT		hResult,
						IDS			idsError )
{
	UNKOBJ_EnterCriticalSection(lpunkobj);
	lpunkobj->idsLastError = idsError;
    lpunkobj->hrLastError = hResult;
	UNKOBJ_LeaveCriticalSection(lpunkobj);

	return hResult;
}

__inline HRESULT
UNKOBJ_HrSetLastError( LPUNKOBJ	lpunkobj,
					   SCODE	sc,
					   IDS		idsError )
{
	UNKOBJ_EnterCriticalSection(lpunkobj);
	lpunkobj->idsLastError = idsError;
    lpunkobj->hrLastError = ResultFromScode(sc);
	UNKOBJ_LeaveCriticalSection(lpunkobj);

	return ResultFromScode(sc);
}

__inline VOID
UNKOBJ_SetLastError( LPUNKOBJ	lpunkobj,
					 SCODE		sc,
					 IDS		idsError )
{
	lpunkobj->idsLastError = idsError;
    lpunkobj->hrLastError = ResultFromScode(sc);
}

__inline VOID
UNKOBJ_SetLastErrorSc( LPUNKOBJ	lpunkobj,
					   SCODE	sc )
{
	lpunkobj->hrLastError = ResultFromScode(sc);
}

__inline VOID
UNKOBJ_SetLastErrorIds( LPUNKOBJ	lpunkobj,
						IDS			ids )
{
	lpunkobj->idsLastError = ids;
}

STDAPI_(SCODE)
UNKOBJ_Init( LPUNKOBJ			lpunkobj,
			 UNKOBJ_Vtbl FAR *	lpvtblUnkobj,
			 ULONG				ulcbVtbl,
			 LPIID FAR *		rgpiidList,
			 ULONG				ulcIID,
			 PUNKINST			punkinst );

STDAPI_(VOID)
UNKOBJ_Deinit( LPUNKOBJ lpunkobj );

STDAPI_(SCODE)
UNKOBJ_ScAllocate( LPUNKOBJ		lpunkobj,
				   ULONG		ulcb,
				   LPVOID FAR *	lppv );

STDAPI_(SCODE)
UNKOBJ_ScAllocateMore( LPUNKOBJ		lpunkobj,
					   ULONG		ulcb,
					   LPVOID		lpv,
					   LPVOID FAR *	lppv );

STDAPI_(VOID)
UNKOBJ_Free( LPUNKOBJ	lpunkobj,
			 LPVOID		lpv );

STDAPI_(VOID)
UNKOBJ_FreeRows( LPUNKOBJ	lpunkobj,
				 LPSRowSet	lprows );


STDAPI_(SCODE)
UNKOBJ_ScCOAllocate( LPUNKOBJ		lpunkobj,
				   ULONG		ulcb,
				   LPVOID FAR *	lppv );


STDAPI_(SCODE)
UNKOBJ_ScCOReallocate( LPUNKOBJ		lpunkobj,
					   ULONG		ulcb,
					   LPVOID FAR *	lplpv );

STDAPI_(VOID)
UNKOBJ_COFree( LPUNKOBJ	lpunkobj,
			 LPVOID		lpv );

 

STDAPI_(SCODE)
UNKOBJ_ScSzFromIdsAlloc( LPUNKOBJ		lpunkobj,
						 IDS			ids,
						 ULONG			ulFlags,
						 int			cchBuf,
						 LPTSTR FAR *	lpszBuf );

STDAPI_(SCODE)
UNKOBJ_ScSzFromIdsAllocMore( LPUNKOBJ		lpunkobj,
							 IDS			ids,
							 ULONG			ulFlags,
							 LPVOID			lpvBase,
							 int			cchBuf,
							 LPTSTR FAR *	lppszBuf );


/* These should be moved to a more useful (generic) location (mapidefs.h?).
 */

#ifdef WIN16

/* IsEqualGUID is used to eliminate dependency on compob(j/32).lib. This
 * is only necessary on WIN16 because all other platforms define this 
 * already. (see objbase.h)
 */
#define IsEqualGUID(a, b)			(memcmp((a), (b), sizeof(GUID)) == 0)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\mapistub\mapistub\_glheap.h ===
/*
 * glheap.h
 *
 * Implementation of global and local heaps
 *
 * Copyright (C) 1994 Microsoft Corporation
 */

#ifndef __GLHEAP_H_
#define __GLHEAP_H_

#ifdef __cplusplus
extern "C" {
#endif

/* Windows 95 Implementation -------------------------------------------------- */

#ifdef CHICAGO

#define GH_POINTERS_VALID

typedef DWORD			GHNAME, * PGHNAME,	** PPGHNAME;
typedef DWORD			GHID,	* PGHID,	** PPGHID;
typedef struct GHDR		GHDR,	* PGHDR,	** PPGHDR;
typedef struct GH		GH,  	* PGH,		** PPGH;
typedef PGH				_HGH;
typedef HANDLE			_HLH;

struct GHDR {
	PGHDR			pghdrNext;		// Pointer to next heap
	HANDLE			hHeap;			// Handle to the heap
	GHNAME			ghname;			// Name of the heap
	GHID			ghidRoot;		// Client root heap block
	ULONG			cRef;			// Number of active clients
};

struct GH {
	HANDLE			hHeap;			// Handle to the heap
	HANDLE			hMutex;			// Handle to mutex for this heap
	PGHDR			pghdr;			// Pointer to the heap header block
	#ifdef DEBUG
	UINT			cMutex;			// Mutex entry count
	#endif
};

__inline void HeapFreeZ(HANDLE hHeap, LPVOID pv)
{
	if (pv)
		HeapFree(hHeap, 0, pv);
}

_HGH	WINAPI _GH_Open(BOOL fCreate, GHNAME ghname, DWORD dwMaxHeap);
void	WINAPI _GH_Close(_HGH hgh);
#define _GH_GetRoot(hgh)			((hgh)->pghdr->ghidRoot)
#define _GH_SetRoot(hgh, ghid)		((hgh)->pghdr->ghidRoot = (ghid))
#define _GH_GetName(hgh)			((hgh)->pghdr->ghname)
#define _GH_GetPv(hgh, ghid)		((LPVOID)(ghid))
#define _GH_GetId(hgh, pv)			((GHID)(pv))
#define _GH_GetSize(hgh, ghid)		HeapSize((hgh)->hHeap, 0, (LPVOID)(ghid))
#define _GH_Alloc(hgh, cb)			((GHID)HeapAlloc((hgh)->hHeap, 0, cb))
#define _GH_Realloc(hgh, ghid, cb)	((GHID)HeapReAlloc((hgh)->hHeap, 0, (LPVOID)(ghid), cb))
#define _GH_Free(hgh, ghid)			HeapFreeZ((hgh)->hHeap, (LPVOID)(ghid))

#ifdef DEBUG
BOOL	WINAPI _GH_WaitForMutex(_HGH hgh, ULONG ulTimeout);
void	WINAPI _GH_ReleaseMutex(_HGH hgh);
#else
#define	_GH_WaitForMutex(hgh, ulT)	GH_WaitForSingleObject(hgh->hMutex, ulT)
#ifdef __cplusplus
#define _GH_ReleaseMutex(hgh)		::ReleaseMutex((hgh)->hMutex)
#else
#define _GH_ReleaseMutex(hgh)		ReleaseMutex((hgh)->hMutex)
#endif
#endif

#define	_LH_Open(dwMaxHeap)			HeapCreate(0, 0, dwMaxHeap)
#define _LH_Close(hlh)				HeapDestroy(hlh)
#define _LH_Alloc(hlh, cb)			HeapAlloc(hlh, 0, cb)
#define _LH_Realloc(hlh, pv, cb)	HeapReAlloc(hlh, 0, pv, cb)
#define _LH_GetSize(hlh, pv)		HeapSize(hlh, 0, pv)
#define _LH_Free(hlh, pv)			HeapFreeZ(hlh, pv)

#endif

/* Win16 Implementation ---------------------------------------------------- */

#ifdef WIN16

#define GH_POINTERS_VALID

typedef __segment		HPH,	* PHPH,		** PPHPH;
typedef DWORD			HPID,	* PHPID,	** PPHPID;
typedef DWORD			GHNAME, * PGHNAME,	** PPGHNAME;
typedef HPID			GHID,	* PGHID,	** PPGHID;
typedef HPH				_HGH;
typedef HPH				_HLH;

typedef struct HP {
	HPH				hphRoot;		// Pointer to root heap
	HPH				hphPrev;		// Pointer to the previous heap (fShared)
	HPH				hphNext;		// Pointer to next heap (fShared)
	HPH				hphChild;		// Pointer to extended heaps
	BOOL			fShared;		// TRUE if heap is shared across processes
	GHNAME			ghname;			// Name of the shared heap (fShared)
	GHID			ghidRoot;		// Client root heap block
	DWORD			dwCurHeap;		// Current size of the heap
	DWORD			dwMaxHeap;		// Maximum size of the heap
	UINT			cRef;			// Number of active clients
	UINT			cbHeap;			// Size of this heap
	UINT			cbFree;			// Maximum contiguous free bytes in heap
} HP, * PHP;

#define HphToPhp(hph)				((PHP)((ULONG)(hph) << 16))
#define HP_CREATE					0x0001
#define HP_SHARED					0x0002

HPH		WINAPI HP_Open(UINT uiFlags, GHNAME ghname, DWORD dwMaxHeap);
void	WINAPI HP_Close(HPH hph);
HPID	WINAPI HP_Alloc(HPH hph, UINT cb);
HPID	WINAPI HP_Realloc(HPH hph, HPID hpid, UINT cb);
void	WINAPI HP_Free(HPH hph, HPID hpid);
#define	HP_GetSize(hgh, hpid)		(*((UINT *)(hpid) - 2))

#define _GH_Open(fCreate, ghname, dwMaxHeap) \
			HP_Open(HP_SHARED | !!(fCreate), ghname, dwMaxHeap)
#define	_GH_Close(hgh)				HP_Close(hgh)
#define _GH_GetRoot(hgh)			(HphToPhp(hgh)->ghidRoot)
#define _GH_SetRoot(hgh, ghid)		(HphToPhp(hgh)->ghidRoot = (ghid))
#define _GH_GetName(hgh)			(HphToPhp(hgh)->ghname)
#define _GH_GetPv(hgh, ghid)		((LPVOID)(ghid))
#define _GH_GetId(hgh, pv)			((GHID)(pv))
#define _GH_GetSize(hgh, ghid)		HP_GetSize(hgh, ghid)
#define _GH_Alloc(hgh, cb)			((GHID)HP_Alloc(hgh, cb))
#define _GH_Realloc(hgh, ghid, cb)	((GHID)HP_Realloc(hgh, ghid, cb))
#define _GH_Free(hgh, ghid)			HP_Free(hgh, ghid)
#define _GH_WaitForMutex(hgh, ul)	(TRUE)
#define _GH_ReleaseMutex(hgh)

#define	_LH_Open(dwMaxHeap)			HP_Open(HP_CREATE, 0, dwMaxHeap)
#define	_LH_Close(hlh)				HP_Close(hlh)
#define _LH_Alloc(hlh, cb)			((LPVOID)HP_Alloc(hlh, cb))
#define _LH_Realloc(hlh, pv, cb)	((LPVOID)HP_Realloc(hlh, (HPID)(pv), cb))
#define _LH_GetSize(hlh, pv)		HP_GetSize(hlh, pv)
#define _LH_Free(hlh, pv)			HP_Free(hlh, (HPID)(pv))

#endif

/* NT Implementation ------------------------------------------------------- */

#if defined(WIN32) && !defined(CHICAGO) && !defined(MAC)

typedef DWORD			GHNAME, * PGHNAME,	** PPGHNAME;
typedef DWORD			GHID,	* PGHID,	** PPGHID;
typedef struct GROOT	GROOT,	* PGROOT,	** PPGROOT;
typedef struct GH		GH,		* PGH,		** PPGH;
typedef struct GHBLK	GHBLK,	* PGHBLK;
typedef PGH				_HGH;
typedef HANDLE			_HLH;

struct GHBLK {
	DWORD			dwSig;			//	Signature for block validation
	WORD			cb;				//	size of the data
	WORD			ibPrev;			//	offset of previous block
};

struct GROOT
{
	GHBLK			blk;			// Block header
	GHNAME			ghname;			// Name of the heap
	GHID			ghidRoot;		// Client root heap block
	DWORD			dwCurHeap;		// Current size of the heap
	DWORD			dwMaxHeap;		// Maximum size of the heap
	WORD			rgcbFree[1];	// Maximum contiguous free bytes per page
};

struct GH
{
	PGROOT			pgroot;			// Pointer to the first byte of the heap
	HANDLE			hMutex;			// Handle to public mutex for this heap
	HANDLE			hMutexHeap;		// Handle to private mutex for this heap
	HANDLE			hMapping;		// Handle to file mapping object
	#ifdef DEBUG
	UINT			cMutex;			// Mutex entry count
	#endif
};

typedef struct GH_SECURITY_ATTRIBUTES {
	SECURITY_ATTRIBUTES		sa;
	BYTE					rgbSd[SECURITY_DESCRIPTOR_MIN_LENGTH];
} GH_SECURITY_ATTRIBUTES, * PGH_SECURITY_ATTRIBUTES;

BOOL	WINAPI GH_InitializeSecurityAttributes(PGH_SECURITY_ATTRIBUTES pghsa);

__inline void HeapFreeZ(HANDLE hHeap, LPVOID pv)
{
	if (pv)
		HeapFree(hHeap, 0, pv);
}

_HGH	WINAPI _GH_Open(BOOL fCreate, GHNAME ghname, DWORD dwMaxHeap);
void	WINAPI _GH_Close(_HGH hgh);
GHID	WINAPI _GH_Alloc(_HGH hgh, UINT cb);
GHID	WINAPI _GH_Realloc(_HGH hgh, GHID ghid, UINT cb);
void	WINAPI _GH_Free(_HGH hgh, GHID ghid);

#define _GH_GetPv(hgh, ghid)		((LPVOID)((BYTE *)(hgh)->pgroot + (ghid)))
#define _GH_GetId(hgh, pv)			((GHID)((BYTE *)(pv) - (BYTE *)(hgh)->pgroot))
#define _GH_GetSize(hgh, ghid)		((UINT)(((GHBLK *)_GH_GetPv(hgh, ghid) - 1)->cb))
#define _GH_GetRoot(hgh)			((hgh)->pgroot->ghidRoot)
#define _GH_SetRoot(hgh, ghid)		((hgh)->pgroot->ghidRoot = (ghid))
#define _GH_GetName(hgh)			((hgh)->pgroot->ghname)

#ifdef DEBUG
BOOL	WINAPI _GH_WaitForMutex(_HGH hgh, ULONG ulTimeout);
void	WINAPI _GH_ReleaseMutex(_HGH hgh);
#else
#define _GH_WaitForMutex(hgh, ul)	GH_WaitForSingleObject((hgh)->hMutex, ul)
#ifdef __cplusplus
#define _GH_ReleaseMutex(hgh)		::ReleaseMutex((hgh)->hMutex)
#else
#define _GH_ReleaseMutex(hgh)		ReleaseMutex((hgh)->hMutex)
#endif
#endif

typedef HANDLE (WINAPI MHEAPCREATE)(
	ULONG	cHeaps,
	DWORD	dwFlags,
	DWORD	dwInitialSize,
	DWORD	dwMaxSize);

typedef BOOL (WINAPI MHEAPDESTROY)(VOID);

typedef LPVOID (WINAPI MHEAPALLOC)(
	DWORD	dwSize);

typedef LPVOID (WINAPI MHEAPREALLOC)(
	LPVOID	pvOld,
	DWORD	dwSize);

typedef BOOL (WINAPI MHEAPFREE)(
	LPVOID	pvFree);

typedef DWORD (WINAPI MHEAPSIZE)(
	LPVOID	pvSize);

typedef MHEAPCREATE  FAR *LPMHEAPCREATE;
typedef MHEAPDESTROY FAR *LPMHEAPDESTROY;
typedef MHEAPALLOC   FAR *LPMHEAPALLOC;
typedef MHEAPREALLOC FAR *LPMHEAPREALLOC;
typedef MHEAPFREE    FAR *LPMHEAPFREE;
typedef MHEAPSIZE    FAR *LPMHEAPSIZE;

HANDLE WINAPI LH_ExtHeapCreate(
	DWORD	dwFlags,
	DWORD	dwInitialSize,
	DWORD	dwMaxSize);

BOOL WINAPI LH_ExtHeapDestroy(
    HANDLE  hHeap);

LPVOID WINAPI LH_ExtHeapAlloc(
    HANDLE  hHeap,
	DWORD	dwFlags,
	DWORD	dwSize);

LPVOID WINAPI LH_ExtHeapReAlloc(
    HANDLE  hHeap,
	DWORD	dwFlags,
	LPVOID	pvOld,
	DWORD	dwSize);

BOOL WINAPI LH_ExtHeapFree(
    HANDLE  hHeap,
	DWORD	dwFlags,
	LPVOID	pvFree);

DWORD WINAPI LH_ExtHeapSize(
    HANDLE  hHeap,
	DWORD	dwFlags,
	LPVOID	pvSize);

#define	_LH_Open(dwMaxHeap)			LH_ExtHeapCreate(0, 0, dwMaxHeap)
#define _LH_Close(_hlh)				LH_ExtHeapDestroy(_hlh)
#define _LH_Alloc(_hlh, cb)			LH_ExtHeapAlloc(_hlh, 0, cb)
#define _LH_Realloc(_hlh, pv, cb)	LH_ExtHeapReAlloc(_hlh, 0, pv, cb)
#define _LH_GetSize(_hlh, pv)		LH_ExtHeapSize(_hlh, 0, pv)
#define _LH_Free(_hlh, pv)			LH_ExtHeapFree(_hlh, 0, pv)

#ifndef DEBUG
HANDLE WINAPI LH_ExtHlh(VOID);

#define _LH_Hlh()                   LH_ExtHlh()
#endif

VOID WINAPI InitMemoryMgmt(VOID);
VOID WINAPI UninitMemoryMgmt(VOID);

#endif	/* WIN32 */

/* Mac Implementation ------------------------------------------------------ */

#ifdef MAC

#include <macname1.h>
#include <macos\Memory.h>
#include <macname2.h>

#define GH_POINTERS_VALID

typedef DWORD			GHNAME, * PGHNAME,	** PPGHNAME;
typedef DWORD			GHID,	* PGHID,	** PPGHID;
typedef struct GH		GH,		* PGH,		** PPGH;
typedef PGH				_HGH;
typedef HANDLE			_HLH;

typedef struct tag_SBlock {
	Handle				h;
	Ptr					ptr;
	Handle				hblk;
	struct tag_SBlock	*next;
} Block, *BlkPtr, **BlkHandle;

struct GH {
	Handle			hgh;			// Handle to 'heap' for [disposal]
	GHNAME			ghname;			// Name of the heap
	ULONG			cRef;			// Number of active clients
	GHID			ghidRoot;		// Client root heap block [a holder]
	BlkPtr			pblk;			// Ptr to first client block
	PGH				next;			// Pointer to next shared heap
};

#define	_GH_WaitForMutex(hgh, ul)	(TRUE)
#define _GH_ReleaseMutex(hgh)
#define _GH_GetRoot(pgh)			((pgh)->ghidRoot)
#define _GH_SetRoot(pgh, ghid)		((pgh)->ghidRoot = ghid)
#define _GH_GetName(pgh)			((pgh)->ghname)
#define _GH_GetPv(pgh, ghid)		((LPVOID)(ghid))
#define _GH_GetId(pgh, pv)			((GHID)(pv))

PGH		WINAPI _GH_Open(BOOL fCreate, GHNAME ghname, DWORD dwMaxHeap);
void	WINAPI _GH_Close(PGH pgh);
GHID	WINAPI _GH_Alloc(PGH pgh, UINT cb);
UINT 	WINAPI _GH_GetSize(PGH pgh, GHID ghid);
GHID	WINAPI _GH_Realloc(PGH pgh, GHID ghid, UINT cb);
void	WINAPI _GH_Free(PGH pgh, GHID ghid);

// -------------------------------
#ifndef __TEXTUTILS__
extern pascal void  NumToString(long theNum, Str255 theString);
#endif

typedef struct tag_LBlock {
	Ptr					ptr;
	struct tag_LBlock	*next;
} LBlock, *LBlkPtr;

typedef struct tag_LHeap {
	LBlkPtr				plb;	// Ptr to first local block
	struct tag_LHeap	*next;	// Ptr to next heap
} LHeap, *LHeapPtr;

LPVOID	WINAPI _LH_Open(DWORD dwMaxHeap);
void	WINAPI _LH_Close(LPVOID pvhlh);
LPVOID	WINAPI _LH_Alloc(LPVOID pvhlh, UINT cb);
LPVOID	WINAPI _LH_Realloc(LPVOID pvhlh, LPVOID pv, UINT cb);
UINT	WINAPI _LH_GetSize(LPVOID pvhlh, LPVOID pv);
void	WINAPI _LH_Free(LPVOID pvhlh, LPVOID pv);

#endif /* MAC */

/* DOS Implementation ------------------------------------------------------ */

#ifdef DOS

typedef DWORD			GHID,	* PGHID,	** PPGHID;
typedef LPMALLOC		_HLH;

__inline LPVOID _LH_Alloc(_HLH hlh, UINT cb)
{
#ifdef __cplusplus
	return((hlh)->Alloc(cb));
#else
	return((hlh)->lpVtbl->Alloc(hlh, cb));
#endif
}

__inline LPVOID _LH_Realloc(_HLH hlh, LPVOID pv, UINT cb)
{
#ifdef __cplusplus
	return(hlh->Realloc(pv, cb));
#else
	return(hlh->lpVtbl->Realloc(hlh, pv, cb));
#endif
}

__inline void _LH_Free(_HLH hlh, LPVOID pv)
{
#ifdef __cplusplus
	hlh->Free(pv);
#else
	hlh->lpVtbl->Free(hlh, pv);
#endif
}

__inline UINT _LH_GetSize(_HLH hlh, LPVOID pv)
{
#ifdef __cplusplus
	return((UINT)hlh->GetSize(pv));
#else
	return((UINT)hlh->lpVtbl->GetSize(hlh, pv));
#endif
}

#endif

// LH External API ------------------------------------------------------------

#if defined(DEBUG) && (defined(WIN16) || defined(WIN32))
#define	IFHEAPNAME(x)	x

typedef struct LH *	HLH;

HLH		WINAPI LH_Open(DWORD dwMaxHeap);
void	WINAPI LH_Close(HLH hlh);
LPVOID	WINAPI LH_Alloc(HLH hlh, UINT cb);
LPVOID	WINAPI LH_Realloc(HLH hlh, LPVOID pv, UINT cb);
UINT	WINAPI LH_GetSize(HLH hlh, LPVOID pv);
void	WINAPI LH_Free(HLH hlh, LPVOID pv);
BOOL	WINAPI LH_DidAlloc(HLH hlh, LPVOID pv);

void __cdecl LH_SetHeapNameFn(HLH hlh, char *pszFormat, ...);
void __cdecl LH_SetNameFn(HLH hlh, LPVOID pv, char *pszFormat, ...);

char *	WINAPI LH_GetName(HLH hlh, LPVOID pv);

#else
#define	IFHEAPNAME(x)	0

typedef _HLH	HLH;

#define	LH_Open(dwMaxHeap)						_LH_Open(dwMaxHeap)
#define LH_Close(hlh)							_LH_Close(hlh)
#define LH_Alloc(hlh, cb)						_LH_Alloc(hlh, cb)
#define LH_Realloc(hlh, pv, cb)					_LH_Realloc(hlh, pv, cb)
#define LH_GetSize(hlh, pv)						_LH_GetSize(hlh, pv)
#define LH_Free(hlh, pv)						_LH_Free(hlh, pv)
#define LH_Hlh()                                _LH_Hlh()

#endif

#define LH_SetHeapName(hlh,psz)					IFHEAPNAME(LH_SetHeapNameFn(hlh,psz))
#define LH_SetHeapName1(hlh,psz,a1)				IFHEAPNAME(LH_SetHeapNameFn(hlh,psz,a1))
#define LH_SetHeapName2(hlh,psz,a1,a2)			IFHEAPNAME(LH_SetHeapNameFn(hlh,psz,a1,a2))
#define LH_SetHeapName3(hlh,psz,a1,a2,a3)		IFHEAPNAME(LH_SetHeapNameFn(hlh,psz,a1,a2,a3))
#define LH_SetHeapName4(hlh,psz,a1,a2,a3,a4)	IFHEAPNAME(LH_SetHeapNameFn(hlh,psz,a1,a2,a3,a4))
#define LH_SetHeapName5(hlh,psz,a1,a2,a3,a4,a5)	IFHEAPNAME(LH_SetHeapNameFn(hlh,psz,a1,a2,a3,a4,a5))

#define LH_SetName(hlh,pv,psz)					IFHEAPNAME(LH_SetNameFn(hlh,pv,psz))
#define LH_SetName1(hlh,pv,psz,a1)				IFHEAPNAME(LH_SetNameFn(hlh,pv,psz,a1))
#define LH_SetName2(hlh,pv,psz,a1,a2)			IFHEAPNAME(LH_SetNameFn(hlh,pv,psz,a1,a2))
#define LH_SetName3(hlh,pv,psz,a1,a2,a3)		IFHEAPNAME(LH_SetNameFn(hlh,pv,psz,a1,a2,a3))
#define LH_SetName4(hlh,pv,psz,a1,a2,a3,a4)		IFHEAPNAME(LH_SetNameFn(hlh,pv,psz,a1,a2,a3,a4))
#define LH_SetName5(hlh,pv,psz,a1,a2,a3,a4,a5)	IFHEAPNAME(LH_SetNameFn(hlh,pv,psz,a1,a2,a3,a4,a5))


// GH External API ------------------------------------------------------------

#if !defined(DOS)

typedef _HGH	HGH;

#define	GH_Open(fCreate, ghname, dwMaxHeap)		_GH_Open(fCreate, ghname, \
															dwMaxHeap)
#define	GH_Close(hgh)							_GH_Close(hgh)
#define GH_GetRoot(hgh)							_GH_GetRoot(hgh)
#define GH_SetRoot(hgh, ghid)					_GH_SetRoot(hgh, ghid)
#define GH_GetName(hgh)							_GH_GetName(hgh)
#define GH_GetPv(hgh, ghid)						_GH_GetPv(hgh, ghid)
#define GH_GetId(hgh, pv)						_GH_GetId(hgh, pv)
#define GH_GetSize(hgh, ghid)					_GH_GetSize(hgh, ghid)
#define GH_Alloc(hgh, cb)						_GH_Alloc(hgh, cb)
#define GH_Realloc(hgh, ghid, cb)				_GH_Realloc(hgh, ghid, cb)
#define GH_Free(hgh, ghid)						_GH_Free(hgh, ghid)
#define	GH_WaitForMutex(hgh, ulT)				_GH_WaitForMutex(hgh, ulT)
#define GH_ReleaseMutex(hgh)					_GH_ReleaseMutex(hgh)
#define GH_GetObjectName(pszName, ghname, bTag) _GH_GetObjectName(pszName, \
														ghname, bTag);
#define GH_WaitForSingleObject(hMutex, ulTO)	_GH_WaitForSingleObject(hMutex,\
														ulTO)
#endif

#ifdef	WIN32
#if defined(_WINNT)
#define GH_NAME_CCH			25
#else
#define GH_NAME_CCH			17
#endif
#define GH_NAME_MUTEX_1		'*'		/* reserved for internal use */
#define GH_NAME_MUTEX_2		'+'		/* reserved for internal use */
#define GH_NAME_MUTEX_3		'^'
#define GH_NAME_FILE_MAPPING	'!'
void	WINAPI _GH_GetObjectName(CHAR *pszName, GHNAME ghname, BYTE bTag);

BOOL	WINAPI _GH_WaitForSingleObject(HANDLE hMutex, ULONG ulTimeout);
#endif


// ----------------------------------------------------------------------------

#ifdef __cplusplus
}
#endif

#endif	// __GLHEAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\mapistub\mapistub\_mapiexp.h ===
#ifdef NEVER // comments for preprocessor but not to be passed to .def file
// EX_CDECL_NAME (exports CDECL by name)
// EX_STDAPI_NONDEC (exports STDAPI by nondecorated name if different from decorated)
// EX_STDAPI_DEC (exports STDAPI by decorated name)
// EX_STDAPI_ALLNON (exports STDAPI by nondecorated name)
// EX_WINAPI_NONDEC (exports WINAPI by nondecorated name if different from decorated)
// EX_WINAPI_DEC (exports WINAPI by decorated name)
// EX_WINAPI_ALLNON (exports WINAPI by nondecorated name)
#endif

#ifdef WIN32
#if !defined (_X86_)
#define EX_CDECL_NAME(szName)				szName
#define EX_STDAPI_NONDEC(szName,szSuffix)
#define EX_STDAPI_DEC(szName,szSuffix)		szName
#define EX_STDAPI_ALLNON(szName,szSuffix)	szName
#define EX_WINAPI_NONDEC(szName,szSuffix)
#define EX_WINAPI_DEC(szName,szSuffix)		szName
#define EX_WINAPI_ALLNON(szName,szSuffix)	szName
#else //Intel
#define EX_CDECL_NAME(szName)				szName
#define EX_STDAPI_NONDEC(szName,szSuffix)	szName = szName##@##szSuffix
#define EX_STDAPI_DEC(szName,szSuffix)		szName##@##szSuffix
#define EX_STDAPI_ALLNON(szName,szSuffix)	szName = szName##@##szSuffix
#define EX_WINAPI_NONDEC(szName,szSuffix)	szName = szName##@##szSuffix
#define EX_WINAPI_DEC(szName,szSuffix)		szName##@##szSuffix
#define EX_WINAPI_ALLNON(szName,szSuffix)	szName = szName##@##szSuffix
#endif // Intel vs nonIntel
#endif // Win32

#ifdef WIN16
#define EX_CDECL_NAME(szName)				_##szName
#define EX_STDAPI_NONDEC(szName,szSuffix)	szName = _##szName
#define EX_STDAPI_DEC(szName,szSuffix)		_##szName
#define EX_STDAPI_ALLNON(szName,szSuffix)	szName = _##szName
#define EX_WINAPI_NONDEC(szName,szSuffix)
#define EX_WINAPI_DEC(szName,szSuffix)		szName
#define EX_WINAPI_ALLNON(szName,szSuffix)	szName
#endif // Win16


#ifdef NEVER // comments for preprocessor but not to be passed to .def file
// The following macros expand out to include an ording in the export
// EX_CDECL_NAME_ORD (exports CDECL by name)
// EX_STDAPI_NONDEC_ORD (exports STDAPI by nondecorated name if different from decorated)
// EX_STDAPI_DEC_ORD (exports STDAPI by decorated name)
// EX_STDAPI_ALLNON_ORD (exports STDAPI by nondecorated name)
// EX_WINAPI_NONDEC_ORD (exports WINAPI by nondecorated name if different from decorated)
// EX_WINAPI_DEC_ORD (exports WINAPI by decorated name)
// EX_WINAPI_ALLNON_ORD (exports WINAPI by nondecorated name)
#endif

#ifdef WIN32
#if !defined (_X86_)
#define EX_CDECL_NAME_ORD(szName,ord)				szName	ord
#define EX_STDAPI_NONDEC_ORD(szName,szSuffix,ord)
#define EX_STDAPI_DEC_ORD(szName,szSuffix,ord)		szName	ord
#define EX_STDAPI_ALLNON_ORD(szName,szSuffix,ord)	szName	ord
#define EX_WINAPI_NONDEC_ORD(szName,szSuffix,ord)
#define EX_WINAPI_DEC_ORD(szName,szSuffix,ord)		szName	ord
#define EX_WINAPI_ALLNON_ORD(szName,szSuffix,ord)	szName	ord
#else //Intel
#define EX_CDECL_NAME_ORD(szName,ord)				szName	ord
#define EX_STDAPI_NONDEC_ORD(szName,szSuffix,ord)	szName = szName##@##szSuffix	ord
#define EX_STDAPI_DEC_ORD(szName,szSuffix,ord)		szName##@##szSuffix	ord
#define EX_STDAPI_ALLNON_ORD(szName,szSuffix,ord)	szName = szName##@##szSuffix	ord
#define EX_WINAPI_NONDEC_ORD(szName,szSuffix,ord)	szName = szName##@##szSuffix	ord
#define EX_WINAPI_DEC_ORD(szName,szSuffix,ord)		szName##@##szSuffix	ord
#define EX_WINAPI_ALLNON_ORD(szName,szSuffix,ord)	szName = szName##@##szSuffix	ord
#endif // Intel vs nonIntel
#endif // Win32

#ifdef WIN16
#define EX_CDECL_NAME_ORD(szName,ord)				_##szName	ord
#define EX_STDAPI_NONDEC_ORD(szName,szSuffix,ord)	szName = _##szName	ord
#define EX_STDAPI_DEC_ORD(szName,szSuffix,ord)		_##szName	ord
#define EX_STDAPI_ALLNON_ORD(szName,szSuffix,ord)	szName = _##szName	ord
#define EX_WINAPI_NONDEC_ORD(szName,szSuffix,ord)
#define EX_WINAPI_DEC_ORD(szName,szSuffix,ord)		szName	ord
#define EX_WINAPI_ALLNON_ORD(szName,szSuffix,ord)	szName	ord
#endif // Win16


#ifdef NEVER // comments for preprocessor but not to be passed to .def file
// GP_CDECL_NAME (GetProcAddress() string for exports CDECL by name)
// GP_STDAPI_NONDEC (GetProcAddress() string for exports STDAPI by nondecorated name)
// GP_STDAPI_DEC (GetProcAddress() string for exports STDAPI by decorated name)
// GP_STDAPI_ALLNON (GetProcAddress() string for exports STDAPI by nondecorated name)
// GP_WINAPI_NONDEC (GetProcAddress() string for exports WINAPI by nondecorated name)
// GP_WINAPI_DEC (GetProcAddress() string for exports WINAPI by decorated name)
// GP_WINAPI_ALLNON (GetProcAddress() string for exports WINAPI by nondecorated name)
#endif

#ifdef WIN32
#if !defined (_X86_)
#define GP_CDECL_NAME(szName)				# szName
#define GP_STDAPI_NONDEC(szName,szSuffix)	# szName
#define GP_STDAPI_DEC(szName,szSuffix)		# szName
#define GP_STDAPI_ALLNON(szName,szSuffix)	# szName
#define GP_WINAPI_NONDEC(szName,szSuffix)	# szName
#define GP_WINAPI_DEC(szName,szSuffix)		# szName
#define GP_WINAPI_ALLNON(szName,szSuffix)	# szName
#else //Intel
#define GP_CDECL_NAME(szName)				# szName
#define GP_STDAPI_NONDEC(szName,szSuffix)	# szName
#define GP_STDAPI_DEC(szName,szSuffix)		# szName "@" # szSuffix
#define GP_STDAPI_ALLNON(szName,szSuffix)	# szName
#define GP_WINAPI_NONDEC(szName,szSuffix)	# szName
#define GP_WINAPI_DEC(szName,szSuffix)		# szName "@" # szSuffix
#define GP_WINAPI_ALLNON(szName,szSuffix)	# szName
#endif // Intel vs nonIntel
#endif // Win32

#ifdef WIN16
#define GP_CDECL_NAME(szName)				"_" # szName
#define GP_STDAPI_NONDEC(szName,szSuffix)	# szName
#define GP_STDAPI_DEC(szName,szSuffix)		"_" # szName
#define GP_STDAPI_ALLNON(szName,szSuffix)	# szName
#define GP_WINAPI_NONDEC(szName,szSuffix)	# szName
#define GP_WINAPI_DEC(szName,szSuffix)		# szName
#define GP_WINAPI_ALLNON(szName,szSuffix)	# szName
#endif // Win16
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\mapistub\mapistub\xcmc.h ===
/*BEGIN CMC INTERFACE */

#ifndef _XCMC_H
#define _XCMC_H

#ifdef __cplusplus
extern "C" {
#endif

/*BASIC DATA TYPES*/
#ifndef DIFFERENT_PLATFORM
typedef char                CMC_sint8;
typedef short               CMC_sint16;
typedef long int            CMC_sint32;
typedef unsigned short int  CMC_uint16;
typedef unsigned long int   CMC_uint32;
typedef void far *          CMC_buffer;
typedef char far *          CMC_string;
#endif

typedef CMC_uint16          CMC_boolean;
typedef CMC_sint32          CMC_enum;
typedef CMC_uint32          CMC_return_code;
typedef CMC_uint32          CMC_flags;
typedef CMC_string          CMC_object_identifier;

#define CMC_FALSE   ((CMC_boolean)0)
#define CMC_TRUE    ((CMC_boolean)1)

/*DATA STRUCTURES*/

/*COUNTED STRING*/
typedef struct {
    CMC_uint32          length;
    char                string[1];
} CMC_counted_string;

/*SESSION ID*/
typedef CMC_uint32      CMC_session_id;

/*TIME*/
/* unusedX fields needed to align struct on 4-byte boundary */
typedef struct {
    CMC_sint8           second;
    CMC_sint8           minute;
    CMC_sint8           hour;
    CMC_sint8           day;
    CMC_sint8           month;
    CMC_sint8           year;
    CMC_sint8           isdst;
    CMC_sint8           unused1;
    CMC_sint16          tmzone;
    CMC_sint16          unused2;
} CMC_time;

#define CMC_NO_TIMEZONE                     ((CMC_sint16) 0x8000)

typedef CMC_uint32          CMC_ui_id;

/*EXTENSION*/
typedef struct {
    CMC_uint32              item_code;
    CMC_uint32              item_data;
    CMC_buffer              item_reference;
    CMC_flags               extension_flags;
} CMC_extension;

/* EXTENSION FLAGS */
#define CMC_EXT_REQUIRED                    ((CMC_flags) 0x00010000)
#define CMC_EXT_OUTPUT                      ((CMC_flags) 0x00020000)
#define CMC_EXT_LAST_ELEMENT                ((CMC_flags) 0x80000000)
#define CMC_EXT_RSV_FLAG_MASK               ((CMC_flags) 0xFFFF0000)
#define CMC_EXT_ITEM_FLAG_MASK              ((CMC_flags) 0x0000FFFF)

/*ATTACHMENT*/
typedef struct {
    CMC_string              attach_title;
    CMC_object_identifier   attach_type;
    CMC_string              attach_filename;
    CMC_flags               attach_flags;
    CMC_extension FAR       *attach_extensions;
} CMC_attachment;

/* ATTACHMENT FLAGS */
#define CMC_ATT_APP_OWNS_FILE               ((CMC_flags) 1)
#define CMC_ATT_LAST_ELEMENT                ((CMC_flags) 0x80000000)

#define CMC_ATT_OID_BINARY                  "? ? ? ? ? ?"
#define CMC_ATT_OID_TEXT                    "? ? ? ? ? ?"

/*MESSAGE REFERENCE*/
typedef CMC_counted_string  CMC_message_reference;

/*RECIPIENT*/
typedef struct {
    CMC_string              name;
    CMC_enum                name_type;
    CMC_string              address;
    CMC_enum                role;
    CMC_flags               recip_flags;
    CMC_extension FAR       *recip_extensions;
} CMC_recipient;

/* NAME TYPES */
#define CMC_TYPE_UNKNOWN                    ((CMC_enum) 0)
#define CMC_TYPE_INDIVIDUAL                 ((CMC_enum) 1)
#define CMC_TYPE_GROUP                      ((CMC_enum) 2)

/* ROLES */
#define CMC_ROLE_TO                         ((CMC_enum) 0)
#define CMC_ROLE_CC                         ((CMC_enum) 1)
#define CMC_ROLE_BCC                        ((CMC_enum) 2)
#define CMC_ROLE_ORIGINATOR                 ((CMC_enum) 3)
#define CMC_ROLE_AUTHORIZING_USER           ((CMC_enum) 4)

/* RECIPIENT FLAGS */
#define CMC_RECIP_IGNORE                    ((CMC_flags) 1)
#define CMC_RECIP_LIST_TRUNCATED            ((CMC_flags) 2)
#define CMC_RECIP_LAST_ELEMENT              ((CMC_flags) 0x80000000)

/*MESSAGE*/
typedef struct {
    CMC_message_reference FAR   *message_reference;
    CMC_string              message_type;
    CMC_string              subject;
    CMC_time                time_sent;
    CMC_string              text_note;
    CMC_recipient FAR       *recipients;
    CMC_attachment FAR      *attachments;
    CMC_flags               message_flags;
    CMC_extension FAR       *message_extensions;
} CMC_message;

/* MESSAGE FLAGS */
#define CMC_MSG_READ                        ((CMC_flags) 1)
#define CMC_MSG_TEXT_NOTE_AS_FILE           ((CMC_flags) 2)
#define CMC_MSG_UNSENT                      ((CMC_flags) 4)
#define CMC_MSG_LAST_ELEMENT                ((CMC_flags) 0x80000000)

/*MESSAGE SUMMARY*/
typedef struct {
    CMC_message_reference FAR   *message_reference;
    CMC_string              message_type;
    CMC_string              subject;
    CMC_time                time_sent;
    CMC_uint32              byte_length;
    CMC_recipient FAR       *originator;
    CMC_flags               summary_flags;
    CMC_extension FAR       *message_summary_extensions;
} CMC_message_summary;

/* MESSAGE SUMMARY FLAGS */
#define CMC_SUM_READ                        ((CMC_flags) 1)
#define CMC_SUM_UNSENT                      ((CMC_flags) 2)
#define CMC_SUM_LAST_ELEMENT                ((CMC_flags) 0x80000000)

/*CMC FUNCTIONS */

/*CROSS FUNCTION FLAGS */
#define CMC_ERROR_UI_ALLOWED                ((CMC_flags) 0x01000000)
#define CMC_LOGON_UI_ALLOWED                ((CMC_flags) 0x02000000)
#define CMC_COUNTED_STRING_TYPE             ((CMC_flags) 0x04000000)

/*SEND*/
CMC_return_code FAR PASCAL
cmc_send(
    CMC_session_id          session,
    CMC_message FAR         *message,
    CMC_flags               send_flags,
    CMC_ui_id               ui_id,
    CMC_extension FAR       *send_extensions
);

#define CMC_SEND_UI_REQUESTED               ((CMC_flags) 1)

/*SEND DOCUMENT*/
CMC_return_code FAR PASCAL
cmc_send_documents(
    CMC_string              recipient_addresses,
    CMC_string              subject,
    CMC_string              text_note,
    CMC_flags               send_doc_flags,
    CMC_string              file_paths,
    CMC_string              file_names,
    CMC_string              delimiter,
    CMC_ui_id               ui_id
);

#define CMC_FIRST_ATTACH_AS_TEXT_NOTE       ((CMC_flags) 2)

/*ACT ON*/
CMC_return_code FAR PASCAL
cmc_act_on(
    CMC_session_id          session,
    CMC_message_reference FAR   *message_reference,
    CMC_enum                operation,
    CMC_flags               act_on_flags,
    CMC_ui_id               ui_id,
    CMC_extension FAR       *act_on_extensions
);

#define CMC_ACT_ON_EXTENDED                 ((CMC_enum) 0)
#define CMC_ACT_ON_DELETE                   ((CMC_enum) 1)

/*LIST*/
CMC_return_code FAR PASCAL
cmc_list(
    CMC_session_id          session,
    CMC_string              message_type,
    CMC_flags               list_flags,
    CMC_message_reference FAR   *seed,
    CMC_uint32 FAR          *count,
    CMC_ui_id               ui_id,
    CMC_message_summary FAR * FAR *result,
    CMC_extension FAR       *list_extensions
);

#define CMC_LIST_UNREAD_ONLY                ((CMC_flags) 1)
#define CMC_LIST_MSG_REFS_ONLY              ((CMC_flags) 2)
#define CMC_LIST_COUNT_ONLY                 ((CMC_flags) 4)

#define CMC_LENGTH_UNKNOWN          0xFFFFFFFF

/*READ*/
CMC_return_code FAR PASCAL
cmc_read(
    CMC_session_id          session,
    CMC_message_reference FAR   *message_reference,
    CMC_flags               read_flags,
    CMC_message FAR * FAR   *message,
    CMC_ui_id               ui_id,
    CMC_extension FAR       *read_extensions
);

#define CMC_DO_NOT_MARK_AS_READ             ((CMC_flags) 1)
#define CMC_MSG_AND_ATT_HDRS_ONLY           ((CMC_flags) 2)
#define CMC_READ_FIRST_UNREAD_MESSAGE       ((CMC_flags) 4)

/*LOOK UP*/
CMC_return_code FAR PASCAL
cmc_look_up(
    CMC_session_id          session,
    CMC_recipient FAR       *recipient_in,
    CMC_flags               look_up_flags,
    CMC_ui_id               ui_id,
    CMC_uint32 FAR          *count,
    CMC_recipient FAR * FAR *recipient_out,
    CMC_extension FAR       *look_up_extensions
);

#define CMC_LOOKUP_RESOLVE_PREFIX_SEARCH    ((CMC_flags) 1)
#define CMC_LOOKUP_RESOLVE_IDENTITY         ((CMC_flags) 2)
#define CMC_LOOKUP_RESOLVE_UI               ((CMC_flags) 4)
#define CMC_LOOKUP_DETAILS_UI               ((CMC_flags) 8)
#define CMC_LOOKUP_ADDRESSING_UI            ((CMC_flags) 16)

/*FREE*/
CMC_return_code FAR PASCAL
cmc_free(
    CMC_buffer              memory
);

/* LOGOFF */
CMC_return_code FAR PASCAL
cmc_logoff(
    CMC_session_id          session,
    CMC_ui_id               ui_id,
    CMC_flags               logoff_flags,
    CMC_extension FAR       *logoff_extensions
);

#define CMC_LOGOFF_UI_ALLOWED               ((CMC_flags) 1)

/* LOGON */
CMC_return_code FAR PASCAL
cmc_logon(
    CMC_string              service,
    CMC_string              user,
    CMC_string              password,
    CMC_object_identifier   character_set,
    CMC_ui_id               ui_id,
    CMC_uint16              caller_cmc_version,
    CMC_flags               logon_flags,
    CMC_session_id FAR      *session,
    CMC_extension FAR       *logon_extensions
);

#define CMC_VERSION         ((CMC_uint16) 100)

/* QUERY CONFIGURATION */
CMC_return_code FAR PASCAL
cmc_query_configuration(
    CMC_session_id          session,
    CMC_enum                item,
    CMC_buffer              reference,
    CMC_extension FAR       *config_extensions
);

/*QUERY CONFIGURATION ENUMS */
#define CMC_CONFIG_CHARACTER_SET            ((CMC_enum) 1)
#define CMC_CONFIG_LINE_TERM                ((CMC_enum) 2)
#define CMC_CONFIG_DEFAULT_SERVICE          ((CMC_enum) 3)
#define CMC_CONFIG_DEFAULT_USER             ((CMC_enum) 4)
#define CMC_CONFIG_REQ_PASSWORD             ((CMC_enum) 5)
#define CMC_CONFIG_REQ_SERVICE              ((CMC_enum) 6)
#define CMC_CONFIG_REQ_USER                 ((CMC_enum) 7)
#define CMC_CONFIG_UI_AVAIL                 ((CMC_enum) 8)
#define CMC_CONFIG_SUP_NOMKMSGREAD          ((CMC_enum) 9)
#define CMC_CONFIG_SUP_COUNTED_STR          ((CMC_enum) 10)
#define CMC_CONFIG_VER_IMPLEM               ((CMC_enum) 11)
#define CMC_CONFIG_VER_SPEC                 ((CMC_enum) 12)

/* CONFIG LINE TERM ENUM */
#define CMC_LINE_TERM_CRLF                  ((CMC_enum) 0)
#define CMC_LINE_TERM_CR                    ((CMC_enum) 1)
#define CMC_LINE_TERM_LF                    ((CMC_enum) 2)

/* CONFIG REQUIRED LOGON PARAMETER ENUM */
#define CMC_REQUIRED_NO                     ((CMC_enum) 0)
#define CMC_REQUIRED_YES                    ((CMC_enum) 1)
#define CMC_REQUIRED_OPT                    ((CMC_enum) 2)

/* DEFINED OBJECT ID'S FOR CHARACTER SETS */
#define CMC_CHAR_CP437                      "1 2 840 113556 3 2 437"
#define CMC_CHAR_CP850                      "1 2 840 113556 3 2 850"
#define CMC_CHAR_CP1252                     "1 2 840 113556 3 2 1252"
#define CMC_CHAR_ISTRING                    "1 2 840 113556 3 2 0"
#define CMC_CHAR_UNICODE                    "1 2 840 113556 3 2 1"

/* RETURN CODE FLAGS */
#define CMC_ERROR_DISPLAYED                 ((CMC_return_code) 0x00008000)
#define CMC_ERROR_RSV_MASK                  ((CMC_return_code) 0x0000FFFF)
#define CMC_ERROR_IMPL_MASK                 ((CMC_return_code) 0xFFFF0000)

/* RETURN CODES */
#define CMC_SUCCESS                         ((CMC_return_code) 0)

#define CMC_E_AMBIGUOUS_RECIPIENT           ((CMC_return_code) 1)
#define CMC_E_ATTACHMENT_NOT_FOUND          ((CMC_return_code) 2)
#define CMC_E_ATTACHMENT_OPEN_FAILURE       ((CMC_return_code) 3)
#define CMC_E_ATTACHMENT_READ_FAILURE       ((CMC_return_code) 4)
#define CMC_E_ATTACHMENT_WRITE_FAILURE      ((CMC_return_code) 5)
#define CMC_E_COUNTED_STRING_UNSUPPORTED    ((CMC_return_code) 6)
#define CMC_E_DISK_FULL                     ((CMC_return_code) 7)
#define CMC_E_FAILURE                       ((CMC_return_code) 8)
#define CMC_E_INSUFFICIENT_MEMORY           ((CMC_return_code) 9)
#define CMC_E_INVALID_CONFIGURATION         ((CMC_return_code) 10)
#define CMC_E_INVALID_ENUM                  ((CMC_return_code) 11)
#define CMC_E_INVALID_FLAG                  ((CMC_return_code) 12)
#define CMC_E_INVALID_MEMORY                ((CMC_return_code) 13)
#define CMC_E_INVALID_MESSAGE_PARAMETER     ((CMC_return_code) 14)
#define CMC_E_INVALID_MESSAGE_REFERENCE     ((CMC_return_code) 15)
#define CMC_E_INVALID_PARAMETER             ((CMC_return_code) 16)
#define CMC_E_INVALID_SESSION_ID            ((CMC_return_code) 17)
#define CMC_E_INVALID_UI_ID                 ((CMC_return_code) 18)
#define CMC_E_LOGON_FAILURE                 ((CMC_return_code) 19)
#define CMC_E_MESSAGE_IN_USE                ((CMC_return_code) 20)
#define CMC_E_NOT_SUPPORTED                 ((CMC_return_code) 21)
#define CMC_E_PASSWORD_REQUIRED             ((CMC_return_code) 22)
#define CMC_E_RECIPIENT_NOT_FOUND           ((CMC_return_code) 23)
#define CMC_E_SERVICE_UNAVAILABLE           ((CMC_return_code) 24)
#define CMC_E_TEXT_TOO_LARGE                ((CMC_return_code) 25)
#define CMC_E_TOO_MANY_FILES                ((CMC_return_code) 26)
#define CMC_E_TOO_MANY_RECIPIENTS           ((CMC_return_code) 27)
#define CMC_E_UNABLE_TO_NOT_MARK_AS_READ    ((CMC_return_code) 28)
#define CMC_E_UNRECOGNIZED_MESSAGE_TYPE     ((CMC_return_code) 29)
#define CMC_E_UNSUPPORTED_ACTION            ((CMC_return_code) 30)
#define CMC_E_UNSUPPORTED_CHARACTER_SET     ((CMC_return_code) 31)
#define CMC_E_UNSUPPORTED_DATA_EXT          ((CMC_return_code) 32)
#define CMC_E_UNSUPPORTED_FLAG              ((CMC_return_code) 33)
#define CMC_E_UNSUPPORTED_FUNCTION_EXT      ((CMC_return_code) 34)
#define CMC_E_UNSUPPORTED_VERSION           ((CMC_return_code) 35)
#define CMC_E_USER_CANCEL                   ((CMC_return_code) 36)
#define CMC_E_USER_NOT_LOGGED_ON            ((CMC_return_code) 37)

#ifdef __cplusplus
}       /* extern "C" */
#endif

#endif  /* _XCMC_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\mapistub\mapistub\_mapiu.h ===
/*
 *      _ M A P I U . H
 *      
 *      Non-public MACROs and FUNCTIONs which may be used by MAPI
 *
 *      Used in conjunction with routines found in MAPIU.DLL.
 *      
 *      Copyright 1992-93 Microsoft Corporation.  All Rights Reserved.
 */

#ifndef _MAPIU_H
#define _MAPIU_H

#ifdef __cplusplus
extern "C" {
#endif

#ifndef MAPIUTIL_H
#include        <mapiutil.h>
#endif
#include        <stddef.h>

/* Declarations for Global data defined by MAPIU
 */

#if defined(WIN32) && !defined(MAC)
#ifndef DATA1_BEGIN
#include "mapiperf.h"
#endif
#pragma DATA1_BEGIN
extern CRITICAL_SECTION csUnkobjInit;
#pragma DATA_END
#endif

extern TCHAR    szEmpty[];

/* Macros provided by MAPIU
 */
#ifndef CharSizeOf
#define CharSizeOf(x)   (sizeof(x) / sizeof(TCHAR))
#endif

//      Alignment

#define AlignN(n, x)            (((x)+(1<<(n))-1) & ~((1<<(n))-1))
#define Align2(x)                       AlignN(1,(x))
#define Align4(x)                       AlignN(2,(x))
#define Align8(x)                       AlignN(3,(x))

#if defined (_MIPS_) || defined (_ALPHA_) || defined (_PPC_)
#define AlignNatural(cb)                        Align8(cb)
#elif defined (WIN32)
#define AlignNatural(cb)                        Align4(cb)
#else // defined (WIN16)
#define AlignNatural(cb)                        Align2(cb)
#endif

#define FIsAligned(p)                           (AlignNatural((ULONG)((LPVOID)p)) == (ULONG)((LPVOID)p))
#define FIsAlignedCb(cb)                        (AlignNatural((ULONG)(cb)) == (ULONG)(cb))

/* Prototypes for private math functions
 */
STDAPI_(DWORD)
DwDivFtDw( FILETIME ftDividend, DWORD dwDivisor);

VOID
VSzFromIDS(ULONG ulIDS, UINT uncchBuffer, LPWSTR lpszBuffer, ULONG ulFlags);

/* Prototype for LoadString wrapper
 * Utility to allocate memory and loadstring and string IDS, ANSI/UNICODE.
 */ 
 
#define MAX_CCH_IDS             256
SCODE ScStringFromIDS( LPALLOCATEBUFFER lpMapiAllocBuffer, ULONG ulFlags, UINT ids, 
                LPTSTR * lppszIDS );

/* Prototypes for Message and Dialog Box utilities.
 */
SCODE
ScMessageBoxIDS( ULONG  ulUIParam,
                                 UINT   idsCaption,
                                 UINT   idsMessage,
                                 UINT   uMBType);

/* Prototypes for MAPI status utilities.
 */
BOOL
FProfileLoggedOn( LPSTR szProfileName);

/* Prototypes for functions used to validate complex parameters.
 */

#ifndef __cplusplus
#define FBadIfacePtr(param, iface)                                      \
                (       IsBadReadPtr((param), sizeof(iface))    \
                 ||     IsBadReadPtr((param)->lpVtbl, sizeof(iface##Vtbl)))
#else
#define FBadIfacePtr(param, iface)      (FALSE)
#endif

/*
 *      FBadDelPTA
 *
 *      Returns TRUE if the given Prop Tag Array is readable and contains only
 *      prop tags which are valid for a DeleteProps (or related) call.
 */
STDAPI_(BOOL)
FBadDelPTA(LPSPropTagArray lpPropTagArray);


/*
 *      IListedPropID
 *
 *  Purpose
 *              If a tag with ID == PROP_ID(ulPropTag) is listed in lptaga then
 *              the index of tag is returned.  If the tag is not in lptaga then
 *              -1 is returned.
 *
 *      Arguments
 *              ulPropTag       Property tag to locate.
 *              lptaga          Property tag array to search.
 *
 *      Returns         TRUE or FALSE
 */
_inline LONG
IListedPropID( ULONG                    ulPropTag,
                           LPSPropTagArray      lptaga)
{
        ULONG FAR       *lpulPTag;

        /* No tag is contained in a NULL list of tags.
         */
    if (!lptaga)
        {
                return -1;
        }

        /* Mutate ulPropTag to just a PROP_ID.
         */
    ulPropTag = PROP_ID(ulPropTag);

        for ( lpulPTag = lptaga->aulPropTag + lptaga->cValues
                ; --lpulPTag >= lptaga->aulPropTag
                ; )
        {
                /* Compare PROP_ID's.
                 */
                if (PROP_ID(*lpulPTag) == ulPropTag)
                {
                        return (LONG)(lpulPTag - lptaga->aulPropTag);
                }
        }

        return -1;
}

/*
 *      FListedPropID
 *
 *  Purpose
 *              Determine if a tag with ID == PROP_ID(ulPropTag) is listed in lptaga.
 *
 *      Arguments
 *              ulPropTag       Property tag to locate.
 *              lptaga          Property tag array to search.
 *
 *      Returns         TRUE or FALSE
 */
_inline BOOL
FListedPropID( ULONG                    ulPropTag,
                           LPSPropTagArray      lptaga)
{
        ULONG FAR       *lpulPTag;

        /* No tag is contained in a NULL list of tags.
         */
    if (!lptaga)
        {
                return FALSE;
        }

        /* Mutate ulPropTag to just a PROP_ID.
         */
    ulPropTag = PROP_ID(ulPropTag);

        for ( lpulPTag = lptaga->aulPropTag + lptaga->cValues
                ; --lpulPTag >= lptaga->aulPropTag
                ; )
        {
                /* Compare PROP_ID's.
                 */
                if (PROP_ID(*lpulPTag) == ulPropTag)
                {
                        return TRUE;
                }
        }

        return FALSE;
}

/*
 *      FListedPropTAG
 *
 *  Purpose
 *              Determine if a the given ulPropTag is listed in lptaga.
 *
 *      Arguments
 *              ulPropTag       Property tag to locate.
 *              lptaga          Property tag array to search.
 *
 *      Returns         TRUE or FALSE
 */
_inline BOOL
FListedPropTAG( ULONG                   ulPropTag,
                                LPSPropTagArray lptaga)
{
        ULONG FAR       *lpulPTag;

        /* No tag is contained in a NULL list of tags.
         */
    if (!lptaga)
        {
                return FALSE;
        }

        /* Compare the entire prop tag to be sure both ID and TYPE match
         */
        for ( lpulPTag = lptaga->aulPropTag + lptaga->cValues
                ; --lpulPTag >= lptaga->aulPropTag
                ; )
        {
                /* Compare PROP_ID's.
                 */
                if (PROP_ID(*lpulPTag) == ulPropTag)
                {
                        return TRUE;
                }
        }

        return FALSE;
}


/*
 *      AddProblem
 *
 *  Purpose
 *              Adds a problem to the next available entry of a pre-allocated problem
 *              array.
 *              The pre-allocated problem array must be big enough to have another
 *              problem added.  The caller is responsible for making sure this is
 *              true.
 *
 *      Arguments
 *              lpProblems      Pointer to pre-allocated probelem array.
 *              ulIndex         Index into prop tag/value array of the problem property.
 *              ulPropTag       Prop tag of property which had the problem.
 *              scode           Error code to list for the property.
 *
 *      Returns         TRUE or FALSE
 */
_inline VOID
AddProblem( LPSPropProblemArray lpProblems,
                        ULONG                           ulIndex,
                        ULONG                           ulPropTag,
                        SCODE                           scode)
{
        if (lpProblems)
        {
                Assert( !IsBadWritePtr( lpProblems->aProblem + lpProblems->cProblem
                          , sizeof(SPropProblem)));
                lpProblems->aProblem[lpProblems->cProblem].ulIndex = ulIndex;
                lpProblems->aProblem[lpProblems->cProblem].ulPropTag = ulPropTag;
                lpProblems->aProblem[lpProblems->cProblem].scode = scode;
                lpProblems->cProblem++;
        }
}

__inline BOOL
FIsExcludedIID( LPCIID lpiidToCheck, LPCIID rgiidExclude, ULONG ciidExclude)
{
        /* Check the obvious (no exclusions).
         */
        if (!ciidExclude || !rgiidExclude)
        {
                return FALSE;
        }

        /* Check each iid in the list of exclusions.
         */
        for (; ciidExclude; rgiidExclude++, ciidExclude--)
        {
//              if (IsEqualGUID( lpiidToCheck, rgiidExclude))
                if (!memcmp( lpiidToCheck, rgiidExclude, sizeof(MAPIUID)))
                {
                        return TRUE;
                }
        }

        return FALSE;
}


/*
 *      Error/Warning Alert Message Boxes
 */
int                     AlertIdsCtx( HWND hwnd,
                                                 HINSTANCE hinst,
                                                 UINT idsMsg,
                                                 LPSTR szComponent,
                                                 ULONG ulContext,
                                                 ULONG ulLow,
                                                 UINT fuStyle);

__inline int
AlertIds(HWND hwnd, HINSTANCE hinst, UINT idsMsg, UINT fuStyle)
{
        return AlertIdsCtx(hwnd, hinst, idsMsg, NULL, 0, 0, fuStyle);
}

int                     AlertSzCtx( HWND hwnd,
                                                LPSTR szMsg,
                                                LPSTR szComponent,
                                                ULONG ulContext,
                                                ULONG ulLow,
                                                UINT fuStyle);

__inline int
AlertSz(HWND hwnd, LPSTR szMsg, UINT fuStyle)
{
        return AlertSzCtx(hwnd, szMsg, NULL, 0, 0, fuStyle);
}




/*  Encoding and decoding strings */
STDAPI_(void)                   EncodeID(LPBYTE lpb, ULONG cb, LPTSTR lpsz);
STDAPI_(BOOL)                   FDecodeID(LPTSTR lpsz, LPBYTE lpb, ULONG FAR *lpcb);
STDAPI_(ULONG)                  CchOfEncoding(ULONG cb);
STDAPI_(ULONG)                  CbOfEncoded(LPTSTR lpsz);
STDAPI_(int)                    CchEncodedLine(int cb);


/*  Idle engine routines */

#ifdef  DEBUG

/*
 *      DumpIdleTable
 *
 *              Used for debugging only.  Writes information in the PGD(hftgIdle)
 *              table to COM1.
 */

STDAPI_(void)
DumpIdleTable (void);

#endif
/*
 *      FDoNextIdleTask
 *
 *              Dispatches the first eligible idle function, according to
 *              its simple scheduling algorithm.
 */

STDAPI_(BOOL) FDoNextIdleTask (void);

/* C runtime substitutes */

typedef int (__cdecl FNSGNCMP)(const void FAR *lpv1, const void FAR *lpv2);
typedef FNSGNCMP FAR *PFNSGNCMP;

FNSGNCMP                                SgnCmpPadrentryByType;

BOOL FRKFindSubpb(LPBYTE pbTarget, ULONG cbTarget, LPBYTE pbPattern, ULONG cbPattern);
BOOL FRKFindSubpsz(LPSTR pszTarget, ULONG cbTarget, LPSTR pszPattern, ULONG cbPattern, ULONG ulFuzzyLevel);
LPSTR LpszRKFindSubpsz(LPSTR pszTarget, ULONG cbTarget, LPSTR pszPattern, ULONG cbPattern, ULONG ulFuzzyLevel);

STDAPI_(void)                   ShellSort(LPVOID lpv, UINT cv,                  /* qsort */
                                                LPVOID lpvT, UINT cb, PFNSGNCMP fpCmp);


/*  Advise list maintainence utilities  */
/*
 *      Structure and functions for maintaining a list of advise sinks,
 *      together with the keys used to release them.
 */

typedef struct
{
        LPMAPIADVISESINK        lpAdvise;
        ULONG                           ulConnection;
        ULONG                           ulType;
        LPUNKNOWN                       lpParent;
} ADVISEITEM, FAR *LPADVISEITEM;

typedef struct
{
        ULONG                           cItemsMac;
        ULONG                           cItemsMax;
        #if defined(WIN32) && !defined(MAC)
        CRITICAL_SECTION FAR * lpcs;
        #endif
        ADVISEITEM                      rgItems[1];
} ADVISELIST, FAR *LPADVISELIST;

#define CbNewADVISELIST(_citems) \
        (offsetof(ADVISELIST, rgItems) + (_citems) * sizeof(ADVISEITEM))
#define CbADVISELIST(_plist) \
        (offsetof(ADVISELIST, rgItems) + (_plist)->cItemsMax * sizeof(ADVISEITEM))

STDAPI_(SCODE)
ScAddAdviseList(        LPVOID lpvReserved,
                                        LPADVISELIST FAR *lppList,
                                        LPMAPIADVISESINK lpAdvise,
                                        ULONG ulConnection,
                                        ULONG ulType,
                                        LPUNKNOWN lpParent);

STDAPI_(SCODE)
ScDelAdviseList(        LPADVISELIST lpList,
                                        ULONG ulConnection);
STDAPI_(SCODE)
ScFindAdviseList(       LPADVISELIST lpList,
                                        ULONG ulConnection,
                                        LPADVISEITEM FAR *lppItem);
STDAPI_(void)
DestroyAdviseList(      LPADVISELIST FAR *lppList);

// prototype for routine that detects whether calling apps is
// an interactive EXE or a service.

#if defined( _WINNT )
BOOL WINAPI IsServiceAnExe( VOID );
#endif

// prototype for internal routine that computes the size required 
// to hold a given propval array based on specified alignment

SCODE ScCountPropsEx( int cprop,
                      LPSPropValue rgprop,
                      ULONG ulAlign,
                      ULONG FAR *pcb );

/*  Option data handling routines */
#ifdef MAPISPI_H

STDAPI_(SCODE)
ScCountOptionData(LPOPTIONDATA lpOption, ULONG FAR *lpcb);

STDAPI_(SCODE)
ScCopyOptionData(LPOPTIONDATA lpOption, LPVOID lpvDst, ULONG FAR *lpcb);

STDAPI_(SCODE)
ScRelocOptionData(LPOPTIONDATA lpOption,
                LPVOID lpvBaseOld, LPVOID lpvBaseNew, ULONG FAR *lpcb);

#endif  /* MAPISPI_H */


#ifdef __cplusplus
}
#endif


#endif  // _MAPIU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\mapistub\mapistub\_spooler.h ===
/*
 *	_ S P O O L E R . H
 *
 *	Common Spooler Definitions for use in the MAPI and SPOOLER Subsytems
 *	Copyright 1992-1995 Microsoft Corporation.	All Rights Reserved.
 */

//	Spooler event (reserved in mapidefs.h) */
//
#define	fnevSpooler		((ULONG)0x40000000)

//	Spooler flag for calling into MapiInitialize()
//
#define MAPI_SPOOLER_INIT	0x40000000	/* reserved in MAPIX.H */

//	Spooler startup security information
//
#define cbSplSecurity	(sizeof(ULONG) * 4)		// spooler security data

//	Magic flags for StoreLogoffTransports() that
//	are required for LocalReplication usage
//
//	IMPORTANT!  These are defined this way for a reason.
//	We do not want to have to doc this behavior!  We do
//	not want to have to support this in the future.  We
//	do not want to give anybody an idea that there may be
//	something hidden behind reserved bits in MAPIDEFS.H.
//
//	To this end, these reserved bits are not even defined
//	as reserved bits in MAPIDEFS.H.  Should we need to move
//	them over, then we will.  But otherwise, they stay here.
//
//	These bits are the control bits for a hack to help the
//	local rep crew temorarily disable a store for spooler
//	processing.
//
//	When the spooler gets a StoreLogoffTransports() call with
//	the LOGOFF_SUSPEND bit set, any sending on that store is
//	aborted, and the outgoing queue is thrown out.  If the store
//	was the default store, then the spooler will disable all the
//	transports as well.
//
//	When the resume is received, the store is reactivated
//	the outgoing queue is reacquired.  We make no assumption
//	about any hold-overs from the old OQ to the new one.
//
//	Now you are starting to see why we really do not want to
//	doc this "subtle-nuance" to the StoreLogoffTransports()
//	api.
//
#define	LOGOFF_RESERVED1		((ULONG) 0x00001000) /* Reserved for future use */
#define LOGOFF_RESERVED2		((ULONG) 0x00002000) /* Reserved for future use */
#define	LOGOFF_SUSPEND			LOGOFF_RESERVED1
#define LOGOFF_RESUME			LOGOFF_RESERVED2

//	Biggest size we expect from a resource string
//
#define RES_MAX	255

typedef struct _HEARTBEAT
{
	UINT				cBeats;
	DWORD				dwTimeout;
#if defined(WIN32) && !defined(MAC)
	HANDLE				htSpl;
	HANDLE				hevt;
	CRITICAL_SECTION	cs;
#endif
#ifdef	WIN16
	HHOOK				hhkFilter;
#endif
#if defined(WIN16) || defined(MAC)
	BOOL				fInHeartbeat;
	DWORD				dwHeartbeat;
	UINT				cBeatsCur;
#endif
#ifdef MAC
	HHOOK				hhkKbdFilter;
	HHOOK				hhkMouseFilter;
#endif

} HEARTBEAT, FAR * LPHEARTBEAT;

typedef struct _GOQ GOQ, FAR * LPGOQ;
typedef struct _SPLDATA
{
	ULONG				cbSize;
	BYTE				rgbSecurity[cbSplSecurity];
	HINSTANCE			hInstMapiX;
	HINSTANCE			hInstSpooler;
	HWND				hwndPrev;
	HWND				hwndSpooler;
	LPCLASSFACTORY		lpclsfct;
	HEARTBEAT			hb;
	LPGOQ				lpgoq;
	TCHAR				rgchClassName[RES_MAX+1];
	TCHAR				rgchWindowTitle[RES_MAX+1];
	ULONG				dwTckLast;
	ULONG				dwTckValidate;
	ULONG				ulFlags;
	ULONG				ulNotif;
	ULONG				ulSplSrvc;
	ULONG				ulStatus;

#if defined(WIN32) && !defined(MAC)
	CRITICAL_SECTION	csOQ;
	UINT				lcInitHiPriority;
	UINT				uBasePriority;
	HWND				hwndStub;
#endif
#if defined(WIN16) || defined (MAC)
	DWORD				dwTckLastFilterMsg;
#endif
#ifdef	DEBUG
	BOOL				fHeartbeat:1;
	BOOL				fHooks:1;
	BOOL				fInbound:1;
	BOOL				fOutbound:1;
	BOOL				fOutQueue:1;
	BOOL				fPPs:1;
	BOOL				fService:1;
	BOOL				fVerbose:1;
	BOOL				fYield:1;
#endif

} SPLDATA, FAR * LPSPLDATA;

typedef struct _SPOOLERINIT
{
	MAPIINIT_0	mi;
	LPBYTE		lpbSecurity;
	
} SPLINIT, FAR * LPSPLINIT;


//	Values used for SPLENTRY
//
#define SPL_AUTOSTART	((UINT)1)
#define SPL_EXCHANGE	((UINT)4)

#define SPLENTRYORDINAL	((UINT)8)
#define SPL_VERSION		((ULONG)0x00010001)

typedef SCODE (STDMAPIINITCALLTYPE FAR * LPSPLENTRY)(
	LPSPLDATA		lpSpoolerData,
	LPVOID			lpvReserved,
	ULONG			ulSpoolerVer,
	ULONG FAR *		lpulMAPIVer
);


//	Values used for uSpooler in the shared memory block
//	SPL_NONE -		No spooler is running or trying to run
//	SPL_AUTOSTARTED -	Spooler process has been launched by MAPI but
//						not yet Initialized itself.
//	SPL_INITIALIZED -	Spooler has initialized itself but is not yet
//						running the message pump.
//	SPL_RUNNING -	Spooler is running its message pump.
//	SPL_EXITING -	Spooler process is shutting down
//
#define SPL_NONE			((UINT)0)
#define SPL_AUTOSTARTED		((UINT)1)
#define SPL_INITIALIZED		((UINT)2)
#define SPL_RUNNING			((UINT)3)
#define SPL_EXITING			((UINT)4)

/*
 *	IMAPISpoolerService Interface ---------------------------------------------
 *
 *	MAPI Spooler OLE Remotely Activated Service Interface
 */
DECLARE_MAPI_INTERFACE_PTR(IMAPISpoolerService, LPSPOOLERSERVICE);
#define MAPI_IMAPISPOOLERSERVICE_METHODS(IPURE)							\
	MAPIMETHOD(OpenStatusEntry)											\
		(THIS_	LPMAPIUID					lpSessionUid,				\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulObjType,				\
				LPMAPIPROP FAR *			lppMAPIPropEntry) IPURE;	\

#undef		 INTERFACE
#define		 INTERFACE	IMAPISpoolerService
DECLARE_MAPI_INTERFACE_(IMAPISpoolerService, IUnknown)
{
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPISPOOLERSERVICE_METHODS(PURE)
};

HRESULT HrCreateSplServCF (LPCLASSFACTORY FAR * lppClassFactory);
HRESULT NewSPLSERV (LPSPOOLERSERVICE FAR * lppSPLSERV);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\mapistub\mapistub\_smerror.h ===
/*
 *	_SMERROR.H
 *	
 *	This file contains all of the status codes defined for Capone.
 *	This file also contains masks for all of the facilities that
 *	don't include a facility ID in their status codes.
 */
#ifndef _SMERROR_H_
#define _SMERROR_H_

#ifdef _MSC_VER
#	if defined (WIN32) 
#		ifndef _OLEERROR_H_
#			include <objerror.h>
#		endif
#		ifndef _OBJBASE_H_
#			include <objbase.h>
#		endif
#	else
#		ifndef _COMPOBJ_H_
#			include <compobj.h>
#		endif		
#	endif
#endif

#ifndef __SCODE_H__
#include <scode.h>
#endif

/*
 *	C o n s t a n t s
 */

// Error string limits
#define cchContextMax			128
#define cchProblemMax			300
#define cchComponentMax			128
#define cchScodeMax				64
#define	cchErrorMax				(cchContextMax + cchProblemMax + cchComponentMax + cchScodeMax)

// Scode sources
#define FACILITY_MAIL			(0x0100)
#define FACILITY_MAPI			(0x0200)
#define FACILITY_WIN			(0x0300)
#define FACILITY_MASK			(0x0700)

// Scode masks
#define scmskMail				(MAKE_SCODE(0, FACILITY_MAIL, 0))
#define scmskMapi				(MAKE_SCODE(0, FACILITY_MAPI, 0))
#define scmskWin				(MAKE_SCODE(0, FACILITY_WIN, 0))
#define scmskMask				(MAKE_SCODE(0, FACILITY_MASK, 0))

// Critical error flag
#define CRITICAL_FLAG			((SCODE) 0x00008000)


/*
 *	T y p e s
 */


// Error context filled in by PushErrctx (not by caller!)
typedef struct _errctx
{
	UINT str;							// String resource ID
	struct _errctx * perrctxPrev;		// Previous error context
}
ERRCTX;


/*
 *	M a c r o s
 */


// Scode manipulation
#define StrFromScode(_sc) \
	((UINT) ((_sc) & (0x00007fffL)))
#define FCriticalScode(_sc) \
	((_sc) & CRITICAL_FLAG)
#define FMailScode(_sc) \
	(((_sc) & scmskMask) == scmskMail)
#define FMapiScode(_sc) \
	(((_sc) & scmskMask) == scmskMapi)
#define FWinScode(_sc) \
	(((_sc) & scmskMask) == scmskWin)
#define FGenericScode(_sc) \
	(((_sc) & scmskMask) == 0)

// Scode constructors
#define MAKE_NOTE_S_SCODE(_str) \
	MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_MAIL, (_str))
#define MAKE_NOTE_E_SCODE(_str) \
	MAKE_SCODE(SEVERITY_ERROR, FACILITY_MAIL, (_str))
#define MAKE_NOTE_X_SCODE(_str) \
	MAKE_SCODE(SEVERITY_ERROR, FACILITY_MAIL, (_str) | CRITICAL_FLAG)

// Windows errors
#define ScWin(_sc) \
	((SCODE) ((_sc) | scmskWin))
#define ScWinN(_n) \
	(MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN, (ULONG) (_n)))
#ifdef WIN32
#define ScWinLastError() \
	MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN, GetLastError())
#else
#define ScWinLastError() \
	MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN, 0)
#endif
#define GetWinError(_sc) \
	_sc = ScWinLastError()

// MAPI errors
#define ScMapi(_sc) \
	((SCODE) ((_sc) | scmskMapi))
#define	MarkMAPIError(_sc) \
	_sc |= scmskMapi


/*
 *	E r r o r   S t r i n g s
 */

#define STR_ErrorCaptionMail			(IDS_SIMPLE_MAPI_SEND + 61)

#define	ERRSTR_Start					(IDS_SIMPLE_MAPI_SEND + 62)

#define STR_CriticalErrorText			ERRSTR_Start+0
#define STR_MailComponentName			ERRSTR_Start+1		


/*
 *	E r r o r   C o n t e x t s
 *
 */

// Note
#define STR_CtxMailSend					ERRSTR_Start+2		
#define STR_CtxFormatFont				ERRSTR_Start+3		
#define STR_CtxFileClose				ERRSTR_Start+4		

// Attachments							 
#define STR_CtxInsertFile				ERRSTR_Start+5			
#define STR_CtxLoadAttachments			ERRSTR_Start+6
#define STR_CtxWriteAttachments			ERRSTR_Start+7
#define STR_CtxInsertAttach				ERRSTR_Start+31

// Clipboard
#define STR_CtxClipboard				ERRSTR_Start+30

/*
 *	E r r o r   M e s s a g e s
 *
 */

#define STR_ErrMemory					ERRSTR_Start+8				

// Note
#define STR_ErrCantCloseObject			ERRSTR_Start+9
#define STR_ErrClipboardChanged			ERRSTR_Start+10	
#define STR_ErrCantCreateObject			ERRSTR_Start+11
#define STR_ErrOleUIFailed				ERRSTR_Start+12
#define STR_ErrNoClientSite				ERRSTR_Start+13
#define STR_ErrNoStorage				ERRSTR_Start+14

// Attachments
#define	STR_ErrStreamInFile				ERRSTR_Start+15		
#define	STR_ErrStreamOutFile			ERRSTR_Start+16
#define STR_ErrUnknownStorage			ERRSTR_Start+17
#define STR_ErrCreateTempFile			ERRSTR_Start+18
#define STR_ErrCantAttachDir			ERRSTR_Start+19	
#define	STR_ErrStreamInFileLocked		ERRSTR_Start+20
#define	STR_ErrCantDoVerb				ERRSTR_Start+21		
#define STR_ErrMacBin					ERRSTR_Start+22
#define STR_ErrAttachEncoding			ERRSTR_Start+23
#define STR_FileAttStillOpen			ERRSTR_Start+24
#define STR_TempFileGone				ERRSTR_Start+25
#define STR_NoDragDropDir				ERRSTR_Start+26
#define STR_ErrorLoadAttach				ERRSTR_Start+27

#define STR_ErrNoAccess					ERRSTR_Start+35	
#define STR_ErrMediumFull				ERRSTR_Start+36	
#define STR_ErrGenericFailNoCtx			ERRSTR_Start+37	
#define STR_ErrGenericFail				ERRSTR_Start+38	

#define STR_ErrNoHelp					IDS_E_NO_HELP

// Display strings
//
#define	STR_FileAttShortName			ERRSTR_Start+40			
#define	STR_FileAttFullName				ERRSTR_Start+41	

/*
 *	N o t e  S c o d e s
 *
 *	Use MAKE_NOTE_S_SCODE for success scodes, MAKE_NOTE_E_SCODE for regular
 *	errors, and MAKE_NOTE_X_SCODE for critical [stop sign] errors.
 *	Define nondisplayable errors incrementally, and displayable errors 
 *	using their string.  Don't overlap E and S scodes.
 */


// No strings attached
//
#define NOTE_E_REPORTED				MAKE_NOTE_E_SCODE(0)

// Address book
//
#define NOTE_E_MEMORY				MAKE_NOTE_X_SCODE(STR_ErrMemory)

// Note
//
#define NOTE_E_CANTCLOSEOBJECT		MAKE_NOTE_E_SCODE(STR_ErrCantCloseObject)
#define NOTE_E_CLIPBOARDCHANGED		MAKE_NOTE_E_SCODE(STR_ErrClipboardChanged)
#define NOTE_E_CANTCREATEOBJECT		MAKE_NOTE_E_SCODE(STR_ErrCantCreateObject)
#define NOTE_E_OLEUIFAILED			MAKE_NOTE_E_SCODE(STR_ErrOleUIFailed)
#define NOTE_E_NOCLIENTSITE			MAKE_NOTE_E_SCODE(STR_ErrNoClientSite)
#define NOTE_E_NOSTORAGE			MAKE_NOTE_E_SCODE(STR_ErrNoStorage)

// Attachments
//
#define	NOTE_E_STREAMINFILE			MAKE_NOTE_E_SCODE(STR_ErrStreamInFile)
#define	NOTE_E_STREAMOUTFILE		MAKE_NOTE_E_SCODE(STR_ErrStreamOutFile)
#define	NOTE_E_UNKNOWNSTORAGE		MAKE_NOTE_E_SCODE(STR_ErrUnknownStorage)
#define	NOTE_E_CREATETEMPFILE		MAKE_NOTE_E_SCODE(STR_ErrCreateTempFile)
#define	NOTE_E_CANTATTACHDIR		MAKE_NOTE_E_SCODE(STR_ErrCantAttachDir)
#define	NOTE_E_STREAMINFILELOCKED	MAKE_NOTE_E_SCODE(STR_ErrStreamInFileLocked)
#define	NOTE_E_CANTDOVERB			MAKE_NOTE_E_SCODE(STR_ErrCantDoVerb)
#define NOTE_E_ERRMACBIN			MAKE_NOTE_E_SCODE(STR_ErrMacBin)
#define NOTE_E_ERRATTACHENCODING	MAKE_NOTE_E_SCODE(STR_ErrAttachEncoding)

#define NOTE_E_GENERAL				MAKE_NOTE_E_SCODE(STR_ErrGenericFail)
#define NOTE_E_NOHELP				MAKE_NOTE_E_SCODE(STR_ErrNoHelp)
#define NOTE_E_NOACCESS				MAKE_NOTE_E_SCODE(STR_ErrNoAccess)
#define NOTE_E_MEDIUMFULL			MAKE_NOTE_E_SCODE(STR_ErrMediumFull)

#define MAPI_E_UNRESOLVED_RECIPS	MAKE_NOTE_E_SCODE(IDS_E_UNRESOLVED_RECIPS)

// LPMAPIERROR ulLowLevelError values
//
#define	ulExtensionError			1000

// end of _smerror.h
//
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\mapistub\mapistub\_vbmapi.h ===
// Structures and Functions used by BMAPI and VB2C

#define RECIPIENT   	((USHORT)0x0001)
#define FILE        	((USHORT)0x0002)
#define MESSAGE     	((USHORT)0x0004)
#define SAFEARRAY		((USHORT)0x1000)

#if defined (WIN32)
#ifndef BMAPI_ENTRY                         		 // PFP
  #define BMAPI_ENTRY  ULONG FAR PASCAL    // define BMAPI_ENTRY  PFP
#endif                                      		 // PFP
#else
#ifndef BMAPI_ENTRY                         		 // PFP
  #define BMAPI_ENTRY  ULONG __export FAR PASCAL    // define BMAPI_ENTRY  PFP
#endif                                      		 // PFP
#endif

//#ifndef LHANDLE
//  #define LHANDLE ULONG
//#endif

#ifndef ERR
  #define ERR 	USHORT
#endif


#if defined (WIN32)
//-----------------------------------------------------------------------
// WIN32 definitions of 32 bit VB interface function support
//-----------------------------------------------------------------------
typedef struct
{
	ULONG	ulReserved;
	BSTR 	bstrSubject;
	BSTR 	bstrNoteText;
	BSTR 	bstrMessageType;
	BSTR 	bstrDate;
	BSTR 	bstrConversationID;
	ULONG 	flFlags;
	ULONG 	nRecipCount;
	ULONG 	nFileCount;
} VB_Message,FAR *lpVB_Message;

typedef VB_Message VB_MESSAGE;
typedef VB_Message FAR *LPVB_MESSAGE;


typedef struct
{
	ULONG 	ulReserved;
	ULONG 	ulRecipClass;
	BSTR 	bstrName;
	BSTR 	bstrAddress;
	ULONG 	ulEIDSize;
	BSTR 	bstrEID;
} VB_Recip,FAR *lpVB_Recip;

typedef VB_Recip VB_RECIPIENT;
typedef VB_Recip FAR *LPVB_RECIPIENT;


typedef struct
{
	ULONG 	ulReserved;
	ULONG 	flFlags;
	ULONG 	nPosition;
	BSTR 	bstrPathName;
	BSTR 	bstrFileName;
	BSTR 	bstrFileType;
} VB_File, FAR *lpVB_File;

// OLEAUT32.DLL loadlib and getprocaddress support

// WINOLEAUTAPI_(void) SysFreeString(BSTR);
typedef VOID (STDAPICALLTYPE *LPFNSYSFREESTRING)
	( BSTR bstr );

// WINOLEAUTAPI_(unsigned int) SysStringByteLen(BSTR bstr);
typedef UINT (STDAPICALLTYPE *LPFNSYSSTRINGBYTELEN)
	(BSTR bstr);

// WINOLEAUTAPI_(BSTR) SysAllocStringByteLen(const char FAR* psz, unsigned int len);
typedef BSTR (STDAPICALLTYPE *LPFNSYSALLOCSTRINGBYTELEN)
	(const char *psz, UINT len );

// WINOLEAUTAPI_(BSTR) SysAllocString(const OLECHAR FAR*);
typedef BSTR (STDAPICALLTYPE *LPFNSYSALLOCSTRING)
	(const OLECHAR * szwString);

// WINOLEAUTAPI_(int)  SysReAllocString(BSTR FAR*, const OLECHAR FAR*);
typedef INT (STDAPICALLTYPE *LPFNSYSREALLOCSTRING)
	(BSTR * lpBstr, const OLECHAR * szwString);

// WINOLEAUTAPI_(unsigned int) SysStringLen(BSTR);
typedef UINT (STDAPICALLTYPE *LPFNSYSSTRINGLEN)
	(BSTR bstr);

// WINOLEAUTAPI SafeArrayAccessData(SAFEARRAY FAR* psa, void HUGEP* FAR* ppvData);
typedef HRESULT (STDAPICALLTYPE *LPFNSAFEARRAYACCESSDATA)
	(struct tagSAFEARRAY *psa, void **ppvData);

// WINOLEAUTAPI SafeArrayUnaccessData(SAFEARRAY FAR* psa);
typedef HRESULT (STDAPICALLTYPE *LPFNSAFEARRAYUNACCESSDATA)
	(struct tagSAFEARRAY *psa);

extern LPFNSYSFREESTRING 			lpfnSysFreeString;
extern LPFNSYSSTRINGBYTELEN 		lpfnSysStringByteLen;
extern LPFNSYSALLOCSTRINGBYTELEN	lpfnSysAllocStringByteLen;
extern LPFNSYSALLOCSTRING			lpfnSysAllocString;
extern LPFNSYSREALLOCSTRING			lpfnSysReAllocString;
extern LPFNSYSSTRINGLEN				lpfnSysStringLen;
extern LPFNSAFEARRAYACCESSDATA		lpfnSafeArrayAccessData;
extern LPFNSAFEARRAYUNACCESSDATA	lpfnSafeArrayUnaccessData;

#undef SysFreeString
#undef SysStringByteLen
#undef SysAllocStringByteLen
#undef SysAllocString
#undef SysReAllocString
#undef SysStringLen
#undef SafeArrayAccessData
#undef SafeArrayUnaccessData

#define SysFreeString			(*lpfnSysFreeString)
#define SysStringByteLen 		(*lpfnSysStringByteLen)
#define SysAllocStringByteLen	(*lpfnSysAllocStringByteLen)
#define SysAllocString			(*lpfnSysAllocString)
#define SysReAllocString		(*lpfnSysReAllocString)
#define SysStringLen			(*lpfnSysStringLen)
#define SafeArrayAccessData		(*lpfnSafeArrayAccessData)
#define SafeArrayUnaccessData	(*lpfnSafeArrayUnaccessData)

#else	// !WIN32

//-----------------------------------------------------------------------
// VB 3.0 definitions for 16 bit VB interface support
//-----------------------------------------------------------------------
typedef struct
{
	ULONG ulReserved;
	HLSTR hlstrSubject;
	HLSTR hlstrNoteText;
	HLSTR hlstrMessageType;
	HLSTR hlstrDate;
	HLSTR hlstrConversationID;
	ULONG flFlags;
	ULONG nRecipCount;
	ULONG nFileCount;
} VB_Message,FAR *lpVB_Message;

typedef VB_Message VB_MESSAGE;
typedef VB_Message FAR *LPVB_MESSAGE;


typedef struct
{
	ULONG ulReserved;
	ULONG ulRecipClass;
	HLSTR hlstrName;
	HLSTR hlstrAddress;
	ULONG ulEIDSize;
	HLSTR hlstrEID;
} VB_Recip,FAR *lpVB_Recip;

typedef VB_Recip VB_RECIPIENT;
typedef VB_Recip FAR *LPVB_RECIPIENT;


typedef struct
{
	ULONG ulReserved;
	ULONG flFlags;
	ULONG nPosition;
	HLSTR hlstrPathName;
	HLSTR hlstrFileName;
	HLSTR hlstrFileType;
} VB_File, FAR *lpVB_File;
#endif	// WIN32

typedef VB_File 			VB_FILE;
typedef VB_File FAR *		LPVB_FILE;

typedef MapiMessage 		VB_MAPI_MESSAGE;
typedef MapiMessage FAR *	LPMAPI_MESSAGE;
typedef LPMAPI_MESSAGE FAR *LPPMAPI_MESSAGE;


typedef MapiRecipDesc 		MAPI_RECIPIENT;
typedef MapiRecipDesc FAR *	LPMAPI_RECIPIENT;
typedef LPMAPI_RECIPIENT FAR *LPPMAPI_RECIPIENT;

typedef MapiFileDesc 		MAPI_FILE;
typedef MapiFileDesc FAR *	LPMAPI_FILE;
typedef LPMAPI_FILE FAR *	LPPMAPI_FILE;

typedef HANDLE FAR *		LPHANDLE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\msasn1\bit.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"


static const ASN1uint8_t
c_aBitMask[] = {
    0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff
};

static const ASN1uint8_t
c_aBitMask2[] = {
    0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff
};

static const ASN1uint8_t
c_aBitMask4[] = {
    0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01, 0x00
};

static const ASN1int32_t
c_aBitMask5[] = {
    (ASN1int32_t)0xffffffff, (ASN1int32_t)0xfffffffe,
    (ASN1int32_t)0xfffffffc, (ASN1int32_t)0xfffffff8,
    (ASN1int32_t)0xfffffff0, (ASN1int32_t)0xffffffe0,
    (ASN1int32_t)0xffffffc0, (ASN1int32_t)0xffffff80,
    (ASN1int32_t)0xffffff00, (ASN1int32_t)0xfffffe00,
    (ASN1int32_t)0xfffffc00, (ASN1int32_t)0xfffff800,
    (ASN1int32_t)0xfffff000, (ASN1int32_t)0xffffe000,
    (ASN1int32_t)0xffffc000, (ASN1int32_t)0xffff8000,
    (ASN1int32_t)0xffff0000, (ASN1int32_t)0xfffe0000,
    (ASN1int32_t)0xfffc0000, (ASN1int32_t)0xfff80000,
    (ASN1int32_t)0xfff00000, (ASN1int32_t)0xffe00000,
    (ASN1int32_t)0xffc00000, (ASN1int32_t)0xff800000,
    (ASN1int32_t)0xff000000, (ASN1int32_t)0xfe000000,
    (ASN1int32_t)0xfc000000, (ASN1int32_t)0xf8000000,
    (ASN1int32_t)0xf0000000, (ASN1int32_t)0xe0000000,
    (ASN1int32_t)0xc0000000, (ASN1int32_t)0x80000000,
    (ASN1int32_t)0x00000000
};

static const ASN1uint8_t
c_aBitCount[] = {
    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
    4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
};

/* copy nbits bits from src/srcbit into dst/dstbit;
   src points to first octet containing bits to be copied
   srcbit names the first bit within the first octet to be copied (0=msb, 7=lsb)
   dst points to first octet to copy into
   dstbit names the first bit within the first octet to copy into (0=msb, 7=lsb)
   nbits is the number of bits to copy;
   assumes that bits of broken octet at dst/dstbit are cleared;
   bits of last octet behind dst/dstbit+nbits-1 will be cleared
*/
void ASN1bitcpy(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits)
{
    ASN1uint32_t xsrcbit, xdstbit;

    if (!nbits)
        return;

    if (dstbit >= 8) {
        dst += dstbit / 8;
        dstbit &= 7;
    }
    if (srcbit >= 8) {
        src += srcbit / 8;
        srcbit &= 7;
    }

    /* check if we have to fill broken first octet */
    if (dstbit) {
        xdstbit = 8 - dstbit;

        /* enough bits to fill up broken octet? */
        if (nbits >= xdstbit) {
            if (srcbit < dstbit) {
                *dst++ |= (*src >> (dstbit - srcbit)) & c_aBitMask[xdstbit];
                nbits -= xdstbit;
                srcbit += xdstbit;
                dstbit = 0;
            } else if (srcbit == dstbit) {
                *dst++ |= *src++ & c_aBitMask[xdstbit];
                nbits -= xdstbit;
                srcbit = 0;
                dstbit = 0;
            } else {
                *dst++ |= ((*src & c_aBitMask[8 - srcbit]) << (srcbit - dstbit)) |
                    (src[1] >> (8 - (srcbit - dstbit)));
                nbits -= xdstbit;
                src++;
                srcbit -= dstbit;
                dstbit = 0;
            }

        /* less bits to fill than needed to fill up the broken octet */
        } else {
            if (srcbit <= dstbit) {
                *dst |= ((*src >> (8 - srcbit - nbits)) & c_aBitMask[nbits]) <<
                    (xdstbit - nbits);
            } else {
                *dst++ |= ((*src & c_aBitMask[8 - srcbit]) << (srcbit - dstbit)) |
                    ((src[1] >> (16 - srcbit - nbits)) << (xdstbit - nbits));
            }
            return;
        }
    }

    /* fill up complete octets */
    if (nbits >= 8) {
        if (!srcbit) {
            CopyMemory(dst, src, nbits / 8);
            dst += nbits / 8;
            src += nbits / 8;
            nbits &= 7;
        } else {
            xsrcbit = 8 - srcbit;
            do {
                *dst++ = (*src << srcbit) | (src[1] >> (xsrcbit));
                src++;
                nbits -= 8;
            } while (nbits >= 8);
        }
    }

    /* fill bits into last octet */
    if (nbits)
        {
                *dst = (*src << srcbit) & c_aBitMask2[nbits];
                // lonchanc: made the following fix for the case that
                // src bits across byte boundary.
                if (srcbit + nbits > 8)
                {
                        xsrcbit = nbits - (8 - srcbit);
                        src++;
                        *dst |= ((*src & c_aBitMask2[xsrcbit]) >> (8 - srcbit));
                }
        }
}

/* clear nbits bits at dst/dstbit;
   bits of last octet behind dst/dstbit+nbits-1 will be cleared
*/
void ASN1bitclr(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1uint32_t nbits)
{
    ASN1uint32_t xdstbit;

    if (!nbits)
        return;

    if (dstbit >= 8) {
        dst += dstbit / 8;
        dstbit &= 7;
    }

    /* clear broken ASN1octet first */
    if (dstbit) {
        xdstbit = 8 - dstbit;
        *dst &= c_aBitMask2[xdstbit];
        if (xdstbit < nbits) {
            dst++;
            nbits -= xdstbit;
        } else {
            return;
        }
    }

    /* clear remaining bits */
    ZeroMemory(dst, (nbits + 7) / 8);
}

/* clear nbits bits at dst/dstbit;
   bits of last octet behind dst/dstbit+nbits-1 will be cleared
*/
void ASN1bitset(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1uint32_t nbits)
{
    ASN1uint32_t xdstbit;

    if (!nbits)
        return;

    if (dstbit >= 8) {
        dst += dstbit / 8;
        dstbit &= 7;
    }

    /* set broken ASN1octet first */
    if (dstbit) {
        xdstbit = 8 - dstbit;
        if (xdstbit < nbits) {
            *dst |= c_aBitMask4[xdstbit];
            dst++;
            nbits -= xdstbit;
        } else {
            *dst |= c_aBitMask4[nbits] << (xdstbit - nbits);
            return;
        }
    }

    /* set complete octets */
    if (nbits >= 8) {
        memset(dst, 0xff, nbits / 8);
        dst += nbits / 8;
        nbits &= 7;
    }

    /* set remaining bits */
    if (nbits)
        *dst |= c_aBitMask4[nbits] << (8 - nbits);
}

/* write nbits bits of val at dst/dstbit;
   assumes that bits of broken octet at dst/dstbit are cleared;
   bits of last octet behind dst/dstbit+nbits-1 will be cleared
*/
void ASN1bitput(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1uint32_t val, ASN1uint32_t nbits)
{
    ASN1uint32_t xdstbit;

    if (!nbits)
        return;

    if (dstbit >= 8) {
        dst += dstbit / 8;
        dstbit &= 7;
    }
    xdstbit = 8 - dstbit;

    /* fill up broken octet first */
    if (dstbit) {
        if (xdstbit <= nbits) {
            *dst++ |= val >> (nbits -= xdstbit);
        } else {
            *dst |= (val & c_aBitMask[nbits]) << (xdstbit - nbits);
            return;
        }
    }

    /* copy complete octets */
    while (nbits >= 8)
        *dst++ = (ASN1octet_t) (val >> (nbits -= 8));

    /* copy left bits */
    if (nbits)
        *dst = (ASN1octet_t) ((val & c_aBitMask[nbits]) << (8 - nbits));
}

/* read nbits bits of val at src/srcbit */
// lonchanc: the return value is independent of big or little endian
// because we use shift left within a long integer.
ASN1uint32_t ASN1bitgetu(ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits)
{
    ASN1uint32_t xsrcbit;
    ASN1uint32_t ret;

    if (!nbits)
        return 0;

    if (srcbit >= 8) {
        src += srcbit / 8;
        srcbit &= 7;
    }
    xsrcbit = 8 - srcbit;
    ret = 0;

    /* get bits from broken octet first */
    if (srcbit) {
        if (xsrcbit <= nbits) {
            ret = (*src++ & c_aBitMask[xsrcbit]) << (nbits -= xsrcbit);
        } else {
            return (*src >> (xsrcbit - nbits)) & c_aBitMask[nbits];
        }
    }

    /* get complete octets */
    while (nbits >= 8)
        ret |= *src++ << (nbits -= 8);

    /* get left bits */
    if (nbits)
        ret |= ((*src) >> (8 - nbits)) & c_aBitMask[nbits];
    return ret;
}

/* read nbits bits of val at src/srcbit */
ASN1int32_t ASN1bitget(ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits)
{
    ASN1uint32_t xsrcbit;
    ASN1int32_t ret;

    if (!nbits)
        return 0;

    if (srcbit >= 8) {
        src += srcbit / 8;
        srcbit &= 7;
    }
    xsrcbit = 8 - srcbit;
    if (*src & (0x80 >> srcbit))
        ret = c_aBitMask5[nbits];
    else
        ret = 0;

    /* get bits from broken octet first */
    if (srcbit) {
        if (xsrcbit <= nbits) {
            ret = *src++ << (nbits -= xsrcbit);
        } else {
            return (*src >> (xsrcbit - nbits)) & c_aBitMask[nbits];
        }
    }

    /* get complete octets */
    while (nbits >= 8)
        ret |= *src++ << (nbits -= 8);

    /* get left bits */
    if (nbits)
        ret |= ((*src) >> (8 - nbits)) & c_aBitMask[nbits];
    return ret;
}

/* get number of set bits in nbits bits at src/srcbit */
ASN1uint32_t ASN1bitcount(ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits)
{
    ASN1uint32_t xsrcbit;
    ASN1uint32_t ret;

    if (!nbits)
        return 0;

    if (srcbit >= 8) {
        src += srcbit / 8;
        srcbit &= 7;
    }
    xsrcbit = 8 - srcbit;

    /* count bits from broken octet first */
    if (srcbit) {
        if (xsrcbit <= nbits) {
            ret = c_aBitCount[*src++ & c_aBitMask4[srcbit]];
            nbits -= xsrcbit;
        } else {
            return c_aBitCount[(*src >> (xsrcbit - nbits)) & c_aBitMask[nbits]];
        }
    } else {
        ret = 0;
    }

    /* count bits in complete octets */
    while (nbits >= 8)
	{
        ret += c_aBitCount[*src++];
		nbits -= 8;
	}

    /* count left bits */
    if (nbits)
        ret += c_aBitCount[(*src) & c_aBitMask2[nbits]];
    return ret;
}

/* write noctets of val at dst */
void ASN1octetput(ASN1octet_t *dst, ASN1uint32_t val, ASN1uint32_t noctets)
{
    switch (noctets) {
    case 4:
        *dst++ = (ASN1octet_t)(val >> 24);
        /*FALLTHROUGH*/
    case 3:
        *dst++ = (ASN1octet_t)(val >> 16);
        /*FALLTHROUGH*/
    case 2:
        *dst++ = (ASN1octet_t)(val >> 8);
        /*FALLTHROUGH*/
    case 1:
        *dst++ = (ASN1octet_t)(val);
        break;
    default:
    break;
        MyAssert(0);
        /*NOTREACHED*/
    }
}

/* read noctets of val at dst */
ASN1uint32_t ASN1octetget(ASN1octet_t *src, ASN1uint32_t noctets)
{
    switch (noctets) {
    case 4:
        return (*src << 24) | (src[1] << 16) | (src[2] << 8) | src[3];
    case 3:
        return (*src << 16) | (src[1] << 8) | src[2];
    case 2:
        return (*src << 8) | src[1];
    case 1:
        return *src;
    default:
        MyAssert(0);
        return(0);
        /*NOTREACHED*/
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\msasn1\berencod.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

#ifdef ENABLE_BER

#include <float.h>
#include <math.h>

#if HAS_IEEEFP_H
// #include <ieeefp.h>
#elif HAS_FLOAT_H
// #include <float.h>
#endif

static const char bitmsk2[] =
{
    (const char) 0x00,
    (const char) 0x80,
    (const char) 0xc0,
    (const char) 0xe0,
    (const char) 0xf0,
    (const char) 0xf8,
    (const char) 0xfc,
    (const char) 0xfe
};


/* encode a string value */
int ASN1BEREncCharString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char_t *val)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* encode length */
        if (ASN1BEREncLength(enc, len))
        {
            CopyMemory(enc->pos, val, len);
            enc->pos += len;
            return 1;
        }
    }
    return 0;
}

/* encode a string value (CER) */
int ASN1CEREncCharString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char_t *val)
{
    ASN1uint32_t n;

    if (len <= 1000)
    {
        /* encode tag */
        if (ASN1BEREncTag(enc, tag))
        {
            /* encode length */
            if (ASN1BEREncLength(enc, len))
            {
                CopyMemory(enc->pos, val, len);
                enc->pos += len;
                return 1;
            }
        }
    }
    else
    {
        ASN1uint32_t nLenOff;
        /* encode value as constructed, using segments of 1000 octets */
        if (ASN1BEREncExplicitTag(enc, tag, &nLenOff))
        {
            while (len)
            {
                n = len > 1000 ? 1000 : len;
                if (ASN1BEREncTag(enc, 0x4))
                {
                    if (ASN1BEREncLength(enc, n))
                    {
                        CopyMemory(enc->pos, val, n);
                        enc->pos += n;
                        val += n;
                        len -= n;
                    }
                    else
                    {
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            }
            return ASN1BEREncEndOfContents(enc, nLenOff);
        }
    }
    return 0;
}

/* encode a 16 bit string value */
int ASN1BEREncChar16String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char16_t *val)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* encode length */
        if (ASN1BEREncLength(enc, len * sizeof(ASN1char16_t)))
        {
            while (len--)
            {
                *enc->pos++ = (ASN1octet_t)(*val >> 8);
                *enc->pos++ = (ASN1octet_t)(*val);
                val++;
            }
        }
        return 1;
    }
    return 0;
}

/* encode a 16 bit string value (CER) */
int ASN1CEREncChar16String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char16_t *val)
{
    ASN1uint32_t n;

    if (len <= 1000 / sizeof(ASN1char16_t))
    {
        /* encode tag */
        if (ASN1BEREncTag(enc, tag))
        {
            /* encode length */
            if (ASN1BEREncLength(enc, len * sizeof(ASN1char16_t)))
            {
                while (len--)
                {
                    *enc->pos++ = (ASN1octet_t)(*val >> 8);
                    *enc->pos++ = (ASN1octet_t)(*val);
                    val++;
                }
                return 1;
            }
        }
    }
    else
    {
        ASN1uint32_t nLenOff;
        /* encode value as constructed, using segments of 1000 octets */
        if (ASN1BEREncExplicitTag(enc, tag, &nLenOff))
        {
            while (len)
            {
                n = len > 1000 / sizeof(ASN1char16_t) ?
                    1000 / sizeof(ASN1char16_t) : len;
                if (ASN1BEREncTag(enc, 0x4))
                {
                    if (ASN1BEREncLength(enc, n))
                    {
                        while (len--)
                        {
                            *enc->pos++ = (ASN1octet_t)(*val >> 8);
                            *enc->pos++ = (ASN1octet_t)(*val);
                            val++;
                        }
                        len -= n;
                    }
                    else
                    {
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            }
            return ASN1BEREncEndOfContents(enc, nLenOff);
        }
    }
    return 0;
}

/* encode a 32 bit string value */
int ASN1BEREncChar32String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char32_t *val)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* encode length */
        if (ASN1BEREncLength(enc, len * sizeof(ASN1char32_t)))
        {
            while (len--)
            {
                *enc->pos++ = (ASN1octet_t)(*val >> 24);
                *enc->pos++ = (ASN1octet_t)(*val >> 16);
                *enc->pos++ = (ASN1octet_t)(*val >> 8);
                *enc->pos++ = (ASN1octet_t)(*val);
                val++;
            }
            return 1;
        }
    }
    return 0;
}

/* encode a 32 bit string value (CER) */
int ASN1CEREncChar32String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char32_t *val)
{
    ASN1uint32_t n;

    if (len <= 1000 / sizeof(ASN1char32_t))
    {
        /* encode tag */
        if (ASN1BEREncTag(enc, tag))
        {
            /* encode length */
            if (ASN1BEREncLength(enc, len * sizeof(ASN1char32_t)))
            {
                while (len--)
                {
                    *enc->pos++ = (ASN1octet_t)(*val >> 24);
                    *enc->pos++ = (ASN1octet_t)(*val >> 16);
                    *enc->pos++ = (ASN1octet_t)(*val >> 8);
                    *enc->pos++ = (ASN1octet_t)(*val);
                    val++;
                }
                return 1;
            }
        }
    }
    else
    {
        ASN1uint32_t nLenOff;
        /* encode value as constructed, using segments of 1000 octets */
        if (ASN1BEREncExplicitTag(enc, tag, &nLenOff))
        {
            while (len)
            {
                n = len > 1000 / sizeof(ASN1char32_t) ?
                    1000 / sizeof(ASN1char32_t) : len;
                if (ASN1BEREncTag(enc, 0x4))
                {
                    if (ASN1BEREncLength(enc, n))
                    {
                        while (len--)
                        {
                            *enc->pos++ = (ASN1octet_t)(*val >> 24);
                            *enc->pos++ = (ASN1octet_t)(*val >> 16);
                            *enc->pos++ = (ASN1octet_t)(*val >> 8);
                            *enc->pos++ = (ASN1octet_t)(*val);
                            val++;
                        }
                        len -= n;
                    }
                    else
                    {
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            } // while
            return ASN1BEREncEndOfContents(enc, nLenOff);
        }
    }
    return 0;
}

/* encode a bit string value */
int ASN1BEREncBitString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val)
{
    ASN1uint32_t noctets = (len + 7) / 8;

    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* encode length */
        if (ASN1BEREncLength(enc, noctets + 1))
        {
            ASN1uint32_t cUnusedBits = (7 - ((len + 7) & 7));
            *enc->pos++ = (ASN1octet_t) cUnusedBits;
            CopyMemory(enc->pos, val, noctets);
            enc->pos += noctets;
            EncAssert(enc, noctets >= 1);
            if (cUnusedBits)
            {
                EncAssert(enc, 8 >= cUnusedBits);
                *(enc->pos - 1) &= bitmsk2[8 - cUnusedBits];
            }
            return 1;
        }
    }
    return 0;
}

/* encode a bit string value (CER) */
int ASN1CEREncBitString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val)
{
    ASN1uint32_t noctets;
    ASN1uint32_t n;

    noctets = (len + 7) / 8;
    if (noctets + 1 <= 1000)
    {
        /* encode tag */
        if (ASN1BEREncTag(enc, tag))
        {
            /* encode length */
            if (ASN1BEREncLength(enc, noctets + 1))
            {
                *enc->pos++ = (ASN1octet_t) (7 - ((len + 7) & 7));
                CopyMemory(enc->pos, val, noctets);
                enc->pos += noctets;
                return 1;
            }
        }
    }
    else
    {
        ASN1uint32_t nLenOff;
        /* encode value as constructed, using segments of 1000 octets */
        if (ASN1BEREncExplicitTag(enc, tag, &nLenOff))
        {
            while (noctets)
            {
                n = len > 999 ? 999 : len;
                if (ASN1BEREncTag(enc, 0x3))
                {
                    if (ASN1BEREncLength(enc, n + 1))
                    {
                        *enc->pos++ = (ASN1octet_t) (n < len ? 0 : 7 - ((len + 7) & 7));
                        CopyMemory(enc->pos, val, n);
                        enc->pos += n;
                        val += n;
                        noctets -= n;
                    }
                    else
                    {
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            } // while
            return ASN1BEREncEndOfContents(enc, nLenOff);
        }
    }
    return 0;
}

#ifdef ENABLE_GENERALIZED_CHAR_STR
/* encode a character string value */
int ASN1BEREncCharacterString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1characterstring_t *val)
{
    ASN1uint32_t index;
    ASN1uint32_t flag;

    /* search identification */
    if (!ASN1EncSearchCharacterStringIdentification(((ASN1INTERNencoding_t) enc)->parent,
        &val->identification, &index, &flag))
        return 0;
    if (index > 255)
        flag = 1;

    if (flag)
    {
        ASN1uint32_t nLenOff_, nLenOff0, nLenOff1;

        /* CS-A encoding: */
        /* encode as constructed value */
        if (!ASN1BEREncExplicitTag(enc, tag, &nLenOff_))
            return 0;

        /* encode index */
        if (!ASN1BEREncU32(enc, 0x80000000, index))
            return 0;

        /* encode tag of identification */
        if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
            return 0;

        /* encode identification */
        switch (val->identification.o)
        {
        case ASN1characterstring_identification_syntaxes_o:
            if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff1))
                return 0;
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000000,
                &val->identification.u.syntaxes.abstract))
                return 0;
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000001,
                &val->identification.u.syntaxes.transfer))
                return 0;
            if (!ASN1BEREncEndOfContents(enc, nLenOff1))
                return 0;
            break;
        case ASN1characterstring_identification_syntax_o:
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000001,
                &val->identification.u.syntax))
                return 0;
            break;
        case ASN1characterstring_identification_presentation_context_id_o:
            if (!ASN1BEREncU32(enc, 0x80000002,
                val->identification.u.presentation_context_id))
                return 0;
            break;
        case ASN1characterstring_identification_context_negotiation_o:
            if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff1))
                return 0;
            if (!ASN1BEREncU32(enc, 0x80000000, val->
                identification.u.context_negotiation.presentation_context_id))
                return 0;
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000001,
                &val->identification.u.context_negotiation.transfer_syntax))
                return 0;
            if (!ASN1BEREncEndOfContents(enc, nLenOff1))
                return 0;
            break;
        case ASN1characterstring_identification_transfer_syntax_o:
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000004,
                &val->identification.u.transfer_syntax))
                return 0;
            break;
        case ASN1characterstring_identification_fixed_o:
            if (!ASN1BEREncNull(enc, 0x80000005))
                return 0;
            break;
        default:
            ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
            return 0;
        }

        /* end of identification */
        if (!ASN1BEREncEndOfContents(enc, nLenOff0))
            return 0;

        /* encode data value */
        switch (val->data_value.o)
        {
        case ASN1characterstring_data_value_notation_o:
            if (!ASN1BEREncOctetString(enc, 0x80000002,
                val->data_value.u.notation.length,
                val->data_value.u.notation.encoded))
                return 0;
            break;
        case ASN1characterstring_data_value_encoded_o:
            if (!ASN1BEREncOctetString(enc, 0x80000002,
                val->data_value.u.encoded.length,
                val->data_value.u.encoded.value))
                return 0;
            break;
        default:
            ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
            return 0;
        }

        /* end of character string */
        if (!ASN1BEREncEndOfContents(enc, nLenOff_))
            return 0;
    }
    else
    {
        /* CS-B encoding: */
        /* encode tag */
        if (!ASN1BEREncTag(enc, tag))
            return 0;

        /* encode data value */
        switch (val->data_value.o)
        {
        case ASN1characterstring_data_value_notation_o:
            if (!ASN1BEREncLength(enc,
                val->data_value.u.notation.length + 1))
                return 0;
            *enc->pos++ = (ASN1octet_t) index;
            CopyMemory(enc->pos, val->data_value.u.notation.encoded,
                val->data_value.u.notation.length);
            enc->pos += val->data_value.u.notation.length;
            break;
        case ASN1characterstring_data_value_encoded_o:
            if (!ASN1BEREncLength(enc,
                val->data_value.u.encoded.length + 1))
                return 0;
            *enc->pos++ = (ASN1octet_t) index;
            CopyMemory(enc->pos, val->data_value.u.encoded.value,
                val->data_value.u.encoded.length);
            enc->pos += val->data_value.u.encoded.length;
            break;
        default:
            ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
            return 0;
        }
    }
    return 1;
}
#endif // ENABLE_GENERALIZED_CHAR_STR

#ifdef ENABLE_DOUBLE
/* encode a real value */
int ASN1BEREncDouble(ASN1encoding_t enc, ASN1uint32_t tag, double d)
{
    double mantissa;
    int exponent;
    ASN1uint32_t nmoctets;
    ASN1uint32_t neoctets;
    ASN1octet_t head;
    ASN1uint32_t sign;
    ASN1uint32_t len;
    ASN1octet_t mASN1octets[16]; /* should be enough */
    ASN1octet_t eASN1octets[16]; /* should be enough */

    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* check for PLUS_INFINITY */
        if (ASN1double_ispinf(d))
        {
            /* encode length */
            if (ASN1BEREncLength(enc, 1))
            {
                /* encode value */
                *enc->pos++ = 0x40;
                return 1;
            }
        }
        else
        /* check for MINUS_INFINITY */
        if (ASN1double_isminf(d))
        {
            /* encode length */
            if (ASN1BEREncLength(enc, 1))
            {
                /* encode value */
                *enc->pos++ = 0x41;
                return 1;
            }
        }
        else
        /* check for bad real value */
        if (finite(d))
        {
            /* encode normal real value */

            /* split into mantissa and exponent */
            mantissa = frexp(d, &exponent);

            /* check for zero value */
            if (mantissa == 0.0 && exponent == 0)
            {
                /* encode zero length */
                return ASN1BEREncLength(enc, 0);
            }

            /* get sign bit */
            if (mantissa < 0.0)
            {
                sign = 1;
                mantissa = -mantissa;
            }
            else
            {
                sign = 0;
            }

            /* encode mantissa */
            nmoctets = 0;
            while (mantissa != 0.0 && nmoctets < sizeof(mASN1octets))
            {
                mantissa *= 256.0;
                exponent -= 8;
                mASN1octets[nmoctets++] = (int)mantissa;
                mantissa -= (double)(int)mantissa;
            }

            /* encode exponent and create head octet of encoded value */
            head = (ASN1octet_t) (0x80 | (sign << 6));
            if (exponent <= 0x7f && exponent >= -0x80)
            {
                eASN1octets[0] = (ASN1octet_t)(exponent);
                neoctets = 1;
            }
            else
            if (exponent <= 0x7fff && exponent >= -0x8000)
            {
                eASN1octets[0] = (ASN1octet_t)(exponent >> 8);
                eASN1octets[1] = (ASN1octet_t)(exponent);
                neoctets = 2;
                head |= 0x01;
            }
            else
            if (exponent <= 0x7fffff && exponent >= -0x800000)
            {
                eASN1octets[0] = (ASN1octet_t)(exponent >> 16);
                eASN1octets[1] = (ASN1octet_t)(exponent >> 8);
                eASN1octets[2] = (ASN1octet_t)(exponent);
                neoctets = 3;
                head |= 0x02;
            }
            else
            {
                eASN1octets[0] = 4; /* XXX does not work if ASN1int32_t != int */
                eASN1octets[1] = (ASN1octet_t)(exponent >> 24);
                eASN1octets[2] = (ASN1octet_t)(exponent >> 16);
                eASN1octets[3] = (ASN1octet_t)(exponent >> 8);
                eASN1octets[4] = (ASN1octet_t)(exponent);
                neoctets = 5;
                head |= 0x03;
            }

            /* encode length into first octet */
            len = 1 + neoctets + nmoctets;
            if (ASN1BEREncLength(enc, len))
            {
                /* put head octet, mantissa and exponent */
                *enc->pos++ = head;
                CopyMemory(enc->pos, eASN1octets, neoctets);
                enc->pos += neoctets;
                CopyMemory(enc->pos, mASN1octets, nmoctets);
                enc->pos += nmoctets;
                return 1;
            }
        }
        else
        {
            ASN1EncSetError(enc, ASN1_ERR_BADREAL);
        }
    }
    /* finished */
    return 0;
}
#endif // ENABLE_DOUBLE

#ifdef ENABLE_REAL
/* encode a real value */
int ASN1BEREncReal(ASN1encoding_t enc, ASN1uint32_t tag, ASN1real_t *val)
{
    ASN1intx_t mantissa;
    ASN1intx_t exponent;
    ASN1intx_t help;
    ASN1uint32_t nmoctets;
    ASN1uint32_t neoctets;
    ASN1octet_t head;
    ASN1uint32_t sign;
    ASN1uint32_t len;
    ASN1octet_t mASN1octets[256]; /* should be enough */
    ASN1octet_t eASN1octets[256]; /* should be enough */

    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* check for PLUS_INFINITY */
        if (val->type == eReal_PlusInfinity)
        {
            /* encode length */
            if (ASN1BEREncLength(enc, 1))
            {
                /* encode value */
                *enc->pos++ = 0x40;
                return 1;
            }
        }
        else
        /* check for MINUS_INFINITY */
        if (val->type == eReal_MinusInfinity)
        {
            /* encode length */
            if (ASN1BEREncLength(enc, 1))
            {
                /* encode value */
                *enc->pos++ = 0x41;
                return 1;
            }
        }
        /* encode normal real value */
        else
        {
            /* check for zero value */
            if (!ASN1intx_cmp(&val->mantissa, &ASN1intx_0))
            {
                /* encode zero length */
                return ASN1BEREncLength(enc, 0);
            }

            /* get sign bit */
            if (val->mantissa.value[0] > 0x7f)
            {
                sign = 1;
                ASN1intx_neg(&mantissa, &val->mantissa);
            }
            else
            {
                sign = 0;
                if (! ASN1intx_dup(&mantissa, &val->mantissa))
                {
                    return 0;
                }
            }
            if (! ASN1intx_dup(&exponent, &val->exponent))
            {
                return 0;
            }

            /* encode mantissa */
            nmoctets = ASN1intx_uoctets(&mantissa);
            if (nmoctets < 256)
            {
                CopyMemory(mASN1octets,
                    mantissa.value + mantissa.length - nmoctets,
                    nmoctets);
                ASN1intx_setuint32(&help, 8 * nmoctets);
                ASN1intx_sub(&exponent, &exponent, &help);
                ASN1intx_free(&mantissa);
                ASN1intx_free(&help);

                /* encode exponent and create head octet of encoded value */
                neoctets = ASN1intx_octets(&exponent);
                if (neoctets < 256)
                {
                    CopyMemory(mASN1octets,
                        val->exponent.value + val->exponent.length - neoctets,
                        neoctets);
                    ASN1intx_free(&exponent);
                    head = (ASN1octet_t) (0x80 | (sign << 6) | (neoctets - 1));

                    /* encode length into first octet */
                    len = 1 + neoctets + nmoctets;
                    if (ASN1BEREncLength(enc, len))
                    {
                        /* put head octet, mantissa and exponent */
                        *enc->pos++ = head;
                        CopyMemory(enc->pos, eASN1octets, neoctets);
                        enc->pos += neoctets;
                        CopyMemory(enc->pos, mASN1octets, nmoctets);
                        enc->pos += nmoctets;
                        return 1;
                    }
                }
                else
                {
                    ASN1intx_free(&exponent);
                    ASN1EncSetError(enc, ASN1_ERR_LARGE);
                }
            }
            else
            {
                ASN1intx_free(&mantissa);
                ASN1intx_free(&help);
                ASN1EncSetError(enc, ASN1_ERR_LARGE);
            }
        }
    }
    /* finished */
    return 0;
}
#endif // ENABLE_REAL

#ifdef ENABLE_EMBEDDED_PDV
/* encode an embedded pdv value */
int ASN1BEREncEmbeddedPdv(ASN1encoding_t enc, ASN1uint32_t tag, ASN1embeddedpdv_t *val)
{
    ASN1uint32_t index;
    ASN1uint32_t flag;

    /* search identification */
    if (!ASN1EncSearchEmbeddedPdvIdentification(((ASN1INTERNencoding_t) enc)->parent,
        &val->identification, &index, &flag))
        return 0;
    if (index > 255 ||
            (val->data_value.o == ASN1embeddedpdv_data_value_encoded_o &&
        (val->data_value.u.encoded.length & 7))) {
        flag = 1;
    }
        
    if (flag)
    {
        ASN1uint32_t nLenOff_, nLenOff0, nLenOff1;

        /* EP-A encoding: */
        /* encode as construct value */
        if (!ASN1BEREncExplicitTag(enc, tag, &nLenOff_))
            return 0;

        /* encode index */
        if (!ASN1BEREncU32(enc, 0x80000000, index))
            return 0;

        /* encode tag of identification */
        if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
            return 0;

        /* encode identification */
        switch (val->identification.o)
        {
        case ASN1embeddedpdv_identification_syntaxes_o:
            if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff1))
                return 0;
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000000,
                &val->identification.u.syntaxes.abstract))
                return 0;
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000001,
                &val->identification.u.syntaxes.transfer))
                return 0;
            if (!ASN1BEREncEndOfContents(enc, nLenOff1))
                return 0;
            break;
        case ASN1embeddedpdv_identification_syntax_o:
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000001,
                &val->identification.u.syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_presentation_context_id_o:
            if (!ASN1BEREncU32(enc, 0x80000002,
                val->identification.u.presentation_context_id))
                return 0;
            break;
        case ASN1embeddedpdv_identification_context_negotiation_o:
            if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff1))
                return 0;
            if (!ASN1BEREncU32(enc, 0x80000000, val->
                identification.u.context_negotiation.presentation_context_id))
                return 0;
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000001,
                &val->identification.u.context_negotiation.transfer_syntax))
                return 0;
            if (!ASN1BEREncEndOfContents(enc, nLenOff1))
                return 0;
            break;
        case ASN1embeddedpdv_identification_transfer_syntax_o:
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000004,
                &val->identification.u.transfer_syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_fixed_o:
            if (!ASN1BEREncNull(enc, 0x80000005))
                return 0;
            break;
        default:
            ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
            return 0;
        }

        /* end of identification */
        if (!ASN1BEREncEndOfContents(enc, nLenOff0))
            return 0;

        /* encode data value */
        switch (val->data_value.o)
        {
        case ASN1embeddedpdv_data_value_notation_o:
            if (!ASN1BEREncBitString(enc, 0x80000002,
                val->data_value.u.notation.length * 8,
                val->data_value.u.notation.encoded))
                return 0;
            break;
        case ASN1embeddedpdv_data_value_encoded_o:
            if (!ASN1BEREncBitString(enc, 0x80000002,
                val->data_value.u.encoded.length,
                val->data_value.u.encoded.value))
                return 0;
            break;
        default:
            ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
            return 0;
        }

        /* end of embedded pdv */
        if (!ASN1BEREncEndOfContents(enc, nLenOff_))
            return 0;
    }
    else
    {
        /* EP-B encoding: */
        /* encode tag */
        if (!ASN1BEREncTag(enc, tag))
            return 0;

        /* encode data value */
        switch (val->data_value.o)
        {
        case ASN1embeddedpdv_data_value_notation_o:
            if (!ASN1BEREncLength(enc,
                val->data_value.u.notation.length + 1))
                return 0;
            *enc->pos++ = (ASN1octet_t) index;
            CopyMemory(enc->pos, val->data_value.u.notation.encoded,
                val->data_value.u.notation.length);
            enc->pos += val->data_value.u.notation.length;
            break;
        case ASN1embeddedpdv_data_value_encoded_o:
            if (!ASN1BEREncLength(enc,
                val->data_value.u.encoded.length / 8 + 1))
                return 0;
            *enc->pos++ = (ASN1octet_t) index;
            CopyMemory(enc->pos, val->data_value.u.encoded.value,
                val->data_value.u.encoded.length / 8);
            enc->pos += val->data_value.u.encoded.length / 8;
            break;
        default:
            ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
            return 0;
        }
    }
    return 1;
}
#endif // ENABLE_EMBEDDED_PDV


#ifdef ENABLE_EXTERNAL
/* encode an external value */
int ASN1BEREncExternal(ASN1encoding_t enc, ASN1uint32_t tag, ASN1external_t *val)
{
    ASN1uint32_t t;
    ASN1uint32_t nLenOff_, nLenOff0;

    if (!val->data_value_descriptor)
        val->o[0] &= ~0x80;

    /* encode tag */
    if (!ASN1BEREncExplicitTag(enc, tag, &nLenOff_))
        return 0;

    /* encode identification */
    switch (val->identification.o) {
    case ASN1external_identification_syntax_o:
        if (!ASN1BEREncObjectIdentifier(enc, 0x6,
            &val->identification.u.syntax))
            return 0;
        break;
    case ASN1external_identification_presentation_context_id_o:
        if (!ASN1BEREncU32(enc, 0x2,
            val->identification.u.presentation_context_id))
            return 0;
        break;
    case ASN1external_identification_context_negotiation_o:
        if (!ASN1BEREncObjectIdentifier(enc, 0x6,
            &val->identification.u.context_negotiation.transfer_syntax))
            return 0;
        if (!ASN1BEREncU32(enc, 0x2,
            val->identification.u.context_negotiation.presentation_context_id))
            return 0;
        break;
    default:
        ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
        return 0;
    }

    /* encode data value descriptor if present */
    if (val->o[0] & 0x80) {
        t = My_lstrlenA(val->data_value_descriptor);
        if (!ASN1BEREncCharString(enc, 0x7, t, val->data_value_descriptor))
            return 0;
    }

    /* encode data value */
    switch (val->data_value.o)
    {
    case ASN1external_data_value_notation_o:
        if (!ASN1BEREncExplicitTag(enc, 0, &nLenOff0))
            return 0;
        if (!ASN1BEREncOpenType(enc, &val->data_value.u.notation))
            return 0;
        if (!ASN1BEREncEndOfContents(enc, nLenOff0))
            return 0;
        break;
    case ASN1external_data_value_encoded_o:
        if (!(val->data_value.u.encoded.length & 7))
        {
            if (!ASN1BEREncExplicitTag(enc, 1, &nLenOff0))
                return 0;
            if (!ASN1BEREncOctetString(enc, 0x4,
                val->data_value.u.encoded.length / 8,
                val->data_value.u.encoded.value))
                return 0;
            if (!ASN1BEREncEndOfContents(enc, nLenOff0))
                return 0;
        }
        else
        {
            if (!ASN1BEREncExplicitTag(enc, 2, &nLenOff0))
                return 0;
            if (!ASN1BEREncBitString(enc, 0x3,
                val->data_value.u.encoded.length,
                val->data_value.u.encoded.value))
                return 0;
            if (!ASN1BEREncEndOfContents(enc, nLenOff0))
                return 0;
        }
        break;
    default:
        ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
        return 0;
    }

    /* end of external value */
    return ASN1BEREncEndOfContents(enc, nLenOff_);
}
#endif // ENABLE_EXTERNAL

/* encode a generalized time value */
int ASN1BEREncGeneralizedTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1generalizedtime_t *val)
{
    char time[32];
    ASN1generalizedtime2string(time, val);
    return ASN1BEREncCharString(enc, tag, My_lstrlenA(time), time);
}

/* encode a generalized time value (CER) */
int ASN1CEREncGeneralizedTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1generalizedtime_t *val)
{
    char time[32];
    ASN1generalizedtime2string(time, val);
    return ASN1CEREncCharString(enc, tag, My_lstrlenA(time), time);
}

/* encode a signed integer value */
int ASN1BEREncS32(ASN1encoding_t enc, ASN1uint32_t tag, ASN1int32_t val)
{
    if (ASN1BEREncTag(enc, tag))
    {
        if (val >= -0x8000 && val < 0x8000)
        {
            if (val >= -0x80 && val < 0x80)
            {
                if (ASN1BEREncLength(enc, 1))
                {
                    *enc->pos++ = (ASN1octet_t)(val);
                    return 1;
                }
            }
            else
            {
                if (ASN1BEREncLength(enc, 2))
                {
                    *enc->pos++ = (ASN1octet_t)(val >> 8);
                    *enc->pos++ = (ASN1octet_t)(val);
                    return 1;
                }
            }
        }
        else
        {
            if (val >= -0x800000 && val < 0x800000)
            {
                if (ASN1BEREncLength(enc, 3))
                {
                    *enc->pos++ = (ASN1octet_t)(val >> 16);
                    *enc->pos++ = (ASN1octet_t)(val >> 8);
                    *enc->pos++ = (ASN1octet_t)(val);
                    return 1;
                }
            }
            else
            {
                if (ASN1BEREncLength(enc, 4))
                {
                    *enc->pos++ = (ASN1octet_t)(val >> 24);
                    *enc->pos++ = (ASN1octet_t)(val >> 16);
                    *enc->pos++ = (ASN1octet_t)(val >> 8);
                    *enc->pos++ = (ASN1octet_t)(val);
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* encode a intx_t integer value */
int ASN1BEREncSX(ASN1encoding_t enc, ASN1uint32_t tag, ASN1intx_t *val)
{
    ASN1uint32_t cb;
    ASN1octet_t *p;

    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        // strip out leading 0 and ff.
        for (cb = val->length, p = val->value; cb > 1; cb--, p++)
        {
			// break if not 00 nor FF
            if (*p && *p != 0xFF)
            {
                break;
            }
			// break if 00 FF
			if ((! *p) && (*(p+1) & 0x80))
			{
				break;
			}
			// break if FF 7F
			if (*p == 0xFF && (!(*(p+1) & 0x80)))
			{
				break;
			}
        }

        /* encode length */
        if (ASN1BEREncLength(enc, cb))
        {
            /* copy value */
            CopyMemory(enc->pos, p, cb);
            enc->pos += cb;
            return 1;
        }
    }
    return 0;
}

/* encode a multibyte string value */
int ASN1BEREncZeroMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1ztcharstring_t val)
{
    return ASN1BEREncCharString(enc, tag, My_lstrlenA(val), val);
}

int ASN1BEREncMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1charstring_t *val)
{
    return ASN1BEREncCharString(enc, tag, val->length, val->value);
}

/* encode a multibyte string value (CER) */
int ASN1CEREncZeroMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1ztcharstring_t val)
{
    return ASN1CEREncCharString(enc, tag, My_lstrlenA(val), val);
}

int ASN1CEREncMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1charstring_t *val)
{
    return ASN1CEREncCharString(enc, tag, val->length, val->value);
}

/* encode a null value */
int ASN1BEREncNull(ASN1encoding_t enc, ASN1uint32_t tag)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* encode zero length */
        return ASN1BEREncLength(enc, 0);
    }
    return 0;
}

// encode an oid node s to buffer pointed by p
ASN1octet_t *_BEREncOidNode(ASN1octet_t *p, ASN1uint32_t s)
{
    if (s < 0x80)
    {
        *p++ = (ASN1octet_t)(s);
    }
    else
    if (s < 0x4000)
    {
        *p++ = (ASN1octet_t)((s >> 7) | 0x80);
        *p++ = (ASN1octet_t)(s & 0x7f);
    }
    else
    if (s < 0x200000)
    {
        *p++ = (ASN1octet_t)((s >> 14) | 0x80);
        *p++ = (ASN1octet_t)((s >> 7) | 0x80);
        *p++ = (ASN1octet_t)(s & 0x7f);
    }
    else
    if (s < 0x10000000)
    {
        *p++ = (ASN1octet_t)((s >> 21) | 0x80);
        *p++ = (ASN1octet_t)((s >> 14) | 0x80);
        *p++ = (ASN1octet_t)((s >> 7) | 0x80);
        *p++ = (ASN1octet_t)(s & 0x7f);
    }
    else
    {
        *p++ = (ASN1octet_t)((s >> 28) | 0x80);
        *p++ = (ASN1octet_t)((s >> 21) | 0x80);
        *p++ = (ASN1octet_t)((s >> 14) | 0x80);
        *p++ = (ASN1octet_t)((s >> 7) | 0x80);
        *p++ = (ASN1octet_t)(s & 0x7f);
    }
    return p;
}

/* encode an object identifier value */
int ASN1BEREncObjectIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, ASN1objectidentifier_t *val)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        ASN1objectidentifier_t obj = *val;
        ASN1uint32_t i, s, l, *v;
        ASN1octet_t *data, *p;

        l = GetObjectIdentifierCount(obj);
        if (l)
        {
            /* convert object identifier to octets */
            p = data = (ASN1octet_t *)MemAlloc(l * 5, _ModName(enc)); /* max. 5 octets/subelement */
            if (p)
            {
                int rc;
                for (i = 0; i < l; i++)
                {
                    s = obj->value;
                    obj = obj->next;
                    if (!i && l > 1)
                    {
                        s = s * 40 + obj->value;
                        obj = obj->next;
                        i++;
                    }
                    p = _BEREncOidNode(p, s);
                } // for

                /* encode length */
                rc = ASN1BEREncLength(enc, (ASN1uint32_t) (p - data));
                if (rc)
                {
                    /* copy value */
                    CopyMemory(enc->pos, data, p - data);
                    enc->pos += p - data;
                }
                MemFree(data);
                return rc;
            }
            ASN1EncSetError(enc, ASN1_ERR_MEMORY);
            return 0;
        } // if (l)
        /* encode zero length */
        return ASN1BEREncLength(enc, 0);
    }
    return 0;
}

/* encode an object identifier value */
int ASN1BEREncObjectIdentifier2(ASN1encoding_t enc, ASN1uint32_t tag, ASN1objectidentifier2_t *val)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        ASN1uint32_t i, s;
        ASN1octet_t *data, *p;

        if (val->count)
        {
            /* convert object identifier to octets */
            p = data = (ASN1octet_t *)MemAlloc(val->count * 5, _ModName(enc)); /* max. 5 octets/subelement */
            if (p)
            {
                int rc;
                for (i = 0; i < val->count; i++)
                {
                    s = val->value[i];
                    if (!i && val->count > 1)
                    {
                        i++;
                        s = s * 40 + val->value[i];
                    }
                    p = _BEREncOidNode(p, s);
                } // for

                /* encode length */
                rc = ASN1BEREncLength(enc, (ASN1uint32_t) (p - data));
                if (rc)
                {
                    /* copy value */
                    CopyMemory(enc->pos, data, p - data);
                    enc->pos += p - data;
                }
                MemFree(data);
                return rc;
            }
            ASN1EncSetError(enc, ASN1_ERR_MEMORY);
            return 0;
        } // if (l)
        /* encode zero length */
        return ASN1BEREncLength(enc, 0);
    }
    return 0;
}

/* encode an octet string value (CER) */
int ASN1CEREncOctetString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val)
{
    ASN1uint32_t n;

    if (len <= 1000)
    {
        /* encode tag */
        if (ASN1BEREncTag(enc, tag))
        {
            /* encode length */
            if (ASN1BEREncLength(enc, len))
            {
                /* copy value */
                CopyMemory(enc->pos, val, len);
                enc->pos += len;
                return 1;
            }
        }
    }
    else
    {
        ASN1uint32_t nLenOff;
        /* encode value as constructed, using segments of 1000 octets */
        if (ASN1BEREncExplicitTag(enc, tag, &nLenOff))
        {
            while (len)
            {
                n = len > 1000 ? 1000 : len;
                if (ASN1BEREncTag(enc, 0x4))
                {
                    if (ASN1BEREncLength(enc, n))
                    {
                        CopyMemory(enc->pos, val, n);
                        enc->pos += n;
                        val += n;
                        len -= n;
                    }
                    else
                    {
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            }
            return ASN1BEREncEndOfContents(enc, nLenOff);
        }
    }
    return 0;
}

/* encode an open type value */
int ASN1BEREncOpenType(ASN1encoding_t enc, ASN1open_t *val)
{
    if (ASN1BEREncCheck(enc, val->length))
    {
        /* copy value */
        CopyMemory(enc->pos, val->encoded, val->length);
        enc->pos += val->length;
        return 1;
    }
    return 0;
}

/* remove trailing zero bits from bit string */
int ASN1BEREncRemoveZeroBits(ASN1uint32_t *nbits, ASN1octet_t *val)
{
    ASN1uint32_t n;
    int i;

    /* get value */
    n = *nbits;

    /* let val point to last ASN1octet used */
    val += (n - 1) / 8;

    /* check if broken ASN1octet consist out of zero bits */
    if ((n & 7) && !(*val & bitmsk2[n & 7]))
    {
        n &= ~7;
        val--;
    }

    /* scan complete ASN1octets (memcchr missing ...) */
    if (!(n & 7))
    {
        while (n && !*val)
        {
            n -= 8;
            val--;
        }
    }

    /* scan current ASN1octet bit after bit */
    if (n)
    {
        for (i = (n - 1) & 7; i >= 0; i--)
        {
            if (*val & (0x80 >> i))
                break;
            n--;
        }
    }

    /* return real bitstring len */
    *nbits = n;
    return 1;
}

/* encode an utc time value */
int ASN1BEREncUTCTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1utctime_t *val)
{
    char time[32];
    ASN1utctime2string(time, val);
    return ASN1BEREncCharString(enc, tag, My_lstrlenA(time), time);
}

/* encode an utc time value (CER) */
int ASN1CEREncUTCTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1utctime_t *val)
{
    char time[32];
    ASN1utctime2string(time, val);
    return ASN1CEREncCharString(enc, tag, My_lstrlenA(time), time);
}

/* end of encoding */
int ASN1BEREncFlush(ASN1encoding_t enc)
{
    /* allocate at least one octet */
    if (enc->buf)
    {
        /* fill in zero-octet if encoding is empty bitstring */
        if (enc->buf == enc->pos)
            *enc->pos++ = 0;

        /* calculate length */
        enc->len = (ASN1uint32_t) (enc->pos - enc->buf);
        return 1;
    }
    return ASN1BEREncCheck(enc, 1);
}

#endif // ENABLE_BER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\msasn1\char.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"


/* check if a 16 bit character is a space */
int ASN1is16space(ASN1char16_t c)
{
    return c == ' ' || c == '\t' || c == '\b' || c == '\f' || c == '\r' ||
	c == '\n' || c == '\v';
}

/* get length of a 16 bit string */
// lonchanc: lstrlenW()
int ASN1str16len(ASN1char16_t *p)
{
    
    int len;

    for (len = 0; *p; p++)
        len++;
    return len;
}

int My_lstrlenA(char *p)
{
    return (NULL != p) ? lstrlenA(p) : 0;
}

int My_lstrlenW(WCHAR *p)
{
    return (NULL != p) ? lstrlenW(p) : 0;
}

/* check if a 32 bit character is a space */
int ASN1is32space(ASN1char32_t c)
{
    return c == ' ' || c == '\t' || c == '\b' || c == '\f' || c == '\r' ||
            c == '\n' || c == '\v';
}

/* get length of a 32 bit string */
int ASN1str32len(ASN1char32_t *p)
{
    int len;

    for (len = 0; *p; p++)
        len++;
    return len;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\msasn1\cintern.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#ifndef _ASN1_CINTERN_H_
#define _ASN1_CINTERN_H_


typedef struct ASN1INTERNencoding_s *ASN1INTERNencoding_t;
typedef struct ASN1INTERNdecoding_s *ASN1INTERNdecoding_t;

// lonchanc: this is really bad to duplicate the definitions of ASN1encoding_s
// and ASN1decoding_s here. We sould simply use them as components in
// the following ASN1INTERNencoding_s and ASN1INTERNdecoding_s.

struct ASN1INTERNencoding_s {

    // public view of encoding structure
    struct ASN1encoding_s       info;

    // private portion of encoding structure
    ASN1INTERNencoding_t        parent;
    ASN1INTERNencoding_t        child;

#ifdef ENABLE_EXTRA_INFO
    ASN1uint32_t				memlength;
    ASN1uint32_t				memsize;
    void**					    mem;
    ASN1uint32_t				epilength;
    ASN1uint32_t				episize;
    ASN1embeddedpdv_identification_t**		epi;
    ASN1uint32_t				csilength;
    ASN1uint32_t				csisize;
    ASN1characterstring_identification_t**	csi;
#endif // ENABLE_EXTRA_INFO
};

struct ASN1INTERNdecoding_s {

    // public view of decoding structure
    struct ASN1decoding_s       info;

    // private portion of decoding structure
    ASN1INTERNdecoding_t        parent;
    ASN1INTERNdecoding_t        child;

#ifdef ENABLE_EXTRA_INFO
    ASN1uint32_t				memlength;
    ASN1uint32_t				memsize;
    void**					    mem;
    ASN1uint32_t				epilength;
    ASN1uint32_t				episize;
    ASN1embeddedpdv_identification_t**		epi;
    ASN1uint32_t				csilength;
    ASN1uint32_t				csisize;
    ASN1characterstring_identification_t**	csi;
#endif // ENABLE_EXTRA_INFO

    // decoded into an external buffer
    ASN1uint32_t                fExtBuf;
    void*                       lpOrigExtBuf;    // original buffer pointer
    ASN1uint32_t                cbOrigExtBufSize;// original buffer size
    ASN1uint8_t*                lpRemExtBuf;     // remaining buffer pointer
    ASN1uint32_t                cbRemExtBufSize; // remaining buffer size
    ASN1uint32_t                cbLinearBufSize; // linear buffer size to hold the data
};

extern ASN1_PUBLIC void ASN1API ASN1DecAbort(ASN1decoding_t dec);
extern ASN1_PUBLIC void ASN1API ASN1DecDone(ASN1decoding_t dec);
extern ASN1_PUBLIC void ASN1API ASN1EncAbort(ASN1encoding_t enc);
extern ASN1_PUBLIC void ASN1API ASN1EncDone(ASN1encoding_t enc);

#ifdef ENABLE_GENERALIZED_CHAR_STR
int ASN1EncSearchCharacterStringIdentification(ASN1INTERNencoding_t e, ASN1characterstring_identification_t *identification, ASN1uint32_t *index, ASN1uint32_t *flag);
int ASN1DecAddCharacterStringIdentification(ASN1INTERNdecoding_t d, ASN1characterstring_identification_t *identification);
ASN1characterstring_identification_t *ASN1DecGetCharacterStringIdentification(ASN1INTERNdecoding_t d, ASN1uint32_t index);
#endif // ENABLE_GENERALIZED_CHAR_STR

#ifdef ENABLE_EMBEDDED_PDV
int ASN1EncSearchEmbeddedPdvIdentification(ASN1INTERNencoding_t e, ASN1embeddedpdv_identification_t *identification, ASN1uint32_t *index, ASN1uint32_t *flag);
int ASN1DecAddEmbeddedPdvIdentification(ASN1INTERNdecoding_t d, ASN1embeddedpdv_identification_t *identification);
ASN1embeddedpdv_identification_t *ASN1DecGetEmbeddedPdvIdentification(ASN1INTERNdecoding_t d, ASN1uint32_t index);
#endif // ENABLE_EMBEDDED_PDV

int ASN1DecDupObjectIdentifier(ASN1decoding_t dec, ASN1objectidentifier_t *dst, ASN1objectidentifier_t *src);

ASN1uint32_t GetObjectIdentifierCount(ASN1objectidentifier_t val);
ASN1uint32_t CopyObjectIdentifier(ASN1objectidentifier_t dst, ASN1objectidentifier_t src);
ASN1objectidentifier_t DecAllocObjectIdentifier(ASN1decoding_t dec, ASN1uint32_t cObjIds);
void DecFreeObjectIdentifier(ASN1decoding_t dec, ASN1objectidentifier_t p);


/* ------ perencod.c ------ */

int ASN1EncCheck(ASN1encoding_t enc, ASN1uint32_t noctets);
__inline int ASN1PEREncCheck(ASN1encoding_t enc, ASN1uint32_t noctets)
{
    return ASN1EncCheck(enc, noctets);
}
__inline int ASN1BEREncCheck(ASN1encoding_t enc, ASN1uint32_t noctets)
{
    return ASN1EncCheck(enc, noctets);
}

/* ------ bit.c ------ */

int ASN1is32space(ASN1char32_t);
int ASN1str32len(ASN1char32_t *);
int ASN1is16space(ASN1char16_t);
int ASN1str16len(ASN1char16_t *);
int My_lstrlenA(char *p);
int My_lstrlenW(WCHAR *p);
void ASN1bitcpy(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits);
void ASN1bitclr(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1uint32_t nbits);
void ASN1bitset(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1uint32_t nbits);
void ASN1bitput(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1uint32_t val, ASN1uint32_t nbits);
ASN1uint32_t ASN1bitgetu(ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits);
ASN1int32_t ASN1bitget(ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits);
ASN1uint32_t ASN1bitcount(ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits);
void ASN1octetput(ASN1octet_t *dst, ASN1uint32_t val, ASN1uint32_t noctets);
ASN1uint32_t ASN1octetget(ASN1octet_t *src, ASN1uint32_t noctets);


#endif /* _ASN1_CINTERN_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\msasn1\berdecod.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

#ifdef ENABLE_BER

#include <math.h>

static const char bitmsk2[] =
{
    (const char) 0x00,
    (const char) 0x80,
    (const char) 0xc0,
    (const char) 0xe0,
    (const char) 0xf0,
    (const char) 0xf8,
    (const char) 0xfc,
    (const char) 0xfe
};


/* decode bit string value */
int _BERDecBitString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bitstring_t *val, ASN1uint32_t fNoCopy)
{
    ASN1uint32_t constructed, len, infinite;
    ASN1bitstring_t b;
    ASN1decoding_t dd;
    ASN1octet_t *di;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (constructed)
            {
                /* constructed? then start decoding of constructed value */
                val->length = 0;
                if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                {
                    while (ASN1BERDecNotEndOfContents(dd, di))
                    {
                        if (_BERDecBitString(dd, 0x3, &b, fNoCopy))
                        {
                            if (b.length)
                            {
                                if (fNoCopy)
                                {
                                    *val = b;
                                    break; // break out the loop because nocopy cannot have multiple constructed streams
                                }

                                /* resize value */
                                val->value = (ASN1octet_t *)DecMemReAlloc(dd, val->value,
                                    (val->length + b.length + 7) / 8);
                                if (val->value)
                                {
                                    /* concat bit strings */
                                    ASN1bitcpy(val->value, val->length, b.value, 0, b.length);
                                    val->length += b.length;
                                    if (val->length & 7)
                                        val->value[val->length / 8] &= bitmsk2[val->length & 7];

                                    /* free unused bit string */
                                    DecMemFree(dec, b.value);
                                }
                                else
                                {
                                    return 0;
                                }
                            }
                        }
                    } // while
                    return ASN1BERDecEndOfContents(dec, dd, di);
                }
            }
            else
            {
                /* primitive? then copy value */
                if (!len)
                {
                    val->length = 0;
                    val->value = NULL;
                    return 1;
                }
                else
                {
                    if (*dec->pos < 8)
                    {
                        len--; // skip over the initial octet; len is now the actual length of octets
                        val->length = len * 8 - *dec->pos++;
                        if (fNoCopy)
                        {
                            val->value = dec->pos;
                            dec->pos += len;
                            return 1;
                        }
                        else
                        {
                            if (val->length)
                            {
                                val->value = (ASN1octet_t *)DecMemAlloc(dec, (val->length + 7) / 8);
                                if (val->value)
                                {
                                    CopyMemory(val->value, dec->pos, len);
                                    if (val->length & 7)
                                        val->value[len - 1] &= bitmsk2[val->length & 7];
                                    dec->pos += len;
                                    return 1;
                                }
                            }
                            else
                            {
                                val->value = NULL;
                                return 1;
                            }
                        }
                    }
                    else
                    {
                        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                    }
                }
            }
        }
    }
    return 0;
}

/* decode bit string value, making copy */
int ASN1BERDecBitString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bitstring_t *val)
{
    return _BERDecBitString(dec, tag, val, FALSE);
}

/* decode bit string value, no copy */
int ASN1BERDecBitString2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bitstring_t *val)
{
    return _BERDecBitString(dec, tag, val, TRUE);
}

/* decode string value */
int ASN1BERDecCharString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1charstring_t *val)
{
    ASN1uint32_t constructed, len, infinite;
    ASN1charstring_t c;
    ASN1decoding_t dd;
    ASN1octet_t *di;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (constructed)
            {
                /* constructed? then start decoding of constructed value */
                val->length = 0;
                if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                {
                    while (ASN1BERDecNotEndOfContents(dd, di))
                    {
                        if (ASN1BERDecCharString(dd, 0x4, &c))
                        {
                            if (c.length)
                            {
                                /* resize value */
                                val->value = (char *)DecMemReAlloc(dd, val->value,
                                    val->length + c.length);
                                if (val->value)
                                {
                                    /* concat strings */
                                    CopyMemory(val->value + val->length, c.value, c.length);
                                    val->length += c.length;

                                    /* free unused string */
                                    DecMemFree(dec, c.value);
                                }
                                else
                                {
                                    return 0;
                                }
                            }
                        }
                        else
                        {
                            return 0;
                        }
                    } // while
                    return ASN1BERDecEndOfContents(dec, dd, di);
                }
            }
            else
            {
                /* primitive? then copy value */
                val->length = len;
                if (len)
                {
                    val->value = (char *)DecMemAlloc(dec, len+1);
                    if (val->value)
                    {
                        CopyMemory(val->value, dec->pos, len);
                        dec->pos += len;
                        val->value[len] = 0;
                        return 1;
                    }
                }
                else
                {
                    val->value = NULL;
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* decode 16 bit string value */
int ASN1BERDecChar16String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1char16string_t *val)
{
    ASN1uint32_t constructed, len, infinite;
    ASN1char16string_t c;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t i;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (constructed)
            {
                /* constructed? then start decoding of constructed value */
                val->length = 0;
                if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                {
                    while (ASN1BERDecNotEndOfContents(dd, di))
                    {
                        if (ASN1BERDecChar16String(dd, 0x4, &c))
                        {
                            if (c.length)
                            {
                                /* resize value */
                                val->value = (ASN1char16_t *)DecMemReAlloc(dd, val->value,
                                    (val->length + c.length) * sizeof(ASN1char16_t));
                                if (val->value)
                                {
                                    /* concat strings */
                                    CopyMemory(val->value + val->length, c.value,
                                        c.length * sizeof(ASN1char16_t));
                                    val->length += c.length;

                                    /* free unused string */
                                    DecMemFree(dec, c.value);
                                }
                                else
                                {
                                    return 0;
                                }
                            }
                        }
                        else
                        {
                            return 0;
                        }
                    }
                    return ASN1BERDecEndOfContents(dec, dd, di);
                }
            }
            else
            {
                /* primitive? then copy value */
                DecAssert(dec, 2 * sizeof(ASN1octet_t) == sizeof(ASN1char16_t));
                len = len >> 1; // divided by 2
                val->length = len;
                if (len)
                {
                    val->value = (ASN1char16_t *)DecMemAlloc(dec, (len+1) * sizeof(ASN1char16_t));
                    if (val->value)
                    {
                        for (i = 0; i < len; i++)
                        {
                            val->value[i] = (*dec->pos << 8) | dec->pos[1];
                            dec->pos += 2;
                        }
                        val->value[len] = 0;
                        return 1;
                    }
                }
                else
                {
                    val->value = NULL;
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* decode 32 bit string value */
int ASN1BERDecChar32String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1char32string_t *val)
{
    ASN1uint32_t constructed, len, infinite;
    ASN1char32string_t c;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t i;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (constructed)
            {
                /* constructed? then start decoding of constructed value */
                val->length = 0;
                if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                {
                    while (ASN1BERDecNotEndOfContents(dd, di))
                    {
                        if (ASN1BERDecChar32String(dd, 0x4, &c))
                        {
                            if (c.length)
                            {
                                /* resize value */
                                val->value = (ASN1char32_t *)DecMemReAlloc(dd, val->value,
                                    (val->length + c.length) * sizeof(ASN1char32_t));
                                if (val->value)
                                {
                                    /* concat strings */
                                    CopyMemory(val->value + val->length, c.value,
                                        c.length * sizeof(ASN1char32_t));
                                    val->length += c.length;

                                    /* free unused string */
                                    DecMemFree(dec, c.value);
                                }
                                else
                                {
                                    return 0;
                                }
                            }
                        }
                        else
                        {
                            return 0;
                        }
                    }
                    return ASN1BERDecEndOfContents(dec, dd, di);
                }
            }
            else
            {
                /* primitive? then copy value */
                DecAssert(dec, 4 * sizeof(ASN1octet_t) == sizeof(ASN1char32_t));
                len = len >> 2; // divided by 4
                val->length = len;
                if (len)
                {
                    val->value = (ASN1char32_t *)DecMemAlloc(dec, (len+1) * sizeof(ASN1char32_t));
                    if (val->value)
                    {
                        for (i = 0; i < len; i++)
                        {
                            val->value[i] = (*dec->pos << 24) | (dec->pos[1] << 16) |
                                (dec->pos[2] << 8) | dec->pos[3];;
                            dec->pos += 4;
                        }
                        val->value[len] = 0;
                        return 1;
                    }
                }
                else
                {
                    val->value = NULL;
                    return 1;
                }
            }
        }
    }
    return 0;
}

#ifdef ENABLE_GENERALIZED_CHAR_STR
/* decode character string value */
int ASN1BERDecCharacterString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1characterstring_t *val)
{
    ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t) dec;
    ASN1uint32_t constructed, len, infinite;
    ASN1uint32_t index;
    ASN1characterstring_identification_t *identification;
    ASN1decoding_t dd, dd2, dd3;
    ASN1octet_t *di, *di2, *di3;

    /* skip tag */
    if (!ASN1BERDecTag(dec, tag, &constructed))
        return 0;

    if (constructed)
    {
        /* constructed? CS-A encoded: */
        /* get length */
        if (!ASN1BERDecLength(dec, &len, &infinite))
            return 0;

        /* start decoding of constructed value */
        if (! _BERDecConstructed(dec, len, infinite, &dd, &di))
            return 0;
        if (!ASN1BERDecU32Val(dd, 0x80000000, &index))
            return 0;
        if (index != d->parent->csilength)
        {
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }
        if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd2, &di2))
            return 0;
        if (!ASN1BERDecPeekTag(dd2, &tag))
            return 0;
        switch (tag)
        {
        case 0x80000000:
            val->identification.o =
                ASN1characterstring_identification_syntaxes_o;
            if (!ASN1BERDecExplicitTag(dd2, 0x80000000, &dd3, &di3))
                return 0;
            if (!ASN1BERDecObjectIdentifier(dd3, 0x80000000,
                &val->identification.u.syntaxes.abstract))
                return 0;
            if (!ASN1BERDecObjectIdentifier(dd3, 0x80000001,
                &val->identification.u.syntaxes.transfer))
                return 0;
            if (!ASN1BERDecEndOfContents(dd2, dd3, di3))
                return 0;
            break;
        case 0x80000001:
            val->identification.o = ASN1characterstring_identification_syntax_o;
            if (!ASN1BERDecObjectIdentifier(dd2, 0x80000001,
                &val->identification.u.syntax))
                return 0;
            break;
        case 0x80000002:
            val->identification.o =
                ASN1characterstring_identification_presentation_context_id_o;
            if (!ASN1BERDecU32Val(dd2, 0x80000002,
                &val->identification.u.presentation_context_id))
                return 0;
            break;
        case 0x80000003:
            val->identification.o =
                ASN1characterstring_identification_context_negotiation_o;
            if (!ASN1BERDecExplicitTag(dd2, 0x80000003, &dd3, &di3))
                return 0;
            if (!ASN1BERDecU32Val(dd3, 0x80000000, &val->
                identification.u.context_negotiation.presentation_context_id))
                return 0;
            if (!ASN1BERDecObjectIdentifier(dd3, 0x80000001,
                &val->identification.u.context_negotiation.transfer_syntax))
                return 0;
            if (!ASN1BERDecEndOfContents(dd2, dd3, di3))
                return 0;
            break;
        case 0x80000004:
            val->identification.o =
                ASN1characterstring_identification_transfer_syntax_o;
            if (!ASN1BERDecObjectIdentifier(dd2, 0x80000004,
                &val->identification.u.transfer_syntax))
                return 0;
            break;
        case 0x80000005:
            val->identification.o = ASN1characterstring_identification_fixed_o;
            if (!ASN1BERDecNull(dd2, 0x80000005))
                return 0;
            break;
        default:
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }
        if (!ASN1BERDecEndOfContents(dd, dd2, di2))
            return 0;
        if (!ASN1DecAddCharacterStringIdentification(d->parent,
            &val->identification))
            return 0;
        val->data_value.o = ASN1characterstring_data_value_encoded_o;
        if (!ASN1BERDecOctetString(dd, 0x80000003,
            &val->data_value.u.encoded))
            return 0;
        if (!ASN1BERDecEndOfContents(dec, dd, di))
            return 0;
    }
    else
    {
        /* primitive? CS-B encoded */
        /* get length */
        if (!ASN1BERDecLength(dec, &len, NULL))
            return 0;

        /* then copy value */
        if (!len)
        {
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }
        val->data_value.o = ASN1characterstring_data_value_encoded_o;
        val->data_value.u.encoded.length = len - 1;
        val->data_value.u.encoded.value = (ASN1octet_t *)DecMemAlloc(dec, len - 1);
        if (!val->data_value.u.encoded.value)
        {
            return 0;
        }
        index = *dec->pos++;
        CopyMemory(val->data_value.u.encoded.value, dec->pos, len - 1);
        identification = ASN1DecGetCharacterStringIdentification(d->parent,
            index);
        if (!identification)
            return 0;
        val->identification.o = identification->o;
        switch (identification->o)
        {
        case ASN1characterstring_identification_syntaxes_o:
            if (!ASN1DecDupObjectIdentifier(dec, 
                &val->identification.u.syntaxes.abstract,
                &identification->u.syntaxes.abstract))
                return 0;
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.syntaxes.transfer,
                &identification->u.syntaxes.transfer))
                return 0;
            break;
        case ASN1characterstring_identification_syntax_o:
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.syntax,
                &identification->u.syntax))
                return 0;
            break;
        case ASN1characterstring_identification_presentation_context_id_o:
            val->identification.u.presentation_context_id =
                identification->u.presentation_context_id;
            break;
        case ASN1characterstring_identification_context_negotiation_o:
            val->identification.u.context_negotiation.presentation_context_id =
                identification->u.context_negotiation.presentation_context_id;
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.context_negotiation.transfer_syntax,
                &identification->u.context_negotiation.transfer_syntax))
                return 0;
            break;
        case ASN1characterstring_identification_transfer_syntax_o:
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.transfer_syntax,
                &identification->u.transfer_syntax))
                return 0;
            break;
        case ASN1characterstring_identification_fixed_o:
            break;
        }
    }
    return 1;
}
#endif // ENABLE_GENERALIZED_CHAR_STR

#ifdef ENABLE_DOUBLE
/* decode real value */
int ASN1BERDecDouble(ASN1decoding_t dec, ASN1uint32_t tag, double *val)
{
    ASN1uint32_t head;
    ASN1int32_t exponent;
    ASN1uint32_t baselog2;
    ASN1uint32_t len;
    ASN1uint32_t i;
    ASN1octet_t *p, *q;
    double v;
    char buf[256], *b;

    /* skip tag */
    if (!ASN1BERDecTag(dec, tag, NULL))
        return 0;

    /* get length */
    if (!ASN1BERDecLength(dec, &len, NULL))
        return 0;

    /* null length is 0.0 */
    if (!len)
    {
        *val = 0.0;
    }
    else
    {
        p = q = dec->pos;
        dec->pos += len;
        head = *p++;

        /* binary encoding? */
        if (head & 0x80)
        {
            /* get base */
            switch (head & 0x30)
            {
            case 0:
                /* base 2 */
                baselog2 = 1;
                break;
            case 0x10:
                /* base 8 */
                baselog2 = 3;
                break;
            case 0x20:
                /* base 16 */
                baselog2 = 4;
                break;
            default:
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }

            /* get exponent */
            switch (head & 0x03)
            {
            case 0:
                /* 8 bit exponent */
                exponent = (ASN1int8_t)*p++;
                break;
            case 1:
                /* 16 bit exponent */
                exponent = (ASN1int16_t)((*p << 8) | p[1]);
                p += 2;
                break;
            case 2:
                /* 24 bit exponent */
                exponent = ((*p << 16) | (p[1] << 8) | p[2]);
                if (exponent & 0x800000)
                    exponent -= 0x1000000;
                break;
            default:
                /* variable length exponent */
                exponent = (p[1] & 0x80) ? -1 : 0;
                for (i = 1; i <= *p; i++)
                    exponent = (exponent << 8) | p[i];
                p += *p + 1;
                break;
            }

            /* calculate remaining length */
            len -= (ASN1uint32_t) (p - q);

            /* get mantissa */
            v = 0.0;
            for (i = 0; i < len; i++)
                v = v * 256.0 + *p++;

            /* scale mantissa */
            switch (head & 0x0c)
            {
            case 0x04:
                /* scaling factor 1 */
                v *= 2.0;
                break;
            case 0x08:
                /* scaling factor 2 */
                v *= 4.0;
                break;
            case 0x0c:
                /* scaling factor 3 */
                v *= 8.0;
                break;
            }

            /* check sign */
            if (head & 0x40)
                v = -v;

            /* calculate value */
            *val = ldexp(v, exponent * baselog2);
        }
        else
        /* special real values? */
        if (head & 0x40)
        {
            switch (head)
            {
            case 0x40:
                /* PLUS-INFINITY */
                *val = ASN1double_pinf();
                break;
            case 0x41:
                /* MINUS-INFINITY */
                *val = ASN1double_minf();
                break;
            default:
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }
        }
        /* decimal encoding */
        else
        {
            // Prevent a buffer overrun by ensuring that buf is large enough to hold the
            // data stored in p:
            if (len > sizeof(buf))
            {
                ASN1DecSetError(dec, ASN1_ERR_LARGE);
                return 0;
            }
            CopyMemory(buf, p, len - 1);
            buf[len - 1] = 0;
            b = strchr(buf, ',');
            if (b)
                *b = '.';
            *val = strtod((char *)buf, &b);
            if (*b)
            {
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }
        }
    }
    return 1;
}
#endif // ENABLE_DOUBLE

#ifdef ENABLE_REAL
int ASN1BERDecReal(ASN1decoding_t dec, ASN1uint32_t tag, ASN1real_t *val)
{
    ASN1uint32_t head;
    ASN1int32_t ex;
    // ASN1intx_t exponent;
    ASN1uint32_t baselog2;
    ASN1uint32_t len;
    ASN1uint32_t i;
    ASN1octet_t *p, *q;
    double v;
    ASN1intx_t help;

    if (!ASN1BERDecTag(dec, tag, NULL))
        return 0;
    if (!ASN1BERDecLength(dec, &len, NULL))
        return 0;

    // *val = 0.0;
    DecAssert(dec, 0 == (int) eReal_Normal);
    ZeroMemory(val, sizeof(*val));
    if (len)
    {
        p = q = dec->pos;
        dec->pos += len;
        head = *p++;

        /* binary encoding? */
        if (head & 0x80)
        {
            val->type = eReal_Normal;

            /* get base */
            switch (head & 0x30)
            {
            case 0:
                /* base 2 */
                baselog2 = 1;
                break;
            case 0x10:
                /* base 8 */
                baselog2 = 3;
                break;
            case 0x20:
                /* base 16 */
                baselog2 = 4;
                break;
            default:
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }

            /* get exponent */
            switch (head & 0x03)
            {
            case 0:
                /* 8 bit exponent */
                ex = (ASN1int8_t)*p++;
                ASN1intx_setint32(&val->exponent, ex);
                break;
            case 1:
                /* 16 bit exponent */
                ex = (ASN1int16_t)((*p << 8) | p[1]);
                p += 2;
                // ASN1intx_setint32_t(&exponent, ex);
                ASN1intx_setint32(&val->exponent, ex);
                break;
            case 2:
                /* 24 bit exponent */
                ex = ((*p << 16) | (p[1] << 8) | p[2]);
                if (ex & 0x800000)
                    ex -= 0x1000000;
                // ASN1intx_setint32_t(&exponent, ex);
                ASN1intx_setint32(&val->exponent, ex);
                break;
            default:
                /* variable length exponent */
                val->exponent.length = *p;
                val->exponent.value = (ASN1octet_t *)DecMemAlloc(dec, *p);
                if (!val->exponent.value)
                {
                    return 0;
                }
                CopyMemory(val->exponent.value, p + 1, *p);
                p += *p + 1;
                break;
            }

            /* calculate remaining length */
            len -= (p - q);
            if (!len)
            {
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }

            /* get mantissa */
            val->mantissa.length = (*p & 0x80) ? len + 1 : len;
            val->mantissa.value = (ASN1octet_t *)DecMemAlloc(dec, val->mantissa.length);
            if (!val->mantissa.value)
            {
                return 0;
            }
            val->mantissa.value[0] = 0;
            CopyMemory(val->mantissa.value + val->mantissa.length - len, p, len);

            /* scale mantissa */
            switch (head & 0x0c)
            {
            case 0x04:
                /* scaling factor 1 */
                ASN1intx_muloctet(&help, &val->mantissa, 2);
                ASN1intx_free(&val->mantissa);
                val->mantissa = help;
                break;
            case 0x08:
                /* scaling factor 2 */
                ASN1intx_muloctet(&help, &val->mantissa, 4);
                ASN1intx_free(&val->mantissa);
                val->mantissa = help;
                break;
            case 0x0c:
                /* scaling factor 3 */
                ASN1intx_muloctet(&help, &val->mantissa, 8);
                ASN1intx_free(&val->mantissa);
                val->mantissa = help;
                break;
            }

            /* check sign */
            if (head & 0x40)
            {
                ASN1intx_neg(&help, &val->mantissa);
                ASN1intx_free(&val->mantissa);
                val->mantissa = help;
            }
        }
        else
        /* special real values? */
        if (head & 0x40)
        {
            switch (head)
            {
            case 0x40:
                /* PLUS-INFINITY */
                val->type = eReal_PlusInfinity;
                break;
            case 0x41:
                /* MINUS-INFINITY */
                val->type = eReal_MinusInfinity;
                break;
            default:
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }
        }
        /* decimal encoding */
        else
        {
            char *b;
            char buf[256];

            DecAssert(dec, (head & 0xc0) == 0xc0); 

            // Prevent a buffer overrun by ensuring that buf is large enough to hold the
            // data stored in p:
            if (len > sizeof(buf))
            {
                ASN1DecSetError(dec, ASN1_ERR_LARGE);
                return 0;
            }
            CopyMemory(buf, p, len - 1);
            buf[len - 1] = 0;
            ex = 0;
            b = strchr(buf, ',');
            if (b)
            {
                // move the decimal point to the right
                ex -= lstrlenA(b+1);
                lstrcpyA(b, b+1);
            }
            // skip leading zeros
            for (b = &buf[0]; '0' == *b; b++)
                ;
            val->type = eReal_Normal;
            val->base = 10;
            ASN1intx_setint32(&val->exponent, ex);
            /*XXX*/
            // missing code here!!!
            // need to set val->mantissa through the decimal digits string
            DecAssert(dec, 0);
            return 0;
        }
    }
    return 1;
}
#endif // ENABLE_REAL

#ifdef ENABLE_EMBEDDED_PDV
/* decode embedded pdv value */
int ASN1BERDecEmbeddedPdv(ASN1decoding_t dec, ASN1uint32_t tag, ASN1embeddedpdv_t *val)
{
    ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t) dec;
    ASN1uint32_t constructed, len, infinite;
    ASN1uint32_t index;
    ASN1embeddedpdv_identification_t *identification;
    ASN1decoding_t dd, dd2, dd3;
    ASN1octet_t *di, *di2, *di3;

    /* skip tag */
    if (!ASN1BERDecTag(dec, tag, &constructed))
        return 0;

    if (constructed)
    {
        /* constructed? EP-A encoded: */
        /* get length */
        if (!ASN1BERDecLength(dec, &len, &infinite))
            return 0;

        /* then start decoding of constructed value */
        if (! _BERDecConstructed(dec, len, infinite, &dd, &di))
            return 0;
        if (!ASN1BERDecU32Val(dd, 0x80000000, &index))
            return 0;
        if (index != d->parent->epilength)
        {
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }
        if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd2, &di2))
            return 0;
        if (!ASN1BERDecPeekTag(dd2, &tag))
            return 0;
        switch (tag)
        {
        case 0x80000000:
            val->identification.o = ASN1embeddedpdv_identification_syntaxes_o;
            if (!ASN1BERDecExplicitTag(dd2, 0x80000000, &dd3, &di3))
                return 0;
            if (!ASN1BERDecObjectIdentifier(dd3, 0x80000000,
                &val->identification.u.syntaxes.abstract))
                return 0;
            if (!ASN1BERDecObjectIdentifier(dd3, 0x80000001,
                &val->identification.u.syntaxes.transfer))
                return 0;
            if (!ASN1BERDecEndOfContents(dd2, dd3, di3))
                return 0;
            break;
        case 0x80000001:
            val->identification.o = ASN1embeddedpdv_identification_syntax_o;
            if (!ASN1BERDecObjectIdentifier(dd2, 0x80000001,
                &val->identification.u.syntax))
                return 0;
            break;
        case 0x80000002:
            val->identification.o =
                ASN1embeddedpdv_identification_presentation_context_id_o;
            if (!ASN1BERDecU32Val(dd2, 0x80000002,
                &val->identification.u.presentation_context_id))
                return 0;
            break;
        case 0x80000003:
            val->identification.o =
                ASN1embeddedpdv_identification_context_negotiation_o;
            if (!ASN1BERDecExplicitTag(dd2, 0x80000003, &dd3, &di3))
                return 0;
            if (!ASN1BERDecU32Val(dd3, 0x80000000, &val->
                identification.u.context_negotiation.presentation_context_id))
                return 0;
            if (!ASN1BERDecObjectIdentifier(dd3, 0x80000001,
                &val->identification.u.context_negotiation.transfer_syntax))
                return 0;
            if (!ASN1BERDecEndOfContents(dd2, dd3, di3))
                return 0;
            break;
        case 0x80000004:
            val->identification.o =
                ASN1embeddedpdv_identification_transfer_syntax_o;
            if (!ASN1BERDecObjectIdentifier(dd2, 0x80000004,
                &val->identification.u.transfer_syntax))
                return 0;
            break;
        case 0x80000005:
            val->identification.o = ASN1embeddedpdv_identification_fixed_o;
            if (!ASN1BERDecNull(dd2, 0x80000005))
                return 0;
            break;
        default:
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }
        if (!ASN1BERDecEndOfContents(dd, dd2, di2))
            return 0;
        if (!ASN1DecAddEmbeddedPdvIdentification(d->parent,
            &val->identification))
            return 0;
        val->data_value.o = ASN1embeddedpdv_data_value_encoded_o;
        if (!ASN1BERDecBitString(dd, 0x80000003,
            &val->data_value.u.encoded))
            return 0;
        if (!ASN1BERDecEndOfContents(dec, dd, di))
            return 0;
    }
    else
    {
        /* primitive? EP-B encoded: */
        if (!ASN1BERDecLength(dec, &len, NULL))
            return 0;

        /* then copy value */
        if (!len)
        {
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }
        val->data_value.o = ASN1embeddedpdv_data_value_encoded_o;
        val->data_value.u.encoded.length = 8 * (len - 1);
        val->data_value.u.encoded.value = (ASN1octet_t *)DecMemAlloc(dec, len - 1);
        if (!val->data_value.u.encoded.value)
        {
            return 0;
        }
        index = *dec->pos++;
        CopyMemory(val->data_value.u.encoded.value, dec->pos, len - 1);
        identification = ASN1DecGetEmbeddedPdvIdentification(d->parent, index);
        if (!identification)
            return 0;
        val->identification.o = identification->o;
        switch (identification->o)
        {
        case ASN1embeddedpdv_identification_syntaxes_o:
            if (!ASN1DecDupObjectIdentifier(dec, 
                &val->identification.u.syntaxes.abstract,
                &identification->u.syntaxes.abstract))
                return 0;
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.syntaxes.transfer,
                &identification->u.syntaxes.transfer))
                return 0;
            break;
        case ASN1embeddedpdv_identification_syntax_o:
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.syntax,
                &identification->u.syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_presentation_context_id_o:
            val->identification.u.presentation_context_id =
                identification->u.presentation_context_id;
            break;
        case ASN1embeddedpdv_identification_context_negotiation_o:
            val->identification.u.context_negotiation.presentation_context_id =
                identification->u.context_negotiation.presentation_context_id;
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.context_negotiation.transfer_syntax,
                &identification->u.context_negotiation.transfer_syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_transfer_syntax_o:
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.transfer_syntax,
                &identification->u.transfer_syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_fixed_o:
            break;
        }
    }
    return 1;
}
#endif // ENABLE_EMBEDDED_PDV

#ifdef ENABLE_EXTERNAL
/* decode external value */
int ASN1BERDecExternal(ASN1decoding_t dec, ASN1uint32_t tag, ASN1external_t *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1objectidentifier_t id;
    ASN1octetstring_t os;

    /* decode explicit tag */
    if (!ASN1BERDecExplicitTag(dec, tag | 0x20000000, &dd, &di))
        return 0;

    /* peek tag of choice alternative */
    if (!ASN1BERDecPeekTag(dd, &tag))
        return 0;

    /* decode alternative */
    if (tag == 0x6)
    {
        if (!ASN1BERDecObjectIdentifier(dd, 0x6, &id))
            return 0;
        if (!ASN1BERDecPeekTag(dd, &tag))
            return 0;
        if (tag == 0x2)
        {
            val->identification.o =
                ASN1external_identification_context_negotiation_o;
            val->identification.u.context_negotiation.transfer_syntax = id;
            if (!ASN1BERDecU32Val(dd, 0x2, &val->
                identification.u.context_negotiation.presentation_context_id))
                return 0;
            if (!ASN1BERDecPeekTag(dd, &tag))
                return 0;
        }
        else
        {
            val->identification.o = ASN1external_identification_syntax_o;
            val->identification.u.syntax = id;
        }
    }
    else
    if (tag == 0x2)
    {
        val->identification.o =
            ASN1external_identification_presentation_context_id_o;
        if (!ASN1BERDecU32Val(dd, 0x2,
            &val->identification.u.presentation_context_id))
            return 0;
        if (!ASN1BERDecPeekTag(dd, &tag))
            return 0;
    }
    else
    {
        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
        return 0;
    }

    /* decode optional data value descriptor if present */
    if (tag == 0x7)
    {
        if (!ASN1BERDecZeroCharString(dd, 0x7, &val->data_value_descriptor))
            return 0;
        if (!ASN1BERDecPeekTag(dd, &tag))
            return 0;
    }
    else
    {
        val->data_value_descriptor = NULL;
    }

    /* decode data value alternative */
    switch (tag)
    {
    case 0:
        val->data_value.o = ASN1external_data_value_notation_o;
        if (!ASN1BERDecOpenType(dd, &val->data_value.u.notation))
            return 0;
        break;
    case 1:
        val->data_value.o = ASN1external_data_value_encoded_o;
        if (!ASN1BERDecOctetString(dd, 0x4, &os))
            return 0;
        val->data_value.u.encoded.value = os.value;
        val->data_value.u.encoded.length = os.length * 8;
        break;
    case 2:
        val->data_value.o = ASN1external_data_value_encoded_o;
        if (!ASN1BERDecBitString(dd, 0x3, &val->data_value.u.encoded))
            return 0;
        break;
    default:
        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
        return 0;
    }

    /* end of constructed (explicit tagged) value */
    if (!ASN1BERDecEndOfContents(dec, dd, di))
        return 0;

    return 1;
}
#endif // ENABLE_EXTERNAL

/* decode generalized time value */
int ASN1BERDecGeneralizedTime(ASN1decoding_t dec, ASN1uint32_t tag, ASN1generalizedtime_t *val)
{
    ASN1ztcharstring_t time;
    if (ASN1BERDecZeroCharString(dec, tag, &time))
    {
        int rc = ASN1string2generalizedtime(val, time);
        DecMemFree(dec, time);
        if (rc)
        {
            return 1;
        }
        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
    }
    return 0;
}

/* decode multibyte string value */
int ASN1BERDecZeroMultibyteString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztcharstring_t *val)
{
    return ASN1BERDecZeroCharString(dec, tag, val);
}

int ASN1BERDecMultibyteString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1charstring_t *val)
{
    return ASN1BERDecCharString(dec, tag, val);
}

/* decode null value */
int ASN1BERDecNull(ASN1decoding_t dec, ASN1uint32_t tag)
{
    ASN1uint32_t len;
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            if (! len)
            {
                return 1;
            }
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
        }
    }
    return 0;
}

/* decode object identifier value */
int ASN1BERDecObjectIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, ASN1objectidentifier_t *val)
{
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len, i, v;
        ASN1octet_t *data, *p;
        ASN1uint32_t nelem;
        ASN1objectidentifier_t q;

        if (ASN1BERDecLength(dec, &len, NULL))
        {
            data = dec->pos;
            dec->pos += len;
            nelem = 1;
            for (i = 0, p = data; i < len; i++, p++)
            {
                if (!(*p & 0x80))
                    nelem++;
            }
            *val = q = DecAllocObjectIdentifier(dec, nelem);
            if (q)
            {
                v = 0;
                for (i = 0, p = data; i < len; i++, p++)
                {
                    v = (v << 7) | (*p & 0x7f);
                    if (!(*p & 0x80))
                    {
                        if (q == *val)
                        { // first id
                            q->value = v / 40;
                            if (q->value > 2)
                                q->value = 2;
                            q->next->value = v - 40 * q->value;
                            q = q->next->next;
                        }
                        else
                        {
                            q->value = v;
                            q = q->next;
                        }
                        v = 0;
                    }
                }
                return 1;
            }
        }
    }
    return 0;
}

/* decode object identifier value */
int ASN1BERDecObjectIdentifier2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1objectidentifier2_t *val)
{
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len, i, v;
        ASN1octet_t *data, *p;
        ASN1objectidentifier_t q;

        if (ASN1BERDecLength(dec, &len, NULL))
        {
            if (len <= 16) // lonchanc: hard-coded value 16 to be consistent with ASN1objectidentifier2_t
            {
                data = dec->pos;
                dec->pos += len;
                val->count = 0;
                v = 0;
                for (i = 0, p = data; i < len; i++, p++)
                {
                    v = (v << 7) | (*p & 0x7f);
                    if (!(*p & 0x80))
                    {
                        if (! val->count)
                        { // first id
                            val->value[0] = v / 40;
                            if (val->value[0] > 2)
                                val->value[0] = 2;
                            val->value[1] = v - 40 * val->value[0];
                            val->count = 2;
                        }
                        else
                        {
                            val->value[val->count++] = v;
                        }
                        v = 0;
                    }
                }
                return 1;
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_LARGE);
            }
        }
    }
    return 0;
}

/* decode integer into signed 8 bit value */
int ASN1BERDecS8Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int8_t *val)
{
    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len;
        /* get length */
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            /* get value */
            if (1 == len)
            {
                *val = *dec->pos++;
                return 1;
            }
            ASN1DecSetError(dec, (len < 1) ? ASN1_ERR_CORRUPT : ASN1_ERR_LARGE);
        }
    }
    return 0;
}

/* decode integer into signed 16 bit value */
int ASN1BERDecS16Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int16_t *val)
{
    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len;
        /* get length */
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            /* get value */
            switch (len)
            {
            case 1:
                *val = *dec->pos++;
                break;
            case 2:
                *val = (*dec->pos << 8) | dec->pos[1];
                dec->pos += 2;
                break;
            default:
                ASN1DecSetError(dec, (len < 1) ? ASN1_ERR_CORRUPT : ASN1_ERR_LARGE);
                return 0;
            }
            return 1;
        }
    }
    return 0;
}

const ASN1int32_t c_nSignMask[] = { 0xFFFFFF00, 0xFFFF0000, 0xFF000000, 0 };

/* decode integer into signed 32 bit value */
int ASN1BERDecS32Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int32_t *val)
{
    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len;
        /* get length */
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            int fSigned = 0x80 & *dec->pos;

            /* get value */
            switch (len)
            {
            case 1:
                *val = *dec->pos++;
                break;
            case 2:
                *val = (*dec->pos << 8) | dec->pos[1];
                dec->pos += 2;
                break;
            case 3:
                *val = (*dec->pos << 16) | (dec->pos[1] << 8) | dec->pos[2];
                dec->pos += 3;
                break;
            case 4:
                *val = (*dec->pos << 24) | (dec->pos[1] << 16) |
                    (dec->pos[2] << 8) | dec->pos[3];
                dec->pos += 4;
                break;
            default:
                ASN1DecSetError(dec, (len < 1) ? ASN1_ERR_CORRUPT : ASN1_ERR_LARGE);
                return 0;
            }
            if (fSigned)
            {
                *val |= c_nSignMask[len-1];
            }
            return 1;
        }
    }
    return 0;
}

/* decode integer into intx value */
int ASN1BERDecSXVal(ASN1decoding_t dec, ASN1uint32_t tag, ASN1intx_t *val)
{
    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len;
        /* get length */
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            /* get value */
            if (len >= 1)
            {
                val->length = len;
                val->value = (ASN1octet_t *)DecMemAlloc(dec, len);
                if (val->value)
                {
                    CopyMemory(val->value, dec->pos, len);
                    dec->pos += len;
                    return 1;
                }
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            }
        }
    }
    return 0;
}

/* decode integer into unsigned 8 bit value */
int ASN1BERDecU8Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint8_t *val)
{
    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len;
        /* get length */
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            /* get value */
            switch (len)
            {
            case 1:
                *val = *dec->pos++;
                return 1;
            case 2:
                if (0 == *dec->pos)
                {
                    *val = dec->pos[1];
                    dec->pos += 2;
                    return 1;
                }
                // intentionally fall through
            default:
                ASN1DecSetError(dec, (len < 1) ? ASN1_ERR_CORRUPT : ASN1_ERR_LARGE);
                break;
            }
        }
    }
    return 0;
}

/* decode integer into unsigned 16 bit value */
int ASN1BERDecU16Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint16_t *val)
{
    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len;
        /* get length */
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            /* get value */
            switch (len)
            {
            case 1:
                *val = *dec->pos++;
                return 1;
            case 2:
                *val = (*dec->pos << 8) | dec->pos[1];
                dec->pos += 2;
                return 1;
            case 3:
                if (0 == *dec->pos)
                {
                    *val = (dec->pos[1] << 8) | dec->pos[2];
                    dec->pos += 3;
                    return 1;
                }
                // intentionally fall through
            default:
                ASN1DecSetError(dec, (len < 1) ? ASN1_ERR_CORRUPT : ASN1_ERR_LARGE);
                break;
            }
        }
    }
    return 0;
}

/* decode utc time value */
int ASN1BERDecUTCTime(ASN1decoding_t dec, ASN1uint32_t tag, ASN1utctime_t *val)
{
    ASN1ztcharstring_t time;
    if (ASN1BERDecZeroCharString(dec, tag, &time))
    {
        int rc = ASN1string2utctime(val, time);
        DecMemFree(dec, time);
        if (rc)
        {
            return 1;
        }
        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
    }
    return 0;
}

/* decode zero terminated string value */
int ASN1BERDecZeroCharString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztcharstring_t *val)
{
    ASN1uint32_t constructed, len, infinite;
    ASN1ztcharstring_t c;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t lv, lc;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (constructed)
            {
                /* constructed? then start decoding of constructed value */
                *val = NULL;
                if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                {
                    while (ASN1BERDecNotEndOfContents(dd, di))
                    {
                        if (ASN1BERDecZeroCharString(dd, 0x4, &c))
                        {
                            lv = My_lstrlenA(*val);
                            lc = My_lstrlenA(c);
                            if (lc)
                            {
                                /* resize value */
                                *val = (char *)DecMemReAlloc(dd, *val, lv + lc + 1);
                                if (*val)
                                {
                                    /* concat strings */
                                    CopyMemory(*val + lv, c, lc + 1);

                                    /* free unused string */
                                    DecMemFree(dec, c);
                                }
                                else
                                {
                                    return 0;
                                }
                            }
                        }
                        else
                        {
                            return 0;
                        }
                    } // while
                    return ASN1BERDecEndOfContents(dec, dd, di);
                }
            }
            else
            {
                /* primitive? then copy value */
                *val = (char *)DecMemAlloc(dec, len + 1);
                if (*val)
                {
                    CopyMemory(*val, dec->pos, len);
                    (*val)[len] = 0;
                    dec->pos += len;
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* decode zero terminated 16 bit string value */
int ASN1BERDecZeroChar16String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztchar16string_t *val)
{
    ASN1uint32_t constructed, len, infinite;
    ASN1ztchar16string_t c;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t i;
    ASN1uint32_t lv, lc;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (constructed)
            {
                /* constructed? then start decoding of constructed value */
                *val = NULL;
                if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                {
                    while (ASN1BERDecNotEndOfContents(dd, di))
                    {
                        if (ASN1BERDecZeroChar16String(dd, 0x4, &c))
                        {
                            lv = ASN1str16len(*val);
                            lc = ASN1str16len(c);
                            if (lc)
                            {
                                /* resize value */
                                *val = (ASN1char16_t *)DecMemReAlloc(dd, *val, (lv + lc + 1) * sizeof(ASN1char16_t));
                                if (*val)
                                {
                                    /* concat strings */
                                    CopyMemory(*val + lv, c, (lc + 1) * sizeof(ASN1char16_t));

                                    /* free unused string */
                                    DecMemFree(dec, c);
                                }
                                else
                                {
                                    return 0;
                                }
                            }
                        }
                        else
                        {
                            return 0;
                        }
                    } // while
                    return ASN1BERDecEndOfContents(dec, dd, di);
                }
            }
            else
            {
                /* primitive? then copy value */
                *val = (ASN1char16_t *)DecMemAlloc(dec, (len + 1) * sizeof(ASN1char16_t));
                if (*val)
                {
                    for (i = 0; i < len; i++)
                    {
                        (*val)[i] = (*dec->pos << 8) | dec->pos[1];
                        dec->pos += 2;
                    }
                    (*val)[len] = 0;
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* decode zero terminated 32 bit string value */
int ASN1BERDecZeroChar32String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztchar32string_t *val)
{
    ASN1uint32_t constructed, len, infinite;
    ASN1ztchar32string_t c;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t i;
    ASN1uint32_t lv, lc;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (constructed)
            {
                /* constructed? then start decoding of constructed value */
                *val = (ASN1char32_t *)DecMemAlloc(dec, sizeof(ASN1char32_t));
                if (*val)
                {
                    **val = 0;
                    if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                    {
                        while (ASN1BERDecNotEndOfContents(dd, di))
                        {
                            if (ASN1BERDecZeroChar32String(dd, 0x4, &c))
                            {
                                lv = ASN1str32len(*val);
                                lc = ASN1str32len(c);
                                if (lc)
                                {
                                    /* resize value */
                                    *val = (ASN1char32_t *)DecMemReAlloc(dd, *val, (lv + lc + 1) * sizeof(ASN1char32_t));
                                    if (*val)
                                    {
                                        /* concat strings */
                                        CopyMemory(*val + lv, c, (lc + 1) * sizeof(ASN1char32_t));

                                        /* free unused string */
                                        DecMemFree(dec, c);
                                    }
                                    else
                                    {
                                        return 0;
                                    }
                                }
                            }
                            else
                            {
                                return 0;
                            }
                        }
                        return ASN1BERDecEndOfContents(dec, dd, di);
                    }
                }
            }
            else
            {
                /* primitive? then copy value */
                *val = (ASN1char32_t *)DecMemAlloc(dec, (len + 1) * sizeof(ASN1char32_t));
                if (*val)
                {
                    for (i = 0; i < len; i++)
                    {
                        (*val)[i] = (*dec->pos << 24) | (dec->pos[1] << 16) |
                                    (dec->pos[2] << 8) | dec->pos[3];;
                        dec->pos += 4;
                    }
                    (*val)[len] = 0;
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* skip a value */
int ASN1BERDecSkip(ASN1decoding_t dec)
{
    ASN1uint32_t tag;
    ASN1uint32_t constructed, len, infinite;
    ASN1decoding_t dd;
    ASN1octet_t *di;

    /* set warning flag */
    ASN1DecSetError(dec, ASN1_WRN_EXTENDED);

    /* read tag */
    if (ASN1BERDecPeekTag(dec, &tag))
    {
        if (ASN1BERDecTag(dec, tag, &constructed))
        {
            if (constructed)
            {
                /* constructed? then get length */
                if (ASN1BERDecLength(dec, &len, &infinite))
                {
                    if (!infinite)
                    {
                        /* skip value */
                        dec->pos += len;
                        // remove the above warning set previously
                        ASN1DecSetError(dec, ASN1_SUCCESS);
                        return 1;
                    } 

                    /* start skipping of constructed value */
                    if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                    {
                        while (ASN1BERDecNotEndOfContents(dd, di))
                        {
                            if (ASN1BERDecSkip(dd))
                            {
                                continue;
                            }
                            return 0;
                        }
                        if (ASN1BERDecEndOfContents(dec, dd, di))
                        {
                            // remove the above warning set previously
                            ASN1DecSetError(dec, ASN1_SUCCESS);
                            return 1;
                        }
                        return 0;
                    }
                }
            }
            else
            {
                /* primitive? then get length */
                if (ASN1BERDecLength(dec, &len, NULL))
                {
                    /* skip value */
                    dec->pos += len;
                    // remove the above warning set previously
                    ASN1DecSetError(dec, ASN1_SUCCESS);
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* decode an open type value */
int _BERDecOpenType(ASN1decoding_t dec, ASN1open_t *val, ASN1uint32_t fNoCopy)
{
    ASN1uint32_t tag;
    ASN1uint32_t constructed, len, infinite;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1octet_t *p;

    p = dec->pos;

    /* skip tag */
    if (ASN1BERDecPeekTag(dec, &tag))
    {
        if (ASN1BERDecTag(dec, tag, &constructed))
        {
            if (constructed)
            {
                /* constructed? then get length */
                if (ASN1BERDecLength(dec, &len, &infinite))
                {
                    if (!infinite)
                    {
                        /* skip value */
                        dec->pos += len;
                        goto MakeCopy;
                    } 

                    /* start decoding of constructed value */
                    if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                    {
                        while (ASN1BERDecNotEndOfContents(dd, di))
                        {
                            if (ASN1BERDecSkip(dd))
                            {
                                continue;
                            }
                            return 0;
                        }
                        if (ASN1BERDecEndOfContents(dec, dd, di))
                        {
                            goto MakeCopy;
                        }
                    }
                }
                return 0;
            }
            else
            {
                /* primitive? then get length */
                if (ASN1BERDecLength(dec, &len, NULL))
                {
                    /* skip value */
                    dec->pos += len;
                }
                else
                {
                    return 0;
                }
            }

        MakeCopy:

            // clean up unused fields
            // val->decoded = NULL;
            // val->userdata = NULL;

            /* copy skipped value */
            val->length = (ASN1uint32_t) (dec->pos - p);
            if (fNoCopy)
            {
                val->encoded = p;
                return 1;
            }
            else
            {
                val->encoded = (ASN1octet_t *)DecMemAlloc(dec, val->length);
                if (val->encoded)
                {
                    CopyMemory(val->encoded, p, val->length);
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* decode an open type value, making a copy */
int ASN1BERDecOpenType(ASN1decoding_t dec, ASN1open_t *val)
{
    return _BERDecOpenType(dec, val, FALSE);
}

/* decode an open type value, no copy */
int ASN1BERDecOpenType2(ASN1decoding_t dec, ASN1open_t *val)
{
    return _BERDecOpenType(dec, val, TRUE);
}

/* finish decoding */
int ASN1BERDecFlush(ASN1decoding_t dec)
{
    /* calculate length */
    dec->len = (ASN1uint32_t) (dec->pos - dec->buf);

    /* set WRN_NOEOD if data left */
    if (dec->len >= dec->size)
    {
        DecAssert(dec, dec->len == dec->size);
        return 1;
    }
    ASN1DecSetError(dec, ASN1_WRN_NOEOD);
    return 1;
}

#endif // ENABLE_BER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\msasn1\cintern.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"
#include "cintern.h"

/* external use only, allocate memory for decoding */
LPVOID ASN1DecAlloc(ASN1decoding_t dec, ASN1uint32_t size)
{
    return DecMemAlloc(dec, size);
}

/* external use only, reallocate memory for decoding */
LPVOID ASN1DecRealloc(ASN1decoding_t dec, LPVOID ptr, ASN1uint32_t size)
{
    return DecMemReAlloc(dec, ptr, size);
}

/* external use only, free a memory block */
void ASN1Free(LPVOID ptr)
{
    MemFree(ptr);
}

// lonchanc: we need to re-visit this approach of aborting a decoding
/* abort decoding, free any memory allocated for decoding */
void ASN1DecAbort(ASN1decoding_t dec)
{
    ASN1INTERNdecoding_t d = ((ASN1INTERNdecoding_t)dec)->parent;

#ifdef ENABLE_EXTRA_INFO
    /* clear the lists */
    d->memlength = d->epilength = d->csilength = 0;
    d->memsize = d->episize = d->csisize = 0;
    MemFree(d->mem);
    MemFree(d->epi);
    MemFree(d->csi);
    d->mem = NULL;
    d->epi = NULL;
    d->csi = NULL;
#endif // ENABLE_EXTRA_INFO
}

// lonchanc: we need to re-visit this approach of aborting a decoding
/* finish decoding */
void ASN1DecDone(ASN1decoding_t dec)
{
    ASN1INTERNdecoding_t d = ((ASN1INTERNdecoding_t)dec)->parent;

#ifdef ENABLE_EXTRA_INFO
    /* clear the lists */
    d->memlength = d->epilength = d->csilength = 0;
    d->memsize = d->episize = d->csisize = 0;
    MemFree(d->mem);
    MemFree(d->epi);
    MemFree(d->csi);
    d->mem = NULL;
    d->epi = NULL;
    d->csi = NULL;
#endif // ENABLE_EXTRA_INFO
}

// lonchanc: we need to re-visit this approach of aborting a decoding
/* abort encoding, free any memory allocated for encoding */
void ASN1EncAbort(ASN1encoding_t enc)
{
    ASN1INTERNencoding_t e = ((ASN1INTERNencoding_t)enc)->parent;

#ifdef ENABLE_EXTRA_INFO
    /* clear the lists */
    e->memlength = e->epilength = e->csilength = 0;
    e->memsize = e->episize = e->csisize = 0;
    MemFree(e->mem);
    MemFree(e->epi);
    MemFree(e->csi);
    e->mem = NULL;
    e->epi = NULL;
    e->csi = NULL;
#endif // ENABLE_EXTRA_INFO
}

// lonchanc: we need to re-visit this approach of aborting a decoding
/* finish encoding */
void ASN1EncDone(ASN1encoding_t enc)
{
    ASN1INTERNencoding_t e = ((ASN1INTERNencoding_t)enc)->parent;

#ifdef ENABLE_EXTRA_INFO
    /* clear the lists */
    e->memlength = e->epilength = e->csilength = 0;
    e->memsize = e->episize = e->csisize = 0;
    MemFree(e->mem);
    MemFree(e->epi);
    MemFree(e->csi);
    e->mem = NULL;
    e->epi = NULL;
    e->csi = NULL;
#endif // ENABLE_EXTRA_INFO
}


/* search the identification of an embedded pdv */
#ifdef ENABLE_EMBEDDED_PDV
int ASN1EncSearchEmbeddedPdvIdentification(ASN1INTERNencoding_t e, ASN1embeddedpdv_identification_t *identification, ASN1uint32_t *index, ASN1uint32_t *flag)
{
    ASN1embeddedpdv_identification_t **id;

    /* search identification in indentification list */
    /* if found then reset flag (to indicate EP-B encoding) and return */
    for (*index = 0, id = e->epi; *index < e->epilength; (*index)++, id++) {
        if ((*id)->o == identification->o) {
            switch ((*id)->o) {
            case ASN1embeddedpdv_identification_syntaxes_o:
                if (!ASN1objectidentifier_cmp(&(*id)->u.syntaxes.abstract,
                    &identification->u.syntaxes.abstract) &&
                    !ASN1objectidentifier_cmp(&(*id)->u.syntaxes.transfer,
                    &identification->u.syntaxes.transfer)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1embeddedpdv_identification_syntax_o:
                if (!ASN1objectidentifier_cmp(&(*id)->u.syntax,
                    &identification->u.syntax)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1embeddedpdv_identification_presentation_context_id_o:
                if ((*id)->u.presentation_context_id ==
                    identification->u.presentation_context_id) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1embeddedpdv_identification_context_negotiation_o:
                if ((*id)->u.context_negotiation.presentation_context_id ==
                    identification->u.context_negotiation.
                    presentation_context_id &&
                    !ASN1objectidentifier_cmp(
                    &(*id)->u.context_negotiation.transfer_syntax,
                    &identification->u.context_negotiation.transfer_syntax)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1embeddedpdv_identification_transfer_syntax_o:
                if (!ASN1objectidentifier_cmp(&(*id)->u.transfer_syntax,
                    &identification->u.transfer_syntax)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1embeddedpdv_identification_fixed_o:
                *flag = 0;
                return 1;
            default:
                e->parent->info.err = ASN1_ERR_CORRUPT;
                return 0;
            }
        }
    }
    /* identification not found */

    /* add it into indentification array */
    if (e->epilength >= e->episize) {
        e->episize = e->episize ? 4 * e->episize : 16;
        e->epi = (ASN1embeddedpdv_identification_t **)MemReAlloc(e->epi,
            e->episize * sizeof(ASN1embeddedpdv_identification_t *), _ModName((ASN1encoding_t) e));
        if (!e->epi)
        {
            ASN1EncSetError((ASN1encoding_t) e, ASN1_ERR_MEMORY);
            return 0;
        }
    }
    e->epi[e->epilength++] = identification;

    /* return flag for EP-A encoding */
    *flag = 1;
    return 1;
}
#endif // ENABLE_EMBEDDED_PDV

/* search the identification of an character string */
#ifdef ENABLE_GENERALIZED_CHAR_STR
int ASN1EncSearchCharacterStringIdentification(ASN1INTERNencoding_t e, ASN1characterstring_identification_t *identification, ASN1uint32_t *index, ASN1uint32_t *flag)
{
    ASN1characterstring_identification_t **id;

    /* search identification in indentification list */
    /* if found then reset flag (to indicate CS-B encoding) and return */
    for (*index = 0, id = e->csi; *index < e->csilength; (*index)++, id++) {
        if ((*id)->o == identification->o) {
            switch ((*id)->o) {
            case ASN1characterstring_identification_syntaxes_o:
                if (!ASN1objectidentifier_cmp(&(*id)->u.syntaxes.abstract,
                    &identification->u.syntaxes.abstract) &&
                    !ASN1objectidentifier_cmp(&(*id)->u.syntaxes.transfer,
                    &identification->u.syntaxes.transfer)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1characterstring_identification_syntax_o:
                if (!ASN1objectidentifier_cmp(&(*id)->u.syntax,
                    &identification->u.syntax)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1characterstring_identification_presentation_context_id_o:
                if ((*id)->u.presentation_context_id ==
                    identification->u.presentation_context_id) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1characterstring_identification_context_negotiation_o:
                if ((*id)->u.context_negotiation.presentation_context_id ==
                    identification->u.context_negotiation.
                    presentation_context_id &&
                    !ASN1objectidentifier_cmp(
                    &(*id)->u.context_negotiation.transfer_syntax,
                    &identification->u.context_negotiation.transfer_syntax)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1characterstring_identification_transfer_syntax_o:
                if (!ASN1objectidentifier_cmp(&(*id)->u.transfer_syntax,
                    &identification->u.transfer_syntax)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1characterstring_identification_fixed_o:
                *flag = 0;
                return 1;
            default:
                e->parent->info.err = ASN1_ERR_CORRUPT;
                return 0;
            }
        }
    }
    /* identification not found */

    /* add it into indentification array */
    if (e->csilength >= e->csisize) {
        e->csisize = e->csisize ? 4 * e->csisize : 16;
        e->csi = (ASN1characterstring_identification_t **)MemReAlloc(e->csi,
            e->csisize * sizeof(ASN1characterstring_identification_t *), _ModName((ASN1encoding_t) e));
        if (!e->csi)
        {
            ASN1EncSetError((ASN1encoding_t) e, ASN1_ERR_MEMORY);
            return 0;
        }
    }
    e->csi[e->csilength++] = identification;

    /* return flag for CS-A encoding */
    *flag = 1;
    return 1;
}
#endif // ENABLE_GENERALIZED_CHAR_STR

/* allocate and copy an object identifier */
#if defined(ENABLE_GENERALIZED_CHAR_STR) || defined(ENABLE_EMBEDDED_PDV)
int ASN1DecDupObjectIdentifier(ASN1decoding_t dec, ASN1objectidentifier_t *dst, ASN1objectidentifier_t *src)
{
    ASN1INTERNdecoding_t d = ((ASN1INTERNdecoding_t)dec)->parent;
    ASN1uint32_t l = GetObjectIdentifierCount(*src);
    *dst = DecAllocObjectIdentifier(dec, l);
    if (! *dst)
    {
        ASN1DecSetError((ASN1decoding_t) d, ASN1_ERR_MEMORY);
        return 0;
    }
    CopyObjectIdentifier(*dst, *src);
    return 1;
}
#endif // defined(ENABLE_GENERALIZED_CHAR_STR) || defined(ENABLE_EMBEDDED_PDV)

/* add an embedded pdv identification to the list of identifications */
#ifdef ENABLE_EMBEDDED_PDV
int ASN1DecAddEmbeddedPdvIdentification(ASN1INTERNdecoding_t d, ASN1embeddedpdv_identification_t *identification)
{
    if (d->epilength >= d->episize) {
        d->episize = d->episize ? 4 * d->episize : 16;
        d->epi = (ASN1embeddedpdv_identification_t **)MemReAlloc(d->epi,
            d->episize * sizeof(ASN1embeddedpdv_identification_t *), _ModName((ASN1decoding_t) d));
        if (!d->epi)
        {
            ASN1DecSetError((ASN1decoding_t) d, ASN1_ERR_MEMORY);
            return 0;
        }
    }
    d->epi[d->epilength++] = identification;
    return 1;
}
#endif // ENABLE_EMBEDDED_PDV

/* get an embedded pdv identification from the list of identifications */
#ifdef ENABLE_EMBEDDED_PDV
ASN1embeddedpdv_identification_t *ASN1DecGetEmbeddedPdvIdentification(ASN1INTERNdecoding_t d, ASN1uint32_t index)
{
    if (index >= d->epilength)
    {
        ASN1DecSetError((ASN1decoding_t) d, ASN1_ERR_CORRUPT);
        return NULL;
    }
    return d->epi[index];
}
#endif // ENABLE_EMBEDDED_PDV

/* add a character string identification to the list of identifications */
#ifdef ENABLE_GENERALIZED_CHAR_STR
int ASN1DecAddCharacterStringIdentification(ASN1INTERNdecoding_t d, ASN1characterstring_identification_t *identification)
{
    if (d->csilength >= d->csisize) {
        d->csisize = d->csisize ? 4 * d->csisize : 16;
        d->csi = (ASN1characterstring_identification_t **)MemReAlloc(d->csi,
            d->csisize * sizeof(ASN1characterstring_identification_t *), _ModName((ASN1decoding_t) d));
        if (!d->csi)
        {
            ASN1DecSetError((ASN1decoding_t) d, ASN1_ERR_MEMORY);
            return 0;
        }
    }
    d->csi[d->csilength++] = identification;
    return 1;
}
#endif // ENABLE_GENERALIZED_CHAR_STR

/* get a character string identification from the list of identifications */
#ifdef ENABLE_GENERALIZED_CHAR_STR
ASN1characterstring_identification_t *ASN1DecGetCharacterStringIdentification(ASN1INTERNdecoding_t d, ASN1uint32_t index)
{
    if (index >= d->csilength)
    {
        ASN1DecSetError((ASN1decoding_t) d, ASN1_ERR_CORRUPT);
        return NULL;
    }
    return d->csi[index];
}
#endif // ENABLE_GENERALIZED_CHAR_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\msasn1\libasn1.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation 1997-1998, All rights reserved. */

#ifndef __LIB_ASN1_H__
#define __LIB_ASN1_H__

#include <msasn1.h>
#include <msper.h>
#include <msber.h>

#ifdef __cplusplus
extern "C" {
#endif

// THE FOLLOWING IS FROM MS_CORE.H

/*
 * This file contains operating system specific defines:
 *
 * Dynamic link library support:
 * Define DllExport as declspec for exported functions and
 * DllImport as declspec for imported functions.
 *
 * Floating point encoding support:
 * For encoding floating point values either
 * - finite()+isinf()+copysign()+frexp() or
 * - finite()+fpclass()+FP_PINF+FP_NINF+frexp()
 * is needed. Define HAS_ISINF for the former case or HAS_FPCLASS for
 * the latter case.
 * Define HAS_IEEEFP_H for inclusion of <ieeefp.h> or HAS_FLOAT_H for
 * inclusion of <float.h> if required.
 *
 * Integer type support
 * [u]int{8,16,32}_t must specify an integral (unsigned iff u-prefixed)
 * type of the specified size (in bits).
 */

/* MS-Windows 95/MS-Windows NT */
#define THIRTYTWO_BITS  1
// #define HAS_SIXTYFOUR_BITS 1
#define HAS_FLOAT_H     1
#define HAS_FPCLASS     1
#define fpclass(_d)     _fpclass(_d)
#define finite(_d)      _finite(_d)
#define isnan(_d)       _isnan(_d)
#define FP_PINF         _FPCLASS_PINF
#define FP_NINF         _FPCLASS_NINF
// #define HAS_STRICMP     1
#define DBL_PINF        {0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x7f}
#define DBL_MINF        {0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0xff}



extern ASN1intx_t ASN1intx_0, ASN1intx_1, ASN1intx_2, ASN1intx_16, ASN1intx_256, ASN1intx_64K, ASN1intx_1G;
extern void ASN1API ASN1intx_addoctet(ASN1intx_t *, ASN1intx_t *, ASN1octet_t);
extern void ASN1API ASN1intx_suboctet(ASN1intx_t *, ASN1intx_t *, ASN1octet_t);
extern void ASN1API ASN1intx_muloctet(ASN1intx_t *, ASN1intx_t *, ASN1octet_t);
extern void ASN1API ASN1intx_inc(ASN1intx_t *);
extern void ASN1API ASN1intx_dec(ASN1intx_t *);
extern void ASN1API ASN1intx_neg(ASN1intx_t *, ASN1intx_t *);
extern ASN1uint32_t ASN1API ASN1intx_log2(ASN1intx_t *);
extern ASN1uint32_t ASN1API ASN1intx_log256(ASN1intx_t *);
extern ASN1int32_t ASN1API ASN1intx_cmp(ASN1intx_t *, ASN1intx_t *);
extern ASN1int32_t ASN1API ASN1intx_dup(ASN1intx_t *, ASN1intx_t *);
// extern void ASN1API ASN1intx_free(ASN1intx_t *);
extern void ASN1API ASN1intx_setuint32(ASN1intx_t *, ASN1uint32_t);
extern void ASN1API ASN1intx_setint32(ASN1intx_t *, ASN1int32_t);
extern int  ASN1API ASN1intxisuint64(ASN1intx_t *);
extern int  ASN1API ASN1intxisint64(ASN1intx_t *);
extern int  ASN1API ASN1intxisuint32(ASN1intx_t *);
extern int  ASN1API ASN1intxisint32(ASN1intx_t *);
extern int  ASN1API ASN1intxisuint16(ASN1intx_t *);
extern int  ASN1API ASN1intxisint16(ASN1intx_t *);
extern int  ASN1API ASN1intxisuint8(ASN1intx_t *);
extern int  ASN1API ASN1intxisint8(ASN1intx_t *);
#ifdef HAS_SIXTYFOUR_BITS
extern ASN1uint64_t ASN1API ASN1intx2uint64(ASN1intx_t *);
extern ASN1int64_t ASN1API ASN1intx2int64(ASN1intx_t *);
#endif
extern ASN1uint32_t ASN1API ASN1intx2uint32(ASN1intx_t *);
extern ASN1int32_t ASN1API ASN1intx2int32(ASN1intx_t *);
extern ASN1uint16_t ASN1API ASN1intx2uint16(ASN1intx_t *);
extern ASN1int16_t ASN1API ASN1intx2int16(ASN1intx_t *);
extern ASN1uint8_t ASN1API ASN1intx2uint8(ASN1intx_t *);
extern ASN1int8_t ASN1API ASN1intx2int8(ASN1intx_t *);
extern ASN1uint32_t ASN1API ASN1intx_octets(ASN1intx_t *);
extern ASN1uint32_t ASN1API ASN1uint32_log2(ASN1uint32_t);
extern ASN1uint32_t ASN1API ASN1uint32_log256(ASN1uint32_t);
extern ASN1uint32_t ASN1API ASN1uint32_octets(ASN1uint32_t);
extern ASN1uint32_t ASN1API ASN1uint32_uoctets(ASN1uint32_t);
extern ASN1uint32_t ASN1API ASN1int32_octets(ASN1int32_t);
extern double ASN1API ASN1intx2double(ASN1intx_t *);
extern double ASN1API ASN1real2double(ASN1real_t *);
extern double ASN1API ASN1double_minf();
extern double ASN1API ASN1double_pinf();
extern int ASN1API ASN1double_isminf(double);
extern int ASN1API ASN1double_ispinf(double);
extern int ASN1API ASN1generalizedtime2string(char *, ASN1generalizedtime_t *);
extern int ASN1API ASN1utctime2string(char *, ASN1utctime_t *);
extern int ASN1API ASN1string2generalizedtime(ASN1generalizedtime_t *, char *);
extern int ASN1API ASN1string2utctime(ASN1utctime_t *, char *);

/* ------ Comparison APIs ------ */

extern int ASN1API ASN1ztchar32string_cmp(ASN1ztchar32string_t, ASN1ztchar32string_t);
extern int ASN1API ASN1double_cmp(double, double);
extern int ASN1API ASN1real_cmp(ASN1real_t *, ASN1real_t *);
extern int ASN1API ASN1external_cmp(ASN1external_t *, ASN1external_t *);
extern int ASN1API ASN1embeddedpdv_cmp(ASN1embeddedpdv_t *, ASN1embeddedpdv_t *);
extern int ASN1API ASN1characterstring_cmp(ASN1characterstring_t *, ASN1characterstring_t *);
extern int ASN1API ASN1sequenceoflengthpointer_cmp(ASN1uint32_t, void *, ASN1uint32_t, void *, ASN1uint32_t, int (*)(void *, void *));
extern int ASN1API ASN1sequenceofsinglylinkedlist_cmp(void *, void *, ASN1uint32_t, int (*)(void *, void *));
extern int ASN1API ASN1sequenceofdoublylinkedlist_cmp(void *, void *, ASN1uint32_t, int (*)(void *, void *));
extern int ASN1API ASN1setoflengthpointer_cmp(ASN1uint32_t, void *, ASN1uint32_t, void *, ASN1uint32_t, int (*)(void *, void *));
extern int ASN1API ASN1setofsinglylinkedlist_cmp(void *, void *, ASN1uint32_t, int (*)(void *, void *));
extern int ASN1API ASN1setofdoublylinkedlist_cmp(void *, void *, ASN1uint32_t, int (*)(void *, void *));



#define ASN1BITSET(_val, _bitnr) \
    ((_val)[(_bitnr) >> 3] |= 0x80 >> ((_bitnr) & 7))
#define ASN1BITCLR(_val, _bitnr) \
    ((_val)[(_bitnr) >> 3] &= ~(0x80 >> ((_bitnr) & 7)))
#define ASN1BITTEST(_val, _bitnr) \
    ((_val)[(_bitnr) >> 3] & (0x80 >> ((_bitnr) & 7)))
    



// internal functions
int _BERDecConstructed(ASN1decoding_t dec, ASN1uint32_t len, ASN1uint32_t infinite, ASN1decoding_t *dd, ASN1octet_t **di);


#ifdef __cplusplus
}
#endif

#endif // __LIB_ASN1_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\msasn1\ident.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

/* copyright identifier */
const char ident1[] = "$Copyright: ASN.1 Compiler V0.9 $";
const char ident2[] = "$Copyright: Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. $";
const char ident3[] = "$Copyright: Copyright (C) Microsoft Corporation, 1997. All rights reserved. $";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\msasn1\ms_core.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

//--------------------------------------------------------------------------
//
// Module Name:  ms_core.h
//
// Brief Description:
//      This module contains the engine for the Microsoft
//      ASN.1 encoder and decoder.
//
// History:
//      10/15/97    Lon-Chan Chu (lonchanc)
//          Created.
//
// Copyright (c) 1997 Microsoft Corporation
//
//--------------------------------------------------------------------------

#include "precomp.h"


int APIENTRY
DllMain ( HINSTANCE hInstance, DWORD dwReason, LPVOID plReserved )
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hInstance);
        break;

    case DLL_PROCESS_DETACH:
        #ifdef ENABLE_MEMORY_TRACKING
        DbgMemTrackFinalCheck();
        #endif // ENABLE_MEMORY_TRACKING
        break;

    default:
        break;
    }

    return TRUE;
}


ASN1error_e ASN1EncSetError(ASN1encoding_t enc, ASN1error_e err)
{
    ASN1INTERNencoding_t e = (ASN1INTERNencoding_t) enc;
    EncAssert(enc, ASN1_SUCCESS <= err);
    while (e)
    {
        e->info.err = err;
        if (e == e->parent)
        {
            break;
        }
        e = e->parent;
    }
    return err;
}

ASN1error_e ASN1DecSetError(ASN1decoding_t dec, ASN1error_e err)
{
    ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t) dec;
    DecAssert(dec, ASN1_SUCCESS <= err);
    while (d)
    {
        d->info.err = err;
        if (d == d->parent)
        {
            break;
        }
        d = d->parent;
    }
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\msasn1\compare.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

#if defined(ENABLE_COMPARE) || defined(ENABLE_BER)

/* compare two object identifiers; return 0 iff equal */
int ASN1objectidentifier_cmp(ASN1objectidentifier_t *v1, ASN1objectidentifier_t *v2)
{
    ASN1uint32_t l, l1, l2, i;
    ASN1objectidentifier_t p1 = *v1;
    ASN1objectidentifier_t p2 = *v2;

    l1 = GetObjectIdentifierCount(p1);
    l2 = GetObjectIdentifierCount(p2);
    l = (l1 > l2) ? l2 : l1; // min(l1,l2)
    for (i = 0; i < l; i++) {
        if (p1->value != p2->value)
            return p1->value - p2->value;
        p1 = p1->next;
        p2 = p2->next;
    }
    return l1 - l2;
}

int ASN1objectidentifier2_cmp(ASN1objectidentifier2_t *v1, ASN1objectidentifier2_t *v2)
{
    ASN1uint16_t len, i;

    len = (v1->count > v2->count) ? v2->count : v1->count; // min(l1,l2)
    for (i = 0; i < len; i++)
    {
        if (v1->value[i] != v2->value[i])
        {
            return ((int) v1->value[i] - (int) v2->value[i]);
        }
    }
    return ((int) v1->count - (int) v2->count);
}

static const ASN1uint8_t c_aBitMask2[] = {
    0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe
};

/* compare two bit strings; return 0 iff equal */
int ASN1bitstring_cmp(ASN1bitstring_t *v1, ASN1bitstring_t *v2, int ignorezero)
{
    ASN1uint32_t l, l1, l2;
    ASN1octet_t o1, o2;
    int ret;

    l1 = v1->length;
    l2 = v2->length;
    l = l1;
    if (l > l2)
        l = l2;

    if (ignorezero) {
        if (l1 > l)
            ASN1PEREncRemoveZeroBits(&l1, v1->value, l);
        if (l2 > l)
            ASN1PEREncRemoveZeroBits(&l2, v2->value, l);
    }
    
    if (l > 7) {
        ret = memcmp(v1->value, v2->value, l / 8);
        if (ret)
            return ret;
    }

    if (l & 7) {
        o1 = v1->value[l / 8] & c_aBitMask2[l & 7];
        o2 = v2->value[l / 8] & c_aBitMask2[l & 7];
        ret = o1 - o2;
        if (ret)
            return ret;
    }

    return l1 - l2;
}

/* compare two octet strings; return 0 iff equal */
int ASN1octetstring_cmp(ASN1octetstring_t *v1, ASN1octetstring_t *v2)
{
    ASN1uint32_t l, l1, l2;
    int ret;

    l1 = v1->length;
    l2 = v2->length;
    l = l1;
    if (l > l2)
        l = l2;

    if (l) {
        ret = memcmp(v1->value, v2->value, l);
        if (ret)
            return ret;
    }

    return l1 - l2;
}


#ifdef ENABLE_EXTERNAL

/* compare two external; return 0 iff equal */
int ASN1external_cmp(ASN1external_t *v1, ASN1external_t *v2)
{
    int ret;

    if ((ret = (v1->identification.o - v2->identification.o)))
        return ret;
    switch (v1->identification.o) {
    case ASN1external_identification_syntax_o:
        if ((ret = ASN1objectidentifier_cmp(&v1->identification.u.syntax,
            &v2->identification.u.syntax)))
            return ret;
        break;
    case ASN1external_identification_presentation_context_id_o:
        if ((ret = (v1->identification.u.presentation_context_id -
            v2->identification.u.presentation_context_id)))
            return ret;
        break;
    case ASN1external_identification_context_negotiation_o:
        if ((ret = (
            v1->identification.u.context_negotiation.presentation_context_id -
            v2->identification.u.context_negotiation.presentation_context_id)))
            return ret;
        if ((ret = ASN1objectidentifier_cmp(
            &v1->identification.u.context_negotiation.transfer_syntax,
            &v2->identification.u.context_negotiation.transfer_syntax)))
            return ret;
        break;
    }
    if (ASN1BITTEST(v1->o, ASN1external_data_value_descriptor_o)) {
        if (ASN1BITTEST(v2->o, ASN1external_data_value_descriptor_o)) {
            if ((ret = ASN1ztcharstring_cmp(
                v1->data_value_descriptor, v2->data_value_descriptor)))
                return ret;
        } else {
            return 1;
        }
    } else {
        return 1;
    }
    if ((ret = (v1->data_value.o - v2->data_value.o)))
        return ret;
    switch (v1->data_value.o) {
    case ASN1external_data_value_notation_o:
        if ((ret = ASN1open_cmp(&v1->data_value.u.notation,
            &v2->data_value.u.notation)))
            return ret;
        break;
    case ASN1external_data_value_encoded_o:
        if ((ret = ASN1bitstring_cmp(&v1->data_value.u.encoded,
            &v2->data_value.u.encoded, 0)))
            return ret;
        break;
    }
    return 0;
}

#endif // ENABLE_EXTERNAL

#ifdef ENABLE_REAL

/* compare two reals; return 0 iff equal */
int ASN1real_cmp(ASN1real_t *v1, ASN1real_t *v2)
{
    ASN1intx_t e, e1, e2, m1, m2, h;
    int ret = 0;

    ZeroMemory(&e1, sizeof(e1));
    ZeroMemory(&e2, sizeof(e2));
    ZeroMemory(&m1, sizeof(m1));
    ZeroMemory(&m2, sizeof(m2));

    if (v1->type == eReal_PlusInfinity || v2->type == eReal_MinusInfinity)
        return 1;
    if (v2->type == eReal_PlusInfinity || v1->type == eReal_MinusInfinity)
        return -1;
    if (v1->type != eReal_Normal || v2->type != eReal_Normal)
        return 0;

    switch (v1->base) {
    case 2:
        if (! ASN1intx_dup(&e1, &v1->exponent))
        {
            ret = -1;
            goto MyExit;
        }
        break;
    case 8:
        ASN1intx_muloctet(&e1, &v1->exponent, 3);
        break;
    case 16:
        ASN1intx_muloctet(&e1, &v1->exponent, 4);
        break;
    }
    switch (v2->base) {
    case 2:
        if (! ASN1intx_dup(&e2, &v2->exponent))
        {
            ret = 1;
            goto MyExit;
        }
        break;
    case 8:
        ASN1intx_muloctet(&e2, &v2->exponent, 3);
        break;
    case 16:
        ASN1intx_muloctet(&e2, &v2->exponent, 4);
        break;
    }
    if (! ASN1intx_dup(&m1, &v1->mantissa))
    {
        ret = -1;
        goto MyExit;
    }
    if (! ASN1intx_dup(&m2, &v2->mantissa))
    {
        ret = 1;
        goto MyExit;
    }
    ASN1intx_sub(&e, &e1, &e2);
    for (;;) {
        ret = ASN1intx_cmp(&e, &ASN1intx_0);
        if (!ret)
            break;
        if (ret > 0) {
            ASN1intx_muloctet(&h, &m1, 2);
            ASN1intx_free(&m1);
            m1 = h;
            ASN1intx_dec(&e);
        } else {
            ASN1intx_muloctet(&h, &m2, 2);
            ASN1intx_free(&m2);
            m2 = h;
            ASN1intx_inc(&e);
        }
    }
// lonchanc: what happened to the memory allocated for e,
// should we call ASN1intx_free(&e)?
    ret = ASN1intx_cmp(&m1, &m2);

MyExit:

    ASN1intx_free(&m1);
    ASN1intx_free(&m2);
    ASN1intx_free(&e1);
    ASN1intx_free(&e2);
    return ret;
}

#endif // ENABLE_REAL

/* compare two doubles; return 0 iff equal */
int ASN1double_cmp(double d1, double d2)
{
    return d1 < d2 ? -1 : d1 > d2 ? 1 : 0;
}

#ifdef ENABLE_EMBEDDED_PDV

/* compare two embedded pdvs; return 0 iff equal */
int ASN1embeddedpdv_cmp(ASN1embeddedpdv_t *v1, ASN1embeddedpdv_t *v2)
{
    int ret;

    if ((ret = (v1->identification.o - v2->identification.o)))
        return ret;
    switch (v1->identification.o) {
    case ASN1embeddedpdv_identification_syntaxes_o:
        if ((ret = ASN1objectidentifier_cmp(
            &v1->identification.u.syntaxes.abstract,
            &v2->identification.u.syntaxes.abstract)))
            return ret;
        if ((ret = ASN1objectidentifier_cmp(
            &v1->identification.u.syntaxes.transfer,
            &v2->identification.u.syntaxes.transfer)))
            return ret;
        break;
    case ASN1embeddedpdv_identification_syntax_o:
        if ((ret = ASN1objectidentifier_cmp(&v1->identification.u.syntax,
            &v2->identification.u.syntax)))
            return ret;
        break;
    case ASN1embeddedpdv_identification_presentation_context_id_o:
        if ((ret = (v1->identification.u.presentation_context_id -
            v2->identification.u.presentation_context_id)))
            return ret;
        break;
    case ASN1embeddedpdv_identification_context_negotiation_o:
        if ((ret = (
            v1->identification.u.context_negotiation.presentation_context_id -
            v2->identification.u.context_negotiation.presentation_context_id)))
            return ret;
        if ((ret = ASN1objectidentifier_cmp(
            &v1->identification.u.context_negotiation.transfer_syntax,
            &v2->identification.u.context_negotiation.transfer_syntax)))
            return ret;
        break;
    case ASN1embeddedpdv_identification_transfer_syntax_o:
        if ((ret = ASN1objectidentifier_cmp(
            &v1->identification.u.transfer_syntax,
            &v2->identification.u.transfer_syntax)))
            return ret;
        break;
    case ASN1embeddedpdv_identification_fixed_o:
        break;
    }
    if ((ret = (v1->data_value.o - v2->data_value.o)))
        return ret;
    switch (v1->data_value.o) {
    case ASN1embeddedpdv_data_value_notation_o:
        if ((ret = ASN1open_cmp(&v1->data_value.u.notation,
            &v2->data_value.u.notation)))
            return ret;
        break;
    case ASN1embeddedpdv_data_value_encoded_o:
        if ((ret = ASN1bitstring_cmp(&v1->data_value.u.encoded,
            &v2->data_value.u.encoded, 0)))
            return ret;
        break;
    }
    return 0;
}

#endif // ENABLE_EMBEDDED_PDV


/* compare two zero-terminated strings; return 0 iff equal */
int ASN1ztcharstring_cmp(ASN1ztcharstring_t v1, ASN1ztcharstring_t v2)
{
    if (v1 && v2)
    {
        return lstrcmpA(v1, v2);
    }
    return v1 ? 1 : -1;
}

/* compare two zero-terminated 16 bit strings; return 0 iff equal */
int ASN1ztchar16string_cmp(ASN1ztchar16string_t v1, ASN1ztchar16string_t v2)
{
    for (;;) {
        if (!*v1 || !*v2 || *v1 != *v2)
            return *v1 - *v2;
        v1++;
        v2++;
    }
}

/* compare two zero-terminated 32 bit strings; return 0 iff equal */
int ASN1ztchar32string_cmp(ASN1ztchar32string_t v1, ASN1ztchar32string_t v2)
{
    for (;;) {
        if (!*v1 || !*v2 || *v1 != *v2)
            return *v1 - *v2;
        v1++;
        v2++;
    }
}

/* compare two strings; return 0 iff equal */
int ASN1charstring_cmp(ASN1charstring_t *v1, ASN1charstring_t *v2)
{
    ASN1uint32_t i, l;

    l = v1->length;
    if (v2->length > l)
        l = v2->length;
    for (i = 0; i < l; i++) {
        if (v1->value[i] != v2->value[i])
            return v1->value[i] - v2->value[i];
    }
    return v1->length - v2->length;
}

/* compare two 16 bit strings; return 0 iff equal */
int ASN1char16string_cmp(ASN1char16string_t *v1, ASN1char16string_t *v2)
{
    ASN1uint32_t i, l;

    l = v1->length;
    if (v2->length > l)
        l = v2->length;
    for (i = 0; i < l; i++) {
        if (v1->value[i] != v2->value[i])
            return v1->value[i] - v2->value[i];
    }
    return v1->length - v2->length;
}

/* compare two 32 bit strings; return 0 iff equal */
int ASN1char32string_cmp(ASN1char32string_t *v1, ASN1char32string_t *v2)
{
    ASN1uint32_t i, l;

    l = v1->length;
    if (v2->length > l)
        l = v2->length;
    for (i = 0; i < l; i++) {
        if (v1->value[i] != v2->value[i])
            return v1->value[i] - v2->value[i];
    }
    return v1->length - v2->length;
}

#ifdef ENABLE_GENERALIZED_CHAR_STR

/* compare two character strings; return 0 iff equal */
int ASN1characterstring_cmp(ASN1characterstring_t *v1, ASN1characterstring_t *v2)
{
    int ret;

    if ((ret = (v1->identification.o - v2->identification.o)))
        return ret;
    switch (v1->identification.o) {
    case ASN1characterstring_identification_syntaxes_o:
        if ((ret = ASN1objectidentifier_cmp(
            &v1->identification.u.syntaxes.abstract,
            &v2->identification.u.syntaxes.abstract)))
            return ret;
        if ((ret = ASN1objectidentifier_cmp(
            &v1->identification.u.syntaxes.transfer,
            &v2->identification.u.syntaxes.transfer)))
            return ret;
        break;
    case ASN1characterstring_identification_syntax_o:
        if ((ret = ASN1objectidentifier_cmp(&v1->identification.u.syntax,
            &v2->identification.u.syntax)))
            return ret;
        break;
    case ASN1characterstring_identification_presentation_context_id_o:
        if ((ret = (v1->identification.u.presentation_context_id -
            v2->identification.u.presentation_context_id)))
            return ret;
        break;
    case ASN1characterstring_identification_context_negotiation_o:
        if ((ret = (
            v1->identification.u.context_negotiation.presentation_context_id -
            v2->identification.u.context_negotiation.presentation_context_id)))
            return ret;
        if ((ret = ASN1objectidentifier_cmp(
            &v1->identification.u.context_negotiation.transfer_syntax,
            &v2->identification.u.context_negotiation.transfer_syntax)))
            return ret;
        break;
    case ASN1characterstring_identification_transfer_syntax_o:
        if ((ret = ASN1objectidentifier_cmp(
            &v1->identification.u.transfer_syntax,
            &v2->identification.u.transfer_syntax)))
            return ret;
        break;
    case ASN1characterstring_identification_fixed_o:
        break;
    }
    if ((ret = (v1->data_value.o - v2->data_value.o)))
        return ret;
    switch (v1->data_value.o) {
    case ASN1characterstring_data_value_notation_o:
        if ((ret = ASN1open_cmp(&v1->data_value.u.notation,
            &v2->data_value.u.notation)))
            return ret;
        break;
    case ASN1characterstring_data_value_encoded_o:
        if ((ret = ASN1octetstring_cmp(&v1->data_value.u.encoded,
            &v2->data_value.u.encoded)))
            return ret;
        break;
    }
    return 0;
}

#endif // ENABLE_GENERALIZED_CHAR_STR

/* compare two utc times; return 0 iff equal */
int ASN1utctime_cmp(ASN1utctime_t *v1, ASN1utctime_t *v2)
{
    if (v1->universal != v2->universal || v1->diff != v2->diff)
        return 1;
    if (v1->year != v2->year)
        return v1->year - v2->year;
    if (v1->month != v2->month)
        return v1->month - v2->month;
    if (v1->day != v2->day)
        return v1->day - v2->day;
    if (v1->hour != v2->hour)
        return v1->hour - v2->hour;
    if (v1->minute != v2->minute)
        return v1->minute - v2->minute;
    return v1->second - v2->second;
}

/* compare two generalized times; return 0 iff equal */
int ASN1generalizedtime_cmp(ASN1generalizedtime_t *v1, ASN1generalizedtime_t *v2)
{
    if (v1->universal != v2->universal || v1->diff != v2->diff)
        return 1;
    if (v1->year != v2->year)
        return v1->year - v2->year;
    if (v1->month != v2->month)
        return v1->month - v2->month;
    if (v1->day != v2->day)
        return v1->day - v2->day;
    if (v1->hour != v2->hour)
        return v1->hour - v2->hour;
    if (v1->minute != v2->minute)
        return v1->minute - v2->minute;
    if (v1->second != v2->second)
        return v1->second - v2->second;
    return v1->millisecond - v2->millisecond;
}

/* compare two open type values; return 0 iff equal */
int ASN1open_cmp(ASN1open_t *v1, ASN1open_t *v2)
{
    ASN1octetstring_t ostr1, ostr2;
    ostr1.length = v1->length;
    ostr1.value = v1->encoded;
    ostr2.length = v2->length;
    ostr2.value = v2->encoded;
    return ASN1octetstring_cmp(&ostr1, &ostr2);
}

/* compare two sequence of values with length-pointer representation */
/* return 0 iff equal */
int ASN1sequenceoflengthpointer_cmp(ASN1uint32_t l1, void *v1, ASN1uint32_t l2, void *v2, ASN1uint32_t size, int (*cmpfn)(void *v1, void *v2))
{
    int ret;
    ASN1octet_t *p1, *p2;

    if ((ret = (l1 - l2)))
        return ret;
    for (p1 = (ASN1octet_t *)v1, p2 = (ASN1octet_t *)v2; l1--;
        p1 += size, p2 += size) {
        if ((ret = cmpfn(p1, p2)))
            return ret;
    }
    return 0;
}

/* compare two sequence of values with singly-linked-list representation */
/* return 0 iff equal */
int ASN1sequenceofsinglylinkedlist_cmp(void *v1, void *v2, ASN1uint32_t off, int (*cmpfn)(void *, void *))
{
    int ret;
    ASN1octet_t *p1, *p2;

    for (p1 = (ASN1octet_t *)v1, p2 = (ASN1octet_t *)v2; p1 && p2;
        p1 = *(ASN1octet_t **)p1, p2 = *(ASN1octet_t **)p2) {
        if ((ret = cmpfn(p1 + off, p2 + off)))
            return ret;
    }
    return 0;
}

/* compare two sequence of values with doubly-linked-list representation */
/* return 0 iff equal */
int ASN1sequenceofdoublylinkedlist_cmp(void *v1, void *v2, ASN1uint32_t off, int (*cmpfn)(void *, void *))
{
    int ret;
    ASN1octet_t *p1, *p2;

    for (p1 = (ASN1octet_t *)v1, p2 = (ASN1octet_t *)v2; p1 && p2;
        p1 = *(ASN1octet_t **)p1, p2 = *(ASN1octet_t **)p2) {
        if ((ret = cmpfn(p1 + off, p2 + off)))
            return ret;
    }
    return 0;
}

/* compare two set of values with length-pointer representation */
/* return 0 iff equal */
int ASN1setoflengthpointer_cmp(ASN1uint32_t l1, void *v1, ASN1uint32_t l2, void *v2, ASN1uint32_t size, int (*cmpfn)(void *v1, void *v2))
{
    int ret;
    ASN1octet_t *p1, *p2, *found, *f;
    ASN1uint32_t l;

    if ((ret = (l1 - l2)))
        return ret;
    if (!l1)
        return 0;
    found = (ASN1octet_t *)MemAlloc(l1, UNKNOWN_MODULE);
    if (found)
    {
        memset(found, 0, l1);
        for (p1 = (ASN1octet_t *)v1; l1--; p1 += size) {
            for (p2 = (ASN1octet_t *)v2, l = l2, f = found; l; p2 += size, f++, l--) {
                if (!*f && !cmpfn(p1, p2)) {
                    *f = 1;
                    break;
                }
            }
            if (!l) {
                MemFree(found);
                return 1;
            }
        }
        MemFree(found);
    }
    return 0;
}

/* compare two set of values with singly-linked-list representation */
/* return 0 iff equal */
int ASN1setofsinglylinkedlist_cmp(void *v1, void *v2, ASN1uint32_t off, int (*cmpfn)(void *, void *))
{
    int ret;
    ASN1octet_t *p1, *p2, *found, *f;
    ASN1uint32_t l1, l2;

    for (p1 = (ASN1octet_t *)v1, l1 = 0; p1; p1 = *(ASN1octet_t **)p1)
        l1++;
    for (p2 = (ASN1octet_t *)v2, l2 = 0; p2; p2 = *(ASN1octet_t **)p2)
        l2++;
    if ((ret = (l1 - l2)))
        return ret;
    if (!l1)
        return 0;
    found = (ASN1octet_t *)MemAlloc(l1, UNKNOWN_MODULE);
    if (found)
    {
        memset(found, 0, l1);
        for (p1 = (ASN1octet_t *)v1; p1; p1 = *(ASN1octet_t **)p1) {
            for (p2 = (ASN1octet_t *)v2, f = found; p2; p2 = *(ASN1octet_t **)p2, f++) {
                if (!*f && !cmpfn(p1 + off, p2 + off)) {
                    *f = 1;
                    break;
                }
            }
            if (!p2) {
                MemFree(found);
                return 1;
            }
        }
        MemFree(found);
    }
    return 0;
}

/* compare two set of values with doubly-linked-list representation */
/* return 0 iff equal */
int ASN1setofdoublylinkedlist_cmp(void *v1, void *v2, ASN1uint32_t off, int (*cmpfn)(void *, void *))
{
    int ret;
    ASN1octet_t *p1, *p2, *found, *f;
    ASN1uint32_t l1, l2;

    for (p1 = (ASN1octet_t *)v1, l1 = 0; p1; p1 = *(ASN1octet_t **)p1)
        l1++;
    for (p2 = (ASN1octet_t *)v2, l2 = 0; p2; p2 = *(ASN1octet_t **)p2)
        l2++;
    if ((ret = (l1 - l2)))
        return ret;
    if (!l1)
        return 0;
    found = (ASN1octet_t *)MemAlloc(l1, UNKNOWN_MODULE);
    if (found)
    {
        memset(found, 0, l1);
        for (p1 = (ASN1octet_t *)v1; p1; p1 = *(ASN1octet_t **)p1) {
            for (p2 = (ASN1octet_t *)v2, f = found; p2; p2 = *(ASN1octet_t **)p2, f++) {
                if (!*f && !cmpfn(p1 + off, p2 + off)) {
                    *f = 1;
                    break;
                }
            }
            if (!p2) {
                MemFree(found);
                return 1;
            }
        }
        MemFree(found);
    }
    return 0;
}

#endif // defined(ENABLE_COMPARE) || defined(ENABLE_BER)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\msasn1\intx.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

// lonchanc: we seem to have a significant amount of memory leak
// while dealing with real number and unlimited integers.
// we definitely want to re-visit all the following routines carefully
// in the future.
// moreover, we need to make sure all the memory allocation and free
// are either using encoding and decoding memory manager or kernel one.
// need to make sure we do not mix them together.

#include "precomp.h"


/* builtin intx values */
ASN1octet_t ASN1intx_0_[] = { 0 };
ASN1intx_t ASN1intx_0 = { 1, ASN1intx_0_ };
ASN1octet_t ASN1intx_1_[] = { 1 };
ASN1intx_t ASN1intx_1 = { 1, ASN1intx_1_ };
ASN1octet_t ASN1intx_2_[] = { 2 };
ASN1intx_t ASN1intx_2 = { 1, ASN1intx_2_ };
ASN1octet_t ASN1intx_16_[] = { 16 };
ASN1intx_t ASN1intx_16 = { 1, ASN1intx_16_ };
ASN1octet_t ASN1intx_256_[] = { 1, 0 };
ASN1intx_t ASN1intx_256 = { 2, ASN1intx_256_ };
ASN1octet_t ASN1intx_64K_[] = { 1, 0, 0 };
ASN1intx_t ASN1intx_64K = { 3, ASN1intx_64K_ };
ASN1octet_t ASN1intx_1G_[] = { 64, 0, 0, 0 };
ASN1intx_t ASN1intx_1G = { 4, ASN1intx_1G_ };

/* add two intx values */
void ASN1intx_add(ASN1intx_t *dst, ASN1intx_t *arg1, ASN1intx_t *arg2)
{
    ASN1octet_t *v;
    int l;
    int s1, s2;
    int o1, o2;
    int i;
    int c;
    int w;

    /* get signs */
    s1 = arg1->value[0] > 0x7f ? 0xff : 0x00;
    s2 = arg2->value[0] > 0x7f ? 0xff : 0x00;

    /* result length will be <= l */
    l = arg1->length > arg2->length ? arg1->length + 1 : arg2->length + 1;

    /* offset into values */
    o1 = l - arg1->length;
    o2 = l - arg2->length;

    /* allocate result */
    v = (ASN1octet_t *)MemAlloc(l, UNKNOWN_MODULE);
    if (v)
    {
        /* clear carry bit */
        c = 0;

        /* add octet by octet */
        for (i = l - 1; i >= 0; i--) {
            w = (i >= o1 ? arg1->value[i - o1] : s1) + (i >= o2 ? arg2->value[i - o2] : s2) + c;
            v[i] = (ASN1octet_t)w;
            c = w > 0xff;
        }

        /* octets which may shall dropped */
        w = v[0] > 0x7f ? 0xff : 0x00;

        /* count octets that shall be dropped */
        for (i = 0; i < l - 1; i++) {
            if (v[i] != w)
                break;
        }
        if ((v[i] ^ w) & 0x80)
            i--;

        /* allocate and copy result */
        dst->length = l - i;
        dst->value = (ASN1octet_t *)MemAlloc(l - i, UNKNOWN_MODULE);
        if (dst->value)
        {
            CopyMemory(dst->value, v + i, l - i);
        }
        MemFree(v);
    }
}

/* substract two intx values */
void ASN1intx_sub(ASN1intx_t *dst, ASN1intx_t *arg1, ASN1intx_t *arg2)
{
    ASN1octet_t *v;
    int l;
    int s1, s2;
    int o1, o2;
    int i;
    int c;
    int w;

    /* get signs */
    s1 = arg1->value[0] > 0x7f ? 0xff : 0x00;
    s2 = arg2->value[0] > 0x7f ? 0xff : 0x00;

    /* result length will be <= l */
    l = arg1->length > arg2->length ? arg1->length + 1 : arg2->length + 1;

    /* offset into values */
    o1 = l - arg1->length;
    o2 = l - arg2->length;

    /* allocate result */
    v = (ASN1octet_t *)MemAlloc(l, UNKNOWN_MODULE);
    if (v)
    {
        /* clear borrow bit */
        c = 0;

        /* substract octet by octet */
        for (i = l - 1; i >= 0; i--) {
            w = (i >= o1 ? arg1->value[i - o1] : s1) - (i >= o2 ? arg2->value[i - o2] : s2) - c;
            v[i] = (ASN1octet_t)w;
            c = w < 0;
        }

        /* octets which may shall dropped */
        w = v[0] > 0x7f ? 0xff : 0x00;

        /* count octets that shall be dropped */
        for (i = 0; i < l - 1; i++) {
            if (v[i] != w)
                break;
        }
        if ((v[i] ^ w) & 0x80)
            i--;

    // lonchanc: do we forget to free dst->value???
    // in case that dst and arg1 are identical. for instance, 
    // ASN1BEREncReal() calls ASN1intx_sub(&exponent, &exponent, &help);
        /* allocate and copy result */
        dst->length = l - i;
        dst->value = (ASN1octet_t *)MemAlloc(l - i, UNKNOWN_MODULE);
        if (dst->value)
        {
            CopyMemory(dst->value, v + i, l - i);
        }
        MemFree(v);
    }
}

/* add one octet to an intx */
#ifdef ENABLE_ALL
void ASN1intx_addoctet(ASN1intx_t *dst, ASN1intx_t *arg1, ASN1octet_t arg2)
{
    ASN1octet_t *v;
    int l;
    int i;
    int c;
    int w;

    /* result length will be <= l */
    l = arg1->length + 1;

    /* allocate result */
    v = (ASN1octet_t *)MemAlloc(l, UNKNOWN_MODULE);
    if (v)
    {
        /* add octet by octet */
        c = arg2;
        for (i = l - 2; i >= 0; i--) {
            w = arg1->value[i] + c;
            v[i + 1] = (ASN1octet_t)w;
            c = (w > 0xff);
        }
        v[0] = arg1->value[0] > 0x7f ? (ASN1octet_t)(0xff + c) : (ASN1octet_t)c;

        /* octets which may shall dropped */
        w = v[0] > 0x7f ? 0xff : 0x00;

        /* count octets that shall be dropped */
        for (i = 0; i < l - 1; i++) {
            if (v[i] != w)
                break;
        }
        if ((v[i] ^ w) & 0x80)
            i--;

        /* allocate and copy result */
        dst->length = l - i;
        dst->value = (ASN1octet_t *)MemAlloc(l - i, UNKNOWN_MODULE);
        if (dst->value)
        {
            CopyMemory(dst->value, v + i, l - i);
        }
        MemFree(v);
    }
}
#endif // ENABLE_ALL

/* substract one octet to an intx */
#ifdef ENABLE_ALL
void ASN1intx_suboctet(ASN1intx_t *dst, ASN1intx_t *arg1, ASN1octet_t arg2)
{
    ASN1octet_t *v;
    int l;
    int i;
    int c;
    int w;

    /* result length will be <= l */
    l = arg1->length + 1;

    /* allocate result */
    v = (ASN1octet_t *)MemAlloc(l, UNKNOWN_MODULE);
    if (v)
    {
        /* substract octet by octet */
        c = arg2;
        for (i = l - 2; i >= 0; i--) {
            w = arg1->value[i] - c;
            v[i + 1] = (ASN1octet_t)w;
            c = (w < 0);
        }
        v[0] = arg1->value[0] > 0x7f ? (ASN1octet_t)(0xff - c) : (ASN1octet_t)c;

        /* octets which may shall dropped */
        w = v[0] > 0x7f ? 0xff : 0x00;

        /* count octets that shall be dropped */
        for (i = 0; i < l - 1; i++) {
            if (v[i] != w)
                break;
        }
        if ((v[i] ^ w) & 0x80)
            i--;

        /* allocate and copy result */
        dst->length = l - i;
        dst->value = (ASN1octet_t *)MemAlloc(l - i, UNKNOWN_MODULE);
        if (dst->value)
        {
            CopyMemory(dst->value, v + i, l - i);
        }
        MemFree(v);
    }
}
#endif // ENABLE_ALL

/* multiply intx by an octet */
void ASN1intx_muloctet(ASN1intx_t *dst, ASN1intx_t *arg1, ASN1octet_t arg2)
{
    ASN1octet_t *v;
    int l;
    int c;
    int i;
    int w;

    /* result length will be <= l */
    l = arg1->length + 1;

    /* allocate result */
    v = (ASN1octet_t *)MemAlloc(l, UNKNOWN_MODULE);
    if (v)
    {
        /* multiply octet by octet */
        c = 0;
        for (i = l - 2; i >= 0; i--) {
            w = arg1->value[i] * arg2 + c;
            v[i + 1] = (ASN1octet_t)w;
            c = w >> 8;
        }
        v[0] = (ASN1octet_t)(arg1->value[0] > 0x7f ? 0xff * arg2 + c : c);

        /* octets which may shall dropped */
        w = v[0] > 0x7f ? 0xff : 0x00;

        /* count octets that shall be dropped */
        for (i = 0; i < l - 1; i++) {
            if (v[i] != w)
                break;
        }
        if ((v[i] ^ w) & 0x80)
            i--;

        /* allocate and copy result */
        dst->length = l - i;
        dst->value = (ASN1octet_t *)MemAlloc(l - i, UNKNOWN_MODULE);
        if (dst->value)
        {
            CopyMemory(dst->value, v + i, l - i);
        }
        MemFree(v);
    }
}

/* increment an intx */
#ifdef ENABLE_ALL
void ASN1intx_inc(ASN1intx_t *val)
{
    ASN1octet_t *v;
    int l;
    int i;
    int w;

    /* result length will be <= l */
    l = val->length + 1;

    /* allocate result */
    v = (ASN1octet_t *)MemAlloc(l, UNKNOWN_MODULE);
    if (v)
    {
        /* copy value */
        CopyMemory(v + 1, val->value, l - 1);
        MemFree(val->value);
        v[0] = v[1] > 0x7f ? 0xff : 0x00;

        /* increment value */
        for (i = l - 1; i >= 0; i--) {
            if (++v[i])
                break;
        }

        /* octets which may shall dropped */
        w = v[0] > 0x7f ? 0xff : 0x00;

        /* count octets that shall be dropped */
        for (i = 0; i < l - 1; i++) {
            if (v[i] != w)
                break;
        }
        if ((v[i] ^ w) & 0x80)
            i--;

        /* allocate and copy result */
        val->length = l - i;
        val->value = (ASN1octet_t *)MemAlloc(l - i, UNKNOWN_MODULE);
        if (val->value)
        {
            CopyMemory(val->value, v + i, l - i);
        }
        MemFree(v);
    }
}
#endif // ENABLE_ALL

/* decrement an intx */
#ifdef ENABLE_ALL
void ASN1intx_dec(ASN1intx_t *val)
{
    ASN1octet_t *v;
    int l;
    int i;
    int w;

    /* result length will be <= l */
    l = val->length + 1;

    /* allocate result */
    v = (ASN1octet_t *)MemAlloc(l, UNKNOWN_MODULE);
    if (v)
    {
        /* copy value */
        CopyMemory(v + 1, val->value, l - 1);
        MemFree(val->value);
        v[0] = v[1] > 0x7f ? 0xff : 0x00;

        /* decrement value */
        for (i = l - 1; i >= 0; i--) {
            if (v[i]--)
                break;
        }

        /* octets which may shall dropped */
        w = v[0] > 0x7f ? 0xff : 0x00;

        /* count octets that shall be dropped */
        for (i = 0; i < l - 1; i++) {
            if (v[i] != w)
                break;
        }
        if ((v[i] ^ w) & 0x80)
            i--;

        /* allocate and copy result */
        val->length = l - i;
        val->value = (ASN1octet_t *)MemAlloc(l - i, UNKNOWN_MODULE);
        if (val->value)
        {
            CopyMemory(val->value, v + i, l - i);
        }
        MemFree(v);
    }
}
#endif // ENABLE_ALL

/* negate an intx value */
#ifdef ENABLE_ALL
void ASN1intx_neg(ASN1intx_t *dst, ASN1intx_t *arg)
{
    ASN1uint32_t i;

    /* duplicate value */
    if (ASN1intx_dup(dst, arg))
    {
        /* ones complement */
        for (i = 0; i < dst->length; i++)
            dst->value[i] = ~dst->value[i];
        
        /* and increment */
        ASN1intx_inc(dst);
    }
}
#endif // ENABLE_ALL

/* returns floor(log2(arg - 1)) */
#ifdef ENABLE_ALL
ASN1uint32_t ASN1intx_log2(ASN1intx_t *arg)
{
    ASN1uint32_t i;
    ASN1intx_t v;
    ASN1uint32_t n;

    if (ASN1intx_dup(&v, arg))
    {
        ASN1intx_dec(&v);
        if (v.value[0] > 0x7f) {
            ASN1intx_free(&v);
            return 0;
        }
        for (i = 0; i < v.length; i++) {
            if (v.value[i])
                break;
        }
        if (i >= v.length) {
            n = 0;
        } else if (v.value[i] > 0x7f) {
            n = 8 * (v.length - i - 1) + 8;
        } else if (v.value[i] > 0x3f) {
            n = 8 * (v.length - i - 1) + 7;
        } else if (v.value[i] > 0x1f) {
            n = 8 * (v.length - i - 1) + 6;
        } else if (v.value[i] > 0x0f) {
            n = 8 * (v.length - i - 1) + 5;
        } else if (v.value[i] > 0x07) {
            n = 8 * (v.length - i - 1) + 4;
        } else if (v.value[i] > 0x03) {
            n = 8 * (v.length - i - 1) + 3;
        } else if (v.value[i] > 0x01) {
            n = 8 * (v.length - i - 1) + 2;
        } else {
            n = 8 * (v.length - i - 1) + 1;
        }
        ASN1intx_free(&v);
        return n;
    }
    return 0;
}
#endif // ENABLE_ALL

/* returns floor(log2(arg - 1)) */
#ifdef ENABLE_ALL
ASN1uint32_t ASN1uint32_log2(ASN1uint32_t arg)
{
    ASN1uint32_t i;

    arg--;
    for (i = 32; i != 0; i--) {
        if (arg & (1 << (i - 1)))
            break;
    }
    return i;
}
#endif // ENABLE_ALL

/* returns floor(log256(arg - 1)) */
#ifdef ENABLE_ALL
ASN1uint32_t ASN1intx_log256(ASN1intx_t *arg)
{
    ASN1uint32_t i;
    ASN1intx_t v;

    if (ASN1intx_dup(&v, arg))
    {
        ASN1intx_dec(&v);
        if (v.value[0] > 0x7f) {
            ASN1intx_free(&v);
            return 0;
        }
        for (i = 0; i < v.length; i++) {
            if (v.value[i])
                break;
        }
        ASN1intx_free(&v);
        return v.length - i;
    }
    return 0;
}
#endif // ENABLE_ALL

/* returns floor(log256(arg - 1)) */
#ifdef ENABLE_ALL
ASN1uint32_t ASN1uint32_log256(ASN1uint32_t arg)
{
    if (arg > 0x10000) {
        if (arg > 0x1000000)
            return 4;
        return 3;
    }
    if (arg > 0x100)
        return 2;
    if (arg > 1)
        return 1;
    return 0;
}
#endif // ENABLE_ALL

/* compare two intx values; return 0 iff equal */
#ifdef ENABLE_ALL
ASN1int32_t ASN1intx_cmp(ASN1intx_t *arg1, ASN1intx_t *arg2)
{
    int s1, s2;
    int o1, o2;
    int l;
    int i;
    int d;

    s1 = arg1->value[0] > 0x7f ? 0xff : 0x00;
    s2 = arg2->value[0] > 0x7f ? 0xff : 0x00;
    if (s1 != s2)
        return s1 == 0xff ? -1 : 1;
    l = arg1->length > arg2->length ? arg1->length : arg2->length;
    o1 = l - arg1->length;
    o2 = l - arg2->length;
    for (i = 0; i < l; i++) {
        d = (i >= o1 ? arg1->value[i - o1] : s1) - (i >= o2 ? arg2->value[i - o2] : s2);
        if (d)
            return d;
    }
    return 0;
}
#endif // ENABLE_ALL

/* create an intx value from an uint32 value */
#ifdef ENABLE_ALL
void ASN1intx_setuint32(ASN1intx_t *dst, ASN1uint32_t val)
{
    ASN1octet_t o[5], *v = o;
    int n = 5;
    v[0] = 0;
    v[1] = (ASN1octet_t)(val >> 24);
    v[2] = (ASN1octet_t)(val >> 16);
    v[3] = (ASN1octet_t)(val >> 8);
    v[4] = (ASN1octet_t)(val);
    while (n > 1 && !*v && v[1] <= 0x7f) {
        n--;
        v++;
    }
    dst->length = n;
    dst->value = (ASN1octet_t *)MemAlloc(n, UNKNOWN_MODULE);
    if (dst->value)
    {
        CopyMemory(dst->value, v, n);
    }
}
#endif // ENABLE_ALL

/* create an intx value from an int32 value */
#ifdef ENABLE_ALL
void ASN1intx_setint32(ASN1intx_t *dst, ASN1int32_t val)
{
    ASN1octet_t o[5], *v = o;
    int n = 5;
    v[0] = (ASN1octet_t)(val < 0 ? 0xff : 0x00);
    v[1] = (ASN1octet_t)(val >> 24);
    v[2] = (ASN1octet_t)(val >> 16);
    v[3] = (ASN1octet_t)(val >> 8);
    v[4] = (ASN1octet_t)(val);
    while (n > 1 && ((!*v && v[1] <= 0x7f) || (*v == 0xff && v[1] > 0x7f))) {
        n--;
        v++;
    }
    dst->length = n;
    dst->value = (ASN1octet_t *)MemAlloc(n, UNKNOWN_MODULE);
    if (dst->value)
    {
        CopyMemory(dst->value, v, n);
    }
}
#endif // ENABLE_ALL

/* copy constructor */
ASN1int32_t ASN1intx_dup(ASN1intx_t *dst, ASN1intx_t *val)
{
    dst->length = val->length;
    dst->value = (ASN1octet_t *)MemAlloc(val->length, UNKNOWN_MODULE);
    if (dst->value)
    {
        CopyMemory(dst->value, val->value, val->length);
        return 1;
    }

    // fail to allocate memory
    dst->length = 0;
    return 0;
}

/* free an intx value */
void ASN1intx_free(ASN1intx_t *val)
{
    if (val)
    {
        MemFree(val->value);
    }
}

#ifdef HAS_SIXTYFOUR_BITS
/* convert an intx value to a uint64 value */
#ifdef ENABLE_ALL
ASN1uint64_t ASN1intx2uint64(ASN1intx_t *val)
{
    switch (val->length) {
    case 1:
        return (ASN1uint64_t)val->value[val->length - 1];
    case 2:
        return (ASN1uint64_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8));
    case 3:
        return (ASN1uint64_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16));
    case 4:
        return (ASN1uint64_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16) |
            ((ASN1uint32_t)val->value[val->length - 4] << 24));
    case 5:
        return (ASN1uint64_t)(val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32));
    case 6:
        return (ASN1uint64_t)(val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32) |
            ((ASN1uint64_t)val->value[val->length - 6] << 40));
    case 7:
        return (ASN1uint64_t)(val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32) |
            ((ASN1uint64_t)val->value[val->length - 6] << 40) |
            ((ASN1uint64_t)val->value[val->length - 7] << 48));
    default:
        return (ASN1uint64_t)(val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32) |
            ((ASN1uint64_t)val->value[val->length - 6] << 40) |
            ((ASN1uint64_t)val->value[val->length - 7] << 48) |
            ((ASN1uint64_t)val->value[val->length - 8] << 56));
    }
}
#endif // ENABLE_ALL
#endif

/* check if intx value is a uint64 value */
#ifdef ENABLE_ALL
int ASN1intxisuint64(ASN1intx_t *val)
{
    if (val->value[0] > 0x7f)
        return 0;
    return ASN1intx_uoctets(val) <= 8;
}
#endif // ENABLE_ALL

#ifdef HAS_SIXTYFOUR_BITS
/* convert an intx value to a int64 value */
#ifdef ENABLE_ALL
ASN1int64_t ASN1intx2int64(ASN1intx_t *val)
{
    switch (val->length) {
    case 1:
        return (ASN1int64_t)(ASN1int8_t)val->value[val->length - 1];
    case 2:
        return (ASN1int64_t)(ASN1int16_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8));
    case 3:
        return (ASN1int64_t)(ASN1int32_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16) |
            ((ASN1uint32_t)val->value[val->length - 3] > 0x7f ?
            0xffffffffff000000LL : 0));
    case 4:
        return (ASN1int64_t)(ASN1int32_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16) |
            ((ASN1uint32_t)val->value[val->length - 4] << 24));
    case 5:
        return (ASN1int64_t)(val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32) |
            ((ASN1uint64_t)val->value[val->length - 5] > 0x7f ?
            0xffffff0000000000LL : 0));
    case 6:
        return (ASN1int64_t)(val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32) |
            ((ASN1uint64_t)val->value[val->length - 6] << 40) |
            ((ASN1uint64_t)val->value[val->length - 6] > 0x7f ?
            0xffff000000000000LL : 0));
    case 7:
        return (ASN1int64_t)((ASN1uint64_t)val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32) |
            ((ASN1uint64_t)val->value[val->length - 6] << 40) |
            ((ASN1uint64_t)val->value[val->length - 7] << 48) |
            ((ASN1uint64_t)val->value[val->length - 7] > 0x7f ?
            0xff00000000000000LL : 0));
    default:
        return (ASN1int64_t)((ASN1uint64_t)val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32) |
            ((ASN1uint64_t)val->value[val->length - 6] << 40) |
            ((ASN1uint64_t)val->value[val->length - 7] << 48) |
            ((ASN1uint64_t)val->value[val->length - 8] << 56));
    }
}
#endif // USE_ASN1intx2int64
#endif

/* check if intx value is an int64 value */
#ifdef USE_ASN1intxisint64
int
ASN1intxisint64(ASN1intx_t *val)
{
    return ASN1intx_octets(val) <= 8;
}
#endif // USE_ASN1intxisint64

/* convert intx value to uint32 value */
#ifdef ENABLE_ALL
ASN1uint32_t ASN1intx2uint32(ASN1intx_t *val)
{
    switch (val->length) {
    case 1:
        return (ASN1uint32_t)val->value[val->length - 1];
    case 2:
        return (ASN1uint32_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8));
    case 3:
        return (ASN1uint32_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16));
    default:
        return (ASN1uint32_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16) |
            ((ASN1uint32_t)val->value[val->length - 4] << 24));
    }
}
#endif // ENABLE_ALL

/* check if intx value is an uint32 value */
#ifdef ENABLE_ALL
int ASN1intxisuint32(ASN1intx_t *val)
{
    if (val->value[0] > 0x7f)
        return 0;
    return ASN1intx_uoctets(val) <= 4;
}
#endif // ENABLE_ALL

/* convert intx value to int32 value */
ASN1int32_t ASN1intx2int32(ASN1intx_t *val)
{
    switch (val->length) {
    case 1:
        return (ASN1int32_t)(ASN1int8_t)val->value[val->length - 1];
    case 2:
        return (ASN1int32_t)(ASN1int16_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8));
    case 3:
        return (ASN1int32_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16) |
            ((ASN1uint32_t)val->value[val->length - 3] > 0x7f ?
            0xff000000 : 0));
    default:
        return (ASN1int32_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16) |
            ((ASN1uint32_t)val->value[val->length - 4] << 24));
    }
}

/* check if intx value is an int32 value */
#ifdef ENABLE_ALL
int ASN1intxisint32(ASN1intx_t *val)
{
    return ASN1intx_octets(val) <= 4;
}
#endif // ENABLE_ALL

/* convert intx value to uint16 value */
#ifdef ENABLE_ALL
ASN1uint16_t ASN1intx2uint16(ASN1intx_t *val)
{
    if (val->length == 1)
        return (ASN1uint16_t)val->value[val->length - 1];
    return (ASN1uint16_t)(val->value[val->length - 1] |
        ((ASN1uint32_t)val->value[val->length - 2] << 8));
}
#endif // ENABLE_ALL

/* check if intx value is an uint16 value */
#ifdef ENABLE_ALL
int ASN1intxisuint16(ASN1intx_t *val)
{
    if (val->value[0] > 0x7f)
        return 0;
    return ASN1intx_uoctets(val) <= 2;
}
#endif // ENABLE_ALL

/* convert intx value to int16 value */
#ifdef ENABLE_ALL
ASN1int16_t ASN1intx2int16(ASN1intx_t *val)
{
    if (val->length == 1)
        return (ASN1int16_t)(ASN1int8_t)val->value[val->length - 1];
    return (ASN1int16_t)(val->value[val->length - 1] |
        ((ASN1uint32_t)val->value[val->length - 2] << 8));
}
#endif // ENABLE_ALL

/* check if intx value is an int16 value */
#ifdef ENABLE_ALL
int ASN1intxisint16(ASN1intx_t *val)
{
    return ASN1intx_octets(val) <= 2;
}
#endif // ENABLE_ALL

/* convert intx value to uint8 value */
#ifdef ENABLE_ALL
ASN1uint8_t ASN1intx2uint8(ASN1intx_t *val)
{
    return (ASN1uint8_t)val->value[val->length - 1];
}
#endif // ENABLE_ALL

/* check if intx value is an uint8 value */
#ifdef ENABLE_ALL
int ASN1intxisuint8(ASN1intx_t *val)
{
    if (val->value[0] > 0x7f)
        return 0;
    return ASN1intx_uoctets(val) <= 1;
}
#endif // ENABLE_ALL

/* convert intx value to int8 value */
#ifdef ENABLE_ALL
ASN1int8_t ASN1intx2int8(ASN1intx_t *val)
{
    return (ASN1int8_t)val->value[val->length - 1];
}
#endif // ENABLE_ALL

/* check if intx value is an int8 value */
#ifdef ENABLE_ALL
int ASN1intxisint8(ASN1intx_t *val)
{
    return ASN1intx_octets(val) <= 1;
}
#endif // ENABLE_ALL

/* count octets for a signed encoding of an intx value */
#ifdef ENABLE_ALL
ASN1uint32_t ASN1intx_octets(ASN1intx_t *val)
{
    ASN1uint32_t i;
    ASN1uint32_t s;

    s = val->value[0] > 0x7f ? 0xff : 0x00;
    for (i = 0; i < val->length; i++) {
        if (val->value[i] != s)
            break;
    }
    if (i && ((val->value[i] ^ s) & 0x80))
        i--;
    return val->length - i;
}
#endif // ENABLE_ALL

/* count octets for unsigned encoding of an unsigned intx value */
ASN1uint32_t ASN1intx_uoctets(ASN1intx_t *val)
{
    ASN1uint32_t i;

    for (i = 0; i < val->length; i++) {
        if (val->value[i])
            break;
    }
    return val->length - i;
}

/* count octets for signed encoding of an uint32 value */
#ifdef ENABLE_ALL
ASN1uint32_t ASN1uint32_octets(ASN1uint32_t val)
{
    if (val >= 0x8000) {
        if (val >= 0x800000) {
            return ((val >= 0x80000000) ? 5 : 4);
        }
        return 3;
    }
    return ((val >= 0x80) ? 2 : 1);
}
#endif // ENABLE_ALL

/* count octets for unsigned encoding of an uint32 value */
ASN1uint32_t ASN1uint32_uoctets(ASN1uint32_t val)
{
    if (val >= 0x10000) {
        return ((val >= 0x1000000) ? 4 : 3);
    }
    return ((val >= 0x100) ? 2 : 1);
}

/* count octets for signed encoding of an int32 value */
ASN1uint32_t ASN1int32_octets(ASN1int32_t val)
{
    if (val >= 0) {
        if (val >= 0x8000) {
            return ((val >= 0x800000) ? 4 : 3);
        }
        return ((val >= 0x80) ? 2 : 1);
    }
    if (val < -0x8000) {
        return ((val < -0x800000) ? 4 : 3);
    }
    return ((val < -0x80) ? 2 : 1);
}

/* convert an intx value into a double */
#ifdef ENABLE_ALL
double ASN1intx2double(ASN1intx_t *val)
{
    double ret;
    ASN1uint32_t i;

    if (val->value[0] > 0x7f)
        ret = (double)(val->value[0] - 0x100);
    else
        ret = (double)val->value[0];
    for (i = 1; i < val->length; i++) {
        ret = ret * 256.0 + (double)val->value[i];
    }
    return ret;
}
#endif // ENABLE_ALL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\msasn1\ms_per.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

//--------------------------------------------------------------------------
//
// Module Name:  ms_per.c
//
// Brief Description:
//      This module contains the routines for the Microsoft
//      ASN.1 encoder and decoder.
//
// History:
//      10/15/97    Lon-Chan Chu (lonchanc)
//          Created.
//
// Copyright (c) 1997 Microsoft Corporation
//
//--------------------------------------------------------------------------

#include "precomp.h"

#define MLZ_FILE_ZONE   ZONE_MSPER


int ASN1PEREncInteger(ASN1encoding_t enc, ASN1int32_t val)
{
    ASN1uint32_t l = ASN1int32_octets(val);
    ASN1PEREncAlignment(enc);
    if (ASN1PEREncBitVal(enc, 8, l))
    {
        return ASN1PEREncBitVal(enc, l * 8, val);
    }
    return 0;
}

int ASN1PERDecInteger(ASN1decoding_t dec, ASN1int32_t *val)
{
    ASN1uint32_t l;
    ASN1PERDecAlignment(dec);
    if (ASN1PERDecFragmentedLength(dec, &l))
    {
        return ASN1PERDecS32Val(dec, l * 8, val);
    }
    return 0;
}

int ASN1PEREncUnsignedInteger(ASN1encoding_t enc, ASN1uint32_t val)
{
    ASN1uint32_t l = ASN1uint32_uoctets(val);
    ASN1PEREncAlignment(enc);
    if (ASN1PEREncBitVal(enc, 8, l))
    {
        return ASN1PEREncBitVal(enc, l * 8, val);
    }
    return 0;
}

int ASN1PERDecUnsignedInteger(ASN1decoding_t dec, ASN1uint32_t *val)
{
    ASN1uint32_t l;
    ASN1PERDecAlignment(dec);
    if (ASN1PERDecFragmentedLength(dec, &l))
    {
        return ASN1PERDecU32Val(dec, l * 8, val);
    }
    return 0;
}

int ASN1PEREncUnsignedShort(ASN1encoding_t enc, ASN1uint32_t val)
{
    ASN1PEREncAlignment(enc);
    return ASN1PEREncBitVal(enc, 16, val);
}

int ASN1PERDecUnsignedShort(ASN1decoding_t dec, ASN1uint16_t *val)
{
    ASN1PERDecAlignment(dec);
    return ASN1PERDecU16Val(dec, 16, val);
}

int ASN1PEREncBoolean(ASN1encoding_t enc, ASN1bool_t val)
{
    return ASN1PEREncBitVal(enc, 1, val ? 1 : 0);
}

int ASN1PERDecBoolean(ASN1decoding_t dec, ASN1bool_t *val)
{
    DecAssert(dec, sizeof(ASN1bool_t) == sizeof(ASN1uint8_t));
    *val = 0; // in case we change the boolean type
    return ASN1PERDecU8Val(dec, 1, val);
}

__inline int _EncExtensionBitClear(ASN1encoding_t enc)
{
    return ASN1PEREncBitVal(enc, 1, 0);
}

int ASN1PEREncExtensionBitClear(ASN1encoding_t enc)
{
    return _EncExtensionBitClear(enc);
}

__inline int _EncExtensionBitSet(ASN1encoding_t enc)
{
    return ASN1PEREncBitVal(enc, 1, 1);
}

int ASN1PEREncExtensionBitSet(ASN1encoding_t enc)
{
    return _EncExtensionBitSet(enc);
}

int ASN1PERDecSkipNormallySmallExtensionFragmented(ASN1decoding_t dec)
{
    ASN1uint32_t e, i;
    if (ASN1PERDecSkipNormallySmallExtension(dec, &e))
    {
        for (i = 0; i < e; i++)
        {
            if (ASN1PERDecSkipFragmented(dec, 8))
            {
                continue;
            }
            return 0;
        }
        return 1;
    }
    return 0;
}

int ASN1PEREncSimpleChoice(ASN1encoding_t enc, ASN1choice_t ChoiceVal, ASN1int32_t cChoiceBits)
{
    if (ChoiceVal >= ASN1_CHOICE_BASE)
    {
        ChoiceVal -= ASN1_CHOICE_BASE;
        return (cChoiceBits ? ASN1PEREncBitVal(enc, cChoiceBits, ChoiceVal) : 1);
    }
    EncAssert(enc, FALSE);
    return 0;
}

int ASN1PERDecSimpleChoice(ASN1decoding_t dec, ASN1choice_t *pChoiceVal, ASN1int32_t cChoiceBits)
{
    DecAssert(dec, cChoiceBits <= sizeof(ASN1choice_t) * 8);
    *pChoiceVal = ASN1_CHOICE_BASE; // default choice
    if (cChoiceBits)
    {
        if (ASN1PERDecU16Val(dec, cChoiceBits, pChoiceVal))
        {
            *pChoiceVal += ASN1_CHOICE_BASE;
        }
        else
        {
            return 0;
        }
    }
    return 1;
}

int ASN1PEREncSimpleChoiceEx(ASN1encoding_t enc, ASN1choice_t ChoiceVal, ASN1int32_t cChoiceBits)
{
    if (ChoiceVal >= ASN1_CHOICE_BASE)
    {
        ChoiceVal -= ASN1_CHOICE_BASE;
        if (_EncExtensionBitClear(enc))
        {
            return (cChoiceBits ? ASN1PEREncBitVal(enc, cChoiceBits, ChoiceVal) : 1);
        }
    }
    else
    {
        EncAssert(enc, 0);
    }
    return 0;
}

int ASN1PERDecSimpleChoiceEx(ASN1decoding_t dec, ASN1choice_t *pChoiceVal, ASN1int32_t cChoiceBits)
{
    ASN1uint32_t x;
    DecAssert(dec, cChoiceBits <= sizeof(ASN1choice_t) * 8);
    if (ASN1PERDecExtensionBit(dec, &x))
    {
        if (!x)
        {
            *pChoiceVal = ASN1_CHOICE_BASE; // default choice
            if (cChoiceBits)
            {
                if (ASN1PERDecU16Val(dec, cChoiceBits, pChoiceVal))
                {
                    *pChoiceVal += ASN1_CHOICE_BASE;
                    return 1;
                }
                return 0;
            }
            return 1;
        }

        *pChoiceVal = ASN1_CHOICE_EXTENSION; // extension choice
        return ASN1PERDecSkipNormallySmall(dec);
    }
    return 0;
}

int ASN1PEREncComplexChoice(ASN1encoding_t enc, ASN1choice_t ChoiceVal, ASN1int32_t cChoiceBits, ASN1choice_t ExtensionChoice)
{
    if (ChoiceVal >= ASN1_CHOICE_BASE)
    {
        ChoiceVal -= ASN1_CHOICE_BASE;
        if (ChoiceVal < ExtensionChoice) // lonchanc: no equal sign
        {
            if (_EncExtensionBitClear(enc))
            {
                if (cChoiceBits)
                {
                    return ASN1PEREncBitVal(enc, cChoiceBits, ChoiceVal);
                }
                return 1;
            }
        }
        else
        {
            if (_EncExtensionBitSet(enc))
            {
                return ASN1PEREncNormallySmall(enc, ChoiceVal - ExtensionChoice);
            }
        }
    }
    else
    {
        EncAssert(enc, 0);
    }
    return 0;
}

int ASN1PERDecComplexChoice(ASN1decoding_t dec, ASN1choice_t *pChoiceVal, ASN1int32_t cChoiceBits, ASN1choice_t ExtensionChoice)
{
    ASN1uint32_t x;
    DecAssert(dec, cChoiceBits <= sizeof(ASN1choice_t) * 8);
    if (ASN1PERDecExtensionBit(dec, &x))
    {
        if (!x)
        {
            *pChoiceVal = ASN1_CHOICE_BASE; // default choice
            if (cChoiceBits)
            {
                if (ASN1PERDecU16Val(dec, cChoiceBits, pChoiceVal))
                {
                    *pChoiceVal += ASN1_CHOICE_BASE;
                    return 1;
                }
                return 0;
            }
            return 1;
        }

        if (ASN1PERDecN16Val(dec, pChoiceVal))
        {
            *pChoiceVal += ExtensionChoice + ASN1_CHOICE_BASE;
            return 1;
        }
    }
    return 0;
}

int ASN1PEREncOctetString_NoSize(ASN1encoding_t enc, ASN1octetstring_t *pOctetStr)
{
    return ASN1PEREncFragmented(enc, pOctetStr->length, pOctetStr->value, 8);
}

int ASN1PERDecOctetString_NoSize(ASN1decoding_t dec, ASN1octetstring_t *pOctetStr)
{
    return ASN1PERDecFragmented(dec, &(pOctetStr->length), &(pOctetStr->value), 8);
}

int _PEREncOctetString2
(
    ASN1encoding_t      enc,
    ASN1uint32_t        length,
    ASN1octet_t        *value,
    ASN1uint32_t        nSizeLowerBound,
    ASN1uint32_t        nSizeUpperBound,
    ASN1uint32_t        cSizeBits
)
{
    // fixed size array?
    if (nSizeLowerBound == nSizeUpperBound)
    {
        ASN1uint32_t nSizeLimit = nSizeLowerBound;
        EncAssert(enc, cSizeBits == 0);
        EncAssert(enc, nSizeLimit < 64 * 1024);
        if (length == nSizeLimit)
        {
            if (nSizeLimit > 2)
            {
                ASN1PEREncAlignment(enc);
            }
            return ASN1PEREncBits(enc, nSizeLimit * 8, value);
        }
        EncAssert(enc, 0);
        return 0;
    }

    // ranged size array
    EncAssert(enc, cSizeBits);
    EncAssert(enc, nSizeLowerBound < nSizeUpperBound);
    if (nSizeLowerBound <= length && length <= nSizeUpperBound)
    {
        if (nSizeUpperBound - nSizeLowerBound < 255) // lonchanc: inherited from TELES
        {
            if (ASN1PEREncBitVal(enc, cSizeBits, length - nSizeLowerBound))
            {
                ASN1PEREncAlignment(enc);
            }
            else
            {
                return 0;
            }
        }
        else
        {
            EncAssert(enc, cSizeBits % 8 == 0);
            ASN1PEREncAlignment(enc);
            if (!ASN1PEREncBitVal(enc, cSizeBits, length - nSizeLowerBound))
                return 0;
        }
        return ASN1PEREncBits(enc, length * 8, value);
    }
    EncAssert(enc, 0);
    return 0;
}

int ASN1PEREncOctetString_FixedSize(ASN1encoding_t enc, ASN1octetstring2_t *pOctetStr, ASN1uint32_t nSizeLimit)
{
    return _PEREncOctetString2(enc, pOctetStr->length, &(pOctetStr->value[0]), nSizeLimit, nSizeLimit, 0);
}

int ASN1PEREncOctetString_FixedSizeEx(ASN1encoding_t enc, ASN1octetstring_t *pOctetStr, ASN1uint32_t nSizeLimit)
{
    return _PEREncOctetString2(enc, pOctetStr->length, pOctetStr->value, nSizeLimit, nSizeLimit, 0);
}

int ASN1PEREncOctetString_VarSize(ASN1encoding_t enc, ASN1octetstring2_t *pOctetStr, ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits)
{
    return _PEREncOctetString2(enc, pOctetStr->length, &(pOctetStr->value[0]), nSizeLowerBound, nSizeUpperBound, cSizeBits);
}

int ASN1PEREncOctetString_VarSizeEx(ASN1encoding_t enc, ASN1octetstring_t *pOctetStr, ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits)
{
    return _PEREncOctetString2(enc, pOctetStr->length, pOctetStr->value, nSizeLowerBound, nSizeUpperBound, cSizeBits);
}


int _PERDecOctetString2
(
    ASN1decoding_t      dec,
    ASN1uint32_t       *length,
    ASN1octet_t       **value,
    ASN1uint32_t        nSizeLowerBound,
    ASN1uint32_t        nSizeUpperBound,
    ASN1uint32_t        cSizeBits
)
{
    // fixed size array?
    if (nSizeLowerBound == nSizeUpperBound)
    {
        ASN1uint32_t nSizeLimit = nSizeLowerBound;
        DecAssert(dec, cSizeBits == 0);
        DecAssert(dec, nSizeLimit < 64 * 1024);
        *length = nSizeLimit;
        if (nSizeLimit > 2)
        {
            ASN1PERDecAlignment(dec);
        }
        if (NULL == *value)
        {
            // must be unbounded
            *value = (ASN1octet_t *) DecMemAlloc(dec, nSizeLimit + 1);
            if (NULL == *value)
            {
                return 0;
            }
        }
        return ASN1PERDecExtension(dec, nSizeLimit * 8, *value);
    }

    // ranged size array
    DecAssert(dec, cSizeBits);
    DecAssert(dec, nSizeLowerBound < nSizeUpperBound);
    if (nSizeUpperBound - nSizeLowerBound < 255) // lonchanc: inherited from TELES
    {
        if (ASN1PERDecU32Val(dec, cSizeBits, length))
        {
            *length += nSizeLowerBound;
            ASN1PERDecAlignment(dec);
        }
        else
        {
            return 0;
        }
    }
    else
    {
        DecAssert(dec, cSizeBits % 8 == 0);
        ASN1PERDecAlignment(dec);
        if (ASN1PERDecU32Val(dec, cSizeBits, length))
        {
            *length += nSizeLowerBound;
        }
        else
        {
            return 0;
        }
    }
    if (*length <= nSizeUpperBound)
    {
        if (NULL == *value)
        {
            *value = (ASN1octet_t *) DecMemAlloc(dec, *length + 1);
            if (NULL == *value)
            {
                return 0;
            }
        }
        return ASN1PERDecExtension(dec, *length * 8, *value);
    }
    DecAssert(dec, 0);
    return 0;

}

int ASN1PERDecOctetString_FixedSize(ASN1decoding_t dec, ASN1octetstring2_t *pOctetStr, ASN1uint32_t nSizeLimit)
{
    ASN1octet_t *pData = &(pOctetStr->value[0]);
    return _PERDecOctetString2(dec, &(pOctetStr->length), &pData, nSizeLimit, nSizeLimit, 0);
}

int ASN1PERDecOctetString_FixedSizeEx(ASN1decoding_t dec, ASN1octetstring_t *pOctetStr, ASN1uint32_t nSizeLimit)
{
    pOctetStr->value = NULL;
    return _PERDecOctetString2(dec, &(pOctetStr->length), &(pOctetStr->value), nSizeLimit, nSizeLimit, 0);
}

int ASN1PERDecOctetString_VarSize(ASN1decoding_t dec, ASN1octetstring2_t *pOctetStr, ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits)
{
    ASN1octet_t *pData = &(pOctetStr->value[0]);
    return _PERDecOctetString2(dec, &(pOctetStr->length), &pData, nSizeLowerBound, nSizeUpperBound, cSizeBits);
}

int ASN1PERDecOctetString_VarSizeEx(ASN1decoding_t dec, ASN1octetstring_t *pOctetStr, ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits)
{
    pOctetStr->value = NULL;
    return _PERDecOctetString2(dec, &(pOctetStr->length), &(pOctetStr->value), nSizeLowerBound, nSizeUpperBound, cSizeBits);
}



int ASN1PEREncSeqOf_NoSize(ASN1encoding_t enc, ASN1iterator_t **val, ASN1iterator_encfn pfnIterator)
{
    ASN1uint32_t t;
    ASN1iterator_t *f;
    ASN1uint32_t i;
    ASN1uint32_t j, n = 0x4000;
    EncAssert(enc, NULL != pfnIterator);
    for (t = 0, f = *val; f; f = f->next)
        t++;
    f = *val;
    for (i = 0; i < t;)
    {
        if (ASN1PEREncFragmentedLength(&n, enc, t - i))
        {
            for (j = 0; j < n; i++, j++)
            {
                if (((*pfnIterator)(enc, f)))
                {
                    f = f->next;
                    continue;
                }
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }

    return ((n < 0x4000) ? 1 : ASN1PEREncFragmentedLength(&n, enc, 0));
}

int ASN1PERDecSeqOf_NoSize(ASN1decoding_t dec, ASN1iterator_t **val, ASN1iterator_decfn pfnIterator, ASN1uint32_t cbElementSize)
{
    ASN1iterator_t **f;
    ASN1uint32_t l;
    ASN1uint32_t i;
    ASN1uint32_t n;
    DecAssert(dec, NULL != pfnIterator);
    f = val;
    do {
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            for (i = 0; i < n; i++)
            {
                if (NULL != (*f = (ASN1iterator_t *)DecMemAlloc(dec, cbElementSize)))
                {
                    if ((*pfnIterator)(dec, *f))
                    {
                        f = &(*f)->next;
                        continue;
                    }
                }
                return 0;
            }
        }
        else
        {
            return 0;
        }
    } while (n >= 0x4000);
    *f = NULL;
    return 1;
}

int ASN1PEREncSeqOf_VarSize(ASN1encoding_t enc, ASN1iterator_t **val, ASN1iterator_encfn pfnIterator,
        ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits)
{
    ASN1uint32_t t;
    ASN1iterator_t *f;
    for (t = 0, f = *val; f; f = f->next)
        t++;
    if (nSizeLowerBound <= t && t <= nSizeUpperBound)
    {
        if (nSizeUpperBound - nSizeLowerBound + 1 >= 256)
        {
            ASN1PEREncAlignment(enc);
        }
        if (ASN1PEREncBitVal(enc, cSizeBits, t - nSizeLowerBound))
        {
            for (f = *val; f; f = f->next)
            {
                if (((*pfnIterator)(enc, f)))
                {
                    continue;
                }
                return 0;
            }
            return 1;
        }
    }
    else
    {
        EncAssert(enc, 0);
    }
    return 0;
}

int ASN1PERDecSeqOf_VarSize(ASN1decoding_t dec, ASN1iterator_t **val, ASN1iterator_decfn pfnIterator, ASN1uint32_t cbElementSize,
        ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits)
{
    ASN1iterator_t **f;
    ASN1uint32_t l, i;

    if (nSizeUpperBound - nSizeLowerBound + 1 >= 256)
    {
        ASN1PERDecAlignment(dec);
    }
    if (ASN1PERDecU32Val(dec, cSizeBits, &l))
    {
        l += nSizeLowerBound;
        DecAssert(dec, l <= nSizeUpperBound);
        f = val;
        for (i = 0; i < l; i++)
        {
            if (NULL != (*f = (ASN1iterator_t *)DecMemAlloc(dec, cbElementSize)))
            {
                if ((*pfnIterator)(dec, *f))
                {
                    f = &(*f)->next;
                    continue;
                }
            }
            return 0;
        }
        *f = NULL;
        return 1;
    }
    return 0;
}

void ASN1PERFreeSeqOf(ASN1iterator_t **val, ASN1iterator_freefn pfnIterator)
{
    if (val)
    {
        ASN1iterator_t *f, *ff;
        for (f = *val; f; f = ff)
        {
            ff = f->next;
            if (pfnIterator)
            {
                (*pfnIterator)(f);
            }
            MemFree(f);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\msasn1\ms_ut.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#ifndef _MS_UT_H_
#define _MS_UT_H_

#define ARRAY_SIZE(arr)             (sizeof(arr) / sizeof(arr[0]))
// #define FIELD_OFFSET(type, field)   ((long)&(((type *)0)->field))   // from winnt.h
#define PARAMS_SIZE_N_ARRARY(arr)   ARRAY_SIZE(arr), arr

#define LPVOID_ADD(ptr,inc)  (LPVOID) ((ASN1octet_t *) (ptr) + (ASN1uint32_t) (inc))
#define LPVOID_SUB(ptr,dec)  (LPVOID) ((ASN1octet_t *) (ptr) - (ASN1uint32_t) (inc))

#define LPVOID_NEXT(ptr)     *(LPVOID FAR *) (ptr)

// the following constants is for calculating decoded data structure size
// we are conservative here and try to be 4-byte aligned due to Alpha platform.

#define ASN1_SIZE_ALIGNED(n)    (n) = ((((n) + 3) >> 2) << 2)

#ifdef ENABLE_BER
int My_memcmp(ASN1octet_t *pBuf1, ASN1uint32_t cbBuf1Size, ASN1octet_t *pBuf2, ASN1uint32_t cbBuf2Size);
#endif // ENABLE_BER

#define UNKNOWN_MODULE                  0

#ifdef ENABLE_MEMORY_TRACKING

void   DbgMemTrackFinalCheck ( void );
LPVOID DbgMemAlloc ( UINT cbSize, ASN1uint32_t nModuleName, LPSTR pszFileName, UINT nLineNumber );
void   DbgMemFree ( LPVOID ptr );
LPVOID DbgMemReAlloc ( LPVOID ptr, UINT cbSize, ASN1uint32_t nModuleName, LPSTR pszFileName, UINT nLineNumber );

#define MemAlloc(cb,modname)            DbgMemAlloc((cb), modname, __FILE__, __LINE__)
#define MemFree(lp)                     DbgMemFree((lp))
#define MemReAlloc(lp,cb,modname)       DbgMemReAlloc((lp), (cb), modname, __FILE__, __LINE__)

#define _ModName(enc_dec)               (enc_dec)->module->nModuleName

LPVOID DbgDecMemAlloc   ( ASN1decoding_t dec, ASN1uint32_t cbSize,  LPSTR pszFileName, ASN1uint32_t nLineNumber);
LPVOID DbgDecMemReAlloc ( ASN1decoding_t dec, LPVOID lpData, ASN1uint32_t cbSize, LPSTR pszFileName, ASN1uint32_t nLineNumber);

#define DecMemAlloc(dec,cb)             DbgDecMemAlloc((dec), (cb), __FILE__, __LINE__)
#define DecMemReAlloc(dec,lp,cb)        DbgDecMemReAlloc((dec), (lp), (cb), __FILE__, __LINE__)

#define EncMemAlloc(enc,cb)             DbgMemAlloc((cb), _ModName(enc), __FILE__, __LINE__)
#define EncMemReAlloc(enc,lp,cb)        DbgMemReAlloc((lp), (cb), _ModName(enc), __FILE__, __LINE__)

#else // ! ENABLE_MEMORY_TRACKING

#define MemAllocEx(dec,cb,fZero)        LocalAlloc((fZero)?LPTR:LMEM_FIXED, (cb))
#define MemAlloc(cb,modname)            LocalAlloc(LPTR,(cb))
#define MemFree(lp)                     LocalFree(lp)
#define MemReAllocEx(dec,lp,cb,fZero)   ((lp) ? \
            LocalReAlloc((lp),(cb),(fZero)?LMEM_MOVEABLE|LMEM_ZEROINIT:LMEM_MOVEABLE) : \
            LocalAlloc((fZero)?LPTR:LMEM_FIXED, (cb)))
#define MemReAlloc(lp,cb,modname)       ((lp) ? \
            LocalReAlloc((lp),(cb),LMEM_MOVEABLE|LMEM_ZEROINIT) : \
            LocalAlloc(LPTR, (cb)))

#define _ModName(enc_dec)                   

LPVOID DecMemAlloc   ( ASN1decoding_t dec, ASN1uint32_t cbSize );
LPVOID DecMemReAlloc ( ASN1decoding_t dec, LPVOID lpData, ASN1uint32_t cbSize );

#define EncMemAlloc(enc,cb)             MemAlloc((cb),0)
#define EncMemReAlloc(enc,lp,cb)        MemReAlloc((lp),(cb),0)

#endif // ! ENABLE_MEMORY_TRACKING

void   DecMemFree    ( ASN1decoding_t dec, LPVOID lpData );

#define EncMemFree(enc,lpData)              MemFree(lpData)

int IsDigit(char p);
unsigned int  DecimalStringToUINT(char * pcszString, ASN1uint32_t cch);
void * ms_bSearch (
        const void *key,
        const void *base,
        size_t num,
        size_t width,
        int (__cdecl *compare)(const void *, const void *)
        );

#define MyAssert(f)         
#ifdef _DEBUG
    void MyDebugBreak(void);
    __inline void EncAssert(ASN1encoding_t enc, int val)
    {
        if ((! (enc->dwFlags & ASN1FLAGS_NOASSERT)) && (! (val)))
        {
            MyDebugBreak();
        }
    }
    __inline void DecAssert(ASN1decoding_t dec, int val)
    {
        if ((! (dec->dwFlags & ASN1FLAGS_NOASSERT)) && (! (val)))
        {
            MyDebugBreak();
        }
    }
#else
    #define EncAssert(enc,f)   
    #define DecAssert(dec,f)   
#endif // _DEBUG

#endif // _MS_UT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\msasn1\ms_ut.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

#ifdef _DEBUG
void MyDebugBreak(void)
{
    // to correct the misleading stack dump
    DebugBreak();
}
#endif // _DEBUG

// Memory manager for decoder
#ifdef ENABLE_MEMORY_TRACKING
LPVOID DbgDecMemAlloc ( ASN1decoding_t dec, ASN1uint32_t cbSize, LPSTR pszFileName, ASN1uint32_t nLineNumber )
#else
LPVOID DecMemAlloc ( ASN1decoding_t dec, ASN1uint32_t cbSize )
#endif
{
    LPVOID lp = NULL;
    ASN1INTERNdecoding_t lpInfo = (ASN1INTERNdecoding_t) dec;
    // make sure the size is 4-byte aligned
    ASN1_SIZE_ALIGNED(cbSize);
    // accumulate the total size
    lpInfo->cbLinearBufSize += cbSize;
    // allocate the buffer
    if (lpInfo->fExtBuf)
    {
        if (lpInfo->cbRemExtBufSize >= cbSize)
        {
            lp = lpInfo->lpRemExtBuf;
            lpInfo->lpRemExtBuf += cbSize;
            lpInfo->cbRemExtBufSize -= cbSize;
        }
        else
        {
            DecAssert(dec, FALSE);
        }
    }
    else
    {
#ifdef ENABLE_MEMORY_TRACKING
        lp = DbgMemAlloc(cbSize, _ModName(dec), pszFileName, nLineNumber);
#else
        lp = MemAllocEx(dec, cbSize, TRUE); // zero memory
#endif
    }
    // make sure to propagate error
    if (lp == NULL)
    {
        ASN1DecSetError(dec, ASN1_ERR_MEMORY);
    }
    return lp;
}

void DecMemFree ( ASN1decoding_t dec, LPVOID lpData )
{
    if (! ((ASN1INTERNdecoding_t) dec)->fExtBuf)
    {
        MemFree(lpData);
    }
}

#ifdef ENABLE_MEMORY_TRACKING
LPVOID DbgDecMemReAlloc ( ASN1decoding_t dec, LPVOID lpData, ASN1uint32_t cbSize, LPSTR pszFileName, ASN1uint32_t nLineNumber )
#else
LPVOID DecMemReAlloc ( ASN1decoding_t dec, LPVOID lpData, ASN1uint32_t cbSize )
#endif
{
    LPVOID lp = NULL;
    // make sure the size is 4-byte aligned
    ASN1_SIZE_ALIGNED(cbSize);
    // accumulate the total size
    ((ASN1INTERNdecoding_t) dec)->cbLinearBufSize += cbSize;
    // allocate the buffer
    if (((ASN1INTERNdecoding_t) dec)->fExtBuf)
    {
        if (lpData == NULL)
        {
            lp = DecMemAlloc(dec, cbSize);
        }
        else
        {
            DecAssert(dec, FALSE);
        }
    }
    else
    {
#ifdef ENABLE_MEMORY_TRACKING
        lp = DbgMemReAlloc(lpData, cbSize, _ModName(dec), pszFileName, nLineNumber);
#else
        lp = MemReAllocEx(dec, lpData, cbSize, TRUE); // zero memory
#endif
    }
    // make sure to propagate error
    if (lp == NULL)
    {
        ASN1DecSetError(dec, ASN1_ERR_MEMORY);
    }
    return lp;
}



/***
*char *ms_bSearch() - do a binary search on an array
*
*Purpose:
*       Does a binary search of a sorted array for a key.
*
*Entry:
*       const char *key    - key to search for
*       const char *base   - base of sorted array to search
*       unsigned int num   - number of elements in array
*       unsigned int width - number of bytes per element
*       int (*compare)()   - pointer to function that compares two array
*               elements, returning neg when #1 < #2, pos when #1 > #2, and
*               0 when they are equal. Function is passed pointers to two
*               array elements.
*
*Exit:
*       if key is found:
*               returns pointer to occurrence of key in array
*       if key is not found:
*               returns NULL
*
*Exceptions:
*
*******************************************************************************/

void * ms_bSearch (
        const void *key,
        const void *base,
        size_t num,
        size_t width,
        int (__cdecl *compare)(const void *, const void *)
        )
{
        char *lo = (char *)base;
        char *hi = (char *)base + (num - 1) * width;
        char *mid;
        unsigned int half;
        int result;

        while (lo <= hi)
                if (half = num / 2)
                {
                        mid = lo + (num & 1 ? half : (half - 1)) * width;
                        if (!(result = (*compare)(key,mid)))
                                return(mid);
                        else if (result < 0)
                        {
                                hi = mid - width;
                                num = num & 1 ? half : half-1;
                        }
                        else    {
                                lo = mid + width;
                                num = half;
                        }
                }
                else if (num)
                        return((*compare)(key,lo) ? NULL : lo);
                else
                        break;

        return(NULL);
}


int IsDigit(char p)
{
      return ((p >= ('0')) && (p <=('9'))) ? 1 : 0 ;
}



// BUGBUG - This is a copy of the same routine in nmutil
// BUGBUG - Remove this when we convert our files to CPP and use nmutil
/*  D E C I M A L  S T R I N G  T O  U  I  N  T  */
/*-------------------------------------------------------------------------
    %%Function: DecimalStringToUINT
    
-------------------------------------------------------------------------*/
unsigned int  DecimalStringToUINT(char * pcszString, ASN1uint32_t cch)
{
	unsigned int uRet = 0;
	char * pszStr =  pcszString;
	while (cch-- && ('\0') != pszStr[0])
	{
		uRet = (10 * uRet) + (int) (pszStr[0] - ('0'));
		pszStr++; // NOTE: DBCS characters are not allowed!
	}
	return uRet;
}


#ifdef ENABLE_BER
int My_memcmp(ASN1octet_t *pBuf1, ASN1uint32_t cbBuf1Size, ASN1octet_t *pBuf2, ASN1uint32_t cbBuf2Size)
{
    int diff;
    ASN1uint32_t cbMinBufSize = (cbBuf1Size < cbBuf2Size) ? cbBuf1Size : cbBuf2Size;
    while (cbMinBufSize--)
    {
        diff = (int) (ASN1uint32_t) *pBuf1++ - (int) (ASN1uint32_t) *pBuf2++;
        if (0 != diff)
        {
            return diff;
        }
    }
    return ((int) cbBuf1Size - (int) cbBuf2Size);
}
#endif // ENABLE_BER


// THE FOLLOWING IS FROM ILS.DLL MEMORY TRACKING

#ifdef ENABLE_MEMORY_TRACKING

#ifndef _DEBUG
void MyDebugBreak(void)
{
    // to correct the misleading stack dump
    DebugBreak();
}
#endif // _DEBUG

#define KEEP_FREE_MEM

#define DBG_NAME_LENGTH     16
typedef struct tagMemTag
{
    DWORD           dwSignature;
    BOOL            fActive;
    ASN1uint32_t    nModuleName;
    CHAR            szFileName[DBG_NAME_LENGTH];
    UINT            nLineNumber;
    UINT            cbSize;
    struct tagMemTag *next;
}
    MEM_TAG;

static MEM_TAG *s_pDbgActiveMemPool = NULL;
#ifdef KEEP_FREE_MEM
static MEM_TAG *s_pDbgFreeMemPool = NULL;
#define FREE_BYTE   ((BYTE) 0xAB)
#define TAIL_BYTE   ((BYTE) 0xEF)
#define TAIL_SIZE   8
#endif
#define CLEAN_BYTE  ((BYTE) 0xCD)
static UINT   s_cDbgActiveMemAlloc = 0;
static UINT   s_cbDbgActiveMem = 0;
const DWORD MEM_TAG_SIGNATURE = 0x12345678UL;

static BOOL s_fDbgInitCritSect = FALSE;
static CRITICAL_SECTION s_DbgCritSect;

void DbgMemTrackReverseList(void)
{
    EnterCriticalSection(&s_DbgCritSect);
    if (NULL != s_pDbgActiveMemPool && NULL != s_pDbgActiveMemPool->next)
    {
        MEM_TAG *p, *q, *r;;

        for (q = (p = s_pDbgActiveMemPool)->next, r = q; // make sure r is not null in the beginning
             NULL != r;
             p = q, q = r)
        {
            r = q->next;
            q->next = p;
        }

        s_pDbgActiveMemPool->next = NULL;
        s_pDbgActiveMemPool = p;
    }
    LeaveCriticalSection(&s_DbgCritSect);
}

#define DBG_MEM_TRACK_DUMP_ALL      ((ASN1uint32_t) -1)

void ASN1DbgMemTrackDumpCurrent ( ASN1uint32_t nModuleName )
{
    MEM_TAG *p;
    int i;
    char szMod[8];
    char szBuf[128];
    EnterCriticalSection(&s_DbgCritSect);
    for (p = s_pDbgActiveMemPool, i = 0; p; p = p->next, i++)
    {
        if (nModuleName == DBG_MEM_TRACK_DUMP_ALL || p->nModuleName == nModuleName)
        {
            ZeroMemory(szMod, sizeof(szMod));
            CopyMemory(szMod, &p->nModuleName, sizeof(ASN1uint32_t));
            wsprintfA(szBuf, "ASN1: mem leak [%u]: mod=%s, file=%s, line=%u, size=%u, ptr=0x%lx\r\n",
                        i, szMod, p->szFileName, p->nLineNumber, p->cbSize, (ASN1uint32_t) (p+1));
            OutputDebugStringA(szBuf);
        }
    }
    LeaveCriticalSection(&s_DbgCritSect);
}

void DbgMemTrackFinalCheck ( void )
{
    DbgMemTrackReverseList();
    ASN1DbgMemTrackDumpCurrent(DBG_MEM_TRACK_DUMP_ALL);
    if (NULL != s_pDbgActiveMemPool ||
        0 != s_cDbgActiveMemAlloc ||
        0 != s_cbDbgActiveMem)
    {
        MyDebugBreak();
    }

    if (s_fDbgInitCritSect)
    {
        DeleteCriticalSection(&s_DbgCritSect);
        s_fDbgInitCritSect = FALSE;
    }
}

static void _GetFileName ( LPSTR pszTarget, LPSTR pszSrc )
{
    LPSTR psz = pszSrc;
    while (*psz != '\0')
    {
        if (*psz++ == '\\')
        {
            pszSrc = psz;
        }
    }
    lstrcpynA(pszTarget, pszSrc, DBG_NAME_LENGTH);
}

static BOOL _IsFilledMemory ( LPBYTE lpb, UINT cbSize, BYTE bPattern )
{
    while (cbSize--)
    {
        if (*lpb++ != bPattern)
            return FALSE;
    }
    return TRUE;
}

LPVOID DbgMemAlloc ( UINT cbSize, ASN1uint32_t nModuleName, LPSTR pszFileName, UINT nLineNumber )
{
    MEM_TAG *p;
    UINT cbToAlloc;

    if (! s_fDbgInitCritSect)
    {
        InitializeCriticalSection(&s_DbgCritSect);
        s_fDbgInitCritSect = TRUE;
    }

    cbToAlloc = sizeof(MEM_TAG) + cbSize;

    EnterCriticalSection(&s_DbgCritSect);

#ifdef KEEP_FREE_MEM
    // add the tail size
    cbToAlloc += TAIL_SIZE;

    // any heap corruption in free pool
    {
        const int c_cKept = 32;
        MEM_TAG *q = s_pDbgFreeMemPool;
        int i;
        for (i = 0; i < c_cKept; i++)
        {
            if (q == NULL)
                break;

            if (! _IsFilledMemory((LPBYTE) (q+1), q->cbSize, FREE_BYTE))
            {
                MyDebugBreak();
            }

            if (! _IsFilledMemory(((LPBYTE) (q+1)) + q->cbSize, TAIL_SIZE, TAIL_BYTE))
            {
                MyDebugBreak();
            }

            if (c_cKept == i)
            {
                MEM_TAG *x = q->next, *y;
                q->next = NULL;
                while (x)
                {
                    y = x->next;
                    LocalFree(x);
                    x = y;
                }
                break;
            }

            q = q->next;
        }
    }
#endif

    
    p = (MEM_TAG *) LocalAlloc(LPTR, cbToAlloc);
    if (p != NULL)
    {
        p->dwSignature = MEM_TAG_SIGNATURE;
        p->nModuleName = nModuleName;
        p->fActive = TRUE;
        _GetFileName(p->szFileName, pszFileName);
        p->nLineNumber = nLineNumber;
        p->cbSize = cbSize;
        p->next = s_pDbgActiveMemPool;
        s_pDbgActiveMemPool = p;
        s_cDbgActiveMemAlloc++;
        s_cbDbgActiveMem += p->cbSize;
#ifdef KEEP_FREE_MEM
        FillMemory((LPVOID) ((LPBYTE) (p+1) + p->cbSize), TAIL_SIZE, TAIL_BYTE);
#endif
        p++;

        // lonchanc; do not fill in some garbage, we must provide same semantics
        // for decoded buffers. all zeroed out.
        // fill in some garbage
        // FillMemory((LPVOID) p, cbSize, CLEAN_BYTE);
    }

    LeaveCriticalSection(&s_DbgCritSect);

    return (LPVOID) p;
}

void DbgMemFree ( LPVOID ptr )
{
    if (ptr != NULL)
    {
        MEM_TAG *p = (MEM_TAG *) ptr;
        MEM_TAG *q, *q0;
        p--;
        if (! IsBadWritePtr(p, sizeof(MEM_TAG)) &&
            p->dwSignature == MEM_TAG_SIGNATURE)
        {
            if (! p->fActive)
            {
                //
                // This memory has been freed already.
                //
                MyDebugBreak();
                return;
            }

            EnterCriticalSection(&s_DbgCritSect);
            for (q = s_pDbgActiveMemPool; q != NULL; q = (q0 = q)->next)
            {
                if (q == p)
                {
                    if (q == s_pDbgActiveMemPool)
                    {
                        s_pDbgActiveMemPool = p->next;
                    }
                    else
                    {
                        q0->next = p->next;
                    }
                    s_cDbgActiveMemAlloc--;
                    s_cbDbgActiveMem -= p->cbSize;
                    p->fActive = FALSE;

                    if (! _IsFilledMemory(((LPBYTE) (p+1)) + p->cbSize, TAIL_SIZE, TAIL_BYTE))
                    {
                        MyDebugBreak();
                    }
#ifdef KEEP_FREE_MEM
                    // put in the free pool
                    p->next = s_pDbgFreeMemPool;
                    s_pDbgFreeMemPool = p;
                    FillMemory(p+1, p->cbSize, FREE_BYTE);
#endif
                    break;
                }
            }
            LeaveCriticalSection(&s_DbgCritSect);
        }
        else
        {
            p++;
            MyDebugBreak();
        }
#ifndef KEEP_FREE_MEM
        LocalFree(p);
#endif
    }
}

LPVOID DbgMemReAlloc ( LPVOID ptr, UINT cbSize, ASN1uint32_t nModuleName, LPSTR pszFileName, UINT nLineNumber )
{
    MEM_TAG *p;
    void *q;

    if (ptr == NULL)
        return DbgMemAlloc(cbSize, nModuleName, pszFileName, nLineNumber);

    p = (MEM_TAG *) ptr;
    p--;

    if (IsBadWritePtr(p, sizeof(MEM_TAG)) ||
        p->dwSignature != MEM_TAG_SIGNATURE)
    {
        MyDebugBreak();
        return LocalReAlloc(ptr, cbSize, LMEM_MOVEABLE|LMEM_ZEROINIT);
    }

    q = DbgMemAlloc(cbSize, nModuleName, pszFileName, nLineNumber);
    if (q != NULL)
    {
        CopyMemory(q, ptr, p->cbSize);
        DbgMemFree(ptr);
    }

    return q;
}

#endif // ENABLE_MEMORY_TRACKING
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\msasn1\ms_utf8.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

#ifdef ENABLE_BER

extern ASN1int32_t _WideCharToUTF8(WCHAR *, ASN1int32_t, ASN1char_t *, ASN1int32_t);
extern ASN1int32_t _UTF8ToWideChar(ASN1char_t *, ASN1int32_t, WCHAR *, ASN1int32_t);


int ASN1BEREncUTF8String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t length, WCHAR *value)
{
    if (value && length)
    {
        // first, get the size of the dest UTF8 string
        ASN1int32_t cbStrSize = _WideCharToUTF8(value, length, NULL, 0);
        if (cbStrSize)
        {
            ASN1char_t *psz = (ASN1char_t *) EncMemAlloc(enc, cbStrSize);
            if (psz)
            {
                int rc;
                ASN1int32_t cbStrSize2 = _WideCharToUTF8(value, length, psz, cbStrSize);
                EncAssert(enc, cbStrSize2);
                EncAssert(enc, cbStrSize == cbStrSize2);
                rc = ASN1BEREncOctetString(enc, tag, cbStrSize2, psz);
                EncMemFree(enc, psz);
                return rc;
            }
        }
        else
        {
            ASN1EncSetError(enc, ASN1_ERR_UTF8);
        }
    }
    else
    {
        return ASN1BEREncOctetString(enc, tag, 0, NULL);
    }
    return 0;
}

int ASN1BERDecUTF8String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1wstring_t *val)
{
    ASN1octetstring_t ostr;
    if (ASN1BERDecOctetString(dec, tag, &ostr))
    {
        if (ostr.length)
        {
            ASN1int32_t cchWideChar = _UTF8ToWideChar(ostr.value, ostr.length, NULL, 0);
            if (cchWideChar)
            {
                val->value = (WCHAR *) DecMemAlloc(dec, sizeof(WCHAR) * cchWideChar);
                if (val->value)
                {
                    val->length = _UTF8ToWideChar(ostr.value, ostr.length, val->value, cchWideChar);
                    DecAssert(dec, val->length);
                    DecAssert(dec, cchWideChar == (ASN1int32_t) val->length);
                    ASN1octetstring_free(&ostr);
                    return 1;
                }
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_UTF8);
            }
            ASN1octetstring_free(&ostr);
        }
        else
        {
            val->length = 0;
            val->value = NULL;
            return 1;
        }
    }
    return 0;
}


#if 1


//
//  Constant Declarations.
//

#define ASCII                 0x007f

#define SHIFT_IN              '+'     // beginning of a shift sequence
#define SHIFT_OUT             '-'     // end       of a shift sequence

#define UTF8_2_MAX            0x07ff  // max UTF8 2-byte sequence (32 * 64 = 2048)
#define UTF8_1ST_OF_2         0xc0    // 110x xxxx
#define UTF8_1ST_OF_3         0xe0    // 1110 xxxx
#define UTF8_1ST_OF_4         0xf0    // 1111 xxxx
#define UTF8_TRAIL            0x80    // 10xx xxxx

#define HIGHER_6_BIT(u)       ((u) >> 12)
#define MIDDLE_6_BIT(u)       (((u) & 0x0fc0) >> 6)
#define LOWER_6_BIT(u)        ((u) & 0x003f)

#define BIT7(a)               ((a) & 0x80)
#define BIT6(a)               ((a) & 0x40)

#define HIGH_SURROGATE_START  0xd800
#define HIGH_SURROGATE_END    0xdbff
#define LOW_SURROGATE_START   0xdc00
#define LOW_SURROGATE_END     0xdfff


////////////////////////////////////////////////////////////////////////////
//
//  UTF8ToUnicode
//
//  Maps a UTF-8 character string to its wide character string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ASN1int32_t _UTF8ToWideChar
(
    /* in */    ASN1char_t         *lpSrcStr,
    /* in */    ASN1int32_t         cchSrc,
    /* out */   WCHAR              *lpDestStr,
    /* in */    ASN1int32_t         cchDest
)
{
    int nTB = 0;                   // # trail bytes to follow
    int cchWC = 0;                 // # of Unicode code points generated
    LPCSTR pUTF8 = lpSrcStr;
    DWORD dwSurrogateChar;         // Full surrogate char
    BOOL bSurrogatePair = FALSE;   // Indicate we'r collecting a surrogate pair
    char UTF8;

    while ((cchSrc--) && ((cchDest == 0) || (cchWC < cchDest)))
    {
        //
        //  See if there are any trail bytes.
        //
        if (BIT7(*pUTF8) == 0)
        {
            //
            //  Found ASCII.
            //
            if (cchDest)
            {
                lpDestStr[cchWC] = (WCHAR)*pUTF8;
            }
            bSurrogatePair = FALSE;
            cchWC++;
        }
        else if (BIT6(*pUTF8) == 0)
        {
            //
            //  Found a trail byte.
            //  Note : Ignore the trail byte if there was no lead byte.
            //
            if (nTB != 0)
            {
                //
                //  Decrement the trail byte counter.
                //
                nTB--;

                if (bSurrogatePair)
                {
                    dwSurrogateChar <<= 6;
                    dwSurrogateChar |= LOWER_6_BIT(*pUTF8);

                    if (nTB == 0)
                    {
                        if (cchDest)
                        {
                            if ((cchWC + 1) < cchDest)
                            {
                                lpDestStr[cchWC]   = (WCHAR)
                                                     (((dwSurrogateChar - 0x10000) >> 10) + HIGH_SURROGATE_START);

                                lpDestStr[cchWC+1] = (WCHAR)
                                                     ((dwSurrogateChar - 0x10000)%0x400 + LOW_SURROGATE_START);
                            }
                        }

                        cchWC += 2;
                        bSurrogatePair = FALSE;
                    }
                }
                else
                {
                    //
                    //  Make room for the trail byte and add the trail byte
                    //  value.
                    //
                    if (cchDest)
                    {
                        lpDestStr[cchWC] <<= 6;
                        lpDestStr[cchWC] |= LOWER_6_BIT(*pUTF8);
                    }

                    if (nTB == 0)
                    {
                        //
                        //  End of sequence.  Advance the output counter.
                        //
                        cchWC++;
                    }
                }
            }
            else
            {
                // error - not expecting a trail byte
                bSurrogatePair = FALSE;
            }
        }
        else
        {
            //
            //  Found a lead byte.
            //
            if (nTB > 0)
            {
                //
                //  Error - previous sequence not finished.
                //
                nTB = 0;
                bSurrogatePair = FALSE;
                cchWC++;
            }
            else
            {
                //
                //  Calculate the number of bytes to follow.
                //  Look for the first 0 from left to right.
                //
                UTF8 = *pUTF8;
                while (BIT7(UTF8) != 0)
                {
                    UTF8 <<= 1;
                    nTB++;
                }

                //
                // If this is a surrogate unicode pair
                //
                if (nTB == 4)
                {
                    dwSurrogateChar = UTF8 >> nTB;
                    bSurrogatePair = TRUE;
                }

                //
                //  Store the value from the first byte and decrement
                //  the number of bytes to follow.
                //
                if (cchDest)
                {
                    lpDestStr[cchWC] = UTF8 >> nTB;
                }
                nTB--;
            }
        }

        pUTF8++;
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Return the number of Unicode characters written.
    //
    return (cchWC);
}


////////////////////////////////////////////////////////////////////////////
//
//  UnicodeToUTF8
//
//  Maps a Unicode character string to its UTF-8 string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ASN1int32_t _WideCharToUTF8
(
    /* in */    WCHAR              *lpSrcStr,
    /* in */    ASN1int32_t         cchSrc,
    /* out */   ASN1char_t         *lpDestStr,
    /* in */    ASN1int32_t         cchDest
)
{
    LPCWSTR lpWC = lpSrcStr;
    int     cchU8 = 0;                // # of UTF8 chars generated
    DWORD   dwSurrogateChar;
    WCHAR   wchHighSurrogate = 0;
    BOOL    bHandled;

    while ((cchSrc--) && ((cchDest == 0) || (cchU8 < cchDest)))
    {
        bHandled = FALSE;

        //
        // Check if high surrogate is available
        //
        if ((*lpWC >= HIGH_SURROGATE_START) && (*lpWC <= HIGH_SURROGATE_END))
        {
            if (cchDest)
            {
                // Another high surrogate, then treat the 1st as normal
                // Unicode character.
                if (wchHighSurrogate)
                {
                    if ((cchU8 + 2) < cchDest)
                    {
                        lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(wchHighSurrogate);
                    }
                    else
                    {
                        // not enough buffer
                        cchSrc++;
                        break;
                    }
                }
            }
            else
            {
                cchU8 += 3;
            }
            wchHighSurrogate = *lpWC;
            bHandled = TRUE;
        }

        if (!bHandled && wchHighSurrogate)
        {
            if ((*lpWC >= LOW_SURROGATE_START) && (*lpWC <= LOW_SURROGATE_END))
            {
                 // wheee, valid surrogate pairs

                 if (cchDest)
                 {
                     if ((cchU8 + 3) < cchDest)
                     {
                         dwSurrogateChar = (((wchHighSurrogate-0xD800) << 10) + (*lpWC - 0xDC00) + 0x10000);

                         lpDestStr[cchU8++] = (UTF8_1ST_OF_4 |
                                               (unsigned char)(dwSurrogateChar >> 18));           // 3 bits from 1st byte

                         lpDestStr[cchU8++] =  (UTF8_TRAIL |
                                                (unsigned char)((dwSurrogateChar >> 12) & 0x3f)); // 6 bits from 2nd byte

                         lpDestStr[cchU8++] = (UTF8_TRAIL |
                                               (unsigned char)((dwSurrogateChar >> 6) & 0x3f));   // 6 bits from 3rd byte

                         lpDestStr[cchU8++] = (UTF8_TRAIL |
                                               (unsigned char)(0x3f & dwSurrogateChar));          // 6 bits from 4th byte
                     }
                     else
                     {
                        // not enough buffer
                        cchSrc++;
                        break;
                     }
                 }
                 else
                 {
                     // we already counted 3 previously (in high surrogate)
                     cchU8 += 1;
                 }

                 bHandled = TRUE;
            }
            else
            {
                 // Bad Surrogate pair : ERROR
                 // Just process wchHighSurrogate , and the code below will
                 // process the current code point
                 if (cchDest)
                 {
                     if ((cchU8 + 2) < cchDest)
                     {
                        lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(wchHighSurrogate);
                     }
                     else
                     {
                        // not enough buffer
                        cchSrc++;
                        break;
                     }
                 }
            }

            wchHighSurrogate = 0;
        }

        if (!bHandled)
        {
            if (*lpWC <= ASCII)
            {
                //
                //  Found ASCII.
                //
                if (cchDest)
                {
                    lpDestStr[cchU8] = (char)*lpWC;
                }
                cchU8++;
            }
            else if (*lpWC <= UTF8_2_MAX)
            {
                //
                //  Found 2 byte sequence if < 0x07ff (11 bits).
                //
                if (cchDest)
                {
                    if ((cchU8 + 1) < cchDest)
                    {
                        //
                        //  Use upper 5 bits in first byte.
                        //  Use lower 6 bits in second byte.
                        //
                        lpDestStr[cchU8++] = UTF8_1ST_OF_2 | (*lpWC >> 6);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(*lpWC);
                    }
                    else
                    {
                        //
                        //  Error - buffer too small.
                        //
                        cchSrc++;
                        break;
                    }
                }
                else
                {
                    cchU8 += 2;
                }
            }
            else
            {
                //
                //  Found 3 byte sequence.
                //
                if (cchDest)
                {
                    if ((cchU8 + 2) < cchDest)
                    {
                        //
                        //  Use upper  4 bits in first byte.
                        //  Use middle 6 bits in second byte.
                        //  Use lower  6 bits in third byte.
                        //
                        lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(*lpWC);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(*lpWC);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(*lpWC);
                    }
                    else
                    {
                        //
                        //  Error - buffer too small.
                        //
                        cchSrc++;
                        break;
                    }
                }
                else
                {
                    cchU8 += 3;
                }
            }
        }

        lpWC++;
    }

    //
    // If the last character was a high surrogate, then handle it as a normal
    // unicode character.
    //
    if ((cchSrc < 0) && (wchHighSurrogate != 0))
    {
        if (cchDest)
        {
            if ((cchU8 + 2) < cchDest)
            {
                lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate);
                lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(wchHighSurrogate);
                lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(wchHighSurrogate);
            }
            else
            {
                cchSrc++;
            }
        }
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Return the number of UTF-8 characters written.
    //
    return (cchU8);
}



#else

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997
//
//  File:       utf8.cpp
//
//  Contents:   WideChar to/from UTF8 APIs
//
//  Functions:  WideCharToUTF8
//              UTF8ToWideChar
//
//  History:    19-Feb-97   philh   created
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  Maps a wide-character (Unicode) string to a new UTF-8 encoded character
//  string.
//
//  The wide characters are mapped as follows:
//
//  Start   End     Bits    UTF-8 Characters
//  ------  ------  ----    --------------------------------
//  0x0000  0x007F  7       0x0xxxxxxx
//  0x0080  0x07FF  11      0x110xxxxx 0x10xxxxxx
//  0x0800  0xFFFF  16      0x1110xxxx 0x10xxxxxx 0x10xxxxxx
//
//  The parameter and return value semantics are the same as for the
//  Win32 API, WideCharToMultiByte.
//
//  Note, starting with NT 4.0, WideCharToMultiByte supports CP_UTF8. CP_UTF8
//  isn't supported on Win95.
//--------------------------------------------------------------------------
ASN1int32_t _WideCharToUTF8
(
    /* in */    WCHAR              *lpWideCharStr,
    /* in */    ASN1int32_t         cchWideChar,
    /* out */   ASN1char_t         *lpUTF8Str,
    /* in */    ASN1int32_t         cchUTF8
)
{
    if (cchUTF8 >= 0)
    {
        ASN1int32_t cchRemainUTF8 = cchUTF8;

        if (cchWideChar < 0)
        {
            cchWideChar = My_lstrlenW(lpWideCharStr) + 1;
        }

        while (cchWideChar--)
        {
            WCHAR wch = *lpWideCharStr++;
            if (wch <= 0x7F)
            {
                // 7 bits
                cchRemainUTF8--;
                if (cchRemainUTF8 >= 0)
                {
                    *lpUTF8Str++ = (ASN1char_t) wch;
                }
            }
            else
            if (wch <= 0x7FF)
            {
                // 11 bits
                cchRemainUTF8 -= 2;
                if (cchRemainUTF8 >= 0)
                {
                    *lpUTF8Str++ = (ASN1char_t) (0xC0 | ((wch >> 6) & 0x1F));
                    *lpUTF8Str++ = (ASN1char_t) (0x80 | (wch & 0x3F));
                }
            }
            else
            {
                // 16 bits
                cchRemainUTF8 -= 3;
                if (cchRemainUTF8 >= 0)
                {
                    *lpUTF8Str++ = (ASN1char_t) (0xE0 | ((wch >> 12) & 0x0F));
                    *lpUTF8Str++ = (ASN1char_t) (0x80 | ((wch >> 6) & 0x3F));
                    *lpUTF8Str++ = (ASN1char_t) (0x80 | (wch & 0x3F));
                }
            }
        }

        if (cchRemainUTF8 >= 0)
        {
            return (cchUTF8 - cchRemainUTF8);
        }
        else
        if (cchUTF8 == 0)
        {
            return (-cchRemainUTF8);
        }
    }
    return 0;
}

//+-------------------------------------------------------------------------
//  Maps a UTF-8 encoded character string to a new wide-character (Unicode)
//  string.
// 
//  See CertWideCharToUTF8 for how the UTF-8 characters are mapped to wide
//  characters.
//
//  The parameter and return value semantics are the same as for the
//  Win32 API, MultiByteToWideChar.
//
//  If the UTF-8 characters don't contain the expected high order bits,
//  ERROR_INVALID_PARAMETER is set and 0 is returned.
//
//  Note, starting with NT 4.0, MultiByteToWideChar supports CP_UTF8. CP_UTF8
//  isn't supported on Win95.
//--------------------------------------------------------------------------
ASN1int32_t _UTF8ToWideChar
(
    /* in */    ASN1char_t         *lpUTF8Str,
    /* in */    ASN1int32_t         cchUTF8,
    /* out */   WCHAR              *lpWideCharStr,
    /* in */    ASN1int32_t         cchWideChar
)
{
    if (cchWideChar >= 0)
    {
        ASN1int32_t cchRemainWideChar = cchWideChar;

        if (cchUTF8 < 0)
        {
            cchUTF8 = My_lstrlenA(lpUTF8Str) + 1;
        }

        while (cchUTF8--)
        {
            ASN1char_t ch = *lpUTF8Str++;
            WCHAR wch;
            ASN1char_t ch2, ch3;

            if (0 == (ch & 0x80))
            {
                // 7 bits, 1 byte
                wch = (WCHAR) ch;
            }
            else
            if (0xC0 == (ch & 0xE0))
            {
                // 11 bits, 2 bytes
                if (--cchUTF8 >= 0)
                {
                    ch2 = *lpUTF8Str++;
                    if (0x80 == (ch2 & 0xC0))
                    {
                        wch = (((WCHAR) ch  & 0x1F) << 6) |
                               ((WCHAR) ch2 & 0x3F);
                    }
                    else
                    {
                        goto MyExit;
                    }
                }
                else
                {
                    goto MyExit;
                }
            }
            else
            if (0xE0 == (ch & 0xF0))
            {
                // 16 bits, 3 bytes
                cchUTF8 -= 2;
                if (cchUTF8 >= 0)
                {
                    ch2 = *lpUTF8Str++;
                    ch3 = *lpUTF8Str++;
                    if (0x80 == (ch2 & 0xC0) && 0x80 == (ch3 & 0xC0))
                    {
                        wch = (((WCHAR) ch  & 0x0F) << 12) |
                              (((WCHAR) ch2 & 0x3F) <<  6) |
                               ((WCHAR) ch3 & 0x3F);
                    }
                    else
                    {
                        goto MyExit;
                    }
                }
                else
                {
                    goto MyExit;
                }
            }
            else
            {
                goto MyExit;
            }

            if (--cchRemainWideChar >= 0)
            {
                *lpWideCharStr++ = wch;
            }
        }

        if (cchRemainWideChar >= 0)
        {
            return (cchWideChar - cchRemainWideChar);
        }
        else
        if (cchWideChar == 0)
        {
            return (-cchRemainWideChar);
        }
    }
MyExit:
    return 0;
}

#endif // 1

#endif // ENABLE_BER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\msasn1\nm_ber.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"


// THE FOLLOWING IS FROM BERENCOD.C

/* get the expected length based on the table */
ASN1uint32_t _BERGetLength(ASN1uint32_t val, const ASN1uint32_t Tbl[], ASN1uint32_t cItems)
{
    ASN1uint32_t i;
    for (i = 0; i < cItems; i++)
    {
        if (val < Tbl[i])
            return i+1;
    }
    return cItems+1;
}

static const ASN1uint32_t c_TagTable[] = { 31, 0x80, 0x4000, 0x200000, 0x10000000 };

/* encode a tag */
int ASN1BEREncTag(ASN1encoding_t enc, ASN1uint32_t tag)
{
    ASN1uint32_t tagclass, tagvalue, cbTagLength;

    tagclass = (tag >> 24) & 0xe0;
    tagvalue = tag & 0x1fffffff;

    cbTagLength = _BERGetLength(tagvalue, c_TagTable, ARRAY_SIZE(c_TagTable));
    if (ASN1BEREncCheck(enc, cbTagLength))
    {
        if (cbTagLength == 1)
        {
            *enc->pos++ = (ASN1octet_t)(tagclass | tagvalue);
        }
        else
        {
            *enc->pos++ = (ASN1octet_t)(tagclass | 0x1f);
            switch (cbTagLength)
            {
            case 6:
                *enc->pos++ = (ASN1octet_t)((tagvalue >> 28) | 0x80);
                // lonchanc: intentionally fall through
            case 5:
                *enc->pos++ = (ASN1octet_t)((tagvalue >> 21) | 0x80);
                // lonchanc: intentionally fall through
            case 4:
                *enc->pos++ = (ASN1octet_t)((tagvalue >> 14) | 0x80);
                // lonchanc: intentionally fall through
            case 3:
                *enc->pos++ = (ASN1octet_t)((tagvalue >> 7) | 0x80);
                // lonchanc: intentionally fall through
            case 2:
                *enc->pos++ = (ASN1octet_t)(tagvalue & 0x7f);
                break;
            }
        }
        return 1;
    }
    return 0;
}

/* put the length value */
void _BERPutLength(ASN1encoding_t enc, ASN1uint32_t len, ASN1uint32_t cbLength)
{
    if (cbLength > 1)
    {
        *enc->pos++ = (ASN1octet_t) (0x7f + cbLength); // 0x80 + cbLength - 1;
    }

    switch (cbLength)
    {
    case 5:
        *enc->pos++ = (ASN1octet_t)(len >> 24);
        // lonchanc: intentionally fall through
    case 4:
        *enc->pos++ = (ASN1octet_t)(len >> 16);
        // lonchanc: intentionally fall through
    case 3:
        *enc->pos++ = (ASN1octet_t)(len >> 8);
        // lonchanc: intentionally fall through
    default: // case 2: case 1:
        *enc->pos++ = (ASN1octet_t)len;
        break;
    }
}

static const ASN1uint32_t c_LengthTable[] = { 0x80, 0x100, 0x10000, 0x1000000 };

/* encode length */
int ASN1BEREncLength(ASN1encoding_t enc, ASN1uint32_t len)
{
    ASN1uint32_t cbLength = _BERGetLength(len, c_LengthTable, ARRAY_SIZE(c_LengthTable));

    if (ASN1BEREncCheck(enc, cbLength + len))
    {
        _BERPutLength(enc, len, cbLength);
        return 1;
    }
    return 0;
}

/* encode an octet string value */
int ASN1BEREncOctetString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* encode length */
        if (ASN1BEREncLength(enc, len))
        {
            /* copy value */
            CopyMemory(enc->pos, val, len);
            enc->pos += len;
            return 1;
        }
    }
    return 0;
}

/* encode a boolean value */
int ASN1BEREncBool(ASN1encoding_t enc, ASN1uint32_t tag, ASN1bool_t val)
{
    if (ASN1BEREncTag(enc, tag))
    {
        if (ASN1BEREncLength(enc, 1))
        {
            *enc->pos++ = val ? 0xFF : 0;
            return 1;
        }
    }
    return 0;
}

static const c_U32LengthTable[] = { 0x80, 0x8000, 0x800000, 0x80000000 };

/* encode a unsigned integer value */
int ASN1BEREncU32(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t val)
{
    EncAssert(enc, tag != 0x01);
    if (ASN1BEREncTag(enc, tag))
    {
        ASN1uint32_t cbLength;
        cbLength = _BERGetLength(val, c_U32LengthTable, ARRAY_SIZE(c_U32LengthTable));
        if (ASN1BEREncLength(enc, cbLength))
        {
            switch (cbLength)
            {
            case 5:
                *enc->pos++ = 0;
                // lonchanc: intentionally fall through
            case 4:
                *enc->pos++ = (ASN1octet_t)(val >> 24);
                // lonchanc: intentionally fall through
            case 3:
                *enc->pos++ = (ASN1octet_t)(val >> 16);
                // lonchanc: intentionally fall through
            case 2:
                *enc->pos++ = (ASN1octet_t)(val >> 8);
                // lonchanc: intentionally fall through
            case 1:
                *enc->pos++ = (ASN1octet_t)(val);
                break;
            }
            return 1;
        }
    }
    return 0;
}


// THE FOLLOWING IS FROM BERDECOD.C


/* check if len octets are left in decoding stream */
int ASN1BERDecCheck(ASN1decoding_t dec, ASN1uint32_t len)
{
    // We need to ensure:
    // 1) that dec->pos + len doesn't cause an arithmetic overflow 
    // 2) dec->pos + len doesn't exceed the size of our buffer
    if (dec->pos + len >= dec->pos && 
        dec->pos + len <= dec->buf + dec->size)
    {
        return 1;
    }

    ASN1DecSetError(dec, ASN1_ERR_EOD);
    return 0;
}

int _BERDecPeekCheck(ASN1decoding_t dec, ASN1uint32_t len)
{
    return ((dec->pos + len <= dec->buf + dec->size) ? 1 : 0);
}

/* start decoding of a constructed value */
int _BERDecConstructed(ASN1decoding_t dec, ASN1uint32_t len, ASN1uint32_t infinite, ASN1decoding_t *dd, ASN1octet_t **ppBufEnd)
{
    // safety net
    DecAssert(dec, NULL != dd);
    *dd = dec;

#if 0 // NO_NESTED_DECODING
    // lonchanc: this does not work because open type can be the last component and
    // the open type decoder needs to peek a tag. as a result, we may peek the tag
    // outside the buffer boundary.
    if (ppBufEnd && (! infinite))
    {
        *ppBufEnd = dec->pos + len;
        return 1;
    }
#endif

    /* initialize a new decoding stream as child of running decoding stream */
    if (ASN1_CreateDecoder(dec->module, dd,
        dec->pos, infinite ? dec->size - (ASN1uint32_t) (dec->pos - dec->buf) : len, dec) >= 0)
    {
        /* set pointer to end of decoding stream if definite length case selected */
        *ppBufEnd = infinite ? NULL : (*dd)->buf + (*dd)->size;
        return 1;
    }
    return 0;
}

/* decode a tag value; return constructed bit if desired */
int ASN1BERDecTag(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint32_t *constructed)
{
    ASN1uint32_t tagvalue, tagclass, c;

    /* get tag class and value */
    if (ASN1BERDecCheck(dec, 1))
    {
        tagclass = *dec->pos & 0xe0;
        tagvalue = *dec->pos++ & 0x1f;
        if (tagvalue == 0x1f)
        {
            tagvalue = 0;
            do {
                if (ASN1BERDecCheck(dec, 1))
                {
                    c = *dec->pos++;
                    if (! (tagvalue & 0xe0000000))
                    {
                        tagvalue = (tagvalue << 7) | (c & 0x7f);
                    }
                    else
                    {
                        ASN1DecSetError(dec, ASN1_ERR_BADTAG);
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            } while (c & 0x80);
        }

        /* extract constructed bit if wanted */
        if (constructed)
        {
            *constructed = tagclass & 0x20;
            tagclass &= ~0x20;
        }

        /* check if tag equals desires */
        if (tag == ((tagclass << 24) | tagvalue))
        {
            return 1;
        }

        ASN1DecSetError(dec, ASN1_ERR_BADTAG);
    }
    return 0;
}

/* decode length */
int ASN1BERDecLength(ASN1decoding_t dec, ASN1uint32_t *len, ASN1uint32_t *infinite)
{
    // default is definite length
    if (infinite)
    {
        *infinite = 0;
    }

    /* get length and infinite flag */
    if (ASN1BERDecCheck(dec, 1))
    {
        ASN1uint32_t l = *dec->pos++;
        if (l < 0x80)
        {
            *len = l;
        }
        else
        if (l == 0x80)
        {
            *len = 0;
            if (infinite)
            {
                *infinite = 1;
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }
        }
        else
        if (l <= 0x84)
        {
            ASN1uint32_t i = l - 0x80;
            if (ASN1BERDecCheck(dec, i))
            {
                l = 0;
                switch (i)
                {
                case 4:
                    l = *dec->pos++ << 24;
                    /*FALLTHROUGH*/
                case 3:
                    l |= *dec->pos++ << 16;
                    /*FALLTHROUGH*/
                case 2:
                    l |= *dec->pos++ << 8;
                    /*FALLTHROUGH*/
                case 1:
                    l |= *dec->pos++;
                    break;
                }
                *len = l;
            }
            else
            {
                return 0;
            }
        }
        else
        {
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }

        /* check if enough octets left if length is known */
        if (!infinite || !*infinite)
        {
            return ASN1BERDecCheck(dec, *len);
        }
        return 1;
    }

    return 0;
}

/* decode an explicit tag */
int ASN1BERDecExplicitTag(ASN1decoding_t dec, ASN1uint32_t tag, ASN1decoding_t *dd, ASN1octet_t **ppBufEnd)
{
    ASN1uint32_t len, infinite, constructed;

    // safety net
    if (dd)
    {
        *dd = dec;
    }

    /* skip the constructed tag */
    if (ASN1BERDecTag(dec, tag | 0x20000000, NULL))
    {
        /* get the length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            /* start decoding of constructed value */
            if (! dd)
            {
                *ppBufEnd = infinite ? NULL : dec->pos + len;
                return 1;
            }
            return _BERDecConstructed(dec, len, infinite, dd, ppBufEnd);
        }
    }
    return 0;
}

/* decode octet string value (helper function) */
int _BERDecOctetStringWorker(ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val, ASN1uint32_t fNoCopy, ASN1uint32_t nMaxRecursionDepth)
{
    ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t)dec;
    ASN1uint32_t constructed, len, infinite;
    ASN1decoding_t dd;
    ASN1octet_t *di;

     /* BUG 750698: Limit the recursion depth for octet strings */ 
    if (nMaxRecursionDepth-- == 0) 
    {
        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
        return -1; /* max recursion depth exceeded */ 
    }

    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (! constructed)
            {
                val->length = len;
                if (fNoCopy)
                {
                    val->value = dec->pos;
                    dec->pos += len;
                    return 1;
                }
                else
                {
                    if (len)
                    {
                        val->value = (ASN1octet_t *)DecMemAlloc(dec, len);
                        if (val->value)
                        {
                            CopyMemory(val->value, dec->pos, len);
                            dec->pos += len;
                            return 1;
                        }
                    }
                    else
                    {
                        val->value = NULL;
                        return 1;
                    }
                }
            }
            else
            {
                ASN1octetstring_t o;
                val->length = 0;
                val->value = NULL;
                if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                {
                    while (ASN1BERDecNotEndOfContents(dd, di))
                    {
                        int nRet; 
                        
                        o.length = 0;
                        o.value = NULL;

                        nRet = _BERDecOctetStringWorker(dd, 0x4, &o, fNoCopy, nMaxRecursionDepth);

                        if (-1 == nRet) /* max recursion depth exceeded */ 
                        {
                            /* propagate the error */
                            return nRet;
                        }
                        else if (nRet)
                        {
                            if (o.length)
                            {
                                if (fNoCopy)
                                {
                                    *val = o;
                                    break; // break out the loop because nocopy cannot have multiple constructed streams
                                }

                                /* resize value */
                                val->value = (ASN1octet_t *)DecMemReAlloc(dd, val->value,
                                                                val->length + o.length);
                                if (val->value)
                                {
                                    /* concat octet strings */
                                    CopyMemory(val->value + val->length, o.value, o.length);
                                    val->length += o.length;

                                    /* free unused octet string */
                                    DecMemFree(dec, o.value);
                                }
                                else
                                {
                                    return 0;
                                }
                            }
                        }
                    }
                    return ASN1BERDecEndOfContents(dec, dd, di);
                }
            }
        }
    }
    return 0;
}

/* define the maximum allowed recursion depth for octet strings */ 
#define MAX_OCTET_STRING_DEPTH 10

/* decode octet string value */
int _BERDecOctetString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val, ASN1uint32_t fNoCopy)
{
    int nRet = _BERDecOctetStringWorker(dec, tag, val, fNoCopy, MAX_OCTET_STRING_DEPTH); 

    if (-1 == nRet)
    {
        nRet = 0;
    }
    return nRet; 
}

/* decode octet string value, making copy */
int ASN1BERDecOctetString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val)
{
    return _BERDecOctetString(dec, tag, val, FALSE);
}

/* decode octet string value, no copy */
int ASN1BERDecOctetString2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val)
{
    return _BERDecOctetString(dec, tag, val, TRUE);
}

/* peek the following tag without advancing the read position */
int ASN1BERDecPeekTag(ASN1decoding_t dec, ASN1uint32_t *tag)
{
    ASN1uint32_t tagvalue, tagclass, c;
    ASN1octet_t *p;

    *tag = 0; // invalid tag
    if (_BERDecPeekCheck(dec, 1))
    {
        p = dec->pos;

        /* get tagclass without primitive/constructed bit */
        tagclass = *dec->pos & 0xc0;

        /* get tag value */
        tagvalue = *dec->pos++ & 0x1f;
        if (tagvalue == 0x1f)
        {
            tagvalue = 0;
            do {
                if (_BERDecPeekCheck(dec, 1))
                {
                    c = *dec->pos++;
                    if (! (tagvalue & 0xe0000000))
                    {
                        tagvalue = (tagvalue << 7) | (c & 0x7f);
                    }
                    else
                    {
                        ASN1DecSetError(dec, ASN1_ERR_BADTAG);
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            } while (c & 0x80);
        }

        /* return tag */
        *tag = ((tagclass << 24) | tagvalue);

        /* reset decoding position */
        dec->pos = p;
        return 1;
    }
    return 0;
}

/* decode boolean into ASN1boot_t */
int ASN1BERDecBool(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bool_t *val)
{
    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        /* get length */
        ASN1uint32_t len;
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            if (len >= 1)
            {
                DecAssert(dec, len == 1);
                *val = *dec->pos ? 1 : 0;
                dec->pos += len; // self defensive
                return 1;
            }
        }
    }
    return 0;
}

/* decode integer into unsigned 32 bit value */
int ASN1BERDecU32Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint32_t *val)
{
    ASN1uint32_t len;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            /* get value */
            if (len >= 1)
            {
                switch (len)
                {
                case 1:
                    *val = *dec->pos++;
                    break;
                case 2:
                    *val = (*dec->pos << 8) | dec->pos[1];
                    dec->pos += 2;
                    break;
                case 3:
                    *val = (*dec->pos << 16) | (dec->pos[1] << 8) | dec->pos[2];
                    dec->pos += 3;
                    break;
                case 4:
                    *val = (*dec->pos << 24) | (dec->pos[1] << 16) |
                        (dec->pos[2] << 8) | dec->pos[3];
                    dec->pos += 4;
                    break;
                case 5:
                    if (! *dec->pos)
                    {
                        *val = (dec->pos[1] << 24) | (dec->pos[2] << 16) |
                            (dec->pos[3] << 8) | dec->pos[4];
                        dec->pos += 5;
                        break;
                    }
                    // intentionally fall through
                default:
                    ASN1DecSetError(dec, ASN1_ERR_LARGE);
                    return 0;
                }
                return 1;
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }
        }
    }
    return 0;
}

int ASN1BERDecEndOfContents(ASN1decoding_t dec, ASN1decoding_t dd, ASN1octet_t *pBufEnd)
{
    ASN1error_e err = ASN1_ERR_CORRUPT;

    if (! dd)
    {
        dd = dec;
    }

    DecAssert(dec, NULL != dd);

    if (pBufEnd)
    {
        /* end of definite length case: */
        /* check if decoded up to end of contents */
        if (dd->pos == pBufEnd)
        {
            dec->pos = pBufEnd;
            err = ASN1_SUCCESS;
        }
    }
    else
    {
        /* end of infinite length case: */
        /* expect end-of-contents octets */
        if (ASN1BERDecCheck(dd, 2))
        {
            if (0 == dd->pos[0] && 0 == dd->pos[1])
            {
                dd->pos += 2;
                if (dd != dec)
                {
                    /* finit child decoding stream and update parent decoding stream */
                    dec->pos = dd->pos;
                }
                err = ASN1_SUCCESS;
            }
        }
        else
        {
            err = ASN1_ERR_EOD;
        }
    }

    if (dd && dd != dec)
    {
        ASN1_CloseDecoder(dd);
    }

    if (ASN1_SUCCESS == err)
    {
        return 1;
    }

    ASN1DecSetError(dec, err);
    return 0;
}

/* check if end of contents (of a constructed value) has been reached */
int ASN1BERDecNotEndOfContents(ASN1decoding_t dec, ASN1octet_t *pBufEnd)
{
    return (pBufEnd ?
                (dec->pos < pBufEnd) :
                (ASN1BERDecCheck(dec, 2) && (dec->pos[0] || dec->pos[1])));
}


#ifdef ENABLE_BER

typedef struct
{
    ASN1octet_t        *pBuf;
    ASN1uint32_t        cbBufSize;
}
    CER_BLK_BUF;

typedef struct
{
    ASN1blocktype_e     eBlkType;
    ASN1encoding_t      encPrimary;
    ASN1encoding_t      encSecondary;
    ASN1uint32_t        nMaxBlkSize;
    ASN1uint32_t        nCurrBlkSize;
    CER_BLK_BUF        *aBlkBuf;
}
    CER_BLOCK;

#define MAX_INIT_BLK_SIZE   16

int ASN1CEREncBeginBlk(ASN1encoding_t enc, ASN1blocktype_e eBlkType, void **ppBlk_)
{
    CER_BLOCK *pBlk = (CER_BLOCK *) EncMemAlloc(enc, sizeof(CER_BLOCK));
    if (NULL != pBlk)
    {
        EncAssert(enc, ASN1_DER_SET_OF_BLOCK == eBlkType);
        pBlk->eBlkType = eBlkType;
        pBlk->encPrimary = enc;
        pBlk->encSecondary = NULL;
        pBlk->nMaxBlkSize = MAX_INIT_BLK_SIZE;
        pBlk->nCurrBlkSize = 0;
        pBlk->aBlkBuf = (CER_BLK_BUF *)EncMemAlloc(enc, MAX_INIT_BLK_SIZE * sizeof(CER_BLK_BUF));
        if (NULL != pBlk->aBlkBuf)
        {
            *ppBlk_ = (void *) pBlk;
            return 1;
        }
        EncMemFree(enc, pBlk);
    }
    return 0;
}

int ASN1CEREncNewBlkElement(void *pBlk_, ASN1encoding_t *enc2)
{
    CER_BLOCK *pBlk = (CER_BLOCK *) pBlk_;
    if (NULL == pBlk->encSecondary)
    {
        if (ASN1_SUCCESS == ASN1_CreateEncoder(pBlk->encPrimary->module,
                                               &(pBlk->encSecondary),
                                               NULL, 0, pBlk->encPrimary))
        {
            pBlk->encSecondary->eRule = pBlk->encPrimary->eRule;
            *enc2 = pBlk->encSecondary;
            return 1;
        }
    }
    else
    {
        ASN1INTERNencoding_t e = (ASN1INTERNencoding_t) (*enc2 = pBlk->encSecondary);

        ZeroMemory(e, sizeof(*e));
        e->info.magic = MAGIC_ENCODER;
        // e->info.err = ASN1_SUCCESS;
        // e->info.pos = e->info.buf = NULL;
        // e->info.size = e->info.len = e->info.bit = 0;
        // e->info.dwFlags = 0;
        e->info.module = pBlk->encPrimary->module;
        e->info.eRule = pBlk->encPrimary->eRule;

        ((ASN1INTERNencoding_t) pBlk->encPrimary)->child = e;
        e->parent = (ASN1INTERNencoding_t) pBlk->encPrimary;
        // e->child = NULL;

        // e->mem = NULL;
        // e->memlength = 0;
        // e->memsize = 0;
        // e->epi = NULL;
        // e->epilength = 0;
        // e->episize = 0;
        // e->csi = NULL;
        // e->csilength = 0;
        // e->csisize = 0;

        if (ASN1BEREncCheck((ASN1encoding_t) e, 1))
        {
            // lonchanc: make sure the first byte is zeroed out, which
            // is required for h245.
            e->info.buf[0] = '\0';
            return 1;
        }
    }

    *enc2 =  NULL;
    return 0;
}

int ASN1CEREncFlushBlkElement(void *pBlk_)
{
    CER_BLOCK *pBlk = (CER_BLOCK *) pBlk_;
    ASN1encoding_t enc = pBlk->encSecondary;
    ASN1uint32_t i;

    if (ASN1BEREncFlush(enc))
    {
        // make sure we have enough space...
        if (pBlk->nCurrBlkSize >= pBlk->nMaxBlkSize)
        {
            CER_BLK_BUF *aBlkBuf = (CER_BLK_BUF *)EncMemAlloc(pBlk->encPrimary, (pBlk->nMaxBlkSize << 1) * sizeof(CER_BLK_BUF));
            if (NULL != aBlkBuf)
            {
                CopyMemory(aBlkBuf, pBlk->aBlkBuf, pBlk->nMaxBlkSize * sizeof(CER_BLK_BUF));
                EncMemFree(pBlk->encPrimary, pBlk->aBlkBuf);
                pBlk->aBlkBuf = aBlkBuf;
                pBlk->nMaxBlkSize <<= 1;
            }
            else
            {
                return 0;
            }
        }

        if (pBlk->encPrimary->eRule & (ASN1_BER_RULE_DER | ASN1_BER_RULE_CER))
        {
            // we need to sort these octet strings
            for (i = 0; i < pBlk->nCurrBlkSize; i++)
            {
                if (0 >= My_memcmp(enc->buf, enc->len, pBlk->aBlkBuf[i].pBuf, pBlk->aBlkBuf[i].cbBufSize))
                {
                    ASN1uint32_t cnt = pBlk->nCurrBlkSize - i;
                    ASN1uint32_t j;
                    for (j = pBlk->nCurrBlkSize; cnt--; j--)
                    {
                        pBlk->aBlkBuf[j] = pBlk->aBlkBuf[j-1];
                    }
                    // i is the place to hold the new one
                    break;
                }
            }
        }
        else
        {
            EncAssert(enc, ASN1_BER_RULE_BER == pBlk->encPrimary->eRule);
            i = pBlk->nCurrBlkSize;
        }

        // remeber the new one.
        pBlk->aBlkBuf[i].pBuf = enc->buf;
        pBlk->aBlkBuf[i].cbBufSize = enc->len;
        pBlk->nCurrBlkSize++;
        
        // clean up the encoder structure
        enc->buf = enc->pos = NULL;
        enc->size = enc->len = 0;
        return 1;
    }
    return 0;
}

int ASN1CEREncEndBlk(void *pBlk_)
{
    CER_BLOCK *pBlk = (CER_BLOCK *) pBlk_;
    ASN1encoding_t enc = pBlk->encPrimary;
    ASN1uint32_t cbTotalSize = 0;
    ASN1uint32_t i;
    int fRet = 0;

    // calculate the total size for all the buffers.
    for (i = 0; i < pBlk->nCurrBlkSize; i++)
    {
        cbTotalSize += pBlk->aBlkBuf[i].cbBufSize;
    }

    if (ASN1BEREncCheck(enc, cbTotalSize))
    {
        for (i = 0; i < pBlk->nCurrBlkSize; i++)
        {
            ASN1uint32_t cbBufSize = pBlk->aBlkBuf[i].cbBufSize;
            CopyMemory(enc->pos, pBlk->aBlkBuf[i].pBuf, cbBufSize);
            enc->pos += cbBufSize;
        }
        fRet = 1;
    }

    // free these block buffers.
    for (i = 0; i < pBlk->nCurrBlkSize; i++)
    {
        EncMemFree(enc, pBlk->aBlkBuf[i].pBuf);
    }

    // free the block buffer array
    EncMemFree(enc, pBlk->aBlkBuf);

	// free the secondary encoder structure
	ASN1_CloseEncoder(pBlk->encSecondary);

    // free the block structure itself.
    EncMemFree(enc, pBlk);

    return fRet;
}

#endif // ENABLE_BER

/* encode explicit tag */
int ASN1BEREncExplicitTag(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t *pnLenOff)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag | 0x20000000))
    {
        /* encode infinite length */
        if (ASN1BEREncCheck(enc, 1))
        {
            if (ASN1_BER_RULE_CER != enc->eRule)
            {
                // BER and DER always use definite length form.
                /* return the place to hold the length */
                *pnLenOff = (ASN1uint32_t) (enc->pos++ - enc->buf);
            }
            else
            {
                // CER sub-rule always use indefinite length form.
                *enc->pos++ = 0x80;
                *pnLenOff = 0;
            }
            return 1;
        }
    }
    return 0;
}

/* encode definite length */
int ASN1BEREncEndOfContents(ASN1encoding_t enc, ASN1uint32_t nLenOff)
{
    if (ASN1_BER_RULE_CER != enc->eRule)
    {
        ASN1octet_t *pbLen = enc->buf + nLenOff;
        ASN1uint32_t len = (ASN1uint32_t) (enc->pos - pbLen - 1);
        ASN1uint32_t cbLength = _BERGetLength(len, c_LengthTable, ARRAY_SIZE(c_LengthTable));

        ASN1uint32_t i;

        if (cbLength == 1)
        {
            *pbLen = (ASN1octet_t) len;
            return 1;
        }

        // we have to move the octets upward by cbLength-1
        // --cbLength;
        if (ASN1BEREncCheck(enc, cbLength-1))
        {
            // update pbLen because enc->buf may change due to realloc.
            pbLen = enc->buf + nLenOff;

            // move memory
            MoveMemory(pbLen + cbLength, pbLen + 1, len);

            // put the length
            enc->pos = pbLen;
            _BERPutLength(enc, len, cbLength);
            EncAssert(enc, enc->pos == pbLen + cbLength);

            // set up new position pointer.
            // now enc->pos is at the beginning of contents.
            enc->pos += len;
            return 1;
        }
    }
    else
    {
        EncAssert(enc, 0 == nLenOff);
        if (ASN1BEREncCheck(enc, 2))
        {
            *enc->pos++ = 0;
            *enc->pos++ = 0;
            return 1;
        }
    }
    return 0;
}


// The following is for CryptoAPI

#ifdef ENABLE_BER

#include <stdlib.h>

 // max num of octets, ceiling of 64 / 7, is 10
#define MAX_BYTES_PER_NODE      10

ASN1uint32_t _BEREncOidNode64(ASN1encoding_t enc, unsigned __int64 n64, ASN1octet_t *pOut)
{
    ASN1uint32_t Low32, i, cb;
    ASN1octet_t aLittleEndian[MAX_BYTES_PER_NODE];

    ZeroMemory(aLittleEndian, sizeof(aLittleEndian));
    for (i = 0; n64 != 0; i++)
    {
        Low32 = *(ASN1uint32_t *) &n64;
        aLittleEndian[i] = (ASN1octet_t) (Low32 & 0x7f);
        n64 = Int64ShrlMod32(n64, 7);
    }
    cb = i ? i : 1; // at least one byte for zero value
    EncAssert(enc, cb <= MAX_BYTES_PER_NODE);
    for (i = 0; i < cb; i++)
    {
        EncAssert(enc, 0 == (0x80 & aLittleEndian[cb - i - 1]));
        *pOut++ = (ASN1octet_t) (0x80 | aLittleEndian[cb - i - 1]);
    }
    *(pOut-1) &= 0x7f;
    return cb;
}

int ASN1BERDotVal2Eoid(ASN1encoding_t enc, char *pszDotVal, ASN1encodedOID_t *pOut)
{
    ASN1uint32_t cNodes, cbMaxSize, cb1, cb2;
    char *psz;

    // calculate how many nodes, at least 1.
    for (cNodes = 0, psz = pszDotVal; NULL != psz; cNodes++)
    {
        psz = strchr(psz, '.');
        if (psz)
        {
            psz++;
        }
    }

    // calculate how many bytes should be allocated
    cb1 = My_lstrlenA(pszDotVal);
    cb2 = cNodes * MAX_BYTES_PER_NODE;
    cbMaxSize = (cb1 > cb2) ? cb1 : cb2;

    // allocate buffer
    pOut->length = 0; // safety net
    pOut->value = (ASN1octet_t *) EncMemAlloc(enc, cbMaxSize);
    if (pOut->value)
    {
        ASN1octet_t *p = pOut->value;
        ASN1uint32_t i;
        unsigned __int64 n64;
        psz = pszDotVal;
        for (i = 0; i < cNodes; i++)
        {
            EncAssert(enc, NULL != psz);
            n64 = (unsigned __int64) _atoi64(psz);
            psz = strchr(psz, '.') + 1;
            if (0 == i && cNodes > 1)
            {
                i++;
                n64 = n64 * 40 + (unsigned __int64) _atoi64(psz);
                psz = strchr(psz, '.') + 1;
            }

            p += _BEREncOidNode64(enc, n64, p);
        }
        pOut->length = (ASN1uint16_t) (p - pOut->value);
        EncAssert(enc, pOut->length <= cbMaxSize);
        return 1;
    }
    pOut->length = 0;
    return 0;
}


ASN1uint32_t _BERDecOidNode64(unsigned __int64 *pn64, ASN1octet_t *pIn)
{
    ASN1uint32_t c;
    *pn64 = 0;
    for (c = 1; TRUE; c++)
    {
        *pn64 = Int64ShllMod32(*pn64, 7) + (unsigned __int64) (*pIn & 0x7f);
        if (!(*pIn++ & 0x80))
        {
            return c;
        }
    }
    return 0;
}
    
int ASN1BEREoid2DotVal(ASN1decoding_t dec, ASN1encodedOID_t *pIn, char **ppszDotVal)
{
    ASN1octet_t *p;
    ASN1uint32_t i, cNodes, cb, n32, nLen, nChars;
    unsigned __int64 n64;
    char *psz;
    char szBuf[256+64]; // should be large enough

    // null out return value
    *ppszDotVal = NULL;

    if (NULL == dec)
    {
        return 0;
    }

    // calculate how many nodes
    cNodes = 0;
    for (p = pIn->value, i = 0; i < pIn->length; p++, i++)
    {
        if (!(*p & 0x80))
        {
            cNodes++;
        }
    }

    if (cNodes++) // first encoded node consists of two nodes
    {
        // decode nodes one by one
        psz = &szBuf[0];
        // BUG 773871 ESCROW: ETA 2/6: Security issue with Msasn1.dll
        // keep a count of how many characters we write to the psz buffer.
        // if this count exceeds 256, then we have a buffer overrun. 
        // note that we've padded our buffer with an extra 64 bytes, which 
        // allows us to detect the overrun safely.  The below code can't 
        // overrun our buffer by more than ~22 bytes.  
        nChars = 0; 
        p = pIn->value;
        for (i = 0; i < cNodes; i++)
        {
            p += _BERDecOidNode64(&n64, p);
            if (!i)
            { // first node
                n32 = (ASN1uint32_t) (n64 / 40);
                if (n32 > 2)
                {
                    n32 = 2;
                }
                n64 -= (unsigned __int64) (40 * n32);
                i++; // first encoded node actually consists of two nodes
                _ultoa(n32, psz, 10);
                nLen = lstrlenA(psz);
                psz += nLen; 
                *psz++ = '.';
                nChars += nLen+1; 
            }
            _ui64toa(n64, psz, 10);
            nLen = lstrlenA(psz);
            psz += nLen; 
            *psz++ = '.';
            nChars += nLen+1; 

            if (nChars > 256) 
            { 
                // This oid is too long for our buffer.  Bail out now.   
                ASN1DecSetError(dec, ASN1_ERR_LARGE);
                return 0; 
            }
        }
        DecAssert(dec, psz > &szBuf[0]);
        *(psz-1) = '\0';

        // duplicate the string
        cb = (ASN1uint32_t) (psz - &szBuf[0]);
        *ppszDotVal = (char *) DecMemAlloc(dec, cb);
        if (*ppszDotVal)
        {
            CopyMemory(*ppszDotVal, &szBuf[0], cb);
            return 1;
        }
    }
    return 0;
}


/* encode an object identifier value */
int ASN1BEREncEoid(ASN1encoding_t enc, ASN1uint32_t tag, ASN1encodedOID_t *val)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* encode length */
        int rc = ASN1BEREncLength(enc, val->length);
        if (rc)
        {
            /* copy value */
            CopyMemory(enc->pos, val->value, val->length);
            enc->pos += val->length;
        }
        return rc;
    }
    return 0;
}

/* decode object identifier value */
int ASN1BERDecEoid(ASN1decoding_t dec, ASN1uint32_t tag, ASN1encodedOID_t *val)
{
    val->length = 0; // safety net
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len;
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            val->length = (ASN1uint16_t) len;
            if (len)
            {
                val->value = (ASN1octet_t *) DecMemAlloc(dec, len);
                if (val->value)
                {
                    CopyMemory(val->value, dec->pos, len);
                    dec->pos += len;
                    return 1;
                }
            }
            else
            {
                val->value = NULL;
                return 1;
            }
        }
    }
    return 0;
}


void ASN1BEREoid_free(ASN1encodedOID_t *val)
{
    if (val)
    {
        MemFree(val->value);
    }
}


#endif // ENABLE_BER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\msasn1\perdecod.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

// lonchanc: things to optimize
// (1) merge ASN1PERDecCharString() and ASN1PERDecZeroCharString().
// (2) merge ASN1PERDecChar16String() and ASN1PERDecZeroChar16String().
// (3) merge ASN1PERDecChar32String() and ASN1PERDecZeroChar32String().
// (4) merge ASN1PERDecTableCharString() and ASN1PERDecZeroTableCharString().
// (5) merge ASN1PERDecTableChar16String() and ASN1PERDecZeroTableChar16String().
// (6) merge ASN1PERDecTableChar32String() and ASN1PERDecZeroTableChar32String().
// (7) merge ASN1PERDecFragmentedCharString() and ASN1PERDecFragmentedZeroCharString().
// (8) merge ASN1PERDecFragmentedChar16String() and ASN1PERDecFragmentedZeroChar16String().
// (9) merge ASN1PERDecFragmentedChar32String() and ASN1PERDecFragmentedZeroChar32String().
// (10) merge ASN1PERDecFragmentedTableCharString() and ASN1PERDecFragmentedZeroTableCharString().
// (11) merge ASN1PERDecFragmentedTableChar16String() and ASN1PERDecFragmentedZeroTableChar16String().
// (12) merge ASN1PERDecFragmentedTableChar32String() and ASN1PERDecFragmentedZeroTableChar32String().

#include "precomp.h"

#include <math.h>
#include "cintern.h"

void PerDecAdvance(ASN1decoding_t dec, ASN1uint32_t nbits)
{
    dec->pos += ((dec->bit + nbits) >> 3);
    dec->bit = (dec->bit + nbits) & 7;
}

static const ASN1uint8_t c_aBitMask3[] =
{
    0x00, 0xfe, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x80
};

#define TO64(x) ((unsigned __int64)(x))

/* check if sufficient data is in decoding buffer */
int ASN1PERDecCheck(ASN1decoding_t dec, ASN1uint32_t nbits)
{
    unsigned __int64 overflowCheck; 

    // Ensure that our computation doesn't overflow:
    overflowCheck = (TO64(dec->pos) - TO64(dec->buf)) * 8 + TO64(dec->bit) + TO64(nbits); 
    if (overflowCheck & (0xFFFFFFFFi64 << 32))
    {
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
        return 0;
    }

    // we're confident that no arithmetic overflow will occur.  Perform the check.
    if ((dec->pos - dec->buf) * 8 + dec->bit + nbits <= dec->size * 8)
    {
        return 1;
    }
    ASN1DecSetError(dec, ASN1_ERR_EOD);
    return 0;
}

/* compare function for binary search in stringtable */
static int __cdecl ASN1CmpStringTableEntriesByIndex(const void *a1, const void *a2)
{
    ASN1stringtableentry_t *c1 = (ASN1stringtableentry_t *)a1;
    ASN1stringtableentry_t *c2 = (ASN1stringtableentry_t *)a2;

    if (c1->value > c2->value + (c2->upper - c2->lower))
        return 1;
    if (c2->value > c1->value + (c1->upper - c1->lower))
        return -1;
    return 0;
}

/* skip nbits bits */
int ASN1PERDecSkipBits(ASN1decoding_t dec, ASN1uint32_t nbits)
{
    ASN1uint32_t n;

    /* check if enough bits present */
    if (ASN1PERDecCheck(dec, nbits))
    {
        /* skip bits */
        n = dec->bit + nbits;
        dec->pos += n / 8;
        dec->bit = n & 7;
        return 1;
    }
    return 0;
}

/* skip a fragmented value */
int ASN1PERDecSkipFragmented(ASN1decoding_t dec, ASN1uint32_t itemsize)
{
    ASN1uint32_t n, m;

    /* skip a fragments one by one */
    do {
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (!n)
                break;
            m = n * itemsize;
            if (ASN1PERDecCheck(dec, m))
            {
                dec->pos += m / 8;
                dec->bit = m & 7;
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    } while (n >= 0x4000);
    return 1;
}

/* decode one bit */
int ASN1PERDecBit(ASN1decoding_t dec, ASN1uint32_t *val)
{
    if (ASN1PERDecCheck(dec, 1))
    {
        *val = (*dec->pos >> (7 - dec->bit)) & 1;
        if (dec->bit < 7)
        {
            dec->bit++;
        }
        else
        {
            dec->bit = 0;
            dec->pos++;
        }
        return 1;
    }
    return 0;
}

/* decode unsigned 32 bit integer value */
int ASN1PERDecU32Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1uint32_t *val)
{
    if (ASN1PERDecCheck(dec, nbits))
    {
        if (nbits <= 32)
        {
            *val = ASN1bitgetu(dec->pos, dec->bit, nbits);
            PerDecAdvance(dec, nbits);
            return 1;
        }
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
    }
    return 0;
}

/* decode unsigned 16 bit integer value */
int ASN1PERDecU16Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1uint16_t *val)
{
    if (ASN1PERDecCheck(dec, nbits))
    {
        if (nbits <= 16)
        {
            *val = (ASN1uint16_t) ASN1bitgetu(dec->pos, dec->bit, nbits);
            PerDecAdvance(dec, nbits);
            return 1;
        }
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
    }
    return 0;
}

/* decode unsigned 8 bit integer value */
int ASN1PERDecU8Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1uint8_t *val)
{
    if (ASN1PERDecCheck(dec, nbits))
    {
        if (nbits <= 8)
        {
            *val = (ASN1uint8_t) ASN1bitgetu(dec->pos, dec->bit, nbits);
            PerDecAdvance(dec, nbits);
            return 1;
        }
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
    }
    return 0;
}

/* decode unsigned intx_t integer value */
int ASN1PERDecUXVal(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1intx_t *val)
{
    if (ASN1PERDecCheck(dec, nbits))
    {
        val->length = (*dec->pos & (0x80 >> dec->bit)) ? (nbits + 7) / 8 : (nbits + 7 + 1) / 8;
        if (NULL != (val->value = (ASN1octet_t *)DecMemAlloc(dec, val->length)))
        {
            val->value[0] = 0;
            ASN1bitcpy(val->value, val->length * 8 - nbits, dec->pos, dec->bit, nbits);
            PerDecAdvance(dec, nbits);
            return 1;
        }
    }
    return 0;
}

/* decode signed 32 bit integer value */
int ASN1PERDecS32Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1int32_t *val)
{
    if (ASN1PERDecCheck(dec, nbits))
    {
        if (nbits <= 32)
        {
            *val = ASN1bitget(dec->pos, dec->bit, nbits);
            PerDecAdvance(dec, nbits);
            return 1;
        }
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
    }
    return 0;
}

/* decode signed 16 bit value */
#ifdef ENABLE_ALL
int ASN1PERDecS16Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1int16_t *val)
{
    if (ASN1PERDecCheck(dec, nbits))
    {
        if (nbits <= 16)
        {
            *val = (ASN1int16_t) ASN1bitget(dec->pos, dec->bit, nbits);
            PerDecAdvance(dec, nbits);
            return 1;
        }
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
    }
    return 0;
}
#endif // ENABLE_ALL

/* decode signed 8 bit value */
#ifdef ENABLE_ALL
int ASN1PERDecS8Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1int8_t *val)
{
    if (ASN1PERDecCheck(dec, nbits))
    {
        if (nbits <= 8)
        {
            *val = (ASN1int8_t) ASN1bitget(dec->pos, dec->bit, nbits);
            PerDecAdvance(dec, nbits);
            return 1;
        }
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
    }
    return 0;
}
#endif // ENABLE_ALL

/* decode signed intx_t value */
#ifdef ENABLE_ALL
int ASN1PERDecSXVal(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1intx_t *val)
{
    if (ASN1PERDecCheck(dec, nbits))
    {
        val->length = (nbits + 7) / 8;
        if (NULL != (val->value = (ASN1octet_t *)DecMemAlloc(dec, val->length)))
        {
            val->value[0] = (*dec->pos & (0x80 >> dec->bit)) ? c_aBitMask3[nbits & 7] : 0;
            ASN1bitcpy(val->value, val->length * 8 - nbits, dec->pos, dec->bit, nbits);
            PerDecAdvance(dec, nbits);
            return 1;
        }
    }
    return 0;
}
#endif // ENABLE_ALL

/* decode length of a fragment */
int ASN1PERDecFragmentedLength(ASN1decoding_t dec, ASN1uint32_t *nitems)
{
    ASN1PERDecAlignment(dec);
    
    if (ASN1PERDecCheck(dec, 8))
    {
        ASN1uint32_t n = *dec->pos++;
        if (n < 0x80)
        {
            *nitems = n;
        }
        else
        if (n < 0xc0)
        {
            if (ASN1PERDecCheck(dec, 8))
            {
                *nitems = ((n & 0x3f) << 8) | *dec->pos++;
            }
            else
            {
                return 0;
            }
        }
        else
        {
            *nitems = 0x4000 * (n & 0x3f);
        }
        return 1;
    }
    return 0;
}

/* decode a fragment */
int ASN1PERDecFragmented(ASN1decoding_t dec, ASN1uint32_t *nitems, ASN1octet_t **val, ASN1uint32_t itemsize)
{
    ASN1uint32_t n, m, l;
    *nitems = 0;
    *val = 0;
    m = 0;
    do {
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (!n)
                break;
            l = n * itemsize;
            if (ASN1PERDecCheck(dec, l))
            {
                *nitems += n;
                if (NULL != (*val = (ASN1octet_t *)DecMemReAlloc(dec, *val, (m + l + 7) / 8)))
                {
                    ASN1bitcpy(*val, m, dec->pos, dec->bit, l);
                    PerDecAdvance(dec, l);
                    m += l;
                }
                else
                {
                    return 0;
                }
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    } while (n >= 0x4000);
    return 1;
}

/* end of decoding */
int ASN1PERDecFlush(ASN1decoding_t dec)
{
    /* complete broken byte */
    ASN1PERDecAlignment(dec);

    /* get zero-octet if encoding is empty bitstring */
    if (dec->buf == dec->pos)
    {
        if (ASN1PERDecCheck(dec, 8))
        {
            if (*dec->pos == 0)
            {
                dec->pos++;
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }

    /* calculate length */
    dec->len = (ASN1uint32_t) (dec->pos - dec->buf);

    /* set WRN_NOEOD if data left */
    if (dec->len >= dec->size)
    {
        return 1;
    }
    ASN1DecSetError(dec, ASN1_WRN_NOEOD);
    return 1;
}

/* skip up to octet boundary */
void ASN1PERDecAlignment(ASN1decoding_t dec)
{
    if (dec->bit)
    {
        dec->bit = 0;
        dec->pos++;
    }
}

/* decode normally small 32 bit integer */
#ifdef ENABLE_ALL
int ASN1PERDecN32Val(ASN1decoding_t dec, ASN1uint32_t *val)
{
    ASN1uint32_t n;

    /* is normally small really small? */
    if (ASN1PERDecBit(dec, &n))
    {
        if (!n)
        {
            return ASN1PERDecU32Val(dec, 6, val);
        }

        /* large */
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (n <= 4)
            {
                if (n)
                {
                    if (ASN1PERDecCheck(dec, n * 8))
                    {
                        *val = ASN1octetget(dec->pos, n);
                        dec->pos += n;
                        return 1;
                    }
                    return 0;
                }
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_LARGE);
            }
        }
    }
    return 0;
}
#endif // ENABLE_ALL

/* decode normally small 16 bit integer */
int ASN1PERDecN16Val(ASN1decoding_t dec, ASN1uint16_t *val)
{
    ASN1uint32_t n;

    /* is normally small really small? */
    if (ASN1PERDecBit(dec, &n))
    {
        if (!n)
        {
            return ASN1PERDecU16Val(dec, 6, val);
        }

        /* large */
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (n <= 2)
            {
                if (n)
                {
                    if (ASN1PERDecCheck(dec, n * 8))
                    {
                        *val = (ASN1uint16_t) ASN1octetget(dec->pos, n);
                        dec->pos += n;
                        return 1;
                    }
                    return 0;
                }
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_LARGE);
            }
        }
    }
    return 0;
}

/* decode normally small 8 bit integer */
#ifdef ENABLE_ALL
int ASN1PERDecN8Val(ASN1decoding_t dec, ASN1uint8_t *val)
{
    ASN1uint32_t n;

    /* is normally small really small? */
    if (ASN1PERDecBit(dec, &n))
    {
        if (!n)
        {
            return ASN1PERDecU8Val(dec, 6, val);
        }

        /* large */
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (n)
            {
                if (n <= 1)
                {
                    if (ASN1PERDecCheck(dec, n * 8))
                    {
                        *val = (ASN1uint8_t) ASN1octetget(dec->pos, n);
                        dec->pos += n;
                        return 1;
                    }
                    return 0;
                }
                ASN1DecSetError(dec, ASN1_ERR_LARGE);
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            }
        }
    }
    return 0;
}
#endif // ENABLE_ALL

/* skip normally small integer */
int ASN1PERDecSkipNormallySmall(ASN1decoding_t dec)
{
    ASN1uint32_t n;

    /* is normally small really small? */
    if (ASN1PERDecBit(dec, &n))
    {
        if (!n)
        {
            return ASN1PERDecSkipBits(dec, 6);
        }

        /* large */
        return ASN1PERDecSkipFragmented(dec, 8);
    }
    return 0;
}

/* decode extension bits with normally small length */
int ASN1PERDecNormallySmallExtension(ASN1decoding_t dec, ASN1uint32_t *nextensions, ASN1uint32_t nbits, ASN1octet_t *val)
{
    ASN1uint32_t n, m;

    *nextensions = 0;
    memset(val, 0, (nbits + 7) / 8);

    /* is normally small length really small? */
    if (ASN1PERDecBit(dec, &n))
    {
        if (n)
        {
            /* no, get extension bits as fragments */
            m = 0;
            do {
                if (ASN1PERDecFragmentedLength(dec, &n))
                {
                    if (!n)
                        break;
                    if (ASN1PERDecCheck(dec, n))
                    {
                        if (n <= nbits)
                        {
                            ASN1bitcpy(val, m, dec->pos, 0, n);
                            m += n;
                            nbits -= n;
                        }
                        else
                        if (nbits)
                        {
                            ASN1bitcpy(val, m, dec->pos, 0, nbits);
                            *nextensions += ASN1bitcount(dec->pos, nbits, n - nbits);
                            nbits = 0;
                        }
                        else
                        {
                            *nextensions += ASN1bitcount(dec->pos, 0, n);
                        }
                        PerDecAdvance(dec, n);
                    }
                    else
                    {
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            } while (n >= 0x4000);
            return 1;
        }

        /* yes, get length of extension bit string */
        if (ASN1PERDecU32Val(dec, 6, &n))
        {
            n++;

            /* copy extension bits */
            if (ASN1PERDecCheck(dec, n))
            {
                if (n <= nbits)
                {
                    ASN1bitcpy(val, 0, dec->pos, dec->bit, n);
                }
                else
                {
                    ASN1bitcpy(val, 0, dec->pos, dec->bit, nbits);
                    *nextensions = ASN1bitcount(dec->pos, dec->bit + nbits, n - nbits);
                }
                PerDecAdvance(dec, n);
                return 1;
            }
        }
    }
    return 0;
}

/* skip extension bits with normally small length */
int ASN1PERDecSkipNormallySmallExtension(ASN1decoding_t dec, ASN1uint32_t *nextensions)
{
    ASN1uint32_t n;

    *nextensions = 0;

    /* is normally small length really small? */
    if (ASN1PERDecBit(dec, &n))
    {
        if (n)
        {
            /* no, get extension bits as fragments */
            do {
                if (ASN1PERDecFragmentedLength(dec, &n))
                {
                    if (!n)
                        break;
                    if (ASN1PERDecCheck(dec, n))
                    {
                        *nextensions += ASN1bitcount(dec->pos, 0, n);
                        PerDecAdvance(dec, n);
                    }
                    else
                    {
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            } while (n >= 0x4000);
            return 1;
        }

        /* yes, get length of extension bit string */
        if (ASN1PERDecU32Val(dec, 6, &n))
        {
            n++;
            if (ASN1PERDecCheck(dec, n))
            {
                *nextensions = ASN1bitcount(dec->pos, dec->bit, n);
                PerDecAdvance(dec, n);
                return 1;
            }
        }
    }
    return 0;
}

/* decode bit string of optionals of sequence/set */
// lonchanc: decode octet string with length constraint.
int ASN1PERDecExtension(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1octet_t *val)
{
    if (ASN1PERDecCheck(dec, nbits))
    {
        ASN1bitcpy(val, 0, dec->pos, dec->bit, nbits);
        PerDecAdvance(dec, nbits);
        return 1;
    }
    return 0;
}

/* decode bit string */
int ASN1PERDecBits(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1octet_t **val)
{
    if (NULL != (*val = (ASN1octet_t *)DecMemAlloc(dec, (nbits + 7) / 8)))
    {
        if (ASN1PERDecCheck(dec, nbits))
        {
            ASN1bitcpy(*val, 0, dec->pos, dec->bit, nbits);
            PerDecAdvance(dec, nbits);
            return 1;
        }
    }
    return 0;
}

/* decode real value */
int ASN1PERDecDouble(ASN1decoding_t dec, double *val)
{
    ASN1uint32_t head;
    ASN1int32_t exponent;
    ASN1uint32_t baselog2;
    ASN1uint32_t len;
    ASN1uint32_t i;
    ASN1octet_t *p, *q;
    double v;
    char buf[256], *b;

    if (ASN1PERDecFragmentedLength(dec, &len))
    {
        if (len < 0x4000)
        {
            if (len)
            {
                p = q = dec->pos;
                dec->pos += len;
                head = *p++;

                /* binary encoding? */
                if (head & 0x80)
                {
                    /* get base */
                    switch (head & 0x30)
                    {
                    case 0:
                        /* base 2 */
                        baselog2 = 1;
                        break;
                    case 0x10:
                        /* base 8 */
                        baselog2 = 3;
                        break;
                    case 0x20:
                        /* base 16 */
                        baselog2 = 4;
                        break;
                    default:
                        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                        return 0;
                    }

                    /* get exponent */
                    switch (head & 0x03)
                    {
                    case 0:
                        /* 8 bit exponent */
                        exponent = (ASN1int8_t)*p++;
                        break;
                    case 1:
                        /* 16 bit exponent */
                        exponent = (ASN1int16_t)((*p << 8) | p[1]);
                        p += 2;
                        break;
                    case 2:
                        /* 24 bit exponent */
                        exponent = ((*p << 16) | (p[1] << 8) | p[2]);
                        if (exponent & 0x800000)
                            exponent -= 0x1000000;
                        break;
                    default:
                        /* variable length exponent */
                        exponent = (p[1] & 0x80) ? -1 : 0;
                        for (i = 1; i <= *p; i++)
                            exponent = (exponent << 8) | p[i];
                        p += *p + 1;
                        break;
                    }

                    /* calculate remaining length */
                    len -= (ASN1uint32_t) (p - q);

                    /* get mantissa */
                    v = 0.0;
                    for (i = 0; i < len; i++)
                        v = v * 256.0 + *p++;

                    /* scale mantissa */
                    switch (head & 0x0c)
                    {
                    case 0x04:
                        /* scaling factor 1 */
                        v *= 2.0;
                        break;
                    case 0x08:
                        /* scaling factor 2 */
                        v *= 4.0;
                        break;
                    case 0x0c:
                        /* scaling factor 3 */
                        v *= 8.0;
                        break;
                    }

                    /* check sign */
                    if (head & 0x40)
                        v = -v;

                    /* calculate value */
                    *val = ldexp(v, exponent * baselog2);

                /* special real values? */
                }
                else
                if (head & 0x40)
                {
                    switch (head)
                    {
                    case 0x40:
                        /* PLUS-INFINITY */
                        *val = ASN1double_pinf();
                        break;
                    case 0x41:
                        /* MINUS-INFINITY */
                        *val = ASN1double_minf();
                        break;
                    default:
                        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                        return 0;
                    }
                
                /* decimal encoding */
                }
                else
                {
                    if (len <= 256)
                    {
                        CopyMemory(buf, p, len - 1);
                    }
                    else
                    {
                        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                        return 0;
                    }
                    buf[len - 1] = 0;
                    b = strchr(buf, ',');
                    if (b)
                        *b = '.';
                    *val = strtod((char *)buf, &b);
                    if (*b)
                    {
                        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                        return 0;
                    }
                }
            }
            else
            {
                *val = 0.0;
            }
            return 1;
        }
        else
        {
            ASN1DecSetError(dec, ASN1_ERR_LARGE);
        }
    }
    return 0;
}

/* decode external value */
#ifdef ENABLE_EXTERNAL
int ASN1PERDecExternal(ASN1decoding_t dec, ASN1external_t *val)
{
    ASN1uint32_t l, u;

    /* get optional bits */
    if (ASN1PERDecU32Val(dec, 3, &u))
    {
        /* get identification */
        switch (u & 6)
        {
        case 4:
            val->identification.o = ASN1external_identification_syntax_o;
            if (!ASN1PERDecObjectIdentifier(dec, &val->identification.u.syntax))
                return 0;
            break;
        case 2:
            val->identification.o =
                ASN1external_identification_presentation_context_id_o;
            if (!ASN1PERDecFragmentedLength(dec, &l))
                return 0;
            if (!ASN1PERDecU32Val(dec, l * 8,
                &val->identification.u.presentation_context_id))
                return 0;
            break;
        case 6:
            val->identification.o =
                ASN1external_identification_context_negotiation_o;
            if (!ASN1PERDecObjectIdentifier(dec,
                &val->identification.u.context_negotiation.transfer_syntax))
                return 0;
            if (!ASN1PERDecFragmentedLength(dec, &l))
                return 0;
            if (!ASN1PERDecU32Val(dec, l * 8,
                &val->identification.u.context_negotiation.presentation_context_id))
                return 0;
            break;
        default:
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }

        /* get value descriptor */
        val->o[0] = (ASN1octet_t) ((u & 1) << 7);
        if (u & 1)
        {
            if (!ASN1PERDecFragmentedZeroCharString(dec, &val->data_value_descriptor, 8))
                return 0;
        }
        else
        {
            val->data_value_descriptor = NULL;
        }

        /* get value */
        if (ASN1PERDecU32Val(dec, 2, &u))
        {
            switch (u)
            {
            case 0:
                val->data_value.o = ASN1external_data_value_notation_o;
                return ASN1PERDecFragmented(dec,
                            &val->data_value.u.notation.length,
                            (ASN1octet_t **) &val->data_value.u.notation.encoded, 8);
                break;
            case 1:
                val->data_value.o = ASN1external_data_value_encoded_o;
                if (ASN1PERDecFragmented(dec,
                            &val->data_value.u.encoded.length,
                            &val->data_value.u.encoded.value, 8))
                {
                    val->data_value.u.encoded.length *= 8;
                    return 1;
                }
                break;
            case 2:
                val->data_value.o = ASN1external_data_value_encoded_o;
                return ASN1PERDecFragmented(dec,
                            &val->data_value.u.encoded.length,
                            &val->data_value.u.encoded.value, 1);
                break;
            default:
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            }
        }
    }
    return 0;
}
#endif // ENABLE_EXTERNAL

/* decode an embedded pdv value */
#ifdef ENABLE_EMBEDDED_PDV
int ASN1PERDecEmbeddedPdv(ASN1decoding_t dec, ASN1embeddedpdv_t *val)
{
    ASN1uint32_t flag;
    ASN1uint32_t index;
    ASN1uint32_t l;
    ASN1embeddedpdv_identification_t *identification;

    /* get EP-A/EP-B encoding bit */
    if (!ASN1PERDecBit(dec, &flag))
        return 0;

    /* get index value */
    if (!ASN1PERDecN32Val(dec, &index))
        return 0;

    if (flag)
    {
        /* EP-A encoding */

        /* get identification */
        if (!ASN1PERDecU8Val(dec, 3, &val->identification.o))
            return 0;
        switch (val->identification.o)
        {
        case ASN1embeddedpdv_identification_syntaxes_o:
            if (!ASN1PERDecObjectIdentifier(dec,
                &val->identification.u.syntaxes.abstract))
                return 0;
            if (!ASN1PERDecObjectIdentifier(dec,
                &val->identification.u.syntaxes.transfer))
                return 0;
            break;
        case ASN1embeddedpdv_identification_syntax_o:
            if (!ASN1PERDecObjectIdentifier(dec,
                &val->identification.u.syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_presentation_context_id_o:
            if (!ASN1PERDecFragmentedLength(dec, &l))
                return 0;
            if (!ASN1PERDecU32Val(dec, l * 8,
                &val->identification.u.presentation_context_id))
                return 0;
            break;
        case ASN1embeddedpdv_identification_context_negotiation_o:
            if (!ASN1PERDecFragmentedLength(dec, &l))
                return 0;
            if (!ASN1PERDecU32Val(dec, l * 8, &val->
                identification.u.context_negotiation.presentation_context_id))
                return 0;
            if (!ASN1PERDecObjectIdentifier(dec,
                &val->identification.u.context_negotiation.transfer_syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_transfer_syntax_o:
            if (!ASN1PERDecObjectIdentifier(dec,
                &val->identification.u.transfer_syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_fixed_o:
            break;
        default:
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }

        /* save identification */
        if (!ASN1DecAddEmbeddedPdvIdentification(((ASN1INTERNdecoding_t) dec)->parent,
                                                 &val->identification))
            return 0;
    }
    else
    {
        /* EP-B encoding */

        /* get identification */
        identification = ASN1DecGetEmbeddedPdvIdentification(((ASN1INTERNdecoding_t) dec)->parent, index);
        if (!identification)
            return 0;
        val->identification.o = identification->o;
        switch (identification->o)
        {
        case ASN1embeddedpdv_identification_syntaxes_o:
            if (!ASN1DecDupObjectIdentifier(dec, 
                &val->identification.u.syntaxes.abstract,
                &identification->u.syntaxes.abstract))
                return 0;
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.syntaxes.transfer,
                &identification->u.syntaxes.transfer))
                return 0;
            break;
        case ASN1embeddedpdv_identification_syntax_o:
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.syntax,
                &identification->u.syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_presentation_context_id_o:
            val->identification.u.presentation_context_id =
                identification->u.presentation_context_id;
            break;
        case ASN1embeddedpdv_identification_context_negotiation_o:
            val->identification.u.context_negotiation.presentation_context_id =
                identification->u.context_negotiation.presentation_context_id;
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.context_negotiation.transfer_syntax,
                &identification->u.context_negotiation.transfer_syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_transfer_syntax_o:
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.transfer_syntax,
                &identification->u.transfer_syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_fixed_o:
            break;
        }
    }

    /* get value */
    ASN1PERDecAlignment(dec);
    val->data_value.o = ASN1embeddedpdv_data_value_encoded_o;
    return ASN1PERDecFragmented(dec,
                    &val->data_value.u.encoded.length,
                    &val->data_value.u.encoded.value, 1);
}
#endif // ENABLE_EMBEDDED_PDV

/* decode an optimized embedded pdv value */
#ifdef ENABLE_EMBEDDED_PDV
int ASN1PERDecEmbeddedPdvOpt(ASN1decoding_t dec, ASN1embeddedpdv_t *val, ASN1objectidentifier_t *abstract, ASN1objectidentifier_t *transfer)
{
    /* set identification */
    if (abstract && transfer)
    {
        val->identification.o = ASN1embeddedpdv_identification_syntaxes_o;
        if (!ASN1DecDupObjectIdentifier(dec, 
            &val->identification.u.syntaxes.abstract, abstract))
            return 0;
        if (!ASN1DecDupObjectIdentifier(dec,
            &val->identification.u.syntaxes.transfer, transfer))
            return 0;
    }
    else
    {
        val->identification.o = ASN1embeddedpdv_identification_fixed_o;
    }

    /* get value */
    val->data_value.o = ASN1embeddedpdv_data_value_encoded_o;
    return ASN1PERDecFragmented(dec,
                    &val->data_value.u.encoded.length,
                    &val->data_value.u.encoded.value, 1);
}
#endif // ENABLE_EMBEDDED_PDV

/* decode character string */
#ifdef ENABLE_GENERALIZED_CHAR_STR
int ASN1PERDecCharacterString(ASN1decoding_t dec, ASN1characterstring_t *val)
{
    ASN1uint32_t flag;
    ASN1uint32_t index;
    ASN1uint32_t l;
    ASN1characterstring_identification_t *identification;

    /* get CS-A/CS-B encoding bit */
    if (!ASN1PERDecBit(dec, &flag))
        return 0;

    /* get index value */
    if (!ASN1PERDecN32Val(dec, &index))
        return 0;

    if (flag)
    {
        /* CS-A encoding */

        /* get identification */
        if (!ASN1PERDecU8Val(dec, 3, &val->identification.o))
            return 0;
        switch (val->identification.o)
        {
        case ASN1characterstring_identification_syntaxes_o:
            if (!ASN1PERDecObjectIdentifier(dec,
                &val->identification.u.syntaxes.abstract))
                return 0;
            if (!ASN1PERDecObjectIdentifier(dec,
                &val->identification.u.syntaxes.transfer))
                return 0;
            break;
        case ASN1characterstring_identification_syntax_o:
            if (!ASN1PERDecObjectIdentifier(dec,
                &val->identification.u.syntax))
                return 0;
            break;
        case ASN1characterstring_identification_presentation_context_id_o:
            if (!ASN1PERDecFragmentedLength(dec, &l))
                return 0;
            if (!ASN1PERDecU32Val(dec, l * 8,
                &val->identification.u.presentation_context_id))
                return 0;
            break;
        case ASN1characterstring_identification_context_negotiation_o:
            if (!ASN1PERDecFragmentedLength(dec, &l))
                return 0;
            if (!ASN1PERDecU32Val(dec, l * 8, &val->
                identification.u.context_negotiation.presentation_context_id))
                return 0;
            if (!ASN1PERDecObjectIdentifier(dec,
                &val->identification.u.context_negotiation.transfer_syntax))
                return 0;
            break;
        case ASN1characterstring_identification_transfer_syntax_o:
            if (!ASN1PERDecObjectIdentifier(dec,
                &val->identification.u.transfer_syntax))
                return 0;
            break;
        case ASN1characterstring_identification_fixed_o:
            break;
        default:
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }

        /* save identification */
        if (!ASN1DecAddCharacterStringIdentification((ASN1INTERNdecoding_t) dec, &val->identification))
            return 0;

    }
    else
    {
        /* CS-B encoding */

        /* get identification */
        identification = ASN1DecGetCharacterStringIdentification((ASN1INTERNdecoding_t) dec, index);
        if (!identification)
            return 0;
        val->identification.o = identification->o;
        switch (identification->o)
        {
        case ASN1characterstring_identification_syntaxes_o:
            if (!ASN1DecDupObjectIdentifier(dec, 
                &val->identification.u.syntaxes.abstract,
                &identification->u.syntaxes.abstract))
                return 0;
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.syntaxes.transfer,
                &identification->u.syntaxes.transfer))
                return 0;
            break;
        case ASN1characterstring_identification_syntax_o:
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.syntax,
                &identification->u.syntax))
                return 0;
            break;
        case ASN1characterstring_identification_presentation_context_id_o:
            val->identification.u.presentation_context_id =
                identification->u.presentation_context_id;
            break;
        case ASN1characterstring_identification_context_negotiation_o:
            val->identification.u.context_negotiation.presentation_context_id =
                identification->u.context_negotiation.presentation_context_id;
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.context_negotiation.transfer_syntax,
                &identification->u.context_negotiation.transfer_syntax))
                return 0;
            break;
        case ASN1characterstring_identification_transfer_syntax_o:
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.transfer_syntax,
                &identification->u.transfer_syntax))
                return 0;
            break;
        case ASN1characterstring_identification_fixed_o:
            break;
        }
    }

    /* get value */
    ASN1PERDecAlignment(dec);
    val->data_value.o = ASN1characterstring_data_value_encoded_o;
    return ASN1PERDecFragmented(dec,
                    &val->data_value.u.encoded.length,
                    &val->data_value.u.encoded.value, 8);
}
#endif // ENABLE_GENERALIZED_CHAR_STR

/* decode an optimized character string value */
#ifdef ENABLE_GENERALIZED_CHAR_STR
int ASN1PERDecCharacterStringOpt(ASN1decoding_t dec, ASN1characterstring_t *val, ASN1objectidentifier_t *abstract, ASN1objectidentifier_t *transfer)
{
    /* set identification */
    if (abstract && transfer)
    {
        val->identification.o = ASN1characterstring_identification_syntaxes_o;
        if (!ASN1DecDupObjectIdentifier(dec, 
            &val->identification.u.syntaxes.abstract, abstract))
            return 0;
        if (!ASN1DecDupObjectIdentifier(dec,
            &val->identification.u.syntaxes.transfer, transfer))
            return 0;
    }
    else
    {
        val->identification.o = ASN1characterstring_identification_fixed_o;
    }

    /* get value */
    val->data_value.o = ASN1characterstring_data_value_encoded_o;
    return ASN1PERDecFragmented(dec,
                    &val->data_value.u.encoded.length,
                    &val->data_value.u.encoded.value, 8);
}
#endif // ENABLE_GENERALIZED_CHAR_STR

/* decode a multibyte string */
#ifdef ENABLE_ALL
int ASN1PERDecMultibyteString(ASN1decoding_t dec, ASN1char_t **val)
{
    return ASN1PERDecFragmentedZeroCharString(dec, val, 8);
}
#endif // ENABLE_ALL

/* decode a string */
int ASN1PERDecCharStringNoAlloc(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits)
{
    ASN1char_t *p = val;

    if (ASN1PERDecCheck(dec, nchars * nbits))
    {
        if (nbits == 8)
        {
            ASN1bitcpy((ASN1octet_t *)p, 0, dec->pos, dec->bit, nchars * 8);
            PerDecAdvance(dec, nchars * 8);
            return 1;
        }
        while (nchars--)
        {
            *p++ = (ASN1char_t) ASN1bitgetu(dec->pos, dec->bit, nbits);
            PerDecAdvance(dec, nbits);
        }
        return 1;
    }
    return 0;
}

#ifdef ENABLE_ALL
int ASN1PERDecCharString(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t **val, ASN1uint32_t nbits)
{
    if (ASN1PERDecCheck(dec, nchars * nbits))
    {
        *val = (ASN1char_t *)DecMemAlloc(dec, nchars);
        return ((*val) ? ASN1PERDecCharStringNoAlloc(dec, nchars, *val, nbits) : 0);
    }
    return 0;
}
#endif // ENABLE_ALL

/* decode a 16 bit string */
int ASN1PERDecChar16String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char16_t **val, ASN1uint32_t nbits)
{
    ASN1char16_t *p;

    if (ASN1PERDecCheck(dec, nchars * nbits))
    {
        p = *val = (ASN1char16_t *)DecMemAlloc(dec, nchars * sizeof(ASN1char16_t));
        if (p)
        {
            if (!dec->bit && nbits == 16)
            {
                while (nchars--)
                {
                    *p++ = (dec->pos[0] << 8) | dec->pos[1];
                    dec->pos += 2;
                }
                return 1;
            }
            while (nchars--)
            {
                *p++ = (ASN1char16_t) ASN1bitgetu(dec->pos, dec->bit, nbits);
                PerDecAdvance(dec, nbits);
            }
            return 1;
        }
    }
    return 0;
}

/* decode a 32 bit string */
#ifdef ENABLE_ALL
int ASN1PERDecChar32String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char32_t **val, ASN1uint32_t nbits)
{
    ASN1char32_t *p;

    if (ASN1PERDecCheck(dec, nchars * nbits))
    {
        p = *val = (ASN1char32_t *)DecMemAlloc(dec, nchars * sizeof(ASN1char32_t));
        if (p)
        {
            if (!dec->bit && nbits == 32)
            {
                while (nchars--)
                {
                    *p++ = (dec->pos[0] << 24) | (dec->pos[1] << 16) |
                        (dec->pos[2] << 8) | dec->pos[3];
                    dec->pos += 4;
                }
                return 1;
            }
            while (nchars--)
            {
                *p++ = ASN1bitgetu(dec->pos, dec->bit, nbits);
                PerDecAdvance(dec, nbits);
            }
            return 1;
        }
    }
    return 0;
}
#endif // ENABLE_ALL

/* decode a zero-terminated string */
int ASN1PERDecZeroCharStringNoAlloc(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits)
{
    ASN1char_t *p = val;

    if (ASN1PERDecCheck(dec, nchars * nbits))
    {
        if (nbits == 8)
        {
            ASN1bitcpy((ASN1octet_t *)p, 0, dec->pos, dec->bit, nchars * 8);
            PerDecAdvance(dec, nchars * 8);
            p[nchars] = 0;
            return 1;
        }
        while (nchars--)
        {
            *p++ = (ASN1char_t) ASN1bitgetu(dec->pos, dec->bit, nbits);
            PerDecAdvance(dec, nbits);
        }
        *p = 0;
        return 1;
    }
    return 0;
}

#ifdef ENABLE_ALL
int ASN1PERDecZeroCharString(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t **val, ASN1uint32_t nbits)
{
    if (ASN1PERDecCheck(dec, nchars * nbits))
    {
        *val = (ASN1char_t *)DecMemAlloc(dec, nchars + 1);
        return ((*val) ? ASN1PERDecZeroCharStringNoAlloc(dec, nchars, *val, nbits) : 0);
    }
    return 0;
}
#endif // ENABLE_ALL

/* decode a zero-terminated 16 bit string */
#ifdef ENABLE_ALL
int ASN1PERDecZeroChar16String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char16_t **val, ASN1uint32_t nbits)
{
    ASN1char16_t *p;

    if (ASN1PERDecCheck(dec, nchars * nbits))
    {
        p = *val = (ASN1char16_t *)DecMemAlloc(dec, (nchars + 1) * sizeof(ASN1char16_t));
        if (p)
        {
            if (!dec->bit && nbits == 16)
            {
                while (nchars--)
                {
                    *p++ = (dec->pos[0] << 8) | dec->pos[1];
                    dec->pos += 2;
                }
                *p = 0;
                return 1;
            }
            while (nchars--)
            {
                *p++ = (ASN1char16_t) ASN1bitgetu(dec->pos, dec->bit, nbits);
                PerDecAdvance(dec, nbits);
            }
            *p = 0;
            return 1;
        }
    }
    return 0;
}
#endif // ENABLE_ALL

/* decode a zero-terminated 32 bit string */
#ifdef ENABLE_ALL
int ASN1PERDecZeroChar32String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char32_t **val, ASN1uint32_t nbits)
{
    ASN1char32_t *p;

    if (ASN1PERDecCheck(dec, nchars * nbits))
    {
        p = *val = (ASN1char32_t *)DecMemAlloc(dec, (nchars + 1) * sizeof(ASN1char32_t));
        if (p)
        {
            if (!dec->bit && nbits == 32)
            {
                while (nchars--)
                {
                    *p++ = (dec->pos[0] << 24) | (dec->pos[1] << 16) |
                        (dec->pos[2] << 8) | dec->pos[3];
                    dec->pos += 4;
                }
                *p = 0;
                return 1;
            }
            while (nchars--)
            {
                *p++ = ASN1bitgetu(dec->pos, dec->bit, nbits);
                PerDecAdvance(dec, nbits);
            }
            *p = 0;
            return 1;
        }
    }
    return 0;
}
#endif // ENABLE_ALL

/* decode a table string */
#ifdef ENABLE_ALL
int ASN1PERDecTableCharStringNoAlloc(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    ASN1char_t *p = val;
    ASN1stringtableentry_t chr, *entry;

    if (ASN1PERDecCheck(dec, nchars * nbits))
    {
        chr.lower = chr.upper = 0;
        while (nchars--)
        {
            chr.value = ASN1bitgetu(dec->pos, dec->bit, nbits);
            PerDecAdvance(dec, nbits);
            entry = (ASN1stringtableentry_t *)ms_bSearch(&chr, table->values,
                table->length, sizeof(ASN1stringtableentry_t),
                ASN1CmpStringTableEntriesByIndex);
            if (entry)
            {
                *p++ = (ASN1char_t) (entry->lower + (chr.value - entry->value));
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }
        }
        return 1;
    }
    return 0;
}
#endif // ENABLE_ALL

#ifdef ENABLE_ALL
int ASN1PERDecTableCharString(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    ASN1stringtableentry_t chr, *entry;

    if (ASN1PERDecCheck(dec, nchars * nbits))
    {
        *val = (ASN1char_t *)DecMemAlloc(dec, nchars);
        return ((*val) ? ASN1PERDecTableCharStringNoAlloc(dec, nchars, *val, nbits, table) : 0);
    }
    return 0;
}
#endif // ENABLE_ALL

/* decode a 16 bit table string */
int ASN1PERDecTableChar16String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char16_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    ASN1char16_t *p;
    ASN1stringtableentry_t chr, *entry;

    if (ASN1PERDecCheck(dec, nchars * nbits))
    {
        *val = p = (ASN1char16_t *)DecMemAlloc(dec, nchars * sizeof(ASN1char16_t));
        if (p)
        {
            chr.lower = chr.upper = 0;
            while (nchars--)
            {
                chr.value = ASN1bitgetu(dec->pos, dec->bit, nbits);
                PerDecAdvance(dec, nbits);
                entry = (ASN1stringtableentry_t *)ms_bSearch(&chr, table->values,
                    table->length, sizeof(ASN1stringtableentry_t),
                    ASN1CmpStringTableEntriesByIndex);
                if (entry)
                {
                    *p++ = (ASN1char16_t) (entry->lower + (chr.value - entry->value));
                }
                else
                {
                    ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                    return 0;
                }
            }
            return 1;
        }
    }
    return 0;
}

/* decode a 32 bit table string */
#ifdef ENABLE_ALL
int ASN1PERDecTableChar32String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char32_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    ASN1char32_t *p;
    ASN1stringtableentry_t chr, *entry;

    if (ASN1PERDecCheck(dec, nchars * nbits))
    {
        *val = p = (ASN1char32_t *)DecMemAlloc(dec, nchars * sizeof(ASN1char32_t));
        if (p)
        {
            chr.lower = chr.upper = 0;
            while (nchars--)
            {
                chr.value = ASN1bitgetu(dec->pos, dec->bit, nbits);
                PerDecAdvance(dec, nbits);
                entry = (ASN1stringtableentry_t *)ms_bSearch(&chr, table->values,
                    table->length, sizeof(ASN1stringtableentry_t),
                    ASN1CmpStringTableEntriesByIndex);
                if (entry)
                {
                    *p++ = entry->lower + (chr.value - entry->value);
                }
                else
                {
                    ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                    return 0;
                }
            }
            return 1;
        }
    }
    return 0;
}
#endif // ENABLE_ALL

/* decode a zero-terminated table string */
int ASN1PERDecZeroTableCharStringNoAlloc(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    ASN1char_t *p = val;
    ASN1stringtableentry_t chr, *entry;

    chr.lower = chr.upper = 0;
    while (nchars--)
    {
        if (ASN1PERDecU32Val(dec, nbits, &chr.value))
        {
            entry = (ASN1stringtableentry_t *)ms_bSearch(&chr, table->values,
                table->length, sizeof(ASN1stringtableentry_t),
                ASN1CmpStringTableEntriesByIndex);
            if (entry)
            {
                *p++ = (ASN1char_t) (entry->lower + (chr.value - entry->value));
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    *p = 0;
    return 1;
}

/* decode a zero-terminated table string */
#ifdef ENABLE_ALL
int ASN1PERDecZeroTableCharString(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    ASN1char_t *p;
    ASN1stringtableentry_t chr, *entry;

    *val = (ASN1char_t *)DecMemAlloc(dec, nchars + 1);
    return ((*val) ? ASN1PERDecZeroTableCharStringNoAlloc(dec, nchars, *val, nbits, table) : 0);
}
#endif // ENABLE_ALL

/* decode a zero-terminated 16 bit table string */
#ifdef ENABLE_ALL
int ASN1PERDecZeroTableChar16String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char16_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    ASN1char16_t *p;
    ASN1stringtableentry_t chr, *entry;

    *val = p = (ASN1char16_t *)DecMemAlloc(dec, (nchars + 1) * sizeof(ASN1char16_t));
    if (p)
    {
        chr.lower = chr.upper = 0;
        while (nchars--)
        {
            if (ASN1PERDecU32Val(dec, nbits, &chr.value))
            {
                entry = (ASN1stringtableentry_t *)ms_bSearch(&chr, table->values,
                    table->length, sizeof(ASN1stringtableentry_t),
                    ASN1CmpStringTableEntriesByIndex);
                if (entry)
                {
                    *p++ = (ASN1char16_t) (entry->lower + (chr.value - entry->value));
                }
                else
                {
                    ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                    return 0;
                }
            }
            else
            {
                return 0;
            }
        }
        *p = 0;
        return 1;
    }
    return 0;
}
#endif // ENABLE_ALL

/* decode a zero-terminated 32 bit table string */
#ifdef ENABLE_ALL
int ASN1PERDecZeroTableChar32String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char32_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    ASN1char32_t *p;
    ASN1stringtableentry_t chr, *entry;

    *val = p = (ASN1char32_t *)DecMemAlloc(dec, (nchars + 1) * sizeof(ASN1char32_t));
    if (p)
    {
        chr.lower = chr.upper = 0;
        while (nchars--)
        {
            if (ASN1PERDecU32Val(dec, nbits, &chr.value))
            {
                entry = (ASN1stringtableentry_t *)ms_bSearch(&chr, table->values,
                    table->length, sizeof(ASN1stringtableentry_t),
                    ASN1CmpStringTableEntriesByIndex);
                if (entry)
                {
                    *p++ = entry->lower + (chr.value - entry->value);
                }
                else
                {
                    ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                    return 0;
                }
            }
            else
            {
                return 0;
            }
        }
        *p = 0;
        return 1;
    }
    return 0;
}
#endif // ENABLE_ALL

/* decode an object identifier */
int ASN1PERDecObjectIdentifier(ASN1decoding_t dec, ASN1objectidentifier_t *val)
{
    ASN1uint32_t len, i, v;
    ASN1octet_t *data, *p;
    ASN1uint32_t nelem;
    ASN1objectidentifier_t q;

    if (ASN1PERDecFragmented(dec, &len, &data, 8))
    {
        int rc = 0;
        nelem = 1;
        for (i = 0, p = data; i < len; i++, p++)
        {
            if (!(*p & 0x80))
                nelem++;
        }
        *val = q = DecAllocObjectIdentifier(dec, nelem);
        if (q)
        {
            v = 0;
            for (i = 0, p = data; i < len; i++, p++)
            {
                v = (v << 7) | (*p & 0x7f);
                if (!(*p & 0x80))
                {
                    if (q == *val)
                    { // first id
                        q->value = v / 40;
                        if (q->value > 2)
                            q->value = 2;
                        q->next->value = v - 40 * q->value;
                        q = q->next->next;
                    }
                    else
                    {
                        q->value = v;
                        q = q->next;
                    }
                    v = 0;
                }
            }
            rc = 1;
        }
        DecMemFree(dec, data);
        return rc;
    }
    return 0;
}

/* decode an object identifier */
int ASN1PERDecObjectIdentifier2(ASN1decoding_t dec, ASN1objectidentifier2_t *val)
{
    ASN1uint32_t len, i, v;
    ASN1octet_t *data, *p;
    ASN1uint32_t nelem;
    ASN1objectidentifier_t q;

    int rc = 0;
    if (ASN1PERDecFragmented(dec, &len, &data, 8))
    {
        if (len <= 16) // lonchanc: hard-coded value 16 to be consistent with ASN1objectidentifier2_t
        {
            val->count = 0;
            v = 0;
            for (i = 0, p = data; i < len; i++, p++)
            {
                v = (v << 7) | (*p & 0x7f);
                if (!(*p & 0x80))
                {
                    if (! val->count)
                    { // first id
                        val->value[0] = v / 40;
                        if (val->value[0] > 2)
                            val->value[0] = 2;
                        val->value[1] = v - 40 * val->value[0];
                        val->count = 2;
                    }
                    else
                    {
                        val->value[val->count++] = v;
                    }
                    v = 0;
                }
            }

            // success
            rc = 1;
        }
        else
        {
            ASN1DecSetError(dec, ASN1_ERR_LARGE);
        }

        DecMemFree(dec, data);
    }
    return rc;
}

/* decode a fragmented signed intx value */
#ifdef ENABLE_ALL
int ASN1PERDecFragmentedIntx(ASN1decoding_t dec, ASN1intx_t *val)
{
    return ASN1PERDecFragmented(dec, &val->length, &val->value, 8);
}
#endif // ENABLE_ALL

/* decode a fragmented unsigned intx value */
#ifdef ENABLE_ALL
int ASN1PERDecFragmentedUIntx(ASN1decoding_t dec, ASN1intx_t *val)
{
    if (ASN1PERDecFragmented(dec, &val->length, &val->value, 8))
    {
        if (val->length && val->value[0] > 0x7f)
        {
            ASN1octet_t *p;
            if (NULL != (p = (ASN1octet_t *)DecMemAlloc(dec, val->length + 1)))
            {
                *p = 0;
                CopyMemory(p + 1, val->value, val->length);
                DecMemFree(dec, val->value);
                val->value = p;
                val->length++;
                return 1;
            }
            return 0;
        }
        return 1;
    }
    return 0;
}
#endif // ENABLE_ALL

/* decode fragmented extension bits */
#ifdef ENABLE_ALL
int ASN1PERDecFragmentedExtension(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1octet_t *val)
{
    ASN1uint32_t m, n;

    m = 0;
    do {
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (m + n <= nbits)
            {
                if (ASN1PERDecCheck(dec, n))
                {
                    ASN1bitcpy(val, m, dec->pos, dec->bit, n);
                    PerDecAdvance(dec, n);
                    m += n;
                }
                else
                {
                    return 0;
                }
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }
        }
        else
        {
            return 0;
        }
    } while (n >= 0x4000);
    return 1;
}
#endif // ENABLE_ALL

/* decode a fragmented string */
#ifdef ENABLE_ALL
int ASN1PERDecFragmentedCharString(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char_t **val, ASN1uint32_t nbits)
{
    ASN1uint32_t m, n, i;
    ASN1char_t *p;

    *val = 0;
    m = 0;
    do {
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (!n)
                break;
            if (ASN1PERDecCheck(dec, n * nbits))
            {
                if (NULL != (*val = (ASN1char_t *)DecMemReAlloc(dec, *val, m + n)))
                {
                    p = *val + m;
                    m += n;
                    if (nbits == 8)
                    {
                        ASN1bitcpy((ASN1octet_t *)p, 0, dec->pos, dec->bit, n * 8);
                        PerDecAdvance(dec, n * 8);
                    }
                    else
                    {
                        for (i = n; i; i--)
                        {
                            *p++ = (ASN1char_t) ASN1bitgetu(dec->pos, dec->bit, nbits);
                            PerDecAdvance(dec, nbits);
                        }
                    }
                }
                else
                {
                    return 0;
                }
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    } while (n >= 0x4000);
    *nchars = m;
    return 1;
}
#endif // ENABLE_ALL

/* decode a fragmented 16 bit string */
#ifdef ENABLE_ALL
int ASN1PERDecFragmentedChar16String(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char16_t **val, ASN1uint32_t nbits)
{
    ASN1uint32_t m, n, i;
    ASN1char16_t *p;

    *val = 0;
    m = 0;
    do {
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (!n)
                break;
            if (ASN1PERDecCheck(dec, n * nbits))
            {
                if (NULL != (*val = (ASN1char16_t *)DecMemReAlloc(dec, *val, (m + n) * sizeof(ASN1char16_t))))
                {
                    p = *val + m;
                    m += n;
                    if (!dec->bit && nbits == 16)
                    {
                        for (i = n; i; i--)
                        {
                            *p++ = (dec->pos[0] << 8) | dec->pos[1];
                            dec->pos += 2;
                        }
                    }
                    else
                    {
                        for (i = n; i; i--)
                        {
                            *p++ = (ASN1char16_t) ASN1bitgetu(dec->pos, dec->bit, nbits);
                            PerDecAdvance(dec, nbits);
                        }
                    }
                }
                else
                {
                    return 0;
                }
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    } while (n >= 0x4000);
    *nchars = m;
    return 1;
}
#endif // ENABLE_ALL

/* decode a fragmented 32 bit string */
#ifdef ENABLE_ALL
int ASN1PERDecFragmentedChar32String(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char32_t **val, ASN1uint32_t nbits)
{
    ASN1uint32_t m, n, i;
    ASN1char32_t *p;

    *val = 0;
    m = 0;
    do {
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (!n)
                break;
            if (ASN1PERDecCheck(dec, n * nbits))
            {
                if (NULL != (*val = (ASN1char32_t *)DecMemReAlloc(dec, *val, (m + n) * sizeof(ASN1char32_t))))
                {
                    p = *val + m;
                    m += n;
                    if (!dec->bit && nbits == 32)
                    {
                        for (i = n; i; i--)
                        {
                            *p++ = (dec->pos[0] << 24) | (dec->pos[1] << 16) |
                                (dec->pos[2] << 8) | dec->pos[3];
                            dec->pos += 4;
                        }
                    }
                    else
                    {
                        for (i = n; i; i--)
                        {
                            *p++ = ASN1bitgetu(dec->pos, dec->bit, nbits);
                            PerDecAdvance(dec, nbits);
                        }
                    }
                }
                else
                {
                    return 0;
                }
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    } while (n >= 0x4000);
    *nchars = m;
    return 1;
}
#endif // ENABLE_ALL

/* decode a fragmented zero-terminated string */
int ASN1PERDecFragmentedZeroCharString(ASN1decoding_t dec, ASN1char_t **val, ASN1uint32_t nbits)
{
    ASN1uint32_t m, n, i;
    ASN1char_t *p;

    *val = 0;
    m = 0;
    do {
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (!n)
                break;
            if (ASN1PERDecCheck(dec, n * nbits))
            {
                if (NULL != (*val = (ASN1char_t *)DecMemReAlloc(dec, *val, m + n + 1)))
                {
                    p = *val + m;
                    m += n;
                    if (nbits == 8)
                    {
                        ASN1bitcpy((ASN1octet_t *)p, 0, dec->pos, dec->bit, n * 8);
                        PerDecAdvance(dec, n * 8);
                    }
                    else
                    {
                        for (i = n; i; i--)
                        {
                            *p++ = (ASN1char_t) ASN1bitgetu(dec->pos, dec->bit, nbits);
                            PerDecAdvance(dec, nbits);
                        }
                    }
                }
                else
                {
                    return 0;
                }
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    } while (n >= 0x4000);

    if (!*val)
        *val = (ASN1char_t *)DecMemAlloc(dec, 1);
    if (*val)
        (*val)[m] = 0;
    return 1;
}


/* decode a fragmented zero-terminated 16 bit string */
#ifdef ENABLE_ALL
int ASN1PERDecFragmentedZeroChar16String(ASN1decoding_t dec, ASN1char16_t **val, ASN1uint32_t nbits)
{
    ASN1uint32_t m, n, i;
    ASN1char16_t *p;

    *val = 0;
    m = 0;
    do {
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (!n)
                break;
            if (ASN1PERDecCheck(dec, n * nbits))
            {
                if (NULL != (*val = (ASN1char16_t *)DecMemReAlloc(dec, *val, (m + n + 1) * sizeof(ASN1char16_t))))
                {
                    p = *val + m;
                    m += n;
                    if (!dec->bit && nbits == 16)
                    {
                        for (i = n; i; i--)
                        {
                            *p++ = (dec->pos[0] << 8) | dec->pos[1];
                            dec->pos += 2;
                        }
                    }
                    else
                    {
                        for (i = n; i; i--)
                        {
                            *p++ = (ASN1char16_t) ASN1bitgetu(dec->pos, dec->bit, nbits);
                            PerDecAdvance(dec, nbits);
                        }
                    }
                }
                else
                {
                    return 0;
                }
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    } while (n >= 0x4000);

    if (!*val)
        *val = (ASN1char16_t *)DecMemAlloc(dec, sizeof(ASN1char16_t));
    if (*val)
        (*val)[m] = 0;
    return 1;
}
#endif // ENABLE_ALL

/* decode a fragmented zero-terminated 32 bit string */
#ifdef ENABLE_ALL
int ASN1PERDecFragmentedZeroChar32String(ASN1decoding_t dec, ASN1char32_t **val, ASN1uint32_t nbits)
{
    ASN1uint32_t m, n, i;
    ASN1char32_t *p;

    *val = 0;
    m = 0;
    do {
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (!n)
                break;
            if (ASN1PERDecCheck(dec, n * nbits))
            {
                if (NULL != (*val = (ASN1char32_t *)DecMemReAlloc(dec, *val, (m + n + 1) * sizeof(ASN1char32_t))))
                {
                    p = *val + m;
                    m += n;
                    if (!dec->bit && nbits == 32)
                    {
                        for (i = n; i; i--)
                        {
                            *p++ = (dec->pos[0] << 24) | (dec->pos[1] << 16) |
                                   (dec->pos[2] << 8) | dec->pos[3];
                            dec->pos += 4;
                        }
                    }
                    else
                    {
                        for (i = n; i; i--)
                        {
                            *p++ = ASN1bitgetu(dec->pos, dec->bit, nbits);
                            PerDecAdvance(dec, nbits);
                        }
                    }
                }
                else
                {
                    return 0;
                }
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    } while (n >= 0x4000);

    if (!*val)
        *val = (ASN1char32_t *)DecMemAlloc(dec, sizeof(ASN1char32_t));
    if (*val)
        (*val)[m] = 0;
    return 1;
}
#endif // ENABLE_ALL

/* decode a fragmented table string */
#ifdef ENABLE_ALL
int ASN1PERDecFragmentedTableCharString(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    ASN1uint32_t m, n, i;
    ASN1stringtableentry_t chr, *entry;
    ASN1char_t *p;

    *val = 0;
    m = 0;
    chr.lower = chr.upper = 0;
    do {
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (!n)
                break;
            if (ASN1PERDecCheck(dec, n * nbits))
            {
                if (NULL != (*val = (ASN1char_t *)DecMemReAlloc(dec, *val, m + n)))
                {
                    p = *val + m;
                    m += n;
                    for (i = n; i; i--)
                    {
                        chr.value = ASN1bitgetu(dec->pos, dec->bit, nbits);
                        PerDecAdvance(dec, nbits);
                        entry = (ASN1stringtableentry_t *)ms_bSearch(&chr, table->values,
                            table->length, sizeof(ASN1stringtableentry_t),
                            ASN1CmpStringTableEntriesByIndex);
                        if (entry)
                        {
                            *p++ = (ASN1char_t) (entry->lower + (chr.value - entry->value));
                        }
                        else
                        {
                            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                            return 0;
                        }
                    }
                }
                else
                {
                    return 0;
                }
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    } while (n >= 0x4000);
    *nchars = m;
    return 1;
}
#endif // ENABLE_ALL

/* decode a fragmented 16 bit table string */
#ifdef ENABLE_ALL
int ASN1PERDecFragmentedTableChar16String(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char16_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    ASN1uint32_t m, n, i;
    ASN1stringtableentry_t chr, *entry;
    ASN1char16_t *p;

    *val = 0;
    m = 0;
    chr.lower = chr.upper = 0;
    do {
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (!n)
                break;
            if (ASN1PERDecCheck(dec, n * nbits))
            {
                if (NULL != (*val = (ASN1char16_t *)DecMemReAlloc(dec, *val, (m + n) * sizeof(ASN1char16_t))))
                {
                    p = *val + m;
                    m += n;
                    for (i = n; i; i--)
                    {
                        chr.value = ASN1bitgetu(dec->pos, dec->bit, nbits);
                        PerDecAdvance(dec, nbits);
                        entry = (ASN1stringtableentry_t *)ms_bSearch(&chr, table->values,
                            table->length, sizeof(ASN1stringtableentry_t),
                            ASN1CmpStringTableEntriesByIndex);
                        if (entry)
                        {
                            *p++ = (ASN1char16_t) (entry->lower + (chr.value - entry->value));
                        }
                        else
                        {
                            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                            return 0;
                        }
                    }
                }
                else
                {
                    return 0;
                }
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    } while (n >= 0x4000);
    *nchars = m;
    return 1;
}
#endif // ENABLE_ALL

/* decode a fragmented 32 bit table string */
#ifdef ENABLE_ALL
int ASN1PERDecFragmentedTableChar32String(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char32_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    ASN1uint32_t m, n, i;
    ASN1stringtableentry_t chr, *entry;
    ASN1char32_t *p;

    *val = 0;
    m = 0;
    chr.lower = chr.upper = 0;
    do {
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (!n)
                break;
            if (ASN1PERDecCheck(dec, n * nbits))
            {
                if (NULL != (*val = (ASN1char32_t *)DecMemReAlloc(dec, *val, (m + n) * sizeof(ASN1char32_t))))
                {
                    p = *val + m;
                    m += n;
                    for (i = n; i; i--)
                    {
                        chr.value = ASN1bitgetu(dec->pos, dec->bit, nbits);
                        PerDecAdvance(dec, nbits);
                        entry = (ASN1stringtableentry_t *)ms_bSearch(&chr, table->values,
                            table->length, sizeof(ASN1stringtableentry_t),
                            ASN1CmpStringTableEntrie